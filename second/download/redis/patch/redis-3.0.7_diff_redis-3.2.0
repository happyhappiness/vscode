diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/00-RELEASENOTES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/00-RELEASENOTES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/00-RELEASENOTES	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/00-RELEASENOTES	2016-05-06 15:11:36.000000000 +0800
@@ -1,791 +1,1009 @@
-Redis 3.0 release notes
+Redis 3.2 release notes
 =======================
 
 --------------------------------------------------------------------------------
 Upgrade urgency levels:
 
 LOW:      No need to upgrade unless there are new features you want to use.
 MODERATE: Program an upgrade of the server, but it's not urgent.
 HIGH:     There is a critical bug that may affect a subset of users. Upgrade!
 CRITICAL: There is a critical bug affecting MOST USERS. Upgrade ASAP.
 --------------------------------------------------------------------------------
 
---[ Redis 3.0.7 ] Release date: 25 jan 2016
+================================================================================
+Redis 3.2.0     Released Fri May 06 08:47:10 CEST 2016
+================================================================================
 
-Upgrade urgency MODERATE: this release fixes important Redis Cluster bugs.
+Upgrade urgency HIGH: 3.2-RC users should upgrade ASAP to this more
+                      stable release of Redis.
 
-* [FIX] Many fixes to MIGRATE multiple keys implementation. The command
-        could handle errors in a faulty way leading to crashes or other
-        unexpected behaviors. MIGRATE command refactoring.
-        (The analysis of the faulty conditions was conducted by
-         Kevin McGehee. The fix was developed by Salvatore Sanfilippo)
-* [FIX] A Redis Cluster node crash was fixed because of wrong handling of
-        node->slaveof pointers.
-        (Reported by JackyWoo, fixed by Salvatore Sanfilippo)
-* [FIX] Fix redis-trib rebalance when nodes need to be left empty because
-        the specified weight is zero.
-        (Reported by Shahar Mor, fixed by Salvatore Sanfilippo)
-* [FIX] MIGRATE: Never send -ASK redirections for MIGRATE when there are
-        open slots. Redis-trib and other cluster management utility must
-        always be free to move keys between nodes about open slots, in order
-        to reshard, fix the cluster configuration, and so forth.
-        (Salvatore Sanfilippo)
-* [FIX] Lua debugger crash when printing too deeply nested objects.
-        (Reported by Paul Kulchenko, fixed by Salvatore Sanfilippo)
-* [FIX] Redis-cli implementation of Lua debugging now allows to use the
-        SCRIPT DEBUG command directly, switching to debugging mode as needed.
-        (Reported by Paul Kulchenko, fixed by Salvatore Sanfilippo)
-* [FIX] Redis-trib is now able to fix more errors. A new CLUSTER subcommand
-        called BUMPEPOCH was introduced in order to support new modes
-        for the "fix" subcommand. (Salvatore Sanfilippo)
-* [NEW] Redis proctected mode: this feature improves Redis security and makes
-        harder to run Redis in a configuration that is unsecure because no
-        firewalling was used in order to protect Redis from external accesses.
-        See this Reddit post for more info: https://www.reddit.com/r/redis/comments/3zv85m/new_security_feature_redis_protected_mode/ (Salvatore Sanfilippo)
-* [NEW] Cluster/Sentinel tests now use OSX leak to perform leak detection
-        at the end of every unit. (Salvatore Sanfilippo)
-* [NEW] Detect and show server crashes during Cluster/Sentinel tests.
-        (Salvatore Sanfilippo)
-* [NEW] More reliable Cluster/Sentinel test becuase of timing errors and
-        -LOADING errors. (Salvatore Sanfilippo)
+Hello, this is Redis 3.2.0 stable! And with the new release there is a new
+format for the changelog. Now it is composed of a "letter" like the one
+you are reading, followed by all the commits composing the release for people
+interested in the details.
 
---[ Redis 3.0.6 ] Release date: 18 Dec 2015
+There are a few changes between the latest release candidate of Redis 3.2
+and the final 3.2.0 release. The main ones are the obvious bug fixes you
+can find detailed below, also a few new things:
 
-Upgrade urgency: MODERATE. We fixed a crash that happens very rarely, so
-                 updating does not hurt, but most users are unlikely to
-                 experience this condition because it requires some odd
-                 timing. However if you are a Redis Cluster user, upgrading
-                 is strongly adviced since this release includes very
-                 important improvements to Redis Cluster.
-
-* [FIX] lua_struct.c/getnum security issue fixed. (Luca Bruno discovered it,
-        patched by Sun He and Chris Lamb)
-* [FIX] Redis Cluster replica migration fixed. See issue #2924 for details.
-        (Salvatore Sanfilippo)
-* [FIX] Fix a race condition in processCommand() because of interactions
-        with freeMemoryIfNeeded(). Details in issue #2948 and especially
-        in the commit message d999f5a. (Race found analytically by
-        Oran Agra, patch by Salvatore Sanfilippo)
-
-* [NEW] Backported from the upcoming Redis 3.2:
-        MIGRATE now supports an extended multiple-keys pipelined mode, which
-        is an order of magnitude faster. Redis Cluster now uses this mode
-        in order to perform reshardings and rebalancings. (Salvatore Sanfilippo)
-* [NEW] Backported from the upcoming Redis 3.2:
-        Redis Cluster has now support for rebalancing via the redis-trib
-        rebalance command. Demo here:
-        https://asciinema.org/a/0tw2e5740kouda0yhkqrm5790
-        Official documentation will be available ASAP. (Salvatore Sanfilippo)
-* [NEW] Redis Cluster redis-trib.rb new "info" subcommand.
-* [NEW] Redis Cluster tests improved. (Salvatore Sanfilippo)
-* [NEW] Log offending memory access address on SIGSEGV/SIGBUS (Salvatore
-        Sanfilippo)
-
---[ Redis 3.0.5 ] Release date: 15 Oct 2015
-
-Upgrade urgency: MODERATE, the most important thing is a fix in the replication
-                 code that may make the slave hanging forever if the master
-                 remains with an open socket even if it is no longer able to
-                 reply.
-
-* [FIX] MOVE now moves the TTL as well. A bug lasting forever... finally
-        fixed thanks to Andy Grunwald that reported it.
-        (reported by Andy Grunwald, fixed by Salvatore Sanfilippo)
-* [FIX] Fix a false positive in HSTRLEN test.
-* [FIX] Fix a bug in redis-cli --pipe mode that was not able to read back
-        replies from the server incrementally. Now a mass import will use
-        a lot less memory, and you can use --pipe to do incremental streaming.
-        (reported by Twitter user @fsaintjacques, fixed by Salvatore
-        Sanfilippo)
-* [FIX] Slave detection of master timeout. (fixed by Kevin McGehee, refactoring
-        and regression test by Salvatore Sanfilippo)
+Critical bugs fixed:
 
-* [NEW] Cluster: redis-trib fix can fix an additional case for opens lots.
-        (Salvatore Sanfilippo)
-* [NEW] Cluster: redis-trib import support for --copy and --replace options
-        (David Thomson)
+* There was a problem in the way a cluster instance loaded the AOF that
+  could cause data written via scripts to be lost during reshardings.
 
---[ Redis 3.0.4 ] Release date: 8 Sep 2015
+New things:
 
-Upgrade urgency: HIGH for Redis and Sentinel. However note that in order to
-                 fix certain replication bugs, the replication internals were
-                 modified in a very heavy way. So while this release is
-                 conceptually saner, it may contain regressions. For this
-                 reason, before the release, QA activities were performed by
-                 me (antirez) and Redis Labs and no evident bug was found.
-
-* [FIX] A number of bugs related to replication PSYNC and the (yet experimental)
-        diskless replication feature were fixed. The bugs could lead to
-        inconsistency between masters and slaves. (Salvatore Sanfilippo, Oran
-        Agra fixed the issue found by Yuval Inbar)
-* [FIX] A replication bug in the context of PSYNC partial resynchonization was
-        found and fixed. This bug happens even when diskless replication is off
-        in the case different slaves connect at different times while the master
-        is creating an RDB file, and later a partial resynchronization is
-        attempted by a slave that connected not as the first one. (Salvatore
-        Sanfilippo, Oran Agra)
-* [FIX] Chained replication and PSYNC interactions leading to potential stale
-        chained slaves data set, see issue #2694. (Salvatore Sanfilippo fixed
-        an issue reported by "GeorgeBJ" user at Github)
-* [FIX] redis-cli --scan iteration fixed when returned cursor overflows
-        32 bit signed integer. (Ofir Luzon, Yuval Inbar)
-* [FIX] Sentinel: fixed a bug during the master switch process, where for a
-        failed conditional check, the new configuration is rewritten, during
-        a small window of time, in a corrupted way where the master is
-        also reported to be one of the slaves. This bug is rare to trigger
-        but apparently it happens in the wild, and the effect is to see
-        a replication loop where the master will try to replicate with itself.
-        A detailed explanation of the bug and its effects can be found in
-        the commit message here: https://github.com/antirez/redis/commit/c20218eb5770b2cafb12bc7092313b8358fedc0a.
-        The bug was found by Jan-Erik Rediger using a static analyzer and
-        fixed by Salvatore Sanfilippo.
-* [FIX] Sentinel lack of arity checks for certain commands.
-        (Rogerio Goncalves, Salvatore Sanfilippo)
-
-* [NEW] Replication internals rewritten in order to be more resistant to bugs.
-        The replication handshake in the slave side was rewritten as a non
-        blocking state machine. (Salvatore Sanfilippo, Oran Agra)
-* [NEW] New "replication capabilities" feature introduced in order to signal
-        from the master to the slave what are the features supported, so that
-        the master can choose the kind of replication to start (diskless or
-        not) when master and slave are of different versions. (Oran Agra,
-        Salvatore Sanfilippo)
-* [NEW] Log clients details when SLAVEOF command is received. (Salvatore
-        Sanfilippo with inputs from Nick Craver and Marc Gravell).
-
---[ Redis 3.0.3 ] Release date: 17 Jul 2015
-
-Upgrade urgency: LOW for Redis and Sentinel.
-
-* [FIX] Fix blocking operations timeout precision when HZ is at its default
-        value (not increased) and there are thousands of clients connected
-        at the same time. This bug affected Sidekiq users that experienced
-        a very long delay for BLPOP and similar commands to return for
-        timeout. Check commit b029ff1 for more info. (Salvatore Sanfilippo)
-* [FIX] MIGRATE "creating socket: Invalid argument" error fix. Check
-        issues #2609 and #2612 for more info. (Salvatore Sanfilippo)
-* [FIX] Be able to connect to the master even when the slave is bound to
-        just the loopback interface and has no valid public address in the
-        network the master is reacahble. (Salvatore Sanfilippo)
-* [FIX] ZADD with options encoding promotion fixed. (linfangrong)
-* [FIX] Reset aof_delayed_fsync on CONFIG RESETSTATS. (Tom Kiemes)
-* [FIX] PFCOUNT key parsing in cluster fixed. (MOON_CLJ)
-* [FIX] Fix Solaris compilation of Redis 3.0. (Jan-Erik Rediger)
-
-* [NEW] Variadic EXISTS command. Now the command accepts multiple arguments
-        and returns the total count of existing keys.
-
---[ Redis 3.0.2 ] Release date: 4 Jun 2015
-
-Upgrade urgency: HIGH for Redis because of a security issue.
-                 LOW for Sentinel.
-
-* [FIX] Critical security issue fix by Ben Murphy: http://t.co/LpGTyZmfS7
-* [FIX] SMOVE reply fixed when src and dst keys are the same. (Glenn Nethercutt)
-* [FIX] Lua cmsgpack lib updated to support str8 type. (Sebastian Waisbrot)
+* There is a new very powerful BITFIELD command. Check the documentation
+  here: http://redis.io/commands/BITFIELD
 
-* [NEW] ZADD support for options: NX, XX, CH. See new doc at redis.io.
-        (Salvatore Sanfilippo)
-* [NEW] Senitnel: CKQUORUM and FLUSHCONFIG commands back ported.
-        (Salvatore Sanfilippo and Bill Anderson)
+* CONFIG GET is allowed during the loading of the dataset.
+
+* The DEBUG command have new features and can show an help with DEBUG HELP.
 
---[ Redis 3.0.1 ] Release date: 5 May 2015
+* redis-cli show hits about the commands arguments to the right.
 
-Upgrade urgency: LOW for Redis and Cluster, MODERATE for Sentinel.
+* GEORADIUS got a STORE / STOREDIST option to store the result into a target
+  key (as as orted set) instead of reporting it to the user.
 
-* [FIX] Sentinel memory leak due to hiredis fixed. (Salvatore Sanfilippo)
-* [FIX] Sentinel memory leak on duplicated instance. (Charsyam)
-* [FIX] Redis crash on Lua reaching output buffer limits. (Yossi Gottlieb)
-* [FIX] Sentinel flushes config on +slave events. (Bill Anderson)
+* Redis Cluster replicas migration now works in a slightly different way. In
+  the past a slave could migrate only to a master that used to have slaves
+  in the past (and if there was still trace of this information). Now instead
+  if a new slave gets at least a slot, and at least one other master in the
+  cluster has a slave, then the new master is considered a valid target for
+  replica migration. So if it will be orphaned and there is a spare slave
+  it will get one.
 
---[ Redis 3.0.0 ] Release date: 1 Apr 2015
+* CLUSTER SLOTS output now includes the node ID (in a backward compatible
+  manner).
 
->> What's new in Redis 3.0 compared to Redis 2.8?
+* A lot of bug fixes you can read in the commits details below, with the
+  authors that kindly provided many useful patches. Thanks.
 
-* Redis Cluster: a distributed implementation of a subset of Redis.
-* New "embedded string" object encoding resulting in less cache
-  misses. Big speed gain under certain work loads.
-* AOF child -> parent final data transmission to minimize latency due
-  to "last write" during AOF rewrites.
-* Much improved LRU approximation algorithm for keys eviction.
-* WAIT command to block waiting for a write to be transmitted to
-  the specified number of slaves.
-* MIGRATE connection caching. Much faster keys migraitons.
-* MIGRATE new options COPY and REPLACE.
-* CLIENT PAUSE command: stop processing client requests for a
-  specified amount of time.
-* BITCOUNT performance improvements.
-* CONFIG SET accepts memory values in different units (for example
-  you can use "CONFIG SET maxmemory 1gb").
-* Redis log format slightly changed reporting in each line the role of the
-  instance (master/slave) or if it's a saving child log.
-* INCR performance improvements.
+As usually what "stable" means is that we are confident the release is mature,
+however do your tests before putting it into production in your environemnt
+as it's fresh meat anyway.
 
->> Refactoring changes (no new features nor bug fixes)
+Cheers,
+Salvatore
 
-* Blocking operations full refactoring (blocked.c)
-* Client output buffer memory tracking refactored.
++-------------------------------------------------------------------------------
+| Cluster: don't check scripts key slots during AOF loading.
+| By antirez, 2016-05-05 23:37:08 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/746e1bebb4baf876c1e8cd2fe2d468a1c41e5dc3
 
-Changes between RC6 and 3.0.0 stable:
 
->> General changes
+ src/scripting.c | 6 ++++--
+ 1 file changed, 4 insertions(+), 2 deletions(-)
 
-* Fixes to diskless replication. (Oran Agra)
-* Test for BLPOP replication on role change. (Salvatore Sanfilippo)
-* prepareClientToWrite() error handling improvements. (Salvatore Sanfilippo)
-* Remove dict.c no longer used function. (Salvatore Sanfilippo)
++-------------------------------------------------------------------------------
+| redis-cli: remove debugging message.
+| By antirez, 2016-05-05 18:05:37 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/3907b059280898c6340b53982b3b65957535da7c
 
->> Cluster changes
 
-None
+ src/redis-cli.c | 1 -
+ 1 file changed, 1 deletion(-)
 
->> Sentinel changes
++-------------------------------------------------------------------------------
+| Revert "Fix commandCommand arity"
+| By antirez, 2016-05-05 17:35:33 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/f01a2714582a9a916b41e6cb90e42474a104925d
 
-None
+This reverts commit 1189a4eae6d009fc0da8d50fd542ba1391542165.
 
---[ Redis 3.0.0 RC6 (version 2.9.106) ] Release date: 24 mar 2015
+Actually this is wrong, the command can be called without args at all.
 
-Upgrade urgency: HIGH because of bugs related to Redis Custer and replication.
+ src/server.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-This is the 6th release candidate of Redis 3.0.0. This release fixes important
-issues discovered during stress testing, and implements safest behavior
-for blocking operations during clients reshardings, and a new much needed
-functionality of Redis Cluster manual failovers.
++-------------------------------------------------------------------------------
+| Fix commandCommand arity
+| By Ruben Bridgewater, 2016-01-04 11:39:45 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/1189a4eae6d009fc0da8d50fd542ba1391542165
 
-In order to fix certain bugs quite a bit of refactoring was needed which
-is usually non advisabble in a Release Candidate, but needed in order to
-end with a clean fix.
 
->> General changes
+ src/server.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-* [FIX] Redis (non clustered & clustered) replication bug involving blocking
-        operations: see issue #2473. (Salvatore Sanfilippo)
++-------------------------------------------------------------------------------
+| Fix a possible race condition of sdown detection if the connection to master/slave/sentinel decames disconnected just after the last PONG and before the next PING.
+| By Daniel Shih, 2016-01-12 17:06:47 +0800
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/d9dc0d777b775f2fe4f23f42e1b4130f4de1ed72
 
->> Cluster changes
 
-* [FIX] clientsArePaused() fix crashing the old master during manual failover.
-        (Salvatore Sanfilippo)
-* [FIX] Lua scripts replication in Redis Cluster was totally broken.
-        (Salvatore Sanfilippo)
-* [FIX] Redirect clients blocked into list operations when the hash slot
-        they are blocked into is migrated to another instance or the cluster
-        state turns into "fail". (Salvatore Sanfilippo)
-
-* [NEW] TAKEOVER option for CLUSTER FAILOVER implemented. It is now possible
-        to fix a cluster manually in the minority side of the partition, for
-        example in order to allow for multi DC setups & recovery.
-        (Salvatore Sanfilippo)
+ src/sentinel.c | 2 ++
+ 1 file changed, 2 insertions(+)
 
->> Sentinel changes
++-------------------------------------------------------------------------------
+| Fix nanosecond conversion
+| By Jan-Erik Rediger, 2016-01-13 10:22:29 -0700
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/13bd702844eda7bccc7c672b6ff77f53e21ab841
 
-No changes in Sentinel.
+1 microsecond = 1000 nanoseconds
+1e3 = 1000
+10e3 = 10000
 
---[ Redis 3.0.0 RC5 (version 2.9.105) ] Release date: 20 mar 2015
+ src/redis-cli.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Upgrade urgency: Moderate for Redis Cluster users, low otherwise.
++-------------------------------------------------------------------------------
+| redis-cli: don't free historyfile, is used later.
+| By antirez, 2016-05-05 13:57:57 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/f6b7df3aec1d8fddf3121c4315fea4bf45cc4cfe
 
-This is the 5th release candidate of Redis 3.0.0, released in order to fix
-a moderate bug in Redis Cluster. This RC does not shift in the future the
-Redis 3.0.0 final release which is scheduled in a few days (we are in the
-process of finishing the documentation for Redis Cluster).
 
->> General changes
+ src/redis-cli.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-* [FIX] Fix LATENCY command crash. (Salvatore Sanfilippo, thx to Ingmar)
-* [FIX] Config: missing activerehashing option support in CONFIG SET added.
-        (Salvatore Sanfilippo, thx to Bill Anderson)
-* [FIX] Fix for backtrace generation issue. (Mariano Pérez Rodríguez, Matt Stancliff, Salvatore Sanfilippo)
++-------------------------------------------------------------------------------
+| Cluster test 12: reshard back just a few slots to speedup the test.
+| By antirez, 2016-05-05 11:49:27 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/97ce72fa2d348f914fc40ccf0a32008c7362b817
 
-* [NEW] Redis-cli --latency-dist backported from unstable.
-        (Salvatore Sanfilippo)
 
->> Cluster changes
+ tests/cluster/tests/12-replica-migration-2.tcl | 14 +++++++-------
+ 1 file changed, 7 insertions(+), 7 deletions(-)
 
-* [FIX] Avoid redundant SELECT in MIGRATE. (Tommy Wang, Salvatore Sanfilippo)
-* [FIX] More robust slave check in CLUSTER REPLICATE. (Salvatore Sanfilippo)
-* [FIX] Fixed possible Redis Cluster node crash due to wrong separation of
-        concerns between getNodeByQuery() and Cluster global state update
-        fnuction. (Salvatore Sanfilippo, thx to Ingmar)
++-------------------------------------------------------------------------------
+| Cluster: make getNodeByQuery() responsible of -CLUSTERDOWN errors.
+| By antirez, 2016-05-05 11:33:43 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/708f486c77b455fa7ae1e87cf31278474eb9d432
 
-* [NEW] Add command CLUSTER MYID to easily featch instance ID. (Michel Martens)
+This fixes a bug introduced by d827dbf, and makes the code consistent
+with the logic of always allowing, while the cluster is down, commands
+that don't target any key.
 
->> Sentinel changes
+As a side effect the code is also simpler now.
 
-* [NEW] Support for CLIENT command added. It was missing in the command table.
-        (Leandro López)
+ src/cluster.c | 13 +++++++++++--
+ src/server.c  | 26 ++++++++++----------------
+ 2 files changed, 21 insertions(+), 18 deletions(-)
 
---[ Redis 3.0.0 RC4 (version 2.9.104) ] Release date: 13 feb 2015
++-------------------------------------------------------------------------------
+| Fixes a typo
+| By Itamar Haber, 2016-01-28 21:47:18 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/1fc2ed61bec2f2bf266b48e566a197c5214b4350
 
-Upgrade urgency: High for Redis if you use LRU eviction, low otherwise.
 
-This is the 4th release candidate of Redis 3.0.0, it fixes problems with
-LRU eviction that are not present in older release (2.8.x is not affected)
-and adds new tools to inspect latency and load-test LRU.
+ src/cluster.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
->> General changes
++-------------------------------------------------------------------------------
+| Reverse redirect address parse
+| By David Cavar, 2016-02-09 15:04:42 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/787d5ab9be45bf4feb6cfa8a227c185c93aaadae
 
-* [FIX] redis-cli CSV output NIL spurious newline removed. (Matt Collier)
-* [FIX] Memory efficiency test in unit test is now much faster: it affacted
-        the total "make test" execution time in a bad way.  (Salvatore
-        Sanfilippo)
-* [FIX] Fixes and improvements to dict.c and LRU eviction. Redis 3.0.0 new
-        LRU eviction had bugs creating high latency spikes when LRU was
-        happening during the keys dictionary rehashing. This bug is not
-        present into 2.8, was 3.0 specific. As a side effect of this issue
-        dict.c is now improved, and LRU algorithm is more precise (better
-        approximates true LRU). This was a joint effort, see issue
-        #2306 for details. (Oran Agra, Sun He, Salvatore Sanfilippo).
-        Thanks to Charsyam for spotting an integer overflow.
+Fix issue in case the redirect address is in ipv6 format. Parse from behind to extract last part of the response which represents actual port.
+ src/redis-cli.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-* [NEW] New latency tool: redis-cli --latency-dist is able to show an
-        xterm-256 based spectrum of latencies over time. (Salvatore Sanfilippo)
-* [NEW] redis-cli --lru-test implemented (cache workload simulator). (Salvatore
-        Sanfilippo)
-* [NEW] redis-cli --stat now shows LOAD when Redis is loading data.
-* [NEW] Support "1G" etc. units in CONFIG SET. (Chris Lamb, Salvatore
-        Sanfilippo)
++-------------------------------------------------------------------------------
+| Bind both IPv4 and IPv6 or exit with an error by default.
+| By antirez, 2016-05-05 10:02:42 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/0fda06225f19b18a370d63ac650a8bb61020235d
 
->> Cluster changes
+Thanks to @tushar2708 for the PR. I applied a slightly different fix.
+Thanks to @cespare for reporting.
 
-* None.
+Close #3024
+Close #3020
 
->> Sentinel changes
+ src/server.c | 18 ++++++++++--------
+ 1 file changed, 10 insertions(+), 8 deletions(-)
 
-* None.
++-------------------------------------------------------------------------------
+| Quick fix to avoid false positive in replica migration test.
+| By antirez, 2016-05-05 09:45:31 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/65707fa6b5bb38b5818af57ab93b9b1da47d708a
 
---[ Redis 3.0.0 RC3 (version 2.9.103) ] Release date: 30 jan 2015
 
-Upgrade urgency: High for Redis Cluster users, low otherwise.
+ tests/cluster/tests/12-replica-migration-2.tcl | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
 
-This is the third release candidate for Redis 3.0.0, the new RC fixes
-several critical issues with Redis Cluster.
++-------------------------------------------------------------------------------
+| Ensure slots are rechecked on EXEC.
+| By Chris Thunes, 2016-03-11 15:22:36 -0500
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/1f3ed652e2a6cfcbbd5300a31f5771f2ce842e98
 
->> General changes
+Fixes #2515.
 
-* [FIX] AOF bug unlikely to happen in practice and mostly harmless: child
-        process segfaults when parent is not reachable via pipe. (Sun He)
-* [FIX] Scripting engine now reports an error when misused with Lua debug
-        hooks, instead of crashing. (Salvatore Sanfilippo)
+ src/server.c | 9 +++++++--
+ 1 file changed, 7 insertions(+), 2 deletions(-)
 
->> Cluster changes
++-------------------------------------------------------------------------------
+| fix for #3187
+| By therealbill, 2016-04-22 10:43:48 -0500
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/3a4810678904af013901a896ab0bb3c71856644c
 
-* [FIX] Several issues with Redis Cluster internal nodes objects handling.
-        (Matt Stancliff & Salvatore Sanfilippo)
-* [FIX] Improvements in the Cluster test.
-        (Matt Stancliff & Salvatore Sanfilippo).
-* [FIX] Cluster memory leaks / double frees (Matt Stancliff).
-* [FIX] /dev/urandom surrogate for generation of unique IDs in a more
-        cheap way. (Salvatore Sanfilippo)
-* [FIX] Fixes and improvements to PING / PONG packets gossip sections
-        in order to improve (and fix) failure detection and speedup
-        cluster info propagation. (Salvatore Sanfilippo)
+I've renamed maxmemoryToString to evictPolicyToString since that is
+more accurate (and easier to mentally connect with the correct data), as
+well as updated the function to user server.maxmemory_policy rather than
+server.maxmemory. Now with a default config it is actually returning
+the correct policy rather than volatile-lru.
 
-* [NEW] CLUSTER count-failure-reports command added. (Salvatore Sanfilippo)
+ src/config.c | 4 ++--
+ src/server.c | 2 +-
+ src/server.h | 2 +-
+ 3 files changed, 4 insertions(+), 4 deletions(-)
 
->> Sentinel changes
++-------------------------------------------------------------------------------
+| Fixed typo in README.md
+| By Seth Bergman, 2016-04-30 11:58:48 -0500
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/bba53d7fc7a759b53d72a7c3be17a00abe32039e
 
-No changes for Sentinel.
 
---[ Redis 3.0.0 RC2 (version 2.9.102) ] Release date: 13 jan 2015
+ README.md | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Upgrade urgency: LOW.
++-------------------------------------------------------------------------------
+| fix variable
+| By Ryosuke Hasebe, 2016-03-30 23:09:36 +0900
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/ab7581489871eebcf0253915acc26efb27f5df23
 
-This is the second release candidate of Redis 3.0.0. The major changes
-are back porting of things implemented into the unstable branch while
-this was still possible (with the new development model adopted only
-bug fixes will be merged in the future).
 
-RC2 also fixes a few Redis Cluster non critical bugs.
+ src/redis-trib.rb | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
 
->> General changes
++-------------------------------------------------------------------------------
+| fix check_open_slots
+| By Ryosuke Hasebe, 2016-03-30 21:56:22 +0900
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/0fcf896ac14c6e5c57e3b79e836dd8bf7dad94b5
 
-* [FIX] A number of minor bug fixes.
 
-* [NEW] Diskless replication backportede.
-* [NEW] Lua bitops and updated cmsgpack backported.
-* [NEW] Transparent Huge Pages warnings and reporting backported.
+ src/redis-trib.rb | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
 
->> Cluster changes
++-------------------------------------------------------------------------------
+| Minor redis-cli wording change in --help output.
+| By antirez, 2016-05-04 22:34:17 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/b8a63635e39ce312b2c5664f2c2a59184849b8fb
 
-* [FIX] Fix PUBLISH cluster bus message count field.
-* [FIX] It is no longer possible to write outside node hash slots using Lua.
-* [FIX] Valgrind warnings (no actual bugs).
-* [FIX] Less strict in acceptiong myself->ip if it's not populated.
 
-* [NEW] Better testing of Lua scripts.
+ src/redis-cli.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
 
->> Sentinel changes
++-------------------------------------------------------------------------------
+| Allow CONFIG GET during loading.
+| By antirez, 2016-05-04 15:45:38 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/ae95de93312d6bb2c8c365c31f2a3fd0b6d2c100
 
-No changes to Sentinel.
+Thanks to @oranagra for the idea of allowing CONFIG GET during loading.
 
---[ Redis 3.0.0 RC1 (version 2.9.101) ] Release date: 9 oct 2014
+ src/config.c | 6 ++++++
+ src/server.c | 2 +-
+ 2 files changed, 7 insertions(+), 1 deletion(-)
 
-This is the first release candidate of Redis 3.0.0.
++-------------------------------------------------------------------------------
+| Command "r" flag removed from commands not accessing the key space.
+| By antirez, 2016-05-04 15:42:14 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/3ff8f57ef32e3b1ddd407b65d474f610881bef34
 
->> General changes
+Thanks to @oranagra for the hint about misplaced 'r' flags.
 
-* [FIX] An very large number of small fixes, old and new, merged in the
-        context of a the issue #1906. Please see the issue page here
-        for exact credits: https://github.com/antirez/redis/pull/1906
-        of each commit. (Matt Stancliff and many others).
-* [FIX] SAVE is no longer propagated to AOF / slaves.
-* [FIX] GETRANGE test no longer fails for 32 bit builds (Matt Stancliff).
-* [FIX] Limit SCAN latency when the hash table is in an odd state (very few
-        populted buckets because rehashing is in progress). (Xiaost and
-        Salvatore Sanfilippo)
+ src/server.c | 70 ++++++++++++++++++++++++++++++------------------------------
+ 1 file changed, 35 insertions(+), 35 deletions(-)
 
-* [NEW] Redis is now able to load truncated AOF files without requiring a
-        redis-check-aof utility run. The default now is to load truncated
-        (but apparently not corrupted) AOFs, you can change this in redis.conf.
-        (Salvatore Sanfilippo).
-* [NEW] DEBUG POPULATE two args form implemented. It is now possible to
-        call it with DEBUG POPULATE <count> <prefix>. Default prefix
-        is "key:" as usually.
-* [NEW] INCR: Modify incremented object in-place when possible. This results
-        in speed improvements + possibly better memory locality.
++-------------------------------------------------------------------------------
+| DEBUG command self documentation.
+| By antirez, 2016-05-04 12:45:55 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/07b852d24ec8d7cb47044b096baf0af1410c69ed
 
->> Cluster changes
 
-* [FIX] Cluster: claim ping_sent time even if we can't connect.
-* [FIX] redis-trib should not abort easily on connection issues.
-* [FIX] Cluster test: less console-spammy resharding test.
-* [FIX] Fix logic to detect we are among a minority.
-* [FIX] Process gossip section only for known nodes.
+ src/debug.c  | 49 ++++++++++++++++++++++++++++++++++++++++++++++++-
+ src/server.c |  2 +-
+ 2 files changed, 49 insertions(+), 2 deletions(-)
 
-* [NEW] Redis Cluster is stable and tested enough, there is a clear MVP,
-        so it was promoted from beta to stable.
-* [NEW] New unit 09, Pub/Sub across the cluster.
-* [NEW] New unit 08, update messages.
-* [NEW] New cluster option to work with partial slots coverage.
-* [NEW] More chatty cluster slaves when failover is stalled. They log reason
-        with rate limiting, only when reason changes or a given time
-        has elapsed.
++-------------------------------------------------------------------------------
+| various cleanups and minor fixes
+| By Oran Agra, 2016-04-25 16:49:57 +0300
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/cfc08b65b04cf972ebeadf3be9f39f2acd7672b3
 
->> Sentinel changes
 
-* [FIX] Sentinel critical bug fixed: the absolute majority was computed in a
-        wrong way because of a programming error. Now the implementation does
-        what the specification says and the majority to authorize a failover
-        (that should not be confused with the ODOWN quorum) is the majority of
-        *all* the Sentinels ever seen for a given master, regardless of their
-        current state.
-* [FIX] Resolved a memory leak in the hiredis library causing a memory leak
-        in Redis Sentinel when a monitored instance or another Sentinel is
-        unavailable. Every reconnection attempt will leak a small amount of
-        memory, but in the long run the process can reach a considerable size.
+ src/adlist.c             | 18 ++++++------------
+ src/ae_epoll.c           |  6 ++----
+ src/aof.c                |  5 ++++-
+ src/db.c                 |  2 +-
+ src/rdb.c                |  6 ++++--
+ src/rio.c                |  5 +++--
+ src/rio.h                |  2 ++
+ src/server.h             |  3 +--
+ tests/support/test.tcl   |  6 ------
+ tests/unit/bitops.tcl    |  2 +-
+ tests/unit/other.tcl     |  1 +
+ tests/unit/scripting.tcl | 27 ++++++++++++++-------------
+ 12 files changed, 39 insertions(+), 44 deletions(-)
 
-* [NEW] Sentinel: ability to announce itself with an arbitrary IP/port to work
-        in the context of natted networks. However this is probably still
-        not enough since there is no equivalent mechanism for slaves listed
-        in the master INFO output. (Dara Kong and Salvatore Sanfilippo)
++-------------------------------------------------------------------------------
+| dict.c minor optimization
+| By Oran Agra, 2016-04-25 16:48:25 +0300
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/6710c8dc15680b756de26d1d45df110987b951b3
 
---[ Redis 3.0.0 Beta 8 (version 2.9.57) ] Release date: 29 jul 2014
 
-This is the 8th beta of Redis 3.0.0.
+ src/dict.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
->> General changes
++-------------------------------------------------------------------------------
+| networking.c minor optimization
+| By Oran Agra, 2016-04-25 16:48:09 +0300
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/be5c0869821b16f18104d9ea62ab42bfa0615816
 
-* [FIX] Solaris compilation issues. (Matt Stancliff, Salvatore Sanfilippo)
-* [FIX] Allow shared integer objects if maxmemory policy is not LRU based.
-        (Salvatore Sanfilippo)
-* [FIX] PFSELFTEST: less false positives. (Salvatore Sanfilippo)
-* [FIX] Fail SYNC if background save child aborted due to a signal. (Yossi
-        Gottlieb)
 
-* [NEW] Latency framework backported from unstable branch. (Salvatore
-        Sanfilippo)
-* [NEW] AOF rewrite improved for latency. (Salvatore Sanfilippo)
-* [NEW] Pub/Sub PING. (Salvatore Sanfilippo)
-* [NEW] Much faster ZUNIONSTORE. (Kyle Hubert, Salvatore Sanfilippo)
-* [NEW] Faster ll2string() implementation. (Salvatore Sanfilippo)
+ src/networking.c | 11 +++++------
+ 1 file changed, 5 insertions(+), 6 deletions(-)
 
->> Cluster changes
++-------------------------------------------------------------------------------
+| add DEBUG JEMALLC PURGE and JEMALLOC INFO cleanup
+| By Oran Agra, 2016-04-25 16:47:42 +0300
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/3ede6c7a506bcff3c7d2147c8af140dd4102a36e
 
-* [FIX] CLUSTER RESET: Flush slave dataset on reset. (Salvatore Sanfilippo)
-* [FIX] Replica migration: don't migrate to masters that never had slaves
-        in the past, but only to masters that remained orphaned after
-        failure events. (Salvatore Sanfilippo)
 
-* [NEW] redis-trib: allow to reshard in non-interactive way. (Salvatore
-        Sanfilippo)
-* [NEW] Cluster test: unit 04, check consistency during resharding. (Salvatore
-        Sanfilippo)
-* [NEW] Cluster test: unit 05, slave selection. (Salvatore Sanfilippo)
-* [NEW] Cluster test: unit 06, slaves with stale data can't failover. (Salvatore
-        Sanfilippo)
-* [NEW] Cluster test: unit 07, replicas migration. (Salvatore Sanfilippo)
+ src/debug.c     | 17 ++++++++++++++++-
+ src/redis-cli.c |  2 +-
+ 2 files changed, 17 insertions(+), 2 deletions(-)
 
->> Sentinel changes
++-------------------------------------------------------------------------------
+| fix small issues in redis 3.2
+| By Oran Agra, 2016-04-25 14:19:28 +0300
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/e2fab184efd01ffa0d510739f4d819a30b1d6787
 
-* No Sentinel changes in this release.
 
---[ Redis 3.0.0 Beta 7 (version 2.9.56) ] Release date: 30 jun 2014
+ src/config.c | 2 ++
+ src/rdb.c    | 2 +-
+ 2 files changed, 3 insertions(+), 1 deletion(-)
 
-This is the 7th beta of Redis 3.0.0.
++-------------------------------------------------------------------------------
+| additional fix to issue #2948
+| By Oran Agra, 2016-04-25 14:18:40 +0300
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/9d57ceec08687545c2a63a2c18c28e2bcaf74664
 
->> General changes
 
-* [FIX] Scripting fixes backported from unstable, see Redis 2.8.12 changelog
-        for more info. (Salvatore Sanfilippo)
-* [FIX] Cancel SHUTDOWN if initial AOF is being written. (Matt Stancliff)
+ src/networking.c | 3 +++
+ 1 file changed, 3 insertions(+)
 
-* [NEW] New command: COMMAND, for commands introspection (Matt Stancliff &
-        Salvatore Sanfilippo)
-* [NEW] hiredis: Update to latest version. (Matt Stancliff)
-* [NEW] Jemalloc updated to 3.6.0. (Salvatore Sanfilippo)
++-------------------------------------------------------------------------------
+| Reply with error on negative geo radius.
+| By antirez, 2016-05-04 08:59:56 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/7ba2cf5f8bea9cd125e773de147e3ea9b19ee2b0
 
->> Cluster changes
+Thanks to @tidwall for reporting.
+Close #3194.
 
-* [FIX] Cluster: clear NOADDR flag when updating node address.
-        (Salvatore Sanfilippo)
+ src/geo.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
 
-* [NEW] New CLUSTER SLOTS command to simplify Cluster clients operations.
-        (Matt Stancliff)
-* [NEW] More Cluster tests. (Salvatore Sanfilippo)
-* [NEW] Log when failover authorization are granted / denied.
-        (Salvatore Sanfilippo)
++-------------------------------------------------------------------------------
+| Cluster regression test for #3043.
+| By antirez, 2016-05-02 18:36:09 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/38cf2bd257d09b360be6adf450d59592a359696d
+
+The test works but is very slow so far, since it involves resharding
+1/5 of all the cluster slots from master 0 to the other 4 masters and
+back into the original master.
+
+ tests/cluster/tests/12-replica-migration-2.tcl | 61 ++++++++++++++++++++++++++
+ 1 file changed, 61 insertions(+)
+
++-------------------------------------------------------------------------------
+| New masters with slots are now targets of migration if others are.
+| By antirez, 2016-05-02 16:41:56 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/7b618823c189c24313effbccda7022d167ea419c
+
+This fixes issue #3043.
+
+Before this fix, after a complete resharding of a master slots
+to other nodes, the master remains empty and the slaves migrate away
+to other masters with non-zero nodes. However the old master now empty,
+is no longer considered a target for migration, because the system has
+no way to tell it had slaves in the past.
+
+This fix leaves the algorithm used in the past untouched, but adds a
+new rule. When a new or old master which is empty and without slaves,
+are assigend with their first slot, if other masters in the cluster have
+slaves, they are automatically considered to be targets for replicas
+migration.
+
+ src/cluster.c | 36 +++++++++++++++++++++++++++++++++++-
+ 1 file changed, 35 insertions(+), 1 deletion(-)
+
++-------------------------------------------------------------------------------
+| Test ZINCRBY return value.
+| By antirez, 2016-05-02 08:57:30 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/1101b515c73dcb0ff4a868ba38a91dcebb5b85cc
+
+
+ tests/unit/type/zset.tcl | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
++-------------------------------------------------------------------------------
+| redis-cli preferences and rc file support.
+| By antirez, 2016-04-13 13:58:30 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/bbf93108ef2a7ac7bd53e26c96bf838f7c5e72df
+
+
+ src/redis-cli.c | 102 ++++++++++++++++++++++++++++++++++++++++++++++----------
+ 1 file changed, 85 insertions(+), 17 deletions(-)
+
++-------------------------------------------------------------------------------
+| redis-cli hints.
+| By antirez, 2016-04-13 12:34:14 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/3fd3fca0dd38cb21c900e4ba98e3d41f333335aa
+
+
+ deps/linenoise/linenoise.c |  8 +++++++
+ deps/linenoise/linenoise.h |  2 +-
+ src/redis-cli.c            | 53 ++++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 62 insertions(+), 1 deletion(-)
+
++-------------------------------------------------------------------------------
+| Linenoise updated again (hints support).
+| By antirez, 2016-04-12 23:39:18 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/34354473ffe8d60b80acdbc8c16b194f8bbd70a0
+
+
+ deps/linenoise/README.markdown | 176 ++++++++++++++++++++++++++++++++++++++++-
+ deps/linenoise/example.c       |  10 +++
+ deps/linenoise/linenoise.c     |  55 ++++++++++++-
+ deps/linenoise/linenoise.h     |  15 +++-
+ 4 files changed, 248 insertions(+), 8 deletions(-)
+
++-------------------------------------------------------------------------------
+| Linenoise updated.
+| By antirez, 2016-04-06 13:37:27 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/58229cd766fa02f399267310b5b488aac2c55a6a
+
+As a side effect, cat commands.txt | redis-cli now is able to handle
+lines more than 4096 bytes.
+
+ deps/linenoise/linenoise.c | 60 ++++++++++++++++++++++++++++++++++------------
+ 1 file changed, 45 insertions(+), 15 deletions(-)
+
++-------------------------------------------------------------------------------
+| ae.c: Fix delay until next timer event.
+| By antirez, 2016-04-04 14:08:16 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/29645f1f44926ac2662ed768fe1e369775a30b66
+
+This fix was written by Anthony LaTorre.
+The old code mis-calculated the amount of time to wait till next event.
+
+ src/ae.c | 21 ++++++++++++---------
+ 1 file changed, 12 insertions(+), 9 deletions(-)
+
++-------------------------------------------------------------------------------
+| ae.c: comment to explain why we have a useless maxId check.
+| By antirez, 2016-04-04 12:23:10 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/aa79c1f1c1d288e4cc2c0f4689ad01488678bf9d
+
+
+ src/ae.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
++-------------------------------------------------------------------------------
+| Fix ae.c to avoid timers infinite loop.
+| By antirez, 2016-01-08 15:05:14 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/0b69c9865619b54b75576e67aaafe7b018734bec
+
+This fix was suggested by Anthony LaTorre, that provided also a good
+test case that was used to verify the fix.
+
+The problem with the old implementation is that, the time returned by
+a timer event (that is the time after it want to run again) is added
+to the event *start time*. So if the event takes, in order to run, more
+than the time it says it want to be scheduled again for running, an
+infinite loop is triggered.
+
+ src/ae.c          | 51 ++++++++++++++++++++++-----------------------------
+ src/ae.h          |  3 +++
+ src/anet.h        |  2 ++
+ src/redis-trib.rb |  2 +-
+ 4 files changed, 28 insertions(+), 30 deletions(-)
+
++-------------------------------------------------------------------------------
+| BITFIELD: overflow wrap behavior fuzz tester.
+| By antirez, 2016-03-02 17:22:42 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/258857cd62e0eb70da32742651a55213fbc28a53
+
+
+ tests/unit/bitfield.tcl | 51 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 51 insertions(+)
+
++-------------------------------------------------------------------------------
+| BITFIELD basic unit tests.
+| By antirez, 2016-03-02 16:31:02 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/35d05d6dc5d7fb810e732f9de7b05c6b14933fb6
+
+
+ tests/unit/bitfield.tcl | 86 ++++++++++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 85 insertions(+), 1 deletion(-)
+
++-------------------------------------------------------------------------------
+| BITFIELD: Farest bit set is offset+bits-1. Off by one error fixed.
+| By antirez, 2016-03-02 16:20:28 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/6cf83feffad7f7b7693a207a9d63278354769ece
+
+
+ src/bitops.c | 6 ++++--
+ 1 file changed, 4 insertions(+), 2 deletions(-)
+
++-------------------------------------------------------------------------------
+| BITFIELD: overflow fuzzy testing.
+| By antirez, 2016-03-02 15:15:18 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/b4d65c9501be01531eb8fbeb4ba2b444e35d6494
+
+
+ tests/test_helper.tcl   |  1 +
+ tests/unit/bitfield.tcl | 52 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 53 insertions(+)
+
++-------------------------------------------------------------------------------
+| Fix typo in bitops.tcl comment.
+| By antirez, 2016-03-02 15:14:53 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/d75e0fdbe6ecf3074b18c4dd1e8b71a474254ccc
+
+
+ tests/unit/bitops.tcl | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
++-------------------------------------------------------------------------------
+| More BITFIELD fixes. Overflow conditional simplified.
+| By antirez, 2016-03-02 15:13:45 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/5f3ef73ed41be6e051daad9fdb7efa91b4ca682d
+
+See issue #3114.
+
+ src/bitops.c | 17 ++++++++---------
+ 1 file changed, 8 insertions(+), 9 deletions(-)
+
++-------------------------------------------------------------------------------
+| bitops/bitfield: fix length, overflow condition and *sign
+| By Sun He, 2016-03-02 18:11:30 +0800
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/5b9aa5026204fb6c8b0098d4e47c2e001cf06151
+
+
+ src/bitops.c | 13 ++++++++-----
+ 1 file changed, 8 insertions(+), 5 deletions(-)
+
++-------------------------------------------------------------------------------
+| Fix INFO commandstats reporting when argv is rewritten.
+| By antirez, 2016-03-02 08:51:27 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/ba9154d7e7bf959b002533384319a1e90545447b
+
+We want to report the original command in the stats, for example GEOADD,
+even when what is actually executed is the ZADD implementation.
 
->> Sentinel changes
+ src/scripting.c | 2 +-
+ src/server.c    | 4 ++--
+ 2 files changed, 3 insertions(+), 3 deletions(-)
 
-* [FIX] A few Sentinel bugs fixed and improvements, see Redis 2.8.12
-        changelog for more info.  (Salvatore Sanfilippo & Matt Stancliff)
-* [NEW] New Sentinel-Client handshake protocol, ROLE command, CLIENT KILL,
-        all backported to 3.0 branch. (Salvatore Sanfilippo)
-
---[ Redis 3.0.0 Beta 6 (version 2.9.55) ] Release date: 9 jun 2014
-
-This is the 6th beta of Redis 3.0.0.
-
->> General changes
-
-* [FIX] Fix software watchdog signal handler crash due to re-entering.
-* [FIX] Better Lua number -> string conversion for Lua scripts.
-* [FIX] Serious replication bug when min-slaves-* feature is used in slaves
-        configuration fixed.
-* [FIX] Blocking pop on lists now works when the list is created by commands
-        other than *PUSH* (for example SORT STORE).
-
->> Cluster changes
-
-* [FIX] CRITICAL: For a bug in the implementation of CLUSTER SET-CONFIG-EPOCH
-        introduced with beta-3 (especially beta-4 where the command
-        is actually used by redis-trib), a configEpoch for a node could
-        jump backward, breaking the eventual consistency property of the
-        slots -> nodes mapping in the cluster.
-
->> Sentinel changes
-
-* No changes for Sentinel in this release.
-
---[ Redis 3.0.0 Beta 5 (version 2.9.54) ] Release date: 26 may 2014
-
-This is the 5th beta of Redis 3.0.0. It does not include any real
-worthwhile change (just three days passed since the previous beta), but
-fixes two stupid bugs preventing cluster tests to pass.
-
---[ Redis 3.0.0 Beta 4 (version 2.9.53) ] Release date: 23 may 2014
-
-This is the fourth beta of Redis 3.0.0.
-
->> General changes
-
-* [NEW] Scripting engine performances improvements.
-* [NEW] Log format slightly changed to report current node role.
-
-* [FIX] Correct the HyperLogLog stale cache flag to prevent unnecessary
-        computation.
-
->> Cluster changes
-
-* [NEW] redis-trib: ability to import data from standalone Redis instances.
-* [NEW] redis-trib: "fix" subcommand much better at fixing errors.
-* [NEW] CLUSTER FAILOVER FORCE implemented.
-* [NEW] CLUSTER RESET implemented, it is now possible to completely reset
-        nodes and create a new cluster without restarting anything.
-* [NEW] Slave validity factor (max estimated data age to still failover)
-        is now under the control of the user, and can be configured via
-        redis.conf or CONFIG SET. Option name cluster-slave-validity-factor.
-* [NEW] Cluster test: failure detection and failover initial tests.
-* [NEW] CLUSTER MEET: better error messages when address is invalid.
-* [NEW] Bulk-accept new Cluster nodes in the Cluster bus instead of
-        performing just a single accept() per event fired.
-
-* [FIX] Bypass data_age check for manual failovers.
-* [FIX] Fixed data_age computation / check integer overflow.
-* [FIX] Various fixes to Tcl client.tcl Redis Cluster client used in tests.
-* [FIX] Better handling of stolen slots.
-* [FIX] Don't accept cluster bus connections during startup.
-
->> Sentinel changes
-
-* [NEW] Generate +config-update-from event when a new config is received.
-* [NEW] Log when a failover will be re-attempted again.
-
-* [FIX] Sentinel: Add "dir /tmp" directive in example sentinel.conf.
-
---[ Redis 3.0.0 Beta 3 (version 2.9.52) ] Release date: 5 may 2014
-
-This is the third beta of Redis 3.0.0.
-
->> General changes
-
-* [NEW] New data structure: the HyperLogLog (see 2.8 release notes).
-* [NEW] Lexicograhical range queries in sorted sets (see 2.8 release notes).
-* [NEW] LRU algorithm precision greatly improved.
-
-* [FIX] Redis is now much more responsive to reply with LOADING / BUSY errors.
-
->> Cluster changes
-
-* [NEW] Cluster testing framework and initial tests.
-* [NEW] Cluster epochs collision resolution (make Redis Cluster more resilient
-        to admin and programming errors).
-* [NEW] Persist / fsync some global state to ensure correct crash-recovery
-        semantics.
-* [NEW] New command introduced: CLUSTER SET-CONFIG-EPOCH, still not used
-        by redis-trib. Will be used to speedup the assignment of unique
-        epochs to different nodes at cluster creation time. For now this is
-        handled as a side effect of the cluster epochs collision resolution.
-
-* [FIX] Different fixes to redis-trib cluster creation.
-* [FIX] Fix an error in the CLUSTER NODES output for nodes slots.
-
->> Sentinel changes
-
-* [NEW] Sentinels are now able to send update messages in a peer-to-peer
-        fashion even if no Redis instances are available. Now the Sentinel
-        liveness property that the most updated configuration in a given
-        partition is propagated to all the Sentinels is extended to partitions
-        without reachable instances.
-* [NEW] Sentinel safety properties are now ensured in a crash-recovery system
-        model since some state is persisted on disk before replying to other
-        nodes, and reloaded at startup.
-* [NEW] Sentinel now uses CLIENT SETNAME so that it is easy to identify
-        Sentinels using CLIENT LIST among other clients.
-* [NEW] Sentinel failure detection and reconnection code improved.
-
---[ Redis 3.0.0 Beta 2 (version 2.9.51) ] Release date: 11 mar 2014
-
-This is the second beta of Redis 3.0.0.
-
->> General changes
-
-* [FIX] Sometimes the absolute config file path was obtained in a wrong way.
-        This happened when there was a "dir" directive inside the config file
-        and at the same time the configuration file was given as a relative
-        path to redis-server or redis-sentinel executables.
-* [FIX] redis-cli: Automatically enter --slave mode when SYNC or PSYNC are
-        called during an interactive session.
-* [FIX] BITCOUNT: fixed unaligned access causing issues in sparc and other
-        archs not capable of dealing with unaligned accesses. This also makes
-        the code faster in archs where unaligned accesses are allowed.
-* [FIX] Force INFO used_memory_peak to match peak memory. This generated some
-        confusion among users even if it was not an actual bug.
-* [FIX] Fixed an critical EVALSHA script cache bug: scripts executed may not
-        propagate to AOF / Slaves correctly under certain conditions.
-        See issue #1549 at Github for more information.
-* [FIX] Fixed multiple bugs resulting into closing the link with master or slave
-        during replication without good reasons. This will result in useless
-        resynchronizations, or infinite loops where the replication link can't
-        be established.
-* [FIX] Don't count the time needed to populate the buffers of clients waiting
-        in MONITOR mode when populating the Slow Log entries.
-
-* [NEW] Redis-cli updated to use SCAN instead of random sampling via
-        RANDOMKEY in order to implement --bigkeys feature. Moreover the
-        implementation now supports pipelining and reports more information
-        at the end of the scan. Much faster, much better. A special thank
-        you to Michael Grunder for this improvement.
-* [NEW] redis-cli now supports a new --intrinsic-latency mode that is able
-        to meter the latency of a system due to kernel / hypervisor.
-        How to use it is explained at http://redis.io/topics/latency.
-* [NEW] New command BITPOS: find first bit set or clear in a bitmap.
-* [NEW] CONFIG REWRITE calls are now logged.
-* [NEW] AOF write errors (like no space on device) no longer abort Redis if the
-        fsync policy is none or every second. The database enters a read-only
-        mode where every write is refused with an error. Normal operations are
-        restored as soon as Redis is able to append again data to the AOF file.
-* [NEW] Sentinel now accepts SHUTDOWN command.
-
-
->> Cluster changes
-
-* [FIX] Bind the first interface listed in the "bind" configuration directive
-        if any, in order to perform outgoing connections. This fixes Cluster
-        usage when an address is bound but there are multiple interfaces that
-        may be used to connect with other nodes.
-* [FIX] When an "Importing" slot is closed via CLUSTER SETSLOT NODE ...
-        increment the configEpoch in the special case it is zero.
-* [FIX] Current transaction is invalidated on redirection errors.
-* [FIX] Abort if port does not allow for a valid cluster bus port that is
-        always at fixed +10000 offset.
-* [FIX] Keys extraction algorithm fixed for ZUNIONSTORE/ZINTERSTORE and SORT.
-* [FIX] Better failover timeout and retry times: failover should now work
-        reliabily when node-timeout is very small (a few milliseconds).
-* [FIX] Don't allow SORT GET/BY options in Cluster mode.
-* [FIX] Clear importing/migrating state when turning from master to slave role.
-* [FIX] Set slot error if we receive an update for a busy slot.
-* [FIX] Update node configEpoch on UPDATE messages.
-
-* [NEW] Support multi-key operations as long as keys resolve to the same
-        hash slot, and the slot is not migrating, or it is migrating but all
-        the mentioned keys are available.
-* [NEW] New DEBUG command CMDKEYS available to debug / test keys identification
-        in Redis commands.
-* [NEW] redis-trib: create subcommand is now able to assign spare slaves.
-* [NEW] redis-trib: new subcommand 'call'. Exec command in all nodes.
-
-
->> Sentinel changes
-
-* [FIX] Sentinel "IDONTKNOW" error removed as it does not made sense with the
-        new Sentinel design. This error was actually a fix for a design error
-        in the first implementation of Sentinel.
-* [FIX] Sentinel: added a missing exit() call to abort after config file
-        checks at startup. This error was introduced with an improvement in
-        a previous 2.8 release.
-* [FIX] Sentinel: better nodes fail over start time desynchronization to avoid
-        split-brain during the voting process needed to get authorization to
-        fail over. This means the system is less likely to need to retry
-        and will fail over faster. No changes in behavior / correctness.
-
-* [NEW] Sentinel unit tests and framework. More tests needed and units must
-        be improved in order to have less false positives, but it is a start
-        and features a debugging console that is useful to fix tests or to
-        inspect bugs causing tests failures.
-* [NEW] New Sentinel events: +/-monitor and +set used to monitor when an
-        instance to monitor is added or removed, or when a configuration
-        is modified via SENTINEL SET.
++-------------------------------------------------------------------------------
+| BITFIELD: refactoring & fix of retval on FAIL.
+| By antirez, 2016-02-29 09:08:46 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/76b22e3728e37fe11582b71802bf98a2be09623f
+
+
+ src/bitops.c | 32 ++++++++++++++++++++++++--------
+ 1 file changed, 24 insertions(+), 8 deletions(-)
+
++-------------------------------------------------------------------------------
+| BITFIELD: Fix #<index> form parsing.
+| By antirez, 2016-02-26 15:53:29 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/c333a9e2d7873190b22aaee8835a188bc55b60dc
+
+
+ src/bitops.c | 10 ++++------
+ 1 file changed, 4 insertions(+), 6 deletions(-)
+
++-------------------------------------------------------------------------------
+| BITFIELD: Support #<index> offsets form.
+| By antirez, 2016-02-26 15:16:24 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/f84871cb5dd3bb3c04bfd7ac53b6e06b246f511f
+
+
+ src/bitops.c | 29 +++++++++++++++++++++++------
+ 1 file changed, 23 insertions(+), 6 deletions(-)
+
++-------------------------------------------------------------------------------
+| BITFIELD command initial implementation.
+| By antirez, 2016-02-25 23:31:45 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/761a77287107ce53dbf4755f1435cc9660b6c86d
+
+The new bitfield command is an extension to the Redis bit operations,
+where not just single bit operations are performed, but the array of
+bits composing a string, can be addressed at random, not aligned
+offsets, with any width unsigned and signed integers like u8, s5, u10
+(up to 64 bit signed integers and 63 bit unsigned integers).
+
+The BITFIELD command supports subcommands that can SET, GET, or INCRBY
+those arbitrary bit counters, with multiple overflow semantics.
+
+Trivial and credits:
+
+A similar command was imagined a few times in the past, but for
+some reason looked a bit far fetched or not well specified.
+Finally the command was proposed again in a clear form by
+Yoav Steinberg from Redis Labs, that proposed a set of commands on
+arbitrary sized integers stored at bit offsets.
+
+Starting from this proposal I wrote an initial specification of a single
+command with sub-commands similar to what Yoav envisioned, using short
+names for types definitions, and adding control on the overflow.
+
+This commit is the resulting implementation.
+
+Examples:
+
+    BITFIELD mykey OVERFLOW wrap INCRBY i2 10 -1 GET i2 10
+
+ src/bitops.c | 506 +++++++++++++++++++++++++++++++++++++++++++++++++++++++----
+ src/server.c |   1 +
+ src/server.h |   1 +
+ 3 files changed, 476 insertions(+), 32 deletions(-)
+
++-------------------------------------------------------------------------------
+| Eliminates engineers near the equator & prime meridian
+| By Itamar Haber, 2016-02-18 15:11:30 -0800
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/4b89ea3a95ef72353e14e0eb5cbf293bf2dc8b48
+
+
+ src/geo.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
++-------------------------------------------------------------------------------
+| Fixes a typo in a comment
+| By Itamar Haber, 2016-02-18 15:01:34 -0800
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/0f46f9bd423a146f96e1993aca6221e1305f9a28
+
+
+ src/geo.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
++-------------------------------------------------------------------------------
+| Adjusts accuracy for GEODIST
+| By Itamar Haber, 2016-02-18 15:00:39 -0800
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/9de844603c5203ae6ff6e7882a3dcb47a9f79a85
+
+
+ src/geo.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
++-------------------------------------------------------------------------------
+| addReplyHumanLongDouble() API added.
+| By antirez, 2016-02-18 22:08:47 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/79e553a58d7f814fd08482b118561fcf9854b1df
+
+Send a long double or double as a bulk reply, in a human friendly
+format.
+
+ src/networking.c | 9 +++++++++
+ src/server.h     | 1 +
+ 2 files changed, 10 insertions(+)
+
++-------------------------------------------------------------------------------
+| Fix GEORADIUS STORE/DIST refcount after backport to 3.2.
+| By antirez, 2016-02-18 15:33:02 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/158d1e2fbf6badb881a4d78623fd1bffde34cc49
+
+
+ src/geo.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
++-------------------------------------------------------------------------------
+| GEOADD STORE/STOREDIST tests.
+| By antirez, 2016-02-18 14:42:42 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/123cd88286127cc20684bf0457cb51107a67cfa2
+
+
+ tests/unit/geo.tcl | 54 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 54 insertions(+)
+
++-------------------------------------------------------------------------------
+| New options for GEORADIUS: STORE and STOREDIST.
+| By antirez, 2016-02-18 10:24:11 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/0b6daf5a6b27447f03c76387b8b707ce0ab7b08d
+
+Related to issue #3019.
+
+ src/geo.c    | 143 +++++++++++++++++++++++++++++++++++++++++------------------
+ src/server.c |   4 +-
+ src/server.h |   1 +
+ src/t_zset.c |  18 +++++---
+ 4 files changed, 117 insertions(+), 49 deletions(-)
+
++-------------------------------------------------------------------------------
+| Include full paths on RDB/AOF files errors.
+| By antirez, 2016-02-15 16:14:56 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/f7af1beaab938b7e319d1b91d7736f043b7ef682
+
+Close #3086.
+
+ src/aof.c | 17 +++++++++++++++--
+ src/rdb.c | 19 +++++++++++++++++--
+ 2 files changed, 32 insertions(+), 4 deletions(-)
+
++-------------------------------------------------------------------------------
+| Remove Lua state reference from buffers in lua_cmsgpack.
+| By antirez, 2016-02-10 09:12:17 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/0b4a628fc716ab6b88c9823b143de174601a790d
+
+
+ deps/lua/src/lua_cmsgpack.c | 53 +++++++++++++++++++++------------------------
+ 1 file changed, 25 insertions(+), 28 deletions(-)
+
++-------------------------------------------------------------------------------
+| cmsgpack: pass correct osize values to lua allocator, update correct buf free space in cmsgpack
+| By yoav@monfort.co.il, 2016-02-07 20:24:28 +0200
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/43509f686452fba68966aa89b87d1be065b50e17
+
+
+ deps/lua/src/lua_cmsgpack.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
++-------------------------------------------------------------------------------
+| Fixes a typo
+| By Itamar Haber, 2016-02-03 11:04:09 -0800
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/cd9f7c6976f81c0e9ffae9e34b31eda19384a7dd
+
+
+ src/server.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
++-------------------------------------------------------------------------------
+| Adds keyspace notifications for lrem
+| By Itamar Haber, 2016-02-02 09:58:19 -0800
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/bf30f5a73922e5111d6a39da7351e22357213134
+
+
+ src/t_list.c | 7 ++++++-
+ 1 file changed, 6 insertions(+), 1 deletion(-)
+
++-------------------------------------------------------------------------------
+| Typo ASII -> ASCII fixed in comment.
+| By antirez, 2016-01-29 12:08:10 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/0c7c7631d206964b8bf1dae3db286a3acda4edad
+
+
+ src/server.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
++-------------------------------------------------------------------------------
+| Cluster: include node IDs in SLOTS output.
+| By antirez, 2016-01-29 12:00:38 +0100
++--------------------------------------------------------------------------------
+https://github.com/antirez/redis/commit/0f3fb0097ae70e36ee65468b79f0be4160934bb4
+
+CLUSTER SLOTS now includes IDs in the nodes description associated with
+a given slot range. Certain client libraries implementations need a way
+to reference a node in an unique way, so they were relying on CLUSTER
+NODES, that is not a stable API and may change frequently depending on
+Redis Cluster future requirements.
+
+ src/cluster.c | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+
+~~~~~~~~~~~~~~~~~~~~~~~~~~ OLD STYLE CHANGELOG ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+--[ Redis 3.2.0 RC3 (version 3.1.103) ] Release date: 28 jan 2016
+
+Upgrade urgency MODERATE: this release fixes a non trivial Sentinel crash.
+
+* [FIX] avg_ttl reporting in INFO improved. (Salvatore Sanfilippo)
+* [FIX] Sentinel: improve handling of known Sentinel instances.
+        (Salvatore Sanfilippo, thanks to Paweł Kowalczykf or the original
+         crash report).
+* [FIX] Redis Cluster address update (via gossip section) processing improved
+        to avoid initiating inwanted handshakes.
+
+--[ Redis 3.2.0 RC2 (version 3.1.102) ] Release date: 25 jan 2016
+
+Upgrade urgency MODERATE: this release fixes important Redis Cluster bugs.
+
+* [FIX] Many fixes to MIGRATE multiple keys implementation. The command
+        could handle errors in a faulty way leading to crashes or other
+        unexpected behaviors. MIGRATE command refactoring.
+        (The analysis of the faulty conditions was conducted by
+         Kevin McGehee. The fix was developed by Salvatore Sanfilippo)
+* [FIX] A Redis Cluster node crash was fixed because of wrong handling of
+        node->slaveof pointers.
+        (Reported by JackyWoo, fixed by Salvatore Sanfilippo)
+* [FIX] Fix redis-trib rebalance when nodes need to be left empty because
+        the specified weight is zero.
+        (Reported by Shahar Mor, fixed by Salvatore Sanfilippo)
+* [FIX] MIGRATE: Never send -ASK redirections for MIGRATE when there are
+        open slots. Redis-trib and other cluster management utility must
+        always be free to move keys between nodes about open slots, in order
+        to reshard, fix the cluster configuration, and so forth.
+        (Salvatore Sanfilippo)
+* [FIX] Lua debugger crash when printing too deeply nested objects.
+        (Reported by Paul Kulchenko, fixed by Salvatore Sanfilippo)
+* [FIX] Redis-cli implementation of Lua debugging now allows to use the
+        SCRIPT DEBUG command directly, switching to debugging mode as needed.
+        (Reported by Paul Kulchenko, fixed by Salvatore Sanfilippo)
+* [FIX] Redis-trib is now able to fix more errors. A new CLUSTER subcommand
+        called BUMPEPOCH was introduced in order to support new modes
+        for the "fix" subcommand. (Salvatore Sanfilippo)
+* [NEW] Redis proctected mode: this feature improves Redis security and makes
+        harder to run Redis in a configuration that is unsecure because no
+        firewalling was used in order to protect Redis from external accesses.
+        See this Reddit post for more info: https://www.reddit.com/r/redis/comments/3zv85m/new_security_feature_redis_protected_mode/ (Salvatore Sanfilippo)
+* [NEW] Cluster/Sentinel tests now use OSX leak to perform leak detection
+        at the end of every unit. (Salvatore Sanfilippo)
+* [NEW] Detect and show server crashes during Cluster/Sentinel tests.
+        (Salvatore Sanfilippo)
+* [NEW] More reliable Cluster/Sentinel test becuase of timing errors and
+        -LOADING errors. (Salvatore Sanfilippo)
 
---[ Redis 3.0.0 Beta 1 (version 2.9.50) ] Release date: 11 Feb 2014
+--[ Redis 3.2.0 RC1 (version 3.1.101) ] Release date: 23 dec 2015
 
-This is the first beta of Redis 3.0.0.
+This is the first release candidate of Redis 3.2. The changelog above shows
+what's new in this release. In the next of the following weeks we'll test
+in depth every feature and we'll release new RCs as bugs are discovered
+and fixed. Note that while 3.2 looks solid already, it contains many changes
+to its internals. It's still fresh code compared to 3.0.
+
+General changes:
+
+* [NEW] Lua scripts "effect replication". Makes possible to write scripts
+        with side effects, use of random commands, and so forth.
+        (Salvatore Sanfilippo)
+* [NEW] Lua scripts selective replication. Makes possible to replicate to
+        slaves and AOF only selected parts of a script. (Design by
+        Yossi Gottlieb and Salvatore Sanfilippo, implemented by Salvatore)
+* [NEW] Geo indexing support via GEOADD, GEORADIUS and other commands.
+        See http://redis.io/commands/geoadd for more information.
+        (Initially implemented in a fork of Redis called "Ardb".
+         Matt Stancliff "imported back" the work to Redis and created the
+         initial API and implementation. Salvatore Sanfilippo modified
+         the API and the implementation, fixed bugs, improved performances
+         and unified the duplicated code with t_zset.c)
+* [NEW] Lua debugger. A complete stepping, remote debugger for Lua scripts.
+        Video here: https://www.youtube.com/watch?v=IMvRfStaoyM
+        (Salvatore Sanfilippo with many feedbacks and testing from
+         Itamar Haber)
+* [NEW] SDS improvements for speed and maximum string length.
+        This makes Redis more memory efficient in different use cases.
+        (Design and implementation by Oran Agra, some additional work
+         by Salvatore Sanfilippo)
+* [NEW] Modify Jemalloc size classes to make certain Redis objects fit
+        better, improving memory efficiency. (Oran Agra)
+* [NEW] Better consistency behavior between masters and slaves for expired
+        keys. The slaves are only able to logically consider a key expired
+        even before receiving the `DEL` command from the master. This avoids
+        the delay there is sometimes between the natural expire of the key
+        and the moment the slave is notified. (Salvatore Sanfilippo)
+* [NEW] Support daemon supervision by upstart or systemd (Pierre-Yves Ritschard)
+* [NEW] New encoding for the List type: Quicklists. Very important memory
+        savings and storage space in RDB gains (up to 10x sometimes).
+        (Design and implementation by Matt Stancliff. RDB storage reworked
+         by Salvatore Sanfilippo)
+* [NEW] SPOP with optional count argument. (Initial implementation by
+        Alon Diamant, mostly reimplemented by Salvatore Sanfilippo for speed
+        and in order to make the replication of a this class of commands,
+        having as logical effect the execution of multiple commands, possible).
+* [NEW] Support for RDB AUX fields. Now RDB files contain additional info
+        like the creation date, version of Redis generating it and so forth.
+        (Salvatore Sanfilippo)
+* [NEW] Faster RDB loading via the RESIZEDB opcode to avoid useless hash tables
+        rehashings. (Salvatore Sanfilippo)
+* [NEW] HSTRLEN command. (@landmime and Salvatore Sanfilippo)
+* [NEW] CONFIG SET/GET implementations refactored, partially rewritten,
+        now exposing more config options. (Salvatore Sanfilippo)
+* [NEW] CLUSTER NODES major speedup. (Salvatore Sanfilippo)
+* [NEW] CLIENT KILL TYPE MASTER, to kill (disconnect) masters from slaves.
+        (Salvatore Sanfilippo)
+* [NEW] Jemalloc updated to 4.0.3 (Salvatore Sanfilippo)
+* [NEW] DEBUG RESTART/CRASH-AND-RECOVER [delay] (Salvatore Sanfilippo)
+* [NEW] CLIENT REPLY command implemented: ON, OFF and SKIP modes.
+        (Salvatore Sanfilippo)
+* [NEW] Crash report produced by Redis on crash improved. (Salvatore Sanfilippo)
+* [NEW] Better memory test on crash. (Salvatore Sanfilippo)
+
+Redis Cluster changes:
+
+All the Redis Cluster changes in 3.2 were backported to 3.0, so there is
+technically nothing new for now in this release. The most important things
+are:
+
+* Cluster rebalancing.
+* A pipelined MIGRATE command which is 10x faster and makes resharding
+  and rebalancing faster.
+* Improved replicas migration.
+* As a side effect of quicklists encoding (see above items), moving big
+  lists between nodes is now a lot faster.
+
+Redis Sentinel changes:
+
+* [NEW] Sentinel connection sharing. Makes Sentinels able to scale to
+        monitor many masters. (Salvatore Sanfilippo)
+* [NEW] New SENTINEL INFO-CACHE command. (Matt Stancliff)
+* More things backported to Redis 3.0 in the past, so no longer news of 3.2.
 
-Migrating from 2.8 to 3.0
+Migrating from 3.0 to 3.2
 =========================
 
-Redis 2.8 is mostly a strict subset of 3.0, you should not have any problem
-upgrading your application from 2.8 to 3.0. However this is a list of small
-non-backward compatible changes introduced in the 3.0 release:
-
-* The log format was modified. The prefix of each line included the pid
-  in the following format [1234]. Now instead it is 1234:? Where
-  '?' is actually the role of the instance. M for master, S for slave, C
-  if this process is a saving child (for RDB/AOF), and X for Sentinel.
-
-* The default maxmemory policy in Redis 3.0 is no longer "volatile-lru" as
-  it used to be in 2.8, but "noeviction". The policies behavior is the same
-  (but LRU eviction is much more precise in 3.0), so only the default value
-  changed. Just make sure to specify in your redis.conf what you mean.
+Redis 3.0 is mostly a strict subset of 3.2, you should not have any problem
+upgrading your application from 3.0 to 3.2. However this is a list of small
+non-backward compatible changes introduced in the 3.2 release:
+
+* The default configuration file now binds to 127.0.0.1.
+* Slaves try to no longer expose stale data about already expired keys.
+* The RDB format changed. Redis 3.2 is still able to read 3.0 (and all the
+  past versions) files, but not the other way around.
+* Behavior on crash may be different. The crash log format changed and
+  the memory test executed is now different.
 
 --------------------------------------------------------------------------------
 
-Credits: Where not specified the implementation and design is done by
-Salvatore Sanfilippo. Thanks to Pivotal for making all this possible.
+Credits: For each release, a list of changes with the relative author is
+provided. Where not specified the implementation and design is done by
+Salvatore Sanfilippo. Thanks to Redis Labs for making all this possible.
 Also many thanks to all the other contributors and the amazing community
 we have.
 
-See commit messages for more credits.
+Commit messages may contain additional credits.
 
 Cheers,
 Salvatore
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps: geohash-int
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/async.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/async.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/async.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/async.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/hiredis.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/hiredis.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/hiredis.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/hiredis.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/libhiredis.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/libhiredis.a differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/net.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/net.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/net.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/net.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis: sdsalloc.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,9 +1,11 @@
-/* SDSLib, A C dynamic strings library
+/* SDSLib 2.0 -- A C dynamic strings library
  *
- * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2015, Oran Agra
+ * Copyright (c) 2015, Redis Labs, Inc
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  *   * Redistributions of source code must retain the above copyright notice,
@@ -31,50 +33,117 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <assert.h>
 #include "sds.h"
-#include "zmalloc.h"
+#include "sdsalloc.h"
+
+static inline int sdsHdrSize(char type) {
+    switch(type&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            return sizeof(struct sdshdr5);
+        case SDS_TYPE_8:
+            return sizeof(struct sdshdr8);
+        case SDS_TYPE_16:
+            return sizeof(struct sdshdr16);
+        case SDS_TYPE_32:
+            return sizeof(struct sdshdr32);
+        case SDS_TYPE_64:
+            return sizeof(struct sdshdr64);
+    }
+    return 0;
+}
+
+static inline char sdsReqType(size_t string_size) {
+    if (string_size < 32)
+        return SDS_TYPE_5;
+    if (string_size < 0xff)
+        return SDS_TYPE_8;
+    if (string_size < 0xffff)
+        return SDS_TYPE_16;
+    if (string_size < 0xffffffff)
+        return SDS_TYPE_32;
+    return SDS_TYPE_64;
+}
 
 /* Create a new sds string with the content specified by the 'init' pointer
  * and 'initlen'.
  * If NULL is used for 'init' the string is initialized with zero bytes.
  *
  * The string is always null-termined (all the sds strings are, always) so
  * even if you create an sds string with:
  *
- * mystring = sdsnewlen("abc",3");
+ * mystring = sdsnewlen("abc",3);
  *
  * You can print the string with printf() as there is an implicit \0 at the
  * end of the string. However the string is binary safe and can contain
  * \0 characters in the middle, as the length is stored in the sds header. */
 sds sdsnewlen(const void *init, size_t initlen) {
-    struct sdshdr *sh;
-
-    if (init) {
-        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
-    } else {
-        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);
-    }
+    void *sh;
+    sds s;
+    char type = sdsReqType(initlen);
+    /* Empty strings are usually created in order to append. Use type 8
+     * since type 5 is not good at this. */
+    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
+    int hdrlen = sdsHdrSize(type);
+    unsigned char *fp; /* flags pointer. */
+
+    sh = s_malloc(hdrlen+initlen+1);
+    if (!init)
+        memset(sh, 0, hdrlen+initlen+1);
     if (sh == NULL) return NULL;
-    sh->len = initlen;
-    sh->free = 0;
+    s = (char*)sh+hdrlen;
+    fp = ((unsigned char*)s)-1;
+    switch(type) {
+        case SDS_TYPE_5: {
+            *fp = type | (initlen << SDS_TYPE_BITS);
+            break;
+        }
+        case SDS_TYPE_8: {
+            SDS_HDR_VAR(8,s);
+            sh->len = initlen;
+            sh->alloc = initlen;
+            *fp = type;
+            break;
+        }
+        case SDS_TYPE_16: {
+            SDS_HDR_VAR(16,s);
+            sh->len = initlen;
+            sh->alloc = initlen;
+            *fp = type;
+            break;
+        }
+        case SDS_TYPE_32: {
+            SDS_HDR_VAR(32,s);
+            sh->len = initlen;
+            sh->alloc = initlen;
+            *fp = type;
+            break;
+        }
+        case SDS_TYPE_64: {
+            SDS_HDR_VAR(64,s);
+            sh->len = initlen;
+            sh->alloc = initlen;
+            *fp = type;
+            break;
+        }
+    }
     if (initlen && init)
-        memcpy(sh->buf, init, initlen);
-    sh->buf[initlen] = '\0';
-    return (char*)sh->buf;
+        memcpy(s, init, initlen);
+    s[initlen] = '\0';
+    return s;
 }
 
 /* Create an empty (zero length) sds string. Even in this case the string
  * always has an implicit null term. */
 sds sdsempty(void) {
     return sdsnewlen("",0);
 }
 
-/* Create a new sds string starting from a null termined C string. */
+/* Create a new sds string starting from a null terminated C string. */
 sds sdsnew(const char *init) {
     size_t initlen = (init == NULL) ? 0 : strlen(init);
     return sdsnewlen(init, initlen);
 }
 
 /* Duplicate an sds string. */
@@ -82,13 +151,13 @@
     return sdsnewlen(s, sdslen(s));
 }
 
 /* Free an sds string. No operation is performed if 's' is NULL. */
 void sdsfree(sds s) {
     if (s == NULL) return;
-    zfree(s-sizeof(struct sdshdr));
+    s_free((char*)s-sdsHdrSize(s[-1]));
 }
 
 /* Set the sds string length to the length as obtained with strlen(), so
  * considering as content only up to the first null term character.
  *
  * This function is useful when the sds string is hacked manually in some
@@ -100,81 +169,124 @@
  * printf("%d\n", sdslen(s));
  *
  * The output will be "2", but if we comment out the call to sdsupdatelen()
  * the output will be "6" as the string was modified but the logical length
  * remains 6 bytes. */
 void sdsupdatelen(sds s) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     int reallen = strlen(s);
-    sh->free += (sh->len-reallen);
-    sh->len = reallen;
+    sdssetlen(s, reallen);
 }
 
-/* Modify an sds string on-place to make it empty (zero length).
+/* Modify an sds string in-place to make it empty (zero length).
  * However all the existing buffer is not discarded but set as free space
  * so that next append operations will not require allocations up to the
  * number of bytes previously available. */
 void sdsclear(sds s) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
-    sh->free += sh->len;
-    sh->len = 0;
-    sh->buf[0] = '\0';
+    sdssetlen(s, 0);
+    s[0] = '\0';
 }
 
 /* Enlarge the free space at the end of the sds string so that the caller
  * is sure that after calling this function can overwrite up to addlen
  * bytes after the end of the string, plus one more byte for nul term.
  *
  * Note: this does not change the *length* of the sds string as returned
  * by sdslen(), but only the free buffer space we have. */
 sds sdsMakeRoomFor(sds s, size_t addlen) {
-    struct sdshdr *sh, *newsh;
-    size_t free = sdsavail(s);
+    void *sh, *newsh;
+    size_t avail = sdsavail(s);
     size_t len, newlen;
+    char type, oldtype = s[-1] & SDS_TYPE_MASK;
+    int hdrlen;
+
+    /* Return ASAP if there is enough space left. */
+    if (avail >= addlen) return s;
 
-    if (free >= addlen) return s;
     len = sdslen(s);
-    sh = (void*) (s-(sizeof(struct sdshdr)));
+    sh = (char*)s-sdsHdrSize(oldtype);
     newlen = (len+addlen);
     if (newlen < SDS_MAX_PREALLOC)
         newlen *= 2;
     else
         newlen += SDS_MAX_PREALLOC;
-    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);
-    if (newsh == NULL) return NULL;
 
-    newsh->free = newlen - len;
-    return newsh->buf;
+    type = sdsReqType(newlen);
+
+    /* Don't use type 5: the user is appending to the string and type 5 is
+     * not able to remember empty space, so sdsMakeRoomFor() must be called
+     * at every appending operation. */
+    if (type == SDS_TYPE_5) type = SDS_TYPE_8;
+
+    hdrlen = sdsHdrSize(type);
+    if (oldtype==type) {
+        newsh = s_realloc(sh, hdrlen+newlen+1);
+        if (newsh == NULL) return NULL;
+        s = (char*)newsh+hdrlen;
+    } else {
+        /* Since the header size changes, need to move the string forward,
+         * and can't use realloc */
+        newsh = s_malloc(hdrlen+newlen+1);
+        if (newsh == NULL) return NULL;
+        memcpy((char*)newsh+hdrlen, s, len+1);
+        s_free(sh);
+        s = (char*)newsh+hdrlen;
+        s[-1] = type;
+        sdssetlen(s, len);
+    }
+    sdssetalloc(s, newlen);
+    return s;
 }
 
 /* Reallocate the sds string so that it has no free space at the end. The
  * contained string remains not altered, but next concatenation operations
  * will require a reallocation.
  *
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdsRemoveFreeSpace(sds s) {
-    struct sdshdr *sh;
-
-    sh = (void*) (s-(sizeof(struct sdshdr)));
-    sh = zrealloc(sh, sizeof(struct sdshdr)+sh->len+1);
-    sh->free = 0;
-    return sh->buf;
+    void *sh, *newsh;
+    char type, oldtype = s[-1] & SDS_TYPE_MASK;
+    int hdrlen;
+    size_t len = sdslen(s);
+    sh = (char*)s-sdsHdrSize(oldtype);
+
+    type = sdsReqType(len);
+    hdrlen = sdsHdrSize(type);
+    if (oldtype==type) {
+        newsh = s_realloc(sh, hdrlen+len+1);
+        if (newsh == NULL) return NULL;
+        s = (char*)newsh+hdrlen;
+    } else {
+        newsh = s_malloc(hdrlen+len+1);
+        if (newsh == NULL) return NULL;
+        memcpy((char*)newsh+hdrlen, s, len+1);
+        s_free(sh);
+        s = (char*)newsh+hdrlen;
+        s[-1] = type;
+        sdssetlen(s, len);
+    }
+    sdssetalloc(s, len);
+    return s;
 }
 
 /* Return the total size of the allocation of the specifed sds string,
  * including:
  * 1) The sds header before the pointer.
  * 2) The string.
  * 3) The free buffer at the end if any.
  * 4) The implicit null term.
  */
 size_t sdsAllocSize(sds s) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    size_t alloc = sdsalloc(s);
+    return sdsHdrSize(s[-1])+alloc+1;
+}
 
-    return sizeof(*sh)+sh->len+sh->free+1;
+/* Return the pointer of the actual SDS allocation (normally SDS strings
+ * are referenced by the start of the string buffer). */
+void *sdsAllocPtr(sds s) {
+    return (void*) (s-sdsHdrSize(s[-1]));
 }
 
 /* Increment the sds length and decrements the left free space at the
  * end of the string according to 'incr'. Also set the null term
  * in the new end of the string.
  *
@@ -195,60 +307,82 @@
  * s = sdsMakeRoomFor(s, BUFFER_SIZE);
  * nread = read(fd, s+oldlen, BUFFER_SIZE);
  * ... check for nread <= 0 and handle it ...
  * sdsIncrLen(s, nread);
  */
 void sdsIncrLen(sds s, int incr) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
-
-    if (incr >= 0)
-        assert(sh->free >= (unsigned int)incr);
-    else
-        assert(sh->len >= (unsigned int)(-incr));
-    sh->len += incr;
-    sh->free -= incr;
-    s[sh->len] = '\0';
+    unsigned char flags = s[-1];
+    size_t len;
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5: {
+            unsigned char *fp = ((unsigned char*)s)-1;
+            unsigned char oldlen = SDS_TYPE_5_LEN(flags);
+            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));
+            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);
+            len = oldlen+incr;
+            break;
+        }
+        case SDS_TYPE_8: {
+            SDS_HDR_VAR(8,s);
+            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
+            len = (sh->len += incr);
+            break;
+        }
+        case SDS_TYPE_16: {
+            SDS_HDR_VAR(16,s);
+            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
+            len = (sh->len += incr);
+            break;
+        }
+        case SDS_TYPE_32: {
+            SDS_HDR_VAR(32,s);
+            assert((incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
+            len = (sh->len += incr);
+            break;
+        }
+        case SDS_TYPE_64: {
+            SDS_HDR_VAR(64,s);
+            assert((incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));
+            len = (sh->len += incr);
+            break;
+        }
+        default: len = 0; /* Just to avoid compilation warnings. */
+    }
+    s[len] = '\0';
 }
 
 /* Grow the sds to have the specified length. Bytes that were not part of
  * the original length of the sds will be set to zero.
  *
  * if the specified length is smaller than the current length, no operation
  * is performed. */
 sds sdsgrowzero(sds s, size_t len) {
-    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
-    size_t totlen, curlen = sh->len;
+    size_t curlen = sdslen(s);
 
     if (len <= curlen) return s;
     s = sdsMakeRoomFor(s,len-curlen);
     if (s == NULL) return NULL;
 
     /* Make sure added region doesn't contain garbage */
-    sh = (void*)(s-(sizeof(struct sdshdr)));
     memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
-    totlen = sh->len+sh->free;
-    sh->len = len;
-    sh->free = totlen-sh->len;
+    sdssetlen(s, len);
     return s;
 }
 
 /* Append the specified binary-safe string pointed by 't' of 'len' bytes to the
  * end of the specified sds string 's'.
  *
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatlen(sds s, const void *t, size_t len) {
-    struct sdshdr *sh;
     size_t curlen = sdslen(s);
 
     s = sdsMakeRoomFor(s,len);
     if (s == NULL) return NULL;
-    sh = (void*) (s-(sizeof(struct sdshdr)));
     memcpy(s+curlen, t, len);
-    sh->len = curlen+len;
-    sh->free = sh->free-len;
+    sdssetlen(s, curlen+len);
     s[curlen+len] = '\0';
     return s;
 }
 
 /* Append the specified null termianted C string to the sds string 's'.
  *
@@ -266,25 +400,19 @@
     return sdscatlen(s, t, sdslen(t));
 }
 
 /* Destructively modify the sds string 's' to hold the specified binary
  * safe string pointed by 't' of length 'len' bytes. */
 sds sdscpylen(sds s, const char *t, size_t len) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
-    size_t totlen = sh->free+sh->len;
-
-    if (totlen < len) {
-        s = sdsMakeRoomFor(s,len-sh->len);
+    if (sdsalloc(s) < len) {
+        s = sdsMakeRoomFor(s,len-sdslen(s));
         if (s == NULL) return NULL;
-        sh = (void*) (s-(sizeof(struct sdshdr)));
-        totlen = sh->free+sh->len;
     }
     memcpy(s, t, len);
     s[len] = '\0';
-    sh->len = len;
-    sh->free = totlen-len;
+    sdssetlen(s, len);
     return s;
 }
 
 /* Like sdscpylen() but 't' must be a null-termined string so that the length
  * of the string is obtained with strlen(). */
 sds sdscpy(sds s, const char *t) {
@@ -292,13 +420,13 @@
 }
 
 /* Helper for sdscatlonglong() doing the actual number -> string
  * conversion. 's' must point to a string with room for at least
  * SDS_LLSTR_SIZE bytes.
  *
- * The function returns the lenght of the null-terminated string
+ * The function returns the length of the null-terminated string
  * representation stored at 's'. */
 #define SDS_LLSTR_SIZE 21
 int sdsll2str(char *s, long long value) {
     char *p, aux;
     unsigned long long v;
     size_t l;
@@ -366,59 +494,59 @@
     char buf[SDS_LLSTR_SIZE];
     int len = sdsll2str(buf,value);
 
     return sdsnewlen(buf,len);
 }
 
-/* Like sdscatpritf() but gets va_list instead of being variadic. */
+/* Like sdscatprintf() but gets va_list instead of being variadic. */
 sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
     va_list cpy;
     char staticbuf[1024], *buf = staticbuf, *t;
     size_t buflen = strlen(fmt)*2;
 
     /* We try to start using a static buffer for speed.
      * If not possible we revert to heap allocation. */
     if (buflen > sizeof(staticbuf)) {
-        buf = zmalloc(buflen);
+        buf = s_malloc(buflen);
         if (buf == NULL) return NULL;
     } else {
         buflen = sizeof(staticbuf);
     }
 
     /* Try with buffers two times bigger every time we fail to
      * fit the string in the current buffer size. */
     while(1) {
         buf[buflen-2] = '\0';
         va_copy(cpy,ap);
         vsnprintf(buf, buflen, fmt, cpy);
-        va_end(ap);
+        va_end(cpy);
         if (buf[buflen-2] != '\0') {
-            if (buf != staticbuf) zfree(buf);
+            if (buf != staticbuf) s_free(buf);
             buflen *= 2;
-            buf = zmalloc(buflen);
+            buf = s_malloc(buflen);
             if (buf == NULL) return NULL;
             continue;
         }
         break;
     }
 
     /* Finally concat the obtained string to the SDS string and return it. */
     t = sdscat(s, buf);
-    if (buf != staticbuf) zfree(buf);
+    if (buf != staticbuf) s_free(buf);
     return t;
 }
 
 /* Append to the sds string 's' a string obtained using printf-alike format
  * specifier.
  *
  * After the call, the modified sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call.
  *
  * Example:
  *
- * s = sdsempty("Sum is: ");
+ * s = sdsnew("Sum is: ");
  * s = sdscatprintf(s,"%d+%d = %d",a,b,a+b).
  *
  * Often you need to create a string from scratch with the printf-alike
  * format. When this is the need, just use sdsempty() as the target string:
  *
  * s = sdscatprintf(sdsempty(), "... your format ...", args);
@@ -446,100 +574,90 @@
  * %I - 64 bit signed integer (long long, int64_t)
  * %u - unsigned int
  * %U - 64 bit unsigned integer (unsigned long long, uint64_t)
  * %% - Verbatim "%" character.
  */
 sds sdscatfmt(sds s, char const *fmt, ...) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     size_t initlen = sdslen(s);
     const char *f = fmt;
     int i;
     va_list ap;
 
     va_start(ap,fmt);
     f = fmt;    /* Next format specifier byte to process. */
     i = initlen; /* Position of the next byte to write to dest str. */
     while(*f) {
         char next, *str;
-        unsigned int l;
+        size_t l;
         long long num;
         unsigned long long unum;
 
         /* Make sure there is always space for at least 1 char. */
-        if (sh->free == 0) {
+        if (sdsavail(s)==0) {
             s = sdsMakeRoomFor(s,1);
-            sh = (void*) (s-(sizeof(struct sdshdr)));
         }
 
         switch(*f) {
         case '%':
             next = *(f+1);
             f++;
             switch(next) {
             case 's':
             case 'S':
                 str = va_arg(ap,char*);
                 l = (next == 's') ? strlen(str) : sdslen(str);
-                if (sh->free < l) {
+                if (sdsavail(s) < l) {
                     s = sdsMakeRoomFor(s,l);
-                    sh = (void*) (s-(sizeof(struct sdshdr)));
                 }
                 memcpy(s+i,str,l);
-                sh->len += l;
-                sh->free -= l;
+                sdsinclen(s,l);
                 i += l;
                 break;
             case 'i':
             case 'I':
                 if (next == 'i')
                     num = va_arg(ap,int);
                 else
                     num = va_arg(ap,long long);
                 {
                     char buf[SDS_LLSTR_SIZE];
                     l = sdsll2str(buf,num);
-                    if (sh->free < l) {
+                    if (sdsavail(s) < l) {
                         s = sdsMakeRoomFor(s,l);
-                        sh = (void*) (s-(sizeof(struct sdshdr)));
                     }
                     memcpy(s+i,buf,l);
-                    sh->len += l;
-                    sh->free -= l;
+                    sdsinclen(s,l);
                     i += l;
                 }
                 break;
             case 'u':
             case 'U':
                 if (next == 'u')
                     unum = va_arg(ap,unsigned int);
                 else
                     unum = va_arg(ap,unsigned long long);
                 {
                     char buf[SDS_LLSTR_SIZE];
                     l = sdsull2str(buf,unum);
-                    if (sh->free < l) {
+                    if (sdsavail(s) < l) {
                         s = sdsMakeRoomFor(s,l);
-                        sh = (void*) (s-(sizeof(struct sdshdr)));
                     }
                     memcpy(s+i,buf,l);
-                    sh->len += l;
-                    sh->free -= l;
+                    sdsinclen(s,l);
                     i += l;
                 }
                 break;
             default: /* Handle %% and generally %<unknown>. */
                 s[i++] = next;
-                sh->len += 1;
-                sh->free -= 1;
+                sdsinclen(s,1);
                 break;
             }
             break;
         default:
             s[i++] = *f;
-            sh->len += 1;
-            sh->free -= 1;
+            sdsinclen(s,1);
             break;
         }
         f++;
     }
     va_end(ap);
 
@@ -554,31 +672,29 @@
  * After the call, the modified sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call.
  *
  * Example:
  *
  * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");
- * s = sdstrim(s,"A. :");
+ * s = sdstrim(s,"Aa. :");
  * printf("%s\n", s);
  *
  * Output will be just "Hello World".
  */
 sds sdstrim(sds s, const char *cset) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     char *start, *end, *sp, *ep;
     size_t len;
 
     sp = start = s;
     ep = end = s+sdslen(s)-1;
     while(sp <= end && strchr(cset, *sp)) sp++;
-    while(ep > start && strchr(cset, *ep)) ep--;
+    while(ep > sp && strchr(cset, *ep)) ep--;
     len = (sp > ep) ? 0 : ((ep-sp)+1);
-    if (sh->buf != sp) memmove(sh->buf, sp, len);
-    sh->buf[len] = '\0';
-    sh->free = sh->free+(sh->len-len);
-    sh->len = len;
+    if (s != sp) memmove(s, sp, len);
+    s[len] = '\0';
+    sdssetlen(s,len);
     return s;
 }
 
 /* Turn the string into a smaller (or equal) string containing only the
  * substring specified by the 'start' and 'end' indexes.
  *
@@ -593,13 +709,12 @@
  * Example:
  *
  * s = sdsnew("Hello World");
  * sdsrange(s,1,-1); => "ello World"
  */
 void sdsrange(sds s, int start, int end) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     size_t newlen, len = sdslen(s);
 
     if (len == 0) return;
     if (start < 0) {
         start = len+start;
         if (start < 0) start = 0;
@@ -616,16 +731,15 @@
             end = len-1;
             newlen = (start > end) ? 0 : (end-start)+1;
         }
     } else {
         start = 0;
     }
-    if (start && newlen) memmove(sh->buf, sh->buf+start, newlen);
-    sh->buf[newlen] = 0;
-    sh->free = sh->free+(sh->len-newlen);
-    sh->len = newlen;
+    if (start && newlen) memmove(s, s+start, newlen);
+    s[newlen] = 0;
+    sdssetlen(s,newlen);
 }
 
 /* Apply tolower() to every character of the sds string 's'. */
 void sdstolower(sds s) {
     int len = sdslen(s), j;
 
@@ -640,14 +754,14 @@
 }
 
 /* Compare two sds strings s1 and s2 with memcmp().
  *
  * Return value:
  *
- *     1 if s1 > s2.
- *    -1 if s1 < s2.
+ *     positive if s1 > s2.
+ *     negative if s1 < s2.
  *     0 if s1 and s2 are exactly the same binary string.
  *
  * If two strings share exactly the same prefix, but one of the two has
  * additional characters, the longer string is considered to be greater than
  * the smaller one. */
 int sdscmp(const sds s1, const sds s2) {
@@ -681,26 +795,26 @@
 sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {
     int elements = 0, slots = 5, start = 0, j;
     sds *tokens;
 
     if (seplen < 1 || len < 0) return NULL;
 
-    tokens = zmalloc(sizeof(sds)*slots);
+    tokens = s_malloc(sizeof(sds)*slots);
     if (tokens == NULL) return NULL;
 
     if (len == 0) {
         *count = 0;
         return tokens;
     }
     for (j = 0; j < (len-(seplen-1)); j++) {
         /* make sure there is room for the next element and the final one */
         if (slots < elements+2) {
             sds *newtokens;
 
             slots *= 2;
-            newtokens = zrealloc(tokens,sizeof(sds)*slots);
+            newtokens = s_realloc(tokens,sizeof(sds)*slots);
             if (newtokens == NULL) goto cleanup;
             tokens = newtokens;
         }
         /* search the separator */
         if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
             tokens[elements] = sdsnewlen(s+start,j-start);
@@ -718,24 +832,24 @@
     return tokens;
 
 cleanup:
     {
         int i;
         for (i = 0; i < elements; i++) sdsfree(tokens[i]);
-        zfree(tokens);
+        s_free(tokens);
         *count = 0;
         return NULL;
     }
 }
 
 /* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */
 void sdsfreesplitres(sds *tokens, int count) {
     if (!tokens) return;
     while(count--)
         sdsfree(tokens[count]);
-    zfree(tokens);
+    s_free(tokens);
 }
 
 /* Append to the sds string "s" an escaped string representation where
  * all the non-printable characters (tested with isprint()) are turned into
  * escapes in the form "\n\r\a...." or "\x<hex-number>".
  *
@@ -903,27 +1017,27 @@
                         break;
                     }
                 }
                 if (*p) p++;
             }
             /* add the token to the vector */
-            vector = zrealloc(vector,((*argc)+1)*sizeof(char*));
+            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));
             vector[*argc] = current;
             (*argc)++;
             current = NULL;
         } else {
             /* Even on empty input string return something not NULL. */
-            if (vector == NULL) vector = zmalloc(sizeof(void*));
+            if (vector == NULL) vector = s_malloc(sizeof(void*));
             return vector;
         }
     }
 
 err:
     while((*argc)--)
         sdsfree(vector[*argc]);
-    zfree(vector);
+    s_free(vector);
     if (current) sdsfree(current);
     *argc = 0;
     return NULL;
 }
 
 /* Modify the string substituting all the occurrences of the set of
@@ -959,20 +1073,41 @@
         join = sdscat(join, argv[j]);
         if (j != argc-1) join = sdscat(join,sep);
     }
     return join;
 }
 
-#ifdef SDS_TEST_MAIN
+/* Like sdsjoin, but joins an array of SDS strings. */
+sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
+    sds join = sdsempty();
+    int j;
+
+    for (j = 0; j < argc; j++) {
+        join = sdscatsds(join, argv[j]);
+        if (j != argc-1) join = sdscatlen(join,sep,seplen);
+    }
+    return join;
+}
+
+/* Wrappers to the allocators used by SDS. Note that SDS will actually
+ * just use the macros defined into sdsalloc.h in order to avoid to pay
+ * the overhead of function calls. Here we define these wrappers only for
+ * the programs SDS is linked to, if they want to touch the SDS internals
+ * even if they use a different allocator. */
+void *sds_malloc(size_t size) { return s_malloc(size); }
+void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }
+void sds_free(void *ptr) { s_free(ptr); }
+
+#if defined(SDS_TEST_MAIN)
 #include <stdio.h>
 #include "testhelp.h"
 #include "limits.h"
 
-int main(void) {
+#define UNUSED(x) (void)(x)
+int sdsTest(void) {
     {
-        struct sdshdr *sh;
         sds x = sdsnew("foo"), y;
 
         test_cond("Create a string and obtain the length",
             sdslen(x) == 3 && memcmp(x,"foo\0",4) == 0)
 
         sdsfree(x);
@@ -1002,21 +1137,34 @@
         x = sdsnew("--");
         x = sdscatfmt(x, "Hello %s World %I,%I--", "Hi!", LLONG_MIN,LLONG_MAX);
         test_cond("sdscatfmt() seems working in the base case",
             sdslen(x) == 60 &&
             memcmp(x,"--Hello Hi! World -9223372036854775808,"
                      "9223372036854775807--",60) == 0)
+        printf("[%s]\n",x);
 
         sdsfree(x);
         x = sdsnew("--");
         x = sdscatfmt(x, "%u,%U--", UINT_MAX, ULLONG_MAX);
         test_cond("sdscatfmt() seems working with unsigned numbers",
             sdslen(x) == 35 &&
             memcmp(x,"--4294967295,18446744073709551615--",35) == 0)
 
         sdsfree(x);
+        x = sdsnew(" x ");
+        sdstrim(x," x");
+        test_cond("sdstrim() works when all chars match",
+            sdslen(x) == 0)
+
+        sdsfree(x);
+        x = sdsnew(" x ");
+        sdstrim(x," ");
+        test_cond("sdstrim() works when a single char remains",
+            sdslen(x) == 1 && x[0] == 'x')
+
+        sdsfree(x);
         x = sdsnew("xxciaoyyy");
         sdstrim(x,"xy");
         test_cond("sdstrim() correctly trims characters",
             sdslen(x) == 4 && memcmp(x,"ciao\0",5) == 0)
 
         y = sdsdup(x);
@@ -1077,27 +1225,50 @@
         x = sdsnewlen("\a\n\0foo\r",7);
         y = sdscatrepr(sdsempty(),x,sdslen(x));
         test_cond("sdscatrepr(...data...)",
             memcmp(y,"\"\\a\\n\\x00foo\\r\"",15) == 0)
 
         {
-            int oldfree;
+            unsigned int oldfree;
+            char *p;
+            int step = 10, j, i;
 
             sdsfree(x);
+            sdsfree(y);
             x = sdsnew("0");
-            sh = (void*) (x-(sizeof(struct sdshdr)));
-            test_cond("sdsnew() free/len buffers", sh->len == 1 && sh->free == 0);
-            x = sdsMakeRoomFor(x,1);
-            sh = (void*) (x-(sizeof(struct sdshdr)));
-            test_cond("sdsMakeRoomFor()", sh->len == 1 && sh->free > 0);
-            oldfree = sh->free;
-            x[1] = '1';
-            sdsIncrLen(x,1);
-            test_cond("sdsIncrLen() -- content", x[0] == '0' && x[1] == '1');
-            test_cond("sdsIncrLen() -- len", sh->len == 2);
-            test_cond("sdsIncrLen() -- free", sh->free == oldfree-1);
+            test_cond("sdsnew() free/len buffers", sdslen(x) == 1 && sdsavail(x) == 0);
+
+            /* Run the test a few times in order to hit the first two
+             * SDS header types. */
+            for (i = 0; i < 10; i++) {
+                int oldlen = sdslen(x);
+                x = sdsMakeRoomFor(x,step);
+                int type = x[-1]&SDS_TYPE_MASK;
+
+                test_cond("sdsMakeRoomFor() len", sdslen(x) == oldlen);
+                if (type != SDS_TYPE_5) {
+                    test_cond("sdsMakeRoomFor() free", sdsavail(x) >= step);
+                    oldfree = sdsavail(x);
+                }
+                p = x+oldlen;
+                for (j = 0; j < step; j++) {
+                    p[j] = 'A'+j;
+                }
+                sdsIncrLen(x,step);
+            }
+            test_cond("sdsMakeRoomFor() content",
+                memcmp("0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ",x,101) == 0);
+            test_cond("sdsMakeRoomFor() final length",sdslen(x)==101);
+
+            sdsfree(x);
         }
     }
     test_report()
     return 0;
 }
 #endif
+
+#ifdef SDS_TEST_MAIN
+int main(void) {
+    return sdsTest();
+}
+#endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,9 +1,11 @@
-/* SDSLib, A C dynamic strings library
+/* SDSLib 2.0 -- A C dynamic strings library
  *
- * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2015, Oran Agra
+ * Copyright (c) 2015, Redis Labs, Inc
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  *   * Redistributions of source code must retain the above copyright notice,
@@ -32,38 +34,194 @@
 #define __SDS_H
 
 #define SDS_MAX_PREALLOC (1024*1024)
 
 #include <sys/types.h>
 #include <stdarg.h>
+#include <stdint.h>
 
 typedef char *sds;
 
-struct sdshdr {
-    unsigned int len;
-    unsigned int free;
+/* Note: sdshdr5 is never used, we just access the flags byte directly.
+ * However is here to document the layout of type 5 SDS strings. */
+struct __attribute__ ((__packed__)) sdshdr5 {
+    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
+    char buf[];
+};
+struct __attribute__ ((__packed__)) sdshdr8 {
+    uint8_t len; /* used */
+    uint8_t alloc; /* excluding the header and null terminator */
+    unsigned char flags; /* 3 lsb of type, 5 unused bits */
+    char buf[];
+};
+struct __attribute__ ((__packed__)) sdshdr16 {
+    uint16_t len; /* used */
+    uint16_t alloc; /* excluding the header and null terminator */
+    unsigned char flags; /* 3 lsb of type, 5 unused bits */
+    char buf[];
+};
+struct __attribute__ ((__packed__)) sdshdr32 {
+    uint32_t len; /* used */
+    uint32_t alloc; /* excluding the header and null terminator */
+    unsigned char flags; /* 3 lsb of type, 5 unused bits */
+    char buf[];
+};
+struct __attribute__ ((__packed__)) sdshdr64 {
+    uint64_t len; /* used */
+    uint64_t alloc; /* excluding the header and null terminator */
+    unsigned char flags; /* 3 lsb of type, 5 unused bits */
     char buf[];
 };
 
+#define SDS_TYPE_5  0
+#define SDS_TYPE_8  1
+#define SDS_TYPE_16 2
+#define SDS_TYPE_32 3
+#define SDS_TYPE_64 4
+#define SDS_TYPE_MASK 7
+#define SDS_TYPE_BITS 3
+#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));
+#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
+#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)
+
 static inline size_t sdslen(const sds s) {
-    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
-    return sh->len;
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            return SDS_TYPE_5_LEN(flags);
+        case SDS_TYPE_8:
+            return SDS_HDR(8,s)->len;
+        case SDS_TYPE_16:
+            return SDS_HDR(16,s)->len;
+        case SDS_TYPE_32:
+            return SDS_HDR(32,s)->len;
+        case SDS_TYPE_64:
+            return SDS_HDR(64,s)->len;
+    }
+    return 0;
 }
 
 static inline size_t sdsavail(const sds s) {
-    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
-    return sh->free;
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5: {
+            return 0;
+        }
+        case SDS_TYPE_8: {
+            SDS_HDR_VAR(8,s);
+            return sh->alloc - sh->len;
+        }
+        case SDS_TYPE_16: {
+            SDS_HDR_VAR(16,s);
+            return sh->alloc - sh->len;
+        }
+        case SDS_TYPE_32: {
+            SDS_HDR_VAR(32,s);
+            return sh->alloc - sh->len;
+        }
+        case SDS_TYPE_64: {
+            SDS_HDR_VAR(64,s);
+            return sh->alloc - sh->len;
+        }
+    }
+    return 0;
+}
+
+static inline void sdssetlen(sds s, size_t newlen) {
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            {
+                unsigned char *fp = ((unsigned char*)s)-1;
+                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
+            }
+            break;
+        case SDS_TYPE_8:
+            SDS_HDR(8,s)->len = newlen;
+            break;
+        case SDS_TYPE_16:
+            SDS_HDR(16,s)->len = newlen;
+            break;
+        case SDS_TYPE_32:
+            SDS_HDR(32,s)->len = newlen;
+            break;
+        case SDS_TYPE_64:
+            SDS_HDR(64,s)->len = newlen;
+            break;
+    }
+}
+
+static inline void sdsinclen(sds s, size_t inc) {
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            {
+                unsigned char *fp = ((unsigned char*)s)-1;
+                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;
+                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
+            }
+            break;
+        case SDS_TYPE_8:
+            SDS_HDR(8,s)->len += inc;
+            break;
+        case SDS_TYPE_16:
+            SDS_HDR(16,s)->len += inc;
+            break;
+        case SDS_TYPE_32:
+            SDS_HDR(32,s)->len += inc;
+            break;
+        case SDS_TYPE_64:
+            SDS_HDR(64,s)->len += inc;
+            break;
+    }
+}
+
+/* sdsalloc() = sdsavail() + sdslen() */
+static inline size_t sdsalloc(const sds s) {
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            return SDS_TYPE_5_LEN(flags);
+        case SDS_TYPE_8:
+            return SDS_HDR(8,s)->alloc;
+        case SDS_TYPE_16:
+            return SDS_HDR(16,s)->alloc;
+        case SDS_TYPE_32:
+            return SDS_HDR(32,s)->alloc;
+        case SDS_TYPE_64:
+            return SDS_HDR(64,s)->alloc;
+    }
+    return 0;
+}
+
+static inline void sdssetalloc(sds s, size_t newlen) {
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            /* Nothing to do, this type has no total allocation info. */
+            break;
+        case SDS_TYPE_8:
+            SDS_HDR(8,s)->alloc = newlen;
+            break;
+        case SDS_TYPE_16:
+            SDS_HDR(16,s)->alloc = newlen;
+            break;
+        case SDS_TYPE_32:
+            SDS_HDR(32,s)->alloc = newlen;
+            break;
+        case SDS_TYPE_64:
+            SDS_HDR(64,s)->alloc = newlen;
+            break;
+    }
 }
 
 sds sdsnewlen(const void *init, size_t initlen);
 sds sdsnew(const char *init);
 sds sdsempty(void);
-size_t sdslen(const sds s);
 sds sdsdup(const sds s);
 void sdsfree(sds s);
-size_t sdsavail(const sds s);
 sds sdsgrowzero(sds s, size_t len);
 sds sdscatlen(sds s, const void *t, size_t len);
 sds sdscat(sds s, const char *t);
 sds sdscatsds(sds s, const sds t);
 sds sdscpylen(sds s, const char *t, size_t len);
 sds sdscpy(sds s, const char *t);
@@ -88,14 +246,28 @@
 void sdstoupper(sds s);
 sds sdsfromlonglong(long long value);
 sds sdscatrepr(sds s, const char *p, size_t len);
 sds *sdssplitargs(const char *line, int *argc);
 sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);
 sds sdsjoin(char **argv, int argc, char *sep);
+sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);
 
 /* Low level functions exposed to the user API */
 sds sdsMakeRoomFor(sds s, size_t addlen);
 void sdsIncrLen(sds s, int incr);
 sds sdsRemoveFreeSpace(sds s);
 size_t sdsAllocSize(sds s);
+void *sdsAllocPtr(sds s);
+
+/* Export the allocator used by SDS to the program using SDS.
+ * Sometimes the program SDS is linked to, may use a different set of
+ * allocators, but may want to allocate or free things that SDS will
+ * respectively free or allocate. */
+void *sds_malloc(size_t size);
+void *sds_realloc(void *ptr, size_t size);
+void sds_free(void *ptr);
+
+#ifdef REDIS_TEST
+int sdsTest(int argc, char *argv[]);
+#endif
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc: .autom4te.cfg
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/bin: jemalloc-config
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/bin: jemalloc-config.in
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/bin/jemalloc.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/bin/jemalloc.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/bin/jemalloc.sh	2017-09-27 22:47:53.310963471 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/bin/jemalloc.sh	2017-09-27 22:49:15.098960473 +0800
@@ -1,9 +1,9 @@
 #!/bin/sh
 
 prefix=/usr/local
 exec_prefix=/usr/local
 libdir=${exec_prefix}/lib
 
-LD_PRELOAD=${libdir}/libjemalloc.so.1
+LD_PRELOAD=${libdir}/libjemalloc.so.2
 export LD_PRELOAD
 exec "$@"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/bin: jeprof
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/bin: jeprof.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/bin: pprof
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/ChangeLog /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/ChangeLog
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/ChangeLog	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/ChangeLog	2016-05-06 15:11:36.000000000 +0800
@@ -1,13 +1,253 @@
 Following are change highlights associated with official releases.  Important
-bug fixes are all mentioned, but internal enhancements are omitted here for
-brevity (even though they are more fun to write about).  Much more detail can be
-found in the git revision history:
+bug fixes are all mentioned, but some internal enhancements are omitted here for
+brevity.  Much more detail can be found in the git revision history:
 
     https://github.com/jemalloc/jemalloc
 
+* 4.0.3 (September 24, 2015)
+
+  This bugfix release continues the trend of xallocx() and heap profiling fixes.
+
+  Bug fixes:
+  - Fix xallocx(..., MALLOCX_ZERO) to zero all trailing bytes of large
+    allocations when --enable-cache-oblivious configure option is enabled.
+  - Fix xallocx(..., MALLOCX_ZERO) to zero trailing bytes of huge allocations
+    when resizing from/to a size class that is not a multiple of the chunk size.
+  - Fix prof_tctx_dump_iter() to filter out nodes that were created after heap
+    profile dumping started.
+  - Work around a potentially bad thread-specific data initialization
+    interaction with NPTL (glibc's pthreads implementation).
+
+* 4.0.2 (September 21, 2015)
+
+  This bugfix release addresses a few bugs specific to heap profiling.
+
+  Bug fixes:
+  - Fix ixallocx_prof_sample() to never modify nor create sampled small
+    allocations.  xallocx() is in general incapable of moving small allocations,
+    so this fix removes buggy code without loss of generality.
+  - Fix irallocx_prof_sample() to always allocate large regions, even when
+    alignment is non-zero.
+  - Fix prof_alloc_rollback() to read tdata from thread-specific data rather
+    than dereferencing a potentially invalid tctx.
+
+* 4.0.1 (September 15, 2015)
+
+  This is a bugfix release that is somewhat high risk due to the amount of
+  refactoring required to address deep xallocx() problems.  As a side effect of
+  these fixes, xallocx() now tries harder to partially fulfill requests for
+  optional extra space.  Note that a couple of minor heap profiling
+  optimizations are included, but these are better thought of as performance
+  fixes that were integral to disovering most of the other bugs.
+
+  Optimizations:
+  - Avoid a chunk metadata read in arena_prof_tctx_set(), since it is in the
+    fast path when heap profiling is enabled.  Additionally, split a special
+    case out into arena_prof_tctx_reset(), which also avoids chunk metadata
+    reads.
+  - Optimize irallocx_prof() to optimistically update the sampler state.  The
+    prior implementation appears to have been a holdover from when
+    rallocx()/xallocx() functionality was combined as rallocm().
+
+  Bug fixes:
+  - Fix TLS configuration such that it is enabled by default for platforms on
+    which it works correctly.
+  - Fix arenas_cache_cleanup() and arena_get_hard() to handle
+    allocation/deallocation within the application's thread-specific data
+    cleanup functions even after arenas_cache is torn down.
+  - Fix xallocx() bugs related to size+extra exceeding HUGE_MAXCLASS.
+  - Fix chunk purge hook calls for in-place huge shrinking reallocation to
+    specify the old chunk size rather than the new chunk size.  This bug caused
+    no correctness issues for the default chunk purge function, but was
+    visible to custom functions set via the "arena.<i>.chunk_hooks" mallctl.
+  - Fix heap profiling bugs:
+    + Fix heap profiling to distinguish among otherwise identical sample sites
+      with interposed resets (triggered via the "prof.reset" mallctl).  This bug
+      could cause data structure corruption that would most likely result in a
+      segfault.
+    + Fix irealloc_prof() to prof_alloc_rollback() on OOM.
+    + Make one call to prof_active_get_unlocked() per allocation event, and use
+      the result throughout the relevant functions that handle an allocation
+      event.  Also add a missing check in prof_realloc().  These fixes protect
+      allocation events against concurrent prof_active changes.
+    + Fix ixallocx_prof() to pass usize_max and zero to ixallocx_prof_sample()
+      in the correct order.
+    + Fix prof_realloc() to call prof_free_sampled_object() after calling
+      prof_malloc_sample_object().  Prior to this fix, if tctx and old_tctx were
+      the same, the tctx could have been prematurely destroyed.
+  - Fix portability bugs:
+    + Don't bitshift by negative amounts when encoding/decoding run sizes in
+      chunk header maps.  This affected systems with page sizes greater than 8
+      KiB.
+    + Rename index_t to szind_t to avoid an existing type on Solaris.
+    + Add JEMALLOC_CXX_THROW to the memalign() function prototype, in order to
+      match glibc and avoid compilation errors when including both
+      jemalloc/jemalloc.h and malloc.h in C++ code.
+    + Don't assume that /bin/sh is appropriate when running size_classes.sh
+      during configuration.
+    + Consider __sparcv9 a synonym for __sparc64__ when defining LG_QUANTUM.
+    + Link tests to librt if it contains clock_gettime(2).
+
+* 4.0.0 (August 17, 2015)
+
+  This version contains many speed and space optimizations, both minor and
+  major.  The major themes are generalization, unification, and simplification.
+  Although many of these optimizations cause no visible behavior change, their
+  cumulative effect is substantial.
+
+  New features:
+  - Normalize size class spacing to be consistent across the complete size
+    range.  By default there are four size classes per size doubling, but this
+    is now configurable via the --with-lg-size-class-group option.  Also add the
+    --with-lg-page, --with-lg-page-sizes, --with-lg-quantum, and
+    --with-lg-tiny-min options, which can be used to tweak page and size class
+    settings.  Impacts:
+    + Worst case performance for incrementally growing/shrinking reallocation
+      is improved because there are far fewer size classes, and therefore
+      copying happens less often.
+    + Internal fragmentation is limited to 20% for all but the smallest size
+      classes (those less than four times the quantum).  (1B + 4 KiB)
+      and (1B + 4 MiB) previously suffered nearly 50% internal fragmentation.
+    + Chunk fragmentation tends to be lower because there are fewer distinct run
+      sizes to pack.
+  - Add support for explicit tcaches.  The "tcache.create", "tcache.flush", and
+    "tcache.destroy" mallctls control tcache lifetime and flushing, and the
+    MALLOCX_TCACHE(tc) and MALLOCX_TCACHE_NONE flags to the *allocx() API
+    control which tcache is used for each operation.
+  - Implement per thread heap profiling, as well as the ability to
+    enable/disable heap profiling on a per thread basis.  Add the "prof.reset",
+    "prof.lg_sample", "thread.prof.name", "thread.prof.active",
+    "opt.prof_thread_active_init", "prof.thread_active_init", and
+    "thread.prof.active" mallctls.
+  - Add support for per arena application-specified chunk allocators, configured
+    via the "arena.<i>.chunk_hooks" mallctl.
+  - Refactor huge allocation to be managed by arenas, so that arenas now
+    function as general purpose independent allocators.  This is important in
+    the context of user-specified chunk allocators, aside from the scalability
+    benefits.  Related new statistics:
+    + The "stats.arenas.<i>.huge.allocated", "stats.arenas.<i>.huge.nmalloc",
+      "stats.arenas.<i>.huge.ndalloc", and "stats.arenas.<i>.huge.nrequests"
+      mallctls provide high level per arena huge allocation statistics.
+    + The "arenas.nhchunks", "arenas.hchunk.<i>.size",
+      "stats.arenas.<i>.hchunks.<j>.nmalloc",
+      "stats.arenas.<i>.hchunks.<j>.ndalloc",
+      "stats.arenas.<i>.hchunks.<j>.nrequests", and
+      "stats.arenas.<i>.hchunks.<j>.curhchunks" mallctls provide per size class
+      statistics.
+  - Add the 'util' column to malloc_stats_print() output, which reports the
+    proportion of available regions that are currently in use for each small
+    size class.
+  - Add "alloc" and "free" modes for for junk filling (see the "opt.junk"
+    mallctl), so that it is possible to separately enable junk filling for
+    allocation versus deallocation.
+  - Add the jemalloc-config script, which provides information about how
+    jemalloc was configured, and how to integrate it into application builds.
+  - Add metadata statistics, which are accessible via the "stats.metadata",
+    "stats.arenas.<i>.metadata.mapped", and
+    "stats.arenas.<i>.metadata.allocated" mallctls.
+  - Add the "stats.resident" mallctl, which reports the upper limit of
+    physically resident memory mapped by the allocator.
+  - Add per arena control over unused dirty page purging, via the
+    "arenas.lg_dirty_mult", "arena.<i>.lg_dirty_mult", and
+    "stats.arenas.<i>.lg_dirty_mult" mallctls.
+  - Add the "prof.gdump" mallctl, which makes it possible to toggle the gdump
+    feature on/off during program execution.
+  - Add sdallocx(), which implements sized deallocation.  The primary
+    optimization over dallocx() is the removal of a metadata read, which often
+    suffers an L1 cache miss.
+  - Add missing header includes in jemalloc/jemalloc.h, so that applications
+    only have to #include <jemalloc/jemalloc.h>.
+  - Add support for additional platforms:
+    + Bitrig
+    + Cygwin
+    + DragonFlyBSD
+    + iOS
+    + OpenBSD
+    + OpenRISC/or1k
+
+  Optimizations:
+  - Maintain dirty runs in per arena LRUs rather than in per arena trees of
+    dirty-run-containing chunks.  In practice this change significantly reduces
+    dirty page purging volume.
+  - Integrate whole chunks into the unused dirty page purging machinery.  This
+    reduces the cost of repeated huge allocation/deallocation, because it
+    effectively introduces a cache of chunks.
+  - Split the arena chunk map into two separate arrays, in order to increase
+    cache locality for the frequently accessed bits.
+  - Move small run metadata out of runs, into arena chunk headers.  This reduces
+    run fragmentation, smaller runs reduce external fragmentation for small size
+    classes, and packed (less uniformly aligned) metadata layout improves CPU
+    cache set distribution.
+  - Randomly distribute large allocation base pointer alignment relative to page
+    boundaries in order to more uniformly utilize CPU cache sets.  This can be
+    disabled via the --disable-cache-oblivious configure option, and queried via
+    the "config.cache_oblivious" mallctl.
+  - Micro-optimize the fast paths for the public API functions.
+  - Refactor thread-specific data to reside in a single structure.  This assures
+    that only a single TLS read is necessary per call into the public API.
+  - Implement in-place huge allocation growing and shrinking.
+  - Refactor rtree (radix tree for chunk lookups) to be lock-free, and make
+    additional optimizations that reduce maximum lookup depth to one or two
+    levels.  This resolves what was a concurrency bottleneck for per arena huge
+    allocation, because a global data structure is critical for determining
+    which arenas own which huge allocations.
+
+  Incompatible changes:
+  - Replace --enable-cc-silence with --disable-cc-silence to suppress spurious
+    warnings by default.
+  - Assure that the constness of malloc_usable_size()'s return type matches that
+    of the system implementation.
+  - Change the heap profile dump format to support per thread heap profiling,
+    rename pprof to jeprof, and enhance it with the --thread=<n> option.  As a
+    result, the bundled jeprof must now be used rather than the upstream
+    (gperftools) pprof.
+  - Disable "opt.prof_final" by default, in order to avoid atexit(3), which can
+    internally deadlock on some platforms.
+  - Change the "arenas.nlruns" mallctl type from size_t to unsigned.
+  - Replace the "stats.arenas.<i>.bins.<j>.allocated" mallctl with
+    "stats.arenas.<i>.bins.<j>.curregs".
+  - Ignore MALLOC_CONF in set{uid,gid,cap} binaries.
+  - Ignore MALLOCX_ARENA(a) in dallocx(), in favor of using the
+    MALLOCX_TCACHE(tc) and MALLOCX_TCACHE_NONE flags to control tcache usage.
+
+  Removed features:
+  - Remove the *allocm() API, which is superseded by the *allocx() API.
+  - Remove the --enable-dss options, and make dss non-optional on all platforms
+    which support sbrk(2).
+  - Remove the "arenas.purge" mallctl, which was obsoleted by the
+    "arena.<i>.purge" mallctl in 3.1.0.
+  - Remove the unnecessary "opt.valgrind" mallctl; jemalloc automatically
+    detects whether it is running inside Valgrind.
+  - Remove the "stats.huge.allocated", "stats.huge.nmalloc", and
+    "stats.huge.ndalloc" mallctls.
+  - Remove the --enable-mremap option.
+  - Remove the "stats.chunks.current", "stats.chunks.total", and
+    "stats.chunks.high" mallctls.
+
+  Bug fixes:
+  - Fix the cactive statistic to decrease (rather than increase) when active
+    memory decreases.  This regression was first released in 3.5.0.
+  - Fix OOM handling in memalign() and valloc().  A variant of this bug existed
+    in all releases since 2.0.0, which introduced these functions.
+  - Fix an OOM-related regression in arena_tcache_fill_small(), which could
+    cause cache corruption on OOM.  This regression was present in all releases
+    from 2.2.0 through 3.6.0.
+  - Fix size class overflow handling for malloc(), posix_memalign(), memalign(),
+    calloc(), and realloc() when profiling is enabled.
+  - Fix the "arena.<i>.dss" mallctl to return an error if "primary" or
+    "secondary" precedence is specified, but sbrk(2) is not supported.
+  - Fix fallback lg_floor() implementations to handle extremely large inputs.
+  - Ensure the default purgeable zone is after the default zone on OS X.
+  - Fix latent bugs in atomic_*().
+  - Fix the "arena.<i>.dss" mallctl to handle read-only calls.
+  - Fix tls_model configuration to enable the initial-exec model when possible.
+  - Mark malloc_conf as a weak symbol so that the application can override it.
+  - Correctly detect glibc's adaptive pthread mutexes.
+  - Fix the --without-export configure option.
+
 * 3.6.0 (March 31, 2014)
 
   This version contains a critical bug fix for a regression present in 3.5.0 and
   3.5.1.
 
   Bug fixes:
@@ -18,13 +258,13 @@
   - Fix backtracing for gcc intrinsics-based backtracing by specifying
     -fno-omit-frame-pointer to gcc.  Note that the application (and all the
     libraries it links to) must also be compiled with this option for
     backtracing to be reliable.
   - Use dss allocation precedence for huge allocations as well as small/large
     allocations.
-  - Fix test assertion failure message formatting.  This bug did not manifect on
+  - Fix test assertion failure message formatting.  This bug did not manifest on
     x86_64 systems because of implementation subtleties in va_list.
   - Fix inconsequential test failures for hash and SFMT code.
 
   New features:
   - Support heap profiling on FreeBSD.  This feature depends on the proc
     filesystem being mounted during heap profile dumping.
@@ -513,13 +753,13 @@
   - Implement autoconf-based configuration system.
   - Add mallctl*(), for the purposes of introspection and run-time
     configuration.
   - Make it possible for the application to manually flush a thread's cache, via
     the "tcache.flush" mallctl.
   - Base maximum dirty page count on proportion of active memory.
-  - Compute various addtional run-time statistics, including per size class
+  - Compute various additional run-time statistics, including per size class
     statistics for large objects.
   - Expose malloc_stats_print(), which can be called repeatedly by the
     application.
   - Simplify the malloc_message() signature to only take one string argument,
     and incorporate an opaque data pointer argument for use by the application
     in combination with malloc_stats_print().
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/config.guess /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/config.guess
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/config.guess	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/config.guess	2016-05-06 15:11:36.000000000 +0800
@@ -1,11 +1,11 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2013 Free Software Foundation, Inc.
+#   Copyright 1992-2014 Free Software Foundation, Inc.
 
-timestamp='2013-06-10'
+timestamp='2014-03-23'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
@@ -47,13 +47,13 @@
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2013 Free Software Foundation, Inc.
+Copyright 1992-2014 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
@@ -146,13 +146,13 @@
 	#elif defined(__dietlibc__)
 	LIBC=dietlibc
 	#else
 	LIBC=gnu
 	#endif
 	EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
 	;;
 esac
 
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
@@ -823,13 +823,13 @@
     *:MINGW64*:*)
 	echo ${UNAME_MACHINE}-pc-mingw64
 	exit ;;
     *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
-    i*:MSYS*:*)
+    *:MSYS*:*)
 	echo ${UNAME_MACHINE}-pc-msys
 	exit ;;
     i*:windows32*:*)
 	# uname -m includes "-pc" on this system.
 	echo ${UNAME_MACHINE}-mingw32
 	exit ;;
@@ -966,16 +966,16 @@
 	#endif
 	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
 	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
-    or1k:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-${LIBC}
 	exit ;;
-    or32:Linux:*:*)
+    or32:Linux:*:* | or1k*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     padre:Linux:*:*)
 	echo sparc-unknown-linux-${LIBC}
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
@@ -1257,22 +1257,32 @@
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
 	eval $set_cc_for_build
 	if test "$UNAME_PROCESSOR" = unknown ; then
 	    UNAME_PROCESSOR=powerpc
 	fi
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		grep IS_64BIT_ARCH >/dev/null
-	    then
-		case $UNAME_PROCESSOR in
-		    i386) UNAME_PROCESSOR=x86_64 ;;
-		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
-		esac
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		    (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
 	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
 	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
 	if test "$UNAME_PROCESSOR" = "x86"; then
@@ -1358,160 +1368,12 @@
 	exit ;;
     x86_64:VMkernel:*:*)
 	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
 esac
 
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-	"4"
-#else
-	""
-#endif
-	); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-  exit (1);
-}
-EOF
-
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
-	{ echo "$SYSTEM_NAME"; exit; }
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
-
 cat >&2 <<EOF
 $0: unable to guess system type
 
 This script, last modified $timestamp, has failed to recognize
 the operating system you are using. It is advised that you
 download the most up to date version of the config scripts from
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/config.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/config.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/config.log	2017-09-27 22:47:53.594963460 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/config.log	2017-09-27 22:49:15.510960458 +0800
@@ -40,173 +40,173 @@
 
 
 ## ----------- ##
 ## Core tests. ##
 ## ----------- ##
 
-configure:2523: checking for xsltproc
-configure:2541: found /opt/anaconda2/bin/xsltproc
-configure:2554: result: /opt/anaconda2/bin/xsltproc
-configure:2635: checking for gcc
-configure:2651: found /usr/bin/gcc
-configure:2662: result: gcc
-configure:2891: checking for C compiler version
-configure:2900: gcc --version >&5
+configure:2540: checking for xsltproc
+configure:2558: found /opt/anaconda2/bin/xsltproc
+configure:2571: result: /opt/anaconda2/bin/xsltproc
+configure:2652: checking for gcc
+configure:2668: found /usr/bin/gcc
+configure:2679: result: gcc
+configure:2908: checking for C compiler version
+configure:2917: gcc --version >&5
 gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4
 Copyright (C) 2013 Free Software Foundation, Inc.
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-configure:2911: $? = 0
-configure:2900: gcc -v >&5
+configure:2928: $? = 0
+configure:2917: gcc -v >&5
 Using built-in specs.
 COLLECT_GCC=gcc
 COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper
 Target: x86_64-linux-gnu
 Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04.3' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
 Thread model: posix
 gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.3) 
-configure:2911: $? = 0
-configure:2900: gcc -V >&5
+configure:2928: $? = 0
+configure:2917: gcc -V >&5
 gcc: error: unrecognized command line option '-V'
 gcc: fatal error: no input files
 compilation terminated.
-configure:2911: $? = 4
-configure:2900: gcc -qversion >&5
+configure:2928: $? = 4
+configure:2917: gcc -qversion >&5
 gcc: error: unrecognized command line option '-qversion'
 gcc: fatal error: no input files
 compilation terminated.
-configure:2911: $? = 4
-configure:2931: checking whether the C compiler works
-configure:2953: gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:2957: $? = 0
-configure:3005: result: yes
-configure:3008: checking for C compiler default output file name
-configure:3010: result: a.out
-configure:3016: checking for suffix of executables
-configure:3023: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:3027: $? = 0
-configure:3049: result: 
-configure:3071: checking whether we are cross compiling
-configure:3079: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:3083: $? = 0
-configure:3090: ./conftest
-configure:3094: $? = 0
-configure:3109: result: no
-configure:3114: checking for suffix of object files
-configure:3136: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:3140: $? = 0
-configure:3161: result: o
-configure:3165: checking whether we are using the GNU C compiler
-configure:3184: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:3184: $? = 0
-configure:3193: result: yes
-configure:3202: checking whether gcc accepts -g
-configure:3222: gcc -c -g  conftest.c >&5
-configure:3222: $? = 0
-configure:3263: result: yes
-configure:3280: checking for gcc option to accept ISO C89
-configure:3343: gcc  -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:3343: $? = 0
-configure:3356: result: none needed
-configure:3718: checking how to run the C preprocessor
-configure:3749: gcc -E  conftest.c
-configure:3749: $? = 0
-configure:3763: gcc -E  conftest.c
+configure:2928: $? = 4
+configure:2948: checking whether the C compiler works
+configure:2970: gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:2974: $? = 0
+configure:3022: result: yes
+configure:3025: checking for C compiler default output file name
+configure:3027: result: a.out
+configure:3033: checking for suffix of executables
+configure:3040: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:3044: $? = 0
+configure:3066: result: 
+configure:3088: checking whether we are cross compiling
+configure:3096: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:3100: $? = 0
+configure:3107: ./conftest
+configure:3111: $? = 0
+configure:3126: result: no
+configure:3131: checking for suffix of object files
+configure:3153: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:3157: $? = 0
+configure:3178: result: o
+configure:3182: checking whether we are using the GNU C compiler
+configure:3201: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:3201: $? = 0
+configure:3210: result: yes
+configure:3219: checking whether gcc accepts -g
+configure:3239: gcc -c -g  conftest.c >&5
+configure:3239: $? = 0
+configure:3280: result: yes
+configure:3297: checking for gcc option to accept ISO C89
+configure:3360: gcc  -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:3360: $? = 0
+configure:3373: result: none needed
+configure:3807: checking how to run the C preprocessor
+configure:3838: gcc -E  conftest.c
+configure:3838: $? = 0
+configure:3852: gcc -E  conftest.c
 conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
  #include <ac_nonexistent.h>
                             ^
 compilation terminated.
-configure:3763: $? = 1
+configure:3852: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
 | #define PACKAGE_BUGREPORT ""
 | #define PACKAGE_URL ""
 | /* end confdefs.h.  */
 | #include <ac_nonexistent.h>
-configure:3788: result: gcc -E
-configure:3808: gcc -E  conftest.c
-configure:3808: $? = 0
-configure:3822: gcc -E  conftest.c
+configure:3877: result: gcc -E
+configure:3897: gcc -E  conftest.c
+configure:3897: $? = 0
+configure:3911: gcc -E  conftest.c
 conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
  #include <ac_nonexistent.h>
                             ^
 compilation terminated.
-configure:3822: $? = 1
+configure:3911: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
 | #define PACKAGE_BUGREPORT ""
 | #define PACKAGE_URL ""
 | /* end confdefs.h.  */
 | #include <ac_nonexistent.h>
-configure:3852: checking for grep that handles long lines and -e
-configure:3910: result: /bin/grep
-configure:3915: checking for egrep
-configure:3977: result: /bin/grep -E
-configure:3982: checking for ANSI C header files
-configure:4002: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4002: $? = 0
-configure:4075: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4075: $? = 0
-configure:4075: ./conftest
-configure:4075: $? = 0
-configure:4086: result: yes
-configure:4099: checking for sys/types.h
-configure:4099: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4099: $? = 0
-configure:4099: result: yes
-configure:4099: checking for sys/stat.h
-configure:4099: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4099: $? = 0
-configure:4099: result: yes
-configure:4099: checking for stdlib.h
-configure:4099: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4099: $? = 0
-configure:4099: result: yes
-configure:4099: checking for string.h
-configure:4099: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4099: $? = 0
-configure:4099: result: yes
-configure:4099: checking for memory.h
-configure:4099: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4099: $? = 0
-configure:4099: result: yes
-configure:4099: checking for strings.h
-configure:4099: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4099: $? = 0
-configure:4099: result: yes
-configure:4099: checking for inttypes.h
-configure:4099: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4099: $? = 0
-configure:4099: result: yes
-configure:4099: checking for stdint.h
-configure:4099: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4099: $? = 0
-configure:4099: result: yes
-configure:4099: checking for unistd.h
-configure:4099: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4099: $? = 0
-configure:4099: result: yes
-configure:4111: checking whether byte ordering is bigendian
-configure:4126: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:3941: checking for grep that handles long lines and -e
+configure:3999: result: /bin/grep
+configure:4004: checking for egrep
+configure:4066: result: /bin/grep -E
+configure:4071: checking for ANSI C header files
+configure:4091: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4091: $? = 0
+configure:4164: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4164: $? = 0
+configure:4164: ./conftest
+configure:4164: $? = 0
+configure:4175: result: yes
+configure:4188: checking for sys/types.h
+configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4188: $? = 0
+configure:4188: result: yes
+configure:4188: checking for sys/stat.h
+configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4188: $? = 0
+configure:4188: result: yes
+configure:4188: checking for stdlib.h
+configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4188: $? = 0
+configure:4188: result: yes
+configure:4188: checking for string.h
+configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4188: $? = 0
+configure:4188: result: yes
+configure:4188: checking for memory.h
+configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4188: $? = 0
+configure:4188: result: yes
+configure:4188: checking for strings.h
+configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4188: $? = 0
+configure:4188: result: yes
+configure:4188: checking for inttypes.h
+configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4188: $? = 0
+configure:4188: result: yes
+configure:4188: checking for stdint.h
+configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4188: $? = 0
+configure:4188: result: yes
+configure:4188: checking for unistd.h
+configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4188: $? = 0
+configure:4188: result: yes
+configure:4200: checking whether byte ordering is bigendian
+configure:4215: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
 conftest.c:20:9: error: unknown type name 'not'
          not a universal capable compiler
          ^
 conftest.c:20:15: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'universal'
          not a universal capable compiler
                ^
 conftest.c:20:15: error: unknown type name 'universal'
-configure:4126: $? = 1
+configure:4215: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -225,23 +225,23 @@
 | /* end confdefs.h.  */
 | #ifndef __APPLE_CC__
 | 	       not a universal capable compiler
 | 	     #endif
 | 	     typedef int dummy;
 | 
-configure:4171: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4171: $? = 0
-configure:4189: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4260: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4260: $? = 0
+configure:4278: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
 conftest.c: In function 'main':
 conftest.c:26:4: error: unknown type name 'not'
     not big endian
     ^
 conftest.c:26:12: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'endian'
     not big endian
             ^
-configure:4189: $? = 1
+configure:4278: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -268,72 +268,68 @@
 | 		 not big endian
 | 		#endif
 | 
 |   ;
 |   return 0;
 | }
-configure:4317: result: no
-configure:4345: checking size of void *
-configure:4350: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4350: $? = 0
-configure:4350: ./conftest
-configure:4350: $? = 0
-configure:4364: result: 8
-configure:4390: checking size of int
-configure:4395: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4395: $? = 0
-configure:4395: ./conftest
-configure:4395: $? = 0
-configure:4409: result: 4
-configure:4435: checking size of long
-configure:4440: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4440: $? = 0
-configure:4440: ./conftest
-configure:4440: $? = 0
-configure:4454: result: 8
-configure:4480: checking size of intmax_t
-configure:4485: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4485: $? = 0
-configure:4485: ./conftest
-configure:4485: $? = 0
-configure:4499: result: 8
-configure:4556: checking build system type
-configure:4570: result: x86_64-unknown-linux-gnu
-configure:4590: checking host system type
-configure:4603: result: x86_64-unknown-linux-gnu
-configure:4629: checking whether pause instruction is compilable
-configure:4645: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4645: $? = 0
-configure:4653: result: yes
-configure:4660: checking whether SSE2 intrinsics is compilable
-configure:4678: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4678: $? = 0
-configure:4686: result: yes
-configure:4774: checking for ar
-configure:4790: found /usr/bin/ar
-configure:4801: result: ar
-configure:4963: checking whether __attribute__ syntax is compilable
-configure:4979: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE  conftest.c  >&5
-configure:4979: $? = 0
-configure:4987: result: yes
-configure:4995: checking whether compiler supports -fvisibility=hidden
-configure:5017: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE conftest.c >&5
-configure:5017: $? = 0
-configure:5019: result: yes
-configure:5034: checking whether compiler supports -Werror
-configure:5056: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
-configure:5056: $? = 0
-configure:5058: result: yes
-configure:5070: checking whether tls_model attribute is compilable
-configure:5088: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c  >&5
-conftest.c: In function 'main':
-conftest.c:39:59: error: variable 'foo' set but not used [-Werror=unused-but-set-variable]
-                __attribute__((tls_model("initial-exec"))) foo;
-                                                           ^
-cc1: all warnings being treated as errors
-configure:5088: $? = 1
+configure:4406: result: no
+configure:4438: checking size of void *
+configure:4443: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4443: $? = 0
+configure:4443: ./conftest
+configure:4443: $? = 0
+configure:4457: result: 8
+configure:4483: checking size of int
+configure:4488: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4488: $? = 0
+configure:4488: ./conftest
+configure:4488: $? = 0
+configure:4502: result: 4
+configure:4528: checking size of long
+configure:4533: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4533: $? = 0
+configure:4533: ./conftest
+configure:4533: $? = 0
+configure:4547: result: 8
+configure:4573: checking size of intmax_t
+configure:4578: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4578: $? = 0
+configure:4578: ./conftest
+configure:4578: $? = 0
+configure:4592: result: 8
+configure:4649: checking build system type
+configure:4663: result: x86_64-unknown-linux-gnu
+configure:4683: checking host system type
+configure:4696: result: x86_64-unknown-linux-gnu
+configure:4723: checking whether pause instruction is compilable
+configure:4739: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4739: $? = 0
+configure:4747: result: yes
+configure:4834: checking for ar
+configure:4850: found /usr/bin/ar
+configure:4861: result: ar
+configure:5024: checking malloc.h usability
+configure:5024: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE conftest.c >&5
+configure:5024: $? = 0
+configure:5024: result: yes
+configure:5024: checking malloc.h presence
+configure:5024: gcc -E  -D_GNU_SOURCE conftest.c
+configure:5024: $? = 0
+configure:5024: result: yes
+configure:5024: checking for malloc.h
+configure:5024: result: yes
+configure:5030: checking whether malloc_usable_size definition can use const argument
+configure:5046: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE conftest.c >&5
+conftest.c:35:12: error: conflicting types for 'malloc_usable_size'
+     size_t malloc_usable_size(const void *ptr);
+            ^
+In file included from conftest.c:33:0:
+/usr/include/malloc.h:129:15: note: previous declaration of 'malloc_usable_size' was here
+ extern size_t malloc_usable_size (void *__ptr) __THROW;
+               ^
+configure:5046: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -354,63 +350,103 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
-| #define JEMALLOC_USABLE_SIZE_CONST 
-| #define JEMALLOC_HAVE_ATTR  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | /* end confdefs.h.  */
+| #include <malloc.h>
+|      #include <stddef.h>
+|     size_t malloc_usable_size(const void *ptr);
 | 
 | int
 | main ()
 | {
-| static __thread int
-|                __attribute__((tls_model("initial-exec"))) foo;
-|                foo = 0;
+| 
 |   ;
 |   return 0;
 | }
-configure:5096: result: no
-configure:5152: checking for a BSD-compatible install
-configure:5220: result: /usr/bin/install -c
-configure:5274: checking for ranlib
-configure:5290: found /usr/bin/ranlib
-configure:5301: result: ranlib
-configure:5325: checking for ld
-configure:5343: found /usr/bin/ld
-configure:5356: result: /usr/bin/ld
-configure:5366: checking for autoconf
-configure:5384: found /usr/bin/autoconf
-configure:5397: result: /usr/bin/autoconf
-configure:5408: checking for memalign
-configure:5408: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-configure:5408: $? = 0
-configure:5408: result: yes
-configure:5415: checking for valloc
-configure:5415: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-configure:5415: $? = 0
-configure:5415: result: yes
-configure:6166: checking configured backtracing method
-configure:6168: result: N/A
-configure:6293: checking for sbrk
-configure:6293: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-configure:6293: $? = 0
-configure:6293: result: yes
-configure:6352: checking whether utrace(2) is compilable
-configure:6376: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-conftest.c:51:24: fatal error: sys/ktrace.h: No such file or directory
+configure:5054: result: no
+configure:5089: checking whether __attribute__ syntax is compilable
+configure:5105: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE  conftest.c  >&5
+configure:5105: $? = 0
+configure:5113: result: yes
+configure:5121: checking whether compiler supports -fvisibility=hidden
+configure:5143: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE conftest.c >&5
+configure:5143: $? = 0
+configure:5145: result: yes
+configure:5160: checking whether compiler supports -Werror
+configure:5182: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
+configure:5182: $? = 0
+configure:5184: result: yes
+configure:5196: checking whether tls_model attribute is compilable
+configure:5214: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c  >&5
+configure:5214: $? = 0
+configure:5222: result: yes
+configure:5235: checking whether compiler supports -Werror
+configure:5257: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
+configure:5257: $? = 0
+configure:5259: result: yes
+configure:5271: checking whether alloc_size attribute is compilable
+configure:5287: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c  >&5
+configure:5287: $? = 0
+configure:5295: result: yes
+configure:5305: checking whether compiler supports -Werror
+configure:5327: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
+configure:5327: $? = 0
+configure:5329: result: yes
+configure:5341: checking whether format(gnu_printf, ...) attribute is compilable
+configure:5357: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c  >&5
+configure:5357: $? = 0
+configure:5365: result: yes
+configure:5375: checking whether compiler supports -Werror
+configure:5397: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
+configure:5397: $? = 0
+configure:5399: result: yes
+configure:5411: checking whether format(printf, ...) attribute is compilable
+configure:5427: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c  >&5
+configure:5427: $? = 0
+configure:5435: result: yes
+configure:5488: checking for a BSD-compatible install
+configure:5556: result: /usr/bin/install -c
+configure:5610: checking for ranlib
+configure:5626: found /usr/bin/ranlib
+configure:5637: result: ranlib
+configure:5661: checking for ld
+configure:5679: found /usr/bin/ld
+configure:5692: result: /usr/bin/ld
+configure:5702: checking for autoconf
+configure:5720: found /usr/bin/autoconf
+configure:5733: result: /usr/bin/autoconf
+configure:5744: checking for memalign
+configure:5744: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
+configure:5744: $? = 0
+configure:5744: result: yes
+configure:5751: checking for valloc
+configure:5751: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
+configure:5751: $? = 0
+configure:5751: result: yes
+configure:6493: checking configured backtracing method
+configure:6495: result: N/A
+configure:6551: checking for sbrk
+configure:6551: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
+configure:6551: $? = 0
+configure:6551: result: yes
+configure:6606: checking whether utrace(2) is compilable
+configure:6630: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
+conftest.c:55:24: fatal error: sys/ktrace.h: No such file or directory
  #include <sys/ktrace.h>
                         ^
 compilation terminated.
-configure:6376: $? = 1
+configure:6630: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -431,30 +467,34 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | /* end confdefs.h.  */
 | 
 | #include <sys/types.h>
 | #include <sys/param.h>
 | #include <sys/time.h>
@@ -467,20 +507,20 @@
 | 
 | 	utrace((void *)0, 0);
 | 
 |   ;
 |   return 0;
 | }
-configure:6384: result: no
-configure:6411: checking whether valgrind is compilable
-configure:6434: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-conftest.c:47:31: fatal error: valgrind/valgrind.h: No such file or directory
+configure:6638: result: no
+configure:6665: checking whether valgrind is compilable
+configure:6688: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
+conftest.c:51:31: fatal error: valgrind/valgrind.h: No such file or directory
  #include <valgrind/valgrind.h>
                                ^
 compilation terminated.
-configure:6434: $? = 1
+configure:6688: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -501,30 +541,34 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | /* end confdefs.h.  */
 | 
 | #include <valgrind/valgrind.h>
 | #include <valgrind/memcheck.h>
 | 
@@ -536,43 +580,51 @@
 | main ()
 | {
 | 
 |   ;
 |   return 0;
 | }
-configure:6442: result: no
-configure:6474: checking STATIC_PAGE_SHIFT
-configure:6528: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-conftest.c: In function 'main':
-conftest.c:72:5: warning: implicit declaration of function 'ffsl' [-Wimplicit-function-declaration]
-     result = ffsl(result) - 1;
-     ^
-configure:6528: $? = 0
-configure:6528: ./conftest
-configure:6528: $? = 0
-configure:6538: result: 12
-configure:6571: checking pthread.h usability
-configure:6571: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE conftest.c >&5
-configure:6571: $? = 0
-configure:6571: result: yes
-configure:6571: checking pthread.h presence
-configure:6571: gcc -E  -D_GNU_SOURCE conftest.c
-configure:6571: $? = 0
-configure:6571: result: yes
-configure:6571: checking for pthread.h
-configure:6571: result: yes
-configure:6583: checking for pthread_create in -lpthread
-configure:6608: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lpthread   >&5
-configure:6608: $? = 0
-configure:6617: result: yes
-configure:6686: checking for _malloc_thread_cleanup
-configure:6686: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-/tmp/cca261Xs.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c:82: undefined reference to `_malloc_thread_cleanup'
+configure:6696: result: no
+configure:6748: checking whether a program using __builtin_ffsl is compilable
+configure:6773: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
+configure:6773: $? = 0
+configure:6781: result: yes
+configure:6874: checking LG_PAGE
+configure:6925: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
+configure:6925: $? = 0
+configure:6925: ./conftest
+configure:6925: $? = 0
+configure:6935: result: 12
+configure:6994: checking pthread.h usability
+configure:6994: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE conftest.c >&5
+configure:6994: $? = 0
+configure:6994: result: yes
+configure:6994: checking pthread.h presence
+configure:6994: gcc -E  -D_GNU_SOURCE conftest.c
+configure:6994: $? = 0
+configure:6994: result: yes
+configure:6994: checking for pthread.h
+configure:6994: result: yes
+configure:7006: checking for pthread_create in -lpthread
+configure:7031: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lpthread   >&5
+configure:7031: $? = 0
+configure:7040: result: yes
+configure:7111: checking for library containing clock_gettime
+configure:7142: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  >&5
+configure:7142: $? = 0
+configure:7159: result: none required
+configure:7170: checking for secure_getenv
+configure:7170: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:7170: $? = 0
+configure:7170: result: yes
+configure:7183: checking for issetugid
+configure:7183: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+/tmp/ccqlPr9L.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c:91: undefined reference to `issetugid'
 collect2: error: ld returned 1 exit status
-configure:6686: $? = 1
+configure:7183: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -593,33 +645,144 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
-| #define STATIC_PAGE_SHIFT 12
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
+| /* end confdefs.h.  */
+| /* Define issetugid to an innocuous variant, in case <limits.h> declares issetugid.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define issetugid innocuous_issetugid
+| 
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char issetugid (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+| 
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+| 
+| #undef issetugid
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char issetugid ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined __stub_issetugid || defined __stub___issetugid
+| choke me
+| #endif
+| 
+| int
+| main ()
+| {
+| return issetugid ();
+|   ;
+|   return 0;
+| }
+configure:7183: result: no
+configure:7196: checking for _malloc_thread_cleanup
+configure:7196: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+/tmp/cclhu6LO.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c:91: undefined reference to `_malloc_thread_cleanup'
+collect2: error: ld returned 1 exit status
+configure:7196: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| #define JEMALLOC_HAVE_ATTR  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
+| #define JEMALLOC_OVERRIDE_MEMALIGN  
+| #define JEMALLOC_OVERRIDE_VALLOC  
+| #define JEMALLOC_PREFIX "je_"
+| #define JEMALLOC_CPREFIX "JE_"
+| #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CC_SILENCE  
+| #define JEMALLOC_STATS  
+| #define JEMALLOC_TCACHE  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
+| #define JEMALLOC_FILL  
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
+| #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
 | /* end confdefs.h.  */
 | /* Define _malloc_thread_cleanup to an innocuous variant, in case <limits.h> declares _malloc_thread_cleanup.
 |    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
 | #define _malloc_thread_cleanup innocuous__malloc_thread_cleanup
 | 
 | /* System header to define __stub macros and hopefully few prototypes,
@@ -653,19 +816,19 @@
 | main ()
 | {
 | return _malloc_thread_cleanup ();
 |   ;
 |   return 0;
 | }
-configure:6686: result: no
-configure:6700: checking for _pthread_mutex_init_calloc_cb
-configure:6700: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-/tmp/ccWWV1Fu.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c:82: undefined reference to `_pthread_mutex_init_calloc_cb'
+configure:7196: result: no
+configure:7210: checking for _pthread_mutex_init_calloc_cb
+configure:7210: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+/tmp/ccvzNlwQ.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c:91: undefined reference to `_pthread_mutex_init_calloc_cb'
 collect2: error: ld returned 1 exit status
-configure:6700: $? = 1
+configure:7210: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -686,33 +849,42 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
-| #define STATIC_PAGE_SHIFT 12
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
 | /* end confdefs.h.  */
 | /* Define _pthread_mutex_init_calloc_cb to an innocuous variant, in case <limits.h> declares _pthread_mutex_init_calloc_cb.
 |    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
 | #define _pthread_mutex_init_calloc_cb innocuous__pthread_mutex_init_calloc_cb
 | 
 | /* System header to define __stub macros and hopefully few prototypes,
@@ -746,28 +918,118 @@
 | main ()
 | {
 | return _pthread_mutex_init_calloc_cb ();
 |   ;
 |   return 0;
 | }
-configure:6700: result: no
-configure:6826: checking for TLS
-configure:6845: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
-configure:6845: $? = 0
-configure:6846: result: yes
-configure:6866: checking whether a program using ffsl is compilable
-configure:6891: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-configure:6891: $? = 0
-configure:6899: result: yes
-configure:6908: checking whether atomic(9) is compilable
-configure:6939: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-conftest.c:51:28: fatal error: machine/atomic.h: No such file or directory
+configure:7210: result: no
+configure:7341: checking for TLS
+configure:7360: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
+configure:7360: $? = 0
+configure:7361: result: yes
+configure:7389: checking whether C11 atomics is compilable
+configure:7418: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+conftest.c:63:2: error: #error Atomics not available
+ #error Atomics not available
+  ^
+conftest.c: In function 'main':
+conftest.c:72:5: error: unknown type name 'atomic_uint_least64_t'
+     volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;
+     ^
+conftest.c:72:5: error: unknown type name 'atomic_uint_least64_t'
+conftest.c:73:5: warning: implicit declaration of function 'atomic_fetch_add' [-Wimplicit-function-declaration]
+     uint64_t r = atomic_fetch_add(a, x) + x;
+     ^
+configure:7418: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| #define JEMALLOC_HAVE_ATTR  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
+| #define JEMALLOC_OVERRIDE_MEMALIGN  
+| #define JEMALLOC_OVERRIDE_VALLOC  
+| #define JEMALLOC_PREFIX "je_"
+| #define JEMALLOC_CPREFIX "JE_"
+| #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CC_SILENCE  
+| #define JEMALLOC_STATS  
+| #define JEMALLOC_TCACHE  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
+| #define JEMALLOC_FILL  
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
+| #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
+| #define JEMALLOC_TLS
+| /* end confdefs.h.  */
+| 
+| #include <stdint.h>
+| #if (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__)
+| #include <stdatomic.h>
+| #else
+| #error Atomics not available
+| #endif
+| 
+| int
+| main ()
+| {
+| 
+|     uint64_t *p = (uint64_t *)0;
+|     uint64_t x = 1;
+|     volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;
+|     uint64_t r = atomic_fetch_add(a, x) + x;
+|     return (r == 0);
+| 
+|   ;
+|   return 0;
+| }
+configure:7426: result: no
+configure:7436: checking whether atomic(9) is compilable
+configure:7467: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+conftest.c:60:28: fatal error: machine/atomic.h: No such file or directory
  #include <machine/atomic.h>
                             ^
 compilation terminated.
-configure:6939: $? = 1
+configure:7467: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -788,33 +1050,42 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
-| #define STATIC_PAGE_SHIFT 12
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
 | /* end confdefs.h.  */
 | 
 | #include <sys/types.h>
 | #include <machine/atomic.h>
 | #include <inttypes.h>
@@ -834,20 +1105,20 @@
 | 		atomic_fetchadd_long(xlongp, 1);
 | 	}
 | 
 |   ;
 |   return 0;
 | }
-configure:6947: result: no
-configure:6957: checking whether Darwin OSAtomic*() is compilable
-configure:6987: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-conftest.c:50:30: fatal error: libkern/OSAtomic.h: No such file or directory
+configure:7475: result: no
+configure:7485: checking whether Darwin OSAtomic*() is compilable
+configure:7515: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+conftest.c:59:30: fatal error: libkern/OSAtomic.h: No such file or directory
  #include <libkern/OSAtomic.h>
                               ^
 compilation terminated.
-configure:6987: $? = 1
+configure:7515: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -868,33 +1139,42 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
-| #define STATIC_PAGE_SHIFT 12
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
 | /* end confdefs.h.  */
 | 
 | #include <libkern/OSAtomic.h>
 | #include <inttypes.h>
 | 
@@ -913,20 +1193,24 @@
 | 		OSAtomicAdd64(1, x64p);
 | 	}
 | 
 |   ;
 |   return 0;
 | }
-configure:6995: result: no
-configure:7008: checking whether to force 32-bit __sync_{add,sub}_and_fetch()
-configure:7036: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:7523: result: no
+configure:7533: checking whether madvise(2) is compilable
+configure:7555: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:7555: $? = 0
+configure:7563: result: yes
+configure:7576: checking whether to force 32-bit __sync_{add,sub}_and_fetch()
+configure:7604: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
 conftest.c: In function 'main':
-conftest.c:63:51: error: #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 is defined, no need to force
+conftest.c:73:51: error: #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 is defined, no need to force
                                                   #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 is defined, no need to force
                                                    ^
-configure:7036: $? = 1
+configure:7604: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -947,34 +1231,44 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
-| #define STATIC_PAGE_SHIFT 12
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
+| #define JEMALLOC_HAVE_MADVISE  
 | /* end confdefs.h.  */
 | 
 |                                                  #include <stdint.h>
 | 
 | int
 | main ()
@@ -990,20 +1284,20 @@
 |                                                  #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 is defined, no need to force
 |                                                  #endif
 | 
 |   ;
 |   return 0;
 | }
-configure:7044: result: no
-configure:7053: checking whether to force 64-bit __sync_{add,sub}_and_fetch()
-configure:7081: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:7612: result: no
+configure:7621: checking whether to force 64-bit __sync_{add,sub}_and_fetch()
+configure:7649: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
 conftest.c: In function 'main':
-conftest.c:63:51: error: #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 is defined, no need to force
+conftest.c:73:51: error: #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 is defined, no need to force
                                                   #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 is defined, no need to force
                                                    ^
-configure:7081: $? = 1
+configure:7649: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -1024,34 +1318,44 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
-| #define STATIC_PAGE_SHIFT 12
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
+| #define JEMALLOC_HAVE_MADVISE  
 | /* end confdefs.h.  */
 | 
 |                                                  #include <stdint.h>
 | 
 | int
 | main ()
@@ -1067,20 +1371,31 @@
 |                                                  #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 is defined, no need to force
 |                                                  #endif
 | 
 |   ;
 |   return 0;
 | }
-configure:7089: result: no
-configure:7101: checking whether Darwin OSSpin*() is compilable
-configure:7124: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-conftest.c:50:30: fatal error: libkern/OSAtomic.h: No such file or directory
+configure:7657: result: no
+configure:7668: checking for __builtin_clz
+configure:7693: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+conftest.c: In function 'main':
+conftest.c:66:61: warning: unused variable 'y' [-Wunused-variable]
+                                                         int y = __builtin_clz(x);
+                                                             ^
+conftest.c:70:61: warning: unused variable 'y' [-Wunused-variable]
+                                                         int y = __builtin_clzl(x);
+                                                             ^
+configure:7693: $? = 0
+configure:7701: result: yes
+configure:7711: checking whether Darwin OSSpin*() is compilable
+configure:7734: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+conftest.c:61:30: fatal error: libkern/OSAtomic.h: No such file or directory
  #include <libkern/OSAtomic.h>
                               ^
 compilation terminated.
-configure:7124: $? = 1
+configure:7734: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -1101,34 +1416,45 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
-| #define STATIC_PAGE_SHIFT 12
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
+| #define JEMALLOC_HAVE_MADVISE  
+| #define JEMALLOC_HAVE_BUILTIN_CLZ  
 | /* end confdefs.h.  */
 | 
 | #include <libkern/OSAtomic.h>
 | #include <inttypes.h>
 | 
 | int
@@ -1139,60 +1465,76 @@
 | 	OSSpinLockLock(&lock);
 | 	OSSpinLockUnlock(&lock);
 | 
 |   ;
 |   return 0;
 | }
-configure:7132: result: no
-configure:7319: checking for stdbool.h that conforms to C99
-configure:7386: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
+configure:7742: result: no
+configure:7929: checking whether glibc malloc hook is compilable
+configure:7956: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:7956: $? = 0
+configure:7964: result: yes
+configure:7973: checking whether glibc memalign hook is compilable
+configure:7996: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+conftest.c: In function 'main':
+conftest.c:70:9: warning: variable 'ptr' set but not used [-Wunused-but-set-variable]
+   void *ptr = 0L;
+         ^
+configure:7996: $? = 0
+configure:8004: result: yes
+configure:8013: checking whether pthreads adaptive mutexes is compilable
+configure:8036: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:8036: $? = 0
+configure:8044: result: yes
+configure:8052: checking for stdbool.h that conforms to C99
+configure:8119: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
 conftest.c: In function 'main':
-conftest.c:98:14: warning: the address of 's' will always evaluate as 'true' [-Waddress]
+conftest.c:112:14: warning: the address of 's' will always evaluate as 'true' [-Waddress]
               bool e = &s;
               ^
-conftest.c:102:22: warning: the address of 'a' will always evaluate as 'true' [-Waddress]
+conftest.c:116:22: warning: the address of 'a' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                       ^
-conftest.c:102:27: warning: the address of 'b' will always evaluate as 'true' [-Waddress]
+conftest.c:116:27: warning: the address of 'b' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                            ^
-conftest.c:102:32: warning: the address of 'c' will always evaluate as 'true' [-Waddress]
+conftest.c:116:32: warning: the address of 'c' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                 ^
-conftest.c:102:37: warning: the address of 'd' will always evaluate as 'true' [-Waddress]
+conftest.c:116:37: warning: the address of 'd' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                      ^
-conftest.c:102:47: warning: the address of 'f' will always evaluate as 'true' [-Waddress]
+conftest.c:116:47: warning: the address of 'f' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                                ^
-conftest.c:102:52: warning: the address of 'g' will always evaluate as 'true' [-Waddress]
+conftest.c:116:52: warning: the address of 'g' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                                     ^
-conftest.c:102:57: warning: the address of 'h' will always evaluate as 'true' [-Waddress]
+conftest.c:116:57: warning: the address of 'h' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                                          ^
-conftest.c:102:62: warning: the address of 'i' will always evaluate as 'true' [-Waddress]
+conftest.c:116:62: warning: the address of 'i' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                                               ^
-conftest.c:103:29: warning: the address of 'n' will always evaluate as 'true' [-Waddress]
+conftest.c:117:29: warning: the address of 'n' will always evaluate as 'true' [-Waddress]
                              ^
-conftest.c:103:34: warning: the address of 'o' will always evaluate as 'true' [-Waddress]
+conftest.c:117:34: warning: the address of 'o' will always evaluate as 'true' [-Waddress]
                                   ^
-conftest.c:103:39: warning: the address of 'p' will always evaluate as 'true' [-Waddress]
+conftest.c:117:39: warning: the address of 'p' will always evaluate as 'true' [-Waddress]
                                        ^
-configure:7386: $? = 0
-configure:7393: result: yes
-configure:7395: checking for _Bool
-configure:7395: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
-configure:7395: $? = 0
-configure:7395: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
+configure:8119: $? = 0
+configure:8126: result: yes
+configure:8128: checking for _Bool
+configure:8128: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
+configure:8128: $? = 0
+configure:8128: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
 conftest.c: In function 'main':
-conftest.c:85:20: error: expected expression before ')' token
+conftest.c:99:20: error: expected expression before ')' token
  if (sizeof ((_Bool)))
                     ^
-configure:7395: $? = 1
+configure:8128: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -1213,34 +1555,48 @@
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
-| #define HAVE_SSE2
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
 | #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 | #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
-| #define JEMALLOC_TLS_MODEL  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
-| #define JEMALLOC_EXPERIMENTAL  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
-| #define JEMALLOC_HAVE_SBRK  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
-| #define STATIC_PAGE_SHIFT 12
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
+| #define JEMALLOC_HAVE_MADVISE  
+| #define JEMALLOC_HAVE_BUILTIN_CLZ  
+| #define JEMALLOC_GLIBC_MALLOC_HOOK  
+| #define JEMALLOC_GLIBC_MEMALIGN_HOOK  
+| #define JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP  
 | /* end confdefs.h.  */
 | #include <stdio.h>
 | #ifdef HAVE_SYS_TYPES_H
 | # include <sys/types.h>
 | #endif
 | #ifdef HAVE_SYS_STAT_H
@@ -1277,14 +1633,14 @@
 | {
 | if (sizeof ((_Bool)))
 | 	    return 0;
 |   ;
 |   return 0;
 | }
-configure:7395: result: yes
-configure:7562: creating ./config.status
+configure:8128: result: yes
+configure:8295: creating ./config.status
 
 ## ---------------------- ##
 ## Running config.status. ##
 ## ---------------------- ##
 
 This file was extended by config.status, which was
@@ -1295,89 +1651,93 @@
   CONFIG_LINKS    = 
   CONFIG_COMMANDS = 
   $ ./config.status 
 
 on sarah-Erazer-X310
 
-config.status:986: creating Makefile
-config.status:986: creating doc/html.xsl
-config.status:986: creating doc/manpages.xsl
-config.status:986: creating doc/jemalloc.xml
-config.status:986: creating include/jemalloc/jemalloc_macros.h
-config.status:986: creating include/jemalloc/jemalloc_protos.h
-config.status:986: creating include/jemalloc/internal/jemalloc_internal.h
-config.status:986: creating test/test.sh
-config.status:986: creating test/include/test/jemalloc_test.h
-config.status:986: creating config.stamp
-config.status:986: creating bin/jemalloc.sh
-config.status:986: creating include/jemalloc/jemalloc_defs.h
-config.status:986: creating include/jemalloc/internal/jemalloc_internal_defs.h
-config.status:986: creating test/include/test/jemalloc_test_defs.h
-config.status:1175: executing include/jemalloc/internal/private_namespace.h commands
-config.status:1175: executing include/jemalloc/internal/private_unnamespace.h commands
-config.status:1175: executing include/jemalloc/internal/public_symbols.txt commands
-config.status:1175: executing include/jemalloc/internal/public_namespace.h commands
-config.status:1175: executing include/jemalloc/internal/public_unnamespace.h commands
-config.status:1175: executing include/jemalloc/internal/size_classes.h commands
-config.status:1175: executing include/jemalloc/jemalloc_protos_jet.h commands
-config.status:1175: executing include/jemalloc/jemalloc_rename.h commands
-config.status:1175: executing include/jemalloc/jemalloc_mangle.h commands
-config.status:1175: executing include/jemalloc/jemalloc_mangle_jet.h commands
-config.status:1175: executing include/jemalloc/jemalloc.h commands
-configure:8859: result: ===============================================================================
-configure:8861: result: jemalloc version   : 3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340
-configure:8863: result: library revision   : 1
-configure:8865: result: 
-configure:8867: result: CC                 : gcc
-configure:8869: result: CPPFLAGS           :  -D_GNU_SOURCE -D_REENTRANT
-configure:8871: result: CFLAGS             : -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden
-configure:8873: result: LDFLAGS            : 
-configure:8875: result: EXTRA_LDFLAGS      : 
-configure:8877: result: LIBS               :  -lpthread
-configure:8879: result: RPATH_EXTRA        : 
-configure:8881: result: 
-configure:8883: result: XSLTPROC           : /opt/anaconda2/bin/xsltproc
-configure:8885: result: XSLROOT            : /usr/share/xml/docbook/stylesheet/docbook-xsl
-configure:8887: result: 
-configure:8889: result: PREFIX             : /usr/local
-configure:8891: result: BINDIR             : /usr/local/bin
-configure:8893: result: INCLUDEDIR         : /usr/local/include
-configure:8895: result: LIBDIR             : /usr/local/lib
-configure:8897: result: DATADIR            : /usr/local/share
-configure:8899: result: MANDIR             : /usr/local/share/man
-configure:8901: result: 
-configure:8903: result: srcroot            : 
-configure:8905: result: abs_srcroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/
-configure:8907: result: objroot            : 
-configure:8909: result: abs_objroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/
-configure:8911: result: 
-configure:8913: result: JEMALLOC_PREFIX    : je_
-configure:8915: result: JEMALLOC_PRIVATE_NAMESPACE
-configure:8917: result:                    : je_
-configure:8919: result: install_suffix     : 
-configure:8921: result: autogen            : 0
-configure:8923: result: experimental       : 1
-configure:8925: result: cc-silence         : 1
-configure:8927: result: debug              : 0
-configure:8929: result: code-coverage      : 0
-configure:8931: result: stats              : 1
-configure:8933: result: prof               : 0
-configure:8935: result: prof-libunwind     : 0
-configure:8937: result: prof-libgcc        : 0
-configure:8939: result: prof-gcc           : 0
-configure:8941: result: tcache             : 1
-configure:8943: result: fill               : 1
-configure:8945: result: utrace             : 0
-configure:8947: result: valgrind           : 0
-configure:8949: result: xmalloc            : 0
-configure:8951: result: mremap             : 0
-configure:8953: result: munmap             : 0
-configure:8955: result: dss                : 0
-configure:8957: result: lazy_lock          : 0
-configure:8959: result: tls                : 1
-configure:8961: result: ===============================================================================
+config.status:1009: creating Makefile
+config.status:1009: creating jemalloc.pc
+config.status:1009: creating doc/html.xsl
+config.status:1009: creating doc/manpages.xsl
+config.status:1009: creating doc/jemalloc.xml
+config.status:1009: creating include/jemalloc/jemalloc_macros.h
+config.status:1009: creating include/jemalloc/jemalloc_protos.h
+config.status:1009: creating include/jemalloc/jemalloc_typedefs.h
+config.status:1009: creating include/jemalloc/internal/jemalloc_internal.h
+config.status:1009: creating test/test.sh
+config.status:1009: creating test/include/test/jemalloc_test.h
+config.status:1009: creating config.stamp
+config.status:1009: creating bin/jemalloc-config
+config.status:1009: creating bin/jemalloc.sh
+config.status:1009: creating bin/jeprof
+config.status:1009: creating include/jemalloc/jemalloc_defs.h
+config.status:1009: creating include/jemalloc/internal/jemalloc_internal_defs.h
+config.status:1009: creating test/include/test/jemalloc_test_defs.h
+config.status:1198: executing include/jemalloc/internal/private_namespace.h commands
+config.status:1198: executing include/jemalloc/internal/private_unnamespace.h commands
+config.status:1198: executing include/jemalloc/internal/public_symbols.txt commands
+config.status:1198: executing include/jemalloc/internal/public_namespace.h commands
+config.status:1198: executing include/jemalloc/internal/public_unnamespace.h commands
+config.status:1198: executing include/jemalloc/internal/size_classes.h commands
+config.status:1198: executing include/jemalloc/jemalloc_protos_jet.h commands
+config.status:1198: executing include/jemalloc/jemalloc_rename.h commands
+config.status:1198: executing include/jemalloc/jemalloc_mangle.h commands
+config.status:1198: executing include/jemalloc/jemalloc_mangle_jet.h commands
+config.status:1198: executing include/jemalloc/jemalloc.h commands
+configure:9599: result: ===============================================================================
+configure:9601: result: jemalloc version   : 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c
+configure:9603: result: library revision   : 2
+configure:9605: result: 
+configure:9607: result: CONFIG             : --with-jemalloc-prefix=je_ --enable-cc-silence 'CFLAGS=-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops ' LDFLAGS=
+configure:9609: result: CC                 : gcc
+configure:9611: result: CFLAGS             : -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden
+configure:9613: result: CPPFLAGS           :  -D_GNU_SOURCE -D_REENTRANT
+configure:9615: result: LDFLAGS            : 
+configure:9617: result: EXTRA_LDFLAGS      : 
+configure:9619: result: LIBS               :  -lpthread
+configure:9621: result: TESTLIBS           : 
+configure:9623: result: RPATH_EXTRA        : 
+configure:9625: result: 
+configure:9627: result: XSLTPROC           : /opt/anaconda2/bin/xsltproc
+configure:9629: result: XSLROOT            : /usr/share/xml/docbook/stylesheet/docbook-xsl
+configure:9631: result: 
+configure:9633: result: PREFIX             : /usr/local
+configure:9635: result: BINDIR             : /usr/local/bin
+configure:9637: result: DATADIR            : /usr/local/share
+configure:9639: result: INCLUDEDIR         : /usr/local/include
+configure:9641: result: LIBDIR             : /usr/local/lib
+configure:9643: result: MANDIR             : /usr/local/share/man
+configure:9645: result: 
+configure:9647: result: srcroot            : 
+configure:9649: result: abs_srcroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/
+configure:9651: result: objroot            : 
+configure:9653: result: abs_objroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/
+configure:9655: result: 
+configure:9657: result: JEMALLOC_PREFIX    : je_
+configure:9659: result: JEMALLOC_PRIVATE_NAMESPACE
+configure:9661: result:                    : je_
+configure:9663: result: install_suffix     : 
+configure:9665: result: autogen            : 0
+configure:9667: result: cc-silence         : 1
+configure:9669: result: debug              : 0
+configure:9671: result: code-coverage      : 0
+configure:9673: result: stats              : 1
+configure:9675: result: prof               : 0
+configure:9677: result: prof-libunwind     : 0
+configure:9679: result: prof-libgcc        : 0
+configure:9681: result: prof-gcc           : 0
+configure:9683: result: tcache             : 1
+configure:9685: result: fill               : 1
+configure:9687: result: utrace             : 0
+configure:9689: result: valgrind           : 0
+configure:9691: result: xmalloc            : 0
+configure:9693: result: munmap             : 0
+configure:9695: result: lazy_lock          : 0
+configure:9697: result: tls                : 1
+configure:9699: result: cache-oblivious    : 1
+configure:9701: result: ===============================================================================
 
 ## ---------------- ##
 ## Cache variables. ##
 ## ---------------- ##
 
 ac_cv_big_endian=0
@@ -1401,16 +1761,19 @@
 ac_cv_env_host_alias_set=
 ac_cv_env_host_alias_value=
 ac_cv_env_target_alias_set=
 ac_cv_env_target_alias_value=
 ac_cv_func__malloc_thread_cleanup=no
 ac_cv_func__pthread_mutex_init_calloc_cb=no
+ac_cv_func_issetugid=no
 ac_cv_func_memalign=yes
 ac_cv_func_sbrk=yes
+ac_cv_func_secure_getenv=yes
 ac_cv_func_valloc=yes
 ac_cv_header_inttypes_h=yes
+ac_cv_header_malloc_h=yes
 ac_cv_header_memory_h=yes
 ac_cv_header_pthread_h=yes
 ac_cv_header_stdbool_h=yes
 ac_cv_header_stdc=yes
 ac_cv_header_stdint_h=yes
 ac_cv_header_stdlib_h=yes
@@ -1431,29 +1794,38 @@
 ac_cv_prog_CPP='gcc -E'
 ac_cv_prog_ac_ct_AR=ar
 ac_cv_prog_ac_ct_CC=gcc
 ac_cv_prog_ac_ct_RANLIB=ranlib
 ac_cv_prog_cc_c89=
 ac_cv_prog_cc_g=yes
+ac_cv_search_clock_gettime='none required'
 ac_cv_sizeof_int=4
 ac_cv_sizeof_intmax_t=8
 ac_cv_sizeof_long=8
 ac_cv_sizeof_void_p=8
 ac_cv_type__Bool=yes
+je_cv_alloc_size=yes
 je_cv_atomic9=no
 je_cv_attribute=yes
+je_cv_builtin_clz=yes
+je_cv_c11atomics=no
 je_cv_cflags_appended=-Werror
-je_cv_function_ffsl=yes
+je_cv_format_gnu_printf=yes
+je_cv_format_printf=yes
+je_cv_gcc_builtin_ffsl=yes
+je_cv_glibc_malloc_hook=yes
+je_cv_glibc_memalign_hook=yes
+je_cv_lg_page=12
+je_cv_madvise=yes
 je_cv_osatomic=no
 je_cv_osspin=no
 je_cv_pause=yes
-je_cv_sse2=yes
-je_cv_static_page_shift=12
+je_cv_pthread_mutex_adaptive_np=yes
 je_cv_sync_compare_and_swap_4=no
 je_cv_sync_compare_and_swap_8=no
-je_cv_tls_model=no
+je_cv_tls_model=yes
 je_cv_utrace=no
 je_cv_valgrind=no
 
 ## ----------------- ##
 ## Output variables. ##
 ## ----------------- ##
@@ -1463,12 +1835,13 @@
 AROUT=' $@'
 AUTOCONF='/usr/bin/autoconf'
 BINDIR='/usr/local/bin'
 CC='gcc'
 CC_MM='1'
 CFLAGS='-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden'
+CONFIG='--with-jemalloc-prefix=je_ --enable-cc-silence '\''CFLAGS=-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops '\'' LDFLAGS='
 CPP='gcc -E'
 CPPFLAGS=' -D_GNU_SOURCE -D_REENTRANT'
 CTARGET='-o $@'
 DATADIR='/usr/local/share'
 DEFS='-DHAVE_CONFIG_H'
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
@@ -1480,12 +1853,13 @@
 EXTRA_LDFLAGS=''
 GREP='/bin/grep'
 INCLUDEDIR='/usr/local/include'
 INSTALL_DATA='${INSTALL} -m 644'
 INSTALL_PROGRAM='${INSTALL}'
 INSTALL_SCRIPT='${INSTALL}'
+JEMALLOC_CPREFIX='JE_'
 LD='/usr/bin/ld'
 LDFLAGS=''
 LDTARGET='-o $@'
 LD_PRELOAD_VAR='LD_PRELOAD'
 LIBDIR='/usr/local/lib'
 LIBOBJS=''
@@ -1504,42 +1878,41 @@
 PIC_CFLAGS='-fPIC -DPIC'
 PREFIX='/usr/local'
 RANLIB='ranlib'
 RPATH='-Wl,-rpath,$(1)'
 RPATH_EXTRA=''
 SHELL='/bin/bash'
-SOREV='so.1'
+SOREV='so.2'
+TESTLIBS=''
 XSLROOT='/usr/share/xml/docbook/stylesheet/docbook-xsl'
 XSLTPROC='/opt/anaconda2/bin/xsltproc'
 a='a'
 abi='elf'
-abs_objroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/'
-abs_srcroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/'
+abs_objroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/'
+abs_srcroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/'
 ac_ct_CC='gcc'
 bindir='${exec_prefix}/bin'
 build='x86_64-unknown-linux-gnu'
 build_alias=''
 build_cpu='x86_64'
 build_os='linux-gnu'
 build_vendor='unknown'
 cfghdrs_in='include/jemalloc/jemalloc_defs.h.in include/jemalloc/internal/jemalloc_internal_defs.h.in include/jemalloc/internal/private_namespace.sh include/jemalloc/internal/private_unnamespace.sh include/jemalloc/internal/private_symbols.txt include/jemalloc/internal/public_namespace.sh include/jemalloc/internal/public_unnamespace.sh include/jemalloc/internal/size_classes.sh include/jemalloc/jemalloc_rename.sh include/jemalloc/jemalloc_mangle.sh include/jemalloc/jemalloc.sh test/include/test/jemalloc_test_defs.h.in'
 cfghdrs_out='include/jemalloc/jemalloc_defs.h include/jemalloc/jemalloc.h include/jemalloc/internal/private_namespace.h include/jemalloc/internal/private_unnamespace.h include/jemalloc/internal/public_symbols.txt include/jemalloc/internal/public_namespace.h include/jemalloc/internal/public_unnamespace.h include/jemalloc/internal/size_classes.h include/jemalloc/jemalloc_protos_jet.h include/jemalloc/jemalloc_rename.h include/jemalloc/jemalloc_mangle.h include/jemalloc/jemalloc_mangle_jet.h include/jemalloc/internal/jemalloc_internal_defs.h test/include/test/jemalloc_test_defs.h'
-cfgoutputs_in='Makefile.in doc/html.xsl.in doc/manpages.xsl.in doc/jemalloc.xml.in include/jemalloc/jemalloc_macros.h.in include/jemalloc/jemalloc_protos.h.in include/jemalloc/internal/jemalloc_internal.h.in test/test.sh.in test/include/test/jemalloc_test.h.in'
-cfgoutputs_out='Makefile doc/html.xsl doc/manpages.xsl doc/jemalloc.xml include/jemalloc/jemalloc_macros.h include/jemalloc/jemalloc_protos.h include/jemalloc/internal/jemalloc_internal.h test/test.sh test/include/test/jemalloc_test.h'
+cfgoutputs_in='Makefile.in jemalloc.pc.in doc/html.xsl.in doc/manpages.xsl.in doc/jemalloc.xml.in include/jemalloc/jemalloc_macros.h.in include/jemalloc/jemalloc_protos.h.in include/jemalloc/jemalloc_typedefs.h.in include/jemalloc/internal/jemalloc_internal.h.in test/test.sh.in test/include/test/jemalloc_test.h.in'
+cfgoutputs_out='Makefile jemalloc.pc doc/html.xsl doc/manpages.xsl doc/jemalloc.xml include/jemalloc/jemalloc_macros.h include/jemalloc/jemalloc_protos.h include/jemalloc/jemalloc_typedefs.h include/jemalloc/internal/jemalloc_internal.h test/test.sh test/include/test/jemalloc_test.h'
 datadir='${datarootdir}'
 datarootdir='${prefix}/share'
 docdir='${datarootdir}/doc/${PACKAGE}'
 dvidir='${docdir}'
 enable_autogen='0'
+enable_cache_oblivious='1'
 enable_code_coverage='0'
 enable_debug='0'
-enable_dss='0'
-enable_experimental='1'
 enable_fill='1'
 enable_lazy_lock='0'
-enable_mremap='0'
 enable_munmap='0'
 enable_prof='0'
 enable_stats='1'
 enable_tcache='1'
 enable_tls='1'
 enable_utrace='0'
@@ -1556,17 +1929,17 @@
 htmldir='${docdir}'
 importlib='so'
 includedir='${prefix}/include'
 infodir='${datarootdir}/info'
 install_suffix=''
 je_='je_'
-jemalloc_version='3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340'
-jemalloc_version_bugfix='0'
-jemalloc_version_gid='46c0af68bd248b04df75e4f92d5fb804c3d75340'
-jemalloc_version_major='3'
-jemalloc_version_minor='6'
+jemalloc_version='4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c'
+jemalloc_version_bugfix='3'
+jemalloc_version_gid='e9192eacf8935e29fc62fddc2701f7942b1cc02c'
+jemalloc_version_major='4'
+jemalloc_version_minor='0'
 jemalloc_version_nrev='0'
 libdir='${exec_prefix}/lib'
 libexecdir='${exec_prefix}/libexec'
 libprefix='lib'
 localedir='${datarootdir}/locale'
 localstatedir='${prefix}/var'
@@ -1576,13 +1949,13 @@
 oldincludedir='/usr/include'
 pdfdir='${docdir}'
 prefix='/usr/local'
 private_namespace='je_'
 program_transform_name='s,x,x,'
 psdir='${docdir}'
-rev='1'
+rev='2'
 sbindir='${exec_prefix}/sbin'
 sharedstatedir='${prefix}/com'
 so='so'
 srcroot=''
 sysconfdir='${prefix}/etc'
 target_alias=''
@@ -1613,32 +1986,46 @@
 #define SIZEOF_INT 4
 #define LG_SIZEOF_INT 2
 #define SIZEOF_LONG 8
 #define LG_SIZEOF_LONG 3
 #define SIZEOF_INTMAX_T 8
 #define LG_SIZEOF_INTMAX_T 3
-#define HAVE_SSE2
 #define CPU_SPINWAIT __asm__ volatile("pause")
 #define JEMALLOC_HAS_ALLOCA_H 1
 #define JEMALLOC_PURGE_MADVISE_DONTNEED  
 #define JEMALLOC_THREADED_INIT  
+#define JEMALLOC_USE_CXX_THROW  
+#define HAVE_MALLOC_H 1
 #define JEMALLOC_USABLE_SIZE_CONST 
 #define JEMALLOC_HAVE_ATTR  
-#define JEMALLOC_TLS_MODEL  
+#define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+#define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+#define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+#define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 #define JEMALLOC_OVERRIDE_MEMALIGN  
 #define JEMALLOC_OVERRIDE_VALLOC  
-#define JEMALLOC_EXPERIMENTAL  
 #define JEMALLOC_PREFIX "je_"
 #define JEMALLOC_CPREFIX "JE_"
 #define JEMALLOC_PRIVATE_NAMESPACE je_
 #define JEMALLOC_CC_SILENCE  
 #define JEMALLOC_STATS  
 #define JEMALLOC_TCACHE  
-#define JEMALLOC_HAVE_SBRK  
+#define JEMALLOC_MAPS_COALESCE  
+#define JEMALLOC_DSS  
 #define JEMALLOC_FILL  
-#define STATIC_PAGE_SHIFT 12
+#define JEMALLOC_CACHE_OBLIVIOUS  
+#define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+#define JEMALLOC_INTERNAL_FFS __builtin_ffs
+#define LG_TINY_MIN 3
+#define LG_PAGE 12
 #define HAVE_PTHREAD_H 1
+#define JEMALLOC_HAVE_SECURE_GETENV  
 #define JEMALLOC_TLS
+#define JEMALLOC_HAVE_MADVISE  
+#define JEMALLOC_HAVE_BUILTIN_CLZ  
+#define JEMALLOC_GLIBC_MALLOC_HOOK  
+#define JEMALLOC_GLIBC_MEMALIGN_HOOK  
+#define JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP  
 #define HAVE__BOOL 1
 #define HAVE_STDBOOL_H 1
 
 configure: exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/config.status /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/config.status
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/config.status	2017-09-27 22:47:53.162963476 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/config.status	2017-09-27 22:49:14.946960479 +0800
@@ -390,13 +390,13 @@
   $ $0 $@
 
 on `(hostname || uname -n) 2>/dev/null | sed 1q`
 "
 
 # Files that config.status was made for.
-config_files=" Makefile doc/html.xsl:doc/html.xsl.in doc/manpages.xsl:doc/manpages.xsl.in doc/jemalloc.xml:doc/jemalloc.xml.in include/jemalloc/jemalloc_macros.h:include/jemalloc/jemalloc_macros.h.in include/jemalloc/jemalloc_protos.h:include/jemalloc/jemalloc_protos.h.in include/jemalloc/internal/jemalloc_internal.h test/test.sh:test/test.sh.in test/include/test/jemalloc_test.h:test/include/test/jemalloc_test.h.in config.stamp bin/jemalloc.sh"
+config_files=" Makefile jemalloc.pc:jemalloc.pc.in doc/html.xsl:doc/html.xsl.in doc/manpages.xsl:doc/manpages.xsl.in doc/jemalloc.xml:doc/jemalloc.xml.in include/jemalloc/jemalloc_macros.h:include/jemalloc/jemalloc_macros.h.in include/jemalloc/jemalloc_protos.h:include/jemalloc/jemalloc_protos.h.in include/jemalloc/jemalloc_typedefs.h:include/jemalloc/jemalloc_typedefs.h.in include/jemalloc/internal/jemalloc_internal.h test/test.sh:test/test.sh.in test/include/test/jemalloc_test.h:test/include/test/jemalloc_test.h.in config.stamp bin/jemalloc-config bin/jemalloc.sh bin/jeprof"
 config_headers=" include/jemalloc/jemalloc_defs.h:include/jemalloc/jemalloc_defs.h.in include/jemalloc/internal/jemalloc_internal_defs.h:include/jemalloc/internal/jemalloc_internal_defs.h.in test/include/test/jemalloc_test_defs.h:test/include/test/jemalloc_test_defs.h.in"
 config_commands=" include/jemalloc/internal/private_namespace.h include/jemalloc/internal/private_unnamespace.h include/jemalloc/internal/public_symbols.txt include/jemalloc/internal/public_namespace.h include/jemalloc/internal/public_unnamespace.h include/jemalloc/internal/size_classes.h include/jemalloc/jemalloc_protos_jet.h include/jemalloc/jemalloc_rename.h include/jemalloc/jemalloc_mangle.h include/jemalloc/jemalloc_mangle_jet.h include/jemalloc/jemalloc.h"
 
 ac_cs_usage="\
 \`$as_me' instantiates files and other configuration actions
 from templates according to the current configuration.  Unless the files
@@ -434,13 +434,13 @@
   with options \"$ac_cs_config\"
 
 Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
-ac_pwd='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc'
+ac_pwd='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc'
 srcdir='.'
 INSTALL='/usr/bin/install -c'
 test -n "$AWK" || AWK=awk
 # The default lists apply if the user does not specify any file.
 ac_need_defaults=:
 while test $# != 0
@@ -546,26 +546,31 @@
   objroot=""
 
 
   srcdir="."
   objroot=""
   mangling_map=""
-  public_syms="malloc_conf malloc_message malloc calloc posix_memalign aligned_alloc realloc free mallocx rallocx xallocx sallocx dallocx nallocx mallctl mallctlnametomib mallctlbymib malloc_stats_print malloc_usable_size memalign valloc allocm dallocm nallocm rallocm sallocm"
+  public_syms="malloc_conf malloc_message malloc calloc posix_memalign aligned_alloc realloc free mallocx rallocx xallocx sallocx dallocx sdallocx nallocx mallctl mallctlnametomib mallctlbymib malloc_stats_print malloc_usable_size memalign valloc"
   JEMALLOC_PREFIX="je_"
 
 
   srcdir="."
   objroot=""
 
 
   srcdir="."
   objroot=""
 
 
+  SHELL="/bin/bash"
   srcdir="."
   objroot=""
+  LG_QUANTA="3 4"
+  LG_TINY_MIN=3
+  LG_PAGE_SIZES="12"
+  LG_SIZE_CLASS_GROUP=2
 
 
   srcdir="."
   objroot=""
 
 
@@ -602,13 +607,15 @@
     "include/jemalloc/jemalloc_mangle.h") CONFIG_COMMANDS="$CONFIG_COMMANDS include/jemalloc/jemalloc_mangle.h" ;;
     "include/jemalloc/jemalloc_mangle_jet.h") CONFIG_COMMANDS="$CONFIG_COMMANDS include/jemalloc/jemalloc_mangle_jet.h" ;;
     "include/jemalloc/jemalloc.h") CONFIG_COMMANDS="$CONFIG_COMMANDS include/jemalloc/jemalloc.h" ;;
     "$cfghdrs_tup") CONFIG_HEADERS="$CONFIG_HEADERS $cfghdrs_tup" ;;
     "$cfgoutputs_tup") CONFIG_FILES="$CONFIG_FILES $cfgoutputs_tup" ;;
     "config.stamp") CONFIG_FILES="$CONFIG_FILES config.stamp" ;;
+    "bin/jemalloc-config") CONFIG_FILES="$CONFIG_FILES bin/jemalloc-config" ;;
     "bin/jemalloc.sh") CONFIG_FILES="$CONFIG_FILES bin/jemalloc.sh" ;;
+    "bin/jeprof") CONFIG_FILES="$CONFIG_FILES bin/jeprof" ;;
 
   *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
 
 
@@ -670,49 +677,50 @@
 fi
 
 echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
 cat >>"$ac_tmp/subs1.awk" <<\_ACAWK &&
 S["LTLIBOBJS"]=""
 S["LIBOBJS"]=""
-S["cfgoutputs_out"]="Makefile doc/html.xsl doc/manpages.xsl doc/jemalloc.xml include/jemalloc/jemalloc_macros.h include/jemalloc/jemalloc_protos.h include/jemalloc/inter"\
-"nal/jemalloc_internal.h test/test.sh test/include/test/jemalloc_test.h"
-S["cfgoutputs_in"]="Makefile.in doc/html.xsl.in doc/manpages.xsl.in doc/jemalloc.xml.in include/jemalloc/jemalloc_macros.h.in include/jemalloc/jemalloc_protos.h.in incl"\
-"ude/jemalloc/internal/jemalloc_internal.h.in test/test.sh.in test/include/test/jemalloc_test.h.in"
+S["cfgoutputs_out"]="Makefile jemalloc.pc doc/html.xsl doc/manpages.xsl doc/jemalloc.xml include/jemalloc/jemalloc_macros.h include/jemalloc/jemalloc_protos.h include/je"\
+"malloc/jemalloc_typedefs.h include/jemalloc/internal/jemalloc_internal.h test/test.sh test/include/test/jemalloc_test.h"
+S["cfgoutputs_in"]="Makefile.in jemalloc.pc.in doc/html.xsl.in doc/manpages.xsl.in doc/jemalloc.xml.in include/jemalloc/jemalloc_macros.h.in include/jemalloc/jemalloc_p"\
+"rotos.h.in include/jemalloc/jemalloc_typedefs.h.in include/jemalloc/internal/jemalloc_internal.h.in test/test.sh.in test/include/test/jemalloc_test."\
+"h.in"
 S["cfghdrs_out"]="include/jemalloc/jemalloc_defs.h include/jemalloc/jemalloc.h include/jemalloc/internal/private_namespace.h include/jemalloc/internal/private_unnames"\
 "pace.h include/jemalloc/internal/public_symbols.txt include/jemalloc/internal/public_namespace.h include/jemalloc/internal/public_unnamespace.h incl"\
 "ude/jemalloc/internal/size_classes.h include/jemalloc/jemalloc_protos_jet.h include/jemalloc/jemalloc_rename.h include/jemalloc/jemalloc_mangle.h in"\
 "clude/jemalloc/jemalloc_mangle_jet.h include/jemalloc/internal/jemalloc_internal_defs.h test/include/test/jemalloc_test_defs.h"
 S["cfghdrs_in"]="include/jemalloc/jemalloc_defs.h.in include/jemalloc/internal/jemalloc_internal_defs.h.in include/jemalloc/internal/private_namespace.sh include/jem"\
 "alloc/internal/private_unnamespace.sh include/jemalloc/internal/private_symbols.txt include/jemalloc/internal/public_namespace.sh include/jemalloc/i"\
 "nternal/public_unnamespace.sh include/jemalloc/internal/size_classes.sh include/jemalloc/jemalloc_rename.sh include/jemalloc/jemalloc_mangle.sh incl"\
 "ude/jemalloc/jemalloc.sh test/include/test/jemalloc_test_defs.h.in"
 S["enable_zone_allocator"]=""
 S["enable_tls"]="1"
 S["enable_lazy_lock"]="0"
-S["jemalloc_version_gid"]="46c0af68bd248b04df75e4f92d5fb804c3d75340"
+S["TESTLIBS"]=""
+S["jemalloc_version_gid"]="e9192eacf8935e29fc62fddc2701f7942b1cc02c"
 S["jemalloc_version_nrev"]="0"
-S["jemalloc_version_bugfix"]="0"
-S["jemalloc_version_minor"]="6"
-S["jemalloc_version_major"]="3"
-S["jemalloc_version"]="3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340"
+S["jemalloc_version_bugfix"]="3"
+S["jemalloc_version_minor"]="0"
+S["jemalloc_version_major"]="4"
+S["jemalloc_version"]="4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c"
+S["enable_cache_oblivious"]="1"
 S["enable_xmalloc"]="0"
 S["enable_valgrind"]="0"
 S["enable_utrace"]="0"
 S["enable_fill"]="1"
-S["enable_dss"]="0"
 S["enable_munmap"]="0"
-S["enable_mremap"]="0"
 S["enable_tcache"]="1"
 S["enable_prof"]="0"
 S["enable_stats"]="1"
 S["enable_debug"]="0"
 S["je_"]="je_"
 S["install_suffix"]=""
 S["private_namespace"]="je_"
+S["JEMALLOC_CPREFIX"]="JE_"
 S["enable_code_coverage"]="0"
-S["enable_experimental"]="1"
 S["AUTOCONF"]="/usr/bin/autoconf"
 S["LD"]="/usr/bin/ld"
 S["RANLIB"]="ranlib"
 S["INSTALL_DATA"]="${INSTALL} -m 644"
 S["INSTALL_SCRIPT"]="${INSTALL}"
 S["INSTALL_PROGRAM"]="${INSTALL}"
@@ -722,13 +730,13 @@
 S["AROUT"]=" $@"
 S["ARFLAGS"]="crus"
 S["MKLIB"]=""
 S["LDTARGET"]="-o $@"
 S["CTARGET"]="-o $@"
 S["PIC_CFLAGS"]="-fPIC -DPIC"
-S["SOREV"]="so.1"
+S["SOREV"]="so.2"
 S["EXTRA_LDFLAGS"]=""
 S["DSO_LDFLAGS"]="-shared -Wl,-soname,$(@F)"
 S["libprefix"]="lib"
 S["exe"]=""
 S["a"]="a"
 S["o"]="o"
@@ -761,17 +769,18 @@
 S["MANDIR"]="/usr/local/share/man"
 S["DATADIR"]="/usr/local/share"
 S["LIBDIR"]="/usr/local/lib"
 S["INCLUDEDIR"]="/usr/local/include"
 S["BINDIR"]="/usr/local/bin"
 S["PREFIX"]="/usr/local"
-S["abs_objroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/"
+S["abs_objroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/"
 S["objroot"]=""
-S["abs_srcroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/"
+S["abs_srcroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/"
 S["srcroot"]=""
-S["rev"]="1"
+S["rev"]="2"
+S["CONFIG"]="--with-jemalloc-prefix=je_ --enable-cc-silence 'CFLAGS=-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops ' LDFLAGS="
 S["target_alias"]=""
 S["host_alias"]=""
 S["build_alias"]=""
 S["LIBS"]=" -lpthread"
 S["ECHO_T"]=""
 S["ECHO_N"]="-n"
@@ -869,34 +878,48 @@
 D["SIZEOF_INT"]=" 4"
 D["LG_SIZEOF_INT"]=" 2"
 D["SIZEOF_LONG"]=" 8"
 D["LG_SIZEOF_LONG"]=" 3"
 D["SIZEOF_INTMAX_T"]=" 8"
 D["LG_SIZEOF_INTMAX_T"]=" 3"
-D["HAVE_SSE2"]=" "
 D["CPU_SPINWAIT"]=" __asm__ volatile(\"pause\")"
 D["JEMALLOC_HAS_ALLOCA_H"]=" 1"
 D["JEMALLOC_PURGE_MADVISE_DONTNEED"]=" "
 D["JEMALLOC_THREADED_INIT"]=" "
+D["JEMALLOC_USE_CXX_THROW"]=" "
+D["HAVE_MALLOC_H"]=" 1"
 D["JEMALLOC_USABLE_SIZE_CONST"]=" "
 D["JEMALLOC_HAVE_ATTR"]=" "
-D["JEMALLOC_TLS_MODEL"]=" "
+D["JEMALLOC_TLS_MODEL"]=" __attribute__((tls_model(\"initial-exec\")))"
+D["JEMALLOC_HAVE_ATTR_ALLOC_SIZE"]=" "
+D["JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF"]=" "
+D["JEMALLOC_HAVE_ATTR_FORMAT_PRINTF"]=" "
 D["JEMALLOC_OVERRIDE_MEMALIGN"]=" "
 D["JEMALLOC_OVERRIDE_VALLOC"]=" "
-D["JEMALLOC_EXPERIMENTAL"]=" "
 D["JEMALLOC_PREFIX"]=" \"je_\""
 D["JEMALLOC_CPREFIX"]=" \"JE_\""
 D["JEMALLOC_PRIVATE_NAMESPACE"]=" je_"
 D["JEMALLOC_CC_SILENCE"]=" "
 D["JEMALLOC_STATS"]=" "
 D["JEMALLOC_TCACHE"]=" "
-D["JEMALLOC_HAVE_SBRK"]=" "
+D["JEMALLOC_MAPS_COALESCE"]=" "
+D["JEMALLOC_DSS"]=" "
 D["JEMALLOC_FILL"]=" "
-D["STATIC_PAGE_SHIFT"]=" 12"
+D["JEMALLOC_CACHE_OBLIVIOUS"]=" "
+D["JEMALLOC_INTERNAL_FFSL"]=" __builtin_ffsl"
+D["JEMALLOC_INTERNAL_FFS"]=" __builtin_ffs"
+D["LG_TINY_MIN"]=" 3"
+D["LG_PAGE"]=" 12"
 D["HAVE_PTHREAD_H"]=" 1"
+D["JEMALLOC_HAVE_SECURE_GETENV"]=" "
 D["JEMALLOC_TLS"]=" "
+D["JEMALLOC_HAVE_MADVISE"]=" "
+D["JEMALLOC_HAVE_BUILTIN_CLZ"]=" "
+D["JEMALLOC_GLIBC_MALLOC_HOOK"]=" "
+D["JEMALLOC_GLIBC_MEMALIGN_HOOK"]=" "
+D["JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP"]=" "
 D["HAVE__BOOL"]=" 1"
 D["HAVE_STDBOOL_H"]=" 1"
   for (key in D) D_is_set[key] = 1
   FS = ""
 }
 /^[\t ]*#[\t ]*(define|undef)[\t ]+[_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ][_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]*([\t (]|$)/ {
@@ -1210,13 +1233,13 @@
     "include/jemalloc/internal/public_unnamespace.h":C)
   mkdir -p "${objroot}include/jemalloc/internal"
   "${srcdir}/include/jemalloc/internal/public_unnamespace.sh" "${objroot}include/jemalloc/internal/public_symbols.txt" > "${objroot}include/jemalloc/internal/public_unnamespace.h"
  ;;
     "include/jemalloc/internal/size_classes.h":C)
   mkdir -p "${objroot}include/jemalloc/internal"
-  "${srcdir}/include/jemalloc/internal/size_classes.sh" > "${objroot}include/jemalloc/internal/size_classes.h"
+  "${SHELL}" "${srcdir}/include/jemalloc/internal/size_classes.sh" "${LG_QUANTA}" ${LG_TINY_MIN} "${LG_PAGE_SIZES}" ${LG_SIZE_CLASS_GROUP} > "${objroot}include/jemalloc/internal/size_classes.h"
  ;;
     "include/jemalloc/jemalloc_protos_jet.h":C)
   mkdir -p "${objroot}include/jemalloc"
   cat "${srcdir}/include/jemalloc/jemalloc_protos.h.in" | sed -e 's/@je_@/jet_/g' > "${objroot}include/jemalloc/jemalloc_protos_jet.h"
  ;;
     "include/jemalloc/jemalloc_rename.h":C)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/config.sub /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/config.sub
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/config.sub	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/config.sub	2016-05-06 15:11:36.000000000 +0800
@@ -1,11 +1,11 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2013 Free Software Foundation, Inc.
+#   Copyright 1992-2014 Free Software Foundation, Inc.
 
-timestamp='2013-10-01'
+timestamp='2014-05-01'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
@@ -65,13 +65,13 @@
 
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2013 Free Software Foundation, Inc.
+Copyright 1992-2014 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
@@ -280,27 +280,28 @@
 	| mips64vr4100 | mips64vr4100el \
 	| mips64vr4300 | mips64vr4300el \
 	| mips64vr5000 | mips64vr5000el \
 	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa32r6 | mipsisa32r6el \
 	| mipsisa64 | mipsisa64el \
 	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64r6 | mipsisa64r6el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipsr5900 | mipsr5900el \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
 	| moxie \
 	| mt \
 	| msp430 \
 	| nds32 | nds32le | nds32be \
 	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
-	| open8 \
-	| or1k | or32 \
+	| open8 | or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
 	| rl78 | rx \
 	| score \
 	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
@@ -399,25 +400,28 @@
 	| mips64vr4100-* | mips64vr4100el-* \
 	| mips64vr4300-* | mips64vr4300el-* \
 	| mips64vr5000-* | mips64vr5000el-* \
 	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa32r6-* | mipsisa32r6el-* \
 	| mipsisa64-* | mipsisa64el-* \
 	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64r6-* | mipsisa64r6el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipsr5900-* | mipsr5900el-* \
 	| mipstx39-* | mipstx39el-* \
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
 	| nds32-* | nds32le-* | nds32be-* \
 	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
 	| open8-* \
+	| or1k*-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
 	| pyramid-* \
 	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
@@ -1373,13 +1377,13 @@
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
 		case $basic_machine in
 		    x86-* | i*86-*)
 			;;
@@ -1397,12 +1401,15 @@
 	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
 	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
 	-mac*)
 		os=`echo $os | sed -e 's|mac|macos|'`
 		;;
+	# Apple iOS
+	-ios*)
+		;;
 	-linux-dietlibc)
 		os=-linux-dietlibc
 		;;
 	-linux*)
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
@@ -1591,15 +1598,12 @@
 	mips*-cisco)
 		os=-elf
 		;;
 	mips*-*)
 		os=-elf
 		;;
-	or1k-*)
-		os=-elf
-		;;
 	or32-*)
 		os=-coff
 		;;
 	*-tti)	# must be before sparc entry or we get the wrong os.
 		os=-sysv3
 		;;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/configure	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/configure	2016-05-06 15:11:36.000000000 +0800
@@ -625,34 +625,34 @@
 cfgoutputs_in
 cfghdrs_out
 cfghdrs_in
 enable_zone_allocator
 enable_tls
 enable_lazy_lock
+TESTLIBS
 jemalloc_version_gid
 jemalloc_version_nrev
 jemalloc_version_bugfix
 jemalloc_version_minor
 jemalloc_version_major
 jemalloc_version
+enable_cache_oblivious
 enable_xmalloc
 enable_valgrind
 enable_utrace
 enable_fill
-enable_dss
 enable_munmap
-enable_mremap
 enable_tcache
 enable_prof
 enable_stats
 enable_debug
 je_
 install_suffix
 private_namespace
+JEMALLOC_CPREFIX
 enable_code_coverage
-enable_experimental
 AUTOCONF
 LD
 RANLIB
 INSTALL_DATA
 INSTALL_SCRIPT
 INSTALL_PROGRAM
@@ -706,12 +706,13 @@
 PREFIX
 abs_objroot
 objroot
 abs_srcroot
 srcroot
 rev
+CONFIG
 target_alias
 host_alias
 build_alias
 LIBS
 ECHO_T
 ECHO_N
@@ -750,13 +751,12 @@
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
 with_xslroot
 with_rpath
 enable_autogen
-enable_experimental
 enable_code_coverage
 with_mangling
 with_jemalloc_prefix
 with_export
 with_private_namespace
 with_install_suffix
@@ -767,19 +767,23 @@
 enable_prof
 enable_prof_libunwind
 with_static_libunwind
 enable_prof_libgcc
 enable_prof_gcc
 enable_tcache
-enable_mremap
 enable_munmap
-enable_dss
 enable_fill
 enable_utrace
 enable_valgrind
 enable_xmalloc
+enable_cache_oblivious
+with_lg_tiny_min
+with_lg_quantum
+with_lg_page
+with_lg_page_sizes
+with_lg_size_class_group
 enable_lazy_lock
 enable_tls
 enable_zone_allocator
 '
       ac_precious_vars='build_alias
 host_alias
@@ -1399,31 +1403,31 @@
 
 Optional Features:
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
   --enable-autogen        Automatically regenerate configure output
-  --disable-experimental  Disable support for the experimental API
   --enable-code-coverage  Enable code coverage
-  --enable-cc-silence     Silence irrelevant compiler warnings
+  --disable-cc-silence    Do not silence irrelevant compiler warnings
   --enable-debug          Build debugging code (implies --enable-ivsalloc)
   --enable-ivsalloc       Validate pointers passed through the public API
   --disable-stats         Disable statistics calculation/reporting
   --enable-prof           Enable allocation profiling
   --enable-prof-libunwind Use libunwind for backtracing
   --disable-prof-libgcc   Do not use libgcc for backtracing
   --disable-prof-gcc      Do not use gcc intrinsics for backtracing
   --disable-tcache        Disable per thread caches
-  --enable-mremap         Enable mremap(2) for huge realloc()
   --disable-munmap        Disable VM deallocation via munmap(2)
-  --enable-dss            Enable allocation from DSS
   --disable-fill          Disable support for junk/zero filling, quarantine,
                           and redzones
   --enable-utrace         Enable utrace(2)-based tracing
   --disable-valgrind      Disable support for Valgrind
   --enable-xmalloc        Support xmalloc option
+  --disable-cache-oblivious
+                          Disable support for cache-oblivious allocation
+                          alignment
   --enable-lazy-lock      Enable lazy locking (only lock when multi-threaded)
   --disable-tls           Disable thread-local storage (__thread keyword)
   --disable-zone-allocator
                           Disable zone allocator for Darwin
 
 Optional Packages:
@@ -1439,12 +1443,22 @@
                           Prefix to prepend to all library-private APIs
   --with-install-suffix=<suffix>
                           Suffix to append to all installed files
   --with-static-libunwind=<libunwind.a>
                           Path to static libunwind library; use rather than
                           dynamically linking
+  --with-lg-tiny-min=<lg-tiny-min>
+                          Base 2 log of minimum tiny size class to support
+  --with-lg-quantum=<lg-quantum>
+                          Base 2 log of minimum allocation alignment
+  --with-lg-page=<lg-page>
+                          Base 2 log of system page size
+  --with-lg-page-sizes=<lg-page-sizes>
+                          Base 2 logs of system page sizes to support
+  --with-lg-size-class-group=<lg-size-class-group>
+                          Base 2 log of size classes per doubling
 
 Some influential environment variables:
   CC          C compiler command
   CFLAGS      C compiler flags
   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
               nonstandard directory <lib dir>
@@ -1907,79 +1921,12 @@
   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_link
 
-# ac_fn_c_check_func LINENO FUNC VAR
-# ----------------------------------
-# Tests whether FUNC exists, setting the cache variable VAR accordingly
-ac_fn_c_check_func ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $2 innocuous_$2
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $2 (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $2
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $2 ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$2 || defined __stub___$2
-choke me
-#endif
-
-int
-main ()
-{
-return $2 ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_func
-
 # ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
 # -------------------------------------------------------
 # Tests whether HEADER exists, giving a warning if it cannot be compiled using
 # the include files in INCLUDES and setting the cache variable VAR
 # accordingly.
 ac_fn_c_check_header_mongrel ()
@@ -2061,12 +2008,79 @@
 $as_echo "$ac_res" >&6; }
 fi
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_header_mongrel
 
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main ()
+{
+return $2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_func
+
 # ac_fn_c_check_type LINENO TYPE VAR INCLUDES
 # -------------------------------------------
 # Tests whether TYPE exists after having included INCLUDES, setting cache
 # variable VAR accordingly.
 ac_fn_c_check_type ()
 {
@@ -2473,13 +2487,16 @@
 
 
 
 
 
 
-rev=1
+CONFIG=`echo ${ac_configure_args} | sed -e 's#'"'"'\([^ ]*\)'"'"'#\1#g'`
+
+
+rev=2
 
 
 srcroot=$srcdir
 if test "x${srcroot}" = "x." ; then
   srcroot=""
 else
@@ -3485,12 +3502,48 @@
               CFLAGS="${TCFLAGS}"
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -Werror=declaration-after-statement" >&5
+$as_echo_n "checking whether compiler supports -Werror=declaration-after-statement... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-Werror=declaration-after-statement"
+else
+  CFLAGS="${CFLAGS} -Werror=declaration-after-statement"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-Werror=declaration-after-statement
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -pipe" >&5
 $as_echo_n "checking whether compiler supports -pipe... " >&6; }
 TCFLAGS="${CFLAGS}"
 if test "x${CFLAGS}" = "x" ; then
   CFLAGS="-pipe"
 else
@@ -3666,13 +3719,49 @@
 $as_echo "no" >&6; }
               CFLAGS="${TCFLAGS}"
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
-    CPPFLAGS="$CPPFLAGS -I${srcroot}/include/msvc_compat"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -FS" >&5
+$as_echo_n "checking whether compiler supports -FS... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-FS"
+else
+  CFLAGS="${CFLAGS} -FS"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-FS
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+    CPPFLAGS="$CPPFLAGS -I${srcdir}/include/msvc_compat"
   fi
 fi
 if test "x$EXTRA_CFLAGS" != "x" ; then
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports $EXTRA_CFLAGS" >&5
 $as_echo_n "checking whether compiler supports $EXTRA_CFLAGS... " >&6; }
@@ -4335,12 +4424,16 @@
   cat >>confdefs.h <<_ACEOF
 #define JEMALLOC_BIG_ENDIAN
 _ACEOF
 
 fi
 
+if test "x${je_cv_msvc}" = "xyes" -a "x${ac_cv_header_inttypes_h}" = "xno"; then
+  CPPFLAGS="$CPPFLAGS -I${srcdir}/include/msvc_compat/C99"
+fi
+
 # The cast to long int works around a bug in the HP C Compiler
 # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
 # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of void *" >&5
 $as_echo_n "checking size of void *... " >&6; }
@@ -4619,15 +4712,16 @@
 IFS=$ac_save_IFS
 case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
 CPU_SPINWAIT=""
 case "${host_cpu}" in
-  i[345]86)
-	;;
   i686|x86_64)
+	if ${je_cv_pause+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether pause instruction is compilable" >&5
 $as_echo_n "checking whether pause instruction is compilable... " >&6; }
 if ${je_cv_pause+:} false; then :
   $as_echo_n "(cached) " >&6
 else
@@ -4650,50 +4744,16 @@
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_pause" >&5
 $as_echo "$je_cv_pause" >&6; }
 
-	if test "x${je_cv_pause}" = "xyes" ; then
-	    CPU_SPINWAIT='__asm__ volatile("pause")'
-	fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether SSE2 intrinsics is compilable" >&5
-$as_echo_n "checking whether SSE2 intrinsics is compilable... " >&6; }
-if ${je_cv_sse2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <emmintrin.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  je_cv_sse2=yes
-else
-  je_cv_sse2=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_sse2" >&5
-$as_echo "$je_cv_sse2" >&6; }
-
-	if test "x${je_cv_sse2}" = "xyes" ; then
-	  cat >>confdefs.h <<_ACEOF
-#define HAVE_SSE2
-_ACEOF
 
+	if test "x${je_cv_pause}" = "xyes" ; then
+	    CPU_SPINWAIT='__asm__ volatile("pause")'
 	fi
 	;;
   powerpc)
 	cat >>confdefs.h <<_ACEOF
 #define HAVE_ALTIVEC
 _ACEOF
@@ -4819,46 +4879,66 @@
 else
   AR="$ac_cv_prog_AR"
 fi
 
 
 default_munmap="1"
-JEMALLOC_USABLE_SIZE_CONST="const"
+maps_coalesce="1"
 case "${host}" in
-  *-*-darwin*)
+  *-*-darwin* | *-*-ios*)
 	CFLAGS="$CFLAGS"
 	abi="macho"
 	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
 
 	RPATH=""
 	LD_PRELOAD_VAR="DYLD_INSERT_LIBRARIES"
 	so="dylib"
 	importlib="${so}"
 	force_tls="0"
-	DSO_LDFLAGS='-shared -Wl,-dylib_install_name,$(@F)'
+	DSO_LDFLAGS='-shared -Wl,-install_name,$(LIBDIR)/$(@F)'
 	SOREV="${rev}.${so}"
 	sbrk_deprecated="1"
 	;;
   *-*-freebsd*)
 	CFLAGS="$CFLAGS"
 	abi="elf"
 	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
 
 	force_lazy_lock="1"
 	;;
+  *-*-dragonfly*)
+	CFLAGS="$CFLAGS"
+	abi="elf"
+	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
+
+	;;
+  *-*-openbsd*)
+	CFLAGS="$CFLAGS"
+	abi="elf"
+	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
+
+	force_tls="0"
+	;;
+  *-*-bitrig*)
+	CFLAGS="$CFLAGS"
+	abi="elf"
+	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
+
+	;;
   *-*-linux*)
 	CFLAGS="$CFLAGS"
 	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
 	abi="elf"
 	$as_echo "#define JEMALLOC_HAS_ALLOCA_H 1" >>confdefs.h
 
 	$as_echo "#define JEMALLOC_PURGE_MADVISE_DONTNEED  " >>confdefs.h
 
 	$as_echo "#define JEMALLOC_THREADED_INIT  " >>confdefs.h
 
-	JEMALLOC_USABLE_SIZE_CONST=""
+	$as_echo "#define JEMALLOC_USE_CXX_THROW  " >>confdefs.h
+
 	default_munmap="0"
 	;;
   *-*-netbsd*)
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking ABI" >&5
 $as_echo_n "checking ABI... " >&6; }
         cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -4902,15 +4982,17 @@
 	  	  LD_PRELOAD_VAR="LDR_PRELOAD64"
 	else
 	  	  LD_PRELOAD_VAR="LDR_PRELOAD"
 	fi
 	abi="xcoff"
 	;;
-  *-*-mingw*)
+  *-*-mingw* | *-*-cygwin*)
 	abi="pecoff"
 	force_tls="0"
+	force_lazy_lock="1"
+	maps_coalesce="0"
 	RPATH=""
 	so="dll"
 	if test "x$je_cv_msvc" = "xyes" ; then
 	  importlib="lib"
 	  DSO_LDFLAGS="-LD"
 	  EXTRA_LDFLAGS="-link -DEBUG"
@@ -4932,15 +5014,59 @@
   *)
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Unsupported operating system: ${host}" >&5
 $as_echo "Unsupported operating system: ${host}" >&6; }
 	abi="elf"
 	;;
 esac
-cat >>confdefs.h <<_ACEOF
-#define JEMALLOC_USABLE_SIZE_CONST $JEMALLOC_USABLE_SIZE_CONST
-_ACEOF
+
+JEMALLOC_USABLE_SIZE_CONST=const
+for ac_header in malloc.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "malloc.h" "ac_cv_header_malloc_h" "$ac_includes_default"
+if test "x$ac_cv_header_malloc_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_MALLOC_H 1
+_ACEOF
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether malloc_usable_size definition can use const argument" >&5
+$as_echo_n "checking whether malloc_usable_size definition can use const argument... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <malloc.h>
+     #include <stddef.h>
+    size_t malloc_usable_size(const void *ptr);
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+                { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+else
+
+                JEMALLOC_USABLE_SIZE_CONST=
+                { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+
+done
+
+cat >>confdefs.h <<_ACEOF
+#define JEMALLOC_USABLE_SIZE_CONST $JEMALLOC_USABLE_SIZE_CONST
+_ACEOF
 
 
 
 
 
 
@@ -5076,13 +5202,13 @@
 /* end confdefs.h.  */
 
 int
 main ()
 {
 static __thread int
-               __attribute__((tls_model("initial-exec"))) foo;
+               __attribute__((tls_model("initial-exec"), unused)) foo;
                foo = 0;
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
@@ -5101,12 +5227,222 @@
   $as_echo "#define JEMALLOC_TLS_MODEL __attribute__((tls_model(\"initial-exec\")))" >>confdefs.h
 
 else
   $as_echo "#define JEMALLOC_TLS_MODEL  " >>confdefs.h
 
 fi
+SAVED_CFLAGS="${CFLAGS}"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -Werror" >&5
+$as_echo_n "checking whether compiler supports -Werror... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-Werror"
+else
+  CFLAGS="${CFLAGS} -Werror"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-Werror
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether alloc_size attribute is compilable" >&5
+$as_echo_n "checking whether alloc_size attribute is compilable... " >&6; }
+if ${je_cv_alloc_size+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+int
+main ()
+{
+void *foo(size_t size) __attribute__((alloc_size(1)));
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_alloc_size=yes
+else
+  je_cv_alloc_size=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_alloc_size" >&5
+$as_echo "$je_cv_alloc_size" >&6; }
+
+CFLAGS="${SAVED_CFLAGS}"
+if test "x${je_cv_alloc_size}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  " >>confdefs.h
+
+fi
+SAVED_CFLAGS="${CFLAGS}"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -Werror" >&5
+$as_echo_n "checking whether compiler supports -Werror... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-Werror"
+else
+  CFLAGS="${CFLAGS} -Werror"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-Werror
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether format(gnu_printf, ...) attribute is compilable" >&5
+$as_echo_n "checking whether format(gnu_printf, ...) attribute is compilable... " >&6; }
+if ${je_cv_format_gnu_printf+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+int
+main ()
+{
+void *foo(const char *format, ...) __attribute__((format(gnu_printf, 1, 2)));
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_format_gnu_printf=yes
+else
+  je_cv_format_gnu_printf=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_format_gnu_printf" >&5
+$as_echo "$je_cv_format_gnu_printf" >&6; }
+
+CFLAGS="${SAVED_CFLAGS}"
+if test "x${je_cv_format_gnu_printf}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  " >>confdefs.h
+
+fi
+SAVED_CFLAGS="${CFLAGS}"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -Werror" >&5
+$as_echo_n "checking whether compiler supports -Werror... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-Werror"
+else
+  CFLAGS="${CFLAGS} -Werror"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-Werror
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether format(printf, ...) attribute is compilable" >&5
+$as_echo_n "checking whether format(printf, ...) attribute is compilable... " >&6; }
+if ${je_cv_format_printf+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+int
+main ()
+{
+void *foo(const char *format, ...) __attribute__((format(printf, 1, 2)));
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_format_printf=yes
+else
+  je_cv_format_printf=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_format_printf" >&5
+$as_echo "$je_cv_format_printf" >&6; }
+
+CFLAGS="${SAVED_CFLAGS}"
+if test "x${je_cv_format_printf}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  " >>confdefs.h
+
+fi
 
 
 # Check whether --with-rpath was given.
 if test "${with_rpath+set}" = set; then :
   withval=$with_rpath; if test "x$with_rpath" = "xno" ; then
   RPATH_EXTRA=
@@ -5400,13 +5736,13 @@
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
 
-public_syms="malloc_conf malloc_message malloc calloc posix_memalign aligned_alloc realloc free mallocx rallocx xallocx sallocx dallocx nallocx mallctl mallctlnametomib mallctlbymib malloc_stats_print malloc_usable_size"
+public_syms="malloc_conf malloc_message malloc calloc posix_memalign aligned_alloc realloc free mallocx rallocx xallocx sallocx dallocx sdallocx nallocx mallctl mallctlnametomib mallctlbymib malloc_stats_print malloc_usable_size"
 
 ac_fn_c_check_func "$LINENO" "memalign" "ac_cv_func_memalign"
 if test "x$ac_cv_func_memalign" = xyes; then :
   $as_echo "#define JEMALLOC_OVERRIDE_MEMALIGN  " >>confdefs.h
 
 	       public_syms="${public_syms} memalign"
@@ -5417,32 +5753,12 @@
   $as_echo "#define JEMALLOC_OVERRIDE_VALLOC  " >>confdefs.h
 
 	       public_syms="${public_syms} valloc"
 fi
 
 
-# Check whether --enable-experimental was given.
-if test "${enable_experimental+set}" = set; then :
-  enableval=$enable_experimental; if test "x$enable_experimental" = "xno" ; then
-  enable_experimental="0"
-else
-  enable_experimental="1"
-fi
-
-else
-  enable_experimental="1"
-
-fi
-
-if test "x$enable_experimental" = "x1" ; then
-  $as_echo "#define JEMALLOC_EXPERIMENTAL  " >>confdefs.h
-
-  public_syms="${public_syms} allocm dallocm nallocm rallocm sallocm"
-fi
-
-
 GCOV_FLAGS=
 # Check whether --enable-code-coverage was given.
 if test "${enable_code_coverage+set}" = set; then :
   enableval=$enable_code_coverage; if test "x$enable_code_coverage" = "xno" ; then
   enable_code_coverage="0"
 else
@@ -5610,54 +5927,60 @@
 install_suffix="$INSTALL_SUFFIX"
 
 
 je_="je_"
 
 
-cfgoutputs_in="${srcroot}Makefile.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}doc/html.xsl.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}doc/manpages.xsl.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}doc/jemalloc.xml.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}include/jemalloc/jemalloc_macros.h.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}include/jemalloc/jemalloc_protos.h.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}include/jemalloc/internal/jemalloc_internal.h.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}test/test.sh.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}test/include/test/jemalloc_test.h.in"
+cfgoutputs_in="Makefile.in"
+cfgoutputs_in="${cfgoutputs_in} jemalloc.pc.in"
+cfgoutputs_in="${cfgoutputs_in} doc/html.xsl.in"
+cfgoutputs_in="${cfgoutputs_in} doc/manpages.xsl.in"
+cfgoutputs_in="${cfgoutputs_in} doc/jemalloc.xml.in"
+cfgoutputs_in="${cfgoutputs_in} include/jemalloc/jemalloc_macros.h.in"
+cfgoutputs_in="${cfgoutputs_in} include/jemalloc/jemalloc_protos.h.in"
+cfgoutputs_in="${cfgoutputs_in} include/jemalloc/jemalloc_typedefs.h.in"
+cfgoutputs_in="${cfgoutputs_in} include/jemalloc/internal/jemalloc_internal.h.in"
+cfgoutputs_in="${cfgoutputs_in} test/test.sh.in"
+cfgoutputs_in="${cfgoutputs_in} test/include/test/jemalloc_test.h.in"
 
 cfgoutputs_out="Makefile"
+cfgoutputs_out="${cfgoutputs_out} jemalloc.pc"
 cfgoutputs_out="${cfgoutputs_out} doc/html.xsl"
 cfgoutputs_out="${cfgoutputs_out} doc/manpages.xsl"
 cfgoutputs_out="${cfgoutputs_out} doc/jemalloc.xml"
 cfgoutputs_out="${cfgoutputs_out} include/jemalloc/jemalloc_macros.h"
 cfgoutputs_out="${cfgoutputs_out} include/jemalloc/jemalloc_protos.h"
+cfgoutputs_out="${cfgoutputs_out} include/jemalloc/jemalloc_typedefs.h"
 cfgoutputs_out="${cfgoutputs_out} include/jemalloc/internal/jemalloc_internal.h"
 cfgoutputs_out="${cfgoutputs_out} test/test.sh"
 cfgoutputs_out="${cfgoutputs_out} test/include/test/jemalloc_test.h"
 
 cfgoutputs_tup="Makefile"
+cfgoutputs_tup="${cfgoutputs_tup} jemalloc.pc:jemalloc.pc.in"
 cfgoutputs_tup="${cfgoutputs_tup} doc/html.xsl:doc/html.xsl.in"
 cfgoutputs_tup="${cfgoutputs_tup} doc/manpages.xsl:doc/manpages.xsl.in"
 cfgoutputs_tup="${cfgoutputs_tup} doc/jemalloc.xml:doc/jemalloc.xml.in"
 cfgoutputs_tup="${cfgoutputs_tup} include/jemalloc/jemalloc_macros.h:include/jemalloc/jemalloc_macros.h.in"
 cfgoutputs_tup="${cfgoutputs_tup} include/jemalloc/jemalloc_protos.h:include/jemalloc/jemalloc_protos.h.in"
+cfgoutputs_tup="${cfgoutputs_tup} include/jemalloc/jemalloc_typedefs.h:include/jemalloc/jemalloc_typedefs.h.in"
 cfgoutputs_tup="${cfgoutputs_tup} include/jemalloc/internal/jemalloc_internal.h"
 cfgoutputs_tup="${cfgoutputs_tup} test/test.sh:test/test.sh.in"
 cfgoutputs_tup="${cfgoutputs_tup} test/include/test/jemalloc_test.h:test/include/test/jemalloc_test.h.in"
 
-cfghdrs_in="${srcroot}include/jemalloc/jemalloc_defs.h.in"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/jemalloc_internal_defs.h.in"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/private_namespace.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/private_unnamespace.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/private_symbols.txt"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/public_namespace.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/public_unnamespace.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/size_classes.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/jemalloc_rename.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/jemalloc_mangle.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/jemalloc.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}test/include/test/jemalloc_test_defs.h.in"
+cfghdrs_in="include/jemalloc/jemalloc_defs.h.in"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/jemalloc_internal_defs.h.in"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/private_namespace.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/private_unnamespace.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/private_symbols.txt"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/public_namespace.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/public_unnamespace.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/size_classes.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/jemalloc_rename.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/jemalloc_mangle.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/jemalloc.sh"
+cfghdrs_in="${cfghdrs_in} test/include/test/jemalloc_test_defs.h.in"
 
 cfghdrs_out="include/jemalloc/jemalloc_defs.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/jemalloc${install_suffix}.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/internal/private_namespace.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/internal/private_unnamespace.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/internal/public_symbols.txt"
@@ -5669,25 +5992,25 @@
 cfghdrs_out="${cfghdrs_out} include/jemalloc/jemalloc_mangle.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/jemalloc_mangle_jet.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/internal/jemalloc_internal_defs.h"
 cfghdrs_out="${cfghdrs_out} test/include/test/jemalloc_test_defs.h"
 
 cfghdrs_tup="include/jemalloc/jemalloc_defs.h:include/jemalloc/jemalloc_defs.h.in"
-cfghdrs_tup="${cfghdrs_tup} include/jemalloc/internal/jemalloc_internal_defs.h:${srcroot}include/jemalloc/internal/jemalloc_internal_defs.h.in"
-cfghdrs_tup="${cfghdrs_tup} test/include/test/jemalloc_test_defs.h:${srcroot}test/include/test/jemalloc_test_defs.h.in"
+cfghdrs_tup="${cfghdrs_tup} include/jemalloc/internal/jemalloc_internal_defs.h:include/jemalloc/internal/jemalloc_internal_defs.h.in"
+cfghdrs_tup="${cfghdrs_tup} test/include/test/jemalloc_test_defs.h:test/include/test/jemalloc_test_defs.h.in"
 
 # Check whether --enable-cc-silence was given.
 if test "${enable_cc_silence+set}" = set; then :
   enableval=$enable_cc_silence; if test "x$enable_cc_silence" = "xno" ; then
   enable_cc_silence="0"
 else
   enable_cc_silence="1"
 fi
 
 else
-  enable_cc_silence="0"
+  enable_cc_silence="1"
 
 fi
 
 if test "x$enable_cc_silence" = "x1" ; then
   $as_echo "#define JEMALLOC_CC_SILENCE  " >>confdefs.h
 
@@ -5706,12 +6029,16 @@
 
 fi
 
 if test "x$enable_debug" = "x1" ; then
   $as_echo "#define JEMALLOC_DEBUG  " >>confdefs.h
 
+fi
+if test "x$enable_debug" = "x1" ; then
+  $as_echo "#define JEMALLOC_DEBUG  " >>confdefs.h
+
   enable_ivsalloc="1"
 fi
 
 
 # Check whether --enable-ivsalloc was given.
 if test "${enable_ivsalloc+set}" = set; then :
@@ -5966,15 +6293,15 @@
   enable_prof_libunwind="0"
 fi
 
 done
 
   if test "x$LUNWIND" = "x-lunwind" ; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for backtrace in -lunwind" >&5
-$as_echo_n "checking for backtrace in -lunwind... " >&6; }
-if ${ac_cv_lib_unwind_backtrace+:} false; then :
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for unw_backtrace in -lunwind" >&5
+$as_echo_n "checking for unw_backtrace in -lunwind... " >&6; }
+if ${ac_cv_lib_unwind_unw_backtrace+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lunwind  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -5982,33 +6309,33 @@
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
 #ifdef __cplusplus
 extern "C"
 #endif
-char backtrace ();
+char unw_backtrace ();
 int
 main ()
 {
-return backtrace ();
+return unw_backtrace ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_unwind_backtrace=yes
+  ac_cv_lib_unwind_unw_backtrace=yes
 else
-  ac_cv_lib_unwind_backtrace=no
+  ac_cv_lib_unwind_unw_backtrace=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_unwind_backtrace" >&5
-$as_echo "$ac_cv_lib_unwind_backtrace" >&6; }
-if test "x$ac_cv_lib_unwind_backtrace" = xyes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_unwind_unw_backtrace" >&5
+$as_echo "$ac_cv_lib_unwind_unw_backtrace" >&6; }
+if test "x$ac_cv_lib_unwind_unw_backtrace" = xyes; then :
   LIBS="$LIBS $LUNWIND"
 else
   enable_prof_libunwind="0"
 fi
 
   else
@@ -6165,17 +6492,12 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking configured backtracing method" >&5
 $as_echo_n "checking configured backtracing method... " >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $backtrace_method" >&5
 $as_echo "$backtrace_method" >&6; }
 if test "x$enable_prof" = "x1" ; then
-  if test "x${force_tls}" = "x0" ; then
-    as_fn_error $? "Heap profiling requires TLS" "$LINENO" 5;
-  fi
-  force_tls="1"
-
   if test "x$abi" != "xpecoff"; then
         LIBS="$LIBS -lm"
   fi
 
   $as_echo "#define JEMALLOC_PROF  " >>confdefs.h
 
@@ -6198,69 +6520,17 @@
 if test "x$enable_tcache" = "x1" ; then
   $as_echo "#define JEMALLOC_TCACHE  " >>confdefs.h
 
 fi
 
 
-# Check whether --enable-mremap was given.
-if test "${enable_mremap+set}" = set; then :
-  enableval=$enable_mremap; if test "x$enable_mremap" = "xno" ; then
-  enable_mremap="0"
-else
-  enable_mremap="1"
-fi
-
-else
-  enable_mremap="0"
+if test "x${maps_coalesce}" = "x1" ; then
+  $as_echo "#define JEMALLOC_MAPS_COALESCE  " >>confdefs.h
 
 fi
 
-if test "x$enable_mremap" = "x1" ; then
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether mremap(...MREMAP_FIXED...) is compilable" >&5
-$as_echo_n "checking whether mremap(...MREMAP_FIXED...) is compilable... " >&6; }
-if ${je_cv_mremap_fixed+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#define	_GNU_SOURCE
-#include <sys/mman.h>
-
-int
-main ()
-{
-
-void *p = mremap((void *)0, 0, 0, MREMAP_MAYMOVE|MREMAP_FIXED, (void *)0);
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  je_cv_mremap_fixed=yes
-else
-  je_cv_mremap_fixed=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_mremap_fixed" >&5
-$as_echo "$je_cv_mremap_fixed" >&6; }
-
-  if test "x${je_cv_mremap_fixed}" = "xno" ; then
-    enable_mremap="0"
-  fi
-fi
-if test "x$enable_mremap" = "x1" ; then
-  $as_echo "#define JEMALLOC_MREMAP  " >>confdefs.h
-
-fi
-
-
 # Check whether --enable-munmap was given.
 if test "${enable_munmap+set}" = set; then :
   enableval=$enable_munmap; if test "x$enable_munmap" = "xno" ; then
   enable_munmap="0"
 else
   enable_munmap="1"
@@ -6274,51 +6544,35 @@
 if test "x$enable_munmap" = "x1" ; then
   $as_echo "#define JEMALLOC_MUNMAP  " >>confdefs.h
 
 fi
 
 
-# Check whether --enable-dss was given.
-if test "${enable_dss+set}" = set; then :
-  enableval=$enable_dss; if test "x$enable_dss" = "xno" ; then
-  enable_dss="0"
-else
-  enable_dss="1"
-fi
-
-else
-  enable_dss="0"
-
-fi
-
+have_dss="1"
 ac_fn_c_check_func "$LINENO" "sbrk" "ac_cv_func_sbrk"
 if test "x$ac_cv_func_sbrk" = xyes; then :
   have_sbrk="1"
 else
   have_sbrk="0"
 fi
 
 if test "x$have_sbrk" = "x1" ; then
-  if test "x$sbrk_deprecated" == "x1" ; then
+  if test "x$sbrk_deprecated" = "x1" ; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: Disabling dss allocation because sbrk is deprecated" >&5
 $as_echo "Disabling dss allocation because sbrk is deprecated" >&6; }
-    enable_dss="0"
-  else
-    $as_echo "#define JEMALLOC_HAVE_SBRK  " >>confdefs.h
-
+    have_dss="0"
   fi
 else
-  enable_dss="0"
+  have_dss="0"
 fi
 
-if test "x$enable_dss" = "x1" ; then
+if test "x$have_dss" = "x1" ; then
   $as_echo "#define JEMALLOC_DSS  " >>confdefs.h
 
 fi
 
-
 # Check whether --enable-fill was given.
 if test "${enable_fill+set}" = set; then :
   enableval=$enable_fill; if test "x$enable_fill" = "xno" ; then
   enable_fill="0"
 else
   enable_fill="1"
@@ -6462,28 +6716,171 @@
 
 else
   enable_xmalloc="0"
 
 fi
 
-if test "x$enable_xmalloc" = "x1" ; then
-  $as_echo "#define JEMALLOC_XMALLOC  " >>confdefs.h
+if test "x$enable_xmalloc" = "x1" ; then
+  $as_echo "#define JEMALLOC_XMALLOC  " >>confdefs.h
+
+fi
+
+
+# Check whether --enable-cache-oblivious was given.
+if test "${enable_cache_oblivious+set}" = set; then :
+  enableval=$enable_cache_oblivious; if test "x$enable_cache_oblivious" = "xno" ; then
+  enable_cache_oblivious="0"
+else
+  enable_cache_oblivious="1"
+fi
+
+else
+  enable_cache_oblivious="1"
+
+fi
+
+if test "x$enable_cache_oblivious" = "x1" ; then
+  $as_echo "#define JEMALLOC_CACHE_OBLIVIOUS  " >>confdefs.h
+
+fi
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program using __builtin_ffsl is compilable" >&5
+$as_echo_n "checking whether a program using __builtin_ffsl is compilable... " >&6; }
+if ${je_cv_gcc_builtin_ffsl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <strings.h>
+#include <string.h>
+
+int
+main ()
+{
+
+	{
+		int rv = __builtin_ffsl(0x08);
+		printf("%d\n", rv);
+	}
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_gcc_builtin_ffsl=yes
+else
+  je_cv_gcc_builtin_ffsl=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_gcc_builtin_ffsl" >&5
+$as_echo "$je_cv_gcc_builtin_ffsl" >&6; }
+
+if test "x${je_cv_gcc_builtin_ffsl}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_INTERNAL_FFSL __builtin_ffsl" >>confdefs.h
+
+  $as_echo "#define JEMALLOC_INTERNAL_FFS __builtin_ffs" >>confdefs.h
+
+else
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program using ffsl is compilable" >&5
+$as_echo_n "checking whether a program using ffsl is compilable... " >&6; }
+if ${je_cv_function_ffsl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+  #include <stdio.h>
+  #include <strings.h>
+  #include <string.h>
+
+int
+main ()
+{
+
+	{
+		int rv = ffsl(0x08);
+		printf("%d\n", rv);
+	}
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_function_ffsl=yes
+else
+  je_cv_function_ffsl=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_function_ffsl" >&5
+$as_echo "$je_cv_function_ffsl" >&6; }
+
+  if test "x${je_cv_function_ffsl}" = "xyes" ; then
+    $as_echo "#define JEMALLOC_INTERNAL_FFSL ffsl" >>confdefs.h
+
+    $as_echo "#define JEMALLOC_INTERNAL_FFS ffs" >>confdefs.h
+
+  else
+    as_fn_error $? "Cannot build without ffsl(3) or __builtin_ffsl()" "$LINENO" 5
+  fi
+fi
+
+
+# Check whether --with-lg_tiny_min was given.
+if test "${with_lg_tiny_min+set}" = set; then :
+  withval=$with_lg_tiny_min; LG_TINY_MIN="$with_lg_tiny_min"
+else
+  LG_TINY_MIN="3"
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define LG_TINY_MIN $LG_TINY_MIN
+_ACEOF
+
+
+
+# Check whether --with-lg_quantum was given.
+if test "${with_lg_quantum+set}" = set; then :
+  withval=$with_lg_quantum; LG_QUANTA="$with_lg_quantum"
+else
+  LG_QUANTA="3 4"
+fi
+
+if test "x$with_lg_quantum" != "x" ; then
+  cat >>confdefs.h <<_ACEOF
+#define LG_QUANTUM $with_lg_quantum
+_ACEOF
+
+fi
+
 
+# Check whether --with-lg_page was given.
+if test "${with_lg_page+set}" = set; then :
+  withval=$with_lg_page; LG_PAGE="$with_lg_page"
+else
+  LG_PAGE="detect"
 fi
 
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking STATIC_PAGE_SHIFT" >&5
-$as_echo_n "checking STATIC_PAGE_SHIFT... " >&6; }
-if ${je_cv_static_page_shift+:} false; then :
+if test "x$LG_PAGE" = "xdetect"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking LG_PAGE" >&5
+$as_echo_n "checking LG_PAGE... " >&6; }
+if ${je_cv_lg_page+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test "$cross_compiling" = yes; then :
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot run test program while cross compiling
-See \`config.log' for more details" "$LINENO" 5; }
+  je_cv_lg_page=12
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 #include <strings.h>
 #ifdef _WIN32
@@ -6507,13 +6904,13 @@
 #else
     result = sysconf(_SC_PAGESIZE);
 #endif
     if (result == -1) {
 	return 1;
     }
-    result = ffsl(result) - 1;
+    result = JEMALLOC_INTERNAL_FFSL(result) - 1;
 
     f = fopen("conftest.out", "w");
     if (f == NULL) {
 	return 1;
     }
     fprintf(f, "%d\n", result);
@@ -6523,38 +6920,64 @@
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_run "$LINENO"; then :
-  je_cv_static_page_shift=`cat conftest.out`
+  je_cv_lg_page=`cat conftest.out`
 else
-  je_cv_static_page_shift=undefined
+  je_cv_lg_page=undefined
 fi
 rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
   conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_static_page_shift" >&5
-$as_echo "$je_cv_static_page_shift" >&6; }
-
-if test "x$je_cv_static_page_shift" != "xundefined"; then
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_lg_page" >&5
+$as_echo "$je_cv_lg_page" >&6; }
+fi
+if test "x${je_cv_lg_page}" != "x" ; then
+  LG_PAGE="${je_cv_lg_page}"
+fi
+if test "x${LG_PAGE}" != "xundefined" ; then
    cat >>confdefs.h <<_ACEOF
-#define STATIC_PAGE_SHIFT $je_cv_static_page_shift
+#define LG_PAGE $LG_PAGE
 _ACEOF
 
 else
-   as_fn_error $? "cannot determine value for STATIC_PAGE_SHIFT" "$LINENO" 5
+   as_fn_error $? "cannot determine value for LG_PAGE" "$LINENO" 5
+fi
+
+
+# Check whether --with-lg_page_sizes was given.
+if test "${with_lg_page_sizes+set}" = set; then :
+  withval=$with_lg_page_sizes; LG_PAGE_SIZES="$with_lg_page_sizes"
+else
+  LG_PAGE_SIZES="$LG_PAGE"
+fi
+
+
+
+# Check whether --with-lg_size_class_group was given.
+if test "${with_lg_size_class_group+set}" = set; then :
+  withval=$with_lg_size_class_group; LG_SIZE_CLASS_GROUP="$with_lg_size_class_group"
+else
+  LG_SIZE_CLASS_GROUP="2"
 fi
 
 
-if test -d "${srcroot}.git" ; then
-  git describe --long --abbrev=40 > ${srcroot}VERSION
+if test ! -e "${objroot}VERSION" ; then
+  if test ! -e "${srcroot}VERSION" ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: Missing VERSION file, and unable to generate it; creating bogus VERSION" >&5
+$as_echo "Missing VERSION file, and unable to generate it; creating bogus VERSION" >&6; }
+    echo "0.0.0-0-g0000000000000000000000000000000000000000" > "${objroot}VERSION"
+  else
+    cp ${srcroot}VERSION ${objroot}VERSION
+  fi
 fi
-jemalloc_version=`cat ${srcroot}VERSION`
+jemalloc_version=`cat "${objroot}VERSION"`
 jemalloc_version_major=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print $1}'`
 jemalloc_version_minor=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print $2}'`
 jemalloc_version_bugfix=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print $3}'`
 jemalloc_version_nrev=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print $4}'`
 jemalloc_version_gid=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print $5}'`
 
@@ -6680,12 +7103,99 @@
 fi
 
 fi
 
 CPPFLAGS="$CPPFLAGS -D_REENTRANT"
 
+SAVED_LIBS="${LIBS}"
+LIBS=
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime" >&5
+$as_echo_n "checking for library containing clock_gettime... " >&6; }
+if ${ac_cv_search_clock_gettime+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char clock_gettime ();
+int
+main ()
+{
+return clock_gettime ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' rt; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_clock_gettime=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_clock_gettime+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_clock_gettime+:} false; then :
+
+else
+  ac_cv_search_clock_gettime=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_clock_gettime" >&5
+$as_echo "$ac_cv_search_clock_gettime" >&6; }
+ac_res=$ac_cv_search_clock_gettime
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+  TESTLIBS="${LIBS}"
+fi
+
+
+LIBS="${SAVED_LIBS}"
+
+ac_fn_c_check_func "$LINENO" "secure_getenv" "ac_cv_func_secure_getenv"
+if test "x$ac_cv_func_secure_getenv" = xyes; then :
+  have_secure_getenv="1"
+else
+  have_secure_getenv="0"
+
+fi
+
+if test "x$have_secure_getenv" = "x1" ; then
+  $as_echo "#define JEMALLOC_HAVE_SECURE_GETENV  " >>confdefs.h
+
+fi
+
+ac_fn_c_check_func "$LINENO" "issetugid" "ac_cv_func_issetugid"
+if test "x$ac_cv_func_issetugid" = xyes; then :
+  have_issetugid="1"
+else
+  have_issetugid="0"
+
+fi
+
+if test "x$have_issetugid" = "x1" ; then
+  $as_echo "#define JEMALLOC_HAVE_ISSETUGID  " >>confdefs.h
+
+fi
+
 ac_fn_c_check_func "$LINENO" "_malloc_thread_cleanup" "ac_cv_func__malloc_thread_cleanup"
 if test "x$ac_cv_func__malloc_thread_cleanup" = xyes; then :
   have__malloc_thread_cleanup="1"
 else
   have__malloc_thread_cleanup="0"
 
@@ -6716,17 +7226,17 @@
   enable_lazy_lock="0"
 else
   enable_lazy_lock="1"
 fi
 
 else
-  enable_lazy_lock="0"
+  enable_lazy_lock=""
 
 fi
 
-if test "x$enable_lazy_lock" = "x0" -a "x${force_lazy_lock}" = "x1" ; then
+if test "x$enable_lazy_lock" = "x" -a "x${force_lazy_lock}" = "x1" ; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: Forcing lazy-lock to avoid allocator/threading bootstrap issues" >&5
 $as_echo "Forcing lazy-lock to avoid allocator/threading bootstrap issues" >&6; }
   enable_lazy_lock="1"
 fi
 if test "x$enable_lazy_lock" = "x1" ; then
   if test "x$abi" != "xpecoff" ; then
@@ -6793,37 +7303,42 @@
 
 fi
 
   fi
   $as_echo "#define JEMALLOC_LAZY_LOCK  " >>confdefs.h
 
+else
+  enable_lazy_lock="0"
 fi
 
 
 # Check whether --enable-tls was given.
 if test "${enable_tls+set}" = set; then :
   enableval=$enable_tls; if test "x$enable_tls" = "xno" ; then
   enable_tls="0"
 else
   enable_tls="1"
 fi
 
 else
-  enable_tls="1"
+  enable_tls=""
 
 fi
 
-if test "x${enable_tls}" = "x0" -a "x${force_tls}" = "x1" ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: Forcing TLS to avoid allocator/threading bootstrap issues" >&5
+if test "x${enable_tls}" = "x" ; then
+  if test "x${force_tls}" = "x1" ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: Forcing TLS to avoid allocator/threading bootstrap issues" >&5
 $as_echo "Forcing TLS to avoid allocator/threading bootstrap issues" >&6; }
-  enable_tls="1"
-fi
-if test "x${enable_tls}" = "x1" -a "x${force_tls}" = "x0" ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: Forcing no TLS to avoid allocator/threading bootstrap issues" >&5
+    enable_tls="1"
+  elif test "x${force_tls}" = "x0" ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: Forcing no TLS to avoid allocator/threading bootstrap issues" >&5
 $as_echo "Forcing no TLS to avoid allocator/threading bootstrap issues" >&6; }
-  enable_tls="0"
+    enable_tls="0"
+  else
+    enable_tls="1"
+  fi
 fi
 if test "x${enable_tls}" = "x1" ; then
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for TLS" >&5
 $as_echo_n "checking for TLS... " >&6; }
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -6848,62 +7363,75 @@
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
               enable_tls="0"
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+else
+  enable_tls="0"
 fi
 
 if test "x${enable_tls}" = "x1" ; then
+  if test "x${force_tls}" = "x0" ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: TLS enabled despite being marked unusable on this platform" >&5
+$as_echo "$as_me: WARNING: TLS enabled despite being marked unusable on this platform" >&2;}
+  fi
   cat >>confdefs.h <<_ACEOF
 #define JEMALLOC_TLS
 _ACEOF
 
 elif test "x${force_tls}" = "x1" ; then
-  as_fn_error $? "Failed to configure TLS, which is mandatory for correct function" "$LINENO" 5
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: TLS disabled despite being marked critical on this platform" >&5
+$as_echo "$as_me: WARNING: TLS disabled despite being marked critical on this platform" >&2;}
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program using ffsl is compilable" >&5
-$as_echo_n "checking whether a program using ffsl is compilable... " >&6; }
-if ${je_cv_function_ffsl+:} false; then :
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether C11 atomics is compilable" >&5
+$as_echo_n "checking whether C11 atomics is compilable... " >&6; }
+if ${je_cv_c11atomics+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-#include <stdio.h>
-#include <strings.h>
-#include <string.h>
+#include <stdint.h>
+#if (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__)
+#include <stdatomic.h>
+#else
+#error Atomics not available
+#endif
 
 int
 main ()
 {
 
-	{
-		int rv = ffsl(0x08);
-		printf("%d\n", rv);
-	}
+    uint64_t *p = (uint64_t *)0;
+    uint64_t x = 1;
+    volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;
+    uint64_t r = atomic_fetch_add(a, x) + x;
+    return (r == 0);
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  je_cv_function_ffsl=yes
+  je_cv_c11atomics=yes
 else
-  je_cv_function_ffsl=no
+  je_cv_c11atomics=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_function_ffsl" >&5
-$as_echo "$je_cv_function_ffsl" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_c11atomics" >&5
+$as_echo "$je_cv_c11atomics" >&6; }
+
+if test "x${je_cv_c11atomics}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_C11ATOMICS 1" >>confdefs.h
 
-if test "x${je_cv_function_ffsl}" != "xyes" ; then
-   as_fn_error $? "Cannot build without ffsl(3)" "$LINENO" 5
 fi
 
 
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether atomic(9) is compilable" >&5
 $as_echo_n "checking whether atomic(9) is compilable... " >&6; }
@@ -6999,12 +7527,52 @@
   $as_echo "#define JEMALLOC_OSATOMIC  " >>confdefs.h
 
 fi
 
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether madvise(2) is compilable" >&5
+$as_echo_n "checking whether madvise(2) is compilable... " >&6; }
+if ${je_cv_madvise+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/mman.h>
+
+int
+main ()
+{
+
+	{
+		madvise((void *)0, 0, 0);
+	}
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_madvise=yes
+else
+  je_cv_madvise=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_madvise" >&5
+$as_echo "$je_cv_madvise" >&6; }
+
+if test "x${je_cv_madvise}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_HAVE_MADVISE  " >>confdefs.h
+
+fi
+
+
+
 
 if test "x${je_cv_atomic9}" != "xyes" -a "x${je_cv_osatomic}" != "xyes" ; then
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to force 32-bit __sync_{add,sub}_and_fetch()" >&5
 $as_echo_n "checking whether to force 32-bit __sync_{add,sub}_and_fetch()... " >&6; }
 if ${je_cv_sync_compare_and_swap_4+:} false; then :
@@ -7094,12 +7662,54 @@
 
   fi
 
 fi
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for __builtin_clz" >&5
+$as_echo_n "checking for __builtin_clz... " >&6; }
+if ${je_cv_builtin_clz+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+                                                {
+                                                        unsigned x = 0;
+                                                        int y = __builtin_clz(x);
+                                                }
+                                                {
+                                                        unsigned long x = 0;
+                                                        int y = __builtin_clzl(x);
+                                                }
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_builtin_clz=yes
+else
+  je_cv_builtin_clz=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_builtin_clz" >&5
+$as_echo "$je_cv_builtin_clz" >&6; }
+
+if test "x${je_cv_builtin_clz}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_HAVE_BUILTIN_CLZ  " >>confdefs.h
+
+fi
+
+
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether Darwin OSSpin*() is compilable" >&5
 $as_echo_n "checking whether Darwin OSSpin*() is compilable... " >&6; }
 if ${je_cv_osspin+:} false; then :
   $as_echo_n "(cached) " >&6
 else
@@ -7157,14 +7767,12 @@
 
 
 if test "x${enable_zone_allocator}" = "x1" ; then
   if test "x${abi}" != "xmacho"; then
     as_fn_error $? "--enable-zone-allocator is only supported on Darwin" "$LINENO" 5
   fi
-  $as_echo "#define JEMALLOC_IVSALLOC  " >>confdefs.h
-
   $as_echo "#define JEMALLOC_ZONE  " >>confdefs.h
 
 
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking malloc zone version" >&5
 $as_echo_n "checking malloc zone version... " >&6; }
 
@@ -7172,13 +7780,13 @@
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <malloc/malloc.h>
 int
 main ()
 {
-static foo[sizeof(malloc_zone_t) == sizeof(void *) * 14 ? 1 : -1]
+static int foo[sizeof(malloc_zone_t) == sizeof(void *) * 14 ? 1 : -1]
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
@@ -7188,13 +7796,13 @@
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <malloc/malloc.h>
 int
 main ()
 {
-static foo[sizeof(malloc_zone_t) == sizeof(void *) * 15 ? 1 : -1]
+static int foo[sizeof(malloc_zone_t) == sizeof(void *) * 15 ? 1 : -1]
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
@@ -7204,13 +7812,13 @@
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <malloc/malloc.h>
 int
 main ()
 {
-static foo[sizeof(malloc_zone_t) == sizeof(void *) * 16 ? 1 : -1]
+static int foo[sizeof(malloc_zone_t) == sizeof(void *) * 16 ? 1 : -1]
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
@@ -7218,13 +7826,13 @@
     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <malloc/malloc.h>
 int
 main ()
 {
-static foo[sizeof(malloc_introspection_t) == sizeof(void *) * 9 ? 1 : -1]
+static int foo[sizeof(malloc_introspection_t) == sizeof(void *) * 9 ? 1 : -1]
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
@@ -7234,13 +7842,13 @@
     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <malloc/malloc.h>
 int
 main ()
 {
-static foo[sizeof(malloc_introspection_t) == sizeof(void *) * 13 ? 1 : -1]
+static int foo[sizeof(malloc_introspection_t) == sizeof(void *) * 13 ? 1 : -1]
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
@@ -7257,13 +7865,13 @@
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <malloc/malloc.h>
 int
 main ()
 {
-static foo[sizeof(malloc_zone_t) == sizeof(void *) * 17 ? 1 : -1]
+static int foo[sizeof(malloc_zone_t) == sizeof(void *) * 17 ? 1 : -1]
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
@@ -7273,13 +7881,13 @@
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <malloc/malloc.h>
 int
 main ()
 {
-static foo[sizeof(malloc_zone_t) > sizeof(void *) * 17 ? 1 : -1]
+static int foo[sizeof(malloc_zone_t) > sizeof(void *) * 17 ? 1 : -1]
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
@@ -7313,12 +7921,137 @@
   cat >>confdefs.h <<_ACEOF
 #define JEMALLOC_ZONE_VERSION $JEMALLOC_ZONE_VERSION
 _ACEOF
 
 fi
 
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether glibc malloc hook is compilable" >&5
+$as_echo_n "checking whether glibc malloc hook is compilable... " >&6; }
+if ${je_cv_glibc_malloc_hook+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <stddef.h>
+
+extern void (* __free_hook)(void *ptr);
+extern void *(* __malloc_hook)(size_t size);
+extern void *(* __realloc_hook)(void *ptr, size_t size);
+
+int
+main ()
+{
+
+  void *ptr = 0L;
+  if (__malloc_hook) ptr = __malloc_hook(1);
+  if (__realloc_hook) ptr = __realloc_hook(ptr, 2);
+  if (__free_hook && ptr) __free_hook(ptr);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_glibc_malloc_hook=yes
+else
+  je_cv_glibc_malloc_hook=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_glibc_malloc_hook" >&5
+$as_echo "$je_cv_glibc_malloc_hook" >&6; }
+
+if test "x${je_cv_glibc_malloc_hook}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_GLIBC_MALLOC_HOOK  " >>confdefs.h
+
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether glibc memalign hook is compilable" >&5
+$as_echo_n "checking whether glibc memalign hook is compilable... " >&6; }
+if ${je_cv_glibc_memalign_hook+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <stddef.h>
+
+extern void *(* __memalign_hook)(size_t alignment, size_t size);
+
+int
+main ()
+{
+
+  void *ptr = 0L;
+  if (__memalign_hook) ptr = __memalign_hook(16, 7);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_glibc_memalign_hook=yes
+else
+  je_cv_glibc_memalign_hook=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_glibc_memalign_hook" >&5
+$as_echo "$je_cv_glibc_memalign_hook" >&6; }
+
+if test "x${je_cv_glibc_memalign_hook}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_GLIBC_MEMALIGN_HOOK  " >>confdefs.h
+
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether pthreads adaptive mutexes is compilable" >&5
+$as_echo_n "checking whether pthreads adaptive mutexes is compilable... " >&6; }
+if ${je_cv_pthread_mutex_adaptive_np+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <pthread.h>
+
+int
+main ()
+{
+
+  pthread_mutexattr_t attr;
+  pthread_mutexattr_init(&attr);
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);
+  pthread_mutexattr_destroy(&attr);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_pthread_mutex_adaptive_np=yes
+else
+  je_cv_pthread_mutex_adaptive_np=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_pthread_mutex_adaptive_np" >&5
+$as_echo "$je_cv_pthread_mutex_adaptive_np" >&6; }
+
+if test "x${je_cv_pthread_mutex_adaptive_np}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP  " >>confdefs.h
+
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for stdbool.h that conforms to C99" >&5
 $as_echo_n "checking for stdbool.h that conforms to C99... " >&6; }
 if ${ac_cv_header_stdbool_h+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -7437,13 +8170,13 @@
 
 
 ac_config_headers="$ac_config_headers $cfghdrs_tup"
 
 
 
-ac_config_files="$ac_config_files $cfgoutputs_tup config.stamp bin/jemalloc.sh"
+ac_config_files="$ac_config_files $cfgoutputs_tup config.stamp bin/jemalloc-config bin/jemalloc.sh bin/jeprof"
 
 
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -8155,14 +8888,19 @@
 
 
   srcdir="${srcdir}"
   objroot="${objroot}"
 
 
+  SHELL="${SHELL}"
   srcdir="${srcdir}"
   objroot="${objroot}"
+  LG_QUANTA="${LG_QUANTA}"
+  LG_TINY_MIN=${LG_TINY_MIN}
+  LG_PAGE_SIZES="${LG_PAGE_SIZES}"
+  LG_SIZE_CLASS_GROUP=${LG_SIZE_CLASS_GROUP}
 
 
   srcdir="${srcdir}"
   objroot="${objroot}"
 
 
@@ -8202,13 +8940,15 @@
     "include/jemalloc/jemalloc_mangle.h") CONFIG_COMMANDS="$CONFIG_COMMANDS include/jemalloc/jemalloc_mangle.h" ;;
     "include/jemalloc/jemalloc_mangle_jet.h") CONFIG_COMMANDS="$CONFIG_COMMANDS include/jemalloc/jemalloc_mangle_jet.h" ;;
     "include/jemalloc/jemalloc.h") CONFIG_COMMANDS="$CONFIG_COMMANDS include/jemalloc/jemalloc.h" ;;
     "$cfghdrs_tup") CONFIG_HEADERS="$CONFIG_HEADERS $cfghdrs_tup" ;;
     "$cfgoutputs_tup") CONFIG_FILES="$CONFIG_FILES $cfgoutputs_tup" ;;
     "config.stamp") CONFIG_FILES="$CONFIG_FILES config.stamp" ;;
+    "bin/jemalloc-config") CONFIG_FILES="$CONFIG_FILES bin/jemalloc-config" ;;
     "bin/jemalloc.sh") CONFIG_FILES="$CONFIG_FILES bin/jemalloc.sh" ;;
+    "bin/jeprof") CONFIG_FILES="$CONFIG_FILES bin/jeprof" ;;
 
   *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
 
 
@@ -8792,13 +9532,13 @@
     "include/jemalloc/internal/public_unnamespace.h":C)
   mkdir -p "${objroot}include/jemalloc/internal"
   "${srcdir}/include/jemalloc/internal/public_unnamespace.sh" "${objroot}include/jemalloc/internal/public_symbols.txt" > "${objroot}include/jemalloc/internal/public_unnamespace.h"
  ;;
     "include/jemalloc/internal/size_classes.h":C)
   mkdir -p "${objroot}include/jemalloc/internal"
-  "${srcdir}/include/jemalloc/internal/size_classes.sh" > "${objroot}include/jemalloc/internal/size_classes.h"
+  "${SHELL}" "${srcdir}/include/jemalloc/internal/size_classes.sh" "${LG_QUANTA}" ${LG_TINY_MIN} "${LG_PAGE_SIZES}" ${LG_SIZE_CLASS_GROUP} > "${objroot}include/jemalloc/internal/size_classes.h"
  ;;
     "include/jemalloc/jemalloc_protos_jet.h":C)
   mkdir -p "${objroot}include/jemalloc"
   cat "${srcdir}/include/jemalloc/jemalloc_protos.h.in" | sed -e 's/@je_@/jet_/g' > "${objroot}include/jemalloc/jemalloc_protos_jet.h"
  ;;
     "include/jemalloc/jemalloc_rename.h":C)
@@ -8861,24 +9601,28 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: jemalloc version   : ${jemalloc_version}" >&5
 $as_echo "jemalloc version   : ${jemalloc_version}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: library revision   : ${rev}" >&5
 $as_echo "library revision   : ${rev}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: " >&5
 $as_echo "" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: CONFIG             : ${CONFIG}" >&5
+$as_echo "CONFIG             : ${CONFIG}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: CC                 : ${CC}" >&5
 $as_echo "CC                 : ${CC}" >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: CPPFLAGS           : ${CPPFLAGS}" >&5
-$as_echo "CPPFLAGS           : ${CPPFLAGS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: CFLAGS             : ${CFLAGS}" >&5
 $as_echo "CFLAGS             : ${CFLAGS}" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: CPPFLAGS           : ${CPPFLAGS}" >&5
+$as_echo "CPPFLAGS           : ${CPPFLAGS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: LDFLAGS            : ${LDFLAGS}" >&5
 $as_echo "LDFLAGS            : ${LDFLAGS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: EXTRA_LDFLAGS      : ${EXTRA_LDFLAGS}" >&5
 $as_echo "EXTRA_LDFLAGS      : ${EXTRA_LDFLAGS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: LIBS               : ${LIBS}" >&5
 $as_echo "LIBS               : ${LIBS}" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: TESTLIBS           : ${TESTLIBS}" >&5
+$as_echo "TESTLIBS           : ${TESTLIBS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: RPATH_EXTRA        : ${RPATH_EXTRA}" >&5
 $as_echo "RPATH_EXTRA        : ${RPATH_EXTRA}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: " >&5
 $as_echo "" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: XSLTPROC           : ${XSLTPROC}" >&5
 $as_echo "XSLTPROC           : ${XSLTPROC}" >&6; }
@@ -8887,18 +9631,18 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: " >&5
 $as_echo "" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: PREFIX             : ${PREFIX}" >&5
 $as_echo "PREFIX             : ${PREFIX}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: BINDIR             : ${BINDIR}" >&5
 $as_echo "BINDIR             : ${BINDIR}" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: DATADIR            : ${DATADIR}" >&5
+$as_echo "DATADIR            : ${DATADIR}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: INCLUDEDIR         : ${INCLUDEDIR}" >&5
 $as_echo "INCLUDEDIR         : ${INCLUDEDIR}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: LIBDIR             : ${LIBDIR}" >&5
 $as_echo "LIBDIR             : ${LIBDIR}" >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: DATADIR            : ${DATADIR}" >&5
-$as_echo "DATADIR            : ${DATADIR}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: MANDIR             : ${MANDIR}" >&5
 $as_echo "MANDIR             : ${MANDIR}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: " >&5
 $as_echo "" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: srcroot            : ${srcroot}" >&5
 $as_echo "srcroot            : ${srcroot}" >&6; }
@@ -8917,14 +9661,12 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:                    : ${JEMALLOC_PRIVATE_NAMESPACE}" >&5
 $as_echo "                   : ${JEMALLOC_PRIVATE_NAMESPACE}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: install_suffix     : ${install_suffix}" >&5
 $as_echo "install_suffix     : ${install_suffix}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: autogen            : ${enable_autogen}" >&5
 $as_echo "autogen            : ${enable_autogen}" >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: experimental       : ${enable_experimental}" >&5
-$as_echo "experimental       : ${enable_experimental}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: cc-silence         : ${enable_cc_silence}" >&5
 $as_echo "cc-silence         : ${enable_cc_silence}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: debug              : ${enable_debug}" >&5
 $as_echo "debug              : ${enable_debug}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: code-coverage      : ${enable_code_coverage}" >&5
 $as_echo "code-coverage      : ${enable_code_coverage}" >&6; }
@@ -8945,18 +9687,16 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: utrace             : ${enable_utrace}" >&5
 $as_echo "utrace             : ${enable_utrace}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: valgrind           : ${enable_valgrind}" >&5
 $as_echo "valgrind           : ${enable_valgrind}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: xmalloc            : ${enable_xmalloc}" >&5
 $as_echo "xmalloc            : ${enable_xmalloc}" >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: mremap             : ${enable_mremap}" >&5
-$as_echo "mremap             : ${enable_mremap}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: munmap             : ${enable_munmap}" >&5
 $as_echo "munmap             : ${enable_munmap}" >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: dss                : ${enable_dss}" >&5
-$as_echo "dss                : ${enable_dss}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: lazy_lock          : ${enable_lazy_lock}" >&5
 $as_echo "lazy_lock          : ${enable_lazy_lock}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: tls                : ${enable_tls}" >&5
 $as_echo "tls                : ${enable_tls}" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: cache-oblivious    : ${enable_cache_oblivious}" >&5
+$as_echo "cache-oblivious    : ${enable_cache_oblivious}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: ===============================================================================" >&5
 $as_echo "===============================================================================" >&6; }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/configure.ac	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/configure.ac	2016-05-06 15:11:36.000000000 +0800
@@ -40,14 +40,17 @@
                                [$4=yes],
                                [$4=no])])
 ])
 
 dnl ============================================================================
 
+CONFIG=`echo ${ac_configure_args} | sed -e 's#'"'"'\([^ ]*\)'"'"'#\1#g'`
+AC_SUBST([CONFIG])
+
 dnl Library revision.
-rev=1
+rev=2
 AC_SUBST([rev])
 
 srcroot=$srcdir
 if test "x${srcroot}" = "x." ; then
   srcroot=""
 else
@@ -131,20 +134,22 @@
   if test "x$GCC" = "xyes" ; then
     JE_CFLAGS_APPEND([-std=gnu99])
     if test "x$je_cv_cflags_appended" = "x-std=gnu99" ; then
       AC_DEFINE_UNQUOTED([JEMALLOC_HAS_RESTRICT])
     fi
     JE_CFLAGS_APPEND([-Wall])
+    JE_CFLAGS_APPEND([-Werror=declaration-after-statement])
     JE_CFLAGS_APPEND([-pipe])
     JE_CFLAGS_APPEND([-g3])
   elif test "x$je_cv_msvc" = "xyes" ; then
     CC="$CC -nologo"
     JE_CFLAGS_APPEND([-Zi])
     JE_CFLAGS_APPEND([-MT])
     JE_CFLAGS_APPEND([-W3])
-    CPPFLAGS="$CPPFLAGS -I${srcroot}/include/msvc_compat"
+    JE_CFLAGS_APPEND([-FS])
+    CPPFLAGS="$CPPFLAGS -I${srcdir}/include/msvc_compat"
   fi
 fi
 dnl Append EXTRA_CFLAGS to CFLAGS, if defined.
 if test "x$EXTRA_CFLAGS" != "x" ; then
   JE_CFLAGS_APPEND([$EXTRA_CFLAGS])
 fi
@@ -152,12 +157,16 @@
 
 AC_C_BIGENDIAN([ac_cv_big_endian=1], [ac_cv_big_endian=0])
 if test "x${ac_cv_big_endian}" = "x1" ; then
   AC_DEFINE_UNQUOTED([JEMALLOC_BIG_ENDIAN], [ ])
 fi
 
+if test "x${je_cv_msvc}" = "xyes" -a "x${ac_cv_header_inttypes_h}" = "xno"; then
+  CPPFLAGS="$CPPFLAGS -I${srcdir}/include/msvc_compat/C99"
+fi
+
 AC_CHECK_SIZEOF([void *])
 if test "x${ac_cv_sizeof_void_p}" = "x8" ; then
   LG_SIZEOF_PTR=3
 elif test "x${ac_cv_sizeof_void_p}" = "x4" ; then
   LG_SIZEOF_PTR=2
 else
@@ -198,29 +207,20 @@
 AC_DEFINE_UNQUOTED([LG_SIZEOF_INTMAX_T], [$LG_SIZEOF_INTMAX_T])
 
 AC_CANONICAL_HOST
 dnl CPU-specific settings.
 CPU_SPINWAIT=""
 case "${host_cpu}" in
-  i[[345]]86)
-	;;
   i686|x86_64)
-	JE_COMPILABLE([pause instruction], [],
-	              [[__asm__ volatile("pause"); return 0;]],
-	              [je_cv_pause])
+	AC_CACHE_VAL([je_cv_pause],
+	  [JE_COMPILABLE([pause instruction], [],
+	                [[__asm__ volatile("pause"); return 0;]],
+	                [je_cv_pause])])
 	if test "x${je_cv_pause}" = "xyes" ; then
 	    CPU_SPINWAIT='__asm__ volatile("pause")'
 	fi
-	dnl emmintrin.h fails to compile unless MMX, SSE, and SSE2 are
-	dnl supported.
-	JE_COMPILABLE([SSE2 intrinsics], [
-#include <emmintrin.h>
-], [], [je_cv_sse2])
-	if test "x${je_cv_sse2}" = "xyes" ; then
-	  AC_DEFINE_UNQUOTED([HAVE_SSE2], [ ])
-	fi
 	;;
   powerpc)
 	AC_DEFINE_UNQUOTED([HAVE_ALTIVEC], [ ])
 	;;
   *)
 	;;
@@ -255,41 +255,57 @@
 dnl not worth the trouble.
 dnl 
 dnl Define cpp macros in CPPFLAGS, rather than doing AC_DEFINE(macro), since the
 dnl definitions need to be seen before any headers are included, which is a pain
 dnl to make happen otherwise.
 default_munmap="1"
-JEMALLOC_USABLE_SIZE_CONST="const"
+maps_coalesce="1"
 case "${host}" in
-  *-*-darwin*)
+  *-*-darwin* | *-*-ios*)
 	CFLAGS="$CFLAGS"
 	abi="macho"
 	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
 	RPATH=""
 	LD_PRELOAD_VAR="DYLD_INSERT_LIBRARIES"
 	so="dylib"
 	importlib="${so}"
 	force_tls="0"
-	DSO_LDFLAGS='-shared -Wl,-dylib_install_name,$(@F)'
+	DSO_LDFLAGS='-shared -Wl,-install_name,$(LIBDIR)/$(@F)'
 	SOREV="${rev}.${so}"
 	sbrk_deprecated="1"
 	;;
   *-*-freebsd*)
 	CFLAGS="$CFLAGS"
 	abi="elf"
 	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
 	force_lazy_lock="1"
 	;;
+  *-*-dragonfly*)
+	CFLAGS="$CFLAGS"
+	abi="elf"
+	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
+	;;
+  *-*-openbsd*)
+	CFLAGS="$CFLAGS"
+	abi="elf"
+	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
+	force_tls="0"
+	;;
+  *-*-bitrig*)
+	CFLAGS="$CFLAGS"
+	abi="elf"
+	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
+	;;
   *-*-linux*)
 	CFLAGS="$CFLAGS"
 	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
 	abi="elf"
 	AC_DEFINE([JEMALLOC_HAS_ALLOCA_H])
 	AC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED], [ ])
 	AC_DEFINE([JEMALLOC_THREADED_INIT], [ ])
-	JEMALLOC_USABLE_SIZE_CONST=""
+	AC_DEFINE([JEMALLOC_USE_CXX_THROW], [ ])
 	default_munmap="0"
 	;;
   *-*-netbsd*)
 	AC_MSG_CHECKING([ABI])
         AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
 [[#ifdef __ELF__
@@ -319,15 +335,17 @@
 	else
 	  dnl 32bit AIX
 	  LD_PRELOAD_VAR="LDR_PRELOAD"
 	fi
 	abi="xcoff"
 	;;
-  *-*-mingw*)
+  *-*-mingw* | *-*-cygwin*)
 	abi="pecoff"
 	force_tls="0"
+	force_lazy_lock="1"
+	maps_coalesce="0"
 	RPATH=""
 	so="dll"
 	if test "x$je_cv_msvc" = "xyes" ; then
 	  importlib="lib"
 	  DSO_LDFLAGS="-LD"
 	  EXTRA_LDFLAGS="-link -DEBUG"
@@ -348,12 +366,28 @@
 	;;
   *)
 	AC_MSG_RESULT([Unsupported operating system: ${host}])
 	abi="elf"
 	;;
 esac
+
+JEMALLOC_USABLE_SIZE_CONST=const
+AC_CHECK_HEADERS([malloc.h], [
+  AC_MSG_CHECKING([whether malloc_usable_size definition can use const argument])
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+    [#include <malloc.h>
+     #include <stddef.h>
+    size_t malloc_usable_size(const void *ptr);
+    ],
+    [])],[
+                AC_MSG_RESULT([yes])
+         ],[
+                JEMALLOC_USABLE_SIZE_CONST=
+                AC_MSG_RESULT([no])
+         ])
+])
 AC_DEFINE_UNQUOTED([JEMALLOC_USABLE_SIZE_CONST], [$JEMALLOC_USABLE_SIZE_CONST])
 AC_SUBST([abi])
 AC_SUBST([RPATH])
 AC_SUBST([LD_PRELOAD_VAR])
 AC_SUBST([so])
 AC_SUBST([importlib])
@@ -384,22 +418,52 @@
 fi
 dnl Check for tls_model attribute support (clang 3.0 still lacks support).
 SAVED_CFLAGS="${CFLAGS}"
 JE_CFLAGS_APPEND([-Werror])
 JE_COMPILABLE([tls_model attribute], [],
               [static __thread int
-               __attribute__((tls_model("initial-exec"))) foo;
+               __attribute__((tls_model("initial-exec"), unused)) foo;
                foo = 0;],
               [je_cv_tls_model])
 CFLAGS="${SAVED_CFLAGS}"
 if test "x${je_cv_tls_model}" = "xyes" ; then
   AC_DEFINE([JEMALLOC_TLS_MODEL],
             [__attribute__((tls_model("initial-exec")))])
 else
   AC_DEFINE([JEMALLOC_TLS_MODEL], [ ])
 fi
+dnl Check for alloc_size attribute support.
+SAVED_CFLAGS="${CFLAGS}"
+JE_CFLAGS_APPEND([-Werror])
+JE_COMPILABLE([alloc_size attribute], [#include <stdlib.h>],
+              [void *foo(size_t size) __attribute__((alloc_size(1)));],
+              [je_cv_alloc_size])
+CFLAGS="${SAVED_CFLAGS}"
+if test "x${je_cv_alloc_size}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_HAVE_ATTR_ALLOC_SIZE], [ ])
+fi
+dnl Check for format(gnu_printf, ...) attribute support.
+SAVED_CFLAGS="${CFLAGS}"
+JE_CFLAGS_APPEND([-Werror])
+JE_COMPILABLE([format(gnu_printf, ...) attribute], [#include <stdlib.h>],
+              [void *foo(const char *format, ...) __attribute__((format(gnu_printf, 1, 2)));],
+              [je_cv_format_gnu_printf])
+CFLAGS="${SAVED_CFLAGS}"
+if test "x${je_cv_format_gnu_printf}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF], [ ])
+fi
+dnl Check for format(printf, ...) attribute support.
+SAVED_CFLAGS="${CFLAGS}"
+JE_CFLAGS_APPEND([-Werror])
+JE_COMPILABLE([format(printf, ...) attribute], [#include <stdlib.h>],
+              [void *foo(const char *format, ...) __attribute__((format(printf, 1, 2)));],
+              [je_cv_format_printf])
+CFLAGS="${SAVED_CFLAGS}"
+if test "x${je_cv_format_printf}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_PRINTF], [ ])
+fi
 
 dnl Support optional additions to rpath.
 AC_ARG_WITH([rpath],
   [AS_HELP_STRING([--with-rpath=<rpath>], [Colon-separated rpath (ELF systems only)])],
 if test "x$with_rpath" = "xno" ; then
   RPATH_EXTRA=
@@ -425,40 +489,22 @@
 
 AC_PROG_INSTALL
 AC_PROG_RANLIB
 AC_PATH_PROG([LD], [ld], [false], [$PATH])
 AC_PATH_PROG([AUTOCONF], [autoconf], [false], [$PATH])
 
-public_syms="malloc_conf malloc_message malloc calloc posix_memalign aligned_alloc realloc free mallocx rallocx xallocx sallocx dallocx nallocx mallctl mallctlnametomib mallctlbymib malloc_stats_print malloc_usable_size"
+public_syms="malloc_conf malloc_message malloc calloc posix_memalign aligned_alloc realloc free mallocx rallocx xallocx sallocx dallocx sdallocx nallocx mallctl mallctlnametomib mallctlbymib malloc_stats_print malloc_usable_size"
 
 dnl Check for allocator-related functions that should be wrapped.
 AC_CHECK_FUNC([memalign],
 	      [AC_DEFINE([JEMALLOC_OVERRIDE_MEMALIGN], [ ])
 	       public_syms="${public_syms} memalign"])
 AC_CHECK_FUNC([valloc],
 	      [AC_DEFINE([JEMALLOC_OVERRIDE_VALLOC], [ ])
 	       public_syms="${public_syms} valloc"])
 
-dnl Support the experimental API by default.
-AC_ARG_ENABLE([experimental],
-  [AS_HELP_STRING([--disable-experimental],
-   [Disable support for the experimental API])],
-[if test "x$enable_experimental" = "xno" ; then
-  enable_experimental="0"
-else
-  enable_experimental="1"
-fi
-],
-[enable_experimental="1"]
-)
-if test "x$enable_experimental" = "x1" ; then
-  AC_DEFINE([JEMALLOC_EXPERIMENTAL], [ ])
-  public_syms="${public_syms} allocm dallocm nallocm rallocm sallocm"
-fi
-AC_SUBST([enable_experimental])
-
 dnl Do not compute test code coverage by default.
 GCOV_FLAGS=
 AC_ARG_ENABLE([code-coverage],
   [AS_HELP_STRING([--enable-code-coverage],
    [Enable code coverage])],
 [if test "x$enable_code_coverage" = "xno" ; then
@@ -498,12 +544,13 @@
 )
 if test "x$JEMALLOC_PREFIX" != "x" ; then
   JEMALLOC_CPREFIX=`echo ${JEMALLOC_PREFIX} | tr "a-z" "A-Z"`
   AC_DEFINE_UNQUOTED([JEMALLOC_PREFIX], ["$JEMALLOC_PREFIX"])
   AC_DEFINE_UNQUOTED([JEMALLOC_CPREFIX], ["$JEMALLOC_CPREFIX"])
 fi
+AC_SUBST([JEMALLOC_CPREFIX])
 
 AC_ARG_WITH([export],
   [AS_HELP_STRING([--without-export], [disable exporting jemalloc public APIs])],
   [if test "x$with_export" = "xno"; then
   AC_DEFINE([JEMALLOC_EXPORT],[])
 fi]
@@ -530,54 +577,60 @@
 
 dnl Substitute @je_@ in jemalloc_protos.h.in, primarily to make generation of
 dnl jemalloc_protos_jet.h easy.
 je_="je_"
 AC_SUBST([je_])
 
-cfgoutputs_in="${srcroot}Makefile.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}doc/html.xsl.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}doc/manpages.xsl.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}doc/jemalloc.xml.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}include/jemalloc/jemalloc_macros.h.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}include/jemalloc/jemalloc_protos.h.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}include/jemalloc/internal/jemalloc_internal.h.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}test/test.sh.in"
-cfgoutputs_in="${cfgoutputs_in} ${srcroot}test/include/test/jemalloc_test.h.in"
+cfgoutputs_in="Makefile.in"
+cfgoutputs_in="${cfgoutputs_in} jemalloc.pc.in"
+cfgoutputs_in="${cfgoutputs_in} doc/html.xsl.in"
+cfgoutputs_in="${cfgoutputs_in} doc/manpages.xsl.in"
+cfgoutputs_in="${cfgoutputs_in} doc/jemalloc.xml.in"
+cfgoutputs_in="${cfgoutputs_in} include/jemalloc/jemalloc_macros.h.in"
+cfgoutputs_in="${cfgoutputs_in} include/jemalloc/jemalloc_protos.h.in"
+cfgoutputs_in="${cfgoutputs_in} include/jemalloc/jemalloc_typedefs.h.in"
+cfgoutputs_in="${cfgoutputs_in} include/jemalloc/internal/jemalloc_internal.h.in"
+cfgoutputs_in="${cfgoutputs_in} test/test.sh.in"
+cfgoutputs_in="${cfgoutputs_in} test/include/test/jemalloc_test.h.in"
 
 cfgoutputs_out="Makefile"
+cfgoutputs_out="${cfgoutputs_out} jemalloc.pc"
 cfgoutputs_out="${cfgoutputs_out} doc/html.xsl"
 cfgoutputs_out="${cfgoutputs_out} doc/manpages.xsl"
 cfgoutputs_out="${cfgoutputs_out} doc/jemalloc.xml"
 cfgoutputs_out="${cfgoutputs_out} include/jemalloc/jemalloc_macros.h"
 cfgoutputs_out="${cfgoutputs_out} include/jemalloc/jemalloc_protos.h"
+cfgoutputs_out="${cfgoutputs_out} include/jemalloc/jemalloc_typedefs.h"
 cfgoutputs_out="${cfgoutputs_out} include/jemalloc/internal/jemalloc_internal.h"
 cfgoutputs_out="${cfgoutputs_out} test/test.sh"
 cfgoutputs_out="${cfgoutputs_out} test/include/test/jemalloc_test.h"
 
 cfgoutputs_tup="Makefile"
+cfgoutputs_tup="${cfgoutputs_tup} jemalloc.pc:jemalloc.pc.in"
 cfgoutputs_tup="${cfgoutputs_tup} doc/html.xsl:doc/html.xsl.in"
 cfgoutputs_tup="${cfgoutputs_tup} doc/manpages.xsl:doc/manpages.xsl.in"
 cfgoutputs_tup="${cfgoutputs_tup} doc/jemalloc.xml:doc/jemalloc.xml.in"
 cfgoutputs_tup="${cfgoutputs_tup} include/jemalloc/jemalloc_macros.h:include/jemalloc/jemalloc_macros.h.in"
 cfgoutputs_tup="${cfgoutputs_tup} include/jemalloc/jemalloc_protos.h:include/jemalloc/jemalloc_protos.h.in"
+cfgoutputs_tup="${cfgoutputs_tup} include/jemalloc/jemalloc_typedefs.h:include/jemalloc/jemalloc_typedefs.h.in"
 cfgoutputs_tup="${cfgoutputs_tup} include/jemalloc/internal/jemalloc_internal.h"
 cfgoutputs_tup="${cfgoutputs_tup} test/test.sh:test/test.sh.in"
 cfgoutputs_tup="${cfgoutputs_tup} test/include/test/jemalloc_test.h:test/include/test/jemalloc_test.h.in"
 
-cfghdrs_in="${srcroot}include/jemalloc/jemalloc_defs.h.in"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/jemalloc_internal_defs.h.in"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/private_namespace.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/private_unnamespace.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/private_symbols.txt"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/public_namespace.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/public_unnamespace.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/internal/size_classes.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/jemalloc_rename.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/jemalloc_mangle.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}include/jemalloc/jemalloc.sh"
-cfghdrs_in="${cfghdrs_in} ${srcroot}test/include/test/jemalloc_test_defs.h.in"
+cfghdrs_in="include/jemalloc/jemalloc_defs.h.in"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/jemalloc_internal_defs.h.in"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/private_namespace.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/private_unnamespace.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/private_symbols.txt"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/public_namespace.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/public_unnamespace.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/internal/size_classes.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/jemalloc_rename.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/jemalloc_mangle.sh"
+cfghdrs_in="${cfghdrs_in} include/jemalloc/jemalloc.sh"
+cfghdrs_in="${cfghdrs_in} test/include/test/jemalloc_test_defs.h.in"
 
 cfghdrs_out="include/jemalloc/jemalloc_defs.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/jemalloc${install_suffix}.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/internal/private_namespace.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/internal/private_unnamespace.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/internal/public_symbols.txt"
@@ -589,52 +642,56 @@
 cfghdrs_out="${cfghdrs_out} include/jemalloc/jemalloc_mangle.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/jemalloc_mangle_jet.h"
 cfghdrs_out="${cfghdrs_out} include/jemalloc/internal/jemalloc_internal_defs.h"
 cfghdrs_out="${cfghdrs_out} test/include/test/jemalloc_test_defs.h"
 
 cfghdrs_tup="include/jemalloc/jemalloc_defs.h:include/jemalloc/jemalloc_defs.h.in"
-cfghdrs_tup="${cfghdrs_tup} include/jemalloc/internal/jemalloc_internal_defs.h:${srcroot}include/jemalloc/internal/jemalloc_internal_defs.h.in"
-cfghdrs_tup="${cfghdrs_tup} test/include/test/jemalloc_test_defs.h:${srcroot}test/include/test/jemalloc_test_defs.h.in"
+cfghdrs_tup="${cfghdrs_tup} include/jemalloc/internal/jemalloc_internal_defs.h:include/jemalloc/internal/jemalloc_internal_defs.h.in"
+cfghdrs_tup="${cfghdrs_tup} test/include/test/jemalloc_test_defs.h:test/include/test/jemalloc_test_defs.h.in"
 
-dnl Do not silence irrelevant compiler warnings by default, since enabling this
-dnl option incurs a performance penalty.
+dnl Silence irrelevant compiler warnings by default.
 AC_ARG_ENABLE([cc-silence],
-  [AS_HELP_STRING([--enable-cc-silence],
-                  [Silence irrelevant compiler warnings])],
+  [AS_HELP_STRING([--disable-cc-silence],
+                  [Do not silence irrelevant compiler warnings])],
 [if test "x$enable_cc_silence" = "xno" ; then
   enable_cc_silence="0"
 else
   enable_cc_silence="1"
 fi
 ],
-[enable_cc_silence="0"]
+[enable_cc_silence="1"]
 )
 if test "x$enable_cc_silence" = "x1" ; then
   AC_DEFINE([JEMALLOC_CC_SILENCE], [ ])
 fi
 
 dnl Do not compile with debugging by default.
 AC_ARG_ENABLE([debug],
-  [AS_HELP_STRING([--enable-debug], [Build debugging code (implies --enable-ivsalloc)])],
+  [AS_HELP_STRING([--enable-debug],
+                  [Build debugging code (implies --enable-ivsalloc)])],
 [if test "x$enable_debug" = "xno" ; then
   enable_debug="0"
 else
   enable_debug="1"
 fi
 ],
 [enable_debug="0"]
 )
 if test "x$enable_debug" = "x1" ; then
   AC_DEFINE([JEMALLOC_DEBUG], [ ])
+fi
+if test "x$enable_debug" = "x1" ; then
+  AC_DEFINE([JEMALLOC_DEBUG], [ ])
   enable_ivsalloc="1"
 fi
 AC_SUBST([enable_debug])
 
 dnl Do not validate pointers by default.
 AC_ARG_ENABLE([ivsalloc],
-  [AS_HELP_STRING([--enable-ivsalloc], [Validate pointers passed through the public API])],
+  [AS_HELP_STRING([--enable-ivsalloc],
+                  [Validate pointers passed through the public API])],
 [if test "x$enable_ivsalloc" = "xno" ; then
   enable_ivsalloc="0"
 else
   enable_ivsalloc="1"
 fi
 ],
@@ -718,13 +775,13 @@
 fi,
   LUNWIND="-lunwind"
 )
 if test "x$backtrace_method" = "x" -a "x$enable_prof_libunwind" = "x1" ; then
   AC_CHECK_HEADERS([libunwind.h], , [enable_prof_libunwind="0"])
   if test "x$LUNWIND" = "x-lunwind" ; then
-    AC_CHECK_LIB([unwind], [backtrace], [LIBS="$LIBS $LUNWIND"],
+    AC_CHECK_LIB([unwind], [unw_backtrace], [LIBS="$LIBS $LUNWIND"],
                  [enable_prof_libunwind="0"])
   else
     LIBS="$LIBS $LUNWIND"
   fi
   if test "x${enable_prof_libunwind}" = "x1" ; then
     backtrace_method="libunwind"
@@ -779,17 +836,12 @@
   backtrace_method="none (disabling profiling)"
   enable_prof="0"
 fi
 AC_MSG_CHECKING([configured backtracing method])
 AC_MSG_RESULT([$backtrace_method])
 if test "x$enable_prof" = "x1" ; then
-  if test "x${force_tls}" = "x0" ; then
-    AC_MSG_ERROR([Heap profiling requires TLS]);
-  fi
-  force_tls="1"
-
   if test "x$abi" != "xpecoff"; then
     dnl Heap profiling uses the log(3) function.
     LIBS="$LIBS -lm"
   fi
 
   AC_DEFINE([JEMALLOC_PROF], [ ])
@@ -809,38 +861,17 @@
 )
 if test "x$enable_tcache" = "x1" ; then
   AC_DEFINE([JEMALLOC_TCACHE], [ ])
 fi
 AC_SUBST([enable_tcache])
 
-dnl Disable mremap() for huge realloc() by default.
-AC_ARG_ENABLE([mremap],
-  [AS_HELP_STRING([--enable-mremap], [Enable mremap(2) for huge realloc()])],
-[if test "x$enable_mremap" = "xno" ; then
-  enable_mremap="0"
-else
-  enable_mremap="1"
+dnl Indicate whether adjacent virtual memory mappings automatically coalesce
+dnl (and fragment on demand).
+if test "x${maps_coalesce}" = "x1" ; then
+  AC_DEFINE([JEMALLOC_MAPS_COALESCE], [ ])
 fi
-],
-[enable_mremap="0"]
-)
-if test "x$enable_mremap" = "x1" ; then
-  JE_COMPILABLE([mremap(...MREMAP_FIXED...)], [
-#define	_GNU_SOURCE
-#include <sys/mman.h>
-], [
-void *p = mremap((void *)0, 0, 0, MREMAP_MAYMOVE|MREMAP_FIXED, (void *)0);
-], [je_cv_mremap_fixed])
-  if test "x${je_cv_mremap_fixed}" = "xno" ; then
-    enable_mremap="0"
-  fi
-fi
-if test "x$enable_mremap" = "x1" ; then
-  AC_DEFINE([JEMALLOC_MREMAP], [ ])
-fi
-AC_SUBST([enable_mremap])
 
 dnl Enable VM deallocation via munmap() by default.
 AC_ARG_ENABLE([munmap],
   [AS_HELP_STRING([--disable-munmap], [Disable VM deallocation via munmap(2)])],
 [if test "x$enable_munmap" = "xno" ; then
   enable_munmap="0"
@@ -852,40 +883,28 @@
 )
 if test "x$enable_munmap" = "x1" ; then
   AC_DEFINE([JEMALLOC_MUNMAP], [ ])
 fi
 AC_SUBST([enable_munmap])
 
-dnl Do not enable allocation from DSS by default.
-AC_ARG_ENABLE([dss],
-  [AS_HELP_STRING([--enable-dss], [Enable allocation from DSS])],
-[if test "x$enable_dss" = "xno" ; then
-  enable_dss="0"
-else
-  enable_dss="1"
-fi
-],
-[enable_dss="0"]
-)
+dnl Enable allocation from DSS if supported by the OS.
+have_dss="1"
 dnl Check whether the BSD/SUSv1 sbrk() exists.  If not, disable DSS support.
 AC_CHECK_FUNC([sbrk], [have_sbrk="1"], [have_sbrk="0"])
 if test "x$have_sbrk" = "x1" ; then
-  if test "x$sbrk_deprecated" == "x1" ; then
+  if test "x$sbrk_deprecated" = "x1" ; then
     AC_MSG_RESULT([Disabling dss allocation because sbrk is deprecated])
-    enable_dss="0"
-  else
-    AC_DEFINE([JEMALLOC_HAVE_SBRK], [ ])
+    have_dss="0"
   fi
 else
-  enable_dss="0"
+  have_dss="0"
 fi
 
-if test "x$enable_dss" = "x1" ; then
+if test "x$have_dss" = "x1" ; then
   AC_DEFINE([JEMALLOC_DSS], [ ])
 fi
-AC_SUBST([enable_dss])
 
 dnl Support the junk/zero filling option by default.
 AC_ARG_ENABLE([fill],
   [AS_HELP_STRING([--disable-fill],
                   [Disable support for junk/zero filling, quarantine, and redzones])],
 [if test "x$enable_fill" = "xno" ; then
@@ -971,14 +990,89 @@
 )
 if test "x$enable_xmalloc" = "x1" ; then
   AC_DEFINE([JEMALLOC_XMALLOC], [ ])
 fi
 AC_SUBST([enable_xmalloc])
 
-AC_CACHE_CHECK([STATIC_PAGE_SHIFT],
-               [je_cv_static_page_shift],
+dnl Support cache-oblivious allocation alignment by default.
+AC_ARG_ENABLE([cache-oblivious],
+  [AS_HELP_STRING([--disable-cache-oblivious],
+                  [Disable support for cache-oblivious allocation alignment])],
+[if test "x$enable_cache_oblivious" = "xno" ; then
+  enable_cache_oblivious="0"
+else
+  enable_cache_oblivious="1"
+fi
+],
+[enable_cache_oblivious="1"]
+)
+if test "x$enable_cache_oblivious" = "x1" ; then
+  AC_DEFINE([JEMALLOC_CACHE_OBLIVIOUS], [ ])
+fi
+AC_SUBST([enable_cache_oblivious])
+
+dnl ============================================================================
+dnl Check for  __builtin_ffsl(), then ffsl(3), and fail if neither are found.
+dnl One of those two functions should (theoretically) exist on all platforms
+dnl that jemalloc currently has a chance of functioning on without modification.
+dnl We additionally assume ffs() or __builtin_ffs() are defined if
+dnl ffsl() or __builtin_ffsl() are defined, respectively.
+JE_COMPILABLE([a program using __builtin_ffsl], [
+#include <stdio.h>
+#include <strings.h>
+#include <string.h>
+], [
+	{
+		int rv = __builtin_ffsl(0x08);
+		printf("%d\n", rv);
+	}
+], [je_cv_gcc_builtin_ffsl])
+if test "x${je_cv_gcc_builtin_ffsl}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [__builtin_ffsl])
+  AC_DEFINE([JEMALLOC_INTERNAL_FFS], [__builtin_ffs])
+else
+  JE_COMPILABLE([a program using ffsl], [
+  #include <stdio.h>
+  #include <strings.h>
+  #include <string.h>
+  ], [
+	{
+		int rv = ffsl(0x08);
+		printf("%d\n", rv);
+	}
+  ], [je_cv_function_ffsl])
+  if test "x${je_cv_function_ffsl}" = "xyes" ; then
+    AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [ffsl])
+    AC_DEFINE([JEMALLOC_INTERNAL_FFS], [ffs])
+  else
+    AC_MSG_ERROR([Cannot build without ffsl(3) or __builtin_ffsl()])
+  fi
+fi
+
+AC_ARG_WITH([lg_tiny_min],
+  [AS_HELP_STRING([--with-lg-tiny-min=<lg-tiny-min>],
+   [Base 2 log of minimum tiny size class to support])],
+  [LG_TINY_MIN="$with_lg_tiny_min"],
+  [LG_TINY_MIN="3"])
+AC_DEFINE_UNQUOTED([LG_TINY_MIN], [$LG_TINY_MIN])
+
+AC_ARG_WITH([lg_quantum],
+  [AS_HELP_STRING([--with-lg-quantum=<lg-quantum>],
+   [Base 2 log of minimum allocation alignment])],
+  [LG_QUANTA="$with_lg_quantum"],
+  [LG_QUANTA="3 4"])
+if test "x$with_lg_quantum" != "x" ; then
+  AC_DEFINE_UNQUOTED([LG_QUANTUM], [$with_lg_quantum])
+fi
+
+AC_ARG_WITH([lg_page],
+  [AS_HELP_STRING([--with-lg-page=<lg-page>], [Base 2 log of system page size])],
+  [LG_PAGE="$with_lg_page"], [LG_PAGE="detect"])
+if test "x$LG_PAGE" = "xdetect"; then
+  AC_CACHE_CHECK([LG_PAGE],
+               [je_cv_lg_page],
                AC_RUN_IFELSE([AC_LANG_PROGRAM(
 [[
 #include <strings.h>
 #ifdef _WIN32
 #include <windows.h>
 #else
@@ -997,41 +1091,82 @@
 #else
     result = sysconf(_SC_PAGESIZE);
 #endif
     if (result == -1) {
 	return 1;
     }
-    result = ffsl(result) - 1;
+    result = JEMALLOC_INTERNAL_FFSL(result) - 1;
 
     f = fopen("conftest.out", "w");
     if (f == NULL) {
 	return 1;
     }
     fprintf(f, "%d\n", result);
     fclose(f);
 
     return 0;
 ]])],
-                             [je_cv_static_page_shift=`cat conftest.out`],
-                             [je_cv_static_page_shift=undefined]))
-
-if test "x$je_cv_static_page_shift" != "xundefined"; then
-   AC_DEFINE_UNQUOTED([STATIC_PAGE_SHIFT], [$je_cv_static_page_shift])
+                             [je_cv_lg_page=`cat conftest.out`],
+                             [je_cv_lg_page=undefined],
+                             [je_cv_lg_page=12]))
+fi
+if test "x${je_cv_lg_page}" != "x" ; then
+  LG_PAGE="${je_cv_lg_page}"
+fi
+if test "x${LG_PAGE}" != "xundefined" ; then
+   AC_DEFINE_UNQUOTED([LG_PAGE], [$LG_PAGE])
 else
-   AC_MSG_ERROR([cannot determine value for STATIC_PAGE_SHIFT])
+   AC_MSG_ERROR([cannot determine value for LG_PAGE])
 fi
 
+AC_ARG_WITH([lg_page_sizes],
+  [AS_HELP_STRING([--with-lg-page-sizes=<lg-page-sizes>],
+   [Base 2 logs of system page sizes to support])],
+  [LG_PAGE_SIZES="$with_lg_page_sizes"], [LG_PAGE_SIZES="$LG_PAGE"])
+
+AC_ARG_WITH([lg_size_class_group],
+  [AS_HELP_STRING([--with-lg-size-class-group=<lg-size-class-group>],
+   [Base 2 log of size classes per doubling])],
+  [LG_SIZE_CLASS_GROUP="$with_lg_size_class_group"],
+  [LG_SIZE_CLASS_GROUP="2"])
+
 dnl ============================================================================
 dnl jemalloc configuration.
 dnl 
 
-dnl Set VERSION if source directory has an embedded git repository.
-if test -d "${srcroot}.git" ; then
-  git describe --long --abbrev=40 > ${srcroot}VERSION
+dnl Set VERSION if source directory is inside a git repository.
+if test "x`test ! \"${srcroot}\" && cd \"${srcroot}\"; git rev-parse --is-inside-work-tree 2>/dev/null`" = "xtrue" ; then
+  dnl Pattern globs aren't powerful enough to match both single- and
+  dnl double-digit version numbers, so iterate over patterns to support up to
+  dnl version 99.99.99 without any accidental matches.
+  rm -f "${objroot}VERSION"
+  for pattern in ['[0-9].[0-9].[0-9]' '[0-9].[0-9].[0-9][0-9]' \
+                 '[0-9].[0-9][0-9].[0-9]' '[0-9].[0-9][0-9].[0-9][0-9]' \
+                 '[0-9][0-9].[0-9].[0-9]' '[0-9][0-9].[0-9].[0-9][0-9]' \
+                 '[0-9][0-9].[0-9][0-9].[0-9]' \
+                 '[0-9][0-9].[0-9][0-9].[0-9][0-9]']; do
+    if test ! -e "${objroot}VERSION" ; then
+      (test ! "${srcroot}" && cd "${srcroot}"; git describe --long --abbrev=40 --match="${pattern}") > "${objroot}VERSION.tmp" 2>/dev/null
+      if test $? -eq 0 ; then
+        mv "${objroot}VERSION.tmp" "${objroot}VERSION"
+        break
+      fi
+    fi
+  done
+fi
+rm -f "${objroot}VERSION.tmp"
+if test ! -e "${objroot}VERSION" ; then
+  if test ! -e "${srcroot}VERSION" ; then
+    AC_MSG_RESULT(
+      [Missing VERSION file, and unable to generate it; creating bogus VERSION])
+    echo "0.0.0-0-g0000000000000000000000000000000000000000" > "${objroot}VERSION"
+  else
+    cp ${srcroot}VERSION ${objroot}VERSION
+  fi
 fi
-jemalloc_version=`cat ${srcroot}VERSION`
+jemalloc_version=`cat "${objroot}VERSION"`
 jemalloc_version_major=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print [$]1}'`
 jemalloc_version_minor=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print [$]2}'`
 jemalloc_version_bugfix=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print [$]3}'`
 jemalloc_version_nrev=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print [$]4}'`
 jemalloc_version_gid=`echo ${jemalloc_version} | tr ".g-" " " | awk '{print [$]5}'`
 AC_SUBST([jemalloc_version])
@@ -1052,12 +1187,38 @@
                [AC_SEARCH_LIBS([pthread_create], , ,
                                AC_MSG_ERROR([libpthread is missing]))])
 fi
 
 CPPFLAGS="$CPPFLAGS -D_REENTRANT"
 
+dnl Check whether clock_gettime(2) is in libc or librt.  This function is only
+dnl used in test code, so save the result to TESTLIBS to avoid poluting LIBS.
+SAVED_LIBS="${LIBS}"
+LIBS=
+AC_SEARCH_LIBS([clock_gettime], [rt], [TESTLIBS="${LIBS}"])
+AC_SUBST([TESTLIBS])
+LIBS="${SAVED_LIBS}"
+
+dnl Check if the GNU-specific secure_getenv function exists.
+AC_CHECK_FUNC([secure_getenv],
+              [have_secure_getenv="1"],
+              [have_secure_getenv="0"]
+             )
+if test "x$have_secure_getenv" = "x1" ; then
+  AC_DEFINE([JEMALLOC_HAVE_SECURE_GETENV], [ ])
+fi
+
+dnl Check if the Solaris/BSD issetugid function exists.
+AC_CHECK_FUNC([issetugid],
+              [have_issetugid="1"],
+              [have_issetugid="0"]
+             )
+if test "x$have_issetugid" = "x1" ; then
+  AC_DEFINE([JEMALLOC_HAVE_ISSETUGID], [ ])
+fi
+
 dnl Check whether the BSD-specific _malloc_thread_cleanup() exists.  If so, use
 dnl it rather than pthreads TSD cleanup functions to support cleanup during
 dnl thread exit, in order to avoid pthreads library recursion during
 dnl bootstrapping.
 AC_CHECK_FUNC([_malloc_thread_cleanup],
               [have__malloc_thread_cleanup="1"],
@@ -1086,47 +1247,52 @@
 [if test "x$enable_lazy_lock" = "xno" ; then
   enable_lazy_lock="0"
 else
   enable_lazy_lock="1"
 fi
 ],
-[enable_lazy_lock="0"]
+[enable_lazy_lock=""]
 )
-if test "x$enable_lazy_lock" = "x0" -a "x${force_lazy_lock}" = "x1" ; then
+if test "x$enable_lazy_lock" = "x" -a "x${force_lazy_lock}" = "x1" ; then
   AC_MSG_RESULT([Forcing lazy-lock to avoid allocator/threading bootstrap issues])
   enable_lazy_lock="1"
 fi
 if test "x$enable_lazy_lock" = "x1" ; then
   if test "x$abi" != "xpecoff" ; then
     AC_CHECK_HEADERS([dlfcn.h], , [AC_MSG_ERROR([dlfcn.h is missing])])
     AC_CHECK_FUNC([dlsym], [],
       [AC_CHECK_LIB([dl], [dlsym], [LIBS="$LIBS -ldl"],
                     [AC_MSG_ERROR([libdl is missing])])
       ])
   fi
   AC_DEFINE([JEMALLOC_LAZY_LOCK], [ ])
+else
+  enable_lazy_lock="0"
 fi
 AC_SUBST([enable_lazy_lock])
 
 AC_ARG_ENABLE([tls],
   [AS_HELP_STRING([--disable-tls], [Disable thread-local storage (__thread keyword)])],
 if test "x$enable_tls" = "xno" ; then
   enable_tls="0"
 else
   enable_tls="1"
 fi
 ,
-enable_tls="1"
+enable_tls=""
 )
-if test "x${enable_tls}" = "x0" -a "x${force_tls}" = "x1" ; then
-  AC_MSG_RESULT([Forcing TLS to avoid allocator/threading bootstrap issues])
-  enable_tls="1"
-fi
-if test "x${enable_tls}" = "x1" -a "x${force_tls}" = "x0" ; then
-  AC_MSG_RESULT([Forcing no TLS to avoid allocator/threading bootstrap issues])
-  enable_tls="0"
+if test "x${enable_tls}" = "x" ; then
+  if test "x${force_tls}" = "x1" ; then
+    AC_MSG_RESULT([Forcing TLS to avoid allocator/threading bootstrap issues])
+    enable_tls="1"
+  elif test "x${force_tls}" = "x0" ; then
+    AC_MSG_RESULT([Forcing no TLS to avoid allocator/threading bootstrap issues])
+    enable_tls="0"
+  else
+    enable_tls="1"
+  fi
 fi
 if test "x${enable_tls}" = "x1" ; then
 AC_MSG_CHECKING([for TLS])
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
 [[
     __thread int x;
@@ -1135,36 +1301,44 @@
 
     return 0;
 ]])],
               AC_MSG_RESULT([yes]),
               AC_MSG_RESULT([no])
               enable_tls="0")
+else
+  enable_tls="0"
 fi
 AC_SUBST([enable_tls])
 if test "x${enable_tls}" = "x1" ; then
+  if test "x${force_tls}" = "x0" ; then
+    AC_MSG_WARN([TLS enabled despite being marked unusable on this platform])
+  fi
   AC_DEFINE_UNQUOTED([JEMALLOC_TLS], [ ])
 elif test "x${force_tls}" = "x1" ; then
-  AC_MSG_ERROR([Failed to configure TLS, which is mandatory for correct function])
+  AC_MSG_WARN([TLS disabled despite being marked critical on this platform])
 fi
 
 dnl ============================================================================
-dnl Check for ffsl(3), and fail if not found.  This function exists on all
-dnl platforms that jemalloc currently has a chance of functioning on without
-dnl modification.
-JE_COMPILABLE([a program using ffsl], [
-#include <stdio.h>
-#include <strings.h>
-#include <string.h>
+dnl Check for C11 atomics.
+
+JE_COMPILABLE([C11 atomics], [
+#include <stdint.h>
+#if (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__)
+#include <stdatomic.h>
+#else
+#error Atomics not available
+#endif
 ], [
-	{
-		int rv = ffsl(0x08);
-		printf("%d\n", rv);
-	}
-], [je_cv_function_ffsl])
-if test "x${je_cv_function_ffsl}" != "xyes" ; then
-   AC_MSG_ERROR([Cannot build without ffsl(3)])
+    uint64_t *p = (uint64_t *)0;
+    uint64_t x = 1;
+    volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;
+    uint64_t r = atomic_fetch_add(a, x) + x;
+    return (r == 0);
+], [je_cv_c11atomics])
+if test "x${je_cv_c11atomics}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_C11ATOMICS])
 fi
 
 dnl ============================================================================
 dnl Check for atomic(9) operations as provided on FreeBSD.
 
 JE_COMPILABLE([atomic(9)], [
@@ -1207,12 +1381,26 @@
 ], [je_cv_osatomic])
 if test "x${je_cv_osatomic}" = "xyes" ; then
   AC_DEFINE([JEMALLOC_OSATOMIC], [ ])
 fi
 
 dnl ============================================================================
+dnl Check for madvise(2).
+
+JE_COMPILABLE([madvise(2)], [
+#include <sys/mman.h>
+], [
+	{
+		madvise((void *)0, 0, 0);
+	}
+], [je_cv_madvise])
+if test "x${je_cv_madvise}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_HAVE_MADVISE], [ ])
+fi
+
+dnl ============================================================================
 dnl Check whether __sync_{add,sub}_and_fetch() are available despite
 dnl __GCC_HAVE_SYNC_COMPARE_AND_SWAP_n macros being undefined.
 
 AC_DEFUN([JE_SYNC_COMPARE_AND_SWAP_CHECK],[
   AC_CACHE_CHECK([whether to force $1-bit __sync_{add,sub}_and_fetch()],
                [je_cv_sync_compare_and_swap_$2],
@@ -1241,12 +1429,35 @@
 if test "x${je_cv_atomic9}" != "xyes" -a "x${je_cv_osatomic}" != "xyes" ; then
   JE_SYNC_COMPARE_AND_SWAP_CHECK(32, 4)
   JE_SYNC_COMPARE_AND_SWAP_CHECK(64, 8)
 fi
 
 dnl ============================================================================
+dnl Check for __builtin_clz() and __builtin_clzl().
+
+AC_CACHE_CHECK([for __builtin_clz],
+               [je_cv_builtin_clz],
+               [AC_LINK_IFELSE([AC_LANG_PROGRAM([],
+                                                [
+                                                {
+                                                        unsigned x = 0;
+                                                        int y = __builtin_clz(x);
+                                                }
+                                                {
+                                                        unsigned long x = 0;
+                                                        int y = __builtin_clzl(x);
+                                                }
+                                                ])],
+                               [je_cv_builtin_clz=yes],
+                               [je_cv_builtin_clz=no])])
+
+if test "x${je_cv_builtin_clz}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_HAVE_BUILTIN_CLZ], [ ])
+fi
+
+dnl ============================================================================
 dnl Check for spinlock(3) operations as provided on Darwin.
 
 JE_COMPILABLE([Darwin OSSpin*()], [
 #include <libkern/OSAtomic.h>
 #include <inttypes.h>
 ], [
@@ -1278,23 +1489,22 @@
 AC_SUBST([enable_zone_allocator])
 
 if test "x${enable_zone_allocator}" = "x1" ; then
   if test "x${abi}" != "xmacho"; then
     AC_MSG_ERROR([--enable-zone-allocator is only supported on Darwin])
   fi
-  AC_DEFINE([JEMALLOC_IVSALLOC], [ ])
   AC_DEFINE([JEMALLOC_ZONE], [ ])
 
   dnl The szone version jumped from 3 to 6 between the OS X 10.5.x and 10.6
   dnl releases.  malloc_zone_t and malloc_introspection_t have new fields in
   dnl 10.6, which is the only source-level indication of the change.
   AC_MSG_CHECKING([malloc zone version])
   AC_DEFUN([JE_ZONE_PROGRAM],
     [AC_LANG_PROGRAM(
       [#include <malloc/malloc.h>],
-      [static foo[[sizeof($1) $2 sizeof(void *) * $3 ? 1 : -1]]]
+      [static int foo[[sizeof($1) $2 sizeof(void *) * $3 ? 1 : -1]]]
     )])
 
   AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_zone_t,==,14)],[JEMALLOC_ZONE_VERSION=3],[
   AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_zone_t,==,15)],[JEMALLOC_ZONE_VERSION=5],[
   AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_zone_t,==,16)],[
     AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_introspection_t,==,9)],[JEMALLOC_ZONE_VERSION=6],[
@@ -1314,12 +1524,55 @@
     AC_MSG_RESULT([$JEMALLOC_ZONE_VERSION])
   fi
   AC_DEFINE_UNQUOTED(JEMALLOC_ZONE_VERSION, [$JEMALLOC_ZONE_VERSION])
 fi
 
 dnl ============================================================================
+dnl Check for glibc malloc hooks
+
+JE_COMPILABLE([glibc malloc hook], [
+#include <stddef.h>
+
+extern void (* __free_hook)(void *ptr);
+extern void *(* __malloc_hook)(size_t size);
+extern void *(* __realloc_hook)(void *ptr, size_t size);
+], [
+  void *ptr = 0L;
+  if (__malloc_hook) ptr = __malloc_hook(1);
+  if (__realloc_hook) ptr = __realloc_hook(ptr, 2);
+  if (__free_hook && ptr) __free_hook(ptr);
+], [je_cv_glibc_malloc_hook])
+if test "x${je_cv_glibc_malloc_hook}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_GLIBC_MALLOC_HOOK], [ ])
+fi
+
+JE_COMPILABLE([glibc memalign hook], [
+#include <stddef.h>
+
+extern void *(* __memalign_hook)(size_t alignment, size_t size);
+], [
+  void *ptr = 0L;
+  if (__memalign_hook) ptr = __memalign_hook(16, 7);
+], [je_cv_glibc_memalign_hook])
+if test "x${je_cv_glibc_memalign_hook}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_GLIBC_MEMALIGN_HOOK], [ ])
+fi
+
+JE_COMPILABLE([pthreads adaptive mutexes], [
+#include <pthread.h>
+], [
+  pthread_mutexattr_t attr;
+  pthread_mutexattr_init(&attr);
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);
+  pthread_mutexattr_destroy(&attr);
+], [je_cv_pthread_mutex_adaptive_np])
+if test "x${je_cv_pthread_mutex_adaptive_np}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP], [ ])
+fi
+
+dnl ============================================================================
 dnl Check for typedefs, structures, and compiler characteristics.
 AC_HEADER_STDBOOL
 
 dnl ============================================================================
 dnl Define commands that generate output files.
 
@@ -1373,16 +1626,21 @@
 ], [
   srcdir="${srcdir}"
   objroot="${objroot}"
 ])
 AC_CONFIG_COMMANDS([include/jemalloc/internal/size_classes.h], [
   mkdir -p "${objroot}include/jemalloc/internal"
-  "${srcdir}/include/jemalloc/internal/size_classes.sh" > "${objroot}include/jemalloc/internal/size_classes.h"
+  "${SHELL}" "${srcdir}/include/jemalloc/internal/size_classes.sh" "${LG_QUANTA}" ${LG_TINY_MIN} "${LG_PAGE_SIZES}" ${LG_SIZE_CLASS_GROUP} > "${objroot}include/jemalloc/internal/size_classes.h"
 ], [
+  SHELL="${SHELL}"
   srcdir="${srcdir}"
   objroot="${objroot}"
+  LG_QUANTA="${LG_QUANTA}"
+  LG_TINY_MIN=${LG_TINY_MIN}
+  LG_PAGE_SIZES="${LG_PAGE_SIZES}"
+  LG_SIZE_CLASS_GROUP=${LG_SIZE_CLASS_GROUP}
 ])
 AC_CONFIG_COMMANDS([include/jemalloc/jemalloc_protos_jet.h], [
   mkdir -p "${objroot}include/jemalloc"
   cat "${srcdir}/include/jemalloc/jemalloc_protos.h.in" | sed -e 's/@je_@/jet_/g' > "${objroot}include/jemalloc/jemalloc_protos_jet.h"
 ], [
   srcdir="${srcdir}"
@@ -1423,52 +1681,53 @@
 AC_SUBST([cfghdrs_out])
 AC_CONFIG_HEADERS([$cfghdrs_tup])
 
 dnl ============================================================================
 dnl Generate outputs.
 
-AC_CONFIG_FILES([$cfgoutputs_tup config.stamp bin/jemalloc.sh])
+AC_CONFIG_FILES([$cfgoutputs_tup config.stamp bin/jemalloc-config bin/jemalloc.sh bin/jeprof])
 AC_SUBST([cfgoutputs_in])
 AC_SUBST([cfgoutputs_out])
 AC_OUTPUT
 
 dnl ============================================================================
 dnl Print out the results of configuration.
 AC_MSG_RESULT([===============================================================================])
 AC_MSG_RESULT([jemalloc version   : ${jemalloc_version}])
 AC_MSG_RESULT([library revision   : ${rev}])
 AC_MSG_RESULT([])
+AC_MSG_RESULT([CONFIG             : ${CONFIG}])
 AC_MSG_RESULT([CC                 : ${CC}])
-AC_MSG_RESULT([CPPFLAGS           : ${CPPFLAGS}])
 AC_MSG_RESULT([CFLAGS             : ${CFLAGS}])
+AC_MSG_RESULT([CPPFLAGS           : ${CPPFLAGS}])
 AC_MSG_RESULT([LDFLAGS            : ${LDFLAGS}])
 AC_MSG_RESULT([EXTRA_LDFLAGS      : ${EXTRA_LDFLAGS}])
 AC_MSG_RESULT([LIBS               : ${LIBS}])
+AC_MSG_RESULT([TESTLIBS           : ${TESTLIBS}])
 AC_MSG_RESULT([RPATH_EXTRA        : ${RPATH_EXTRA}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([XSLTPROC           : ${XSLTPROC}])
 AC_MSG_RESULT([XSLROOT            : ${XSLROOT}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([PREFIX             : ${PREFIX}])
 AC_MSG_RESULT([BINDIR             : ${BINDIR}])
+AC_MSG_RESULT([DATADIR            : ${DATADIR}])
 AC_MSG_RESULT([INCLUDEDIR         : ${INCLUDEDIR}])
 AC_MSG_RESULT([LIBDIR             : ${LIBDIR}])
-AC_MSG_RESULT([DATADIR            : ${DATADIR}])
 AC_MSG_RESULT([MANDIR             : ${MANDIR}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([srcroot            : ${srcroot}])
 AC_MSG_RESULT([abs_srcroot        : ${abs_srcroot}])
 AC_MSG_RESULT([objroot            : ${objroot}])
 AC_MSG_RESULT([abs_objroot        : ${abs_objroot}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([JEMALLOC_PREFIX    : ${JEMALLOC_PREFIX}])
 AC_MSG_RESULT([JEMALLOC_PRIVATE_NAMESPACE])
 AC_MSG_RESULT([                   : ${JEMALLOC_PRIVATE_NAMESPACE}])
 AC_MSG_RESULT([install_suffix     : ${install_suffix}])
 AC_MSG_RESULT([autogen            : ${enable_autogen}])
-AC_MSG_RESULT([experimental       : ${enable_experimental}])
 AC_MSG_RESULT([cc-silence         : ${enable_cc_silence}])
 AC_MSG_RESULT([debug              : ${enable_debug}])
 AC_MSG_RESULT([code-coverage      : ${enable_code_coverage}])
 AC_MSG_RESULT([stats              : ${enable_stats}])
 AC_MSG_RESULT([prof               : ${enable_prof}])
 AC_MSG_RESULT([prof-libunwind     : ${enable_prof_libunwind}])
@@ -1476,12 +1735,11 @@
 AC_MSG_RESULT([prof-gcc           : ${enable_prof_gcc}])
 AC_MSG_RESULT([tcache             : ${enable_tcache}])
 AC_MSG_RESULT([fill               : ${enable_fill}])
 AC_MSG_RESULT([utrace             : ${enable_utrace}])
 AC_MSG_RESULT([valgrind           : ${enable_valgrind}])
 AC_MSG_RESULT([xmalloc            : ${enable_xmalloc}])
-AC_MSG_RESULT([mremap             : ${enable_mremap}])
 AC_MSG_RESULT([munmap             : ${enable_munmap}])
-AC_MSG_RESULT([dss                : ${enable_dss}])
 AC_MSG_RESULT([lazy_lock          : ${enable_lazy_lock}])
 AC_MSG_RESULT([tls                : ${enable_tls}])
+AC_MSG_RESULT([cache-oblivious    : ${enable_cache_oblivious}])
 AC_MSG_RESULT([===============================================================================])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/COPYING /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/COPYING
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/COPYING	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/COPYING	2016-05-06 15:11:36.000000000 +0800
@@ -1,13 +1,13 @@
 Unless otherwise specified, files in the jemalloc source distribution are
 subject to the following license:
 --------------------------------------------------------------------------------
-Copyright (C) 2002-2014 Jason Evans <jasone@canonware.com>.
+Copyright (C) 2002-2015 Jason Evans <jasone@canonware.com>.
 All rights reserved.
 Copyright (C) 2007-2012 Mozilla Foundation.  All rights reserved.
-Copyright (C) 2009-2014 Facebook, Inc.  All rights reserved.
+Copyright (C) 2009-2015 Facebook, Inc.  All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 1. Redistributions of source code must retain the above copyright notice(s),
    this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright notice(s),
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/html.xsl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/html.xsl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/html.xsl	2017-09-27 22:47:53.198963475 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/html.xsl	2017-09-27 22:49:14.990960477 +0800
@@ -1,4 +1,4 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:import href="/usr/share/xml/docbook/stylesheet/docbook-xsl/html/docbook.xsl"/>
-  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/stylesheet.xsl"/>
+  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/stylesheet.xsl"/>
 </xsl:stylesheet>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/jemalloc.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/jemalloc.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/jemalloc.3	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/jemalloc.3	2016-05-06 15:11:36.000000000 +0800
@@ -1,16 +1,16 @@
 '\" t
 .\"     Title: JEMALLOC
 .\"    Author: Jason Evans
 .\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
-.\"      Date: 03/31/2014
+.\"      Date: 09/24/2015
 .\"    Manual: User Manual
-.\"    Source: jemalloc 3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340
+.\"    Source: jemalloc 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c
 .\"  Language: English
 .\"
-.TH "JEMALLOC" "3" "03/31/2014" "jemalloc 3.6.0-0-g46c0af68bd24" "User Manual"
+.TH "JEMALLOC" "3" "09/24/2015" "jemalloc 4.0.3-0-ge9192eacf893" "User Manual"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
 .\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .\" http://bugs.debian.org/507673
 .\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
@@ -28,19 +28,18 @@
 .\" * MAIN CONTENT STARTS HERE *
 .\" -----------------------------------------------------------------
 .SH "NAME"
 jemalloc \- general purpose memory allocation functions
 .SH "LIBRARY"
 .PP
-This manual describes jemalloc 3\&.6\&.0\-0\-g46c0af68bd248b04df75e4f92d5fb804c3d75340\&. More information can be found at the
+This manual describes jemalloc 4\&.0\&.3\-0\-ge9192eacf8935e29fc62fddc2701f7942b1cc02c\&. More information can be found at the
 \m[blue]\fBjemalloc website\fR\m[]\&\s-2\u[1]\d\s+2\&.
 .SH "SYNOPSIS"
 .sp
 .ft B
 .nf
-#include <stdlib\&.h>
 #include <jemalloc/jemalloc\&.h>
 .fi
 .ft
 .SS "Standard API"
 .HP \w'void\ *malloc('u
 .BI "void *malloc(size_t\ " "size" ");"
@@ -62,12 +61,14 @@
 .HP \w'size_t\ xallocx('u
 .BI "size_t xallocx(void\ *" "ptr" ", size_t\ " "size" ", size_t\ " "extra" ", int\ " "flags" ");"
 .HP \w'size_t\ sallocx('u
 .BI "size_t sallocx(void\ *" "ptr" ", int\ " "flags" ");"
 .HP \w'void\ dallocx('u
 .BI "void dallocx(void\ *" "ptr" ", int\ " "flags" ");"
+.HP \w'void\ sdallocx('u
+.BI "void sdallocx(void\ *" "ptr" ", size_t\ " "size" ", int\ " "flags" ");"
 .HP \w'size_t\ nallocx('u
 .BI "size_t nallocx(size_t\ " "size" ", int\ " "flags" ");"
 .HP \w'int\ mallctl('u
 .BI "int mallctl(const\ char\ *" "name" ", void\ *" "oldp" ", size_t\ *" "oldlenp" ", void\ *" "newp" ", size_t\ " "newlen" ");"
 .HP \w'int\ mallctlnametomib('u
 .BI "int mallctlnametomib(const\ char\ *" "name" ", size_t\ *" "mibp" ", size_t\ *" "miblenp" ");"
@@ -78,23 +79,12 @@
 .HP \w'size_t\ malloc_usable_size('u
 .BI "size_t malloc_usable_size(const\ void\ *" "ptr" ");"
 .HP \w'void\ (*malloc_message)('u
 .BI "void (*malloc_message)(void\ *" "cbopaque" ", const\ char\ *" "s" ");"
 .PP
 const char *\fImalloc_conf\fR;
-.SS "Experimental API"
-.HP \w'int\ allocm('u
-.BI "int allocm(void\ **" "ptr" ", size_t\ *" "rsize" ", size_t\ " "size" ", int\ " "flags" ");"
-.HP \w'int\ rallocm('u
-.BI "int rallocm(void\ **" "ptr" ", size_t\ *" "rsize" ", size_t\ " "size" ", size_t\ " "extra" ", int\ " "flags" ");"
-.HP \w'int\ sallocm('u
-.BI "int sallocm(const\ void\ *" "ptr" ", size_t\ *" "rsize" ", int\ " "flags" ");"
-.HP \w'int\ dallocm('u
-.BI "int dallocm(void\ *" "ptr" ", int\ " "flags" ");"
-.HP \w'int\ nallocm('u
-.BI "int nallocm(size_t\ *" "rsize" ", size_t\ " "size" ", int\ " "flags" ");"
 .SH "DESCRIPTION"
 .SS "Standard API"
 .PP
 The
 \fBmalloc\fR\fB\fR
 function allocates
@@ -115,24 +105,24 @@
 \fIsize\fR, with the exception that the allocated memory is explicitly initialized to zero bytes\&.
 .PP
 The
 \fBposix_memalign\fR\fB\fR
 function allocates
 \fIsize\fR
-bytes of memory such that the allocation\*(Aqs base address is an even multiple of
+bytes of memory such that the allocation\*(Aqs base address is a multiple of
 \fIalignment\fR, and returns the allocation in the value pointed to by
 \fIptr\fR\&. The requested
 \fIalignment\fR
 must be a power of 2 at least as large as
 sizeof(\fBvoid *\fR)\&.
 .PP
 The
 \fBaligned_alloc\fR\fB\fR
 function allocates
 \fIsize\fR
-bytes of memory such that the allocation\*(Aqs base address is an even multiple of
+bytes of memory such that the allocation\*(Aqs base address is a multiple of
 \fIalignment\fR\&. The requested
 \fIalignment\fR
 must be a power of 2\&. Behavior is undefined if
 \fIsize\fR
 is not an integral multiple of
 \fIalignment\fR\&.
@@ -169,13 +159,14 @@
 .PP
 The
 \fBmallocx\fR\fB\fR,
 \fBrallocx\fR\fB\fR,
 \fBxallocx\fR\fB\fR,
 \fBsallocx\fR\fB\fR,
-\fBdallocx\fR\fB\fR, and
+\fBdallocx\fR\fB\fR,
+\fBsdallocx\fR\fB\fR, and
 \fBnallocx\fR\fB\fR
 functions all have a
 \fIflags\fR
 argument that can be used to specify options\&. The functions only check the options that are contextually relevant\&. Use bitwise or (|) operations to specify one or more of the following:
 .PP
 \fBMALLOCX_LG_ALIGN(\fR\fB\fIla\fR\fR\fB) \fR
@@ -198,17 +189,38 @@
 .PP
 \fBMALLOCX_ZERO\fR
 .RS 4
 Initialize newly allocated memory to contain zero bytes\&. In the growing reallocation case, the real size prior to reallocation defines the boundary between untouched bytes and those that are initialized to contain zero bytes\&. If this macro is absent, newly allocated memory is uninitialized\&.
 .RE
 .PP
+\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB) \fR
+.RS 4
+Use the thread\-specific cache (tcache) specified by the identifier
+\fItc\fR, which must have been acquired via the
+"tcache\&.create"
+mallctl\&. This macro does not validate that
+\fItc\fR
+specifies a valid identifier\&.
+.RE
+.PP
+\fBMALLOCX_TCACHE_NONE\fR
+.RS 4
+Do not use a thread\-specific cache (tcache)\&. Unless
+\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR
+or
+\fBMALLOCX_TCACHE_NONE\fR
+is specified, an automatically managed tcache will be used under many circumstances\&. This macro cannot be used in the same
+\fIflags\fR
+argument as
+\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR\&.
+.RE
+.PP
 \fBMALLOCX_ARENA(\fR\fB\fIa\fR\fR\fB) \fR
 .RS 4
 Use the arena specified by the index
-\fIa\fR
-(and by necessity bypass the thread cache)\&. This macro has no effect for huge regions, nor for regions that were allocated via an arena other than the one specified\&. This macro does not validate that
+\fIa\fR\&. This macro has no effect for regions that were allocated via an arena other than the one specified\&. This macro does not validate that
 \fIa\fR
 specifies an arena index in the valid range\&.
 .RE
 .PP
 The
 \fBmallocx\fR\fB\fR
@@ -255,12 +267,23 @@
 \fBdallocx\fR\fB\fR
 function causes the memory referenced by
 \fIptr\fR
 to be made available for future allocations\&.
 .PP
 The
+\fBsdallocx\fR\fB\fR
+function is an extension of
+\fBdallocx\fR\fB\fR
+with a
+\fIsize\fR
+parameter to allow the caller to pass in the allocation size as an optimization\&. The minimum valid input size is the original requested size of the allocation, and the maximum valid input size is the corresponding value returned by
+\fBnallocx\fR\fB\fR
+or
+\fBsallocx\fR\fB\fR\&.
+.PP
+The
 \fBnallocx\fR\fB\fR
 function allocates no memory, but it performs the same size computation as the
 \fBmallocx\fR\fB\fR
 function, and returns the real size of the allocation that would result from the equivalent
 \fBmallocx\fR\fB\fR
 function call\&. Behavior is undefined if
@@ -348,143 +371,23 @@
 string\&. Note that
 \fBmalloc_message\fR\fB\fR
 uses the
 \fBmallctl*\fR\fB\fR
 functions internally, so inconsistent statistics can be reported if multiple threads use these functions simultaneously\&. If
 \fB\-\-enable\-stats\fR
-is specified during configuration, \(lqm\(rq and \(lqa\(rq can be specified to omit merged arena and per arena statistics, respectively; \(lqb\(rq and \(lql\(rq can be specified to omit per size class statistics for bins and large objects, respectively\&. Unrecognized characters are silently ignored\&. Note that thread caching may prevent some statistics from being completely up to date, since extra locking would be required to merge counters that track thread cache operations\&.
+is specified during configuration, \(lqm\(rq and \(lqa\(rq can be specified to omit merged arena and per arena statistics, respectively; \(lqb\(rq, \(lql\(rq, and \(lqh\(rq can be specified to omit per size class statistics for bins, large objects, and huge objects, respectively\&. Unrecognized characters are silently ignored\&. Note that thread caching may prevent some statistics from being completely up to date, since extra locking would be required to merge counters that track thread cache operations\&.
 .PP
 The
 \fBmalloc_usable_size\fR\fB\fR
 function returns the usable size of the allocation pointed to by
 \fIptr\fR\&. The return value may be larger than the size that was requested during allocation\&. The
 \fBmalloc_usable_size\fR\fB\fR
 function is not a mechanism for in\-place
 \fBrealloc\fR\fB\fR; rather it is provided solely as a tool for introspection purposes\&. Any discrepancy between the requested allocation size and the size reported by
 \fBmalloc_usable_size\fR\fB\fR
 should not be depended on, since such behavior is entirely implementation\-dependent\&.
-.SS "Experimental API"
-.PP
-The experimental API is subject to change or removal without regard for backward compatibility\&. If
-\fB\-\-disable\-experimental\fR
-is specified during configuration, the experimental API is omitted\&.
-.PP
-The
-\fBallocm\fR\fB\fR,
-\fBrallocm\fR\fB\fR,
-\fBsallocm\fR\fB\fR,
-\fBdallocm\fR\fB\fR, and
-\fBnallocm\fR\fB\fR
-functions all have a
-\fIflags\fR
-argument that can be used to specify options\&. The functions only check the options that are contextually relevant\&. Use bitwise or (|) operations to specify one or more of the following:
-.PP
-\fBALLOCM_LG_ALIGN(\fR\fB\fIla\fR\fR\fB) \fR
-.RS 4
-Align the memory allocation to start at an address that is a multiple of
-(1 << \fIla\fR)\&. This macro does not validate that
-\fIla\fR
-is within the valid range\&.
-.RE
-.PP
-\fBALLOCM_ALIGN(\fR\fB\fIa\fR\fR\fB) \fR
-.RS 4
-Align the memory allocation to start at an address that is a multiple of
-\fIa\fR, where
-\fIa\fR
-is a power of two\&. This macro does not validate that
-\fIa\fR
-is a power of 2\&.
-.RE
-.PP
-\fBALLOCM_ZERO\fR
-.RS 4
-Initialize newly allocated memory to contain zero bytes\&. In the growing reallocation case, the real size prior to reallocation defines the boundary between untouched bytes and those that are initialized to contain zero bytes\&. If this macro is absent, newly allocated memory is uninitialized\&.
-.RE
-.PP
-\fBALLOCM_NO_MOVE\fR
-.RS 4
-For reallocation, fail rather than moving the object\&. This constraint can apply to both growth and shrinkage\&.
-.RE
-.PP
-\fBALLOCM_ARENA(\fR\fB\fIa\fR\fR\fB) \fR
-.RS 4
-Use the arena specified by the index
-\fIa\fR
-(and by necessity bypass the thread cache)\&. This macro has no effect for huge regions, nor for regions that were allocated via an arena other than the one specified\&. This macro does not validate that
-\fIa\fR
-specifies an arena index in the valid range\&.
-.RE
-.PP
-The
-\fBallocm\fR\fB\fR
-function allocates at least
-\fIsize\fR
-bytes of memory, sets
-\fI*ptr\fR
-to the base address of the allocation, and sets
-\fI*rsize\fR
-to the real size of the allocation if
-\fIrsize\fR
-is not
-\fBNULL\fR\&. Behavior is undefined if
-\fIsize\fR
-is
-\fB0\fR, or if request size overflows due to size class and/or alignment constraints\&.
-.PP
-The
-\fBrallocm\fR\fB\fR
-function resizes the allocation at
-\fI*ptr\fR
-to be at least
-\fIsize\fR
-bytes, sets
-\fI*ptr\fR
-to the base address of the allocation if it moved, and sets
-\fI*rsize\fR
-to the real size of the allocation if
-\fIrsize\fR
-is not
-\fBNULL\fR\&. If
-\fIextra\fR
-is non\-zero, an attempt is made to resize the allocation to be at least
-(\fIsize\fR + \fIextra\fR)
-bytes, though inability to allocate the extra byte(s) will not by itself result in failure\&. Behavior is undefined if
-\fIsize\fR
-is
-\fB0\fR, if request size overflows due to size class and/or alignment constraints, or if
-(\fIsize\fR + \fIextra\fR > \fBSIZE_T_MAX\fR)\&.
-.PP
-The
-\fBsallocm\fR\fB\fR
-function sets
-\fI*rsize\fR
-to the real size of the allocation\&.
-.PP
-The
-\fBdallocm\fR\fB\fR
-function causes the memory referenced by
-\fIptr\fR
-to be made available for future allocations\&.
-.PP
-The
-\fBnallocm\fR\fB\fR
-function allocates no memory, but it performs the same size computation as the
-\fBallocm\fR\fB\fR
-function, and if
-\fIrsize\fR
-is not
-\fBNULL\fR
-it sets
-\fI*rsize\fR
-to the real size of the allocation that would result from the equivalent
-\fBallocm\fR\fB\fR
-function call\&. Behavior is undefined if
-\fIsize\fR
-is
-\fB0\fR, or if request size overflows due to size class and/or alignment constraints\&.
 .SH "TUNING"
 .PP
 Once, when the first call is made to one of the memory allocation routines, the allocator initializes its internals based in part on various options that can be specified at compile\- or run\-time\&.
 .PP
 The string pointed to by the global variable
 \fImalloc_conf\fR, the \(lqname\(rq of the file referenced by the symbolic link named
@@ -516,14 +419,14 @@
 options\&. Some options have boolean values (true/false), others have integer values (base 8, 10, or 16, depending on prefix), and yet others have raw string values\&.
 .SH "IMPLEMENTATION NOTES"
 .PP
 Traditionally, allocators have used
 \fBsbrk\fR(2)
 to obtain memory, which is suboptimal for several reasons, including race conditions, increased fragmentation, and artificial limitations on maximum usable memory\&. If
-\fB\-\-enable\-dss\fR
-is specified during configuration, this allocator uses both
+\fBsbrk\fR(2)
+is supported by the operating system, this allocator uses both
 \fBmmap\fR(2)
 and
 \fBsbrk\fR(2), in that order of preference; otherwise only
 \fBmmap\fR(2)
 is used\&.
 .PP
@@ -532,24 +435,35 @@
 In addition to multiple arenas, unless
 \fB\-\-disable\-tcache\fR
 is specified during configuration, this allocator supports thread\-specific caching for small and large objects, in order to make it possible to completely avoid synchronization for most allocation requests\&. Such caching allows very fast allocation in the common case, but it increases memory usage and fragmentation, since a bounded number of objects can remain allocated in each thread cache\&.
 .PP
 Memory is conceptually broken into equal\-sized chunks, where the chunk size is a power of two that is greater than the page size\&. Chunks are always aligned to multiples of the chunk size\&. This alignment makes it possible to find metadata for user objects very quickly\&.
 .PP
-User objects are broken into three categories according to size: small, large, and huge\&. Small objects are smaller than one page\&. Large objects are smaller than the chunk size\&. Huge objects are a multiple of the chunk size\&. Small and large objects are managed by arenas; huge objects are managed separately in a single data structure that is shared by all threads\&. Huge objects are used by applications infrequently enough that this single data structure is not a scalability issue\&.
+User objects are broken into three categories according to size: small, large, and huge\&. Small and large objects are managed entirely by arenas; huge objects are additionally aggregated in a single data structure that is shared by all threads\&. Huge objects are typically used by applications infrequently enough that this single data structure is not a scalability issue\&.
 .PP
 Each chunk that is managed by an arena tracks its contents as runs of contiguous pages (unused, backing a set of small objects, or backing one large object)\&. The combination of chunk alignment and chunk page maps makes it possible to determine all metadata regarding small and large allocations in constant time\&.
 .PP
-Small objects are managed in groups by page runs\&. Each run maintains a frontier and free list to track which regions are in use\&. Allocation requests that are no more than half the quantum (8 or 16, depending on architecture) are rounded up to the nearest power of two that is at least
-sizeof(\fBdouble\fR)\&. All other small object size classes are multiples of the quantum, spaced such that internal fragmentation is limited to approximately 25% for all but the smallest size classes\&. Allocation requests that are larger than the maximum small size class, but small enough to fit in an arena\-managed chunk (see the
+Small objects are managed in groups by page runs\&. Each run maintains a bitmap to track which regions are in use\&. Allocation requests that are no more than half the quantum (8 or 16, depending on architecture) are rounded up to the nearest power of two that is at least
+sizeof(\fBdouble\fR)\&. All other object size classes are multiples of the quantum, spaced such that there are four size classes for each doubling in size, which limits internal fragmentation to approximately 20% for all but the smallest size classes\&. Small size classes are smaller than four times the page size, large size classes are smaller than the chunk size (see the
 "opt\&.lg_chunk"
-option), are rounded up to the nearest run size\&. Allocation requests that are too large to fit in an arena\-managed chunk are rounded up to the nearest multiple of the chunk size\&.
+option), and huge size classes extend from the chunk size up to one size class less than the full address space size\&.
 .PP
 Allocations are packed tightly together, which can be an issue for multi\-threaded applications\&. If you need to assure that allocations do not suffer from cacheline sharing, round your allocation requests up to the nearest multiple of the cacheline size, or specify cacheline alignment when allocating\&.
 .PP
-Assuming 4 MiB chunks, 4 KiB pages, and a 16\-byte quantum on a 64\-bit system, the size classes in each category are as shown in
+The
+\fBrealloc\fR\fB\fR,
+\fBrallocx\fR\fB\fR, and
+\fBxallocx\fR\fB\fR
+functions may resize allocations without moving them under limited circumstances\&. Unlike the
+\fB*allocx\fR\fB\fR
+API, the standard API does not officially round up the usable size of an allocation to the nearest size class, so technically it is necessary to call
+\fBrealloc\fR\fB\fR
+to grow e\&.g\&. a 9\-byte allocation to 16 bytes, or shrink a 16\-byte allocation to 9 bytes\&. Growth and shrinkage trivially succeeds in place as long as the pre\-size and post\-size both round up to the same size class\&. No other API guarantees are made regarding in\-place resizing, but the current implementation also tries to resize large and huge allocations in place, as long as the pre\-size and post\-size are both large or both huge\&. In such cases shrinkage always succeeds for large size classes, but for huge size classes the chunk allocator must support splitting (see
+"arena\&.<i>\&.chunk_hooks")\&. Growth only succeeds if the trailing memory is currently available, and additionally for huge size classes the chunk allocator must support merging\&.
+.PP
+Assuming 2 MiB chunks, 4 KiB pages, and a 16\-byte quantum on a 64\-bit system, the size classes in each category are as shown in
 Table 1\&.
 .sp
 .it 1 an-trap
 .nr an-no-space-flag 1
 .nr an-break-flag 1
 .br
@@ -569,25 +483,40 @@
 ^ r l
 ^ r l
 ^ r l
 ^ r l
 ^ r l
 ^ r l
+^ r l
+^ r l
 l r l
-l r l.
+^ r l
+^ r l
+^ r l
+^ r l
+^ r l
+^ r l
+^ r l
+l r l
+^ r l
+^ r l
+^ r l
+^ r l
+^ r l
+^ r l.
 T{
 Small
 T}:T{
 lg
 T}:T{
 [8]
 T}
 :T{
 16
 T}:T{
-[16, 32, 48, \&.\&.\&., 128]
+[16, 32, 48, 64, 80, 96, 112, 128]
 T}
 :T{
 32
 T}:T{
 [160, 192, 224, 256]
 T}
@@ -606,27 +535,102 @@
 T}:T{
 [1280, 1536, 1792, 2048]
 T}
 :T{
 512
 T}:T{
-[2560, 3072, 3584]
+[2560, 3072, 3584, 4096]
+T}
+:T{
+1 KiB
+T}:T{
+[5 KiB, 6 KiB, 7 KiB, 8 KiB]
+T}
+:T{
+2 KiB
+T}:T{
+[10 KiB, 12 KiB, 14 KiB]
 T}
 T{
 Large
 T}:T{
+2 KiB
+T}:T{
+[16 KiB]
+T}
+:T{
 4 KiB
 T}:T{
-[4 KiB, 8 KiB, 12 KiB, \&.\&.\&., 4072 KiB]
+[20 KiB, 24 KiB, 28 KiB, 32 KiB]
+T}
+:T{
+8 KiB
+T}:T{
+[40 KiB, 48 KiB, 54 KiB, 64 KiB]
+T}
+:T{
+16 KiB
+T}:T{
+[80 KiB, 96 KiB, 112 KiB, 128 KiB]
+T}
+:T{
+32 KiB
+T}:T{
+[160 KiB, 192 KiB, 224 KiB, 256 KiB]
+T}
+:T{
+64 KiB
+T}:T{
+[320 KiB, 384 KiB, 448 KiB, 512 KiB]
+T}
+:T{
+128 KiB
+T}:T{
+[640 KiB, 768 KiB, 896 KiB, 1 MiB]
+T}
+:T{
+256 KiB
+T}:T{
+[1280 KiB, 1536 KiB, 1792 KiB]
 T}
 T{
 Huge
 T}:T{
+256 KiB
+T}:T{
+[2 MiB]
+T}
+:T{
+512 KiB
+T}:T{
+[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]
+T}
+:T{
+1 MiB
+T}:T{
+[5 MiB, 6 MiB, 7 MiB, 8 MiB]
+T}
+:T{
+2 MiB
+T}:T{
+[10 MiB, 12 MiB, 14 MiB, 16 MiB]
+T}
+:T{
 4 MiB
 T}:T{
-[4 MiB, 8 MiB, 12 MiB, \&.\&.\&.]
+[20 MiB, 24 MiB, 28 MiB, 32 MiB]
+T}
+:T{
+8 MiB
+T}:T{
+[40 MiB, 48 MiB, 56 MiB, 64 MiB]
+T}
+:T{
+\&.\&.\&.
+T}:T{
+\&.\&.\&.
 T}
 .TE
 .sp 1
 .SH "MALLCTL NAMESPACE"
 .PP
 The following names are defined in the namespace accessible via the
@@ -657,21 +661,21 @@
 .RS 4
 If a value is passed in, refresh the data from which the
 \fBmallctl*\fR\fB\fR
 functions report values, and increment the epoch\&. Return the current epoch\&. This is useful for detecting whether another thread caused a refresh\&.
 .RE
 .PP
-"config\&.debug" (\fBbool\fR) r\-
+"config\&.cache_oblivious" (\fBbool\fR) r\-
 .RS 4
-\fB\-\-enable\-debug\fR
+\fB\-\-enable\-cache\-oblivious\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.dss" (\fBbool\fR) r\-
+"config\&.debug" (\fBbool\fR) r\-
 .RS 4
-\fB\-\-enable\-dss\fR
+\fB\-\-enable\-debug\fR
 was specified during build configuration\&.
 .RE
 .PP
 "config\&.fill" (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-fill\fR
@@ -681,18 +685,12 @@
 "config\&.lazy_lock" (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-lazy\-lock\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.mremap" (\fBbool\fR) r\-
-.RS 4
-\fB\-\-enable\-mremap\fR
-was specified during build configuration\&.
-.RE
-.PP
 "config\&.munmap" (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-munmap\fR
 was specified during build configuration\&.
 .RE
 .PP
@@ -760,52 +758,63 @@
 .RE
 .PP
 "opt\&.dss" (\fBconst char *\fR) r\-
 .RS 4
 dss (\fBsbrk\fR(2)) allocation precedence as related to
 \fBmmap\fR(2)
-allocation\&. The following settings are supported: \(lqdisabled\(rq, \(lqprimary\(rq, and \(lqsecondary\(rq\&. The default is \(lqsecondary\(rq if
-"config\&.dss"
-is true, \(lqdisabled\(rq otherwise\&.
+allocation\&. The following settings are supported if
+\fBsbrk\fR(2)
+is supported by the operating system: \(lqdisabled\(rq, \(lqprimary\(rq, and \(lqsecondary\(rq; otherwise only \(lqdisabled\(rq is supported\&. The default is \(lqsecondary\(rq if
+\fBsbrk\fR(2)
+is supported by the operating system; \(lqdisabled\(rq otherwise\&.
 .RE
 .PP
 "opt\&.lg_chunk" (\fBsize_t\fR) r\-
 .RS 4
-Virtual memory chunk size (log base 2)\&. If a chunk size outside the supported size range is specified, the size is silently clipped to the minimum/maximum supported size\&. The default chunk size is 4 MiB (2^22)\&.
+Virtual memory chunk size (log base 2)\&. If a chunk size outside the supported size range is specified, the size is silently clipped to the minimum/maximum supported size\&. The default chunk size is 2 MiB (2^21)\&.
 .RE
 .PP
 "opt\&.narenas" (\fBsize_t\fR) r\-
 .RS 4
 Maximum number of arenas to use for automatic multiplexing of threads and arenas\&. The default is four times the number of CPUs, or one if there is a single CPU\&.
 .RE
 .PP
 "opt\&.lg_dirty_mult" (\fBssize_t\fR) r\-
 .RS 4
 Per\-arena minimum ratio (log base 2) of active to dirty pages\&. Some dirty unused pages may be allowed to accumulate, within the limit set by the ratio (or one chunk worth of dirty pages, whichever is greater), before informing the kernel about some of those pages via
 \fBmadvise\fR(2)
-or a similar system call\&. This provides the kernel with sufficient information to recycle dirty pages if physical memory becomes scarce and the pages remain unused\&. The default minimum ratio is 8:1 (2^3:1); an option value of \-1 will disable dirty page purging\&.
+or a similar system call\&. This provides the kernel with sufficient information to recycle dirty pages if physical memory becomes scarce and the pages remain unused\&. The default minimum ratio is 8:1 (2^3:1); an option value of \-1 will disable dirty page purging\&. See
+"arenas\&.lg_dirty_mult"
+and
+"arena\&.<i>\&.lg_dirty_mult"
+for related dynamic control options\&.
 .RE
 .PP
 "opt\&.stats_print" (\fBbool\fR) r\-
 .RS 4
 Enable/disable statistics printing at exit\&. If enabled, the
 \fBmalloc_stats_print\fR\fB\fR
 function is called at program exit via an
 \fBatexit\fR(3)
 function\&. If
 \fB\-\-enable\-stats\fR
-is specified during configuration, this has the potential to cause deadlock for a multi\-threaded process that exits while one or more threads are executing in the memory allocation functions\&. Therefore, this option should only be used with care; it is primarily intended as a performance tuning aid during application development\&. This option is disabled by default\&.
+is specified during configuration, this has the potential to cause deadlock for a multi\-threaded process that exits while one or more threads are executing in the memory allocation functions\&. Furthermore,
+\fBatexit\fR\fB\fR
+may allocate memory during application initialization and then deadlock internally when jemalloc in turn calls
+\fBatexit\fR\fB\fR, so this option is not univerally usable (though the application can register its own
+\fBatexit\fR\fB\fR
+function with equivalent functionality)\&. Therefore, this option should only be used with care; it is primarily intended as a performance tuning aid during application development\&. This option is disabled by default\&.
 .RE
 .PP
-"opt\&.junk" (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
-.RS 4
-Junk filling enabled/disabled\&. If enabled, each byte of uninitialized allocated memory will be initialized to
-0xa5\&. All deallocated memory will be initialized to
-0x5a\&. This is intended for debugging and will impact performance negatively\&. This option is disabled by default unless
+"opt\&.junk" (\fBconst char *\fR) r\- [\fB\-\-enable\-fill\fR]
+.RS 4
+Junk filling\&. If set to "alloc", each byte of uninitialized allocated memory will be initialized to
+0xa5\&. If set to "free", all deallocated memory will be initialized to
+0x5a\&. If set to "true", both allocated and deallocated memory will be initialized, and if set to "false", junk filling be disabled entirely\&. This is intended for debugging and will impact performance negatively\&. This option is "false" by default unless
 \fB\-\-enable\-debug\fR
-is specified during configuration, in which case it is enabled by default unless running inside
+is specified during configuration, in which case it is "true" by default unless running inside
 \m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2\&.
 .RE
 .PP
 "opt\&.quarantine" (\fBsize_t\fR) r\- [\fB\-\-enable\-fill\fR]
 .RS 4
 Per thread quarantine size in bytes\&. If non\-zero, each thread maintains a FIFO object quarantine that stores up to the specified number of bytes of memory\&. The quarantined memory is not freed until it is released from quarantine, though it is immediately junk\-filled if the
@@ -822,32 +831,25 @@
 \m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, which needs redzones in order to do effective buffer overflow/underflow detection\&. This option is intended for debugging and will impact performance negatively\&. This option is disabled by default unless running inside Valgrind\&.
 .RE
 .PP
 "opt\&.zero" (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
 .RS 4
 Zero filling enabled/disabled\&. If enabled, each byte of uninitialized allocated memory will be initialized to 0\&. Note that this initialization only happens once for each byte, so
-\fBrealloc\fR\fB\fR,
-\fBrallocx\fR\fB\fR
+\fBrealloc\fR\fB\fR
 and
-\fBrallocm\fR\fB\fR
+\fBrallocx\fR\fB\fR
 calls do not zero memory that was previously allocated\&. This is intended for debugging and will impact performance negatively\&. This option is disabled by default\&.
 .RE
 .PP
 "opt\&.utrace" (\fBbool\fR) r\- [\fB\-\-enable\-utrace\fR]
 .RS 4
 Allocation tracing based on
 \fButrace\fR(2)
 enabled/disabled\&. This option is disabled by default\&.
 .RE
 .PP
-"opt\&.valgrind" (\fBbool\fR) r\- [\fB\-\-enable\-valgrind\fR]
-.RS 4
-\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2
-support enabled/disabled\&. This option is vestigal because jemalloc auto\-detects whether it is running inside Valgrind\&. This option is disabled by default, unless running inside Valgrind\&.
-.RE
-.PP
 "opt\&.xmalloc" (\fBbool\fR) r\- [\fB\-\-enable\-xmalloc\fR]
 .RS 4
 Abort\-on\-out\-of\-memory enabled/disabled\&. If enabled, rather than returning failure for any allocation function, display a diagnostic message on
 \fBSTDERR_FILENO\fR
 and cause the program to drop core (using
 \fBabort\fR(3))\&. If an application is designed to depend on this behavior, set the option at compile time by including the following in the source code:
@@ -864,21 +866,21 @@
 .sp
 This option is disabled by default\&.
 .RE
 .PP
 "opt\&.tcache" (\fBbool\fR) r\- [\fB\-\-enable\-tcache\fR]
 .RS 4
-Thread\-specific caching enabled/disabled\&. When there are multiple threads, each thread uses a thread\-specific cache for objects up to a certain size\&. Thread\-specific caching allows many allocations to be satisfied without performing any thread synchronization, at the cost of increased memory use\&. See the
+Thread\-specific caching (tcache) enabled/disabled\&. When there are multiple threads, each thread uses a tcache for objects up to a certain size\&. Thread\-specific caching allows many allocations to be satisfied without performing any thread synchronization, at the cost of increased memory use\&. See the
 "opt\&.lg_tcache_max"
 option for related tuning information\&. This option is enabled by default unless running inside
-\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2\&.
+\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, in which case it is forcefully disabled\&.
 .RE
 .PP
 "opt\&.lg_tcache_max" (\fBsize_t\fR) r\- [\fB\-\-enable\-tcache\fR]
 .RS 4
-Maximum size class (log base 2) to cache in the thread\-specific cache\&. At a minimum, all small size classes are cached, and at a maximum all large size classes are cached\&. The default maximum is 32 KiB (2^15)\&.
+Maximum size class (log base 2) to cache in the thread\-specific cache (tcache)\&. At a minimum, all small size classes are cached, and at a maximum all large size classes are cached\&. The default maximum is 32 KiB (2^15)\&.
 .RE
 .PP
 "opt\&.prof" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Memory profiling enabled/disabled\&. If enabled, profile memory allocation activity\&. See the
 "opt\&.prof_active"
@@ -889,34 +891,45 @@
 option for control of cumulative sample reporting\&. See the
 "opt\&.lg_prof_interval"
 option for information on interval\-triggered profile dumping, the
 "opt\&.prof_gdump"
 option for information on high\-water\-triggered profile dumping, and the
 "opt\&.prof_final"
-option for final profile dumping\&. Profile output is compatible with the included
+option for final profile dumping\&. Profile output is compatible with the
+\fBjeprof\fR
+command, which is based on the
 \fBpprof\fR
-Perl script, which originates from the
+that is developed as part of the
 \m[blue]\fBgperftools package\fR\m[]\&\s-2\u[3]\d\s+2\&.
 .RE
 .PP
 "opt\&.prof_prefix" (\fBconst char *\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Filename prefix for profile dumps\&. If the prefix is set to the empty string, no automatic dumps will occur; this is primarily useful for disabling the automatic final heap dump (which also disables leak reporting, if enabled)\&. The default prefix is
 jeprof\&.
 .RE
 .PP
-"opt\&.prof_active" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
+"opt\&.prof_active" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Profiling activated/deactivated\&. This is a secondary control mechanism that makes it possible to start the application with profiling enabled (see the
 "opt\&.prof"
 option) but inactive, then toggle profiling at any time during program execution with the
 "prof\&.active"
 mallctl\&. This option is enabled by default\&.
 .RE
 .PP
-"opt\&.lg_prof_sample" (\fBssize_t\fR) r\- [\fB\-\-enable\-prof\fR]
+"opt\&.prof_thread_active_init" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
+.RS 4
+Initial setting for
+"thread\&.prof\&.active"
+in newly created threads\&. The initial setting for newly created threads can also be changed during execution via the
+"prof\&.thread_active_init"
+mallctl\&. This option is enabled by default\&.
+.RE
+.PP
+"opt\&.lg_prof_sample" (\fBsize_t\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Average interval (log base 2) between allocation samples, as measured in bytes of allocation activity\&. Increasing the sampling interval decreases profile fidelity, but also decreases the computational overhead\&. The default sample interval is 512 KiB (2^19 B)\&.
 .RE
 .PP
 "opt\&.prof_accum" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
@@ -932,30 +945,31 @@
 "opt\&.prof_prefix"
 option\&. By default, interval\-triggered profile dumping is disabled (encoded as \-1)\&.
 .RE
 .PP
 "opt\&.prof_gdump" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
-Trigger a memory profile dump every time the total virtual memory exceeds the previous maximum\&. Profiles are dumped to files named according to the pattern
-<prefix>\&.<pid>\&.<seq>\&.u<useq>\&.heap, where
-<prefix>
-is controlled by the
-"opt\&.prof_prefix"
-option\&. This option is disabled by default\&.
+Set the initial state of
+"prof\&.gdump", which when enabled triggers a memory profile dump every time the total virtual memory exceeds the previous maximum\&. This option is disabled by default\&.
 .RE
 .PP
 "opt\&.prof_final" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Use an
 \fBatexit\fR(3)
 function to dump final memory usage to a file named according to the pattern
 <prefix>\&.<pid>\&.<seq>\&.f\&.heap, where
 <prefix>
 is controlled by the
 "opt\&.prof_prefix"
-option\&. This option is enabled by default\&.
+option\&. Note that
+\fBatexit\fR\fB\fR
+may allocate memory during application initialization and then deadlock internally when jemalloc in turn calls
+\fBatexit\fR\fB\fR, so this option is not univerally usable (though the application can register its own
+\fBatexit\fR\fB\fR
+function with equivalent functionality)\&. This option is disabled by default\&.
 .RE
 .PP
 "opt\&.prof_leak" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Leak reporting enabled/disabled\&. If enabled, use an
 \fBatexit\fR(3)
@@ -1004,41 +1018,308 @@
 Enable/disable calling thread\*(Aqs tcache\&. The tcache is implicitly flushed as a side effect of becoming disabled (see
 "thread\&.tcache\&.flush")\&.
 .RE
 .PP
 "thread\&.tcache\&.flush" (\fBvoid\fR) \-\- [\fB\-\-enable\-tcache\fR]
 .RS 4
-Flush calling thread\*(Aqs tcache\&. This interface releases all cached objects and internal data structures associated with the calling thread\*(Aqs thread\-specific cache\&. Ordinarily, this interface need not be called, since automatic periodic incremental garbage collection occurs, and the thread cache is automatically discarded when a thread exits\&. However, garbage collection is triggered by allocation activity, so it is possible for a thread that stops allocating/deallocating to retain its cache indefinitely, in which case the developer may find manual flushing useful\&.
+Flush calling thread\*(Aqs thread\-specific cache (tcache)\&. This interface releases all cached objects and internal data structures associated with the calling thread\*(Aqs tcache\&. Ordinarily, this interface need not be called, since automatic periodic incremental garbage collection occurs, and the thread cache is automatically discarded when a thread exits\&. However, garbage collection is triggered by allocation activity, so it is possible for a thread that stops allocating/deallocating to retain its cache indefinitely, in which case the developer may find manual flushing useful\&.
+.RE
+.PP
+"thread\&.prof\&.name" (\fBconst char *\fR) r\- or \-w [\fB\-\-enable\-prof\fR]
+.RS 4
+Get/set the descriptive name associated with the calling thread in memory profile dumps\&. An internal copy of the name string is created, so the input string need not be maintained after this interface completes execution\&. The output string of this interface should be copied for non\-ephemeral uses, because multiple implementation details can cause asynchronous string deallocation\&. Furthermore, each invocation of this interface can only read or write; simultaneous read/write is not supported due to string lifetime limitations\&. The name string must nil\-terminated and comprised only of characters in the sets recognized by
+\fBisgraph\fR(3)
+and
+\fBisblank\fR(3)\&.
+.RE
+.PP
+"thread\&.prof\&.active" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
+.RS 4
+Control whether sampling is currently active for the calling thread\&. This is an activation mechanism in addition to
+"prof\&.active"; both must be active for the calling thread to sample\&. This flag is enabled by default\&.
+.RE
+.PP
+"tcache\&.create" (\fBunsigned\fR) r\- [\fB\-\-enable\-tcache\fR]
+.RS 4
+Create an explicit thread\-specific cache (tcache) and return an identifier that can be passed to the
+\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR
+macro to explicitly use the specified cache rather than the automatically managed one that is used by default\&. Each explicit cache can be used by only one thread at a time; the application must assure that this constraint holds\&.
+.RE
+.PP
+"tcache\&.flush" (\fBunsigned\fR) \-w [\fB\-\-enable\-tcache\fR]
+.RS 4
+Flush the specified thread\-specific cache (tcache)\&. The same considerations apply to this interface as to
+"thread\&.tcache\&.flush", except that the tcache will never be automatically be discarded\&.
 .RE
 .PP
-"arena\&.<i>\&.purge" (\fBunsigned\fR) \-\-
+"tcache\&.destroy" (\fBunsigned\fR) \-w [\fB\-\-enable\-tcache\fR]
+.RS 4
+Flush the specified thread\-specific cache (tcache) and make the identifier available for use during a future tcache creation\&.
+.RE
+.PP
+"arena\&.<i>\&.purge" (\fBvoid\fR) \-\-
 .RS 4
 Purge unused dirty pages for arena <i>, or for all arenas if <i> equals
 "arenas\&.narenas"\&.
 .RE
 .PP
 "arena\&.<i>\&.dss" (\fBconst char *\fR) rw
 .RS 4
 Set the precedence of dss allocation as related to mmap allocation for arena <i>, or for all arenas if <i> equals
-"arenas\&.narenas"\&. Note that even during huge allocation this setting is read from the arena that would be chosen for small or large allocation so that applications can depend on consistent dss versus mmap allocation regardless of allocation size\&. See
+"arenas\&.narenas"\&. See
 "opt\&.dss"
 for supported settings\&.
 .RE
 .PP
+"arena\&.<i>\&.lg_dirty_mult" (\fBssize_t\fR) rw
+.RS 4
+Current per\-arena minimum ratio (log base 2) of active to dirty pages for arena <i>\&. Each time this interface is set and the ratio is increased, pages are synchronously purged as necessary to impose the new ratio\&. See
+"opt\&.lg_dirty_mult"
+for additional information\&.
+.RE
+.PP
+"arena\&.<i>\&.chunk_hooks" (\fBchunk_hooks_t\fR) rw
+.RS 4
+Get or set the chunk management hook functions for arena <i>\&. The functions must be capable of operating on all extant chunks associated with arena <i>, usually by passing unknown chunks to the replaced functions\&. In practice, it is feasible to control allocation for arenas created via
+"arenas\&.extend"
+such that all chunks originate from an application\-supplied chunk allocator (by setting custom chunk hook functions just after arena creation), but the automatically created arenas may have already created chunks prior to the application having an opportunity to take over chunk allocation\&.
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+typedef struct {
+	chunk_alloc_t		*alloc;
+	chunk_dalloc_t		*dalloc;
+	chunk_commit_t		*commit;
+	chunk_decommit_t	*decommit;
+	chunk_purge_t		*purge;
+	chunk_split_t		*split;
+	chunk_merge_t		*merge;
+} chunk_hooks_t;
+.fi
+.if n \{\
+.RE
+.\}
+.sp
+The
+\fBchunk_hooks_t\fR
+structure comprises function pointers which are described individually below\&. jemalloc uses these functions to manage chunk lifetime, which starts off with allocation of mapped committed memory, in the simplest case followed by deallocation\&. However, there are performance and platform reasons to retain chunks for later reuse\&. Cleanup attempts cascade from deallocation to decommit to purging, which gives the chunk management functions opportunities to reject the most permanent cleanup operations in favor of less permanent (and often less costly) operations\&. The chunk splitting and merging operations can also be opted out of, but this is mainly intended to support platforms on which virtual memory mappings provided by the operating system kernel do not automatically coalesce and split, e\&.g\&. Windows\&.
+.HP \w'typedef\ void\ *(chunk_alloc_t)('u
+.BI "typedef void *(chunk_alloc_t)(void\ *" "chunk" ", size_t\ " "size" ", size_t\ " "alignment" ", bool\ *" "zero" ", bool\ *" "commit" ", unsigned\ " "arena_ind" ");"
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+.fi
+.if n \{\
+.RE
+.\}
+.sp
+A chunk allocation function conforms to the
+\fBchunk_alloc_t\fR
+type and upon success returns a pointer to
+\fIsize\fR
+bytes of mapped memory on behalf of arena
+\fIarena_ind\fR
+such that the chunk\*(Aqs base address is a multiple of
+\fIalignment\fR, as well as setting
+\fI*zero\fR
+to indicate whether the chunk is zeroed and
+\fI*commit\fR
+to indicate whether the chunk is committed\&. Upon error the function returns
+\fBNULL\fR
+and leaves
+\fI*zero\fR
+and
+\fI*commit\fR
+unmodified\&. The
+\fIsize\fR
+parameter is always a multiple of the chunk size\&. The
+\fIalignment\fR
+parameter is always a power of two at least as large as the chunk size\&. Zeroing is mandatory if
+\fI*zero\fR
+is true upon function entry\&. Committing is mandatory if
+\fI*commit\fR
+is true upon function entry\&. If
+\fIchunk\fR
+is not
+\fBNULL\fR, the returned pointer must be
+\fIchunk\fR
+on success or
+\fBNULL\fR
+on error\&. Committed memory may be committed in absolute terms as on a system that does not overcommit, or in implicit terms as on a system that overcommits and satisfies physical memory needs on demand via soft page faults\&. Note that replacing the default chunk allocation function makes the arena\*(Aqs
+"arena\&.<i>\&.dss"
+setting irrelevant\&.
+.HP \w'typedef\ bool\ (chunk_dalloc_t)('u
+.BI "typedef bool (chunk_dalloc_t)(void\ *" "chunk" ", size_t\ " "size" ", bool\ " "committed" ", unsigned\ " "arena_ind" ");"
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+.fi
+.if n \{\
+.RE
+.\}
+.sp
+A chunk deallocation function conforms to the
+\fBchunk_dalloc_t\fR
+type and deallocates a
+\fIchunk\fR
+of given
+\fIsize\fR
+with
+\fIcommitted\fR/decommited memory as indicated, on behalf of arena
+\fIarena_ind\fR, returning false upon success\&. If the function returns true, this indicates opt\-out from deallocation; the virtual memory mapping associated with the chunk remains mapped, in the same commit state, and available for future use, in which case it will be automatically retained for later reuse\&.
+.HP \w'typedef\ bool\ (chunk_commit_t)('u
+.BI "typedef bool (chunk_commit_t)(void\ *" "chunk" ", size_t\ " "size" ", size_t\ " "offset" ", size_t\ " "length" ", unsigned\ " "arena_ind" ");"
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+.fi
+.if n \{\
+.RE
+.\}
+.sp
+A chunk commit function conforms to the
+\fBchunk_commit_t\fR
+type and commits zeroed physical memory to back pages within a
+\fIchunk\fR
+of given
+\fIsize\fR
+at
+\fIoffset\fR
+bytes, extending for
+\fIlength\fR
+on behalf of arena
+\fIarena_ind\fR, returning false upon success\&. Committed memory may be committed in absolute terms as on a system that does not overcommit, or in implicit terms as on a system that overcommits and satisfies physical memory needs on demand via soft page faults\&. If the function returns true, this indicates insufficient physical memory to satisfy the request\&.
+.HP \w'typedef\ bool\ (chunk_decommit_t)('u
+.BI "typedef bool (chunk_decommit_t)(void\ *" "chunk" ", size_t\ " "size" ", size_t\ " "offset" ", size_t\ " "length" ", unsigned\ " "arena_ind" ");"
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+.fi
+.if n \{\
+.RE
+.\}
+.sp
+A chunk decommit function conforms to the
+\fBchunk_decommit_t\fR
+type and decommits any physical memory that is backing pages within a
+\fIchunk\fR
+of given
+\fIsize\fR
+at
+\fIoffset\fR
+bytes, extending for
+\fIlength\fR
+on behalf of arena
+\fIarena_ind\fR, returning false upon success, in which case the pages will be committed via the chunk commit function before being reused\&. If the function returns true, this indicates opt\-out from decommit; the memory remains committed and available for future use, in which case it will be automatically retained for later reuse\&.
+.HP \w'typedef\ bool\ (chunk_purge_t)('u
+.BI "typedef bool (chunk_purge_t)(void\ *" "chunk" ", size_t" "size" ", size_t\ " "offset" ", size_t\ " "length" ", unsigned\ " "arena_ind" ");"
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+.fi
+.if n \{\
+.RE
+.\}
+.sp
+A chunk purge function conforms to the
+\fBchunk_purge_t\fR
+type and optionally discards physical pages within the virtual memory mapping associated with
+\fIchunk\fR
+of given
+\fIsize\fR
+at
+\fIoffset\fR
+bytes, extending for
+\fIlength\fR
+on behalf of arena
+\fIarena_ind\fR, returning false if pages within the purged virtual memory range will be zero\-filled the next time they are accessed\&.
+.HP \w'typedef\ bool\ (chunk_split_t)('u
+.BI "typedef bool (chunk_split_t)(void\ *" "chunk" ", size_t\ " "size" ", size_t\ " "size_a" ", size_t\ " "size_b" ", bool\ " "committed" ", unsigned\ " "arena_ind" ");"
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+.fi
+.if n \{\
+.RE
+.\}
+.sp
+A chunk split function conforms to the
+\fBchunk_split_t\fR
+type and optionally splits
+\fIchunk\fR
+of given
+\fIsize\fR
+into two adjacent chunks, the first of
+\fIsize_a\fR
+bytes, and the second of
+\fIsize_b\fR
+bytes, operating on
+\fIcommitted\fR/decommitted memory as indicated, on behalf of arena
+\fIarena_ind\fR, returning false upon success\&. If the function returns true, this indicates that the chunk remains unsplit and therefore should continue to be operated on as a whole\&.
+.HP \w'typedef\ bool\ (chunk_merge_t)('u
+.BI "typedef bool (chunk_merge_t)(void\ *" "chunk_a" ", size_t\ " "size_a" ", void\ *" "chunk_b" ", size_t\ " "size_b" ", bool\ " "committed" ", unsigned\ " "arena_ind" ");"
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+.fi
+.if n \{\
+.RE
+.\}
+.sp
+A chunk merge function conforms to the
+\fBchunk_merge_t\fR
+type and optionally merges adjacent chunks,
+\fIchunk_a\fR
+of given
+\fIsize_a\fR
+and
+\fIchunk_b\fR
+of given
+\fIsize_b\fR
+into one contiguous chunk, operating on
+\fIcommitted\fR/decommitted memory as indicated, on behalf of arena
+\fIarena_ind\fR, returning false upon success\&. If the function returns true, this indicates that the chunks remain distinct mappings and therefore should continue to be operated on independently\&.
+.RE
+.PP
 "arenas\&.narenas" (\fBunsigned\fR) r\-
 .RS 4
 Current limit on number of arenas\&.
 .RE
 .PP
 "arenas\&.initialized" (\fBbool *\fR) r\-
 .RS 4
 An array of
 "arenas\&.narenas"
 booleans\&. Each boolean indicates whether the corresponding arena is initialized\&.
 .RE
 .PP
+"arenas\&.lg_dirty_mult" (\fBssize_t\fR) rw
+.RS 4
+Current default per\-arena minimum ratio (log base 2) of active to dirty pages, used to initialize
+"arena\&.<i>\&.lg_dirty_mult"
+during arena creation\&. See
+"opt\&.lg_dirty_mult"
+for additional information\&.
+.RE
+.PP
 "arenas\&.quantum" (\fBsize_t\fR) r\-
 .RS 4
 Quantum size\&.
 .RE
 .PP
 "arenas\&.page" (\fBsize_t\fR) r\-
@@ -1073,59 +1354,99 @@
 .PP
 "arenas\&.bin\&.<i>\&.run_size" (\fBsize_t\fR) r\-
 .RS 4
 Number of bytes per page run\&.
 .RE
 .PP
-"arenas\&.nlruns" (\fBsize_t\fR) r\-
+"arenas\&.nlruns" (\fBunsigned\fR) r\-
 .RS 4
 Total number of large size classes\&.
 .RE
 .PP
 "arenas\&.lrun\&.<i>\&.size" (\fBsize_t\fR) r\-
 .RS 4
 Maximum size supported by this large size class\&.
 .RE
 .PP
-"arenas\&.purge" (\fBunsigned\fR) \-w
+"arenas\&.nhchunks" (\fBunsigned\fR) r\-
+.RS 4
+Total number of huge size classes\&.
+.RE
+.PP
+"arenas\&.hchunk\&.<i>\&.size" (\fBsize_t\fR) r\-
 .RS 4
-Purge unused dirty pages for the specified arena, or for all arenas if none is specified\&.
+Maximum size supported by this huge size class\&.
 .RE
 .PP
 "arenas\&.extend" (\fBunsigned\fR) r\-
 .RS 4
 Extend the array of arenas by appending a new arena, and returning the new arena index\&.
 .RE
 .PP
+"prof\&.thread_active_init" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
+.RS 4
+Control the initial setting for
+"thread\&.prof\&.active"
+in newly created threads\&. See the
+"opt\&.prof_thread_active_init"
+option for additional information\&.
+.RE
+.PP
 "prof\&.active" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
 .RS 4
 Control whether sampling is currently active\&. See the
 "opt\&.prof_active"
-option for additional information\&.
+option for additional information, as well as the interrelated
+"thread\&.prof\&.active"
+mallctl\&.
 .RE
 .PP
 "prof\&.dump" (\fBconst char *\fR) \-w [\fB\-\-enable\-prof\fR]
 .RS 4
 Dump a memory profile to the specified file, or if NULL is specified, to a file according to the pattern
 <prefix>\&.<pid>\&.<seq>\&.m<mseq>\&.heap, where
 <prefix>
 is controlled by the
 "opt\&.prof_prefix"
 option\&.
 .RE
 .PP
+"prof\&.gdump" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
+.RS 4
+When enabled, trigger a memory profile dump every time the total virtual memory exceeds the previous maximum\&. Profiles are dumped to files named according to the pattern
+<prefix>\&.<pid>\&.<seq>\&.u<useq>\&.heap, where
+<prefix>
+is controlled by the
+"opt\&.prof_prefix"
+option\&.
+.RE
+.PP
+"prof\&.reset" (\fBsize_t\fR) \-w [\fB\-\-enable\-prof\fR]
+.RS 4
+Reset all memory profile statistics, and optionally update the sample rate (see
+"opt\&.lg_prof_sample"
+and
+"prof\&.lg_sample")\&.
+.RE
+.PP
+"prof\&.lg_sample" (\fBsize_t\fR) r\- [\fB\-\-enable\-prof\fR]
+.RS 4
+Get the current sample rate (see
+"opt\&.lg_prof_sample")\&.
+.RE
+.PP
 "prof\&.interval" (\fBuint64_t\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Average number of bytes allocated between inverval\-based profile dumps\&. See the
 "opt\&.lg_prof_interval"
 option for additional information\&.
 .RE
 .PP
 "stats\&.cactive" (\fBsize_t *\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
-Pointer to a counter that contains an approximate count of the current number of bytes in active pages\&. The estimate may be high, but never low, because each arena rounds up to the nearest multiple of the chunk size when computing its contribution to the counter\&. Note that the
+Pointer to a counter that contains an approximate count of the current number of bytes in active pages\&. The estimate may be high, but never low, because each arena rounds up when computing its contribution to the counter\&. Note that the
 "epoch"
 mallctl has no bearing on this counter\&. Furthermore, counter consistency is maintained via atomic operations, so it is necessary to use an atomic operation in order to guarantee a consistent read when dereferencing the pointer\&.
 .RE
 .PP
 "stats\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
@@ -1133,61 +1454,51 @@
 .RE
 .PP
 "stats\&.active" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Total number of bytes in active pages allocated by the application\&. This is a multiple of the page size, and greater than or equal to
 "stats\&.allocated"\&. This does not include
-"stats\&.arenas\&.<i>\&.pdirty"
-and pages entirely devoted to allocator metadata\&.
-.RE
-.PP
-"stats\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
-.RS 4
-Total number of bytes in chunks mapped on behalf of the application\&. This is a multiple of the chunk size, and is at least as large as
-"stats\&.active"\&. This does not include inactive chunks\&.
-.RE
-.PP
-"stats\&.chunks\&.current" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
-.RS 4
-Total number of chunks actively mapped on behalf of the application\&. This does not include inactive chunks\&.
-.RE
-.PP
-"stats\&.chunks\&.total" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
-.RS 4
-Cumulative number of chunks allocated\&.
-.RE
-.PP
-"stats\&.chunks\&.high" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
-.RS 4
-Maximum number of active chunks at any time thus far\&.
+"stats\&.arenas\&.<i>\&.pdirty", nor pages entirely devoted to allocator metadata\&.
 .RE
 .PP
-"stats\&.huge\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+"stats\&.metadata" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
-Number of bytes currently allocated by huge objects\&.
+Total number of bytes dedicated to metadata, which comprise base allocations used for bootstrap\-sensitive internal allocator data structures, arena chunk headers (see
+"stats\&.arenas\&.<i>\&.metadata\&.mapped"), and internal allocations (see
+"stats\&.arenas\&.<i>\&.metadata\&.allocated")\&.
 .RE
 .PP
-"stats\&.huge\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+"stats\&.resident" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
-Cumulative number of huge allocation requests\&.
+Maximum number of bytes in physically resident data pages mapped by the allocator, comprising all pages dedicated to allocator metadata, pages backing active allocations, and unused dirty pages\&. This is a maximum rather than precise because pages may not actually be physically resident if they correspond to demand\-zeroed virtual memory that has not yet been touched\&. This is a multiple of the page size, and is larger than
+"stats\&.active"\&.
 .RE
 .PP
-"stats\&.huge\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+"stats\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
-Cumulative number of huge deallocation requests\&.
+Total number of bytes in active chunks mapped by the allocator\&. This is a multiple of the chunk size, and is larger than
+"stats\&.active"\&. This does not include inactive chunks, even those that contain unused dirty pages, which means that there is no strict ordering between this and
+"stats\&.resident"\&.
 .RE
 .PP
 "stats\&.arenas\&.<i>\&.dss" (\fBconst char *\fR) r\-
 .RS 4
 dss (\fBsbrk\fR(2)) allocation precedence as related to
 \fBmmap\fR(2)
 allocation\&. See
 "opt\&.dss"
 for details\&.
 .RE
 .PP
+"stats\&.arenas\&.<i>\&.lg_dirty_mult" (\fBssize_t\fR) r\-
+.RS 4
+Minimum ratio (log base 2) of active to dirty pages\&. See
+"opt\&.lg_dirty_mult"
+for details\&.
+.RE
+.PP
 "stats\&.arenas\&.<i>\&.nthreads" (\fBunsigned\fR) r\-
 .RS 4
 Number of threads currently assigned to arena\&.
 .RE
 .PP
 "stats\&.arenas\&.<i>\&.pactive" (\fBsize_t\fR) r\-
@@ -1204,12 +1515,30 @@
 .PP
 "stats\&.arenas\&.<i>\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of mapped bytes\&.
 .RE
 .PP
+"stats\&.arenas\&.<i>\&.metadata\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Number of mapped bytes in arena chunk headers, which track the states of the non\-metadata pages\&.
+.RE
+.PP
+"stats\&.arenas\&.<i>\&.metadata\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Number of bytes dedicated to internal allocations\&. Internal allocations differ from application\-originated allocations in that they are for internal use, and that they are omitted from heap profiles\&. This statistic is reported separately from
+"stats\&.metadata"
+and
+"stats\&.arenas\&.<i>\&.metadata\&.mapped"
+because it overlaps with e\&.g\&. the
+"stats\&.allocated"
+and
+"stats\&.active"
+statistics, whereas the other metadata statistics do not\&.
+.RE
+.PP
 "stats\&.arenas\&.<i>\&.npurge" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of dirty page purge sweeps performed\&.
 .RE
 .PP
 "stats\&.arenas\&.<i>\&.nmadvise" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
@@ -1261,15 +1590,30 @@
 .PP
 "stats\&.arenas\&.<i>\&.large\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of large allocation requests\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+"stats\&.arenas\&.<i>\&.huge\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Number of bytes currently allocated by huge objects\&.
+.RE
+.PP
+"stats\&.arenas\&.<i>\&.huge\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Cumulative number of huge allocation requests served directly by the arena\&.
+.RE
+.PP
+"stats\&.arenas\&.<i>\&.huge\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
-Current number of bytes allocated by bin\&.
+Cumulative number of huge deallocation requests served directly by the arena\&.
+.RE
+.PP
+"stats\&.arenas\&.<i>\&.huge\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Cumulative number of huge allocation requests\&.
 .RE
 .PP
 "stats\&.arenas\&.<i>\&.bins\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocations served by bin\&.
 .RE
@@ -1281,12 +1625,17 @@
 .PP
 "stats\&.arenas\&.<i>\&.bins\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocation requests\&.
 .RE
 .PP
+"stats\&.arenas\&.<i>\&.bins\&.<j>\&.curregs" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Current number of regions for this size class\&.
+.RE
+.PP
 "stats\&.arenas\&.<i>\&.bins\&.<j>\&.nfills" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
 .RS 4
 Cumulative number of tcache fills\&.
 .RE
 .PP
 "stats\&.arenas\&.<i>\&.bins\&.<j>\&.nflushes" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
@@ -1325,12 +1674,32 @@
 .RE
 .PP
 "stats\&.arenas\&.<i>\&.lruns\&.<j>\&.curruns" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Current number of runs for this size class\&.
 .RE
+.PP
+"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Cumulative number of allocation requests for this size class served directly by the arena\&.
+.RE
+.PP
+"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Cumulative number of deallocation requests for this size class served directly by the arena\&.
+.RE
+.PP
+"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Cumulative number of allocation requests for this size class\&.
+.RE
+.PP
+"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.curhchunks" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Current number of huge allocations for this size class\&.
+.RE
 .SH "DEBUGGING MALLOC PROBLEMS"
 .PP
 When debugging, it is a good idea to configure/build jemalloc with the
 \fB\-\-enable\-debug\fR
 and
 \fB\-\-enable\-fill\fR
@@ -1510,50 +1879,12 @@
 .RE
 .PP
 The
 \fBmalloc_usable_size\fR\fB\fR
 function returns the usable size of the allocation pointed to by
 \fIptr\fR\&.
-.SS "Experimental API"
-.PP
-The
-\fBallocm\fR\fB\fR,
-\fBrallocm\fR\fB\fR,
-\fBsallocm\fR\fB\fR,
-\fBdallocm\fR\fB\fR, and
-\fBnallocm\fR\fB\fR
-functions return
-\fBALLOCM_SUCCESS\fR
-on success; otherwise they return an error value\&. The
-\fBallocm\fR\fB\fR,
-\fBrallocm\fR\fB\fR, and
-\fBnallocm\fR\fB\fR
-functions will fail if:
-.PP
-ALLOCM_ERR_OOM
-.RS 4
-Out of memory\&. Insufficient contiguous memory was available to service the allocation request\&. The
-\fBallocm\fR\fB\fR
-function additionally sets
-\fI*ptr\fR
-to
-\fBNULL\fR, whereas the
-\fBrallocm\fR\fB\fR
-function leaves
-\fB*ptr\fR
-unmodified\&.
-.RE
-The
-\fBrallocm\fR\fB\fR
-function will also fail if:
-.PP
-ALLOCM_ERR_NOT_MOVED
-.RS 4
-\fBALLOCM_NO_MOVE\fR
-was specified, but the reallocation request could not be serviced without moving the object\&.
-.RE
 .SH "ENVIRONMENT"
 .PP
 The following environment variable affects the execution of the allocation functions:
 .PP
 \fBMALLOC_CONF\fR
 .RS 4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/jemalloc.html /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/jemalloc.html
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/jemalloc.html	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/jemalloc.html	2016-05-06 15:11:36.000000000 +0800
@@ -1,28 +1,27 @@
-<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>JEMALLOC</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="idm316394519664"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>jemalloc &#8212; general purpose memory allocation functions</p></div><div class="refsect1"><a name="library"></a><h2>LIBRARY</h2><p>This manual describes jemalloc 3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340.  More information
-    can be found at the <a class="ulink" href="http://www.canonware.com/jemalloc/" target="_top">jemalloc website</a>.</p></div><div class="refsynopsisdiv"><h2>SYNOPSIS</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;<code class="filename">stdlib.h</code>&gt;
-#include &lt;<code class="filename">jemalloc/jemalloc.h</code>&gt;</pre><div class="refsect2"><a name="idm316394002288"></a><h3>Standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">malloc</b>(</code></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">calloc</b>(</code></td><td>size_t <var class="pdparam">number</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">posix_memalign</b>(</code></td><td>void **<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">aligned_alloc</b>(</code></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">realloc</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">free</b>(</code></td><td>void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="refsect2"><a name="idm316393986160"></a><h3>Non-standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">mallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">rallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">xallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">extra</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">sallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">dallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">nallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctl</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlnametomib</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">mibp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">miblenp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlbymib</b>(</code></td><td>const size_t *<var class="pdparam">mib</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">miblen</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">malloc_stats_print</b>(</code></td><td>void <var class="pdparam">(*write_cb)</var>
+<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>JEMALLOC</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="idp45223136"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>jemalloc &#8212; general purpose memory allocation functions</p></div><div class="refsect1"><a name="library"></a><h2>LIBRARY</h2><p>This manual describes jemalloc 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c.  More information
+    can be found at the <a class="ulink" href="http://www.canonware.com/jemalloc/" target="_top">jemalloc website</a>.</p></div><div class="refsynopsisdiv"><h2>SYNOPSIS</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;<code class="filename">jemalloc/jemalloc.h</code>&gt;</pre><div class="refsect2"><a name="idp44244480"></a><h3>Standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">malloc</b>(</code></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">calloc</b>(</code></td><td>size_t <var class="pdparam">number</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">posix_memalign</b>(</code></td><td>void **<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">aligned_alloc</b>(</code></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">realloc</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">free</b>(</code></td><td>void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="refsect2"><a name="idp46062768"></a><h3>Non-standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">mallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">rallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">xallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">extra</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">sallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">dallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">sdallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">nallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctl</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlnametomib</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">mibp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">miblenp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlbymib</b>(</code></td><td>const size_t *<var class="pdparam">mib</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">miblen</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">malloc_stats_print</b>(</code></td><td>void <var class="pdparam">(*write_cb)</var>
             <code>(</code>void *, const char *<code>)</code>
-          , </td></tr><tr><td></td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td></td><td>const char *<var class="pdparam">opts</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">malloc_usable_size</b>(</code></td><td>const void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">(*malloc_message)</b>(</code></td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td></td><td>const char *<var class="pdparam">s</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><p><span class="type">const char *</span><code class="varname">malloc_conf</code>;</p></div><div class="refsect2"><a name="idm316388684112"></a><h3>Experimental API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">allocm</b>(</code></td><td>void **<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">rsize</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">rallocm</b>(</code></td><td>void **<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">rsize</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">extra</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">sallocm</b>(</code></td><td>const void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">rsize</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">dallocm</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">nallocm</b>(</code></td><td>size_t *<var class="pdparam">rsize</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div></div></div><div class="refsect1"><a name="description"></a><h2>DESCRIPTION</h2><div class="refsect2"><a name="idm316388663504"></a><h3>Standard API</h3><p>The <code class="function">malloc</code>(<em class="parameter"><code></code></em>) function allocates
+          , </td></tr><tr><td></td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td></td><td>const char *<var class="pdparam">opts</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">malloc_usable_size</b>(</code></td><td>const void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">(*malloc_message)</b>(</code></td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td></td><td>const char *<var class="pdparam">s</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><p><span class="type">const char *</span><code class="varname">malloc_conf</code>;</p></div></div></div><div class="refsect1"><a name="description"></a><h2>DESCRIPTION</h2><div class="refsect2"><a name="idp46115952"></a><h3>Standard API</h3><p>The <code class="function">malloc</code>(<em class="parameter"><code></code></em>) function allocates
       <em class="parameter"><code>size</code></em> bytes of uninitialized memory.  The allocated
       space is suitably aligned (after possible pointer coercion) for storage
       of any type of object.</p><p>The <code class="function">calloc</code>(<em class="parameter"><code></code></em>) function allocates
       space for <em class="parameter"><code>number</code></em> objects, each
       <em class="parameter"><code>size</code></em> bytes in length.  The result is identical to
       calling <code class="function">malloc</code>(<em class="parameter"><code></code></em>) with an argument of
       <em class="parameter"><code>number</code></em> * <em class="parameter"><code>size</code></em>, with the
       exception that the allocated memory is explicitly initialized to zero
       bytes.</p><p>The <code class="function">posix_memalign</code>(<em class="parameter"><code></code></em>) function
       allocates <em class="parameter"><code>size</code></em> bytes of memory such that the
-      allocation's base address is an even multiple of
+      allocation's base address is a multiple of
       <em class="parameter"><code>alignment</code></em>, and returns the allocation in the value
       pointed to by <em class="parameter"><code>ptr</code></em>.  The requested
-      <em class="parameter"><code>alignment</code></em> must be a power of 2 at least as large
-      as <code class="code">sizeof(<span class="type">void *</span>)</code>.</p><p>The <code class="function">aligned_alloc</code>(<em class="parameter"><code></code></em>) function
+      <em class="parameter"><code>alignment</code></em> must be a power of 2 at least as large as
+      <code class="code">sizeof(<span class="type">void *</span>)</code>.</p><p>The <code class="function">aligned_alloc</code>(<em class="parameter"><code></code></em>) function
       allocates <em class="parameter"><code>size</code></em> bytes of memory such that the
-      allocation's base address is an even multiple of
+      allocation's base address is a multiple of
       <em class="parameter"><code>alignment</code></em>.  The requested
       <em class="parameter"><code>alignment</code></em> must be a power of 2.  Behavior is
       undefined if <em class="parameter"><code>size</code></em> is not an integral multiple of
       <em class="parameter"><code>alignment</code></em>.</p><p>The <code class="function">realloc</code>(<em class="parameter"><code></code></em>) function changes the
       size of the previously allocated memory referenced by
       <em class="parameter"><code>ptr</code></em> to <em class="parameter"><code>size</code></em> bytes.  The
@@ -35,43 +34,57 @@
       resulting in a different return value than <em class="parameter"><code>ptr</code></em>.
       If <em class="parameter"><code>ptr</code></em> is <code class="constant">NULL</code>, the
       <code class="function">realloc</code>(<em class="parameter"><code></code></em>) function behaves identically to
       <code class="function">malloc</code>(<em class="parameter"><code></code></em>) for the specified size.</p><p>The <code class="function">free</code>(<em class="parameter"><code></code></em>) function causes the
       allocated memory referenced by <em class="parameter"><code>ptr</code></em> to be made
       available for future allocations.  If <em class="parameter"><code>ptr</code></em> is
-      <code class="constant">NULL</code>, no action occurs.</p></div><div class="refsect2"><a name="idm316388639904"></a><h3>Non-standard API</h3><p>The <code class="function">mallocx</code>(<em class="parameter"><code></code></em>),
+      <code class="constant">NULL</code>, no action occurs.</p></div><div class="refsect2"><a name="idp46144704"></a><h3>Non-standard API</h3><p>The <code class="function">mallocx</code>(<em class="parameter"><code></code></em>),
       <code class="function">rallocx</code>(<em class="parameter"><code></code></em>),
       <code class="function">xallocx</code>(<em class="parameter"><code></code></em>),
       <code class="function">sallocx</code>(<em class="parameter"><code></code></em>),
-      <code class="function">dallocx</code>(<em class="parameter"><code></code></em>), and
+      <code class="function">dallocx</code>(<em class="parameter"><code></code></em>),
+      <code class="function">sdallocx</code>(<em class="parameter"><code></code></em>), and
       <code class="function">nallocx</code>(<em class="parameter"><code></code></em>) functions all have a
       <em class="parameter"><code>flags</code></em> argument that can be used to specify
       options.  The functions only check the options that are contextually
       relevant.  Use bitwise or (<code class="code">|</code>) operations to
       specify one or more of the following:
-        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">MALLOCX_LG_ALIGN(<em class="parameter"><code>la</code></em>)
+        </p><div class="variablelist"><dl class="variablelist"><dt><a name="MALLOCX_LG_ALIGN"></a><span class="term"><code class="constant">MALLOCX_LG_ALIGN(<em class="parameter"><code>la</code></em>)
             </code></span></dt><dd><p>Align the memory allocation to start at an address
             that is a multiple of <code class="code">(1 &lt;&lt;
             <em class="parameter"><code>la</code></em>)</code>.  This macro does not validate
             that <em class="parameter"><code>la</code></em> is within the valid
-            range.</p></dd><dt><span class="term"><code class="constant">MALLOCX_ALIGN(<em class="parameter"><code>a</code></em>)
+            range.</p></dd><dt><a name="MALLOCX_ALIGN"></a><span class="term"><code class="constant">MALLOCX_ALIGN(<em class="parameter"><code>a</code></em>)
             </code></span></dt><dd><p>Align the memory allocation to start at an address
             that is a multiple of <em class="parameter"><code>a</code></em>, where
             <em class="parameter"><code>a</code></em> is a power of two.  This macro does not
             validate that <em class="parameter"><code>a</code></em> is a power of 2.
-            </p></dd><dt><span class="term"><code class="constant">MALLOCX_ZERO</code></span></dt><dd><p>Initialize newly allocated memory to contain zero
+            </p></dd><dt><a name="MALLOCX_ZERO"></a><span class="term"><code class="constant">MALLOCX_ZERO</code></span></dt><dd><p>Initialize newly allocated memory to contain zero
             bytes.  In the growing reallocation case, the real size prior to
             reallocation defines the boundary between untouched bytes and those
             that are initialized to contain zero bytes.  If this macro is
-            absent, newly allocated memory is uninitialized.</p></dd><dt><span class="term"><code class="constant">MALLOCX_ARENA(<em class="parameter"><code>a</code></em>)
+            absent, newly allocated memory is uninitialized.</p></dd><dt><a name="MALLOCX_TCACHE"></a><span class="term"><code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)
+            </code></span></dt><dd><p>Use the thread-specific cache (tcache) specified by
+            the identifier <em class="parameter"><code>tc</code></em>, which must have been
+            acquired via the <a class="link" href="#tcache.create">
+    "<code class="mallctl">tcache.create</code>"
+  </a>
+            mallctl.  This macro does not validate that
+            <em class="parameter"><code>tc</code></em> specifies a valid
+            identifier.</p></dd><dt><a name="MALLOC_TCACHE_NONE"></a><span class="term"><code class="constant">MALLOCX_TCACHE_NONE</code></span></dt><dd><p>Do not use a thread-specific cache (tcache).  Unless
+            <code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code> or
+            <code class="constant">MALLOCX_TCACHE_NONE</code> is specified, an
+            automatically managed tcache will be used under many circumstances.
+            This macro cannot be used in the same <em class="parameter"><code>flags</code></em>
+            argument as
+            <code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code>.</p></dd><dt><a name="MALLOCX_ARENA"></a><span class="term"><code class="constant">MALLOCX_ARENA(<em class="parameter"><code>a</code></em>)
             </code></span></dt><dd><p>Use the arena specified by the index
-            <em class="parameter"><code>a</code></em> (and by necessity bypass the thread
-            cache).  This macro has no effect for huge regions, nor for regions
-            that were allocated via an arena other than the one specified.
-            This macro does not validate that <em class="parameter"><code>a</code></em>
-            specifies an arena index in the valid range.</p></dd></dl></div><p>
+            <em class="parameter"><code>a</code></em>.  This macro has no effect for regions that
+            were allocated via an arena other than the one specified.  This
+            macro does not validate that <em class="parameter"><code>a</code></em> specifies an
+            arena index in the valid range.</p></dd></dl></div><p>
       </p><p>The <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) function allocates at
       least <em class="parameter"><code>size</code></em> bytes of memory, and returns a pointer
       to the base address of the allocation.  Behavior is undefined if
       <em class="parameter"><code>size</code></em> is <code class="constant">0</code>, or if request size
       overflows due to size class and/or alignment constraints.</p><p>The <code class="function">rallocx</code>(<em class="parameter"><code></code></em>) function resizes the
       allocation at <em class="parameter"><code>ptr</code></em> to be at least
@@ -88,13 +101,20 @@
       the extra byte(s) will not by itself result in failure to resize.
       Behavior is undefined if <em class="parameter"><code>size</code></em> is
       <code class="constant">0</code>, or if <code class="code">(<em class="parameter"><code>size</code></em> + <em class="parameter"><code>extra</code></em>
       &gt; <code class="constant">SIZE_T_MAX</code>)</code>.</p><p>The <code class="function">sallocx</code>(<em class="parameter"><code></code></em>) function returns the
       real size of the allocation at <em class="parameter"><code>ptr</code></em>.</p><p>The <code class="function">dallocx</code>(<em class="parameter"><code></code></em>) function causes the
       memory referenced by <em class="parameter"><code>ptr</code></em> to be made available for
-      future allocations.</p><p>The <code class="function">nallocx</code>(<em class="parameter"><code></code></em>) function allocates no
+      future allocations.</p><p>The <code class="function">sdallocx</code>(<em class="parameter"><code></code></em>) function is an
+      extension of <code class="function">dallocx</code>(<em class="parameter"><code></code></em>) with a
+      <em class="parameter"><code>size</code></em> parameter to allow the caller to pass in the
+      allocation size as an optimization.  The minimum valid input size is the
+      original requested size of the allocation, and the maximum valid input
+      size is the corresponding value returned by
+      <code class="function">nallocx</code>(<em class="parameter"><code></code></em>) or
+      <code class="function">sallocx</code>(<em class="parameter"><code></code></em>).</p><p>The <code class="function">nallocx</code>(<em class="parameter"><code></code></em>) function allocates no
       memory, but it performs the same size computation as the
       <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) function, and returns the real
       size of the allocation that would result from the equivalent
       <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) function call.  Behavior is
       undefined if <em class="parameter"><code>size</code></em> is <code class="constant">0</code>, or if
       request size overflows due to size class and/or alignment
@@ -159,95 +179,29 @@
       <code class="function">malloc_message</code>(<em class="parameter"><code></code></em>) uses the
       <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>) functions internally, so
       inconsistent statistics can be reported if multiple threads use these
       functions simultaneously.  If <code class="option">--enable-stats</code> is
       specified during configuration, &#8220;m&#8221; and &#8220;a&#8221; can
       be specified to omit merged arena and per arena statistics, respectively;
-      &#8220;b&#8221; and &#8220;l&#8221; can be specified to omit per size
-      class statistics for bins and large objects, respectively.  Unrecognized
-      characters are silently ignored.  Note that thread caching may prevent
-      some statistics from being completely up to date, since extra locking
-      would be required to merge counters that track thread cache operations.
+      &#8220;b&#8221;, &#8220;l&#8221;, and &#8220;h&#8221; can be specified to
+      omit per size class statistics for bins, large objects, and huge objects,
+      respectively.  Unrecognized characters are silently ignored.  Note that
+      thread caching may prevent some statistics from being completely up to
+      date, since extra locking would be required to merge counters that track
+      thread cache operations.
       </p><p>The <code class="function">malloc_usable_size</code>(<em class="parameter"><code></code></em>) function
       returns the usable size of the allocation pointed to by
       <em class="parameter"><code>ptr</code></em>.  The return value may be larger than the size
       that was requested during allocation.  The
       <code class="function">malloc_usable_size</code>(<em class="parameter"><code></code></em>) function is not a
       mechanism for in-place <code class="function">realloc</code>(<em class="parameter"><code></code></em>); rather
       it is provided solely as a tool for introspection purposes.  Any
       discrepancy between the requested allocation size and the size reported
       by <code class="function">malloc_usable_size</code>(<em class="parameter"><code></code></em>) should not be
       depended on, since such behavior is entirely implementation-dependent.
-      </p></div><div class="refsect2"><a name="idm316388574208"></a><h3>Experimental API</h3><p>The experimental API is subject to change or removal without regard
-      for backward compatibility.  If <code class="option">--disable-experimental</code>
-      is specified during configuration, the experimental API is
-      omitted.</p><p>The <code class="function">allocm</code>(<em class="parameter"><code></code></em>),
-      <code class="function">rallocm</code>(<em class="parameter"><code></code></em>),
-      <code class="function">sallocm</code>(<em class="parameter"><code></code></em>),
-      <code class="function">dallocm</code>(<em class="parameter"><code></code></em>), and
-      <code class="function">nallocm</code>(<em class="parameter"><code></code></em>) functions all have a
-      <em class="parameter"><code>flags</code></em> argument that can be used to specify
-      options.  The functions only check the options that are contextually
-      relevant.  Use bitwise or (<code class="code">|</code>) operations to
-      specify one or more of the following:
-        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="constant">ALLOCM_LG_ALIGN(<em class="parameter"><code>la</code></em>)
-            </code></span></dt><dd><p>Align the memory allocation to start at an address
-            that is a multiple of <code class="code">(1 &lt;&lt;
-            <em class="parameter"><code>la</code></em>)</code>.  This macro does not validate
-            that <em class="parameter"><code>la</code></em> is within the valid
-            range.</p></dd><dt><span class="term"><code class="constant">ALLOCM_ALIGN(<em class="parameter"><code>a</code></em>)
-            </code></span></dt><dd><p>Align the memory allocation to start at an address
-            that is a multiple of <em class="parameter"><code>a</code></em>, where
-            <em class="parameter"><code>a</code></em> is a power of two.  This macro does not
-            validate that <em class="parameter"><code>a</code></em> is a power of 2.
-            </p></dd><dt><span class="term"><code class="constant">ALLOCM_ZERO</code></span></dt><dd><p>Initialize newly allocated memory to contain zero
-            bytes.  In the growing reallocation case, the real size prior to
-            reallocation defines the boundary between untouched bytes and those
-            that are initialized to contain zero bytes.  If this macro is
-            absent, newly allocated memory is uninitialized.</p></dd><dt><span class="term"><code class="constant">ALLOCM_NO_MOVE</code></span></dt><dd><p>For reallocation, fail rather than moving the
-            object.  This constraint can apply to both growth and
-            shrinkage.</p></dd><dt><span class="term"><code class="constant">ALLOCM_ARENA(<em class="parameter"><code>a</code></em>)
-            </code></span></dt><dd><p>Use the arena specified by the index
-            <em class="parameter"><code>a</code></em> (and by necessity bypass the thread
-            cache).  This macro has no effect for huge regions, nor for regions
-            that were allocated via an arena other than the one specified.
-            This macro does not validate that <em class="parameter"><code>a</code></em>
-            specifies an arena index in the valid range.</p></dd></dl></div><p>
-      </p><p>The <code class="function">allocm</code>(<em class="parameter"><code></code></em>) function allocates at
-      least <em class="parameter"><code>size</code></em> bytes of memory, sets
-      <em class="parameter"><code>*ptr</code></em> to the base address of the allocation, and
-      sets <em class="parameter"><code>*rsize</code></em> to the real size of the allocation if
-      <em class="parameter"><code>rsize</code></em> is not <code class="constant">NULL</code>.  Behavior
-      is undefined if <em class="parameter"><code>size</code></em> is <code class="constant">0</code>, or
-      if request size overflows due to size class and/or alignment
-      constraints.</p><p>The <code class="function">rallocm</code>(<em class="parameter"><code></code></em>) function resizes the
-      allocation at <em class="parameter"><code>*ptr</code></em> to be at least
-      <em class="parameter"><code>size</code></em> bytes, sets <em class="parameter"><code>*ptr</code></em> to
-      the base address of the allocation if it moved, and sets
-      <em class="parameter"><code>*rsize</code></em> to the real size of the allocation if
-      <em class="parameter"><code>rsize</code></em> is not <code class="constant">NULL</code>.  If
-      <em class="parameter"><code>extra</code></em> is non-zero, an attempt is made to resize
-      the allocation to be at least <code class="code">(<em class="parameter"><code>size</code></em> +
-      <em class="parameter"><code>extra</code></em>)</code> bytes, though inability to allocate
-      the extra byte(s) will not by itself result in failure.  Behavior is
-      undefined if <em class="parameter"><code>size</code></em> is <code class="constant">0</code>, if
-      request size overflows due to size class and/or alignment constraints, or
-      if <code class="code">(<em class="parameter"><code>size</code></em> +
-      <em class="parameter"><code>extra</code></em> &gt;
-      <code class="constant">SIZE_T_MAX</code>)</code>.</p><p>The <code class="function">sallocm</code>(<em class="parameter"><code></code></em>) function sets
-      <em class="parameter"><code>*rsize</code></em> to the real size of the allocation.</p><p>The <code class="function">dallocm</code>(<em class="parameter"><code></code></em>) function causes the
-      memory referenced by <em class="parameter"><code>ptr</code></em> to be made available for
-      future allocations.</p><p>The <code class="function">nallocm</code>(<em class="parameter"><code></code></em>) function allocates no
-      memory, but it performs the same size computation as the
-      <code class="function">allocm</code>(<em class="parameter"><code></code></em>) function, and if
-      <em class="parameter"><code>rsize</code></em> is not <code class="constant">NULL</code> it sets
-      <em class="parameter"><code>*rsize</code></em> to the real size of the allocation that
-      would result from the equivalent <code class="function">allocm</code>(<em class="parameter"><code></code></em>)
-      function call.  Behavior is undefined if <em class="parameter"><code>size</code></em> is
-      <code class="constant">0</code>, or if request size overflows due to size class
-      and/or alignment constraints.</p></div></div><div class="refsect1"><a name="tuning"></a><h2>TUNING</h2><p>Once, when the first call is made to one of the memory allocation
+      </p></div></div><div class="refsect1"><a name="tuning"></a><h2>TUNING</h2><p>Once, when the first call is made to one of the memory allocation
     routines, the allocator initializes its internals based in part on various
     options that can be specified at compile- or run-time.</p><p>The string pointed to by the global variable
     <code class="varname">malloc_conf</code>, the &#8220;name&#8221; of the file
     referenced by the symbolic link named <code class="filename">/etc/malloc.conf</code>, and the value of the
     environment variable <code class="envar">MALLOC_CONF</code>, will be interpreted, in
     that order, from left to right as options.  Note that
@@ -269,14 +223,15 @@
     options have boolean values (true/false), others have integer values (base
     8, 10, or 16, depending on prefix), and yet others have raw string
     values.</p></div><div class="refsect1"><a name="implementation_notes"></a><h2>IMPLEMENTATION NOTES</h2><p>Traditionally, allocators have used
     <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> to obtain memory, which is
     suboptimal for several reasons, including race conditions, increased
     fragmentation, and artificial limitations on maximum usable memory.  If
-    <code class="option">--enable-dss</code> is specified during configuration, this
-    allocator uses both <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> and
+    <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> is supported by the operating
+    system, this allocator uses both
+    <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> and
     <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>, in that order of preference;
     otherwise only <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> is used.</p><p>This allocator uses multiple arenas in order to reduce lock
     contention for threaded programs on multi-processor systems.  This works
     well with regard to threading scalability, but incurs some costs.  There is
     a small fixed per-arena overhead, and additionally, arenas manage memory
     completely independently of each other, which means a small fixed increase
@@ -292,40 +247,58 @@
     allocation requests.  Such caching allows very fast allocation in the
     common case, but it increases memory usage and fragmentation, since a
     bounded number of objects can remain allocated in each thread cache.</p><p>Memory is conceptually broken into equal-sized chunks, where the
     chunk size is a power of two that is greater than the page size.  Chunks
     are always aligned to multiples of the chunk size.  This alignment makes it
     possible to find metadata for user objects very quickly.</p><p>User objects are broken into three categories according to size:
-    small, large, and huge.  Small objects are smaller than one page.  Large
-    objects are smaller than the chunk size.  Huge objects are a multiple of
-    the chunk size.  Small and large objects are managed by arenas; huge
-    objects are managed separately in a single data structure that is shared by
-    all threads.  Huge objects are used by applications infrequently enough
-    that this single data structure is not a scalability issue.</p><p>Each chunk that is managed by an arena tracks its contents as runs of
+    small, large, and huge.  Small and large objects are managed entirely by
+    arenas; huge objects are additionally aggregated in a single data structure
+    that is shared by all threads.  Huge objects are typically used by
+    applications infrequently enough that this single data structure is not a
+    scalability issue.</p><p>Each chunk that is managed by an arena tracks its contents as runs of
     contiguous pages (unused, backing a set of small objects, or backing one
     large object).  The combination of chunk alignment and chunk page maps
     makes it possible to determine all metadata regarding small and large
     allocations in constant time.</p><p>Small objects are managed in groups by page runs.  Each run maintains
-    a frontier and free list to track which regions are in use.  Allocation
-    requests that are no more than half the quantum (8 or 16, depending on
-    architecture) are rounded up to the nearest power of two that is at least
-    <code class="code">sizeof(<span class="type">double</span>)</code>.  All other small
-    object size classes are multiples of the quantum, spaced such that internal
-    fragmentation is limited to approximately 25% for all but the smallest size
-    classes.  Allocation requests that are larger than the maximum small size
-    class, but small enough to fit in an arena-managed chunk (see the <a class="link" href="#opt.lg_chunk">
+    a bitmap to track which regions are in use.  Allocation requests that are no
+    more than half the quantum (8 or 16, depending on architecture) are rounded
+    up to the nearest power of two that is at least <code class="code">sizeof(<span class="type">double</span>)</code>.  All other object size
+    classes are multiples of the quantum, spaced such that there are four size
+    classes for each doubling in size, which limits internal fragmentation to
+    approximately 20% for all but the smallest size classes.  Small size classes
+    are smaller than four times the page size, large size classes are smaller
+    than the chunk size (see the <a class="link" href="#opt.lg_chunk">
     "<code class="mallctl">opt.lg_chunk</code>"
-  </a> option), are
-    rounded up to the nearest run size.  Allocation requests that are too large
-    to fit in an arena-managed chunk are rounded up to the nearest multiple of
-    the chunk size.</p><p>Allocations are packed tightly together, which can be an issue for
+  </a> option), and
+    huge size classes extend from the chunk size up to one size class less than
+    the full address space size.</p><p>Allocations are packed tightly together, which can be an issue for
     multi-threaded applications.  If you need to assure that allocations do not
     suffer from cacheline sharing, round your allocation requests up to the
     nearest multiple of the cacheline size, or specify cacheline alignment when
-    allocating.</p><p>Assuming 4 MiB chunks, 4 KiB pages, and a 16-byte quantum on a 64-bit
-    system, the size classes in each category are as shown in <a class="xref" href="#size_classes" title="Table1.Size classes">Table 1</a>.</p><div class="table"><a name="size_classes"></a><p class="title"><b>Table1.Size classes</b></p><div class="table-contents"><table summary="Size classes" border="1"><colgroup><col align="left" class="c1"><col align="right" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Category</th><th align="right">Spacing</th><th align="left">Size</th></tr></thead><tbody><tr><td rowspan="7" align="left">Small</td><td align="right">lg</td><td align="left">[8]</td></tr><tr><td align="right">16</td><td align="left">[16, 32, 48, ..., 128]</td></tr><tr><td align="right">32</td><td align="left">[160, 192, 224, 256]</td></tr><tr><td align="right">64</td><td align="left">[320, 384, 448, 512]</td></tr><tr><td align="right">128</td><td align="left">[640, 768, 896, 1024]</td></tr><tr><td align="right">256</td><td align="left">[1280, 1536, 1792, 2048]</td></tr><tr><td align="right">512</td><td align="left">[2560, 3072, 3584]</td></tr><tr><td align="left">Large</td><td align="right">4 KiB</td><td align="left">[4 KiB, 8 KiB, 12 KiB, ..., 4072 KiB]</td></tr><tr><td align="left">Huge</td><td align="right">4 MiB</td><td align="left">[4 MiB, 8 MiB, 12 MiB, ...]</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="mallctl_namespace"></a><h2>MALLCTL NAMESPACE</h2><p>The following names are defined in the namespace accessible via the
+    allocating.</p><p>The <code class="function">realloc</code>(<em class="parameter"><code></code></em>),
+    <code class="function">rallocx</code>(<em class="parameter"><code></code></em>), and
+    <code class="function">xallocx</code>(<em class="parameter"><code></code></em>) functions may resize allocations
+    without moving them under limited circumstances.  Unlike the
+    <code class="function">*allocx</code>(<em class="parameter"><code></code></em>) API, the standard API does not
+    officially round up the usable size of an allocation to the nearest size
+    class, so technically it is necessary to call
+    <code class="function">realloc</code>(<em class="parameter"><code></code></em>) to grow e.g. a 9-byte allocation to
+    16 bytes, or shrink a 16-byte allocation to 9 bytes.  Growth and shrinkage
+    trivially succeeds in place as long as the pre-size and post-size both round
+    up to the same size class.  No other API guarantees are made regarding
+    in-place resizing, but the current implementation also tries to resize large
+    and huge allocations in place, as long as the pre-size and post-size are
+    both large or both huge.  In such cases shrinkage always succeeds for large
+    size classes, but for huge size classes the chunk allocator must support
+    splitting (see <a class="link" href="#arena.i.chunk_hooks">
+    "<code class="mallctl">arena.&lt;i&gt;.chunk_hooks</code>"
+  </a>).
+    Growth only succeeds if the trailing memory is currently available, and
+    additionally for huge size classes the chunk allocator must support
+    merging.</p><p>Assuming 2 MiB chunks, 4 KiB pages, and a 16-byte quantum on a
+    64-bit system, the size classes in each category are as shown in <a class="xref" href="#size_classes" title="Table1.Size classes">Table 1</a>.</p><div class="table"><a name="size_classes"></a><p class="title"><b>Table1.Size classes</b></p><div class="table-contents"><table summary="Size classes" border="1"><colgroup><col align="left" class="c1"><col align="right" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Category</th><th align="right">Spacing</th><th align="left">Size</th></tr></thead><tbody><tr><td rowspan="9" align="left">Small</td><td align="right">lg</td><td align="left">[8]</td></tr><tr><td align="right">16</td><td align="left">[16, 32, 48, 64, 80, 96, 112, 128]</td></tr><tr><td align="right">32</td><td align="left">[160, 192, 224, 256]</td></tr><tr><td align="right">64</td><td align="left">[320, 384, 448, 512]</td></tr><tr><td align="right">128</td><td align="left">[640, 768, 896, 1024]</td></tr><tr><td align="right">256</td><td align="left">[1280, 1536, 1792, 2048]</td></tr><tr><td align="right">512</td><td align="left">[2560, 3072, 3584, 4096]</td></tr><tr><td align="right">1 KiB</td><td align="left">[5 KiB, 6 KiB, 7 KiB, 8 KiB]</td></tr><tr><td align="right">2 KiB</td><td align="left">[10 KiB, 12 KiB, 14 KiB]</td></tr><tr><td rowspan="8" align="left">Large</td><td align="right">2 KiB</td><td align="left">[16 KiB]</td></tr><tr><td align="right">4 KiB</td><td align="left">[20 KiB, 24 KiB, 28 KiB, 32 KiB]</td></tr><tr><td align="right">8 KiB</td><td align="left">[40 KiB, 48 KiB, 54 KiB, 64 KiB]</td></tr><tr><td align="right">16 KiB</td><td align="left">[80 KiB, 96 KiB, 112 KiB, 128 KiB]</td></tr><tr><td align="right">32 KiB</td><td align="left">[160 KiB, 192 KiB, 224 KiB, 256 KiB]</td></tr><tr><td align="right">64 KiB</td><td align="left">[320 KiB, 384 KiB, 448 KiB, 512 KiB]</td></tr><tr><td align="right">128 KiB</td><td align="left">[640 KiB, 768 KiB, 896 KiB, 1 MiB]</td></tr><tr><td align="right">256 KiB</td><td align="left">[1280 KiB, 1536 KiB, 1792 KiB]</td></tr><tr><td rowspan="7" align="left">Huge</td><td align="right">256 KiB</td><td align="left">[2 MiB]</td></tr><tr><td align="right">512 KiB</td><td align="left">[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]</td></tr><tr><td align="right">1 MiB</td><td align="left">[5 MiB, 6 MiB, 7 MiB, 8 MiB]</td></tr><tr><td align="right">2 MiB</td><td align="left">[10 MiB, 12 MiB, 14 MiB, 16 MiB]</td></tr><tr><td align="right">4 MiB</td><td align="left">[20 MiB, 24 MiB, 28 MiB, 32 MiB]</td></tr><tr><td align="right">8 MiB</td><td align="left">[40 MiB, 48 MiB, 56 MiB, 64 MiB]</td></tr><tr><td align="right">...</td><td align="left">...</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="mallctl_namespace"></a><h2>MALLCTL NAMESPACE</h2><p>The following names are defined in the namespace accessible via the
     <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>) functions.  Value types are
     specified in parentheses, their readable/writable statuses are encoded as
     <code class="literal">rw</code>, <code class="literal">r-</code>, <code class="literal">-w</code>, or
     <code class="literal">--</code>, and required build configuration flags follow, if
     any.  A name element encoded as <code class="literal">&lt;i&gt;</code> or
     <code class="literal">&lt;j&gt;</code> indicates an integer component, where the
@@ -352,26 +325,26 @@
   
           (<span class="type">uint64_t</span>)
           <code class="literal">rw</code>
         </span></dt><dd><p>If a value is passed in, refresh the data from which
         the <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>) functions report values,
         and increment the epoch.  Return the current epoch.  This is useful for
-        detecting whether another thread caused a refresh.</p></dd><dt><a name="config.debug"></a><span class="term">
+        detecting whether another thread caused a refresh.</p></dd><dt><a name="config.cache_oblivious"></a><span class="term">
           
-    "<code class="mallctl">config.debug</code>"
+    "<code class="mallctl">config.cache_oblivious</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p><code class="option">--enable-debug</code> was specified during
-        build configuration.</p></dd><dt><a name="config.dss"></a><span class="term">
+        </span></dt><dd><p><code class="option">--enable-cache-oblivious</code> was specified
+        during build configuration.</p></dd><dt><a name="config.debug"></a><span class="term">
           
-    "<code class="mallctl">config.dss</code>"
+    "<code class="mallctl">config.debug</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p><code class="option">--enable-dss</code> was specified during
+        </span></dt><dd><p><code class="option">--enable-debug</code> was specified during
         build configuration.</p></dd><dt><a name="config.fill"></a><span class="term">
           
     "<code class="mallctl">config.fill</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
@@ -380,20 +353,13 @@
           
     "<code class="mallctl">config.lazy_lock</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-lazy-lock</code> was specified
-        during build configuration.</p></dd><dt><a name="config.mremap"></a><span class="term">
-          
-    "<code class="mallctl">config.mremap</code>"
-  
-          (<span class="type">bool</span>)
-          <code class="literal">r-</code>
-        </span></dt><dd><p><code class="option">--enable-mremap</code> was specified during
-        build configuration.</p></dd><dt><a name="config.munmap"></a><span class="term">
+        during build configuration.</p></dd><dt><a name="config.munmap"></a><span class="term">
           
     "<code class="mallctl">config.munmap</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-munmap</code> was specified during
@@ -476,28 +442,29 @@
     "<code class="mallctl">opt.dss</code>"
   
           (<span class="type">const char *</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>dss (<span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>) allocation precedence as
         related to <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> allocation.  The following
-        settings are supported: &#8220;disabled&#8221;, &#8220;primary&#8221;,
-        and &#8220;secondary&#8221;.  The default is &#8220;secondary&#8221; if
-        <a class="link" href="#config.dss">
-    "<code class="mallctl">config.dss</code>"
-  </a> is
-        true, &#8220;disabled&#8221; otherwise.
+        settings are supported if
+        <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> is supported by the operating
+        system: &#8220;disabled&#8221;, &#8220;primary&#8221;, and
+        &#8220;secondary&#8221;; otherwise only &#8220;disabled&#8221; is
+        supported.  The default is &#8220;secondary&#8221; if
+        <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> is supported by the operating
+        system; &#8220;disabled&#8221; otherwise.
         </p></dd><dt><a name="opt.lg_chunk"></a><span class="term">
           
     "<code class="mallctl">opt.lg_chunk</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Virtual memory chunk size (log base 2).  If a chunk
         size outside the supported size range is specified, the size is
         silently clipped to the minimum/maximum supported size.  The default
-        chunk size is 4 MiB (2^22).
+        chunk size is 2 MiB (2^21).
         </p></dd><dt><a name="opt.narenas"></a><span class="term">
           
     "<code class="mallctl">opt.narenas</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
@@ -514,42 +481,56 @@
         the limit set by the ratio (or one chunk worth of dirty pages,
         whichever is greater), before informing the kernel about some of those
         pages via <span class="citerefentry"><span class="refentrytitle">madvise</span>(2)</span> or a similar system call.  This
         provides the kernel with sufficient information to recycle dirty pages
         if physical memory becomes scarce and the pages remain unused.  The
         default minimum ratio is 8:1 (2^3:1); an option value of -1 will
-        disable dirty page purging.</p></dd><dt><a name="opt.stats_print"></a><span class="term">
+        disable dirty page purging.  See <a class="link" href="#arenas.lg_dirty_mult">
+    "<code class="mallctl">arenas.lg_dirty_mult</code>"
+  </a>
+        and <a class="link" href="#arena.i.lg_dirty_mult">
+    "<code class="mallctl">arena.&lt;i&gt;.lg_dirty_mult</code>"
+  </a>
+        for related dynamic control options.</p></dd><dt><a name="opt.stats_print"></a><span class="term">
           
     "<code class="mallctl">opt.stats_print</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Enable/disable statistics printing at exit.  If
         enabled, the <code class="function">malloc_stats_print</code>(<em class="parameter"><code></code></em>)
         function is called at program exit via an
         <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span> function.  If
         <code class="option">--enable-stats</code> is specified during configuration, this
         has the potential to cause deadlock for a multi-threaded process that
         exits while one or more threads are executing in the memory allocation
-        functions.  Therefore, this option should only be used with care; it is
-        primarily intended as a performance tuning aid during application
+        functions.  Furthermore, <code class="function">atexit</code>(<em class="parameter"><code></code></em>) may
+        allocate memory during application initialization and then deadlock
+        internally when jemalloc in turn calls
+        <code class="function">atexit</code>(<em class="parameter"><code></code></em>), so this option is not
+        univerally usable (though the application can register its own
+        <code class="function">atexit</code>(<em class="parameter"><code></code></em>) function with equivalent
+        functionality).  Therefore, this option should only be used with care;
+        it is primarily intended as a performance tuning aid during application
         development.  This option is disabled by default.</p></dd><dt><a name="opt.junk"></a><span class="term">
           
     "<code class="mallctl">opt.junk</code>"
   
-          (<span class="type">bool</span>)
+          (<span class="type">const char *</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-fill</code>]
-        </span></dt><dd><p>Junk filling enabled/disabled.  If enabled, each byte
-        of uninitialized allocated memory will be initialized to
-        <code class="literal">0xa5</code>.  All deallocated memory will be initialized to
-        <code class="literal">0x5a</code>.  This is intended for debugging and will
-        impact performance negatively.  This option is disabled by default
-        unless <code class="option">--enable-debug</code> is specified during
-        configuration, in which case it is enabled by default unless running
-        inside <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>.</p></dd><dt><a name="opt.quarantine"></a><span class="term">
+        </span></dt><dd><p>Junk filling.  If set to "alloc", each byte of
+        uninitialized allocated memory will be initialized to
+        <code class="literal">0xa5</code>.  If set to "free", all deallocated memory will
+        be initialized to <code class="literal">0x5a</code>.  If set to "true", both
+        allocated and deallocated memory will be initialized, and if set to
+        "false", junk filling be disabled entirely.  This is intended for
+        debugging and will impact performance negatively.  This option is
+        "false" by default unless <code class="option">--enable-debug</code> is specified
+        during configuration, in which case it is "true" by default unless
+        running inside <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>.</p></dd><dt><a name="opt.quarantine"></a><span class="term">
           
     "<code class="mallctl">opt.quarantine</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-fill</code>]
@@ -589,37 +570,26 @@
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-fill</code>]
         </span></dt><dd><p>Zero filling enabled/disabled.  If enabled, each byte
         of uninitialized allocated memory will be initialized to 0.  Note that
         this initialization only happens once for each byte, so
-        <code class="function">realloc</code>(<em class="parameter"><code></code></em>),
-        <code class="function">rallocx</code>(<em class="parameter"><code></code></em>) and
-        <code class="function">rallocm</code>(<em class="parameter"><code></code></em>) calls do not zero memory that
+        <code class="function">realloc</code>(<em class="parameter"><code></code></em>) and
+        <code class="function">rallocx</code>(<em class="parameter"><code></code></em>) calls do not zero memory that
         was previously allocated.  This is intended for debugging and will
         impact performance negatively.  This option is disabled by default.
         </p></dd><dt><a name="opt.utrace"></a><span class="term">
           
     "<code class="mallctl">opt.utrace</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-utrace</code>]
         </span></dt><dd><p>Allocation tracing based on
         <span class="citerefentry"><span class="refentrytitle">utrace</span>(2)</span> enabled/disabled.  This option
-        is disabled by default.</p></dd><dt><a name="opt.valgrind"></a><span class="term">
-          
-    "<code class="mallctl">opt.valgrind</code>"
-  
-          (<span class="type">bool</span>)
-          <code class="literal">r-</code>
-          [<code class="option">--enable-valgrind</code>]
-        </span></dt><dd><p><a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>
-        support enabled/disabled.  This option is vestigal because jemalloc
-        auto-detects whether it is running inside Valgrind.  This option is
-        disabled by default, unless running inside Valgrind.</p></dd><dt><a name="opt.xmalloc"></a><span class="term">
+        is disabled by default.</p></dd><dt><a name="opt.xmalloc"></a><span class="term">
           
     "<code class="mallctl">opt.xmalloc</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-xmalloc</code>]
@@ -636,31 +606,31 @@
           
     "<code class="mallctl">opt.tcache</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-tcache</code>]
-        </span></dt><dd><p>Thread-specific caching enabled/disabled.  When there
-        are multiple threads, each thread uses a thread-specific cache for
-        objects up to a certain size.  Thread-specific caching allows many
-        allocations to be satisfied without performing any thread
-        synchronization, at the cost of increased memory use.  See the
-        <a class="link" href="#opt.lg_tcache_max">
+        </span></dt><dd><p>Thread-specific caching (tcache) enabled/disabled.  When
+        there are multiple threads, each thread uses a tcache for objects up to
+        a certain size.  Thread-specific caching allows many allocations to be
+        satisfied without performing any thread synchronization, at the cost of
+        increased memory use.  See the <a class="link" href="#opt.lg_tcache_max">
     "<code class="mallctl">opt.lg_tcache_max</code>"
   </a>
         option for related tuning information.  This option is enabled by
-        default unless running inside <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>.</p></dd><dt><a name="opt.lg_tcache_max"></a><span class="term">
+        default unless running inside <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>, in which case it is
+        forcefully disabled.</p></dd><dt><a name="opt.lg_tcache_max"></a><span class="term">
           
     "<code class="mallctl">opt.lg_tcache_max</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Maximum size class (log base 2) to cache in the
-        thread-specific cache.  At a minimum, all small size classes are
-        cached, and at a maximum all large size classes are cached.  The
+        thread-specific cache (tcache).  At a minimum, all small size classes
+        are cached, and at a maximum all large size classes are cached.  The
         default maximum is 32 KiB (2^15).</p></dd><dt><a name="opt.prof"></a><span class="term">
           
     "<code class="mallctl">opt.prof</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
@@ -683,14 +653,14 @@
   </a>
         option for information on high-water-triggered profile dumping, and the
         <a class="link" href="#opt.prof_final">
     "<code class="mallctl">opt.prof_final</code>"
   </a>
         option for final profile dumping.  Profile output is compatible with
-        the included <span class="command"><strong>pprof</strong></span> Perl script, which originates
-        from the <a class="ulink" href="http://code.google.com/p/gperftools/" target="_top">gperftools
+        the <span class="command"><strong>jeprof</strong></span> command, which is based on the
+        <span class="command"><strong>pprof</strong></span> that is developed as part of the <a class="ulink" href="http://code.google.com/p/gperftools/" target="_top">gperftools
         package</a>.</p></dd><dt><a name="opt.prof_prefix"></a><span class="term">
           
     "<code class="mallctl">opt.prof_prefix</code>"
   
           (<span class="type">const char *</span>)
           <code class="literal">r-</code>
@@ -701,28 +671,42 @@
         also disables leak reporting, if enabled).  The default prefix is
         <code class="filename">jeprof</code>.</p></dd><dt><a name="opt.prof_active"></a><span class="term">
           
     "<code class="mallctl">opt.prof_active</code>"
   
           (<span class="type">bool</span>)
-          <code class="literal">rw</code>
+          <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Profiling activated/deactivated.  This is a secondary
         control mechanism that makes it possible to start the application with
         profiling enabled (see the <a class="link" href="#opt.prof">
     "<code class="mallctl">opt.prof</code>"
   </a> option) but
         inactive, then toggle profiling at any time during program execution
         with the <a class="link" href="#prof.active">
     "<code class="mallctl">prof.active</code>"
   </a> mallctl.
-        This option is enabled by default.</p></dd><dt><a name="opt.lg_prof_sample"></a><span class="term">
+        This option is enabled by default.</p></dd><dt><a name="opt.prof_thread_active_init"></a><span class="term">
+          
+    "<code class="mallctl">opt.prof_thread_active_init</code>"
+  
+          (<span class="type">bool</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-prof</code>]
+        </span></dt><dd><p>Initial setting for <a class="link" href="#thread.prof.active">
+    "<code class="mallctl">thread.prof.active</code>"
+  </a>
+        in newly created threads.  The initial setting for newly created threads
+        can also be changed during execution via the <a class="link" href="#prof.thread_active_init">
+    "<code class="mallctl">prof.thread_active_init</code>"
+  </a>
+        mallctl.  This option is enabled by default.</p></dd><dt><a name="opt.lg_prof_sample"></a><span class="term">
           
     "<code class="mallctl">opt.lg_prof_sample</code>"
   
-          (<span class="type">ssize_t</span>)
+          (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Average interval (log base 2) between allocation
         samples, as measured in bytes of allocation activity.  Increasing the
         sampling interval decreases profile fidelity, but also decreases the
         computational overhead.  The default sample interval is 512 KiB (2^19
@@ -761,20 +745,18 @@
           
     "<code class="mallctl">opt.prof_gdump</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
-        </span></dt><dd><p>Trigger a memory profile dump every time the total
-        virtual memory exceeds the previous maximum.  Profiles are dumped to
-        files named according to the pattern
-        <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap</code>,
-        where <code class="literal">&lt;prefix&gt;</code> is controlled by the <a class="link" href="#opt.prof_prefix">
-    "<code class="mallctl">opt.prof_prefix</code>"
-  </a>
-        option.  This option is disabled by default.</p></dd><dt><a name="opt.prof_final"></a><span class="term">
+        </span></dt><dd><p>Set the initial state of <a class="link" href="#prof.gdump">
+    "<code class="mallctl">prof.gdump</code>"
+  </a>, which when
+        enabled triggers a memory profile dump every time the total virtual
+        memory exceeds the previous maximum.  This option is disabled by
+        default.</p></dd><dt><a name="opt.prof_final"></a><span class="term">
           
     "<code class="mallctl">opt.prof_final</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
@@ -782,13 +764,19 @@
         <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span> function to dump final memory
         usage to a file named according to the pattern
         <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap</code>,
         where <code class="literal">&lt;prefix&gt;</code> is controlled by the <a class="link" href="#opt.prof_prefix">
     "<code class="mallctl">opt.prof_prefix</code>"
   </a>
-        option.  This option is enabled by default.</p></dd><dt><a name="opt.prof_leak"></a><span class="term">
+        option.  Note that <code class="function">atexit</code>(<em class="parameter"><code></code></em>) may allocate
+        memory during application initialization and then deadlock internally
+        when jemalloc in turn calls <code class="function">atexit</code>(<em class="parameter"><code></code></em>), so
+        this option is not univerally usable (though the application can
+        register its own <code class="function">atexit</code>(<em class="parameter"><code></code></em>) function with
+        equivalent functionality).  This option is disabled by
+        default.</p></dd><dt><a name="opt.prof_leak"></a><span class="term">
           
     "<code class="mallctl">opt.prof_leak</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
@@ -861,35 +849,100 @@
   
           (<span class="type">bool</span>)
           <code class="literal">rw</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Enable/disable calling thread's tcache.  The tcache is
         implicitly flushed as a side effect of becoming
-        disabled (see 
+        disabled (see <a class="link" href="#thread.tcache.flush">
     "<code class="mallctl">thread.tcache.flush</code>"
-  ).
+  </a>).
         </p></dd><dt><a name="thread.tcache.flush"></a><span class="term">
           
     "<code class="mallctl">thread.tcache.flush</code>"
   
           (<span class="type">void</span>)
           <code class="literal">--</code>
           [<code class="option">--enable-tcache</code>]
-        </span></dt><dd><p>Flush calling thread's tcache.  This interface releases
-        all cached objects and internal data structures associated with the
-        calling thread's thread-specific cache.  Ordinarily, this interface
+        </span></dt><dd><p>Flush calling thread's thread-specific cache (tcache).
+        This interface releases all cached objects and internal data structures
+        associated with the calling thread's tcache.  Ordinarily, this interface
         need not be called, since automatic periodic incremental garbage
         collection occurs, and the thread cache is automatically discarded when
         a thread exits.  However, garbage collection is triggered by allocation
         activity, so it is possible for a thread that stops
         allocating/deallocating to retain its cache indefinitely, in which case
-        the developer may find manual flushing useful.</p></dd><dt><a name="arena.i.purge"></a><span class="term">
+        the developer may find manual flushing useful.</p></dd><dt><a name="thread.prof.name"></a><span class="term">
           
-    "<code class="mallctl">arena.&lt;i&gt;.purge</code>"
+    "<code class="mallctl">thread.prof.name</code>"
+  
+          (<span class="type">const char *</span>)
+          <code class="literal">r-</code> or
+          <code class="literal">-w</code>
+          [<code class="option">--enable-prof</code>]
+        </span></dt><dd><p>Get/set the descriptive name associated with the calling
+        thread in memory profile dumps.  An internal copy of the name string is
+        created, so the input string need not be maintained after this interface
+        completes execution.  The output string of this interface should be
+        copied for non-ephemeral uses, because multiple implementation details
+        can cause asynchronous string deallocation.  Furthermore, each
+        invocation of this interface can only read or write; simultaneous
+        read/write is not supported due to string lifetime limitations.  The
+        name string must nil-terminated and comprised only of characters in the
+        sets recognized
+        by <span class="citerefentry"><span class="refentrytitle">isgraph</span>(3)</span> and
+        <span class="citerefentry"><span class="refentrytitle">isblank</span>(3)</span>.</p></dd><dt><a name="thread.prof.active"></a><span class="term">
+          
+    "<code class="mallctl">thread.prof.active</code>"
+  
+          (<span class="type">bool</span>)
+          <code class="literal">rw</code>
+          [<code class="option">--enable-prof</code>]
+        </span></dt><dd><p>Control whether sampling is currently active for the
+        calling thread.  This is an activation mechanism in addition to <a class="link" href="#prof.active">
+    "<code class="mallctl">prof.active</code>"
+  </a>; both must
+        be active for the calling thread to sample.  This flag is enabled by
+        default.</p></dd><dt><a name="tcache.create"></a><span class="term">
+          
+    "<code class="mallctl">tcache.create</code>"
   
           (<span class="type">unsigned</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-tcache</code>]
+        </span></dt><dd><p>Create an explicit thread-specific cache (tcache) and
+        return an identifier that can be passed to the <a class="link" href="#MALLOCX_TCACHE"><code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code></a>
+        macro to explicitly use the specified cache rather than the
+        automatically managed one that is used by default.  Each explicit cache
+        can be used by only one thread at a time; the application must assure
+        that this constraint holds.
+        </p></dd><dt><a name="tcache.flush"></a><span class="term">
+          
+    "<code class="mallctl">tcache.flush</code>"
+  
+          (<span class="type">unsigned</span>)
+          <code class="literal">-w</code>
+          [<code class="option">--enable-tcache</code>]
+        </span></dt><dd><p>Flush the specified thread-specific cache (tcache).  The
+        same considerations apply to this interface as to <a class="link" href="#thread.tcache.flush">
+    "<code class="mallctl">thread.tcache.flush</code>"
+  </a>,
+        except that the tcache will never be automatically be discarded.
+        </p></dd><dt><a name="tcache.destroy"></a><span class="term">
+          
+    "<code class="mallctl">tcache.destroy</code>"
+  
+          (<span class="type">unsigned</span>)
+          <code class="literal">-w</code>
+          [<code class="option">--enable-tcache</code>]
+        </span></dt><dd><p>Flush the specified thread-specific cache (tcache) and
+        make the identifier available for use during a future tcache creation.
+        </p></dd><dt><a name="arena.i.purge"></a><span class="term">
+          
+    "<code class="mallctl">arena.&lt;i&gt;.purge</code>"
+  
+          (<span class="type">void</span>)
           <code class="literal">--</code>
         </span></dt><dd><p>Purge unused dirty pages for arena &lt;i&gt;, or for
         all arenas if &lt;i&gt; equals <a class="link" href="#arenas.narenas">
     "<code class="mallctl">arenas.narenas</code>"
   </a>.
         </p></dd><dt><a name="arena.i.dss"></a><span class="term">
@@ -899,21 +952,144 @@
           (<span class="type">const char *</span>)
           <code class="literal">rw</code>
         </span></dt><dd><p>Set the precedence of dss allocation as related to mmap
         allocation for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals
         <a class="link" href="#arenas.narenas">
     "<code class="mallctl">arenas.narenas</code>"
-  </a>.  Note
-        that even during huge allocation this setting is read from the arena
-        that would be chosen for small or large allocation so that applications
-        can depend on consistent dss versus mmap allocation regardless of
-        allocation size.  See <a class="link" href="#opt.dss">
+  </a>.  See
+        <a class="link" href="#opt.dss">
     "<code class="mallctl">opt.dss</code>"
   </a> for supported
-        settings.
-        </p></dd><dt><a name="arenas.narenas"></a><span class="term">
+        settings.</p></dd><dt><a name="arena.i.lg_dirty_mult"></a><span class="term">
+          
+    "<code class="mallctl">arena.&lt;i&gt;.lg_dirty_mult</code>"
+  
+          (<span class="type">ssize_t</span>)
+          <code class="literal">rw</code>
+        </span></dt><dd><p>Current per-arena minimum ratio (log base 2) of active
+        to dirty pages for arena &lt;i&gt;.  Each time this interface is set and
+        the ratio is increased, pages are synchronously purged as necessary to
+        impose the new ratio.  See <a class="link" href="#opt.lg_dirty_mult">
+    "<code class="mallctl">opt.lg_dirty_mult</code>"
+  </a>
+        for additional information.</p></dd><dt><a name="arena.i.chunk_hooks"></a><span class="term">
+          
+    "<code class="mallctl">arena.&lt;i&gt;.chunk_hooks</code>"
+  
+          (<span class="type">chunk_hooks_t</span>)
+          <code class="literal">rw</code>
+        </span></dt><dd><p>Get or set the chunk management hook functions for arena
+        &lt;i&gt;.  The functions must be capable of operating on all extant
+        chunks associated with arena &lt;i&gt;, usually by passing unknown
+        chunks to the replaced functions.  In practice, it is feasible to
+        control allocation for arenas created via <a class="link" href="#arenas.extend">
+    "<code class="mallctl">arenas.extend</code>"
+  </a> such
+        that all chunks originate from an application-supplied chunk allocator
+        (by setting custom chunk hook functions just after arena creation), but
+        the automatically created arenas may have already created chunks prior
+        to the application having an opportunity to take over chunk
+        allocation.</p><pre class="programlisting">
+typedef struct {
+	chunk_alloc_t		*alloc;
+	chunk_dalloc_t		*dalloc;
+	chunk_commit_t		*commit;
+	chunk_decommit_t	*decommit;
+	chunk_purge_t		*purge;
+	chunk_split_t		*split;
+	chunk_merge_t		*merge;
+} chunk_hooks_t;</pre><p>The <span class="type">chunk_hooks_t</span> structure comprises function
+        pointers which are described individually below.  jemalloc uses these
+        functions to manage chunk lifetime, which starts off with allocation of
+        mapped committed memory, in the simplest case followed by deallocation.
+        However, there are performance and platform reasons to retain chunks for
+        later reuse.  Cleanup attempts cascade from deallocation to decommit to
+        purging, which gives the chunk management functions opportunities to
+        reject the most permanent cleanup operations in favor of less permanent
+        (and often less costly) operations.  The chunk splitting and merging
+        operations can also be opted out of, but this is mainly intended to
+        support platforms on which virtual memory mappings provided by the
+        operating system kernel do not automatically coalesce and split, e.g.
+        Windows.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef void *<b class="fsfunc">(chunk_alloc_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>bool *<var class="pdparam">zero</var>, </td></tr><tr><td></td><td>bool *<var class="pdparam">commit</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk allocation function conforms to the
+        <span class="type">chunk_alloc_t</span> type and upon success returns a pointer to
+        <em class="parameter"><code>size</code></em> bytes of mapped memory on behalf of arena
+        <em class="parameter"><code>arena_ind</code></em> such that the chunk's base address is a
+        multiple of <em class="parameter"><code>alignment</code></em>, as well as setting
+        <em class="parameter"><code>*zero</code></em> to indicate whether the chunk is zeroed and
+        <em class="parameter"><code>*commit</code></em> to indicate whether the chunk is
+        committed.  Upon error the function returns <code class="constant">NULL</code>
+        and leaves <em class="parameter"><code>*zero</code></em> and
+        <em class="parameter"><code>*commit</code></em> unmodified.  The
+        <em class="parameter"><code>size</code></em> parameter is always a multiple of the chunk
+        size.  The <em class="parameter"><code>alignment</code></em> parameter is always a power
+        of two at least as large as the chunk size.  Zeroing is mandatory if
+        <em class="parameter"><code>*zero</code></em> is true upon function entry.  Committing is
+        mandatory if <em class="parameter"><code>*commit</code></em> is true upon function entry.
+        If <em class="parameter"><code>chunk</code></em> is not <code class="constant">NULL</code>, the
+        returned pointer must be <em class="parameter"><code>chunk</code></em> on success or
+        <code class="constant">NULL</code> on error.  Committed memory may be committed
+        in absolute terms as on a system that does not overcommit, or in
+        implicit terms as on a system that overcommits and satisfies physical
+        memory needs on demand via soft page faults.  Note that replacing the
+        default chunk allocation function makes the arena's <a class="link" href="#arena.i.dss">
+    "<code class="mallctl">arena.&lt;i&gt;.dss</code>"
+  </a>
+        setting irrelevant.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_dalloc_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>
+        A chunk deallocation function conforms to the
+        <span class="type">chunk_dalloc_t</span> type and deallocates a
+        <em class="parameter"><code>chunk</code></em> of given <em class="parameter"><code>size</code></em> with
+        <em class="parameter"><code>committed</code></em>/decommited memory as indicated, on
+        behalf of arena <em class="parameter"><code>arena_ind</code></em>, returning false upon
+        success.  If the function returns true, this indicates opt-out from
+        deallocation; the virtual memory mapping associated with the chunk
+        remains mapped, in the same commit state, and available for future use,
+        in which case it will be automatically retained for later reuse.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_commit_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk commit function conforms to the
+        <span class="type">chunk_commit_t</span> type and commits zeroed physical memory to
+        back pages within a <em class="parameter"><code>chunk</code></em> of given
+        <em class="parameter"><code>size</code></em> at <em class="parameter"><code>offset</code></em> bytes,
+        extending for <em class="parameter"><code>length</code></em> on behalf of arena
+        <em class="parameter"><code>arena_ind</code></em>, returning false upon success.
+        Committed memory may be committed in absolute terms as on a system that
+        does not overcommit, or in implicit terms as on a system that
+        overcommits and satisfies physical memory needs on demand via soft page
+        faults. If the function returns true, this indicates insufficient
+        physical memory to satisfy the request.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_decommit_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk decommit function conforms to the
+        <span class="type">chunk_decommit_t</span> type and decommits any physical memory
+        that is backing pages within a <em class="parameter"><code>chunk</code></em> of given
+        <em class="parameter"><code>size</code></em> at <em class="parameter"><code>offset</code></em> bytes,
+        extending for <em class="parameter"><code>length</code></em> on behalf of arena
+        <em class="parameter"><code>arena_ind</code></em>, returning false upon success, in which
+        case the pages will be committed via the chunk commit function before
+        being reused.  If the function returns true, this indicates opt-out from
+        decommit; the memory remains committed and available for future use, in
+        which case it will be automatically retained for later reuse.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_purge_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t<var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk purge function conforms to the <span class="type">chunk_purge_t</span>
+        type and optionally discards physical pages within the virtual memory
+        mapping associated with <em class="parameter"><code>chunk</code></em> of given
+        <em class="parameter"><code>size</code></em> at <em class="parameter"><code>offset</code></em> bytes,
+        extending for <em class="parameter"><code>length</code></em> on behalf of arena
+        <em class="parameter"><code>arena_ind</code></em>, returning false if pages within the
+        purged virtual memory range will be zero-filled the next time they are
+        accessed.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_split_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_a</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_b</var>, </td></tr><tr><td></td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk split function conforms to the <span class="type">chunk_split_t</span>
+        type and optionally splits <em class="parameter"><code>chunk</code></em> of given
+        <em class="parameter"><code>size</code></em> into two adjacent chunks, the first of
+        <em class="parameter"><code>size_a</code></em> bytes, and the second of
+        <em class="parameter"><code>size_b</code></em> bytes, operating on
+        <em class="parameter"><code>committed</code></em>/decommitted memory as indicated, on
+        behalf of arena <em class="parameter"><code>arena_ind</code></em>, returning false upon
+        success.  If the function returns true, this indicates that the chunk
+        remains unsplit and therefore should continue to be operated on as a
+        whole.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_merge_t)</b>(</code></td><td>void *<var class="pdparam">chunk_a</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_a</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">chunk_b</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_b</var>, </td></tr><tr><td></td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk merge function conforms to the <span class="type">chunk_merge_t</span>
+        type and optionally merges adjacent chunks,
+        <em class="parameter"><code>chunk_a</code></em> of given <em class="parameter"><code>size_a</code></em>
+        and <em class="parameter"><code>chunk_b</code></em> of given
+        <em class="parameter"><code>size_b</code></em> into one contiguous chunk, operating on
+        <em class="parameter"><code>committed</code></em>/decommitted memory as indicated, on
+        behalf of arena <em class="parameter"><code>arena_ind</code></em>, returning false upon
+        success.  If the function returns true, this indicates that the chunks
+        remain distinct mappings and therefore should continue to be operated on
+        independently.</p></dd><dt><a name="arenas.narenas"></a><span class="term">
           
     "<code class="mallctl">arenas.narenas</code>"
   
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Current limit on number of arenas.</p></dd><dt><a name="arenas.initialized"></a><span class="term">
@@ -923,13 +1099,26 @@
           (<span class="type">bool *</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>An array of <a class="link" href="#arenas.narenas">
     "<code class="mallctl">arenas.narenas</code>"
   </a>
         booleans.  Each boolean indicates whether the corresponding arena is
-        initialized.</p></dd><dt><a name="arenas.quantum"></a><span class="term">
+        initialized.</p></dd><dt><a name="arenas.lg_dirty_mult"></a><span class="term">
+          
+    "<code class="mallctl">arenas.lg_dirty_mult</code>"
+  
+          (<span class="type">ssize_t</span>)
+          <code class="literal">rw</code>
+        </span></dt><dd><p>Current default per-arena minimum ratio (log base 2) of
+        active to dirty pages, used to initialize <a class="link" href="#arena.i.lg_dirty_mult">
+    "<code class="mallctl">arena.&lt;i&gt;.lg_dirty_mult</code>"
+  </a>
+        during arena creation.  See <a class="link" href="#opt.lg_dirty_mult">
+    "<code class="mallctl">opt.lg_dirty_mult</code>"
+  </a>
+        for additional information.</p></dd><dt><a name="arenas.quantum"></a><span class="term">
           
     "<code class="mallctl">arenas.quantum</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Quantum size.</p></dd><dt><a name="arenas.page"></a><span class="term">
@@ -978,48 +1167,69 @@
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Number of bytes per page run.</p></dd><dt><a name="arenas.nlruns"></a><span class="term">
           
     "<code class="mallctl">arenas.nlruns</code>"
   
-          (<span class="type">size_t</span>)
+          (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Total number of large size classes.</p></dd><dt><a name="arenas.lrun.i.size"></a><span class="term">
           
     "<code class="mallctl">arenas.lrun.&lt;i&gt;.size</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Maximum size supported by this large size
-        class.</p></dd><dt><a name="arenas.purge"></a><span class="term">
+        class.</p></dd><dt><a name="arenas.nhchunks"></a><span class="term">
           
-    "<code class="mallctl">arenas.purge</code>"
+    "<code class="mallctl">arenas.nhchunks</code>"
   
           (<span class="type">unsigned</span>)
-          <code class="literal">-w</code>
-        </span></dt><dd><p>Purge unused dirty pages for the specified arena, or
-        for all arenas if none is specified.</p></dd><dt><a name="arenas.extend"></a><span class="term">
+          <code class="literal">r-</code>
+        </span></dt><dd><p>Total number of huge size classes.</p></dd><dt><a name="arenas.hchunk.i.size"></a><span class="term">
+          
+    "<code class="mallctl">arenas.hchunk.&lt;i&gt;.size</code>"
+  
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+        </span></dt><dd><p>Maximum size supported by this huge size
+        class.</p></dd><dt><a name="arenas.extend"></a><span class="term">
           
     "<code class="mallctl">arenas.extend</code>"
   
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Extend the array of arenas by appending a new arena,
-        and returning the new arena index.</p></dd><dt><a name="prof.active"></a><span class="term">
+        and returning the new arena index.</p></dd><dt><a name="prof.thread_active_init"></a><span class="term">
+          
+    "<code class="mallctl">prof.thread_active_init</code>"
+  
+          (<span class="type">bool</span>)
+          <code class="literal">rw</code>
+          [<code class="option">--enable-prof</code>]
+        </span></dt><dd><p>Control the initial setting for <a class="link" href="#thread.prof.active">
+    "<code class="mallctl">thread.prof.active</code>"
+  </a>
+        in newly created threads.  See the <a class="link" href="#opt.prof_thread_active_init">
+    "<code class="mallctl">opt.prof_thread_active_init</code>"
+  </a>
+        option for additional information.</p></dd><dt><a name="prof.active"></a><span class="term">
           
     "<code class="mallctl">prof.active</code>"
   
           (<span class="type">bool</span>)
           <code class="literal">rw</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Control whether sampling is currently active.  See the
         <a class="link" href="#opt.prof_active">
     "<code class="mallctl">opt.prof_active</code>"
   </a>
-        option for additional information.
-        </p></dd><dt><a name="prof.dump"></a><span class="term">
+        option for additional information, as well as the interrelated <a class="link" href="#thread.prof.active">
+    "<code class="mallctl">thread.prof.active</code>"
+  </a>
+        mallctl.</p></dd><dt><a name="prof.dump"></a><span class="term">
           
     "<code class="mallctl">prof.dump</code>"
   
           (<span class="type">const char *</span>)
           <code class="literal">-w</code>
           [<code class="option">--enable-prof</code>]
@@ -1027,13 +1237,51 @@
         is specified, to a file according to the pattern
         <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.m&lt;mseq&gt;.heap</code>,
         where <code class="literal">&lt;prefix&gt;</code> is controlled by the
         <a class="link" href="#opt.prof_prefix">
     "<code class="mallctl">opt.prof_prefix</code>"
   </a>
-        option.</p></dd><dt><a name="prof.interval"></a><span class="term">
+        option.</p></dd><dt><a name="prof.gdump"></a><span class="term">
+          
+    "<code class="mallctl">prof.gdump</code>"
+  
+          (<span class="type">bool</span>)
+          <code class="literal">rw</code>
+          [<code class="option">--enable-prof</code>]
+        </span></dt><dd><p>When enabled, trigger a memory profile dump every time
+        the total virtual memory exceeds the previous maximum.  Profiles are
+        dumped to files named according to the pattern
+        <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap</code>,
+        where <code class="literal">&lt;prefix&gt;</code> is controlled by the <a class="link" href="#opt.prof_prefix">
+    "<code class="mallctl">opt.prof_prefix</code>"
+  </a>
+        option.</p></dd><dt><a name="prof.reset"></a><span class="term">
+          
+    "<code class="mallctl">prof.reset</code>"
+  
+          (<span class="type">size_t</span>)
+          <code class="literal">-w</code>
+          [<code class="option">--enable-prof</code>]
+        </span></dt><dd><p>Reset all memory profile statistics, and optionally
+        update the sample rate (see <a class="link" href="#opt.lg_prof_sample">
+    "<code class="mallctl">opt.lg_prof_sample</code>"
+  </a>
+        and <a class="link" href="#prof.lg_sample">
+    "<code class="mallctl">prof.lg_sample</code>"
+  </a>).
+        </p></dd><dt><a name="prof.lg_sample"></a><span class="term">
+          
+    "<code class="mallctl">prof.lg_sample</code>"
+  
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-prof</code>]
+        </span></dt><dd><p>Get the current sample rate (see <a class="link" href="#opt.lg_prof_sample">
+    "<code class="mallctl">opt.lg_prof_sample</code>"
+  </a>).
+        </p></dd><dt><a name="prof.interval"></a><span class="term">
           
     "<code class="mallctl">prof.interval</code>"
   
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
@@ -1048,15 +1296,14 @@
   
           (<span class="type">size_t *</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Pointer to a counter that contains an approximate count
         of the current number of bytes in active pages.  The estimate may be
-        high, but never low, because each arena rounds up to the nearest
-        multiple of the chunk size when computing its contribution to the
-        counter.  Note that the <a class="link" href="#epoch">
+        high, but never low, because each arena rounds up when computing its
+        contribution to the counter.  Note that the <a class="link" href="#epoch">
     "<code class="mallctl">epoch</code>"
   </a> mallctl has no bearing
         on this counter.  Furthermore, counter consistency is maintained via
         atomic operations, so it is necessary to use an atomic operation in
         order to guarantee a consistent read when dereferencing the pointer.
         </p></dd><dt><a name="stats.allocated"></a><span class="term">
@@ -1079,84 +1326,79 @@
         equal to <a class="link" href="#stats.allocated">
     "<code class="mallctl">stats.allocated</code>"
   </a>.
         This does not include <a class="link" href="#stats.arenas.i.pdirty">
         
     "<code class="mallctl">stats.arenas.&lt;i&gt;.pdirty</code>"
-  </a> and pages
-        entirely devoted to allocator metadata.</p></dd><dt><a name="stats.mapped"></a><span class="term">
-          
-    "<code class="mallctl">stats.mapped</code>"
-  
-          (<span class="type">size_t</span>)
-          <code class="literal">r-</code>
-          [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Total number of bytes in chunks mapped on behalf of the
-        application.  This is a multiple of the chunk size, and is at least as
-        large as <a class="link" href="#stats.active">
-    "<code class="mallctl">stats.active</code>"
-  </a>.  This
-        does not include inactive chunks.</p></dd><dt><a name="stats.chunks.current"></a><span class="term">
+  </a>, nor pages
+        entirely devoted to allocator metadata.</p></dd><dt><a name="stats.metadata"></a><span class="term">
           
-    "<code class="mallctl">stats.chunks.current</code>"
+    "<code class="mallctl">stats.metadata</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Total number of chunks actively mapped on behalf of the
-        application.  This does not include inactive chunks.
-        </p></dd><dt><a name="stats.chunks.total"></a><span class="term">
-          
-    "<code class="mallctl">stats.chunks.total</code>"
-  
-          (<span class="type">uint64_t</span>)
-          <code class="literal">r-</code>
-          [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Cumulative number of chunks allocated.</p></dd><dt><a name="stats.chunks.high"></a><span class="term">
+        </span></dt><dd><p>Total number of bytes dedicated to metadata, which
+        comprise base allocations used for bootstrap-sensitive internal
+        allocator data structures, arena chunk headers (see <a class="link" href="#stats.arenas.i.metadata.mapped">
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.mapped</code>"
+  </a>),
+        and internal allocations (see <a class="link" href="#stats.arenas.i.metadata.allocated">
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.allocated</code>"
+  </a>).</p></dd><dt><a name="stats.resident"></a><span class="term">
           
-    "<code class="mallctl">stats.chunks.high</code>"
+    "<code class="mallctl">stats.resident</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Maximum number of active chunks at any time thus far.
-        </p></dd><dt><a name="stats.huge.allocated"></a><span class="term">
+        </span></dt><dd><p>Maximum number of bytes in physically resident data
+        pages mapped by the allocator, comprising all pages dedicated to
+        allocator metadata, pages backing active allocations, and unused dirty
+        pages.  This is a maximum rather than precise because pages may not
+        actually be physically resident if they correspond to demand-zeroed
+        virtual memory that has not yet been touched.  This is a multiple of the
+        page size, and is larger than <a class="link" href="#stats.active">
+    "<code class="mallctl">stats.active</code>"
+  </a>.</p></dd><dt><a name="stats.mapped"></a><span class="term">
           
-    "<code class="mallctl">stats.huge.allocated</code>"
+    "<code class="mallctl">stats.mapped</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Number of bytes currently allocated by huge objects.
-        </p></dd><dt><a name="stats.huge.nmalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.huge.nmalloc</code>"
-  
-          (<span class="type">uint64_t</span>)
-          <code class="literal">r-</code>
-          [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Cumulative number of huge allocation requests.
-        </p></dd><dt><a name="stats.huge.ndalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.huge.ndalloc</code>"
-  
-          (<span class="type">uint64_t</span>)
-          <code class="literal">r-</code>
-          [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Cumulative number of huge deallocation requests.
-        </p></dd><dt><a name="stats.arenas.i.dss"></a><span class="term">
+        </span></dt><dd><p>Total number of bytes in active chunks mapped by the
+        allocator.  This is a multiple of the chunk size, and is larger than
+        <a class="link" href="#stats.active">
+    "<code class="mallctl">stats.active</code>"
+  </a>.
+        This does not include inactive chunks, even those that contain unused
+        dirty pages, which means that there is no strict ordering between this
+        and <a class="link" href="#stats.resident">
+    "<code class="mallctl">stats.resident</code>"
+  </a>.</p></dd><dt><a name="stats.arenas.i.dss"></a><span class="term">
           
     "<code class="mallctl">stats.arenas.&lt;i&gt;.dss</code>"
   
           (<span class="type">const char *</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>dss (<span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>) allocation precedence as
         related to <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> allocation.  See <a class="link" href="#opt.dss">
     "<code class="mallctl">opt.dss</code>"
   </a> for details.
-        </p></dd><dt><a name="stats.arenas.i.nthreads"></a><span class="term">
+        </p></dd><dt><a name="stats.arenas.i.lg_dirty_mult"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.lg_dirty_mult</code>"
+  
+          (<span class="type">ssize_t</span>)
+          <code class="literal">r-</code>
+        </span></dt><dd><p>Minimum ratio (log base 2) of active to dirty pages.
+        See <a class="link" href="#opt.lg_dirty_mult">
+    "<code class="mallctl">opt.lg_dirty_mult</code>"
+  </a>
+        for details.</p></dd><dt><a name="stats.arenas.i.nthreads"></a><span class="term">
           
     "<code class="mallctl">stats.arenas.&lt;i&gt;.nthreads</code>"
   
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Number of threads currently assigned to
@@ -1179,13 +1421,44 @@
           
     "<code class="mallctl">stats.arenas.&lt;i&gt;.mapped</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Number of mapped bytes.</p></dd><dt><a name="stats.arenas.i.npurge"></a><span class="term">
+        </span></dt><dd><p>Number of mapped bytes.</p></dd><dt><a name="stats.arenas.i.metadata.mapped"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.mapped</code>"
+  
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Number of mapped bytes in arena chunk headers, which
+        track the states of the non-metadata pages.</p></dd><dt><a name="stats.arenas.i.metadata.allocated"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.allocated</code>"
+  
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Number of bytes dedicated to internal allocations.
+        Internal allocations differ from application-originated allocations in
+        that they are for internal use, and that they are omitted from heap
+        profiles.  This statistic is reported separately from <a class="link" href="#stats.metadata">
+    "<code class="mallctl">stats.metadata</code>"
+  </a> and
+        <a class="link" href="#stats.arenas.i.metadata.mapped">
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.mapped</code>"
+  </a>
+        because it overlaps with e.g. the <a class="link" href="#stats.allocated">
+    "<code class="mallctl">stats.allocated</code>"
+  </a> and
+        <a class="link" href="#stats.active">
+    "<code class="mallctl">stats.active</code>"
+  </a>
+        statistics, whereas the other metadata statistics do
+        not.</p></dd><dt><a name="stats.arenas.i.npurge"></a><span class="term">
           
     "<code class="mallctl">stats.arenas.&lt;i&gt;.npurge</code>"
   
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
@@ -1267,21 +1540,45 @@
     "<code class="mallctl">stats.arenas.&lt;i&gt;.large.nrequests</code>"
   
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of large allocation requests.
-        </p></dd><dt><a name="stats.arenas.i.bins.j.allocated"></a><span class="term">
+        </p></dd><dt><a name="stats.arenas.i.huge.allocated"></a><span class="term">
           
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.allocated</code>"
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.huge.allocated</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Current number of bytes allocated by
-        bin.</p></dd><dt><a name="stats.arenas.i.bins.j.nmalloc"></a><span class="term">
+        </span></dt><dd><p>Number of bytes currently allocated by huge objects.
+        </p></dd><dt><a name="stats.arenas.i.huge.nmalloc"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.huge.nmalloc</code>"
+  
+          (<span class="type">uint64_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Cumulative number of huge allocation requests served
+        directly by the arena.</p></dd><dt><a name="stats.arenas.i.huge.ndalloc"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.huge.ndalloc</code>"
+  
+          (<span class="type">uint64_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Cumulative number of huge deallocation requests served
+        directly by the arena.</p></dd><dt><a name="stats.arenas.i.huge.nrequests"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.huge.nrequests</code>"
+  
+          (<span class="type">uint64_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Cumulative number of huge allocation requests.
+        </p></dd><dt><a name="stats.arenas.i.bins.j.nmalloc"></a><span class="term">
           
     "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nmalloc</code>"
   
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
@@ -1299,13 +1596,21 @@
     "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nrequests</code>"
   
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of allocation
-        requests.</p></dd><dt><a name="stats.arenas.i.bins.j.nfills"></a><span class="term">
+        requests.</p></dd><dt><a name="stats.arenas.i.bins.j.curregs"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curregs</code>"
+  
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Current number of regions for this size
+        class.</p></dd><dt><a name="stats.arenas.i.bins.j.nfills"></a><span class="term">
           
     "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nfills</code>"
   
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code> <code class="option">--enable-tcache</code>]
@@ -1367,12 +1672,44 @@
     "<code class="mallctl">stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.curruns</code>"
   
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Current number of runs for this size class.
+        </p></dd><dt><a name="stats.arenas.i.hchunks.j.nmalloc"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nmalloc</code>"
+  
+          (<span class="type">uint64_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Cumulative number of allocation requests for this size
+        class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.hchunks.j.ndalloc"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.ndalloc</code>"
+  
+          (<span class="type">uint64_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Cumulative number of deallocation requests for this
+        size class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.hchunks.j.nrequests"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nrequests</code>"
+  
+          (<span class="type">uint64_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Cumulative number of allocation requests for this size
+        class.</p></dd><dt><a name="stats.arenas.i.hchunks.j.curhchunks"></a><span class="term">
+          
+    "<code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.curhchunks</code>"
+  
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Current number of huge allocations for this size class.
         </p></dd></dl></div></div><div class="refsect1"><a name="debugging_malloc_problems"></a><h2>DEBUGGING MALLOC PROBLEMS</h2><p>When debugging, it is a good idea to configure/build jemalloc with
     the <code class="option">--enable-debug</code> and <code class="option">--enable-fill</code>
     options, and recompile the program with suitable options and symbols for
     debugger support.  When so configured, jemalloc incorporates a wide variety
     of run-time assertions that catch application errors such as double-free,
     write-after-free, etc.</p><p>Programs often accidentally depend on &#8220;uninitialized&#8221;
@@ -1403,13 +1740,13 @@
     <code class="function">malloc_message</code>(<em class="parameter"><code></code></em>) takes the
     <em class="parameter"><code>cbopaque</code></em> pointer argument that is
     <code class="constant">NULL</code> unless overridden by the arguments in a call to
     <code class="function">malloc_stats_print</code>(<em class="parameter"><code></code></em>), followed by a string
     pointer.  Please note that doing anything which tries to allocate memory in
     this function is likely to result in a crash or deadlock.</p><p>All messages are prefixed by
-    &#8220;<code class="computeroutput">&lt;jemalloc&gt;: </code>&#8221;.</p></div><div class="refsect1"><a name="return_values"></a><h2>RETURN VALUES</h2><div class="refsect2"><a name="idm316388028784"></a><h3>Standard API</h3><p>The <code class="function">malloc</code>(<em class="parameter"><code></code></em>) and
+    &#8220;<code class="computeroutput">&lt;jemalloc&gt;: </code>&#8221;.</p></div><div class="refsect1"><a name="return_values"></a><h2>RETURN VALUES</h2><div class="refsect2"><a name="idp46949776"></a><h3>Standard API</h3><p>The <code class="function">malloc</code>(<em class="parameter"><code></code></em>) and
       <code class="function">calloc</code>(<em class="parameter"><code></code></em>) functions return a pointer to the
       allocated memory if successful; otherwise a <code class="constant">NULL</code>
       pointer is returned and <code class="varname">errno</code> is set to
       <span class="errorname">ENOMEM</span>.</p><p>The <code class="function">posix_memalign</code>(<em class="parameter"><code></code></em>) function
       returns the value 0 if successful; otherwise it returns an error value.
       The <code class="function">posix_memalign</code>(<em class="parameter"><code></code></em>) function will fail
@@ -1431,13 +1768,13 @@
       allocated memory if successful; otherwise a <code class="constant">NULL</code>
       pointer is returned, and <code class="varname">errno</code> is set to
       <span class="errorname">ENOMEM</span> if the error was the result of an
       allocation failure.  The <code class="function">realloc</code>(<em class="parameter"><code></code></em>)
       function always leaves the original buffer intact when an error occurs.
       </p><p>The <code class="function">free</code>(<em class="parameter"><code></code></em>) function returns no
-      value.</p></div><div class="refsect2"><a name="idm316388003104"></a><h3>Non-standard API</h3><p>The <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) and
+      value.</p></div><div class="refsect2"><a name="idp46974576"></a><h3>Non-standard API</h3><p>The <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) and
       <code class="function">rallocx</code>(<em class="parameter"><code></code></em>) functions return a pointer to
       the allocated memory if successful; otherwise a <code class="constant">NULL</code>
       pointer is returned to indicate insufficient contiguous memory was
       available to service the allocation request.  </p><p>The <code class="function">xallocx</code>(<em class="parameter"><code></code></em>) function returns the
       real size of the resulting resized allocation pointed to by
       <em class="parameter"><code>ptr</code></em>, which is a value less than
@@ -1462,33 +1799,13 @@
             write read-only value.</p></dd><dt><span class="term"><span class="errorname">EAGAIN</span></span></dt><dd><p>A memory allocation failure
             occurred.</p></dd><dt><span class="term"><span class="errorname">EFAULT</span></span></dt><dd><p>An interface with side effects failed in some way
             not directly related to <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>)
             read/write processing.</p></dd></dl></div><p>
       </p><p>The <code class="function">malloc_usable_size</code>(<em class="parameter"><code></code></em>) function
       returns the usable size of the allocation pointed to by
-      <em class="parameter"><code>ptr</code></em>.  </p></div><div class="refsect2"><a name="idm316387973360"></a><h3>Experimental API</h3><p>The <code class="function">allocm</code>(<em class="parameter"><code></code></em>),
-      <code class="function">rallocm</code>(<em class="parameter"><code></code></em>),
-      <code class="function">sallocm</code>(<em class="parameter"><code></code></em>),
-      <code class="function">dallocm</code>(<em class="parameter"><code></code></em>), and
-      <code class="function">nallocm</code>(<em class="parameter"><code></code></em>) functions return
-      <code class="constant">ALLOCM_SUCCESS</code> on success; otherwise they return an
-      error value.  The <code class="function">allocm</code>(<em class="parameter"><code></code></em>),
-      <code class="function">rallocm</code>(<em class="parameter"><code></code></em>), and
-      <code class="function">nallocm</code>(<em class="parameter"><code></code></em>) functions will fail if:
-        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorname">ALLOCM_ERR_OOM</span></span></dt><dd><p>Out of memory.  Insufficient contiguous memory was
-            available to service the allocation request.  The
-            <code class="function">allocm</code>(<em class="parameter"><code></code></em>) function additionally sets
-            <em class="parameter"><code>*ptr</code></em> to <code class="constant">NULL</code>, whereas
-            the <code class="function">rallocm</code>(<em class="parameter"><code></code></em>) function leaves
-            <code class="constant">*ptr</code> unmodified.</p></dd></dl></div><p>
-      The <code class="function">rallocm</code>(<em class="parameter"><code></code></em>) function will also
-      fail if:
-        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorname">ALLOCM_ERR_NOT_MOVED</span></span></dt><dd><p><code class="constant">ALLOCM_NO_MOVE</code> was specified,
-            but the reallocation request could not be serviced without moving
-            the object.</p></dd></dl></div><p>
-      </p></div></div><div class="refsect1"><a name="environment"></a><h2>ENVIRONMENT</h2><p>The following environment variable affects the execution of the
+      <em class="parameter"><code>ptr</code></em>.  </p></div></div><div class="refsect1"><a name="environment"></a><h2>ENVIRONMENT</h2><p>The following environment variable affects the execution of the
     allocation functions:
       </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="envar">MALLOC_CONF</code></span></dt><dd><p>If the environment variable
           <code class="envar">MALLOC_CONF</code> is set, the characters it contains
           will be interpreted as options.</p></dd></dl></div><p>
     </p></div><div class="refsect1"><a name="examples"></a><h2>EXAMPLES</h2><p>To dump core whenever a problem occurs:
       </p><pre class="screen">ln -s 'abort:true' /etc/malloc.conf</pre><p>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/jemalloc.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/jemalloc.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/jemalloc.xml	2017-09-27 22:47:53.218963474 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/jemalloc.xml	2017-09-27 22:49:15.014960476 +0800
@@ -6,13 +6,13 @@
 ]>
 
 <refentry>
   <refentryinfo>
     <title>User Manual</title>
     <productname>jemalloc</productname>
-    <releaseinfo role="version">3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340</releaseinfo>
+    <releaseinfo role="version">4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c</releaseinfo>
     <authorgroup>
       <author>
         <firstname>Jason</firstname>
         <surname>Evans</surname>
         <personblurb>Author</personblurb>
       </author>
@@ -35,37 +35,32 @@
     <refname>free</refname>
     <refname>mallocx</refname>
     <refname>rallocx</refname>
     <refname>xallocx</refname>
     <refname>sallocx</refname>
     <refname>dallocx</refname>
+    <refname>sdallocx</refname>
     <refname>nallocx</refname>
     <refname>mallctl</refname>
     <refname>mallctlnametomib</refname>
     <refname>mallctlbymib</refname>
     <refname>malloc_stats_print</refname>
     <refname>malloc_usable_size</refname>
-    <refname>allocm</refname>
-    <refname>rallocm</refname>
-    <refname>sallocm</refname>
-    <refname>dallocm</refname>
-    <refname>nallocm</refname>
     -->
     <refpurpose>general purpose memory allocation functions</refpurpose>
   </refnamediv>
   <refsect1 id="library">
     <title>LIBRARY</title>
-    <para>This manual describes jemalloc 3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340.  More information
+    <para>This manual describes jemalloc 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c.  More information
     can be found at the <ulink
     url="http://www.canonware.com/jemalloc/">jemalloc website</ulink>.</para>
   </refsect1>
   <refsynopsisdiv>
     <title>SYNOPSIS</title>
     <funcsynopsis>
-      <funcsynopsisinfo>#include &lt;<filename class="headerfile">stdlib.h</filename>&gt;
-#include &lt;<filename class="headerfile">jemalloc/jemalloc.h</filename>&gt;</funcsynopsisinfo>
+      <funcsynopsisinfo>#include &lt;<filename class="headerfile">jemalloc/jemalloc.h</filename>&gt;</funcsynopsisinfo>
       <refsect2>
         <title>Standard API</title>
         <funcprototype>
           <funcdef>void *<function>malloc</function></funcdef>
           <paramdef>size_t <parameter>size</parameter></paramdef>
         </funcprototype>
@@ -123,12 +118,18 @@
         <funcprototype>
           <funcdef>void <function>dallocx</function></funcdef>
           <paramdef>void *<parameter>ptr</parameter></paramdef>
           <paramdef>int <parameter>flags</parameter></paramdef>
         </funcprototype>
         <funcprototype>
+          <funcdef>void <function>sdallocx</function></funcdef>
+          <paramdef>void *<parameter>ptr</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>int <parameter>flags</parameter></paramdef>
+        </funcprototype>
+        <funcprototype>
           <funcdef>size_t <function>nallocx</function></funcdef>
           <paramdef>size_t <parameter>size</parameter></paramdef>
           <paramdef>int <parameter>flags</parameter></paramdef>
         </funcprototype>
         <funcprototype>
           <funcdef>int <function>mallctl</function></funcdef>
@@ -169,47 +170,12 @@
           <funcdef>void <function>(*malloc_message)</function></funcdef>
           <paramdef>void *<parameter>cbopaque</parameter></paramdef>
           <paramdef>const char *<parameter>s</parameter></paramdef>
         </funcprototype>
         <para><type>const char *</type><varname>malloc_conf</varname>;</para>
       </refsect2>
-      <refsect2>
-      <title>Experimental API</title>
-        <funcprototype>
-          <funcdef>int <function>allocm</function></funcdef>
-          <paramdef>void **<parameter>ptr</parameter></paramdef>
-          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
-          <paramdef>size_t <parameter>size</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-        <funcprototype>
-          <funcdef>int <function>rallocm</function></funcdef>
-          <paramdef>void **<parameter>ptr</parameter></paramdef>
-          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
-          <paramdef>size_t <parameter>size</parameter></paramdef>
-          <paramdef>size_t <parameter>extra</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-        <funcprototype>
-          <funcdef>int <function>sallocm</function></funcdef>
-          <paramdef>const void *<parameter>ptr</parameter></paramdef>
-          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-        <funcprototype>
-          <funcdef>int <function>dallocm</function></funcdef>
-          <paramdef>void *<parameter>ptr</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-        <funcprototype>
-          <funcdef>int <function>nallocm</function></funcdef>
-          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
-          <paramdef>size_t <parameter>size</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-      </refsect2>
     </funcsynopsis>
   </refsynopsisdiv>
   <refsect1 id="description">
     <title>DESCRIPTION</title>
     <refsect2>
       <title>Standard API</title>
@@ -226,21 +192,21 @@
       <parameter>number</parameter> * <parameter>size</parameter>, with the
       exception that the allocated memory is explicitly initialized to zero
       bytes.</para>
 
       <para>The <function>posix_memalign<parameter/></function> function
       allocates <parameter>size</parameter> bytes of memory such that the
-      allocation's base address is an even multiple of
+      allocation's base address is a multiple of
       <parameter>alignment</parameter>, and returns the allocation in the value
       pointed to by <parameter>ptr</parameter>.  The requested
-      <parameter>alignment</parameter> must be a power of 2 at least as large
-      as <code language="C">sizeof(<type>void *</type>)</code>.</para>
+      <parameter>alignment</parameter> must be a power of 2 at least as large as
+      <code language="C">sizeof(<type>void *</type>)</code>.</para>
 
       <para>The <function>aligned_alloc<parameter/></function> function
       allocates <parameter>size</parameter> bytes of memory such that the
-      allocation's base address is an even multiple of
+      allocation's base address is a multiple of
       <parameter>alignment</parameter>.  The requested
       <parameter>alignment</parameter> must be a power of 2.  Behavior is
       undefined if <parameter>size</parameter> is not an integral multiple of
       <parameter>alignment</parameter>.</para>
 
       <para>The <function>realloc<parameter/></function> function changes the
@@ -265,58 +231,81 @@
     <refsect2>
       <title>Non-standard API</title>
       <para>The <function>mallocx<parameter/></function>,
       <function>rallocx<parameter/></function>,
       <function>xallocx<parameter/></function>,
       <function>sallocx<parameter/></function>,
-      <function>dallocx<parameter/></function>, and
+      <function>dallocx<parameter/></function>,
+      <function>sdallocx<parameter/></function>, and
       <function>nallocx<parameter/></function> functions all have a
       <parameter>flags</parameter> argument that can be used to specify
       options.  The functions only check the options that are contextually
       relevant.  Use bitwise or (<code language="C">|</code>) operations to
       specify one or more of the following:
         <variablelist>
-          <varlistentry>
+          <varlistentry id="MALLOCX_LG_ALIGN">
             <term><constant>MALLOCX_LG_ALIGN(<parameter>la</parameter>)
             </constant></term>
 
             <listitem><para>Align the memory allocation to start at an address
             that is a multiple of <code language="C">(1 &lt;&lt;
             <parameter>la</parameter>)</code>.  This macro does not validate
             that <parameter>la</parameter> is within the valid
             range.</para></listitem>
           </varlistentry>
-          <varlistentry>
+          <varlistentry id="MALLOCX_ALIGN">
             <term><constant>MALLOCX_ALIGN(<parameter>a</parameter>)
             </constant></term>
 
             <listitem><para>Align the memory allocation to start at an address
             that is a multiple of <parameter>a</parameter>, where
             <parameter>a</parameter> is a power of two.  This macro does not
             validate that <parameter>a</parameter> is a power of 2.
             </para></listitem>
           </varlistentry>
-          <varlistentry>
+          <varlistentry id="MALLOCX_ZERO">
             <term><constant>MALLOCX_ZERO</constant></term>
 
             <listitem><para>Initialize newly allocated memory to contain zero
             bytes.  In the growing reallocation case, the real size prior to
             reallocation defines the boundary between untouched bytes and those
             that are initialized to contain zero bytes.  If this macro is
             absent, newly allocated memory is uninitialized.</para></listitem>
           </varlistentry>
-          <varlistentry>
+          <varlistentry id="MALLOCX_TCACHE">
+            <term><constant>MALLOCX_TCACHE(<parameter>tc</parameter>)
+            </constant></term>
+
+            <listitem><para>Use the thread-specific cache (tcache) specified by
+            the identifier <parameter>tc</parameter>, which must have been
+            acquired via the <link
+            linkend="tcache.create"><mallctl>tcache.create</mallctl></link>
+            mallctl.  This macro does not validate that
+            <parameter>tc</parameter> specifies a valid
+            identifier.</para></listitem>
+          </varlistentry>
+          <varlistentry id="MALLOC_TCACHE_NONE">
+            <term><constant>MALLOCX_TCACHE_NONE</constant></term>
+
+            <listitem><para>Do not use a thread-specific cache (tcache).  Unless
+            <constant>MALLOCX_TCACHE(<parameter>tc</parameter>)</constant> or
+            <constant>MALLOCX_TCACHE_NONE</constant> is specified, an
+            automatically managed tcache will be used under many circumstances.
+            This macro cannot be used in the same <parameter>flags</parameter>
+            argument as
+            <constant>MALLOCX_TCACHE(<parameter>tc</parameter>)</constant>.</para></listitem>
+          </varlistentry>
+          <varlistentry id="MALLOCX_ARENA">
             <term><constant>MALLOCX_ARENA(<parameter>a</parameter>)
             </constant></term>
 
             <listitem><para>Use the arena specified by the index
-            <parameter>a</parameter> (and by necessity bypass the thread
-            cache).  This macro has no effect for huge regions, nor for regions
-            that were allocated via an arena other than the one specified.
-            This macro does not validate that <parameter>a</parameter>
-            specifies an arena index in the valid range.</para></listitem>
+            <parameter>a</parameter>.  This macro has no effect for regions that
+            were allocated via an arena other than the one specified.  This
+            macro does not validate that <parameter>a</parameter> specifies an
+            arena index in the valid range.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
       <para>The <function>mallocx<parameter/></function> function allocates at
       least <parameter>size</parameter> bytes of memory, and returns a pointer
@@ -349,12 +338,21 @@
       real size of the allocation at <parameter>ptr</parameter>.</para>
 
       <para>The <function>dallocx<parameter/></function> function causes the
       memory referenced by <parameter>ptr</parameter> to be made available for
       future allocations.</para>
 
+      <para>The <function>sdallocx<parameter/></function> function is an
+      extension of <function>dallocx<parameter/></function> with a
+      <parameter>size</parameter> parameter to allow the caller to pass in the
+      allocation size as an optimization.  The minimum valid input size is the
+      original requested size of the allocation, and the maximum valid input
+      size is the corresponding value returned by
+      <function>nallocx<parameter/></function> or
+      <function>sallocx<parameter/></function>.</para>
+
       <para>The <function>nallocx<parameter/></function> function allocates no
       memory, but it performs the same size computation as the
       <function>mallocx<parameter/></function> function, and returns the real
       size of the allocation that would result from the equivalent
       <function>mallocx<parameter/></function> function call.  Behavior is
       undefined if <parameter>size</parameter> is <constant>0</constant>, or if
@@ -427,17 +425,18 @@
       <function>malloc_message<parameter/></function> uses the
       <function>mallctl*<parameter/></function> functions internally, so
       inconsistent statistics can be reported if multiple threads use these
       functions simultaneously.  If <option>--enable-stats</option> is
       specified during configuration, &ldquo;m&rdquo; and &ldquo;a&rdquo; can
       be specified to omit merged arena and per arena statistics, respectively;
-      &ldquo;b&rdquo; and &ldquo;l&rdquo; can be specified to omit per size
-      class statistics for bins and large objects, respectively.  Unrecognized
-      characters are silently ignored.  Note that thread caching may prevent
-      some statistics from being completely up to date, since extra locking
-      would be required to merge counters that track thread cache operations.
+      &ldquo;b&rdquo;, &ldquo;l&rdquo;, and &ldquo;h&rdquo; can be specified to
+      omit per size class statistics for bins, large objects, and huge objects,
+      respectively.  Unrecognized characters are silently ignored.  Note that
+      thread caching may prevent some statistics from being completely up to
+      date, since extra locking would be required to merge counters that track
+      thread cache operations.
       </para>
 
       <para>The <function>malloc_usable_size<parameter/></function> function
       returns the usable size of the allocation pointed to by
       <parameter>ptr</parameter>.  The return value may be larger than the size
       that was requested during allocation.  The
@@ -446,122 +445,12 @@
       it is provided solely as a tool for introspection purposes.  Any
       discrepancy between the requested allocation size and the size reported
       by <function>malloc_usable_size<parameter/></function> should not be
       depended on, since such behavior is entirely implementation-dependent.
       </para>
     </refsect2>
-    <refsect2>
-      <title>Experimental API</title>
-      <para>The experimental API is subject to change or removal without regard
-      for backward compatibility.  If <option>--disable-experimental</option>
-      is specified during configuration, the experimental API is
-      omitted.</para>
-
-      <para>The <function>allocm<parameter/></function>,
-      <function>rallocm<parameter/></function>,
-      <function>sallocm<parameter/></function>,
-      <function>dallocm<parameter/></function>, and
-      <function>nallocm<parameter/></function> functions all have a
-      <parameter>flags</parameter> argument that can be used to specify
-      options.  The functions only check the options that are contextually
-      relevant.  Use bitwise or (<code language="C">|</code>) operations to
-      specify one or more of the following:
-        <variablelist>
-          <varlistentry>
-            <term><constant>ALLOCM_LG_ALIGN(<parameter>la</parameter>)
-            </constant></term>
-
-            <listitem><para>Align the memory allocation to start at an address
-            that is a multiple of <code language="C">(1 &lt;&lt;
-            <parameter>la</parameter>)</code>.  This macro does not validate
-            that <parameter>la</parameter> is within the valid
-            range.</para></listitem>
-          </varlistentry>
-          <varlistentry>
-            <term><constant>ALLOCM_ALIGN(<parameter>a</parameter>)
-            </constant></term>
-
-            <listitem><para>Align the memory allocation to start at an address
-            that is a multiple of <parameter>a</parameter>, where
-            <parameter>a</parameter> is a power of two.  This macro does not
-            validate that <parameter>a</parameter> is a power of 2.
-            </para></listitem>
-          </varlistentry>
-          <varlistentry>
-            <term><constant>ALLOCM_ZERO</constant></term>
-
-            <listitem><para>Initialize newly allocated memory to contain zero
-            bytes.  In the growing reallocation case, the real size prior to
-            reallocation defines the boundary between untouched bytes and those
-            that are initialized to contain zero bytes.  If this macro is
-            absent, newly allocated memory is uninitialized.</para></listitem>
-          </varlistentry>
-          <varlistentry>
-            <term><constant>ALLOCM_NO_MOVE</constant></term>
-
-            <listitem><para>For reallocation, fail rather than moving the
-            object.  This constraint can apply to both growth and
-            shrinkage.</para></listitem>
-          </varlistentry>
-          <varlistentry>
-            <term><constant>ALLOCM_ARENA(<parameter>a</parameter>)
-            </constant></term>
-
-            <listitem><para>Use the arena specified by the index
-            <parameter>a</parameter> (and by necessity bypass the thread
-            cache).  This macro has no effect for huge regions, nor for regions
-            that were allocated via an arena other than the one specified.
-            This macro does not validate that <parameter>a</parameter>
-            specifies an arena index in the valid range.</para></listitem>
-          </varlistentry>
-        </variablelist>
-      </para>
-
-      <para>The <function>allocm<parameter/></function> function allocates at
-      least <parameter>size</parameter> bytes of memory, sets
-      <parameter>*ptr</parameter> to the base address of the allocation, and
-      sets <parameter>*rsize</parameter> to the real size of the allocation if
-      <parameter>rsize</parameter> is not <constant>NULL</constant>.  Behavior
-      is undefined if <parameter>size</parameter> is <constant>0</constant>, or
-      if request size overflows due to size class and/or alignment
-      constraints.</para>
-
-      <para>The <function>rallocm<parameter/></function> function resizes the
-      allocation at <parameter>*ptr</parameter> to be at least
-      <parameter>size</parameter> bytes, sets <parameter>*ptr</parameter> to
-      the base address of the allocation if it moved, and sets
-      <parameter>*rsize</parameter> to the real size of the allocation if
-      <parameter>rsize</parameter> is not <constant>NULL</constant>.  If
-      <parameter>extra</parameter> is non-zero, an attempt is made to resize
-      the allocation to be at least <code
-      language="C">(<parameter>size</parameter> +
-      <parameter>extra</parameter>)</code> bytes, though inability to allocate
-      the extra byte(s) will not by itself result in failure.  Behavior is
-      undefined if <parameter>size</parameter> is <constant>0</constant>, if
-      request size overflows due to size class and/or alignment constraints, or
-      if <code language="C">(<parameter>size</parameter> +
-      <parameter>extra</parameter> &gt;
-      <constant>SIZE_T_MAX</constant>)</code>.</para>
-
-      <para>The <function>sallocm<parameter/></function> function sets
-      <parameter>*rsize</parameter> to the real size of the allocation.</para>
-
-      <para>The <function>dallocm<parameter/></function> function causes the
-      memory referenced by <parameter>ptr</parameter> to be made available for
-      future allocations.</para>
-
-      <para>The <function>nallocm<parameter/></function> function allocates no
-      memory, but it performs the same size computation as the
-      <function>allocm<parameter/></function> function, and if
-      <parameter>rsize</parameter> is not <constant>NULL</constant> it sets
-      <parameter>*rsize</parameter> to the real size of the allocation that
-      would result from the equivalent <function>allocm<parameter/></function>
-      function call.  Behavior is undefined if <parameter>size</parameter> is
-      <constant>0</constant>, or if request size overflows due to size class
-      and/or alignment constraints.</para>
-    </refsect2>
   </refsect1>
   <refsect1 id="tuning">
     <title>TUNING</title>
     <para>Once, when the first call is made to one of the memory allocation
     routines, the allocator initializes its internals based in part on various
     options that can be specified at compile- or run-time.</para>
@@ -595,14 +484,16 @@
     <title>IMPLEMENTATION NOTES</title>
     <para>Traditionally, allocators have used
     <citerefentry><refentrytitle>sbrk</refentrytitle>
     <manvolnum>2</manvolnum></citerefentry> to obtain memory, which is
     suboptimal for several reasons, including race conditions, increased
     fragmentation, and artificial limitations on maximum usable memory.  If
-    <option>--enable-dss</option> is specified during configuration, this
-    allocator uses both <citerefentry><refentrytitle>mmap</refentrytitle>
+    <citerefentry><refentrytitle>sbrk</refentrytitle>
+    <manvolnum>2</manvolnum></citerefentry> is supported by the operating
+    system, this allocator uses both
+    <citerefentry><refentrytitle>mmap</refentrytitle>
     <manvolnum>2</manvolnum></citerefentry> and
     <citerefentry><refentrytitle>sbrk</refentrytitle>
     <manvolnum>2</manvolnum></citerefentry>, in that order of preference;
     otherwise only <citerefentry><refentrytitle>mmap</refentrytitle>
     <manvolnum>2</manvolnum></citerefentry> is used.</para>
 
@@ -629,47 +520,67 @@
     <para>Memory is conceptually broken into equal-sized chunks, where the
     chunk size is a power of two that is greater than the page size.  Chunks
     are always aligned to multiples of the chunk size.  This alignment makes it
     possible to find metadata for user objects very quickly.</para>
 
     <para>User objects are broken into three categories according to size:
-    small, large, and huge.  Small objects are smaller than one page.  Large
-    objects are smaller than the chunk size.  Huge objects are a multiple of
-    the chunk size.  Small and large objects are managed by arenas; huge
-    objects are managed separately in a single data structure that is shared by
-    all threads.  Huge objects are used by applications infrequently enough
-    that this single data structure is not a scalability issue.</para>
+    small, large, and huge.  Small and large objects are managed entirely by
+    arenas; huge objects are additionally aggregated in a single data structure
+    that is shared by all threads.  Huge objects are typically used by
+    applications infrequently enough that this single data structure is not a
+    scalability issue.</para>
 
     <para>Each chunk that is managed by an arena tracks its contents as runs of
     contiguous pages (unused, backing a set of small objects, or backing one
     large object).  The combination of chunk alignment and chunk page maps
     makes it possible to determine all metadata regarding small and large
     allocations in constant time.</para>
 
     <para>Small objects are managed in groups by page runs.  Each run maintains
-    a frontier and free list to track which regions are in use.  Allocation
-    requests that are no more than half the quantum (8 or 16, depending on
-    architecture) are rounded up to the nearest power of two that is at least
-    <code language="C">sizeof(<type>double</type>)</code>.  All other small
-    object size classes are multiples of the quantum, spaced such that internal
-    fragmentation is limited to approximately 25% for all but the smallest size
-    classes.  Allocation requests that are larger than the maximum small size
-    class, but small enough to fit in an arena-managed chunk (see the <link
-    linkend="opt.lg_chunk"><mallctl>opt.lg_chunk</mallctl></link> option), are
-    rounded up to the nearest run size.  Allocation requests that are too large
-    to fit in an arena-managed chunk are rounded up to the nearest multiple of
-    the chunk size.</para>
+    a bitmap to track which regions are in use.  Allocation requests that are no
+    more than half the quantum (8 or 16, depending on architecture) are rounded
+    up to the nearest power of two that is at least <code
+    language="C">sizeof(<type>double</type>)</code>.  All other object size
+    classes are multiples of the quantum, spaced such that there are four size
+    classes for each doubling in size, which limits internal fragmentation to
+    approximately 20% for all but the smallest size classes.  Small size classes
+    are smaller than four times the page size, large size classes are smaller
+    than the chunk size (see the <link
+    linkend="opt.lg_chunk"><mallctl>opt.lg_chunk</mallctl></link> option), and
+    huge size classes extend from the chunk size up to one size class less than
+    the full address space size.</para>
 
     <para>Allocations are packed tightly together, which can be an issue for
     multi-threaded applications.  If you need to assure that allocations do not
     suffer from cacheline sharing, round your allocation requests up to the
     nearest multiple of the cacheline size, or specify cacheline alignment when
     allocating.</para>
 
-    <para>Assuming 4 MiB chunks, 4 KiB pages, and a 16-byte quantum on a 64-bit
-    system, the size classes in each category are as shown in <xref
+    <para>The <function>realloc<parameter/></function>,
+    <function>rallocx<parameter/></function>, and
+    <function>xallocx<parameter/></function> functions may resize allocations
+    without moving them under limited circumstances.  Unlike the
+    <function>*allocx<parameter/></function> API, the standard API does not
+    officially round up the usable size of an allocation to the nearest size
+    class, so technically it is necessary to call
+    <function>realloc<parameter/></function> to grow e.g. a 9-byte allocation to
+    16 bytes, or shrink a 16-byte allocation to 9 bytes.  Growth and shrinkage
+    trivially succeeds in place as long as the pre-size and post-size both round
+    up to the same size class.  No other API guarantees are made regarding
+    in-place resizing, but the current implementation also tries to resize large
+    and huge allocations in place, as long as the pre-size and post-size are
+    both large or both huge.  In such cases shrinkage always succeeds for large
+    size classes, but for huge size classes the chunk allocator must support
+    splitting (see <link
+    linkend="arena.i.chunk_hooks"><mallctl>arena.&lt;i&gt;.chunk_hooks</mallctl></link>).
+    Growth only succeeds if the trailing memory is currently available, and
+    additionally for huge size classes the chunk allocator must support
+    merging.</para>
+
+    <para>Assuming 2 MiB chunks, 4 KiB pages, and a 16-byte quantum on a
+    64-bit system, the size classes in each category are as shown in <xref
     linkend="size_classes" xrefstyle="template:Table %n"/>.</para>
 
     <table xml:id="size_classes" frame="all">
       <title>Size classes</title>
       <tgroup cols="3" colsep="1" rowsep="1">
       <colspec colname="c1" align="left"/>
@@ -681,19 +592,19 @@
           <entry>Spacing</entry>
           <entry>Size</entry>
         </row>
       </thead>
       <tbody>
         <row>
-          <entry morerows="6">Small</entry>
+          <entry morerows="8">Small</entry>
           <entry>lg</entry>
           <entry>[8]</entry>
         </row>
         <row>
           <entry>16</entry>
-          <entry>[16, 32, 48, ..., 128]</entry>
+          <entry>[16, 32, 48, 64, 80, 96, 112, 128]</entry>
         </row>
         <row>
           <entry>32</entry>
           <entry>[160, 192, 224, 256]</entry>
         </row>
         <row>
@@ -707,23 +618,83 @@
         <row>
           <entry>256</entry>
           <entry>[1280, 1536, 1792, 2048]</entry>
         </row>
         <row>
           <entry>512</entry>
-          <entry>[2560, 3072, 3584]</entry>
+          <entry>[2560, 3072, 3584, 4096]</entry>
+        </row>
+        <row>
+          <entry>1 KiB</entry>
+          <entry>[5 KiB, 6 KiB, 7 KiB, 8 KiB]</entry>
+        </row>
+        <row>
+          <entry>2 KiB</entry>
+          <entry>[10 KiB, 12 KiB, 14 KiB]</entry>
+        </row>
+        <row>
+          <entry morerows="7">Large</entry>
+          <entry>2 KiB</entry>
+          <entry>[16 KiB]</entry>
         </row>
         <row>
-          <entry>Large</entry>
           <entry>4 KiB</entry>
-          <entry>[4 KiB, 8 KiB, 12 KiB, ..., 4072 KiB]</entry>
+          <entry>[20 KiB, 24 KiB, 28 KiB, 32 KiB]</entry>
+        </row>
+        <row>
+          <entry>8 KiB</entry>
+          <entry>[40 KiB, 48 KiB, 54 KiB, 64 KiB]</entry>
+        </row>
+        <row>
+          <entry>16 KiB</entry>
+          <entry>[80 KiB, 96 KiB, 112 KiB, 128 KiB]</entry>
+        </row>
+        <row>
+          <entry>32 KiB</entry>
+          <entry>[160 KiB, 192 KiB, 224 KiB, 256 KiB]</entry>
+        </row>
+        <row>
+          <entry>64 KiB</entry>
+          <entry>[320 KiB, 384 KiB, 448 KiB, 512 KiB]</entry>
+        </row>
+        <row>
+          <entry>128 KiB</entry>
+          <entry>[640 KiB, 768 KiB, 896 KiB, 1 MiB]</entry>
+        </row>
+        <row>
+          <entry>256 KiB</entry>
+          <entry>[1280 KiB, 1536 KiB, 1792 KiB]</entry>
+        </row>
+        <row>
+          <entry morerows="6">Huge</entry>
+          <entry>256 KiB</entry>
+          <entry>[2 MiB]</entry>
+        </row>
+        <row>
+          <entry>512 KiB</entry>
+          <entry>[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]</entry>
+        </row>
+        <row>
+          <entry>1 MiB</entry>
+          <entry>[5 MiB, 6 MiB, 7 MiB, 8 MiB]</entry>
+        </row>
+        <row>
+          <entry>2 MiB</entry>
+          <entry>[10 MiB, 12 MiB, 14 MiB, 16 MiB]</entry>
         </row>
         <row>
-          <entry>Huge</entry>
           <entry>4 MiB</entry>
-          <entry>[4 MiB, 8 MiB, 12 MiB, ...]</entry>
+          <entry>[20 MiB, 24 MiB, 28 MiB, 32 MiB]</entry>
+        </row>
+        <row>
+          <entry>8 MiB</entry>
+          <entry>[40 MiB, 48 MiB, 56 MiB, 64 MiB]</entry>
+        </row>
+        <row>
+          <entry>...</entry>
+          <entry>...</entry>
         </row>
       </tbody>
       </tgroup>
     </table>
   </refsect1>
   <refsect1 id="mallctl_namespace">
@@ -762,29 +733,29 @@
         <listitem><para>If a value is passed in, refresh the data from which
         the <function>mallctl*<parameter/></function> functions report values,
         and increment the epoch.  Return the current epoch.  This is useful for
         detecting whether another thread caused a refresh.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="config.debug">
+      <varlistentry id="config.cache_oblivious">
         <term>
-          <mallctl>config.debug</mallctl>
+          <mallctl>config.cache_oblivious</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
-        <listitem><para><option>--enable-debug</option> was specified during
-        build configuration.</para></listitem>
+        <listitem><para><option>--enable-cache-oblivious</option> was specified
+        during build configuration.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="config.dss">
+      <varlistentry id="config.debug">
         <term>
-          <mallctl>config.dss</mallctl>
+          <mallctl>config.debug</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
-        <listitem><para><option>--enable-dss</option> was specified during
+        <listitem><para><option>--enable-debug</option> was specified during
         build configuration.</para></listitem>
       </varlistentry>
 
       <varlistentry id="config.fill">
         <term>
           <mallctl>config.fill</mallctl>
@@ -802,22 +773,12 @@
           <literal>r-</literal>
         </term>
         <listitem><para><option>--enable-lazy-lock</option> was specified
         during build configuration.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="config.mremap">
-        <term>
-          <mallctl>config.mremap</mallctl>
-          (<type>bool</type>)
-          <literal>r-</literal>
-        </term>
-        <listitem><para><option>--enable-mremap</option> was specified during
-        build configuration.</para></listitem>
-      </varlistentry>
-
       <varlistentry id="config.munmap">
         <term>
           <mallctl>config.munmap</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
@@ -937,29 +898,34 @@
           <literal>r-</literal>
         </term>
         <listitem><para>dss (<citerefentry><refentrytitle>sbrk</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry>) allocation precedence as
         related to <citerefentry><refentrytitle>mmap</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> allocation.  The following
-        settings are supported: &ldquo;disabled&rdquo;, &ldquo;primary&rdquo;,
-        and &ldquo;secondary&rdquo;.  The default is &ldquo;secondary&rdquo; if
-        <link linkend="config.dss"><mallctl>config.dss</mallctl></link> is
-        true, &ldquo;disabled&rdquo; otherwise.
+        settings are supported if
+        <citerefentry><refentrytitle>sbrk</refentrytitle>
+        <manvolnum>2</manvolnum></citerefentry> is supported by the operating
+        system: &ldquo;disabled&rdquo;, &ldquo;primary&rdquo;, and
+        &ldquo;secondary&rdquo;; otherwise only &ldquo;disabled&rdquo; is
+        supported.  The default is &ldquo;secondary&rdquo; if
+        <citerefentry><refentrytitle>sbrk</refentrytitle>
+        <manvolnum>2</manvolnum></citerefentry> is supported by the operating
+        system; &ldquo;disabled&rdquo; otherwise.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.lg_chunk">
         <term>
           <mallctl>opt.lg_chunk</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Virtual memory chunk size (log base 2).  If a chunk
         size outside the supported size range is specified, the size is
         silently clipped to the minimum/maximum supported size.  The default
-        chunk size is 4 MiB (2^22).
+        chunk size is 2 MiB (2^21).
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.narenas">
         <term>
           <mallctl>opt.narenas</mallctl>
@@ -983,13 +949,17 @@
         whichever is greater), before informing the kernel about some of those
         pages via <citerefentry><refentrytitle>madvise</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> or a similar system call.  This
         provides the kernel with sufficient information to recycle dirty pages
         if physical memory becomes scarce and the pages remain unused.  The
         default minimum ratio is 8:1 (2^3:1); an option value of -1 will
-        disable dirty page purging.</para></listitem>
+        disable dirty page purging.  See <link
+        linkend="arenas.lg_dirty_mult"><mallctl>arenas.lg_dirty_mult</mallctl></link>
+        and <link
+        linkend="arena.i.lg_dirty_mult"><mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl></link>
+        for related dynamic control options.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.stats_print">
         <term>
           <mallctl>opt.stats_print</mallctl>
           (<type>bool</type>)
@@ -1000,32 +970,40 @@
         function is called at program exit via an
         <citerefentry><refentrytitle>atexit</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> function.  If
         <option>--enable-stats</option> is specified during configuration, this
         has the potential to cause deadlock for a multi-threaded process that
         exits while one or more threads are executing in the memory allocation
-        functions.  Therefore, this option should only be used with care; it is
-        primarily intended as a performance tuning aid during application
+        functions.  Furthermore, <function>atexit<parameter/></function> may
+        allocate memory during application initialization and then deadlock
+        internally when jemalloc in turn calls
+        <function>atexit<parameter/></function>, so this option is not
+        univerally usable (though the application can register its own
+        <function>atexit<parameter/></function> function with equivalent
+        functionality).  Therefore, this option should only be used with care;
+        it is primarily intended as a performance tuning aid during application
         development.  This option is disabled by default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.junk">
         <term>
           <mallctl>opt.junk</mallctl>
-          (<type>bool</type>)
+          (<type>const char *</type>)
           <literal>r-</literal>
           [<option>--enable-fill</option>]
         </term>
-        <listitem><para>Junk filling enabled/disabled.  If enabled, each byte
-        of uninitialized allocated memory will be initialized to
-        <literal>0xa5</literal>.  All deallocated memory will be initialized to
-        <literal>0x5a</literal>.  This is intended for debugging and will
-        impact performance negatively.  This option is disabled by default
-        unless <option>--enable-debug</option> is specified during
-        configuration, in which case it is enabled by default unless running
-        inside <ulink
+        <listitem><para>Junk filling.  If set to "alloc", each byte of
+        uninitialized allocated memory will be initialized to
+        <literal>0xa5</literal>.  If set to "free", all deallocated memory will
+        be initialized to <literal>0x5a</literal>.  If set to "true", both
+        allocated and deallocated memory will be initialized, and if set to
+        "false", junk filling be disabled entirely.  This is intended for
+        debugging and will impact performance negatively.  This option is
+        "false" by default unless <option>--enable-debug</option> is specified
+        during configuration, in which case it is "true" by default unless
+        running inside <ulink
         url="http://valgrind.org/">Valgrind</ulink>.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.quarantine">
         <term>
           <mallctl>opt.quarantine</mallctl>
@@ -1073,15 +1051,14 @@
           <literal>r-</literal>
           [<option>--enable-fill</option>]
         </term>
         <listitem><para>Zero filling enabled/disabled.  If enabled, each byte
         of uninitialized allocated memory will be initialized to 0.  Note that
         this initialization only happens once for each byte, so
-        <function>realloc<parameter/></function>,
-        <function>rallocx<parameter/></function> and
-        <function>rallocm<parameter/></function> calls do not zero memory that
+        <function>realloc<parameter/></function> and
+        <function>rallocx<parameter/></function> calls do not zero memory that
         was previously allocated.  This is intended for debugging and will
         impact performance negatively.  This option is disabled by default.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.utrace">
@@ -1094,25 +1071,12 @@
         <listitem><para>Allocation tracing based on
         <citerefentry><refentrytitle>utrace</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> enabled/disabled.  This option
         is disabled by default.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="opt.valgrind">
-        <term>
-          <mallctl>opt.valgrind</mallctl>
-          (<type>bool</type>)
-          <literal>r-</literal>
-          [<option>--enable-valgrind</option>]
-        </term>
-        <listitem><para><ulink url="http://valgrind.org/">Valgrind</ulink>
-        support enabled/disabled.  This option is vestigal because jemalloc
-        auto-detects whether it is running inside Valgrind.  This option is
-        disabled by default, unless running inside Valgrind.</para></listitem>
-      </varlistentry>
-
       <varlistentry id="opt.xmalloc">
         <term>
           <mallctl>opt.xmalloc</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
           [<option>--enable-xmalloc</option>]
@@ -1134,34 +1098,34 @@
         <term>
           <mallctl>opt.tcache</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
           [<option>--enable-tcache</option>]
         </term>
-        <listitem><para>Thread-specific caching enabled/disabled.  When there
-        are multiple threads, each thread uses a thread-specific cache for
-        objects up to a certain size.  Thread-specific caching allows many
-        allocations to be satisfied without performing any thread
-        synchronization, at the cost of increased memory use.  See the
-        <link
+        <listitem><para>Thread-specific caching (tcache) enabled/disabled.  When
+        there are multiple threads, each thread uses a tcache for objects up to
+        a certain size.  Thread-specific caching allows many allocations to be
+        satisfied without performing any thread synchronization, at the cost of
+        increased memory use.  See the <link
         linkend="opt.lg_tcache_max"><mallctl>opt.lg_tcache_max</mallctl></link>
         option for related tuning information.  This option is enabled by
         default unless running inside <ulink
-        url="http://valgrind.org/">Valgrind</ulink>.</para></listitem>
+        url="http://valgrind.org/">Valgrind</ulink>, in which case it is
+        forcefully disabled.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.lg_tcache_max">
         <term>
           <mallctl>opt.lg_tcache_max</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-tcache</option>]
         </term>
         <listitem><para>Maximum size class (log base 2) to cache in the
-        thread-specific cache.  At a minimum, all small size classes are
-        cached, and at a maximum all large size classes are cached.  The
+        thread-specific cache (tcache).  At a minimum, all small size classes
+        are cached, and at a maximum all large size classes are cached.  The
         default maximum is 32 KiB (2^15).</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof">
         <term>
           <mallctl>opt.prof</mallctl>
@@ -1180,14 +1144,15 @@
         linkend="opt.lg_prof_interval"><mallctl>opt.lg_prof_interval</mallctl></link>
         option for information on interval-triggered profile dumping, the <link
         linkend="opt.prof_gdump"><mallctl>opt.prof_gdump</mallctl></link>
         option for information on high-water-triggered profile dumping, and the
         <link linkend="opt.prof_final"><mallctl>opt.prof_final</mallctl></link>
         option for final profile dumping.  Profile output is compatible with
-        the included <command>pprof</command> Perl script, which originates
-        from the <ulink url="http://code.google.com/p/gperftools/">gperftools
+        the <command>jeprof</command> command, which is based on the
+        <command>pprof</command> that is developed as part of the <ulink
+        url="http://code.google.com/p/gperftools/">gperftools
         package</ulink>.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_prefix">
         <term>
           <mallctl>opt.prof_prefix</mallctl>
@@ -1203,29 +1168,44 @@
       </varlistentry>
 
       <varlistentry id="opt.prof_active">
         <term>
           <mallctl>opt.prof_active</mallctl>
           (<type>bool</type>)
-          <literal>rw</literal>
+          <literal>r-</literal>
           [<option>--enable-prof</option>]
         </term>
         <listitem><para>Profiling activated/deactivated.  This is a secondary
         control mechanism that makes it possible to start the application with
         profiling enabled (see the <link
         linkend="opt.prof"><mallctl>opt.prof</mallctl></link> option) but
         inactive, then toggle profiling at any time during program execution
         with the <link
         linkend="prof.active"><mallctl>prof.active</mallctl></link> mallctl.
         This option is enabled by default.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="opt.prof_thread_active_init">
+        <term>
+          <mallctl>opt.prof_thread_active_init</mallctl>
+          (<type>bool</type>)
+          <literal>r-</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Initial setting for <link
+        linkend="thread.prof.active"><mallctl>thread.prof.active</mallctl></link>
+        in newly created threads.  The initial setting for newly created threads
+        can also be changed during execution via the <link
+        linkend="prof.thread_active_init"><mallctl>prof.thread_active_init</mallctl></link>
+        mallctl.  This option is enabled by default.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="opt.lg_prof_sample">
         <term>
           <mallctl>opt.lg_prof_sample</mallctl>
-          (<type>ssize_t</type>)
+          (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-prof</option>]
         </term>
         <listitem><para>Average interval (log base 2) between allocation
         samples, as measured in bytes of allocation activity.  Increasing the
         sampling interval decreases profile fidelity, but also decreases the
@@ -1273,19 +1253,17 @@
         <term>
           <mallctl>opt.prof_gdump</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
           [<option>--enable-prof</option>]
         </term>
-        <listitem><para>Trigger a memory profile dump every time the total
-        virtual memory exceeds the previous maximum.  Profiles are dumped to
-        files named according to the pattern
-        <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap</filename>,
-        where <literal>&lt;prefix&gt;</literal> is controlled by the <link
-        linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
-        option.  This option is disabled by default.</para></listitem>
+        <listitem><para>Set the initial state of <link
+        linkend="prof.gdump"><mallctl>prof.gdump</mallctl></link>, which when
+        enabled triggers a memory profile dump every time the total virtual
+        memory exceeds the previous maximum.  This option is disabled by
+        default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_final">
         <term>
           <mallctl>opt.prof_final</mallctl>
           (<type>bool</type>)
@@ -1296,13 +1274,19 @@
         <citerefentry><refentrytitle>atexit</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> function to dump final memory
         usage to a file named according to the pattern
         <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap</filename>,
         where <literal>&lt;prefix&gt;</literal> is controlled by the <link
         linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
-        option.  This option is enabled by default.</para></listitem>
+        option.  Note that <function>atexit<parameter/></function> may allocate
+        memory during application initialization and then deadlock internally
+        when jemalloc in turn calls <function>atexit<parameter/></function>, so
+        this option is not univerally usable (though the application can
+        register its own <function>atexit<parameter/></function> function with
+        equivalent functionality).  This option is disabled by
+        default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_leak">
         <term>
           <mallctl>opt.prof_leak</mallctl>
           (<type>bool</type>)
@@ -1393,38 +1377,119 @@
           <literal>rw</literal>
           [<option>--enable-tcache</option>]
         </term>
         <listitem><para>Enable/disable calling thread's tcache.  The tcache is
         implicitly flushed as a side effect of becoming
         disabled (see <link
-        lenkend="thread.tcache.flush"><mallctl>thread.tcache.flush</mallctl></link>).
+        linkend="thread.tcache.flush"><mallctl>thread.tcache.flush</mallctl></link>).
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="thread.tcache.flush">
         <term>
           <mallctl>thread.tcache.flush</mallctl>
           (<type>void</type>)
           <literal>--</literal>
           [<option>--enable-tcache</option>]
         </term>
-        <listitem><para>Flush calling thread's tcache.  This interface releases
-        all cached objects and internal data structures associated with the
-        calling thread's thread-specific cache.  Ordinarily, this interface
+        <listitem><para>Flush calling thread's thread-specific cache (tcache).
+        This interface releases all cached objects and internal data structures
+        associated with the calling thread's tcache.  Ordinarily, this interface
         need not be called, since automatic periodic incremental garbage
         collection occurs, and the thread cache is automatically discarded when
         a thread exits.  However, garbage collection is triggered by allocation
         activity, so it is possible for a thread that stops
         allocating/deallocating to retain its cache indefinitely, in which case
         the developer may find manual flushing useful.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="thread.prof.name">
+        <term>
+          <mallctl>thread.prof.name</mallctl>
+          (<type>const char *</type>)
+          <literal>r-</literal> or
+          <literal>-w</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Get/set the descriptive name associated with the calling
+        thread in memory profile dumps.  An internal copy of the name string is
+        created, so the input string need not be maintained after this interface
+        completes execution.  The output string of this interface should be
+        copied for non-ephemeral uses, because multiple implementation details
+        can cause asynchronous string deallocation.  Furthermore, each
+        invocation of this interface can only read or write; simultaneous
+        read/write is not supported due to string lifetime limitations.  The
+        name string must nil-terminated and comprised only of characters in the
+        sets recognized
+        by <citerefentry><refentrytitle>isgraph</refentrytitle>
+        <manvolnum>3</manvolnum></citerefentry> and
+        <citerefentry><refentrytitle>isblank</refentrytitle>
+        <manvolnum>3</manvolnum></citerefentry>.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="thread.prof.active">
+        <term>
+          <mallctl>thread.prof.active</mallctl>
+          (<type>bool</type>)
+          <literal>rw</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Control whether sampling is currently active for the
+        calling thread.  This is an activation mechanism in addition to <link
+        linkend="prof.active"><mallctl>prof.active</mallctl></link>; both must
+        be active for the calling thread to sample.  This flag is enabled by
+        default.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="tcache.create">
+        <term>
+          <mallctl>tcache.create</mallctl>
+          (<type>unsigned</type>)
+          <literal>r-</literal>
+          [<option>--enable-tcache</option>]
+        </term>
+        <listitem><para>Create an explicit thread-specific cache (tcache) and
+        return an identifier that can be passed to the <link
+        linkend="MALLOCX_TCACHE"><constant>MALLOCX_TCACHE(<parameter>tc</parameter>)</constant></link>
+        macro to explicitly use the specified cache rather than the
+        automatically managed one that is used by default.  Each explicit cache
+        can be used by only one thread at a time; the application must assure
+        that this constraint holds.
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry id="tcache.flush">
+        <term>
+          <mallctl>tcache.flush</mallctl>
+          (<type>unsigned</type>)
+          <literal>-w</literal>
+          [<option>--enable-tcache</option>]
+        </term>
+        <listitem><para>Flush the specified thread-specific cache (tcache).  The
+        same considerations apply to this interface as to <link
+        linkend="thread.tcache.flush"><mallctl>thread.tcache.flush</mallctl></link>,
+        except that the tcache will never be automatically be discarded.
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry id="tcache.destroy">
+        <term>
+          <mallctl>tcache.destroy</mallctl>
+          (<type>unsigned</type>)
+          <literal>-w</literal>
+          [<option>--enable-tcache</option>]
+        </term>
+        <listitem><para>Flush the specified thread-specific cache (tcache) and
+        make the identifier available for use during a future tcache creation.
+        </para></listitem>
+      </varlistentry>
+
       <varlistentry id="arena.i.purge">
         <term>
           <mallctl>arena.&lt;i&gt;.purge</mallctl>
-          (<type>unsigned</type>)
+          (<type>void</type>)
           <literal>--</literal>
         </term>
         <listitem><para>Purge unused dirty pages for arena &lt;i&gt;, or for
         all arenas if &lt;i&gt; equals <link
         linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.
         </para></listitem>
@@ -1436,20 +1501,228 @@
           (<type>const char *</type>)
           <literal>rw</literal>
         </term>
         <listitem><para>Set the precedence of dss allocation as related to mmap
         allocation for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals
         <link
-        linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.  Note
-        that even during huge allocation this setting is read from the arena
-        that would be chosen for small or large allocation so that applications
-        can depend on consistent dss versus mmap allocation regardless of
-        allocation size.  See <link
-        linkend="opt.dss"><mallctl>opt.dss</mallctl></link> for supported
-        settings.
-        </para></listitem>
+        linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.  See
+        <link linkend="opt.dss"><mallctl>opt.dss</mallctl></link> for supported
+        settings.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="arena.i.lg_dirty_mult">
+        <term>
+          <mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl>
+          (<type>ssize_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Current per-arena minimum ratio (log base 2) of active
+        to dirty pages for arena &lt;i&gt;.  Each time this interface is set and
+        the ratio is increased, pages are synchronously purged as necessary to
+        impose the new ratio.  See <link
+        linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
+        for additional information.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="arena.i.chunk_hooks">
+        <term>
+          <mallctl>arena.&lt;i&gt;.chunk_hooks</mallctl>
+          (<type>chunk_hooks_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Get or set the chunk management hook functions for arena
+        &lt;i&gt;.  The functions must be capable of operating on all extant
+        chunks associated with arena &lt;i&gt;, usually by passing unknown
+        chunks to the replaced functions.  In practice, it is feasible to
+        control allocation for arenas created via <link
+        linkend="arenas.extend"><mallctl>arenas.extend</mallctl></link> such
+        that all chunks originate from an application-supplied chunk allocator
+        (by setting custom chunk hook functions just after arena creation), but
+        the automatically created arenas may have already created chunks prior
+        to the application having an opportunity to take over chunk
+        allocation.</para>
+
+        <programlisting language="C"><![CDATA[
+typedef struct {
+	chunk_alloc_t		*alloc;
+	chunk_dalloc_t		*dalloc;
+	chunk_commit_t		*commit;
+	chunk_decommit_t	*decommit;
+	chunk_purge_t		*purge;
+	chunk_split_t		*split;
+	chunk_merge_t		*merge;
+} chunk_hooks_t;]]></programlisting>
+        <para>The <type>chunk_hooks_t</type> structure comprises function
+        pointers which are described individually below.  jemalloc uses these
+        functions to manage chunk lifetime, which starts off with allocation of
+        mapped committed memory, in the simplest case followed by deallocation.
+        However, there are performance and platform reasons to retain chunks for
+        later reuse.  Cleanup attempts cascade from deallocation to decommit to
+        purging, which gives the chunk management functions opportunities to
+        reject the most permanent cleanup operations in favor of less permanent
+        (and often less costly) operations.  The chunk splitting and merging
+        operations can also be opted out of, but this is mainly intended to
+        support platforms on which virtual memory mappings provided by the
+        operating system kernel do not automatically coalesce and split, e.g.
+        Windows.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef void *<function>(chunk_alloc_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>alignment</parameter></paramdef>
+          <paramdef>bool *<parameter>zero</parameter></paramdef>
+          <paramdef>bool *<parameter>commit</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk allocation function conforms to the
+        <type>chunk_alloc_t</type> type and upon success returns a pointer to
+        <parameter>size</parameter> bytes of mapped memory on behalf of arena
+        <parameter>arena_ind</parameter> such that the chunk's base address is a
+        multiple of <parameter>alignment</parameter>, as well as setting
+        <parameter>*zero</parameter> to indicate whether the chunk is zeroed and
+        <parameter>*commit</parameter> to indicate whether the chunk is
+        committed.  Upon error the function returns <constant>NULL</constant>
+        and leaves <parameter>*zero</parameter> and
+        <parameter>*commit</parameter> unmodified.  The
+        <parameter>size</parameter> parameter is always a multiple of the chunk
+        size.  The <parameter>alignment</parameter> parameter is always a power
+        of two at least as large as the chunk size.  Zeroing is mandatory if
+        <parameter>*zero</parameter> is true upon function entry.  Committing is
+        mandatory if <parameter>*commit</parameter> is true upon function entry.
+        If <parameter>chunk</parameter> is not <constant>NULL</constant>, the
+        returned pointer must be <parameter>chunk</parameter> on success or
+        <constant>NULL</constant> on error.  Committed memory may be committed
+        in absolute terms as on a system that does not overcommit, or in
+        implicit terms as on a system that overcommits and satisfies physical
+        memory needs on demand via soft page faults.  Note that replacing the
+        default chunk allocation function makes the arena's <link
+        linkend="arena.i.dss"><mallctl>arena.&lt;i&gt;.dss</mallctl></link>
+        setting irrelevant.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_dalloc_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>bool <parameter>committed</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>
+        A chunk deallocation function conforms to the
+        <type>chunk_dalloc_t</type> type and deallocates a
+        <parameter>chunk</parameter> of given <parameter>size</parameter> with
+        <parameter>committed</parameter>/decommited memory as indicated, on
+        behalf of arena <parameter>arena_ind</parameter>, returning false upon
+        success.  If the function returns true, this indicates opt-out from
+        deallocation; the virtual memory mapping associated with the chunk
+        remains mapped, in the same commit state, and available for future use,
+        in which case it will be automatically retained for later reuse.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_commit_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>offset</parameter></paramdef>
+          <paramdef>size_t <parameter>length</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk commit function conforms to the
+        <type>chunk_commit_t</type> type and commits zeroed physical memory to
+        back pages within a <parameter>chunk</parameter> of given
+        <parameter>size</parameter> at <parameter>offset</parameter> bytes,
+        extending for <parameter>length</parameter> on behalf of arena
+        <parameter>arena_ind</parameter>, returning false upon success.
+        Committed memory may be committed in absolute terms as on a system that
+        does not overcommit, or in implicit terms as on a system that
+        overcommits and satisfies physical memory needs on demand via soft page
+        faults. If the function returns true, this indicates insufficient
+        physical memory to satisfy the request.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_decommit_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>offset</parameter></paramdef>
+          <paramdef>size_t <parameter>length</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk decommit function conforms to the
+        <type>chunk_decommit_t</type> type and decommits any physical memory
+        that is backing pages within a <parameter>chunk</parameter> of given
+        <parameter>size</parameter> at <parameter>offset</parameter> bytes,
+        extending for <parameter>length</parameter> on behalf of arena
+        <parameter>arena_ind</parameter>, returning false upon success, in which
+        case the pages will be committed via the chunk commit function before
+        being reused.  If the function returns true, this indicates opt-out from
+        decommit; the memory remains committed and available for future use, in
+        which case it will be automatically retained for later reuse.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_purge_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t<parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>offset</parameter></paramdef>
+          <paramdef>size_t <parameter>length</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk purge function conforms to the <type>chunk_purge_t</type>
+        type and optionally discards physical pages within the virtual memory
+        mapping associated with <parameter>chunk</parameter> of given
+        <parameter>size</parameter> at <parameter>offset</parameter> bytes,
+        extending for <parameter>length</parameter> on behalf of arena
+        <parameter>arena_ind</parameter>, returning false if pages within the
+        purged virtual memory range will be zero-filled the next time they are
+        accessed.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_split_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>size_a</parameter></paramdef>
+          <paramdef>size_t <parameter>size_b</parameter></paramdef>
+          <paramdef>bool <parameter>committed</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk split function conforms to the <type>chunk_split_t</type>
+        type and optionally splits <parameter>chunk</parameter> of given
+        <parameter>size</parameter> into two adjacent chunks, the first of
+        <parameter>size_a</parameter> bytes, and the second of
+        <parameter>size_b</parameter> bytes, operating on
+        <parameter>committed</parameter>/decommitted memory as indicated, on
+        behalf of arena <parameter>arena_ind</parameter>, returning false upon
+        success.  If the function returns true, this indicates that the chunk
+        remains unsplit and therefore should continue to be operated on as a
+        whole.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_merge_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk_a</parameter></paramdef>
+          <paramdef>size_t <parameter>size_a</parameter></paramdef>
+          <paramdef>void *<parameter>chunk_b</parameter></paramdef>
+          <paramdef>size_t <parameter>size_b</parameter></paramdef>
+          <paramdef>bool <parameter>committed</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk merge function conforms to the <type>chunk_merge_t</type>
+        type and optionally merges adjacent chunks,
+        <parameter>chunk_a</parameter> of given <parameter>size_a</parameter>
+        and <parameter>chunk_b</parameter> of given
+        <parameter>size_b</parameter> into one contiguous chunk, operating on
+        <parameter>committed</parameter>/decommitted memory as indicated, on
+        behalf of arena <parameter>arena_ind</parameter>, returning false upon
+        success.  If the function returns true, this indicates that the chunks
+        remain distinct mappings and therefore should continue to be operated on
+        independently.</para>
+        </listitem>
       </varlistentry>
 
       <varlistentry id="arenas.narenas">
         <term>
           <mallctl>arenas.narenas</mallctl>
           (<type>unsigned</type>)
@@ -1467,12 +1740,26 @@
         <listitem><para>An array of <link
         linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>
         booleans.  Each boolean indicates whether the corresponding arena is
         initialized.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="arenas.lg_dirty_mult">
+        <term>
+          <mallctl>arenas.lg_dirty_mult</mallctl>
+          (<type>ssize_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Current default per-arena minimum ratio (log base 2) of
+        active to dirty pages, used to initialize <link
+        linkend="arena.i.lg_dirty_mult"><mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl></link>
+        during arena creation.  See <link
+        linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
+        for additional information.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="arenas.quantum">
         <term>
           <mallctl>arenas.quantum</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
         </term>
@@ -1545,13 +1832,13 @@
         <listitem><para>Number of bytes per page run.</para></listitem>
       </varlistentry>
 
       <varlistentry id="arenas.nlruns">
         <term>
           <mallctl>arenas.nlruns</mallctl>
-          (<type>size_t</type>)
+          (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Total number of large size classes.</para></listitem>
       </varlistentry>
 
       <varlistentry id="arenas.lrun.i.size">
@@ -1561,44 +1848,68 @@
           <literal>r-</literal>
         </term>
         <listitem><para>Maximum size supported by this large size
         class.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="arenas.purge">
+      <varlistentry id="arenas.nhchunks">
         <term>
-          <mallctl>arenas.purge</mallctl>
+          <mallctl>arenas.nhchunks</mallctl>
           (<type>unsigned</type>)
-          <literal>-w</literal>
+          <literal>r-</literal>
         </term>
-        <listitem><para>Purge unused dirty pages for the specified arena, or
-        for all arenas if none is specified.</para></listitem>
+        <listitem><para>Total number of huge size classes.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="arenas.hchunk.i.size">
+        <term>
+          <mallctl>arenas.hchunk.&lt;i&gt;.size</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Maximum size supported by this huge size
+        class.</para></listitem>
       </varlistentry>
 
       <varlistentry id="arenas.extend">
         <term>
           <mallctl>arenas.extend</mallctl>
           (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Extend the array of arenas by appending a new arena,
         and returning the new arena index.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="prof.thread_active_init">
+        <term>
+          <mallctl>prof.thread_active_init</mallctl>
+          (<type>bool</type>)
+          <literal>rw</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Control the initial setting for <link
+        linkend="thread.prof.active"><mallctl>thread.prof.active</mallctl></link>
+        in newly created threads.  See the <link
+        linkend="opt.prof_thread_active_init"><mallctl>opt.prof_thread_active_init</mallctl></link>
+        option for additional information.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="prof.active">
         <term>
           <mallctl>prof.active</mallctl>
           (<type>bool</type>)
           <literal>rw</literal>
           [<option>--enable-prof</option>]
         </term>
         <listitem><para>Control whether sampling is currently active.  See the
         <link
         linkend="opt.prof_active"><mallctl>opt.prof_active</mallctl></link>
-        option for additional information.
-        </para></listitem>
+        option for additional information, as well as the interrelated <link
+        linkend="thread.prof.active"><mallctl>thread.prof.active</mallctl></link>
+        mallctl.</para></listitem>
       </varlistentry>
 
       <varlistentry id="prof.dump">
         <term>
           <mallctl>prof.dump</mallctl>
           (<type>const char *</type>)
@@ -1611,12 +1922,55 @@
         where <literal>&lt;prefix&gt;</literal> is controlled by the
         <link
         linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
         option.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="prof.gdump">
+        <term>
+          <mallctl>prof.gdump</mallctl>
+          (<type>bool</type>)
+          <literal>rw</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>When enabled, trigger a memory profile dump every time
+        the total virtual memory exceeds the previous maximum.  Profiles are
+        dumped to files named according to the pattern
+        <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap</filename>,
+        where <literal>&lt;prefix&gt;</literal> is controlled by the <link
+        linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
+        option.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="prof.reset">
+        <term>
+          <mallctl>prof.reset</mallctl>
+          (<type>size_t</type>)
+          <literal>-w</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Reset all memory profile statistics, and optionally
+        update the sample rate (see <link
+        linkend="opt.lg_prof_sample"><mallctl>opt.lg_prof_sample</mallctl></link>
+        and <link
+        linkend="prof.lg_sample"><mallctl>prof.lg_sample</mallctl></link>).
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry id="prof.lg_sample">
+        <term>
+          <mallctl>prof.lg_sample</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Get the current sample rate (see <link
+        linkend="opt.lg_prof_sample"><mallctl>opt.lg_prof_sample</mallctl></link>).
+        </para></listitem>
+      </varlistentry>
+
       <varlistentry id="prof.interval">
         <term>
           <mallctl>prof.interval</mallctl>
           (<type>uint64_t</type>)
           <literal>r-</literal>
           [<option>--enable-prof</option>]
@@ -1634,15 +1988,14 @@
           (<type>size_t *</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Pointer to a counter that contains an approximate count
         of the current number of bytes in active pages.  The estimate may be
-        high, but never low, because each arena rounds up to the nearest
-        multiple of the chunk size when computing its contribution to the
-        counter.  Note that the <link
+        high, but never low, because each arena rounds up when computing its
+        contribution to the counter.  Note that the <link
         linkend="epoch"><mallctl>epoch</mallctl></link> mallctl has no bearing
         on this counter.  Furthermore, counter consistency is maintained via
         atomic operations, so it is necessary to use an atomic operation in
         order to guarantee a consistent read when dereferencing the pointer.
         </para></listitem>
       </varlistentry>
@@ -1667,94 +2020,62 @@
         </term>
         <listitem><para>Total number of bytes in active pages allocated by the
         application.  This is a multiple of the page size, and greater than or
         equal to <link
         linkend="stats.allocated"><mallctl>stats.allocated</mallctl></link>.
         This does not include <link linkend="stats.arenas.i.pdirty">
-        <mallctl>stats.arenas.&lt;i&gt;.pdirty</mallctl></link> and pages
+        <mallctl>stats.arenas.&lt;i&gt;.pdirty</mallctl></link>, nor pages
         entirely devoted to allocator metadata.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="stats.mapped">
+      <varlistentry id="stats.metadata">
         <term>
-          <mallctl>stats.mapped</mallctl>
+          <mallctl>stats.metadata</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
-        <listitem><para>Total number of bytes in chunks mapped on behalf of the
-        application.  This is a multiple of the chunk size, and is at least as
-        large as <link
-        linkend="stats.active"><mallctl>stats.active</mallctl></link>.  This
-        does not include inactive chunks.</para></listitem>
+        <listitem><para>Total number of bytes dedicated to metadata, which
+        comprise base allocations used for bootstrap-sensitive internal
+        allocator data structures, arena chunk headers (see <link
+        linkend="stats.arenas.i.metadata.mapped"><mallctl>stats.arenas.&lt;i&gt;.metadata.mapped</mallctl></link>),
+        and internal allocations (see <link
+        linkend="stats.arenas.i.metadata.allocated"><mallctl>stats.arenas.&lt;i&gt;.metadata.allocated</mallctl></link>).</para></listitem>
       </varlistentry>
 
-      <varlistentry id="stats.chunks.current">
+      <varlistentry id="stats.resident">
         <term>
-          <mallctl>stats.chunks.current</mallctl>
+          <mallctl>stats.resident</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
-        <listitem><para>Total number of chunks actively mapped on behalf of the
-        application.  This does not include inactive chunks.
-        </para></listitem>
+        <listitem><para>Maximum number of bytes in physically resident data
+        pages mapped by the allocator, comprising all pages dedicated to
+        allocator metadata, pages backing active allocations, and unused dirty
+        pages.  This is a maximum rather than precise because pages may not
+        actually be physically resident if they correspond to demand-zeroed
+        virtual memory that has not yet been touched.  This is a multiple of the
+        page size, and is larger than <link
+        linkend="stats.active"><mallctl>stats.active</mallctl></link>.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="stats.chunks.total">
-        <term>
-          <mallctl>stats.chunks.total</mallctl>
-          (<type>uint64_t</type>)
-          <literal>r-</literal>
-          [<option>--enable-stats</option>]
-        </term>
-        <listitem><para>Cumulative number of chunks allocated.</para></listitem>
-      </varlistentry>
-
-      <varlistentry id="stats.chunks.high">
-        <term>
-          <mallctl>stats.chunks.high</mallctl>
-          (<type>size_t</type>)
-          <literal>r-</literal>
-          [<option>--enable-stats</option>]
-        </term>
-        <listitem><para>Maximum number of active chunks at any time thus far.
-        </para></listitem>
-      </varlistentry>
-
-      <varlistentry id="stats.huge.allocated">
+      <varlistentry id="stats.mapped">
         <term>
-          <mallctl>stats.huge.allocated</mallctl>
+          <mallctl>stats.mapped</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
-        <listitem><para>Number of bytes currently allocated by huge objects.
-        </para></listitem>
-      </varlistentry>
-
-      <varlistentry id="stats.huge.nmalloc">
-        <term>
-          <mallctl>stats.huge.nmalloc</mallctl>
-          (<type>uint64_t</type>)
-          <literal>r-</literal>
-          [<option>--enable-stats</option>]
-        </term>
-        <listitem><para>Cumulative number of huge allocation requests.
-        </para></listitem>
-      </varlistentry>
-
-      <varlistentry id="stats.huge.ndalloc">
-        <term>
-          <mallctl>stats.huge.ndalloc</mallctl>
-          (<type>uint64_t</type>)
-          <literal>r-</literal>
-          [<option>--enable-stats</option>]
-        </term>
-        <listitem><para>Cumulative number of huge deallocation requests.
-        </para></listitem>
+        <listitem><para>Total number of bytes in active chunks mapped by the
+        allocator.  This is a multiple of the chunk size, and is larger than
+        <link linkend="stats.active"><mallctl>stats.active</mallctl></link>.
+        This does not include inactive chunks, even those that contain unused
+        dirty pages, which means that there is no strict ordering between this
+        and <link
+        linkend="stats.resident"><mallctl>stats.resident</mallctl></link>.</para></listitem>
       </varlistentry>
 
       <varlistentry id="stats.arenas.i.dss">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.dss</mallctl>
           (<type>const char *</type>)
@@ -1765,12 +2086,24 @@
         related to <citerefentry><refentrytitle>mmap</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> allocation.  See <link
         linkend="opt.dss"><mallctl>opt.dss</mallctl></link> for details.
         </para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.lg_dirty_mult">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.lg_dirty_mult</mallctl>
+          (<type>ssize_t</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Minimum ratio (log base 2) of active to dirty pages.
+        See <link
+        linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
+        for details.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.nthreads">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.nthreads</mallctl>
           (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
@@ -1806,12 +2139,44 @@
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Number of mapped bytes.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.metadata.mapped">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.metadata.mapped</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Number of mapped bytes in arena chunk headers, which
+        track the states of the non-metadata pages.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.metadata.allocated">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.metadata.allocated</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Number of bytes dedicated to internal allocations.
+        Internal allocations differ from application-originated allocations in
+        that they are for internal use, and that they are omitted from heap
+        profiles.  This statistic is reported separately from <link
+        linkend="stats.metadata"><mallctl>stats.metadata</mallctl></link> and
+        <link
+        linkend="stats.arenas.i.metadata.mapped"><mallctl>stats.arenas.&lt;i&gt;.metadata.mapped</mallctl></link>
+        because it overlaps with e.g. the <link
+        linkend="stats.allocated"><mallctl>stats.allocated</mallctl></link> and
+        <link linkend="stats.active"><mallctl>stats.active</mallctl></link>
+        statistics, whereas the other metadata statistics do
+        not.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.npurge">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.npurge</mallctl>
           (<type>uint64_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
@@ -1927,21 +2292,54 @@
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Cumulative number of large allocation requests.
         </para></listitem>
       </varlistentry>
 
-      <varlistentry id="stats.arenas.i.bins.j.allocated">
+      <varlistentry id="stats.arenas.i.huge.allocated">
         <term>
-          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.allocated</mallctl>
+          <mallctl>stats.arenas.&lt;i&gt;.huge.allocated</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
-        <listitem><para>Current number of bytes allocated by
-        bin.</para></listitem>
+        <listitem><para>Number of bytes currently allocated by huge objects.
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.huge.nmalloc">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.huge.nmalloc</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of huge allocation requests served
+        directly by the arena.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.huge.ndalloc">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.huge.ndalloc</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of huge deallocation requests served
+        directly by the arena.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.huge.nrequests">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.huge.nrequests</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of huge allocation requests.
+        </para></listitem>
       </varlistentry>
 
       <varlistentry id="stats.arenas.i.bins.j.nmalloc">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nmalloc</mallctl>
           (<type>uint64_t</type>)
@@ -1971,12 +2369,23 @@
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Cumulative number of allocation
         requests.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.bins.j.curregs">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curregs</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Current number of regions for this size
+        class.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.bins.j.nfills">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nfills</mallctl>
           (<type>uint64_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option> <option>--enable-tcache</option>]
@@ -2065,12 +2474,56 @@
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Current number of runs for this size class.
         </para></listitem>
       </varlistentry>
+
+      <varlistentry id="stats.arenas.i.hchunks.j.nmalloc">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nmalloc</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of allocation requests for this size
+        class served directly by the arena.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.hchunks.j.ndalloc">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.ndalloc</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of deallocation requests for this
+        size class served directly by the arena.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.hchunks.j.nrequests">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nrequests</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of allocation requests for this size
+        class.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.hchunks.j.curhchunks">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.curhchunks</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Current number of huge allocations for this size class.
+        </para></listitem>
+      </varlistentry>
     </variablelist>
   </refsect1>
   <refsect1 id="debugging_malloc_problems">
     <title>DEBUGGING MALLOC PROBLEMS</title>
     <para>When debugging, it is a good idea to configure/build jemalloc with
     the <option>--enable-debug</option> and <option>--enable-fill</option>
@@ -2250,48 +2703,12 @@
       </para>
 
       <para>The <function>malloc_usable_size<parameter/></function> function
       returns the usable size of the allocation pointed to by
       <parameter>ptr</parameter>.  </para>
     </refsect2>
-    <refsect2>
-      <title>Experimental API</title>
-      <para>The <function>allocm<parameter/></function>,
-      <function>rallocm<parameter/></function>,
-      <function>sallocm<parameter/></function>,
-      <function>dallocm<parameter/></function>, and
-      <function>nallocm<parameter/></function> functions return
-      <constant>ALLOCM_SUCCESS</constant> on success; otherwise they return an
-      error value.  The <function>allocm<parameter/></function>,
-      <function>rallocm<parameter/></function>, and
-      <function>nallocm<parameter/></function> functions will fail if:
-        <variablelist>
-          <varlistentry>
-            <term><errorname>ALLOCM_ERR_OOM</errorname></term>
-
-            <listitem><para>Out of memory.  Insufficient contiguous memory was
-            available to service the allocation request.  The
-            <function>allocm<parameter/></function> function additionally sets
-            <parameter>*ptr</parameter> to <constant>NULL</constant>, whereas
-            the <function>rallocm<parameter/></function> function leaves
-            <constant>*ptr</constant> unmodified.</para></listitem>
-          </varlistentry>
-        </variablelist>
-      The <function>rallocm<parameter/></function> function will also
-      fail if:
-        <variablelist>
-          <varlistentry>
-            <term><errorname>ALLOCM_ERR_NOT_MOVED</errorname></term>
-
-            <listitem><para><constant>ALLOCM_NO_MOVE</constant> was specified,
-            but the reallocation request could not be serviced without moving
-            the object.</para></listitem>
-          </varlistentry>
-        </variablelist>
-      </para>
-    </refsect2>
   </refsect1>
   <refsect1 id="environment">
     <title>ENVIRONMENT</title>
     <para>The following environment variable affects the execution of the
     allocation functions:
       <variablelist>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/jemalloc.xml.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/jemalloc.xml.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/jemalloc.xml.in	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/jemalloc.xml.in	2016-05-06 15:11:36.000000000 +0800
@@ -35,37 +35,32 @@
     <refname>free</refname>
     <refname>mallocx</refname>
     <refname>rallocx</refname>
     <refname>xallocx</refname>
     <refname>sallocx</refname>
     <refname>dallocx</refname>
+    <refname>sdallocx</refname>
     <refname>nallocx</refname>
     <refname>mallctl</refname>
     <refname>mallctlnametomib</refname>
     <refname>mallctlbymib</refname>
     <refname>malloc_stats_print</refname>
     <refname>malloc_usable_size</refname>
-    <refname>allocm</refname>
-    <refname>rallocm</refname>
-    <refname>sallocm</refname>
-    <refname>dallocm</refname>
-    <refname>nallocm</refname>
     -->
     <refpurpose>general purpose memory allocation functions</refpurpose>
   </refnamediv>
   <refsect1 id="library">
     <title>LIBRARY</title>
     <para>This manual describes jemalloc @jemalloc_version@.  More information
     can be found at the <ulink
     url="http://www.canonware.com/jemalloc/">jemalloc website</ulink>.</para>
   </refsect1>
   <refsynopsisdiv>
     <title>SYNOPSIS</title>
     <funcsynopsis>
-      <funcsynopsisinfo>#include &lt;<filename class="headerfile">stdlib.h</filename>&gt;
-#include &lt;<filename class="headerfile">jemalloc/jemalloc.h</filename>&gt;</funcsynopsisinfo>
+      <funcsynopsisinfo>#include &lt;<filename class="headerfile">jemalloc/jemalloc.h</filename>&gt;</funcsynopsisinfo>
       <refsect2>
         <title>Standard API</title>
         <funcprototype>
           <funcdef>void *<function>malloc</function></funcdef>
           <paramdef>size_t <parameter>size</parameter></paramdef>
         </funcprototype>
@@ -123,12 +118,18 @@
         <funcprototype>
           <funcdef>void <function>dallocx</function></funcdef>
           <paramdef>void *<parameter>ptr</parameter></paramdef>
           <paramdef>int <parameter>flags</parameter></paramdef>
         </funcprototype>
         <funcprototype>
+          <funcdef>void <function>sdallocx</function></funcdef>
+          <paramdef>void *<parameter>ptr</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>int <parameter>flags</parameter></paramdef>
+        </funcprototype>
+        <funcprototype>
           <funcdef>size_t <function>nallocx</function></funcdef>
           <paramdef>size_t <parameter>size</parameter></paramdef>
           <paramdef>int <parameter>flags</parameter></paramdef>
         </funcprototype>
         <funcprototype>
           <funcdef>int <function>mallctl</function></funcdef>
@@ -169,47 +170,12 @@
           <funcdef>void <function>(*malloc_message)</function></funcdef>
           <paramdef>void *<parameter>cbopaque</parameter></paramdef>
           <paramdef>const char *<parameter>s</parameter></paramdef>
         </funcprototype>
         <para><type>const char *</type><varname>malloc_conf</varname>;</para>
       </refsect2>
-      <refsect2>
-      <title>Experimental API</title>
-        <funcprototype>
-          <funcdef>int <function>allocm</function></funcdef>
-          <paramdef>void **<parameter>ptr</parameter></paramdef>
-          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
-          <paramdef>size_t <parameter>size</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-        <funcprototype>
-          <funcdef>int <function>rallocm</function></funcdef>
-          <paramdef>void **<parameter>ptr</parameter></paramdef>
-          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
-          <paramdef>size_t <parameter>size</parameter></paramdef>
-          <paramdef>size_t <parameter>extra</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-        <funcprototype>
-          <funcdef>int <function>sallocm</function></funcdef>
-          <paramdef>const void *<parameter>ptr</parameter></paramdef>
-          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-        <funcprototype>
-          <funcdef>int <function>dallocm</function></funcdef>
-          <paramdef>void *<parameter>ptr</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-        <funcprototype>
-          <funcdef>int <function>nallocm</function></funcdef>
-          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
-          <paramdef>size_t <parameter>size</parameter></paramdef>
-          <paramdef>int <parameter>flags</parameter></paramdef>
-        </funcprototype>
-      </refsect2>
     </funcsynopsis>
   </refsynopsisdiv>
   <refsect1 id="description">
     <title>DESCRIPTION</title>
     <refsect2>
       <title>Standard API</title>
@@ -226,21 +192,21 @@
       <parameter>number</parameter> * <parameter>size</parameter>, with the
       exception that the allocated memory is explicitly initialized to zero
       bytes.</para>
 
       <para>The <function>posix_memalign<parameter/></function> function
       allocates <parameter>size</parameter> bytes of memory such that the
-      allocation's base address is an even multiple of
+      allocation's base address is a multiple of
       <parameter>alignment</parameter>, and returns the allocation in the value
       pointed to by <parameter>ptr</parameter>.  The requested
-      <parameter>alignment</parameter> must be a power of 2 at least as large
-      as <code language="C">sizeof(<type>void *</type>)</code>.</para>
+      <parameter>alignment</parameter> must be a power of 2 at least as large as
+      <code language="C">sizeof(<type>void *</type>)</code>.</para>
 
       <para>The <function>aligned_alloc<parameter/></function> function
       allocates <parameter>size</parameter> bytes of memory such that the
-      allocation's base address is an even multiple of
+      allocation's base address is a multiple of
       <parameter>alignment</parameter>.  The requested
       <parameter>alignment</parameter> must be a power of 2.  Behavior is
       undefined if <parameter>size</parameter> is not an integral multiple of
       <parameter>alignment</parameter>.</para>
 
       <para>The <function>realloc<parameter/></function> function changes the
@@ -265,58 +231,81 @@
     <refsect2>
       <title>Non-standard API</title>
       <para>The <function>mallocx<parameter/></function>,
       <function>rallocx<parameter/></function>,
       <function>xallocx<parameter/></function>,
       <function>sallocx<parameter/></function>,
-      <function>dallocx<parameter/></function>, and
+      <function>dallocx<parameter/></function>,
+      <function>sdallocx<parameter/></function>, and
       <function>nallocx<parameter/></function> functions all have a
       <parameter>flags</parameter> argument that can be used to specify
       options.  The functions only check the options that are contextually
       relevant.  Use bitwise or (<code language="C">|</code>) operations to
       specify one or more of the following:
         <variablelist>
-          <varlistentry>
+          <varlistentry id="MALLOCX_LG_ALIGN">
             <term><constant>MALLOCX_LG_ALIGN(<parameter>la</parameter>)
             </constant></term>
 
             <listitem><para>Align the memory allocation to start at an address
             that is a multiple of <code language="C">(1 &lt;&lt;
             <parameter>la</parameter>)</code>.  This macro does not validate
             that <parameter>la</parameter> is within the valid
             range.</para></listitem>
           </varlistentry>
-          <varlistentry>
+          <varlistentry id="MALLOCX_ALIGN">
             <term><constant>MALLOCX_ALIGN(<parameter>a</parameter>)
             </constant></term>
 
             <listitem><para>Align the memory allocation to start at an address
             that is a multiple of <parameter>a</parameter>, where
             <parameter>a</parameter> is a power of two.  This macro does not
             validate that <parameter>a</parameter> is a power of 2.
             </para></listitem>
           </varlistentry>
-          <varlistentry>
+          <varlistentry id="MALLOCX_ZERO">
             <term><constant>MALLOCX_ZERO</constant></term>
 
             <listitem><para>Initialize newly allocated memory to contain zero
             bytes.  In the growing reallocation case, the real size prior to
             reallocation defines the boundary between untouched bytes and those
             that are initialized to contain zero bytes.  If this macro is
             absent, newly allocated memory is uninitialized.</para></listitem>
           </varlistentry>
-          <varlistentry>
+          <varlistentry id="MALLOCX_TCACHE">
+            <term><constant>MALLOCX_TCACHE(<parameter>tc</parameter>)
+            </constant></term>
+
+            <listitem><para>Use the thread-specific cache (tcache) specified by
+            the identifier <parameter>tc</parameter>, which must have been
+            acquired via the <link
+            linkend="tcache.create"><mallctl>tcache.create</mallctl></link>
+            mallctl.  This macro does not validate that
+            <parameter>tc</parameter> specifies a valid
+            identifier.</para></listitem>
+          </varlistentry>
+          <varlistentry id="MALLOC_TCACHE_NONE">
+            <term><constant>MALLOCX_TCACHE_NONE</constant></term>
+
+            <listitem><para>Do not use a thread-specific cache (tcache).  Unless
+            <constant>MALLOCX_TCACHE(<parameter>tc</parameter>)</constant> or
+            <constant>MALLOCX_TCACHE_NONE</constant> is specified, an
+            automatically managed tcache will be used under many circumstances.
+            This macro cannot be used in the same <parameter>flags</parameter>
+            argument as
+            <constant>MALLOCX_TCACHE(<parameter>tc</parameter>)</constant>.</para></listitem>
+          </varlistentry>
+          <varlistentry id="MALLOCX_ARENA">
             <term><constant>MALLOCX_ARENA(<parameter>a</parameter>)
             </constant></term>
 
             <listitem><para>Use the arena specified by the index
-            <parameter>a</parameter> (and by necessity bypass the thread
-            cache).  This macro has no effect for huge regions, nor for regions
-            that were allocated via an arena other than the one specified.
-            This macro does not validate that <parameter>a</parameter>
-            specifies an arena index in the valid range.</para></listitem>
+            <parameter>a</parameter>.  This macro has no effect for regions that
+            were allocated via an arena other than the one specified.  This
+            macro does not validate that <parameter>a</parameter> specifies an
+            arena index in the valid range.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
       <para>The <function>mallocx<parameter/></function> function allocates at
       least <parameter>size</parameter> bytes of memory, and returns a pointer
@@ -349,12 +338,21 @@
       real size of the allocation at <parameter>ptr</parameter>.</para>
 
       <para>The <function>dallocx<parameter/></function> function causes the
       memory referenced by <parameter>ptr</parameter> to be made available for
       future allocations.</para>
 
+      <para>The <function>sdallocx<parameter/></function> function is an
+      extension of <function>dallocx<parameter/></function> with a
+      <parameter>size</parameter> parameter to allow the caller to pass in the
+      allocation size as an optimization.  The minimum valid input size is the
+      original requested size of the allocation, and the maximum valid input
+      size is the corresponding value returned by
+      <function>nallocx<parameter/></function> or
+      <function>sallocx<parameter/></function>.</para>
+
       <para>The <function>nallocx<parameter/></function> function allocates no
       memory, but it performs the same size computation as the
       <function>mallocx<parameter/></function> function, and returns the real
       size of the allocation that would result from the equivalent
       <function>mallocx<parameter/></function> function call.  Behavior is
       undefined if <parameter>size</parameter> is <constant>0</constant>, or if
@@ -427,17 +425,18 @@
       <function>malloc_message<parameter/></function> uses the
       <function>mallctl*<parameter/></function> functions internally, so
       inconsistent statistics can be reported if multiple threads use these
       functions simultaneously.  If <option>--enable-stats</option> is
       specified during configuration, &ldquo;m&rdquo; and &ldquo;a&rdquo; can
       be specified to omit merged arena and per arena statistics, respectively;
-      &ldquo;b&rdquo; and &ldquo;l&rdquo; can be specified to omit per size
-      class statistics for bins and large objects, respectively.  Unrecognized
-      characters are silently ignored.  Note that thread caching may prevent
-      some statistics from being completely up to date, since extra locking
-      would be required to merge counters that track thread cache operations.
+      &ldquo;b&rdquo;, &ldquo;l&rdquo;, and &ldquo;h&rdquo; can be specified to
+      omit per size class statistics for bins, large objects, and huge objects,
+      respectively.  Unrecognized characters are silently ignored.  Note that
+      thread caching may prevent some statistics from being completely up to
+      date, since extra locking would be required to merge counters that track
+      thread cache operations.
       </para>
 
       <para>The <function>malloc_usable_size<parameter/></function> function
       returns the usable size of the allocation pointed to by
       <parameter>ptr</parameter>.  The return value may be larger than the size
       that was requested during allocation.  The
@@ -446,122 +445,12 @@
       it is provided solely as a tool for introspection purposes.  Any
       discrepancy between the requested allocation size and the size reported
       by <function>malloc_usable_size<parameter/></function> should not be
       depended on, since such behavior is entirely implementation-dependent.
       </para>
     </refsect2>
-    <refsect2>
-      <title>Experimental API</title>
-      <para>The experimental API is subject to change or removal without regard
-      for backward compatibility.  If <option>--disable-experimental</option>
-      is specified during configuration, the experimental API is
-      omitted.</para>
-
-      <para>The <function>allocm<parameter/></function>,
-      <function>rallocm<parameter/></function>,
-      <function>sallocm<parameter/></function>,
-      <function>dallocm<parameter/></function>, and
-      <function>nallocm<parameter/></function> functions all have a
-      <parameter>flags</parameter> argument that can be used to specify
-      options.  The functions only check the options that are contextually
-      relevant.  Use bitwise or (<code language="C">|</code>) operations to
-      specify one or more of the following:
-        <variablelist>
-          <varlistentry>
-            <term><constant>ALLOCM_LG_ALIGN(<parameter>la</parameter>)
-            </constant></term>
-
-            <listitem><para>Align the memory allocation to start at an address
-            that is a multiple of <code language="C">(1 &lt;&lt;
-            <parameter>la</parameter>)</code>.  This macro does not validate
-            that <parameter>la</parameter> is within the valid
-            range.</para></listitem>
-          </varlistentry>
-          <varlistentry>
-            <term><constant>ALLOCM_ALIGN(<parameter>a</parameter>)
-            </constant></term>
-
-            <listitem><para>Align the memory allocation to start at an address
-            that is a multiple of <parameter>a</parameter>, where
-            <parameter>a</parameter> is a power of two.  This macro does not
-            validate that <parameter>a</parameter> is a power of 2.
-            </para></listitem>
-          </varlistentry>
-          <varlistentry>
-            <term><constant>ALLOCM_ZERO</constant></term>
-
-            <listitem><para>Initialize newly allocated memory to contain zero
-            bytes.  In the growing reallocation case, the real size prior to
-            reallocation defines the boundary between untouched bytes and those
-            that are initialized to contain zero bytes.  If this macro is
-            absent, newly allocated memory is uninitialized.</para></listitem>
-          </varlistentry>
-          <varlistentry>
-            <term><constant>ALLOCM_NO_MOVE</constant></term>
-
-            <listitem><para>For reallocation, fail rather than moving the
-            object.  This constraint can apply to both growth and
-            shrinkage.</para></listitem>
-          </varlistentry>
-          <varlistentry>
-            <term><constant>ALLOCM_ARENA(<parameter>a</parameter>)
-            </constant></term>
-
-            <listitem><para>Use the arena specified by the index
-            <parameter>a</parameter> (and by necessity bypass the thread
-            cache).  This macro has no effect for huge regions, nor for regions
-            that were allocated via an arena other than the one specified.
-            This macro does not validate that <parameter>a</parameter>
-            specifies an arena index in the valid range.</para></listitem>
-          </varlistentry>
-        </variablelist>
-      </para>
-
-      <para>The <function>allocm<parameter/></function> function allocates at
-      least <parameter>size</parameter> bytes of memory, sets
-      <parameter>*ptr</parameter> to the base address of the allocation, and
-      sets <parameter>*rsize</parameter> to the real size of the allocation if
-      <parameter>rsize</parameter> is not <constant>NULL</constant>.  Behavior
-      is undefined if <parameter>size</parameter> is <constant>0</constant>, or
-      if request size overflows due to size class and/or alignment
-      constraints.</para>
-
-      <para>The <function>rallocm<parameter/></function> function resizes the
-      allocation at <parameter>*ptr</parameter> to be at least
-      <parameter>size</parameter> bytes, sets <parameter>*ptr</parameter> to
-      the base address of the allocation if it moved, and sets
-      <parameter>*rsize</parameter> to the real size of the allocation if
-      <parameter>rsize</parameter> is not <constant>NULL</constant>.  If
-      <parameter>extra</parameter> is non-zero, an attempt is made to resize
-      the allocation to be at least <code
-      language="C">(<parameter>size</parameter> +
-      <parameter>extra</parameter>)</code> bytes, though inability to allocate
-      the extra byte(s) will not by itself result in failure.  Behavior is
-      undefined if <parameter>size</parameter> is <constant>0</constant>, if
-      request size overflows due to size class and/or alignment constraints, or
-      if <code language="C">(<parameter>size</parameter> +
-      <parameter>extra</parameter> &gt;
-      <constant>SIZE_T_MAX</constant>)</code>.</para>
-
-      <para>The <function>sallocm<parameter/></function> function sets
-      <parameter>*rsize</parameter> to the real size of the allocation.</para>
-
-      <para>The <function>dallocm<parameter/></function> function causes the
-      memory referenced by <parameter>ptr</parameter> to be made available for
-      future allocations.</para>
-
-      <para>The <function>nallocm<parameter/></function> function allocates no
-      memory, but it performs the same size computation as the
-      <function>allocm<parameter/></function> function, and if
-      <parameter>rsize</parameter> is not <constant>NULL</constant> it sets
-      <parameter>*rsize</parameter> to the real size of the allocation that
-      would result from the equivalent <function>allocm<parameter/></function>
-      function call.  Behavior is undefined if <parameter>size</parameter> is
-      <constant>0</constant>, or if request size overflows due to size class
-      and/or alignment constraints.</para>
-    </refsect2>
   </refsect1>
   <refsect1 id="tuning">
     <title>TUNING</title>
     <para>Once, when the first call is made to one of the memory allocation
     routines, the allocator initializes its internals based in part on various
     options that can be specified at compile- or run-time.</para>
@@ -595,14 +484,16 @@
     <title>IMPLEMENTATION NOTES</title>
     <para>Traditionally, allocators have used
     <citerefentry><refentrytitle>sbrk</refentrytitle>
     <manvolnum>2</manvolnum></citerefentry> to obtain memory, which is
     suboptimal for several reasons, including race conditions, increased
     fragmentation, and artificial limitations on maximum usable memory.  If
-    <option>--enable-dss</option> is specified during configuration, this
-    allocator uses both <citerefentry><refentrytitle>mmap</refentrytitle>
+    <citerefentry><refentrytitle>sbrk</refentrytitle>
+    <manvolnum>2</manvolnum></citerefentry> is supported by the operating
+    system, this allocator uses both
+    <citerefentry><refentrytitle>mmap</refentrytitle>
     <manvolnum>2</manvolnum></citerefentry> and
     <citerefentry><refentrytitle>sbrk</refentrytitle>
     <manvolnum>2</manvolnum></citerefentry>, in that order of preference;
     otherwise only <citerefentry><refentrytitle>mmap</refentrytitle>
     <manvolnum>2</manvolnum></citerefentry> is used.</para>
 
@@ -629,47 +520,67 @@
     <para>Memory is conceptually broken into equal-sized chunks, where the
     chunk size is a power of two that is greater than the page size.  Chunks
     are always aligned to multiples of the chunk size.  This alignment makes it
     possible to find metadata for user objects very quickly.</para>
 
     <para>User objects are broken into three categories according to size:
-    small, large, and huge.  Small objects are smaller than one page.  Large
-    objects are smaller than the chunk size.  Huge objects are a multiple of
-    the chunk size.  Small and large objects are managed by arenas; huge
-    objects are managed separately in a single data structure that is shared by
-    all threads.  Huge objects are used by applications infrequently enough
-    that this single data structure is not a scalability issue.</para>
+    small, large, and huge.  Small and large objects are managed entirely by
+    arenas; huge objects are additionally aggregated in a single data structure
+    that is shared by all threads.  Huge objects are typically used by
+    applications infrequently enough that this single data structure is not a
+    scalability issue.</para>
 
     <para>Each chunk that is managed by an arena tracks its contents as runs of
     contiguous pages (unused, backing a set of small objects, or backing one
     large object).  The combination of chunk alignment and chunk page maps
     makes it possible to determine all metadata regarding small and large
     allocations in constant time.</para>
 
     <para>Small objects are managed in groups by page runs.  Each run maintains
-    a frontier and free list to track which regions are in use.  Allocation
-    requests that are no more than half the quantum (8 or 16, depending on
-    architecture) are rounded up to the nearest power of two that is at least
-    <code language="C">sizeof(<type>double</type>)</code>.  All other small
-    object size classes are multiples of the quantum, spaced such that internal
-    fragmentation is limited to approximately 25% for all but the smallest size
-    classes.  Allocation requests that are larger than the maximum small size
-    class, but small enough to fit in an arena-managed chunk (see the <link
-    linkend="opt.lg_chunk"><mallctl>opt.lg_chunk</mallctl></link> option), are
-    rounded up to the nearest run size.  Allocation requests that are too large
-    to fit in an arena-managed chunk are rounded up to the nearest multiple of
-    the chunk size.</para>
+    a bitmap to track which regions are in use.  Allocation requests that are no
+    more than half the quantum (8 or 16, depending on architecture) are rounded
+    up to the nearest power of two that is at least <code
+    language="C">sizeof(<type>double</type>)</code>.  All other object size
+    classes are multiples of the quantum, spaced such that there are four size
+    classes for each doubling in size, which limits internal fragmentation to
+    approximately 20% for all but the smallest size classes.  Small size classes
+    are smaller than four times the page size, large size classes are smaller
+    than the chunk size (see the <link
+    linkend="opt.lg_chunk"><mallctl>opt.lg_chunk</mallctl></link> option), and
+    huge size classes extend from the chunk size up to one size class less than
+    the full address space size.</para>
 
     <para>Allocations are packed tightly together, which can be an issue for
     multi-threaded applications.  If you need to assure that allocations do not
     suffer from cacheline sharing, round your allocation requests up to the
     nearest multiple of the cacheline size, or specify cacheline alignment when
     allocating.</para>
 
-    <para>Assuming 4 MiB chunks, 4 KiB pages, and a 16-byte quantum on a 64-bit
-    system, the size classes in each category are as shown in <xref
+    <para>The <function>realloc<parameter/></function>,
+    <function>rallocx<parameter/></function>, and
+    <function>xallocx<parameter/></function> functions may resize allocations
+    without moving them under limited circumstances.  Unlike the
+    <function>*allocx<parameter/></function> API, the standard API does not
+    officially round up the usable size of an allocation to the nearest size
+    class, so technically it is necessary to call
+    <function>realloc<parameter/></function> to grow e.g. a 9-byte allocation to
+    16 bytes, or shrink a 16-byte allocation to 9 bytes.  Growth and shrinkage
+    trivially succeeds in place as long as the pre-size and post-size both round
+    up to the same size class.  No other API guarantees are made regarding
+    in-place resizing, but the current implementation also tries to resize large
+    and huge allocations in place, as long as the pre-size and post-size are
+    both large or both huge.  In such cases shrinkage always succeeds for large
+    size classes, but for huge size classes the chunk allocator must support
+    splitting (see <link
+    linkend="arena.i.chunk_hooks"><mallctl>arena.&lt;i&gt;.chunk_hooks</mallctl></link>).
+    Growth only succeeds if the trailing memory is currently available, and
+    additionally for huge size classes the chunk allocator must support
+    merging.</para>
+
+    <para>Assuming 2 MiB chunks, 4 KiB pages, and a 16-byte quantum on a
+    64-bit system, the size classes in each category are as shown in <xref
     linkend="size_classes" xrefstyle="template:Table %n"/>.</para>
 
     <table xml:id="size_classes" frame="all">
       <title>Size classes</title>
       <tgroup cols="3" colsep="1" rowsep="1">
       <colspec colname="c1" align="left"/>
@@ -681,19 +592,19 @@
           <entry>Spacing</entry>
           <entry>Size</entry>
         </row>
       </thead>
       <tbody>
         <row>
-          <entry morerows="6">Small</entry>
+          <entry morerows="8">Small</entry>
           <entry>lg</entry>
           <entry>[8]</entry>
         </row>
         <row>
           <entry>16</entry>
-          <entry>[16, 32, 48, ..., 128]</entry>
+          <entry>[16, 32, 48, 64, 80, 96, 112, 128]</entry>
         </row>
         <row>
           <entry>32</entry>
           <entry>[160, 192, 224, 256]</entry>
         </row>
         <row>
@@ -707,23 +618,83 @@
         <row>
           <entry>256</entry>
           <entry>[1280, 1536, 1792, 2048]</entry>
         </row>
         <row>
           <entry>512</entry>
-          <entry>[2560, 3072, 3584]</entry>
+          <entry>[2560, 3072, 3584, 4096]</entry>
+        </row>
+        <row>
+          <entry>1 KiB</entry>
+          <entry>[5 KiB, 6 KiB, 7 KiB, 8 KiB]</entry>
+        </row>
+        <row>
+          <entry>2 KiB</entry>
+          <entry>[10 KiB, 12 KiB, 14 KiB]</entry>
+        </row>
+        <row>
+          <entry morerows="7">Large</entry>
+          <entry>2 KiB</entry>
+          <entry>[16 KiB]</entry>
         </row>
         <row>
-          <entry>Large</entry>
           <entry>4 KiB</entry>
-          <entry>[4 KiB, 8 KiB, 12 KiB, ..., 4072 KiB]</entry>
+          <entry>[20 KiB, 24 KiB, 28 KiB, 32 KiB]</entry>
+        </row>
+        <row>
+          <entry>8 KiB</entry>
+          <entry>[40 KiB, 48 KiB, 54 KiB, 64 KiB]</entry>
+        </row>
+        <row>
+          <entry>16 KiB</entry>
+          <entry>[80 KiB, 96 KiB, 112 KiB, 128 KiB]</entry>
+        </row>
+        <row>
+          <entry>32 KiB</entry>
+          <entry>[160 KiB, 192 KiB, 224 KiB, 256 KiB]</entry>
+        </row>
+        <row>
+          <entry>64 KiB</entry>
+          <entry>[320 KiB, 384 KiB, 448 KiB, 512 KiB]</entry>
+        </row>
+        <row>
+          <entry>128 KiB</entry>
+          <entry>[640 KiB, 768 KiB, 896 KiB, 1 MiB]</entry>
+        </row>
+        <row>
+          <entry>256 KiB</entry>
+          <entry>[1280 KiB, 1536 KiB, 1792 KiB]</entry>
+        </row>
+        <row>
+          <entry morerows="6">Huge</entry>
+          <entry>256 KiB</entry>
+          <entry>[2 MiB]</entry>
+        </row>
+        <row>
+          <entry>512 KiB</entry>
+          <entry>[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]</entry>
+        </row>
+        <row>
+          <entry>1 MiB</entry>
+          <entry>[5 MiB, 6 MiB, 7 MiB, 8 MiB]</entry>
+        </row>
+        <row>
+          <entry>2 MiB</entry>
+          <entry>[10 MiB, 12 MiB, 14 MiB, 16 MiB]</entry>
         </row>
         <row>
-          <entry>Huge</entry>
           <entry>4 MiB</entry>
-          <entry>[4 MiB, 8 MiB, 12 MiB, ...]</entry>
+          <entry>[20 MiB, 24 MiB, 28 MiB, 32 MiB]</entry>
+        </row>
+        <row>
+          <entry>8 MiB</entry>
+          <entry>[40 MiB, 48 MiB, 56 MiB, 64 MiB]</entry>
+        </row>
+        <row>
+          <entry>...</entry>
+          <entry>...</entry>
         </row>
       </tbody>
       </tgroup>
     </table>
   </refsect1>
   <refsect1 id="mallctl_namespace">
@@ -762,29 +733,29 @@
         <listitem><para>If a value is passed in, refresh the data from which
         the <function>mallctl*<parameter/></function> functions report values,
         and increment the epoch.  Return the current epoch.  This is useful for
         detecting whether another thread caused a refresh.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="config.debug">
+      <varlistentry id="config.cache_oblivious">
         <term>
-          <mallctl>config.debug</mallctl>
+          <mallctl>config.cache_oblivious</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
-        <listitem><para><option>--enable-debug</option> was specified during
-        build configuration.</para></listitem>
+        <listitem><para><option>--enable-cache-oblivious</option> was specified
+        during build configuration.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="config.dss">
+      <varlistentry id="config.debug">
         <term>
-          <mallctl>config.dss</mallctl>
+          <mallctl>config.debug</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
-        <listitem><para><option>--enable-dss</option> was specified during
+        <listitem><para><option>--enable-debug</option> was specified during
         build configuration.</para></listitem>
       </varlistentry>
 
       <varlistentry id="config.fill">
         <term>
           <mallctl>config.fill</mallctl>
@@ -802,22 +773,12 @@
           <literal>r-</literal>
         </term>
         <listitem><para><option>--enable-lazy-lock</option> was specified
         during build configuration.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="config.mremap">
-        <term>
-          <mallctl>config.mremap</mallctl>
-          (<type>bool</type>)
-          <literal>r-</literal>
-        </term>
-        <listitem><para><option>--enable-mremap</option> was specified during
-        build configuration.</para></listitem>
-      </varlistentry>
-
       <varlistentry id="config.munmap">
         <term>
           <mallctl>config.munmap</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
@@ -937,29 +898,34 @@
           <literal>r-</literal>
         </term>
         <listitem><para>dss (<citerefentry><refentrytitle>sbrk</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry>) allocation precedence as
         related to <citerefentry><refentrytitle>mmap</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> allocation.  The following
-        settings are supported: &ldquo;disabled&rdquo;, &ldquo;primary&rdquo;,
-        and &ldquo;secondary&rdquo;.  The default is &ldquo;secondary&rdquo; if
-        <link linkend="config.dss"><mallctl>config.dss</mallctl></link> is
-        true, &ldquo;disabled&rdquo; otherwise.
+        settings are supported if
+        <citerefentry><refentrytitle>sbrk</refentrytitle>
+        <manvolnum>2</manvolnum></citerefentry> is supported by the operating
+        system: &ldquo;disabled&rdquo;, &ldquo;primary&rdquo;, and
+        &ldquo;secondary&rdquo;; otherwise only &ldquo;disabled&rdquo; is
+        supported.  The default is &ldquo;secondary&rdquo; if
+        <citerefentry><refentrytitle>sbrk</refentrytitle>
+        <manvolnum>2</manvolnum></citerefentry> is supported by the operating
+        system; &ldquo;disabled&rdquo; otherwise.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.lg_chunk">
         <term>
           <mallctl>opt.lg_chunk</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Virtual memory chunk size (log base 2).  If a chunk
         size outside the supported size range is specified, the size is
         silently clipped to the minimum/maximum supported size.  The default
-        chunk size is 4 MiB (2^22).
+        chunk size is 2 MiB (2^21).
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.narenas">
         <term>
           <mallctl>opt.narenas</mallctl>
@@ -983,13 +949,17 @@
         whichever is greater), before informing the kernel about some of those
         pages via <citerefentry><refentrytitle>madvise</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> or a similar system call.  This
         provides the kernel with sufficient information to recycle dirty pages
         if physical memory becomes scarce and the pages remain unused.  The
         default minimum ratio is 8:1 (2^3:1); an option value of -1 will
-        disable dirty page purging.</para></listitem>
+        disable dirty page purging.  See <link
+        linkend="arenas.lg_dirty_mult"><mallctl>arenas.lg_dirty_mult</mallctl></link>
+        and <link
+        linkend="arena.i.lg_dirty_mult"><mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl></link>
+        for related dynamic control options.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.stats_print">
         <term>
           <mallctl>opt.stats_print</mallctl>
           (<type>bool</type>)
@@ -1000,32 +970,40 @@
         function is called at program exit via an
         <citerefentry><refentrytitle>atexit</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> function.  If
         <option>--enable-stats</option> is specified during configuration, this
         has the potential to cause deadlock for a multi-threaded process that
         exits while one or more threads are executing in the memory allocation
-        functions.  Therefore, this option should only be used with care; it is
-        primarily intended as a performance tuning aid during application
+        functions.  Furthermore, <function>atexit<parameter/></function> may
+        allocate memory during application initialization and then deadlock
+        internally when jemalloc in turn calls
+        <function>atexit<parameter/></function>, so this option is not
+        univerally usable (though the application can register its own
+        <function>atexit<parameter/></function> function with equivalent
+        functionality).  Therefore, this option should only be used with care;
+        it is primarily intended as a performance tuning aid during application
         development.  This option is disabled by default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.junk">
         <term>
           <mallctl>opt.junk</mallctl>
-          (<type>bool</type>)
+          (<type>const char *</type>)
           <literal>r-</literal>
           [<option>--enable-fill</option>]
         </term>
-        <listitem><para>Junk filling enabled/disabled.  If enabled, each byte
-        of uninitialized allocated memory will be initialized to
-        <literal>0xa5</literal>.  All deallocated memory will be initialized to
-        <literal>0x5a</literal>.  This is intended for debugging and will
-        impact performance negatively.  This option is disabled by default
-        unless <option>--enable-debug</option> is specified during
-        configuration, in which case it is enabled by default unless running
-        inside <ulink
+        <listitem><para>Junk filling.  If set to "alloc", each byte of
+        uninitialized allocated memory will be initialized to
+        <literal>0xa5</literal>.  If set to "free", all deallocated memory will
+        be initialized to <literal>0x5a</literal>.  If set to "true", both
+        allocated and deallocated memory will be initialized, and if set to
+        "false", junk filling be disabled entirely.  This is intended for
+        debugging and will impact performance negatively.  This option is
+        "false" by default unless <option>--enable-debug</option> is specified
+        during configuration, in which case it is "true" by default unless
+        running inside <ulink
         url="http://valgrind.org/">Valgrind</ulink>.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.quarantine">
         <term>
           <mallctl>opt.quarantine</mallctl>
@@ -1073,15 +1051,14 @@
           <literal>r-</literal>
           [<option>--enable-fill</option>]
         </term>
         <listitem><para>Zero filling enabled/disabled.  If enabled, each byte
         of uninitialized allocated memory will be initialized to 0.  Note that
         this initialization only happens once for each byte, so
-        <function>realloc<parameter/></function>,
-        <function>rallocx<parameter/></function> and
-        <function>rallocm<parameter/></function> calls do not zero memory that
+        <function>realloc<parameter/></function> and
+        <function>rallocx<parameter/></function> calls do not zero memory that
         was previously allocated.  This is intended for debugging and will
         impact performance negatively.  This option is disabled by default.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.utrace">
@@ -1094,25 +1071,12 @@
         <listitem><para>Allocation tracing based on
         <citerefentry><refentrytitle>utrace</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> enabled/disabled.  This option
         is disabled by default.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="opt.valgrind">
-        <term>
-          <mallctl>opt.valgrind</mallctl>
-          (<type>bool</type>)
-          <literal>r-</literal>
-          [<option>--enable-valgrind</option>]
-        </term>
-        <listitem><para><ulink url="http://valgrind.org/">Valgrind</ulink>
-        support enabled/disabled.  This option is vestigal because jemalloc
-        auto-detects whether it is running inside Valgrind.  This option is
-        disabled by default, unless running inside Valgrind.</para></listitem>
-      </varlistentry>
-
       <varlistentry id="opt.xmalloc">
         <term>
           <mallctl>opt.xmalloc</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
           [<option>--enable-xmalloc</option>]
@@ -1134,34 +1098,34 @@
         <term>
           <mallctl>opt.tcache</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
           [<option>--enable-tcache</option>]
         </term>
-        <listitem><para>Thread-specific caching enabled/disabled.  When there
-        are multiple threads, each thread uses a thread-specific cache for
-        objects up to a certain size.  Thread-specific caching allows many
-        allocations to be satisfied without performing any thread
-        synchronization, at the cost of increased memory use.  See the
-        <link
+        <listitem><para>Thread-specific caching (tcache) enabled/disabled.  When
+        there are multiple threads, each thread uses a tcache for objects up to
+        a certain size.  Thread-specific caching allows many allocations to be
+        satisfied without performing any thread synchronization, at the cost of
+        increased memory use.  See the <link
         linkend="opt.lg_tcache_max"><mallctl>opt.lg_tcache_max</mallctl></link>
         option for related tuning information.  This option is enabled by
         default unless running inside <ulink
-        url="http://valgrind.org/">Valgrind</ulink>.</para></listitem>
+        url="http://valgrind.org/">Valgrind</ulink>, in which case it is
+        forcefully disabled.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.lg_tcache_max">
         <term>
           <mallctl>opt.lg_tcache_max</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-tcache</option>]
         </term>
         <listitem><para>Maximum size class (log base 2) to cache in the
-        thread-specific cache.  At a minimum, all small size classes are
-        cached, and at a maximum all large size classes are cached.  The
+        thread-specific cache (tcache).  At a minimum, all small size classes
+        are cached, and at a maximum all large size classes are cached.  The
         default maximum is 32 KiB (2^15).</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof">
         <term>
           <mallctl>opt.prof</mallctl>
@@ -1180,14 +1144,15 @@
         linkend="opt.lg_prof_interval"><mallctl>opt.lg_prof_interval</mallctl></link>
         option for information on interval-triggered profile dumping, the <link
         linkend="opt.prof_gdump"><mallctl>opt.prof_gdump</mallctl></link>
         option for information on high-water-triggered profile dumping, and the
         <link linkend="opt.prof_final"><mallctl>opt.prof_final</mallctl></link>
         option for final profile dumping.  Profile output is compatible with
-        the included <command>pprof</command> Perl script, which originates
-        from the <ulink url="http://code.google.com/p/gperftools/">gperftools
+        the <command>jeprof</command> command, which is based on the
+        <command>pprof</command> that is developed as part of the <ulink
+        url="http://code.google.com/p/gperftools/">gperftools
         package</ulink>.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_prefix">
         <term>
           <mallctl>opt.prof_prefix</mallctl>
@@ -1203,29 +1168,44 @@
       </varlistentry>
 
       <varlistentry id="opt.prof_active">
         <term>
           <mallctl>opt.prof_active</mallctl>
           (<type>bool</type>)
-          <literal>rw</literal>
+          <literal>r-</literal>
           [<option>--enable-prof</option>]
         </term>
         <listitem><para>Profiling activated/deactivated.  This is a secondary
         control mechanism that makes it possible to start the application with
         profiling enabled (see the <link
         linkend="opt.prof"><mallctl>opt.prof</mallctl></link> option) but
         inactive, then toggle profiling at any time during program execution
         with the <link
         linkend="prof.active"><mallctl>prof.active</mallctl></link> mallctl.
         This option is enabled by default.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="opt.prof_thread_active_init">
+        <term>
+          <mallctl>opt.prof_thread_active_init</mallctl>
+          (<type>bool</type>)
+          <literal>r-</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Initial setting for <link
+        linkend="thread.prof.active"><mallctl>thread.prof.active</mallctl></link>
+        in newly created threads.  The initial setting for newly created threads
+        can also be changed during execution via the <link
+        linkend="prof.thread_active_init"><mallctl>prof.thread_active_init</mallctl></link>
+        mallctl.  This option is enabled by default.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="opt.lg_prof_sample">
         <term>
           <mallctl>opt.lg_prof_sample</mallctl>
-          (<type>ssize_t</type>)
+          (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-prof</option>]
         </term>
         <listitem><para>Average interval (log base 2) between allocation
         samples, as measured in bytes of allocation activity.  Increasing the
         sampling interval decreases profile fidelity, but also decreases the
@@ -1273,19 +1253,17 @@
         <term>
           <mallctl>opt.prof_gdump</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
           [<option>--enable-prof</option>]
         </term>
-        <listitem><para>Trigger a memory profile dump every time the total
-        virtual memory exceeds the previous maximum.  Profiles are dumped to
-        files named according to the pattern
-        <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap</filename>,
-        where <literal>&lt;prefix&gt;</literal> is controlled by the <link
-        linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
-        option.  This option is disabled by default.</para></listitem>
+        <listitem><para>Set the initial state of <link
+        linkend="prof.gdump"><mallctl>prof.gdump</mallctl></link>, which when
+        enabled triggers a memory profile dump every time the total virtual
+        memory exceeds the previous maximum.  This option is disabled by
+        default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_final">
         <term>
           <mallctl>opt.prof_final</mallctl>
           (<type>bool</type>)
@@ -1296,13 +1274,19 @@
         <citerefentry><refentrytitle>atexit</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> function to dump final memory
         usage to a file named according to the pattern
         <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap</filename>,
         where <literal>&lt;prefix&gt;</literal> is controlled by the <link
         linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
-        option.  This option is enabled by default.</para></listitem>
+        option.  Note that <function>atexit<parameter/></function> may allocate
+        memory during application initialization and then deadlock internally
+        when jemalloc in turn calls <function>atexit<parameter/></function>, so
+        this option is not univerally usable (though the application can
+        register its own <function>atexit<parameter/></function> function with
+        equivalent functionality).  This option is disabled by
+        default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_leak">
         <term>
           <mallctl>opt.prof_leak</mallctl>
           (<type>bool</type>)
@@ -1393,38 +1377,119 @@
           <literal>rw</literal>
           [<option>--enable-tcache</option>]
         </term>
         <listitem><para>Enable/disable calling thread's tcache.  The tcache is
         implicitly flushed as a side effect of becoming
         disabled (see <link
-        lenkend="thread.tcache.flush"><mallctl>thread.tcache.flush</mallctl></link>).
+        linkend="thread.tcache.flush"><mallctl>thread.tcache.flush</mallctl></link>).
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="thread.tcache.flush">
         <term>
           <mallctl>thread.tcache.flush</mallctl>
           (<type>void</type>)
           <literal>--</literal>
           [<option>--enable-tcache</option>]
         </term>
-        <listitem><para>Flush calling thread's tcache.  This interface releases
-        all cached objects and internal data structures associated with the
-        calling thread's thread-specific cache.  Ordinarily, this interface
+        <listitem><para>Flush calling thread's thread-specific cache (tcache).
+        This interface releases all cached objects and internal data structures
+        associated with the calling thread's tcache.  Ordinarily, this interface
         need not be called, since automatic periodic incremental garbage
         collection occurs, and the thread cache is automatically discarded when
         a thread exits.  However, garbage collection is triggered by allocation
         activity, so it is possible for a thread that stops
         allocating/deallocating to retain its cache indefinitely, in which case
         the developer may find manual flushing useful.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="thread.prof.name">
+        <term>
+          <mallctl>thread.prof.name</mallctl>
+          (<type>const char *</type>)
+          <literal>r-</literal> or
+          <literal>-w</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Get/set the descriptive name associated with the calling
+        thread in memory profile dumps.  An internal copy of the name string is
+        created, so the input string need not be maintained after this interface
+        completes execution.  The output string of this interface should be
+        copied for non-ephemeral uses, because multiple implementation details
+        can cause asynchronous string deallocation.  Furthermore, each
+        invocation of this interface can only read or write; simultaneous
+        read/write is not supported due to string lifetime limitations.  The
+        name string must nil-terminated and comprised only of characters in the
+        sets recognized
+        by <citerefentry><refentrytitle>isgraph</refentrytitle>
+        <manvolnum>3</manvolnum></citerefentry> and
+        <citerefentry><refentrytitle>isblank</refentrytitle>
+        <manvolnum>3</manvolnum></citerefentry>.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="thread.prof.active">
+        <term>
+          <mallctl>thread.prof.active</mallctl>
+          (<type>bool</type>)
+          <literal>rw</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Control whether sampling is currently active for the
+        calling thread.  This is an activation mechanism in addition to <link
+        linkend="prof.active"><mallctl>prof.active</mallctl></link>; both must
+        be active for the calling thread to sample.  This flag is enabled by
+        default.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="tcache.create">
+        <term>
+          <mallctl>tcache.create</mallctl>
+          (<type>unsigned</type>)
+          <literal>r-</literal>
+          [<option>--enable-tcache</option>]
+        </term>
+        <listitem><para>Create an explicit thread-specific cache (tcache) and
+        return an identifier that can be passed to the <link
+        linkend="MALLOCX_TCACHE"><constant>MALLOCX_TCACHE(<parameter>tc</parameter>)</constant></link>
+        macro to explicitly use the specified cache rather than the
+        automatically managed one that is used by default.  Each explicit cache
+        can be used by only one thread at a time; the application must assure
+        that this constraint holds.
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry id="tcache.flush">
+        <term>
+          <mallctl>tcache.flush</mallctl>
+          (<type>unsigned</type>)
+          <literal>-w</literal>
+          [<option>--enable-tcache</option>]
+        </term>
+        <listitem><para>Flush the specified thread-specific cache (tcache).  The
+        same considerations apply to this interface as to <link
+        linkend="thread.tcache.flush"><mallctl>thread.tcache.flush</mallctl></link>,
+        except that the tcache will never be automatically be discarded.
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry id="tcache.destroy">
+        <term>
+          <mallctl>tcache.destroy</mallctl>
+          (<type>unsigned</type>)
+          <literal>-w</literal>
+          [<option>--enable-tcache</option>]
+        </term>
+        <listitem><para>Flush the specified thread-specific cache (tcache) and
+        make the identifier available for use during a future tcache creation.
+        </para></listitem>
+      </varlistentry>
+
       <varlistentry id="arena.i.purge">
         <term>
           <mallctl>arena.&lt;i&gt;.purge</mallctl>
-          (<type>unsigned</type>)
+          (<type>void</type>)
           <literal>--</literal>
         </term>
         <listitem><para>Purge unused dirty pages for arena &lt;i&gt;, or for
         all arenas if &lt;i&gt; equals <link
         linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.
         </para></listitem>
@@ -1436,20 +1501,228 @@
           (<type>const char *</type>)
           <literal>rw</literal>
         </term>
         <listitem><para>Set the precedence of dss allocation as related to mmap
         allocation for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals
         <link
-        linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.  Note
-        that even during huge allocation this setting is read from the arena
-        that would be chosen for small or large allocation so that applications
-        can depend on consistent dss versus mmap allocation regardless of
-        allocation size.  See <link
-        linkend="opt.dss"><mallctl>opt.dss</mallctl></link> for supported
-        settings.
-        </para></listitem>
+        linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.  See
+        <link linkend="opt.dss"><mallctl>opt.dss</mallctl></link> for supported
+        settings.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="arena.i.lg_dirty_mult">
+        <term>
+          <mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl>
+          (<type>ssize_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Current per-arena minimum ratio (log base 2) of active
+        to dirty pages for arena &lt;i&gt;.  Each time this interface is set and
+        the ratio is increased, pages are synchronously purged as necessary to
+        impose the new ratio.  See <link
+        linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
+        for additional information.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="arena.i.chunk_hooks">
+        <term>
+          <mallctl>arena.&lt;i&gt;.chunk_hooks</mallctl>
+          (<type>chunk_hooks_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Get or set the chunk management hook functions for arena
+        &lt;i&gt;.  The functions must be capable of operating on all extant
+        chunks associated with arena &lt;i&gt;, usually by passing unknown
+        chunks to the replaced functions.  In practice, it is feasible to
+        control allocation for arenas created via <link
+        linkend="arenas.extend"><mallctl>arenas.extend</mallctl></link> such
+        that all chunks originate from an application-supplied chunk allocator
+        (by setting custom chunk hook functions just after arena creation), but
+        the automatically created arenas may have already created chunks prior
+        to the application having an opportunity to take over chunk
+        allocation.</para>
+
+        <programlisting language="C"><![CDATA[
+typedef struct {
+	chunk_alloc_t		*alloc;
+	chunk_dalloc_t		*dalloc;
+	chunk_commit_t		*commit;
+	chunk_decommit_t	*decommit;
+	chunk_purge_t		*purge;
+	chunk_split_t		*split;
+	chunk_merge_t		*merge;
+} chunk_hooks_t;]]></programlisting>
+        <para>The <type>chunk_hooks_t</type> structure comprises function
+        pointers which are described individually below.  jemalloc uses these
+        functions to manage chunk lifetime, which starts off with allocation of
+        mapped committed memory, in the simplest case followed by deallocation.
+        However, there are performance and platform reasons to retain chunks for
+        later reuse.  Cleanup attempts cascade from deallocation to decommit to
+        purging, which gives the chunk management functions opportunities to
+        reject the most permanent cleanup operations in favor of less permanent
+        (and often less costly) operations.  The chunk splitting and merging
+        operations can also be opted out of, but this is mainly intended to
+        support platforms on which virtual memory mappings provided by the
+        operating system kernel do not automatically coalesce and split, e.g.
+        Windows.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef void *<function>(chunk_alloc_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>alignment</parameter></paramdef>
+          <paramdef>bool *<parameter>zero</parameter></paramdef>
+          <paramdef>bool *<parameter>commit</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk allocation function conforms to the
+        <type>chunk_alloc_t</type> type and upon success returns a pointer to
+        <parameter>size</parameter> bytes of mapped memory on behalf of arena
+        <parameter>arena_ind</parameter> such that the chunk's base address is a
+        multiple of <parameter>alignment</parameter>, as well as setting
+        <parameter>*zero</parameter> to indicate whether the chunk is zeroed and
+        <parameter>*commit</parameter> to indicate whether the chunk is
+        committed.  Upon error the function returns <constant>NULL</constant>
+        and leaves <parameter>*zero</parameter> and
+        <parameter>*commit</parameter> unmodified.  The
+        <parameter>size</parameter> parameter is always a multiple of the chunk
+        size.  The <parameter>alignment</parameter> parameter is always a power
+        of two at least as large as the chunk size.  Zeroing is mandatory if
+        <parameter>*zero</parameter> is true upon function entry.  Committing is
+        mandatory if <parameter>*commit</parameter> is true upon function entry.
+        If <parameter>chunk</parameter> is not <constant>NULL</constant>, the
+        returned pointer must be <parameter>chunk</parameter> on success or
+        <constant>NULL</constant> on error.  Committed memory may be committed
+        in absolute terms as on a system that does not overcommit, or in
+        implicit terms as on a system that overcommits and satisfies physical
+        memory needs on demand via soft page faults.  Note that replacing the
+        default chunk allocation function makes the arena's <link
+        linkend="arena.i.dss"><mallctl>arena.&lt;i&gt;.dss</mallctl></link>
+        setting irrelevant.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_dalloc_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>bool <parameter>committed</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>
+        A chunk deallocation function conforms to the
+        <type>chunk_dalloc_t</type> type and deallocates a
+        <parameter>chunk</parameter> of given <parameter>size</parameter> with
+        <parameter>committed</parameter>/decommited memory as indicated, on
+        behalf of arena <parameter>arena_ind</parameter>, returning false upon
+        success.  If the function returns true, this indicates opt-out from
+        deallocation; the virtual memory mapping associated with the chunk
+        remains mapped, in the same commit state, and available for future use,
+        in which case it will be automatically retained for later reuse.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_commit_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>offset</parameter></paramdef>
+          <paramdef>size_t <parameter>length</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk commit function conforms to the
+        <type>chunk_commit_t</type> type and commits zeroed physical memory to
+        back pages within a <parameter>chunk</parameter> of given
+        <parameter>size</parameter> at <parameter>offset</parameter> bytes,
+        extending for <parameter>length</parameter> on behalf of arena
+        <parameter>arena_ind</parameter>, returning false upon success.
+        Committed memory may be committed in absolute terms as on a system that
+        does not overcommit, or in implicit terms as on a system that
+        overcommits and satisfies physical memory needs on demand via soft page
+        faults. If the function returns true, this indicates insufficient
+        physical memory to satisfy the request.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_decommit_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>offset</parameter></paramdef>
+          <paramdef>size_t <parameter>length</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk decommit function conforms to the
+        <type>chunk_decommit_t</type> type and decommits any physical memory
+        that is backing pages within a <parameter>chunk</parameter> of given
+        <parameter>size</parameter> at <parameter>offset</parameter> bytes,
+        extending for <parameter>length</parameter> on behalf of arena
+        <parameter>arena_ind</parameter>, returning false upon success, in which
+        case the pages will be committed via the chunk commit function before
+        being reused.  If the function returns true, this indicates opt-out from
+        decommit; the memory remains committed and available for future use, in
+        which case it will be automatically retained for later reuse.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_purge_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t<parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>offset</parameter></paramdef>
+          <paramdef>size_t <parameter>length</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk purge function conforms to the <type>chunk_purge_t</type>
+        type and optionally discards physical pages within the virtual memory
+        mapping associated with <parameter>chunk</parameter> of given
+        <parameter>size</parameter> at <parameter>offset</parameter> bytes,
+        extending for <parameter>length</parameter> on behalf of arena
+        <parameter>arena_ind</parameter>, returning false if pages within the
+        purged virtual memory range will be zero-filled the next time they are
+        accessed.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_split_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk</parameter></paramdef>
+          <paramdef>size_t <parameter>size</parameter></paramdef>
+          <paramdef>size_t <parameter>size_a</parameter></paramdef>
+          <paramdef>size_t <parameter>size_b</parameter></paramdef>
+          <paramdef>bool <parameter>committed</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk split function conforms to the <type>chunk_split_t</type>
+        type and optionally splits <parameter>chunk</parameter> of given
+        <parameter>size</parameter> into two adjacent chunks, the first of
+        <parameter>size_a</parameter> bytes, and the second of
+        <parameter>size_b</parameter> bytes, operating on
+        <parameter>committed</parameter>/decommitted memory as indicated, on
+        behalf of arena <parameter>arena_ind</parameter>, returning false upon
+        success.  If the function returns true, this indicates that the chunk
+        remains unsplit and therefore should continue to be operated on as a
+        whole.</para>
+
+        <funcsynopsis><funcprototype>
+          <funcdef>typedef bool <function>(chunk_merge_t)</function></funcdef>
+          <paramdef>void *<parameter>chunk_a</parameter></paramdef>
+          <paramdef>size_t <parameter>size_a</parameter></paramdef>
+          <paramdef>void *<parameter>chunk_b</parameter></paramdef>
+          <paramdef>size_t <parameter>size_b</parameter></paramdef>
+          <paramdef>bool <parameter>committed</parameter></paramdef>
+          <paramdef>unsigned <parameter>arena_ind</parameter></paramdef>
+        </funcprototype></funcsynopsis>
+        <literallayout></literallayout>
+        <para>A chunk merge function conforms to the <type>chunk_merge_t</type>
+        type and optionally merges adjacent chunks,
+        <parameter>chunk_a</parameter> of given <parameter>size_a</parameter>
+        and <parameter>chunk_b</parameter> of given
+        <parameter>size_b</parameter> into one contiguous chunk, operating on
+        <parameter>committed</parameter>/decommitted memory as indicated, on
+        behalf of arena <parameter>arena_ind</parameter>, returning false upon
+        success.  If the function returns true, this indicates that the chunks
+        remain distinct mappings and therefore should continue to be operated on
+        independently.</para>
+        </listitem>
       </varlistentry>
 
       <varlistentry id="arenas.narenas">
         <term>
           <mallctl>arenas.narenas</mallctl>
           (<type>unsigned</type>)
@@ -1467,12 +1740,26 @@
         <listitem><para>An array of <link
         linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>
         booleans.  Each boolean indicates whether the corresponding arena is
         initialized.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="arenas.lg_dirty_mult">
+        <term>
+          <mallctl>arenas.lg_dirty_mult</mallctl>
+          (<type>ssize_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Current default per-arena minimum ratio (log base 2) of
+        active to dirty pages, used to initialize <link
+        linkend="arena.i.lg_dirty_mult"><mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl></link>
+        during arena creation.  See <link
+        linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
+        for additional information.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="arenas.quantum">
         <term>
           <mallctl>arenas.quantum</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
         </term>
@@ -1545,13 +1832,13 @@
         <listitem><para>Number of bytes per page run.</para></listitem>
       </varlistentry>
 
       <varlistentry id="arenas.nlruns">
         <term>
           <mallctl>arenas.nlruns</mallctl>
-          (<type>size_t</type>)
+          (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Total number of large size classes.</para></listitem>
       </varlistentry>
 
       <varlistentry id="arenas.lrun.i.size">
@@ -1561,44 +1848,68 @@
           <literal>r-</literal>
         </term>
         <listitem><para>Maximum size supported by this large size
         class.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="arenas.purge">
+      <varlistentry id="arenas.nhchunks">
         <term>
-          <mallctl>arenas.purge</mallctl>
+          <mallctl>arenas.nhchunks</mallctl>
           (<type>unsigned</type>)
-          <literal>-w</literal>
+          <literal>r-</literal>
         </term>
-        <listitem><para>Purge unused dirty pages for the specified arena, or
-        for all arenas if none is specified.</para></listitem>
+        <listitem><para>Total number of huge size classes.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="arenas.hchunk.i.size">
+        <term>
+          <mallctl>arenas.hchunk.&lt;i&gt;.size</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Maximum size supported by this huge size
+        class.</para></listitem>
       </varlistentry>
 
       <varlistentry id="arenas.extend">
         <term>
           <mallctl>arenas.extend</mallctl>
           (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Extend the array of arenas by appending a new arena,
         and returning the new arena index.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="prof.thread_active_init">
+        <term>
+          <mallctl>prof.thread_active_init</mallctl>
+          (<type>bool</type>)
+          <literal>rw</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Control the initial setting for <link
+        linkend="thread.prof.active"><mallctl>thread.prof.active</mallctl></link>
+        in newly created threads.  See the <link
+        linkend="opt.prof_thread_active_init"><mallctl>opt.prof_thread_active_init</mallctl></link>
+        option for additional information.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="prof.active">
         <term>
           <mallctl>prof.active</mallctl>
           (<type>bool</type>)
           <literal>rw</literal>
           [<option>--enable-prof</option>]
         </term>
         <listitem><para>Control whether sampling is currently active.  See the
         <link
         linkend="opt.prof_active"><mallctl>opt.prof_active</mallctl></link>
-        option for additional information.
-        </para></listitem>
+        option for additional information, as well as the interrelated <link
+        linkend="thread.prof.active"><mallctl>thread.prof.active</mallctl></link>
+        mallctl.</para></listitem>
       </varlistentry>
 
       <varlistentry id="prof.dump">
         <term>
           <mallctl>prof.dump</mallctl>
           (<type>const char *</type>)
@@ -1611,12 +1922,55 @@
         where <literal>&lt;prefix&gt;</literal> is controlled by the
         <link
         linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
         option.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="prof.gdump">
+        <term>
+          <mallctl>prof.gdump</mallctl>
+          (<type>bool</type>)
+          <literal>rw</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>When enabled, trigger a memory profile dump every time
+        the total virtual memory exceeds the previous maximum.  Profiles are
+        dumped to files named according to the pattern
+        <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap</filename>,
+        where <literal>&lt;prefix&gt;</literal> is controlled by the <link
+        linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
+        option.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="prof.reset">
+        <term>
+          <mallctl>prof.reset</mallctl>
+          (<type>size_t</type>)
+          <literal>-w</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Reset all memory profile statistics, and optionally
+        update the sample rate (see <link
+        linkend="opt.lg_prof_sample"><mallctl>opt.lg_prof_sample</mallctl></link>
+        and <link
+        linkend="prof.lg_sample"><mallctl>prof.lg_sample</mallctl></link>).
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry id="prof.lg_sample">
+        <term>
+          <mallctl>prof.lg_sample</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-prof</option>]
+        </term>
+        <listitem><para>Get the current sample rate (see <link
+        linkend="opt.lg_prof_sample"><mallctl>opt.lg_prof_sample</mallctl></link>).
+        </para></listitem>
+      </varlistentry>
+
       <varlistentry id="prof.interval">
         <term>
           <mallctl>prof.interval</mallctl>
           (<type>uint64_t</type>)
           <literal>r-</literal>
           [<option>--enable-prof</option>]
@@ -1634,15 +1988,14 @@
           (<type>size_t *</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Pointer to a counter that contains an approximate count
         of the current number of bytes in active pages.  The estimate may be
-        high, but never low, because each arena rounds up to the nearest
-        multiple of the chunk size when computing its contribution to the
-        counter.  Note that the <link
+        high, but never low, because each arena rounds up when computing its
+        contribution to the counter.  Note that the <link
         linkend="epoch"><mallctl>epoch</mallctl></link> mallctl has no bearing
         on this counter.  Furthermore, counter consistency is maintained via
         atomic operations, so it is necessary to use an atomic operation in
         order to guarantee a consistent read when dereferencing the pointer.
         </para></listitem>
       </varlistentry>
@@ -1667,94 +2020,62 @@
         </term>
         <listitem><para>Total number of bytes in active pages allocated by the
         application.  This is a multiple of the page size, and greater than or
         equal to <link
         linkend="stats.allocated"><mallctl>stats.allocated</mallctl></link>.
         This does not include <link linkend="stats.arenas.i.pdirty">
-        <mallctl>stats.arenas.&lt;i&gt;.pdirty</mallctl></link> and pages
+        <mallctl>stats.arenas.&lt;i&gt;.pdirty</mallctl></link>, nor pages
         entirely devoted to allocator metadata.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="stats.mapped">
+      <varlistentry id="stats.metadata">
         <term>
-          <mallctl>stats.mapped</mallctl>
+          <mallctl>stats.metadata</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
-        <listitem><para>Total number of bytes in chunks mapped on behalf of the
-        application.  This is a multiple of the chunk size, and is at least as
-        large as <link
-        linkend="stats.active"><mallctl>stats.active</mallctl></link>.  This
-        does not include inactive chunks.</para></listitem>
+        <listitem><para>Total number of bytes dedicated to metadata, which
+        comprise base allocations used for bootstrap-sensitive internal
+        allocator data structures, arena chunk headers (see <link
+        linkend="stats.arenas.i.metadata.mapped"><mallctl>stats.arenas.&lt;i&gt;.metadata.mapped</mallctl></link>),
+        and internal allocations (see <link
+        linkend="stats.arenas.i.metadata.allocated"><mallctl>stats.arenas.&lt;i&gt;.metadata.allocated</mallctl></link>).</para></listitem>
       </varlistentry>
 
-      <varlistentry id="stats.chunks.current">
+      <varlistentry id="stats.resident">
         <term>
-          <mallctl>stats.chunks.current</mallctl>
+          <mallctl>stats.resident</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
-        <listitem><para>Total number of chunks actively mapped on behalf of the
-        application.  This does not include inactive chunks.
-        </para></listitem>
+        <listitem><para>Maximum number of bytes in physically resident data
+        pages mapped by the allocator, comprising all pages dedicated to
+        allocator metadata, pages backing active allocations, and unused dirty
+        pages.  This is a maximum rather than precise because pages may not
+        actually be physically resident if they correspond to demand-zeroed
+        virtual memory that has not yet been touched.  This is a multiple of the
+        page size, and is larger than <link
+        linkend="stats.active"><mallctl>stats.active</mallctl></link>.</para></listitem>
       </varlistentry>
 
-      <varlistentry id="stats.chunks.total">
-        <term>
-          <mallctl>stats.chunks.total</mallctl>
-          (<type>uint64_t</type>)
-          <literal>r-</literal>
-          [<option>--enable-stats</option>]
-        </term>
-        <listitem><para>Cumulative number of chunks allocated.</para></listitem>
-      </varlistentry>
-
-      <varlistentry id="stats.chunks.high">
-        <term>
-          <mallctl>stats.chunks.high</mallctl>
-          (<type>size_t</type>)
-          <literal>r-</literal>
-          [<option>--enable-stats</option>]
-        </term>
-        <listitem><para>Maximum number of active chunks at any time thus far.
-        </para></listitem>
-      </varlistentry>
-
-      <varlistentry id="stats.huge.allocated">
+      <varlistentry id="stats.mapped">
         <term>
-          <mallctl>stats.huge.allocated</mallctl>
+          <mallctl>stats.mapped</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
-        <listitem><para>Number of bytes currently allocated by huge objects.
-        </para></listitem>
-      </varlistentry>
-
-      <varlistentry id="stats.huge.nmalloc">
-        <term>
-          <mallctl>stats.huge.nmalloc</mallctl>
-          (<type>uint64_t</type>)
-          <literal>r-</literal>
-          [<option>--enable-stats</option>]
-        </term>
-        <listitem><para>Cumulative number of huge allocation requests.
-        </para></listitem>
-      </varlistentry>
-
-      <varlistentry id="stats.huge.ndalloc">
-        <term>
-          <mallctl>stats.huge.ndalloc</mallctl>
-          (<type>uint64_t</type>)
-          <literal>r-</literal>
-          [<option>--enable-stats</option>]
-        </term>
-        <listitem><para>Cumulative number of huge deallocation requests.
-        </para></listitem>
+        <listitem><para>Total number of bytes in active chunks mapped by the
+        allocator.  This is a multiple of the chunk size, and is larger than
+        <link linkend="stats.active"><mallctl>stats.active</mallctl></link>.
+        This does not include inactive chunks, even those that contain unused
+        dirty pages, which means that there is no strict ordering between this
+        and <link
+        linkend="stats.resident"><mallctl>stats.resident</mallctl></link>.</para></listitem>
       </varlistentry>
 
       <varlistentry id="stats.arenas.i.dss">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.dss</mallctl>
           (<type>const char *</type>)
@@ -1765,12 +2086,24 @@
         related to <citerefentry><refentrytitle>mmap</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> allocation.  See <link
         linkend="opt.dss"><mallctl>opt.dss</mallctl></link> for details.
         </para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.lg_dirty_mult">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.lg_dirty_mult</mallctl>
+          (<type>ssize_t</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Minimum ratio (log base 2) of active to dirty pages.
+        See <link
+        linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
+        for details.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.nthreads">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.nthreads</mallctl>
           (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
@@ -1806,12 +2139,44 @@
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Number of mapped bytes.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.metadata.mapped">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.metadata.mapped</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Number of mapped bytes in arena chunk headers, which
+        track the states of the non-metadata pages.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.metadata.allocated">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.metadata.allocated</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Number of bytes dedicated to internal allocations.
+        Internal allocations differ from application-originated allocations in
+        that they are for internal use, and that they are omitted from heap
+        profiles.  This statistic is reported separately from <link
+        linkend="stats.metadata"><mallctl>stats.metadata</mallctl></link> and
+        <link
+        linkend="stats.arenas.i.metadata.mapped"><mallctl>stats.arenas.&lt;i&gt;.metadata.mapped</mallctl></link>
+        because it overlaps with e.g. the <link
+        linkend="stats.allocated"><mallctl>stats.allocated</mallctl></link> and
+        <link linkend="stats.active"><mallctl>stats.active</mallctl></link>
+        statistics, whereas the other metadata statistics do
+        not.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.npurge">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.npurge</mallctl>
           (<type>uint64_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
@@ -1927,21 +2292,54 @@
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Cumulative number of large allocation requests.
         </para></listitem>
       </varlistentry>
 
-      <varlistentry id="stats.arenas.i.bins.j.allocated">
+      <varlistentry id="stats.arenas.i.huge.allocated">
         <term>
-          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.allocated</mallctl>
+          <mallctl>stats.arenas.&lt;i&gt;.huge.allocated</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
-        <listitem><para>Current number of bytes allocated by
-        bin.</para></listitem>
+        <listitem><para>Number of bytes currently allocated by huge objects.
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.huge.nmalloc">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.huge.nmalloc</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of huge allocation requests served
+        directly by the arena.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.huge.ndalloc">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.huge.ndalloc</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of huge deallocation requests served
+        directly by the arena.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.huge.nrequests">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.huge.nrequests</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of huge allocation requests.
+        </para></listitem>
       </varlistentry>
 
       <varlistentry id="stats.arenas.i.bins.j.nmalloc">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nmalloc</mallctl>
           (<type>uint64_t</type>)
@@ -1971,12 +2369,23 @@
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Cumulative number of allocation
         requests.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.bins.j.curregs">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curregs</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Current number of regions for this size
+        class.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.bins.j.nfills">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nfills</mallctl>
           (<type>uint64_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option> <option>--enable-tcache</option>]
@@ -2065,12 +2474,56 @@
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Current number of runs for this size class.
         </para></listitem>
       </varlistentry>
+
+      <varlistentry id="stats.arenas.i.hchunks.j.nmalloc">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nmalloc</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of allocation requests for this size
+        class served directly by the arena.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.hchunks.j.ndalloc">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.ndalloc</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of deallocation requests for this
+        size class served directly by the arena.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.hchunks.j.nrequests">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nrequests</mallctl>
+          (<type>uint64_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Cumulative number of allocation requests for this size
+        class.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="stats.arenas.i.hchunks.j.curhchunks">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.curhchunks</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Current number of huge allocations for this size class.
+        </para></listitem>
+      </varlistentry>
     </variablelist>
   </refsect1>
   <refsect1 id="debugging_malloc_problems">
     <title>DEBUGGING MALLOC PROBLEMS</title>
     <para>When debugging, it is a good idea to configure/build jemalloc with
     the <option>--enable-debug</option> and <option>--enable-fill</option>
@@ -2250,48 +2703,12 @@
       </para>
 
       <para>The <function>malloc_usable_size<parameter/></function> function
       returns the usable size of the allocation pointed to by
       <parameter>ptr</parameter>.  </para>
     </refsect2>
-    <refsect2>
-      <title>Experimental API</title>
-      <para>The <function>allocm<parameter/></function>,
-      <function>rallocm<parameter/></function>,
-      <function>sallocm<parameter/></function>,
-      <function>dallocm<parameter/></function>, and
-      <function>nallocm<parameter/></function> functions return
-      <constant>ALLOCM_SUCCESS</constant> on success; otherwise they return an
-      error value.  The <function>allocm<parameter/></function>,
-      <function>rallocm<parameter/></function>, and
-      <function>nallocm<parameter/></function> functions will fail if:
-        <variablelist>
-          <varlistentry>
-            <term><errorname>ALLOCM_ERR_OOM</errorname></term>
-
-            <listitem><para>Out of memory.  Insufficient contiguous memory was
-            available to service the allocation request.  The
-            <function>allocm<parameter/></function> function additionally sets
-            <parameter>*ptr</parameter> to <constant>NULL</constant>, whereas
-            the <function>rallocm<parameter/></function> function leaves
-            <constant>*ptr</constant> unmodified.</para></listitem>
-          </varlistentry>
-        </variablelist>
-      The <function>rallocm<parameter/></function> function will also
-      fail if:
-        <variablelist>
-          <varlistentry>
-            <term><errorname>ALLOCM_ERR_NOT_MOVED</errorname></term>
-
-            <listitem><para><constant>ALLOCM_NO_MOVE</constant> was specified,
-            but the reallocation request could not be serviced without moving
-            the object.</para></listitem>
-          </varlistentry>
-        </variablelist>
-      </para>
-    </refsect2>
   </refsect1>
   <refsect1 id="environment">
     <title>ENVIRONMENT</title>
     <para>The following environment variable affects the execution of the
     allocation functions:
       <variablelist>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/manpages.xsl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/manpages.xsl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/manpages.xsl	2017-09-27 22:47:53.206963475 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/manpages.xsl	2017-09-27 22:49:14.998960477 +0800
@@ -1,4 +1,4 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:import href="/usr/share/xml/docbook/stylesheet/docbook-xsl/manpages/docbook.xsl"/>
-  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/doc/stylesheet.xsl"/>
+  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/doc/stylesheet.xsl"/>
 </xsl:stylesheet>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc: .gitattributes
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/.gitignore /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/.gitignore
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/.gitignore	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/.gitignore	2016-05-06 15:11:36.000000000 +0800
@@ -1,23 +1,25 @@
 /*.gcov.*
 
-/autom4te.cache/
-
+/bin/jemalloc-config
 /bin/jemalloc.sh
+/bin/jeprof
 
 /config.stamp
 /config.log
 /config.status
 /configure
 
 /doc/html.xsl
 /doc/manpages.xsl
 /doc/jemalloc.xml
 /doc/jemalloc.html
 /doc/jemalloc.3
 
+/jemalloc.pc
+
 /lib/
 
 /Makefile
 
 /include/jemalloc/internal/jemalloc_internal.h
 /include/jemalloc/internal/jemalloc_internal_defs.h
@@ -32,12 +34,13 @@
 /include/jemalloc/jemalloc_macros.h
 /include/jemalloc/jemalloc_mangle.h
 /include/jemalloc/jemalloc_mangle_jet.h
 /include/jemalloc/jemalloc_protos.h
 /include/jemalloc/jemalloc_protos_jet.h
 /include/jemalloc/jemalloc_rename.h
+/include/jemalloc/jemalloc_typedefs.h
 
 /src/*.[od]
 /src/*.gcda
 /src/*.gcno
 
 /test/test.sh
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/arena.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/arena.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/arena.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/arena.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,226 +1,202 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
-/*
- * RUN_MAX_OVRHD indicates maximum desired run header overhead.  Runs are sized
- * as small as possible such that this setting is still honored, without
- * violating other constraints.  The goal is to make runs as small as possible
- * without exceeding a per run external fragmentation threshold.
- *
- * We use binary fixed point math for overhead computations, where the binary
- * point is implicitly RUN_BFP bits to the left.
- *
- * Note that it is possible to set RUN_MAX_OVRHD low enough that it cannot be
- * honored for some/all object sizes, since when heap profiling is enabled
- * there is one pointer of header overhead per object (plus a constant).  This
- * constraint is relaxed (ignored) for runs that are so small that the
- * per-region overhead is greater than:
- *
- *   (RUN_MAX_OVRHD / (reg_interval << (3+RUN_BFP))
- */
-#define	RUN_BFP			12
-/*                                    \/   Implicit binary fixed point. */
-#define	RUN_MAX_OVRHD		0x0000003dU
-#define	RUN_MAX_OVRHD_RELAX	0x00001800U
+#define	LARGE_MINCLASS		(ZU(1) << LG_LARGE_MINCLASS)
 
 /* Maximum number of regions in one run. */
-#define	LG_RUN_MAXREGS		11
+#define	LG_RUN_MAXREGS		(LG_PAGE - LG_TINY_MIN)
 #define	RUN_MAXREGS		(1U << LG_RUN_MAXREGS)
 
 /*
  * Minimum redzone size.  Redzones may be larger than this if necessary to
  * preserve region alignment.
  */
 #define	REDZONE_MINSIZE		16
 
 /*
  * The minimum ratio of active:dirty pages per arena is computed as:
  *
- *   (nactive >> opt_lg_dirty_mult) >= ndirty
+ *   (nactive >> lg_dirty_mult) >= ndirty
  *
- * So, supposing that opt_lg_dirty_mult is 3, there can be no less than 8 times
- * as many active pages as dirty pages.
+ * So, supposing that lg_dirty_mult is 3, there can be no less than 8 times as
+ * many active pages as dirty pages.
  */
 #define	LG_DIRTY_MULT_DEFAULT	3
 
-typedef struct arena_chunk_map_s arena_chunk_map_t;
-typedef struct arena_chunk_s arena_chunk_t;
+typedef struct arena_runs_dirty_link_s arena_runs_dirty_link_t;
 typedef struct arena_run_s arena_run_t;
+typedef struct arena_chunk_map_bits_s arena_chunk_map_bits_t;
+typedef struct arena_chunk_map_misc_s arena_chunk_map_misc_t;
+typedef struct arena_chunk_s arena_chunk_t;
 typedef struct arena_bin_info_s arena_bin_info_t;
 typedef struct arena_bin_s arena_bin_t;
 typedef struct arena_s arena_t;
 
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
 
-/* Each element of the chunk map corresponds to one page within the chunk. */
-struct arena_chunk_map_s {
-#ifndef JEMALLOC_PROF
-	/*
-	 * Overlay prof_ctx in order to allow it to be referenced by dead code.
-	 * Such antics aren't warranted for per arena data structures, but
-	 * chunk map overhead accounts for a percentage of memory, rather than
-	 * being just a fixed cost.
-	 */
-	union {
-#endif
-	union {
-		/*
-		 * Linkage for run trees.  There are two disjoint uses:
-		 *
-		 * 1) arena_t's runs_avail tree.
-		 * 2) arena_run_t conceptually uses this linkage for in-use
-		 *    non-full runs, rather than directly embedding linkage.
-		 */
-		rb_node(arena_chunk_map_t)	rb_link;
-		/*
-		 * List of runs currently in purgatory.  arena_chunk_purge()
-		 * temporarily allocates runs that contain dirty pages while
-		 * purging, so that other threads cannot use the runs while the
-		 * purging thread is operating without the arena lock held.
-		 */
-		ql_elm(arena_chunk_map_t)	ql_link;
-	}				u;
+#ifdef JEMALLOC_ARENA_STRUCTS_A
+struct arena_run_s {
+	/* Index of bin this run is associated with. */
+	szind_t		binind;
 
-	/* Profile counters, used for large object runs. */
-	prof_ctx_t			*prof_ctx;
-#ifndef JEMALLOC_PROF
-	}; /* union { ... }; */
-#endif
+	/* Number of free regions in run. */
+	unsigned	nfree;
 
+	/* Per region allocated/deallocated bitmap. */
+	bitmap_t	bitmap[BITMAP_GROUPS_MAX];
+};
+
+/* Each element of the chunk map corresponds to one page within the chunk. */
+struct arena_chunk_map_bits_s {
 	/*
 	 * Run address (or size) and various flags are stored together.  The bit
 	 * layout looks like (assuming 32-bit system):
 	 *
-	 *   ???????? ???????? ????nnnn nnnndula
+	 *   ???????? ???????? ???nnnnn nnndumla
 	 *
 	 * ? : Unallocated: Run address for first/last pages, unset for internal
 	 *                  pages.
 	 *     Small: Run page offset.
-	 *     Large: Run size for first page, unset for trailing pages.
+	 *     Large: Run page count for first page, unset for trailing pages.
 	 * n : binind for small size class, BININD_INVALID for large size class.
 	 * d : dirty?
 	 * u : unzeroed?
+	 * m : decommitted?
 	 * l : large?
 	 * a : allocated?
 	 *
 	 * Following are example bit patterns for the three types of runs.
 	 *
 	 * p : run page offset
 	 * s : run size
 	 * n : binind for size class; large objects set these to BININD_INVALID
-	 *     except for promoted allocations (see prof_promote)
 	 * x : don't care
 	 * - : 0
 	 * + : 1
-	 * [DULA] : bit set
-	 * [dula] : bit unset
+	 * [DUMLA] : bit set
+	 * [dumla] : bit unset
 	 *
 	 *   Unallocated (clean):
-	 *     ssssssss ssssssss ssss++++ ++++du-a
-	 *     xxxxxxxx xxxxxxxx xxxxxxxx xxxx-Uxx
-	 *     ssssssss ssssssss ssss++++ ++++dU-a
+	 *     ssssssss ssssssss sss+++++ +++dum-a
+	 *     xxxxxxxx xxxxxxxx xxxxxxxx xxx-Uxxx
+	 *     ssssssss ssssssss sss+++++ +++dUm-a
 	 *
 	 *   Unallocated (dirty):
-	 *     ssssssss ssssssss ssss++++ ++++D--a
+	 *     ssssssss ssssssss sss+++++ +++D-m-a
 	 *     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
-	 *     ssssssss ssssssss ssss++++ ++++D--a
+	 *     ssssssss ssssssss sss+++++ +++D-m-a
 	 *
 	 *   Small:
-	 *     pppppppp pppppppp ppppnnnn nnnnd--A
-	 *     pppppppp pppppppp ppppnnnn nnnn---A
-	 *     pppppppp pppppppp ppppnnnn nnnnd--A
+	 *     pppppppp pppppppp pppnnnnn nnnd---A
+	 *     pppppppp pppppppp pppnnnnn nnn----A
+	 *     pppppppp pppppppp pppnnnnn nnnd---A
 	 *
 	 *   Large:
-	 *     ssssssss ssssssss ssss++++ ++++D-LA
+	 *     ssssssss ssssssss sss+++++ +++D--LA
 	 *     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
-	 *     -------- -------- ----++++ ++++D-LA
+	 *     -------- -------- ---+++++ +++D--LA
 	 *
-	 *   Large (sampled, size <= PAGE):
-	 *     ssssssss ssssssss ssssnnnn nnnnD-LA
+	 *   Large (sampled, size <= LARGE_MINCLASS):
+	 *     ssssssss ssssssss sssnnnnn nnnD--LA
+	 *     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
+	 *     -------- -------- ---+++++ +++D--LA
 	 *
-	 *   Large (not sampled, size == PAGE):
-	 *     ssssssss ssssssss ssss++++ ++++D-LA
+	 *   Large (not sampled, size == LARGE_MINCLASS):
+	 *     ssssssss ssssssss sss+++++ +++D--LA
+	 *     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
+	 *     -------- -------- ---+++++ +++D--LA
 	 */
 	size_t				bits;
-#define	CHUNK_MAP_BININD_SHIFT	4
+#define	CHUNK_MAP_ALLOCATED	((size_t)0x01U)
+#define	CHUNK_MAP_LARGE		((size_t)0x02U)
+#define	CHUNK_MAP_STATE_MASK	((size_t)0x3U)
+
+#define	CHUNK_MAP_DECOMMITTED	((size_t)0x04U)
+#define	CHUNK_MAP_UNZEROED	((size_t)0x08U)
+#define	CHUNK_MAP_DIRTY		((size_t)0x10U)
+#define	CHUNK_MAP_FLAGS_MASK	((size_t)0x1cU)
+
+#define	CHUNK_MAP_BININD_SHIFT	5
 #define	BININD_INVALID		((size_t)0xffU)
-/*     CHUNK_MAP_BININD_MASK == (BININD_INVALID << CHUNK_MAP_BININD_SHIFT) */
-#define	CHUNK_MAP_BININD_MASK	((size_t)0xff0U)
+#define	CHUNK_MAP_BININD_MASK	(BININD_INVALID << CHUNK_MAP_BININD_SHIFT)
 #define	CHUNK_MAP_BININD_INVALID CHUNK_MAP_BININD_MASK
-#define	CHUNK_MAP_FLAGS_MASK	((size_t)0xcU)
-#define	CHUNK_MAP_DIRTY		((size_t)0x8U)
-#define	CHUNK_MAP_UNZEROED	((size_t)0x4U)
-#define	CHUNK_MAP_LARGE		((size_t)0x2U)
-#define	CHUNK_MAP_ALLOCATED	((size_t)0x1U)
-#define	CHUNK_MAP_KEY		CHUNK_MAP_ALLOCATED
+
+#define	CHUNK_MAP_RUNIND_SHIFT	(CHUNK_MAP_BININD_SHIFT + 8)
+#define	CHUNK_MAP_SIZE_SHIFT	(CHUNK_MAP_RUNIND_SHIFT - LG_PAGE)
+#define	CHUNK_MAP_SIZE_MASK						\
+    (~(CHUNK_MAP_BININD_MASK | CHUNK_MAP_FLAGS_MASK | CHUNK_MAP_STATE_MASK))
 };
-typedef rb_tree(arena_chunk_map_t) arena_avail_tree_t;
-typedef rb_tree(arena_chunk_map_t) arena_run_tree_t;
-typedef ql_head(arena_chunk_map_t) arena_chunk_mapelms_t;
 
-/* Arena chunk header. */
-struct arena_chunk_s {
-	/* Arena that owns the chunk. */
-	arena_t			*arena;
+struct arena_runs_dirty_link_s {
+	qr(arena_runs_dirty_link_t)	rd_link;
+};
+
+/*
+ * Each arena_chunk_map_misc_t corresponds to one page within the chunk, just
+ * like arena_chunk_map_bits_t.  Two separate arrays are stored within each
+ * chunk header in order to improve cache locality.
+ */
+struct arena_chunk_map_misc_s {
+	/*
+	 * Linkage for run trees.  There are two disjoint uses:
+	 *
+	 * 1) arena_t's runs_avail tree.
+	 * 2) arena_run_t conceptually uses this linkage for in-use non-full
+	 *    runs, rather than directly embedding linkage.
+	 */
+	rb_node(arena_chunk_map_misc_t)		rb_link;
 
-	/* Linkage for tree of arena chunks that contain dirty runs. */
-	rb_node(arena_chunk_t)	dirty_link;
+	union {
+		/* Linkage for list of dirty runs. */
+		arena_runs_dirty_link_t		rd;
 
-	/* Number of dirty pages. */
-	size_t			ndirty;
+		/* Profile counters, used for large object runs. */
+		union {
+			void				*prof_tctx_pun;
+			prof_tctx_t			*prof_tctx;
+		};
 
-	/* Number of available runs. */
-	size_t			nruns_avail;
+		/* Small region run metadata. */
+		arena_run_t			run;
+	};
+};
+typedef rb_tree(arena_chunk_map_misc_t) arena_avail_tree_t;
+typedef rb_tree(arena_chunk_map_misc_t) arena_run_tree_t;
+#endif /* JEMALLOC_ARENA_STRUCTS_A */
 
+#ifdef JEMALLOC_ARENA_STRUCTS_B
+/* Arena chunk header. */
+struct arena_chunk_s {
 	/*
-	 * Number of available run adjacencies that purging could coalesce.
-	 * Clean and dirty available runs are not coalesced, which causes
-	 * virtual memory fragmentation.  The ratio of
-	 * (nruns_avail-nruns_adjac):nruns_adjac is used for tracking this
-	 * fragmentation.
+	 * A pointer to the arena that owns the chunk is stored within the node.
+	 * This field as a whole is used by chunks_rtree to support both
+	 * ivsalloc() and core-based debugging.
 	 */
-	size_t			nruns_adjac;
+	extent_node_t		node;
 
 	/*
 	 * Map of pages within chunk that keeps track of free/large/small.  The
 	 * first map_bias entries are omitted, since the chunk header does not
 	 * need to be tracked in the map.  This omission saves a header page
 	 * for common chunk sizes (e.g. 4 MiB).
 	 */
-	arena_chunk_map_t	map[1]; /* Dynamically sized. */
-};
-typedef rb_tree(arena_chunk_t) arena_chunk_tree_t;
-
-struct arena_run_s {
-	/* Bin this run is associated with. */
-	arena_bin_t	*bin;
-
-	/* Index of next region that has never been allocated, or nregs. */
-	uint32_t	nextind;
-
-	/* Number of free regions in run. */
-	unsigned	nfree;
+	arena_chunk_map_bits_t	map_bits[1]; /* Dynamically sized. */
 };
 
 /*
  * Read-only information associated with each element of arena_t's bins array
  * is stored separately, partly to reduce memory usage (only one copy, rather
  * than one per arena), but mainly to avoid false cacheline sharing.
  *
  * Each run has the following layout:
  *
  *               /--------------------\
- *               | arena_run_t header |
- *               | ...                |
- * bitmap_offset | bitmap             |
- *               | ...                |
- *   ctx0_offset | ctx map            |
- *               | ...                |
+ *               | pad?               |
  *               |--------------------|
  *               | redzone            |
  *   reg0_offset | region 0           |
  *               | redzone            |
  *               |--------------------| \
  *               | redzone            | |
@@ -256,29 +232,17 @@
 	size_t		run_size;
 
 	/* Total number of regions in a run for this bin's size class. */
 	uint32_t	nregs;
 
 	/*
-	 * Offset of first bitmap_t element in a run header for this bin's size
-	 * class.
-	 */
-	uint32_t	bitmap_offset;
-
-	/*
 	 * Metadata used to manipulate bitmaps for runs associated with this
 	 * bin.
 	 */
 	bitmap_info_t	bitmap_info;
 
-	/*
-	 * Offset of first (prof_ctx_t *) in a run header for this bin's size
-	 * class, or 0 if (config_prof == false || opt_prof == false).
-	 */
-	uint32_t	ctx0_offset;
-
 	/* Offset of first region in a run for this bin's size class. */
 	uint32_t	reg0_offset;
 };
 
 struct arena_bin_s {
 	/*
@@ -318,32 +282,35 @@
 	 */
 	unsigned		nthreads;
 
 	/*
 	 * There are three classes of arena operations from a locking
 	 * perspective:
-	 * 1) Thread asssignment (modifies nthreads) is protected by
-	 *    arenas_lock.
+	 * 1) Thread assignment (modifies nthreads) is protected by arenas_lock.
 	 * 2) Bin-related operations are protected by bin locks.
 	 * 3) Chunk- and run-related operations are protected by this mutex.
 	 */
 	malloc_mutex_t		lock;
 
 	arena_stats_t		stats;
 	/*
 	 * List of tcaches for extant threads associated with this arena.
-	 * Stats from these are merged incrementally, and at exit.
+	 * Stats from these are merged incrementally, and at exit if
+	 * opt_stats_print is enabled.
 	 */
 	ql_head(tcache_t)	tcache_ql;
 
 	uint64_t		prof_accumbytes;
 
-	dss_prec_t		dss_prec;
+	/*
+	 * PRNG state for cache index randomization of large allocation base
+	 * pointers.
+	 */
+	uint64_t		offset_state;
 
-	/* Tree of dirty-page-containing chunks this arena manages. */
-	arena_chunk_tree_t	chunks_dirty;
+	dss_prec_t		dss_prec;
 
 	/*
 	 * In order to avoid rapid chunk allocation/deallocation when an arena
 	 * oscillates right on the cusp of needing a new chunk, cache the most
 	 * recently freed chunk.  The spare is left in the arena's chunk trees
 	 * until it is deleted.
@@ -351,62 +318,140 @@
 	 * There is one spare chunk per arena, rather than one spare total, in
 	 * order to avoid interactions between multiple threads that could make
 	 * a single spare inadequate.
 	 */
 	arena_chunk_t		*spare;
 
-	/* Number of pages in active runs. */
+	/* Minimum ratio (log base 2) of nactive:ndirty. */
+	ssize_t			lg_dirty_mult;
+
+	/* True if a thread is currently executing arena_purge(). */
+	bool			purging;
+
+	/* Number of pages in active runs and huge regions. */
 	size_t			nactive;
 
 	/*
 	 * Current count of pages within unused runs that are potentially
 	 * dirty, and for which madvise(... MADV_DONTNEED) has not been called.
 	 * By tracking this, we can institute a limit on how much dirty unused
 	 * memory is mapped for each arena.
 	 */
 	size_t			ndirty;
 
 	/*
-	 * Approximate number of pages being purged.  It is possible for
-	 * multiple threads to purge dirty pages concurrently, and they use
-	 * npurgatory to indicate the total number of pages all threads are
-	 * attempting to purge.
+	 * Size/address-ordered tree of this arena's available runs.  The tree
+	 * is used for first-best-fit run allocation.
 	 */
-	size_t			npurgatory;
+	arena_avail_tree_t	runs_avail;
 
 	/*
-	 * Size/address-ordered trees of this arena's available runs.  The trees
-	 * are used for first-best-fit run allocation.
+	 * Unused dirty memory this arena manages.  Dirty memory is conceptually
+	 * tracked as an arbitrarily interleaved LRU of dirty runs and cached
+	 * chunks, but the list linkage is actually semi-duplicated in order to
+	 * avoid extra arena_chunk_map_misc_t space overhead.
+	 *
+	 *   LRU-----------------------------------------------------------MRU
+	 *
+	 *        /-- arena ---\
+	 *        |            |
+	 *        |            |
+	 *        |------------|                             /- chunk -\
+	 *   ...->|chunks_cache|<--------------------------->|  /----\ |<--...
+	 *        |------------|                             |  |node| |
+	 *        |            |                             |  |    | |
+	 *        |            |    /- run -\    /- run -\   |  |    | |
+	 *        |            |    |       |    |       |   |  |    | |
+	 *        |            |    |       |    |       |   |  |    | |
+	 *        |------------|    |-------|    |-------|   |  |----| |
+	 *   ...->|runs_dirty  |<-->|rd     |<-->|rd     |<---->|rd  |<----...
+	 *        |------------|    |-------|    |-------|   |  |----| |
+	 *        |            |    |       |    |       |   |  |    | |
+	 *        |            |    |       |    |       |   |  \----/ |
+	 *        |            |    \-------/    \-------/   |         |
+	 *        |            |                             |         |
+	 *        |            |                             |         |
+	 *        \------------/                             \---------/
 	 */
-	arena_avail_tree_t	runs_avail;
+	arena_runs_dirty_link_t	runs_dirty;
+	extent_node_t		chunks_cache;
+
+	/* Extant huge allocations. */
+	ql_head(extent_node_t)	huge;
+	/* Synchronizes all huge allocation/update/deallocation. */
+	malloc_mutex_t		huge_mtx;
+
+	/*
+	 * Trees of chunks that were previously allocated (trees differ only in
+	 * node ordering).  These are used when allocating chunks, in an attempt
+	 * to re-use address space.  Depending on function, different tree
+	 * orderings are needed, which is why there are two trees with the same
+	 * contents.
+	 */
+	extent_tree_t		chunks_szad_cached;
+	extent_tree_t		chunks_ad_cached;
+	extent_tree_t		chunks_szad_retained;
+	extent_tree_t		chunks_ad_retained;
+
+	malloc_mutex_t		chunks_mtx;
+	/* Cache of nodes that were allocated via base_alloc(). */
+	ql_head(extent_node_t)	node_cache;
+	malloc_mutex_t		node_cache_mtx;
+
+	/* User-configurable chunk hook functions. */
+	chunk_hooks_t		chunk_hooks;
 
 	/* bins is used to store trees of free regions. */
 	arena_bin_t		bins[NBINS];
 };
+#endif /* JEMALLOC_ARENA_STRUCTS_B */
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-extern ssize_t	opt_lg_dirty_mult;
-/*
- * small_size2bin is a compact lookup table that rounds request sizes up to
- * size classes.  In order to reduce cache footprint, the table is compressed,
- * and all accesses are via the SMALL_SIZE2BIN macro.
- */
-extern uint8_t const	small_size2bin[];
-#define	SMALL_SIZE2BIN(s)	(small_size2bin[(s-1) >> LG_TINY_MIN])
+static const size_t	large_pad =
+#ifdef JEMALLOC_CACHE_OBLIVIOUS
+    PAGE
+#else
+    0
+#endif
+    ;
 
-extern arena_bin_info_t	arena_bin_info[NBINS];
+extern ssize_t		opt_lg_dirty_mult;
 
-/* Number of large size classes. */
-#define			nlclasses (chunk_npages - map_bias)
+extern arena_bin_info_t	arena_bin_info[NBINS];
 
+extern size_t		map_bias; /* Number of arena chunk header pages. */
+extern size_t		map_misc_offset;
+extern size_t		arena_maxrun; /* Max run size for arenas. */
+extern size_t		large_maxclass; /* Max large size class. */
+extern unsigned		nlclasses; /* Number of large size classes. */
+extern unsigned		nhclasses; /* Number of huge size classes. */
+
+void	arena_chunk_cache_maybe_insert(arena_t *arena, extent_node_t *node,
+    bool cache);
+void	arena_chunk_cache_maybe_remove(arena_t *arena, extent_node_t *node,
+    bool cache);
+extent_node_t	*arena_node_alloc(arena_t *arena);
+void	arena_node_dalloc(arena_t *arena, extent_node_t *node);
+void	*arena_chunk_alloc_huge(arena_t *arena, size_t usize, size_t alignment,
+    bool *zero);
+void	arena_chunk_dalloc_huge(arena_t *arena, void *chunk, size_t usize);
+void	arena_chunk_ralloc_huge_similar(arena_t *arena, void *chunk,
+    size_t oldsize, size_t usize);
+void	arena_chunk_ralloc_huge_shrink(arena_t *arena, void *chunk,
+    size_t oldsize, size_t usize);
+bool	arena_chunk_ralloc_huge_expand(arena_t *arena, void *chunk,
+    size_t oldsize, size_t usize, bool *zero);
+ssize_t	arena_lg_dirty_mult_get(arena_t *arena);
+bool	arena_lg_dirty_mult_set(arena_t *arena, ssize_t lg_dirty_mult);
+void	arena_maybe_purge(arena_t *arena);
 void	arena_purge_all(arena_t *arena);
 void	arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin,
-    size_t binind, uint64_t prof_accumbytes);
+    szind_t binind, uint64_t prof_accumbytes);
 void	arena_alloc_junk_small(void *ptr, arena_bin_info_t *bin_info,
     bool zero);
 #ifdef JEMALLOC_JET
 typedef void (arena_redzone_corruption_t)(void *, size_t, bool, size_t,
     uint8_t);
 extern arena_redzone_corruption_t *arena_redzone_corruption;
@@ -415,110 +460,189 @@
 #else
 void	arena_dalloc_junk_small(void *ptr, arena_bin_info_t *bin_info);
 #endif
 void	arena_quarantine_junk_small(void *ptr, size_t usize);
 void	*arena_malloc_small(arena_t *arena, size_t size, bool zero);
 void	*arena_malloc_large(arena_t *arena, size_t size, bool zero);
-void	*arena_palloc(arena_t *arena, size_t size, size_t alignment, bool zero);
+void	*arena_palloc(tsd_t *tsd, arena_t *arena, size_t usize,
+    size_t alignment, bool zero, tcache_t *tcache);
 void	arena_prof_promoted(const void *ptr, size_t size);
-void	arena_dalloc_bin_locked(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    arena_chunk_map_t *mapelm);
+void	arena_dalloc_bin_junked_locked(arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, arena_chunk_map_bits_t *bitselm);
 void	arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    size_t pageind, arena_chunk_map_t *mapelm);
+    size_t pageind, arena_chunk_map_bits_t *bitselm);
 void	arena_dalloc_small(arena_t *arena, arena_chunk_t *chunk, void *ptr,
     size_t pageind);
 #ifdef JEMALLOC_JET
 typedef void (arena_dalloc_junk_large_t)(void *, size_t);
 extern arena_dalloc_junk_large_t *arena_dalloc_junk_large;
+#else
+void	arena_dalloc_junk_large(void *ptr, size_t usize);
 #endif
-void	arena_dalloc_large_locked(arena_t *arena, arena_chunk_t *chunk,
+void	arena_dalloc_large_junked_locked(arena_t *arena, arena_chunk_t *chunk,
     void *ptr);
 void	arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr);
 #ifdef JEMALLOC_JET
 typedef void (arena_ralloc_junk_large_t)(void *, size_t, size_t);
 extern arena_ralloc_junk_large_t *arena_ralloc_junk_large;
 #endif
 bool	arena_ralloc_no_move(void *ptr, size_t oldsize, size_t size,
     size_t extra, bool zero);
-void	*arena_ralloc(arena_t *arena, void *ptr, size_t oldsize, size_t size,
-    size_t extra, size_t alignment, bool zero, bool try_tcache_alloc,
-    bool try_tcache_dalloc);
+void	*arena_ralloc(tsd_t *tsd, arena_t *arena, void *ptr, size_t oldsize,
+    size_t size, size_t alignment, bool zero, tcache_t *tcache);
 dss_prec_t	arena_dss_prec_get(arena_t *arena);
-void	arena_dss_prec_set(arena_t *arena, dss_prec_t dss_prec);
-void	arena_stats_merge(arena_t *arena, const char **dss, size_t *nactive,
-    size_t *ndirty, arena_stats_t *astats, malloc_bin_stats_t *bstats,
-    malloc_large_stats_t *lstats);
-bool	arena_new(arena_t *arena, unsigned ind);
-void	arena_boot(void);
+bool	arena_dss_prec_set(arena_t *arena, dss_prec_t dss_prec);
+ssize_t	arena_lg_dirty_mult_default_get(void);
+bool	arena_lg_dirty_mult_default_set(ssize_t lg_dirty_mult);
+void	arena_stats_merge(arena_t *arena, const char **dss,
+    ssize_t *lg_dirty_mult, size_t *nactive, size_t *ndirty,
+    arena_stats_t *astats, malloc_bin_stats_t *bstats,
+    malloc_large_stats_t *lstats, malloc_huge_stats_t *hstats);
+arena_t	*arena_new(unsigned ind);
+bool	arena_boot(void);
 void	arena_prefork(arena_t *arena);
 void	arena_postfork_parent(arena_t *arena);
 void	arena_postfork_child(arena_t *arena);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
-arena_chunk_map_t	*arena_mapp_get(arena_chunk_t *chunk, size_t pageind);
+arena_chunk_map_bits_t	*arena_bitselm_get(arena_chunk_t *chunk,
+    size_t pageind);
+arena_chunk_map_misc_t	*arena_miscelm_get(arena_chunk_t *chunk,
+    size_t pageind);
+size_t	arena_miscelm_to_pageind(arena_chunk_map_misc_t *miscelm);
+void	*arena_miscelm_to_rpages(arena_chunk_map_misc_t *miscelm);
+arena_chunk_map_misc_t	*arena_rd_to_miscelm(arena_runs_dirty_link_t *rd);
+arena_chunk_map_misc_t	*arena_run_to_miscelm(arena_run_t *run);
 size_t	*arena_mapbitsp_get(arena_chunk_t *chunk, size_t pageind);
 size_t	arena_mapbitsp_read(size_t *mapbitsp);
 size_t	arena_mapbits_get(arena_chunk_t *chunk, size_t pageind);
+size_t	arena_mapbits_size_decode(size_t mapbits);
 size_t	arena_mapbits_unallocated_size_get(arena_chunk_t *chunk,
     size_t pageind);
 size_t	arena_mapbits_large_size_get(arena_chunk_t *chunk, size_t pageind);
 size_t	arena_mapbits_small_runind_get(arena_chunk_t *chunk, size_t pageind);
-size_t	arena_mapbits_binind_get(arena_chunk_t *chunk, size_t pageind);
+szind_t	arena_mapbits_binind_get(arena_chunk_t *chunk, size_t pageind);
 size_t	arena_mapbits_dirty_get(arena_chunk_t *chunk, size_t pageind);
 size_t	arena_mapbits_unzeroed_get(arena_chunk_t *chunk, size_t pageind);
+size_t	arena_mapbits_decommitted_get(arena_chunk_t *chunk, size_t pageind);
 size_t	arena_mapbits_large_get(arena_chunk_t *chunk, size_t pageind);
 size_t	arena_mapbits_allocated_get(arena_chunk_t *chunk, size_t pageind);
 void	arena_mapbitsp_write(size_t *mapbitsp, size_t mapbits);
+size_t	arena_mapbits_size_encode(size_t size);
 void	arena_mapbits_unallocated_set(arena_chunk_t *chunk, size_t pageind,
     size_t size, size_t flags);
 void	arena_mapbits_unallocated_size_set(arena_chunk_t *chunk, size_t pageind,
     size_t size);
+void	arena_mapbits_internal_set(arena_chunk_t *chunk, size_t pageind,
+    size_t flags);
 void	arena_mapbits_large_set(arena_chunk_t *chunk, size_t pageind,
     size_t size, size_t flags);
 void	arena_mapbits_large_binind_set(arena_chunk_t *chunk, size_t pageind,
-    size_t binind);
+    szind_t binind);
 void	arena_mapbits_small_set(arena_chunk_t *chunk, size_t pageind,
-    size_t runind, size_t binind, size_t flags);
-void	arena_mapbits_unzeroed_set(arena_chunk_t *chunk, size_t pageind,
-    size_t unzeroed);
+    size_t runind, szind_t binind, size_t flags);
+void	arena_metadata_allocated_add(arena_t *arena, size_t size);
+void	arena_metadata_allocated_sub(arena_t *arena, size_t size);
+size_t	arena_metadata_allocated_get(arena_t *arena);
 bool	arena_prof_accum_impl(arena_t *arena, uint64_t accumbytes);
 bool	arena_prof_accum_locked(arena_t *arena, uint64_t accumbytes);
 bool	arena_prof_accum(arena_t *arena, uint64_t accumbytes);
-size_t	arena_ptr_small_binind_get(const void *ptr, size_t mapbits);
-size_t	arena_bin_index(arena_t *arena, arena_bin_t *bin);
+szind_t	arena_ptr_small_binind_get(const void *ptr, size_t mapbits);
+szind_t	arena_bin_index(arena_t *arena, arena_bin_t *bin);
 unsigned	arena_run_regind(arena_run_t *run, arena_bin_info_t *bin_info,
     const void *ptr);
-prof_ctx_t	*arena_prof_ctx_get(const void *ptr);
-void	arena_prof_ctx_set(const void *ptr, size_t usize, prof_ctx_t *ctx);
-void	*arena_malloc(arena_t *arena, size_t size, bool zero, bool try_tcache);
+prof_tctx_t	*arena_prof_tctx_get(const void *ptr);
+void	arena_prof_tctx_set(const void *ptr, size_t usize, prof_tctx_t *tctx);
+void	arena_prof_tctx_reset(const void *ptr, size_t usize,
+    const void *old_ptr, prof_tctx_t *old_tctx);
+void	*arena_malloc(tsd_t *tsd, arena_t *arena, size_t size, bool zero,
+    tcache_t *tcache);
+arena_t	*arena_aalloc(const void *ptr);
 size_t	arena_salloc(const void *ptr, bool demote);
-void	arena_dalloc(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    bool try_tcache);
+void	arena_dalloc(tsd_t *tsd, void *ptr, tcache_t *tcache);
+void	arena_sdalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_ARENA_C_))
 #  ifdef JEMALLOC_ARENA_INLINE_A
-JEMALLOC_ALWAYS_INLINE arena_chunk_map_t *
-arena_mapp_get(arena_chunk_t *chunk, size_t pageind)
+JEMALLOC_ALWAYS_INLINE arena_chunk_map_bits_t *
+arena_bitselm_get(arena_chunk_t *chunk, size_t pageind)
 {
 
 	assert(pageind >= map_bias);
 	assert(pageind < chunk_npages);
 
-	return (&chunk->map[pageind-map_bias]);
+	return (&chunk->map_bits[pageind-map_bias]);
+}
+
+JEMALLOC_ALWAYS_INLINE arena_chunk_map_misc_t *
+arena_miscelm_get(arena_chunk_t *chunk, size_t pageind)
+{
+
+	assert(pageind >= map_bias);
+	assert(pageind < chunk_npages);
+
+	return ((arena_chunk_map_misc_t *)((uintptr_t)chunk +
+	    (uintptr_t)map_misc_offset) + pageind-map_bias);
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+arena_miscelm_to_pageind(arena_chunk_map_misc_t *miscelm)
+{
+	arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(miscelm);
+	size_t pageind = ((uintptr_t)miscelm - ((uintptr_t)chunk +
+	    map_misc_offset)) / sizeof(arena_chunk_map_misc_t) + map_bias;
+
+	assert(pageind >= map_bias);
+	assert(pageind < chunk_npages);
+
+	return (pageind);
+}
+
+JEMALLOC_ALWAYS_INLINE void *
+arena_miscelm_to_rpages(arena_chunk_map_misc_t *miscelm)
+{
+	arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(miscelm);
+	size_t pageind = arena_miscelm_to_pageind(miscelm);
+
+	return ((void *)((uintptr_t)chunk + (pageind << LG_PAGE)));
+}
+
+JEMALLOC_ALWAYS_INLINE arena_chunk_map_misc_t *
+arena_rd_to_miscelm(arena_runs_dirty_link_t *rd)
+{
+	arena_chunk_map_misc_t *miscelm = (arena_chunk_map_misc_t
+	    *)((uintptr_t)rd - offsetof(arena_chunk_map_misc_t, rd));
+
+	assert(arena_miscelm_to_pageind(miscelm) >= map_bias);
+	assert(arena_miscelm_to_pageind(miscelm) < chunk_npages);
+
+	return (miscelm);
+}
+
+JEMALLOC_ALWAYS_INLINE arena_chunk_map_misc_t *
+arena_run_to_miscelm(arena_run_t *run)
+{
+	arena_chunk_map_misc_t *miscelm = (arena_chunk_map_misc_t
+	    *)((uintptr_t)run - offsetof(arena_chunk_map_misc_t, run));
+
+	assert(arena_miscelm_to_pageind(miscelm) >= map_bias);
+	assert(arena_miscelm_to_pageind(miscelm) < chunk_npages);
+
+	return (miscelm);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t *
 arena_mapbitsp_get(arena_chunk_t *chunk, size_t pageind)
 {
 
-	return (&arena_mapp_get(chunk, pageind)->bits);
+	return (&arena_bitselm_get(chunk, pageind)->bits);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 arena_mapbitsp_read(size_t *mapbitsp)
 {
 
@@ -530,48 +654,64 @@
 {
 
 	return (arena_mapbitsp_read(arena_mapbitsp_get(chunk, pageind)));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
+arena_mapbits_size_decode(size_t mapbits)
+{
+	size_t size;
+
+#if CHUNK_MAP_SIZE_SHIFT > 0
+	size = (mapbits & CHUNK_MAP_SIZE_MASK) >> CHUNK_MAP_SIZE_SHIFT;
+#elif CHUNK_MAP_SIZE_SHIFT == 0
+	size = mapbits & CHUNK_MAP_SIZE_MASK;
+#else
+	size = (mapbits & CHUNK_MAP_SIZE_MASK) << -CHUNK_MAP_SIZE_SHIFT;
+#endif
+
+	return (size);
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
 arena_mapbits_unallocated_size_get(arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	assert((mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) == 0);
-	return (mapbits & ~PAGE_MASK);
+	return (arena_mapbits_size_decode(mapbits));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 arena_mapbits_large_size_get(arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	assert((mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) ==
 	    (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED));
-	return (mapbits & ~PAGE_MASK);
+	return (arena_mapbits_size_decode(mapbits));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 arena_mapbits_small_runind_get(arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	assert((mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) ==
 	    CHUNK_MAP_ALLOCATED);
-	return (mapbits >> LG_PAGE);
+	return (mapbits >> CHUNK_MAP_RUNIND_SHIFT);
 }
 
-JEMALLOC_ALWAYS_INLINE size_t
+JEMALLOC_ALWAYS_INLINE szind_t
 arena_mapbits_binind_get(arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
-	size_t binind;
+	szind_t binind;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	binind = (mapbits & CHUNK_MAP_BININD_MASK) >> CHUNK_MAP_BININD_SHIFT;
 	assert(binind < NBINS || binind == BININD_INVALID);
 	return (binind);
 }
@@ -579,25 +719,40 @@
 JEMALLOC_ALWAYS_INLINE size_t
 arena_mapbits_dirty_get(arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
+	assert((mapbits & CHUNK_MAP_DECOMMITTED) == 0 || (mapbits &
+	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
 	return (mapbits & CHUNK_MAP_DIRTY);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 arena_mapbits_unzeroed_get(arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
+	assert((mapbits & CHUNK_MAP_DECOMMITTED) == 0 || (mapbits &
+	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
 	return (mapbits & CHUNK_MAP_UNZEROED);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
+arena_mapbits_decommitted_get(arena_chunk_t *chunk, size_t pageind)
+{
+	size_t mapbits;
+
+	mapbits = arena_mapbits_get(chunk, pageind);
+	assert((mapbits & CHUNK_MAP_DECOMMITTED) == 0 || (mapbits &
+	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
+	return (mapbits & CHUNK_MAP_DECOMMITTED);
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
 arena_mapbits_large_get(arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	return (mapbits & CHUNK_MAP_LARGE);
@@ -616,89 +771,126 @@
 arena_mapbitsp_write(size_t *mapbitsp, size_t mapbits)
 {
 
 	*mapbitsp = mapbits;
 }
 
+JEMALLOC_ALWAYS_INLINE size_t
+arena_mapbits_size_encode(size_t size)
+{
+	size_t mapbits;
+
+#if CHUNK_MAP_SIZE_SHIFT > 0
+	mapbits = size << CHUNK_MAP_SIZE_SHIFT;
+#elif CHUNK_MAP_SIZE_SHIFT == 0
+	mapbits = size;
+#else
+	mapbits = size >> -CHUNK_MAP_SIZE_SHIFT;
+#endif
+
+	assert((mapbits & ~CHUNK_MAP_SIZE_MASK) == 0);
+	return (mapbits);
+}
+
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_unallocated_set(arena_chunk_t *chunk, size_t pageind, size_t size,
     size_t flags)
 {
 	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
 
 	assert((size & PAGE_MASK) == 0);
-	assert((flags & ~CHUNK_MAP_FLAGS_MASK) == 0);
-	assert((flags & (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == flags);
-	arena_mapbitsp_write(mapbitsp, size | CHUNK_MAP_BININD_INVALID | flags);
+	assert((flags & CHUNK_MAP_FLAGS_MASK) == flags);
+	assert((flags & CHUNK_MAP_DECOMMITTED) == 0 || (flags &
+	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
+	arena_mapbitsp_write(mapbitsp, arena_mapbits_size_encode(size) |
+	    CHUNK_MAP_BININD_INVALID | flags);
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_unallocated_size_set(arena_chunk_t *chunk, size_t pageind,
     size_t size)
 {
 	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
 	size_t mapbits = arena_mapbitsp_read(mapbitsp);
 
 	assert((size & PAGE_MASK) == 0);
 	assert((mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) == 0);
-	arena_mapbitsp_write(mapbitsp, size | (mapbits & PAGE_MASK));
+	arena_mapbitsp_write(mapbitsp, arena_mapbits_size_encode(size) |
+	    (mapbits & ~CHUNK_MAP_SIZE_MASK));
+}
+
+JEMALLOC_ALWAYS_INLINE void
+arena_mapbits_internal_set(arena_chunk_t *chunk, size_t pageind, size_t flags)
+{
+	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
+
+	assert((flags & CHUNK_MAP_UNZEROED) == flags);
+	arena_mapbitsp_write(mapbitsp, flags);
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_large_set(arena_chunk_t *chunk, size_t pageind, size_t size,
     size_t flags)
 {
 	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
-	size_t mapbits = arena_mapbitsp_read(mapbitsp);
-	size_t unzeroed;
 
 	assert((size & PAGE_MASK) == 0);
-	assert((flags & CHUNK_MAP_DIRTY) == flags);
-	unzeroed = mapbits & CHUNK_MAP_UNZEROED; /* Preserve unzeroed. */
-	arena_mapbitsp_write(mapbitsp, size | CHUNK_MAP_BININD_INVALID | flags
-	    | unzeroed | CHUNK_MAP_LARGE | CHUNK_MAP_ALLOCATED);
+	assert((flags & CHUNK_MAP_FLAGS_MASK) == flags);
+	assert((flags & CHUNK_MAP_DECOMMITTED) == 0 || (flags &
+	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
+	arena_mapbitsp_write(mapbitsp, arena_mapbits_size_encode(size) |
+	    CHUNK_MAP_BININD_INVALID | flags | CHUNK_MAP_LARGE |
+	    CHUNK_MAP_ALLOCATED);
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_large_binind_set(arena_chunk_t *chunk, size_t pageind,
-    size_t binind)
+    szind_t binind)
 {
 	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
 	size_t mapbits = arena_mapbitsp_read(mapbitsp);
 
 	assert(binind <= BININD_INVALID);
-	assert(arena_mapbits_large_size_get(chunk, pageind) == PAGE);
+	assert(arena_mapbits_large_size_get(chunk, pageind) == LARGE_MINCLASS +
+	    large_pad);
 	arena_mapbitsp_write(mapbitsp, (mapbits & ~CHUNK_MAP_BININD_MASK) |
 	    (binind << CHUNK_MAP_BININD_SHIFT));
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_small_set(arena_chunk_t *chunk, size_t pageind, size_t runind,
-    size_t binind, size_t flags)
+    szind_t binind, size_t flags)
 {
 	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
-	size_t mapbits = arena_mapbitsp_read(mapbitsp);
-	size_t unzeroed;
 
 	assert(binind < BININD_INVALID);
 	assert(pageind - runind >= map_bias);
-	assert((flags & CHUNK_MAP_DIRTY) == flags);
-	unzeroed = mapbits & CHUNK_MAP_UNZEROED; /* Preserve unzeroed. */
-	arena_mapbitsp_write(mapbitsp, (runind << LG_PAGE) | (binind <<
-	    CHUNK_MAP_BININD_SHIFT) | flags | unzeroed | CHUNK_MAP_ALLOCATED);
+	assert((flags & CHUNK_MAP_UNZEROED) == flags);
+	arena_mapbitsp_write(mapbitsp, (runind << CHUNK_MAP_RUNIND_SHIFT) |
+	    (binind << CHUNK_MAP_BININD_SHIFT) | flags | CHUNK_MAP_ALLOCATED);
 }
 
-JEMALLOC_ALWAYS_INLINE void
-arena_mapbits_unzeroed_set(arena_chunk_t *chunk, size_t pageind,
-    size_t unzeroed)
+JEMALLOC_INLINE void
+arena_metadata_allocated_add(arena_t *arena, size_t size)
+{
+
+	atomic_add_z(&arena->stats.metadata_allocated, size);
+}
+
+JEMALLOC_INLINE void
+arena_metadata_allocated_sub(arena_t *arena, size_t size)
 {
-	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
-	size_t mapbits = arena_mapbitsp_read(mapbitsp);
 
-	arena_mapbitsp_write(mapbitsp, (mapbits & ~CHUNK_MAP_UNZEROED) |
-	    unzeroed);
+	atomic_sub_z(&arena->stats.metadata_allocated, size);
+}
+
+JEMALLOC_INLINE size_t
+arena_metadata_allocated_get(arena_t *arena)
+{
+
+	return (atomic_read_z(&arena->stats.metadata_allocated));
 }
 
 JEMALLOC_INLINE bool
 arena_prof_accum_impl(arena_t *arena, uint64_t accumbytes)
 {
 
@@ -716,109 +908,118 @@
 JEMALLOC_INLINE bool
 arena_prof_accum_locked(arena_t *arena, uint64_t accumbytes)
 {
 
 	cassert(config_prof);
 
-	if (prof_interval == 0)
+	if (likely(prof_interval == 0))
 		return (false);
 	return (arena_prof_accum_impl(arena, accumbytes));
 }
 
 JEMALLOC_INLINE bool
 arena_prof_accum(arena_t *arena, uint64_t accumbytes)
 {
 
 	cassert(config_prof);
 
-	if (prof_interval == 0)
+	if (likely(prof_interval == 0))
 		return (false);
 
 	{
 		bool ret;
 
 		malloc_mutex_lock(&arena->lock);
 		ret = arena_prof_accum_impl(arena, accumbytes);
 		malloc_mutex_unlock(&arena->lock);
 		return (ret);
 	}
 }
 
-JEMALLOC_ALWAYS_INLINE size_t
+JEMALLOC_ALWAYS_INLINE szind_t
 arena_ptr_small_binind_get(const void *ptr, size_t mapbits)
 {
-	size_t binind;
+	szind_t binind;
 
 	binind = (mapbits & CHUNK_MAP_BININD_MASK) >> CHUNK_MAP_BININD_SHIFT;
 
 	if (config_debug) {
 		arena_chunk_t *chunk;
 		arena_t *arena;
 		size_t pageind;
 		size_t actual_mapbits;
+		size_t rpages_ind;
 		arena_run_t *run;
 		arena_bin_t *bin;
-		size_t actual_binind;
+		szind_t run_binind, actual_binind;
 		arena_bin_info_t *bin_info;
+		arena_chunk_map_misc_t *miscelm;
+		void *rpages;
 
 		assert(binind != BININD_INVALID);
 		assert(binind < NBINS);
 		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-		arena = chunk->arena;
+		arena = extent_node_arena_get(&chunk->node);
 		pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 		actual_mapbits = arena_mapbits_get(chunk, pageind);
 		assert(mapbits == actual_mapbits);
 		assert(arena_mapbits_large_get(chunk, pageind) == 0);
 		assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
-		run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
-		    (actual_mapbits >> LG_PAGE)) << LG_PAGE));
-		bin = run->bin;
+		rpages_ind = pageind - arena_mapbits_small_runind_get(chunk,
+		    pageind);
+		miscelm = arena_miscelm_get(chunk, rpages_ind);
+		run = &miscelm->run;
+		run_binind = run->binind;
+		bin = &arena->bins[run_binind];
 		actual_binind = bin - arena->bins;
-		assert(binind == actual_binind);
+		assert(run_binind == actual_binind);
 		bin_info = &arena_bin_info[actual_binind];
-		assert(((uintptr_t)ptr - ((uintptr_t)run +
+		rpages = arena_miscelm_to_rpages(miscelm);
+		assert(((uintptr_t)ptr - ((uintptr_t)rpages +
 		    (uintptr_t)bin_info->reg0_offset)) % bin_info->reg_interval
 		    == 0);
 	}
 
 	return (binind);
 }
 #  endif /* JEMALLOC_ARENA_INLINE_A */
 
 #  ifdef JEMALLOC_ARENA_INLINE_B
-JEMALLOC_INLINE size_t
+JEMALLOC_INLINE szind_t
 arena_bin_index(arena_t *arena, arena_bin_t *bin)
 {
-	size_t binind = bin - arena->bins;
+	szind_t binind = bin - arena->bins;
 	assert(binind < NBINS);
 	return (binind);
 }
 
 JEMALLOC_INLINE unsigned
 arena_run_regind(arena_run_t *run, arena_bin_info_t *bin_info, const void *ptr)
 {
 	unsigned shift, diff, regind;
 	size_t interval;
+	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
+	void *rpages = arena_miscelm_to_rpages(miscelm);
 
 	/*
 	 * Freeing a pointer lower than region zero can cause assertion
 	 * failure.
 	 */
-	assert((uintptr_t)ptr >= (uintptr_t)run +
+	assert((uintptr_t)ptr >= (uintptr_t)rpages +
 	    (uintptr_t)bin_info->reg0_offset);
 
 	/*
 	 * Avoid doing division with a variable divisor if possible.  Using
 	 * actual division here can reduce allocator throughput by over 20%!
 	 */
-	diff = (unsigned)((uintptr_t)ptr - (uintptr_t)run -
+	diff = (unsigned)((uintptr_t)ptr - (uintptr_t)rpages -
 	    bin_info->reg0_offset);
 
 	/* Rescale (factor powers of 2 out of the numerator and denominator). */
 	interval = bin_info->reg_interval;
-	shift = ffs(interval) - 1;
+	shift = jemalloc_ffs(interval) - 1;
 	diff >>= shift;
 	interval >>= shift;
 
 	if (interval == 1) {
 		/* The divisor was a power of 2. */
 		regind = diff;
@@ -847,14 +1048,14 @@
 		    SIZE_INV(16), SIZE_INV(17), SIZE_INV(18), SIZE_INV(19),
 		    SIZE_INV(20), SIZE_INV(21), SIZE_INV(22), SIZE_INV(23),
 		    SIZE_INV(24), SIZE_INV(25), SIZE_INV(26), SIZE_INV(27),
 		    SIZE_INV(28), SIZE_INV(29), SIZE_INV(30), SIZE_INV(31)
 		};
 
-		if (interval <= ((sizeof(interval_invs) / sizeof(unsigned)) +
-		    2)) {
+		if (likely(interval <= ((sizeof(interval_invs) /
+		    sizeof(unsigned)) + 2))) {
 			regind = (diff * interval_invs[interval - 3]) >>
 			    SIZE_INV_SHIFT;
 		} else
 			regind = diff / interval;
 #undef SIZE_INV
 #undef SIZE_INV_SHIFT
@@ -862,202 +1063,285 @@
 	assert(diff == regind * interval);
 	assert(regind < bin_info->nregs);
 
 	return (regind);
 }
 
-JEMALLOC_INLINE prof_ctx_t *
-arena_prof_ctx_get(const void *ptr)
+JEMALLOC_INLINE prof_tctx_t *
+arena_prof_tctx_get(const void *ptr)
 {
-	prof_ctx_t *ret;
+	prof_tctx_t *ret;
 	arena_chunk_t *chunk;
-	size_t pageind, mapbits;
 
 	cassert(config_prof);
 	assert(ptr != NULL);
-	assert(CHUNK_ADDR2BASE(ptr) != ptr);
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-	mapbits = arena_mapbits_get(chunk, pageind);
-	assert((mapbits & CHUNK_MAP_ALLOCATED) != 0);
-	if ((mapbits & CHUNK_MAP_LARGE) == 0) {
-		if (prof_promote)
-			ret = (prof_ctx_t *)(uintptr_t)1U;
+	if (likely(chunk != ptr)) {
+		size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
+		size_t mapbits = arena_mapbits_get(chunk, pageind);
+		assert((mapbits & CHUNK_MAP_ALLOCATED) != 0);
+		if (likely((mapbits & CHUNK_MAP_LARGE) == 0))
+			ret = (prof_tctx_t *)(uintptr_t)1U;
 		else {
-			arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
-			    (uintptr_t)((pageind - (mapbits >> LG_PAGE)) <<
-			    LG_PAGE));
-			size_t binind = arena_ptr_small_binind_get(ptr,
-			    mapbits);
-			arena_bin_info_t *bin_info = &arena_bin_info[binind];
-			unsigned regind;
-
-			regind = arena_run_regind(run, bin_info, ptr);
-			ret = *(prof_ctx_t **)((uintptr_t)run +
-			    bin_info->ctx0_offset + (regind *
-			    sizeof(prof_ctx_t *)));
+			arena_chunk_map_misc_t *elm = arena_miscelm_get(chunk,
+			    pageind);
+			ret = atomic_read_p(&elm->prof_tctx_pun);
 		}
 	} else
-		ret = arena_mapp_get(chunk, pageind)->prof_ctx;
+		ret = huge_prof_tctx_get(ptr);
 
 	return (ret);
 }
 
 JEMALLOC_INLINE void
-arena_prof_ctx_set(const void *ptr, size_t usize, prof_ctx_t *ctx)
+arena_prof_tctx_set(const void *ptr, size_t usize, prof_tctx_t *tctx)
 {
 	arena_chunk_t *chunk;
-	size_t pageind;
 
 	cassert(config_prof);
 	assert(ptr != NULL);
-	assert(CHUNK_ADDR2BASE(ptr) != ptr);
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-	assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
+	if (likely(chunk != ptr)) {
+		size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 
-	if (usize > SMALL_MAXCLASS || (prof_promote &&
-	    ((uintptr_t)ctx != (uintptr_t)1U || arena_mapbits_large_get(chunk,
-	    pageind) != 0))) {
-		assert(arena_mapbits_large_get(chunk, pageind) != 0);
-		arena_mapp_get(chunk, pageind)->prof_ctx = ctx;
-	} else {
-		assert(arena_mapbits_large_get(chunk, pageind) == 0);
-		if (prof_promote == false) {
-			size_t mapbits = arena_mapbits_get(chunk, pageind);
-			arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
-			    (uintptr_t)((pageind - (mapbits >> LG_PAGE)) <<
-			    LG_PAGE));
-			size_t binind;
-			arena_bin_info_t *bin_info;
-			unsigned regind;
-
-			binind = arena_ptr_small_binind_get(ptr, mapbits);
-			bin_info = &arena_bin_info[binind];
-			regind = arena_run_regind(run, bin_info, ptr);
-
-			*((prof_ctx_t **)((uintptr_t)run +
-			    bin_info->ctx0_offset + (regind * sizeof(prof_ctx_t
-			    *)))) = ctx;
+		assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
+
+		if (unlikely(usize > SMALL_MAXCLASS || (uintptr_t)tctx >
+		    (uintptr_t)1U)) {
+			arena_chunk_map_misc_t *elm;
+
+			assert(arena_mapbits_large_get(chunk, pageind) != 0);
+
+			elm = arena_miscelm_get(chunk, pageind);
+			atomic_write_p(&elm->prof_tctx_pun, tctx);
+		} else {
+			/*
+			 * tctx must always be initialized for large runs.
+			 * Assert that the surrounding conditional logic is
+			 * equivalent to checking whether ptr refers to a large
+			 * run.
+			 */
+			assert(arena_mapbits_large_get(chunk, pageind) == 0);
 		}
+	} else
+		huge_prof_tctx_set(ptr, tctx);
+}
+
+JEMALLOC_INLINE void
+arena_prof_tctx_reset(const void *ptr, size_t usize, const void *old_ptr,
+    prof_tctx_t *old_tctx)
+{
+
+	cassert(config_prof);
+	assert(ptr != NULL);
+
+	if (unlikely(usize > SMALL_MAXCLASS || (ptr == old_ptr &&
+	    (uintptr_t)old_tctx > (uintptr_t)1U))) {
+		arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+		if (likely(chunk != ptr)) {
+			size_t pageind;
+			arena_chunk_map_misc_t *elm;
+
+			pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >>
+			    LG_PAGE;
+			assert(arena_mapbits_allocated_get(chunk, pageind) !=
+			    0);
+			assert(arena_mapbits_large_get(chunk, pageind) != 0);
+
+			elm = arena_miscelm_get(chunk, pageind);
+			atomic_write_p(&elm->prof_tctx_pun,
+			    (prof_tctx_t *)(uintptr_t)1U);
+		} else
+			huge_prof_tctx_reset(ptr);
 	}
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-arena_malloc(arena_t *arena, size_t size, bool zero, bool try_tcache)
+arena_malloc(tsd_t *tsd, arena_t *arena, size_t size, bool zero,
+    tcache_t *tcache)
 {
-	tcache_t *tcache;
 
 	assert(size != 0);
-	assert(size <= arena_maxclass);
 
-	if (size <= SMALL_MAXCLASS) {
-		if (try_tcache && (tcache = tcache_get(true)) != NULL)
-			return (tcache_alloc_small(tcache, size, zero));
-		else {
-			return (arena_malloc_small(choose_arena(arena), size,
+	arena = arena_choose(tsd, arena);
+	if (unlikely(arena == NULL))
+		return (NULL);
+
+	if (likely(size <= SMALL_MAXCLASS)) {
+		if (likely(tcache != NULL)) {
+			return (tcache_alloc_small(tsd, arena, tcache, size,
 			    zero));
-		}
-	} else {
+		} else
+			return (arena_malloc_small(arena, size, zero));
+	} else if (likely(size <= large_maxclass)) {
 		/*
 		 * Initialize tcache after checking size in order to avoid
 		 * infinite recursion during tcache initialization.
 		 */
-		if (try_tcache && size <= tcache_maxclass && (tcache =
-		    tcache_get(true)) != NULL)
-			return (tcache_alloc_large(tcache, size, zero));
-		else {
-			return (arena_malloc_large(choose_arena(arena), size,
+		if (likely(tcache != NULL) && size <= tcache_maxclass) {
+			return (tcache_alloc_large(tsd, arena, tcache, size,
 			    zero));
-		}
-	}
+		} else
+			return (arena_malloc_large(arena, size, zero));
+	} else
+		return (huge_malloc(tsd, arena, size, zero, tcache));
+}
+
+JEMALLOC_ALWAYS_INLINE arena_t *
+arena_aalloc(const void *ptr)
+{
+	arena_chunk_t *chunk;
+
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+	if (likely(chunk != ptr))
+		return (extent_node_arena_get(&chunk->node));
+	else
+		return (huge_aalloc(ptr));
 }
 
 /* Return the size of the allocation pointed to by ptr. */
 JEMALLOC_ALWAYS_INLINE size_t
 arena_salloc(const void *ptr, bool demote)
 {
 	size_t ret;
 	arena_chunk_t *chunk;
-	size_t pageind, binind;
+	size_t pageind;
+	szind_t binind;
 
 	assert(ptr != NULL);
-	assert(CHUNK_ADDR2BASE(ptr) != ptr);
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-	assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
-	binind = arena_mapbits_binind_get(chunk, pageind);
-	if (binind == BININD_INVALID || (config_prof && demote == false &&
-	    prof_promote && arena_mapbits_large_get(chunk, pageind) != 0)) {
-		/*
-		 * Large allocation.  In the common case (demote == true), and
-		 * as this is an inline function, most callers will only end up
-		 * looking at binind to determine that ptr is a small
-		 * allocation.
-		 */
-		assert(((uintptr_t)ptr & PAGE_MASK) == 0);
-		ret = arena_mapbits_large_size_get(chunk, pageind);
-		assert(ret != 0);
-		assert(pageind + (ret>>LG_PAGE) <= chunk_npages);
-		assert(ret == PAGE || arena_mapbits_large_size_get(chunk,
-		    pageind+(ret>>LG_PAGE)-1) == 0);
-		assert(binind == arena_mapbits_binind_get(chunk,
-		    pageind+(ret>>LG_PAGE)-1));
-		assert(arena_mapbits_dirty_get(chunk, pageind) ==
-		    arena_mapbits_dirty_get(chunk, pageind+(ret>>LG_PAGE)-1));
-	} else {
-		/*
-		 * Small allocation (possibly promoted to a large object due to
-		 * prof_promote).
-		 */
-		assert(arena_mapbits_large_get(chunk, pageind) != 0 ||
-		    arena_ptr_small_binind_get(ptr, arena_mapbits_get(chunk,
-		    pageind)) == binind);
-		ret = arena_bin_info[binind].reg_size;
-	}
+	if (likely(chunk != ptr)) {
+		pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
+		assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
+		binind = arena_mapbits_binind_get(chunk, pageind);
+		if (unlikely(binind == BININD_INVALID || (config_prof && !demote
+		    && arena_mapbits_large_get(chunk, pageind) != 0))) {
+			/*
+			 * Large allocation.  In the common case (demote), and
+			 * as this is an inline function, most callers will only
+			 * end up looking at binind to determine that ptr is a
+			 * small allocation.
+			 */
+			assert(config_cache_oblivious || ((uintptr_t)ptr &
+			    PAGE_MASK) == 0);
+			ret = arena_mapbits_large_size_get(chunk, pageind) -
+			    large_pad;
+			assert(ret != 0);
+			assert(pageind + ((ret+large_pad)>>LG_PAGE) <=
+			    chunk_npages);
+			assert(arena_mapbits_dirty_get(chunk, pageind) ==
+			    arena_mapbits_dirty_get(chunk,
+			    pageind+((ret+large_pad)>>LG_PAGE)-1));
+		} else {
+			/*
+			 * Small allocation (possibly promoted to a large
+			 * object).
+			 */
+			assert(arena_mapbits_large_get(chunk, pageind) != 0 ||
+			    arena_ptr_small_binind_get(ptr,
+			    arena_mapbits_get(chunk, pageind)) == binind);
+			ret = index2size(binind);
+		}
+	} else
+		ret = huge_salloc(ptr);
 
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-arena_dalloc(arena_t *arena, arena_chunk_t *chunk, void *ptr, bool try_tcache)
+arena_dalloc(tsd_t *tsd, void *ptr, tcache_t *tcache)
 {
+	arena_chunk_t *chunk;
 	size_t pageind, mapbits;
-	tcache_t *tcache;
 
-	assert(arena != NULL);
-	assert(chunk->arena == arena);
 	assert(ptr != NULL);
-	assert(CHUNK_ADDR2BASE(ptr) != ptr);
 
-	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-	mapbits = arena_mapbits_get(chunk, pageind);
-	assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
-	if ((mapbits & CHUNK_MAP_LARGE) == 0) {
-		/* Small allocation. */
-		if (try_tcache && (tcache = tcache_get(false)) != NULL) {
-			size_t binind;
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+	if (likely(chunk != ptr)) {
+		pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
+		mapbits = arena_mapbits_get(chunk, pageind);
+		assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
+		if (likely((mapbits & CHUNK_MAP_LARGE) == 0)) {
+			/* Small allocation. */
+			if (likely(tcache != NULL)) {
+				szind_t binind = arena_ptr_small_binind_get(ptr,
+				    mapbits);
+				tcache_dalloc_small(tsd, tcache, ptr, binind);
+			} else {
+				arena_dalloc_small(extent_node_arena_get(
+				    &chunk->node), chunk, ptr, pageind);
+			}
+		} else {
+			size_t size = arena_mapbits_large_size_get(chunk,
+			    pageind);
+
+			assert(config_cache_oblivious || ((uintptr_t)ptr &
+			    PAGE_MASK) == 0);
+
+			if (likely(tcache != NULL) && size - large_pad <=
+			    tcache_maxclass) {
+				tcache_dalloc_large(tsd, tcache, ptr, size -
+				    large_pad);
+			} else {
+				arena_dalloc_large(extent_node_arena_get(
+				    &chunk->node), chunk, ptr);
+			}
+		}
+	} else
+		huge_dalloc(tsd, ptr, tcache);
+}
 
-			binind = arena_ptr_small_binind_get(ptr, mapbits);
-			tcache_dalloc_small(tcache, ptr, binind);
-		} else
-			arena_dalloc_small(arena, chunk, ptr, pageind);
-	} else {
-		size_t size = arena_mapbits_large_size_get(chunk, pageind);
+JEMALLOC_ALWAYS_INLINE void
+arena_sdalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
+{
+	arena_chunk_t *chunk;
 
-		assert(((uintptr_t)ptr & PAGE_MASK) == 0);
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+	if (likely(chunk != ptr)) {
+		if (config_prof && opt_prof) {
+			size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >>
+			    LG_PAGE;
+			assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
+			if (arena_mapbits_large_get(chunk, pageind) != 0) {
+				/*
+				 * Make sure to use promoted size, not request
+				 * size.
+				 */
+				size = arena_mapbits_large_size_get(chunk,
+				    pageind) - large_pad;
+			}
+		}
+		assert(s2u(size) == s2u(arena_salloc(ptr, false)));
 
-		if (try_tcache && size <= tcache_maxclass && (tcache =
-		    tcache_get(false)) != NULL) {
-			tcache_dalloc_large(tcache, ptr, size);
-		} else
-			arena_dalloc_large(arena, chunk, ptr);
-	}
+		if (likely(size <= SMALL_MAXCLASS)) {
+			/* Small allocation. */
+			if (likely(tcache != NULL)) {
+				szind_t binind = size2index(size);
+				tcache_dalloc_small(tsd, tcache, ptr, binind);
+			} else {
+				size_t pageind = ((uintptr_t)ptr -
+				    (uintptr_t)chunk) >> LG_PAGE;
+				arena_dalloc_small(extent_node_arena_get(
+				    &chunk->node), chunk, ptr, pageind);
+			}
+		} else {
+			assert(config_cache_oblivious || ((uintptr_t)ptr &
+			    PAGE_MASK) == 0);
+
+			if (likely(tcache != NULL) && size <= tcache_maxclass)
+				tcache_dalloc_large(tsd, tcache, ptr, size);
+			else {
+				arena_dalloc_large(extent_node_arena_get(
+				    &chunk->node), chunk, ptr);
+			}
+		}
+	} else
+		huge_dalloc(tsd, ptr, tcache);
 }
 #  endif /* JEMALLOC_ARENA_INLINE_B */
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/atomic.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/atomic.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/atomic.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/atomic.h	2016-05-06 15:11:36.000000000 +0800
@@ -8,126 +8,258 @@
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 #define	atomic_read_uint64(p)	atomic_add_uint64(p, 0)
 #define	atomic_read_uint32(p)	atomic_add_uint32(p, 0)
+#define	atomic_read_p(p)	atomic_add_p(p, NULL)
 #define	atomic_read_z(p)	atomic_add_z(p, 0)
 #define	atomic_read_u(p)	atomic_add_u(p, 0)
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
+/*
+ * All arithmetic functions return the arithmetic result of the atomic
+ * operation.  Some atomic operation APIs return the value prior to mutation, in
+ * which case the following functions must redundantly compute the result so
+ * that it can be returned.  These functions are normally inlined, so the extra
+ * operations can be optimized away if the return values aren't used by the
+ * callers.
+ *
+ *   <t> atomic_read_<t>(<t> *p) { return (*p); }
+ *   <t> atomic_add_<t>(<t> *p, <t> x) { return (*p + x); }
+ *   <t> atomic_sub_<t>(<t> *p, <t> x) { return (*p - x); }
+ *   bool atomic_cas_<t>(<t> *p, <t> c, <t> s)
+ *   {
+ *     if (*p != c)
+ *       return (true);
+ *     *p = s;
+ *     return (false);
+ *   }
+ *   void atomic_write_<t>(<t> *p, <t> x) { *p = x; }
+ */
+
 #ifndef JEMALLOC_ENABLE_INLINE
 uint64_t	atomic_add_uint64(uint64_t *p, uint64_t x);
 uint64_t	atomic_sub_uint64(uint64_t *p, uint64_t x);
+bool	atomic_cas_uint64(uint64_t *p, uint64_t c, uint64_t s);
+void	atomic_write_uint64(uint64_t *p, uint64_t x);
 uint32_t	atomic_add_uint32(uint32_t *p, uint32_t x);
 uint32_t	atomic_sub_uint32(uint32_t *p, uint32_t x);
+bool	atomic_cas_uint32(uint32_t *p, uint32_t c, uint32_t s);
+void	atomic_write_uint32(uint32_t *p, uint32_t x);
+void	*atomic_add_p(void **p, void *x);
+void	*atomic_sub_p(void **p, void *x);
+bool	atomic_cas_p(void **p, void *c, void *s);
+void	atomic_write_p(void **p, const void *x);
 size_t	atomic_add_z(size_t *p, size_t x);
 size_t	atomic_sub_z(size_t *p, size_t x);
+bool	atomic_cas_z(size_t *p, size_t c, size_t s);
+void	atomic_write_z(size_t *p, size_t x);
 unsigned	atomic_add_u(unsigned *p, unsigned x);
 unsigned	atomic_sub_u(unsigned *p, unsigned x);
+bool	atomic_cas_u(unsigned *p, unsigned c, unsigned s);
+void	atomic_write_u(unsigned *p, unsigned x);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_ATOMIC_C_))
 /******************************************************************************/
 /* 64-bit operations. */
 #if (LG_SIZEOF_PTR == 3 || LG_SIZEOF_INT == 3)
-#  ifdef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
+#  if (defined(__amd64__) || defined(__x86_64__))
 JEMALLOC_INLINE uint64_t
 atomic_add_uint64(uint64_t *p, uint64_t x)
 {
+	uint64_t t = x;
 
-	return (__sync_add_and_fetch(p, x));
+	asm volatile (
+	    "lock; xaddq %0, %1;"
+	    : "+r" (t), "=m" (*p) /* Outputs. */
+	    : "m" (*p) /* Inputs. */
+	    );
+
+	return (t + x);
 }
 
 JEMALLOC_INLINE uint64_t
 atomic_sub_uint64(uint64_t *p, uint64_t x)
 {
+	uint64_t t;
 
-	return (__sync_sub_and_fetch(p, x));
+	x = (uint64_t)(-(int64_t)x);
+	t = x;
+	asm volatile (
+	    "lock; xaddq %0, %1;"
+	    : "+r" (t), "=m" (*p) /* Outputs. */
+	    : "m" (*p) /* Inputs. */
+	    );
+
+	return (t + x);
 }
-#elif (defined(_MSC_VER))
+
+JEMALLOC_INLINE bool
+atomic_cas_uint64(uint64_t *p, uint64_t c, uint64_t s)
+{
+	uint8_t success;
+
+	asm volatile (
+	    "lock; cmpxchgq %4, %0;"
+	    "sete %1;"
+	    : "=m" (*p), "=a" (success) /* Outputs. */
+	    : "m" (*p), "a" (c), "r" (s) /* Inputs. */
+	    : "memory" /* Clobbers. */
+	    );
+
+	return (!(bool)success);
+}
+
+JEMALLOC_INLINE void
+atomic_write_uint64(uint64_t *p, uint64_t x)
+{
+
+	asm volatile (
+	    "xchgq %1, %0;" /* Lock is implied by xchgq. */
+	    : "=m" (*p), "+r" (x) /* Outputs. */
+	    : "m" (*p) /* Inputs. */
+	    : "memory" /* Clobbers. */
+	    );
+}
+#  elif (defined(JEMALLOC_C11ATOMICS))
 JEMALLOC_INLINE uint64_t
 atomic_add_uint64(uint64_t *p, uint64_t x)
 {
-
-	return (InterlockedExchangeAdd64(p, x));
+	volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;
+	return (atomic_fetch_add(a, x) + x);
 }
 
 JEMALLOC_INLINE uint64_t
 atomic_sub_uint64(uint64_t *p, uint64_t x)
 {
+	volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;
+	return (atomic_fetch_sub(a, x) - x);
+}
+
+JEMALLOC_INLINE bool
+atomic_cas_uint64(uint64_t *p, uint64_t c, uint64_t s)
+{
+	volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;
+	return (!atomic_compare_exchange_strong(a, &c, s));
+}
 
-	return (InterlockedExchangeAdd64(p, -((int64_t)x)));
+JEMALLOC_INLINE void
+atomic_write_uint64(uint64_t *p, uint64_t x)
+{
+	volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;
+	atomic_store(a, x);
 }
-#elif (defined(JEMALLOC_OSATOMIC))
+#  elif (defined(JEMALLOC_ATOMIC9))
 JEMALLOC_INLINE uint64_t
 atomic_add_uint64(uint64_t *p, uint64_t x)
 {
 
-	return (OSAtomicAdd64((int64_t)x, (int64_t *)p));
+	/*
+	 * atomic_fetchadd_64() doesn't exist, but we only ever use this
+	 * function on LP64 systems, so atomic_fetchadd_long() will do.
+	 */
+	assert(sizeof(uint64_t) == sizeof(unsigned long));
+
+	return (atomic_fetchadd_long(p, (unsigned long)x) + x);
 }
 
 JEMALLOC_INLINE uint64_t
 atomic_sub_uint64(uint64_t *p, uint64_t x)
 {
 
-	return (OSAtomicAdd64(-((int64_t)x), (int64_t *)p));
+	assert(sizeof(uint64_t) == sizeof(unsigned long));
+
+	return (atomic_fetchadd_long(p, (unsigned long)(-(long)x)) - x);
+}
+
+JEMALLOC_INLINE bool
+atomic_cas_uint64(uint64_t *p, uint64_t c, uint64_t s)
+{
+
+	assert(sizeof(uint64_t) == sizeof(unsigned long));
+
+	return (!atomic_cmpset_long(p, (unsigned long)c, (unsigned long)s));
+}
+
+JEMALLOC_INLINE void
+atomic_write_uint64(uint64_t *p, uint64_t x)
+{
+
+	assert(sizeof(uint64_t) == sizeof(unsigned long));
+
+	atomic_store_rel_long(p, x);
 }
-#  elif (defined(__amd64__) || defined(__x86_64__))
+#  elif (defined(JEMALLOC_OSATOMIC))
 JEMALLOC_INLINE uint64_t
 atomic_add_uint64(uint64_t *p, uint64_t x)
 {
 
-	asm volatile (
-	    "lock; xaddq %0, %1;"
-	    : "+r" (x), "=m" (*p) /* Outputs. */
-	    : "m" (*p) /* Inputs. */
-	    );
-
-	return (x);
+	return (OSAtomicAdd64((int64_t)x, (int64_t *)p));
 }
 
 JEMALLOC_INLINE uint64_t
 atomic_sub_uint64(uint64_t *p, uint64_t x)
 {
 
-	x = (uint64_t)(-(int64_t)x);
-	asm volatile (
-	    "lock; xaddq %0, %1;"
-	    : "+r" (x), "=m" (*p) /* Outputs. */
-	    : "m" (*p) /* Inputs. */
-	    );
+	return (OSAtomicAdd64(-((int64_t)x), (int64_t *)p));
+}
+
+JEMALLOC_INLINE bool
+atomic_cas_uint64(uint64_t *p, uint64_t c, uint64_t s)
+{
 
-	return (x);
+	return (!OSAtomicCompareAndSwap64(c, s, (int64_t *)p));
 }
-#  elif (defined(JEMALLOC_ATOMIC9))
+
+JEMALLOC_INLINE void
+atomic_write_uint64(uint64_t *p, uint64_t x)
+{
+	uint64_t o;
+
+	/*The documented OSAtomic*() API does not expose an atomic exchange. */
+	do {
+		o = atomic_read_uint64(p);
+	} while (atomic_cas_uint64(p, o, x));
+}
+#  elif (defined(_MSC_VER))
 JEMALLOC_INLINE uint64_t
 atomic_add_uint64(uint64_t *p, uint64_t x)
 {
 
-	/*
-	 * atomic_fetchadd_64() doesn't exist, but we only ever use this
-	 * function on LP64 systems, so atomic_fetchadd_long() will do.
-	 */
-	assert(sizeof(uint64_t) == sizeof(unsigned long));
-
-	return (atomic_fetchadd_long(p, (unsigned long)x) + x);
+	return (InterlockedExchangeAdd64(p, x) + x);
 }
 
 JEMALLOC_INLINE uint64_t
 atomic_sub_uint64(uint64_t *p, uint64_t x)
 {
 
-	assert(sizeof(uint64_t) == sizeof(unsigned long));
+	return (InterlockedExchangeAdd64(p, -((int64_t)x)) - x);
+}
 
-	return (atomic_fetchadd_long(p, (unsigned long)(-(long)x)) - x);
+JEMALLOC_INLINE bool
+atomic_cas_uint64(uint64_t *p, uint64_t c, uint64_t s)
+{
+	uint64_t o;
+
+	o = InterlockedCompareExchange64(p, s, c);
+	return (o != c);
 }
-#  elif (defined(JE_FORCE_SYNC_COMPARE_AND_SWAP_8))
+
+JEMALLOC_INLINE void
+atomic_write_uint64(uint64_t *p, uint64_t x)
+{
+
+	InterlockedExchange64(p, x);
+}
+#  elif (defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8) || \
+    defined(JE_FORCE_SYNC_COMPARE_AND_SWAP_8))
 JEMALLOC_INLINE uint64_t
 atomic_add_uint64(uint64_t *p, uint64_t x)
 {
 
 	return (__sync_add_and_fetch(p, x));
 }
@@ -135,103 +267,211 @@
 JEMALLOC_INLINE uint64_t
 atomic_sub_uint64(uint64_t *p, uint64_t x)
 {
 
 	return (__sync_sub_and_fetch(p, x));
 }
+
+JEMALLOC_INLINE bool
+atomic_cas_uint64(uint64_t *p, uint64_t c, uint64_t s)
+{
+
+	return (!__sync_bool_compare_and_swap(p, c, s));
+}
+
+JEMALLOC_INLINE void
+atomic_write_uint64(uint64_t *p, uint64_t x)
+{
+
+	__sync_lock_test_and_set(p, x);
+}
 #  else
 #    error "Missing implementation for 64-bit atomic operations"
 #  endif
 #endif
 
 /******************************************************************************/
 /* 32-bit operations. */
-#ifdef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4
+#if (defined(__i386__) || defined(__amd64__) || defined(__x86_64__))
 JEMALLOC_INLINE uint32_t
 atomic_add_uint32(uint32_t *p, uint32_t x)
 {
+	uint32_t t = x;
 
-	return (__sync_add_and_fetch(p, x));
+	asm volatile (
+	    "lock; xaddl %0, %1;"
+	    : "+r" (t), "=m" (*p) /* Outputs. */
+	    : "m" (*p) /* Inputs. */
+	    );
+
+	return (t + x);
 }
 
 JEMALLOC_INLINE uint32_t
 atomic_sub_uint32(uint32_t *p, uint32_t x)
 {
+	uint32_t t;
 
-	return (__sync_sub_and_fetch(p, x));
+	x = (uint32_t)(-(int32_t)x);
+	t = x;
+	asm volatile (
+	    "lock; xaddl %0, %1;"
+	    : "+r" (t), "=m" (*p) /* Outputs. */
+	    : "m" (*p) /* Inputs. */
+	    );
+
+	return (t + x);
 }
-#elif (defined(_MSC_VER))
+
+JEMALLOC_INLINE bool
+atomic_cas_uint32(uint32_t *p, uint32_t c, uint32_t s)
+{
+	uint8_t success;
+
+	asm volatile (
+	    "lock; cmpxchgl %4, %0;"
+	    "sete %1;"
+	    : "=m" (*p), "=a" (success) /* Outputs. */
+	    : "m" (*p), "a" (c), "r" (s) /* Inputs. */
+	    : "memory"
+	    );
+
+	return (!(bool)success);
+}
+
+JEMALLOC_INLINE void
+atomic_write_uint32(uint32_t *p, uint32_t x)
+{
+
+	asm volatile (
+	    "xchgl %1, %0;" /* Lock is implied by xchgl. */
+	    : "=m" (*p), "+r" (x) /* Outputs. */
+	    : "m" (*p) /* Inputs. */
+	    : "memory" /* Clobbers. */
+	    );
+}
+#  elif (defined(JEMALLOC_C11ATOMICS))
 JEMALLOC_INLINE uint32_t
 atomic_add_uint32(uint32_t *p, uint32_t x)
 {
-
-	return (InterlockedExchangeAdd(p, x));
+	volatile atomic_uint_least32_t *a = (volatile atomic_uint_least32_t *)p;
+	return (atomic_fetch_add(a, x) + x);
 }
 
 JEMALLOC_INLINE uint32_t
 atomic_sub_uint32(uint32_t *p, uint32_t x)
 {
+	volatile atomic_uint_least32_t *a = (volatile atomic_uint_least32_t *)p;
+	return (atomic_fetch_sub(a, x) - x);
+}
+
+JEMALLOC_INLINE bool
+atomic_cas_uint32(uint32_t *p, uint32_t c, uint32_t s)
+{
+	volatile atomic_uint_least32_t *a = (volatile atomic_uint_least32_t *)p;
+	return (!atomic_compare_exchange_strong(a, &c, s));
+}
 
-	return (InterlockedExchangeAdd(p, -((int32_t)x)));
+JEMALLOC_INLINE void
+atomic_write_uint32(uint32_t *p, uint32_t x)
+{
+	volatile atomic_uint_least32_t *a = (volatile atomic_uint_least32_t *)p;
+	atomic_store(a, x);
 }
-#elif (defined(JEMALLOC_OSATOMIC))
+#elif (defined(JEMALLOC_ATOMIC9))
 JEMALLOC_INLINE uint32_t
 atomic_add_uint32(uint32_t *p, uint32_t x)
 {
 
-	return (OSAtomicAdd32((int32_t)x, (int32_t *)p));
+	return (atomic_fetchadd_32(p, x) + x);
 }
 
 JEMALLOC_INLINE uint32_t
 atomic_sub_uint32(uint32_t *p, uint32_t x)
 {
 
-	return (OSAtomicAdd32(-((int32_t)x), (int32_t *)p));
+	return (atomic_fetchadd_32(p, (uint32_t)(-(int32_t)x)) - x);
+}
+
+JEMALLOC_INLINE bool
+atomic_cas_uint32(uint32_t *p, uint32_t c, uint32_t s)
+{
+
+	return (!atomic_cmpset_32(p, c, s));
+}
+
+JEMALLOC_INLINE void
+atomic_write_uint32(uint32_t *p, uint32_t x)
+{
+
+	atomic_store_rel_32(p, x);
 }
-#elif (defined(__i386__) || defined(__amd64__) || defined(__x86_64__))
+#elif (defined(JEMALLOC_OSATOMIC))
 JEMALLOC_INLINE uint32_t
 atomic_add_uint32(uint32_t *p, uint32_t x)
 {
 
-	asm volatile (
-	    "lock; xaddl %0, %1;"
-	    : "+r" (x), "=m" (*p) /* Outputs. */
-	    : "m" (*p) /* Inputs. */
-	    );
-
-	return (x);
+	return (OSAtomicAdd32((int32_t)x, (int32_t *)p));
 }
 
 JEMALLOC_INLINE uint32_t
 atomic_sub_uint32(uint32_t *p, uint32_t x)
 {
 
-	x = (uint32_t)(-(int32_t)x);
-	asm volatile (
-	    "lock; xaddl %0, %1;"
-	    : "+r" (x), "=m" (*p) /* Outputs. */
-	    : "m" (*p) /* Inputs. */
-	    );
+	return (OSAtomicAdd32(-((int32_t)x), (int32_t *)p));
+}
 
-	return (x);
+JEMALLOC_INLINE bool
+atomic_cas_uint32(uint32_t *p, uint32_t c, uint32_t s)
+{
+
+	return (!OSAtomicCompareAndSwap32(c, s, (int32_t *)p));
 }
-#elif (defined(JEMALLOC_ATOMIC9))
+
+JEMALLOC_INLINE void
+atomic_write_uint32(uint32_t *p, uint32_t x)
+{
+	uint32_t o;
+
+	/*The documented OSAtomic*() API does not expose an atomic exchange. */
+	do {
+		o = atomic_read_uint32(p);
+	} while (atomic_cas_uint32(p, o, x));
+}
+#elif (defined(_MSC_VER))
 JEMALLOC_INLINE uint32_t
 atomic_add_uint32(uint32_t *p, uint32_t x)
 {
 
-	return (atomic_fetchadd_32(p, x) + x);
+	return (InterlockedExchangeAdd(p, x) + x);
 }
 
 JEMALLOC_INLINE uint32_t
 atomic_sub_uint32(uint32_t *p, uint32_t x)
 {
 
-	return (atomic_fetchadd_32(p, (uint32_t)(-(int32_t)x)) - x);
+	return (InterlockedExchangeAdd(p, -((int32_t)x)) - x);
+}
+
+JEMALLOC_INLINE bool
+atomic_cas_uint32(uint32_t *p, uint32_t c, uint32_t s)
+{
+	uint32_t o;
+
+	o = InterlockedCompareExchange(p, s, c);
+	return (o != c);
 }
-#elif (defined(JE_FORCE_SYNC_COMPARE_AND_SWAP_4))
+
+JEMALLOC_INLINE void
+atomic_write_uint32(uint32_t *p, uint32_t x)
+{
+
+	InterlockedExchange(p, x);
+}
+#elif (defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4) || \
+ defined(JE_FORCE_SYNC_COMPARE_AND_SWAP_4))
 JEMALLOC_INLINE uint32_t
 atomic_add_uint32(uint32_t *p, uint32_t x)
 {
 
 	return (__sync_add_and_fetch(p, x));
 }
@@ -239,17 +479,79 @@
 JEMALLOC_INLINE uint32_t
 atomic_sub_uint32(uint32_t *p, uint32_t x)
 {
 
 	return (__sync_sub_and_fetch(p, x));
 }
+
+JEMALLOC_INLINE bool
+atomic_cas_uint32(uint32_t *p, uint32_t c, uint32_t s)
+{
+
+	return (!__sync_bool_compare_and_swap(p, c, s));
+}
+
+JEMALLOC_INLINE void
+atomic_write_uint32(uint32_t *p, uint32_t x)
+{
+
+	__sync_lock_test_and_set(p, x);
+}
 #else
 #  error "Missing implementation for 32-bit atomic operations"
 #endif
 
 /******************************************************************************/
+/* Pointer operations. */
+JEMALLOC_INLINE void *
+atomic_add_p(void **p, void *x)
+{
+
+#if (LG_SIZEOF_PTR == 3)
+	return ((void *)atomic_add_uint64((uint64_t *)p, (uint64_t)x));
+#elif (LG_SIZEOF_PTR == 2)
+	return ((void *)atomic_add_uint32((uint32_t *)p, (uint32_t)x));
+#endif
+}
+
+JEMALLOC_INLINE void *
+atomic_sub_p(void **p, void *x)
+{
+
+#if (LG_SIZEOF_PTR == 3)
+	return ((void *)atomic_add_uint64((uint64_t *)p,
+	    (uint64_t)-((int64_t)x)));
+#elif (LG_SIZEOF_PTR == 2)
+	return ((void *)atomic_add_uint32((uint32_t *)p,
+	    (uint32_t)-((int32_t)x)));
+#endif
+}
+
+JEMALLOC_INLINE bool
+atomic_cas_p(void **p, void *c, void *s)
+{
+
+#if (LG_SIZEOF_PTR == 3)
+	return (atomic_cas_uint64((uint64_t *)p, (uint64_t)c, (uint64_t)s));
+#elif (LG_SIZEOF_PTR == 2)
+	return (atomic_cas_uint32((uint32_t *)p, (uint32_t)c, (uint32_t)s));
+#endif
+}
+
+JEMALLOC_INLINE void
+atomic_write_p(void **p, const void *x)
+{
+
+#if (LG_SIZEOF_PTR == 3)
+	atomic_write_uint64((uint64_t *)p, (uint64_t)x);
+#elif (LG_SIZEOF_PTR == 2)
+	atomic_write_uint32((uint32_t *)p, (uint32_t)x);
+#endif
+}
+
+/******************************************************************************/
 /* size_t operations. */
 JEMALLOC_INLINE size_t
 atomic_add_z(size_t *p, size_t x)
 {
 
 #if (LG_SIZEOF_PTR == 3)
@@ -269,12 +571,34 @@
 #elif (LG_SIZEOF_PTR == 2)
 	return ((size_t)atomic_add_uint32((uint32_t *)p,
 	    (uint32_t)-((int32_t)x)));
 #endif
 }
 
+JEMALLOC_INLINE bool
+atomic_cas_z(size_t *p, size_t c, size_t s)
+{
+
+#if (LG_SIZEOF_PTR == 3)
+	return (atomic_cas_uint64((uint64_t *)p, (uint64_t)c, (uint64_t)s));
+#elif (LG_SIZEOF_PTR == 2)
+	return (atomic_cas_uint32((uint32_t *)p, (uint32_t)c, (uint32_t)s));
+#endif
+}
+
+JEMALLOC_INLINE void
+atomic_write_z(size_t *p, size_t x)
+{
+
+#if (LG_SIZEOF_PTR == 3)
+	atomic_write_uint64((uint64_t *)p, (uint64_t)x);
+#elif (LG_SIZEOF_PTR == 2)
+	atomic_write_uint32((uint32_t *)p, (uint32_t)x);
+#endif
+}
+
 /******************************************************************************/
 /* unsigned operations. */
 JEMALLOC_INLINE unsigned
 atomic_add_u(unsigned *p, unsigned x)
 {
 
@@ -294,11 +618,34 @@
 	    (uint64_t)-((int64_t)x)));
 #elif (LG_SIZEOF_INT == 2)
 	return ((unsigned)atomic_add_uint32((uint32_t *)p,
 	    (uint32_t)-((int32_t)x)));
 #endif
 }
+
+JEMALLOC_INLINE bool
+atomic_cas_u(unsigned *p, unsigned c, unsigned s)
+{
+
+#if (LG_SIZEOF_INT == 3)
+	return (atomic_cas_uint64((uint64_t *)p, (uint64_t)c, (uint64_t)s));
+#elif (LG_SIZEOF_INT == 2)
+	return (atomic_cas_uint32((uint32_t *)p, (uint32_t)c, (uint32_t)s));
+#endif
+}
+
+JEMALLOC_INLINE void
+atomic_write_u(unsigned *p, unsigned x)
+{
+
+#if (LG_SIZEOF_INT == 3)
+	atomic_write_uint64((uint64_t *)p, (uint64_t)x);
+#elif (LG_SIZEOF_INT == 2)
+	atomic_write_uint32((uint32_t *)p, (uint32_t)x);
+#endif
+}
+
 /******************************************************************************/
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/base.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/base.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/base.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/base.h	2016-05-06 15:11:36.000000000 +0800
@@ -7,15 +7,13 @@
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 void	*base_alloc(size_t size);
-void	*base_calloc(size_t number, size_t size);
-extent_node_t *base_node_alloc(void);
-void	base_node_dealloc(extent_node_t *node);
+void	base_stats_get(size_t *allocated, size_t *resident, size_t *mapped);
 bool	base_boot(void);
 void	base_prefork(void);
 void	base_postfork_parent(void);
 void	base_postfork_child(void);
 
 #endif /* JEMALLOC_H_EXTERNS */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/bitmap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/bitmap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/bitmap.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/bitmap.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,22 +1,68 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
 /* Maximum bitmap bit count is 2^LG_BITMAP_MAXBITS. */
 #define	LG_BITMAP_MAXBITS	LG_RUN_MAXREGS
+#define	BITMAP_MAXBITS		(ZU(1) << LG_BITMAP_MAXBITS)
 
 typedef struct bitmap_level_s bitmap_level_t;
 typedef struct bitmap_info_s bitmap_info_t;
 typedef unsigned long bitmap_t;
 #define	LG_SIZEOF_BITMAP	LG_SIZEOF_LONG
 
 /* Number of bits per group. */
 #define	LG_BITMAP_GROUP_NBITS		(LG_SIZEOF_BITMAP + 3)
 #define	BITMAP_GROUP_NBITS		(ZU(1) << LG_BITMAP_GROUP_NBITS)
 #define	BITMAP_GROUP_NBITS_MASK		(BITMAP_GROUP_NBITS-1)
 
+/* Number of groups required to store a given number of bits. */
+#define	BITMAP_BITS2GROUPS(nbits)					\
+    ((nbits + BITMAP_GROUP_NBITS_MASK) >> LG_BITMAP_GROUP_NBITS)
+
+/*
+ * Number of groups required at a particular level for a given number of bits.
+ */
+#define	BITMAP_GROUPS_L0(nbits)						\
+    BITMAP_BITS2GROUPS(nbits)
+#define	BITMAP_GROUPS_L1(nbits)						\
+    BITMAP_BITS2GROUPS(BITMAP_BITS2GROUPS(nbits))
+#define	BITMAP_GROUPS_L2(nbits)						\
+    BITMAP_BITS2GROUPS(BITMAP_BITS2GROUPS(BITMAP_BITS2GROUPS((nbits))))
+#define	BITMAP_GROUPS_L3(nbits)						\
+    BITMAP_BITS2GROUPS(BITMAP_BITS2GROUPS(BITMAP_BITS2GROUPS(		\
+	BITMAP_BITS2GROUPS((nbits)))))
+
+/*
+ * Assuming the number of levels, number of groups required for a given number
+ * of bits.
+ */
+#define	BITMAP_GROUPS_1_LEVEL(nbits)					\
+    BITMAP_GROUPS_L0(nbits)
+#define	BITMAP_GROUPS_2_LEVEL(nbits)					\
+    (BITMAP_GROUPS_1_LEVEL(nbits) + BITMAP_GROUPS_L1(nbits))
+#define	BITMAP_GROUPS_3_LEVEL(nbits)					\
+    (BITMAP_GROUPS_2_LEVEL(nbits) + BITMAP_GROUPS_L2(nbits))
+#define	BITMAP_GROUPS_4_LEVEL(nbits)					\
+    (BITMAP_GROUPS_3_LEVEL(nbits) + BITMAP_GROUPS_L3(nbits))
+
+/*
+ * Maximum number of groups required to support LG_BITMAP_MAXBITS.
+ */
+#if LG_BITMAP_MAXBITS <= LG_BITMAP_GROUP_NBITS
+#  define BITMAP_GROUPS_MAX	BITMAP_GROUPS_1_LEVEL(BITMAP_MAXBITS)
+#elif LG_BITMAP_MAXBITS <= LG_BITMAP_GROUP_NBITS * 2
+#  define BITMAP_GROUPS_MAX	BITMAP_GROUPS_2_LEVEL(BITMAP_MAXBITS)
+#elif LG_BITMAP_MAXBITS <= LG_BITMAP_GROUP_NBITS * 3
+#  define BITMAP_GROUPS_MAX	BITMAP_GROUPS_3_LEVEL(BITMAP_MAXBITS)
+#elif LG_BITMAP_MAXBITS <= LG_BITMAP_GROUP_NBITS * 4
+#  define BITMAP_GROUPS_MAX	BITMAP_GROUPS_4_LEVEL(BITMAP_MAXBITS)
+#else
+#  error "Unsupported bitmap size"
+#endif
+
 /* Maximum number of levels possible. */
 #define	BITMAP_MAX_LEVELS						\
     (LG_BITMAP_MAXBITS / LG_SIZEOF_BITMAP)				\
     + !!(LG_BITMAP_MAXBITS % LG_SIZEOF_BITMAP)
 
 #endif /* JEMALLOC_H_TYPES */
@@ -90,13 +136,13 @@
 {
 	size_t goff;
 	bitmap_t *gp;
 	bitmap_t g;
 
 	assert(bit < binfo->nbits);
-	assert(bitmap_get(bitmap, binfo, bit) == false);
+	assert(!bitmap_get(bitmap, binfo, bit));
 	goff = bit >> LG_BITMAP_GROUP_NBITS;
 	gp = &bitmap[goff];
 	g = *gp;
 	assert(g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK)));
 	g ^= 1LU << (bit & BITMAP_GROUP_NBITS_MASK);
 	*gp = g;
@@ -123,21 +169,21 @@
 bitmap_sfu(bitmap_t *bitmap, const bitmap_info_t *binfo)
 {
 	size_t bit;
 	bitmap_t g;
 	unsigned i;
 
-	assert(bitmap_full(bitmap, binfo) == false);
+	assert(!bitmap_full(bitmap, binfo));
 
 	i = binfo->nlevels - 1;
 	g = bitmap[binfo->levels[i].group_offset];
-	bit = ffsl(g) - 1;
+	bit = jemalloc_ffsl(g) - 1;
 	while (i > 0) {
 		i--;
 		g = bitmap[binfo->levels[i].group_offset + bit];
-		bit = (bit << LG_BITMAP_GROUP_NBITS) + (ffsl(g) - 1);
+		bit = (bit << LG_BITMAP_GROUP_NBITS) + (jemalloc_ffsl(g) - 1);
 	}
 
 	bitmap_set(bitmap, binfo, bit);
 	return (bit);
 }
 
@@ -155,13 +201,13 @@
 	gp = &bitmap[goff];
 	g = *gp;
 	propagate = (g == 0);
 	assert((g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK))) == 0);
 	g ^= 1LU << (bit & BITMAP_GROUP_NBITS_MASK);
 	*gp = g;
-	assert(bitmap_get(bitmap, binfo, bit) == false);
+	assert(!bitmap_get(bitmap, binfo, bit));
 	/* Propagate group state transitions up the tree. */
 	if (propagate) {
 		unsigned i;
 		for (i = 1; i < binfo->nlevels; i++) {
 			bit = goff;
 			goff = bit >> LG_BITMAP_GROUP_NBITS;
@@ -169,13 +215,13 @@
 			g = *gp;
 			propagate = (g == 0);
 			assert((g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK)))
 			    == 0);
 			g ^= 1LU << (bit & BITMAP_GROUP_NBITS_MASK);
 			*gp = g;
-			if (propagate == false)
+			if (!propagate)
 				break;
 		}
 	}
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/chunk_dss.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/chunk_dss.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/chunk_dss.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/chunk_dss.h	2016-05-06 15:11:36.000000000 +0800
@@ -20,13 +20,14 @@
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 dss_prec_t	chunk_dss_prec_get(void);
 bool	chunk_dss_prec_set(dss_prec_t dss_prec);
-void	*chunk_alloc_dss(size_t size, size_t alignment, bool *zero);
+void	*chunk_alloc_dss(arena_t *arena, void *new_addr, size_t size,
+    size_t alignment, bool *zero, bool *commit);
 bool	chunk_in_dss(void *chunk);
 bool	chunk_dss_boot(void);
 void	chunk_dss_prefork(void);
 void	chunk_dss_postfork_parent(void);
 void	chunk_dss_postfork_child(void);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/chunk.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/chunk.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/chunk.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/chunk.h	2016-05-06 15:11:36.000000000 +0800
@@ -2,13 +2,13 @@
 #ifdef JEMALLOC_H_TYPES
 
 /*
  * Size and alignment of memory chunks that are allocated by the OS's virtual
  * memory system.
  */
-#define	LG_CHUNK_DEFAULT	22
+#define	LG_CHUNK_DEFAULT	21
 
 /* Return the chunk address for allocation address a. */
 #define	CHUNK_ADDR2BASE(a)						\
 	((void *)((uintptr_t)(a) & ~chunksize_mask))
 
 /* Return the chunk offset of address a. */
@@ -16,48 +16,84 @@
 	((size_t)((uintptr_t)(a) & chunksize_mask))
 
 /* Return the smallest chunk multiple that is >= s. */
 #define	CHUNK_CEILING(s)						\
 	(((s) + chunksize_mask) & ~chunksize_mask)
 
+#define	CHUNK_HOOKS_INITIALIZER {					\
+    NULL,								\
+    NULL,								\
+    NULL,								\
+    NULL,								\
+    NULL,								\
+    NULL,								\
+    NULL								\
+}
+
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 extern size_t		opt_lg_chunk;
 extern const char	*opt_dss;
 
-/* Protects stats_chunks; currently not used for any other purpose. */
-extern malloc_mutex_t	chunks_mtx;
-/* Chunk statistics. */
-extern chunk_stats_t	stats_chunks;
-
-extern rtree_t		*chunks_rtree;
+extern rtree_t		chunks_rtree;
 
 extern size_t		chunksize;
 extern size_t		chunksize_mask; /* (chunksize - 1). */
 extern size_t		chunk_npages;
-extern size_t		map_bias; /* Number of arena chunk header pages. */
-extern size_t		arena_maxclass; /* Max size class for arenas. */
 
-void	*chunk_alloc(size_t size, size_t alignment, bool base, bool *zero,
-    dss_prec_t dss_prec);
-void	chunk_unmap(void *chunk, size_t size);
-void	chunk_dealloc(void *chunk, size_t size, bool unmap);
+extern const chunk_hooks_t	chunk_hooks_default;
+
+chunk_hooks_t	chunk_hooks_get(arena_t *arena);
+chunk_hooks_t	chunk_hooks_set(arena_t *arena,
+    const chunk_hooks_t *chunk_hooks);
+
+bool	chunk_register(const void *chunk, const extent_node_t *node);
+void	chunk_deregister(const void *chunk, const extent_node_t *node);
+void	*chunk_alloc_base(size_t size);
+void	*chunk_alloc_cache(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *new_addr, size_t size, size_t alignment, bool *zero,
+    bool dalloc_node);
+void	*chunk_alloc_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *new_addr, size_t size, size_t alignment, bool *zero, bool *commit);
+void	chunk_dalloc_cache(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *chunk, size_t size, bool committed);
+void	chunk_dalloc_arena(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *chunk, size_t size, bool zeroed, bool committed);
+void	chunk_dalloc_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *chunk, size_t size, bool committed);
+bool	chunk_purge_arena(arena_t *arena, void *chunk, size_t offset,
+    size_t length);
+bool	chunk_purge_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *chunk, size_t size, size_t offset, size_t length);
 bool	chunk_boot(void);
 void	chunk_prefork(void);
 void	chunk_postfork_parent(void);
 void	chunk_postfork_child(void);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
+#ifndef JEMALLOC_ENABLE_INLINE
+extent_node_t	*chunk_lookup(const void *chunk, bool dependent);
+#endif
+
+#if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_CHUNK_C_))
+JEMALLOC_INLINE extent_node_t *
+chunk_lookup(const void *ptr, bool dependent)
+{
+
+	return (rtree_get(&chunks_rtree, (uintptr_t)ptr, dependent));
+}
+#endif
+
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
 
 #include "jemalloc/internal/chunk_dss.h"
 #include "jemalloc/internal/chunk_mmap.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/chunk_mmap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/chunk_mmap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/chunk_mmap.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/chunk_mmap.h	2016-05-06 15:11:36.000000000 +0800
@@ -6,16 +6,15 @@
 #ifdef JEMALLOC_H_STRUCTS
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-bool	pages_purge(void *addr, size_t length);
-
-void	*chunk_alloc_mmap(size_t size, size_t alignment, bool *zero);
-bool	chunk_dealloc_mmap(void *chunk, size_t size);
+void	*chunk_alloc_mmap(size_t size, size_t alignment, bool *zero,
+    bool *commit);
+bool	chunk_dalloc_mmap(void *chunk, size_t size);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #endif /* JEMALLOC_H_INLINES */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/ckh.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/ckh.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/ckh.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/ckh.h	2016-05-06 15:11:36.000000000 +0800
@@ -63,19 +63,19 @@
 };
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-bool	ckh_new(ckh_t *ckh, size_t minitems, ckh_hash_t *hash,
+bool	ckh_new(tsd_t *tsd, ckh_t *ckh, size_t minitems, ckh_hash_t *hash,
     ckh_keycomp_t *keycomp);
-void	ckh_delete(ckh_t *ckh);
+void	ckh_delete(tsd_t *tsd, ckh_t *ckh);
 size_t	ckh_count(ckh_t *ckh);
 bool	ckh_iter(ckh_t *ckh, size_t *tabind, void **key, void **data);
-bool	ckh_insert(ckh_t *ckh, const void *key, const void *data);
-bool	ckh_remove(ckh_t *ckh, const void *searchkey, void **key,
+bool	ckh_insert(tsd_t *tsd, ckh_t *ckh, const void *key, const void *data);
+bool	ckh_remove(tsd_t *tsd, ckh_t *ckh, const void *searchkey, void **key,
     void **data);
 bool	ckh_search(ckh_t *ckh, const void *seachkey, void **key, void **data);
 void	ckh_string_hash(const void *key, size_t r_hash[2]);
 bool	ckh_string_keycomp(const void *k1, const void *k2);
 void	ckh_pointer_hash(const void *key, size_t r_hash[2]);
 bool	ckh_pointer_keycomp(const void *k1, const void *k2);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/ctl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/ctl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/ctl.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/ctl.h	2016-05-06 15:11:36.000000000 +0800
@@ -31,40 +31,34 @@
 };
 
 struct ctl_arena_stats_s {
 	bool			initialized;
 	unsigned		nthreads;
 	const char		*dss;
+	ssize_t			lg_dirty_mult;
 	size_t			pactive;
 	size_t			pdirty;
 	arena_stats_t		astats;
 
 	/* Aggregate stats for small size classes, based on bin stats. */
 	size_t			allocated_small;
 	uint64_t		nmalloc_small;
 	uint64_t		ndalloc_small;
 	uint64_t		nrequests_small;
 
 	malloc_bin_stats_t	bstats[NBINS];
 	malloc_large_stats_t	*lstats;	/* nlclasses elements. */
+	malloc_huge_stats_t	*hstats;	/* nhclasses elements. */
 };
 
 struct ctl_stats_s {
 	size_t			allocated;
 	size_t			active;
+	size_t			metadata;
+	size_t			resident;
 	size_t			mapped;
-	struct {
-		size_t		current;	/* stats_chunks.curchunks */
-		uint64_t	total;		/* stats_chunks.nchunks */
-		size_t		high;		/* stats_chunks.highchunks */
-	} chunks;
-	struct {
-		size_t		allocated;	/* huge_allocated */
-		uint64_t	nmalloc;	/* huge_nmalloc */
-		uint64_t	ndalloc;	/* huge_ndalloc */
-	} huge;
 	unsigned		narenas;
 	ctl_arena_stats_t	*arenas;	/* (narenas + 1) elements. */
 };
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/extent.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/extent.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/extent.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/extent.h	2016-05-06 15:11:36.000000000 +0800
@@ -4,31 +4,59 @@
 typedef struct extent_node_s extent_node_t;
 
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
 
-/* Tree of extents. */
+/* Tree of extents.  Use accessor functions for en_* fields. */
 struct extent_node_s {
-	/* Linkage for the size/address-ordered tree. */
-	rb_node(extent_node_t)	link_szad;
-
-	/* Linkage for the address-ordered tree. */
-	rb_node(extent_node_t)	link_ad;
-
-	/* Profile counters, used for huge objects. */
-	prof_ctx_t		*prof_ctx;
+	/* Arena from which this extent came, if any. */
+	arena_t			*en_arena;
 
 	/* Pointer to the extent that this tree node is responsible for. */
-	void			*addr;
+	void			*en_addr;
 
 	/* Total region size. */
-	size_t			size;
+	size_t			en_size;
+
+	/*
+	 * The zeroed flag is used by chunk recycling code to track whether
+	 * memory is zero-filled.
+	 */
+	bool			en_zeroed;
+
+	/*
+	 * True if physical memory is committed to the extent, whether
+	 * explicitly or implicitly as on a system that overcommits and
+	 * satisfies physical memory needs on demand via soft page faults.
+	 */
+	bool			en_committed;
+
+	/*
+	 * The achunk flag is used to validate that huge allocation lookups
+	 * don't return arena chunks.
+	 */
+	bool			en_achunk;
 
-	/* True if zero-filled; used by chunk recycling code. */
-	bool			zeroed;
+	/* Profile counters, used for huge objects. */
+	prof_tctx_t		*en_prof_tctx;
+
+	/* Linkage for arena's runs_dirty and chunks_cache rings. */
+	arena_runs_dirty_link_t	rd;
+	qr(extent_node_t)	cc_link;
+
+	union {
+		/* Linkage for the size/address-ordered tree. */
+		rb_node(extent_node_t)	szad_link;
+
+		/* Linkage for arena's huge and node_cache lists. */
+		ql_elm(extent_node_t)	ql_link;
+	};
+
+	/* Linkage for the address-ordered tree. */
+	rb_node(extent_node_t)	ad_link;
 };
 typedef rb_tree(extent_node_t) extent_tree_t;
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
@@ -38,9 +66,174 @@
 rb_proto(, extent_tree_ad_, extent_tree_t, extent_node_t)
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
+#ifndef JEMALLOC_ENABLE_INLINE
+arena_t	*extent_node_arena_get(const extent_node_t *node);
+void	*extent_node_addr_get(const extent_node_t *node);
+size_t	extent_node_size_get(const extent_node_t *node);
+bool	extent_node_zeroed_get(const extent_node_t *node);
+bool	extent_node_committed_get(const extent_node_t *node);
+bool	extent_node_achunk_get(const extent_node_t *node);
+prof_tctx_t	*extent_node_prof_tctx_get(const extent_node_t *node);
+void	extent_node_arena_set(extent_node_t *node, arena_t *arena);
+void	extent_node_addr_set(extent_node_t *node, void *addr);
+void	extent_node_size_set(extent_node_t *node, size_t size);
+void	extent_node_zeroed_set(extent_node_t *node, bool zeroed);
+void	extent_node_committed_set(extent_node_t *node, bool committed);
+void	extent_node_achunk_set(extent_node_t *node, bool achunk);
+void	extent_node_prof_tctx_set(extent_node_t *node, prof_tctx_t *tctx);
+void	extent_node_init(extent_node_t *node, arena_t *arena, void *addr,
+    size_t size, bool zeroed, bool committed);
+void	extent_node_dirty_linkage_init(extent_node_t *node);
+void	extent_node_dirty_insert(extent_node_t *node,
+    arena_runs_dirty_link_t *runs_dirty, extent_node_t *chunks_dirty);
+void	extent_node_dirty_remove(extent_node_t *node);
+#endif
+
+#if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_EXTENT_C_))
+JEMALLOC_INLINE arena_t *
+extent_node_arena_get(const extent_node_t *node)
+{
+
+	return (node->en_arena);
+}
+
+JEMALLOC_INLINE void *
+extent_node_addr_get(const extent_node_t *node)
+{
+
+	return (node->en_addr);
+}
+
+JEMALLOC_INLINE size_t
+extent_node_size_get(const extent_node_t *node)
+{
+
+	return (node->en_size);
+}
+
+JEMALLOC_INLINE bool
+extent_node_zeroed_get(const extent_node_t *node)
+{
+
+	return (node->en_zeroed);
+}
+
+JEMALLOC_INLINE bool
+extent_node_committed_get(const extent_node_t *node)
+{
+
+	assert(!node->en_achunk);
+	return (node->en_committed);
+}
+
+JEMALLOC_INLINE bool
+extent_node_achunk_get(const extent_node_t *node)
+{
+
+	return (node->en_achunk);
+}
+
+JEMALLOC_INLINE prof_tctx_t *
+extent_node_prof_tctx_get(const extent_node_t *node)
+{
+
+	return (node->en_prof_tctx);
+}
+
+JEMALLOC_INLINE void
+extent_node_arena_set(extent_node_t *node, arena_t *arena)
+{
+
+	node->en_arena = arena;
+}
+
+JEMALLOC_INLINE void
+extent_node_addr_set(extent_node_t *node, void *addr)
+{
+
+	node->en_addr = addr;
+}
+
+JEMALLOC_INLINE void
+extent_node_size_set(extent_node_t *node, size_t size)
+{
+
+	node->en_size = size;
+}
+
+JEMALLOC_INLINE void
+extent_node_zeroed_set(extent_node_t *node, bool zeroed)
+{
+
+	node->en_zeroed = zeroed;
+}
+
+JEMALLOC_INLINE void
+extent_node_committed_set(extent_node_t *node, bool committed)
+{
+
+	node->en_committed = committed;
+}
+
+JEMALLOC_INLINE void
+extent_node_achunk_set(extent_node_t *node, bool achunk)
+{
+
+	node->en_achunk = achunk;
+}
+
+JEMALLOC_INLINE void
+extent_node_prof_tctx_set(extent_node_t *node, prof_tctx_t *tctx)
+{
+
+	node->en_prof_tctx = tctx;
+}
+
+JEMALLOC_INLINE void
+extent_node_init(extent_node_t *node, arena_t *arena, void *addr, size_t size,
+    bool zeroed, bool committed)
+{
+
+	extent_node_arena_set(node, arena);
+	extent_node_addr_set(node, addr);
+	extent_node_size_set(node, size);
+	extent_node_zeroed_set(node, zeroed);
+	extent_node_committed_set(node, committed);
+	extent_node_achunk_set(node, false);
+	if (config_prof)
+		extent_node_prof_tctx_set(node, NULL);
+}
+
+JEMALLOC_INLINE void
+extent_node_dirty_linkage_init(extent_node_t *node)
+{
+
+	qr_new(&node->rd, rd_link);
+	qr_new(node, cc_link);
+}
+
+JEMALLOC_INLINE void
+extent_node_dirty_insert(extent_node_t *node,
+    arena_runs_dirty_link_t *runs_dirty, extent_node_t *chunks_dirty)
+{
+
+	qr_meld(runs_dirty, &node->rd, rd_link);
+	qr_meld(chunks_dirty, node, cc_link);
+}
+
+JEMALLOC_INLINE void
+extent_node_dirty_remove(extent_node_t *node)
+{
+
+	qr_remove(&node->rd, rd_link);
+	qr_remove(node, cc_link);
+}
+
+#endif
+
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/hash.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/hash.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/hash.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/hash.h	2016-05-06 15:11:36.000000000 +0800
@@ -32,19 +32,20 @@
 /******************************************************************************/
 /* Internal implementation. */
 JEMALLOC_INLINE uint32_t
 hash_rotl_32(uint32_t x, int8_t r)
 {
 
-	return (x << r) | (x >> (32 - r));
+	return ((x << r) | (x >> (32 - r)));
 }
 
 JEMALLOC_INLINE uint64_t
 hash_rotl_64(uint64_t x, int8_t r)
 {
-	return (x << r) | (x >> (64 - r));
+
+	return ((x << r) | (x >> (64 - r)));
 }
 
 JEMALLOC_INLINE uint32_t
 hash_get_block_32(const uint32_t *p, int i)
 {
 
@@ -73,15 +74,15 @@
 
 JEMALLOC_INLINE uint64_t
 hash_fmix_64(uint64_t k)
 {
 
 	k ^= k >> 33;
-	k *= QU(0xff51afd7ed558ccdLLU);
+	k *= KQU(0xff51afd7ed558ccd);
 	k ^= k >> 33;
-	k *= QU(0xc4ceb9fe1a85ec53LLU);
+	k *= KQU(0xc4ceb9fe1a85ec53);
 	k ^= k >> 33;
 
 	return (k);
 }
 
 JEMALLOC_INLINE uint32_t
@@ -244,14 +245,14 @@
 	const uint8_t *data = (const uint8_t *) key;
 	const int nblocks = len / 16;
 
 	uint64_t h1 = seed;
 	uint64_t h2 = seed;
 
-	const uint64_t c1 = QU(0x87c37b91114253d5LLU);
-	const uint64_t c2 = QU(0x4cf5ad432745937fLLU);
+	const uint64_t c1 = KQU(0x87c37b91114253d5);
+	const uint64_t c2 = KQU(0x4cf5ad432745937f);
 
 	/* body */
 	{
 		const uint64_t *blocks = (const uint64_t *) (data);
 		int i;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/huge.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/huge.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/huge.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/huge.h	2016-05-06 15:11:36.000000000 +0800
@@ -6,40 +6,30 @@
 #ifdef JEMALLOC_H_STRUCTS
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-/* Huge allocation statistics. */
-extern uint64_t		huge_nmalloc;
-extern uint64_t		huge_ndalloc;
-extern size_t		huge_allocated;
-
-/* Protects chunk-related data structures. */
-extern malloc_mutex_t	huge_mtx;
-
-void	*huge_malloc(size_t size, bool zero, dss_prec_t dss_prec);
-void	*huge_palloc(size_t size, size_t alignment, bool zero,
-    dss_prec_t dss_prec);
-bool	huge_ralloc_no_move(void *ptr, size_t oldsize, size_t size,
-    size_t extra);
-void	*huge_ralloc(void *ptr, size_t oldsize, size_t size, size_t extra,
-    size_t alignment, bool zero, bool try_tcache_dalloc, dss_prec_t dss_prec);
+void	*huge_malloc(tsd_t *tsd, arena_t *arena, size_t size, bool zero,
+    tcache_t *tcache);
+void	*huge_palloc(tsd_t *tsd, arena_t *arena, size_t size, size_t alignment,
+    bool zero, tcache_t *tcache);
+bool	huge_ralloc_no_move(void *ptr, size_t oldsize, size_t usize_min,
+    size_t usize_max, bool zero);
+void	*huge_ralloc(tsd_t *tsd, arena_t *arena, void *ptr, size_t oldsize,
+    size_t usize, size_t alignment, bool zero, tcache_t *tcache);
 #ifdef JEMALLOC_JET
 typedef void (huge_dalloc_junk_t)(void *, size_t);
 extern huge_dalloc_junk_t *huge_dalloc_junk;
 #endif
-void	huge_dalloc(void *ptr, bool unmap);
+void	huge_dalloc(tsd_t *tsd, void *ptr, tcache_t *tcache);
+arena_t	*huge_aalloc(const void *ptr);
 size_t	huge_salloc(const void *ptr);
-dss_prec_t	huge_dss_prec_get(arena_t *arena);
-prof_ctx_t	*huge_prof_ctx_get(const void *ptr);
-void	huge_prof_ctx_set(const void *ptr, prof_ctx_t *ctx);
-bool	huge_boot(void);
-void	huge_prefork(void);
-void	huge_postfork_parent(void);
-void	huge_postfork_child(void);
+prof_tctx_t	*huge_prof_tctx_get(const void *ptr);
+void	huge_prof_tctx_set(const void *ptr, prof_tctx_t *tctx);
+void	huge_prof_tctx_reset(const void *ptr);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #endif /* JEMALLOC_H_INLINES */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal: jemalloc_internal_decls.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h	2017-09-27 22:47:53.326963470 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h	2017-09-27 22:49:15.130960472 +0800
@@ -20,12 +20,15 @@
 /*
  * Hyper-threaded CPUs may need a special instruction inside spin loops in
  * order to yield to another virtual CPU.
  */
 #define CPU_SPINWAIT __asm__ volatile("pause")
 
+/* Defined if C11 atomics are available. */
+/* #undef JEMALLOC_C11ATOMICS */
+
 /* Defined if the equivalent of FreeBSD's atomic(9) functions are available. */
 /* #undef JEMALLOC_ATOMIC9 */
 
 /*
  * Defined if OSAtomic*() functions are available, as provided by Darwin, and
  * documented in the atomic(3) manual page.
@@ -33,31 +36,51 @@
 /* #undef JEMALLOC_OSATOMIC */
 
 /*
  * Defined if __sync_add_and_fetch(uint32_t *, uint32_t) and
  * __sync_sub_and_fetch(uint32_t *, uint32_t) are available, despite
  * __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 not being defined (which means the
- * functions are defined in libgcc instead of being inlines)
+ * functions are defined in libgcc instead of being inlines).
  */
 /* #undef JE_FORCE_SYNC_COMPARE_AND_SWAP_4 */
 
 /*
  * Defined if __sync_add_and_fetch(uint64_t *, uint64_t) and
  * __sync_sub_and_fetch(uint64_t *, uint64_t) are available, despite
  * __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 not being defined (which means the
- * functions are defined in libgcc instead of being inlines)
+ * functions are defined in libgcc instead of being inlines).
  */
 /* #undef JE_FORCE_SYNC_COMPARE_AND_SWAP_8 */
 
 /*
+ * Defined if __builtin_clz() and __builtin_clzl() are available.
+ */
+#define JEMALLOC_HAVE_BUILTIN_CLZ 
+
+/*
+ * Defined if madvise(2) is available.
+ */
+#define JEMALLOC_HAVE_MADVISE 
+
+/*
  * Defined if OSSpin*() functions are available, as provided by Darwin, and
  * documented in the spinlock(3) manual page.
  */
 /* #undef JEMALLOC_OSSPIN */
 
 /*
+ * Defined if secure_getenv(3) is available.
+ */
+#define JEMALLOC_HAVE_SECURE_GETENV 
+
+/*
+ * Defined if issetugid(2) is available.
+ */
+/* #undef JEMALLOC_HAVE_ISSETUGID */
+
+/*
  * Defined if _malloc_thread_cleanup() exists.  At least in the case of
  * FreeBSD, pthread_key_create() allocates, which if used during malloc
  * bootstrapping will cause recursion into the pthreads library.  Therefore, if
  * _malloc_thread_cleanup() exists, use it as the basis for thread cleanup in
  * malloc_tsd.
  */
@@ -74,17 +97,14 @@
  * Defined if the pthreads implementation defines
  * _pthread_mutex_init_calloc_cb(), in which case the function is used in order
  * to avoid recursive allocation during mutex initialization.
  */
 /* #undef JEMALLOC_MUTEX_INIT_CB */
 
-/* Defined if sbrk() is supported. */
-#define JEMALLOC_HAVE_SBRK 
-
 /* Non-empty if the tls_model attribute is supported. */
-#define JEMALLOC_TLS_MODEL 
+#define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
 
 /* JEMALLOC_CC_SILENCE enables code that silences unuseful compiler warnings. */
 #define JEMALLOC_CC_SILENCE 
 
 /* JEMALLOC_CODE_COVERAGE enables test code coverage analysis. */
 /* #undef JEMALLOC_CODE_COVERAGE */
@@ -118,13 +138,13 @@
 #define JEMALLOC_TCACHE 
 
 /*
  * JEMALLOC_DSS enables use of sbrk(2) to allocate chunks from the data storage
  * segment (DSS).
  */
-/* #undef JEMALLOC_DSS */
+#define JEMALLOC_DSS 
 
 /* Support memory filling (junk/zero/quarantine/redzone). */
 #define JEMALLOC_FILL 
 
 /* Support utrace(2)-based tracing. */
 /* #undef JEMALLOC_UTRACE */
@@ -135,39 +155,63 @@
 /* Support optional abort() on OOM. */
 /* #undef JEMALLOC_XMALLOC */
 
 /* Support lazy locking (avoid locking unless a second thread is launched). */
 /* #undef JEMALLOC_LAZY_LOCK */
 
-/* One page is 2^STATIC_PAGE_SHIFT bytes. */
-#define STATIC_PAGE_SHIFT 12
+/* Minimum size class to support is 2^LG_TINY_MIN bytes. */
+#define LG_TINY_MIN 3
+
+/*
+ * Minimum allocation alignment is 2^LG_QUANTUM bytes (ignoring tiny size
+ * classes).
+ */
+/* #undef LG_QUANTUM */
+
+/* One page is 2^LG_PAGE bytes. */
+#define LG_PAGE 12
+
+/*
+ * If defined, adjacent virtual memory mappings with identical attributes
+ * automatically coalesce, and they fragment when changes are made to subranges.
+ * This is the normal order of things for mmap()/munmap(), but on Windows
+ * VirtualAlloc()/VirtualFree() operations must be precisely matched, i.e.
+ * mappings do *not* coalesce/fragment.
+ */
+#define JEMALLOC_MAPS_COALESCE 
 
 /*
  * If defined, use munmap() to unmap freed chunks, rather than storing them for
  * later reuse.  This is disabled by default on Linux because common sequences
  * of mmap()/munmap() calls will cause virtual memory map holes.
  */
 /* #undef JEMALLOC_MUNMAP */
 
-/*
- * If defined, use mremap(...MREMAP_FIXED...) for huge realloc().  This is
- * disabled by default because it is Linux-specific and it will cause virtual
- * memory map holes, much like munmap(2) does.
- */
-/* #undef JEMALLOC_MREMAP */
-
 /* TLS is used to map arenas and magazine caches to threads. */
 #define JEMALLOC_TLS 
 
 /*
+ * ffs()/ffsl() functions to use for bitmapping.  Don't use these directly;
+ * instead, use jemalloc_ffs() or jemalloc_ffsl() from util.h.
+ */
+#define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+#define JEMALLOC_INTERNAL_FFS __builtin_ffs
+
+/*
  * JEMALLOC_IVSALLOC enables ivsalloc(), which verifies that pointers reside
  * within jemalloc-owned chunks before dereferencing them.
  */
 /* #undef JEMALLOC_IVSALLOC */
 
 /*
+ * If defined, explicitly attempt to more uniformly distribute large allocation
+ * pointer alignments across all cache indices.
+ */
+#define JEMALLOC_CACHE_OBLIVIOUS 
+
+/*
  * Darwin (OS X) uses zones to work around Mach-O symbol override shortcomings.
  */
 /* #undef JEMALLOC_ZONE */
 /* #undef JEMALLOC_ZONE_VERSION */
 
 /*
@@ -180,15 +224,13 @@
  *                             unused, such that they will be discarded rather
  *                             than swapped out.
  */
 #define JEMALLOC_PURGE_MADVISE_DONTNEED 
 /* #undef JEMALLOC_PURGE_MADVISE_FREE */
 
-/*
- * Define if operating system has alloca.h header.
- */
+/* Define if operating system has alloca.h header. */
 #define JEMALLOC_HAS_ALLOCA_H 1
 
 /* C99 restrict keyword supported. */
 /* #undef JEMALLOC_HAS_RESTRICT */
 
 /* For use by hash code. */
@@ -200,7 +242,22 @@
 /* sizeof(long) == 2^LG_SIZEOF_LONG. */
 #define LG_SIZEOF_LONG 3
 
 /* sizeof(intmax_t) == 2^LG_SIZEOF_INTMAX_T. */
 #define LG_SIZEOF_INTMAX_T 3
 
+/* glibc malloc hooks (__malloc_hook, __realloc_hook, __free_hook). */
+#define JEMALLOC_GLIBC_MALLOC_HOOK 
+
+/* glibc memalign hook. */
+#define JEMALLOC_GLIBC_MEMALIGN_HOOK 
+
+/* Adaptive mutex support in pthreads. */
+#define JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP 
+
+/*
+ * If defined, jemalloc symbols are not exported (doesn't work when
+ * JEMALLOC_PREFIX is not defined).
+ */
+/* #undef JEMALLOC_EXPORT */
+
 #endif /* JEMALLOC_INTERNAL_DEFS_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h.in	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h.in	2016-05-06 15:11:36.000000000 +0800
@@ -19,12 +19,15 @@
 /*
  * Hyper-threaded CPUs may need a special instruction inside spin loops in
  * order to yield to another virtual CPU.
  */
 #undef CPU_SPINWAIT
 
+/* Defined if C11 atomics are available. */
+#undef JEMALLOC_C11ATOMICS
+
 /* Defined if the equivalent of FreeBSD's atomic(9) functions are available. */
 #undef JEMALLOC_ATOMIC9
 
 /*
  * Defined if OSAtomic*() functions are available, as provided by Darwin, and
  * documented in the atomic(3) manual page.
@@ -32,31 +35,51 @@
 #undef JEMALLOC_OSATOMIC
 
 /*
  * Defined if __sync_add_and_fetch(uint32_t *, uint32_t) and
  * __sync_sub_and_fetch(uint32_t *, uint32_t) are available, despite
  * __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 not being defined (which means the
- * functions are defined in libgcc instead of being inlines)
+ * functions are defined in libgcc instead of being inlines).
  */
 #undef JE_FORCE_SYNC_COMPARE_AND_SWAP_4
 
 /*
  * Defined if __sync_add_and_fetch(uint64_t *, uint64_t) and
  * __sync_sub_and_fetch(uint64_t *, uint64_t) are available, despite
  * __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 not being defined (which means the
- * functions are defined in libgcc instead of being inlines)
+ * functions are defined in libgcc instead of being inlines).
  */
 #undef JE_FORCE_SYNC_COMPARE_AND_SWAP_8
 
 /*
+ * Defined if __builtin_clz() and __builtin_clzl() are available.
+ */
+#undef JEMALLOC_HAVE_BUILTIN_CLZ
+
+/*
+ * Defined if madvise(2) is available.
+ */
+#undef JEMALLOC_HAVE_MADVISE
+
+/*
  * Defined if OSSpin*() functions are available, as provided by Darwin, and
  * documented in the spinlock(3) manual page.
  */
 #undef JEMALLOC_OSSPIN
 
 /*
+ * Defined if secure_getenv(3) is available.
+ */
+#undef JEMALLOC_HAVE_SECURE_GETENV
+
+/*
+ * Defined if issetugid(2) is available.
+ */
+#undef JEMALLOC_HAVE_ISSETUGID
+
+/*
  * Defined if _malloc_thread_cleanup() exists.  At least in the case of
  * FreeBSD, pthread_key_create() allocates, which if used during malloc
  * bootstrapping will cause recursion into the pthreads library.  Therefore, if
  * _malloc_thread_cleanup() exists, use it as the basis for thread cleanup in
  * malloc_tsd.
  */
@@ -73,15 +96,12 @@
  * Defined if the pthreads implementation defines
  * _pthread_mutex_init_calloc_cb(), in which case the function is used in order
  * to avoid recursive allocation during mutex initialization.
  */
 #undef JEMALLOC_MUTEX_INIT_CB
 
-/* Defined if sbrk() is supported. */
-#undef JEMALLOC_HAVE_SBRK
-
 /* Non-empty if the tls_model attribute is supported. */
 #undef JEMALLOC_TLS_MODEL
 
 /* JEMALLOC_CC_SILENCE enables code that silences unuseful compiler warnings. */
 #undef JEMALLOC_CC_SILENCE
 
@@ -134,39 +154,63 @@
 /* Support optional abort() on OOM. */
 #undef JEMALLOC_XMALLOC
 
 /* Support lazy locking (avoid locking unless a second thread is launched). */
 #undef JEMALLOC_LAZY_LOCK
 
-/* One page is 2^STATIC_PAGE_SHIFT bytes. */
-#undef STATIC_PAGE_SHIFT
+/* Minimum size class to support is 2^LG_TINY_MIN bytes. */
+#undef LG_TINY_MIN
+
+/*
+ * Minimum allocation alignment is 2^LG_QUANTUM bytes (ignoring tiny size
+ * classes).
+ */
+#undef LG_QUANTUM
+
+/* One page is 2^LG_PAGE bytes. */
+#undef LG_PAGE
+
+/*
+ * If defined, adjacent virtual memory mappings with identical attributes
+ * automatically coalesce, and they fragment when changes are made to subranges.
+ * This is the normal order of things for mmap()/munmap(), but on Windows
+ * VirtualAlloc()/VirtualFree() operations must be precisely matched, i.e.
+ * mappings do *not* coalesce/fragment.
+ */
+#undef JEMALLOC_MAPS_COALESCE
 
 /*
  * If defined, use munmap() to unmap freed chunks, rather than storing them for
  * later reuse.  This is disabled by default on Linux because common sequences
  * of mmap()/munmap() calls will cause virtual memory map holes.
  */
 #undef JEMALLOC_MUNMAP
 
-/*
- * If defined, use mremap(...MREMAP_FIXED...) for huge realloc().  This is
- * disabled by default because it is Linux-specific and it will cause virtual
- * memory map holes, much like munmap(2) does.
- */
-#undef JEMALLOC_MREMAP
-
 /* TLS is used to map arenas and magazine caches to threads. */
 #undef JEMALLOC_TLS
 
 /*
+ * ffs()/ffsl() functions to use for bitmapping.  Don't use these directly;
+ * instead, use jemalloc_ffs() or jemalloc_ffsl() from util.h.
+ */
+#undef JEMALLOC_INTERNAL_FFSL
+#undef JEMALLOC_INTERNAL_FFS
+
+/*
  * JEMALLOC_IVSALLOC enables ivsalloc(), which verifies that pointers reside
  * within jemalloc-owned chunks before dereferencing them.
  */
 #undef JEMALLOC_IVSALLOC
 
 /*
+ * If defined, explicitly attempt to more uniformly distribute large allocation
+ * pointer alignments across all cache indices.
+ */
+#undef JEMALLOC_CACHE_OBLIVIOUS
+
+/*
  * Darwin (OS X) uses zones to work around Mach-O symbol override shortcomings.
  */
 #undef JEMALLOC_ZONE
 #undef JEMALLOC_ZONE_VERSION
 
 /*
@@ -179,15 +223,13 @@
  *                             unused, such that they will be discarded rather
  *                             than swapped out.
  */
 #undef JEMALLOC_PURGE_MADVISE_DONTNEED
 #undef JEMALLOC_PURGE_MADVISE_FREE
 
-/*
- * Define if operating system has alloca.h header.
- */
+/* Define if operating system has alloca.h header. */
 #undef JEMALLOC_HAS_ALLOCA_H
 
 /* C99 restrict keyword supported. */
 #undef JEMALLOC_HAS_RESTRICT
 
 /* For use by hash code. */
@@ -199,7 +241,22 @@
 /* sizeof(long) == 2^LG_SIZEOF_LONG. */
 #undef LG_SIZEOF_LONG
 
 /* sizeof(intmax_t) == 2^LG_SIZEOF_INTMAX_T. */
 #undef LG_SIZEOF_INTMAX_T
 
+/* glibc malloc hooks (__malloc_hook, __realloc_hook, __free_hook). */
+#undef JEMALLOC_GLIBC_MALLOC_HOOK
+
+/* glibc memalign hook. */
+#undef JEMALLOC_GLIBC_MEMALIGN_HOOK
+
+/* Adaptive mutex support in pthreads. */
+#undef JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP
+
+/*
+ * If defined, jemalloc symbols are not exported (doesn't work when
+ * JEMALLOC_PREFIX is not defined).
+ */
+#undef JEMALLOC_EXPORT
+
 #endif /* JEMALLOC_INTERNAL_DEFS_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h	2017-09-27 22:47:53.266963472 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h	2017-09-27 22:49:15.046960475 +0800
@@ -1,73 +1,16 @@
 #ifndef JEMALLOC_INTERNAL_H
 #define	JEMALLOC_INTERNAL_H
-#include <math.h>
-#ifdef _WIN32
-#  include <windows.h>
-#  define ENOENT ERROR_PATH_NOT_FOUND
-#  define EINVAL ERROR_BAD_ARGUMENTS
-#  define EAGAIN ERROR_OUTOFMEMORY
-#  define EPERM  ERROR_WRITE_FAULT
-#  define EFAULT ERROR_INVALID_ADDRESS
-#  define ENOMEM ERROR_NOT_ENOUGH_MEMORY
-#  undef ERANGE
-#  define ERANGE ERROR_INVALID_DATA
-#else
-#  include <sys/param.h>
-#  include <sys/mman.h>
-#  include <sys/syscall.h>
-#  if !defined(SYS_write) && defined(__NR_write)
-#    define SYS_write __NR_write
-#  endif
-#  include <sys/uio.h>
-#  include <pthread.h>
-#  include <errno.h>
-#endif
-#include <sys/types.h>
-
-#include <limits.h>
-#ifndef SIZE_T_MAX
-#  define SIZE_T_MAX	SIZE_MAX
-#endif
-#include <stdarg.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <stddef.h>
-#ifndef offsetof
-#  define offsetof(type, member)	((size_t)&(((type *)NULL)->member))
-#endif
-#include <inttypes.h>
-#include <string.h>
-#include <strings.h>
-#include <ctype.h>
-#ifdef _MSC_VER
-#  include <io.h>
-typedef intptr_t ssize_t;
-#  define PATH_MAX 1024
-#  define STDERR_FILENO 2
-#  define __func__ __FUNCTION__
-/* Disable warnings about deprecated system functions */
-#  pragma warning(disable: 4996)
-#else
-#  include <unistd.h>
-#endif
-#include <fcntl.h>
 
 #include "jemalloc_internal_defs.h"
+#include "jemalloc/internal/jemalloc_internal_decls.h"
 
 #ifdef JEMALLOC_UTRACE
 #include <sys/ktrace.h>
 #endif
 
-#ifdef JEMALLOC_VALGRIND
-#include <valgrind/valgrind.h>
-#include <valgrind/memcheck.h>
-#endif
-
 #define	JEMALLOC_NO_DEMANGLE
 #ifdef JEMALLOC_JET
 #  define JEMALLOC_N(n) jet_##n
 #  include "jemalloc/internal/public_namespace.h"
 #  define JEMALLOC_NO_RENAME
 #  include "../jemalloc.h"
@@ -82,13 +25,13 @@
 #ifdef JEMALLOC_DEBUG
     true
 #else
     false
 #endif
     ;
-static const bool config_dss =
+static const bool have_dss =
 #ifdef JEMALLOC_DSS
     true
 #else
     false
 #endif
     ;
@@ -124,14 +67,14 @@
 #ifdef JEMALLOC_PROF_LIBUNWIND
     true
 #else
     false
 #endif
     ;
-static const bool config_mremap =
-#ifdef JEMALLOC_MREMAP
+static const bool maps_coalesce =
+#ifdef JEMALLOC_MAPS_COALESCE
     true
 #else
     false
 #endif
     ;
 static const bool config_munmap =
@@ -187,12 +130,23 @@
 #ifdef JEMALLOC_IVSALLOC
     true
 #else
     false
 #endif
     ;
+static const bool config_cache_oblivious =
+#ifdef JEMALLOC_CACHE_OBLIVIOUS
+    true
+#else
+    false
+#endif
+    ;
+
+#ifdef JEMALLOC_C11ATOMICS
+#include <stdatomic.h>
+#endif
 
 #ifdef JEMALLOC_ATOMIC9
 #include <machine/atomic.h>
 #endif
 
 #if (defined(JEMALLOC_OSATOMIC) || defined(JEMALLOC_OSSPIN))
@@ -226,34 +180,62 @@
  */
 /******************************************************************************/
 #define	JEMALLOC_H_TYPES
 
 #include "jemalloc/internal/jemalloc_internal_macros.h"
 
+/* Size class index type. */
+typedef unsigned szind_t;
+
+/*
+ * Flags bits:
+ *
+ * a: arena
+ * t: tcache
+ * 0: unused
+ * z: zero
+ * n: alignment
+ *
+ * aaaaaaaa aaaatttt tttttttt 0znnnnnn
+ */
+#define	MALLOCX_ARENA_MASK	((int)~0xfffff)
+#define	MALLOCX_ARENA_MAX	0xffe
+#define	MALLOCX_TCACHE_MASK	((int)~0xfff000ffU)
+#define	MALLOCX_TCACHE_MAX	0xffd
 #define	MALLOCX_LG_ALIGN_MASK	((int)0x3f)
-#define	ALLOCM_LG_ALIGN_MASK	((int)0x3f)
+/* Use MALLOCX_ALIGN_GET() if alignment may not be specified in flags. */
+#define	MALLOCX_ALIGN_GET_SPECIFIED(flags)				\
+    (ZU(1) << (flags & MALLOCX_LG_ALIGN_MASK))
+#define	MALLOCX_ALIGN_GET(flags)					\
+    (MALLOCX_ALIGN_GET_SPECIFIED(flags) & (SIZE_T_MAX-1))
+#define	MALLOCX_ZERO_GET(flags)						\
+    ((bool)(flags & MALLOCX_ZERO))
+
+#define	MALLOCX_TCACHE_GET(flags)					\
+    (((unsigned)((flags & MALLOCX_TCACHE_MASK) >> 8)) - 2)
+#define	MALLOCX_ARENA_GET(flags)					\
+    (((unsigned)(((unsigned)flags) >> 20)) - 1)
 
 /* Smallest size class to support. */
-#define	LG_TINY_MIN		3
 #define	TINY_MIN		(1U << LG_TINY_MIN)
 
 /*
- * Minimum alignment of allocations is 2^LG_QUANTUM bytes (ignoring tiny size
+ * Minimum allocation alignment is 2^LG_QUANTUM bytes (ignoring tiny size
  * classes).
  */
 #ifndef LG_QUANTUM
 #  if (defined(__i386__) || defined(_M_IX86))
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __ia64__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __alpha__
 #    define LG_QUANTUM		4
 #  endif
-#  ifdef __sparc64__
+#  if (defined(__sparc64__) || defined(__sparcv9))
 #    define LG_QUANTUM		4
 #  endif
 #  if (defined(__amd64__) || defined(__x86_64__) || defined(_M_X64))
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __arm__
@@ -265,26 +247,33 @@
 #  ifdef __hppa__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __mips__
 #    define LG_QUANTUM		3
 #  endif
+#  ifdef __or1k__
+#    define LG_QUANTUM		3
+#  endif
 #  ifdef __powerpc__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __s390__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __SH4__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __tile__
 #    define LG_QUANTUM		4
 #  endif
+#  ifdef __le32__
+#    define LG_QUANTUM		4
+#  endif
 #  ifndef LG_QUANTUM
-#    error "No LG_QUANTUM definition for architecture; specify via CPPFLAGS"
+#    error "Unknown minimum alignment for architecture; specify via "
+	 "--with-lg-quantum"
 #  endif
 #endif
 
 #define	QUANTUM			((size_t)(1U << LG_QUANTUM))
 #define	QUANTUM_MASK		(QUANTUM - 1)
 
@@ -318,18 +307,17 @@
 #define	CACHELINE_MASK		(CACHELINE - 1)
 
 /* Return the smallest cacheline multiple that is >= s. */
 #define	CACHELINE_CEILING(s)						\
 	(((s) + CACHELINE_MASK) & ~CACHELINE_MASK)
 
-/* Page size.  STATIC_PAGE_SHIFT is determined by the configure script. */
+/* Page size.  LG_PAGE is determined by the configure script. */
 #ifdef PAGE_MASK
 #  undef PAGE_MASK
 #endif
-#define	LG_PAGE		STATIC_PAGE_SHIFT
-#define	PAGE		((size_t)(1U << STATIC_PAGE_SHIFT))
+#define	PAGE		((size_t)(1U << LG_PAGE))
 #define	PAGE_MASK	((size_t)(PAGE - 1))
 
 /* Return the smallest pagesize multiple that is >= s. */
 #define	PAGE_CEILING(s)							\
 	(((s) + PAGE_MASK) & ~PAGE_MASK)
 
@@ -342,105 +330,31 @@
 	((size_t)((uintptr_t)(a) & (alignment - 1)))
 
 /* Return the smallest alignment multiple that is >= s. */
 #define	ALIGNMENT_CEILING(s, alignment)					\
 	(((s) + (alignment - 1)) & (-(alignment)))
 
-/* Declare a variable length array */
+/* Declare a variable-length array. */
 #if __STDC_VERSION__ < 199901L
 #  ifdef _MSC_VER
 #    include <malloc.h>
 #    define alloca _alloca
 #  else
 #    ifdef JEMALLOC_HAS_ALLOCA_H
 #      include <alloca.h>
 #    else
 #      include <stdlib.h>
 #    endif
 #  endif
 #  define VARIABLE_ARRAY(type, name, count) \
-	type *name = alloca(sizeof(type) * count)
-#else
-#  define VARIABLE_ARRAY(type, name, count) type name[count]
-#endif
-
-#ifdef JEMALLOC_VALGRIND
-/*
- * The JEMALLOC_VALGRIND_*() macros must be macros rather than functions
- * so that when Valgrind reports errors, there are no extra stack frames
- * in the backtraces.
- *
- * The size that is reported to valgrind must be consistent through a chain of
- * malloc..realloc..realloc calls.  Request size isn't recorded anywhere in
- * jemalloc, so it is critical that all callers of these macros provide usize
- * rather than request size.  As a result, buffer overflow detection is
- * technically weakened for the standard API, though it is generally accepted
- * practice to consider any extra bytes reported by malloc_usable_size() as
- * usable space.
- */
-#define	JEMALLOC_VALGRIND_MALLOC(cond, ptr, usize, zero) do {		\
-	if (config_valgrind && opt_valgrind && cond)			\
-		VALGRIND_MALLOCLIKE_BLOCK(ptr, usize, p2rz(ptr), zero);	\
-} while (0)
-#define	JEMALLOC_VALGRIND_REALLOC(ptr, usize, old_ptr, old_usize,	\
-    old_rzsize, zero)  do {						\
-	if (config_valgrind && opt_valgrind) {				\
-		size_t rzsize = p2rz(ptr);				\
-									\
-		if (ptr == old_ptr) {					\
-			VALGRIND_RESIZEINPLACE_BLOCK(ptr, old_usize,	\
-			    usize, rzsize);				\
-			if (zero && old_usize < usize) {		\
-				VALGRIND_MAKE_MEM_DEFINED(		\
-				    (void *)((uintptr_t)ptr +		\
-				    old_usize), usize - old_usize);	\
-			}						\
-		} else {						\
-			if (old_ptr != NULL) {				\
-				VALGRIND_FREELIKE_BLOCK(old_ptr,	\
-				    old_rzsize);			\
-			}						\
-			if (ptr != NULL) {				\
-				size_t copy_size = (old_usize < usize)	\
-				    ?  old_usize : usize;		\
-				size_t tail_size = usize - copy_size;	\
-				VALGRIND_MALLOCLIKE_BLOCK(ptr, usize,	\
-				    rzsize, false);			\
-				if (copy_size > 0) {			\
-					VALGRIND_MAKE_MEM_DEFINED(ptr,	\
-					    copy_size);			\
-				}					\
-				if (zero && tail_size > 0) {		\
-					VALGRIND_MAKE_MEM_DEFINED(	\
-					    (void *)((uintptr_t)ptr +	\
-					    copy_size), tail_size);	\
-				}					\
-			}						\
-		}							\
-	}								\
-} while (0)
-#define	JEMALLOC_VALGRIND_FREE(ptr, rzsize) do {			\
-	if (config_valgrind && opt_valgrind)				\
-		VALGRIND_FREELIKE_BLOCK(ptr, rzsize);			\
-} while (0)
+	type *name = alloca(sizeof(type) * (count))
 #else
-#define	RUNNING_ON_VALGRIND	((unsigned)0)
-#define	VALGRIND_MALLOCLIKE_BLOCK(addr, sizeB, rzB, is_zeroed) \
-    do {} while (0)
-#define	VALGRIND_RESIZEINPLACE_BLOCK(addr, oldSizeB, newSizeB, rzB) \
-    do {} while (0)
-#define	VALGRIND_FREELIKE_BLOCK(addr, rzB) do {} while (0)
-#define	VALGRIND_MAKE_MEM_NOACCESS(_qzz_addr, _qzz_len) do {} while (0)
-#define	VALGRIND_MAKE_MEM_UNDEFINED(_qzz_addr, _qzz_len) do {} while (0)
-#define	VALGRIND_MAKE_MEM_DEFINED(_qzz_addr, _qzz_len) do {} while (0)
-#define	JEMALLOC_VALGRIND_MALLOC(cond, ptr, usize, zero) do {} while (0)
-#define	JEMALLOC_VALGRIND_REALLOC(ptr, usize, old_ptr, old_usize,	\
-    old_rzsize, zero) do {} while (0)
-#define	JEMALLOC_VALGRIND_FREE(ptr, rzsize) do {} while (0)
+#  define VARIABLE_ARRAY(type, name, count) type name[(count)]
 #endif
 
+#include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
 #include "jemalloc/internal/prng.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
 #include "jemalloc/internal/stats.h"
@@ -449,166 +363,316 @@
 #include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/arena.h"
 #include "jemalloc/internal/bitmap.h"
 #include "jemalloc/internal/base.h"
+#include "jemalloc/internal/rtree.h"
+#include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
-#include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_TYPES
 /******************************************************************************/
 #define	JEMALLOC_H_STRUCTS
 
+#include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
 #include "jemalloc/internal/prng.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
 #include "jemalloc/internal/mutex.h"
-#include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/bitmap.h"
+#define	JEMALLOC_ARENA_STRUCTS_A
+#include "jemalloc/internal/arena.h"
+#undef JEMALLOC_ARENA_STRUCTS_A
 #include "jemalloc/internal/extent.h"
+#define	JEMALLOC_ARENA_STRUCTS_B
 #include "jemalloc/internal/arena.h"
+#undef JEMALLOC_ARENA_STRUCTS_B
 #include "jemalloc/internal/base.h"
+#include "jemalloc/internal/rtree.h"
+#include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
-#include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 #include "jemalloc/internal/prof.h"
 
-typedef struct {
-	uint64_t	allocated;
-	uint64_t	deallocated;
-} thread_allocated_t;
-/*
- * The JEMALLOC_ARG_CONCAT() wrapper is necessary to pass {0, 0} via a cpp macro
- * argument.
- */
-#define	THREAD_ALLOCATED_INITIALIZER	JEMALLOC_ARG_CONCAT({0, 0})
+#include "jemalloc/internal/tsd.h"
 
 #undef JEMALLOC_H_STRUCTS
 /******************************************************************************/
 #define	JEMALLOC_H_EXTERNS
 
 extern bool	opt_abort;
-extern bool	opt_junk;
+extern const char	*opt_junk;
+extern bool	opt_junk_alloc;
+extern bool	opt_junk_free;
 extern size_t	opt_quarantine;
 extern bool	opt_redzone;
 extern bool	opt_utrace;
-extern bool	opt_valgrind;
 extern bool	opt_xmalloc;
 extern bool	opt_zero;
 extern size_t	opt_narenas;
 
+extern bool	in_valgrind;
+
 /* Number of CPUs. */
 extern unsigned		ncpus;
 
-/* Protects arenas initialization (arenas, arenas_total). */
-extern malloc_mutex_t	arenas_lock;
 /*
- * Arenas that are used to service external requests.  Not all elements of the
- * arenas array are necessarily used; arenas are created lazily as needed.
- *
- * arenas[0..narenas_auto) are used for automatic multiplexing of threads and
- * arenas.  arenas[narenas_auto..narenas_total) are only used if the application
- * takes some action to create them and allocate from them.
+ * index2size_tab encodes the same information as could be computed (at
+ * unacceptable cost in some code paths) by index2size_compute().
+ */
+extern size_t const	index2size_tab[NSIZES];
+/*
+ * size2index_tab is a compact lookup table that rounds request sizes up to
+ * size classes.  In order to reduce cache footprint, the table is compressed,
+ * and all accesses are via size2index().
  */
-extern arena_t		**arenas;
-extern unsigned		narenas_total;
-extern unsigned		narenas_auto; /* Read-only after initialization. */
+extern uint8_t const	size2index_tab[];
 
+arena_t	*a0get(void);
+void	*a0malloc(size_t size);
+void	a0dalloc(void *ptr);
+void	*bootstrap_malloc(size_t size);
+void	*bootstrap_calloc(size_t num, size_t size);
+void	bootstrap_free(void *ptr);
 arena_t	*arenas_extend(unsigned ind);
-void	arenas_cleanup(void *arg);
-arena_t	*choose_arena_hard(void);
+arena_t	*arena_init(unsigned ind);
+unsigned	narenas_total_get(void);
+arena_t	*arena_get_hard(tsd_t *tsd, unsigned ind, bool init_if_missing);
+arena_t	*arena_choose_hard(tsd_t *tsd);
+void	arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind);
+unsigned	arena_nbound(unsigned ind);
+void	thread_allocated_cleanup(tsd_t *tsd);
+void	thread_deallocated_cleanup(tsd_t *tsd);
+void	arena_cleanup(tsd_t *tsd);
+void	arenas_cache_cleanup(tsd_t *tsd);
+void	narenas_cache_cleanup(tsd_t *tsd);
+void	arenas_cache_bypass_cleanup(tsd_t *tsd);
 void	jemalloc_prefork(void);
 void	jemalloc_postfork_parent(void);
 void	jemalloc_postfork_child(void);
 
+#include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
 #include "jemalloc/internal/prng.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
 #include "jemalloc/internal/mutex.h"
-#include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/bitmap.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/arena.h"
 #include "jemalloc/internal/base.h"
+#include "jemalloc/internal/rtree.h"
+#include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
-#include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 #include "jemalloc/internal/prof.h"
+#include "jemalloc/internal/tsd.h"
 
 #undef JEMALLOC_H_EXTERNS
 /******************************************************************************/
 #define	JEMALLOC_H_INLINES
 
+#include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
 #include "jemalloc/internal/prng.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
 #include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/base.h"
+#include "jemalloc/internal/rtree.h"
+#include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
 
 #ifndef JEMALLOC_ENABLE_INLINE
-malloc_tsd_protos(JEMALLOC_ATTR(unused), arenas, arena_t *)
-
+szind_t	size2index_compute(size_t size);
+szind_t	size2index_lookup(size_t size);
+szind_t	size2index(size_t size);
+size_t	index2size_compute(szind_t index);
+size_t	index2size_lookup(szind_t index);
+size_t	index2size(szind_t index);
+size_t	s2u_compute(size_t size);
+size_t	s2u_lookup(size_t size);
 size_t	s2u(size_t size);
 size_t	sa2u(size_t size, size_t alignment);
-unsigned	narenas_total_get(void);
-arena_t	*choose_arena(arena_t *arena);
+arena_t	*arena_choose(tsd_t *tsd, arena_t *arena);
+arena_t	*arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
+    bool refresh_if_missing);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
-/*
- * Map of pthread_self() --> arenas[???], used for selecting an arena to use
- * for allocations.
- */
-malloc_tsd_externs(arenas, arena_t *)
-malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, arenas, arena_t *, NULL,
-    arenas_cleanup)
+JEMALLOC_INLINE szind_t
+size2index_compute(size_t size)
+{
+
+#if (NTBINS != 0)
+	if (size <= (ZU(1) << LG_TINY_MAXCLASS)) {
+		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
+		size_t lg_ceil = lg_floor(pow2_ceil(size));
+		return (lg_ceil < lg_tmin ? 0 : lg_ceil - lg_tmin);
+	}
+#endif
+	{
+		size_t x = unlikely(ZI(size) < 0) ? ((size<<1) ?
+		    (ZU(1)<<(LG_SIZEOF_PTR+3)) : ((ZU(1)<<(LG_SIZEOF_PTR+3))-1))
+		    : lg_floor((size<<1)-1);
+		size_t shift = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? 0 :
+		    x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);
+		size_t grp = shift << LG_SIZE_CLASS_GROUP;
+
+		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
+		    ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
+
+		size_t delta_inverse_mask = ZI(-1) << lg_delta;
+		size_t mod = ((((size-1) & delta_inverse_mask) >> lg_delta)) &
+		    ((ZU(1) << LG_SIZE_CLASS_GROUP) - 1);
+
+		size_t index = NTBINS + grp + mod;
+		return (index);
+	}
+}
+
+JEMALLOC_ALWAYS_INLINE szind_t
+size2index_lookup(size_t size)
+{
+
+	assert(size <= LOOKUP_MAXCLASS);
+	{
+		size_t ret = ((size_t)(size2index_tab[(size-1) >>
+		    LG_TINY_MIN]));
+		assert(ret == size2index_compute(size));
+		return (ret);
+	}
+}
+
+JEMALLOC_ALWAYS_INLINE szind_t
+size2index(size_t size)
+{
+
+	assert(size > 0);
+	if (likely(size <= LOOKUP_MAXCLASS))
+		return (size2index_lookup(size));
+	return (size2index_compute(size));
+}
+
+JEMALLOC_INLINE size_t
+index2size_compute(szind_t index)
+{
+
+#if (NTBINS > 0)
+	if (index < NTBINS)
+		return (ZU(1) << (LG_TINY_MAXCLASS - NTBINS + 1 + index));
+#endif
+	{
+		size_t reduced_index = index - NTBINS;
+		size_t grp = reduced_index >> LG_SIZE_CLASS_GROUP;
+		size_t mod = reduced_index & ((ZU(1) << LG_SIZE_CLASS_GROUP) -
+		    1);
+
+		size_t grp_size_mask = ~((!!grp)-1);
+		size_t grp_size = ((ZU(1) << (LG_QUANTUM +
+		    (LG_SIZE_CLASS_GROUP-1))) << grp) & grp_size_mask;
+
+		size_t shift = (grp == 0) ? 1 : grp;
+		size_t lg_delta = shift + (LG_QUANTUM-1);
+		size_t mod_size = (mod+1) << lg_delta;
+
+		size_t usize = grp_size + mod_size;
+		return (usize);
+	}
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+index2size_lookup(szind_t index)
+{
+	size_t ret = (size_t)index2size_tab[index];
+	assert(ret == index2size_compute(index));
+	return (ret);
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+index2size(szind_t index)
+{
+
+	assert(index < NSIZES);
+	return (index2size_lookup(index));
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+s2u_compute(size_t size)
+{
+
+#if (NTBINS > 0)
+	if (size <= (ZU(1) << LG_TINY_MAXCLASS)) {
+		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
+		size_t lg_ceil = lg_floor(pow2_ceil(size));
+		return (lg_ceil < lg_tmin ? (ZU(1) << lg_tmin) :
+		    (ZU(1) << lg_ceil));
+	}
+#endif
+	{
+		size_t x = unlikely(ZI(size) < 0) ? ((size<<1) ?
+		    (ZU(1)<<(LG_SIZEOF_PTR+3)) : ((ZU(1)<<(LG_SIZEOF_PTR+3))-1))
+		    : lg_floor((size<<1)-1);
+		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
+		    ?  LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
+		size_t delta = ZU(1) << lg_delta;
+		size_t delta_mask = delta - 1;
+		size_t usize = (size + delta_mask) & ~delta_mask;
+		return (usize);
+	}
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+s2u_lookup(size_t size)
+{
+	size_t ret = index2size_lookup(size2index_lookup(size));
+
+	assert(ret == s2u_compute(size));
+	return (ret);
+}
 
 /*
  * Compute usable size that would result from allocating an object with the
  * specified size.
  */
 JEMALLOC_ALWAYS_INLINE size_t
 s2u(size_t size)
 {
 
-	if (size <= SMALL_MAXCLASS)
-		return (arena_bin_info[SMALL_SIZE2BIN(size)].reg_size);
-	if (size <= arena_maxclass)
-		return (PAGE_CEILING(size));
-	return (CHUNK_CEILING(size));
+	assert(size > 0);
+	if (likely(size <= LOOKUP_MAXCLASS))
+		return (s2u_lookup(size));
+	return (s2u_compute(size));
 }
 
 /*
  * Compute usable size that would result from allocating an object with the
  * specified size and alignment.
  */
@@ -616,264 +680,306 @@
 sa2u(size_t size, size_t alignment)
 {
 	size_t usize;
 
 	assert(alignment != 0 && ((alignment - 1) & alignment) == 0);
 
-	/*
-	 * Round size up to the nearest multiple of alignment.
-	 *
-	 * This done, we can take advantage of the fact that for each small
-	 * size class, every object is aligned at the smallest power of two
-	 * that is non-zero in the base two representation of the size.  For
-	 * example:
-	 *
-	 *   Size |   Base 2 | Minimum alignment
-	 *   -----+----------+------------------
-	 *     96 |  1100000 |  32
-	 *    144 | 10100000 |  32
-	 *    192 | 11000000 |  64
-	 */
-	usize = ALIGNMENT_CEILING(size, alignment);
-	/*
-	 * (usize < size) protects against the combination of maximal
-	 * alignment and size greater than maximal alignment.
-	 */
-	if (usize < size) {
-		/* size_t overflow. */
-		return (0);
+	/* Try for a small size class. */
+	if (size <= SMALL_MAXCLASS && alignment < PAGE) {
+		/*
+		 * Round size up to the nearest multiple of alignment.
+		 *
+		 * This done, we can take advantage of the fact that for each
+		 * small size class, every object is aligned at the smallest
+		 * power of two that is non-zero in the base two representation
+		 * of the size.  For example:
+		 *
+		 *   Size |   Base 2 | Minimum alignment
+		 *   -----+----------+------------------
+		 *     96 |  1100000 |  32
+		 *    144 | 10100000 |  32
+		 *    192 | 11000000 |  64
+		 */
+		usize = s2u(ALIGNMENT_CEILING(size, alignment));
+		if (usize < LARGE_MINCLASS)
+			return (usize);
 	}
 
-	if (usize <= arena_maxclass && alignment <= PAGE) {
-		if (usize <= SMALL_MAXCLASS)
-			return (arena_bin_info[SMALL_SIZE2BIN(usize)].reg_size);
-		return (PAGE_CEILING(usize));
-	} else {
-		size_t run_size;
-
+	/* Try for a large size class. */
+	if (likely(size <= large_maxclass) && likely(alignment < chunksize)) {
 		/*
 		 * We can't achieve subpage alignment, so round up alignment
-		 * permanently; it makes later calculations simpler.
+		 * to the minimum that can actually be supported.
 		 */
 		alignment = PAGE_CEILING(alignment);
-		usize = PAGE_CEILING(size);
-		/*
-		 * (usize < size) protects against very large sizes within
-		 * PAGE of SIZE_T_MAX.
-		 *
-		 * (usize + alignment < usize) protects against the
-		 * combination of maximal alignment and usize large enough
-		 * to cause overflow.  This is similar to the first overflow
-		 * check above, but it needs to be repeated due to the new
-		 * usize value, which may now be *equal* to maximal
-		 * alignment, whereas before we only detected overflow if the
-		 * original size was *greater* than maximal alignment.
-		 */
-		if (usize < size || usize + alignment < usize) {
-			/* size_t overflow. */
-			return (0);
-		}
+
+		/* Make sure result is a large size class. */
+		usize = (size <= LARGE_MINCLASS) ? LARGE_MINCLASS : s2u(size);
 
 		/*
 		 * Calculate the size of the over-size run that arena_palloc()
 		 * would need to allocate in order to guarantee the alignment.
-		 * If the run wouldn't fit within a chunk, round up to a huge
-		 * allocation size.
 		 */
-		run_size = usize + alignment - PAGE;
-		if (run_size <= arena_maxclass)
-			return (PAGE_CEILING(usize));
-		return (CHUNK_CEILING(usize));
+		if (usize + large_pad + alignment - PAGE <= arena_maxrun)
+			return (usize);
 	}
-}
 
-JEMALLOC_INLINE unsigned
-narenas_total_get(void)
-{
-	unsigned narenas;
+	/* Huge size class.  Beware of size_t overflow. */
+
+	/*
+	 * We can't achieve subchunk alignment, so round up alignment to the
+	 * minimum that can actually be supported.
+	 */
+	alignment = CHUNK_CEILING(alignment);
+	if (alignment == 0) {
+		/* size_t overflow. */
+		return (0);
+	}
 
-	malloc_mutex_lock(&arenas_lock);
-	narenas = narenas_total;
-	malloc_mutex_unlock(&arenas_lock);
+	/* Make sure result is a huge size class. */
+	if (size <= chunksize)
+		usize = chunksize;
+	else {
+		usize = s2u(size);
+		if (usize < size) {
+			/* size_t overflow. */
+			return (0);
+		}
+	}
 
-	return (narenas);
+	/*
+	 * Calculate the multi-chunk mapping that huge_palloc() would need in
+	 * order to guarantee the alignment.
+	 */
+	if (usize + alignment - PAGE < usize) {
+		/* size_t overflow. */
+		return (0);
+	}
+	return (usize);
 }
 
 /* Choose an arena based on a per-thread value. */
 JEMALLOC_INLINE arena_t *
-choose_arena(arena_t *arena)
+arena_choose(tsd_t *tsd, arena_t *arena)
 {
 	arena_t *ret;
 
 	if (arena != NULL)
 		return (arena);
 
-	if ((ret = *arenas_tsd_get()) == NULL) {
-		ret = choose_arena_hard();
-		assert(ret != NULL);
-	}
+	if (unlikely((ret = tsd_arena_get(tsd)) == NULL))
+		ret = arena_choose_hard(tsd);
 
 	return (ret);
 }
+
+JEMALLOC_INLINE arena_t *
+arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
+    bool refresh_if_missing)
+{
+	arena_t *arena;
+	arena_t **arenas_cache = tsd_arenas_cache_get(tsd);
+
+	/* init_if_missing requires refresh_if_missing. */
+	assert(!init_if_missing || refresh_if_missing);
+
+	if (unlikely(arenas_cache == NULL)) {
+		/* arenas_cache hasn't been initialized yet. */
+		return (arena_get_hard(tsd, ind, init_if_missing));
+	}
+	if (unlikely(ind >= tsd_narenas_cache_get(tsd))) {
+		/*
+		 * ind is invalid, cache is old (too small), or arena to be
+		 * initialized.
+		 */
+		return (refresh_if_missing ? arena_get_hard(tsd, ind,
+		    init_if_missing) : NULL);
+	}
+	arena = arenas_cache[ind];
+	if (likely(arena != NULL) || !refresh_if_missing)
+		return (arena);
+	return (arena_get_hard(tsd, ind, init_if_missing));
+}
 #endif
 
 #include "jemalloc/internal/bitmap.h"
-#include "jemalloc/internal/rtree.h"
 /*
- * Include arena.h twice in order to resolve circular dependencies with
- * tcache.h.
+ * Include portions of arena.h interleaved with tcache.h in order to resolve
+ * circular dependencies.
  */
 #define	JEMALLOC_ARENA_INLINE_A
 #include "jemalloc/internal/arena.h"
 #undef JEMALLOC_ARENA_INLINE_A
 #include "jemalloc/internal/tcache.h"
 #define	JEMALLOC_ARENA_INLINE_B
 #include "jemalloc/internal/arena.h"
 #undef JEMALLOC_ARENA_INLINE_B
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 
 #ifndef JEMALLOC_ENABLE_INLINE
-void	*imalloct(size_t size, bool try_tcache, arena_t *arena);
-void	*imalloc(size_t size);
-void	*icalloct(size_t size, bool try_tcache, arena_t *arena);
-void	*icalloc(size_t size);
-void	*ipalloct(size_t usize, size_t alignment, bool zero, bool try_tcache,
-    arena_t *arena);
-void	*ipalloc(size_t usize, size_t alignment, bool zero);
+arena_t	*iaalloc(const void *ptr);
 size_t	isalloc(const void *ptr, bool demote);
+void	*iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache,
+    bool is_metadata, arena_t *arena);
+void	*imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
+void	*imalloc(tsd_t *tsd, size_t size);
+void	*icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
+void	*icalloc(tsd_t *tsd, size_t size);
+void	*ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, bool is_metadata, arena_t *arena);
+void	*ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, arena_t *arena);
+void	*ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero);
 size_t	ivsalloc(const void *ptr, bool demote);
 size_t	u2rz(size_t usize);
 size_t	p2rz(const void *ptr);
-void	idalloct(void *ptr, bool try_tcache);
-void	idalloc(void *ptr);
-void	iqalloct(void *ptr, bool try_tcache);
-void	iqalloc(void *ptr);
-void	*iralloct_realign(void *ptr, size_t oldsize, size_t size, size_t extra,
-    size_t alignment, bool zero, bool try_tcache_alloc, bool try_tcache_dalloc,
+void	idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata);
+void	idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache);
+void	idalloc(tsd_t *tsd, void *ptr);
+void	iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache);
+void	isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
+void	isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
+void	*iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
+    size_t extra, size_t alignment, bool zero, tcache_t *tcache,
     arena_t *arena);
-void	*iralloct(void *ptr, size_t size, size_t extra, size_t alignment,
-    bool zero, bool try_tcache_alloc, bool try_tcache_dalloc, arena_t *arena);
-void	*iralloc(void *ptr, size_t size, size_t extra, size_t alignment,
-    bool zero);
-bool	ixalloc(void *ptr, size_t size, size_t extra, size_t alignment,
-    bool zero);
-malloc_tsd_protos(JEMALLOC_ATTR(unused), thread_allocated, thread_allocated_t)
+void	*iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
+    size_t alignment, bool zero, tcache_t *tcache, arena_t *arena);
+void	*iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
+    size_t alignment, bool zero);
+bool	ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra,
+    size_t alignment, bool zero);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
+JEMALLOC_ALWAYS_INLINE arena_t *
+iaalloc(const void *ptr)
+{
+
+	assert(ptr != NULL);
+
+	return (arena_aalloc(ptr));
+}
+
+/*
+ * Typical usage:
+ *   void *ptr = [...]
+ *   size_t sz = isalloc(ptr, config_prof);
+ */
+JEMALLOC_ALWAYS_INLINE size_t
+isalloc(const void *ptr, bool demote)
+{
+
+	assert(ptr != NULL);
+	/* Demotion only makes sense if config_prof is true. */
+	assert(config_prof || !demote);
+
+	return (arena_salloc(ptr, demote));
+}
+
 JEMALLOC_ALWAYS_INLINE void *
-imalloct(size_t size, bool try_tcache, arena_t *arena)
+iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache, bool is_metadata,
+    arena_t *arena)
 {
+	void *ret;
 
 	assert(size != 0);
 
-	if (size <= arena_maxclass)
-		return (arena_malloc(arena, size, false, try_tcache));
-	else
-		return (huge_malloc(size, false, huge_dss_prec_get(arena)));
+	ret = arena_malloc(tsd, arena, size, zero, tcache);
+	if (config_stats && is_metadata && likely(ret != NULL)) {
+		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
+		    config_prof));
+	}
+	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-imalloc(size_t size)
+imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
 {
 
-	return (imalloct(size, true, NULL));
+	return (iallocztm(tsd, size, false, tcache, false, arena));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-icalloct(size_t size, bool try_tcache, arena_t *arena)
+imalloc(tsd_t *tsd, size_t size)
 {
 
-	if (size <= arena_maxclass)
-		return (arena_malloc(arena, size, true, try_tcache));
-	else
-		return (huge_malloc(size, true, huge_dss_prec_get(arena)));
+	return (iallocztm(tsd, size, false, tcache_get(tsd, true), false, NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-icalloc(size_t size)
+icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
 {
 
-	return (icalloct(size, true, NULL));
+	return (iallocztm(tsd, size, true, tcache, false, arena));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-ipalloct(size_t usize, size_t alignment, bool zero, bool try_tcache,
-    arena_t *arena)
+icalloc(tsd_t *tsd, size_t size)
+{
+
+	return (iallocztm(tsd, size, true, tcache_get(tsd, true), false, NULL));
+}
+
+JEMALLOC_ALWAYS_INLINE void *
+ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, bool is_metadata, arena_t *arena)
 {
 	void *ret;
 
 	assert(usize != 0);
 	assert(usize == sa2u(usize, alignment));
 
-	if (usize <= arena_maxclass && alignment <= PAGE)
-		ret = arena_malloc(arena, usize, zero, try_tcache);
-	else {
-		if (usize <= arena_maxclass) {
-			ret = arena_palloc(choose_arena(arena), usize,
-			    alignment, zero);
-		} else if (alignment <= chunksize)
-			ret = huge_malloc(usize, zero, huge_dss_prec_get(arena));
-		else
-			ret = huge_palloc(usize, alignment, zero, huge_dss_prec_get(arena));
-	}
-
+	ret = arena_palloc(tsd, arena, usize, alignment, zero, tcache);
 	assert(ALIGNMENT_ADDR2BASE(ret, alignment) == ret);
+	if (config_stats && is_metadata && likely(ret != NULL)) {
+		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
+		    config_prof));
+	}
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-ipalloc(size_t usize, size_t alignment, bool zero)
+ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, arena_t *arena)
 {
 
-	return (ipalloct(usize, alignment, zero, true, NULL));
+	return (ipallocztm(tsd, usize, alignment, zero, tcache, false, arena));
 }
 
-/*
- * Typical usage:
- *   void *ptr = [...]
- *   size_t sz = isalloc(ptr, config_prof);
- */
-JEMALLOC_ALWAYS_INLINE size_t
-isalloc(const void *ptr, bool demote)
+JEMALLOC_ALWAYS_INLINE void *
+ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero)
 {
-	size_t ret;
-	arena_chunk_t *chunk;
-
-	assert(ptr != NULL);
-	/* Demotion only makes sense if config_prof is true. */
-	assert(config_prof || demote == false);
-
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	if (chunk != ptr)
-		ret = arena_salloc(ptr, demote);
-	else
-		ret = huge_salloc(ptr);
 
-	return (ret);
+	return (ipallocztm(tsd, usize, alignment, zero, tcache_get(tsd,
+	    NULL), false, NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 ivsalloc(const void *ptr, bool demote)
 {
+	extent_node_t *node;
 
 	/* Return 0 if ptr is not within a chunk managed by jemalloc. */
-	if (rtree_get(chunks_rtree, (uintptr_t)CHUNK_ADDR2BASE(ptr)) == 0)
+	node = chunk_lookup(ptr, false);
+	if (node == NULL)
 		return (0);
+	/* Only arena chunks should be looked up via interior pointers. */
+	assert(extent_node_addr_get(node) == ptr ||
+	    extent_node_achunk_get(node));
 
 	return (isalloc(ptr, demote));
 }
 
 JEMALLOC_INLINE size_t
 u2rz(size_t usize)
 {
 	size_t ret;
 
 	if (usize <= SMALL_MAXCLASS) {
-		size_t binind = SMALL_SIZE2BIN(usize);
+		szind_t binind = size2index(usize);
 		ret = arena_bin_info[binind].redzone_size;
 	} else
 		ret = 0;
 
 	return (ret);
 }
@@ -884,144 +990,144 @@
 	size_t usize = isalloc(ptr, false);
 
 	return (u2rz(usize));
 }
 
 JEMALLOC_ALWAYS_INLINE void
-idalloct(void *ptr, bool try_tcache)
+idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata)
 {
-	arena_chunk_t *chunk;
 
 	assert(ptr != NULL);
+	if (config_stats && is_metadata) {
+		arena_metadata_allocated_sub(iaalloc(ptr), isalloc(ptr,
+		    config_prof));
+	}
 
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	if (chunk != ptr)
-		arena_dalloc(chunk->arena, chunk, ptr, try_tcache);
-	else
-		huge_dalloc(ptr, true);
+	arena_dalloc(tsd, ptr, tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-idalloc(void *ptr)
+idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache)
 {
 
-	idalloct(ptr, true);
+	idalloctm(tsd, ptr, tcache, false);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-iqalloct(void *ptr, bool try_tcache)
+idalloc(tsd_t *tsd, void *ptr)
 {
 
-	if (config_fill && opt_quarantine)
-		quarantine(ptr);
+	idalloctm(tsd, ptr, tcache_get(tsd, false), false);
+}
+
+JEMALLOC_ALWAYS_INLINE void
+iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache)
+{
+
+	if (config_fill && unlikely(opt_quarantine))
+		quarantine(tsd, ptr);
 	else
-		idalloct(ptr, try_tcache);
+		idalloctm(tsd, ptr, tcache, false);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-iqalloc(void *ptr)
+isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
 {
 
-	iqalloct(ptr, true);
+	arena_sdalloc(tsd, ptr, size, tcache);
+}
+
+JEMALLOC_ALWAYS_INLINE void
+isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
+{
+
+	if (config_fill && unlikely(opt_quarantine))
+		quarantine(tsd, ptr);
+	else
+		isdalloct(tsd, ptr, size, tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-iralloct_realign(void *ptr, size_t oldsize, size_t size, size_t extra,
-    size_t alignment, bool zero, bool try_tcache_alloc, bool try_tcache_dalloc,
-    arena_t *arena)
+iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
+    size_t extra, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena)
 {
 	void *p;
 	size_t usize, copysize;
 
 	usize = sa2u(size + extra, alignment);
 	if (usize == 0)
 		return (NULL);
-	p = ipalloct(usize, alignment, zero, try_tcache_alloc, arena);
+	p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
 	if (p == NULL) {
 		if (extra == 0)
 			return (NULL);
 		/* Try again, without extra this time. */
 		usize = sa2u(size, alignment);
 		if (usize == 0)
 			return (NULL);
-		p = ipalloct(usize, alignment, zero, try_tcache_alloc, arena);
+		p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
 		if (p == NULL)
 			return (NULL);
 	}
 	/*
 	 * Copy at most size bytes (not size+extra), since the caller has no
 	 * expectation that the extra bytes will be reliably preserved.
 	 */
 	copysize = (size < oldsize) ? size : oldsize;
 	memcpy(p, ptr, copysize);
-	iqalloct(ptr, try_tcache_dalloc);
+	isqalloc(tsd, ptr, oldsize, tcache);
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-iralloct(void *ptr, size_t size, size_t extra, size_t alignment, bool zero,
-    bool try_tcache_alloc, bool try_tcache_dalloc, arena_t *arena)
+iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
+    bool zero, tcache_t *tcache, arena_t *arena)
 {
-	size_t oldsize;
 
 	assert(ptr != NULL);
 	assert(size != 0);
 
-	oldsize = isalloc(ptr, config_prof);
-
 	if (alignment != 0 && ((uintptr_t)ptr & ((uintptr_t)alignment-1))
 	    != 0) {
 		/*
 		 * Existing object alignment is inadequate; allocate new space
 		 * and copy.
 		 */
-		return (iralloct_realign(ptr, oldsize, size, extra, alignment,
-		    zero, try_tcache_alloc, try_tcache_dalloc, arena));
+		return (iralloct_realign(tsd, ptr, oldsize, size, 0, alignment,
+		    zero, tcache, arena));
 	}
 
-	if (size + extra <= arena_maxclass) {
-		return (arena_ralloc(arena, ptr, oldsize, size, extra,
-		    alignment, zero, try_tcache_alloc,
-		    try_tcache_dalloc));
-	} else {
-		return (huge_ralloc(ptr, oldsize, size, extra,
-		    alignment, zero, try_tcache_dalloc, huge_dss_prec_get(arena)));
-	}
+	return (arena_ralloc(tsd, arena, ptr, oldsize, size, alignment, zero,
+	    tcache));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-iralloc(void *ptr, size_t size, size_t extra, size_t alignment, bool zero)
+iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
+    bool zero)
 {
 
-	return (iralloct(ptr, size, extra, alignment, zero, true, true, NULL));
+	return (iralloct(tsd, ptr, oldsize, size, alignment, zero,
+	    tcache_get(tsd, true), NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE bool
-ixalloc(void *ptr, size_t size, size_t extra, size_t alignment, bool zero)
+ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra, size_t alignment,
+    bool zero)
 {
-	size_t oldsize;
 
 	assert(ptr != NULL);
 	assert(size != 0);
 
-	oldsize = isalloc(ptr, config_prof);
 	if (alignment != 0 && ((uintptr_t)ptr & ((uintptr_t)alignment-1))
 	    != 0) {
 		/* Existing object alignment is inadequate. */
 		return (true);
 	}
 
-	if (size <= arena_maxclass)
-		return (arena_ralloc_no_move(ptr, oldsize, size, extra, zero));
-	else
-		return (huge_ralloc_no_move(ptr, oldsize, size, extra));
+	return (arena_ralloc_no_move(ptr, oldsize, size, extra, zero));
 }
-
-malloc_tsd_externs(thread_allocated, thread_allocated_t)
-malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, thread_allocated, thread_allocated_t,
-    THREAD_ALLOCATED_INITIALIZER, malloc_tsd_no_cleanup)
 #endif
 
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_INLINES
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h.in	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h.in	2016-05-06 15:11:36.000000000 +0800
@@ -1,73 +1,16 @@
 #ifndef JEMALLOC_INTERNAL_H
 #define	JEMALLOC_INTERNAL_H
-#include <math.h>
-#ifdef _WIN32
-#  include <windows.h>
-#  define ENOENT ERROR_PATH_NOT_FOUND
-#  define EINVAL ERROR_BAD_ARGUMENTS
-#  define EAGAIN ERROR_OUTOFMEMORY
-#  define EPERM  ERROR_WRITE_FAULT
-#  define EFAULT ERROR_INVALID_ADDRESS
-#  define ENOMEM ERROR_NOT_ENOUGH_MEMORY
-#  undef ERANGE
-#  define ERANGE ERROR_INVALID_DATA
-#else
-#  include <sys/param.h>
-#  include <sys/mman.h>
-#  include <sys/syscall.h>
-#  if !defined(SYS_write) && defined(__NR_write)
-#    define SYS_write __NR_write
-#  endif
-#  include <sys/uio.h>
-#  include <pthread.h>
-#  include <errno.h>
-#endif
-#include <sys/types.h>
-
-#include <limits.h>
-#ifndef SIZE_T_MAX
-#  define SIZE_T_MAX	SIZE_MAX
-#endif
-#include <stdarg.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <stddef.h>
-#ifndef offsetof
-#  define offsetof(type, member)	((size_t)&(((type *)NULL)->member))
-#endif
-#include <inttypes.h>
-#include <string.h>
-#include <strings.h>
-#include <ctype.h>
-#ifdef _MSC_VER
-#  include <io.h>
-typedef intptr_t ssize_t;
-#  define PATH_MAX 1024
-#  define STDERR_FILENO 2
-#  define __func__ __FUNCTION__
-/* Disable warnings about deprecated system functions */
-#  pragma warning(disable: 4996)
-#else
-#  include <unistd.h>
-#endif
-#include <fcntl.h>
 
 #include "jemalloc_internal_defs.h"
+#include "jemalloc/internal/jemalloc_internal_decls.h"
 
 #ifdef JEMALLOC_UTRACE
 #include <sys/ktrace.h>
 #endif
 
-#ifdef JEMALLOC_VALGRIND
-#include <valgrind/valgrind.h>
-#include <valgrind/memcheck.h>
-#endif
-
 #define	JEMALLOC_NO_DEMANGLE
 #ifdef JEMALLOC_JET
 #  define JEMALLOC_N(n) jet_##n
 #  include "jemalloc/internal/public_namespace.h"
 #  define JEMALLOC_NO_RENAME
 #  include "../jemalloc@install_suffix@.h"
@@ -82,13 +25,13 @@
 #ifdef JEMALLOC_DEBUG
     true
 #else
     false
 #endif
     ;
-static const bool config_dss =
+static const bool have_dss =
 #ifdef JEMALLOC_DSS
     true
 #else
     false
 #endif
     ;
@@ -124,14 +67,14 @@
 #ifdef JEMALLOC_PROF_LIBUNWIND
     true
 #else
     false
 #endif
     ;
-static const bool config_mremap =
-#ifdef JEMALLOC_MREMAP
+static const bool maps_coalesce =
+#ifdef JEMALLOC_MAPS_COALESCE
     true
 #else
     false
 #endif
     ;
 static const bool config_munmap =
@@ -187,12 +130,23 @@
 #ifdef JEMALLOC_IVSALLOC
     true
 #else
     false
 #endif
     ;
+static const bool config_cache_oblivious =
+#ifdef JEMALLOC_CACHE_OBLIVIOUS
+    true
+#else
+    false
+#endif
+    ;
+
+#ifdef JEMALLOC_C11ATOMICS
+#include <stdatomic.h>
+#endif
 
 #ifdef JEMALLOC_ATOMIC9
 #include <machine/atomic.h>
 #endif
 
 #if (defined(JEMALLOC_OSATOMIC) || defined(JEMALLOC_OSSPIN))
@@ -226,34 +180,62 @@
  */
 /******************************************************************************/
 #define	JEMALLOC_H_TYPES
 
 #include "jemalloc/internal/jemalloc_internal_macros.h"
 
+/* Size class index type. */
+typedef unsigned szind_t;
+
+/*
+ * Flags bits:
+ *
+ * a: arena
+ * t: tcache
+ * 0: unused
+ * z: zero
+ * n: alignment
+ *
+ * aaaaaaaa aaaatttt tttttttt 0znnnnnn
+ */
+#define	MALLOCX_ARENA_MASK	((int)~0xfffff)
+#define	MALLOCX_ARENA_MAX	0xffe
+#define	MALLOCX_TCACHE_MASK	((int)~0xfff000ffU)
+#define	MALLOCX_TCACHE_MAX	0xffd
 #define	MALLOCX_LG_ALIGN_MASK	((int)0x3f)
-#define	ALLOCM_LG_ALIGN_MASK	((int)0x3f)
+/* Use MALLOCX_ALIGN_GET() if alignment may not be specified in flags. */
+#define	MALLOCX_ALIGN_GET_SPECIFIED(flags)				\
+    (ZU(1) << (flags & MALLOCX_LG_ALIGN_MASK))
+#define	MALLOCX_ALIGN_GET(flags)					\
+    (MALLOCX_ALIGN_GET_SPECIFIED(flags) & (SIZE_T_MAX-1))
+#define	MALLOCX_ZERO_GET(flags)						\
+    ((bool)(flags & MALLOCX_ZERO))
+
+#define	MALLOCX_TCACHE_GET(flags)					\
+    (((unsigned)((flags & MALLOCX_TCACHE_MASK) >> 8)) - 2)
+#define	MALLOCX_ARENA_GET(flags)					\
+    (((unsigned)(((unsigned)flags) >> 20)) - 1)
 
 /* Smallest size class to support. */
-#define	LG_TINY_MIN		3
 #define	TINY_MIN		(1U << LG_TINY_MIN)
 
 /*
- * Minimum alignment of allocations is 2^LG_QUANTUM bytes (ignoring tiny size
+ * Minimum allocation alignment is 2^LG_QUANTUM bytes (ignoring tiny size
  * classes).
  */
 #ifndef LG_QUANTUM
 #  if (defined(__i386__) || defined(_M_IX86))
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __ia64__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __alpha__
 #    define LG_QUANTUM		4
 #  endif
-#  ifdef __sparc64__
+#  if (defined(__sparc64__) || defined(__sparcv9))
 #    define LG_QUANTUM		4
 #  endif
 #  if (defined(__amd64__) || defined(__x86_64__) || defined(_M_X64))
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __arm__
@@ -265,26 +247,33 @@
 #  ifdef __hppa__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __mips__
 #    define LG_QUANTUM		3
 #  endif
+#  ifdef __or1k__
+#    define LG_QUANTUM		3
+#  endif
 #  ifdef __powerpc__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __s390__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __SH4__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __tile__
 #    define LG_QUANTUM		4
 #  endif
+#  ifdef __le32__
+#    define LG_QUANTUM		4
+#  endif
 #  ifndef LG_QUANTUM
-#    error "No LG_QUANTUM definition for architecture; specify via CPPFLAGS"
+#    error "Unknown minimum alignment for architecture; specify via "
+	 "--with-lg-quantum"
 #  endif
 #endif
 
 #define	QUANTUM			((size_t)(1U << LG_QUANTUM))
 #define	QUANTUM_MASK		(QUANTUM - 1)
 
@@ -318,18 +307,17 @@
 #define	CACHELINE_MASK		(CACHELINE - 1)
 
 /* Return the smallest cacheline multiple that is >= s. */
 #define	CACHELINE_CEILING(s)						\
 	(((s) + CACHELINE_MASK) & ~CACHELINE_MASK)
 
-/* Page size.  STATIC_PAGE_SHIFT is determined by the configure script. */
+/* Page size.  LG_PAGE is determined by the configure script. */
 #ifdef PAGE_MASK
 #  undef PAGE_MASK
 #endif
-#define	LG_PAGE		STATIC_PAGE_SHIFT
-#define	PAGE		((size_t)(1U << STATIC_PAGE_SHIFT))
+#define	PAGE		((size_t)(1U << LG_PAGE))
 #define	PAGE_MASK	((size_t)(PAGE - 1))
 
 /* Return the smallest pagesize multiple that is >= s. */
 #define	PAGE_CEILING(s)							\
 	(((s) + PAGE_MASK) & ~PAGE_MASK)
 
@@ -342,105 +330,31 @@
 	((size_t)((uintptr_t)(a) & (alignment - 1)))
 
 /* Return the smallest alignment multiple that is >= s. */
 #define	ALIGNMENT_CEILING(s, alignment)					\
 	(((s) + (alignment - 1)) & (-(alignment)))
 
-/* Declare a variable length array */
+/* Declare a variable-length array. */
 #if __STDC_VERSION__ < 199901L
 #  ifdef _MSC_VER
 #    include <malloc.h>
 #    define alloca _alloca
 #  else
 #    ifdef JEMALLOC_HAS_ALLOCA_H
 #      include <alloca.h>
 #    else
 #      include <stdlib.h>
 #    endif
 #  endif
 #  define VARIABLE_ARRAY(type, name, count) \
-	type *name = alloca(sizeof(type) * count)
-#else
-#  define VARIABLE_ARRAY(type, name, count) type name[count]
-#endif
-
-#ifdef JEMALLOC_VALGRIND
-/*
- * The JEMALLOC_VALGRIND_*() macros must be macros rather than functions
- * so that when Valgrind reports errors, there are no extra stack frames
- * in the backtraces.
- *
- * The size that is reported to valgrind must be consistent through a chain of
- * malloc..realloc..realloc calls.  Request size isn't recorded anywhere in
- * jemalloc, so it is critical that all callers of these macros provide usize
- * rather than request size.  As a result, buffer overflow detection is
- * technically weakened for the standard API, though it is generally accepted
- * practice to consider any extra bytes reported by malloc_usable_size() as
- * usable space.
- */
-#define	JEMALLOC_VALGRIND_MALLOC(cond, ptr, usize, zero) do {		\
-	if (config_valgrind && opt_valgrind && cond)			\
-		VALGRIND_MALLOCLIKE_BLOCK(ptr, usize, p2rz(ptr), zero);	\
-} while (0)
-#define	JEMALLOC_VALGRIND_REALLOC(ptr, usize, old_ptr, old_usize,	\
-    old_rzsize, zero)  do {						\
-	if (config_valgrind && opt_valgrind) {				\
-		size_t rzsize = p2rz(ptr);				\
-									\
-		if (ptr == old_ptr) {					\
-			VALGRIND_RESIZEINPLACE_BLOCK(ptr, old_usize,	\
-			    usize, rzsize);				\
-			if (zero && old_usize < usize) {		\
-				VALGRIND_MAKE_MEM_DEFINED(		\
-				    (void *)((uintptr_t)ptr +		\
-				    old_usize), usize - old_usize);	\
-			}						\
-		} else {						\
-			if (old_ptr != NULL) {				\
-				VALGRIND_FREELIKE_BLOCK(old_ptr,	\
-				    old_rzsize);			\
-			}						\
-			if (ptr != NULL) {				\
-				size_t copy_size = (old_usize < usize)	\
-				    ?  old_usize : usize;		\
-				size_t tail_size = usize - copy_size;	\
-				VALGRIND_MALLOCLIKE_BLOCK(ptr, usize,	\
-				    rzsize, false);			\
-				if (copy_size > 0) {			\
-					VALGRIND_MAKE_MEM_DEFINED(ptr,	\
-					    copy_size);			\
-				}					\
-				if (zero && tail_size > 0) {		\
-					VALGRIND_MAKE_MEM_DEFINED(	\
-					    (void *)((uintptr_t)ptr +	\
-					    copy_size), tail_size);	\
-				}					\
-			}						\
-		}							\
-	}								\
-} while (0)
-#define	JEMALLOC_VALGRIND_FREE(ptr, rzsize) do {			\
-	if (config_valgrind && opt_valgrind)				\
-		VALGRIND_FREELIKE_BLOCK(ptr, rzsize);			\
-} while (0)
+	type *name = alloca(sizeof(type) * (count))
 #else
-#define	RUNNING_ON_VALGRIND	((unsigned)0)
-#define	VALGRIND_MALLOCLIKE_BLOCK(addr, sizeB, rzB, is_zeroed) \
-    do {} while (0)
-#define	VALGRIND_RESIZEINPLACE_BLOCK(addr, oldSizeB, newSizeB, rzB) \
-    do {} while (0)
-#define	VALGRIND_FREELIKE_BLOCK(addr, rzB) do {} while (0)
-#define	VALGRIND_MAKE_MEM_NOACCESS(_qzz_addr, _qzz_len) do {} while (0)
-#define	VALGRIND_MAKE_MEM_UNDEFINED(_qzz_addr, _qzz_len) do {} while (0)
-#define	VALGRIND_MAKE_MEM_DEFINED(_qzz_addr, _qzz_len) do {} while (0)
-#define	JEMALLOC_VALGRIND_MALLOC(cond, ptr, usize, zero) do {} while (0)
-#define	JEMALLOC_VALGRIND_REALLOC(ptr, usize, old_ptr, old_usize,	\
-    old_rzsize, zero) do {} while (0)
-#define	JEMALLOC_VALGRIND_FREE(ptr, rzsize) do {} while (0)
+#  define VARIABLE_ARRAY(type, name, count) type name[(count)]
 #endif
 
+#include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
 #include "jemalloc/internal/prng.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
 #include "jemalloc/internal/stats.h"
@@ -449,166 +363,316 @@
 #include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/arena.h"
 #include "jemalloc/internal/bitmap.h"
 #include "jemalloc/internal/base.h"
+#include "jemalloc/internal/rtree.h"
+#include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
-#include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_TYPES
 /******************************************************************************/
 #define	JEMALLOC_H_STRUCTS
 
+#include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
 #include "jemalloc/internal/prng.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
 #include "jemalloc/internal/mutex.h"
-#include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/bitmap.h"
+#define	JEMALLOC_ARENA_STRUCTS_A
+#include "jemalloc/internal/arena.h"
+#undef JEMALLOC_ARENA_STRUCTS_A
 #include "jemalloc/internal/extent.h"
+#define	JEMALLOC_ARENA_STRUCTS_B
 #include "jemalloc/internal/arena.h"
+#undef JEMALLOC_ARENA_STRUCTS_B
 #include "jemalloc/internal/base.h"
+#include "jemalloc/internal/rtree.h"
+#include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
-#include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 #include "jemalloc/internal/prof.h"
 
-typedef struct {
-	uint64_t	allocated;
-	uint64_t	deallocated;
-} thread_allocated_t;
-/*
- * The JEMALLOC_ARG_CONCAT() wrapper is necessary to pass {0, 0} via a cpp macro
- * argument.
- */
-#define	THREAD_ALLOCATED_INITIALIZER	JEMALLOC_ARG_CONCAT({0, 0})
+#include "jemalloc/internal/tsd.h"
 
 #undef JEMALLOC_H_STRUCTS
 /******************************************************************************/
 #define	JEMALLOC_H_EXTERNS
 
 extern bool	opt_abort;
-extern bool	opt_junk;
+extern const char	*opt_junk;
+extern bool	opt_junk_alloc;
+extern bool	opt_junk_free;
 extern size_t	opt_quarantine;
 extern bool	opt_redzone;
 extern bool	opt_utrace;
-extern bool	opt_valgrind;
 extern bool	opt_xmalloc;
 extern bool	opt_zero;
 extern size_t	opt_narenas;
 
+extern bool	in_valgrind;
+
 /* Number of CPUs. */
 extern unsigned		ncpus;
 
-/* Protects arenas initialization (arenas, arenas_total). */
-extern malloc_mutex_t	arenas_lock;
 /*
- * Arenas that are used to service external requests.  Not all elements of the
- * arenas array are necessarily used; arenas are created lazily as needed.
- *
- * arenas[0..narenas_auto) are used for automatic multiplexing of threads and
- * arenas.  arenas[narenas_auto..narenas_total) are only used if the application
- * takes some action to create them and allocate from them.
+ * index2size_tab encodes the same information as could be computed (at
+ * unacceptable cost in some code paths) by index2size_compute().
+ */
+extern size_t const	index2size_tab[NSIZES];
+/*
+ * size2index_tab is a compact lookup table that rounds request sizes up to
+ * size classes.  In order to reduce cache footprint, the table is compressed,
+ * and all accesses are via size2index().
  */
-extern arena_t		**arenas;
-extern unsigned		narenas_total;
-extern unsigned		narenas_auto; /* Read-only after initialization. */
+extern uint8_t const	size2index_tab[];
 
+arena_t	*a0get(void);
+void	*a0malloc(size_t size);
+void	a0dalloc(void *ptr);
+void	*bootstrap_malloc(size_t size);
+void	*bootstrap_calloc(size_t num, size_t size);
+void	bootstrap_free(void *ptr);
 arena_t	*arenas_extend(unsigned ind);
-void	arenas_cleanup(void *arg);
-arena_t	*choose_arena_hard(void);
+arena_t	*arena_init(unsigned ind);
+unsigned	narenas_total_get(void);
+arena_t	*arena_get_hard(tsd_t *tsd, unsigned ind, bool init_if_missing);
+arena_t	*arena_choose_hard(tsd_t *tsd);
+void	arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind);
+unsigned	arena_nbound(unsigned ind);
+void	thread_allocated_cleanup(tsd_t *tsd);
+void	thread_deallocated_cleanup(tsd_t *tsd);
+void	arena_cleanup(tsd_t *tsd);
+void	arenas_cache_cleanup(tsd_t *tsd);
+void	narenas_cache_cleanup(tsd_t *tsd);
+void	arenas_cache_bypass_cleanup(tsd_t *tsd);
 void	jemalloc_prefork(void);
 void	jemalloc_postfork_parent(void);
 void	jemalloc_postfork_child(void);
 
+#include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
 #include "jemalloc/internal/prng.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
 #include "jemalloc/internal/mutex.h"
-#include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/bitmap.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/arena.h"
 #include "jemalloc/internal/base.h"
+#include "jemalloc/internal/rtree.h"
+#include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
-#include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/tcache.h"
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 #include "jemalloc/internal/prof.h"
+#include "jemalloc/internal/tsd.h"
 
 #undef JEMALLOC_H_EXTERNS
 /******************************************************************************/
 #define	JEMALLOC_H_INLINES
 
+#include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
 #include "jemalloc/internal/prng.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
 #include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/base.h"
+#include "jemalloc/internal/rtree.h"
+#include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
 
 #ifndef JEMALLOC_ENABLE_INLINE
-malloc_tsd_protos(JEMALLOC_ATTR(unused), arenas, arena_t *)
-
+szind_t	size2index_compute(size_t size);
+szind_t	size2index_lookup(size_t size);
+szind_t	size2index(size_t size);
+size_t	index2size_compute(szind_t index);
+size_t	index2size_lookup(szind_t index);
+size_t	index2size(szind_t index);
+size_t	s2u_compute(size_t size);
+size_t	s2u_lookup(size_t size);
 size_t	s2u(size_t size);
 size_t	sa2u(size_t size, size_t alignment);
-unsigned	narenas_total_get(void);
-arena_t	*choose_arena(arena_t *arena);
+arena_t	*arena_choose(tsd_t *tsd, arena_t *arena);
+arena_t	*arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
+    bool refresh_if_missing);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
-/*
- * Map of pthread_self() --> arenas[???], used for selecting an arena to use
- * for allocations.
- */
-malloc_tsd_externs(arenas, arena_t *)
-malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, arenas, arena_t *, NULL,
-    arenas_cleanup)
+JEMALLOC_INLINE szind_t
+size2index_compute(size_t size)
+{
+
+#if (NTBINS != 0)
+	if (size <= (ZU(1) << LG_TINY_MAXCLASS)) {
+		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
+		size_t lg_ceil = lg_floor(pow2_ceil(size));
+		return (lg_ceil < lg_tmin ? 0 : lg_ceil - lg_tmin);
+	}
+#endif
+	{
+		size_t x = unlikely(ZI(size) < 0) ? ((size<<1) ?
+		    (ZU(1)<<(LG_SIZEOF_PTR+3)) : ((ZU(1)<<(LG_SIZEOF_PTR+3))-1))
+		    : lg_floor((size<<1)-1);
+		size_t shift = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? 0 :
+		    x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);
+		size_t grp = shift << LG_SIZE_CLASS_GROUP;
+
+		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
+		    ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
+
+		size_t delta_inverse_mask = ZI(-1) << lg_delta;
+		size_t mod = ((((size-1) & delta_inverse_mask) >> lg_delta)) &
+		    ((ZU(1) << LG_SIZE_CLASS_GROUP) - 1);
+
+		size_t index = NTBINS + grp + mod;
+		return (index);
+	}
+}
+
+JEMALLOC_ALWAYS_INLINE szind_t
+size2index_lookup(size_t size)
+{
+
+	assert(size <= LOOKUP_MAXCLASS);
+	{
+		size_t ret = ((size_t)(size2index_tab[(size-1) >>
+		    LG_TINY_MIN]));
+		assert(ret == size2index_compute(size));
+		return (ret);
+	}
+}
+
+JEMALLOC_ALWAYS_INLINE szind_t
+size2index(size_t size)
+{
+
+	assert(size > 0);
+	if (likely(size <= LOOKUP_MAXCLASS))
+		return (size2index_lookup(size));
+	return (size2index_compute(size));
+}
+
+JEMALLOC_INLINE size_t
+index2size_compute(szind_t index)
+{
+
+#if (NTBINS > 0)
+	if (index < NTBINS)
+		return (ZU(1) << (LG_TINY_MAXCLASS - NTBINS + 1 + index));
+#endif
+	{
+		size_t reduced_index = index - NTBINS;
+		size_t grp = reduced_index >> LG_SIZE_CLASS_GROUP;
+		size_t mod = reduced_index & ((ZU(1) << LG_SIZE_CLASS_GROUP) -
+		    1);
+
+		size_t grp_size_mask = ~((!!grp)-1);
+		size_t grp_size = ((ZU(1) << (LG_QUANTUM +
+		    (LG_SIZE_CLASS_GROUP-1))) << grp) & grp_size_mask;
+
+		size_t shift = (grp == 0) ? 1 : grp;
+		size_t lg_delta = shift + (LG_QUANTUM-1);
+		size_t mod_size = (mod+1) << lg_delta;
+
+		size_t usize = grp_size + mod_size;
+		return (usize);
+	}
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+index2size_lookup(szind_t index)
+{
+	size_t ret = (size_t)index2size_tab[index];
+	assert(ret == index2size_compute(index));
+	return (ret);
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+index2size(szind_t index)
+{
+
+	assert(index < NSIZES);
+	return (index2size_lookup(index));
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+s2u_compute(size_t size)
+{
+
+#if (NTBINS > 0)
+	if (size <= (ZU(1) << LG_TINY_MAXCLASS)) {
+		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
+		size_t lg_ceil = lg_floor(pow2_ceil(size));
+		return (lg_ceil < lg_tmin ? (ZU(1) << lg_tmin) :
+		    (ZU(1) << lg_ceil));
+	}
+#endif
+	{
+		size_t x = unlikely(ZI(size) < 0) ? ((size<<1) ?
+		    (ZU(1)<<(LG_SIZEOF_PTR+3)) : ((ZU(1)<<(LG_SIZEOF_PTR+3))-1))
+		    : lg_floor((size<<1)-1);
+		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
+		    ?  LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
+		size_t delta = ZU(1) << lg_delta;
+		size_t delta_mask = delta - 1;
+		size_t usize = (size + delta_mask) & ~delta_mask;
+		return (usize);
+	}
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+s2u_lookup(size_t size)
+{
+	size_t ret = index2size_lookup(size2index_lookup(size));
+
+	assert(ret == s2u_compute(size));
+	return (ret);
+}
 
 /*
  * Compute usable size that would result from allocating an object with the
  * specified size.
  */
 JEMALLOC_ALWAYS_INLINE size_t
 s2u(size_t size)
 {
 
-	if (size <= SMALL_MAXCLASS)
-		return (arena_bin_info[SMALL_SIZE2BIN(size)].reg_size);
-	if (size <= arena_maxclass)
-		return (PAGE_CEILING(size));
-	return (CHUNK_CEILING(size));
+	assert(size > 0);
+	if (likely(size <= LOOKUP_MAXCLASS))
+		return (s2u_lookup(size));
+	return (s2u_compute(size));
 }
 
 /*
  * Compute usable size that would result from allocating an object with the
  * specified size and alignment.
  */
@@ -616,264 +680,306 @@
 sa2u(size_t size, size_t alignment)
 {
 	size_t usize;
 
 	assert(alignment != 0 && ((alignment - 1) & alignment) == 0);
 
-	/*
-	 * Round size up to the nearest multiple of alignment.
-	 *
-	 * This done, we can take advantage of the fact that for each small
-	 * size class, every object is aligned at the smallest power of two
-	 * that is non-zero in the base two representation of the size.  For
-	 * example:
-	 *
-	 *   Size |   Base 2 | Minimum alignment
-	 *   -----+----------+------------------
-	 *     96 |  1100000 |  32
-	 *    144 | 10100000 |  32
-	 *    192 | 11000000 |  64
-	 */
-	usize = ALIGNMENT_CEILING(size, alignment);
-	/*
-	 * (usize < size) protects against the combination of maximal
-	 * alignment and size greater than maximal alignment.
-	 */
-	if (usize < size) {
-		/* size_t overflow. */
-		return (0);
+	/* Try for a small size class. */
+	if (size <= SMALL_MAXCLASS && alignment < PAGE) {
+		/*
+		 * Round size up to the nearest multiple of alignment.
+		 *
+		 * This done, we can take advantage of the fact that for each
+		 * small size class, every object is aligned at the smallest
+		 * power of two that is non-zero in the base two representation
+		 * of the size.  For example:
+		 *
+		 *   Size |   Base 2 | Minimum alignment
+		 *   -----+----------+------------------
+		 *     96 |  1100000 |  32
+		 *    144 | 10100000 |  32
+		 *    192 | 11000000 |  64
+		 */
+		usize = s2u(ALIGNMENT_CEILING(size, alignment));
+		if (usize < LARGE_MINCLASS)
+			return (usize);
 	}
 
-	if (usize <= arena_maxclass && alignment <= PAGE) {
-		if (usize <= SMALL_MAXCLASS)
-			return (arena_bin_info[SMALL_SIZE2BIN(usize)].reg_size);
-		return (PAGE_CEILING(usize));
-	} else {
-		size_t run_size;
-
+	/* Try for a large size class. */
+	if (likely(size <= large_maxclass) && likely(alignment < chunksize)) {
 		/*
 		 * We can't achieve subpage alignment, so round up alignment
-		 * permanently; it makes later calculations simpler.
+		 * to the minimum that can actually be supported.
 		 */
 		alignment = PAGE_CEILING(alignment);
-		usize = PAGE_CEILING(size);
-		/*
-		 * (usize < size) protects against very large sizes within
-		 * PAGE of SIZE_T_MAX.
-		 *
-		 * (usize + alignment < usize) protects against the
-		 * combination of maximal alignment and usize large enough
-		 * to cause overflow.  This is similar to the first overflow
-		 * check above, but it needs to be repeated due to the new
-		 * usize value, which may now be *equal* to maximal
-		 * alignment, whereas before we only detected overflow if the
-		 * original size was *greater* than maximal alignment.
-		 */
-		if (usize < size || usize + alignment < usize) {
-			/* size_t overflow. */
-			return (0);
-		}
+
+		/* Make sure result is a large size class. */
+		usize = (size <= LARGE_MINCLASS) ? LARGE_MINCLASS : s2u(size);
 
 		/*
 		 * Calculate the size of the over-size run that arena_palloc()
 		 * would need to allocate in order to guarantee the alignment.
-		 * If the run wouldn't fit within a chunk, round up to a huge
-		 * allocation size.
 		 */
-		run_size = usize + alignment - PAGE;
-		if (run_size <= arena_maxclass)
-			return (PAGE_CEILING(usize));
-		return (CHUNK_CEILING(usize));
+		if (usize + large_pad + alignment - PAGE <= arena_maxrun)
+			return (usize);
 	}
-}
 
-JEMALLOC_INLINE unsigned
-narenas_total_get(void)
-{
-	unsigned narenas;
+	/* Huge size class.  Beware of size_t overflow. */
+
+	/*
+	 * We can't achieve subchunk alignment, so round up alignment to the
+	 * minimum that can actually be supported.
+	 */
+	alignment = CHUNK_CEILING(alignment);
+	if (alignment == 0) {
+		/* size_t overflow. */
+		return (0);
+	}
 
-	malloc_mutex_lock(&arenas_lock);
-	narenas = narenas_total;
-	malloc_mutex_unlock(&arenas_lock);
+	/* Make sure result is a huge size class. */
+	if (size <= chunksize)
+		usize = chunksize;
+	else {
+		usize = s2u(size);
+		if (usize < size) {
+			/* size_t overflow. */
+			return (0);
+		}
+	}
 
-	return (narenas);
+	/*
+	 * Calculate the multi-chunk mapping that huge_palloc() would need in
+	 * order to guarantee the alignment.
+	 */
+	if (usize + alignment - PAGE < usize) {
+		/* size_t overflow. */
+		return (0);
+	}
+	return (usize);
 }
 
 /* Choose an arena based on a per-thread value. */
 JEMALLOC_INLINE arena_t *
-choose_arena(arena_t *arena)
+arena_choose(tsd_t *tsd, arena_t *arena)
 {
 	arena_t *ret;
 
 	if (arena != NULL)
 		return (arena);
 
-	if ((ret = *arenas_tsd_get()) == NULL) {
-		ret = choose_arena_hard();
-		assert(ret != NULL);
-	}
+	if (unlikely((ret = tsd_arena_get(tsd)) == NULL))
+		ret = arena_choose_hard(tsd);
 
 	return (ret);
 }
+
+JEMALLOC_INLINE arena_t *
+arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
+    bool refresh_if_missing)
+{
+	arena_t *arena;
+	arena_t **arenas_cache = tsd_arenas_cache_get(tsd);
+
+	/* init_if_missing requires refresh_if_missing. */
+	assert(!init_if_missing || refresh_if_missing);
+
+	if (unlikely(arenas_cache == NULL)) {
+		/* arenas_cache hasn't been initialized yet. */
+		return (arena_get_hard(tsd, ind, init_if_missing));
+	}
+	if (unlikely(ind >= tsd_narenas_cache_get(tsd))) {
+		/*
+		 * ind is invalid, cache is old (too small), or arena to be
+		 * initialized.
+		 */
+		return (refresh_if_missing ? arena_get_hard(tsd, ind,
+		    init_if_missing) : NULL);
+	}
+	arena = arenas_cache[ind];
+	if (likely(arena != NULL) || !refresh_if_missing)
+		return (arena);
+	return (arena_get_hard(tsd, ind, init_if_missing));
+}
 #endif
 
 #include "jemalloc/internal/bitmap.h"
-#include "jemalloc/internal/rtree.h"
 /*
- * Include arena.h twice in order to resolve circular dependencies with
- * tcache.h.
+ * Include portions of arena.h interleaved with tcache.h in order to resolve
+ * circular dependencies.
  */
 #define	JEMALLOC_ARENA_INLINE_A
 #include "jemalloc/internal/arena.h"
 #undef JEMALLOC_ARENA_INLINE_A
 #include "jemalloc/internal/tcache.h"
 #define	JEMALLOC_ARENA_INLINE_B
 #include "jemalloc/internal/arena.h"
 #undef JEMALLOC_ARENA_INLINE_B
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 
 #ifndef JEMALLOC_ENABLE_INLINE
-void	*imalloct(size_t size, bool try_tcache, arena_t *arena);
-void	*imalloc(size_t size);
-void	*icalloct(size_t size, bool try_tcache, arena_t *arena);
-void	*icalloc(size_t size);
-void	*ipalloct(size_t usize, size_t alignment, bool zero, bool try_tcache,
-    arena_t *arena);
-void	*ipalloc(size_t usize, size_t alignment, bool zero);
+arena_t	*iaalloc(const void *ptr);
 size_t	isalloc(const void *ptr, bool demote);
+void	*iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache,
+    bool is_metadata, arena_t *arena);
+void	*imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
+void	*imalloc(tsd_t *tsd, size_t size);
+void	*icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
+void	*icalloc(tsd_t *tsd, size_t size);
+void	*ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, bool is_metadata, arena_t *arena);
+void	*ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, arena_t *arena);
+void	*ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero);
 size_t	ivsalloc(const void *ptr, bool demote);
 size_t	u2rz(size_t usize);
 size_t	p2rz(const void *ptr);
-void	idalloct(void *ptr, bool try_tcache);
-void	idalloc(void *ptr);
-void	iqalloct(void *ptr, bool try_tcache);
-void	iqalloc(void *ptr);
-void	*iralloct_realign(void *ptr, size_t oldsize, size_t size, size_t extra,
-    size_t alignment, bool zero, bool try_tcache_alloc, bool try_tcache_dalloc,
+void	idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata);
+void	idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache);
+void	idalloc(tsd_t *tsd, void *ptr);
+void	iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache);
+void	isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
+void	isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
+void	*iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
+    size_t extra, size_t alignment, bool zero, tcache_t *tcache,
     arena_t *arena);
-void	*iralloct(void *ptr, size_t size, size_t extra, size_t alignment,
-    bool zero, bool try_tcache_alloc, bool try_tcache_dalloc, arena_t *arena);
-void	*iralloc(void *ptr, size_t size, size_t extra, size_t alignment,
-    bool zero);
-bool	ixalloc(void *ptr, size_t size, size_t extra, size_t alignment,
-    bool zero);
-malloc_tsd_protos(JEMALLOC_ATTR(unused), thread_allocated, thread_allocated_t)
+void	*iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
+    size_t alignment, bool zero, tcache_t *tcache, arena_t *arena);
+void	*iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
+    size_t alignment, bool zero);
+bool	ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra,
+    size_t alignment, bool zero);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
+JEMALLOC_ALWAYS_INLINE arena_t *
+iaalloc(const void *ptr)
+{
+
+	assert(ptr != NULL);
+
+	return (arena_aalloc(ptr));
+}
+
+/*
+ * Typical usage:
+ *   void *ptr = [...]
+ *   size_t sz = isalloc(ptr, config_prof);
+ */
+JEMALLOC_ALWAYS_INLINE size_t
+isalloc(const void *ptr, bool demote)
+{
+
+	assert(ptr != NULL);
+	/* Demotion only makes sense if config_prof is true. */
+	assert(config_prof || !demote);
+
+	return (arena_salloc(ptr, demote));
+}
+
 JEMALLOC_ALWAYS_INLINE void *
-imalloct(size_t size, bool try_tcache, arena_t *arena)
+iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache, bool is_metadata,
+    arena_t *arena)
 {
+	void *ret;
 
 	assert(size != 0);
 
-	if (size <= arena_maxclass)
-		return (arena_malloc(arena, size, false, try_tcache));
-	else
-		return (huge_malloc(size, false, huge_dss_prec_get(arena)));
+	ret = arena_malloc(tsd, arena, size, zero, tcache);
+	if (config_stats && is_metadata && likely(ret != NULL)) {
+		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
+		    config_prof));
+	}
+	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-imalloc(size_t size)
+imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
 {
 
-	return (imalloct(size, true, NULL));
+	return (iallocztm(tsd, size, false, tcache, false, arena));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-icalloct(size_t size, bool try_tcache, arena_t *arena)
+imalloc(tsd_t *tsd, size_t size)
 {
 
-	if (size <= arena_maxclass)
-		return (arena_malloc(arena, size, true, try_tcache));
-	else
-		return (huge_malloc(size, true, huge_dss_prec_get(arena)));
+	return (iallocztm(tsd, size, false, tcache_get(tsd, true), false, NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-icalloc(size_t size)
+icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
 {
 
-	return (icalloct(size, true, NULL));
+	return (iallocztm(tsd, size, true, tcache, false, arena));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-ipalloct(size_t usize, size_t alignment, bool zero, bool try_tcache,
-    arena_t *arena)
+icalloc(tsd_t *tsd, size_t size)
+{
+
+	return (iallocztm(tsd, size, true, tcache_get(tsd, true), false, NULL));
+}
+
+JEMALLOC_ALWAYS_INLINE void *
+ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, bool is_metadata, arena_t *arena)
 {
 	void *ret;
 
 	assert(usize != 0);
 	assert(usize == sa2u(usize, alignment));
 
-	if (usize <= arena_maxclass && alignment <= PAGE)
-		ret = arena_malloc(arena, usize, zero, try_tcache);
-	else {
-		if (usize <= arena_maxclass) {
-			ret = arena_palloc(choose_arena(arena), usize,
-			    alignment, zero);
-		} else if (alignment <= chunksize)
-			ret = huge_malloc(usize, zero, huge_dss_prec_get(arena));
-		else
-			ret = huge_palloc(usize, alignment, zero, huge_dss_prec_get(arena));
-	}
-
+	ret = arena_palloc(tsd, arena, usize, alignment, zero, tcache);
 	assert(ALIGNMENT_ADDR2BASE(ret, alignment) == ret);
+	if (config_stats && is_metadata && likely(ret != NULL)) {
+		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
+		    config_prof));
+	}
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-ipalloc(size_t usize, size_t alignment, bool zero)
+ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, arena_t *arena)
 {
 
-	return (ipalloct(usize, alignment, zero, true, NULL));
+	return (ipallocztm(tsd, usize, alignment, zero, tcache, false, arena));
 }
 
-/*
- * Typical usage:
- *   void *ptr = [...]
- *   size_t sz = isalloc(ptr, config_prof);
- */
-JEMALLOC_ALWAYS_INLINE size_t
-isalloc(const void *ptr, bool demote)
+JEMALLOC_ALWAYS_INLINE void *
+ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero)
 {
-	size_t ret;
-	arena_chunk_t *chunk;
-
-	assert(ptr != NULL);
-	/* Demotion only makes sense if config_prof is true. */
-	assert(config_prof || demote == false);
-
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	if (chunk != ptr)
-		ret = arena_salloc(ptr, demote);
-	else
-		ret = huge_salloc(ptr);
 
-	return (ret);
+	return (ipallocztm(tsd, usize, alignment, zero, tcache_get(tsd,
+	    NULL), false, NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 ivsalloc(const void *ptr, bool demote)
 {
+	extent_node_t *node;
 
 	/* Return 0 if ptr is not within a chunk managed by jemalloc. */
-	if (rtree_get(chunks_rtree, (uintptr_t)CHUNK_ADDR2BASE(ptr)) == 0)
+	node = chunk_lookup(ptr, false);
+	if (node == NULL)
 		return (0);
+	/* Only arena chunks should be looked up via interior pointers. */
+	assert(extent_node_addr_get(node) == ptr ||
+	    extent_node_achunk_get(node));
 
 	return (isalloc(ptr, demote));
 }
 
 JEMALLOC_INLINE size_t
 u2rz(size_t usize)
 {
 	size_t ret;
 
 	if (usize <= SMALL_MAXCLASS) {
-		size_t binind = SMALL_SIZE2BIN(usize);
+		szind_t binind = size2index(usize);
 		ret = arena_bin_info[binind].redzone_size;
 	} else
 		ret = 0;
 
 	return (ret);
 }
@@ -884,144 +990,144 @@
 	size_t usize = isalloc(ptr, false);
 
 	return (u2rz(usize));
 }
 
 JEMALLOC_ALWAYS_INLINE void
-idalloct(void *ptr, bool try_tcache)
+idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata)
 {
-	arena_chunk_t *chunk;
 
 	assert(ptr != NULL);
+	if (config_stats && is_metadata) {
+		arena_metadata_allocated_sub(iaalloc(ptr), isalloc(ptr,
+		    config_prof));
+	}
 
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	if (chunk != ptr)
-		arena_dalloc(chunk->arena, chunk, ptr, try_tcache);
-	else
-		huge_dalloc(ptr, true);
+	arena_dalloc(tsd, ptr, tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-idalloc(void *ptr)
+idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache)
 {
 
-	idalloct(ptr, true);
+	idalloctm(tsd, ptr, tcache, false);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-iqalloct(void *ptr, bool try_tcache)
+idalloc(tsd_t *tsd, void *ptr)
 {
 
-	if (config_fill && opt_quarantine)
-		quarantine(ptr);
+	idalloctm(tsd, ptr, tcache_get(tsd, false), false);
+}
+
+JEMALLOC_ALWAYS_INLINE void
+iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache)
+{
+
+	if (config_fill && unlikely(opt_quarantine))
+		quarantine(tsd, ptr);
 	else
-		idalloct(ptr, try_tcache);
+		idalloctm(tsd, ptr, tcache, false);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-iqalloc(void *ptr)
+isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
 {
 
-	iqalloct(ptr, true);
+	arena_sdalloc(tsd, ptr, size, tcache);
+}
+
+JEMALLOC_ALWAYS_INLINE void
+isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
+{
+
+	if (config_fill && unlikely(opt_quarantine))
+		quarantine(tsd, ptr);
+	else
+		isdalloct(tsd, ptr, size, tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-iralloct_realign(void *ptr, size_t oldsize, size_t size, size_t extra,
-    size_t alignment, bool zero, bool try_tcache_alloc, bool try_tcache_dalloc,
-    arena_t *arena)
+iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
+    size_t extra, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena)
 {
 	void *p;
 	size_t usize, copysize;
 
 	usize = sa2u(size + extra, alignment);
 	if (usize == 0)
 		return (NULL);
-	p = ipalloct(usize, alignment, zero, try_tcache_alloc, arena);
+	p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
 	if (p == NULL) {
 		if (extra == 0)
 			return (NULL);
 		/* Try again, without extra this time. */
 		usize = sa2u(size, alignment);
 		if (usize == 0)
 			return (NULL);
-		p = ipalloct(usize, alignment, zero, try_tcache_alloc, arena);
+		p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
 		if (p == NULL)
 			return (NULL);
 	}
 	/*
 	 * Copy at most size bytes (not size+extra), since the caller has no
 	 * expectation that the extra bytes will be reliably preserved.
 	 */
 	copysize = (size < oldsize) ? size : oldsize;
 	memcpy(p, ptr, copysize);
-	iqalloct(ptr, try_tcache_dalloc);
+	isqalloc(tsd, ptr, oldsize, tcache);
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-iralloct(void *ptr, size_t size, size_t extra, size_t alignment, bool zero,
-    bool try_tcache_alloc, bool try_tcache_dalloc, arena_t *arena)
+iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
+    bool zero, tcache_t *tcache, arena_t *arena)
 {
-	size_t oldsize;
 
 	assert(ptr != NULL);
 	assert(size != 0);
 
-	oldsize = isalloc(ptr, config_prof);
-
 	if (alignment != 0 && ((uintptr_t)ptr & ((uintptr_t)alignment-1))
 	    != 0) {
 		/*
 		 * Existing object alignment is inadequate; allocate new space
 		 * and copy.
 		 */
-		return (iralloct_realign(ptr, oldsize, size, extra, alignment,
-		    zero, try_tcache_alloc, try_tcache_dalloc, arena));
+		return (iralloct_realign(tsd, ptr, oldsize, size, 0, alignment,
+		    zero, tcache, arena));
 	}
 
-	if (size + extra <= arena_maxclass) {
-		return (arena_ralloc(arena, ptr, oldsize, size, extra,
-		    alignment, zero, try_tcache_alloc,
-		    try_tcache_dalloc));
-	} else {
-		return (huge_ralloc(ptr, oldsize, size, extra,
-		    alignment, zero, try_tcache_dalloc, huge_dss_prec_get(arena)));
-	}
+	return (arena_ralloc(tsd, arena, ptr, oldsize, size, alignment, zero,
+	    tcache));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-iralloc(void *ptr, size_t size, size_t extra, size_t alignment, bool zero)
+iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
+    bool zero)
 {
 
-	return (iralloct(ptr, size, extra, alignment, zero, true, true, NULL));
+	return (iralloct(tsd, ptr, oldsize, size, alignment, zero,
+	    tcache_get(tsd, true), NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE bool
-ixalloc(void *ptr, size_t size, size_t extra, size_t alignment, bool zero)
+ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra, size_t alignment,
+    bool zero)
 {
-	size_t oldsize;
 
 	assert(ptr != NULL);
 	assert(size != 0);
 
-	oldsize = isalloc(ptr, config_prof);
 	if (alignment != 0 && ((uintptr_t)ptr & ((uintptr_t)alignment-1))
 	    != 0) {
 		/* Existing object alignment is inadequate. */
 		return (true);
 	}
 
-	if (size <= arena_maxclass)
-		return (arena_ralloc_no_move(ptr, oldsize, size, extra, zero));
-	else
-		return (huge_ralloc_no_move(ptr, oldsize, size, extra));
+	return (arena_ralloc_no_move(ptr, oldsize, size, extra, zero));
 }
-
-malloc_tsd_externs(thread_allocated, thread_allocated_t)
-malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, thread_allocated, thread_allocated_t,
-    THREAD_ALLOCATED_INITIALIZER, malloc_tsd_no_cleanup)
 #endif
 
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_INLINES
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_macros.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_macros.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_macros.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_macros.h	2016-05-06 15:11:36.000000000 +0800
@@ -36,15 +36,21 @@
 #  define UNUSED JEMALLOC_ATTR(unused)
 #else
 #  define UNUSED
 #endif
 
 #define	ZU(z)	((size_t)z)
+#define	ZI(z)	((ssize_t)z)
 #define	QU(q)	((uint64_t)q)
 #define	QI(q)	((int64_t)q)
 
+#define	KZU(z)	ZU(z##ULL)
+#define	KZI(z)	ZI(z##LL)
+#define	KQU(q)	QU(q##ULL)
+#define	KQI(q)	QI(q##LL)
+
 #ifndef __DECONST
 #  define	__DECONST(type, var)	((type)(uintptr_t)(const void *)(var))
 #endif
 
 #ifndef JEMALLOC_HAS_RESTRICT
 #  define restrict
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/mutex.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/mutex.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/mutex.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/mutex.h	2016-05-06 15:11:36.000000000 +0800
@@ -7,13 +7,13 @@
 #  define MALLOC_MUTEX_INITIALIZER
 #elif (defined(JEMALLOC_OSSPIN))
 #  define MALLOC_MUTEX_INITIALIZER {0}
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 #  define MALLOC_MUTEX_INITIALIZER {PTHREAD_MUTEX_INITIALIZER, NULL}
 #else
-#  if (defined(PTHREAD_MUTEX_ADAPTIVE_NP) &&				\
+#  if (defined(JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP) &&		\
        defined(PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP))
 #    define MALLOC_MUTEX_TYPE PTHREAD_MUTEX_ADAPTIVE_NP
 #    define MALLOC_MUTEX_INITIALIZER {PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP}
 #  else
 #    define MALLOC_MUTEX_TYPE PTHREAD_MUTEX_DEFAULT
 #    define MALLOC_MUTEX_INITIALIZER {PTHREAD_MUTEX_INITIALIZER}
@@ -23,13 +23,17 @@
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
 
 struct malloc_mutex_s {
 #ifdef _WIN32
+#  if _WIN32_WINNT >= 0x0600
+	SRWLOCK         	lock;
+#  else
 	CRITICAL_SECTION	lock;
+#  endif
 #elif (defined(JEMALLOC_OSSPIN))
 	OSSpinLock		lock;
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 	pthread_mutex_t		lock;
 	malloc_mutex_t		*postponed_next;
 #else
@@ -67,13 +71,17 @@
 JEMALLOC_INLINE void
 malloc_mutex_lock(malloc_mutex_t *mutex)
 {
 
 	if (isthreaded) {
 #ifdef _WIN32
+#  if _WIN32_WINNT >= 0x0600
+		AcquireSRWLockExclusive(&mutex->lock);
+#  else
 		EnterCriticalSection(&mutex->lock);
+#  endif
 #elif (defined(JEMALLOC_OSSPIN))
 		OSSpinLockLock(&mutex->lock);
 #else
 		pthread_mutex_lock(&mutex->lock);
 #endif
 	}
@@ -82,13 +90,17 @@
 JEMALLOC_INLINE void
 malloc_mutex_unlock(malloc_mutex_t *mutex)
 {
 
 	if (isthreaded) {
 #ifdef _WIN32
+#  if _WIN32_WINNT >= 0x0600
+		ReleaseSRWLockExclusive(&mutex->lock);
+#  else
 		LeaveCriticalSection(&mutex->lock);
+#  endif
 #elif (defined(JEMALLOC_OSSPIN))
 		OSSpinLockUnlock(&mutex->lock);
 #else
 		pthread_mutex_unlock(&mutex->lock);
 #endif
 	}
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal: pages.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/private_namespace.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/private_namespace.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/private_namespace.h	2017-09-27 22:47:53.342963470 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/private_namespace.h	2017-09-27 22:49:15.146960472 +0800
@@ -1,158 +1,209 @@
-#define	a0calloc JEMALLOC_N(a0calloc)
-#define	a0free JEMALLOC_N(a0free)
+#define	a0dalloc JEMALLOC_N(a0dalloc)
+#define	a0get JEMALLOC_N(a0get)
 #define	a0malloc JEMALLOC_N(a0malloc)
+#define	arena_aalloc JEMALLOC_N(arena_aalloc)
 #define	arena_alloc_junk_small JEMALLOC_N(arena_alloc_junk_small)
 #define	arena_bin_index JEMALLOC_N(arena_bin_index)
 #define	arena_bin_info JEMALLOC_N(arena_bin_info)
+#define	arena_bitselm_get JEMALLOC_N(arena_bitselm_get)
 #define	arena_boot JEMALLOC_N(arena_boot)
+#define	arena_choose JEMALLOC_N(arena_choose)
+#define	arena_choose_hard JEMALLOC_N(arena_choose_hard)
+#define	arena_chunk_alloc_huge JEMALLOC_N(arena_chunk_alloc_huge)
+#define	arena_chunk_cache_maybe_insert JEMALLOC_N(arena_chunk_cache_maybe_insert)
+#define	arena_chunk_cache_maybe_remove JEMALLOC_N(arena_chunk_cache_maybe_remove)
+#define	arena_chunk_dalloc_huge JEMALLOC_N(arena_chunk_dalloc_huge)
+#define	arena_chunk_ralloc_huge_expand JEMALLOC_N(arena_chunk_ralloc_huge_expand)
+#define	arena_chunk_ralloc_huge_shrink JEMALLOC_N(arena_chunk_ralloc_huge_shrink)
+#define	arena_chunk_ralloc_huge_similar JEMALLOC_N(arena_chunk_ralloc_huge_similar)
+#define	arena_cleanup JEMALLOC_N(arena_cleanup)
 #define	arena_dalloc JEMALLOC_N(arena_dalloc)
 #define	arena_dalloc_bin JEMALLOC_N(arena_dalloc_bin)
-#define	arena_dalloc_bin_locked JEMALLOC_N(arena_dalloc_bin_locked)
+#define	arena_dalloc_bin_junked_locked JEMALLOC_N(arena_dalloc_bin_junked_locked)
 #define	arena_dalloc_junk_large JEMALLOC_N(arena_dalloc_junk_large)
 #define	arena_dalloc_junk_small JEMALLOC_N(arena_dalloc_junk_small)
 #define	arena_dalloc_large JEMALLOC_N(arena_dalloc_large)
-#define	arena_dalloc_large_locked JEMALLOC_N(arena_dalloc_large_locked)
+#define	arena_dalloc_large_junked_locked JEMALLOC_N(arena_dalloc_large_junked_locked)
 #define	arena_dalloc_small JEMALLOC_N(arena_dalloc_small)
 #define	arena_dss_prec_get JEMALLOC_N(arena_dss_prec_get)
 #define	arena_dss_prec_set JEMALLOC_N(arena_dss_prec_set)
+#define	arena_get JEMALLOC_N(arena_get)
+#define	arena_get_hard JEMALLOC_N(arena_get_hard)
+#define	arena_init JEMALLOC_N(arena_init)
+#define	arena_lg_dirty_mult_default_get JEMALLOC_N(arena_lg_dirty_mult_default_get)
+#define	arena_lg_dirty_mult_default_set JEMALLOC_N(arena_lg_dirty_mult_default_set)
+#define	arena_lg_dirty_mult_get JEMALLOC_N(arena_lg_dirty_mult_get)
+#define	arena_lg_dirty_mult_set JEMALLOC_N(arena_lg_dirty_mult_set)
 #define	arena_malloc JEMALLOC_N(arena_malloc)
 #define	arena_malloc_large JEMALLOC_N(arena_malloc_large)
 #define	arena_malloc_small JEMALLOC_N(arena_malloc_small)
 #define	arena_mapbits_allocated_get JEMALLOC_N(arena_mapbits_allocated_get)
 #define	arena_mapbits_binind_get JEMALLOC_N(arena_mapbits_binind_get)
+#define	arena_mapbits_decommitted_get JEMALLOC_N(arena_mapbits_decommitted_get)
 #define	arena_mapbits_dirty_get JEMALLOC_N(arena_mapbits_dirty_get)
 #define	arena_mapbits_get JEMALLOC_N(arena_mapbits_get)
+#define	arena_mapbits_internal_set JEMALLOC_N(arena_mapbits_internal_set)
 #define	arena_mapbits_large_binind_set JEMALLOC_N(arena_mapbits_large_binind_set)
 #define	arena_mapbits_large_get JEMALLOC_N(arena_mapbits_large_get)
 #define	arena_mapbits_large_set JEMALLOC_N(arena_mapbits_large_set)
 #define	arena_mapbits_large_size_get JEMALLOC_N(arena_mapbits_large_size_get)
+#define	arena_mapbitsp_get JEMALLOC_N(arena_mapbitsp_get)
+#define	arena_mapbitsp_read JEMALLOC_N(arena_mapbitsp_read)
+#define	arena_mapbitsp_write JEMALLOC_N(arena_mapbitsp_write)
+#define	arena_mapbits_size_decode JEMALLOC_N(arena_mapbits_size_decode)
+#define	arena_mapbits_size_encode JEMALLOC_N(arena_mapbits_size_encode)
 #define	arena_mapbits_small_runind_get JEMALLOC_N(arena_mapbits_small_runind_get)
 #define	arena_mapbits_small_set JEMALLOC_N(arena_mapbits_small_set)
 #define	arena_mapbits_unallocated_set JEMALLOC_N(arena_mapbits_unallocated_set)
 #define	arena_mapbits_unallocated_size_get JEMALLOC_N(arena_mapbits_unallocated_size_get)
 #define	arena_mapbits_unallocated_size_set JEMALLOC_N(arena_mapbits_unallocated_size_set)
 #define	arena_mapbits_unzeroed_get JEMALLOC_N(arena_mapbits_unzeroed_get)
-#define	arena_mapbits_unzeroed_set JEMALLOC_N(arena_mapbits_unzeroed_set)
-#define	arena_mapbitsp_get JEMALLOC_N(arena_mapbitsp_get)
-#define	arena_mapbitsp_read JEMALLOC_N(arena_mapbitsp_read)
-#define	arena_mapbitsp_write JEMALLOC_N(arena_mapbitsp_write)
-#define	arena_mapp_get JEMALLOC_N(arena_mapp_get)
-#define	arena_maxclass JEMALLOC_N(arena_maxclass)
+#define	arena_maxrun JEMALLOC_N(arena_maxrun)
+#define	arena_maybe_purge JEMALLOC_N(arena_maybe_purge)
+#define	arena_metadata_allocated_add JEMALLOC_N(arena_metadata_allocated_add)
+#define	arena_metadata_allocated_get JEMALLOC_N(arena_metadata_allocated_get)
+#define	arena_metadata_allocated_sub JEMALLOC_N(arena_metadata_allocated_sub)
+#define	arena_migrate JEMALLOC_N(arena_migrate)
+#define	arena_miscelm_get JEMALLOC_N(arena_miscelm_get)
+#define	arena_miscelm_to_pageind JEMALLOC_N(arena_miscelm_to_pageind)
+#define	arena_miscelm_to_rpages JEMALLOC_N(arena_miscelm_to_rpages)
+#define	arena_nbound JEMALLOC_N(arena_nbound)
 #define	arena_new JEMALLOC_N(arena_new)
+#define	arena_node_alloc JEMALLOC_N(arena_node_alloc)
+#define	arena_node_dalloc JEMALLOC_N(arena_node_dalloc)
 #define	arena_palloc JEMALLOC_N(arena_palloc)
 #define	arena_postfork_child JEMALLOC_N(arena_postfork_child)
 #define	arena_postfork_parent JEMALLOC_N(arena_postfork_parent)
 #define	arena_prefork JEMALLOC_N(arena_prefork)
 #define	arena_prof_accum JEMALLOC_N(arena_prof_accum)
 #define	arena_prof_accum_impl JEMALLOC_N(arena_prof_accum_impl)
 #define	arena_prof_accum_locked JEMALLOC_N(arena_prof_accum_locked)
-#define	arena_prof_ctx_get JEMALLOC_N(arena_prof_ctx_get)
-#define	arena_prof_ctx_set JEMALLOC_N(arena_prof_ctx_set)
 #define	arena_prof_promoted JEMALLOC_N(arena_prof_promoted)
+#define	arena_prof_tctx_get JEMALLOC_N(arena_prof_tctx_get)
+#define	arena_prof_tctx_reset JEMALLOC_N(arena_prof_tctx_reset)
+#define	arena_prof_tctx_set JEMALLOC_N(arena_prof_tctx_set)
 #define	arena_ptr_small_binind_get JEMALLOC_N(arena_ptr_small_binind_get)
 #define	arena_purge_all JEMALLOC_N(arena_purge_all)
 #define	arena_quarantine_junk_small JEMALLOC_N(arena_quarantine_junk_small)
 #define	arena_ralloc JEMALLOC_N(arena_ralloc)
 #define	arena_ralloc_junk_large JEMALLOC_N(arena_ralloc_junk_large)
 #define	arena_ralloc_no_move JEMALLOC_N(arena_ralloc_no_move)
+#define	arena_rd_to_miscelm JEMALLOC_N(arena_rd_to_miscelm)
 #define	arena_redzone_corruption JEMALLOC_N(arena_redzone_corruption)
 #define	arena_run_regind JEMALLOC_N(arena_run_regind)
+#define	arena_run_to_miscelm JEMALLOC_N(arena_run_to_miscelm)
 #define	arena_salloc JEMALLOC_N(arena_salloc)
+#define	arenas_cache_bypass_cleanup JEMALLOC_N(arenas_cache_bypass_cleanup)
+#define	arenas_cache_cleanup JEMALLOC_N(arenas_cache_cleanup)
+#define	arena_sdalloc JEMALLOC_N(arena_sdalloc)
 #define	arena_stats_merge JEMALLOC_N(arena_stats_merge)
 #define	arena_tcache_fill_small JEMALLOC_N(arena_tcache_fill_small)
-#define	arenas JEMALLOC_N(arenas)
-#define	arenas_booted JEMALLOC_N(arenas_booted)
-#define	arenas_cleanup JEMALLOC_N(arenas_cleanup)
-#define	arenas_extend JEMALLOC_N(arenas_extend)
-#define	arenas_initialized JEMALLOC_N(arenas_initialized)
-#define	arenas_lock JEMALLOC_N(arenas_lock)
-#define	arenas_tls JEMALLOC_N(arenas_tls)
-#define	arenas_tsd JEMALLOC_N(arenas_tsd)
-#define	arenas_tsd_boot JEMALLOC_N(arenas_tsd_boot)
-#define	arenas_tsd_cleanup_wrapper JEMALLOC_N(arenas_tsd_cleanup_wrapper)
-#define	arenas_tsd_get JEMALLOC_N(arenas_tsd_get)
-#define	arenas_tsd_get_wrapper JEMALLOC_N(arenas_tsd_get_wrapper)
-#define	arenas_tsd_init_head JEMALLOC_N(arenas_tsd_init_head)
-#define	arenas_tsd_set JEMALLOC_N(arenas_tsd_set)
+#define	atomic_add_p JEMALLOC_N(atomic_add_p)
 #define	atomic_add_u JEMALLOC_N(atomic_add_u)
 #define	atomic_add_uint32 JEMALLOC_N(atomic_add_uint32)
 #define	atomic_add_uint64 JEMALLOC_N(atomic_add_uint64)
 #define	atomic_add_z JEMALLOC_N(atomic_add_z)
+#define	atomic_cas_p JEMALLOC_N(atomic_cas_p)
+#define	atomic_cas_u JEMALLOC_N(atomic_cas_u)
+#define	atomic_cas_uint32 JEMALLOC_N(atomic_cas_uint32)
+#define	atomic_cas_uint64 JEMALLOC_N(atomic_cas_uint64)
+#define	atomic_cas_z JEMALLOC_N(atomic_cas_z)
+#define	atomic_sub_p JEMALLOC_N(atomic_sub_p)
 #define	atomic_sub_u JEMALLOC_N(atomic_sub_u)
 #define	atomic_sub_uint32 JEMALLOC_N(atomic_sub_uint32)
 #define	atomic_sub_uint64 JEMALLOC_N(atomic_sub_uint64)
 #define	atomic_sub_z JEMALLOC_N(atomic_sub_z)
 #define	base_alloc JEMALLOC_N(base_alloc)
 #define	base_boot JEMALLOC_N(base_boot)
-#define	base_calloc JEMALLOC_N(base_calloc)
-#define	base_node_alloc JEMALLOC_N(base_node_alloc)
-#define	base_node_dealloc JEMALLOC_N(base_node_dealloc)
 #define	base_postfork_child JEMALLOC_N(base_postfork_child)
 #define	base_postfork_parent JEMALLOC_N(base_postfork_parent)
 #define	base_prefork JEMALLOC_N(base_prefork)
+#define	base_stats_get JEMALLOC_N(base_stats_get)
 #define	bitmap_full JEMALLOC_N(bitmap_full)
 #define	bitmap_get JEMALLOC_N(bitmap_get)
 #define	bitmap_info_init JEMALLOC_N(bitmap_info_init)
 #define	bitmap_info_ngroups JEMALLOC_N(bitmap_info_ngroups)
 #define	bitmap_init JEMALLOC_N(bitmap_init)
 #define	bitmap_set JEMALLOC_N(bitmap_set)
 #define	bitmap_sfu JEMALLOC_N(bitmap_sfu)
 #define	bitmap_size JEMALLOC_N(bitmap_size)
 #define	bitmap_unset JEMALLOC_N(bitmap_unset)
+#define	bootstrap_calloc JEMALLOC_N(bootstrap_calloc)
+#define	bootstrap_free JEMALLOC_N(bootstrap_free)
+#define	bootstrap_malloc JEMALLOC_N(bootstrap_malloc)
 #define	bt_init JEMALLOC_N(bt_init)
 #define	buferror JEMALLOC_N(buferror)
-#define	choose_arena JEMALLOC_N(choose_arena)
-#define	choose_arena_hard JEMALLOC_N(choose_arena_hard)
-#define	chunk_alloc JEMALLOC_N(chunk_alloc)
+#define	chunk_alloc_base JEMALLOC_N(chunk_alloc_base)
+#define	chunk_alloc_cache JEMALLOC_N(chunk_alloc_cache)
 #define	chunk_alloc_dss JEMALLOC_N(chunk_alloc_dss)
 #define	chunk_alloc_mmap JEMALLOC_N(chunk_alloc_mmap)
+#define	chunk_alloc_wrapper JEMALLOC_N(chunk_alloc_wrapper)
 #define	chunk_boot JEMALLOC_N(chunk_boot)
-#define	chunk_dealloc JEMALLOC_N(chunk_dealloc)
-#define	chunk_dealloc_mmap JEMALLOC_N(chunk_dealloc_mmap)
+#define	chunk_dalloc_arena JEMALLOC_N(chunk_dalloc_arena)
+#define	chunk_dalloc_cache JEMALLOC_N(chunk_dalloc_cache)
+#define	chunk_dalloc_mmap JEMALLOC_N(chunk_dalloc_mmap)
+#define	chunk_dalloc_wrapper JEMALLOC_N(chunk_dalloc_wrapper)
+#define	chunk_deregister JEMALLOC_N(chunk_deregister)
 #define	chunk_dss_boot JEMALLOC_N(chunk_dss_boot)
 #define	chunk_dss_postfork_child JEMALLOC_N(chunk_dss_postfork_child)
 #define	chunk_dss_postfork_parent JEMALLOC_N(chunk_dss_postfork_parent)
 #define	chunk_dss_prec_get JEMALLOC_N(chunk_dss_prec_get)
 #define	chunk_dss_prec_set JEMALLOC_N(chunk_dss_prec_set)
 #define	chunk_dss_prefork JEMALLOC_N(chunk_dss_prefork)
+#define	chunk_hooks_default JEMALLOC_N(chunk_hooks_default)
+#define	chunk_hooks_get JEMALLOC_N(chunk_hooks_get)
+#define	chunk_hooks_set JEMALLOC_N(chunk_hooks_set)
 #define	chunk_in_dss JEMALLOC_N(chunk_in_dss)
+#define	chunk_lookup JEMALLOC_N(chunk_lookup)
 #define	chunk_npages JEMALLOC_N(chunk_npages)
 #define	chunk_postfork_child JEMALLOC_N(chunk_postfork_child)
 #define	chunk_postfork_parent JEMALLOC_N(chunk_postfork_parent)
 #define	chunk_prefork JEMALLOC_N(chunk_prefork)
-#define	chunk_unmap JEMALLOC_N(chunk_unmap)
-#define	chunks_mtx JEMALLOC_N(chunks_mtx)
-#define	chunks_rtree JEMALLOC_N(chunks_rtree)
+#define	chunk_purge_arena JEMALLOC_N(chunk_purge_arena)
+#define	chunk_purge_wrapper JEMALLOC_N(chunk_purge_wrapper)
+#define	chunk_register JEMALLOC_N(chunk_register)
 #define	chunksize JEMALLOC_N(chunksize)
 #define	chunksize_mask JEMALLOC_N(chunksize_mask)
-#define	ckh_bucket_search JEMALLOC_N(ckh_bucket_search)
+#define	chunks_rtree JEMALLOC_N(chunks_rtree)
 #define	ckh_count JEMALLOC_N(ckh_count)
 #define	ckh_delete JEMALLOC_N(ckh_delete)
-#define	ckh_evict_reloc_insert JEMALLOC_N(ckh_evict_reloc_insert)
 #define	ckh_insert JEMALLOC_N(ckh_insert)
-#define	ckh_isearch JEMALLOC_N(ckh_isearch)
 #define	ckh_iter JEMALLOC_N(ckh_iter)
 #define	ckh_new JEMALLOC_N(ckh_new)
 #define	ckh_pointer_hash JEMALLOC_N(ckh_pointer_hash)
 #define	ckh_pointer_keycomp JEMALLOC_N(ckh_pointer_keycomp)
-#define	ckh_rebuild JEMALLOC_N(ckh_rebuild)
 #define	ckh_remove JEMALLOC_N(ckh_remove)
 #define	ckh_search JEMALLOC_N(ckh_search)
 #define	ckh_string_hash JEMALLOC_N(ckh_string_hash)
 #define	ckh_string_keycomp JEMALLOC_N(ckh_string_keycomp)
-#define	ckh_try_bucket_insert JEMALLOC_N(ckh_try_bucket_insert)
-#define	ckh_try_insert JEMALLOC_N(ckh_try_insert)
 #define	ctl_boot JEMALLOC_N(ctl_boot)
 #define	ctl_bymib JEMALLOC_N(ctl_bymib)
 #define	ctl_byname JEMALLOC_N(ctl_byname)
 #define	ctl_nametomib JEMALLOC_N(ctl_nametomib)
 #define	ctl_postfork_child JEMALLOC_N(ctl_postfork_child)
 #define	ctl_postfork_parent JEMALLOC_N(ctl_postfork_parent)
 #define	ctl_prefork JEMALLOC_N(ctl_prefork)
 #define	dss_prec_names JEMALLOC_N(dss_prec_names)
+#define	extent_node_achunk_get JEMALLOC_N(extent_node_achunk_get)
+#define	extent_node_achunk_set JEMALLOC_N(extent_node_achunk_set)
+#define	extent_node_addr_get JEMALLOC_N(extent_node_addr_get)
+#define	extent_node_addr_set JEMALLOC_N(extent_node_addr_set)
+#define	extent_node_arena_get JEMALLOC_N(extent_node_arena_get)
+#define	extent_node_arena_set JEMALLOC_N(extent_node_arena_set)
+#define	extent_node_dirty_insert JEMALLOC_N(extent_node_dirty_insert)
+#define	extent_node_dirty_linkage_init JEMALLOC_N(extent_node_dirty_linkage_init)
+#define	extent_node_dirty_remove JEMALLOC_N(extent_node_dirty_remove)
+#define	extent_node_init JEMALLOC_N(extent_node_init)
+#define	extent_node_prof_tctx_get JEMALLOC_N(extent_node_prof_tctx_get)
+#define	extent_node_prof_tctx_set JEMALLOC_N(extent_node_prof_tctx_set)
+#define	extent_node_size_get JEMALLOC_N(extent_node_size_get)
+#define	extent_node_size_set JEMALLOC_N(extent_node_size_set)
+#define	extent_node_zeroed_get JEMALLOC_N(extent_node_zeroed_get)
+#define	extent_node_zeroed_set JEMALLOC_N(extent_node_zeroed_set)
+#define	extent_tree_ad_empty JEMALLOC_N(extent_tree_ad_empty)
 #define	extent_tree_ad_first JEMALLOC_N(extent_tree_ad_first)
 #define	extent_tree_ad_insert JEMALLOC_N(extent_tree_ad_insert)
 #define	extent_tree_ad_iter JEMALLOC_N(extent_tree_ad_iter)
 #define	extent_tree_ad_iter_recurse JEMALLOC_N(extent_tree_ad_iter_recurse)
 #define	extent_tree_ad_iter_start JEMALLOC_N(extent_tree_ad_iter_start)
 #define	extent_tree_ad_last JEMALLOC_N(extent_tree_ad_last)
@@ -163,12 +214,13 @@
 #define	extent_tree_ad_psearch JEMALLOC_N(extent_tree_ad_psearch)
 #define	extent_tree_ad_remove JEMALLOC_N(extent_tree_ad_remove)
 #define	extent_tree_ad_reverse_iter JEMALLOC_N(extent_tree_ad_reverse_iter)
 #define	extent_tree_ad_reverse_iter_recurse JEMALLOC_N(extent_tree_ad_reverse_iter_recurse)
 #define	extent_tree_ad_reverse_iter_start JEMALLOC_N(extent_tree_ad_reverse_iter_start)
 #define	extent_tree_ad_search JEMALLOC_N(extent_tree_ad_search)
+#define	extent_tree_szad_empty JEMALLOC_N(extent_tree_szad_empty)
 #define	extent_tree_szad_first JEMALLOC_N(extent_tree_szad_first)
 #define	extent_tree_szad_insert JEMALLOC_N(extent_tree_szad_insert)
 #define	extent_tree_szad_iter JEMALLOC_N(extent_tree_szad_iter)
 #define	extent_tree_szad_iter_recurse JEMALLOC_N(extent_tree_szad_iter_recurse)
 #define	extent_tree_szad_iter_start JEMALLOC_N(extent_tree_szad_iter_start)
 #define	extent_tree_szad_last JEMALLOC_N(extent_tree_szad_last)
@@ -190,80 +242,87 @@
 #define	hash_get_block_64 JEMALLOC_N(hash_get_block_64)
 #define	hash_rotl_32 JEMALLOC_N(hash_rotl_32)
 #define	hash_rotl_64 JEMALLOC_N(hash_rotl_64)
 #define	hash_x64_128 JEMALLOC_N(hash_x64_128)
 #define	hash_x86_128 JEMALLOC_N(hash_x86_128)
 #define	hash_x86_32 JEMALLOC_N(hash_x86_32)
-#define	huge_allocated JEMALLOC_N(huge_allocated)
-#define	huge_boot JEMALLOC_N(huge_boot)
+#define	huge_aalloc JEMALLOC_N(huge_aalloc)
 #define	huge_dalloc JEMALLOC_N(huge_dalloc)
 #define	huge_dalloc_junk JEMALLOC_N(huge_dalloc_junk)
-#define	huge_dss_prec_get JEMALLOC_N(huge_dss_prec_get)
 #define	huge_malloc JEMALLOC_N(huge_malloc)
-#define	huge_mtx JEMALLOC_N(huge_mtx)
-#define	huge_ndalloc JEMALLOC_N(huge_ndalloc)
-#define	huge_nmalloc JEMALLOC_N(huge_nmalloc)
 #define	huge_palloc JEMALLOC_N(huge_palloc)
-#define	huge_postfork_child JEMALLOC_N(huge_postfork_child)
-#define	huge_postfork_parent JEMALLOC_N(huge_postfork_parent)
-#define	huge_prefork JEMALLOC_N(huge_prefork)
-#define	huge_prof_ctx_get JEMALLOC_N(huge_prof_ctx_get)
-#define	huge_prof_ctx_set JEMALLOC_N(huge_prof_ctx_set)
+#define	huge_prof_tctx_get JEMALLOC_N(huge_prof_tctx_get)
+#define	huge_prof_tctx_reset JEMALLOC_N(huge_prof_tctx_reset)
+#define	huge_prof_tctx_set JEMALLOC_N(huge_prof_tctx_set)
 #define	huge_ralloc JEMALLOC_N(huge_ralloc)
 #define	huge_ralloc_no_move JEMALLOC_N(huge_ralloc_no_move)
 #define	huge_salloc JEMALLOC_N(huge_salloc)
-#define	iallocm JEMALLOC_N(iallocm)
+#define	iaalloc JEMALLOC_N(iaalloc)
+#define	iallocztm JEMALLOC_N(iallocztm)
 #define	icalloc JEMALLOC_N(icalloc)
 #define	icalloct JEMALLOC_N(icalloct)
 #define	idalloc JEMALLOC_N(idalloc)
 #define	idalloct JEMALLOC_N(idalloct)
+#define	idalloctm JEMALLOC_N(idalloctm)
 #define	imalloc JEMALLOC_N(imalloc)
 #define	imalloct JEMALLOC_N(imalloct)
+#define	index2size JEMALLOC_N(index2size)
+#define	index2size_compute JEMALLOC_N(index2size_compute)
+#define	index2size_lookup JEMALLOC_N(index2size_lookup)
+#define	index2size_tab JEMALLOC_N(index2size_tab)
+#define	in_valgrind JEMALLOC_N(in_valgrind)
 #define	ipalloc JEMALLOC_N(ipalloc)
 #define	ipalloct JEMALLOC_N(ipalloct)
+#define	ipallocztm JEMALLOC_N(ipallocztm)
 #define	iqalloc JEMALLOC_N(iqalloc)
-#define	iqalloct JEMALLOC_N(iqalloct)
 #define	iralloc JEMALLOC_N(iralloc)
 #define	iralloct JEMALLOC_N(iralloct)
 #define	iralloct_realign JEMALLOC_N(iralloct_realign)
 #define	isalloc JEMALLOC_N(isalloc)
+#define	isdalloct JEMALLOC_N(isdalloct)
+#define	isqalloc JEMALLOC_N(isqalloc)
 #define	isthreaded JEMALLOC_N(isthreaded)
 #define	ivsalloc JEMALLOC_N(ivsalloc)
 #define	ixalloc JEMALLOC_N(ixalloc)
 #define	jemalloc_postfork_child JEMALLOC_N(jemalloc_postfork_child)
 #define	jemalloc_postfork_parent JEMALLOC_N(jemalloc_postfork_parent)
 #define	jemalloc_prefork JEMALLOC_N(jemalloc_prefork)
+#define	large_maxclass JEMALLOC_N(large_maxclass)
+#define	lg_floor JEMALLOC_N(lg_floor)
 #define	malloc_cprintf JEMALLOC_N(malloc_cprintf)
 #define	malloc_mutex_init JEMALLOC_N(malloc_mutex_init)
 #define	malloc_mutex_lock JEMALLOC_N(malloc_mutex_lock)
 #define	malloc_mutex_postfork_child JEMALLOC_N(malloc_mutex_postfork_child)
 #define	malloc_mutex_postfork_parent JEMALLOC_N(malloc_mutex_postfork_parent)
 #define	malloc_mutex_prefork JEMALLOC_N(malloc_mutex_prefork)
 #define	malloc_mutex_unlock JEMALLOC_N(malloc_mutex_unlock)
 #define	malloc_printf JEMALLOC_N(malloc_printf)
 #define	malloc_snprintf JEMALLOC_N(malloc_snprintf)
 #define	malloc_strtoumax JEMALLOC_N(malloc_strtoumax)
-#define	malloc_tsd_boot JEMALLOC_N(malloc_tsd_boot)
+#define	malloc_tsd_boot0 JEMALLOC_N(malloc_tsd_boot0)
+#define	malloc_tsd_boot1 JEMALLOC_N(malloc_tsd_boot1)
 #define	malloc_tsd_cleanup_register JEMALLOC_N(malloc_tsd_cleanup_register)
 #define	malloc_tsd_dalloc JEMALLOC_N(malloc_tsd_dalloc)
 #define	malloc_tsd_malloc JEMALLOC_N(malloc_tsd_malloc)
 #define	malloc_tsd_no_cleanup JEMALLOC_N(malloc_tsd_no_cleanup)
 #define	malloc_vcprintf JEMALLOC_N(malloc_vcprintf)
 #define	malloc_vsnprintf JEMALLOC_N(malloc_vsnprintf)
 #define	malloc_write JEMALLOC_N(malloc_write)
 #define	map_bias JEMALLOC_N(map_bias)
+#define	map_misc_offset JEMALLOC_N(map_misc_offset)
 #define	mb_write JEMALLOC_N(mb_write)
 #define	mutex_boot JEMALLOC_N(mutex_boot)
-#define	narenas_auto JEMALLOC_N(narenas_auto)
-#define	narenas_total JEMALLOC_N(narenas_total)
+#define	narenas_cache_cleanup JEMALLOC_N(narenas_cache_cleanup)
 #define	narenas_total_get JEMALLOC_N(narenas_total_get)
 #define	ncpus JEMALLOC_N(ncpus)
 #define	nhbins JEMALLOC_N(nhbins)
 #define	opt_abort JEMALLOC_N(opt_abort)
 #define	opt_dss JEMALLOC_N(opt_dss)
 #define	opt_junk JEMALLOC_N(opt_junk)
+#define	opt_junk_alloc JEMALLOC_N(opt_junk_alloc)
+#define	opt_junk_free JEMALLOC_N(opt_junk_free)
 #define	opt_lg_chunk JEMALLOC_N(opt_lg_chunk)
 #define	opt_lg_dirty_mult JEMALLOC_N(opt_lg_dirty_mult)
 #define	opt_lg_prof_interval JEMALLOC_N(opt_lg_prof_interval)
 #define	opt_lg_prof_sample JEMALLOC_N(opt_lg_prof_sample)
 #define	opt_lg_tcache_max JEMALLOC_N(opt_lg_tcache_max)
 #define	opt_narenas JEMALLOC_N(opt_narenas)
@@ -271,143 +330,170 @@
 #define	opt_prof_accum JEMALLOC_N(opt_prof_accum)
 #define	opt_prof_active JEMALLOC_N(opt_prof_active)
 #define	opt_prof_final JEMALLOC_N(opt_prof_final)
 #define	opt_prof_gdump JEMALLOC_N(opt_prof_gdump)
 #define	opt_prof_leak JEMALLOC_N(opt_prof_leak)
 #define	opt_prof_prefix JEMALLOC_N(opt_prof_prefix)
+#define	opt_prof_thread_active_init JEMALLOC_N(opt_prof_thread_active_init)
 #define	opt_quarantine JEMALLOC_N(opt_quarantine)
 #define	opt_redzone JEMALLOC_N(opt_redzone)
 #define	opt_stats_print JEMALLOC_N(opt_stats_print)
 #define	opt_tcache JEMALLOC_N(opt_tcache)
 #define	opt_utrace JEMALLOC_N(opt_utrace)
-#define	opt_valgrind JEMALLOC_N(opt_valgrind)
 #define	opt_xmalloc JEMALLOC_N(opt_xmalloc)
 #define	opt_zero JEMALLOC_N(opt_zero)
 #define	p2rz JEMALLOC_N(p2rz)
+#define	pages_commit JEMALLOC_N(pages_commit)
+#define	pages_decommit JEMALLOC_N(pages_decommit)
+#define	pages_map JEMALLOC_N(pages_map)
 #define	pages_purge JEMALLOC_N(pages_purge)
+#define	pages_trim JEMALLOC_N(pages_trim)
+#define	pages_unmap JEMALLOC_N(pages_unmap)
 #define	pow2_ceil JEMALLOC_N(pow2_ceil)
+#define	prof_active_get JEMALLOC_N(prof_active_get)
+#define	prof_active_get_unlocked JEMALLOC_N(prof_active_get_unlocked)
+#define	prof_active_set JEMALLOC_N(prof_active_set)
+#define	prof_alloc_prep JEMALLOC_N(prof_alloc_prep)
+#define	prof_alloc_rollback JEMALLOC_N(prof_alloc_rollback)
 #define	prof_backtrace JEMALLOC_N(prof_backtrace)
 #define	prof_boot0 JEMALLOC_N(prof_boot0)
 #define	prof_boot1 JEMALLOC_N(prof_boot1)
 #define	prof_boot2 JEMALLOC_N(prof_boot2)
-#define	prof_bt_count JEMALLOC_N(prof_bt_count)
-#define	prof_ctx_get JEMALLOC_N(prof_ctx_get)
-#define	prof_ctx_set JEMALLOC_N(prof_ctx_set)
+#define	prof_dump_header JEMALLOC_N(prof_dump_header)
 #define	prof_dump_open JEMALLOC_N(prof_dump_open)
 #define	prof_free JEMALLOC_N(prof_free)
+#define	prof_free_sampled_object JEMALLOC_N(prof_free_sampled_object)
 #define	prof_gdump JEMALLOC_N(prof_gdump)
+#define	prof_gdump_get JEMALLOC_N(prof_gdump_get)
+#define	prof_gdump_get_unlocked JEMALLOC_N(prof_gdump_get_unlocked)
+#define	prof_gdump_set JEMALLOC_N(prof_gdump_set)
+#define	prof_gdump_val JEMALLOC_N(prof_gdump_val)
 #define	prof_idump JEMALLOC_N(prof_idump)
 #define	prof_interval JEMALLOC_N(prof_interval)
 #define	prof_lookup JEMALLOC_N(prof_lookup)
 #define	prof_malloc JEMALLOC_N(prof_malloc)
+#define	prof_malloc_sample_object JEMALLOC_N(prof_malloc_sample_object)
 #define	prof_mdump JEMALLOC_N(prof_mdump)
 #define	prof_postfork_child JEMALLOC_N(prof_postfork_child)
 #define	prof_postfork_parent JEMALLOC_N(prof_postfork_parent)
 #define	prof_prefork JEMALLOC_N(prof_prefork)
-#define	prof_promote JEMALLOC_N(prof_promote)
 #define	prof_realloc JEMALLOC_N(prof_realloc)
+#define	prof_reset JEMALLOC_N(prof_reset)
 #define	prof_sample_accum_update JEMALLOC_N(prof_sample_accum_update)
 #define	prof_sample_threshold_update JEMALLOC_N(prof_sample_threshold_update)
-#define	prof_tdata_booted JEMALLOC_N(prof_tdata_booted)
+#define	prof_tctx_get JEMALLOC_N(prof_tctx_get)
+#define	prof_tctx_reset JEMALLOC_N(prof_tctx_reset)
+#define	prof_tctx_set JEMALLOC_N(prof_tctx_set)
 #define	prof_tdata_cleanup JEMALLOC_N(prof_tdata_cleanup)
 #define	prof_tdata_get JEMALLOC_N(prof_tdata_get)
 #define	prof_tdata_init JEMALLOC_N(prof_tdata_init)
-#define	prof_tdata_initialized JEMALLOC_N(prof_tdata_initialized)
-#define	prof_tdata_tls JEMALLOC_N(prof_tdata_tls)
-#define	prof_tdata_tsd JEMALLOC_N(prof_tdata_tsd)
-#define	prof_tdata_tsd_boot JEMALLOC_N(prof_tdata_tsd_boot)
-#define	prof_tdata_tsd_cleanup_wrapper JEMALLOC_N(prof_tdata_tsd_cleanup_wrapper)
-#define	prof_tdata_tsd_get JEMALLOC_N(prof_tdata_tsd_get)
-#define	prof_tdata_tsd_get_wrapper JEMALLOC_N(prof_tdata_tsd_get_wrapper)
-#define	prof_tdata_tsd_init_head JEMALLOC_N(prof_tdata_tsd_init_head)
-#define	prof_tdata_tsd_set JEMALLOC_N(prof_tdata_tsd_set)
+#define	prof_tdata_reinit JEMALLOC_N(prof_tdata_reinit)
+#define	prof_thread_active_get JEMALLOC_N(prof_thread_active_get)
+#define	prof_thread_active_init_get JEMALLOC_N(prof_thread_active_init_get)
+#define	prof_thread_active_init_set JEMALLOC_N(prof_thread_active_init_set)
+#define	prof_thread_active_set JEMALLOC_N(prof_thread_active_set)
+#define	prof_thread_name_get JEMALLOC_N(prof_thread_name_get)
+#define	prof_thread_name_set JEMALLOC_N(prof_thread_name_set)
 #define	quarantine JEMALLOC_N(quarantine)
 #define	quarantine_alloc_hook JEMALLOC_N(quarantine_alloc_hook)
-#define	quarantine_boot JEMALLOC_N(quarantine_boot)
-#define	quarantine_booted JEMALLOC_N(quarantine_booted)
+#define	quarantine_alloc_hook_work JEMALLOC_N(quarantine_alloc_hook_work)
 #define	quarantine_cleanup JEMALLOC_N(quarantine_cleanup)
-#define	quarantine_init JEMALLOC_N(quarantine_init)
-#define	quarantine_tls JEMALLOC_N(quarantine_tls)
-#define	quarantine_tsd JEMALLOC_N(quarantine_tsd)
-#define	quarantine_tsd_boot JEMALLOC_N(quarantine_tsd_boot)
-#define	quarantine_tsd_cleanup_wrapper JEMALLOC_N(quarantine_tsd_cleanup_wrapper)
-#define	quarantine_tsd_get JEMALLOC_N(quarantine_tsd_get)
-#define	quarantine_tsd_get_wrapper JEMALLOC_N(quarantine_tsd_get_wrapper)
-#define	quarantine_tsd_init_head JEMALLOC_N(quarantine_tsd_init_head)
-#define	quarantine_tsd_set JEMALLOC_N(quarantine_tsd_set)
 #define	register_zone JEMALLOC_N(register_zone)
+#define	rtree_child_read JEMALLOC_N(rtree_child_read)
+#define	rtree_child_read_hard JEMALLOC_N(rtree_child_read_hard)
+#define	rtree_child_tryread JEMALLOC_N(rtree_child_tryread)
 #define	rtree_delete JEMALLOC_N(rtree_delete)
 #define	rtree_get JEMALLOC_N(rtree_get)
-#define	rtree_get_locked JEMALLOC_N(rtree_get_locked)
 #define	rtree_new JEMALLOC_N(rtree_new)
-#define	rtree_postfork_child JEMALLOC_N(rtree_postfork_child)
-#define	rtree_postfork_parent JEMALLOC_N(rtree_postfork_parent)
-#define	rtree_prefork JEMALLOC_N(rtree_prefork)
+#define	rtree_node_valid JEMALLOC_N(rtree_node_valid)
 #define	rtree_set JEMALLOC_N(rtree_set)
+#define	rtree_start_level JEMALLOC_N(rtree_start_level)
+#define	rtree_subkey JEMALLOC_N(rtree_subkey)
+#define	rtree_subtree_read JEMALLOC_N(rtree_subtree_read)
+#define	rtree_subtree_read_hard JEMALLOC_N(rtree_subtree_read_hard)
+#define	rtree_subtree_tryread JEMALLOC_N(rtree_subtree_tryread)
+#define	rtree_val_read JEMALLOC_N(rtree_val_read)
+#define	rtree_val_write JEMALLOC_N(rtree_val_write)
 #define	s2u JEMALLOC_N(s2u)
+#define	s2u_compute JEMALLOC_N(s2u_compute)
+#define	s2u_lookup JEMALLOC_N(s2u_lookup)
 #define	sa2u JEMALLOC_N(sa2u)
 #define	set_errno JEMALLOC_N(set_errno)
-#define	small_size2bin JEMALLOC_N(small_size2bin)
+#define	size2index JEMALLOC_N(size2index)
+#define	size2index_compute JEMALLOC_N(size2index_compute)
+#define	size2index_lookup JEMALLOC_N(size2index_lookup)
+#define	size2index_tab JEMALLOC_N(size2index_tab)
 #define	stats_cactive JEMALLOC_N(stats_cactive)
 #define	stats_cactive_add JEMALLOC_N(stats_cactive_add)
 #define	stats_cactive_get JEMALLOC_N(stats_cactive_get)
 #define	stats_cactive_sub JEMALLOC_N(stats_cactive_sub)
-#define	stats_chunks JEMALLOC_N(stats_chunks)
 #define	stats_print JEMALLOC_N(stats_print)
 #define	tcache_alloc_easy JEMALLOC_N(tcache_alloc_easy)
 #define	tcache_alloc_large JEMALLOC_N(tcache_alloc_large)
 #define	tcache_alloc_small JEMALLOC_N(tcache_alloc_small)
 #define	tcache_alloc_small_hard JEMALLOC_N(tcache_alloc_small_hard)
 #define	tcache_arena_associate JEMALLOC_N(tcache_arena_associate)
 #define	tcache_arena_dissociate JEMALLOC_N(tcache_arena_dissociate)
+#define	tcache_arena_reassociate JEMALLOC_N(tcache_arena_reassociate)
 #define	tcache_bin_flush_large JEMALLOC_N(tcache_bin_flush_large)
 #define	tcache_bin_flush_small JEMALLOC_N(tcache_bin_flush_small)
 #define	tcache_bin_info JEMALLOC_N(tcache_bin_info)
-#define	tcache_boot0 JEMALLOC_N(tcache_boot0)
-#define	tcache_boot1 JEMALLOC_N(tcache_boot1)
-#define	tcache_booted JEMALLOC_N(tcache_booted)
+#define	tcache_boot JEMALLOC_N(tcache_boot)
+#define	tcache_cleanup JEMALLOC_N(tcache_cleanup)
 #define	tcache_create JEMALLOC_N(tcache_create)
 #define	tcache_dalloc_large JEMALLOC_N(tcache_dalloc_large)
 #define	tcache_dalloc_small JEMALLOC_N(tcache_dalloc_small)
-#define	tcache_destroy JEMALLOC_N(tcache_destroy)
-#define	tcache_enabled_booted JEMALLOC_N(tcache_enabled_booted)
+#define	tcache_enabled_cleanup JEMALLOC_N(tcache_enabled_cleanup)
 #define	tcache_enabled_get JEMALLOC_N(tcache_enabled_get)
-#define	tcache_enabled_initialized JEMALLOC_N(tcache_enabled_initialized)
 #define	tcache_enabled_set JEMALLOC_N(tcache_enabled_set)
-#define	tcache_enabled_tls JEMALLOC_N(tcache_enabled_tls)
-#define	tcache_enabled_tsd JEMALLOC_N(tcache_enabled_tsd)
-#define	tcache_enabled_tsd_boot JEMALLOC_N(tcache_enabled_tsd_boot)
-#define	tcache_enabled_tsd_cleanup_wrapper JEMALLOC_N(tcache_enabled_tsd_cleanup_wrapper)
-#define	tcache_enabled_tsd_get JEMALLOC_N(tcache_enabled_tsd_get)
-#define	tcache_enabled_tsd_get_wrapper JEMALLOC_N(tcache_enabled_tsd_get_wrapper)
-#define	tcache_enabled_tsd_init_head JEMALLOC_N(tcache_enabled_tsd_init_head)
-#define	tcache_enabled_tsd_set JEMALLOC_N(tcache_enabled_tsd_set)
 #define	tcache_event JEMALLOC_N(tcache_event)
 #define	tcache_event_hard JEMALLOC_N(tcache_event_hard)
 #define	tcache_flush JEMALLOC_N(tcache_flush)
 #define	tcache_get JEMALLOC_N(tcache_get)
-#define	tcache_initialized JEMALLOC_N(tcache_initialized)
+#define	tcache_get_hard JEMALLOC_N(tcache_get_hard)
 #define	tcache_maxclass JEMALLOC_N(tcache_maxclass)
+#define	tcaches JEMALLOC_N(tcaches)
 #define	tcache_salloc JEMALLOC_N(tcache_salloc)
+#define	tcaches_create JEMALLOC_N(tcaches_create)
+#define	tcaches_destroy JEMALLOC_N(tcaches_destroy)
+#define	tcaches_flush JEMALLOC_N(tcaches_flush)
+#define	tcaches_get JEMALLOC_N(tcaches_get)
 #define	tcache_stats_merge JEMALLOC_N(tcache_stats_merge)
-#define	tcache_thread_cleanup JEMALLOC_N(tcache_thread_cleanup)
-#define	tcache_tls JEMALLOC_N(tcache_tls)
-#define	tcache_tsd JEMALLOC_N(tcache_tsd)
-#define	tcache_tsd_boot JEMALLOC_N(tcache_tsd_boot)
-#define	tcache_tsd_cleanup_wrapper JEMALLOC_N(tcache_tsd_cleanup_wrapper)
-#define	tcache_tsd_get JEMALLOC_N(tcache_tsd_get)
-#define	tcache_tsd_get_wrapper JEMALLOC_N(tcache_tsd_get_wrapper)
-#define	tcache_tsd_init_head JEMALLOC_N(tcache_tsd_init_head)
-#define	tcache_tsd_set JEMALLOC_N(tcache_tsd_set)
-#define	thread_allocated_booted JEMALLOC_N(thread_allocated_booted)
-#define	thread_allocated_initialized JEMALLOC_N(thread_allocated_initialized)
-#define	thread_allocated_tls JEMALLOC_N(thread_allocated_tls)
-#define	thread_allocated_tsd JEMALLOC_N(thread_allocated_tsd)
-#define	thread_allocated_tsd_boot JEMALLOC_N(thread_allocated_tsd_boot)
-#define	thread_allocated_tsd_cleanup_wrapper JEMALLOC_N(thread_allocated_tsd_cleanup_wrapper)
-#define	thread_allocated_tsd_get JEMALLOC_N(thread_allocated_tsd_get)
-#define	thread_allocated_tsd_get_wrapper JEMALLOC_N(thread_allocated_tsd_get_wrapper)
-#define	thread_allocated_tsd_init_head JEMALLOC_N(thread_allocated_tsd_init_head)
-#define	thread_allocated_tsd_set JEMALLOC_N(thread_allocated_tsd_set)
+#define	thread_allocated_cleanup JEMALLOC_N(thread_allocated_cleanup)
+#define	thread_deallocated_cleanup JEMALLOC_N(thread_deallocated_cleanup)
+#define	tsd_arena_get JEMALLOC_N(tsd_arena_get)
+#define	tsd_arena_set JEMALLOC_N(tsd_arena_set)
+#define	tsd_boot JEMALLOC_N(tsd_boot)
+#define	tsd_boot0 JEMALLOC_N(tsd_boot0)
+#define	tsd_boot1 JEMALLOC_N(tsd_boot1)
+#define	tsd_booted JEMALLOC_N(tsd_booted)
+#define	tsd_cleanup JEMALLOC_N(tsd_cleanup)
+#define	tsd_cleanup_wrapper JEMALLOC_N(tsd_cleanup_wrapper)
+#define	tsd_fetch JEMALLOC_N(tsd_fetch)
+#define	tsd_get JEMALLOC_N(tsd_get)
+#define	tsd_wrapper_get JEMALLOC_N(tsd_wrapper_get)
+#define	tsd_wrapper_set JEMALLOC_N(tsd_wrapper_set)
+#define	tsd_initialized JEMALLOC_N(tsd_initialized)
 #define	tsd_init_check_recursion JEMALLOC_N(tsd_init_check_recursion)
 #define	tsd_init_finish JEMALLOC_N(tsd_init_finish)
+#define	tsd_init_head JEMALLOC_N(tsd_init_head)
+#define	tsd_nominal JEMALLOC_N(tsd_nominal)
+#define	tsd_quarantine_get JEMALLOC_N(tsd_quarantine_get)
+#define	tsd_quarantine_set JEMALLOC_N(tsd_quarantine_set)
+#define	tsd_set JEMALLOC_N(tsd_set)
+#define	tsd_tcache_enabled_get JEMALLOC_N(tsd_tcache_enabled_get)
+#define	tsd_tcache_enabled_set JEMALLOC_N(tsd_tcache_enabled_set)
+#define	tsd_tcache_get JEMALLOC_N(tsd_tcache_get)
+#define	tsd_tcache_set JEMALLOC_N(tsd_tcache_set)
+#define	tsd_tls JEMALLOC_N(tsd_tls)
+#define	tsd_tsd JEMALLOC_N(tsd_tsd)
+#define	tsd_prof_tdata_get JEMALLOC_N(tsd_prof_tdata_get)
+#define	tsd_prof_tdata_set JEMALLOC_N(tsd_prof_tdata_set)
+#define	tsd_thread_allocated_get JEMALLOC_N(tsd_thread_allocated_get)
+#define	tsd_thread_allocated_set JEMALLOC_N(tsd_thread_allocated_set)
+#define	tsd_thread_deallocated_get JEMALLOC_N(tsd_thread_deallocated_get)
+#define	tsd_thread_deallocated_set JEMALLOC_N(tsd_thread_deallocated_set)
 #define	u2rz JEMALLOC_N(u2rz)
+#define	valgrind_freelike_block JEMALLOC_N(valgrind_freelike_block)
+#define	valgrind_make_mem_defined JEMALLOC_N(valgrind_make_mem_defined)
+#define	valgrind_make_mem_noaccess JEMALLOC_N(valgrind_make_mem_noaccess)
+#define	valgrind_make_mem_undefined JEMALLOC_N(valgrind_make_mem_undefined)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/private_symbols.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/private_symbols.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/private_symbols.txt	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/private_symbols.txt	2016-05-06 15:11:36.000000000 +0800
@@ -1,158 +1,209 @@
-a0calloc
-a0free
+a0dalloc
+a0get
 a0malloc
+arena_aalloc
 arena_alloc_junk_small
 arena_bin_index
 arena_bin_info
+arena_bitselm_get
 arena_boot
+arena_choose
+arena_choose_hard
+arena_chunk_alloc_huge
+arena_chunk_cache_maybe_insert
+arena_chunk_cache_maybe_remove
+arena_chunk_dalloc_huge
+arena_chunk_ralloc_huge_expand
+arena_chunk_ralloc_huge_shrink
+arena_chunk_ralloc_huge_similar
+arena_cleanup
 arena_dalloc
 arena_dalloc_bin
-arena_dalloc_bin_locked
+arena_dalloc_bin_junked_locked
 arena_dalloc_junk_large
 arena_dalloc_junk_small
 arena_dalloc_large
-arena_dalloc_large_locked
+arena_dalloc_large_junked_locked
 arena_dalloc_small
 arena_dss_prec_get
 arena_dss_prec_set
+arena_get
+arena_get_hard
+arena_init
+arena_lg_dirty_mult_default_get
+arena_lg_dirty_mult_default_set
+arena_lg_dirty_mult_get
+arena_lg_dirty_mult_set
 arena_malloc
 arena_malloc_large
 arena_malloc_small
 arena_mapbits_allocated_get
 arena_mapbits_binind_get
+arena_mapbits_decommitted_get
 arena_mapbits_dirty_get
 arena_mapbits_get
+arena_mapbits_internal_set
 arena_mapbits_large_binind_set
 arena_mapbits_large_get
 arena_mapbits_large_set
 arena_mapbits_large_size_get
+arena_mapbitsp_get
+arena_mapbitsp_read
+arena_mapbitsp_write
+arena_mapbits_size_decode
+arena_mapbits_size_encode
 arena_mapbits_small_runind_get
 arena_mapbits_small_set
 arena_mapbits_unallocated_set
 arena_mapbits_unallocated_size_get
 arena_mapbits_unallocated_size_set
 arena_mapbits_unzeroed_get
-arena_mapbits_unzeroed_set
-arena_mapbitsp_get
-arena_mapbitsp_read
-arena_mapbitsp_write
-arena_mapp_get
-arena_maxclass
+arena_maxrun
+arena_maybe_purge
+arena_metadata_allocated_add
+arena_metadata_allocated_get
+arena_metadata_allocated_sub
+arena_migrate
+arena_miscelm_get
+arena_miscelm_to_pageind
+arena_miscelm_to_rpages
+arena_nbound
 arena_new
+arena_node_alloc
+arena_node_dalloc
 arena_palloc
 arena_postfork_child
 arena_postfork_parent
 arena_prefork
 arena_prof_accum
 arena_prof_accum_impl
 arena_prof_accum_locked
-arena_prof_ctx_get
-arena_prof_ctx_set
 arena_prof_promoted
+arena_prof_tctx_get
+arena_prof_tctx_reset
+arena_prof_tctx_set
 arena_ptr_small_binind_get
 arena_purge_all
 arena_quarantine_junk_small
 arena_ralloc
 arena_ralloc_junk_large
 arena_ralloc_no_move
+arena_rd_to_miscelm
 arena_redzone_corruption
 arena_run_regind
+arena_run_to_miscelm
 arena_salloc
+arenas_cache_bypass_cleanup
+arenas_cache_cleanup
+arena_sdalloc
 arena_stats_merge
 arena_tcache_fill_small
-arenas
-arenas_booted
-arenas_cleanup
-arenas_extend
-arenas_initialized
-arenas_lock
-arenas_tls
-arenas_tsd
-arenas_tsd_boot
-arenas_tsd_cleanup_wrapper
-arenas_tsd_get
-arenas_tsd_get_wrapper
-arenas_tsd_init_head
-arenas_tsd_set
+atomic_add_p
 atomic_add_u
 atomic_add_uint32
 atomic_add_uint64
 atomic_add_z
+atomic_cas_p
+atomic_cas_u
+atomic_cas_uint32
+atomic_cas_uint64
+atomic_cas_z
+atomic_sub_p
 atomic_sub_u
 atomic_sub_uint32
 atomic_sub_uint64
 atomic_sub_z
 base_alloc
 base_boot
-base_calloc
-base_node_alloc
-base_node_dealloc
 base_postfork_child
 base_postfork_parent
 base_prefork
+base_stats_get
 bitmap_full
 bitmap_get
 bitmap_info_init
 bitmap_info_ngroups
 bitmap_init
 bitmap_set
 bitmap_sfu
 bitmap_size
 bitmap_unset
+bootstrap_calloc
+bootstrap_free
+bootstrap_malloc
 bt_init
 buferror
-choose_arena
-choose_arena_hard
-chunk_alloc
+chunk_alloc_base
+chunk_alloc_cache
 chunk_alloc_dss
 chunk_alloc_mmap
+chunk_alloc_wrapper
 chunk_boot
-chunk_dealloc
-chunk_dealloc_mmap
+chunk_dalloc_arena
+chunk_dalloc_cache
+chunk_dalloc_mmap
+chunk_dalloc_wrapper
+chunk_deregister
 chunk_dss_boot
 chunk_dss_postfork_child
 chunk_dss_postfork_parent
 chunk_dss_prec_get
 chunk_dss_prec_set
 chunk_dss_prefork
+chunk_hooks_default
+chunk_hooks_get
+chunk_hooks_set
 chunk_in_dss
+chunk_lookup
 chunk_npages
 chunk_postfork_child
 chunk_postfork_parent
 chunk_prefork
-chunk_unmap
-chunks_mtx
-chunks_rtree
+chunk_purge_arena
+chunk_purge_wrapper
+chunk_register
 chunksize
 chunksize_mask
-ckh_bucket_search
+chunks_rtree
 ckh_count
 ckh_delete
-ckh_evict_reloc_insert
 ckh_insert
-ckh_isearch
 ckh_iter
 ckh_new
 ckh_pointer_hash
 ckh_pointer_keycomp
-ckh_rebuild
 ckh_remove
 ckh_search
 ckh_string_hash
 ckh_string_keycomp
-ckh_try_bucket_insert
-ckh_try_insert
 ctl_boot
 ctl_bymib
 ctl_byname
 ctl_nametomib
 ctl_postfork_child
 ctl_postfork_parent
 ctl_prefork
 dss_prec_names
+extent_node_achunk_get
+extent_node_achunk_set
+extent_node_addr_get
+extent_node_addr_set
+extent_node_arena_get
+extent_node_arena_set
+extent_node_dirty_insert
+extent_node_dirty_linkage_init
+extent_node_dirty_remove
+extent_node_init
+extent_node_prof_tctx_get
+extent_node_prof_tctx_set
+extent_node_size_get
+extent_node_size_set
+extent_node_zeroed_get
+extent_node_zeroed_set
+extent_tree_ad_empty
 extent_tree_ad_first
 extent_tree_ad_insert
 extent_tree_ad_iter
 extent_tree_ad_iter_recurse
 extent_tree_ad_iter_start
 extent_tree_ad_last
@@ -163,12 +214,13 @@
 extent_tree_ad_psearch
 extent_tree_ad_remove
 extent_tree_ad_reverse_iter
 extent_tree_ad_reverse_iter_recurse
 extent_tree_ad_reverse_iter_start
 extent_tree_ad_search
+extent_tree_szad_empty
 extent_tree_szad_first
 extent_tree_szad_insert
 extent_tree_szad_iter
 extent_tree_szad_iter_recurse
 extent_tree_szad_iter_start
 extent_tree_szad_last
@@ -190,80 +242,87 @@
 hash_get_block_64
 hash_rotl_32
 hash_rotl_64
 hash_x64_128
 hash_x86_128
 hash_x86_32
-huge_allocated
-huge_boot
+huge_aalloc
 huge_dalloc
 huge_dalloc_junk
-huge_dss_prec_get
 huge_malloc
-huge_mtx
-huge_ndalloc
-huge_nmalloc
 huge_palloc
-huge_postfork_child
-huge_postfork_parent
-huge_prefork
-huge_prof_ctx_get
-huge_prof_ctx_set
+huge_prof_tctx_get
+huge_prof_tctx_reset
+huge_prof_tctx_set
 huge_ralloc
 huge_ralloc_no_move
 huge_salloc
-iallocm
+iaalloc
+iallocztm
 icalloc
 icalloct
 idalloc
 idalloct
+idalloctm
 imalloc
 imalloct
+index2size
+index2size_compute
+index2size_lookup
+index2size_tab
+in_valgrind
 ipalloc
 ipalloct
+ipallocztm
 iqalloc
-iqalloct
 iralloc
 iralloct
 iralloct_realign
 isalloc
+isdalloct
+isqalloc
 isthreaded
 ivsalloc
 ixalloc
 jemalloc_postfork_child
 jemalloc_postfork_parent
 jemalloc_prefork
+large_maxclass
+lg_floor
 malloc_cprintf
 malloc_mutex_init
 malloc_mutex_lock
 malloc_mutex_postfork_child
 malloc_mutex_postfork_parent
 malloc_mutex_prefork
 malloc_mutex_unlock
 malloc_printf
 malloc_snprintf
 malloc_strtoumax
-malloc_tsd_boot
+malloc_tsd_boot0
+malloc_tsd_boot1
 malloc_tsd_cleanup_register
 malloc_tsd_dalloc
 malloc_tsd_malloc
 malloc_tsd_no_cleanup
 malloc_vcprintf
 malloc_vsnprintf
 malloc_write
 map_bias
+map_misc_offset
 mb_write
 mutex_boot
-narenas_auto
-narenas_total
+narenas_cache_cleanup
 narenas_total_get
 ncpus
 nhbins
 opt_abort
 opt_dss
 opt_junk
+opt_junk_alloc
+opt_junk_free
 opt_lg_chunk
 opt_lg_dirty_mult
 opt_lg_prof_interval
 opt_lg_prof_sample
 opt_lg_tcache_max
 opt_narenas
@@ -271,143 +330,170 @@
 opt_prof_accum
 opt_prof_active
 opt_prof_final
 opt_prof_gdump
 opt_prof_leak
 opt_prof_prefix
+opt_prof_thread_active_init
 opt_quarantine
 opt_redzone
 opt_stats_print
 opt_tcache
 opt_utrace
-opt_valgrind
 opt_xmalloc
 opt_zero
 p2rz
+pages_commit
+pages_decommit
+pages_map
 pages_purge
+pages_trim
+pages_unmap
 pow2_ceil
+prof_active_get
+prof_active_get_unlocked
+prof_active_set
+prof_alloc_prep
+prof_alloc_rollback
 prof_backtrace
 prof_boot0
 prof_boot1
 prof_boot2
-prof_bt_count
-prof_ctx_get
-prof_ctx_set
+prof_dump_header
 prof_dump_open
 prof_free
+prof_free_sampled_object
 prof_gdump
+prof_gdump_get
+prof_gdump_get_unlocked
+prof_gdump_set
+prof_gdump_val
 prof_idump
 prof_interval
 prof_lookup
 prof_malloc
+prof_malloc_sample_object
 prof_mdump
 prof_postfork_child
 prof_postfork_parent
 prof_prefork
-prof_promote
 prof_realloc
+prof_reset
 prof_sample_accum_update
 prof_sample_threshold_update
-prof_tdata_booted
+prof_tctx_get
+prof_tctx_reset
+prof_tctx_set
 prof_tdata_cleanup
 prof_tdata_get
 prof_tdata_init
-prof_tdata_initialized
-prof_tdata_tls
-prof_tdata_tsd
-prof_tdata_tsd_boot
-prof_tdata_tsd_cleanup_wrapper
-prof_tdata_tsd_get
-prof_tdata_tsd_get_wrapper
-prof_tdata_tsd_init_head
-prof_tdata_tsd_set
+prof_tdata_reinit
+prof_thread_active_get
+prof_thread_active_init_get
+prof_thread_active_init_set
+prof_thread_active_set
+prof_thread_name_get
+prof_thread_name_set
 quarantine
 quarantine_alloc_hook
-quarantine_boot
-quarantine_booted
+quarantine_alloc_hook_work
 quarantine_cleanup
-quarantine_init
-quarantine_tls
-quarantine_tsd
-quarantine_tsd_boot
-quarantine_tsd_cleanup_wrapper
-quarantine_tsd_get
-quarantine_tsd_get_wrapper
-quarantine_tsd_init_head
-quarantine_tsd_set
 register_zone
+rtree_child_read
+rtree_child_read_hard
+rtree_child_tryread
 rtree_delete
 rtree_get
-rtree_get_locked
 rtree_new
-rtree_postfork_child
-rtree_postfork_parent
-rtree_prefork
+rtree_node_valid
 rtree_set
+rtree_start_level
+rtree_subkey
+rtree_subtree_read
+rtree_subtree_read_hard
+rtree_subtree_tryread
+rtree_val_read
+rtree_val_write
 s2u
+s2u_compute
+s2u_lookup
 sa2u
 set_errno
-small_size2bin
+size2index
+size2index_compute
+size2index_lookup
+size2index_tab
 stats_cactive
 stats_cactive_add
 stats_cactive_get
 stats_cactive_sub
-stats_chunks
 stats_print
 tcache_alloc_easy
 tcache_alloc_large
 tcache_alloc_small
 tcache_alloc_small_hard
 tcache_arena_associate
 tcache_arena_dissociate
+tcache_arena_reassociate
 tcache_bin_flush_large
 tcache_bin_flush_small
 tcache_bin_info
-tcache_boot0
-tcache_boot1
-tcache_booted
+tcache_boot
+tcache_cleanup
 tcache_create
 tcache_dalloc_large
 tcache_dalloc_small
-tcache_destroy
-tcache_enabled_booted
+tcache_enabled_cleanup
 tcache_enabled_get
-tcache_enabled_initialized
 tcache_enabled_set
-tcache_enabled_tls
-tcache_enabled_tsd
-tcache_enabled_tsd_boot
-tcache_enabled_tsd_cleanup_wrapper
-tcache_enabled_tsd_get
-tcache_enabled_tsd_get_wrapper
-tcache_enabled_tsd_init_head
-tcache_enabled_tsd_set
 tcache_event
 tcache_event_hard
 tcache_flush
 tcache_get
-tcache_initialized
+tcache_get_hard
 tcache_maxclass
+tcaches
 tcache_salloc
+tcaches_create
+tcaches_destroy
+tcaches_flush
+tcaches_get
 tcache_stats_merge
-tcache_thread_cleanup
-tcache_tls
-tcache_tsd
-tcache_tsd_boot
-tcache_tsd_cleanup_wrapper
-tcache_tsd_get
-tcache_tsd_get_wrapper
-tcache_tsd_init_head
-tcache_tsd_set
-thread_allocated_booted
-thread_allocated_initialized
-thread_allocated_tls
-thread_allocated_tsd
-thread_allocated_tsd_boot
-thread_allocated_tsd_cleanup_wrapper
-thread_allocated_tsd_get
-thread_allocated_tsd_get_wrapper
-thread_allocated_tsd_init_head
-thread_allocated_tsd_set
+thread_allocated_cleanup
+thread_deallocated_cleanup
+tsd_arena_get
+tsd_arena_set
+tsd_boot
+tsd_boot0
+tsd_boot1
+tsd_booted
+tsd_cleanup
+tsd_cleanup_wrapper
+tsd_fetch
+tsd_get
+tsd_wrapper_get
+tsd_wrapper_set
+tsd_initialized
 tsd_init_check_recursion
 tsd_init_finish
+tsd_init_head
+tsd_nominal
+tsd_quarantine_get
+tsd_quarantine_set
+tsd_set
+tsd_tcache_enabled_get
+tsd_tcache_enabled_set
+tsd_tcache_get
+tsd_tcache_set
+tsd_tls
+tsd_tsd
+tsd_prof_tdata_get
+tsd_prof_tdata_set
+tsd_thread_allocated_get
+tsd_thread_allocated_set
+tsd_thread_deallocated_get
+tsd_thread_deallocated_set
 u2rz
+valgrind_freelike_block
+valgrind_make_mem_defined
+valgrind_make_mem_noaccess
+valgrind_make_mem_undefined
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/private_unnamespace.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/private_unnamespace.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/private_unnamespace.h	2017-09-27 22:47:53.346963470 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/private_unnamespace.h	2017-09-27 22:49:15.150960471 +0800
@@ -1,158 +1,209 @@
-#undef a0calloc
-#undef a0free
+#undef a0dalloc
+#undef a0get
 #undef a0malloc
+#undef arena_aalloc
 #undef arena_alloc_junk_small
 #undef arena_bin_index
 #undef arena_bin_info
+#undef arena_bitselm_get
 #undef arena_boot
+#undef arena_choose
+#undef arena_choose_hard
+#undef arena_chunk_alloc_huge
+#undef arena_chunk_cache_maybe_insert
+#undef arena_chunk_cache_maybe_remove
+#undef arena_chunk_dalloc_huge
+#undef arena_chunk_ralloc_huge_expand
+#undef arena_chunk_ralloc_huge_shrink
+#undef arena_chunk_ralloc_huge_similar
+#undef arena_cleanup
 #undef arena_dalloc
 #undef arena_dalloc_bin
-#undef arena_dalloc_bin_locked
+#undef arena_dalloc_bin_junked_locked
 #undef arena_dalloc_junk_large
 #undef arena_dalloc_junk_small
 #undef arena_dalloc_large
-#undef arena_dalloc_large_locked
+#undef arena_dalloc_large_junked_locked
 #undef arena_dalloc_small
 #undef arena_dss_prec_get
 #undef arena_dss_prec_set
+#undef arena_get
+#undef arena_get_hard
+#undef arena_init
+#undef arena_lg_dirty_mult_default_get
+#undef arena_lg_dirty_mult_default_set
+#undef arena_lg_dirty_mult_get
+#undef arena_lg_dirty_mult_set
 #undef arena_malloc
 #undef arena_malloc_large
 #undef arena_malloc_small
 #undef arena_mapbits_allocated_get
 #undef arena_mapbits_binind_get
+#undef arena_mapbits_decommitted_get
 #undef arena_mapbits_dirty_get
 #undef arena_mapbits_get
+#undef arena_mapbits_internal_set
 #undef arena_mapbits_large_binind_set
 #undef arena_mapbits_large_get
 #undef arena_mapbits_large_set
 #undef arena_mapbits_large_size_get
+#undef arena_mapbitsp_get
+#undef arena_mapbitsp_read
+#undef arena_mapbitsp_write
+#undef arena_mapbits_size_decode
+#undef arena_mapbits_size_encode
 #undef arena_mapbits_small_runind_get
 #undef arena_mapbits_small_set
 #undef arena_mapbits_unallocated_set
 #undef arena_mapbits_unallocated_size_get
 #undef arena_mapbits_unallocated_size_set
 #undef arena_mapbits_unzeroed_get
-#undef arena_mapbits_unzeroed_set
-#undef arena_mapbitsp_get
-#undef arena_mapbitsp_read
-#undef arena_mapbitsp_write
-#undef arena_mapp_get
-#undef arena_maxclass
+#undef arena_maxrun
+#undef arena_maybe_purge
+#undef arena_metadata_allocated_add
+#undef arena_metadata_allocated_get
+#undef arena_metadata_allocated_sub
+#undef arena_migrate
+#undef arena_miscelm_get
+#undef arena_miscelm_to_pageind
+#undef arena_miscelm_to_rpages
+#undef arena_nbound
 #undef arena_new
+#undef arena_node_alloc
+#undef arena_node_dalloc
 #undef arena_palloc
 #undef arena_postfork_child
 #undef arena_postfork_parent
 #undef arena_prefork
 #undef arena_prof_accum
 #undef arena_prof_accum_impl
 #undef arena_prof_accum_locked
-#undef arena_prof_ctx_get
-#undef arena_prof_ctx_set
 #undef arena_prof_promoted
+#undef arena_prof_tctx_get
+#undef arena_prof_tctx_reset
+#undef arena_prof_tctx_set
 #undef arena_ptr_small_binind_get
 #undef arena_purge_all
 #undef arena_quarantine_junk_small
 #undef arena_ralloc
 #undef arena_ralloc_junk_large
 #undef arena_ralloc_no_move
+#undef arena_rd_to_miscelm
 #undef arena_redzone_corruption
 #undef arena_run_regind
+#undef arena_run_to_miscelm
 #undef arena_salloc
+#undef arenas_cache_bypass_cleanup
+#undef arenas_cache_cleanup
+#undef arena_sdalloc
 #undef arena_stats_merge
 #undef arena_tcache_fill_small
-#undef arenas
-#undef arenas_booted
-#undef arenas_cleanup
-#undef arenas_extend
-#undef arenas_initialized
-#undef arenas_lock
-#undef arenas_tls
-#undef arenas_tsd
-#undef arenas_tsd_boot
-#undef arenas_tsd_cleanup_wrapper
-#undef arenas_tsd_get
-#undef arenas_tsd_get_wrapper
-#undef arenas_tsd_init_head
-#undef arenas_tsd_set
+#undef atomic_add_p
 #undef atomic_add_u
 #undef atomic_add_uint32
 #undef atomic_add_uint64
 #undef atomic_add_z
+#undef atomic_cas_p
+#undef atomic_cas_u
+#undef atomic_cas_uint32
+#undef atomic_cas_uint64
+#undef atomic_cas_z
+#undef atomic_sub_p
 #undef atomic_sub_u
 #undef atomic_sub_uint32
 #undef atomic_sub_uint64
 #undef atomic_sub_z
 #undef base_alloc
 #undef base_boot
-#undef base_calloc
-#undef base_node_alloc
-#undef base_node_dealloc
 #undef base_postfork_child
 #undef base_postfork_parent
 #undef base_prefork
+#undef base_stats_get
 #undef bitmap_full
 #undef bitmap_get
 #undef bitmap_info_init
 #undef bitmap_info_ngroups
 #undef bitmap_init
 #undef bitmap_set
 #undef bitmap_sfu
 #undef bitmap_size
 #undef bitmap_unset
+#undef bootstrap_calloc
+#undef bootstrap_free
+#undef bootstrap_malloc
 #undef bt_init
 #undef buferror
-#undef choose_arena
-#undef choose_arena_hard
-#undef chunk_alloc
+#undef chunk_alloc_base
+#undef chunk_alloc_cache
 #undef chunk_alloc_dss
 #undef chunk_alloc_mmap
+#undef chunk_alloc_wrapper
 #undef chunk_boot
-#undef chunk_dealloc
-#undef chunk_dealloc_mmap
+#undef chunk_dalloc_arena
+#undef chunk_dalloc_cache
+#undef chunk_dalloc_mmap
+#undef chunk_dalloc_wrapper
+#undef chunk_deregister
 #undef chunk_dss_boot
 #undef chunk_dss_postfork_child
 #undef chunk_dss_postfork_parent
 #undef chunk_dss_prec_get
 #undef chunk_dss_prec_set
 #undef chunk_dss_prefork
+#undef chunk_hooks_default
+#undef chunk_hooks_get
+#undef chunk_hooks_set
 #undef chunk_in_dss
+#undef chunk_lookup
 #undef chunk_npages
 #undef chunk_postfork_child
 #undef chunk_postfork_parent
 #undef chunk_prefork
-#undef chunk_unmap
-#undef chunks_mtx
-#undef chunks_rtree
+#undef chunk_purge_arena
+#undef chunk_purge_wrapper
+#undef chunk_register
 #undef chunksize
 #undef chunksize_mask
-#undef ckh_bucket_search
+#undef chunks_rtree
 #undef ckh_count
 #undef ckh_delete
-#undef ckh_evict_reloc_insert
 #undef ckh_insert
-#undef ckh_isearch
 #undef ckh_iter
 #undef ckh_new
 #undef ckh_pointer_hash
 #undef ckh_pointer_keycomp
-#undef ckh_rebuild
 #undef ckh_remove
 #undef ckh_search
 #undef ckh_string_hash
 #undef ckh_string_keycomp
-#undef ckh_try_bucket_insert
-#undef ckh_try_insert
 #undef ctl_boot
 #undef ctl_bymib
 #undef ctl_byname
 #undef ctl_nametomib
 #undef ctl_postfork_child
 #undef ctl_postfork_parent
 #undef ctl_prefork
 #undef dss_prec_names
+#undef extent_node_achunk_get
+#undef extent_node_achunk_set
+#undef extent_node_addr_get
+#undef extent_node_addr_set
+#undef extent_node_arena_get
+#undef extent_node_arena_set
+#undef extent_node_dirty_insert
+#undef extent_node_dirty_linkage_init
+#undef extent_node_dirty_remove
+#undef extent_node_init
+#undef extent_node_prof_tctx_get
+#undef extent_node_prof_tctx_set
+#undef extent_node_size_get
+#undef extent_node_size_set
+#undef extent_node_zeroed_get
+#undef extent_node_zeroed_set
+#undef extent_tree_ad_empty
 #undef extent_tree_ad_first
 #undef extent_tree_ad_insert
 #undef extent_tree_ad_iter
 #undef extent_tree_ad_iter_recurse
 #undef extent_tree_ad_iter_start
 #undef extent_tree_ad_last
@@ -163,12 +214,13 @@
 #undef extent_tree_ad_psearch
 #undef extent_tree_ad_remove
 #undef extent_tree_ad_reverse_iter
 #undef extent_tree_ad_reverse_iter_recurse
 #undef extent_tree_ad_reverse_iter_start
 #undef extent_tree_ad_search
+#undef extent_tree_szad_empty
 #undef extent_tree_szad_first
 #undef extent_tree_szad_insert
 #undef extent_tree_szad_iter
 #undef extent_tree_szad_iter_recurse
 #undef extent_tree_szad_iter_start
 #undef extent_tree_szad_last
@@ -190,80 +242,87 @@
 #undef hash_get_block_64
 #undef hash_rotl_32
 #undef hash_rotl_64
 #undef hash_x64_128
 #undef hash_x86_128
 #undef hash_x86_32
-#undef huge_allocated
-#undef huge_boot
+#undef huge_aalloc
 #undef huge_dalloc
 #undef huge_dalloc_junk
-#undef huge_dss_prec_get
 #undef huge_malloc
-#undef huge_mtx
-#undef huge_ndalloc
-#undef huge_nmalloc
 #undef huge_palloc
-#undef huge_postfork_child
-#undef huge_postfork_parent
-#undef huge_prefork
-#undef huge_prof_ctx_get
-#undef huge_prof_ctx_set
+#undef huge_prof_tctx_get
+#undef huge_prof_tctx_reset
+#undef huge_prof_tctx_set
 #undef huge_ralloc
 #undef huge_ralloc_no_move
 #undef huge_salloc
-#undef iallocm
+#undef iaalloc
+#undef iallocztm
 #undef icalloc
 #undef icalloct
 #undef idalloc
 #undef idalloct
+#undef idalloctm
 #undef imalloc
 #undef imalloct
+#undef index2size
+#undef index2size_compute
+#undef index2size_lookup
+#undef index2size_tab
+#undef in_valgrind
 #undef ipalloc
 #undef ipalloct
+#undef ipallocztm
 #undef iqalloc
-#undef iqalloct
 #undef iralloc
 #undef iralloct
 #undef iralloct_realign
 #undef isalloc
+#undef isdalloct
+#undef isqalloc
 #undef isthreaded
 #undef ivsalloc
 #undef ixalloc
 #undef jemalloc_postfork_child
 #undef jemalloc_postfork_parent
 #undef jemalloc_prefork
+#undef large_maxclass
+#undef lg_floor
 #undef malloc_cprintf
 #undef malloc_mutex_init
 #undef malloc_mutex_lock
 #undef malloc_mutex_postfork_child
 #undef malloc_mutex_postfork_parent
 #undef malloc_mutex_prefork
 #undef malloc_mutex_unlock
 #undef malloc_printf
 #undef malloc_snprintf
 #undef malloc_strtoumax
-#undef malloc_tsd_boot
+#undef malloc_tsd_boot0
+#undef malloc_tsd_boot1
 #undef malloc_tsd_cleanup_register
 #undef malloc_tsd_dalloc
 #undef malloc_tsd_malloc
 #undef malloc_tsd_no_cleanup
 #undef malloc_vcprintf
 #undef malloc_vsnprintf
 #undef malloc_write
 #undef map_bias
+#undef map_misc_offset
 #undef mb_write
 #undef mutex_boot
-#undef narenas_auto
-#undef narenas_total
+#undef narenas_cache_cleanup
 #undef narenas_total_get
 #undef ncpus
 #undef nhbins
 #undef opt_abort
 #undef opt_dss
 #undef opt_junk
+#undef opt_junk_alloc
+#undef opt_junk_free
 #undef opt_lg_chunk
 #undef opt_lg_dirty_mult
 #undef opt_lg_prof_interval
 #undef opt_lg_prof_sample
 #undef opt_lg_tcache_max
 #undef opt_narenas
@@ -271,143 +330,170 @@
 #undef opt_prof_accum
 #undef opt_prof_active
 #undef opt_prof_final
 #undef opt_prof_gdump
 #undef opt_prof_leak
 #undef opt_prof_prefix
+#undef opt_prof_thread_active_init
 #undef opt_quarantine
 #undef opt_redzone
 #undef opt_stats_print
 #undef opt_tcache
 #undef opt_utrace
-#undef opt_valgrind
 #undef opt_xmalloc
 #undef opt_zero
 #undef p2rz
+#undef pages_commit
+#undef pages_decommit
+#undef pages_map
 #undef pages_purge
+#undef pages_trim
+#undef pages_unmap
 #undef pow2_ceil
+#undef prof_active_get
+#undef prof_active_get_unlocked
+#undef prof_active_set
+#undef prof_alloc_prep
+#undef prof_alloc_rollback
 #undef prof_backtrace
 #undef prof_boot0
 #undef prof_boot1
 #undef prof_boot2
-#undef prof_bt_count
-#undef prof_ctx_get
-#undef prof_ctx_set
+#undef prof_dump_header
 #undef prof_dump_open
 #undef prof_free
+#undef prof_free_sampled_object
 #undef prof_gdump
+#undef prof_gdump_get
+#undef prof_gdump_get_unlocked
+#undef prof_gdump_set
+#undef prof_gdump_val
 #undef prof_idump
 #undef prof_interval
 #undef prof_lookup
 #undef prof_malloc
+#undef prof_malloc_sample_object
 #undef prof_mdump
 #undef prof_postfork_child
 #undef prof_postfork_parent
 #undef prof_prefork
-#undef prof_promote
 #undef prof_realloc
+#undef prof_reset
 #undef prof_sample_accum_update
 #undef prof_sample_threshold_update
-#undef prof_tdata_booted
+#undef prof_tctx_get
+#undef prof_tctx_reset
+#undef prof_tctx_set
 #undef prof_tdata_cleanup
 #undef prof_tdata_get
 #undef prof_tdata_init
-#undef prof_tdata_initialized
-#undef prof_tdata_tls
-#undef prof_tdata_tsd
-#undef prof_tdata_tsd_boot
-#undef prof_tdata_tsd_cleanup_wrapper
-#undef prof_tdata_tsd_get
-#undef prof_tdata_tsd_get_wrapper
-#undef prof_tdata_tsd_init_head
-#undef prof_tdata_tsd_set
+#undef prof_tdata_reinit
+#undef prof_thread_active_get
+#undef prof_thread_active_init_get
+#undef prof_thread_active_init_set
+#undef prof_thread_active_set
+#undef prof_thread_name_get
+#undef prof_thread_name_set
 #undef quarantine
 #undef quarantine_alloc_hook
-#undef quarantine_boot
-#undef quarantine_booted
+#undef quarantine_alloc_hook_work
 #undef quarantine_cleanup
-#undef quarantine_init
-#undef quarantine_tls
-#undef quarantine_tsd
-#undef quarantine_tsd_boot
-#undef quarantine_tsd_cleanup_wrapper
-#undef quarantine_tsd_get
-#undef quarantine_tsd_get_wrapper
-#undef quarantine_tsd_init_head
-#undef quarantine_tsd_set
 #undef register_zone
+#undef rtree_child_read
+#undef rtree_child_read_hard
+#undef rtree_child_tryread
 #undef rtree_delete
 #undef rtree_get
-#undef rtree_get_locked
 #undef rtree_new
-#undef rtree_postfork_child
-#undef rtree_postfork_parent
-#undef rtree_prefork
+#undef rtree_node_valid
 #undef rtree_set
+#undef rtree_start_level
+#undef rtree_subkey
+#undef rtree_subtree_read
+#undef rtree_subtree_read_hard
+#undef rtree_subtree_tryread
+#undef rtree_val_read
+#undef rtree_val_write
 #undef s2u
+#undef s2u_compute
+#undef s2u_lookup
 #undef sa2u
 #undef set_errno
-#undef small_size2bin
+#undef size2index
+#undef size2index_compute
+#undef size2index_lookup
+#undef size2index_tab
 #undef stats_cactive
 #undef stats_cactive_add
 #undef stats_cactive_get
 #undef stats_cactive_sub
-#undef stats_chunks
 #undef stats_print
 #undef tcache_alloc_easy
 #undef tcache_alloc_large
 #undef tcache_alloc_small
 #undef tcache_alloc_small_hard
 #undef tcache_arena_associate
 #undef tcache_arena_dissociate
+#undef tcache_arena_reassociate
 #undef tcache_bin_flush_large
 #undef tcache_bin_flush_small
 #undef tcache_bin_info
-#undef tcache_boot0
-#undef tcache_boot1
-#undef tcache_booted
+#undef tcache_boot
+#undef tcache_cleanup
 #undef tcache_create
 #undef tcache_dalloc_large
 #undef tcache_dalloc_small
-#undef tcache_destroy
-#undef tcache_enabled_booted
+#undef tcache_enabled_cleanup
 #undef tcache_enabled_get
-#undef tcache_enabled_initialized
 #undef tcache_enabled_set
-#undef tcache_enabled_tls
-#undef tcache_enabled_tsd
-#undef tcache_enabled_tsd_boot
-#undef tcache_enabled_tsd_cleanup_wrapper
-#undef tcache_enabled_tsd_get
-#undef tcache_enabled_tsd_get_wrapper
-#undef tcache_enabled_tsd_init_head
-#undef tcache_enabled_tsd_set
 #undef tcache_event
 #undef tcache_event_hard
 #undef tcache_flush
 #undef tcache_get
-#undef tcache_initialized
+#undef tcache_get_hard
 #undef tcache_maxclass
+#undef tcaches
 #undef tcache_salloc
+#undef tcaches_create
+#undef tcaches_destroy
+#undef tcaches_flush
+#undef tcaches_get
 #undef tcache_stats_merge
-#undef tcache_thread_cleanup
-#undef tcache_tls
-#undef tcache_tsd
-#undef tcache_tsd_boot
-#undef tcache_tsd_cleanup_wrapper
-#undef tcache_tsd_get
-#undef tcache_tsd_get_wrapper
-#undef tcache_tsd_init_head
-#undef tcache_tsd_set
-#undef thread_allocated_booted
-#undef thread_allocated_initialized
-#undef thread_allocated_tls
-#undef thread_allocated_tsd
-#undef thread_allocated_tsd_boot
-#undef thread_allocated_tsd_cleanup_wrapper
-#undef thread_allocated_tsd_get
-#undef thread_allocated_tsd_get_wrapper
-#undef thread_allocated_tsd_init_head
-#undef thread_allocated_tsd_set
+#undef thread_allocated_cleanup
+#undef thread_deallocated_cleanup
+#undef tsd_arena_get
+#undef tsd_arena_set
+#undef tsd_boot
+#undef tsd_boot0
+#undef tsd_boot1
+#undef tsd_booted
+#undef tsd_cleanup
+#undef tsd_cleanup_wrapper
+#undef tsd_fetch
+#undef tsd_get
+#undef tsd_wrapper_get
+#undef tsd_wrapper_set
+#undef tsd_initialized
 #undef tsd_init_check_recursion
 #undef tsd_init_finish
+#undef tsd_init_head
+#undef tsd_nominal
+#undef tsd_quarantine_get
+#undef tsd_quarantine_set
+#undef tsd_set
+#undef tsd_tcache_enabled_get
+#undef tsd_tcache_enabled_set
+#undef tsd_tcache_get
+#undef tsd_tcache_set
+#undef tsd_tls
+#undef tsd_tsd
+#undef tsd_prof_tdata_get
+#undef tsd_prof_tdata_set
+#undef tsd_thread_allocated_get
+#undef tsd_thread_allocated_set
+#undef tsd_thread_deallocated_get
+#undef tsd_thread_deallocated_set
 #undef u2rz
+#undef valgrind_freelike_block
+#undef valgrind_make_mem_defined
+#undef valgrind_make_mem_noaccess
+#undef valgrind_make_mem_undefined
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/prng.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/prng.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/prng.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/prng.h	2016-05-06 15:11:36.000000000 +0800
@@ -12,39 +12,39 @@
  *   c == Odd number (relatively prime to 2^n).
  *   m == 2^32
  *
  * See Knuth's TAOCP 3rd Ed., Vol. 2, pg. 17 for details on these constraints.
  *
  * This choice of m has the disadvantage that the quality of the bits is
- * proportional to bit position.  For example. the lowest bit has a cycle of 2,
+ * proportional to bit position.  For example, the lowest bit has a cycle of 2,
  * the next has a cycle of 4, etc.  For this reason, we prefer to use the upper
  * bits.
  *
  * Macro parameters:
  *   uint32_t r          : Result.
  *   unsigned lg_range   : (0..32], number of least significant bits to return.
  *   uint32_t state      : Seed value.
  *   const uint32_t a, c : See above discussion.
  */
 #define	prng32(r, lg_range, state, a, c) do {				\
-	assert(lg_range > 0);						\
-	assert(lg_range <= 32);						\
+	assert((lg_range) > 0);						\
+	assert((lg_range) <= 32);					\
 									\
 	r = (state * (a)) + (c);					\
 	state = r;							\
-	r >>= (32 - lg_range);						\
+	r >>= (32 - (lg_range));					\
 } while (false)
 
 /* Same as prng32(), but 64 bits of pseudo-randomness, using uint64_t. */
 #define	prng64(r, lg_range, state, a, c) do {				\
-	assert(lg_range > 0);						\
-	assert(lg_range <= 64);						\
+	assert((lg_range) > 0);						\
+	assert((lg_range) <= 64);					\
 									\
 	r = (state * (a)) + (c);					\
 	state = r;							\
-	r >>= (64 - lg_range);						\
+	r >>= (64 - (lg_range));					\
 } while (false)
 
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/prof.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/prof.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/prof.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/prof.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,13 +1,13 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
 typedef struct prof_bt_s prof_bt_t;
 typedef struct prof_cnt_s prof_cnt_t;
-typedef struct prof_thr_cnt_s prof_thr_cnt_t;
-typedef struct prof_ctx_s prof_ctx_t;
+typedef struct prof_tctx_s prof_tctx_t;
+typedef struct prof_gctx_s prof_gctx_t;
 typedef struct prof_tdata_s prof_tdata_t;
 
 /* Option defaults. */
 #ifdef JEMALLOC_PROF
 #  define PROF_PREFIX_DEFAULT		"jeprof"
 #else
@@ -20,31 +20,34 @@
  * Hard limit on stack backtrace depth.  The version of prof_backtrace() that
  * is based on __builtin_return_address() necessarily has a hard-coded number
  * of backtrace frame handlers, and should be kept in sync with this setting.
  */
 #define	PROF_BT_MAX			128
 
-/* Maximum number of backtraces to store in each per thread LRU cache. */
-#define	PROF_TCMAX			1024
-
 /* Initial hash table size. */
 #define	PROF_CKH_MINITEMS		64
 
 /* Size of memory buffer to use when writing dump files. */
 #define	PROF_DUMP_BUFSIZE		65536
 
 /* Size of stack-allocated buffer used by prof_printf(). */
 #define	PROF_PRINTF_BUFSIZE		128
 
 /*
- * Number of mutexes shared among all ctx's.  No space is allocated for these
+ * Number of mutexes shared among all gctx's.  No space is allocated for these
  * unless profiling is enabled, so it's okay to over-provision.
  */
 #define	PROF_NCTX_LOCKS			1024
 
 /*
+ * Number of mutexes shared among all tdata's.  No space is allocated for these
+ * unless profiling is enabled, so it's okay to over-provision.
+ */
+#define	PROF_NTDATA_LOCKS		256
+
+/*
  * prof_tdata pointers close to NULL are used to encode state information that
  * is used for cleaning up during thread shutdown.
  */
 #define	PROF_TDATA_STATE_REINCARNATED	((prof_tdata_t *)(uintptr_t)1)
 #define	PROF_TDATA_STATE_PURGATORY	((prof_tdata_t *)(uintptr_t)2)
 #define	PROF_TDATA_STATE_MAX		PROF_TDATA_STATE_PURGATORY
@@ -60,147 +63,192 @@
 };
 
 #ifdef JEMALLOC_PROF_LIBGCC
 /* Data structure passed to libgcc _Unwind_Backtrace() callback functions. */
 typedef struct {
 	prof_bt_t	*bt;
-	unsigned	nignore;
 	unsigned	max;
 } prof_unwind_data_t;
 #endif
 
 struct prof_cnt_s {
-	/*
-	 * Profiling counters.  An allocation/deallocation pair can operate on
-	 * different prof_thr_cnt_t objects that are linked into the same
-	 * prof_ctx_t cnts_ql, so it is possible for the cur* counters to go
-	 * negative.  In principle it is possible for the *bytes counters to
-	 * overflow/underflow, but a general solution would require something
-	 * like 128-bit counters; this implementation doesn't bother to solve
-	 * that problem.
-	 */
-	int64_t		curobjs;
-	int64_t		curbytes;
+	/* Profiling counters. */
+	uint64_t	curobjs;
+	uint64_t	curbytes;
 	uint64_t	accumobjs;
 	uint64_t	accumbytes;
 };
 
-struct prof_thr_cnt_s {
-	/* Linkage into prof_ctx_t's cnts_ql. */
-	ql_elm(prof_thr_cnt_t)	cnts_link;
-
-	/* Linkage into thread's LRU. */
-	ql_elm(prof_thr_cnt_t)	lru_link;
-
-	/*
-	 * Associated context.  If a thread frees an object that it did not
-	 * allocate, it is possible that the context is not cached in the
-	 * thread's hash table, in which case it must be able to look up the
-	 * context, insert a new prof_thr_cnt_t into the thread's hash table,
-	 * and link it into the prof_ctx_t's cnts_ql.
-	 */
-	prof_ctx_t		*ctx;
-
-	/*
-	 * Threads use memory barriers to update the counters.  Since there is
-	 * only ever one writer, the only challenge is for the reader to get a
-	 * consistent read of the counters.
-	 *
-	 * The writer uses this series of operations:
-	 *
-	 * 1) Increment epoch to an odd number.
-	 * 2) Update counters.
-	 * 3) Increment epoch to an even number.
-	 *
-	 * The reader must assure 1) that the epoch is even while it reads the
-	 * counters, and 2) that the epoch doesn't change between the time it
-	 * starts and finishes reading the counters.
+typedef enum {
+	prof_tctx_state_initializing,
+	prof_tctx_state_nominal,
+	prof_tctx_state_dumping,
+	prof_tctx_state_purgatory /* Dumper must finish destroying. */
+} prof_tctx_state_t;
+
+struct prof_tctx_s {
+	/* Thread data for thread that performed the allocation. */
+	prof_tdata_t		*tdata;
+
+	/*
+	 * Copy of tdata->thr_{uid,discrim}, necessary because tdata may be
+	 * defunct during teardown.
 	 */
-	unsigned		epoch;
+	uint64_t		thr_uid;
+	uint64_t		thr_discrim;
 
-	/* Profiling counters. */
+	/* Profiling counters, protected by tdata->lock. */
 	prof_cnt_t		cnts;
-};
 
-struct prof_ctx_s {
-	/* Associated backtrace. */
-	prof_bt_t		*bt;
+	/* Associated global context. */
+	prof_gctx_t		*gctx;
+
+	/*
+	 * UID that distinguishes multiple tctx's created by the same thread,
+	 * but coexisting in gctx->tctxs.  There are two ways that such
+	 * coexistence can occur:
+	 * - A dumper thread can cause a tctx to be retained in the purgatory
+	 *   state.
+	 * - Although a single "producer" thread must create all tctx's which
+	 *   share the same thr_uid, multiple "consumers" can each concurrently
+	 *   execute portions of prof_tctx_destroy().  prof_tctx_destroy() only
+	 *   gets called once each time cnts.cur{objs,bytes} drop to 0, but this
+	 *   threshold can be hit again before the first consumer finishes
+	 *   executing prof_tctx_destroy().
+	 */
+	uint64_t		tctx_uid;
 
-	/* Protects nlimbo, cnt_merged, and cnts_ql. */
+	/* Linkage into gctx's tctxs. */
+	rb_node(prof_tctx_t)	tctx_link;
+
+	/*
+	 * True during prof_alloc_prep()..prof_malloc_sample_object(), prevents
+	 * sample vs destroy race.
+	 */
+	bool			prepared;
+
+	/* Current dump-related state, protected by gctx->lock. */
+	prof_tctx_state_t	state;
+
+	/*
+	 * Copy of cnts snapshotted during early dump phase, protected by
+	 * dump_mtx.
+	 */
+	prof_cnt_t		dump_cnts;
+};
+typedef rb_tree(prof_tctx_t) prof_tctx_tree_t;
+
+struct prof_gctx_s {
+	/* Protects nlimbo, cnt_summed, and tctxs. */
 	malloc_mutex_t		*lock;
 
 	/*
-	 * Number of threads that currently cause this ctx to be in a state of
+	 * Number of threads that currently cause this gctx to be in a state of
 	 * limbo due to one of:
-	 *   - Initializing per thread counters associated with this ctx.
-	 *   - Preparing to destroy this ctx.
-	 *   - Dumping a heap profile that includes this ctx.
+	 *   - Initializing this gctx.
+	 *   - Initializing per thread counters associated with this gctx.
+	 *   - Preparing to destroy this gctx.
+	 *   - Dumping a heap profile that includes this gctx.
 	 * nlimbo must be 1 (single destroyer) in order to safely destroy the
-	 * ctx.
+	 * gctx.
 	 */
 	unsigned		nlimbo;
 
-	/* Temporary storage for summation during dump. */
-	prof_cnt_t		cnt_summed;
-
-	/* When threads exit, they merge their stats into cnt_merged. */
-	prof_cnt_t		cnt_merged;
-
 	/*
-	 * List of profile counters, one for each thread that has allocated in
+	 * Tree of profile counters, one for each thread that has allocated in
 	 * this context.
 	 */
-	ql_head(prof_thr_cnt_t)	cnts_ql;
+	prof_tctx_tree_t	tctxs;
+
+	/* Linkage for tree of contexts to be dumped. */
+	rb_node(prof_gctx_t)	dump_link;
+
+	/* Temporary storage for summation during dump. */
+	prof_cnt_t		cnt_summed;
+
+	/* Associated backtrace. */
+	prof_bt_t		bt;
 
-	/* Linkage for list of contexts to be dumped. */
-	ql_elm(prof_ctx_t)	dump_link;
+	/* Backtrace vector, variable size, referred to by bt. */
+	void			*vec[1];
 };
-typedef ql_head(prof_ctx_t) prof_ctx_list_t;
+typedef rb_tree(prof_gctx_t) prof_gctx_tree_t;
 
 struct prof_tdata_s {
+	malloc_mutex_t		*lock;
+
+	/* Monotonically increasing unique thread identifier. */
+	uint64_t		thr_uid;
+
 	/*
-	 * Hash of (prof_bt_t *)-->(prof_thr_cnt_t *).  Each thread keeps a
-	 * cache of backtraces, with associated thread-specific prof_thr_cnt_t
-	 * objects.  Other threads may read the prof_thr_cnt_t contents, but no
-	 * others will ever write them.
-	 *
-	 * Upon thread exit, the thread must merge all the prof_thr_cnt_t
-	 * counter data into the associated prof_ctx_t objects, and unlink/free
-	 * the prof_thr_cnt_t objects.
+	 * Monotonically increasing discriminator among tdata structures
+	 * associated with the same thr_uid.
 	 */
-	ckh_t			bt2cnt;
+	uint64_t		thr_discrim;
 
-	/* LRU for contents of bt2cnt. */
-	ql_head(prof_thr_cnt_t)	lru_ql;
+	/* Included in heap profile dumps if non-NULL. */
+	char			*thread_name;
 
-	/* Backtrace vector, used for calls to prof_backtrace(). */
-	void			**vec;
+	bool			attached;
+	bool			expired;
+
+	rb_node(prof_tdata_t)	tdata_link;
+
+	/*
+	 * Counter used to initialize prof_tctx_t's tctx_uid.  No locking is
+	 * necessary when incrementing this field, because only one thread ever
+	 * does so.
+	 */
+	uint64_t		tctx_uid_next;
+
+	/*
+	 * Hash of (prof_bt_t *)-->(prof_tctx_t *).  Each thread tracks
+	 * backtraces for which it has non-zero allocation/deallocation counters
+	 * associated with thread-specific prof_tctx_t objects.  Other threads
+	 * may write to prof_tctx_t contents when freeing associated objects.
+	 */
+	ckh_t			bt2tctx;
 
 	/* Sampling state. */
 	uint64_t		prng_state;
-	uint64_t		threshold;
-	uint64_t		accum;
+	uint64_t		bytes_until_sample;
 
 	/* State used to avoid dumping while operating on prof internals. */
 	bool			enq;
 	bool			enq_idump;
 	bool			enq_gdump;
+
+	/*
+	 * Set to true during an early dump phase for tdata's which are
+	 * currently being dumped.  New threads' tdata's have this initialized
+	 * to false so that they aren't accidentally included in later dump
+	 * phases.
+	 */
+	bool			dumping;
+
+	/*
+	 * True if profiling is active for this tdata's thread
+	 * (thread.prof.active mallctl).
+	 */
+	bool			active;
+
+	/* Temporary storage for summation during dump. */
+	prof_cnt_t		cnt_summed;
+
+	/* Backtrace vector, used for calls to prof_backtrace(). */
+	void			*vec[PROF_BT_MAX];
 };
+typedef rb_tree(prof_tdata_t) prof_tdata_tree_t;
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 extern bool	opt_prof;
-/*
- * Even if opt_prof is true, sampling can be temporarily disabled by setting
- * opt_prof_active to false.  No locking is used when updating opt_prof_active,
- * so there are no guarantees regarding how long it will take for all threads
- * to notice state changes.
- */
 extern bool	opt_prof_active;
+extern bool	opt_prof_thread_active_init;
 extern size_t	opt_lg_prof_sample;   /* Mean bytes between samples. */
 extern ssize_t	opt_lg_prof_interval; /* lg(prof_interval). */
 extern bool	opt_prof_gdump;       /* High-water memory dumping. */
 extern bool	opt_prof_final;       /* Final profile dumping. */
 extern bool	opt_prof_leak;        /* Dump leak summary at exit. */
 extern bool	opt_prof_accum;       /* Report cumulative bytes. */
@@ -208,406 +256,290 @@
     /* Minimize memory bloat for non-prof builds. */
 #ifdef JEMALLOC_PROF
     PATH_MAX +
 #endif
     1];
 
+/* Accessed via prof_active_[gs]et{_unlocked,}(). */
+extern bool	prof_active;
+
+/* Accessed via prof_gdump_[gs]et{_unlocked,}(). */
+extern bool	prof_gdump_val;
+
 /*
  * Profile dump interval, measured in bytes allocated.  Each arena triggers a
  * profile dump when it reaches this threshold.  The effect is that the
  * interval between profile dumps averages prof_interval, though the actual
  * interval between dumps will tend to be sporadic, and the interval will be a
  * maximum of approximately (prof_interval * narenas).
  */
 extern uint64_t	prof_interval;
 
 /*
- * If true, promote small sampled objects to large objects, since small run
- * headers do not have embedded profile context pointers.
+ * Initialized as opt_lg_prof_sample, and potentially modified during profiling
+ * resets.
  */
-extern bool	prof_promote;
+extern size_t	lg_prof_sample;
 
+void	prof_alloc_rollback(tsd_t *tsd, prof_tctx_t *tctx, bool updated);
+void	prof_malloc_sample_object(const void *ptr, size_t usize,
+    prof_tctx_t *tctx);
+void	prof_free_sampled_object(tsd_t *tsd, size_t usize, prof_tctx_t *tctx);
 void	bt_init(prof_bt_t *bt, void **vec);
-void	prof_backtrace(prof_bt_t *bt, unsigned nignore);
-prof_thr_cnt_t	*prof_lookup(prof_bt_t *bt);
+void	prof_backtrace(prof_bt_t *bt);
+prof_tctx_t	*prof_lookup(tsd_t *tsd, prof_bt_t *bt);
 #ifdef JEMALLOC_JET
+size_t	prof_tdata_count(void);
 size_t	prof_bt_count(void);
+const prof_cnt_t *prof_cnt_all(void);
 typedef int (prof_dump_open_t)(bool, const char *);
 extern prof_dump_open_t *prof_dump_open;
+typedef bool (prof_dump_header_t)(bool, const prof_cnt_t *);
+extern prof_dump_header_t *prof_dump_header;
 #endif
 void	prof_idump(void);
 bool	prof_mdump(const char *filename);
 void	prof_gdump(void);
-prof_tdata_t	*prof_tdata_init(void);
-void	prof_tdata_cleanup(void *arg);
+prof_tdata_t	*prof_tdata_init(tsd_t *tsd);
+prof_tdata_t	*prof_tdata_reinit(tsd_t *tsd, prof_tdata_t *tdata);
+void	prof_reset(tsd_t *tsd, size_t lg_sample);
+void	prof_tdata_cleanup(tsd_t *tsd);
+const char	*prof_thread_name_get(void);
+bool	prof_active_get(void);
+bool	prof_active_set(bool active);
+int	prof_thread_name_set(tsd_t *tsd, const char *thread_name);
+bool	prof_thread_active_get(void);
+bool	prof_thread_active_set(bool active);
+bool	prof_thread_active_init_get(void);
+bool	prof_thread_active_init_set(bool active_init);
+bool	prof_gdump_get(void);
+bool	prof_gdump_set(bool active);
 void	prof_boot0(void);
 void	prof_boot1(void);
 bool	prof_boot2(void);
 void	prof_prefork(void);
 void	prof_postfork_parent(void);
 void	prof_postfork_child(void);
+void	prof_sample_threshold_update(prof_tdata_t *tdata);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
-#define	PROF_ALLOC_PREP(nignore, size, ret) do {			\
-	prof_tdata_t *prof_tdata;					\
-	prof_bt_t bt;							\
-									\
-	assert(size == s2u(size));					\
-									\
-	prof_tdata = prof_tdata_get(true);				\
-	if ((uintptr_t)prof_tdata <= (uintptr_t)PROF_TDATA_STATE_MAX) {	\
-		if (prof_tdata != NULL)					\
-			ret = (prof_thr_cnt_t *)(uintptr_t)1U;		\
-		else							\
-			ret = NULL;					\
-		break;							\
-	}								\
-									\
-	if (opt_prof_active == false) {					\
-		/* Sampling is currently inactive, so avoid sampling. */\
-		ret = (prof_thr_cnt_t *)(uintptr_t)1U;			\
-	} else if (opt_lg_prof_sample == 0) {				\
-		/* Don't bother with sampling logic, since sampling   */\
-		/* interval is 1.                                     */\
-		bt_init(&bt, prof_tdata->vec);				\
-		prof_backtrace(&bt, nignore);				\
-		ret = prof_lookup(&bt);					\
-	} else {							\
-		if (prof_tdata->threshold == 0) {			\
-			/* Initialize.  Seed the prng differently for */\
-			/* each thread.                               */\
-			prof_tdata->prng_state =			\
-			    (uint64_t)(uintptr_t)&size;			\
-			prof_sample_threshold_update(prof_tdata);	\
-		}							\
-									\
-		/* Determine whether to capture a backtrace based on  */\
-		/* whether size is enough for prof_accum to reach     */\
-		/* prof_tdata->threshold.  However, delay updating    */\
-		/* these variables until prof_{m,re}alloc(), because  */\
-		/* we don't know for sure that the allocation will    */\
-		/* succeed.                                           */\
-		/*                                                    */\
-		/* Use subtraction rather than addition to avoid      */\
-		/* potential integer overflow.                        */\
-		if (size >= prof_tdata->threshold -			\
-		    prof_tdata->accum) {				\
-			bt_init(&bt, prof_tdata->vec);			\
-			prof_backtrace(&bt, nignore);			\
-			ret = prof_lookup(&bt);				\
-		} else							\
-			ret = (prof_thr_cnt_t *)(uintptr_t)1U;		\
-	}								\
-} while (0)
-
 #ifndef JEMALLOC_ENABLE_INLINE
-malloc_tsd_protos(JEMALLOC_ATTR(unused), prof_tdata, prof_tdata_t *)
-
-prof_tdata_t	*prof_tdata_get(bool create);
-void	prof_sample_threshold_update(prof_tdata_t *prof_tdata);
-prof_ctx_t	*prof_ctx_get(const void *ptr);
-void	prof_ctx_set(const void *ptr, size_t usize, prof_ctx_t *ctx);
-bool	prof_sample_accum_update(size_t size);
-void	prof_malloc(const void *ptr, size_t usize, prof_thr_cnt_t *cnt);
-void	prof_realloc(const void *ptr, size_t usize, prof_thr_cnt_t *cnt,
-    size_t old_usize, prof_ctx_t *old_ctx);
-void	prof_free(const void *ptr, size_t size);
+bool	prof_active_get_unlocked(void);
+bool	prof_gdump_get_unlocked(void);
+prof_tdata_t	*prof_tdata_get(tsd_t *tsd, bool create);
+bool	prof_sample_accum_update(tsd_t *tsd, size_t usize, bool commit,
+    prof_tdata_t **tdata_out);
+prof_tctx_t	*prof_alloc_prep(tsd_t *tsd, size_t usize, bool prof_active,
+    bool update);
+prof_tctx_t	*prof_tctx_get(const void *ptr);
+void	prof_tctx_set(const void *ptr, size_t usize, prof_tctx_t *tctx);
+void	prof_tctx_reset(const void *ptr, size_t usize, const void *old_ptr,
+    prof_tctx_t *tctx);
+void	prof_malloc_sample_object(const void *ptr, size_t usize,
+    prof_tctx_t *tctx);
+void	prof_malloc(const void *ptr, size_t usize, prof_tctx_t *tctx);
+void	prof_realloc(tsd_t *tsd, const void *ptr, size_t usize,
+    prof_tctx_t *tctx, bool prof_active, bool updated, const void *old_ptr,
+    size_t old_usize, prof_tctx_t *old_tctx);
+void	prof_free(tsd_t *tsd, const void *ptr, size_t usize);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_PROF_C_))
-/* Thread-specific backtrace cache, used to reduce bt2ctx contention. */
-malloc_tsd_externs(prof_tdata, prof_tdata_t *)
-malloc_tsd_funcs(JEMALLOC_INLINE, prof_tdata, prof_tdata_t *, NULL,
-    prof_tdata_cleanup)
-
-JEMALLOC_INLINE prof_tdata_t *
-prof_tdata_get(bool create)
+JEMALLOC_ALWAYS_INLINE bool
+prof_active_get_unlocked(void)
 {
-	prof_tdata_t *prof_tdata;
 
-	cassert(config_prof);
+	/*
+	 * Even if opt_prof is true, sampling can be temporarily disabled by
+	 * setting prof_active to false.  No locking is used when reading
+	 * prof_active in the fast path, so there are no guarantees regarding
+	 * how long it will take for all threads to notice state changes.
+	 */
+	return (prof_active);
+}
+
+JEMALLOC_ALWAYS_INLINE bool
+prof_gdump_get_unlocked(void)
+{
 
-	prof_tdata = *prof_tdata_tsd_get();
-	if (create && prof_tdata == NULL)
-		prof_tdata = prof_tdata_init();
-
-	return (prof_tdata);
-}
-
-JEMALLOC_INLINE void
-prof_sample_threshold_update(prof_tdata_t *prof_tdata)
-{
-	/*
-	 * The body of this function is compiled out unless heap profiling is
-	 * enabled, so that it is possible to compile jemalloc with floating
-	 * point support completely disabled.  Avoiding floating point code is
-	 * important on memory-constrained systems, but it also enables a
-	 * workaround for versions of glibc that don't properly save/restore
-	 * floating point registers during dynamic lazy symbol loading (which
-	 * internally calls into whatever malloc implementation happens to be
-	 * integrated into the application).  Note that some compilers (e.g.
-	 * gcc 4.8) may use floating point registers for fast memory moves, so
-	 * jemalloc must be compiled with such optimizations disabled (e.g.
-	 * -mno-sse) in order for the workaround to be complete.
+	/*
+	 * No locking is used when reading prof_gdump_val in the fast path, so
+	 * there are no guarantees regarding how long it will take for all
+	 * threads to notice state changes.
 	 */
-#ifdef JEMALLOC_PROF
-	uint64_t r;
-	double u;
+	return (prof_gdump_val);
+}
+
+JEMALLOC_ALWAYS_INLINE prof_tdata_t *
+prof_tdata_get(tsd_t *tsd, bool create)
+{
+	prof_tdata_t *tdata;
 
 	cassert(config_prof);
 
-	/*
-	 * Compute sample threshold as a geometrically distributed random
-	 * variable with mean (2^opt_lg_prof_sample).
-	 *
-	 *                         __        __
-	 *                         |  log(u)  |                     1
-	 * prof_tdata->threshold = | -------- |, where p = -------------------
-	 *                         | log(1-p) |             opt_lg_prof_sample
-	 *                                                 2
-	 *
-	 * For more information on the math, see:
-	 *
-	 *   Non-Uniform Random Variate Generation
-	 *   Luc Devroye
-	 *   Springer-Verlag, New York, 1986
-	 *   pp 500
-	 *   (http://luc.devroye.org/rnbookindex.html)
-	 */
-	prng64(r, 53, prof_tdata->prng_state,
-	    UINT64_C(6364136223846793005), UINT64_C(1442695040888963407));
-	u = (double)r * (1.0/9007199254740992.0L);
-	prof_tdata->threshold = (uint64_t)(log(u) /
-	    log(1.0 - (1.0 / (double)((uint64_t)1U << opt_lg_prof_sample))))
-	    + (uint64_t)1U;
-#endif
+	tdata = tsd_prof_tdata_get(tsd);
+	if (create) {
+		if (unlikely(tdata == NULL)) {
+			if (tsd_nominal(tsd)) {
+				tdata = prof_tdata_init(tsd);
+				tsd_prof_tdata_set(tsd, tdata);
+			}
+		} else if (unlikely(tdata->expired)) {
+			tdata = prof_tdata_reinit(tsd, tdata);
+			tsd_prof_tdata_set(tsd, tdata);
+		}
+		assert(tdata == NULL || tdata->attached);
+	}
+
+	return (tdata);
 }
 
-JEMALLOC_INLINE prof_ctx_t *
-prof_ctx_get(const void *ptr)
+JEMALLOC_ALWAYS_INLINE prof_tctx_t *
+prof_tctx_get(const void *ptr)
 {
-	prof_ctx_t *ret;
-	arena_chunk_t *chunk;
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	if (chunk != ptr) {
-		/* Region. */
-		ret = arena_prof_ctx_get(ptr);
-	} else
-		ret = huge_prof_ctx_get(ptr);
+	return (arena_prof_tctx_get(ptr));
+}
+
+JEMALLOC_ALWAYS_INLINE void
+prof_tctx_set(const void *ptr, size_t usize, prof_tctx_t *tctx)
+{
 
-	return (ret);
+	cassert(config_prof);
+	assert(ptr != NULL);
+
+	arena_prof_tctx_set(ptr, usize, tctx);
 }
 
-JEMALLOC_INLINE void
-prof_ctx_set(const void *ptr, size_t usize, prof_ctx_t *ctx)
+JEMALLOC_ALWAYS_INLINE void
+prof_tctx_reset(const void *ptr, size_t usize, const void *old_ptr,
+    prof_tctx_t *old_tctx)
 {
-	arena_chunk_t *chunk;
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	if (chunk != ptr) {
-		/* Region. */
-		arena_prof_ctx_set(ptr, usize, ctx);
-	} else
-		huge_prof_ctx_set(ptr, ctx);
+	arena_prof_tctx_reset(ptr, usize, old_ptr, old_tctx);
 }
 
-JEMALLOC_INLINE bool
-prof_sample_accum_update(size_t size)
+JEMALLOC_ALWAYS_INLINE bool
+prof_sample_accum_update(tsd_t *tsd, size_t usize, bool update,
+    prof_tdata_t **tdata_out)
 {
-	prof_tdata_t *prof_tdata;
+	prof_tdata_t *tdata;
 
 	cassert(config_prof);
-	/* Sampling logic is unnecessary if the interval is 1. */
-	assert(opt_lg_prof_sample != 0);
 
-	prof_tdata = prof_tdata_get(false);
-	if ((uintptr_t)prof_tdata <= (uintptr_t)PROF_TDATA_STATE_MAX)
+	tdata = prof_tdata_get(tsd, true);
+	if ((uintptr_t)tdata <= (uintptr_t)PROF_TDATA_STATE_MAX)
+		tdata = NULL;
+
+	if (tdata_out != NULL)
+		*tdata_out = tdata;
+
+	if (tdata == NULL)
 		return (true);
 
-	/* Take care to avoid integer overflow. */
-	if (size >= prof_tdata->threshold - prof_tdata->accum) {
-		prof_tdata->accum -= (prof_tdata->threshold - size);
-		/* Compute new sample threshold. */
-		prof_sample_threshold_update(prof_tdata);
-		while (prof_tdata->accum >= prof_tdata->threshold) {
-			prof_tdata->accum -= prof_tdata->threshold;
-			prof_sample_threshold_update(prof_tdata);
-		}
-		return (false);
-	} else {
-		prof_tdata->accum += size;
+	if (tdata->bytes_until_sample >= usize) {
+		if (update)
+			tdata->bytes_until_sample -= usize;
 		return (true);
+	} else {
+		/* Compute new sample threshold. */
+		if (update)
+			prof_sample_threshold_update(tdata);
+		return (!tdata->active);
+	}
+}
+
+JEMALLOC_ALWAYS_INLINE prof_tctx_t *
+prof_alloc_prep(tsd_t *tsd, size_t usize, bool prof_active, bool update)
+{
+	prof_tctx_t *ret;
+	prof_tdata_t *tdata;
+	prof_bt_t bt;
+
+	assert(usize == s2u(usize));
+
+	if (!prof_active || likely(prof_sample_accum_update(tsd, usize, update,
+	    &tdata)))
+		ret = (prof_tctx_t *)(uintptr_t)1U;
+	else {
+		bt_init(&bt, tdata->vec);
+		prof_backtrace(&bt);
+		ret = prof_lookup(tsd, &bt);
 	}
+
+	return (ret);
 }
 
-JEMALLOC_INLINE void
-prof_malloc(const void *ptr, size_t usize, prof_thr_cnt_t *cnt)
+JEMALLOC_ALWAYS_INLINE void
+prof_malloc(const void *ptr, size_t usize, prof_tctx_t *tctx)
 {
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 	assert(usize == isalloc(ptr, true));
 
-	if (opt_lg_prof_sample != 0) {
-		if (prof_sample_accum_update(usize)) {
-			/*
-			 * Don't sample.  For malloc()-like allocation, it is
-			 * always possible to tell in advance how large an
-			 * object's usable size will be, so there should never
-			 * be a difference between the usize passed to
-			 * PROF_ALLOC_PREP() and prof_malloc().
-			 */
-			assert((uintptr_t)cnt == (uintptr_t)1U);
-		}
-	}
-
-	if ((uintptr_t)cnt > (uintptr_t)1U) {
-		prof_ctx_set(ptr, usize, cnt->ctx);
+	if (unlikely((uintptr_t)tctx > (uintptr_t)1U))
+		prof_malloc_sample_object(ptr, usize, tctx);
+	else
+		prof_tctx_set(ptr, usize, (prof_tctx_t *)(uintptr_t)1U);
+}
 
-		cnt->epoch++;
-		/*********/
-		mb_write();
-		/*********/
-		cnt->cnts.curobjs++;
-		cnt->cnts.curbytes += usize;
-		if (opt_prof_accum) {
-			cnt->cnts.accumobjs++;
-			cnt->cnts.accumbytes += usize;
-		}
-		/*********/
-		mb_write();
-		/*********/
-		cnt->epoch++;
-		/*********/
-		mb_write();
-		/*********/
-	} else
-		prof_ctx_set(ptr, usize, (prof_ctx_t *)(uintptr_t)1U);
-}
-
-JEMALLOC_INLINE void
-prof_realloc(const void *ptr, size_t usize, prof_thr_cnt_t *cnt,
-    size_t old_usize, prof_ctx_t *old_ctx)
+JEMALLOC_ALWAYS_INLINE void
+prof_realloc(tsd_t *tsd, const void *ptr, size_t usize, prof_tctx_t *tctx,
+    bool prof_active, bool updated, const void *old_ptr, size_t old_usize,
+    prof_tctx_t *old_tctx)
 {
-	prof_thr_cnt_t *told_cnt;
+	bool sampled, old_sampled;
 
 	cassert(config_prof);
-	assert(ptr != NULL || (uintptr_t)cnt <= (uintptr_t)1U);
+	assert(ptr != NULL || (uintptr_t)tctx <= (uintptr_t)1U);
 
-	if (ptr != NULL) {
+	if (prof_active && !updated && ptr != NULL) {
 		assert(usize == isalloc(ptr, true));
-		if (opt_lg_prof_sample != 0) {
-			if (prof_sample_accum_update(usize)) {
-				/*
-				 * Don't sample.  The usize passed to
-				 * PROF_ALLOC_PREP() was larger than what
-				 * actually got allocated, so a backtrace was
-				 * captured for this allocation, even though
-				 * its actual usize was insufficient to cross
-				 * the sample threshold.
-				 */
-				cnt = (prof_thr_cnt_t *)(uintptr_t)1U;
-			}
-		}
-	}
-
-	if ((uintptr_t)old_ctx > (uintptr_t)1U) {
-		told_cnt = prof_lookup(old_ctx->bt);
-		if (told_cnt == NULL) {
+		if (prof_sample_accum_update(tsd, usize, true, NULL)) {
 			/*
-			 * It's too late to propagate OOM for this realloc(),
-			 * so operate directly on old_cnt->ctx->cnt_merged.
+			 * Don't sample.  The usize passed to prof_alloc_prep()
+			 * was larger than what actually got allocated, so a
+			 * backtrace was captured for this allocation, even
+			 * though its actual usize was insufficient to cross the
+			 * sample threshold.
 			 */
-			malloc_mutex_lock(old_ctx->lock);
-			old_ctx->cnt_merged.curobjs--;
-			old_ctx->cnt_merged.curbytes -= old_usize;
-			malloc_mutex_unlock(old_ctx->lock);
-			told_cnt = (prof_thr_cnt_t *)(uintptr_t)1U;
-		}
-	} else
-		told_cnt = (prof_thr_cnt_t *)(uintptr_t)1U;
-
-	if ((uintptr_t)told_cnt > (uintptr_t)1U)
-		told_cnt->epoch++;
-	if ((uintptr_t)cnt > (uintptr_t)1U) {
-		prof_ctx_set(ptr, usize, cnt->ctx);
-		cnt->epoch++;
-	} else if (ptr != NULL)
-		prof_ctx_set(ptr, usize, (prof_ctx_t *)(uintptr_t)1U);
-	/*********/
-	mb_write();
-	/*********/
-	if ((uintptr_t)told_cnt > (uintptr_t)1U) {
-		told_cnt->cnts.curobjs--;
-		told_cnt->cnts.curbytes -= old_usize;
-	}
-	if ((uintptr_t)cnt > (uintptr_t)1U) {
-		cnt->cnts.curobjs++;
-		cnt->cnts.curbytes += usize;
-		if (opt_prof_accum) {
-			cnt->cnts.accumobjs++;
-			cnt->cnts.accumbytes += usize;
+			tctx = (prof_tctx_t *)(uintptr_t)1U;
 		}
 	}
-	/*********/
-	mb_write();
-	/*********/
-	if ((uintptr_t)told_cnt > (uintptr_t)1U)
-		told_cnt->epoch++;
-	if ((uintptr_t)cnt > (uintptr_t)1U)
-		cnt->epoch++;
-	/*********/
-	mb_write(); /* Not strictly necessary. */
+
+	sampled = ((uintptr_t)tctx > (uintptr_t)1U);
+	old_sampled = ((uintptr_t)old_tctx > (uintptr_t)1U);
+
+	if (unlikely(sampled))
+		prof_malloc_sample_object(ptr, usize, tctx);
+	else
+		prof_tctx_reset(ptr, usize, old_ptr, old_tctx);
+
+	if (unlikely(old_sampled))
+		prof_free_sampled_object(tsd, old_usize, old_tctx);
 }
 
-JEMALLOC_INLINE void
-prof_free(const void *ptr, size_t size)
+JEMALLOC_ALWAYS_INLINE void
+prof_free(tsd_t *tsd, const void *ptr, size_t usize)
 {
-	prof_ctx_t *ctx = prof_ctx_get(ptr);
+	prof_tctx_t *tctx = prof_tctx_get(ptr);
 
 	cassert(config_prof);
+	assert(usize == isalloc(ptr, true));
 
-	if ((uintptr_t)ctx > (uintptr_t)1) {
-		prof_thr_cnt_t *tcnt;
-		assert(size == isalloc(ptr, true));
-		tcnt = prof_lookup(ctx->bt);
-
-		if (tcnt != NULL) {
-			tcnt->epoch++;
-			/*********/
-			mb_write();
-			/*********/
-			tcnt->cnts.curobjs--;
-			tcnt->cnts.curbytes -= size;
-			/*********/
-			mb_write();
-			/*********/
-			tcnt->epoch++;
-			/*********/
-			mb_write();
-			/*********/
-		} else {
-			/*
-			 * OOM during free() cannot be propagated, so operate
-			 * directly on cnt->ctx->cnt_merged.
-			 */
-			malloc_mutex_lock(ctx->lock);
-			ctx->cnt_merged.curobjs--;
-			ctx->cnt_merged.curbytes -= size;
-			malloc_mutex_unlock(ctx->lock);
-		}
-	}
+	if (unlikely((uintptr_t)tctx > (uintptr_t)1U))
+		prof_free_sampled_object(tsd, usize, tctx);
 }
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/public_namespace.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/public_namespace.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/public_namespace.h	2017-09-27 22:47:53.378963468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/public_namespace.h	2017-09-27 22:49:15.178960470 +0800
@@ -8,19 +8,15 @@
 #define	je_free JEMALLOC_N(free)
 #define	je_mallocx JEMALLOC_N(mallocx)
 #define	je_rallocx JEMALLOC_N(rallocx)
 #define	je_xallocx JEMALLOC_N(xallocx)
 #define	je_sallocx JEMALLOC_N(sallocx)
 #define	je_dallocx JEMALLOC_N(dallocx)
+#define	je_sdallocx JEMALLOC_N(sdallocx)
 #define	je_nallocx JEMALLOC_N(nallocx)
 #define	je_mallctl JEMALLOC_N(mallctl)
 #define	je_mallctlnametomib JEMALLOC_N(mallctlnametomib)
 #define	je_mallctlbymib JEMALLOC_N(mallctlbymib)
 #define	je_malloc_stats_print JEMALLOC_N(malloc_stats_print)
 #define	je_malloc_usable_size JEMALLOC_N(malloc_usable_size)
 #define	je_memalign JEMALLOC_N(memalign)
 #define	je_valloc JEMALLOC_N(valloc)
-#define	je_allocm JEMALLOC_N(allocm)
-#define	je_dallocm JEMALLOC_N(dallocm)
-#define	je_nallocm JEMALLOC_N(nallocm)
-#define	je_rallocm JEMALLOC_N(rallocm)
-#define	je_sallocm JEMALLOC_N(sallocm)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/public_symbols.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/public_symbols.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/public_symbols.txt	2017-09-27 22:47:53.350963469 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/public_symbols.txt	2017-09-27 22:49:15.154960471 +0800
@@ -8,19 +8,15 @@
 free:je_free
 mallocx:je_mallocx
 rallocx:je_rallocx
 xallocx:je_xallocx
 sallocx:je_sallocx
 dallocx:je_dallocx
+sdallocx:je_sdallocx
 nallocx:je_nallocx
 mallctl:je_mallctl
 mallctlnametomib:je_mallctlnametomib
 mallctlbymib:je_mallctlbymib
 malloc_stats_print:je_malloc_stats_print
 malloc_usable_size:je_malloc_usable_size
 memalign:je_memalign
 valloc:je_valloc
-allocm:je_allocm
-dallocm:je_dallocm
-nallocm:je_nallocm
-rallocm:je_rallocm
-sallocm:je_sallocm
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/public_unnamespace.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/public_unnamespace.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/public_unnamespace.h	2017-09-27 22:47:53.406963467 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/public_unnamespace.h	2017-09-27 22:49:15.202960470 +0800
@@ -8,19 +8,15 @@
 #undef je_free
 #undef je_mallocx
 #undef je_rallocx
 #undef je_xallocx
 #undef je_sallocx
 #undef je_dallocx
+#undef je_sdallocx
 #undef je_nallocx
 #undef je_mallctl
 #undef je_mallctlnametomib
 #undef je_mallctlbymib
 #undef je_malloc_stats_print
 #undef je_malloc_usable_size
 #undef je_memalign
 #undef je_valloc
-#undef je_allocm
-#undef je_dallocm
-#undef je_nallocm
-#undef je_rallocm
-#undef je_sallocm
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/ql.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/ql.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/ql.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/ql.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,9 +1,7 @@
-/*
- * List definitions.
- */
+/* List definitions. */
 #define	ql_head(a_type)							\
 struct {								\
 	a_type *qlh_first;						\
 }
 
 #define	ql_head_initializer(a_head) {NULL}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/qr.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/qr.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/qr.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/qr.h	2016-05-06 15:11:36.000000000 +0800
@@ -37,14 +37,16 @@
 	(a_qr_b)->a_field.qre_prev->a_field.qre_next = (a_qr_a);	\
 	t = (a_qr_a)->a_field.qre_prev;					\
 	(a_qr_a)->a_field.qre_prev = (a_qr_b)->a_field.qre_prev;	\
 	(a_qr_b)->a_field.qre_prev = t;					\
 } while (0)
 
-/* qr_meld() and qr_split() are functionally equivalent, so there's no need to
- * have two copies of the code. */
+/*
+ * qr_meld() and qr_split() are functionally equivalent, so there's no need to
+ * have two copies of the code.
+ */
 #define	qr_split(a_qr_a, a_qr_b, a_field)				\
 	qr_meld((a_qr_a), (a_qr_b), a_field)
 
 #define	qr_remove(a_qr, a_field) do {					\
 	(a_qr)->a_field.qre_prev->a_field.qre_next			\
 	    = (a_qr)->a_field.qre_next;					\
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/quarantine.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/quarantine.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/quarantine.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/quarantine.h	2016-05-06 15:11:36.000000000 +0800
@@ -26,42 +26,35 @@
 };
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-quarantine_t	*quarantine_init(size_t lg_maxobjs);
-void	quarantine(void *ptr);
-void	quarantine_cleanup(void *arg);
-bool	quarantine_boot(void);
+void	quarantine_alloc_hook_work(tsd_t *tsd);
+void	quarantine(tsd_t *tsd, void *ptr);
+void	quarantine_cleanup(tsd_t *tsd);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
-malloc_tsd_protos(JEMALLOC_ATTR(unused), quarantine, quarantine_t *)
-
 void	quarantine_alloc_hook(void);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_QUARANTINE_C_))
-malloc_tsd_externs(quarantine, quarantine_t *)
-malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, quarantine, quarantine_t *, NULL,
-    quarantine_cleanup)
-
 JEMALLOC_ALWAYS_INLINE void
 quarantine_alloc_hook(void)
 {
-	quarantine_t *quarantine;
+	tsd_t *tsd;
 
 	assert(config_fill && opt_quarantine);
 
-	quarantine = *quarantine_tsd_get();
-	if (quarantine == NULL)
-		quarantine_init(LG_MAXOBJS_INIT);
+	tsd = tsd_fetch();
+	if (tsd_quarantine_get(tsd) == NULL)
+		quarantine_alloc_hook_work(tsd);
 }
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/rb.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/rb.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/rb.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/rb.h	2016-05-06 15:11:36.000000000 +0800
@@ -155,12 +155,14 @@
  * functions generated by an equivalently parameterized call to rb_gen().
  */
 
 #define	rb_proto(a_attr, a_prefix, a_rbt_type, a_type)			\
 a_attr void								\
 a_prefix##new(a_rbt_type *rbtree);					\
+a_attr bool								\
+a_prefix##empty(a_rbt_type *rbtree);					\
 a_attr a_type *								\
 a_prefix##first(a_rbt_type *rbtree);					\
 a_attr a_type *								\
 a_prefix##last(a_rbt_type *rbtree);					\
 a_attr a_type *								\
 a_prefix##next(a_rbt_type *rbtree, a_type *node);			\
@@ -195,13 +197,13 @@
  *   a_type    : Type for red-black tree node data structure (ex: ex_node_t).
  *   a_field   : Name of red-black tree node linkage (ex: ex_link).
  *   a_cmp     : Node comparison function name, with the following prototype:
  *                 int (a_cmp *)(a_type *a_node, a_type *a_other);
  *                                       ^^^^^^
  *                                    or a_key
- *               Interpretation of comparision function return values:
+ *               Interpretation of comparison function return values:
  *                 -1 : a_node <  a_other
  *                  0 : a_node == a_other
  *                  1 : a_node >  a_other
  *               In all cases, the a_node or a_key macro argument is the first
  *               argument to the comparison function, which makes it possible
  *               to write comparison functions that treat the first argument
@@ -221,12 +223,19 @@
  *   static void
  *   ex_new(ex_t *tree);
  *       Description: Initialize a red-black tree structure.
  *       Args:
  *         tree: Pointer to an uninitialized red-black tree object.
  *
+ *   static bool
+ *   ex_empty(ex_t *tree);
+ *       Description: Determine whether tree is empty.
+ *       Args:
+ *         tree: Pointer to an initialized red-black tree object.
+ *       Ret: True if tree is empty, false otherwise.
+ *
  *   static ex_node_t *
  *   ex_first(ex_t *tree);
  *   static ex_node_t *
  *   ex_last(ex_t *tree);
  *       Description: Get the first/last node in tree.
  *       Args:
@@ -306,12 +315,16 @@
  */
 #define	rb_gen(a_attr, a_prefix, a_rbt_type, a_type, a_field, a_cmp)	\
 a_attr void								\
 a_prefix##new(a_rbt_type *rbtree) {					\
     rb_new(a_type, a_field, rbtree);					\
 }									\
+a_attr bool								\
+a_prefix##empty(a_rbt_type *rbtree) {					\
+    return (rbtree->rbt_root == &rbtree->rbt_nil);			\
+}									\
 a_attr a_type *								\
 a_prefix##first(a_rbt_type *rbtree) {					\
     a_type *ret;							\
     rbtn_first(a_type, a_field, rbtree, rbtree->rbt_root, ret);		\
     if (ret == &rbtree->rbt_nil) {					\
 	ret = NULL;							\
@@ -577,13 +590,13 @@
 	}								\
     } else {								\
 	a_type *left = rbtn_left_get(a_type, a_field, node);		\
 	if (left != &rbtree->rbt_nil) {					\
 	    /* node has no successor, but it has a left child.        */\
 	    /* Splice node out, without losing the left child.        */\
-	    assert(rbtn_red_get(a_type, a_field, node) == false);	\
+	    assert(!rbtn_red_get(a_type, a_field, node));		\
 	    assert(rbtn_red_get(a_type, a_field, left));		\
 	    rbtn_black_set(a_type, a_field, left);			\
 	    if (pathp == path) {					\
 		rbtree->rbt_root = left;				\
 	    } else {							\
 		if (pathp[-1].cmp < 0) {				\
@@ -613,14 +626,13 @@
     pathp->node = &rbtree->rbt_nil;					\
     for (pathp--; (uintptr_t)pathp >= (uintptr_t)path; pathp--) {	\
 	assert(pathp->cmp != 0);					\
 	if (pathp->cmp < 0) {						\
 	    rbtn_left_set(a_type, a_field, pathp->node,			\
 	      pathp[1].node);						\
-	    assert(rbtn_red_get(a_type, a_field, pathp[1].node)		\
-	      == false);						\
+	    assert(!rbtn_red_get(a_type, a_field, pathp[1].node));	\
 	    if (rbtn_red_get(a_type, a_field, pathp->node)) {		\
 		a_type *right = rbtn_right_get(a_type, a_field,		\
 		  pathp->node);						\
 		a_type *rightleft = rbtn_left_get(a_type, a_field,	\
 		  right);						\
 		a_type *tnode;						\
@@ -678,13 +690,13 @@
 		    rbtn_black_set(a_type, a_field, rightleft);		\
 		    rbtn_rotate_right(a_type, a_field, right, tnode);	\
 		    rbtn_right_set(a_type, a_field, pathp->node, tnode);\
 		    rbtn_rotate_left(a_type, a_field, pathp->node,	\
 		      tnode);						\
 		    /* Balance restored, but rotation modified        */\
-		    /* subree root, which may actually be the tree    */\
+		    /* subtree root, which may actually be the tree   */\
 		    /* root.                                          */\
 		    if (pathp == path) {				\
 			/* Set root. */					\
 			rbtree->rbt_root = tnode;			\
 		    } else {						\
 			if (pathp[-1].cmp < 0) {			\
@@ -846,13 +858,13 @@
 		}							\
 	    }								\
 	}								\
     }									\
     /* Set root. */							\
     rbtree->rbt_root = path->node;					\
-    assert(rbtn_red_get(a_type, a_field, rbtree->rbt_root) == false);	\
+    assert(!rbtn_red_get(a_type, a_field, rbtree->rbt_root));		\
 }									\
 a_attr a_type *								\
 a_prefix##iter_recurse(a_rbt_type *rbtree, a_type *node,		\
   a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
     if (node == &rbtree->rbt_nil) {					\
 	return (&rbtree->rbt_nil);					\
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/rtree.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/rtree.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/rtree.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/rtree.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,172 +1,294 @@
 /*
  * This radix tree implementation is tailored to the singular purpose of
- * tracking which chunks are currently owned by jemalloc.  This functionality
- * is mandatory for OS X, where jemalloc must be able to respond to object
- * ownership queries.
+ * associating metadata with chunks that are currently owned by jemalloc.
  *
  *******************************************************************************
  */
 #ifdef JEMALLOC_H_TYPES
 
+typedef struct rtree_node_elm_s rtree_node_elm_t;
+typedef struct rtree_level_s rtree_level_t;
 typedef struct rtree_s rtree_t;
 
 /*
- * Size of each radix tree node (must be a power of 2).  This impacts tree
- * depth.
+ * RTREE_BITS_PER_LEVEL must be a power of two that is no larger than the
+ * machine address width.
  */
-#define	RTREE_NODESIZE (1U << 16)
+#define	LG_RTREE_BITS_PER_LEVEL	4
+#define	RTREE_BITS_PER_LEVEL	(ZU(1) << LG_RTREE_BITS_PER_LEVEL)
+#define	RTREE_HEIGHT_MAX						\
+    ((ZU(1) << (LG_SIZEOF_PTR+3)) / RTREE_BITS_PER_LEVEL)
 
-typedef void *(rtree_alloc_t)(size_t);
-typedef void (rtree_dalloc_t)(void *);
+/* Used for two-stage lock-free node initialization. */
+#define	RTREE_NODE_INITIALIZING	((rtree_node_elm_t *)0x1)
+
+/*
+ * The node allocation callback function's argument is the number of contiguous
+ * rtree_node_elm_t structures to allocate, and the resulting memory must be
+ * zeroed.
+ */
+typedef rtree_node_elm_t *(rtree_node_alloc_t)(size_t);
+typedef void (rtree_node_dalloc_t)(rtree_node_elm_t *);
 
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
 
+struct rtree_node_elm_s {
+	union {
+		void			*pun;
+		rtree_node_elm_t	*child;
+		extent_node_t		*val;
+	};
+};
+
+struct rtree_level_s {
+	/*
+	 * A non-NULL subtree points to a subtree rooted along the hypothetical
+	 * path to the leaf node corresponding to key 0.  Depending on what keys
+	 * have been used to store to the tree, an arbitrary combination of
+	 * subtree pointers may remain NULL.
+	 *
+	 * Suppose keys comprise 48 bits, and LG_RTREE_BITS_PER_LEVEL is 4.
+	 * This results in a 3-level tree, and the leftmost leaf can be directly
+	 * accessed via subtrees[2], the subtree prefixed by 0x0000 (excluding
+	 * 0x00000000) can be accessed via subtrees[1], and the remainder of the
+	 * tree can be accessed via subtrees[0].
+	 *
+	 *   levels[0] : [<unused> | 0x0001******** | 0x0002******** | ...]
+	 *
+	 *   levels[1] : [<unused> | 0x00000001**** | 0x00000002**** | ... ]
+	 *
+	 *   levels[2] : [val(0x000000000000) | val(0x000000000001) | ...]
+	 *
+	 * This has practical implications on x64, which currently uses only the
+	 * lower 47 bits of virtual address space in userland, thus leaving
+	 * subtrees[0] unused and avoiding a level of tree traversal.
+	 */
+	union {
+		void			*subtree_pun;
+		rtree_node_elm_t	*subtree;
+	};
+	/* Number of key bits distinguished by this level. */
+	unsigned		bits;
+	/*
+	 * Cumulative number of key bits distinguished by traversing to
+	 * corresponding tree level.
+	 */
+	unsigned		cumbits;
+};
+
 struct rtree_s {
-	rtree_alloc_t	*alloc;
-	rtree_dalloc_t	*dalloc;
-	malloc_mutex_t	mutex;
-	void		**root;
-	unsigned	height;
-	unsigned	level2bits[1]; /* Dynamically sized. */
+	rtree_node_alloc_t	*alloc;
+	rtree_node_dalloc_t	*dalloc;
+	unsigned		height;
+	/*
+	 * Precomputed table used to convert from the number of leading 0 key
+	 * bits to which subtree level to start at.
+	 */
+	unsigned		start_level[RTREE_HEIGHT_MAX];
+	rtree_level_t		levels[RTREE_HEIGHT_MAX];
 };
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-rtree_t	*rtree_new(unsigned bits, rtree_alloc_t *alloc, rtree_dalloc_t *dalloc);
+bool rtree_new(rtree_t *rtree, unsigned bits, rtree_node_alloc_t *alloc,
+    rtree_node_dalloc_t *dalloc);
 void	rtree_delete(rtree_t *rtree);
-void	rtree_prefork(rtree_t *rtree);
-void	rtree_postfork_parent(rtree_t *rtree);
-void	rtree_postfork_child(rtree_t *rtree);
+rtree_node_elm_t	*rtree_subtree_read_hard(rtree_t *rtree,
+    unsigned level);
+rtree_node_elm_t	*rtree_child_read_hard(rtree_t *rtree,
+    rtree_node_elm_t *elm, unsigned level);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
-#ifdef JEMALLOC_DEBUG
-uint8_t rtree_get_locked(rtree_t *rtree, uintptr_t key);
-#endif
-uint8_t	rtree_get(rtree_t *rtree, uintptr_t key);
-bool	rtree_set(rtree_t *rtree, uintptr_t key, uint8_t val);
+unsigned	rtree_start_level(rtree_t *rtree, uintptr_t key);
+uintptr_t	rtree_subkey(rtree_t *rtree, uintptr_t key, unsigned level);
+
+bool	rtree_node_valid(rtree_node_elm_t *node);
+rtree_node_elm_t	*rtree_child_tryread(rtree_node_elm_t *elm);
+rtree_node_elm_t	*rtree_child_read(rtree_t *rtree, rtree_node_elm_t *elm,
+    unsigned level);
+extent_node_t	*rtree_val_read(rtree_t *rtree, rtree_node_elm_t *elm,
+    bool dependent);
+void	rtree_val_write(rtree_t *rtree, rtree_node_elm_t *elm,
+    const extent_node_t *val);
+rtree_node_elm_t	*rtree_subtree_tryread(rtree_t *rtree, unsigned level);
+rtree_node_elm_t	*rtree_subtree_read(rtree_t *rtree, unsigned level);
+
+extent_node_t	*rtree_get(rtree_t *rtree, uintptr_t key, bool dependent);
+bool	rtree_set(rtree_t *rtree, uintptr_t key, const extent_node_t *val);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_RTREE_C_))
-#define	RTREE_GET_GENERATE(f)						\
-/* The least significant bits of the key are ignored. */		\
-JEMALLOC_INLINE uint8_t							\
-f(rtree_t *rtree, uintptr_t key)					\
-{									\
-	uint8_t ret;							\
-	uintptr_t subkey;						\
-	unsigned i, lshift, height, bits;				\
-	void **node, **child;						\
-									\
-	RTREE_LOCK(&rtree->mutex);					\
-	for (i = lshift = 0, height = rtree->height, node = rtree->root;\
-	    i < height - 1;						\
-	    i++, lshift += bits, node = child) {			\
-		bits = rtree->level2bits[i];				\
-		subkey = (key << lshift) >> ((ZU(1) << (LG_SIZEOF_PTR +	\
-		    3)) - bits);					\
-		child = (void**)node[subkey];				\
-		if (child == NULL) {					\
-			RTREE_UNLOCK(&rtree->mutex);			\
-			return (0);					\
-		}							\
-	}								\
-									\
-	/*								\
-	 * node is a leaf, so it contains values rather than node	\
-	 * pointers.							\
-	 */								\
-	bits = rtree->level2bits[i];					\
-	subkey = (key << lshift) >> ((ZU(1) << (LG_SIZEOF_PTR+3)) -	\
-	    bits);							\
-	{								\
-		uint8_t *leaf = (uint8_t *)node;			\
-		ret = leaf[subkey];					\
-	}								\
-	RTREE_UNLOCK(&rtree->mutex);					\
-									\
-	RTREE_GET_VALIDATE						\
-	return (ret);							\
-}
-
-#ifdef JEMALLOC_DEBUG
-#  define RTREE_LOCK(l)		malloc_mutex_lock(l)
-#  define RTREE_UNLOCK(l)	malloc_mutex_unlock(l)
-#  define RTREE_GET_VALIDATE
-RTREE_GET_GENERATE(rtree_get_locked)
-#  undef RTREE_LOCK
-#  undef RTREE_UNLOCK
-#  undef RTREE_GET_VALIDATE
-#endif
+JEMALLOC_INLINE unsigned
+rtree_start_level(rtree_t *rtree, uintptr_t key)
+{
+	unsigned start_level;
 
-#define	RTREE_LOCK(l)
-#define	RTREE_UNLOCK(l)
-#ifdef JEMALLOC_DEBUG
-   /*
-    * Suppose that it were possible for a jemalloc-allocated chunk to be
-    * munmap()ped, followed by a different allocator in another thread re-using
-    * overlapping virtual memory, all without invalidating the cached rtree
-    * value.  The result would be a false positive (the rtree would claim that
-    * jemalloc owns memory that it had actually discarded).  This scenario
-    * seems impossible, but the following assertion is a prudent sanity check.
-    */
-#  define RTREE_GET_VALIDATE						\
-	assert(rtree_get_locked(rtree, key) == ret);
-#else
-#  define RTREE_GET_VALIDATE
-#endif
-RTREE_GET_GENERATE(rtree_get)
-#undef RTREE_LOCK
-#undef RTREE_UNLOCK
-#undef RTREE_GET_VALIDATE
+	if (unlikely(key == 0))
+		return (rtree->height - 1);
+
+	start_level = rtree->start_level[lg_floor(key) >>
+	    LG_RTREE_BITS_PER_LEVEL];
+	assert(start_level < rtree->height);
+	return (start_level);
+}
+
+JEMALLOC_INLINE uintptr_t
+rtree_subkey(rtree_t *rtree, uintptr_t key, unsigned level)
+{
+
+	return ((key >> ((ZU(1) << (LG_SIZEOF_PTR+3)) -
+	    rtree->levels[level].cumbits)) & ((ZU(1) <<
+	    rtree->levels[level].bits) - 1));
+}
 
 JEMALLOC_INLINE bool
-rtree_set(rtree_t *rtree, uintptr_t key, uint8_t val)
+rtree_node_valid(rtree_node_elm_t *node)
+{
+
+	return ((uintptr_t)node > (uintptr_t)RTREE_NODE_INITIALIZING);
+}
+
+JEMALLOC_INLINE rtree_node_elm_t *
+rtree_child_tryread(rtree_node_elm_t *elm)
+{
+	rtree_node_elm_t *child;
+
+	/* Double-checked read (first read may be stale. */
+	child = elm->child;
+	if (!rtree_node_valid(child))
+		child = atomic_read_p(&elm->pun);
+	return (child);
+}
+
+JEMALLOC_INLINE rtree_node_elm_t *
+rtree_child_read(rtree_t *rtree, rtree_node_elm_t *elm, unsigned level)
+{
+	rtree_node_elm_t *child;
+
+	child = rtree_child_tryread(elm);
+	if (unlikely(!rtree_node_valid(child)))
+		child = rtree_child_read_hard(rtree, elm, level);
+	return (child);
+}
+
+JEMALLOC_INLINE extent_node_t *
+rtree_val_read(rtree_t *rtree, rtree_node_elm_t *elm, bool dependent)
+{
+
+	if (dependent) {
+		/*
+		 * Reading a val on behalf of a pointer to a valid allocation is
+		 * guaranteed to be a clean read even without synchronization,
+		 * because the rtree update became visible in memory before the
+		 * pointer came into existence.
+		 */
+		return (elm->val);
+	} else {
+		/*
+		 * An arbitrary read, e.g. on behalf of ivsalloc(), may not be
+		 * dependent on a previous rtree write, which means a stale read
+		 * could result if synchronization were omitted here.
+		 */
+		return (atomic_read_p(&elm->pun));
+	}
+}
+
+JEMALLOC_INLINE void
+rtree_val_write(rtree_t *rtree, rtree_node_elm_t *elm, const extent_node_t *val)
+{
+
+	atomic_write_p(&elm->pun, val);
+}
+
+JEMALLOC_INLINE rtree_node_elm_t *
+rtree_subtree_tryread(rtree_t *rtree, unsigned level)
+{
+	rtree_node_elm_t *subtree;
+
+	/* Double-checked read (first read may be stale. */
+	subtree = rtree->levels[level].subtree;
+	if (!rtree_node_valid(subtree))
+		subtree = atomic_read_p(&rtree->levels[level].subtree_pun);
+	return (subtree);
+}
+
+JEMALLOC_INLINE rtree_node_elm_t *
+rtree_subtree_read(rtree_t *rtree, unsigned level)
+{
+	rtree_node_elm_t *subtree;
+
+	subtree = rtree_subtree_tryread(rtree, level);
+	if (unlikely(!rtree_node_valid(subtree)))
+		subtree = rtree_subtree_read_hard(rtree, level);
+	return (subtree);
+}
+
+JEMALLOC_INLINE extent_node_t *
+rtree_get(rtree_t *rtree, uintptr_t key, bool dependent)
 {
 	uintptr_t subkey;
-	unsigned i, lshift, height, bits;
-	void **node, **child;
+	unsigned i, start_level;
+	rtree_node_elm_t *node, *child;
+
+	start_level = rtree_start_level(rtree, key);
 
-	malloc_mutex_lock(&rtree->mutex);
-	for (i = lshift = 0, height = rtree->height, node = rtree->root;
-	    i < height - 1;
-	    i++, lshift += bits, node = child) {
-		bits = rtree->level2bits[i];
-		subkey = (key << lshift) >> ((ZU(1) << (LG_SIZEOF_PTR+3)) -
-		    bits);
-		child = (void**)node[subkey];
-		if (child == NULL) {
-			size_t size = ((i + 1 < height - 1) ? sizeof(void *)
-			    : (sizeof(uint8_t))) << rtree->level2bits[i+1];
-			child = (void**)rtree->alloc(size);
-			if (child == NULL) {
-				malloc_mutex_unlock(&rtree->mutex);
-				return (true);
-			}
-			memset(child, 0, size);
-			node[subkey] = child;
+	for (i = start_level, node = rtree_subtree_tryread(rtree, start_level);
+	    /**/; i++, node = child) {
+		if (!dependent && unlikely(!rtree_node_valid(node)))
+			return (NULL);
+		subkey = rtree_subkey(rtree, key, i);
+		if (i == rtree->height - 1) {
+			/*
+			 * node is a leaf, so it contains values rather than
+			 * child pointers.
+			 */
+			return (rtree_val_read(rtree, &node[subkey],
+			    dependent));
 		}
+		assert(i < rtree->height - 1);
+		child = rtree_child_tryread(&node[subkey]);
 	}
+	not_reached();
+}
 
-	/* node is a leaf, so it contains values rather than node pointers. */
-	bits = rtree->level2bits[i];
-	subkey = (key << lshift) >> ((ZU(1) << (LG_SIZEOF_PTR+3)) - bits);
-	{
-		uint8_t *leaf = (uint8_t *)node;
-		leaf[subkey] = val;
-	}
-	malloc_mutex_unlock(&rtree->mutex);
+JEMALLOC_INLINE bool
+rtree_set(rtree_t *rtree, uintptr_t key, const extent_node_t *val)
+{
+	uintptr_t subkey;
+	unsigned i, start_level;
+	rtree_node_elm_t *node, *child;
 
-	return (false);
+	start_level = rtree_start_level(rtree, key);
+
+	node = rtree_subtree_read(rtree, start_level);
+	if (node == NULL)
+		return (true);
+	for (i = start_level; /**/; i++, node = child) {
+		subkey = rtree_subkey(rtree, key, i);
+		if (i == rtree->height - 1) {
+			/*
+			 * node is a leaf, so it contains values rather than
+			 * child pointers.
+			 */
+			rtree_val_write(rtree, &node[subkey], val);
+			return (false);
+		}
+		assert(i + 1 < rtree->height);
+		child = rtree_child_read(rtree, &node[subkey], i);
+		if (child == NULL)
+			return (true);
+	}
+	not_reached();
 }
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/size_classes.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/size_classes.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/size_classes.h	2017-09-27 22:47:53.414963467 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/size_classes.h	2017-09-27 22:49:15.346960464 +0800
@@ -1,705 +1,1435 @@
 /* This file was automatically generated by size_classes.sh. */
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)
-#define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	8,	24)					\
-    SIZE_CLASS(3,	8,	32)					\
-    SIZE_CLASS(4,	8,	40)					\
-    SIZE_CLASS(5,	8,	48)					\
-    SIZE_CLASS(6,	8,	56)					\
-    SIZE_CLASS(7,	8,	64)					\
-    SIZE_CLASS(8,	16,	80)					\
-    SIZE_CLASS(9,	16,	96)					\
-    SIZE_CLASS(10,	16,	112)					\
-    SIZE_CLASS(11,	16,	128)					\
-    SIZE_CLASS(12,	32,	160)					\
-    SIZE_CLASS(13,	32,	192)					\
-    SIZE_CLASS(14,	32,	224)					\
-    SIZE_CLASS(15,	32,	256)					\
-    SIZE_CLASS(16,	64,	320)					\
-    SIZE_CLASS(17,	64,	384)					\
-    SIZE_CLASS(18,	64,	448)					\
-    SIZE_CLASS(19,	64,	512)					\
-    SIZE_CLASS(20,	128,	640)					\
-    SIZE_CLASS(21,	128,	768)					\
-    SIZE_CLASS(22,	128,	896)					\
-    SIZE_CLASS(23,	128,	1024)					\
-    SIZE_CLASS(24,	256,	1280)					\
-    SIZE_CLASS(25,	256,	1536)					\
-    SIZE_CLASS(26,	256,	1792)					\
-    SIZE_CLASS(27,	256,	2048)					\
-    SIZE_CLASS(28,	512,	2560)					\
-    SIZE_CLASS(29,	512,	3072)					\
-    SIZE_CLASS(30,	512,	3584)					\
-
-#define	NBINS		31
-#define	SMALL_MAXCLASS	3584
-#endif
-
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 13)
-#define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	8,	24)					\
-    SIZE_CLASS(3,	8,	32)					\
-    SIZE_CLASS(4,	8,	40)					\
-    SIZE_CLASS(5,	8,	48)					\
-    SIZE_CLASS(6,	8,	56)					\
-    SIZE_CLASS(7,	8,	64)					\
-    SIZE_CLASS(8,	16,	80)					\
-    SIZE_CLASS(9,	16,	96)					\
-    SIZE_CLASS(10,	16,	112)					\
-    SIZE_CLASS(11,	16,	128)					\
-    SIZE_CLASS(12,	32,	160)					\
-    SIZE_CLASS(13,	32,	192)					\
-    SIZE_CLASS(14,	32,	224)					\
-    SIZE_CLASS(15,	32,	256)					\
-    SIZE_CLASS(16,	64,	320)					\
-    SIZE_CLASS(17,	64,	384)					\
-    SIZE_CLASS(18,	64,	448)					\
-    SIZE_CLASS(19,	64,	512)					\
-    SIZE_CLASS(20,	128,	640)					\
-    SIZE_CLASS(21,	128,	768)					\
-    SIZE_CLASS(22,	128,	896)					\
-    SIZE_CLASS(23,	128,	1024)					\
-    SIZE_CLASS(24,	256,	1280)					\
-    SIZE_CLASS(25,	256,	1536)					\
-    SIZE_CLASS(26,	256,	1792)					\
-    SIZE_CLASS(27,	256,	2048)					\
-    SIZE_CLASS(28,	512,	2560)					\
-    SIZE_CLASS(29,	512,	3072)					\
-    SIZE_CLASS(30,	512,	3584)					\
-    SIZE_CLASS(31,	512,	4096)					\
-    SIZE_CLASS(32,	1024,	5120)					\
-    SIZE_CLASS(33,	1024,	6144)					\
-    SIZE_CLASS(34,	1024,	7168)					\
-
-#define	NBINS		35
-#define	SMALL_MAXCLASS	7168
-#endif
-
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 14)
-#define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	8,	24)					\
-    SIZE_CLASS(3,	8,	32)					\
-    SIZE_CLASS(4,	8,	40)					\
-    SIZE_CLASS(5,	8,	48)					\
-    SIZE_CLASS(6,	8,	56)					\
-    SIZE_CLASS(7,	8,	64)					\
-    SIZE_CLASS(8,	16,	80)					\
-    SIZE_CLASS(9,	16,	96)					\
-    SIZE_CLASS(10,	16,	112)					\
-    SIZE_CLASS(11,	16,	128)					\
-    SIZE_CLASS(12,	32,	160)					\
-    SIZE_CLASS(13,	32,	192)					\
-    SIZE_CLASS(14,	32,	224)					\
-    SIZE_CLASS(15,	32,	256)					\
-    SIZE_CLASS(16,	64,	320)					\
-    SIZE_CLASS(17,	64,	384)					\
-    SIZE_CLASS(18,	64,	448)					\
-    SIZE_CLASS(19,	64,	512)					\
-    SIZE_CLASS(20,	128,	640)					\
-    SIZE_CLASS(21,	128,	768)					\
-    SIZE_CLASS(22,	128,	896)					\
-    SIZE_CLASS(23,	128,	1024)					\
-    SIZE_CLASS(24,	256,	1280)					\
-    SIZE_CLASS(25,	256,	1536)					\
-    SIZE_CLASS(26,	256,	1792)					\
-    SIZE_CLASS(27,	256,	2048)					\
-    SIZE_CLASS(28,	512,	2560)					\
-    SIZE_CLASS(29,	512,	3072)					\
-    SIZE_CLASS(30,	512,	3584)					\
-    SIZE_CLASS(31,	512,	4096)					\
-    SIZE_CLASS(32,	1024,	5120)					\
-    SIZE_CLASS(33,	1024,	6144)					\
-    SIZE_CLASS(34,	1024,	7168)					\
-    SIZE_CLASS(35,	1024,	8192)					\
-    SIZE_CLASS(36,	2048,	10240)					\
-    SIZE_CLASS(37,	2048,	12288)					\
-    SIZE_CLASS(38,	2048,	14336)					\
+/*
+ * This header requires LG_SIZEOF_PTR, LG_TINY_MIN, LG_QUANTUM, and LG_PAGE to
+ * be defined prior to inclusion, and it in turn defines:
+ *
+ *   LG_SIZE_CLASS_GROUP: Lg of size class count for each size doubling.
+ *   SIZE_CLASSES: Complete table of
+ *                 SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup)
+ *                 tuples.
+ *     index: Size class index.
+ *     lg_grp: Lg group base size (no deltas added).
+ *     lg_delta: Lg delta to previous size class.
+ *     ndelta: Delta multiplier.  size == 1<<lg_grp + ndelta<<lg_delta
+ *     bin: 'yes' if a small bin size class, 'no' otherwise.
+ *     lg_delta_lookup: Same as lg_delta if a lookup table size class, 'no'
+ *                      otherwise.
+ *   NTBINS: Number of tiny bins.
+ *   NLBINS: Number of bins supported by the lookup table.
+ *   NBINS: Number of small size class bins.
+ *   NSIZES: Number of size classes.
+ *   LG_TINY_MAXCLASS: Lg of maximum tiny size class.
+ *   LOOKUP_MAXCLASS: Maximum size class included in lookup table.
+ *   SMALL_MAXCLASS: Maximum small size class.
+ *   LG_LARGE_MINCLASS: Lg of minimum large size class.
+ *   HUGE_MAXCLASS: Maximum (huge) size class.
+ */
 
-#define	NBINS		39
-#define	SMALL_MAXCLASS	14336
-#endif
+#define	LG_SIZE_CLASS_GROUP	2
 
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 15)
-#define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	8,	24)					\
-    SIZE_CLASS(3,	8,	32)					\
-    SIZE_CLASS(4,	8,	40)					\
-    SIZE_CLASS(5,	8,	48)					\
-    SIZE_CLASS(6,	8,	56)					\
-    SIZE_CLASS(7,	8,	64)					\
-    SIZE_CLASS(8,	16,	80)					\
-    SIZE_CLASS(9,	16,	96)					\
-    SIZE_CLASS(10,	16,	112)					\
-    SIZE_CLASS(11,	16,	128)					\
-    SIZE_CLASS(12,	32,	160)					\
-    SIZE_CLASS(13,	32,	192)					\
-    SIZE_CLASS(14,	32,	224)					\
-    SIZE_CLASS(15,	32,	256)					\
-    SIZE_CLASS(16,	64,	320)					\
-    SIZE_CLASS(17,	64,	384)					\
-    SIZE_CLASS(18,	64,	448)					\
-    SIZE_CLASS(19,	64,	512)					\
-    SIZE_CLASS(20,	128,	640)					\
-    SIZE_CLASS(21,	128,	768)					\
-    SIZE_CLASS(22,	128,	896)					\
-    SIZE_CLASS(23,	128,	1024)					\
-    SIZE_CLASS(24,	256,	1280)					\
-    SIZE_CLASS(25,	256,	1536)					\
-    SIZE_CLASS(26,	256,	1792)					\
-    SIZE_CLASS(27,	256,	2048)					\
-    SIZE_CLASS(28,	512,	2560)					\
-    SIZE_CLASS(29,	512,	3072)					\
-    SIZE_CLASS(30,	512,	3584)					\
-    SIZE_CLASS(31,	512,	4096)					\
-    SIZE_CLASS(32,	1024,	5120)					\
-    SIZE_CLASS(33,	1024,	6144)					\
-    SIZE_CLASS(34,	1024,	7168)					\
-    SIZE_CLASS(35,	1024,	8192)					\
-    SIZE_CLASS(36,	2048,	10240)					\
-    SIZE_CLASS(37,	2048,	12288)					\
-    SIZE_CLASS(38,	2048,	14336)					\
-    SIZE_CLASS(39,	2048,	16384)					\
-    SIZE_CLASS(40,	4096,	20480)					\
-    SIZE_CLASS(41,	4096,	24576)					\
-    SIZE_CLASS(42,	4096,	28672)					\
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0, yes,  3) \
+    SC(  1,      3,        3,      1, yes,  3) \
+    SC(  2,      3,        3,      2, yes,  3) \
+    SC(  3,      3,        3,      3, yes,  3) \
+                                               \
+    SC(  4,      5,        3,      1, yes,  3) \
+    SC(  5,      5,        3,      2, yes,  3) \
+    SC(  6,      5,        3,      3, yes,  3) \
+    SC(  7,      5,        3,      4, yes,  3) \
+                                               \
+    SC(  8,      6,        4,      1, yes,  4) \
+    SC(  9,      6,        4,      2, yes,  4) \
+    SC( 10,      6,        4,      3, yes,  4) \
+    SC( 11,      6,        4,      4, yes,  4) \
+                                               \
+    SC( 12,      7,        5,      1, yes,  5) \
+    SC( 13,      7,        5,      2, yes,  5) \
+    SC( 14,      7,        5,      3, yes,  5) \
+    SC( 15,      7,        5,      4, yes,  5) \
+                                               \
+    SC( 16,      8,        6,      1, yes,  6) \
+    SC( 17,      8,        6,      2, yes,  6) \
+    SC( 18,      8,        6,      3, yes,  6) \
+    SC( 19,      8,        6,      4, yes,  6) \
+                                               \
+    SC( 20,      9,        7,      1, yes,  7) \
+    SC( 21,      9,        7,      2, yes,  7) \
+    SC( 22,      9,        7,      3, yes,  7) \
+    SC( 23,      9,        7,      4, yes,  7) \
+                                               \
+    SC( 24,     10,        8,      1, yes,  8) \
+    SC( 25,     10,        8,      2, yes,  8) \
+    SC( 26,     10,        8,      3, yes,  8) \
+    SC( 27,     10,        8,      4, yes,  8) \
+                                               \
+    SC( 28,     11,        9,      1, yes,  9) \
+    SC( 29,     11,        9,      2, yes,  9) \
+    SC( 30,     11,        9,      3, yes,  9) \
+    SC( 31,     11,        9,      4, yes,  9) \
+                                               \
+    SC( 32,     12,       10,      1, yes, no) \
+    SC( 33,     12,       10,      2, yes, no) \
+    SC( 34,     12,       10,      3, yes, no) \
+    SC( 35,     12,       10,      4, yes, no) \
+                                               \
+    SC( 36,     13,       11,      1, yes, no) \
+    SC( 37,     13,       11,      2, yes, no) \
+    SC( 38,     13,       11,      3, yes, no) \
+    SC( 39,     13,       11,      4,  no, no) \
+                                               \
+    SC( 40,     14,       12,      1,  no, no) \
+    SC( 41,     14,       12,      2,  no, no) \
+    SC( 42,     14,       12,      3,  no, no) \
+    SC( 43,     14,       12,      4,  no, no) \
+                                               \
+    SC( 44,     15,       13,      1,  no, no) \
+    SC( 45,     15,       13,      2,  no, no) \
+    SC( 46,     15,       13,      3,  no, no) \
+    SC( 47,     15,       13,      4,  no, no) \
+                                               \
+    SC( 48,     16,       14,      1,  no, no) \
+    SC( 49,     16,       14,      2,  no, no) \
+    SC( 50,     16,       14,      3,  no, no) \
+    SC( 51,     16,       14,      4,  no, no) \
+                                               \
+    SC( 52,     17,       15,      1,  no, no) \
+    SC( 53,     17,       15,      2,  no, no) \
+    SC( 54,     17,       15,      3,  no, no) \
+    SC( 55,     17,       15,      4,  no, no) \
+                                               \
+    SC( 56,     18,       16,      1,  no, no) \
+    SC( 57,     18,       16,      2,  no, no) \
+    SC( 58,     18,       16,      3,  no, no) \
+    SC( 59,     18,       16,      4,  no, no) \
+                                               \
+    SC( 60,     19,       17,      1,  no, no) \
+    SC( 61,     19,       17,      2,  no, no) \
+    SC( 62,     19,       17,      3,  no, no) \
+    SC( 63,     19,       17,      4,  no, no) \
+                                               \
+    SC( 64,     20,       18,      1,  no, no) \
+    SC( 65,     20,       18,      2,  no, no) \
+    SC( 66,     20,       18,      3,  no, no) \
+    SC( 67,     20,       18,      4,  no, no) \
+                                               \
+    SC( 68,     21,       19,      1,  no, no) \
+    SC( 69,     21,       19,      2,  no, no) \
+    SC( 70,     21,       19,      3,  no, no) \
+    SC( 71,     21,       19,      4,  no, no) \
+                                               \
+    SC( 72,     22,       20,      1,  no, no) \
+    SC( 73,     22,       20,      2,  no, no) \
+    SC( 74,     22,       20,      3,  no, no) \
+    SC( 75,     22,       20,      4,  no, no) \
+                                               \
+    SC( 76,     23,       21,      1,  no, no) \
+    SC( 77,     23,       21,      2,  no, no) \
+    SC( 78,     23,       21,      3,  no, no) \
+    SC( 79,     23,       21,      4,  no, no) \
+                                               \
+    SC( 80,     24,       22,      1,  no, no) \
+    SC( 81,     24,       22,      2,  no, no) \
+    SC( 82,     24,       22,      3,  no, no) \
+    SC( 83,     24,       22,      4,  no, no) \
+                                               \
+    SC( 84,     25,       23,      1,  no, no) \
+    SC( 85,     25,       23,      2,  no, no) \
+    SC( 86,     25,       23,      3,  no, no) \
+    SC( 87,     25,       23,      4,  no, no) \
+                                               \
+    SC( 88,     26,       24,      1,  no, no) \
+    SC( 89,     26,       24,      2,  no, no) \
+    SC( 90,     26,       24,      3,  no, no) \
+    SC( 91,     26,       24,      4,  no, no) \
+                                               \
+    SC( 92,     27,       25,      1,  no, no) \
+    SC( 93,     27,       25,      2,  no, no) \
+    SC( 94,     27,       25,      3,  no, no) \
+    SC( 95,     27,       25,      4,  no, no) \
+                                               \
+    SC( 96,     28,       26,      1,  no, no) \
+    SC( 97,     28,       26,      2,  no, no) \
+    SC( 98,     28,       26,      3,  no, no) \
+    SC( 99,     28,       26,      4,  no, no) \
+                                               \
+    SC(100,     29,       27,      1,  no, no) \
+    SC(101,     29,       27,      2,  no, no) \
+    SC(102,     29,       27,      3,  no, no) \
+    SC(103,     29,       27,      4,  no, no) \
+                                               \
+    SC(104,     30,       28,      1,  no, no) \
+    SC(105,     30,       28,      2,  no, no) \
+    SC(106,     30,       28,      3,  no, no) \
+    SC(107,     30,       28,      4,  no, no) \
+                                               \
+    SC(108,     31,       29,      1,  no, no) \
+    SC(109,     31,       29,      2,  no, no) \
+    SC(110,     31,       29,      3,  no, no) \
 
-#define	NBINS		43
-#define	SMALL_MAXCLASS	28672
-#endif
-
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 16)
 #define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	8,	24)					\
-    SIZE_CLASS(3,	8,	32)					\
-    SIZE_CLASS(4,	8,	40)					\
-    SIZE_CLASS(5,	8,	48)					\
-    SIZE_CLASS(6,	8,	56)					\
-    SIZE_CLASS(7,	8,	64)					\
-    SIZE_CLASS(8,	16,	80)					\
-    SIZE_CLASS(9,	16,	96)					\
-    SIZE_CLASS(10,	16,	112)					\
-    SIZE_CLASS(11,	16,	128)					\
-    SIZE_CLASS(12,	32,	160)					\
-    SIZE_CLASS(13,	32,	192)					\
-    SIZE_CLASS(14,	32,	224)					\
-    SIZE_CLASS(15,	32,	256)					\
-    SIZE_CLASS(16,	64,	320)					\
-    SIZE_CLASS(17,	64,	384)					\
-    SIZE_CLASS(18,	64,	448)					\
-    SIZE_CLASS(19,	64,	512)					\
-    SIZE_CLASS(20,	128,	640)					\
-    SIZE_CLASS(21,	128,	768)					\
-    SIZE_CLASS(22,	128,	896)					\
-    SIZE_CLASS(23,	128,	1024)					\
-    SIZE_CLASS(24,	256,	1280)					\
-    SIZE_CLASS(25,	256,	1536)					\
-    SIZE_CLASS(26,	256,	1792)					\
-    SIZE_CLASS(27,	256,	2048)					\
-    SIZE_CLASS(28,	512,	2560)					\
-    SIZE_CLASS(29,	512,	3072)					\
-    SIZE_CLASS(30,	512,	3584)					\
-    SIZE_CLASS(31,	512,	4096)					\
-    SIZE_CLASS(32,	1024,	5120)					\
-    SIZE_CLASS(33,	1024,	6144)					\
-    SIZE_CLASS(34,	1024,	7168)					\
-    SIZE_CLASS(35,	1024,	8192)					\
-    SIZE_CLASS(36,	2048,	10240)					\
-    SIZE_CLASS(37,	2048,	12288)					\
-    SIZE_CLASS(38,	2048,	14336)					\
-    SIZE_CLASS(39,	2048,	16384)					\
-    SIZE_CLASS(40,	4096,	20480)					\
-    SIZE_CLASS(41,	4096,	24576)					\
-    SIZE_CLASS(42,	4096,	28672)					\
-    SIZE_CLASS(43,	4096,	32768)					\
-    SIZE_CLASS(44,	8192,	40960)					\
-    SIZE_CLASS(45,	8192,	49152)					\
-    SIZE_CLASS(46,	8192,	57344)					\
-
-#define	NBINS		47
-#define	SMALL_MAXCLASS	57344
+#define	NTBINS			0
+#define	NLBINS			32
+#define	NBINS			39
+#define	NSIZES			111
+#define	LG_TINY_MAXCLASS	"NA"
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
+#define	LG_LARGE_MINCLASS	14
+#define	HUGE_MAXCLASS		((((size_t)1) << 31) + (((size_t)3) << 29))
 #endif
 
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)
-#define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	16,	32)					\
-    SIZE_CLASS(3,	16,	48)					\
-    SIZE_CLASS(4,	16,	64)					\
-    SIZE_CLASS(5,	16,	80)					\
-    SIZE_CLASS(6,	16,	96)					\
-    SIZE_CLASS(7,	16,	112)					\
-    SIZE_CLASS(8,	16,	128)					\
-    SIZE_CLASS(9,	32,	160)					\
-    SIZE_CLASS(10,	32,	192)					\
-    SIZE_CLASS(11,	32,	224)					\
-    SIZE_CLASS(12,	32,	256)					\
-    SIZE_CLASS(13,	64,	320)					\
-    SIZE_CLASS(14,	64,	384)					\
-    SIZE_CLASS(15,	64,	448)					\
-    SIZE_CLASS(16,	64,	512)					\
-    SIZE_CLASS(17,	128,	640)					\
-    SIZE_CLASS(18,	128,	768)					\
-    SIZE_CLASS(19,	128,	896)					\
-    SIZE_CLASS(20,	128,	1024)					\
-    SIZE_CLASS(21,	256,	1280)					\
-    SIZE_CLASS(22,	256,	1536)					\
-    SIZE_CLASS(23,	256,	1792)					\
-    SIZE_CLASS(24,	256,	2048)					\
-    SIZE_CLASS(25,	512,	2560)					\
-    SIZE_CLASS(26,	512,	3072)					\
-    SIZE_CLASS(27,	512,	3584)					\
-
-#define	NBINS		28
-#define	SMALL_MAXCLASS	3584
-#endif
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0, yes,  3) \
+                                               \
+    SC(  1,      3,        3,      1, yes,  3) \
+    SC(  2,      4,        4,      1, yes,  4) \
+    SC(  3,      4,        4,      2, yes,  4) \
+    SC(  4,      4,        4,      3, yes,  4) \
+                                               \
+    SC(  5,      6,        4,      1, yes,  4) \
+    SC(  6,      6,        4,      2, yes,  4) \
+    SC(  7,      6,        4,      3, yes,  4) \
+    SC(  8,      6,        4,      4, yes,  4) \
+                                               \
+    SC(  9,      7,        5,      1, yes,  5) \
+    SC( 10,      7,        5,      2, yes,  5) \
+    SC( 11,      7,        5,      3, yes,  5) \
+    SC( 12,      7,        5,      4, yes,  5) \
+                                               \
+    SC( 13,      8,        6,      1, yes,  6) \
+    SC( 14,      8,        6,      2, yes,  6) \
+    SC( 15,      8,        6,      3, yes,  6) \
+    SC( 16,      8,        6,      4, yes,  6) \
+                                               \
+    SC( 17,      9,        7,      1, yes,  7) \
+    SC( 18,      9,        7,      2, yes,  7) \
+    SC( 19,      9,        7,      3, yes,  7) \
+    SC( 20,      9,        7,      4, yes,  7) \
+                                               \
+    SC( 21,     10,        8,      1, yes,  8) \
+    SC( 22,     10,        8,      2, yes,  8) \
+    SC( 23,     10,        8,      3, yes,  8) \
+    SC( 24,     10,        8,      4, yes,  8) \
+                                               \
+    SC( 25,     11,        9,      1, yes,  9) \
+    SC( 26,     11,        9,      2, yes,  9) \
+    SC( 27,     11,        9,      3, yes,  9) \
+    SC( 28,     11,        9,      4, yes,  9) \
+                                               \
+    SC( 29,     12,       10,      1, yes, no) \
+    SC( 30,     12,       10,      2, yes, no) \
+    SC( 31,     12,       10,      3, yes, no) \
+    SC( 32,     12,       10,      4, yes, no) \
+                                               \
+    SC( 33,     13,       11,      1, yes, no) \
+    SC( 34,     13,       11,      2, yes, no) \
+    SC( 35,     13,       11,      3, yes, no) \
+    SC( 36,     13,       11,      4,  no, no) \
+                                               \
+    SC( 37,     14,       12,      1,  no, no) \
+    SC( 38,     14,       12,      2,  no, no) \
+    SC( 39,     14,       12,      3,  no, no) \
+    SC( 40,     14,       12,      4,  no, no) \
+                                               \
+    SC( 41,     15,       13,      1,  no, no) \
+    SC( 42,     15,       13,      2,  no, no) \
+    SC( 43,     15,       13,      3,  no, no) \
+    SC( 44,     15,       13,      4,  no, no) \
+                                               \
+    SC( 45,     16,       14,      1,  no, no) \
+    SC( 46,     16,       14,      2,  no, no) \
+    SC( 47,     16,       14,      3,  no, no) \
+    SC( 48,     16,       14,      4,  no, no) \
+                                               \
+    SC( 49,     17,       15,      1,  no, no) \
+    SC( 50,     17,       15,      2,  no, no) \
+    SC( 51,     17,       15,      3,  no, no) \
+    SC( 52,     17,       15,      4,  no, no) \
+                                               \
+    SC( 53,     18,       16,      1,  no, no) \
+    SC( 54,     18,       16,      2,  no, no) \
+    SC( 55,     18,       16,      3,  no, no) \
+    SC( 56,     18,       16,      4,  no, no) \
+                                               \
+    SC( 57,     19,       17,      1,  no, no) \
+    SC( 58,     19,       17,      2,  no, no) \
+    SC( 59,     19,       17,      3,  no, no) \
+    SC( 60,     19,       17,      4,  no, no) \
+                                               \
+    SC( 61,     20,       18,      1,  no, no) \
+    SC( 62,     20,       18,      2,  no, no) \
+    SC( 63,     20,       18,      3,  no, no) \
+    SC( 64,     20,       18,      4,  no, no) \
+                                               \
+    SC( 65,     21,       19,      1,  no, no) \
+    SC( 66,     21,       19,      2,  no, no) \
+    SC( 67,     21,       19,      3,  no, no) \
+    SC( 68,     21,       19,      4,  no, no) \
+                                               \
+    SC( 69,     22,       20,      1,  no, no) \
+    SC( 70,     22,       20,      2,  no, no) \
+    SC( 71,     22,       20,      3,  no, no) \
+    SC( 72,     22,       20,      4,  no, no) \
+                                               \
+    SC( 73,     23,       21,      1,  no, no) \
+    SC( 74,     23,       21,      2,  no, no) \
+    SC( 75,     23,       21,      3,  no, no) \
+    SC( 76,     23,       21,      4,  no, no) \
+                                               \
+    SC( 77,     24,       22,      1,  no, no) \
+    SC( 78,     24,       22,      2,  no, no) \
+    SC( 79,     24,       22,      3,  no, no) \
+    SC( 80,     24,       22,      4,  no, no) \
+                                               \
+    SC( 81,     25,       23,      1,  no, no) \
+    SC( 82,     25,       23,      2,  no, no) \
+    SC( 83,     25,       23,      3,  no, no) \
+    SC( 84,     25,       23,      4,  no, no) \
+                                               \
+    SC( 85,     26,       24,      1,  no, no) \
+    SC( 86,     26,       24,      2,  no, no) \
+    SC( 87,     26,       24,      3,  no, no) \
+    SC( 88,     26,       24,      4,  no, no) \
+                                               \
+    SC( 89,     27,       25,      1,  no, no) \
+    SC( 90,     27,       25,      2,  no, no) \
+    SC( 91,     27,       25,      3,  no, no) \
+    SC( 92,     27,       25,      4,  no, no) \
+                                               \
+    SC( 93,     28,       26,      1,  no, no) \
+    SC( 94,     28,       26,      2,  no, no) \
+    SC( 95,     28,       26,      3,  no, no) \
+    SC( 96,     28,       26,      4,  no, no) \
+                                               \
+    SC( 97,     29,       27,      1,  no, no) \
+    SC( 98,     29,       27,      2,  no, no) \
+    SC( 99,     29,       27,      3,  no, no) \
+    SC(100,     29,       27,      4,  no, no) \
+                                               \
+    SC(101,     30,       28,      1,  no, no) \
+    SC(102,     30,       28,      2,  no, no) \
+    SC(103,     30,       28,      3,  no, no) \
+    SC(104,     30,       28,      4,  no, no) \
+                                               \
+    SC(105,     31,       29,      1,  no, no) \
+    SC(106,     31,       29,      2,  no, no) \
+    SC(107,     31,       29,      3,  no, no) \
 
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 13)
 #define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	16,	32)					\
-    SIZE_CLASS(3,	16,	48)					\
-    SIZE_CLASS(4,	16,	64)					\
-    SIZE_CLASS(5,	16,	80)					\
-    SIZE_CLASS(6,	16,	96)					\
-    SIZE_CLASS(7,	16,	112)					\
-    SIZE_CLASS(8,	16,	128)					\
-    SIZE_CLASS(9,	32,	160)					\
-    SIZE_CLASS(10,	32,	192)					\
-    SIZE_CLASS(11,	32,	224)					\
-    SIZE_CLASS(12,	32,	256)					\
-    SIZE_CLASS(13,	64,	320)					\
-    SIZE_CLASS(14,	64,	384)					\
-    SIZE_CLASS(15,	64,	448)					\
-    SIZE_CLASS(16,	64,	512)					\
-    SIZE_CLASS(17,	128,	640)					\
-    SIZE_CLASS(18,	128,	768)					\
-    SIZE_CLASS(19,	128,	896)					\
-    SIZE_CLASS(20,	128,	1024)					\
-    SIZE_CLASS(21,	256,	1280)					\
-    SIZE_CLASS(22,	256,	1536)					\
-    SIZE_CLASS(23,	256,	1792)					\
-    SIZE_CLASS(24,	256,	2048)					\
-    SIZE_CLASS(25,	512,	2560)					\
-    SIZE_CLASS(26,	512,	3072)					\
-    SIZE_CLASS(27,	512,	3584)					\
-    SIZE_CLASS(28,	512,	4096)					\
-    SIZE_CLASS(29,	1024,	5120)					\
-    SIZE_CLASS(30,	1024,	6144)					\
-    SIZE_CLASS(31,	1024,	7168)					\
-
-#define	NBINS		32
-#define	SMALL_MAXCLASS	7168
+#define	NTBINS			1
+#define	NLBINS			29
+#define	NBINS			36
+#define	NSIZES			108
+#define	LG_TINY_MAXCLASS	3
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
+#define	LG_LARGE_MINCLASS	14
+#define	HUGE_MAXCLASS		((((size_t)1) << 31) + (((size_t)3) << 29))
 #endif
 
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 14)
-#define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	16,	32)					\
-    SIZE_CLASS(3,	16,	48)					\
-    SIZE_CLASS(4,	16,	64)					\
-    SIZE_CLASS(5,	16,	80)					\
-    SIZE_CLASS(6,	16,	96)					\
-    SIZE_CLASS(7,	16,	112)					\
-    SIZE_CLASS(8,	16,	128)					\
-    SIZE_CLASS(9,	32,	160)					\
-    SIZE_CLASS(10,	32,	192)					\
-    SIZE_CLASS(11,	32,	224)					\
-    SIZE_CLASS(12,	32,	256)					\
-    SIZE_CLASS(13,	64,	320)					\
-    SIZE_CLASS(14,	64,	384)					\
-    SIZE_CLASS(15,	64,	448)					\
-    SIZE_CLASS(16,	64,	512)					\
-    SIZE_CLASS(17,	128,	640)					\
-    SIZE_CLASS(18,	128,	768)					\
-    SIZE_CLASS(19,	128,	896)					\
-    SIZE_CLASS(20,	128,	1024)					\
-    SIZE_CLASS(21,	256,	1280)					\
-    SIZE_CLASS(22,	256,	1536)					\
-    SIZE_CLASS(23,	256,	1792)					\
-    SIZE_CLASS(24,	256,	2048)					\
-    SIZE_CLASS(25,	512,	2560)					\
-    SIZE_CLASS(26,	512,	3072)					\
-    SIZE_CLASS(27,	512,	3584)					\
-    SIZE_CLASS(28,	512,	4096)					\
-    SIZE_CLASS(29,	1024,	5120)					\
-    SIZE_CLASS(30,	1024,	6144)					\
-    SIZE_CLASS(31,	1024,	7168)					\
-    SIZE_CLASS(32,	1024,	8192)					\
-    SIZE_CLASS(33,	2048,	10240)					\
-    SIZE_CLASS(34,	2048,	12288)					\
-    SIZE_CLASS(35,	2048,	14336)					\
-
-#define	NBINS		36
-#define	SMALL_MAXCLASS	14336
-#endif
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \
+    SC(  0,      4,        4,      0, yes,  4) \
+    SC(  1,      4,        4,      1, yes,  4) \
+    SC(  2,      4,        4,      2, yes,  4) \
+    SC(  3,      4,        4,      3, yes,  4) \
+                                               \
+    SC(  4,      6,        4,      1, yes,  4) \
+    SC(  5,      6,        4,      2, yes,  4) \
+    SC(  6,      6,        4,      3, yes,  4) \
+    SC(  7,      6,        4,      4, yes,  4) \
+                                               \
+    SC(  8,      7,        5,      1, yes,  5) \
+    SC(  9,      7,        5,      2, yes,  5) \
+    SC( 10,      7,        5,      3, yes,  5) \
+    SC( 11,      7,        5,      4, yes,  5) \
+                                               \
+    SC( 12,      8,        6,      1, yes,  6) \
+    SC( 13,      8,        6,      2, yes,  6) \
+    SC( 14,      8,        6,      3, yes,  6) \
+    SC( 15,      8,        6,      4, yes,  6) \
+                                               \
+    SC( 16,      9,        7,      1, yes,  7) \
+    SC( 17,      9,        7,      2, yes,  7) \
+    SC( 18,      9,        7,      3, yes,  7) \
+    SC( 19,      9,        7,      4, yes,  7) \
+                                               \
+    SC( 20,     10,        8,      1, yes,  8) \
+    SC( 21,     10,        8,      2, yes,  8) \
+    SC( 22,     10,        8,      3, yes,  8) \
+    SC( 23,     10,        8,      4, yes,  8) \
+                                               \
+    SC( 24,     11,        9,      1, yes,  9) \
+    SC( 25,     11,        9,      2, yes,  9) \
+    SC( 26,     11,        9,      3, yes,  9) \
+    SC( 27,     11,        9,      4, yes,  9) \
+                                               \
+    SC( 28,     12,       10,      1, yes, no) \
+    SC( 29,     12,       10,      2, yes, no) \
+    SC( 30,     12,       10,      3, yes, no) \
+    SC( 31,     12,       10,      4, yes, no) \
+                                               \
+    SC( 32,     13,       11,      1, yes, no) \
+    SC( 33,     13,       11,      2, yes, no) \
+    SC( 34,     13,       11,      3, yes, no) \
+    SC( 35,     13,       11,      4,  no, no) \
+                                               \
+    SC( 36,     14,       12,      1,  no, no) \
+    SC( 37,     14,       12,      2,  no, no) \
+    SC( 38,     14,       12,      3,  no, no) \
+    SC( 39,     14,       12,      4,  no, no) \
+                                               \
+    SC( 40,     15,       13,      1,  no, no) \
+    SC( 41,     15,       13,      2,  no, no) \
+    SC( 42,     15,       13,      3,  no, no) \
+    SC( 43,     15,       13,      4,  no, no) \
+                                               \
+    SC( 44,     16,       14,      1,  no, no) \
+    SC( 45,     16,       14,      2,  no, no) \
+    SC( 46,     16,       14,      3,  no, no) \
+    SC( 47,     16,       14,      4,  no, no) \
+                                               \
+    SC( 48,     17,       15,      1,  no, no) \
+    SC( 49,     17,       15,      2,  no, no) \
+    SC( 50,     17,       15,      3,  no, no) \
+    SC( 51,     17,       15,      4,  no, no) \
+                                               \
+    SC( 52,     18,       16,      1,  no, no) \
+    SC( 53,     18,       16,      2,  no, no) \
+    SC( 54,     18,       16,      3,  no, no) \
+    SC( 55,     18,       16,      4,  no, no) \
+                                               \
+    SC( 56,     19,       17,      1,  no, no) \
+    SC( 57,     19,       17,      2,  no, no) \
+    SC( 58,     19,       17,      3,  no, no) \
+    SC( 59,     19,       17,      4,  no, no) \
+                                               \
+    SC( 60,     20,       18,      1,  no, no) \
+    SC( 61,     20,       18,      2,  no, no) \
+    SC( 62,     20,       18,      3,  no, no) \
+    SC( 63,     20,       18,      4,  no, no) \
+                                               \
+    SC( 64,     21,       19,      1,  no, no) \
+    SC( 65,     21,       19,      2,  no, no) \
+    SC( 66,     21,       19,      3,  no, no) \
+    SC( 67,     21,       19,      4,  no, no) \
+                                               \
+    SC( 68,     22,       20,      1,  no, no) \
+    SC( 69,     22,       20,      2,  no, no) \
+    SC( 70,     22,       20,      3,  no, no) \
+    SC( 71,     22,       20,      4,  no, no) \
+                                               \
+    SC( 72,     23,       21,      1,  no, no) \
+    SC( 73,     23,       21,      2,  no, no) \
+    SC( 74,     23,       21,      3,  no, no) \
+    SC( 75,     23,       21,      4,  no, no) \
+                                               \
+    SC( 76,     24,       22,      1,  no, no) \
+    SC( 77,     24,       22,      2,  no, no) \
+    SC( 78,     24,       22,      3,  no, no) \
+    SC( 79,     24,       22,      4,  no, no) \
+                                               \
+    SC( 80,     25,       23,      1,  no, no) \
+    SC( 81,     25,       23,      2,  no, no) \
+    SC( 82,     25,       23,      3,  no, no) \
+    SC( 83,     25,       23,      4,  no, no) \
+                                               \
+    SC( 84,     26,       24,      1,  no, no) \
+    SC( 85,     26,       24,      2,  no, no) \
+    SC( 86,     26,       24,      3,  no, no) \
+    SC( 87,     26,       24,      4,  no, no) \
+                                               \
+    SC( 88,     27,       25,      1,  no, no) \
+    SC( 89,     27,       25,      2,  no, no) \
+    SC( 90,     27,       25,      3,  no, no) \
+    SC( 91,     27,       25,      4,  no, no) \
+                                               \
+    SC( 92,     28,       26,      1,  no, no) \
+    SC( 93,     28,       26,      2,  no, no) \
+    SC( 94,     28,       26,      3,  no, no) \
+    SC( 95,     28,       26,      4,  no, no) \
+                                               \
+    SC( 96,     29,       27,      1,  no, no) \
+    SC( 97,     29,       27,      2,  no, no) \
+    SC( 98,     29,       27,      3,  no, no) \
+    SC( 99,     29,       27,      4,  no, no) \
+                                               \
+    SC(100,     30,       28,      1,  no, no) \
+    SC(101,     30,       28,      2,  no, no) \
+    SC(102,     30,       28,      3,  no, no) \
+    SC(103,     30,       28,      4,  no, no) \
+                                               \
+    SC(104,     31,       29,      1,  no, no) \
+    SC(105,     31,       29,      2,  no, no) \
+    SC(106,     31,       29,      3,  no, no) \
 
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 15)
 #define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	16,	32)					\
-    SIZE_CLASS(3,	16,	48)					\
-    SIZE_CLASS(4,	16,	64)					\
-    SIZE_CLASS(5,	16,	80)					\
-    SIZE_CLASS(6,	16,	96)					\
-    SIZE_CLASS(7,	16,	112)					\
-    SIZE_CLASS(8,	16,	128)					\
-    SIZE_CLASS(9,	32,	160)					\
-    SIZE_CLASS(10,	32,	192)					\
-    SIZE_CLASS(11,	32,	224)					\
-    SIZE_CLASS(12,	32,	256)					\
-    SIZE_CLASS(13,	64,	320)					\
-    SIZE_CLASS(14,	64,	384)					\
-    SIZE_CLASS(15,	64,	448)					\
-    SIZE_CLASS(16,	64,	512)					\
-    SIZE_CLASS(17,	128,	640)					\
-    SIZE_CLASS(18,	128,	768)					\
-    SIZE_CLASS(19,	128,	896)					\
-    SIZE_CLASS(20,	128,	1024)					\
-    SIZE_CLASS(21,	256,	1280)					\
-    SIZE_CLASS(22,	256,	1536)					\
-    SIZE_CLASS(23,	256,	1792)					\
-    SIZE_CLASS(24,	256,	2048)					\
-    SIZE_CLASS(25,	512,	2560)					\
-    SIZE_CLASS(26,	512,	3072)					\
-    SIZE_CLASS(27,	512,	3584)					\
-    SIZE_CLASS(28,	512,	4096)					\
-    SIZE_CLASS(29,	1024,	5120)					\
-    SIZE_CLASS(30,	1024,	6144)					\
-    SIZE_CLASS(31,	1024,	7168)					\
-    SIZE_CLASS(32,	1024,	8192)					\
-    SIZE_CLASS(33,	2048,	10240)					\
-    SIZE_CLASS(34,	2048,	12288)					\
-    SIZE_CLASS(35,	2048,	14336)					\
-    SIZE_CLASS(36,	2048,	16384)					\
-    SIZE_CLASS(37,	4096,	20480)					\
-    SIZE_CLASS(38,	4096,	24576)					\
-    SIZE_CLASS(39,	4096,	28672)					\
-
-#define	NBINS		40
-#define	SMALL_MAXCLASS	28672
+#define	NTBINS			0
+#define	NLBINS			28
+#define	NBINS			35
+#define	NSIZES			107
+#define	LG_TINY_MAXCLASS	"NA"
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
+#define	LG_LARGE_MINCLASS	14
+#define	HUGE_MAXCLASS		((((size_t)1) << 31) + (((size_t)3) << 29))
 #endif
 
-#if (LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 16)
-#define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	8,	8)					\
-    SIZE_CLASS(1,	8,	16)					\
-    SIZE_CLASS(2,	16,	32)					\
-    SIZE_CLASS(3,	16,	48)					\
-    SIZE_CLASS(4,	16,	64)					\
-    SIZE_CLASS(5,	16,	80)					\
-    SIZE_CLASS(6,	16,	96)					\
-    SIZE_CLASS(7,	16,	112)					\
-    SIZE_CLASS(8,	16,	128)					\
-    SIZE_CLASS(9,	32,	160)					\
-    SIZE_CLASS(10,	32,	192)					\
-    SIZE_CLASS(11,	32,	224)					\
-    SIZE_CLASS(12,	32,	256)					\
-    SIZE_CLASS(13,	64,	320)					\
-    SIZE_CLASS(14,	64,	384)					\
-    SIZE_CLASS(15,	64,	448)					\
-    SIZE_CLASS(16,	64,	512)					\
-    SIZE_CLASS(17,	128,	640)					\
-    SIZE_CLASS(18,	128,	768)					\
-    SIZE_CLASS(19,	128,	896)					\
-    SIZE_CLASS(20,	128,	1024)					\
-    SIZE_CLASS(21,	256,	1280)					\
-    SIZE_CLASS(22,	256,	1536)					\
-    SIZE_CLASS(23,	256,	1792)					\
-    SIZE_CLASS(24,	256,	2048)					\
-    SIZE_CLASS(25,	512,	2560)					\
-    SIZE_CLASS(26,	512,	3072)					\
-    SIZE_CLASS(27,	512,	3584)					\
-    SIZE_CLASS(28,	512,	4096)					\
-    SIZE_CLASS(29,	1024,	5120)					\
-    SIZE_CLASS(30,	1024,	6144)					\
-    SIZE_CLASS(31,	1024,	7168)					\
-    SIZE_CLASS(32,	1024,	8192)					\
-    SIZE_CLASS(33,	2048,	10240)					\
-    SIZE_CLASS(34,	2048,	12288)					\
-    SIZE_CLASS(35,	2048,	14336)					\
-    SIZE_CLASS(36,	2048,	16384)					\
-    SIZE_CLASS(37,	4096,	20480)					\
-    SIZE_CLASS(38,	4096,	24576)					\
-    SIZE_CLASS(39,	4096,	28672)					\
-    SIZE_CLASS(40,	4096,	32768)					\
-    SIZE_CLASS(41,	8192,	40960)					\
-    SIZE_CLASS(42,	8192,	49152)					\
-    SIZE_CLASS(43,	8192,	57344)					\
-
-#define	NBINS		44
-#define	SMALL_MAXCLASS	57344
-#endif
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0, yes,  3) \
+    SC(  1,      3,        3,      1, yes,  3) \
+    SC(  2,      3,        3,      2, yes,  3) \
+    SC(  3,      3,        3,      3, yes,  3) \
+                                               \
+    SC(  4,      5,        3,      1, yes,  3) \
+    SC(  5,      5,        3,      2, yes,  3) \
+    SC(  6,      5,        3,      3, yes,  3) \
+    SC(  7,      5,        3,      4, yes,  3) \
+                                               \
+    SC(  8,      6,        4,      1, yes,  4) \
+    SC(  9,      6,        4,      2, yes,  4) \
+    SC( 10,      6,        4,      3, yes,  4) \
+    SC( 11,      6,        4,      4, yes,  4) \
+                                               \
+    SC( 12,      7,        5,      1, yes,  5) \
+    SC( 13,      7,        5,      2, yes,  5) \
+    SC( 14,      7,        5,      3, yes,  5) \
+    SC( 15,      7,        5,      4, yes,  5) \
+                                               \
+    SC( 16,      8,        6,      1, yes,  6) \
+    SC( 17,      8,        6,      2, yes,  6) \
+    SC( 18,      8,        6,      3, yes,  6) \
+    SC( 19,      8,        6,      4, yes,  6) \
+                                               \
+    SC( 20,      9,        7,      1, yes,  7) \
+    SC( 21,      9,        7,      2, yes,  7) \
+    SC( 22,      9,        7,      3, yes,  7) \
+    SC( 23,      9,        7,      4, yes,  7) \
+                                               \
+    SC( 24,     10,        8,      1, yes,  8) \
+    SC( 25,     10,        8,      2, yes,  8) \
+    SC( 26,     10,        8,      3, yes,  8) \
+    SC( 27,     10,        8,      4, yes,  8) \
+                                               \
+    SC( 28,     11,        9,      1, yes,  9) \
+    SC( 29,     11,        9,      2, yes,  9) \
+    SC( 30,     11,        9,      3, yes,  9) \
+    SC( 31,     11,        9,      4, yes,  9) \
+                                               \
+    SC( 32,     12,       10,      1, yes, no) \
+    SC( 33,     12,       10,      2, yes, no) \
+    SC( 34,     12,       10,      3, yes, no) \
+    SC( 35,     12,       10,      4, yes, no) \
+                                               \
+    SC( 36,     13,       11,      1, yes, no) \
+    SC( 37,     13,       11,      2, yes, no) \
+    SC( 38,     13,       11,      3, yes, no) \
+    SC( 39,     13,       11,      4,  no, no) \
+                                               \
+    SC( 40,     14,       12,      1,  no, no) \
+    SC( 41,     14,       12,      2,  no, no) \
+    SC( 42,     14,       12,      3,  no, no) \
+    SC( 43,     14,       12,      4,  no, no) \
+                                               \
+    SC( 44,     15,       13,      1,  no, no) \
+    SC( 45,     15,       13,      2,  no, no) \
+    SC( 46,     15,       13,      3,  no, no) \
+    SC( 47,     15,       13,      4,  no, no) \
+                                               \
+    SC( 48,     16,       14,      1,  no, no) \
+    SC( 49,     16,       14,      2,  no, no) \
+    SC( 50,     16,       14,      3,  no, no) \
+    SC( 51,     16,       14,      4,  no, no) \
+                                               \
+    SC( 52,     17,       15,      1,  no, no) \
+    SC( 53,     17,       15,      2,  no, no) \
+    SC( 54,     17,       15,      3,  no, no) \
+    SC( 55,     17,       15,      4,  no, no) \
+                                               \
+    SC( 56,     18,       16,      1,  no, no) \
+    SC( 57,     18,       16,      2,  no, no) \
+    SC( 58,     18,       16,      3,  no, no) \
+    SC( 59,     18,       16,      4,  no, no) \
+                                               \
+    SC( 60,     19,       17,      1,  no, no) \
+    SC( 61,     19,       17,      2,  no, no) \
+    SC( 62,     19,       17,      3,  no, no) \
+    SC( 63,     19,       17,      4,  no, no) \
+                                               \
+    SC( 64,     20,       18,      1,  no, no) \
+    SC( 65,     20,       18,      2,  no, no) \
+    SC( 66,     20,       18,      3,  no, no) \
+    SC( 67,     20,       18,      4,  no, no) \
+                                               \
+    SC( 68,     21,       19,      1,  no, no) \
+    SC( 69,     21,       19,      2,  no, no) \
+    SC( 70,     21,       19,      3,  no, no) \
+    SC( 71,     21,       19,      4,  no, no) \
+                                               \
+    SC( 72,     22,       20,      1,  no, no) \
+    SC( 73,     22,       20,      2,  no, no) \
+    SC( 74,     22,       20,      3,  no, no) \
+    SC( 75,     22,       20,      4,  no, no) \
+                                               \
+    SC( 76,     23,       21,      1,  no, no) \
+    SC( 77,     23,       21,      2,  no, no) \
+    SC( 78,     23,       21,      3,  no, no) \
+    SC( 79,     23,       21,      4,  no, no) \
+                                               \
+    SC( 80,     24,       22,      1,  no, no) \
+    SC( 81,     24,       22,      2,  no, no) \
+    SC( 82,     24,       22,      3,  no, no) \
+    SC( 83,     24,       22,      4,  no, no) \
+                                               \
+    SC( 84,     25,       23,      1,  no, no) \
+    SC( 85,     25,       23,      2,  no, no) \
+    SC( 86,     25,       23,      3,  no, no) \
+    SC( 87,     25,       23,      4,  no, no) \
+                                               \
+    SC( 88,     26,       24,      1,  no, no) \
+    SC( 89,     26,       24,      2,  no, no) \
+    SC( 90,     26,       24,      3,  no, no) \
+    SC( 91,     26,       24,      4,  no, no) \
+                                               \
+    SC( 92,     27,       25,      1,  no, no) \
+    SC( 93,     27,       25,      2,  no, no) \
+    SC( 94,     27,       25,      3,  no, no) \
+    SC( 95,     27,       25,      4,  no, no) \
+                                               \
+    SC( 96,     28,       26,      1,  no, no) \
+    SC( 97,     28,       26,      2,  no, no) \
+    SC( 98,     28,       26,      3,  no, no) \
+    SC( 99,     28,       26,      4,  no, no) \
+                                               \
+    SC(100,     29,       27,      1,  no, no) \
+    SC(101,     29,       27,      2,  no, no) \
+    SC(102,     29,       27,      3,  no, no) \
+    SC(103,     29,       27,      4,  no, no) \
+                                               \
+    SC(104,     30,       28,      1,  no, no) \
+    SC(105,     30,       28,      2,  no, no) \
+    SC(106,     30,       28,      3,  no, no) \
+    SC(107,     30,       28,      4,  no, no) \
+                                               \
+    SC(108,     31,       29,      1,  no, no) \
+    SC(109,     31,       29,      2,  no, no) \
+    SC(110,     31,       29,      3,  no, no) \
+    SC(111,     31,       29,      4,  no, no) \
+                                               \
+    SC(112,     32,       30,      1,  no, no) \
+    SC(113,     32,       30,      2,  no, no) \
+    SC(114,     32,       30,      3,  no, no) \
+    SC(115,     32,       30,      4,  no, no) \
+                                               \
+    SC(116,     33,       31,      1,  no, no) \
+    SC(117,     33,       31,      2,  no, no) \
+    SC(118,     33,       31,      3,  no, no) \
+    SC(119,     33,       31,      4,  no, no) \
+                                               \
+    SC(120,     34,       32,      1,  no, no) \
+    SC(121,     34,       32,      2,  no, no) \
+    SC(122,     34,       32,      3,  no, no) \
+    SC(123,     34,       32,      4,  no, no) \
+                                               \
+    SC(124,     35,       33,      1,  no, no) \
+    SC(125,     35,       33,      2,  no, no) \
+    SC(126,     35,       33,      3,  no, no) \
+    SC(127,     35,       33,      4,  no, no) \
+                                               \
+    SC(128,     36,       34,      1,  no, no) \
+    SC(129,     36,       34,      2,  no, no) \
+    SC(130,     36,       34,      3,  no, no) \
+    SC(131,     36,       34,      4,  no, no) \
+                                               \
+    SC(132,     37,       35,      1,  no, no) \
+    SC(133,     37,       35,      2,  no, no) \
+    SC(134,     37,       35,      3,  no, no) \
+    SC(135,     37,       35,      4,  no, no) \
+                                               \
+    SC(136,     38,       36,      1,  no, no) \
+    SC(137,     38,       36,      2,  no, no) \
+    SC(138,     38,       36,      3,  no, no) \
+    SC(139,     38,       36,      4,  no, no) \
+                                               \
+    SC(140,     39,       37,      1,  no, no) \
+    SC(141,     39,       37,      2,  no, no) \
+    SC(142,     39,       37,      3,  no, no) \
+    SC(143,     39,       37,      4,  no, no) \
+                                               \
+    SC(144,     40,       38,      1,  no, no) \
+    SC(145,     40,       38,      2,  no, no) \
+    SC(146,     40,       38,      3,  no, no) \
+    SC(147,     40,       38,      4,  no, no) \
+                                               \
+    SC(148,     41,       39,      1,  no, no) \
+    SC(149,     41,       39,      2,  no, no) \
+    SC(150,     41,       39,      3,  no, no) \
+    SC(151,     41,       39,      4,  no, no) \
+                                               \
+    SC(152,     42,       40,      1,  no, no) \
+    SC(153,     42,       40,      2,  no, no) \
+    SC(154,     42,       40,      3,  no, no) \
+    SC(155,     42,       40,      4,  no, no) \
+                                               \
+    SC(156,     43,       41,      1,  no, no) \
+    SC(157,     43,       41,      2,  no, no) \
+    SC(158,     43,       41,      3,  no, no) \
+    SC(159,     43,       41,      4,  no, no) \
+                                               \
+    SC(160,     44,       42,      1,  no, no) \
+    SC(161,     44,       42,      2,  no, no) \
+    SC(162,     44,       42,      3,  no, no) \
+    SC(163,     44,       42,      4,  no, no) \
+                                               \
+    SC(164,     45,       43,      1,  no, no) \
+    SC(165,     45,       43,      2,  no, no) \
+    SC(166,     45,       43,      3,  no, no) \
+    SC(167,     45,       43,      4,  no, no) \
+                                               \
+    SC(168,     46,       44,      1,  no, no) \
+    SC(169,     46,       44,      2,  no, no) \
+    SC(170,     46,       44,      3,  no, no) \
+    SC(171,     46,       44,      4,  no, no) \
+                                               \
+    SC(172,     47,       45,      1,  no, no) \
+    SC(173,     47,       45,      2,  no, no) \
+    SC(174,     47,       45,      3,  no, no) \
+    SC(175,     47,       45,      4,  no, no) \
+                                               \
+    SC(176,     48,       46,      1,  no, no) \
+    SC(177,     48,       46,      2,  no, no) \
+    SC(178,     48,       46,      3,  no, no) \
+    SC(179,     48,       46,      4,  no, no) \
+                                               \
+    SC(180,     49,       47,      1,  no, no) \
+    SC(181,     49,       47,      2,  no, no) \
+    SC(182,     49,       47,      3,  no, no) \
+    SC(183,     49,       47,      4,  no, no) \
+                                               \
+    SC(184,     50,       48,      1,  no, no) \
+    SC(185,     50,       48,      2,  no, no) \
+    SC(186,     50,       48,      3,  no, no) \
+    SC(187,     50,       48,      4,  no, no) \
+                                               \
+    SC(188,     51,       49,      1,  no, no) \
+    SC(189,     51,       49,      2,  no, no) \
+    SC(190,     51,       49,      3,  no, no) \
+    SC(191,     51,       49,      4,  no, no) \
+                                               \
+    SC(192,     52,       50,      1,  no, no) \
+    SC(193,     52,       50,      2,  no, no) \
+    SC(194,     52,       50,      3,  no, no) \
+    SC(195,     52,       50,      4,  no, no) \
+                                               \
+    SC(196,     53,       51,      1,  no, no) \
+    SC(197,     53,       51,      2,  no, no) \
+    SC(198,     53,       51,      3,  no, no) \
+    SC(199,     53,       51,      4,  no, no) \
+                                               \
+    SC(200,     54,       52,      1,  no, no) \
+    SC(201,     54,       52,      2,  no, no) \
+    SC(202,     54,       52,      3,  no, no) \
+    SC(203,     54,       52,      4,  no, no) \
+                                               \
+    SC(204,     55,       53,      1,  no, no) \
+    SC(205,     55,       53,      2,  no, no) \
+    SC(206,     55,       53,      3,  no, no) \
+    SC(207,     55,       53,      4,  no, no) \
+                                               \
+    SC(208,     56,       54,      1,  no, no) \
+    SC(209,     56,       54,      2,  no, no) \
+    SC(210,     56,       54,      3,  no, no) \
+    SC(211,     56,       54,      4,  no, no) \
+                                               \
+    SC(212,     57,       55,      1,  no, no) \
+    SC(213,     57,       55,      2,  no, no) \
+    SC(214,     57,       55,      3,  no, no) \
+    SC(215,     57,       55,      4,  no, no) \
+                                               \
+    SC(216,     58,       56,      1,  no, no) \
+    SC(217,     58,       56,      2,  no, no) \
+    SC(218,     58,       56,      3,  no, no) \
+    SC(219,     58,       56,      4,  no, no) \
+                                               \
+    SC(220,     59,       57,      1,  no, no) \
+    SC(221,     59,       57,      2,  no, no) \
+    SC(222,     59,       57,      3,  no, no) \
+    SC(223,     59,       57,      4,  no, no) \
+                                               \
+    SC(224,     60,       58,      1,  no, no) \
+    SC(225,     60,       58,      2,  no, no) \
+    SC(226,     60,       58,      3,  no, no) \
+    SC(227,     60,       58,      4,  no, no) \
+                                               \
+    SC(228,     61,       59,      1,  no, no) \
+    SC(229,     61,       59,      2,  no, no) \
+    SC(230,     61,       59,      3,  no, no) \
+    SC(231,     61,       59,      4,  no, no) \
+                                               \
+    SC(232,     62,       60,      1,  no, no) \
+    SC(233,     62,       60,      2,  no, no) \
+    SC(234,     62,       60,      3,  no, no) \
+    SC(235,     62,       60,      4,  no, no) \
+                                               \
+    SC(236,     63,       61,      1,  no, no) \
+    SC(237,     63,       61,      2,  no, no) \
+    SC(238,     63,       61,      3,  no, no) \
 
-#if (LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
 #define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	16,	16)					\
-    SIZE_CLASS(1,	16,	32)					\
-    SIZE_CLASS(2,	16,	48)					\
-    SIZE_CLASS(3,	16,	64)					\
-    SIZE_CLASS(4,	16,	80)					\
-    SIZE_CLASS(5,	16,	96)					\
-    SIZE_CLASS(6,	16,	112)					\
-    SIZE_CLASS(7,	16,	128)					\
-    SIZE_CLASS(8,	32,	160)					\
-    SIZE_CLASS(9,	32,	192)					\
-    SIZE_CLASS(10,	32,	224)					\
-    SIZE_CLASS(11,	32,	256)					\
-    SIZE_CLASS(12,	64,	320)					\
-    SIZE_CLASS(13,	64,	384)					\
-    SIZE_CLASS(14,	64,	448)					\
-    SIZE_CLASS(15,	64,	512)					\
-    SIZE_CLASS(16,	128,	640)					\
-    SIZE_CLASS(17,	128,	768)					\
-    SIZE_CLASS(18,	128,	896)					\
-    SIZE_CLASS(19,	128,	1024)					\
-    SIZE_CLASS(20,	256,	1280)					\
-    SIZE_CLASS(21,	256,	1536)					\
-    SIZE_CLASS(22,	256,	1792)					\
-    SIZE_CLASS(23,	256,	2048)					\
-    SIZE_CLASS(24,	512,	2560)					\
-    SIZE_CLASS(25,	512,	3072)					\
-    SIZE_CLASS(26,	512,	3584)					\
-
-#define	NBINS		27
-#define	SMALL_MAXCLASS	3584
+#define	NTBINS			0
+#define	NLBINS			32
+#define	NBINS			39
+#define	NSIZES			239
+#define	LG_TINY_MAXCLASS	"NA"
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
+#define	LG_LARGE_MINCLASS	14
+#define	HUGE_MAXCLASS		((((size_t)1) << 63) + (((size_t)3) << 61))
 #endif
 
-#if (LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 13)
-#define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	16,	16)					\
-    SIZE_CLASS(1,	16,	32)					\
-    SIZE_CLASS(2,	16,	48)					\
-    SIZE_CLASS(3,	16,	64)					\
-    SIZE_CLASS(4,	16,	80)					\
-    SIZE_CLASS(5,	16,	96)					\
-    SIZE_CLASS(6,	16,	112)					\
-    SIZE_CLASS(7,	16,	128)					\
-    SIZE_CLASS(8,	32,	160)					\
-    SIZE_CLASS(9,	32,	192)					\
-    SIZE_CLASS(10,	32,	224)					\
-    SIZE_CLASS(11,	32,	256)					\
-    SIZE_CLASS(12,	64,	320)					\
-    SIZE_CLASS(13,	64,	384)					\
-    SIZE_CLASS(14,	64,	448)					\
-    SIZE_CLASS(15,	64,	512)					\
-    SIZE_CLASS(16,	128,	640)					\
-    SIZE_CLASS(17,	128,	768)					\
-    SIZE_CLASS(18,	128,	896)					\
-    SIZE_CLASS(19,	128,	1024)					\
-    SIZE_CLASS(20,	256,	1280)					\
-    SIZE_CLASS(21,	256,	1536)					\
-    SIZE_CLASS(22,	256,	1792)					\
-    SIZE_CLASS(23,	256,	2048)					\
-    SIZE_CLASS(24,	512,	2560)					\
-    SIZE_CLASS(25,	512,	3072)					\
-    SIZE_CLASS(26,	512,	3584)					\
-    SIZE_CLASS(27,	512,	4096)					\
-    SIZE_CLASS(28,	1024,	5120)					\
-    SIZE_CLASS(29,	1024,	6144)					\
-    SIZE_CLASS(30,	1024,	7168)					\
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0, yes,  3) \
+                                               \
+    SC(  1,      3,        3,      1, yes,  3) \
+    SC(  2,      4,        4,      1, yes,  4) \
+    SC(  3,      4,        4,      2, yes,  4) \
+    SC(  4,      4,        4,      3, yes,  4) \
+                                               \
+    SC(  5,      6,        4,      1, yes,  4) \
+    SC(  6,      6,        4,      2, yes,  4) \
+    SC(  7,      6,        4,      3, yes,  4) \
+    SC(  8,      6,        4,      4, yes,  4) \
+                                               \
+    SC(  9,      7,        5,      1, yes,  5) \
+    SC( 10,      7,        5,      2, yes,  5) \
+    SC( 11,      7,        5,      3, yes,  5) \
+    SC( 12,      7,        5,      4, yes,  5) \
+                                               \
+    SC( 13,      8,        6,      1, yes,  6) \
+    SC( 14,      8,        6,      2, yes,  6) \
+    SC( 15,      8,        6,      3, yes,  6) \
+    SC( 16,      8,        6,      4, yes,  6) \
+                                               \
+    SC( 17,      9,        7,      1, yes,  7) \
+    SC( 18,      9,        7,      2, yes,  7) \
+    SC( 19,      9,        7,      3, yes,  7) \
+    SC( 20,      9,        7,      4, yes,  7) \
+                                               \
+    SC( 21,     10,        8,      1, yes,  8) \
+    SC( 22,     10,        8,      2, yes,  8) \
+    SC( 23,     10,        8,      3, yes,  8) \
+    SC( 24,     10,        8,      4, yes,  8) \
+                                               \
+    SC( 25,     11,        9,      1, yes,  9) \
+    SC( 26,     11,        9,      2, yes,  9) \
+    SC( 27,     11,        9,      3, yes,  9) \
+    SC( 28,     11,        9,      4, yes,  9) \
+                                               \
+    SC( 29,     12,       10,      1, yes, no) \
+    SC( 30,     12,       10,      2, yes, no) \
+    SC( 31,     12,       10,      3, yes, no) \
+    SC( 32,     12,       10,      4, yes, no) \
+                                               \
+    SC( 33,     13,       11,      1, yes, no) \
+    SC( 34,     13,       11,      2, yes, no) \
+    SC( 35,     13,       11,      3, yes, no) \
+    SC( 36,     13,       11,      4,  no, no) \
+                                               \
+    SC( 37,     14,       12,      1,  no, no) \
+    SC( 38,     14,       12,      2,  no, no) \
+    SC( 39,     14,       12,      3,  no, no) \
+    SC( 40,     14,       12,      4,  no, no) \
+                                               \
+    SC( 41,     15,       13,      1,  no, no) \
+    SC( 42,     15,       13,      2,  no, no) \
+    SC( 43,     15,       13,      3,  no, no) \
+    SC( 44,     15,       13,      4,  no, no) \
+                                               \
+    SC( 45,     16,       14,      1,  no, no) \
+    SC( 46,     16,       14,      2,  no, no) \
+    SC( 47,     16,       14,      3,  no, no) \
+    SC( 48,     16,       14,      4,  no, no) \
+                                               \
+    SC( 49,     17,       15,      1,  no, no) \
+    SC( 50,     17,       15,      2,  no, no) \
+    SC( 51,     17,       15,      3,  no, no) \
+    SC( 52,     17,       15,      4,  no, no) \
+                                               \
+    SC( 53,     18,       16,      1,  no, no) \
+    SC( 54,     18,       16,      2,  no, no) \
+    SC( 55,     18,       16,      3,  no, no) \
+    SC( 56,     18,       16,      4,  no, no) \
+                                               \
+    SC( 57,     19,       17,      1,  no, no) \
+    SC( 58,     19,       17,      2,  no, no) \
+    SC( 59,     19,       17,      3,  no, no) \
+    SC( 60,     19,       17,      4,  no, no) \
+                                               \
+    SC( 61,     20,       18,      1,  no, no) \
+    SC( 62,     20,       18,      2,  no, no) \
+    SC( 63,     20,       18,      3,  no, no) \
+    SC( 64,     20,       18,      4,  no, no) \
+                                               \
+    SC( 65,     21,       19,      1,  no, no) \
+    SC( 66,     21,       19,      2,  no, no) \
+    SC( 67,     21,       19,      3,  no, no) \
+    SC( 68,     21,       19,      4,  no, no) \
+                                               \
+    SC( 69,     22,       20,      1,  no, no) \
+    SC( 70,     22,       20,      2,  no, no) \
+    SC( 71,     22,       20,      3,  no, no) \
+    SC( 72,     22,       20,      4,  no, no) \
+                                               \
+    SC( 73,     23,       21,      1,  no, no) \
+    SC( 74,     23,       21,      2,  no, no) \
+    SC( 75,     23,       21,      3,  no, no) \
+    SC( 76,     23,       21,      4,  no, no) \
+                                               \
+    SC( 77,     24,       22,      1,  no, no) \
+    SC( 78,     24,       22,      2,  no, no) \
+    SC( 79,     24,       22,      3,  no, no) \
+    SC( 80,     24,       22,      4,  no, no) \
+                                               \
+    SC( 81,     25,       23,      1,  no, no) \
+    SC( 82,     25,       23,      2,  no, no) \
+    SC( 83,     25,       23,      3,  no, no) \
+    SC( 84,     25,       23,      4,  no, no) \
+                                               \
+    SC( 85,     26,       24,      1,  no, no) \
+    SC( 86,     26,       24,      2,  no, no) \
+    SC( 87,     26,       24,      3,  no, no) \
+    SC( 88,     26,       24,      4,  no, no) \
+                                               \
+    SC( 89,     27,       25,      1,  no, no) \
+    SC( 90,     27,       25,      2,  no, no) \
+    SC( 91,     27,       25,      3,  no, no) \
+    SC( 92,     27,       25,      4,  no, no) \
+                                               \
+    SC( 93,     28,       26,      1,  no, no) \
+    SC( 94,     28,       26,      2,  no, no) \
+    SC( 95,     28,       26,      3,  no, no) \
+    SC( 96,     28,       26,      4,  no, no) \
+                                               \
+    SC( 97,     29,       27,      1,  no, no) \
+    SC( 98,     29,       27,      2,  no, no) \
+    SC( 99,     29,       27,      3,  no, no) \
+    SC(100,     29,       27,      4,  no, no) \
+                                               \
+    SC(101,     30,       28,      1,  no, no) \
+    SC(102,     30,       28,      2,  no, no) \
+    SC(103,     30,       28,      3,  no, no) \
+    SC(104,     30,       28,      4,  no, no) \
+                                               \
+    SC(105,     31,       29,      1,  no, no) \
+    SC(106,     31,       29,      2,  no, no) \
+    SC(107,     31,       29,      3,  no, no) \
+    SC(108,     31,       29,      4,  no, no) \
+                                               \
+    SC(109,     32,       30,      1,  no, no) \
+    SC(110,     32,       30,      2,  no, no) \
+    SC(111,     32,       30,      3,  no, no) \
+    SC(112,     32,       30,      4,  no, no) \
+                                               \
+    SC(113,     33,       31,      1,  no, no) \
+    SC(114,     33,       31,      2,  no, no) \
+    SC(115,     33,       31,      3,  no, no) \
+    SC(116,     33,       31,      4,  no, no) \
+                                               \
+    SC(117,     34,       32,      1,  no, no) \
+    SC(118,     34,       32,      2,  no, no) \
+    SC(119,     34,       32,      3,  no, no) \
+    SC(120,     34,       32,      4,  no, no) \
+                                               \
+    SC(121,     35,       33,      1,  no, no) \
+    SC(122,     35,       33,      2,  no, no) \
+    SC(123,     35,       33,      3,  no, no) \
+    SC(124,     35,       33,      4,  no, no) \
+                                               \
+    SC(125,     36,       34,      1,  no, no) \
+    SC(126,     36,       34,      2,  no, no) \
+    SC(127,     36,       34,      3,  no, no) \
+    SC(128,     36,       34,      4,  no, no) \
+                                               \
+    SC(129,     37,       35,      1,  no, no) \
+    SC(130,     37,       35,      2,  no, no) \
+    SC(131,     37,       35,      3,  no, no) \
+    SC(132,     37,       35,      4,  no, no) \
+                                               \
+    SC(133,     38,       36,      1,  no, no) \
+    SC(134,     38,       36,      2,  no, no) \
+    SC(135,     38,       36,      3,  no, no) \
+    SC(136,     38,       36,      4,  no, no) \
+                                               \
+    SC(137,     39,       37,      1,  no, no) \
+    SC(138,     39,       37,      2,  no, no) \
+    SC(139,     39,       37,      3,  no, no) \
+    SC(140,     39,       37,      4,  no, no) \
+                                               \
+    SC(141,     40,       38,      1,  no, no) \
+    SC(142,     40,       38,      2,  no, no) \
+    SC(143,     40,       38,      3,  no, no) \
+    SC(144,     40,       38,      4,  no, no) \
+                                               \
+    SC(145,     41,       39,      1,  no, no) \
+    SC(146,     41,       39,      2,  no, no) \
+    SC(147,     41,       39,      3,  no, no) \
+    SC(148,     41,       39,      4,  no, no) \
+                                               \
+    SC(149,     42,       40,      1,  no, no) \
+    SC(150,     42,       40,      2,  no, no) \
+    SC(151,     42,       40,      3,  no, no) \
+    SC(152,     42,       40,      4,  no, no) \
+                                               \
+    SC(153,     43,       41,      1,  no, no) \
+    SC(154,     43,       41,      2,  no, no) \
+    SC(155,     43,       41,      3,  no, no) \
+    SC(156,     43,       41,      4,  no, no) \
+                                               \
+    SC(157,     44,       42,      1,  no, no) \
+    SC(158,     44,       42,      2,  no, no) \
+    SC(159,     44,       42,      3,  no, no) \
+    SC(160,     44,       42,      4,  no, no) \
+                                               \
+    SC(161,     45,       43,      1,  no, no) \
+    SC(162,     45,       43,      2,  no, no) \
+    SC(163,     45,       43,      3,  no, no) \
+    SC(164,     45,       43,      4,  no, no) \
+                                               \
+    SC(165,     46,       44,      1,  no, no) \
+    SC(166,     46,       44,      2,  no, no) \
+    SC(167,     46,       44,      3,  no, no) \
+    SC(168,     46,       44,      4,  no, no) \
+                                               \
+    SC(169,     47,       45,      1,  no, no) \
+    SC(170,     47,       45,      2,  no, no) \
+    SC(171,     47,       45,      3,  no, no) \
+    SC(172,     47,       45,      4,  no, no) \
+                                               \
+    SC(173,     48,       46,      1,  no, no) \
+    SC(174,     48,       46,      2,  no, no) \
+    SC(175,     48,       46,      3,  no, no) \
+    SC(176,     48,       46,      4,  no, no) \
+                                               \
+    SC(177,     49,       47,      1,  no, no) \
+    SC(178,     49,       47,      2,  no, no) \
+    SC(179,     49,       47,      3,  no, no) \
+    SC(180,     49,       47,      4,  no, no) \
+                                               \
+    SC(181,     50,       48,      1,  no, no) \
+    SC(182,     50,       48,      2,  no, no) \
+    SC(183,     50,       48,      3,  no, no) \
+    SC(184,     50,       48,      4,  no, no) \
+                                               \
+    SC(185,     51,       49,      1,  no, no) \
+    SC(186,     51,       49,      2,  no, no) \
+    SC(187,     51,       49,      3,  no, no) \
+    SC(188,     51,       49,      4,  no, no) \
+                                               \
+    SC(189,     52,       50,      1,  no, no) \
+    SC(190,     52,       50,      2,  no, no) \
+    SC(191,     52,       50,      3,  no, no) \
+    SC(192,     52,       50,      4,  no, no) \
+                                               \
+    SC(193,     53,       51,      1,  no, no) \
+    SC(194,     53,       51,      2,  no, no) \
+    SC(195,     53,       51,      3,  no, no) \
+    SC(196,     53,       51,      4,  no, no) \
+                                               \
+    SC(197,     54,       52,      1,  no, no) \
+    SC(198,     54,       52,      2,  no, no) \
+    SC(199,     54,       52,      3,  no, no) \
+    SC(200,     54,       52,      4,  no, no) \
+                                               \
+    SC(201,     55,       53,      1,  no, no) \
+    SC(202,     55,       53,      2,  no, no) \
+    SC(203,     55,       53,      3,  no, no) \
+    SC(204,     55,       53,      4,  no, no) \
+                                               \
+    SC(205,     56,       54,      1,  no, no) \
+    SC(206,     56,       54,      2,  no, no) \
+    SC(207,     56,       54,      3,  no, no) \
+    SC(208,     56,       54,      4,  no, no) \
+                                               \
+    SC(209,     57,       55,      1,  no, no) \
+    SC(210,     57,       55,      2,  no, no) \
+    SC(211,     57,       55,      3,  no, no) \
+    SC(212,     57,       55,      4,  no, no) \
+                                               \
+    SC(213,     58,       56,      1,  no, no) \
+    SC(214,     58,       56,      2,  no, no) \
+    SC(215,     58,       56,      3,  no, no) \
+    SC(216,     58,       56,      4,  no, no) \
+                                               \
+    SC(217,     59,       57,      1,  no, no) \
+    SC(218,     59,       57,      2,  no, no) \
+    SC(219,     59,       57,      3,  no, no) \
+    SC(220,     59,       57,      4,  no, no) \
+                                               \
+    SC(221,     60,       58,      1,  no, no) \
+    SC(222,     60,       58,      2,  no, no) \
+    SC(223,     60,       58,      3,  no, no) \
+    SC(224,     60,       58,      4,  no, no) \
+                                               \
+    SC(225,     61,       59,      1,  no, no) \
+    SC(226,     61,       59,      2,  no, no) \
+    SC(227,     61,       59,      3,  no, no) \
+    SC(228,     61,       59,      4,  no, no) \
+                                               \
+    SC(229,     62,       60,      1,  no, no) \
+    SC(230,     62,       60,      2,  no, no) \
+    SC(231,     62,       60,      3,  no, no) \
+    SC(232,     62,       60,      4,  no, no) \
+                                               \
+    SC(233,     63,       61,      1,  no, no) \
+    SC(234,     63,       61,      2,  no, no) \
+    SC(235,     63,       61,      3,  no, no) \
 
-#define	NBINS		31
-#define	SMALL_MAXCLASS	7168
-#endif
-
-#if (LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 14)
 #define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	16,	16)					\
-    SIZE_CLASS(1,	16,	32)					\
-    SIZE_CLASS(2,	16,	48)					\
-    SIZE_CLASS(3,	16,	64)					\
-    SIZE_CLASS(4,	16,	80)					\
-    SIZE_CLASS(5,	16,	96)					\
-    SIZE_CLASS(6,	16,	112)					\
-    SIZE_CLASS(7,	16,	128)					\
-    SIZE_CLASS(8,	32,	160)					\
-    SIZE_CLASS(9,	32,	192)					\
-    SIZE_CLASS(10,	32,	224)					\
-    SIZE_CLASS(11,	32,	256)					\
-    SIZE_CLASS(12,	64,	320)					\
-    SIZE_CLASS(13,	64,	384)					\
-    SIZE_CLASS(14,	64,	448)					\
-    SIZE_CLASS(15,	64,	512)					\
-    SIZE_CLASS(16,	128,	640)					\
-    SIZE_CLASS(17,	128,	768)					\
-    SIZE_CLASS(18,	128,	896)					\
-    SIZE_CLASS(19,	128,	1024)					\
-    SIZE_CLASS(20,	256,	1280)					\
-    SIZE_CLASS(21,	256,	1536)					\
-    SIZE_CLASS(22,	256,	1792)					\
-    SIZE_CLASS(23,	256,	2048)					\
-    SIZE_CLASS(24,	512,	2560)					\
-    SIZE_CLASS(25,	512,	3072)					\
-    SIZE_CLASS(26,	512,	3584)					\
-    SIZE_CLASS(27,	512,	4096)					\
-    SIZE_CLASS(28,	1024,	5120)					\
-    SIZE_CLASS(29,	1024,	6144)					\
-    SIZE_CLASS(30,	1024,	7168)					\
-    SIZE_CLASS(31,	1024,	8192)					\
-    SIZE_CLASS(32,	2048,	10240)					\
-    SIZE_CLASS(33,	2048,	12288)					\
-    SIZE_CLASS(34,	2048,	14336)					\
-
-#define	NBINS		35
-#define	SMALL_MAXCLASS	14336
+#define	NTBINS			1
+#define	NLBINS			29
+#define	NBINS			36
+#define	NSIZES			236
+#define	LG_TINY_MAXCLASS	3
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
+#define	LG_LARGE_MINCLASS	14
+#define	HUGE_MAXCLASS		((((size_t)1) << 63) + (((size_t)3) << 61))
 #endif
 
-#if (LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 15)
-#define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	16,	16)					\
-    SIZE_CLASS(1,	16,	32)					\
-    SIZE_CLASS(2,	16,	48)					\
-    SIZE_CLASS(3,	16,	64)					\
-    SIZE_CLASS(4,	16,	80)					\
-    SIZE_CLASS(5,	16,	96)					\
-    SIZE_CLASS(6,	16,	112)					\
-    SIZE_CLASS(7,	16,	128)					\
-    SIZE_CLASS(8,	32,	160)					\
-    SIZE_CLASS(9,	32,	192)					\
-    SIZE_CLASS(10,	32,	224)					\
-    SIZE_CLASS(11,	32,	256)					\
-    SIZE_CLASS(12,	64,	320)					\
-    SIZE_CLASS(13,	64,	384)					\
-    SIZE_CLASS(14,	64,	448)					\
-    SIZE_CLASS(15,	64,	512)					\
-    SIZE_CLASS(16,	128,	640)					\
-    SIZE_CLASS(17,	128,	768)					\
-    SIZE_CLASS(18,	128,	896)					\
-    SIZE_CLASS(19,	128,	1024)					\
-    SIZE_CLASS(20,	256,	1280)					\
-    SIZE_CLASS(21,	256,	1536)					\
-    SIZE_CLASS(22,	256,	1792)					\
-    SIZE_CLASS(23,	256,	2048)					\
-    SIZE_CLASS(24,	512,	2560)					\
-    SIZE_CLASS(25,	512,	3072)					\
-    SIZE_CLASS(26,	512,	3584)					\
-    SIZE_CLASS(27,	512,	4096)					\
-    SIZE_CLASS(28,	1024,	5120)					\
-    SIZE_CLASS(29,	1024,	6144)					\
-    SIZE_CLASS(30,	1024,	7168)					\
-    SIZE_CLASS(31,	1024,	8192)					\
-    SIZE_CLASS(32,	2048,	10240)					\
-    SIZE_CLASS(33,	2048,	12288)					\
-    SIZE_CLASS(34,	2048,	14336)					\
-    SIZE_CLASS(35,	2048,	16384)					\
-    SIZE_CLASS(36,	4096,	20480)					\
-    SIZE_CLASS(37,	4096,	24576)					\
-    SIZE_CLASS(38,	4096,	28672)					\
-
-#define	NBINS		39
-#define	SMALL_MAXCLASS	28672
-#endif
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \
+    SC(  0,      4,        4,      0, yes,  4) \
+    SC(  1,      4,        4,      1, yes,  4) \
+    SC(  2,      4,        4,      2, yes,  4) \
+    SC(  3,      4,        4,      3, yes,  4) \
+                                               \
+    SC(  4,      6,        4,      1, yes,  4) \
+    SC(  5,      6,        4,      2, yes,  4) \
+    SC(  6,      6,        4,      3, yes,  4) \
+    SC(  7,      6,        4,      4, yes,  4) \
+                                               \
+    SC(  8,      7,        5,      1, yes,  5) \
+    SC(  9,      7,        5,      2, yes,  5) \
+    SC( 10,      7,        5,      3, yes,  5) \
+    SC( 11,      7,        5,      4, yes,  5) \
+                                               \
+    SC( 12,      8,        6,      1, yes,  6) \
+    SC( 13,      8,        6,      2, yes,  6) \
+    SC( 14,      8,        6,      3, yes,  6) \
+    SC( 15,      8,        6,      4, yes,  6) \
+                                               \
+    SC( 16,      9,        7,      1, yes,  7) \
+    SC( 17,      9,        7,      2, yes,  7) \
+    SC( 18,      9,        7,      3, yes,  7) \
+    SC( 19,      9,        7,      4, yes,  7) \
+                                               \
+    SC( 20,     10,        8,      1, yes,  8) \
+    SC( 21,     10,        8,      2, yes,  8) \
+    SC( 22,     10,        8,      3, yes,  8) \
+    SC( 23,     10,        8,      4, yes,  8) \
+                                               \
+    SC( 24,     11,        9,      1, yes,  9) \
+    SC( 25,     11,        9,      2, yes,  9) \
+    SC( 26,     11,        9,      3, yes,  9) \
+    SC( 27,     11,        9,      4, yes,  9) \
+                                               \
+    SC( 28,     12,       10,      1, yes, no) \
+    SC( 29,     12,       10,      2, yes, no) \
+    SC( 30,     12,       10,      3, yes, no) \
+    SC( 31,     12,       10,      4, yes, no) \
+                                               \
+    SC( 32,     13,       11,      1, yes, no) \
+    SC( 33,     13,       11,      2, yes, no) \
+    SC( 34,     13,       11,      3, yes, no) \
+    SC( 35,     13,       11,      4,  no, no) \
+                                               \
+    SC( 36,     14,       12,      1,  no, no) \
+    SC( 37,     14,       12,      2,  no, no) \
+    SC( 38,     14,       12,      3,  no, no) \
+    SC( 39,     14,       12,      4,  no, no) \
+                                               \
+    SC( 40,     15,       13,      1,  no, no) \
+    SC( 41,     15,       13,      2,  no, no) \
+    SC( 42,     15,       13,      3,  no, no) \
+    SC( 43,     15,       13,      4,  no, no) \
+                                               \
+    SC( 44,     16,       14,      1,  no, no) \
+    SC( 45,     16,       14,      2,  no, no) \
+    SC( 46,     16,       14,      3,  no, no) \
+    SC( 47,     16,       14,      4,  no, no) \
+                                               \
+    SC( 48,     17,       15,      1,  no, no) \
+    SC( 49,     17,       15,      2,  no, no) \
+    SC( 50,     17,       15,      3,  no, no) \
+    SC( 51,     17,       15,      4,  no, no) \
+                                               \
+    SC( 52,     18,       16,      1,  no, no) \
+    SC( 53,     18,       16,      2,  no, no) \
+    SC( 54,     18,       16,      3,  no, no) \
+    SC( 55,     18,       16,      4,  no, no) \
+                                               \
+    SC( 56,     19,       17,      1,  no, no) \
+    SC( 57,     19,       17,      2,  no, no) \
+    SC( 58,     19,       17,      3,  no, no) \
+    SC( 59,     19,       17,      4,  no, no) \
+                                               \
+    SC( 60,     20,       18,      1,  no, no) \
+    SC( 61,     20,       18,      2,  no, no) \
+    SC( 62,     20,       18,      3,  no, no) \
+    SC( 63,     20,       18,      4,  no, no) \
+                                               \
+    SC( 64,     21,       19,      1,  no, no) \
+    SC( 65,     21,       19,      2,  no, no) \
+    SC( 66,     21,       19,      3,  no, no) \
+    SC( 67,     21,       19,      4,  no, no) \
+                                               \
+    SC( 68,     22,       20,      1,  no, no) \
+    SC( 69,     22,       20,      2,  no, no) \
+    SC( 70,     22,       20,      3,  no, no) \
+    SC( 71,     22,       20,      4,  no, no) \
+                                               \
+    SC( 72,     23,       21,      1,  no, no) \
+    SC( 73,     23,       21,      2,  no, no) \
+    SC( 74,     23,       21,      3,  no, no) \
+    SC( 75,     23,       21,      4,  no, no) \
+                                               \
+    SC( 76,     24,       22,      1,  no, no) \
+    SC( 77,     24,       22,      2,  no, no) \
+    SC( 78,     24,       22,      3,  no, no) \
+    SC( 79,     24,       22,      4,  no, no) \
+                                               \
+    SC( 80,     25,       23,      1,  no, no) \
+    SC( 81,     25,       23,      2,  no, no) \
+    SC( 82,     25,       23,      3,  no, no) \
+    SC( 83,     25,       23,      4,  no, no) \
+                                               \
+    SC( 84,     26,       24,      1,  no, no) \
+    SC( 85,     26,       24,      2,  no, no) \
+    SC( 86,     26,       24,      3,  no, no) \
+    SC( 87,     26,       24,      4,  no, no) \
+                                               \
+    SC( 88,     27,       25,      1,  no, no) \
+    SC( 89,     27,       25,      2,  no, no) \
+    SC( 90,     27,       25,      3,  no, no) \
+    SC( 91,     27,       25,      4,  no, no) \
+                                               \
+    SC( 92,     28,       26,      1,  no, no) \
+    SC( 93,     28,       26,      2,  no, no) \
+    SC( 94,     28,       26,      3,  no, no) \
+    SC( 95,     28,       26,      4,  no, no) \
+                                               \
+    SC( 96,     29,       27,      1,  no, no) \
+    SC( 97,     29,       27,      2,  no, no) \
+    SC( 98,     29,       27,      3,  no, no) \
+    SC( 99,     29,       27,      4,  no, no) \
+                                               \
+    SC(100,     30,       28,      1,  no, no) \
+    SC(101,     30,       28,      2,  no, no) \
+    SC(102,     30,       28,      3,  no, no) \
+    SC(103,     30,       28,      4,  no, no) \
+                                               \
+    SC(104,     31,       29,      1,  no, no) \
+    SC(105,     31,       29,      2,  no, no) \
+    SC(106,     31,       29,      3,  no, no) \
+    SC(107,     31,       29,      4,  no, no) \
+                                               \
+    SC(108,     32,       30,      1,  no, no) \
+    SC(109,     32,       30,      2,  no, no) \
+    SC(110,     32,       30,      3,  no, no) \
+    SC(111,     32,       30,      4,  no, no) \
+                                               \
+    SC(112,     33,       31,      1,  no, no) \
+    SC(113,     33,       31,      2,  no, no) \
+    SC(114,     33,       31,      3,  no, no) \
+    SC(115,     33,       31,      4,  no, no) \
+                                               \
+    SC(116,     34,       32,      1,  no, no) \
+    SC(117,     34,       32,      2,  no, no) \
+    SC(118,     34,       32,      3,  no, no) \
+    SC(119,     34,       32,      4,  no, no) \
+                                               \
+    SC(120,     35,       33,      1,  no, no) \
+    SC(121,     35,       33,      2,  no, no) \
+    SC(122,     35,       33,      3,  no, no) \
+    SC(123,     35,       33,      4,  no, no) \
+                                               \
+    SC(124,     36,       34,      1,  no, no) \
+    SC(125,     36,       34,      2,  no, no) \
+    SC(126,     36,       34,      3,  no, no) \
+    SC(127,     36,       34,      4,  no, no) \
+                                               \
+    SC(128,     37,       35,      1,  no, no) \
+    SC(129,     37,       35,      2,  no, no) \
+    SC(130,     37,       35,      3,  no, no) \
+    SC(131,     37,       35,      4,  no, no) \
+                                               \
+    SC(132,     38,       36,      1,  no, no) \
+    SC(133,     38,       36,      2,  no, no) \
+    SC(134,     38,       36,      3,  no, no) \
+    SC(135,     38,       36,      4,  no, no) \
+                                               \
+    SC(136,     39,       37,      1,  no, no) \
+    SC(137,     39,       37,      2,  no, no) \
+    SC(138,     39,       37,      3,  no, no) \
+    SC(139,     39,       37,      4,  no, no) \
+                                               \
+    SC(140,     40,       38,      1,  no, no) \
+    SC(141,     40,       38,      2,  no, no) \
+    SC(142,     40,       38,      3,  no, no) \
+    SC(143,     40,       38,      4,  no, no) \
+                                               \
+    SC(144,     41,       39,      1,  no, no) \
+    SC(145,     41,       39,      2,  no, no) \
+    SC(146,     41,       39,      3,  no, no) \
+    SC(147,     41,       39,      4,  no, no) \
+                                               \
+    SC(148,     42,       40,      1,  no, no) \
+    SC(149,     42,       40,      2,  no, no) \
+    SC(150,     42,       40,      3,  no, no) \
+    SC(151,     42,       40,      4,  no, no) \
+                                               \
+    SC(152,     43,       41,      1,  no, no) \
+    SC(153,     43,       41,      2,  no, no) \
+    SC(154,     43,       41,      3,  no, no) \
+    SC(155,     43,       41,      4,  no, no) \
+                                               \
+    SC(156,     44,       42,      1,  no, no) \
+    SC(157,     44,       42,      2,  no, no) \
+    SC(158,     44,       42,      3,  no, no) \
+    SC(159,     44,       42,      4,  no, no) \
+                                               \
+    SC(160,     45,       43,      1,  no, no) \
+    SC(161,     45,       43,      2,  no, no) \
+    SC(162,     45,       43,      3,  no, no) \
+    SC(163,     45,       43,      4,  no, no) \
+                                               \
+    SC(164,     46,       44,      1,  no, no) \
+    SC(165,     46,       44,      2,  no, no) \
+    SC(166,     46,       44,      3,  no, no) \
+    SC(167,     46,       44,      4,  no, no) \
+                                               \
+    SC(168,     47,       45,      1,  no, no) \
+    SC(169,     47,       45,      2,  no, no) \
+    SC(170,     47,       45,      3,  no, no) \
+    SC(171,     47,       45,      4,  no, no) \
+                                               \
+    SC(172,     48,       46,      1,  no, no) \
+    SC(173,     48,       46,      2,  no, no) \
+    SC(174,     48,       46,      3,  no, no) \
+    SC(175,     48,       46,      4,  no, no) \
+                                               \
+    SC(176,     49,       47,      1,  no, no) \
+    SC(177,     49,       47,      2,  no, no) \
+    SC(178,     49,       47,      3,  no, no) \
+    SC(179,     49,       47,      4,  no, no) \
+                                               \
+    SC(180,     50,       48,      1,  no, no) \
+    SC(181,     50,       48,      2,  no, no) \
+    SC(182,     50,       48,      3,  no, no) \
+    SC(183,     50,       48,      4,  no, no) \
+                                               \
+    SC(184,     51,       49,      1,  no, no) \
+    SC(185,     51,       49,      2,  no, no) \
+    SC(186,     51,       49,      3,  no, no) \
+    SC(187,     51,       49,      4,  no, no) \
+                                               \
+    SC(188,     52,       50,      1,  no, no) \
+    SC(189,     52,       50,      2,  no, no) \
+    SC(190,     52,       50,      3,  no, no) \
+    SC(191,     52,       50,      4,  no, no) \
+                                               \
+    SC(192,     53,       51,      1,  no, no) \
+    SC(193,     53,       51,      2,  no, no) \
+    SC(194,     53,       51,      3,  no, no) \
+    SC(195,     53,       51,      4,  no, no) \
+                                               \
+    SC(196,     54,       52,      1,  no, no) \
+    SC(197,     54,       52,      2,  no, no) \
+    SC(198,     54,       52,      3,  no, no) \
+    SC(199,     54,       52,      4,  no, no) \
+                                               \
+    SC(200,     55,       53,      1,  no, no) \
+    SC(201,     55,       53,      2,  no, no) \
+    SC(202,     55,       53,      3,  no, no) \
+    SC(203,     55,       53,      4,  no, no) \
+                                               \
+    SC(204,     56,       54,      1,  no, no) \
+    SC(205,     56,       54,      2,  no, no) \
+    SC(206,     56,       54,      3,  no, no) \
+    SC(207,     56,       54,      4,  no, no) \
+                                               \
+    SC(208,     57,       55,      1,  no, no) \
+    SC(209,     57,       55,      2,  no, no) \
+    SC(210,     57,       55,      3,  no, no) \
+    SC(211,     57,       55,      4,  no, no) \
+                                               \
+    SC(212,     58,       56,      1,  no, no) \
+    SC(213,     58,       56,      2,  no, no) \
+    SC(214,     58,       56,      3,  no, no) \
+    SC(215,     58,       56,      4,  no, no) \
+                                               \
+    SC(216,     59,       57,      1,  no, no) \
+    SC(217,     59,       57,      2,  no, no) \
+    SC(218,     59,       57,      3,  no, no) \
+    SC(219,     59,       57,      4,  no, no) \
+                                               \
+    SC(220,     60,       58,      1,  no, no) \
+    SC(221,     60,       58,      2,  no, no) \
+    SC(222,     60,       58,      3,  no, no) \
+    SC(223,     60,       58,      4,  no, no) \
+                                               \
+    SC(224,     61,       59,      1,  no, no) \
+    SC(225,     61,       59,      2,  no, no) \
+    SC(226,     61,       59,      3,  no, no) \
+    SC(227,     61,       59,      4,  no, no) \
+                                               \
+    SC(228,     62,       60,      1,  no, no) \
+    SC(229,     62,       60,      2,  no, no) \
+    SC(230,     62,       60,      3,  no, no) \
+    SC(231,     62,       60,      4,  no, no) \
+                                               \
+    SC(232,     63,       61,      1,  no, no) \
+    SC(233,     63,       61,      2,  no, no) \
+    SC(234,     63,       61,      3,  no, no) \
 
-#if (LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 16)
 #define	SIZE_CLASSES_DEFINED
-/*  SIZE_CLASS(bin,	delta,	sz) */
-#define	SIZE_CLASSES							\
-    SIZE_CLASS(0,	16,	16)					\
-    SIZE_CLASS(1,	16,	32)					\
-    SIZE_CLASS(2,	16,	48)					\
-    SIZE_CLASS(3,	16,	64)					\
-    SIZE_CLASS(4,	16,	80)					\
-    SIZE_CLASS(5,	16,	96)					\
-    SIZE_CLASS(6,	16,	112)					\
-    SIZE_CLASS(7,	16,	128)					\
-    SIZE_CLASS(8,	32,	160)					\
-    SIZE_CLASS(9,	32,	192)					\
-    SIZE_CLASS(10,	32,	224)					\
-    SIZE_CLASS(11,	32,	256)					\
-    SIZE_CLASS(12,	64,	320)					\
-    SIZE_CLASS(13,	64,	384)					\
-    SIZE_CLASS(14,	64,	448)					\
-    SIZE_CLASS(15,	64,	512)					\
-    SIZE_CLASS(16,	128,	640)					\
-    SIZE_CLASS(17,	128,	768)					\
-    SIZE_CLASS(18,	128,	896)					\
-    SIZE_CLASS(19,	128,	1024)					\
-    SIZE_CLASS(20,	256,	1280)					\
-    SIZE_CLASS(21,	256,	1536)					\
-    SIZE_CLASS(22,	256,	1792)					\
-    SIZE_CLASS(23,	256,	2048)					\
-    SIZE_CLASS(24,	512,	2560)					\
-    SIZE_CLASS(25,	512,	3072)					\
-    SIZE_CLASS(26,	512,	3584)					\
-    SIZE_CLASS(27,	512,	4096)					\
-    SIZE_CLASS(28,	1024,	5120)					\
-    SIZE_CLASS(29,	1024,	6144)					\
-    SIZE_CLASS(30,	1024,	7168)					\
-    SIZE_CLASS(31,	1024,	8192)					\
-    SIZE_CLASS(32,	2048,	10240)					\
-    SIZE_CLASS(33,	2048,	12288)					\
-    SIZE_CLASS(34,	2048,	14336)					\
-    SIZE_CLASS(35,	2048,	16384)					\
-    SIZE_CLASS(36,	4096,	20480)					\
-    SIZE_CLASS(37,	4096,	24576)					\
-    SIZE_CLASS(38,	4096,	28672)					\
-    SIZE_CLASS(39,	4096,	32768)					\
-    SIZE_CLASS(40,	8192,	40960)					\
-    SIZE_CLASS(41,	8192,	49152)					\
-    SIZE_CLASS(42,	8192,	57344)					\
-
-#define	NBINS		43
-#define	SMALL_MAXCLASS	57344
+#define	NTBINS			0
+#define	NLBINS			28
+#define	NBINS			35
+#define	NSIZES			235
+#define	LG_TINY_MAXCLASS	"NA"
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
+#define	LG_LARGE_MINCLASS	14
+#define	HUGE_MAXCLASS		((((size_t)1) << 63) + (((size_t)3) << 61))
 #endif
 
 #ifndef SIZE_CLASSES_DEFINED
 #  error "No size class definitions match configuration"
 #endif
 #undef SIZE_CLASSES_DEFINED
 /*
- * The small_size2bin lookup table uses uint8_t to encode each bin index, so we
+ * The size2index_tab lookup table uses uint8_t to encode each bin index, so we
  * cannot support more than 256 small size classes.  Further constrain NBINS to
- * 255 to support prof_promote, since all small size classes, plus a "not
- * small" size class must be stored in 8 bits of arena_chunk_map_t's bits
- * field.
+ * 255 since all small size classes, plus a "not small" size class must be
+ * stored in 8 bits of arena_chunk_map_bits_t's bits field.
  */
 #if (NBINS > 255)
 #  error "Too many small size classes"
 #endif
 
 #endif /* JEMALLOC_H_TYPES */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/size_classes.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/size_classes.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/size_classes.sh	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/size_classes.sh	2016-05-06 15:11:36.000000000 +0800
@@ -1,105 +1,269 @@
 #!/bin/sh
+#
+# Usage: size_classes.sh <lg_qarr> <lg_tmin> <lg_parr> <lg_g>
 
 # The following limits are chosen such that they cover all supported platforms.
 
-# Range of quanta.
-lg_qmin=3
-lg_qmax=4
+# Pointer sizes.
+lg_zarr="2 3"
+
+# Quanta.
+lg_qarr=$1
 
 # The range of tiny size classes is [2^lg_tmin..2^(lg_q-1)].
-lg_tmin=3
+lg_tmin=$2
+
+# Maximum lookup size.
+lg_kmax=12
 
-# Range of page sizes.
-lg_pmin=12
-lg_pmax=16
+# Page sizes.
+lg_parr=`echo $3 | tr ',' ' '`
+
+# Size class group size (number of size classes for each size doubling).
+lg_g=$4
 
 pow2() {
   e=$1
   pow2_result=1
   while [ ${e} -gt 0 ] ; do
     pow2_result=$((${pow2_result} + ${pow2_result}))
     e=$((${e} - 1))
   done
 }
 
+lg() {
+  x=$1
+  lg_result=0
+  while [ ${x} -gt 1 ] ; do
+    lg_result=$((${lg_result} + 1))
+    x=$((${x} / 2))
+  done
+}
+
+size_class() {
+  index=$1
+  lg_grp=$2
+  lg_delta=$3
+  ndelta=$4
+  lg_p=$5
+  lg_kmax=$6
+
+  lg ${ndelta}; lg_ndelta=${lg_result}; pow2 ${lg_ndelta}
+  if [ ${pow2_result} -lt ${ndelta} ] ; then
+    rem="yes"
+  else
+    rem="no"
+  fi
+
+  lg_size=${lg_grp}
+  if [ $((${lg_delta} + ${lg_ndelta})) -eq ${lg_grp} ] ; then
+    lg_size=$((${lg_grp} + 1))
+  else
+    lg_size=${lg_grp}
+    rem="yes"
+  fi
+
+  if [ ${lg_size} -lt $((${lg_p} + ${lg_g})) ] ; then
+    bin="yes"
+  else
+    bin="no"
+  fi
+  if [ ${lg_size} -lt ${lg_kmax} \
+      -o ${lg_size} -eq ${lg_kmax} -a ${rem} = "no" ] ; then
+    lg_delta_lookup=${lg_delta}
+  else
+    lg_delta_lookup="no"
+  fi
+  printf '    SC(%3d, %6d, %8d, %6d, %3s, %2s) \\\n' ${index} ${lg_grp} ${lg_delta} ${ndelta} ${bin} ${lg_delta_lookup}
+  # Defined upon return:
+  # - lg_delta_lookup (${lg_delta} or "no")
+  # - bin ("yes" or "no")
+}
+
+sep_line() {
+  echo "                                               \\"
+}
+
+size_classes() {
+  lg_z=$1
+  lg_q=$2
+  lg_t=$3
+  lg_p=$4
+  lg_g=$5
+
+  pow2 $((${lg_z} + 3)); ptr_bits=${pow2_result}
+  pow2 ${lg_g}; g=${pow2_result}
+
+  echo "#define	SIZE_CLASSES \\"
+  echo "  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \\"
+
+  ntbins=0
+  nlbins=0
+  lg_tiny_maxclass='"NA"'
+  nbins=0
+
+  # Tiny size classes.
+  ndelta=0
+  index=0
+  lg_grp=${lg_t}
+  lg_delta=${lg_grp}
+  while [ ${lg_grp} -lt ${lg_q} ] ; do
+    size_class ${index} ${lg_grp} ${lg_delta} ${ndelta} ${lg_p} ${lg_kmax}
+    if [ ${lg_delta_lookup} != "no" ] ; then
+      nlbins=$((${index} + 1))
+    fi
+    if [ ${bin} != "no" ] ; then
+      nbins=$((${index} + 1))
+    fi
+    ntbins=$((${ntbins} + 1))
+    lg_tiny_maxclass=${lg_grp} # Final written value is correct.
+    index=$((${index} + 1))
+    lg_delta=${lg_grp}
+    lg_grp=$((${lg_grp} + 1))
+  done
+
+  # First non-tiny group.
+  if [ ${ntbins} -gt 0 ] ; then
+    sep_line
+    # The first size class has an unusual encoding, because the size has to be
+    # split between grp and delta*ndelta.
+    lg_grp=$((${lg_grp} - 1))
+    ndelta=1
+    size_class ${index} ${lg_grp} ${lg_delta} ${ndelta} ${lg_p} ${lg_kmax}
+    index=$((${index} + 1))
+    lg_grp=$((${lg_grp} + 1))
+    lg_delta=$((${lg_delta} + 1))
+  fi
+  while [ ${ndelta} -lt ${g} ] ; do
+    size_class ${index} ${lg_grp} ${lg_delta} ${ndelta} ${lg_p} ${lg_kmax}
+    index=$((${index} + 1))
+    ndelta=$((${ndelta} + 1))
+  done
+
+  # All remaining groups.
+  lg_grp=$((${lg_grp} + ${lg_g}))
+  while [ ${lg_grp} -lt ${ptr_bits} ] ; do
+    sep_line
+    ndelta=1
+    if [ ${lg_grp} -eq $((${ptr_bits} - 1)) ] ; then
+      ndelta_limit=$((${g} - 1))
+    else
+      ndelta_limit=${g}
+    fi
+    while [ ${ndelta} -le ${ndelta_limit} ] ; do
+      size_class ${index} ${lg_grp} ${lg_delta} ${ndelta} ${lg_p} ${lg_kmax}
+      if [ ${lg_delta_lookup} != "no" ] ; then
+        nlbins=$((${index} + 1))
+        # Final written value is correct:
+        lookup_maxclass="((((size_t)1) << ${lg_grp}) + (((size_t)${ndelta}) << ${lg_delta}))"
+      fi
+      if [ ${bin} != "no" ] ; then
+        nbins=$((${index} + 1))
+        # Final written value is correct:
+        small_maxclass="((((size_t)1) << ${lg_grp}) + (((size_t)${ndelta}) << ${lg_delta}))"
+        if [ ${lg_g} -gt 0 ] ; then
+          lg_large_minclass=$((${lg_grp} + 1))
+        else
+          lg_large_minclass=$((${lg_grp} + 2))
+        fi
+      fi
+      # Final written value is correct:
+      huge_maxclass="((((size_t)1) << ${lg_grp}) + (((size_t)${ndelta}) << ${lg_delta}))"
+      index=$((${index} + 1))
+      ndelta=$((${ndelta} + 1))
+    done
+    lg_grp=$((${lg_grp} + 1))
+    lg_delta=$((${lg_delta} + 1))
+  done
+  echo
+  nsizes=${index}
+
+  # Defined upon completion:
+  # - ntbins
+  # - nlbins
+  # - nbins
+  # - nsizes
+  # - lg_tiny_maxclass
+  # - lookup_maxclass
+  # - small_maxclass
+  # - lg_large_minclass
+  # - huge_maxclass
+}
+
 cat <<EOF
 /* This file was automatically generated by size_classes.sh. */
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
+/*
+ * This header requires LG_SIZEOF_PTR, LG_TINY_MIN, LG_QUANTUM, and LG_PAGE to
+ * be defined prior to inclusion, and it in turn defines:
+ *
+ *   LG_SIZE_CLASS_GROUP: Lg of size class count for each size doubling.
+ *   SIZE_CLASSES: Complete table of
+ *                 SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup)
+ *                 tuples.
+ *     index: Size class index.
+ *     lg_grp: Lg group base size (no deltas added).
+ *     lg_delta: Lg delta to previous size class.
+ *     ndelta: Delta multiplier.  size == 1<<lg_grp + ndelta<<lg_delta
+ *     bin: 'yes' if a small bin size class, 'no' otherwise.
+ *     lg_delta_lookup: Same as lg_delta if a lookup table size class, 'no'
+ *                      otherwise.
+ *   NTBINS: Number of tiny bins.
+ *   NLBINS: Number of bins supported by the lookup table.
+ *   NBINS: Number of small size class bins.
+ *   NSIZES: Number of size classes.
+ *   LG_TINY_MAXCLASS: Lg of maximum tiny size class.
+ *   LOOKUP_MAXCLASS: Maximum size class included in lookup table.
+ *   SMALL_MAXCLASS: Maximum small size class.
+ *   LG_LARGE_MINCLASS: Lg of minimum large size class.
+ *   HUGE_MAXCLASS: Maximum (huge) size class.
+ */
+
+#define	LG_SIZE_CLASS_GROUP	${lg_g}
+
 EOF
 
-lg_q=${lg_qmin}
-while [ ${lg_q} -le ${lg_qmax} ] ; do
-  lg_t=${lg_tmin}
-  while [ ${lg_t} -le ${lg_q} ] ; do
-    lg_p=${lg_pmin}
-    while [ ${lg_p} -le ${lg_pmax} ] ; do
-      echo "#if (LG_TINY_MIN == ${lg_t} && LG_QUANTUM == ${lg_q} && LG_PAGE == ${lg_p})"
-      echo "#define	SIZE_CLASSES_DEFINED"
-      pow2 ${lg_q}; q=${pow2_result}
-      pow2 ${lg_t}; t=${pow2_result}
-      pow2 ${lg_p}; p=${pow2_result}
-      bin=0
-      psz=0
-      sz=${t}
-      delta=$((${sz} - ${psz}))
-      echo "/*  SIZE_CLASS(bin,	delta,	sz) */"
-      echo "#define	SIZE_CLASSES							\\"
-
-      # Tiny size classes.
-      while [ ${sz} -lt ${q} ] ; do
-        echo "    SIZE_CLASS(${bin},	${delta},	${sz})					\\"
-        bin=$((${bin} + 1))
-        psz=${sz}
-        sz=$((${sz} + ${sz}))
-        delta=$((${sz} - ${psz}))
-      done
-      # Quantum-multiple size classes.  For each doubling of sz, as many as 4
-      # size classes exist.  Their spacing is the greater of:
-      # - q
-      # - sz/4, where sz is a power of 2
-      while [ ${sz} -lt ${p} ] ; do
-        if [ ${sz} -ge $((${q} * 4)) ] ; then
-          i=$((${sz} / 4))
-        else
-          i=${q}
-        fi
-        next_2pow=$((${sz} * 2))
-        while [ ${sz} -lt $next_2pow ] ; do
-          echo "    SIZE_CLASS(${bin},	${delta},	${sz})					\\"
-          bin=$((${bin} + 1))
-          psz=${sz}
-          sz=$((${sz} + ${i}))
-          delta=$((${sz} - ${psz}))
-        done
+for lg_z in ${lg_zarr} ; do
+  for lg_q in ${lg_qarr} ; do
+    lg_t=${lg_tmin}
+    while [ ${lg_t} -le ${lg_q} ] ; do
+      # Iterate through page sizes and compute how many bins there are.
+      for lg_p in ${lg_parr} ; do
+        echo "#if (LG_SIZEOF_PTR == ${lg_z} && LG_TINY_MIN == ${lg_t} && LG_QUANTUM == ${lg_q} && LG_PAGE == ${lg_p})"
+        size_classes ${lg_z} ${lg_q} ${lg_t} ${lg_p} ${lg_g}
+        echo "#define	SIZE_CLASSES_DEFINED"
+        echo "#define	NTBINS			${ntbins}"
+        echo "#define	NLBINS			${nlbins}"
+        echo "#define	NBINS			${nbins}"
+        echo "#define	NSIZES			${nsizes}"
+        echo "#define	LG_TINY_MAXCLASS	${lg_tiny_maxclass}"
+        echo "#define	LOOKUP_MAXCLASS		${lookup_maxclass}"
+        echo "#define	SMALL_MAXCLASS		${small_maxclass}"
+        echo "#define	LG_LARGE_MINCLASS	${lg_large_minclass}"
+        echo "#define	HUGE_MAXCLASS		${huge_maxclass}"
+        echo "#endif"
+        echo
       done
-      echo
-      echo "#define	NBINS		${bin}"
-      echo "#define	SMALL_MAXCLASS	${psz}"
-      echo "#endif"
-      echo
-      lg_p=$((${lg_p} + 1))
+      lg_t=$((${lg_t} + 1))
     done
-    lg_t=$((${lg_t} + 1))
   done
-  lg_q=$((${lg_q} + 1))
 done
 
 cat <<EOF
 #ifndef SIZE_CLASSES_DEFINED
 #  error "No size class definitions match configuration"
 #endif
 #undef SIZE_CLASSES_DEFINED
 /*
- * The small_size2bin lookup table uses uint8_t to encode each bin index, so we
+ * The size2index_tab lookup table uses uint8_t to encode each bin index, so we
  * cannot support more than 256 small size classes.  Further constrain NBINS to
- * 255 to support prof_promote, since all small size classes, plus a "not
- * small" size class must be stored in 8 bits of arena_chunk_map_t's bits
- * field.
+ * 255 since all small size classes, plus a "not small" size class must be
+ * stored in 8 bits of arena_chunk_map_bits_t's bits field.
  */
 #if (NBINS > 255)
 #  error "Too many small size classes"
 #endif
 
 #endif /* JEMALLOC_H_TYPES */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/stats.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/stats.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/stats.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/stats.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,12 +1,13 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
 typedef struct tcache_bin_stats_s tcache_bin_stats_t;
 typedef struct malloc_bin_stats_s malloc_bin_stats_t;
 typedef struct malloc_large_stats_s malloc_large_stats_t;
+typedef struct malloc_huge_stats_s malloc_huge_stats_t;
 typedef struct arena_stats_s arena_stats_t;
 typedef struct chunk_stats_s chunk_stats_t;
 
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
@@ -18,18 +19,12 @@
 	 */
 	uint64_t	nrequests;
 };
 
 struct malloc_bin_stats_s {
 	/*
-	 * Current number of bytes allocated, including objects currently
-	 * cached by tcache.
-	 */
-	size_t		allocated;
-
-	/*
 	 * Total number of allocation/deallocation requests served directly by
 	 * the bin.  Note that tcache may allocate an object, then recycle it
 	 * many times, resulting many increments to nrequests, but only one
 	 * each to nmalloc and ndalloc.
 	 */
 	uint64_t	nmalloc;
@@ -39,12 +34,18 @@
 	 * Number of allocation requests that correspond to the size of this
 	 * bin.  This includes requests served by tcache, though tcache only
 	 * periodically merges into this counter.
 	 */
 	uint64_t	nrequests;
 
+	/*
+	 * Current number of regions of this size class, including regions
+	 * currently cached by tcache.
+	 */
+	size_t		curregs;
+
 	/* Number of tcache fills from this bin. */
 	uint64_t	nfills;
 
 	/* Number of tcache flushes to this bin. */
 	uint64_t	nflushes;
 
@@ -75,16 +76,31 @@
 	 * Number of allocation requests that correspond to this size class.
 	 * This includes requests served by tcache, though tcache only
 	 * periodically merges into this counter.
 	 */
 	uint64_t	nrequests;
 
-	/* Current number of runs of this size class. */
+	/*
+	 * Current number of runs of this size class, including runs currently
+	 * cached by tcache.
+	 */
 	size_t		curruns;
 };
 
+struct malloc_huge_stats_s {
+	/*
+	 * Total number of allocation/deallocation requests served directly by
+	 * the arena.
+	 */
+	uint64_t	nmalloc;
+	uint64_t	ndalloc;
+
+	/* Current number of (multi-)chunk allocations of this size class. */
+	size_t		curhchunks;
+};
+
 struct arena_stats_s {
 	/* Number of bytes currently mapped. */
 	size_t		mapped;
 
 	/*
 	 * Total number of purge sweeps, total number of madvise calls made,
@@ -92,40 +108,34 @@
 	 * control.
 	 */
 	uint64_t	npurge;
 	uint64_t	nmadvise;
 	uint64_t	purged;
 
+	/*
+	 * Number of bytes currently mapped purely for metadata purposes, and
+	 * number of bytes currently allocated for internal metadata.
+	 */
+	size_t		metadata_mapped;
+	size_t		metadata_allocated; /* Protected via atomic_*_z(). */
+
 	/* Per-size-category statistics. */
 	size_t		allocated_large;
 	uint64_t	nmalloc_large;
 	uint64_t	ndalloc_large;
 	uint64_t	nrequests_large;
 
-	/*
-	 * One element for each possible size class, including sizes that
-	 * overlap with bin size classes.  This is necessary because ipalloc()
-	 * sometimes has to use such large objects in order to assure proper
-	 * alignment.
-	 */
-	malloc_large_stats_t	*lstats;
-};
-
-struct chunk_stats_s {
-	/* Number of chunks that were allocated. */
-	uint64_t	nchunks;
+	size_t		allocated_huge;
+	uint64_t	nmalloc_huge;
+	uint64_t	ndalloc_huge;
 
-	/* High-water mark for number of chunks allocated. */
-	size_t		highchunks;
+	/* One element for each large size class. */
+	malloc_large_stats_t	*lstats;
 
-	/*
-	 * Current number of chunks allocated.  This value isn't maintained for
-	 * any other purpose, so keep track of it in order to be able to set
-	 * highchunks.
-	 */
-	size_t		curchunks;
+	/* One element for each huge size class. */
+	malloc_huge_stats_t	*hstats;
 };
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/tcache.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/tcache.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/tcache.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/tcache.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,24 +1,30 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
 typedef struct tcache_bin_info_s tcache_bin_info_t;
 typedef struct tcache_bin_s tcache_bin_t;
 typedef struct tcache_s tcache_t;
+typedef struct tcaches_s tcaches_t;
 
 /*
  * tcache pointers close to NULL are used to encode state information that is
  * used for two purposes: preventing thread caching on a per thread basis and
  * cleaning up during thread shutdown.
  */
 #define	TCACHE_STATE_DISABLED		((tcache_t *)(uintptr_t)1)
 #define	TCACHE_STATE_REINCARNATED	((tcache_t *)(uintptr_t)2)
 #define	TCACHE_STATE_PURGATORY		((tcache_t *)(uintptr_t)3)
 #define	TCACHE_STATE_MAX		TCACHE_STATE_PURGATORY
 
 /*
+ * Absolute minimum number of cache slots for each small bin.
+ */
+#define	TCACHE_NSLOTS_SMALL_MIN		20
+
+/*
  * Absolute maximum number of cache slots for each small bin in the thread
  * cache.  This is an additional constraint beyond that imposed as: twice the
  * number of regions per run for this size class.
  *
  * This constant must be an even number.
  */
@@ -66,25 +72,32 @@
 	unsigned	ncached;	/* # of cached objects. */
 	void		**avail;	/* Stack of available objects. */
 };
 
 struct tcache_s {
 	ql_elm(tcache_t) link;		/* Used for aggregating stats. */
-	uint64_t	prof_accumbytes;/* Cleared after arena_prof_accum() */
-	arena_t		*arena;		/* This thread's arena. */
+	uint64_t	prof_accumbytes;/* Cleared after arena_prof_accum(). */
 	unsigned	ev_cnt;		/* Event count since incremental GC. */
-	unsigned	next_gc_bin;	/* Next bin to GC. */
+	szind_t		next_gc_bin;	/* Next bin to GC. */
 	tcache_bin_t	tbins[1];	/* Dynamically sized. */
 	/*
 	 * The pointer stacks associated with tbins follow as a contiguous
 	 * array.  During tcache initialization, the avail pointer in each
 	 * element of tbins is initialized to point to the proper offset within
 	 * this array.
 	 */
 };
 
+/* Linkage for list of available (previously used) explicit tcache IDs. */
+struct tcaches_s {
+	union {
+		tcache_t	*tcache;
+		tcaches_t	*next;
+	};
+};
+
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 extern bool	opt_tcache;
 extern ssize_t	opt_lg_tcache_max;
@@ -92,352 +105,322 @@
 extern tcache_bin_info_t	*tcache_bin_info;
 
 /*
  * Number of tcache bins.  There are NBINS small-object bins, plus 0 or more
  * large-object bins.
  */
-extern size_t			nhbins;
+extern size_t	nhbins;
 
 /* Maximum cached size class. */
-extern size_t			tcache_maxclass;
+extern size_t	tcache_maxclass;
+
+/*
+ * Explicit tcaches, managed via the tcache.{create,flush,destroy} mallctls and
+ * usable via the MALLOCX_TCACHE() flag.  The automatic per thread tcaches are
+ * completely disjoint from this data structure.  tcaches starts off as a sparse
+ * array, so it has no physical memory footprint until individual pages are
+ * touched.  This allows the entire array to be allocated the first time an
+ * explicit tcache is created without a disproportionate impact on memory usage.
+ */
+extern tcaches_t	*tcaches;
 
 size_t	tcache_salloc(const void *ptr);
-void	tcache_event_hard(tcache_t *tcache);
-void	*tcache_alloc_small_hard(tcache_t *tcache, tcache_bin_t *tbin,
-    size_t binind);
-void	tcache_bin_flush_small(tcache_bin_t *tbin, size_t binind, unsigned rem,
-    tcache_t *tcache);
-void	tcache_bin_flush_large(tcache_bin_t *tbin, size_t binind, unsigned rem,
-    tcache_t *tcache);
+void	tcache_event_hard(tsd_t *tsd, tcache_t *tcache);
+void	*tcache_alloc_small_hard(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
+    tcache_bin_t *tbin, szind_t binind);
+void	tcache_bin_flush_small(tsd_t *tsd, tcache_t *tcache, tcache_bin_t *tbin,
+    szind_t binind, unsigned rem);
+void	tcache_bin_flush_large(tsd_t *tsd, tcache_bin_t *tbin, szind_t binind,
+    unsigned rem, tcache_t *tcache);
 void	tcache_arena_associate(tcache_t *tcache, arena_t *arena);
-void	tcache_arena_dissociate(tcache_t *tcache);
-tcache_t *tcache_create(arena_t *arena);
-void	tcache_destroy(tcache_t *tcache);
-void	tcache_thread_cleanup(void *arg);
+void	tcache_arena_reassociate(tcache_t *tcache, arena_t *oldarena,
+    arena_t *newarena);
+void	tcache_arena_dissociate(tcache_t *tcache, arena_t *arena);
+tcache_t *tcache_get_hard(tsd_t *tsd);
+tcache_t *tcache_create(tsd_t *tsd, arena_t *arena);
+void	tcache_cleanup(tsd_t *tsd);
+void	tcache_enabled_cleanup(tsd_t *tsd);
 void	tcache_stats_merge(tcache_t *tcache, arena_t *arena);
-bool	tcache_boot0(void);
-bool	tcache_boot1(void);
+bool	tcaches_create(tsd_t *tsd, unsigned *r_ind);
+void	tcaches_flush(tsd_t *tsd, unsigned ind);
+void	tcaches_destroy(tsd_t *tsd, unsigned ind);
+bool	tcache_boot(void);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
-malloc_tsd_protos(JEMALLOC_ATTR(unused), tcache, tcache_t *)
-malloc_tsd_protos(JEMALLOC_ATTR(unused), tcache_enabled, tcache_enabled_t)
-
-void	tcache_event(tcache_t *tcache);
+void	tcache_event(tsd_t *tsd, tcache_t *tcache);
 void	tcache_flush(void);
 bool	tcache_enabled_get(void);
-tcache_t *tcache_get(bool create);
+tcache_t *tcache_get(tsd_t *tsd, bool create);
 void	tcache_enabled_set(bool enabled);
 void	*tcache_alloc_easy(tcache_bin_t *tbin);
-void	*tcache_alloc_small(tcache_t *tcache, size_t size, bool zero);
-void	*tcache_alloc_large(tcache_t *tcache, size_t size, bool zero);
-void	tcache_dalloc_small(tcache_t *tcache, void *ptr, size_t binind);
-void	tcache_dalloc_large(tcache_t *tcache, void *ptr, size_t size);
+void	*tcache_alloc_small(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
+    size_t size, bool zero);
+void	*tcache_alloc_large(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
+    size_t size, bool zero);
+void	tcache_dalloc_small(tsd_t *tsd, tcache_t *tcache, void *ptr,
+    szind_t binind);
+void	tcache_dalloc_large(tsd_t *tsd, tcache_t *tcache, void *ptr,
+    size_t size);
+tcache_t	*tcaches_get(tsd_t *tsd, unsigned ind);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_TCACHE_C_))
-/* Map of thread-specific caches. */
-malloc_tsd_externs(tcache, tcache_t *)
-malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, tcache, tcache_t *, NULL,
-    tcache_thread_cleanup)
-/* Per thread flag that allows thread caches to be disabled. */
-malloc_tsd_externs(tcache_enabled, tcache_enabled_t)
-malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, tcache_enabled, tcache_enabled_t,
-    tcache_enabled_default, malloc_tsd_no_cleanup)
-
 JEMALLOC_INLINE void
 tcache_flush(void)
 {
-	tcache_t *tcache;
+	tsd_t *tsd;
 
 	cassert(config_tcache);
 
-	tcache = *tcache_tsd_get();
-	if ((uintptr_t)tcache <= (uintptr_t)TCACHE_STATE_MAX)
-		return;
-	tcache_destroy(tcache);
-	tcache = NULL;
-	tcache_tsd_set(&tcache);
+	tsd = tsd_fetch();
+	tcache_cleanup(tsd);
 }
 
 JEMALLOC_INLINE bool
 tcache_enabled_get(void)
 {
+	tsd_t *tsd;
 	tcache_enabled_t tcache_enabled;
 
 	cassert(config_tcache);
 
-	tcache_enabled = *tcache_enabled_tsd_get();
+	tsd = tsd_fetch();
+	tcache_enabled = tsd_tcache_enabled_get(tsd);
 	if (tcache_enabled == tcache_enabled_default) {
 		tcache_enabled = (tcache_enabled_t)opt_tcache;
-		tcache_enabled_tsd_set(&tcache_enabled);
+		tsd_tcache_enabled_set(tsd, tcache_enabled);
 	}
 
 	return ((bool)tcache_enabled);
 }
 
 JEMALLOC_INLINE void
 tcache_enabled_set(bool enabled)
 {
+	tsd_t *tsd;
 	tcache_enabled_t tcache_enabled;
-	tcache_t *tcache;
 
 	cassert(config_tcache);
 
+	tsd = tsd_fetch();
+
 	tcache_enabled = (tcache_enabled_t)enabled;
-	tcache_enabled_tsd_set(&tcache_enabled);
-	tcache = *tcache_tsd_get();
-	if (enabled) {
-		if (tcache == TCACHE_STATE_DISABLED) {
-			tcache = NULL;
-			tcache_tsd_set(&tcache);
-		}
-	} else /* disabled */ {
-		if (tcache > TCACHE_STATE_MAX) {
-			tcache_destroy(tcache);
-			tcache = NULL;
-		}
-		if (tcache == NULL) {
-			tcache = TCACHE_STATE_DISABLED;
-			tcache_tsd_set(&tcache);
-		}
-	}
+	tsd_tcache_enabled_set(tsd, tcache_enabled);
+
+	if (!enabled)
+		tcache_cleanup(tsd);
 }
 
 JEMALLOC_ALWAYS_INLINE tcache_t *
-tcache_get(bool create)
+tcache_get(tsd_t *tsd, bool create)
 {
 	tcache_t *tcache;
 
-	if (config_tcache == false)
-		return (NULL);
-	if (config_lazy_lock && isthreaded == false)
+	if (!config_tcache)
 		return (NULL);
 
-	tcache = *tcache_tsd_get();
-	if ((uintptr_t)tcache <= (uintptr_t)TCACHE_STATE_MAX) {
-		if (tcache == TCACHE_STATE_DISABLED)
-			return (NULL);
-		if (tcache == NULL) {
-			if (create == false) {
-				/*
-				 * Creating a tcache here would cause
-				 * allocation as a side effect of free().
-				 * Ordinarily that would be okay since
-				 * tcache_create() failure is a soft failure
-				 * that doesn't propagate.  However, if TLS
-				 * data are freed via free() as in glibc,
-				 * subtle corruption could result from setting
-				 * a TLS variable after its backing memory is
-				 * freed.
-				 */
-				return (NULL);
-			}
-			if (tcache_enabled_get() == false) {
-				tcache_enabled_set(false); /* Memoize. */
-				return (NULL);
-			}
-			return (tcache_create(choose_arena(NULL)));
-		}
-		if (tcache == TCACHE_STATE_PURGATORY) {
-			/*
-			 * Make a note that an allocator function was called
-			 * after tcache_thread_cleanup() was called.
-			 */
-			tcache = TCACHE_STATE_REINCARNATED;
-			tcache_tsd_set(&tcache);
-			return (NULL);
-		}
-		if (tcache == TCACHE_STATE_REINCARNATED)
-			return (NULL);
-		not_reached();
+	tcache = tsd_tcache_get(tsd);
+	if (!create)
+		return (tcache);
+	if (unlikely(tcache == NULL) && tsd_nominal(tsd)) {
+		tcache = tcache_get_hard(tsd);
+		tsd_tcache_set(tsd, tcache);
 	}
 
 	return (tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-tcache_event(tcache_t *tcache)
+tcache_event(tsd_t *tsd, tcache_t *tcache)
 {
 
 	if (TCACHE_GC_INCR == 0)
 		return;
 
 	tcache->ev_cnt++;
 	assert(tcache->ev_cnt <= TCACHE_GC_INCR);
-	if (tcache->ev_cnt == TCACHE_GC_INCR)
-		tcache_event_hard(tcache);
+	if (unlikely(tcache->ev_cnt == TCACHE_GC_INCR))
+		tcache_event_hard(tsd, tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
 tcache_alloc_easy(tcache_bin_t *tbin)
 {
 	void *ret;
 
-	if (tbin->ncached == 0) {
+	if (unlikely(tbin->ncached == 0)) {
 		tbin->low_water = -1;
 		return (NULL);
 	}
 	tbin->ncached--;
-	if ((int)tbin->ncached < tbin->low_water)
+	if (unlikely((int)tbin->ncached < tbin->low_water))
 		tbin->low_water = tbin->ncached;
 	ret = tbin->avail[tbin->ncached];
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-tcache_alloc_small(tcache_t *tcache, size_t size, bool zero)
+tcache_alloc_small(tsd_t *tsd, arena_t *arena, tcache_t *tcache, size_t size,
+    bool zero)
 {
 	void *ret;
-	size_t binind;
+	szind_t binind;
+	size_t usize;
 	tcache_bin_t *tbin;
 
-	binind = SMALL_SIZE2BIN(size);
+	binind = size2index(size);
 	assert(binind < NBINS);
 	tbin = &tcache->tbins[binind];
-	size = arena_bin_info[binind].reg_size;
+	usize = index2size(binind);
 	ret = tcache_alloc_easy(tbin);
-	if (ret == NULL) {
-		ret = tcache_alloc_small_hard(tcache, tbin, binind);
+	if (unlikely(ret == NULL)) {
+		ret = tcache_alloc_small_hard(tsd, arena, tcache, tbin, binind);
 		if (ret == NULL)
 			return (NULL);
 	}
-	assert(tcache_salloc(ret) == arena_bin_info[binind].reg_size);
+	assert(tcache_salloc(ret) == usize);
 
-	if (zero == false) {
+	if (likely(!zero)) {
 		if (config_fill) {
-			if (opt_junk) {
+			if (unlikely(opt_junk_alloc)) {
 				arena_alloc_junk_small(ret,
 				    &arena_bin_info[binind], false);
-			} else if (opt_zero)
-				memset(ret, 0, size);
+			} else if (unlikely(opt_zero))
+				memset(ret, 0, usize);
 		}
-		VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
 	} else {
-		if (config_fill && opt_junk) {
+		if (config_fill && unlikely(opt_junk_alloc)) {
 			arena_alloc_junk_small(ret, &arena_bin_info[binind],
 			    true);
 		}
-		VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
-		memset(ret, 0, size);
+		memset(ret, 0, usize);
 	}
 
 	if (config_stats)
 		tbin->tstats.nrequests++;
 	if (config_prof)
-		tcache->prof_accumbytes += arena_bin_info[binind].reg_size;
-	tcache_event(tcache);
+		tcache->prof_accumbytes += usize;
+	tcache_event(tsd, tcache);
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-tcache_alloc_large(tcache_t *tcache, size_t size, bool zero)
+tcache_alloc_large(tsd_t *tsd, arena_t *arena, tcache_t *tcache, size_t size,
+    bool zero)
 {
 	void *ret;
-	size_t binind;
+	szind_t binind;
+	size_t usize;
 	tcache_bin_t *tbin;
 
-	size = PAGE_CEILING(size);
-	assert(size <= tcache_maxclass);
-	binind = NBINS + (size >> LG_PAGE) - 1;
+	binind = size2index(size);
+	usize = index2size(binind);
+	assert(usize <= tcache_maxclass);
 	assert(binind < nhbins);
 	tbin = &tcache->tbins[binind];
 	ret = tcache_alloc_easy(tbin);
-	if (ret == NULL) {
+	if (unlikely(ret == NULL)) {
 		/*
 		 * Only allocate one large object at a time, because it's quite
 		 * expensive to create one and not use it.
 		 */
-		ret = arena_malloc_large(tcache->arena, size, zero);
+		ret = arena_malloc_large(arena, usize, zero);
 		if (ret == NULL)
 			return (NULL);
 	} else {
-		if (config_prof && prof_promote && size == PAGE) {
+		if (config_prof && usize == LARGE_MINCLASS) {
 			arena_chunk_t *chunk =
 			    (arena_chunk_t *)CHUNK_ADDR2BASE(ret);
 			size_t pageind = (((uintptr_t)ret - (uintptr_t)chunk) >>
 			    LG_PAGE);
 			arena_mapbits_large_binind_set(chunk, pageind,
 			    BININD_INVALID);
 		}
-		if (zero == false) {
+		if (likely(!zero)) {
 			if (config_fill) {
-				if (opt_junk)
-					memset(ret, 0xa5, size);
-				else if (opt_zero)
-					memset(ret, 0, size);
+				if (unlikely(opt_junk_alloc))
+					memset(ret, 0xa5, usize);
+				else if (unlikely(opt_zero))
+					memset(ret, 0, usize);
 			}
-			VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
-		} else {
-			VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
-			memset(ret, 0, size);
-		}
+		} else
+			memset(ret, 0, usize);
 
 		if (config_stats)
 			tbin->tstats.nrequests++;
 		if (config_prof)
-			tcache->prof_accumbytes += size;
+			tcache->prof_accumbytes += usize;
 	}
 
-	tcache_event(tcache);
+	tcache_event(tsd, tcache);
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-tcache_dalloc_small(tcache_t *tcache, void *ptr, size_t binind)
+tcache_dalloc_small(tsd_t *tsd, tcache_t *tcache, void *ptr, szind_t binind)
 {
 	tcache_bin_t *tbin;
 	tcache_bin_info_t *tbin_info;
 
 	assert(tcache_salloc(ptr) <= SMALL_MAXCLASS);
 
-	if (config_fill && opt_junk)
+	if (config_fill && unlikely(opt_junk_free))
 		arena_dalloc_junk_small(ptr, &arena_bin_info[binind]);
 
 	tbin = &tcache->tbins[binind];
 	tbin_info = &tcache_bin_info[binind];
-	if (tbin->ncached == tbin_info->ncached_max) {
-		tcache_bin_flush_small(tbin, binind, (tbin_info->ncached_max >>
-		    1), tcache);
+	if (unlikely(tbin->ncached == tbin_info->ncached_max)) {
+		tcache_bin_flush_small(tsd, tcache, tbin, binind,
+		    (tbin_info->ncached_max >> 1));
 	}
 	assert(tbin->ncached < tbin_info->ncached_max);
 	tbin->avail[tbin->ncached] = ptr;
 	tbin->ncached++;
 
-	tcache_event(tcache);
+	tcache_event(tsd, tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-tcache_dalloc_large(tcache_t *tcache, void *ptr, size_t size)
+tcache_dalloc_large(tsd_t *tsd, tcache_t *tcache, void *ptr, size_t size)
 {
-	size_t binind;
+	szind_t binind;
 	tcache_bin_t *tbin;
 	tcache_bin_info_t *tbin_info;
 
 	assert((size & PAGE_MASK) == 0);
 	assert(tcache_salloc(ptr) > SMALL_MAXCLASS);
 	assert(tcache_salloc(ptr) <= tcache_maxclass);
 
-	binind = NBINS + (size >> LG_PAGE) - 1;
+	binind = size2index(size);
 
-	if (config_fill && opt_junk)
-		memset(ptr, 0x5a, size);
+	if (config_fill && unlikely(opt_junk_free))
+		arena_dalloc_junk_large(ptr, size);
 
 	tbin = &tcache->tbins[binind];
 	tbin_info = &tcache_bin_info[binind];
-	if (tbin->ncached == tbin_info->ncached_max) {
-		tcache_bin_flush_large(tbin, binind, (tbin_info->ncached_max >>
-		    1), tcache);
+	if (unlikely(tbin->ncached == tbin_info->ncached_max)) {
+		tcache_bin_flush_large(tsd, tbin, binind,
+		    (tbin_info->ncached_max >> 1), tcache);
 	}
 	assert(tbin->ncached < tbin_info->ncached_max);
 	tbin->avail[tbin->ncached] = ptr;
 	tbin->ncached++;
 
-	tcache_event(tcache);
+	tcache_event(tsd, tcache);
+}
+
+JEMALLOC_ALWAYS_INLINE tcache_t *
+tcaches_get(tsd_t *tsd, unsigned ind)
+{
+	tcaches_t *elm = &tcaches[ind];
+	if (unlikely(elm->tcache == NULL))
+		elm->tcache = tcache_create(tsd, arena_choose(tsd, NULL));
+	return (elm->tcache);
 }
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/tsd.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/tsd.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/tsd.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/tsd.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,395 +1,515 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
 /* Maximum number of malloc_tsd users with cleanup functions. */
-#define	MALLOC_TSD_CLEANUPS_MAX	8
+#define	MALLOC_TSD_CLEANUPS_MAX	2
 
 typedef bool (*malloc_tsd_cleanup_t)(void);
 
 #if (!defined(JEMALLOC_MALLOC_THREAD_CLEANUP) && !defined(JEMALLOC_TLS) && \
     !defined(_WIN32))
 typedef struct tsd_init_block_s tsd_init_block_t;
 typedef struct tsd_init_head_s tsd_init_head_t;
 #endif
 
+typedef struct tsd_s tsd_t;
+
+typedef enum {
+	tsd_state_uninitialized,
+	tsd_state_nominal,
+	tsd_state_purgatory,
+	tsd_state_reincarnated
+} tsd_state_t;
+
 /*
  * TLS/TSD-agnostic macro-based implementation of thread-specific data.  There
- * are four macros that support (at least) three use cases: file-private,
+ * are five macros that support (at least) three use cases: file-private,
  * library-private, and library-private inlined.  Following is an example
  * library-private tsd variable:
  *
  * In example.h:
  *   typedef struct {
  *           int x;
  *           int y;
  *   } example_t;
  *   #define EX_INITIALIZER JEMALLOC_CONCAT({0, 0})
- *   malloc_tsd_protos(, example, example_t *)
- *   malloc_tsd_externs(example, example_t *)
+ *   malloc_tsd_types(example_, example_t)
+ *   malloc_tsd_protos(, example_, example_t)
+ *   malloc_tsd_externs(example_, example_t)
  * In example.c:
- *   malloc_tsd_data(, example, example_t *, EX_INITIALIZER)
- *   malloc_tsd_funcs(, example, example_t *, EX_INITIALIZER,
+ *   malloc_tsd_data(, example_, example_t, EX_INITIALIZER)
+ *   malloc_tsd_funcs(, example_, example_t, EX_INITIALIZER,
  *       example_tsd_cleanup)
  *
  * The result is a set of generated functions, e.g.:
  *
  *   bool example_tsd_boot(void) {...}
- *   example_t **example_tsd_get() {...}
- *   void example_tsd_set(example_t **val) {...}
+ *   example_t *example_tsd_get() {...}
+ *   void example_tsd_set(example_t *val) {...}
  *
  * Note that all of the functions deal in terms of (a_type *) rather than
- * (a_type)  so that it is possible to support non-pointer types (unlike
+ * (a_type) so that it is possible to support non-pointer types (unlike
  * pthreads TSD).  example_tsd_cleanup() is passed an (a_type *) pointer that is
- * cast to (void *).  This means that the cleanup function needs to cast *and*
- * dereference the function argument, e.g.:
+ * cast to (void *).  This means that the cleanup function needs to cast the
+ * function argument to (a_type *), then dereference the resulting pointer to
+ * access fields, e.g.
  *
  *   void
  *   example_tsd_cleanup(void *arg)
  *   {
- *           example_t *example = *(example_t **)arg;
+ *           example_t *example = (example_t *)arg;
  *
+ *           example->x = 42;
  *           [...]
- *           if ([want the cleanup function to be called again]) {
- *                   example_tsd_set(&example);
- *           }
+ *           if ([want the cleanup function to be called again])
+ *                   example_tsd_set(example);
  *   }
  *
  * If example_tsd_set() is called within example_tsd_cleanup(), it will be
  * called again.  This is similar to how pthreads TSD destruction works, except
  * that pthreads only calls the cleanup function again if the value was set to
  * non-NULL.
  */
 
+/* malloc_tsd_types(). */
+#ifdef JEMALLOC_MALLOC_THREAD_CLEANUP
+#define	malloc_tsd_types(a_name, a_type)
+#elif (defined(JEMALLOC_TLS))
+#define	malloc_tsd_types(a_name, a_type)
+#elif (defined(_WIN32))
+#define	malloc_tsd_types(a_name, a_type)				\
+typedef struct {							\
+	bool	initialized;						\
+	a_type	val;							\
+} a_name##tsd_wrapper_t;
+#else
+#define	malloc_tsd_types(a_name, a_type)				\
+typedef struct {							\
+	bool	initialized;						\
+	a_type	val;							\
+} a_name##tsd_wrapper_t;
+#endif
+
 /* malloc_tsd_protos(). */
 #define	malloc_tsd_protos(a_attr, a_name, a_type)			\
 a_attr bool								\
-a_name##_tsd_boot(void);						\
+a_name##tsd_boot0(void);						\
+a_attr void								\
+a_name##tsd_boot1(void);						\
+a_attr bool								\
+a_name##tsd_boot(void);							\
 a_attr a_type *								\
-a_name##_tsd_get(void);							\
+a_name##tsd_get(void);							\
 a_attr void								\
-a_name##_tsd_set(a_type *val);
+a_name##tsd_set(a_type *val);
 
 /* malloc_tsd_externs(). */
 #ifdef JEMALLOC_MALLOC_THREAD_CLEANUP
 #define	malloc_tsd_externs(a_name, a_type)				\
-extern __thread a_type	a_name##_tls;					\
-extern __thread bool	a_name##_initialized;				\
-extern bool		a_name##_booted;
+extern __thread a_type	a_name##tsd_tls;				\
+extern __thread bool	a_name##tsd_initialized;			\
+extern bool		a_name##tsd_booted;
 #elif (defined(JEMALLOC_TLS))
 #define	malloc_tsd_externs(a_name, a_type)				\
-extern __thread a_type	a_name##_tls;					\
-extern pthread_key_t	a_name##_tsd;					\
-extern bool		a_name##_booted;
+extern __thread a_type	a_name##tsd_tls;				\
+extern pthread_key_t	a_name##tsd_tsd;				\
+extern bool		a_name##tsd_booted;
 #elif (defined(_WIN32))
 #define	malloc_tsd_externs(a_name, a_type)				\
-extern DWORD		a_name##_tsd;					\
-extern bool		a_name##_booted;
+extern DWORD		a_name##tsd_tsd;				\
+extern a_name##tsd_wrapper_t	a_name##tsd_boot_wrapper;		\
+extern bool		a_name##tsd_booted;
 #else
 #define	malloc_tsd_externs(a_name, a_type)				\
-extern pthread_key_t	a_name##_tsd;					\
-extern tsd_init_head_t	a_name##_tsd_init_head;				\
-extern bool		a_name##_booted;
+extern pthread_key_t	a_name##tsd_tsd;				\
+extern tsd_init_head_t	a_name##tsd_init_head;				\
+extern a_name##tsd_wrapper_t	a_name##tsd_boot_wrapper;		\
+extern bool		a_name##tsd_booted;
 #endif
 
 /* malloc_tsd_data(). */
 #ifdef JEMALLOC_MALLOC_THREAD_CLEANUP
 #define	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\
 a_attr __thread a_type JEMALLOC_TLS_MODEL				\
-    a_name##_tls = a_initializer;					\
+    a_name##tsd_tls = a_initializer;					\
 a_attr __thread bool JEMALLOC_TLS_MODEL					\
-    a_name##_initialized = false;					\
-a_attr bool		a_name##_booted = false;
+    a_name##tsd_initialized = false;					\
+a_attr bool		a_name##tsd_booted = false;
 #elif (defined(JEMALLOC_TLS))
 #define	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\
 a_attr __thread a_type JEMALLOC_TLS_MODEL				\
-    a_name##_tls = a_initializer;					\
-a_attr pthread_key_t	a_name##_tsd;					\
-a_attr bool		a_name##_booted = false;
+    a_name##tsd_tls = a_initializer;					\
+a_attr pthread_key_t	a_name##tsd_tsd;				\
+a_attr bool		a_name##tsd_booted = false;
 #elif (defined(_WIN32))
 #define	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\
-a_attr DWORD		a_name##_tsd;					\
-a_attr bool		a_name##_booted = false;
+a_attr DWORD		a_name##tsd_tsd;				\
+a_attr a_name##tsd_wrapper_t a_name##tsd_boot_wrapper = {		\
+	false,								\
+	a_initializer							\
+};									\
+a_attr bool		a_name##tsd_booted = false;
 #else
 #define	malloc_tsd_data(a_attr, a_name, a_type, a_initializer)		\
-a_attr pthread_key_t	a_name##_tsd;					\
-a_attr tsd_init_head_t	a_name##_tsd_init_head = {			\
+a_attr pthread_key_t	a_name##tsd_tsd;				\
+a_attr tsd_init_head_t	a_name##tsd_init_head = {			\
 	ql_head_initializer(blocks),					\
 	MALLOC_MUTEX_INITIALIZER					\
 };									\
-a_attr bool		a_name##_booted = false;
+a_attr a_name##tsd_wrapper_t a_name##tsd_boot_wrapper = {		\
+	false,								\
+	a_initializer							\
+};									\
+a_attr bool		a_name##tsd_booted = false;
 #endif
 
 /* malloc_tsd_funcs(). */
 #ifdef JEMALLOC_MALLOC_THREAD_CLEANUP
 #define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
     a_cleanup)								\
 /* Initialization/cleanup. */						\
 a_attr bool								\
-a_name##_tsd_cleanup_wrapper(void)					\
+a_name##tsd_cleanup_wrapper(void)					\
 {									\
 									\
-	if (a_name##_initialized) {					\
-		a_name##_initialized = false;				\
-		a_cleanup(&a_name##_tls);				\
+	if (a_name##tsd_initialized) {					\
+		a_name##tsd_initialized = false;			\
+		a_cleanup(&a_name##tsd_tls);				\
 	}								\
-	return (a_name##_initialized);					\
+	return (a_name##tsd_initialized);				\
 }									\
 a_attr bool								\
-a_name##_tsd_boot(void)							\
+a_name##tsd_boot0(void)							\
 {									\
 									\
 	if (a_cleanup != malloc_tsd_no_cleanup) {			\
 		malloc_tsd_cleanup_register(				\
-		    &a_name##_tsd_cleanup_wrapper);			\
+		    &a_name##tsd_cleanup_wrapper);			\
 	}								\
-	a_name##_booted = true;						\
+	a_name##tsd_booted = true;					\
 	return (false);							\
 }									\
+a_attr void								\
+a_name##tsd_boot1(void)							\
+{									\
+									\
+	/* Do nothing. */						\
+}									\
+a_attr bool								\
+a_name##tsd_boot(void)							\
+{									\
+									\
+	return (a_name##tsd_boot0());					\
+}									\
 /* Get/set. */								\
 a_attr a_type *								\
-a_name##_tsd_get(void)							\
+a_name##tsd_get(void)							\
 {									\
 									\
-	assert(a_name##_booted);					\
-	return (&a_name##_tls);						\
+	assert(a_name##tsd_booted);					\
+	return (&a_name##tsd_tls);					\
 }									\
 a_attr void								\
-a_name##_tsd_set(a_type *val)						\
+a_name##tsd_set(a_type *val)						\
 {									\
 									\
-	assert(a_name##_booted);					\
-	a_name##_tls = (*val);						\
+	assert(a_name##tsd_booted);					\
+	a_name##tsd_tls = (*val);					\
 	if (a_cleanup != malloc_tsd_no_cleanup)				\
-		a_name##_initialized = true;				\
+		a_name##tsd_initialized = true;				\
 }
 #elif (defined(JEMALLOC_TLS))
 #define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
     a_cleanup)								\
 /* Initialization/cleanup. */						\
 a_attr bool								\
-a_name##_tsd_boot(void)							\
+a_name##tsd_boot0(void)							\
 {									\
 									\
 	if (a_cleanup != malloc_tsd_no_cleanup) {			\
-		if (pthread_key_create(&a_name##_tsd, a_cleanup) != 0)	\
+		if (pthread_key_create(&a_name##tsd_tsd, a_cleanup) !=	\
+		    0)							\
 			return (true);					\
 	}								\
-	a_name##_booted = true;						\
+	a_name##tsd_booted = true;					\
 	return (false);							\
 }									\
+a_attr void								\
+a_name##tsd_boot1(void)							\
+{									\
+									\
+	/* Do nothing. */						\
+}									\
+a_attr bool								\
+a_name##tsd_boot(void)							\
+{									\
+									\
+	return (a_name##tsd_boot0());					\
+}									\
 /* Get/set. */								\
 a_attr a_type *								\
-a_name##_tsd_get(void)							\
+a_name##tsd_get(void)							\
 {									\
 									\
-	assert(a_name##_booted);					\
-	return (&a_name##_tls);						\
+	assert(a_name##tsd_booted);					\
+	return (&a_name##tsd_tls);					\
 }									\
 a_attr void								\
-a_name##_tsd_set(a_type *val)						\
+a_name##tsd_set(a_type *val)						\
 {									\
 									\
-	assert(a_name##_booted);					\
-	a_name##_tls = (*val);						\
+	assert(a_name##tsd_booted);					\
+	a_name##tsd_tls = (*val);					\
 	if (a_cleanup != malloc_tsd_no_cleanup) {			\
-		if (pthread_setspecific(a_name##_tsd,			\
-		    (void *)(&a_name##_tls))) {				\
+		if (pthread_setspecific(a_name##tsd_tsd,		\
+		    (void *)(&a_name##tsd_tls))) {			\
 			malloc_write("<jemalloc>: Error"		\
 			    " setting TSD for "#a_name"\n");		\
 			if (opt_abort)					\
 				abort();				\
 		}							\
 	}								\
 }
 #elif (defined(_WIN32))
 #define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
     a_cleanup)								\
-/* Data structure. */							\
-typedef struct {							\
-	bool	initialized;						\
-	a_type	val;							\
-} a_name##_tsd_wrapper_t;						\
 /* Initialization/cleanup. */						\
 a_attr bool								\
-a_name##_tsd_cleanup_wrapper(void)					\
+a_name##tsd_cleanup_wrapper(void)					\
 {									\
-	a_name##_tsd_wrapper_t *wrapper;				\
+	DWORD error = GetLastError();					\
+	a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *)	\
+	    TlsGetValue(a_name##tsd_tsd);				\
+	SetLastError(error);						\
 									\
-	wrapper = (a_name##_tsd_wrapper_t *) TlsGetValue(a_name##_tsd);	\
 	if (wrapper == NULL)						\
 		return (false);						\
 	if (a_cleanup != malloc_tsd_no_cleanup &&			\
 	    wrapper->initialized) {					\
-		a_type val = wrapper->val;				\
-		a_type tsd_static_data = a_initializer;			\
 		wrapper->initialized = false;				\
-		wrapper->val = tsd_static_data;				\
-		a_cleanup(&val);					\
+		a_cleanup(&wrapper->val);				\
 		if (wrapper->initialized) {				\
 			/* Trigger another cleanup round. */		\
 			return (true);					\
 		}							\
 	}								\
 	malloc_tsd_dalloc(wrapper);					\
 	return (false);							\
 }									\
-a_attr bool								\
-a_name##_tsd_boot(void)							\
+a_attr void								\
+a_name##tsd_wrapper_set(a_name##tsd_wrapper_t *wrapper)			\
 {									\
 									\
-	a_name##_tsd = TlsAlloc();					\
-	if (a_name##_tsd == TLS_OUT_OF_INDEXES)				\
-		return (true);						\
-	if (a_cleanup != malloc_tsd_no_cleanup) {			\
-		malloc_tsd_cleanup_register(				\
-		    &a_name##_tsd_cleanup_wrapper);			\
+	if (!TlsSetValue(a_name##tsd_tsd, (void *)wrapper)) {		\
+		malloc_write("<jemalloc>: Error setting"		\
+		    " TSD for "#a_name"\n");				\
+		abort();						\
 	}								\
-	a_name##_booted = true;						\
-	return (false);							\
 }									\
-/* Get/set. */								\
-a_attr a_name##_tsd_wrapper_t *						\
-a_name##_tsd_get_wrapper(void)						\
+a_attr a_name##tsd_wrapper_t *						\
+a_name##tsd_wrapper_get(void)						\
 {									\
-	a_name##_tsd_wrapper_t *wrapper = (a_name##_tsd_wrapper_t *)	\
-	    TlsGetValue(a_name##_tsd);					\
-									\
-	if (wrapper == NULL) {						\
-		wrapper = (a_name##_tsd_wrapper_t *)			\
-		    malloc_tsd_malloc(sizeof(a_name##_tsd_wrapper_t));	\
+	DWORD error = GetLastError();					\
+	a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *)	\
+	    TlsGetValue(a_name##tsd_tsd);				\
+	SetLastError(error);						\
+									\
+	if (unlikely(wrapper == NULL)) {				\
+		wrapper = (a_name##tsd_wrapper_t *)			\
+		    malloc_tsd_malloc(sizeof(a_name##tsd_wrapper_t));	\
 		if (wrapper == NULL) {					\
 			malloc_write("<jemalloc>: Error allocating"	\
 			    " TSD for "#a_name"\n");			\
 			abort();					\
 		} else {						\
-			static a_type tsd_static_data = a_initializer;	\
 			wrapper->initialized = false;			\
-			wrapper->val = tsd_static_data;			\
-		}							\
-		if (!TlsSetValue(a_name##_tsd, (void *)wrapper)) {	\
-			malloc_write("<jemalloc>: Error setting"	\
-			    " TSD for "#a_name"\n");			\
-			abort();					\
+			wrapper->val = a_initializer;			\
 		}							\
+		a_name##tsd_wrapper_set(wrapper);			\
 	}								\
 	return (wrapper);						\
 }									\
+a_attr bool								\
+a_name##tsd_boot0(void)							\
+{									\
+									\
+	a_name##tsd_tsd = TlsAlloc();					\
+	if (a_name##tsd_tsd == TLS_OUT_OF_INDEXES)			\
+		return (true);						\
+	if (a_cleanup != malloc_tsd_no_cleanup) {			\
+		malloc_tsd_cleanup_register(				\
+		    &a_name##tsd_cleanup_wrapper);			\
+	}								\
+	a_name##tsd_wrapper_set(&a_name##tsd_boot_wrapper);		\
+	a_name##tsd_booted = true;					\
+	return (false);							\
+}									\
+a_attr void								\
+a_name##tsd_boot1(void)							\
+{									\
+	a_name##tsd_wrapper_t *wrapper;					\
+	wrapper = (a_name##tsd_wrapper_t *)				\
+	    malloc_tsd_malloc(sizeof(a_name##tsd_wrapper_t));		\
+	if (wrapper == NULL) {						\
+		malloc_write("<jemalloc>: Error allocating"		\
+		    " TSD for "#a_name"\n");				\
+		abort();						\
+	}								\
+	memcpy(wrapper, &a_name##tsd_boot_wrapper,			\
+	    sizeof(a_name##tsd_wrapper_t));				\
+	a_name##tsd_wrapper_set(wrapper);				\
+}									\
+a_attr bool								\
+a_name##tsd_boot(void)							\
+{									\
+									\
+	if (a_name##tsd_boot0())					\
+		return (true);						\
+	a_name##tsd_boot1();						\
+	return (false);							\
+}									\
+/* Get/set. */								\
 a_attr a_type *								\
-a_name##_tsd_get(void)							\
+a_name##tsd_get(void)							\
 {									\
-	a_name##_tsd_wrapper_t *wrapper;				\
+	a_name##tsd_wrapper_t *wrapper;					\
 									\
-	assert(a_name##_booted);					\
-	wrapper = a_name##_tsd_get_wrapper();				\
+	assert(a_name##tsd_booted);					\
+	wrapper = a_name##tsd_wrapper_get();				\
 	return (&wrapper->val);						\
 }									\
 a_attr void								\
-a_name##_tsd_set(a_type *val)						\
+a_name##tsd_set(a_type *val)						\
 {									\
-	a_name##_tsd_wrapper_t *wrapper;				\
+	a_name##tsd_wrapper_t *wrapper;					\
 									\
-	assert(a_name##_booted);					\
-	wrapper = a_name##_tsd_get_wrapper();				\
+	assert(a_name##tsd_booted);					\
+	wrapper = a_name##tsd_wrapper_get();				\
 	wrapper->val = *(val);						\
 	if (a_cleanup != malloc_tsd_no_cleanup)				\
 		wrapper->initialized = true;				\
 }
 #else
 #define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
     a_cleanup)								\
-/* Data structure. */							\
-typedef struct {							\
-	bool	initialized;						\
-	a_type	val;							\
-} a_name##_tsd_wrapper_t;						\
 /* Initialization/cleanup. */						\
 a_attr void								\
-a_name##_tsd_cleanup_wrapper(void *arg)					\
+a_name##tsd_cleanup_wrapper(void *arg)					\
 {									\
-	a_name##_tsd_wrapper_t *wrapper = (a_name##_tsd_wrapper_t *)arg;\
+	a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *)arg;	\
 									\
 	if (a_cleanup != malloc_tsd_no_cleanup &&			\
 	    wrapper->initialized) {					\
 		wrapper->initialized = false;				\
 		a_cleanup(&wrapper->val);				\
 		if (wrapper->initialized) {				\
 			/* Trigger another cleanup round. */		\
-			if (pthread_setspecific(a_name##_tsd,		\
+			if (pthread_setspecific(a_name##tsd_tsd,	\
 			    (void *)wrapper)) {				\
 				malloc_write("<jemalloc>: Error"	\
 				    " setting TSD for "#a_name"\n");	\
 				if (opt_abort)				\
 					abort();			\
 			}						\
 			return;						\
 		}							\
 	}								\
 	malloc_tsd_dalloc(wrapper);					\
 }									\
-a_attr bool								\
-a_name##_tsd_boot(void)							\
+a_attr void								\
+a_name##tsd_wrapper_set(a_name##tsd_wrapper_t *wrapper)			\
 {									\
 									\
-	if (pthread_key_create(&a_name##_tsd,				\
-	    a_name##_tsd_cleanup_wrapper) != 0)				\
-		return (true);						\
-	a_name##_booted = true;						\
-	return (false);							\
+	if (pthread_setspecific(a_name##tsd_tsd,			\
+	    (void *)wrapper)) {						\
+		malloc_write("<jemalloc>: Error setting"		\
+		    " TSD for "#a_name"\n");				\
+		abort();						\
+	}								\
 }									\
-/* Get/set. */								\
-a_attr a_name##_tsd_wrapper_t *						\
-a_name##_tsd_get_wrapper(void)						\
+a_attr a_name##tsd_wrapper_t *						\
+a_name##tsd_wrapper_get(void)						\
 {									\
-	a_name##_tsd_wrapper_t *wrapper = (a_name##_tsd_wrapper_t *)	\
-	    pthread_getspecific(a_name##_tsd);				\
+	a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *)	\
+	    pthread_getspecific(a_name##tsd_tsd);			\
 									\
-	if (wrapper == NULL) {						\
+	if (unlikely(wrapper == NULL)) {				\
 		tsd_init_block_t block;					\
 		wrapper = tsd_init_check_recursion(			\
-		    &a_name##_tsd_init_head, &block);			\
+		    &a_name##tsd_init_head, &block);			\
 		if (wrapper)						\
 		    return (wrapper);					\
-		wrapper = (a_name##_tsd_wrapper_t *)			\
-		    malloc_tsd_malloc(sizeof(a_name##_tsd_wrapper_t));	\
+		wrapper = (a_name##tsd_wrapper_t *)			\
+		    malloc_tsd_malloc(sizeof(a_name##tsd_wrapper_t));	\
 		block.data = wrapper;					\
 		if (wrapper == NULL) {					\
 			malloc_write("<jemalloc>: Error allocating"	\
 			    " TSD for "#a_name"\n");			\
 			abort();					\
 		} else {						\
-			static a_type tsd_static_data = a_initializer;	\
 			wrapper->initialized = false;			\
-			wrapper->val = tsd_static_data;			\
+			wrapper->val = a_initializer;			\
 		}							\
-		if (pthread_setspecific(a_name##_tsd,			\
-		    (void *)wrapper)) {					\
-			malloc_write("<jemalloc>: Error setting"	\
-			    " TSD for "#a_name"\n");			\
-			abort();					\
-		}							\
-		tsd_init_finish(&a_name##_tsd_init_head, &block);	\
+		a_name##tsd_wrapper_set(wrapper);			\
+		tsd_init_finish(&a_name##tsd_init_head, &block);	\
 	}								\
 	return (wrapper);						\
 }									\
+a_attr bool								\
+a_name##tsd_boot0(void)							\
+{									\
+									\
+	if (pthread_key_create(&a_name##tsd_tsd,			\
+	    a_name##tsd_cleanup_wrapper) != 0)				\
+		return (true);						\
+	a_name##tsd_wrapper_set(&a_name##tsd_boot_wrapper);		\
+	a_name##tsd_booted = true;					\
+	return (false);							\
+}									\
+a_attr void								\
+a_name##tsd_boot1(void)							\
+{									\
+	a_name##tsd_wrapper_t *wrapper;					\
+	wrapper = (a_name##tsd_wrapper_t *)				\
+	    malloc_tsd_malloc(sizeof(a_name##tsd_wrapper_t));		\
+	if (wrapper == NULL) {						\
+		malloc_write("<jemalloc>: Error allocating"		\
+		    " TSD for "#a_name"\n");				\
+		abort();						\
+	}								\
+	memcpy(wrapper, &a_name##tsd_boot_wrapper,			\
+	    sizeof(a_name##tsd_wrapper_t));				\
+	a_name##tsd_wrapper_set(wrapper);				\
+}									\
+a_attr bool								\
+a_name##tsd_boot(void)							\
+{									\
+									\
+	if (a_name##tsd_boot0())					\
+		return (true);						\
+	a_name##tsd_boot1();						\
+	return (false);							\
+}									\
+/* Get/set. */								\
 a_attr a_type *								\
-a_name##_tsd_get(void)							\
+a_name##tsd_get(void)							\
 {									\
-	a_name##_tsd_wrapper_t *wrapper;				\
+	a_name##tsd_wrapper_t *wrapper;					\
 									\
-	assert(a_name##_booted);					\
-	wrapper = a_name##_tsd_get_wrapper();				\
+	assert(a_name##tsd_booted);					\
+	wrapper = a_name##tsd_wrapper_get();				\
 	return (&wrapper->val);						\
 }									\
 a_attr void								\
-a_name##_tsd_set(a_type *val)						\
+a_name##tsd_set(a_type *val)						\
 {									\
-	a_name##_tsd_wrapper_t *wrapper;				\
+	a_name##tsd_wrapper_t *wrapper;					\
 									\
-	assert(a_name##_booted);					\
-	wrapper = a_name##_tsd_get_wrapper();				\
+	assert(a_name##tsd_booted);					\
+	wrapper = a_name##tsd_wrapper_get();				\
 	wrapper->val = *(val);						\
 	if (a_cleanup != malloc_tsd_no_cleanup)				\
 		wrapper->initialized = true;				\
 }
 #endif
 
@@ -407,28 +527,139 @@
 struct tsd_init_head_s {
 	ql_head(tsd_init_block_t)	blocks;
 	malloc_mutex_t			lock;
 };
 #endif
 
+#define	MALLOC_TSD							\
+/*  O(name,			type) */				\
+    O(tcache,			tcache_t *)				\
+    O(thread_allocated,		uint64_t)				\
+    O(thread_deallocated,	uint64_t)				\
+    O(prof_tdata,		prof_tdata_t *)				\
+    O(arena,			arena_t *)				\
+    O(arenas_cache,		arena_t **)				\
+    O(narenas_cache,		unsigned)				\
+    O(arenas_cache_bypass,	bool)					\
+    O(tcache_enabled,		tcache_enabled_t)			\
+    O(quarantine,		quarantine_t *)				\
+
+#define	TSD_INITIALIZER {						\
+    tsd_state_uninitialized,						\
+    NULL,								\
+    0,									\
+    0,									\
+    NULL,								\
+    NULL,								\
+    NULL,								\
+    0,									\
+    false,								\
+    tcache_enabled_default,						\
+    NULL								\
+}
+
+struct tsd_s {
+	tsd_state_t	state;
+#define	O(n, t)								\
+	t		n;
+MALLOC_TSD
+#undef O
+};
+
+static const tsd_t tsd_initializer = TSD_INITIALIZER;
+
+malloc_tsd_types(, tsd_t)
+
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 void	*malloc_tsd_malloc(size_t size);
 void	malloc_tsd_dalloc(void *wrapper);
-void	malloc_tsd_no_cleanup(void *);
+void	malloc_tsd_no_cleanup(void *arg);
 void	malloc_tsd_cleanup_register(bool (*f)(void));
-void	malloc_tsd_boot(void);
+bool	malloc_tsd_boot0(void);
+void	malloc_tsd_boot1(void);
 #if (!defined(JEMALLOC_MALLOC_THREAD_CLEANUP) && !defined(JEMALLOC_TLS) && \
     !defined(_WIN32))
 void	*tsd_init_check_recursion(tsd_init_head_t *head,
     tsd_init_block_t *block);
 void	tsd_init_finish(tsd_init_head_t *head, tsd_init_block_t *block);
 #endif
+void	tsd_cleanup(void *arg);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
+#ifndef JEMALLOC_ENABLE_INLINE
+malloc_tsd_protos(JEMALLOC_ATTR(unused), , tsd_t)
+
+tsd_t	*tsd_fetch(void);
+bool	tsd_nominal(tsd_t *tsd);
+#define	O(n, t)								\
+t	*tsd_##n##p_get(tsd_t *tsd);					\
+t	tsd_##n##_get(tsd_t *tsd);					\
+void	tsd_##n##_set(tsd_t *tsd, t n);
+MALLOC_TSD
+#undef O
+#endif
+
+#if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_TSD_C_))
+malloc_tsd_externs(, tsd_t)
+malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, , tsd_t, tsd_initializer, tsd_cleanup)
+
+JEMALLOC_ALWAYS_INLINE tsd_t *
+tsd_fetch(void)
+{
+	tsd_t *tsd = tsd_get();
+
+	if (unlikely(tsd->state != tsd_state_nominal)) {
+		if (tsd->state == tsd_state_uninitialized) {
+			tsd->state = tsd_state_nominal;
+			/* Trigger cleanup handler registration. */
+			tsd_set(tsd);
+		} else if (tsd->state == tsd_state_purgatory) {
+			tsd->state = tsd_state_reincarnated;
+			tsd_set(tsd);
+		} else
+			assert(tsd->state == tsd_state_reincarnated);
+	}
+
+	return (tsd);
+}
+
+JEMALLOC_INLINE bool
+tsd_nominal(tsd_t *tsd)
+{
+
+	return (tsd->state == tsd_state_nominal);
+}
+
+#define	O(n, t)								\
+JEMALLOC_ALWAYS_INLINE t *						\
+tsd_##n##p_get(tsd_t *tsd)						\
+{									\
+									\
+	return (&tsd->n);						\
+}									\
+									\
+JEMALLOC_ALWAYS_INLINE t						\
+tsd_##n##_get(tsd_t *tsd)						\
+{									\
+									\
+	return (*tsd_##n##p_get(tsd));					\
+}									\
+									\
+JEMALLOC_ALWAYS_INLINE void						\
+tsd_##n##_set(tsd_t *tsd, t n)						\
+{									\
+									\
+	assert(tsd->state == tsd_state_nominal);			\
+	tsd->n = n;							\
+}
+MALLOC_TSD
+#undef O
+#endif
+
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/util.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/util.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/internal/util.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal/util.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,9 +1,39 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
+#ifdef _WIN32
+#  ifdef _WIN64
+#    define FMT64_PREFIX "ll"
+#    define FMTPTR_PREFIX "ll"
+#  else
+#    define FMT64_PREFIX "ll"
+#    define FMTPTR_PREFIX ""
+#  endif
+#  define FMTd32 "d"
+#  define FMTu32 "u"
+#  define FMTx32 "x"
+#  define FMTd64 FMT64_PREFIX "d"
+#  define FMTu64 FMT64_PREFIX "u"
+#  define FMTx64 FMT64_PREFIX "x"
+#  define FMTdPTR FMTPTR_PREFIX "d"
+#  define FMTuPTR FMTPTR_PREFIX "u"
+#  define FMTxPTR FMTPTR_PREFIX "x"
+#else
+#  include <inttypes.h>
+#  define FMTd32 PRId32
+#  define FMTu32 PRIu32
+#  define FMTx32 PRIx32
+#  define FMTd64 PRId64
+#  define FMTu64 PRIu64
+#  define FMTx64 PRIx64
+#  define FMTdPTR PRIdPTR
+#  define FMTuPTR PRIuPTR
+#  define FMTxPTR PRIxPTR
+#endif
+
 /* Size of stack-allocated buffer passed to buferror(). */
 #define	BUFERROR_BUF		64
 
 /*
  * Size of stack-allocated buffer used by malloc_{,v,vc}printf().  This must be
  * large enough for all possible uses within jemalloc.
@@ -19,24 +49,48 @@
 /*
  * Silence compiler warnings due to uninitialized values.  This is used
  * wherever the compiler fails to recognize that the variable is never used
  * uninitialized.
  */
 #ifdef JEMALLOC_CC_SILENCE
-#  define JEMALLOC_CC_SILENCE_INIT(v) = v
+#	define JEMALLOC_CC_SILENCE_INIT(v) = v
 #else
-#  define JEMALLOC_CC_SILENCE_INIT(v)
+#	define JEMALLOC_CC_SILENCE_INIT(v)
+#endif
+
+#define	JEMALLOC_GNUC_PREREQ(major, minor)				\
+    (!defined(__clang__) &&						\
+    (__GNUC__ > (major) || (__GNUC__ == (major) && __GNUC_MINOR__ >= (minor))))
+#ifndef __has_builtin
+#  define __has_builtin(builtin) (0)
+#endif
+#define	JEMALLOC_CLANG_HAS_BUILTIN(builtin)				\
+    (defined(__clang__) && __has_builtin(builtin))
+
+#ifdef __GNUC__
+#	define likely(x)   __builtin_expect(!!(x), 1)
+#	define unlikely(x) __builtin_expect(!!(x), 0)
+#  if JEMALLOC_GNUC_PREREQ(4, 6) ||					\
+      JEMALLOC_CLANG_HAS_BUILTIN(__builtin_unreachable)
+#	define unreachable() __builtin_unreachable()
+#  else
+#	define unreachable()
+#  endif
+#else
+#	define likely(x)   !!(x)
+#	define unlikely(x) !!(x)
+#	define unreachable()
 #endif
 
 /*
  * Define a custom assert() in order to reduce the chances of deadlock during
  * assertion failure.
  */
 #ifndef assert
 #define	assert(e) do {							\
-	if (config_debug && !(e)) {					\
+	if (unlikely(config_debug && !(e))) {				\
 		malloc_printf(						\
 		    "<jemalloc>: %s:%d: Failed assertion: \"%s\"\n",	\
 		    __FILE__, __LINE__, #e);				\
 		abort();						\
 	}								\
 } while (0)
@@ -47,12 +101,13 @@
 	if (config_debug) {						\
 		malloc_printf(						\
 		    "<jemalloc>: %s:%d: Unreachable code reached\n",	\
 		    __FILE__, __LINE__);				\
 		abort();						\
 	}								\
+	unreachable();							\
 } while (0)
 #endif
 
 #ifndef not_implemented
 #define	not_implemented() do {						\
 	if (config_debug) {						\
@@ -62,20 +117,20 @@
 	}								\
 } while (0)
 #endif
 
 #ifndef assert_not_implemented
 #define	assert_not_implemented(e) do {					\
-	if (config_debug && !(e))					\
+	if (unlikely(config_debug && !(e)))				\
 		not_implemented();					\
 } while (0)
 #endif
 
 /* Use to assert a particular configuration, e.g., cassert(config_debug). */
 #define	cassert(c) do {							\
-	if ((c) == false)						\
+	if (unlikely(!(c)))						\
 		not_reached();						\
 } while (0)
 
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
@@ -93,31 +148,53 @@
  * malloc_vsnprintf() supports a subset of snprintf(3) that avoids floating
  * point math.
  */
 int	malloc_vsnprintf(char *str, size_t size, const char *format,
     va_list ap);
 int	malloc_snprintf(char *str, size_t size, const char *format, ...)
-    JEMALLOC_ATTR(format(printf, 3, 4));
+    JEMALLOC_FORMAT_PRINTF(3, 4);
 void	malloc_vcprintf(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *format, va_list ap);
 void malloc_cprintf(void (*write)(void *, const char *), void *cbopaque,
-    const char *format, ...) JEMALLOC_ATTR(format(printf, 3, 4));
-void	malloc_printf(const char *format, ...)
-    JEMALLOC_ATTR(format(printf, 1, 2));
+    const char *format, ...) JEMALLOC_FORMAT_PRINTF(3, 4);
+void	malloc_printf(const char *format, ...) JEMALLOC_FORMAT_PRINTF(1, 2);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
+int	jemalloc_ffsl(long bitmap);
+int	jemalloc_ffs(int bitmap);
 size_t	pow2_ceil(size_t x);
+size_t	lg_floor(size_t x);
 void	set_errno(int errnum);
 int	get_errno(void);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_UTIL_C_))
+
+/* Sanity check. */
+#if !defined(JEMALLOC_INTERNAL_FFSL) || !defined(JEMALLOC_INTERNAL_FFS)
+#  error Both JEMALLOC_INTERNAL_FFSL && JEMALLOC_INTERNAL_FFS should have been defined by configure
+#endif
+
+JEMALLOC_ALWAYS_INLINE int
+jemalloc_ffsl(long bitmap)
+{
+
+	return (JEMALLOC_INTERNAL_FFSL(bitmap));
+}
+
+JEMALLOC_ALWAYS_INLINE int
+jemalloc_ffs(int bitmap)
+{
+
+	return (JEMALLOC_INTERNAL_FFS(bitmap));
+}
+
 /* Compute the smallest power of 2 that is >= x. */
 JEMALLOC_INLINE size_t
 pow2_ceil(size_t x)
 {
 
 	x--;
@@ -130,25 +207,100 @@
 	x |= x >> 32;
 #endif
 	x++;
 	return (x);
 }
 
-/* Sets error code */
+#if (defined(__i386__) || defined(__amd64__) || defined(__x86_64__))
+JEMALLOC_INLINE size_t
+lg_floor(size_t x)
+{
+	size_t ret;
+
+	assert(x != 0);
+
+	asm ("bsr %1, %0"
+	    : "=r"(ret) // Outputs.
+	    : "r"(x)    // Inputs.
+	    );
+	return (ret);
+}
+#elif (defined(_MSC_VER))
+JEMALLOC_INLINE size_t
+lg_floor(size_t x)
+{
+	unsigned long ret;
+
+	assert(x != 0);
+
+#if (LG_SIZEOF_PTR == 3)
+	_BitScanReverse64(&ret, x);
+#elif (LG_SIZEOF_PTR == 2)
+	_BitScanReverse(&ret, x);
+#else
+#  error "Unsupported type sizes for lg_floor()"
+#endif
+	return (ret);
+}
+#elif (defined(JEMALLOC_HAVE_BUILTIN_CLZ))
+JEMALLOC_INLINE size_t
+lg_floor(size_t x)
+{
+
+	assert(x != 0);
+
+#if (LG_SIZEOF_PTR == LG_SIZEOF_INT)
+	return (((8 << LG_SIZEOF_PTR) - 1) - __builtin_clz(x));
+#elif (LG_SIZEOF_PTR == LG_SIZEOF_LONG)
+	return (((8 << LG_SIZEOF_PTR) - 1) - __builtin_clzl(x));
+#else
+#  error "Unsupported type sizes for lg_floor()"
+#endif
+}
+#else
+JEMALLOC_INLINE size_t
+lg_floor(size_t x)
+{
+
+	assert(x != 0);
+
+	x |= (x >> 1);
+	x |= (x >> 2);
+	x |= (x >> 4);
+	x |= (x >> 8);
+	x |= (x >> 16);
+#if (LG_SIZEOF_PTR == 3 && LG_SIZEOF_PTR == LG_SIZEOF_LONG)
+	x |= (x >> 32);
+	if (x == KZU(0xffffffffffffffff))
+		return (63);
+	x++;
+	return (jemalloc_ffsl(x) - 2);
+#elif (LG_SIZEOF_PTR == 2)
+	if (x == KZU(0xffffffff))
+		return (31);
+	x++;
+	return (jemalloc_ffs(x) - 2);
+#else
+#  error "Unsupported type sizes for lg_floor()"
+#endif
+}
+#endif
+
+/* Set error code. */
 JEMALLOC_INLINE void
 set_errno(int errnum)
 {
 
 #ifdef _WIN32
 	SetLastError(errnum);
 #else
 	errno = errnum;
 #endif
 }
 
-/* Get last error code */
+/* Get last error code. */
 JEMALLOC_INLINE int
 get_errno(void)
 {
 
 #ifdef _WIN32
 	return (GetLastError());
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/internal: valgrind.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_defs.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_defs.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_defs.h	2017-09-27 22:47:53.322963470 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_defs.h	2017-09-27 22:49:15.122960473 +0800
@@ -1,12 +1,18 @@
 /* include/jemalloc/jemalloc_defs.h.  Generated from jemalloc_defs.h.in by configure.  */
 /* Defined if __attribute__((...)) syntax is supported. */
 #define JEMALLOC_HAVE_ATTR 
 
-/* Support the experimental API. */
-#define JEMALLOC_EXPERIMENTAL 
+/* Defined if alloc_size attribute is supported. */
+#define JEMALLOC_HAVE_ATTR_ALLOC_SIZE 
+
+/* Defined if format(gnu_printf, ...) attribute is supported. */
+#define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF 
+
+/* Defined if format(printf, ...) attribute is supported. */
+#define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF 
 
 /*
  * Define overrides for non-standard allocator-related functions if they are
  * present on the system.
  */
 #define JEMALLOC_OVERRIDE_MEMALIGN 
@@ -18,8 +24,15 @@
  *   size_t malloc_usable_size(const void *ptr);
  *
  * Match the operating system's prototype.
  */
 #define JEMALLOC_USABLE_SIZE_CONST 
 
+/*
+ * If defined, specify throw() for the public function prototypes when compiling
+ * with C++.  The only justification for this is to match the prototypes that
+ * glibc defines.
+ */
+#define JEMALLOC_USE_CXX_THROW 
+
 /* sizeof(void *) == 2^LG_SIZEOF_PTR. */
 #define LG_SIZEOF_PTR 3
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_defs.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_defs.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_defs.h.in	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_defs.h.in	2016-05-06 15:11:36.000000000 +0800
@@ -1,11 +1,17 @@
 /* Defined if __attribute__((...)) syntax is supported. */
 #undef JEMALLOC_HAVE_ATTR
 
-/* Support the experimental API. */
-#undef JEMALLOC_EXPERIMENTAL
+/* Defined if alloc_size attribute is supported. */
+#undef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
+
+/* Defined if format(gnu_printf, ...) attribute is supported. */
+#undef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
+
+/* Defined if format(printf, ...) attribute is supported. */
+#undef JEMALLOC_HAVE_ATTR_FORMAT_PRINTF
 
 /*
  * Define overrides for non-standard allocator-related functions if they are
  * present on the system.
  */
 #undef JEMALLOC_OVERRIDE_MEMALIGN
@@ -17,8 +23,15 @@
  *   size_t malloc_usable_size(const void *ptr);
  *
  * Match the operating system's prototype.
  */
 #undef JEMALLOC_USABLE_SIZE_CONST
 
+/*
+ * If defined, specify throw() for the public function prototypes when compiling
+ * with C++.  The only justification for this is to match the prototypes that
+ * glibc defines.
+ */
+#undef JEMALLOC_USE_CXX_THROW
+
 /* sizeof(void *) == 2^LG_SIZEOF_PTR. */
 #undef LG_SIZEOF_PTR
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc.h	2017-09-27 22:47:53.578963461 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc.h	2017-09-27 22:49:15.490960459 +0800
@@ -4,14 +4,20 @@
 extern "C" {
 #endif
 
 /* Defined if __attribute__((...)) syntax is supported. */
 #define	JEMALLOC_HAVE_ATTR
 
-/* Support the experimental API. */
-#define	JEMALLOC_EXPERIMENTAL
+/* Defined if alloc_size attribute is supported. */
+#define	JEMALLOC_HAVE_ATTR_ALLOC_SIZE
+
+/* Defined if format(gnu_printf, ...) attribute is supported. */
+#define	JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
+
+/* Defined if format(printf, ...) attribute is supported. */
+#define	JEMALLOC_HAVE_ATTR_FORMAT_PRINTF
 
 /*
  * Define overrides for non-standard allocator-related functions if they are
  * present on the system.
  */
 #define	JEMALLOC_OVERRIDE_MEMALIGN
@@ -23,12 +29,19 @@
  *   size_t malloc_usable_size(const void *ptr);
  *
  * Match the operating system's prototype.
  */
 #define	JEMALLOC_USABLE_SIZE_CONST
 
+/*
+ * If defined, specify throw() for the public function prototypes when compiling
+ * with C++.  The only justification for this is to match the prototypes that
+ * glibc defines.
+ */
+#define	JEMALLOC_USE_CXX_THROW
+
 /* sizeof(void *) == 2^LG_SIZEOF_PTR. */
 #define	LG_SIZEOF_PTR 3
 
 /*
  * Name mangling for public symbols is controlled by --with-mangling and
  * --with-jemalloc-prefix.  With default settings the je_ prefix is stripped by
@@ -45,147 +58,250 @@
 #  define je_free je_free
 #  define je_mallocx je_mallocx
 #  define je_rallocx je_rallocx
 #  define je_xallocx je_xallocx
 #  define je_sallocx je_sallocx
 #  define je_dallocx je_dallocx
+#  define je_sdallocx je_sdallocx
 #  define je_nallocx je_nallocx
 #  define je_mallctl je_mallctl
 #  define je_mallctlnametomib je_mallctlnametomib
 #  define je_mallctlbymib je_mallctlbymib
 #  define je_malloc_stats_print je_malloc_stats_print
 #  define je_malloc_usable_size je_malloc_usable_size
 #  define je_memalign je_memalign
 #  define je_valloc je_valloc
-#  define je_allocm je_allocm
-#  define je_dallocm je_dallocm
-#  define je_nallocm je_nallocm
-#  define je_rallocm je_rallocm
-#  define je_sallocm je_sallocm
 #endif
 
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdint.h>
 #include <limits.h>
 #include <strings.h>
 
-#define	JEMALLOC_VERSION "3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340"
-#define	JEMALLOC_VERSION_MAJOR 3
-#define	JEMALLOC_VERSION_MINOR 6
-#define	JEMALLOC_VERSION_BUGFIX 0
+#define	JEMALLOC_VERSION "4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c"
+#define	JEMALLOC_VERSION_MAJOR 4
+#define	JEMALLOC_VERSION_MINOR 0
+#define	JEMALLOC_VERSION_BUGFIX 3
 #define	JEMALLOC_VERSION_NREV 0
-#define	JEMALLOC_VERSION_GID "46c0af68bd248b04df75e4f92d5fb804c3d75340"
+#define	JEMALLOC_VERSION_GID "e9192eacf8935e29fc62fddc2701f7942b1cc02c"
 
 #  define MALLOCX_LG_ALIGN(la)	(la)
 #  if LG_SIZEOF_PTR == 2
 #    define MALLOCX_ALIGN(a)	(ffs(a)-1)
 #  else
 #    define MALLOCX_ALIGN(a)						\
 	 ((a < (size_t)INT_MAX) ? ffs(a)-1 : ffs(a>>32)+31)
 #  endif
 #  define MALLOCX_ZERO	((int)0x40)
-/* Bias arena index bits so that 0 encodes "MALLOCX_ARENA() unspecified". */
-#  define MALLOCX_ARENA(a)	((int)(((a)+1) << 8))
+/*
+ * Bias tcache index bits so that 0 encodes "automatic tcache management", and 1
+ * encodes MALLOCX_TCACHE_NONE.
+ */
+#  define MALLOCX_TCACHE(tc)	((int)(((tc)+2) << 8))
+#  define MALLOCX_TCACHE_NONE	MALLOCX_TCACHE(-1)
+/*
+ * Bias arena index bits so that 0 encodes "use an automatically chosen arena".
+ */
+#  define MALLOCX_ARENA(a)	((int)(((a)+1) << 20))
 
-#ifdef JEMALLOC_EXPERIMENTAL
-#  define ALLOCM_LG_ALIGN(la)	(la)
-#  if LG_SIZEOF_PTR == 2
-#    define ALLOCM_ALIGN(a)	(ffs(a)-1)
-#  else
-#    define ALLOCM_ALIGN(a)						\
-	 ((a < (size_t)INT_MAX) ? ffs(a)-1 : ffs(a>>32)+31)
-#  endif
-#  define ALLOCM_ZERO	((int)0x40)
-#  define ALLOCM_NO_MOVE	((int)0x80)
-/* Bias arena index bits so that 0 encodes "ALLOCM_ARENA() unspecified". */
-#  define ALLOCM_ARENA(a)	((int)(((a)+1) << 8))
-#  define ALLOCM_SUCCESS	0
-#  define ALLOCM_ERR_OOM	1
-#  define ALLOCM_ERR_NOT_MOVED	2
+#if defined(__cplusplus) && defined(JEMALLOC_USE_CXX_THROW)
+#  define JEMALLOC_CXX_THROW throw()
+#else
+#  define JEMALLOC_CXX_THROW
 #endif
 
 #ifdef JEMALLOC_HAVE_ATTR
 #  define JEMALLOC_ATTR(s) __attribute__((s))
-#  define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
 #  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
-#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  ifdef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
+#    define JEMALLOC_ALLOC_SIZE(s) JEMALLOC_ATTR(alloc_size(s))
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2) JEMALLOC_ATTR(alloc_size(s1, s2))
+#  else
+#    define JEMALLOC_ALLOC_SIZE(s)
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  endif
+#  ifndef JEMALLOC_EXPORT
+#    define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
+#  endif
+#  ifdef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(gnu_printf, s, i))
+#  elif defined(JEMALLOC_HAVE_ATTR_FORMAT_PRINTF)
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(printf, s, i))
+#  else
+#    define JEMALLOC_FORMAT_PRINTF(s, i)
+#  endif
 #  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
+#  define JEMALLOC_NOTHROW JEMALLOC_ATTR(nothrow)
+#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  define JEMALLOC_RESTRICT_RETURN
+#  define JEMALLOC_ALLOCATOR
 #elif _MSC_VER
 #  define JEMALLOC_ATTR(s)
-#  ifdef DLLEXPORT
-#    define JEMALLOC_EXPORT __declspec(dllexport)
+#  define JEMALLOC_ALIGNED(s) __declspec(align(s))
+#  define JEMALLOC_ALLOC_SIZE(s)
+#  define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  ifndef JEMALLOC_EXPORT
+#    ifdef DLLEXPORT
+#      define JEMALLOC_EXPORT __declspec(dllexport)
+#    else
+#      define JEMALLOC_EXPORT __declspec(dllimport)
+#    endif
+#  endif
+#  define JEMALLOC_FORMAT_PRINTF(s, i)
+#  define JEMALLOC_NOINLINE __declspec(noinline)
+#  ifdef __cplusplus
+#    define JEMALLOC_NOTHROW __declspec(nothrow)
 #  else
-#    define JEMALLOC_EXPORT __declspec(dllimport)
+#    define JEMALLOC_NOTHROW
 #  endif
-#  define JEMALLOC_ALIGNED(s) __declspec(align(s))
 #  define JEMALLOC_SECTION(s) __declspec(allocate(s))
-#  define JEMALLOC_NOINLINE __declspec(noinline)
+#  define JEMALLOC_RESTRICT_RETURN __declspec(restrict)
+#  if _MSC_VER >= 1900 && !defined(__EDG__)
+#    define JEMALLOC_ALLOCATOR __declspec(allocator)
+#  else
+#    define JEMALLOC_ALLOCATOR
+#  endif
 #else
 #  define JEMALLOC_ATTR(s)
-#  define JEMALLOC_EXPORT
 #  define JEMALLOC_ALIGNED(s)
-#  define JEMALLOC_SECTION(s)
+#  define JEMALLOC_ALLOC_SIZE(s)
+#  define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  define JEMALLOC_EXPORT
+#  define JEMALLOC_FORMAT_PRINTF(s, i)
 #  define JEMALLOC_NOINLINE
+#  define JEMALLOC_NOTHROW
+#  define JEMALLOC_SECTION(s)
+#  define JEMALLOC_RESTRICT_RETURN
+#  define JEMALLOC_ALLOCATOR
 #endif
 
 /*
  * The je_ prefix on the following public symbol declarations is an artifact
  * of namespace management, and should be omitted in application code unless
  * JEMALLOC_NO_DEMANGLE is defined (see jemalloc_mangle.h).
  */
 extern JEMALLOC_EXPORT const char	*je_malloc_conf;
 extern JEMALLOC_EXPORT void		(*je_malloc_message)(void *cbopaque,
     const char *s);
 
-JEMALLOC_EXPORT void	*je_malloc(size_t size) JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT void	*je_calloc(size_t num, size_t size)
-    JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT int	je_posix_memalign(void **memptr, size_t alignment,
-    size_t size) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT void	*je_aligned_alloc(size_t alignment, size_t size)
-    JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT void	*je_realloc(void *ptr, size_t size);
-JEMALLOC_EXPORT void	je_free(void *ptr);
-
-JEMALLOC_EXPORT void	*je_mallocx(size_t size, int flags);
-JEMALLOC_EXPORT void	*je_rallocx(void *ptr, size_t size, int flags);
-JEMALLOC_EXPORT size_t	je_xallocx(void *ptr, size_t size, size_t extra,
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_malloc(size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_calloc(size_t num, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	je_posix_memalign(void **memptr,
+    size_t alignment, size_t size) JEMALLOC_CXX_THROW JEMALLOC_ATTR(nonnull(1));
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_aligned_alloc(size_t alignment,
+    size_t size) JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc)
+    JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_realloc(void *ptr, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	je_free(void *ptr)
+    JEMALLOC_CXX_THROW;
+
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_mallocx(size_t size, int flags)
+    JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_rallocx(void *ptr, size_t size,
+    int flags) JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	je_xallocx(void *ptr, size_t size,
+    size_t extra, int flags);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	je_sallocx(const void *ptr,
+    int flags) JEMALLOC_ATTR(pure);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	je_dallocx(void *ptr, int flags);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	je_sdallocx(void *ptr, size_t size,
     int flags);
-JEMALLOC_EXPORT size_t	je_sallocx(const void *ptr, int flags);
-JEMALLOC_EXPORT void	je_dallocx(void *ptr, int flags);
-JEMALLOC_EXPORT size_t	je_nallocx(size_t size, int flags);
-
-JEMALLOC_EXPORT int	je_mallctl(const char *name, void *oldp,
-    size_t *oldlenp, void *newp, size_t newlen);
-JEMALLOC_EXPORT int	je_mallctlnametomib(const char *name, size_t *mibp,
-    size_t *miblenp);
-JEMALLOC_EXPORT int	je_mallctlbymib(const size_t *mib, size_t miblen,
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	je_nallocx(size_t size, int flags)
+    JEMALLOC_ATTR(pure);
+
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	je_mallctl(const char *name,
     void *oldp, size_t *oldlenp, void *newp, size_t newlen);
-JEMALLOC_EXPORT void	je_malloc_stats_print(void (*write_cb)(void *,
-    const char *), void *je_cbopaque, const char *opts);
-JEMALLOC_EXPORT size_t	je_malloc_usable_size(
-    JEMALLOC_USABLE_SIZE_CONST void *ptr);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	je_mallctlnametomib(const char *name,
+    size_t *mibp, size_t *miblenp);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	je_mallctlbymib(const size_t *mib,
+    size_t miblen, void *oldp, size_t *oldlenp, void *newp, size_t newlen);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	je_malloc_stats_print(
+    void (*write_cb)(void *, const char *), void *je_cbopaque,
+    const char *opts);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	je_malloc_usable_size(
+    JEMALLOC_USABLE_SIZE_CONST void *ptr) JEMALLOC_CXX_THROW;
 
 #ifdef JEMALLOC_OVERRIDE_MEMALIGN
-JEMALLOC_EXPORT void *	je_memalign(size_t alignment, size_t size)
-    JEMALLOC_ATTR(malloc);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_memalign(size_t alignment, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc);
 #endif
 
 #ifdef JEMALLOC_OVERRIDE_VALLOC
-JEMALLOC_EXPORT void *	je_valloc(size_t size) JEMALLOC_ATTR(malloc);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_valloc(size_t size) JEMALLOC_CXX_THROW
+    JEMALLOC_ATTR(malloc);
 #endif
 
-#ifdef JEMALLOC_EXPERIMENTAL
-JEMALLOC_EXPORT int	je_allocm(void **ptr, size_t *rsize, size_t size,
-    int flags) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	je_rallocm(void **ptr, size_t *rsize, size_t size,
-    size_t extra, int flags) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	je_sallocm(const void *ptr, size_t *rsize, int flags)
-    JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	je_dallocm(void *ptr, int flags)
-    JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	je_nallocm(size_t *rsize, size_t size, int flags);
-#endif
+/*
+ * void *
+ * chunk_alloc(void *new_addr, size_t size, size_t alignment, bool *zero,
+ *     bool *commit, unsigned arena_ind);
+ */
+typedef void *(chunk_alloc_t)(void *, size_t, size_t, bool *, bool *, unsigned);
+
+/*
+ * bool
+ * chunk_dalloc(void *chunk, size_t size, bool committed, unsigned arena_ind);
+ */
+typedef bool (chunk_dalloc_t)(void *, size_t, bool, unsigned);
+
+/*
+ * bool
+ * chunk_commit(void *chunk, size_t size, size_t offset, size_t length,
+ *     unsigned arena_ind);
+ */
+typedef bool (chunk_commit_t)(void *, size_t, size_t, size_t, unsigned);
+
+/*
+ * bool
+ * chunk_decommit(void *chunk, size_t size, size_t offset, size_t length,
+ *     unsigned arena_ind);
+ */
+typedef bool (chunk_decommit_t)(void *, size_t, size_t, size_t, unsigned);
+
+/*
+ * bool
+ * chunk_purge(void *chunk, size_t size, size_t offset, size_t length,
+ *     unsigned arena_ind);
+ */
+typedef bool (chunk_purge_t)(void *, size_t, size_t, size_t, unsigned);
+
+/*
+ * bool
+ * chunk_split(void *chunk, size_t size, size_t size_a, size_t size_b,
+ *     bool committed, unsigned arena_ind);
+ */
+typedef bool (chunk_split_t)(void *, size_t, size_t, size_t, bool, unsigned);
+
+/*
+ * bool
+ * chunk_merge(void *chunk_a, size_t size_a, void *chunk_b, size_t size_b,
+ *     bool committed, unsigned arena_ind);
+ */
+typedef bool (chunk_merge_t)(void *, size_t, void *, size_t, bool, unsigned);
+
+typedef struct {
+	chunk_alloc_t		*alloc;
+	chunk_dalloc_t		*dalloc;
+	chunk_commit_t		*commit;
+	chunk_decommit_t	*decommit;
+	chunk_purge_t		*purge;
+	chunk_split_t		*split;
+	chunk_merge_t		*merge;
+} chunk_hooks_t;
 
 /*
  * By default application code must explicitly refer to mangled symbol names,
  * so that it is possible to use jemalloc in conjunction with another allocator
  * in the same application.  Define JEMALLOC_MANGLE in order to cause automatic
  * name mangling that matches the API prefixing that happened as a result of
@@ -205,25 +321,21 @@
 #  define free je_free
 #  define mallocx je_mallocx
 #  define rallocx je_rallocx
 #  define xallocx je_xallocx
 #  define sallocx je_sallocx
 #  define dallocx je_dallocx
+#  define sdallocx je_sdallocx
 #  define nallocx je_nallocx
 #  define mallctl je_mallctl
 #  define mallctlnametomib je_mallctlnametomib
 #  define mallctlbymib je_mallctlbymib
 #  define malloc_stats_print je_malloc_stats_print
 #  define malloc_usable_size je_malloc_usable_size
 #  define memalign je_memalign
 #  define valloc je_valloc
-#  define allocm je_allocm
-#  define dallocm je_dallocm
-#  define nallocm je_nallocm
-#  define rallocm je_rallocm
-#  define sallocm je_sallocm
 #endif
 
 /*
  * The je_* macros can be used as stable alternative names for the
  * public jemalloc API if JEMALLOC_NO_DEMANGLE is defined.  This is primarily
  * meant for use in jemalloc itself, but it can be used by application code to
@@ -241,25 +353,21 @@
 #  undef je_free
 #  undef je_mallocx
 #  undef je_rallocx
 #  undef je_xallocx
 #  undef je_sallocx
 #  undef je_dallocx
+#  undef je_sdallocx
 #  undef je_nallocx
 #  undef je_mallctl
 #  undef je_mallctlnametomib
 #  undef je_mallctlbymib
 #  undef je_malloc_stats_print
 #  undef je_malloc_usable_size
 #  undef je_memalign
 #  undef je_valloc
-#  undef je_allocm
-#  undef je_dallocm
-#  undef je_nallocm
-#  undef je_rallocm
-#  undef je_sallocm
 #endif
 
 #ifdef __cplusplus
-};
+}
 #endif
 #endif /* JEMALLOC_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_macros.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_macros.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_macros.h	2017-09-27 22:47:53.246963473 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_macros.h	2017-09-27 22:49:15.022960476 +0800
@@ -1,61 +1,102 @@
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdint.h>
 #include <limits.h>
 #include <strings.h>
 
-#define	JEMALLOC_VERSION "3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340"
-#define	JEMALLOC_VERSION_MAJOR 3
-#define	JEMALLOC_VERSION_MINOR 6
-#define	JEMALLOC_VERSION_BUGFIX 0
+#define	JEMALLOC_VERSION "4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c"
+#define	JEMALLOC_VERSION_MAJOR 4
+#define	JEMALLOC_VERSION_MINOR 0
+#define	JEMALLOC_VERSION_BUGFIX 3
 #define	JEMALLOC_VERSION_NREV 0
-#define	JEMALLOC_VERSION_GID "46c0af68bd248b04df75e4f92d5fb804c3d75340"
+#define	JEMALLOC_VERSION_GID "e9192eacf8935e29fc62fddc2701f7942b1cc02c"
 
 #  define MALLOCX_LG_ALIGN(la)	(la)
 #  if LG_SIZEOF_PTR == 2
 #    define MALLOCX_ALIGN(a)	(ffs(a)-1)
 #  else
 #    define MALLOCX_ALIGN(a)						\
 	 ((a < (size_t)INT_MAX) ? ffs(a)-1 : ffs(a>>32)+31)
 #  endif
 #  define MALLOCX_ZERO	((int)0x40)
-/* Bias arena index bits so that 0 encodes "MALLOCX_ARENA() unspecified". */
-#  define MALLOCX_ARENA(a)	((int)(((a)+1) << 8))
+/*
+ * Bias tcache index bits so that 0 encodes "automatic tcache management", and 1
+ * encodes MALLOCX_TCACHE_NONE.
+ */
+#  define MALLOCX_TCACHE(tc)	((int)(((tc)+2) << 8))
+#  define MALLOCX_TCACHE_NONE	MALLOCX_TCACHE(-1)
+/*
+ * Bias arena index bits so that 0 encodes "use an automatically chosen arena".
+ */
+#  define MALLOCX_ARENA(a)	((int)(((a)+1) << 20))
 
-#ifdef JEMALLOC_EXPERIMENTAL
-#  define ALLOCM_LG_ALIGN(la)	(la)
-#  if LG_SIZEOF_PTR == 2
-#    define ALLOCM_ALIGN(a)	(ffs(a)-1)
-#  else
-#    define ALLOCM_ALIGN(a)						\
-	 ((a < (size_t)INT_MAX) ? ffs(a)-1 : ffs(a>>32)+31)
-#  endif
-#  define ALLOCM_ZERO	((int)0x40)
-#  define ALLOCM_NO_MOVE	((int)0x80)
-/* Bias arena index bits so that 0 encodes "ALLOCM_ARENA() unspecified". */
-#  define ALLOCM_ARENA(a)	((int)(((a)+1) << 8))
-#  define ALLOCM_SUCCESS	0
-#  define ALLOCM_ERR_OOM	1
-#  define ALLOCM_ERR_NOT_MOVED	2
+#if defined(__cplusplus) && defined(JEMALLOC_USE_CXX_THROW)
+#  define JEMALLOC_CXX_THROW throw()
+#else
+#  define JEMALLOC_CXX_THROW
 #endif
 
 #ifdef JEMALLOC_HAVE_ATTR
 #  define JEMALLOC_ATTR(s) __attribute__((s))
-#  define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
 #  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
-#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  ifdef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
+#    define JEMALLOC_ALLOC_SIZE(s) JEMALLOC_ATTR(alloc_size(s))
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2) JEMALLOC_ATTR(alloc_size(s1, s2))
+#  else
+#    define JEMALLOC_ALLOC_SIZE(s)
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  endif
+#  ifndef JEMALLOC_EXPORT
+#    define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
+#  endif
+#  ifdef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(gnu_printf, s, i))
+#  elif defined(JEMALLOC_HAVE_ATTR_FORMAT_PRINTF)
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(printf, s, i))
+#  else
+#    define JEMALLOC_FORMAT_PRINTF(s, i)
+#  endif
 #  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
+#  define JEMALLOC_NOTHROW JEMALLOC_ATTR(nothrow)
+#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  define JEMALLOC_RESTRICT_RETURN
+#  define JEMALLOC_ALLOCATOR
 #elif _MSC_VER
 #  define JEMALLOC_ATTR(s)
-#  ifdef DLLEXPORT
-#    define JEMALLOC_EXPORT __declspec(dllexport)
+#  define JEMALLOC_ALIGNED(s) __declspec(align(s))
+#  define JEMALLOC_ALLOC_SIZE(s)
+#  define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  ifndef JEMALLOC_EXPORT
+#    ifdef DLLEXPORT
+#      define JEMALLOC_EXPORT __declspec(dllexport)
+#    else
+#      define JEMALLOC_EXPORT __declspec(dllimport)
+#    endif
+#  endif
+#  define JEMALLOC_FORMAT_PRINTF(s, i)
+#  define JEMALLOC_NOINLINE __declspec(noinline)
+#  ifdef __cplusplus
+#    define JEMALLOC_NOTHROW __declspec(nothrow)
 #  else
-#    define JEMALLOC_EXPORT __declspec(dllimport)
+#    define JEMALLOC_NOTHROW
 #  endif
-#  define JEMALLOC_ALIGNED(s) __declspec(align(s))
 #  define JEMALLOC_SECTION(s) __declspec(allocate(s))
-#  define JEMALLOC_NOINLINE __declspec(noinline)
+#  define JEMALLOC_RESTRICT_RETURN __declspec(restrict)
+#  if _MSC_VER >= 1900 && !defined(__EDG__)
+#    define JEMALLOC_ALLOCATOR __declspec(allocator)
+#  else
+#    define JEMALLOC_ALLOCATOR
+#  endif
 #else
 #  define JEMALLOC_ATTR(s)
-#  define JEMALLOC_EXPORT
 #  define JEMALLOC_ALIGNED(s)
-#  define JEMALLOC_SECTION(s)
+#  define JEMALLOC_ALLOC_SIZE(s)
+#  define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  define JEMALLOC_EXPORT
+#  define JEMALLOC_FORMAT_PRINTF(s, i)
 #  define JEMALLOC_NOINLINE
+#  define JEMALLOC_NOTHROW
+#  define JEMALLOC_SECTION(s)
+#  define JEMALLOC_RESTRICT_RETURN
+#  define JEMALLOC_ALLOCATOR
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in	2016-05-06 15:11:36.000000000 +0800
@@ -1,6 +1,9 @@
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdint.h>
 #include <limits.h>
 #include <strings.h>
 
 #define	JEMALLOC_VERSION "@jemalloc_version@"
 #define	JEMALLOC_VERSION_MAJOR @jemalloc_version_major@
 #define	JEMALLOC_VERSION_MINOR @jemalloc_version_minor@
@@ -13,49 +16,87 @@
 #    define MALLOCX_ALIGN(a)	(ffs(a)-1)
 #  else
 #    define MALLOCX_ALIGN(a)						\
 	 ((a < (size_t)INT_MAX) ? ffs(a)-1 : ffs(a>>32)+31)
 #  endif
 #  define MALLOCX_ZERO	((int)0x40)
-/* Bias arena index bits so that 0 encodes "MALLOCX_ARENA() unspecified". */
-#  define MALLOCX_ARENA(a)	((int)(((a)+1) << 8))
+/*
+ * Bias tcache index bits so that 0 encodes "automatic tcache management", and 1
+ * encodes MALLOCX_TCACHE_NONE.
+ */
+#  define MALLOCX_TCACHE(tc)	((int)(((tc)+2) << 8))
+#  define MALLOCX_TCACHE_NONE	MALLOCX_TCACHE(-1)
+/*
+ * Bias arena index bits so that 0 encodes "use an automatically chosen arena".
+ */
+#  define MALLOCX_ARENA(a)	((int)(((a)+1) << 20))
 
-#ifdef JEMALLOC_EXPERIMENTAL
-#  define ALLOCM_LG_ALIGN(la)	(la)
-#  if LG_SIZEOF_PTR == 2
-#    define ALLOCM_ALIGN(a)	(ffs(a)-1)
-#  else
-#    define ALLOCM_ALIGN(a)						\
-	 ((a < (size_t)INT_MAX) ? ffs(a)-1 : ffs(a>>32)+31)
-#  endif
-#  define ALLOCM_ZERO	((int)0x40)
-#  define ALLOCM_NO_MOVE	((int)0x80)
-/* Bias arena index bits so that 0 encodes "ALLOCM_ARENA() unspecified". */
-#  define ALLOCM_ARENA(a)	((int)(((a)+1) << 8))
-#  define ALLOCM_SUCCESS	0
-#  define ALLOCM_ERR_OOM	1
-#  define ALLOCM_ERR_NOT_MOVED	2
+#if defined(__cplusplus) && defined(JEMALLOC_USE_CXX_THROW)
+#  define JEMALLOC_CXX_THROW throw()
+#else
+#  define JEMALLOC_CXX_THROW
 #endif
 
 #ifdef JEMALLOC_HAVE_ATTR
 #  define JEMALLOC_ATTR(s) __attribute__((s))
-#  define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
 #  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
-#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  ifdef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
+#    define JEMALLOC_ALLOC_SIZE(s) JEMALLOC_ATTR(alloc_size(s))
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2) JEMALLOC_ATTR(alloc_size(s1, s2))
+#  else
+#    define JEMALLOC_ALLOC_SIZE(s)
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  endif
+#  ifndef JEMALLOC_EXPORT
+#    define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
+#  endif
+#  ifdef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(gnu_printf, s, i))
+#  elif defined(JEMALLOC_HAVE_ATTR_FORMAT_PRINTF)
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(printf, s, i))
+#  else
+#    define JEMALLOC_FORMAT_PRINTF(s, i)
+#  endif
 #  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
+#  define JEMALLOC_NOTHROW JEMALLOC_ATTR(nothrow)
+#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  define JEMALLOC_RESTRICT_RETURN
+#  define JEMALLOC_ALLOCATOR
 #elif _MSC_VER
 #  define JEMALLOC_ATTR(s)
-#  ifdef DLLEXPORT
-#    define JEMALLOC_EXPORT __declspec(dllexport)
+#  define JEMALLOC_ALIGNED(s) __declspec(align(s))
+#  define JEMALLOC_ALLOC_SIZE(s)
+#  define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  ifndef JEMALLOC_EXPORT
+#    ifdef DLLEXPORT
+#      define JEMALLOC_EXPORT __declspec(dllexport)
+#    else
+#      define JEMALLOC_EXPORT __declspec(dllimport)
+#    endif
+#  endif
+#  define JEMALLOC_FORMAT_PRINTF(s, i)
+#  define JEMALLOC_NOINLINE __declspec(noinline)
+#  ifdef __cplusplus
+#    define JEMALLOC_NOTHROW __declspec(nothrow)
 #  else
-#    define JEMALLOC_EXPORT __declspec(dllimport)
+#    define JEMALLOC_NOTHROW
 #  endif
-#  define JEMALLOC_ALIGNED(s) __declspec(align(s))
 #  define JEMALLOC_SECTION(s) __declspec(allocate(s))
-#  define JEMALLOC_NOINLINE __declspec(noinline)
+#  define JEMALLOC_RESTRICT_RETURN __declspec(restrict)
+#  if _MSC_VER >= 1900 && !defined(__EDG__)
+#    define JEMALLOC_ALLOCATOR __declspec(allocator)
+#  else
+#    define JEMALLOC_ALLOCATOR
+#  endif
 #else
 #  define JEMALLOC_ATTR(s)
-#  define JEMALLOC_EXPORT
 #  define JEMALLOC_ALIGNED(s)
-#  define JEMALLOC_SECTION(s)
+#  define JEMALLOC_ALLOC_SIZE(s)
+#  define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  define JEMALLOC_EXPORT
+#  define JEMALLOC_FORMAT_PRINTF(s, i)
 #  define JEMALLOC_NOINLINE
+#  define JEMALLOC_NOTHROW
+#  define JEMALLOC_SECTION(s)
+#  define JEMALLOC_RESTRICT_RETURN
+#  define JEMALLOC_ALLOCATOR
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_mangle.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_mangle.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_mangle.h	2017-09-27 22:47:53.514963463 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_mangle.h	2017-09-27 22:49:15.438960461 +0800
@@ -19,25 +19,21 @@
 #  define free je_free
 #  define mallocx je_mallocx
 #  define rallocx je_rallocx
 #  define xallocx je_xallocx
 #  define sallocx je_sallocx
 #  define dallocx je_dallocx
+#  define sdallocx je_sdallocx
 #  define nallocx je_nallocx
 #  define mallctl je_mallctl
 #  define mallctlnametomib je_mallctlnametomib
 #  define mallctlbymib je_mallctlbymib
 #  define malloc_stats_print je_malloc_stats_print
 #  define malloc_usable_size je_malloc_usable_size
 #  define memalign je_memalign
 #  define valloc je_valloc
-#  define allocm je_allocm
-#  define dallocm je_dallocm
-#  define nallocm je_nallocm
-#  define rallocm je_rallocm
-#  define sallocm je_sallocm
 #endif
 
 /*
  * The je_* macros can be used as stable alternative names for the
  * public jemalloc API if JEMALLOC_NO_DEMANGLE is defined.  This is primarily
  * meant for use in jemalloc itself, but it can be used by application code to
@@ -55,20 +51,16 @@
 #  undef je_free
 #  undef je_mallocx
 #  undef je_rallocx
 #  undef je_xallocx
 #  undef je_sallocx
 #  undef je_dallocx
+#  undef je_sdallocx
 #  undef je_nallocx
 #  undef je_mallctl
 #  undef je_mallctlnametomib
 #  undef je_mallctlbymib
 #  undef je_malloc_stats_print
 #  undef je_malloc_usable_size
 #  undef je_memalign
 #  undef je_valloc
-#  undef je_allocm
-#  undef je_dallocm
-#  undef je_nallocm
-#  undef je_rallocm
-#  undef je_sallocm
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_mangle_jet.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_mangle_jet.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_mangle_jet.h	2017-09-27 22:47:53.562963462 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_mangle_jet.h	2017-09-27 22:49:15.478960459 +0800
@@ -19,25 +19,21 @@
 #  define free jet_free
 #  define mallocx jet_mallocx
 #  define rallocx jet_rallocx
 #  define xallocx jet_xallocx
 #  define sallocx jet_sallocx
 #  define dallocx jet_dallocx
+#  define sdallocx jet_sdallocx
 #  define nallocx jet_nallocx
 #  define mallctl jet_mallctl
 #  define mallctlnametomib jet_mallctlnametomib
 #  define mallctlbymib jet_mallctlbymib
 #  define malloc_stats_print jet_malloc_stats_print
 #  define malloc_usable_size jet_malloc_usable_size
 #  define memalign jet_memalign
 #  define valloc jet_valloc
-#  define allocm jet_allocm
-#  define dallocm jet_dallocm
-#  define nallocm jet_nallocm
-#  define rallocm jet_rallocm
-#  define sallocm jet_sallocm
 #endif
 
 /*
  * The jet_* macros can be used as stable alternative names for the
  * public jemalloc API if JEMALLOC_NO_DEMANGLE is defined.  This is primarily
  * meant for use in jemalloc itself, but it can be used by application code to
@@ -55,20 +51,16 @@
 #  undef jet_free
 #  undef jet_mallocx
 #  undef jet_rallocx
 #  undef jet_xallocx
 #  undef jet_sallocx
 #  undef jet_dallocx
+#  undef jet_sdallocx
 #  undef jet_nallocx
 #  undef jet_mallctl
 #  undef jet_mallctlnametomib
 #  undef jet_mallctlbymib
 #  undef jet_malloc_stats_print
 #  undef jet_malloc_usable_size
 #  undef jet_memalign
 #  undef jet_valloc
-#  undef jet_allocm
-#  undef jet_dallocm
-#  undef jet_nallocm
-#  undef jet_rallocm
-#  undef jet_sallocm
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_protos.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_protos.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_protos.h	2017-09-27 22:47:53.254963473 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_protos.h	2017-09-27 22:49:15.030960476 +0800
@@ -4,55 +4,63 @@
  * JEMALLOC_NO_DEMANGLE is defined (see jemalloc_mangle.h).
  */
 extern JEMALLOC_EXPORT const char	*je_malloc_conf;
 extern JEMALLOC_EXPORT void		(*je_malloc_message)(void *cbopaque,
     const char *s);
 
-JEMALLOC_EXPORT void	*je_malloc(size_t size) JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT void	*je_calloc(size_t num, size_t size)
-    JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT int	je_posix_memalign(void **memptr, size_t alignment,
-    size_t size) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT void	*je_aligned_alloc(size_t alignment, size_t size)
-    JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT void	*je_realloc(void *ptr, size_t size);
-JEMALLOC_EXPORT void	je_free(void *ptr);
-
-JEMALLOC_EXPORT void	*je_mallocx(size_t size, int flags);
-JEMALLOC_EXPORT void	*je_rallocx(void *ptr, size_t size, int flags);
-JEMALLOC_EXPORT size_t	je_xallocx(void *ptr, size_t size, size_t extra,
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_malloc(size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_calloc(size_t num, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	je_posix_memalign(void **memptr,
+    size_t alignment, size_t size) JEMALLOC_CXX_THROW JEMALLOC_ATTR(nonnull(1));
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_aligned_alloc(size_t alignment,
+    size_t size) JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc)
+    JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_realloc(void *ptr, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	je_free(void *ptr)
+    JEMALLOC_CXX_THROW;
+
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_mallocx(size_t size, int flags)
+    JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_rallocx(void *ptr, size_t size,
+    int flags) JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	je_xallocx(void *ptr, size_t size,
+    size_t extra, int flags);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	je_sallocx(const void *ptr,
+    int flags) JEMALLOC_ATTR(pure);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	je_dallocx(void *ptr, int flags);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	je_sdallocx(void *ptr, size_t size,
     int flags);
-JEMALLOC_EXPORT size_t	je_sallocx(const void *ptr, int flags);
-JEMALLOC_EXPORT void	je_dallocx(void *ptr, int flags);
-JEMALLOC_EXPORT size_t	je_nallocx(size_t size, int flags);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	je_nallocx(size_t size, int flags)
+    JEMALLOC_ATTR(pure);
 
-JEMALLOC_EXPORT int	je_mallctl(const char *name, void *oldp,
-    size_t *oldlenp, void *newp, size_t newlen);
-JEMALLOC_EXPORT int	je_mallctlnametomib(const char *name, size_t *mibp,
-    size_t *miblenp);
-JEMALLOC_EXPORT int	je_mallctlbymib(const size_t *mib, size_t miblen,
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	je_mallctl(const char *name,
     void *oldp, size_t *oldlenp, void *newp, size_t newlen);
-JEMALLOC_EXPORT void	je_malloc_stats_print(void (*write_cb)(void *,
-    const char *), void *je_cbopaque, const char *opts);
-JEMALLOC_EXPORT size_t	je_malloc_usable_size(
-    JEMALLOC_USABLE_SIZE_CONST void *ptr);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	je_mallctlnametomib(const char *name,
+    size_t *mibp, size_t *miblenp);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	je_mallctlbymib(const size_t *mib,
+    size_t miblen, void *oldp, size_t *oldlenp, void *newp, size_t newlen);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	je_malloc_stats_print(
+    void (*write_cb)(void *, const char *), void *je_cbopaque,
+    const char *opts);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	je_malloc_usable_size(
+    JEMALLOC_USABLE_SIZE_CONST void *ptr) JEMALLOC_CXX_THROW;
 
 #ifdef JEMALLOC_OVERRIDE_MEMALIGN
-JEMALLOC_EXPORT void *	je_memalign(size_t alignment, size_t size)
-    JEMALLOC_ATTR(malloc);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_memalign(size_t alignment, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc);
 #endif
 
 #ifdef JEMALLOC_OVERRIDE_VALLOC
-JEMALLOC_EXPORT void *	je_valloc(size_t size) JEMALLOC_ATTR(malloc);
-#endif
-
-#ifdef JEMALLOC_EXPERIMENTAL
-JEMALLOC_EXPORT int	je_allocm(void **ptr, size_t *rsize, size_t size,
-    int flags) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	je_rallocm(void **ptr, size_t *rsize, size_t size,
-    size_t extra, int flags) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	je_sallocm(const void *ptr, size_t *rsize, int flags)
-    JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	je_dallocm(void *ptr, int flags)
-    JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	je_nallocm(size_t *rsize, size_t size, int flags);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*je_valloc(size_t size) JEMALLOC_CXX_THROW
+    JEMALLOC_ATTR(malloc);
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_protos.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_protos.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_protos.h.in	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_protos.h.in	2016-05-06 15:11:36.000000000 +0800
@@ -4,55 +4,63 @@
  * JEMALLOC_NO_DEMANGLE is defined (see jemalloc_mangle@install_suffix@.h).
  */
 extern JEMALLOC_EXPORT const char	*@je_@malloc_conf;
 extern JEMALLOC_EXPORT void		(*@je_@malloc_message)(void *cbopaque,
     const char *s);
 
-JEMALLOC_EXPORT void	*@je_@malloc(size_t size) JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT void	*@je_@calloc(size_t num, size_t size)
-    JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT int	@je_@posix_memalign(void **memptr, size_t alignment,
-    size_t size) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT void	*@je_@aligned_alloc(size_t alignment, size_t size)
-    JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT void	*@je_@realloc(void *ptr, size_t size);
-JEMALLOC_EXPORT void	@je_@free(void *ptr);
-
-JEMALLOC_EXPORT void	*@je_@mallocx(size_t size, int flags);
-JEMALLOC_EXPORT void	*@je_@rallocx(void *ptr, size_t size, int flags);
-JEMALLOC_EXPORT size_t	@je_@xallocx(void *ptr, size_t size, size_t extra,
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*@je_@malloc(size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*@je_@calloc(size_t num, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	@je_@posix_memalign(void **memptr,
+    size_t alignment, size_t size) JEMALLOC_CXX_THROW JEMALLOC_ATTR(nonnull(1));
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*@je_@aligned_alloc(size_t alignment,
+    size_t size) JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc)
+    JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*@je_@realloc(void *ptr, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	@je_@free(void *ptr)
+    JEMALLOC_CXX_THROW;
+
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*@je_@mallocx(size_t size, int flags)
+    JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*@je_@rallocx(void *ptr, size_t size,
+    int flags) JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	@je_@xallocx(void *ptr, size_t size,
+    size_t extra, int flags);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	@je_@sallocx(const void *ptr,
+    int flags) JEMALLOC_ATTR(pure);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	@je_@dallocx(void *ptr, int flags);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	@je_@sdallocx(void *ptr, size_t size,
     int flags);
-JEMALLOC_EXPORT size_t	@je_@sallocx(const void *ptr, int flags);
-JEMALLOC_EXPORT void	@je_@dallocx(void *ptr, int flags);
-JEMALLOC_EXPORT size_t	@je_@nallocx(size_t size, int flags);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	@je_@nallocx(size_t size, int flags)
+    JEMALLOC_ATTR(pure);
 
-JEMALLOC_EXPORT int	@je_@mallctl(const char *name, void *oldp,
-    size_t *oldlenp, void *newp, size_t newlen);
-JEMALLOC_EXPORT int	@je_@mallctlnametomib(const char *name, size_t *mibp,
-    size_t *miblenp);
-JEMALLOC_EXPORT int	@je_@mallctlbymib(const size_t *mib, size_t miblen,
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	@je_@mallctl(const char *name,
     void *oldp, size_t *oldlenp, void *newp, size_t newlen);
-JEMALLOC_EXPORT void	@je_@malloc_stats_print(void (*write_cb)(void *,
-    const char *), void *@je_@cbopaque, const char *opts);
-JEMALLOC_EXPORT size_t	@je_@malloc_usable_size(
-    JEMALLOC_USABLE_SIZE_CONST void *ptr);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	@je_@mallctlnametomib(const char *name,
+    size_t *mibp, size_t *miblenp);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	@je_@mallctlbymib(const size_t *mib,
+    size_t miblen, void *oldp, size_t *oldlenp, void *newp, size_t newlen);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	@je_@malloc_stats_print(
+    void (*write_cb)(void *, const char *), void *@je_@cbopaque,
+    const char *opts);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	@je_@malloc_usable_size(
+    JEMALLOC_USABLE_SIZE_CONST void *ptr) JEMALLOC_CXX_THROW;
 
 #ifdef JEMALLOC_OVERRIDE_MEMALIGN
-JEMALLOC_EXPORT void *	@je_@memalign(size_t alignment, size_t size)
-    JEMALLOC_ATTR(malloc);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*@je_@memalign(size_t alignment, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc);
 #endif
 
 #ifdef JEMALLOC_OVERRIDE_VALLOC
-JEMALLOC_EXPORT void *	@je_@valloc(size_t size) JEMALLOC_ATTR(malloc);
-#endif
-
-#ifdef JEMALLOC_EXPERIMENTAL
-JEMALLOC_EXPORT int	@je_@allocm(void **ptr, size_t *rsize, size_t size,
-    int flags) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	@je_@rallocm(void **ptr, size_t *rsize, size_t size,
-    size_t extra, int flags) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	@je_@sallocm(const void *ptr, size_t *rsize, int flags)
-    JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	@je_@dallocm(void *ptr, int flags)
-    JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	@je_@nallocm(size_t *rsize, size_t size, int flags);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*@je_@valloc(size_t size) JEMALLOC_CXX_THROW
+    JEMALLOC_ATTR(malloc);
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_protos_jet.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_protos_jet.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_protos_jet.h	2017-09-27 22:47:53.418963467 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_protos_jet.h	2017-09-27 22:49:15.350960464 +0800
@@ -4,55 +4,63 @@
  * JEMALLOC_NO_DEMANGLE is defined (see jemalloc_mangle@install_suffix@.h).
  */
 extern JEMALLOC_EXPORT const char	*jet_malloc_conf;
 extern JEMALLOC_EXPORT void		(*jet_malloc_message)(void *cbopaque,
     const char *s);
 
-JEMALLOC_EXPORT void	*jet_malloc(size_t size) JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT void	*jet_calloc(size_t num, size_t size)
-    JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT int	jet_posix_memalign(void **memptr, size_t alignment,
-    size_t size) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT void	*jet_aligned_alloc(size_t alignment, size_t size)
-    JEMALLOC_ATTR(malloc);
-JEMALLOC_EXPORT void	*jet_realloc(void *ptr, size_t size);
-JEMALLOC_EXPORT void	jet_free(void *ptr);
-
-JEMALLOC_EXPORT void	*jet_mallocx(size_t size, int flags);
-JEMALLOC_EXPORT void	*jet_rallocx(void *ptr, size_t size, int flags);
-JEMALLOC_EXPORT size_t	jet_xallocx(void *ptr, size_t size, size_t extra,
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*jet_malloc(size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*jet_calloc(size_t num, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	jet_posix_memalign(void **memptr,
+    size_t alignment, size_t size) JEMALLOC_CXX_THROW JEMALLOC_ATTR(nonnull(1));
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*jet_aligned_alloc(size_t alignment,
+    size_t size) JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc)
+    JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*jet_realloc(void *ptr, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	jet_free(void *ptr)
+    JEMALLOC_CXX_THROW;
+
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*jet_mallocx(size_t size, int flags)
+    JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*jet_rallocx(void *ptr, size_t size,
+    int flags) JEMALLOC_ALLOC_SIZE(2);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	jet_xallocx(void *ptr, size_t size,
+    size_t extra, int flags);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	jet_sallocx(const void *ptr,
+    int flags) JEMALLOC_ATTR(pure);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	jet_dallocx(void *ptr, int flags);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	jet_sdallocx(void *ptr, size_t size,
     int flags);
-JEMALLOC_EXPORT size_t	jet_sallocx(const void *ptr, int flags);
-JEMALLOC_EXPORT void	jet_dallocx(void *ptr, int flags);
-JEMALLOC_EXPORT size_t	jet_nallocx(size_t size, int flags);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	jet_nallocx(size_t size, int flags)
+    JEMALLOC_ATTR(pure);
 
-JEMALLOC_EXPORT int	jet_mallctl(const char *name, void *oldp,
-    size_t *oldlenp, void *newp, size_t newlen);
-JEMALLOC_EXPORT int	jet_mallctlnametomib(const char *name, size_t *mibp,
-    size_t *miblenp);
-JEMALLOC_EXPORT int	jet_mallctlbymib(const size_t *mib, size_t miblen,
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	jet_mallctl(const char *name,
     void *oldp, size_t *oldlenp, void *newp, size_t newlen);
-JEMALLOC_EXPORT void	jet_malloc_stats_print(void (*write_cb)(void *,
-    const char *), void *jet_cbopaque, const char *opts);
-JEMALLOC_EXPORT size_t	jet_malloc_usable_size(
-    JEMALLOC_USABLE_SIZE_CONST void *ptr);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	jet_mallctlnametomib(const char *name,
+    size_t *mibp, size_t *miblenp);
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW	jet_mallctlbymib(const size_t *mib,
+    size_t miblen, void *oldp, size_t *oldlenp, void *newp, size_t newlen);
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW	jet_malloc_stats_print(
+    void (*write_cb)(void *, const char *), void *jet_cbopaque,
+    const char *opts);
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW	jet_malloc_usable_size(
+    JEMALLOC_USABLE_SIZE_CONST void *ptr) JEMALLOC_CXX_THROW;
 
 #ifdef JEMALLOC_OVERRIDE_MEMALIGN
-JEMALLOC_EXPORT void *	jet_memalign(size_t alignment, size_t size)
-    JEMALLOC_ATTR(malloc);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*jet_memalign(size_t alignment, size_t size)
+    JEMALLOC_CXX_THROW JEMALLOC_ATTR(malloc);
 #endif
 
 #ifdef JEMALLOC_OVERRIDE_VALLOC
-JEMALLOC_EXPORT void *	jet_valloc(size_t size) JEMALLOC_ATTR(malloc);
-#endif
-
-#ifdef JEMALLOC_EXPERIMENTAL
-JEMALLOC_EXPORT int	jet_allocm(void **ptr, size_t *rsize, size_t size,
-    int flags) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	jet_rallocm(void **ptr, size_t *rsize, size_t size,
-    size_t extra, int flags) JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	jet_sallocm(const void *ptr, size_t *rsize, int flags)
-    JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	jet_dallocm(void *ptr, int flags)
-    JEMALLOC_ATTR(nonnull(1));
-JEMALLOC_EXPORT int	jet_nallocm(size_t *rsize, size_t size, int flags);
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+    void JEMALLOC_NOTHROW	*jet_valloc(size_t size) JEMALLOC_CXX_THROW
+    JEMALLOC_ATTR(malloc);
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_rename.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_rename.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc_rename.h	2017-09-27 22:47:53.466963465 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc_rename.h	2017-09-27 22:49:15.394960463 +0800
@@ -14,20 +14,16 @@
 #  define je_free je_free
 #  define je_mallocx je_mallocx
 #  define je_rallocx je_rallocx
 #  define je_xallocx je_xallocx
 #  define je_sallocx je_sallocx
 #  define je_dallocx je_dallocx
+#  define je_sdallocx je_sdallocx
 #  define je_nallocx je_nallocx
 #  define je_mallctl je_mallctl
 #  define je_mallctlnametomib je_mallctlnametomib
 #  define je_mallctlbymib je_mallctlbymib
 #  define je_malloc_stats_print je_malloc_stats_print
 #  define je_malloc_usable_size je_malloc_usable_size
 #  define je_memalign je_memalign
 #  define je_valloc je_valloc
-#  define je_allocm je_allocm
-#  define je_dallocm je_dallocm
-#  define je_nallocm je_nallocm
-#  define je_rallocm je_rallocm
-#  define je_sallocm je_sallocm
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/jemalloc/jemalloc.sh	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc/jemalloc.sh	2016-05-06 15:11:36.000000000 +0800
@@ -9,20 +9,20 @@
 extern "C" {
 #endif
 
 EOF
 
 for hdr in jemalloc_defs.h jemalloc_rename.h jemalloc_macros.h \
-           jemalloc_protos.h jemalloc_mangle.h ; do
+           jemalloc_protos.h jemalloc_typedefs.h jemalloc_mangle.h ; do
   cat "${objroot}include/jemalloc/${hdr}" \
       | grep -v 'Generated from .* by configure\.' \
       | sed -e 's/^#define /#define	/g' \
       | sed -e 's/ $//g'
   echo
 done
 
 cat <<EOF
 #ifdef __cplusplus
-};
+}
 #endif
 #endif /* JEMALLOC_H_ */
 EOF
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc: jemalloc_typedefs.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/jemalloc: jemalloc_typedefs.h.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/msvc_compat: C99
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/msvc_compat: inttypes.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/msvc_compat: stdbool.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/msvc_compat: stdint.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/msvc_compat/strings.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/msvc_compat/strings.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/include/msvc_compat/strings.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/msvc_compat/strings.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,13 +1,14 @@
 #ifndef strings_h
 #define strings_h
 
 /* MSVC doesn't define ffs/ffsl. This dummy strings.h header is provided
  * for both */
-#include <intrin.h>
-#pragma intrinsic(_BitScanForward)
+#ifdef _MSC_VER
+#  include <intrin.h>
+#  pragma intrinsic(_BitScanForward)
 static __forceinline int ffsl(long x)
 {
 	unsigned long i;
 
 	if (_BitScanForward(&i, x))
 		return (i + 1);
@@ -17,7 +18,12 @@
 static __forceinline int ffs(int x)
 {
 
 	return (ffsl(x));
 }
 
+#else
+#  define ffsl(x) __builtin_ffsl(x)
+#  define ffs(x) __builtin_ffs(x)
 #endif
+
+#endif /* strings_h */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/include/msvc_compat: windows_extra.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/INSTALL	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/INSTALL	2016-05-06 15:11:36.000000000 +0800
@@ -1,13 +1,26 @@
-Building and installing jemalloc can be as simple as typing the following while
-in the root directory of the source tree:
+Building and installing a packaged release of jemalloc can be as simple as
+typing the following while in the root directory of the source tree:
 
     ./configure
     make
     make install
 
+If building from unpackaged developer sources, the simplest command sequence
+that might work is:
+
+    ./autogen.sh
+    make dist
+    make
+    make install
+
+Note that documentation is not built by the default target because doing so
+would create a dependency on xsltproc in packaged releases, hence the
+requirement to either run 'make dist' or avoid installing docs via the various
+install_* targets documented below.
+
 === Advanced configuration =====================================================
 
 The 'configure' script supports numerous options that allow control of which
 functionality is enabled, where jemalloc is installed, etc.  Optionally, pass
 any of the following arguments (not a definitive list) to 'configure':
 
@@ -53,13 +66,13 @@
 
     By default, the prefix is "", except on OS X, where it is "je_".  On OS X,
     jemalloc overlays the default malloc zone, but makes no attempt to actually
     replace the "malloc", "calloc", etc. symbols.
 
 --without-export
-    Don't export public APIs. This can be useful when building jemalloc as a
+    Don't export public APIs.  This can be useful when building jemalloc as a
     static library, or to avoid exporting public APIs when using the zone
     allocator on OSX.
 
 --with-private-namespace=<prefix>
     Prefix all library-private APIs with <prefix>je_.  For shared libraries,
     symbol visibility mechanisms prevent these symbols from being exported, but
@@ -68,16 +81,16 @@
 
 --with-install-suffix=<suffix>
     Append <suffix> to the base name of all installed files, such that multiple
     versions of jemalloc can coexist in the same installation directory.  For
     example, libjemalloc.so.0 becomes libjemalloc<suffix>.so.0.
 
---enable-cc-silence
-    Enable code that silences non-useful compiler warnings.  This is helpful
-    when trying to tell serious warnings from those due to compiler
-    limitations, but it potentially incurs a performance penalty.
+--disable-cc-silence
+    Disable code that silences non-useful compiler warnings.  This is mainly
+    useful during development when auditing the set of warnings that are being
+    silenced.
 
 --enable-debug
     Enable assertions and validation code.  This incurs a substantial
     performance hit, but is very useful during application development.
     Implies --enable-ivsalloc.
 
@@ -91,21 +104,21 @@
       coverage_stress
 
     These targets do not clear code coverage results from previous runs, and
     there are interactions between the various coverage targets, so it is
     usually advisable to run 'make clean' between repeated code coverage runs.
 
---enable-ivsalloc
-    Enable validation code, which verifies that pointers reside within
-    jemalloc-owned chunks before dereferencing them. This incurs a substantial
-    performance hit.
-
 --disable-stats
     Disable statistics gathering functionality.  See the "opt.stats_print"
     option documentation for usage details.
 
+--enable-ivsalloc
+    Enable validation code, which verifies that pointers reside within
+    jemalloc-owned chunks before dereferencing them.  This incurs a minor
+    performance hit.
+
 --enable-prof
     Enable heap profiling and leak detection functionality.  See the "opt.prof"
     option documentation for usage details.  When enabled, there are several
     approaches to backtracing, and the configure script chooses the first one
     in the following list that appears to function correctly:
 
@@ -129,42 +142,29 @@
 
 --disable-tcache
     Disable thread-specific caches for small objects.  Objects are cached and
     released in bulk, thus reducing the total number of mutex operations.  See
     the "opt.tcache" option for usage details.
 
---enable-mremap
-    Enable huge realloc() via mremap(2).  mremap() is disabled by default
-    because the flavor used is specific to Linux, which has a quirk in its
-    virtual memory allocation algorithm that causes semi-permanent VM map holes
-    under normal jemalloc operation.
-
 --disable-munmap
     Disable virtual memory deallocation via munmap(2); instead keep track of
     the virtual memory for later use.  munmap() is disabled by default (i.e.
     --disable-munmap is implied) on Linux, which has a quirk in its virtual
     memory allocation algorithm that causes semi-permanent VM map holes under
     normal jemalloc operation.
 
---enable-dss
-    Enable support for page allocation/deallocation via sbrk(2), in addition to
-    mmap(2).
-
 --disable-fill
     Disable support for junk/zero filling of memory, quarantine, and redzones.
     See the "opt.junk", "opt.zero", "opt.quarantine", and "opt.redzone" option
     documentation for usage details.
 
 --disable-valgrind
     Disable support for Valgrind.
 
---disable-experimental
-    Disable support for the experimental API (*allocm()).
-
 --disable-zone-allocator
-    Disable zone allocator for Darwin. This means jemalloc won't be hooked as
+    Disable zone allocator for Darwin.  This means jemalloc won't be hooked as
     the default allocator on OSX/iOS.
 
 --enable-utrace
     Enable utrace(2)-based allocation tracing.  This feature is not broadly
     portable (FreeBSD has it, but Linux and OS X do not).
 
@@ -182,16 +182,112 @@
 
 --disable-tls
     Disable thread-local storage (TLS), which allows for fast access to
     thread-local variables via the __thread keyword.  If TLS is available,
     jemalloc uses it for several purposes.
 
+--disable-cache-oblivious
+    Disable cache-oblivious large allocation alignment for large allocation
+    requests with no alignment constraints.  If this feature is disabled, all
+    large allocations are page-aligned as an implementation artifact, which can
+    severely harm CPU cache utilization.  However, the cache-oblivious layout
+    comes at the cost of one extra page per large allocation, which in the
+    most extreme case increases physical memory usage for the 16 KiB size class
+    to 20 KiB.
+
 --with-xslroot=<path>
     Specify where to find DocBook XSL stylesheets when building the
     documentation.
 
+--with-lg-page=<lg-page>
+    Specify the base 2 log of the system page size.  This option is only useful
+    when cross compiling, since the configure script automatically determines
+    the host's page size by default.
+
+--with-lg-page-sizes=<lg-page-sizes>
+    Specify the comma-separated base 2 logs of the page sizes to support.  This
+    option may be useful when cross-compiling in combination with
+    --with-lg-page, but its primary use case is for integration with FreeBSD's
+    libc, wherein jemalloc is embedded.
+
+--with-lg-size-class-group=<lg-size-class-group>
+    Specify the base 2 log of how many size classes to use for each doubling in
+    size.  By default jemalloc uses <lg-size-class-group>=2, which results in
+    e.g. the following size classes:
+
+      [...], 64,
+      80, 96, 112, 128,
+      160, [...]
+
+    <lg-size-class-group>=3 results in e.g. the following size classes:
+
+      [...], 64,
+      72, 80, 88, 96, 104, 112, 120, 128,
+      144, [...]
+
+    The minimal <lg-size-class-group>=0 causes jemalloc to only provide size
+    classes that are powers of 2:
+
+      [...],
+      64,
+      128,
+      256,
+      [...]
+
+    An implementation detail currently limits the total number of small size
+    classes to 255, and a compilation error will result if the
+    <lg-size-class-group> you specify cannot be supported.  The limit is
+    roughly <lg-size-class-group>=4, depending on page size.
+
+--with-lg-quantum=<lg-quantum>
+    Specify the base 2 log of the minimum allocation alignment.  jemalloc needs
+    to know the minimum alignment that meets the following C standard
+    requirement (quoted from the April 12, 2011 draft of the C11 standard):
+
+      The pointer returned if the allocation succeeds is suitably aligned so
+      that it may be assigned to a pointer to any type of object with a
+      fundamental alignment requirement and then used to access such an object
+      or an array of such objects in the space allocated [...]
+
+    This setting is architecture-specific, and although jemalloc includes known
+    safe values for the most commonly used modern architectures, there is a
+    wrinkle related to GNU libc (glibc) that may impact your choice of
+    <lg-quantum>.  On most modern architectures, this mandates 16-byte alignment
+    (<lg-quantum>=4), but the glibc developers chose not to meet this
+    requirement for performance reasons.  An old discussion can be found at
+    https://sourceware.org/bugzilla/show_bug.cgi?id=206 .  Unlike glibc,
+    jemalloc does follow the C standard by default (caveat: jemalloc
+    technically cheats if --with-lg-tiny-min is smaller than
+    --with-lg-quantum), but the fact that Linux systems already work around
+    this allocator noncompliance means that it is generally safe in practice to
+    let jemalloc's minimum alignment follow glibc's lead.  If you specify
+    --with-lg-quantum=3 during configuration, jemalloc will provide additional
+    size classes that are not 16-byte-aligned (24, 40, and 56, assuming
+    --with-lg-size-class-group=2).
+
+--with-lg-tiny-min=<lg-tiny-min>
+    Specify the base 2 log of the minimum tiny size class to support.  Tiny
+    size classes are powers of 2 less than the quantum, and are only
+    incorporated if <lg-tiny-min> is less than <lg-quantum> (see
+    --with-lg-quantum).  Tiny size classes technically violate the C standard
+    requirement for minimum alignment, and crashes could conceivably result if
+    the compiler were to generate instructions that made alignment assumptions,
+    both because illegal instruction traps could result, and because accesses
+    could straddle page boundaries and cause segmentation faults due to
+    accessing unmapped addresses.
+
+    The default of <lg-tiny-min>=3 works well in practice even on architectures
+    that technically require 16-byte alignment, probably for the same reason
+    --with-lg-quantum=3 works.  Smaller tiny size classes can, and will, cause
+    crashes (see https://bugzilla.mozilla.org/show_bug.cgi?id=691003 for an
+    example).
+
+    This option is rarely useful, and is mainly provided as documentation of a
+    subtle implementation detail.  If you do use this option, specify a
+    value in [3, ..., <lg-quantum>].
+
 The following environment variables (not a definitive list) impact configure's
 behavior:
 
 CFLAGS="?"
     Pass these flags to the compiler.  You probably shouldn't define this unless
     you know what you are doing.  (Use EXTRA_CFLAGS instead.)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc: jemalloc.pc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc: jemalloc.pc.in
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/lib/libjemalloc.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/lib/libjemalloc.a differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/Makefile	2017-09-27 22:47:53.190963475 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/Makefile	2017-09-27 22:49:14.978960478 +0800
@@ -16,45 +16,48 @@
 INCLUDEDIR := $(DESTDIR)/usr/local/include
 LIBDIR := $(DESTDIR)/usr/local/lib
 DATADIR := $(DESTDIR)/usr/local/share
 MANDIR := $(DESTDIR)/usr/local/share/man
 srcroot := 
 objroot := 
-abs_srcroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/
-abs_objroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/
+abs_srcroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/
+abs_objroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/
 
 # Build parameters.
 CPPFLAGS :=  -D_GNU_SOURCE -D_REENTRANT -I$(srcroot)include -I$(objroot)include
 CFLAGS := -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden
 LDFLAGS := 
 EXTRA_LDFLAGS := 
 LIBS :=  -lpthread
+TESTLIBS := 
 RPATH_EXTRA := 
 SO := so
 IMPORTLIB := so
 O := o
 A := a
 EXE := 
 LIBPREFIX := lib
-REV := 1
+REV := 2
 install_suffix := 
 ABI := elf
 XSLTPROC := /opt/anaconda2/bin/xsltproc
 AUTOCONF := /usr/bin/autoconf
 _RPATH = -Wl,-rpath,$(1)
 RPATH = $(if $(1),$(call _RPATH,$(1)))
-cfghdrs_in := include/jemalloc/jemalloc_defs.h.in include/jemalloc/internal/jemalloc_internal_defs.h.in include/jemalloc/internal/private_namespace.sh include/jemalloc/internal/private_unnamespace.sh include/jemalloc/internal/private_symbols.txt include/jemalloc/internal/public_namespace.sh include/jemalloc/internal/public_unnamespace.sh include/jemalloc/internal/size_classes.sh include/jemalloc/jemalloc_rename.sh include/jemalloc/jemalloc_mangle.sh include/jemalloc/jemalloc.sh test/include/test/jemalloc_test_defs.h.in
+cfghdrs_in := $(addprefix $(srcroot),include/jemalloc/jemalloc_defs.h.in include/jemalloc/internal/jemalloc_internal_defs.h.in include/jemalloc/internal/private_namespace.sh include/jemalloc/internal/private_unnamespace.sh include/jemalloc/internal/private_symbols.txt include/jemalloc/internal/public_namespace.sh include/jemalloc/internal/public_unnamespace.sh include/jemalloc/internal/size_classes.sh include/jemalloc/jemalloc_rename.sh include/jemalloc/jemalloc_mangle.sh include/jemalloc/jemalloc.sh test/include/test/jemalloc_test_defs.h.in)
 cfghdrs_out := include/jemalloc/jemalloc_defs.h include/jemalloc/jemalloc.h include/jemalloc/internal/private_namespace.h include/jemalloc/internal/private_unnamespace.h include/jemalloc/internal/public_symbols.txt include/jemalloc/internal/public_namespace.h include/jemalloc/internal/public_unnamespace.h include/jemalloc/internal/size_classes.h include/jemalloc/jemalloc_protos_jet.h include/jemalloc/jemalloc_rename.h include/jemalloc/jemalloc_mangle.h include/jemalloc/jemalloc_mangle_jet.h include/jemalloc/internal/jemalloc_internal_defs.h test/include/test/jemalloc_test_defs.h
-cfgoutputs_in := Makefile.in doc/html.xsl.in doc/manpages.xsl.in doc/jemalloc.xml.in include/jemalloc/jemalloc_macros.h.in include/jemalloc/jemalloc_protos.h.in include/jemalloc/internal/jemalloc_internal.h.in test/test.sh.in test/include/test/jemalloc_test.h.in
-cfgoutputs_out := Makefile doc/html.xsl doc/manpages.xsl doc/jemalloc.xml include/jemalloc/jemalloc_macros.h include/jemalloc/jemalloc_protos.h include/jemalloc/internal/jemalloc_internal.h test/test.sh test/include/test/jemalloc_test.h
+cfgoutputs_in := $(addprefix $(srcroot),Makefile.in jemalloc.pc.in doc/html.xsl.in doc/manpages.xsl.in doc/jemalloc.xml.in include/jemalloc/jemalloc_macros.h.in include/jemalloc/jemalloc_protos.h.in include/jemalloc/jemalloc_typedefs.h.in include/jemalloc/internal/jemalloc_internal.h.in test/test.sh.in test/include/test/jemalloc_test.h.in)
+cfgoutputs_out := Makefile jemalloc.pc doc/html.xsl doc/manpages.xsl doc/jemalloc.xml include/jemalloc/jemalloc_macros.h include/jemalloc/jemalloc_protos.h include/jemalloc/jemalloc_typedefs.h include/jemalloc/internal/jemalloc_internal.h test/test.sh test/include/test/jemalloc_test.h
 enable_autogen := 0
 enable_code_coverage := 0
-enable_experimental := 1
+enable_prof := 0
+enable_valgrind := 0
 enable_zone_allocator := 
+MALLOC_CONF := JE_MALLOC_CONF
 DSO_LDFLAGS = -shared -Wl,-soname,$(@F)
-SOREV = so.1
+SOREV = so.2
 PIC_CFLAGS = -fPIC -DPIC
 CTARGET = -o $@
 LDTARGET = -o $@
 MKLIB = 
 AR = ar
 ARFLAGS = crus
@@ -70,22 +73,26 @@
 endif
 endif
 
 LIBJEMALLOC := $(LIBPREFIX)jemalloc$(install_suffix)
 
 # Lists of files.
-BINS := $(srcroot)bin/pprof $(objroot)bin/jemalloc.sh
+BINS := $(objroot)bin/jemalloc-config $(objroot)bin/jemalloc.sh $(objroot)bin/jeprof
 C_HDRS := $(objroot)include/jemalloc/jemalloc$(install_suffix).h
 C_SRCS := $(srcroot)src/jemalloc.c $(srcroot)src/arena.c \
 	$(srcroot)src/atomic.c $(srcroot)src/base.c $(srcroot)src/bitmap.c \
 	$(srcroot)src/chunk.c $(srcroot)src/chunk_dss.c \
 	$(srcroot)src/chunk_mmap.c $(srcroot)src/ckh.c $(srcroot)src/ctl.c \
 	$(srcroot)src/extent.c $(srcroot)src/hash.c $(srcroot)src/huge.c \
-	$(srcroot)src/mb.c $(srcroot)src/mutex.c $(srcroot)src/prof.c \
-	$(srcroot)src/quarantine.c $(srcroot)src/rtree.c $(srcroot)src/stats.c \
-	$(srcroot)src/tcache.c $(srcroot)src/util.c $(srcroot)src/tsd.c
+	$(srcroot)src/mb.c $(srcroot)src/mutex.c $(srcroot)src/pages.c \
+	$(srcroot)src/prof.c $(srcroot)src/quarantine.c $(srcroot)src/rtree.c \
+	$(srcroot)src/stats.c $(srcroot)src/tcache.c $(srcroot)src/util.c \
+	$(srcroot)src/tsd.c
+ifeq ($(enable_valgrind), 1)
+C_SRCS += $(srcroot)src/valgrind.c
+endif
 ifeq ($(enable_zone_allocator), 1)
 C_SRCS += $(srcroot)src/zone.c
 endif
 ifeq ($(IMPORTLIB),$(SO))
 STATIC_LIBS := $(objroot)lib/$(LIBJEMALLOC).$(A)
 endif
@@ -95,75 +102,81 @@
 STATIC_LIBS += $(objroot)lib/$(LIBJEMALLOC)_s.$(A)
 endif
 DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SOREV)
 ifneq ($(SOREV),$(SO))
 DSOS += $(objroot)lib/$(LIBJEMALLOC).$(SO)
 endif
+PC := $(objroot)jemalloc.pc
 MAN3 := $(objroot)doc/jemalloc$(install_suffix).3
 DOCS_XML := $(objroot)doc/jemalloc$(install_suffix).xml
-DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.html)
-DOCS_MAN3 := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.3)
+DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(objroot)%.html)
+DOCS_MAN3 := $(DOCS_XML:$(objroot)%.xml=$(objroot)%.3)
 DOCS := $(DOCS_HTML) $(DOCS_MAN3)
-C_TESTLIB_SRCS := $(srcroot)test/src/math.c $(srcroot)test/src/mtx.c \
+C_TESTLIB_SRCS := $(srcroot)test/src/btalloc.c $(srcroot)test/src/btalloc_0.c \
+	$(srcroot)test/src/btalloc_1.c $(srcroot)test/src/math.c \
+	$(srcroot)test/src/mtx.c $(srcroot)test/src/mq.c \
 	$(srcroot)test/src/SFMT.c $(srcroot)test/src/test.c \
-	$(srcroot)test/src/thd.c
+	$(srcroot)test/src/thd.c $(srcroot)test/src/timer.c
 C_UTIL_INTEGRATION_SRCS := $(srcroot)src/util.c
-TESTS_UNIT := $(srcroot)test/unit/bitmap.c \
+TESTS_UNIT := $(srcroot)test/unit/atomic.c \
+	$(srcroot)test/unit/bitmap.c \
 	$(srcroot)test/unit/ckh.c \
 	$(srcroot)test/unit/hash.c \
 	$(srcroot)test/unit/junk.c \
+	$(srcroot)test/unit/junk_alloc.c \
+	$(srcroot)test/unit/junk_free.c \
+	$(srcroot)test/unit/lg_chunk.c \
 	$(srcroot)test/unit/mallctl.c \
 	$(srcroot)test/unit/math.c \
 	$(srcroot)test/unit/mq.c \
 	$(srcroot)test/unit/mtx.c \
 	$(srcroot)test/unit/prof_accum.c \
+	$(srcroot)test/unit/prof_active.c \
 	$(srcroot)test/unit/prof_gdump.c \
 	$(srcroot)test/unit/prof_idump.c \
+	$(srcroot)test/unit/prof_reset.c \
+	$(srcroot)test/unit/prof_thread_name.c \
 	$(srcroot)test/unit/ql.c \
 	$(srcroot)test/unit/qr.c \
 	$(srcroot)test/unit/quarantine.c \
 	$(srcroot)test/unit/rb.c \
 	$(srcroot)test/unit/rtree.c \
 	$(srcroot)test/unit/SFMT.c \
+	$(srcroot)test/unit/size_classes.c \
 	$(srcroot)test/unit/stats.c \
 	$(srcroot)test/unit/tsd.c \
 	$(srcroot)test/unit/util.c \
 	$(srcroot)test/unit/zero.c
-TESTS_UNIT_AUX := $(srcroot)test/unit/prof_accum_a.c \
-	$(srcroot)test/unit/prof_accum_b.c
 TESTS_INTEGRATION := $(srcroot)test/integration/aligned_alloc.c \
 	$(srcroot)test/integration/allocated.c \
+	$(srcroot)test/integration/sdallocx.c \
 	$(srcroot)test/integration/mallocx.c \
-	$(srcroot)test/integration/mremap.c \
+	$(srcroot)test/integration/MALLOCX_ARENA.c \
+	$(srcroot)test/integration/overflow.c \
 	$(srcroot)test/integration/posix_memalign.c \
 	$(srcroot)test/integration/rallocx.c \
 	$(srcroot)test/integration/thread_arena.c \
 	$(srcroot)test/integration/thread_tcache_enabled.c \
-	$(srcroot)test/integration/xallocx.c
-ifeq ($(enable_experimental), 1)
-TESTS_INTEGRATION += $(srcroot)test/integration/allocm.c \
-	$(srcroot)test/integration/MALLOCX_ARENA.c \
-	$(srcroot)test/integration/rallocm.c
-endif
-TESTS_STRESS :=
+	$(srcroot)test/integration/xallocx.c \
+	$(srcroot)test/integration/chunk.c
+TESTS_STRESS := $(srcroot)test/stress/microbench.c
 TESTS := $(TESTS_UNIT) $(TESTS_INTEGRATION) $(TESTS_STRESS)
 
 C_OBJS := $(C_SRCS:$(srcroot)%.c=$(objroot)%.$(O))
 C_PIC_OBJS := $(C_SRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 C_JET_OBJS := $(C_SRCS:$(srcroot)%.c=$(objroot)%.jet.$(O))
 C_TESTLIB_UNIT_OBJS := $(C_TESTLIB_SRCS:$(srcroot)%.c=$(objroot)%.unit.$(O))
 C_TESTLIB_INTEGRATION_OBJS := $(C_TESTLIB_SRCS:$(srcroot)%.c=$(objroot)%.integration.$(O))
 C_UTIL_INTEGRATION_OBJS := $(C_UTIL_INTEGRATION_SRCS:$(srcroot)%.c=$(objroot)%.integration.$(O))
 C_TESTLIB_STRESS_OBJS := $(C_TESTLIB_SRCS:$(srcroot)%.c=$(objroot)%.stress.$(O))
 C_TESTLIB_OBJS := $(C_TESTLIB_UNIT_OBJS) $(C_TESTLIB_INTEGRATION_OBJS) $(C_UTIL_INTEGRATION_OBJS) $(C_TESTLIB_STRESS_OBJS)
 
 TESTS_UNIT_OBJS := $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%.$(O))
-TESTS_UNIT_AUX_OBJS := $(TESTS_UNIT_AUX:$(srcroot)%.c=$(objroot)%.$(O))
 TESTS_INTEGRATION_OBJS := $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%.$(O))
 TESTS_STRESS_OBJS := $(TESTS_STRESS:$(srcroot)%.c=$(objroot)%.$(O))
-TESTS_OBJS := $(TESTS_UNIT_OBJS) $(TESTS_UNIT_AUX_OBJS) $(TESTS_INTEGRATION_OBJS) $(TESTS_STRESS_OBJS)
+TESTS_OBJS := $(TESTS_UNIT_OBJS) $(TESTS_INTEGRATION_OBJS) $(TESTS_STRESS_OBJS)
 
 .PHONY: all dist build_doc_html build_doc_man build_doc
 .PHONY: install_bin install_include install_lib
 .PHONY: install_doc_html install_doc_man install_doc install
 .PHONY: tests check clean distclean relclean
 
@@ -171,16 +184,16 @@
 
 # Default target.
 all: build_lib
 
 dist: build_doc
 
-$(srcroot)doc/%.html : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/html.xsl
+$(objroot)doc/%.html : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/html.xsl
 	$(XSLTPROC) -o $@ $(objroot)doc/html.xsl $<
 
-$(srcroot)doc/%.3 : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/manpages.xsl
+$(objroot)doc/%.3 : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/manpages.xsl
 	$(XSLTPROC) -o $@ $(objroot)doc/manpages.xsl $<
 
 build_doc_html: $(DOCS_HTML)
 build_doc_man: $(DOCS_MAN3)
 build_doc: $(DOCS)
 
@@ -206,33 +219,27 @@
 $(C_TESTLIB_INTEGRATION_OBJS): CPPFLAGS += -DJEMALLOC_INTEGRATION_TEST
 $(C_UTIL_INTEGRATION_OBJS): $(objroot)src/%.integration.$(O): $(srcroot)src/%.c
 $(C_TESTLIB_STRESS_OBJS): $(objroot)test/src/%.stress.$(O): $(srcroot)test/src/%.c
 $(C_TESTLIB_STRESS_OBJS): CPPFLAGS += -DJEMALLOC_STRESS_TEST -DJEMALLOC_STRESS_TESTLIB
 $(C_TESTLIB_OBJS): CPPFLAGS += -I$(srcroot)test/include -I$(objroot)test/include
 $(TESTS_UNIT_OBJS): CPPFLAGS += -DJEMALLOC_UNIT_TEST
-$(TESTS_UNIT_AUX_OBJS): CPPFLAGS += -DJEMALLOC_UNIT_TEST
-define make-unit-link-dep
-$(1): TESTS_UNIT_LINK_OBJS += $(2)
-$(1): $(2)
-endef
-$(foreach test, $(TESTS_UNIT:$(srcroot)test/unit/%.c=$(objroot)test/unit/%$(EXE)), $(eval $(call make-unit-link-dep,$(test),$(filter $(test:%=%_a.$(O)) $(test:%=%_b.$(O)),$(TESTS_UNIT_AUX_OBJS)))))
 $(TESTS_INTEGRATION_OBJS): CPPFLAGS += -DJEMALLOC_INTEGRATION_TEST
 $(TESTS_STRESS_OBJS): CPPFLAGS += -DJEMALLOC_STRESS_TEST
 $(TESTS_OBJS): $(objroot)test/%.$(O): $(srcroot)test/%.c
 $(TESTS_OBJS): CPPFLAGS += -I$(srcroot)test/include -I$(objroot)test/include
 ifneq ($(IMPORTLIB),$(SO))
-$(C_OBJS): CPPFLAGS += -DDLLEXPORT
+$(C_OBJS) $(C_JET_OBJS): CPPFLAGS += -DDLLEXPORT
 endif
 
 ifndef CC_MM
 # Dependencies.
 HEADER_DIRS = $(srcroot)include/jemalloc/internal \
 	$(objroot)include/jemalloc $(objroot)include/jemalloc/internal
 HEADERS = $(wildcard $(foreach dir,$(HEADER_DIRS),$(dir)/*.h))
 $(C_OBJS) $(C_PIC_OBJS) $(C_JET_OBJS) $(C_TESTLIB_OBJS) $(TESTS_OBJS): $(HEADERS)
-$(TESTS_OBJS): $(objroot)test/unit/jemalloc_test.h
+$(TESTS_OBJS): $(objroot)test/include/test/jemalloc_test.h
 endif
 
 $(C_OBJS) $(C_PIC_OBJS) $(C_JET_OBJS) $(C_TESTLIB_OBJS) $(TESTS_OBJS): %.$(O):
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) $(CTARGET) $<
 ifdef CC_MM
@@ -256,21 +263,21 @@
 $(STATIC_LIBS):
 	@mkdir -p $(@D)
 	$(AR) $(ARFLAGS) $@ $+
 
 $(objroot)test/unit/%$(EXE): $(objroot)test/unit/%.$(O) $(TESTS_UNIT_LINK_OBJS) $(C_JET_OBJS) $(C_TESTLIB_UNIT_OBJS)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(EXTRA_LDFLAGS)
+	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
 
 $(objroot)test/integration/%$(EXE): $(objroot)test/integration/%.$(O) $(C_TESTLIB_INTEGRATION_OBJS) $(C_UTIL_INTEGRATION_OBJS) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(filter -lpthread,$(LIBS))) -lm $(EXTRA_LDFLAGS)
+	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(filter -lpthread,$(LIBS))) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
 
 $(objroot)test/stress/%$(EXE): $(objroot)test/stress/%.$(O) $(C_JET_OBJS) $(C_TESTLIB_STRESS_OBJS) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(EXTRA_LDFLAGS)
+	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
 
 build_lib_shared: $(DSOS)
 build_lib_static: $(STATIC_LIBS)
 build_lib: build_lib_shared build_lib_static
 
 install_bin:
@@ -298,13 +305,20 @@
 	install -d $(LIBDIR)
 	@for l in $(STATIC_LIBS); do \
 	echo "install -m 755 $$l $(LIBDIR)"; \
 	install -m 755 $$l $(LIBDIR); \
 done
 
-install_lib: install_lib_shared install_lib_static
+install_lib_pc: $(PC)
+	install -d $(LIBDIR)/pkgconfig
+	@for l in $(PC); do \
+	echo "install -m 644 $$l $(LIBDIR)/pkgconfig"; \
+	install -m 644 $$l $(LIBDIR)/pkgconfig; \
+done
+
+install_lib: install_lib_shared install_lib_static install_lib_pc
 
 install_doc_html:
 	install -d $(DATADIR)/doc/jemalloc$(install_suffix)
 	@for d in $(DOCS_HTML); do \
 	echo "install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix)"; \
 	install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix); \
@@ -327,24 +341,29 @@
 tests: tests_unit tests_integration tests_stress
 
 check_unit_dir:
 	@mkdir -p $(objroot)test/unit
 check_integration_dir:
 	@mkdir -p $(objroot)test/integration
-check_stress_dir:
+stress_dir:
 	@mkdir -p $(objroot)test/stress
-check_dir: check_unit_dir check_integration_dir check_stress_dir
+check_dir: check_unit_dir check_integration_dir
 
 check_unit: tests_unit check_unit_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%)
+check_integration_prof: tests_integration check_integration_dir
+ifeq ($(enable_prof), 1)
+	$(MALLOC_CONF)="prof:true" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="prof:true,prof_active:false" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+endif
 check_integration: tests_integration check_integration_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
-check_stress: tests_stress check_stress_dir
+stress: tests_stress stress_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_STRESS:$(srcroot)%.c=$(objroot)%)
-check: tests check_dir
-	$(SHELL) $(objroot)test/test.sh $(TESTS:$(srcroot)%.c=$(objroot)%)
+check: tests check_dir check_integration_prof
+	$(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%) $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 
 ifeq ($(enable_code_coverage), 1)
 coverage_unit: check_unit
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src jet $(C_JET_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/src unit $(C_TESTLIB_UNIT_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/unit unit $(TESTS_UNIT_OBJS)
@@ -352,13 +371,13 @@
 coverage_integration: check_integration
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src pic $(C_PIC_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src integration $(C_UTIL_INTEGRATION_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/src integration $(C_TESTLIB_INTEGRATION_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/integration integration $(TESTS_INTEGRATION_OBJS)
 
-coverage_stress: check_stress
+coverage_stress: stress
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src pic $(C_PIC_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src jet $(C_JET_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/src stress $(C_TESTLIB_STRESS_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/stress stress $(TESTS_STRESS_OBJS)
 
 coverage: check
@@ -397,23 +416,24 @@
 	rm -f $(TESTS_OBJS:%.$(O)=%.gcno)
 	rm -f $(TESTS_OBJS:%.$(O)=%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
 	rm -f $(objroot)*.gcov.*
 
 distclean: clean
-	rm -rf $(objroot)autom4te.cache
+	rm -f $(objroot)bin/jemalloc-config
 	rm -f $(objroot)bin/jemalloc.sh
+	rm -f $(objroot)bin/jeprof
 	rm -f $(objroot)config.log
 	rm -f $(objroot)config.status
 	rm -f $(objroot)config.stamp
 	rm -f $(cfghdrs_out)
 	rm -f $(cfgoutputs_out)
 
 relclean: distclean
 	rm -f $(objroot)configure
-	rm -f $(srcroot)VERSION
+	rm -f $(objroot)VERSION
 	rm -f $(DOCS_HTML)
 	rm -f $(DOCS_MAN3)
 
 #===============================================================================
 # Re-configuration rules.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/Makefile.in	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/Makefile.in	2016-05-06 15:11:36.000000000 +0800
@@ -25,12 +25,13 @@
 # Build parameters.
 CPPFLAGS := @CPPFLAGS@ -I$(srcroot)include -I$(objroot)include
 CFLAGS := @CFLAGS@
 LDFLAGS := @LDFLAGS@
 EXTRA_LDFLAGS := @EXTRA_LDFLAGS@
 LIBS := @LIBS@
+TESTLIBS := @TESTLIBS@
 RPATH_EXTRA := @RPATH_EXTRA@
 SO := @so@
 IMPORTLIB := @importlib@
 O := @o@
 A := @a@
 EXE := @exe@
@@ -39,20 +40,22 @@
 install_suffix := @install_suffix@
 ABI := @abi@
 XSLTPROC := @XSLTPROC@
 AUTOCONF := @AUTOCONF@
 _RPATH = @RPATH@
 RPATH = $(if $(1),$(call _RPATH,$(1)))
-cfghdrs_in := @cfghdrs_in@
+cfghdrs_in := $(addprefix $(srcroot),@cfghdrs_in@)
 cfghdrs_out := @cfghdrs_out@
-cfgoutputs_in := @cfgoutputs_in@
+cfgoutputs_in := $(addprefix $(srcroot),@cfgoutputs_in@)
 cfgoutputs_out := @cfgoutputs_out@
 enable_autogen := @enable_autogen@
 enable_code_coverage := @enable_code_coverage@
-enable_experimental := @enable_experimental@
+enable_prof := @enable_prof@
+enable_valgrind := @enable_valgrind@
 enable_zone_allocator := @enable_zone_allocator@
+MALLOC_CONF := @JEMALLOC_CPREFIX@MALLOC_CONF
 DSO_LDFLAGS = @DSO_LDFLAGS@
 SOREV = @SOREV@
 PIC_CFLAGS = @PIC_CFLAGS@
 CTARGET = @CTARGET@
 LDTARGET = @LDTARGET@
 MKLIB = @MKLIB@
@@ -70,22 +73,26 @@
 endif
 endif
 
 LIBJEMALLOC := $(LIBPREFIX)jemalloc$(install_suffix)
 
 # Lists of files.
-BINS := $(srcroot)bin/pprof $(objroot)bin/jemalloc.sh
+BINS := $(objroot)bin/jemalloc-config $(objroot)bin/jemalloc.sh $(objroot)bin/jeprof
 C_HDRS := $(objroot)include/jemalloc/jemalloc$(install_suffix).h
 C_SRCS := $(srcroot)src/jemalloc.c $(srcroot)src/arena.c \
 	$(srcroot)src/atomic.c $(srcroot)src/base.c $(srcroot)src/bitmap.c \
 	$(srcroot)src/chunk.c $(srcroot)src/chunk_dss.c \
 	$(srcroot)src/chunk_mmap.c $(srcroot)src/ckh.c $(srcroot)src/ctl.c \
 	$(srcroot)src/extent.c $(srcroot)src/hash.c $(srcroot)src/huge.c \
-	$(srcroot)src/mb.c $(srcroot)src/mutex.c $(srcroot)src/prof.c \
-	$(srcroot)src/quarantine.c $(srcroot)src/rtree.c $(srcroot)src/stats.c \
-	$(srcroot)src/tcache.c $(srcroot)src/util.c $(srcroot)src/tsd.c
+	$(srcroot)src/mb.c $(srcroot)src/mutex.c $(srcroot)src/pages.c \
+	$(srcroot)src/prof.c $(srcroot)src/quarantine.c $(srcroot)src/rtree.c \
+	$(srcroot)src/stats.c $(srcroot)src/tcache.c $(srcroot)src/util.c \
+	$(srcroot)src/tsd.c
+ifeq ($(enable_valgrind), 1)
+C_SRCS += $(srcroot)src/valgrind.c
+endif
 ifeq ($(enable_zone_allocator), 1)
 C_SRCS += $(srcroot)src/zone.c
 endif
 ifeq ($(IMPORTLIB),$(SO))
 STATIC_LIBS := $(objroot)lib/$(LIBJEMALLOC).$(A)
 endif
@@ -95,75 +102,81 @@
 STATIC_LIBS += $(objroot)lib/$(LIBJEMALLOC)_s.$(A)
 endif
 DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SOREV)
 ifneq ($(SOREV),$(SO))
 DSOS += $(objroot)lib/$(LIBJEMALLOC).$(SO)
 endif
+PC := $(objroot)jemalloc.pc
 MAN3 := $(objroot)doc/jemalloc$(install_suffix).3
 DOCS_XML := $(objroot)doc/jemalloc$(install_suffix).xml
-DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.html)
-DOCS_MAN3 := $(DOCS_XML:$(objroot)%.xml=$(srcroot)%.3)
+DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(objroot)%.html)
+DOCS_MAN3 := $(DOCS_XML:$(objroot)%.xml=$(objroot)%.3)
 DOCS := $(DOCS_HTML) $(DOCS_MAN3)
-C_TESTLIB_SRCS := $(srcroot)test/src/math.c $(srcroot)test/src/mtx.c \
+C_TESTLIB_SRCS := $(srcroot)test/src/btalloc.c $(srcroot)test/src/btalloc_0.c \
+	$(srcroot)test/src/btalloc_1.c $(srcroot)test/src/math.c \
+	$(srcroot)test/src/mtx.c $(srcroot)test/src/mq.c \
 	$(srcroot)test/src/SFMT.c $(srcroot)test/src/test.c \
-	$(srcroot)test/src/thd.c
+	$(srcroot)test/src/thd.c $(srcroot)test/src/timer.c
 C_UTIL_INTEGRATION_SRCS := $(srcroot)src/util.c
-TESTS_UNIT := $(srcroot)test/unit/bitmap.c \
+TESTS_UNIT := $(srcroot)test/unit/atomic.c \
+	$(srcroot)test/unit/bitmap.c \
 	$(srcroot)test/unit/ckh.c \
 	$(srcroot)test/unit/hash.c \
 	$(srcroot)test/unit/junk.c \
+	$(srcroot)test/unit/junk_alloc.c \
+	$(srcroot)test/unit/junk_free.c \
+	$(srcroot)test/unit/lg_chunk.c \
 	$(srcroot)test/unit/mallctl.c \
 	$(srcroot)test/unit/math.c \
 	$(srcroot)test/unit/mq.c \
 	$(srcroot)test/unit/mtx.c \
 	$(srcroot)test/unit/prof_accum.c \
+	$(srcroot)test/unit/prof_active.c \
 	$(srcroot)test/unit/prof_gdump.c \
 	$(srcroot)test/unit/prof_idump.c \
+	$(srcroot)test/unit/prof_reset.c \
+	$(srcroot)test/unit/prof_thread_name.c \
 	$(srcroot)test/unit/ql.c \
 	$(srcroot)test/unit/qr.c \
 	$(srcroot)test/unit/quarantine.c \
 	$(srcroot)test/unit/rb.c \
 	$(srcroot)test/unit/rtree.c \
 	$(srcroot)test/unit/SFMT.c \
+	$(srcroot)test/unit/size_classes.c \
 	$(srcroot)test/unit/stats.c \
 	$(srcroot)test/unit/tsd.c \
 	$(srcroot)test/unit/util.c \
 	$(srcroot)test/unit/zero.c
-TESTS_UNIT_AUX := $(srcroot)test/unit/prof_accum_a.c \
-	$(srcroot)test/unit/prof_accum_b.c
 TESTS_INTEGRATION := $(srcroot)test/integration/aligned_alloc.c \
 	$(srcroot)test/integration/allocated.c \
+	$(srcroot)test/integration/sdallocx.c \
 	$(srcroot)test/integration/mallocx.c \
-	$(srcroot)test/integration/mremap.c \
+	$(srcroot)test/integration/MALLOCX_ARENA.c \
+	$(srcroot)test/integration/overflow.c \
 	$(srcroot)test/integration/posix_memalign.c \
 	$(srcroot)test/integration/rallocx.c \
 	$(srcroot)test/integration/thread_arena.c \
 	$(srcroot)test/integration/thread_tcache_enabled.c \
-	$(srcroot)test/integration/xallocx.c
-ifeq ($(enable_experimental), 1)
-TESTS_INTEGRATION += $(srcroot)test/integration/allocm.c \
-	$(srcroot)test/integration/MALLOCX_ARENA.c \
-	$(srcroot)test/integration/rallocm.c
-endif
-TESTS_STRESS :=
+	$(srcroot)test/integration/xallocx.c \
+	$(srcroot)test/integration/chunk.c
+TESTS_STRESS := $(srcroot)test/stress/microbench.c
 TESTS := $(TESTS_UNIT) $(TESTS_INTEGRATION) $(TESTS_STRESS)
 
 C_OBJS := $(C_SRCS:$(srcroot)%.c=$(objroot)%.$(O))
 C_PIC_OBJS := $(C_SRCS:$(srcroot)%.c=$(objroot)%.pic.$(O))
 C_JET_OBJS := $(C_SRCS:$(srcroot)%.c=$(objroot)%.jet.$(O))
 C_TESTLIB_UNIT_OBJS := $(C_TESTLIB_SRCS:$(srcroot)%.c=$(objroot)%.unit.$(O))
 C_TESTLIB_INTEGRATION_OBJS := $(C_TESTLIB_SRCS:$(srcroot)%.c=$(objroot)%.integration.$(O))
 C_UTIL_INTEGRATION_OBJS := $(C_UTIL_INTEGRATION_SRCS:$(srcroot)%.c=$(objroot)%.integration.$(O))
 C_TESTLIB_STRESS_OBJS := $(C_TESTLIB_SRCS:$(srcroot)%.c=$(objroot)%.stress.$(O))
 C_TESTLIB_OBJS := $(C_TESTLIB_UNIT_OBJS) $(C_TESTLIB_INTEGRATION_OBJS) $(C_UTIL_INTEGRATION_OBJS) $(C_TESTLIB_STRESS_OBJS)
 
 TESTS_UNIT_OBJS := $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%.$(O))
-TESTS_UNIT_AUX_OBJS := $(TESTS_UNIT_AUX:$(srcroot)%.c=$(objroot)%.$(O))
 TESTS_INTEGRATION_OBJS := $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%.$(O))
 TESTS_STRESS_OBJS := $(TESTS_STRESS:$(srcroot)%.c=$(objroot)%.$(O))
-TESTS_OBJS := $(TESTS_UNIT_OBJS) $(TESTS_UNIT_AUX_OBJS) $(TESTS_INTEGRATION_OBJS) $(TESTS_STRESS_OBJS)
+TESTS_OBJS := $(TESTS_UNIT_OBJS) $(TESTS_INTEGRATION_OBJS) $(TESTS_STRESS_OBJS)
 
 .PHONY: all dist build_doc_html build_doc_man build_doc
 .PHONY: install_bin install_include install_lib
 .PHONY: install_doc_html install_doc_man install_doc install
 .PHONY: tests check clean distclean relclean
 
@@ -171,16 +184,16 @@
 
 # Default target.
 all: build_lib
 
 dist: build_doc
 
-$(srcroot)doc/%.html : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/html.xsl
+$(objroot)doc/%.html : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/html.xsl
 	$(XSLTPROC) -o $@ $(objroot)doc/html.xsl $<
 
-$(srcroot)doc/%.3 : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/manpages.xsl
+$(objroot)doc/%.3 : $(objroot)doc/%.xml $(srcroot)doc/stylesheet.xsl $(objroot)doc/manpages.xsl
 	$(XSLTPROC) -o $@ $(objroot)doc/manpages.xsl $<
 
 build_doc_html: $(DOCS_HTML)
 build_doc_man: $(DOCS_MAN3)
 build_doc: $(DOCS)
 
@@ -206,33 +219,27 @@
 $(C_TESTLIB_INTEGRATION_OBJS): CPPFLAGS += -DJEMALLOC_INTEGRATION_TEST
 $(C_UTIL_INTEGRATION_OBJS): $(objroot)src/%.integration.$(O): $(srcroot)src/%.c
 $(C_TESTLIB_STRESS_OBJS): $(objroot)test/src/%.stress.$(O): $(srcroot)test/src/%.c
 $(C_TESTLIB_STRESS_OBJS): CPPFLAGS += -DJEMALLOC_STRESS_TEST -DJEMALLOC_STRESS_TESTLIB
 $(C_TESTLIB_OBJS): CPPFLAGS += -I$(srcroot)test/include -I$(objroot)test/include
 $(TESTS_UNIT_OBJS): CPPFLAGS += -DJEMALLOC_UNIT_TEST
-$(TESTS_UNIT_AUX_OBJS): CPPFLAGS += -DJEMALLOC_UNIT_TEST
-define make-unit-link-dep
-$(1): TESTS_UNIT_LINK_OBJS += $(2)
-$(1): $(2)
-endef
-$(foreach test, $(TESTS_UNIT:$(srcroot)test/unit/%.c=$(objroot)test/unit/%$(EXE)), $(eval $(call make-unit-link-dep,$(test),$(filter $(test:%=%_a.$(O)) $(test:%=%_b.$(O)),$(TESTS_UNIT_AUX_OBJS)))))
 $(TESTS_INTEGRATION_OBJS): CPPFLAGS += -DJEMALLOC_INTEGRATION_TEST
 $(TESTS_STRESS_OBJS): CPPFLAGS += -DJEMALLOC_STRESS_TEST
 $(TESTS_OBJS): $(objroot)test/%.$(O): $(srcroot)test/%.c
 $(TESTS_OBJS): CPPFLAGS += -I$(srcroot)test/include -I$(objroot)test/include
 ifneq ($(IMPORTLIB),$(SO))
-$(C_OBJS): CPPFLAGS += -DDLLEXPORT
+$(C_OBJS) $(C_JET_OBJS): CPPFLAGS += -DDLLEXPORT
 endif
 
 ifndef CC_MM
 # Dependencies.
 HEADER_DIRS = $(srcroot)include/jemalloc/internal \
 	$(objroot)include/jemalloc $(objroot)include/jemalloc/internal
 HEADERS = $(wildcard $(foreach dir,$(HEADER_DIRS),$(dir)/*.h))
 $(C_OBJS) $(C_PIC_OBJS) $(C_JET_OBJS) $(C_TESTLIB_OBJS) $(TESTS_OBJS): $(HEADERS)
-$(TESTS_OBJS): $(objroot)test/unit/jemalloc_test.h
+$(TESTS_OBJS): $(objroot)test/include/test/jemalloc_test.h
 endif
 
 $(C_OBJS) $(C_PIC_OBJS) $(C_JET_OBJS) $(C_TESTLIB_OBJS) $(TESTS_OBJS): %.$(O):
 	@mkdir -p $(@D)
 	$(CC) $(CFLAGS) -c $(CPPFLAGS) $(CTARGET) $<
 ifdef CC_MM
@@ -256,21 +263,21 @@
 $(STATIC_LIBS):
 	@mkdir -p $(@D)
 	$(AR) $(ARFLAGS)@AROUT@ $+
 
 $(objroot)test/unit/%$(EXE): $(objroot)test/unit/%.$(O) $(TESTS_UNIT_LINK_OBJS) $(C_JET_OBJS) $(C_TESTLIB_UNIT_OBJS)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(EXTRA_LDFLAGS)
+	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
 
 $(objroot)test/integration/%$(EXE): $(objroot)test/integration/%.$(O) $(C_TESTLIB_INTEGRATION_OBJS) $(C_UTIL_INTEGRATION_OBJS) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(filter -lpthread,$(LIBS))) -lm $(EXTRA_LDFLAGS)
+	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(filter -lpthread,$(LIBS))) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
 
 $(objroot)test/stress/%$(EXE): $(objroot)test/stress/%.$(O) $(C_JET_OBJS) $(C_TESTLIB_STRESS_OBJS) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(EXTRA_LDFLAGS)
+	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
 
 build_lib_shared: $(DSOS)
 build_lib_static: $(STATIC_LIBS)
 build_lib: build_lib_shared build_lib_static
 
 install_bin:
@@ -298,13 +305,20 @@
 	install -d $(LIBDIR)
 	@for l in $(STATIC_LIBS); do \
 	echo "install -m 755 $$l $(LIBDIR)"; \
 	install -m 755 $$l $(LIBDIR); \
 done
 
-install_lib: install_lib_shared install_lib_static
+install_lib_pc: $(PC)
+	install -d $(LIBDIR)/pkgconfig
+	@for l in $(PC); do \
+	echo "install -m 644 $$l $(LIBDIR)/pkgconfig"; \
+	install -m 644 $$l $(LIBDIR)/pkgconfig; \
+done
+
+install_lib: install_lib_shared install_lib_static install_lib_pc
 
 install_doc_html:
 	install -d $(DATADIR)/doc/jemalloc$(install_suffix)
 	@for d in $(DOCS_HTML); do \
 	echo "install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix)"; \
 	install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix); \
@@ -327,24 +341,29 @@
 tests: tests_unit tests_integration tests_stress
 
 check_unit_dir:
 	@mkdir -p $(objroot)test/unit
 check_integration_dir:
 	@mkdir -p $(objroot)test/integration
-check_stress_dir:
+stress_dir:
 	@mkdir -p $(objroot)test/stress
-check_dir: check_unit_dir check_integration_dir check_stress_dir
+check_dir: check_unit_dir check_integration_dir
 
 check_unit: tests_unit check_unit_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%)
+check_integration_prof: tests_integration check_integration_dir
+ifeq ($(enable_prof), 1)
+	$(MALLOC_CONF)="prof:true" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="prof:true,prof_active:false" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+endif
 check_integration: tests_integration check_integration_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
-check_stress: tests_stress check_stress_dir
+stress: tests_stress stress_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_STRESS:$(srcroot)%.c=$(objroot)%)
-check: tests check_dir
-	$(SHELL) $(objroot)test/test.sh $(TESTS:$(srcroot)%.c=$(objroot)%)
+check: tests check_dir check_integration_prof
+	$(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%) $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 
 ifeq ($(enable_code_coverage), 1)
 coverage_unit: check_unit
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src jet $(C_JET_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/src unit $(C_TESTLIB_UNIT_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/unit unit $(TESTS_UNIT_OBJS)
@@ -352,13 +371,13 @@
 coverage_integration: check_integration
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src pic $(C_PIC_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src integration $(C_UTIL_INTEGRATION_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/src integration $(C_TESTLIB_INTEGRATION_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/integration integration $(TESTS_INTEGRATION_OBJS)
 
-coverage_stress: check_stress
+coverage_stress: stress
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src pic $(C_PIC_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src jet $(C_JET_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/src stress $(C_TESTLIB_STRESS_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/stress stress $(TESTS_STRESS_OBJS)
 
 coverage: check
@@ -397,23 +416,24 @@
 	rm -f $(TESTS_OBJS:%.$(O)=%.gcno)
 	rm -f $(TESTS_OBJS:%.$(O)=%.out)
 	rm -f $(DSOS) $(STATIC_LIBS)
 	rm -f $(objroot)*.gcov.*
 
 distclean: clean
-	rm -rf $(objroot)autom4te.cache
+	rm -f $(objroot)bin/jemalloc-config
 	rm -f $(objroot)bin/jemalloc.sh
+	rm -f $(objroot)bin/jeprof
 	rm -f $(objroot)config.log
 	rm -f $(objroot)config.status
 	rm -f $(objroot)config.stamp
 	rm -f $(cfghdrs_out)
 	rm -f $(cfgoutputs_out)
 
 relclean: distclean
 	rm -f $(objroot)configure
-	rm -f $(srcroot)VERSION
+	rm -f $(objroot)VERSION
 	rm -f $(DOCS_HTML)
 	rm -f $(DOCS_MAN3)
 
 #===============================================================================
 # Re-configuration rules.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.c	2016-05-06 15:11:36.000000000 +0800
@@ -2,350 +2,360 @@
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 /* Data. */
 
 ssize_t		opt_lg_dirty_mult = LG_DIRTY_MULT_DEFAULT;
+static ssize_t	lg_dirty_mult_default;
 arena_bin_info_t	arena_bin_info[NBINS];
 
-JEMALLOC_ALIGNED(CACHELINE)
-const uint8_t	small_size2bin[] = {
-#define	S2B_8(i)	i,
-#define	S2B_16(i)	S2B_8(i) S2B_8(i)
-#define	S2B_32(i)	S2B_16(i) S2B_16(i)
-#define	S2B_64(i)	S2B_32(i) S2B_32(i)
-#define	S2B_128(i)	S2B_64(i) S2B_64(i)
-#define	S2B_256(i)	S2B_128(i) S2B_128(i)
-#define	S2B_512(i)	S2B_256(i) S2B_256(i)
-#define	S2B_1024(i)	S2B_512(i) S2B_512(i)
-#define	S2B_2048(i)	S2B_1024(i) S2B_1024(i)
-#define	S2B_4096(i)	S2B_2048(i) S2B_2048(i)
-#define	S2B_8192(i)	S2B_4096(i) S2B_4096(i)
-#define	SIZE_CLASS(bin, delta, size)					\
-	S2B_##delta(bin)
-	SIZE_CLASSES
-#undef S2B_8
-#undef S2B_16
-#undef S2B_32
-#undef S2B_64
-#undef S2B_128
-#undef S2B_256
-#undef S2B_512
-#undef S2B_1024
-#undef S2B_2048
-#undef S2B_4096
-#undef S2B_8192
-#undef SIZE_CLASS
-};
+size_t		map_bias;
+size_t		map_misc_offset;
+size_t		arena_maxrun; /* Max run size for arenas. */
+size_t		large_maxclass; /* Max large size class. */
+static size_t	small_maxrun; /* Max run size used for small size classes. */
+static bool	*small_run_tab; /* Valid small run page multiples. */
+unsigned	nlclasses; /* Number of large size classes. */
+unsigned	nhclasses; /* Number of huge size classes. */
 
 /******************************************************************************/
 /*
  * Function prototypes for static functions that are referenced prior to
  * definition.
  */
 
 static void	arena_purge(arena_t *arena, bool all);
 static void	arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty,
-    bool cleaned);
+    bool cleaned, bool decommitted);
 static void	arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk,
     arena_run_t *run, arena_bin_t *bin);
 static void	arena_bin_lower_run(arena_t *arena, arena_chunk_t *chunk,
     arena_run_t *run, arena_bin_t *bin);
 
 /******************************************************************************/
 
-static inline int
-arena_run_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
+#define	CHUNK_MAP_KEY		((uintptr_t)0x1U)
+
+JEMALLOC_INLINE_C arena_chunk_map_misc_t *
+arena_miscelm_key_create(size_t size)
 {
-	uintptr_t a_mapelm = (uintptr_t)a;
-	uintptr_t b_mapelm = (uintptr_t)b;
 
-	assert(a != NULL);
-	assert(b != NULL);
+	return ((arena_chunk_map_misc_t *)(arena_mapbits_size_encode(size) |
+	    CHUNK_MAP_KEY));
+}
+
+JEMALLOC_INLINE_C bool
+arena_miscelm_is_key(const arena_chunk_map_misc_t *miscelm)
+{
 
-	return ((a_mapelm > b_mapelm) - (a_mapelm < b_mapelm));
+	return (((uintptr_t)miscelm & CHUNK_MAP_KEY) != 0);
 }
 
-/* Generate red-black tree functions. */
-rb_gen(static UNUSED, arena_run_tree_, arena_run_tree_t, arena_chunk_map_t,
-    u.rb_link, arena_run_comp)
+#undef CHUNK_MAP_KEY
 
-static inline int
-arena_avail_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
+JEMALLOC_INLINE_C size_t
+arena_miscelm_key_size_get(const arena_chunk_map_misc_t *miscelm)
 {
-	int ret;
-	size_t a_size = a->bits & ~PAGE_MASK;
-	size_t b_size = b->bits & ~PAGE_MASK;
 
-	ret = (a_size > b_size) - (a_size < b_size);
-	if (ret == 0) {
-		uintptr_t a_mapelm, b_mapelm;
+	assert(arena_miscelm_is_key(miscelm));
 
-		if ((a->bits & CHUNK_MAP_KEY) != CHUNK_MAP_KEY)
-			a_mapelm = (uintptr_t)a;
-		else {
-			/*
-			 * Treat keys as though they are lower than anything
-			 * else.
-			 */
-			a_mapelm = 0;
-		}
-		b_mapelm = (uintptr_t)b;
+	return (arena_mapbits_size_decode((uintptr_t)miscelm));
+}
 
-		ret = (a_mapelm > b_mapelm) - (a_mapelm < b_mapelm);
-	}
+JEMALLOC_INLINE_C size_t
+arena_miscelm_size_get(arena_chunk_map_misc_t *miscelm)
+{
+	arena_chunk_t *chunk;
+	size_t pageind, mapbits;
 
-	return (ret);
-}
+	assert(!arena_miscelm_is_key(miscelm));
 
-/* Generate red-black tree functions. */
-rb_gen(static UNUSED, arena_avail_tree_, arena_avail_tree_t, arena_chunk_map_t,
-    u.rb_link, arena_avail_comp)
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(miscelm);
+	pageind = arena_miscelm_to_pageind(miscelm);
+	mapbits = arena_mapbits_get(chunk, pageind);
+	return (arena_mapbits_size_decode(mapbits));
+}
 
-static inline int
-arena_chunk_dirty_comp(arena_chunk_t *a, arena_chunk_t *b)
+JEMALLOC_INLINE_C int
+arena_run_comp(arena_chunk_map_misc_t *a, arena_chunk_map_misc_t *b)
 {
+	uintptr_t a_miscelm = (uintptr_t)a;
+	uintptr_t b_miscelm = (uintptr_t)b;
 
 	assert(a != NULL);
 	assert(b != NULL);
 
+	return ((a_miscelm > b_miscelm) - (a_miscelm < b_miscelm));
+}
+
+/* Generate red-black tree functions. */
+rb_gen(static UNUSED, arena_run_tree_, arena_run_tree_t, arena_chunk_map_misc_t,
+    rb_link, arena_run_comp)
+
+static size_t
+run_quantize(size_t size)
+{
+	size_t qsize;
+
+	assert(size != 0);
+	assert(size == PAGE_CEILING(size));
+
+	/* Don't change sizes that are valid small run sizes. */
+	if (size <= small_maxrun && small_run_tab[size >> LG_PAGE])
+		return (size);
+
 	/*
-	 * Short-circuit for self comparison.  The following comparison code
-	 * would come to the same result, but at the cost of executing the slow
-	 * path.
+	 * Round down to the nearest run size that can actually be requested
+	 * during normal large allocation.  Add large_pad so that cache index
+	 * randomization can offset the allocation from the page boundary.
 	 */
-	if (a == b)
-		return (0);
+	qsize = index2size(size2index(size - large_pad + 1) - 1) + large_pad;
+	if (qsize <= SMALL_MAXCLASS + large_pad)
+		return (run_quantize(size - large_pad));
+	assert(qsize <= size);
+	return (qsize);
+}
+
+static size_t
+run_quantize_next(size_t size)
+{
+	size_t large_run_size_next;
+
+	assert(size != 0);
+	assert(size == PAGE_CEILING(size));
 
 	/*
-	 * Order such that chunks with higher fragmentation are "less than"
-	 * those with lower fragmentation -- purging order is from "least" to
-	 * "greatest".  Fragmentation is measured as:
-	 *
-	 *     mean current avail run size
-	 *   --------------------------------
-	 *   mean defragmented avail run size
-	 *
-	 *            navail
-	 *         -----------
-	 *         nruns_avail           nruns_avail-nruns_adjac
-	 * = ========================= = -----------------------
-	 *            navail                  nruns_avail
-	 *    -----------------------
-	 *    nruns_avail-nruns_adjac
-	 *
-	 * The following code multiplies away the denominator prior to
-	 * comparison, in order to avoid division.
-	 *
+	 * Return the next quantized size greater than the input size.
+	 * Quantized sizes comprise the union of run sizes that back small
+	 * region runs, and run sizes that back large regions with no explicit
+	 * alignment constraints.
 	 */
-	{
-		size_t a_val = (a->nruns_avail - a->nruns_adjac) *
-		    b->nruns_avail;
-		size_t b_val = (b->nruns_avail - b->nruns_adjac) *
-		    a->nruns_avail;
-
-		if (a_val < b_val)
-			return (1);
-		if (a_val > b_val)
-			return (-1);
-	}
-	/*
-	 * Break ties by chunk address.  For fragmented chunks, report lower
-	 * addresses as "lower", so that fragmentation reduction happens first
-	 * at lower addresses.  However, use the opposite ordering for
-	 * unfragmented chunks, in order to increase the chances of
-	 * re-allocating dirty runs.
-	 */
-	{
-		uintptr_t a_chunk = (uintptr_t)a;
-		uintptr_t b_chunk = (uintptr_t)b;
-		int ret = ((a_chunk > b_chunk) - (a_chunk < b_chunk));
-		if (a->nruns_adjac == 0) {
-			assert(b->nruns_adjac == 0);
-			ret = -ret;
+
+	if (size > SMALL_MAXCLASS) {
+		large_run_size_next = PAGE_CEILING(index2size(size2index(size -
+		    large_pad) + 1) + large_pad);
+	} else
+		large_run_size_next = SIZE_T_MAX;
+	if (size >= small_maxrun)
+		return (large_run_size_next);
+
+	while (true) {
+		size += PAGE;
+		assert(size <= small_maxrun);
+		if (small_run_tab[size >> LG_PAGE]) {
+			if (large_run_size_next < size)
+				return (large_run_size_next);
+			return (size);
 		}
-		return (ret);
 	}
 }
 
-/* Generate red-black tree functions. */
-rb_gen(static UNUSED, arena_chunk_dirty_, arena_chunk_tree_t, arena_chunk_t,
-    dirty_link, arena_chunk_dirty_comp)
-
-static inline bool
-arena_avail_adjac_pred(arena_chunk_t *chunk, size_t pageind)
+static size_t
+run_quantize_first(size_t size)
 {
-	bool ret;
+	size_t qsize = run_quantize(size);
 
-	if (pageind-1 < map_bias)
-		ret = false;
-	else {
-		ret = (arena_mapbits_allocated_get(chunk, pageind-1) == 0);
-		assert(ret == false || arena_mapbits_dirty_get(chunk,
-		    pageind-1) != arena_mapbits_dirty_get(chunk, pageind));
+	if (qsize < size) {
+		/*
+		 * Skip a quantization that may have an adequately large run,
+		 * because under-sized runs may be mixed in.  This only happens
+		 * when an unusual size is requested, i.e. for aligned
+		 * allocation, and is just one of several places where linear
+		 * search would potentially find sufficiently aligned available
+		 * memory somewhere lower.
+		 */
+		qsize = run_quantize_next(size);
 	}
-	return (ret);
+	return (qsize);
 }
 
-static inline bool
-arena_avail_adjac_succ(arena_chunk_t *chunk, size_t pageind, size_t npages)
+JEMALLOC_INLINE_C int
+arena_avail_comp(arena_chunk_map_misc_t *a, arena_chunk_map_misc_t *b)
 {
-	bool ret;
+	int ret;
+	uintptr_t a_miscelm = (uintptr_t)a;
+	size_t a_qsize = run_quantize(arena_miscelm_is_key(a) ?
+	    arena_miscelm_key_size_get(a) : arena_miscelm_size_get(a));
+	size_t b_qsize = run_quantize(arena_miscelm_size_get(b));
 
-	if (pageind+npages == chunk_npages)
-		ret = false;
-	else {
-		assert(pageind+npages < chunk_npages);
-		ret = (arena_mapbits_allocated_get(chunk, pageind+npages) == 0);
-		assert(ret == false || arena_mapbits_dirty_get(chunk, pageind)
-		    != arena_mapbits_dirty_get(chunk, pageind+npages));
+	/*
+	 * Compare based on quantized size rather than size, in order to sort
+	 * equally useful runs only by address.
+	 */
+	ret = (a_qsize > b_qsize) - (a_qsize < b_qsize);
+	if (ret == 0) {
+		if (!arena_miscelm_is_key(a)) {
+			uintptr_t b_miscelm = (uintptr_t)b;
+
+			ret = (a_miscelm > b_miscelm) - (a_miscelm < b_miscelm);
+		} else {
+			/*
+			 * Treat keys as if they are lower than anything else.
+			 */
+			ret = -1;
+		}
 	}
+
 	return (ret);
 }
 
-static inline bool
-arena_avail_adjac(arena_chunk_t *chunk, size_t pageind, size_t npages)
+/* Generate red-black tree functions. */
+rb_gen(static UNUSED, arena_avail_tree_, arena_avail_tree_t,
+    arena_chunk_map_misc_t, rb_link, arena_avail_comp)
+
+static void
+arena_avail_insert(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
+    size_t npages)
 {
 
-	return (arena_avail_adjac_pred(chunk, pageind) ||
-	    arena_avail_adjac_succ(chunk, pageind, npages));
+	assert(npages == (arena_mapbits_unallocated_size_get(chunk, pageind) >>
+	    LG_PAGE));
+	arena_avail_tree_insert(&arena->runs_avail, arena_miscelm_get(chunk,
+	    pageind));
 }
 
 static void
-arena_avail_insert(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
-    size_t npages, bool maybe_adjac_pred, bool maybe_adjac_succ)
+arena_avail_remove(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
+    size_t npages)
 {
 
 	assert(npages == (arena_mapbits_unallocated_size_get(chunk, pageind) >>
 	    LG_PAGE));
+	arena_avail_tree_remove(&arena->runs_avail, arena_miscelm_get(chunk,
+	    pageind));
+}
 
-	/*
-	 * chunks_dirty is keyed by nruns_{avail,adjac}, so the chunk must be
-	 * removed and reinserted even if the run to be inserted is clean.
-	 */
-	if (chunk->ndirty != 0)
-		arena_chunk_dirty_remove(&arena->chunks_dirty, chunk);
+static void
+arena_run_dirty_insert(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
+    size_t npages)
+{
+	arena_chunk_map_misc_t *miscelm = arena_miscelm_get(chunk, pageind);
 
-	if (maybe_adjac_pred && arena_avail_adjac_pred(chunk, pageind))
-		chunk->nruns_adjac++;
-	if (maybe_adjac_succ && arena_avail_adjac_succ(chunk, pageind, npages))
-		chunk->nruns_adjac++;
-	chunk->nruns_avail++;
-	assert(chunk->nruns_avail > chunk->nruns_adjac);
-
-	if (arena_mapbits_dirty_get(chunk, pageind) != 0) {
-		arena->ndirty += npages;
-		chunk->ndirty += npages;
-	}
-	if (chunk->ndirty != 0)
-		arena_chunk_dirty_insert(&arena->chunks_dirty, chunk);
+	assert(npages == (arena_mapbits_unallocated_size_get(chunk, pageind) >>
+	    LG_PAGE));
+	assert(arena_mapbits_dirty_get(chunk, pageind) == CHUNK_MAP_DIRTY);
+	assert(arena_mapbits_dirty_get(chunk, pageind+npages-1) ==
+	    CHUNK_MAP_DIRTY);
 
-	arena_avail_tree_insert(&arena->runs_avail, arena_mapp_get(chunk,
-	    pageind));
+	qr_new(&miscelm->rd, rd_link);
+	qr_meld(&arena->runs_dirty, &miscelm->rd, rd_link);
+	arena->ndirty += npages;
 }
 
 static void
-arena_avail_remove(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
-    size_t npages, bool maybe_adjac_pred, bool maybe_adjac_succ)
+arena_run_dirty_remove(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
+    size_t npages)
 {
+	arena_chunk_map_misc_t *miscelm = arena_miscelm_get(chunk, pageind);
 
 	assert(npages == (arena_mapbits_unallocated_size_get(chunk, pageind) >>
 	    LG_PAGE));
+	assert(arena_mapbits_dirty_get(chunk, pageind) == CHUNK_MAP_DIRTY);
+	assert(arena_mapbits_dirty_get(chunk, pageind+npages-1) ==
+	    CHUNK_MAP_DIRTY);
+
+	qr_remove(&miscelm->rd, rd_link);
+	assert(arena->ndirty >= npages);
+	arena->ndirty -= npages;
+}
 
-	/*
-	 * chunks_dirty is keyed by nruns_{avail,adjac}, so the chunk must be
-	 * removed and reinserted even if the run to be removed is clean.
-	 */
-	if (chunk->ndirty != 0)
-		arena_chunk_dirty_remove(&arena->chunks_dirty, chunk);
+static size_t
+arena_chunk_dirty_npages(const extent_node_t *node)
+{
 
-	if (maybe_adjac_pred && arena_avail_adjac_pred(chunk, pageind))
-		chunk->nruns_adjac--;
-	if (maybe_adjac_succ && arena_avail_adjac_succ(chunk, pageind, npages))
-		chunk->nruns_adjac--;
-	chunk->nruns_avail--;
-	assert(chunk->nruns_avail > chunk->nruns_adjac || (chunk->nruns_avail
-	    == 0 && chunk->nruns_adjac == 0));
-
-	if (arena_mapbits_dirty_get(chunk, pageind) != 0) {
-		arena->ndirty -= npages;
-		chunk->ndirty -= npages;
+	return (extent_node_size_get(node) >> LG_PAGE);
+}
+
+void
+arena_chunk_cache_maybe_insert(arena_t *arena, extent_node_t *node, bool cache)
+{
+
+	if (cache) {
+		extent_node_dirty_linkage_init(node);
+		extent_node_dirty_insert(node, &arena->runs_dirty,
+		    &arena->chunks_cache);
+		arena->ndirty += arena_chunk_dirty_npages(node);
 	}
-	if (chunk->ndirty != 0)
-		arena_chunk_dirty_insert(&arena->chunks_dirty, chunk);
+}
 
-	arena_avail_tree_remove(&arena->runs_avail, arena_mapp_get(chunk,
-	    pageind));
+void
+arena_chunk_cache_maybe_remove(arena_t *arena, extent_node_t *node, bool dirty)
+{
+
+	if (dirty) {
+		extent_node_dirty_remove(node);
+		assert(arena->ndirty >= arena_chunk_dirty_npages(node));
+		arena->ndirty -= arena_chunk_dirty_npages(node);
+	}
 }
 
-static inline void *
+JEMALLOC_INLINE_C void *
 arena_run_reg_alloc(arena_run_t *run, arena_bin_info_t *bin_info)
 {
 	void *ret;
 	unsigned regind;
-	bitmap_t *bitmap = (bitmap_t *)((uintptr_t)run +
-	    (uintptr_t)bin_info->bitmap_offset);
+	arena_chunk_map_misc_t *miscelm;
+	void *rpages;
 
 	assert(run->nfree > 0);
-	assert(bitmap_full(bitmap, &bin_info->bitmap_info) == false);
+	assert(!bitmap_full(run->bitmap, &bin_info->bitmap_info));
 
-	regind = bitmap_sfu(bitmap, &bin_info->bitmap_info);
-	ret = (void *)((uintptr_t)run + (uintptr_t)bin_info->reg0_offset +
+	regind = bitmap_sfu(run->bitmap, &bin_info->bitmap_info);
+	miscelm = arena_run_to_miscelm(run);
+	rpages = arena_miscelm_to_rpages(miscelm);
+	ret = (void *)((uintptr_t)rpages + (uintptr_t)bin_info->reg0_offset +
 	    (uintptr_t)(bin_info->reg_interval * regind));
 	run->nfree--;
-	if (regind == run->nextind)
-		run->nextind++;
-	assert(regind < run->nextind);
 	return (ret);
 }
 
-static inline void
+JEMALLOC_INLINE_C void
 arena_run_reg_dalloc(arena_run_t *run, void *ptr)
 {
 	arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
 	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 	size_t mapbits = arena_mapbits_get(chunk, pageind);
-	size_t binind = arena_ptr_small_binind_get(ptr, mapbits);
+	szind_t binind = arena_ptr_small_binind_get(ptr, mapbits);
 	arena_bin_info_t *bin_info = &arena_bin_info[binind];
 	unsigned regind = arena_run_regind(run, bin_info, ptr);
-	bitmap_t *bitmap = (bitmap_t *)((uintptr_t)run +
-	    (uintptr_t)bin_info->bitmap_offset);
 
 	assert(run->nfree < bin_info->nregs);
 	/* Freeing an interior pointer can cause assertion failure. */
-	assert(((uintptr_t)ptr - ((uintptr_t)run +
+	assert(((uintptr_t)ptr -
+	    ((uintptr_t)arena_miscelm_to_rpages(arena_run_to_miscelm(run)) +
 	    (uintptr_t)bin_info->reg0_offset)) %
 	    (uintptr_t)bin_info->reg_interval == 0);
-	assert((uintptr_t)ptr >= (uintptr_t)run +
+	assert((uintptr_t)ptr >=
+	    (uintptr_t)arena_miscelm_to_rpages(arena_run_to_miscelm(run)) +
 	    (uintptr_t)bin_info->reg0_offset);
 	/* Freeing an unallocated pointer can cause assertion failure. */
-	assert(bitmap_get(bitmap, &bin_info->bitmap_info, regind));
+	assert(bitmap_get(run->bitmap, &bin_info->bitmap_info, regind));
 
-	bitmap_unset(bitmap, &bin_info->bitmap_info, regind);
+	bitmap_unset(run->bitmap, &bin_info->bitmap_info, regind);
 	run->nfree++;
 }
 
-static inline void
+JEMALLOC_INLINE_C void
 arena_run_zero(arena_chunk_t *chunk, size_t run_ind, size_t npages)
 {
 
-	VALGRIND_MAKE_MEM_UNDEFINED((void *)((uintptr_t)chunk + (run_ind <<
-	    LG_PAGE)), (npages << LG_PAGE));
+	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED((void *)((uintptr_t)chunk +
+	    (run_ind << LG_PAGE)), (npages << LG_PAGE));
 	memset((void *)((uintptr_t)chunk + (run_ind << LG_PAGE)), 0,
 	    (npages << LG_PAGE));
 }
 
-static inline void
+JEMALLOC_INLINE_C void
 arena_run_page_mark_zeroed(arena_chunk_t *chunk, size_t run_ind)
 {
 
-	VALGRIND_MAKE_MEM_DEFINED((void *)((uintptr_t)chunk + (run_ind <<
-	    LG_PAGE)), PAGE);
+	JEMALLOC_VALGRIND_MAKE_MEM_DEFINED((void *)((uintptr_t)chunk + (run_ind
+	    << LG_PAGE)), PAGE);
 }
 
-static inline void
+JEMALLOC_INLINE_C void
 arena_run_page_validate_zeroed(arena_chunk_t *chunk, size_t run_ind)
 {
 	size_t i;
 	UNUSED size_t *p = (size_t *)((uintptr_t)chunk + (run_ind << LG_PAGE));
 
 	arena_run_page_mark_zeroed(chunk, run_ind);
@@ -355,172 +365,186 @@
 
 static void
 arena_cactive_update(arena_t *arena, size_t add_pages, size_t sub_pages)
 {
 
 	if (config_stats) {
-		ssize_t cactive_diff = CHUNK_CEILING((arena->nactive +
-		    add_pages) << LG_PAGE) - CHUNK_CEILING((arena->nactive -
-		    sub_pages) << LG_PAGE);
+		ssize_t cactive_diff = CHUNK_CEILING((arena->nactive + add_pages
+		    - sub_pages) << LG_PAGE) - CHUNK_CEILING(arena->nactive <<
+		    LG_PAGE);
 		if (cactive_diff != 0)
 			stats_cactive_add(cactive_diff);
 	}
 }
 
 static void
 arena_run_split_remove(arena_t *arena, arena_chunk_t *chunk, size_t run_ind,
-    size_t flag_dirty, size_t need_pages)
+    size_t flag_dirty, size_t flag_decommitted, size_t need_pages)
 {
 	size_t total_pages, rem_pages;
 
+	assert(flag_dirty == 0 || flag_decommitted == 0);
+
 	total_pages = arena_mapbits_unallocated_size_get(chunk, run_ind) >>
 	    LG_PAGE;
 	assert(arena_mapbits_dirty_get(chunk, run_ind+total_pages-1) ==
 	    flag_dirty);
 	assert(need_pages <= total_pages);
 	rem_pages = total_pages - need_pages;
 
-	arena_avail_remove(arena, chunk, run_ind, total_pages, true, true);
+	arena_avail_remove(arena, chunk, run_ind, total_pages);
+	if (flag_dirty != 0)
+		arena_run_dirty_remove(arena, chunk, run_ind, total_pages);
 	arena_cactive_update(arena, need_pages, 0);
 	arena->nactive += need_pages;
 
 	/* Keep track of trailing unused pages for later use. */
 	if (rem_pages > 0) {
+		size_t flags = flag_dirty | flag_decommitted;
+		size_t flag_unzeroed_mask = (flags == 0) ?  CHUNK_MAP_UNZEROED :
+		    0;
+
+		arena_mapbits_unallocated_set(chunk, run_ind+need_pages,
+		    (rem_pages << LG_PAGE), flags |
+		    (arena_mapbits_unzeroed_get(chunk, run_ind+need_pages) &
+		    flag_unzeroed_mask));
+		arena_mapbits_unallocated_set(chunk, run_ind+total_pages-1,
+		    (rem_pages << LG_PAGE), flags |
+		    (arena_mapbits_unzeroed_get(chunk, run_ind+total_pages-1) &
+		    flag_unzeroed_mask));
 		if (flag_dirty != 0) {
-			arena_mapbits_unallocated_set(chunk,
-			    run_ind+need_pages, (rem_pages << LG_PAGE),
-			    flag_dirty);
-			arena_mapbits_unallocated_set(chunk,
-			    run_ind+total_pages-1, (rem_pages << LG_PAGE),
-			    flag_dirty);
-		} else {
-			arena_mapbits_unallocated_set(chunk, run_ind+need_pages,
-			    (rem_pages << LG_PAGE),
-			    arena_mapbits_unzeroed_get(chunk,
-			    run_ind+need_pages));
-			arena_mapbits_unallocated_set(chunk,
-			    run_ind+total_pages-1, (rem_pages << LG_PAGE),
-			    arena_mapbits_unzeroed_get(chunk,
-			    run_ind+total_pages-1));
+			arena_run_dirty_insert(arena, chunk, run_ind+need_pages,
+			    rem_pages);
 		}
-		arena_avail_insert(arena, chunk, run_ind+need_pages, rem_pages,
-		    false, true);
+		arena_avail_insert(arena, chunk, run_ind+need_pages, rem_pages);
 	}
 }
 
-static void
+static bool
 arena_run_split_large_helper(arena_t *arena, arena_run_t *run, size_t size,
     bool remove, bool zero)
 {
 	arena_chunk_t *chunk;
-	size_t flag_dirty, run_ind, need_pages, i;
+	arena_chunk_map_misc_t *miscelm;
+	size_t flag_dirty, flag_decommitted, run_ind, need_pages;
+	size_t flag_unzeroed_mask;
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
-	run_ind = (unsigned)(((uintptr_t)run - (uintptr_t)chunk) >> LG_PAGE);
+	miscelm = arena_run_to_miscelm(run);
+	run_ind = arena_miscelm_to_pageind(miscelm);
 	flag_dirty = arena_mapbits_dirty_get(chunk, run_ind);
+	flag_decommitted = arena_mapbits_decommitted_get(chunk, run_ind);
 	need_pages = (size >> LG_PAGE);
 	assert(need_pages > 0);
 
+	if (flag_decommitted != 0 && arena->chunk_hooks.commit(chunk, chunksize,
+	    run_ind << LG_PAGE, size, arena->ind))
+		return (true);
+
 	if (remove) {
 		arena_run_split_remove(arena, chunk, run_ind, flag_dirty,
-		    need_pages);
+		    flag_decommitted, need_pages);
 	}
 
 	if (zero) {
-		if (flag_dirty == 0) {
+		if (flag_decommitted != 0) {
+			/* The run is untouched, and therefore zeroed. */
+			JEMALLOC_VALGRIND_MAKE_MEM_DEFINED((void
+			    *)((uintptr_t)chunk + (run_ind << LG_PAGE)),
+			    (need_pages << LG_PAGE));
+		} else if (flag_dirty != 0) {
+			/* The run is dirty, so all pages must be zeroed. */
+			arena_run_zero(chunk, run_ind, need_pages);
+		} else {
 			/*
 			 * The run is clean, so some pages may be zeroed (i.e.
 			 * never before touched).
 			 */
+			size_t i;
 			for (i = 0; i < need_pages; i++) {
 				if (arena_mapbits_unzeroed_get(chunk, run_ind+i)
 				    != 0)
 					arena_run_zero(chunk, run_ind+i, 1);
 				else if (config_debug) {
 					arena_run_page_validate_zeroed(chunk,
 					    run_ind+i);
 				} else {
 					arena_run_page_mark_zeroed(chunk,
 					    run_ind+i);
 				}
 			}
-		} else {
-			/* The run is dirty, so all pages must be zeroed. */
-			arena_run_zero(chunk, run_ind, need_pages);
 		}
 	} else {
-		VALGRIND_MAKE_MEM_UNDEFINED((void *)((uintptr_t)chunk +
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED((void *)((uintptr_t)chunk +
 		    (run_ind << LG_PAGE)), (need_pages << LG_PAGE));
 	}
 
 	/*
 	 * Set the last element first, in case the run only contains one page
 	 * (i.e. both statements set the same element).
 	 */
-	arena_mapbits_large_set(chunk, run_ind+need_pages-1, 0, flag_dirty);
-	arena_mapbits_large_set(chunk, run_ind, size, flag_dirty);
+	flag_unzeroed_mask = (flag_dirty | flag_decommitted) == 0 ?
+	    CHUNK_MAP_UNZEROED : 0;
+	arena_mapbits_large_set(chunk, run_ind+need_pages-1, 0, flag_dirty |
+	    (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk,
+	    run_ind+need_pages-1)));
+	arena_mapbits_large_set(chunk, run_ind, size, flag_dirty |
+	    (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk, run_ind)));
+	return (false);
 }
 
-static void
+static bool
 arena_run_split_large(arena_t *arena, arena_run_t *run, size_t size, bool zero)
 {
 
-	arena_run_split_large_helper(arena, run, size, true, zero);
+	return (arena_run_split_large_helper(arena, run, size, true, zero));
 }
 
-static void
+static bool
 arena_run_init_large(arena_t *arena, arena_run_t *run, size_t size, bool zero)
 {
 
-	arena_run_split_large_helper(arena, run, size, false, zero);
+	return (arena_run_split_large_helper(arena, run, size, false, zero));
 }
 
-static void
+static bool
 arena_run_split_small(arena_t *arena, arena_run_t *run, size_t size,
-    size_t binind)
+    szind_t binind)
 {
 	arena_chunk_t *chunk;
-	size_t flag_dirty, run_ind, need_pages, i;
+	arena_chunk_map_misc_t *miscelm;
+	size_t flag_dirty, flag_decommitted, run_ind, need_pages, i;
 
 	assert(binind != BININD_INVALID);
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
-	run_ind = (unsigned)(((uintptr_t)run - (uintptr_t)chunk) >> LG_PAGE);
+	miscelm = arena_run_to_miscelm(run);
+	run_ind = arena_miscelm_to_pageind(miscelm);
 	flag_dirty = arena_mapbits_dirty_get(chunk, run_ind);
+	flag_decommitted = arena_mapbits_decommitted_get(chunk, run_ind);
 	need_pages = (size >> LG_PAGE);
 	assert(need_pages > 0);
 
-	arena_run_split_remove(arena, chunk, run_ind, flag_dirty, need_pages);
+	if (flag_decommitted != 0 && arena->chunk_hooks.commit(chunk, chunksize,
+	    run_ind << LG_PAGE, size, arena->ind))
+		return (true);
+
+	arena_run_split_remove(arena, chunk, run_ind, flag_dirty,
+	    flag_decommitted, need_pages);
 
-	/*
-	 * Propagate the dirty and unzeroed flags to the allocated small run,
-	 * so that arena_dalloc_bin_run() has the ability to conditionally trim
-	 * clean pages.
-	 */
-	arena_mapbits_small_set(chunk, run_ind, 0, binind, flag_dirty);
-	/*
-	 * The first page will always be dirtied during small run
-	 * initialization, so a validation failure here would not actually
-	 * cause an observable failure.
-	 */
-	if (config_debug && flag_dirty == 0 && arena_mapbits_unzeroed_get(chunk,
-	    run_ind) == 0)
-		arena_run_page_validate_zeroed(chunk, run_ind);
-	for (i = 1; i < need_pages - 1; i++) {
-		arena_mapbits_small_set(chunk, run_ind+i, i, binind, 0);
-		if (config_debug && flag_dirty == 0 &&
-		    arena_mapbits_unzeroed_get(chunk, run_ind+i) == 0)
+	for (i = 0; i < need_pages; i++) {
+		size_t flag_unzeroed = arena_mapbits_unzeroed_get(chunk,
+		    run_ind+i);
+		arena_mapbits_small_set(chunk, run_ind+i, i, binind,
+		    flag_unzeroed);
+		if (config_debug && flag_dirty == 0 && flag_unzeroed == 0)
 			arena_run_page_validate_zeroed(chunk, run_ind+i);
 	}
-	arena_mapbits_small_set(chunk, run_ind+need_pages-1, need_pages-1,
-	    binind, flag_dirty);
-	if (config_debug && flag_dirty == 0 && arena_mapbits_unzeroed_get(chunk,
-	    run_ind+need_pages-1) == 0)
-		arena_run_page_validate_zeroed(chunk, run_ind+need_pages-1);
-	VALGRIND_MAKE_MEM_UNDEFINED((void *)((uintptr_t)chunk +
+	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED((void *)((uintptr_t)chunk +
 	    (run_ind << LG_PAGE)), (need_pages << LG_PAGE));
+	return (false);
 }
 
 static arena_chunk_t *
 arena_chunk_init_spare(arena_t *arena)
 {
 	arena_chunk_t *chunk;
@@ -530,82 +554,149 @@
 	chunk = arena->spare;
 	arena->spare = NULL;
 
 	assert(arena_mapbits_allocated_get(chunk, map_bias) == 0);
 	assert(arena_mapbits_allocated_get(chunk, chunk_npages-1) == 0);
 	assert(arena_mapbits_unallocated_size_get(chunk, map_bias) ==
-	    arena_maxclass);
+	    arena_maxrun);
 	assert(arena_mapbits_unallocated_size_get(chunk, chunk_npages-1) ==
-	    arena_maxclass);
+	    arena_maxrun);
 	assert(arena_mapbits_dirty_get(chunk, map_bias) ==
 	    arena_mapbits_dirty_get(chunk, chunk_npages-1));
 
 	return (chunk);
 }
 
+static bool
+arena_chunk_register(arena_t *arena, arena_chunk_t *chunk, bool zero)
+{
+
+	/*
+	 * The extent node notion of "committed" doesn't directly apply to
+	 * arena chunks.  Arbitrarily mark them as committed.  The commit state
+	 * of runs is tracked individually, and upon chunk deallocation the
+	 * entire chunk is in a consistent commit state.
+	 */
+	extent_node_init(&chunk->node, arena, chunk, chunksize, zero, true);
+	extent_node_achunk_set(&chunk->node, true);
+	return (chunk_register(chunk, &chunk->node));
+}
+
 static arena_chunk_t *
-arena_chunk_init_hard(arena_t *arena)
+arena_chunk_alloc_internal_hard(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    bool *zero, bool *commit)
 {
 	arena_chunk_t *chunk;
-	bool zero;
-	size_t unzeroed, i;
 
-	assert(arena->spare == NULL);
-
-	zero = false;
 	malloc_mutex_unlock(&arena->lock);
-	chunk = (arena_chunk_t *)chunk_alloc(chunksize, chunksize, false,
-	    &zero, arena->dss_prec);
+
+	chunk = (arena_chunk_t *)chunk_alloc_wrapper(arena, chunk_hooks, NULL,
+	    chunksize, chunksize, zero, commit);
+	if (chunk != NULL && !*commit) {
+		/* Commit header. */
+		if (chunk_hooks->commit(chunk, chunksize, 0, map_bias <<
+		    LG_PAGE, arena->ind)) {
+			chunk_dalloc_wrapper(arena, chunk_hooks,
+			    (void *)chunk, chunksize, *commit);
+			chunk = NULL;
+		}
+	}
+	if (chunk != NULL && arena_chunk_register(arena, chunk, *zero)) {
+		if (!*commit) {
+			/* Undo commit of header. */
+			chunk_hooks->decommit(chunk, chunksize, 0, map_bias <<
+			    LG_PAGE, arena->ind);
+		}
+		chunk_dalloc_wrapper(arena, chunk_hooks, (void *)chunk,
+		    chunksize, *commit);
+		chunk = NULL;
+	}
+
 	malloc_mutex_lock(&arena->lock);
-	if (chunk == NULL)
-		return (NULL);
-	if (config_stats)
+	return (chunk);
+}
+
+static arena_chunk_t *
+arena_chunk_alloc_internal(arena_t *arena, bool *zero, bool *commit)
+{
+	arena_chunk_t *chunk;
+	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
+
+	chunk = chunk_alloc_cache(arena, &chunk_hooks, NULL, chunksize,
+	    chunksize, zero, true);
+	if (chunk != NULL) {
+		if (arena_chunk_register(arena, chunk, *zero)) {
+			chunk_dalloc_cache(arena, &chunk_hooks, chunk,
+			    chunksize, true);
+			return (NULL);
+		}
+		*commit = true;
+	}
+	if (chunk == NULL) {
+		chunk = arena_chunk_alloc_internal_hard(arena, &chunk_hooks,
+		    zero, commit);
+	}
+
+	if (config_stats && chunk != NULL) {
 		arena->stats.mapped += chunksize;
+		arena->stats.metadata_mapped += (map_bias << LG_PAGE);
+	}
 
-	chunk->arena = arena;
+	return (chunk);
+}
 
-	/*
-	 * Claim that no pages are in use, since the header is merely overhead.
-	 */
-	chunk->ndirty = 0;
+static arena_chunk_t *
+arena_chunk_init_hard(arena_t *arena)
+{
+	arena_chunk_t *chunk;
+	bool zero, commit;
+	size_t flag_unzeroed, flag_decommitted, i;
 
-	chunk->nruns_avail = 0;
-	chunk->nruns_adjac = 0;
+	assert(arena->spare == NULL);
+
+	zero = false;
+	commit = false;
+	chunk = arena_chunk_alloc_internal(arena, &zero, &commit);
+	if (chunk == NULL)
+		return (NULL);
 
 	/*
 	 * Initialize the map to contain one maximal free untouched run.  Mark
-	 * the pages as zeroed iff chunk_alloc() returned a zeroed chunk.
+	 * the pages as zeroed if chunk_alloc() returned a zeroed or decommitted
+	 * chunk.
 	 */
-	unzeroed = zero ? 0 : CHUNK_MAP_UNZEROED;
-	arena_mapbits_unallocated_set(chunk, map_bias, arena_maxclass,
-	    unzeroed);
+	flag_unzeroed = (zero || !commit) ? 0 : CHUNK_MAP_UNZEROED;
+	flag_decommitted = commit ? 0 : CHUNK_MAP_DECOMMITTED;
+	arena_mapbits_unallocated_set(chunk, map_bias, arena_maxrun,
+	    flag_unzeroed | flag_decommitted);
 	/*
 	 * There is no need to initialize the internal page map entries unless
 	 * the chunk is not zeroed.
 	 */
-	if (zero == false) {
-		VALGRIND_MAKE_MEM_UNDEFINED((void *)arena_mapp_get(chunk,
-		    map_bias+1), (size_t)((uintptr_t) arena_mapp_get(chunk,
-		    chunk_npages-1) - (uintptr_t)arena_mapp_get(chunk,
+	if (!zero) {
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(
+		    (void *)arena_bitselm_get(chunk, map_bias+1),
+		    (size_t)((uintptr_t) arena_bitselm_get(chunk,
+		    chunk_npages-1) - (uintptr_t)arena_bitselm_get(chunk,
 		    map_bias+1)));
 		for (i = map_bias+1; i < chunk_npages-1; i++)
-			arena_mapbits_unzeroed_set(chunk, i, unzeroed);
+			arena_mapbits_internal_set(chunk, i, flag_unzeroed);
 	} else {
-		VALGRIND_MAKE_MEM_DEFINED((void *)arena_mapp_get(chunk,
-		    map_bias+1), (size_t)((uintptr_t) arena_mapp_get(chunk,
-		    chunk_npages-1) - (uintptr_t)arena_mapp_get(chunk,
-		    map_bias+1)));
+		JEMALLOC_VALGRIND_MAKE_MEM_DEFINED((void
+		    *)arena_bitselm_get(chunk, map_bias+1), (size_t)((uintptr_t)
+		    arena_bitselm_get(chunk, chunk_npages-1) -
+		    (uintptr_t)arena_bitselm_get(chunk, map_bias+1)));
 		if (config_debug) {
 			for (i = map_bias+1; i < chunk_npages-1; i++) {
 				assert(arena_mapbits_unzeroed_get(chunk, i) ==
-				    unzeroed);
+				    flag_unzeroed);
 			}
 		}
 	}
-	arena_mapbits_unallocated_set(chunk, chunk_npages-1, arena_maxclass,
-	    unzeroed);
+	arena_mapbits_unallocated_set(chunk, chunk_npages-1, arena_maxrun,
+	    flag_unzeroed);
 
 	return (chunk);
 }
 
 static arena_chunk_t *
 arena_chunk_alloc(arena_t *arena)
@@ -618,468 +709,836 @@
 		chunk = arena_chunk_init_hard(arena);
 		if (chunk == NULL)
 			return (NULL);
 	}
 
 	/* Insert the run into the runs_avail tree. */
-	arena_avail_insert(arena, chunk, map_bias, chunk_npages-map_bias,
-	    false, false);
+	arena_avail_insert(arena, chunk, map_bias, chunk_npages-map_bias);
 
 	return (chunk);
 }
 
 static void
-arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk)
+arena_chunk_dalloc(arena_t *arena, arena_chunk_t *chunk)
 {
+
 	assert(arena_mapbits_allocated_get(chunk, map_bias) == 0);
 	assert(arena_mapbits_allocated_get(chunk, chunk_npages-1) == 0);
 	assert(arena_mapbits_unallocated_size_get(chunk, map_bias) ==
-	    arena_maxclass);
+	    arena_maxrun);
 	assert(arena_mapbits_unallocated_size_get(chunk, chunk_npages-1) ==
-	    arena_maxclass);
+	    arena_maxrun);
 	assert(arena_mapbits_dirty_get(chunk, map_bias) ==
 	    arena_mapbits_dirty_get(chunk, chunk_npages-1));
+	assert(arena_mapbits_decommitted_get(chunk, map_bias) ==
+	    arena_mapbits_decommitted_get(chunk, chunk_npages-1));
 
 	/*
 	 * Remove run from the runs_avail tree, so that the arena does not use
 	 * it.
 	 */
-	arena_avail_remove(arena, chunk, map_bias, chunk_npages-map_bias,
-	    false, false);
+	arena_avail_remove(arena, chunk, map_bias, chunk_npages-map_bias);
 
 	if (arena->spare != NULL) {
 		arena_chunk_t *spare = arena->spare;
+		chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
+		bool committed;
 
 		arena->spare = chunk;
-		malloc_mutex_unlock(&arena->lock);
-		chunk_dealloc((void *)spare, chunksize, true);
-		malloc_mutex_lock(&arena->lock);
-		if (config_stats)
+		if (arena_mapbits_dirty_get(spare, map_bias) != 0) {
+			arena_run_dirty_remove(arena, spare, map_bias,
+			    chunk_npages-map_bias);
+		}
+
+		chunk_deregister(spare, &spare->node);
+
+		committed = (arena_mapbits_decommitted_get(spare, map_bias) ==
+		    0);
+		if (!committed) {
+			/*
+			 * Decommit the header.  Mark the chunk as decommitted
+			 * even if header decommit fails, since treating a
+			 * partially committed chunk as committed has a high
+			 * potential for causing later access of decommitted
+			 * memory.
+			 */
+			chunk_hooks = chunk_hooks_get(arena);
+			chunk_hooks.decommit(spare, chunksize, 0, map_bias <<
+			    LG_PAGE, arena->ind);
+		}
+
+		chunk_dalloc_cache(arena, &chunk_hooks, (void *)spare,
+		    chunksize, committed);
+
+		if (config_stats) {
 			arena->stats.mapped -= chunksize;
+			arena->stats.metadata_mapped -= (map_bias << LG_PAGE);
+		}
 	} else
 		arena->spare = chunk;
 }
 
-static arena_run_t *
-arena_run_alloc_large_helper(arena_t *arena, size_t size, bool zero)
+static void
+arena_huge_malloc_stats_update(arena_t *arena, size_t usize)
 {
-	arena_run_t *run;
-	arena_chunk_map_t *mapelm, key;
+	szind_t index = size2index(usize) - nlclasses - NBINS;
 
-	key.bits = size | CHUNK_MAP_KEY;
-	mapelm = arena_avail_tree_nsearch(&arena->runs_avail, &key);
-	if (mapelm != NULL) {
-		arena_chunk_t *run_chunk = CHUNK_ADDR2BASE(mapelm);
-		size_t pageind = (((uintptr_t)mapelm -
-		    (uintptr_t)run_chunk->map) / sizeof(arena_chunk_map_t))
-		    + map_bias;
+	cassert(config_stats);
 
-		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
-		    LG_PAGE));
-		arena_run_split_large(arena, run, size, zero);
-		return (run);
+	arena->stats.nmalloc_huge++;
+	arena->stats.allocated_huge += usize;
+	arena->stats.hstats[index].nmalloc++;
+	arena->stats.hstats[index].curhchunks++;
+}
+
+static void
+arena_huge_malloc_stats_update_undo(arena_t *arena, size_t usize)
+{
+	szind_t index = size2index(usize) - nlclasses - NBINS;
+
+	cassert(config_stats);
+
+	arena->stats.nmalloc_huge--;
+	arena->stats.allocated_huge -= usize;
+	arena->stats.hstats[index].nmalloc--;
+	arena->stats.hstats[index].curhchunks--;
+}
+
+static void
+arena_huge_dalloc_stats_update(arena_t *arena, size_t usize)
+{
+	szind_t index = size2index(usize) - nlclasses - NBINS;
+
+	cassert(config_stats);
+
+	arena->stats.ndalloc_huge++;
+	arena->stats.allocated_huge -= usize;
+	arena->stats.hstats[index].ndalloc++;
+	arena->stats.hstats[index].curhchunks--;
+}
+
+static void
+arena_huge_dalloc_stats_update_undo(arena_t *arena, size_t usize)
+{
+	szind_t index = size2index(usize) - nlclasses - NBINS;
+
+	cassert(config_stats);
+
+	arena->stats.ndalloc_huge--;
+	arena->stats.allocated_huge += usize;
+	arena->stats.hstats[index].ndalloc--;
+	arena->stats.hstats[index].curhchunks++;
+}
+
+static void
+arena_huge_ralloc_stats_update(arena_t *arena, size_t oldsize, size_t usize)
+{
+
+	arena_huge_dalloc_stats_update(arena, oldsize);
+	arena_huge_malloc_stats_update(arena, usize);
+}
+
+static void
+arena_huge_ralloc_stats_update_undo(arena_t *arena, size_t oldsize,
+    size_t usize)
+{
+
+	arena_huge_dalloc_stats_update_undo(arena, oldsize);
+	arena_huge_malloc_stats_update_undo(arena, usize);
+}
+
+extent_node_t *
+arena_node_alloc(arena_t *arena)
+{
+	extent_node_t *node;
+
+	malloc_mutex_lock(&arena->node_cache_mtx);
+	node = ql_last(&arena->node_cache, ql_link);
+	if (node == NULL) {
+		malloc_mutex_unlock(&arena->node_cache_mtx);
+		return (base_alloc(sizeof(extent_node_t)));
 	}
+	ql_tail_remove(&arena->node_cache, extent_node_t, ql_link);
+	malloc_mutex_unlock(&arena->node_cache_mtx);
+	return (node);
+}
 
-	return (NULL);
+void
+arena_node_dalloc(arena_t *arena, extent_node_t *node)
+{
+
+	malloc_mutex_lock(&arena->node_cache_mtx);
+	ql_elm_new(node, ql_link);
+	ql_tail_insert(&arena->node_cache, node, ql_link);
+	malloc_mutex_unlock(&arena->node_cache_mtx);
+}
+
+static void *
+arena_chunk_alloc_huge_hard(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    size_t usize, size_t alignment, bool *zero, size_t csize)
+{
+	void *ret;
+	bool commit = true;
+
+	ret = chunk_alloc_wrapper(arena, chunk_hooks, NULL, csize, alignment,
+	    zero, &commit);
+	if (ret == NULL) {
+		/* Revert optimistic stats updates. */
+		malloc_mutex_lock(&arena->lock);
+		if (config_stats) {
+			arena_huge_malloc_stats_update_undo(arena, usize);
+			arena->stats.mapped -= usize;
+		}
+		arena->nactive -= (usize >> LG_PAGE);
+		malloc_mutex_unlock(&arena->lock);
+	}
+
+	return (ret);
+}
+
+void *
+arena_chunk_alloc_huge(arena_t *arena, size_t usize, size_t alignment,
+    bool *zero)
+{
+	void *ret;
+	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
+	size_t csize = CHUNK_CEILING(usize);
+
+	malloc_mutex_lock(&arena->lock);
+
+	/* Optimistically update stats. */
+	if (config_stats) {
+		arena_huge_malloc_stats_update(arena, usize);
+		arena->stats.mapped += usize;
+	}
+	arena->nactive += (usize >> LG_PAGE);
+
+	ret = chunk_alloc_cache(arena, &chunk_hooks, NULL, csize, alignment,
+	    zero, true);
+	malloc_mutex_unlock(&arena->lock);
+	if (ret == NULL) {
+		ret = arena_chunk_alloc_huge_hard(arena, &chunk_hooks, usize,
+		    alignment, zero, csize);
+	}
+
+	if (config_stats && ret != NULL)
+		stats_cactive_add(usize);
+	return (ret);
+}
+
+void
+arena_chunk_dalloc_huge(arena_t *arena, void *chunk, size_t usize)
+{
+	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
+	size_t csize;
+
+	csize = CHUNK_CEILING(usize);
+	malloc_mutex_lock(&arena->lock);
+	if (config_stats) {
+		arena_huge_dalloc_stats_update(arena, usize);
+		arena->stats.mapped -= usize;
+		stats_cactive_sub(usize);
+	}
+	arena->nactive -= (usize >> LG_PAGE);
+
+	chunk_dalloc_cache(arena, &chunk_hooks, chunk, csize, true);
+	malloc_mutex_unlock(&arena->lock);
+}
+
+void
+arena_chunk_ralloc_huge_similar(arena_t *arena, void *chunk, size_t oldsize,
+    size_t usize)
+{
+
+	assert(CHUNK_CEILING(oldsize) == CHUNK_CEILING(usize));
+	assert(oldsize != usize);
+
+	malloc_mutex_lock(&arena->lock);
+	if (config_stats)
+		arena_huge_ralloc_stats_update(arena, oldsize, usize);
+	if (oldsize < usize) {
+		size_t udiff = usize - oldsize;
+		arena->nactive += udiff >> LG_PAGE;
+		if (config_stats)
+			stats_cactive_add(udiff);
+	} else {
+		size_t udiff = oldsize - usize;
+		arena->nactive -= udiff >> LG_PAGE;
+		if (config_stats)
+			stats_cactive_sub(udiff);
+	}
+	malloc_mutex_unlock(&arena->lock);
+}
+
+void
+arena_chunk_ralloc_huge_shrink(arena_t *arena, void *chunk, size_t oldsize,
+    size_t usize)
+{
+	size_t udiff = oldsize - usize;
+	size_t cdiff = CHUNK_CEILING(oldsize) - CHUNK_CEILING(usize);
+
+	malloc_mutex_lock(&arena->lock);
+	if (config_stats) {
+		arena_huge_ralloc_stats_update(arena, oldsize, usize);
+		if (cdiff != 0) {
+			arena->stats.mapped -= cdiff;
+			stats_cactive_sub(udiff);
+		}
+	}
+	arena->nactive -= udiff >> LG_PAGE;
+
+	if (cdiff != 0) {
+		chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
+		void *nchunk = (void *)((uintptr_t)chunk +
+		    CHUNK_CEILING(usize));
+
+		chunk_dalloc_cache(arena, &chunk_hooks, nchunk, cdiff, true);
+	}
+	malloc_mutex_unlock(&arena->lock);
+}
+
+static bool
+arena_chunk_ralloc_huge_expand_hard(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *chunk, size_t oldsize, size_t usize, bool *zero, void *nchunk,
+    size_t udiff, size_t cdiff)
+{
+	bool err;
+	bool commit = true;
+
+	err = (chunk_alloc_wrapper(arena, chunk_hooks, nchunk, cdiff, chunksize,
+	    zero, &commit) == NULL);
+	if (err) {
+		/* Revert optimistic stats updates. */
+		malloc_mutex_lock(&arena->lock);
+		if (config_stats) {
+			arena_huge_ralloc_stats_update_undo(arena, oldsize,
+			    usize);
+			arena->stats.mapped -= cdiff;
+		}
+		arena->nactive -= (udiff >> LG_PAGE);
+		malloc_mutex_unlock(&arena->lock);
+	} else if (chunk_hooks->merge(chunk, CHUNK_CEILING(oldsize), nchunk,
+	    cdiff, true, arena->ind)) {
+		chunk_dalloc_arena(arena, chunk_hooks, nchunk, cdiff, *zero,
+		    true);
+		err = true;
+	}
+	return (err);
+}
+
+bool
+arena_chunk_ralloc_huge_expand(arena_t *arena, void *chunk, size_t oldsize,
+    size_t usize, bool *zero)
+{
+	bool err;
+	chunk_hooks_t chunk_hooks = chunk_hooks_get(arena);
+	void *nchunk = (void *)((uintptr_t)chunk + CHUNK_CEILING(oldsize));
+	size_t udiff = usize - oldsize;
+	size_t cdiff = CHUNK_CEILING(usize) - CHUNK_CEILING(oldsize);
+
+	malloc_mutex_lock(&arena->lock);
+
+	/* Optimistically update stats. */
+	if (config_stats) {
+		arena_huge_ralloc_stats_update(arena, oldsize, usize);
+		arena->stats.mapped += cdiff;
+	}
+	arena->nactive += (udiff >> LG_PAGE);
+
+	err = (chunk_alloc_cache(arena, &arena->chunk_hooks, nchunk, cdiff,
+	    chunksize, zero, true) == NULL);
+	malloc_mutex_unlock(&arena->lock);
+	if (err) {
+		err = arena_chunk_ralloc_huge_expand_hard(arena, &chunk_hooks,
+		    chunk, oldsize, usize, zero, nchunk, udiff,
+		    cdiff);
+	} else if (chunk_hooks.merge(chunk, CHUNK_CEILING(oldsize), nchunk,
+	    cdiff, true, arena->ind)) {
+		chunk_dalloc_arena(arena, &chunk_hooks, nchunk, cdiff, *zero,
+		    true);
+		err = true;
+	}
+
+	if (config_stats && !err)
+		stats_cactive_add(udiff);
+	return (err);
+}
+
+/*
+ * Do first-best-fit run selection, i.e. select the lowest run that best fits.
+ * Run sizes are quantized, so not all candidate runs are necessarily exactly
+ * the same size.
+ */
+static arena_run_t *
+arena_run_first_best_fit(arena_t *arena, size_t size)
+{
+	size_t search_size = run_quantize_first(size);
+	arena_chunk_map_misc_t *key = arena_miscelm_key_create(search_size);
+	arena_chunk_map_misc_t *miscelm =
+	    arena_avail_tree_nsearch(&arena->runs_avail, key);
+	if (miscelm == NULL)
+		return (NULL);
+	return (&miscelm->run);
+}
+
+static arena_run_t *
+arena_run_alloc_large_helper(arena_t *arena, size_t size, bool zero)
+{
+	arena_run_t *run = arena_run_first_best_fit(arena, s2u(size));
+	if (run != NULL) {
+		if (arena_run_split_large(arena, run, size, zero))
+			run = NULL;
+	}
+	return (run);
 }
 
 static arena_run_t *
 arena_run_alloc_large(arena_t *arena, size_t size, bool zero)
 {
 	arena_chunk_t *chunk;
 	arena_run_t *run;
 
-	assert(size <= arena_maxclass);
-	assert((size & PAGE_MASK) == 0);
+	assert(size <= arena_maxrun);
+	assert(size == PAGE_CEILING(size));
 
 	/* Search the arena's chunks for the lowest best fit. */
 	run = arena_run_alloc_large_helper(arena, size, zero);
 	if (run != NULL)
 		return (run);
 
 	/*
 	 * No usable runs.  Create a new chunk from which to allocate the run.
 	 */
 	chunk = arena_chunk_alloc(arena);
 	if (chunk != NULL) {
-		run = (arena_run_t *)((uintptr_t)chunk + (map_bias << LG_PAGE));
-		arena_run_split_large(arena, run, size, zero);
+		run = &arena_miscelm_get(chunk, map_bias)->run;
+		if (arena_run_split_large(arena, run, size, zero))
+			run = NULL;
 		return (run);
 	}
 
 	/*
 	 * arena_chunk_alloc() failed, but another thread may have made
 	 * sufficient memory available while this one dropped arena->lock in
 	 * arena_chunk_alloc(), so search one more time.
 	 */
 	return (arena_run_alloc_large_helper(arena, size, zero));
 }
 
 static arena_run_t *
-arena_run_alloc_small_helper(arena_t *arena, size_t size, size_t binind)
+arena_run_alloc_small_helper(arena_t *arena, size_t size, szind_t binind)
 {
-	arena_run_t *run;
-	arena_chunk_map_t *mapelm, key;
-
-	key.bits = size | CHUNK_MAP_KEY;
-	mapelm = arena_avail_tree_nsearch(&arena->runs_avail, &key);
-	if (mapelm != NULL) {
-		arena_chunk_t *run_chunk = CHUNK_ADDR2BASE(mapelm);
-		size_t pageind = (((uintptr_t)mapelm -
-		    (uintptr_t)run_chunk->map) / sizeof(arena_chunk_map_t))
-		    + map_bias;
-
-		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
-		    LG_PAGE));
-		arena_run_split_small(arena, run, size, binind);
-		return (run);
+	arena_run_t *run = arena_run_first_best_fit(arena, size);
+	if (run != NULL) {
+		if (arena_run_split_small(arena, run, size, binind))
+			run = NULL;
 	}
-
-	return (NULL);
+	return (run);
 }
 
 static arena_run_t *
-arena_run_alloc_small(arena_t *arena, size_t size, size_t binind)
+arena_run_alloc_small(arena_t *arena, size_t size, szind_t binind)
 {
 	arena_chunk_t *chunk;
 	arena_run_t *run;
 
-	assert(size <= arena_maxclass);
-	assert((size & PAGE_MASK) == 0);
+	assert(size <= arena_maxrun);
+	assert(size == PAGE_CEILING(size));
 	assert(binind != BININD_INVALID);
 
 	/* Search the arena's chunks for the lowest best fit. */
 	run = arena_run_alloc_small_helper(arena, size, binind);
 	if (run != NULL)
 		return (run);
 
 	/*
 	 * No usable runs.  Create a new chunk from which to allocate the run.
 	 */
 	chunk = arena_chunk_alloc(arena);
 	if (chunk != NULL) {
-		run = (arena_run_t *)((uintptr_t)chunk + (map_bias << LG_PAGE));
-		arena_run_split_small(arena, run, size, binind);
+		run = &arena_miscelm_get(chunk, map_bias)->run;
+		if (arena_run_split_small(arena, run, size, binind))
+			run = NULL;
 		return (run);
 	}
 
 	/*
 	 * arena_chunk_alloc() failed, but another thread may have made
 	 * sufficient memory available while this one dropped arena->lock in
 	 * arena_chunk_alloc(), so search one more time.
 	 */
 	return (arena_run_alloc_small_helper(arena, size, binind));
 }
 
-static inline void
+static bool
+arena_lg_dirty_mult_valid(ssize_t lg_dirty_mult)
+{
+
+	return (lg_dirty_mult >= -1 && lg_dirty_mult < (ssize_t)(sizeof(size_t)
+	    << 3));
+}
+
+ssize_t
+arena_lg_dirty_mult_get(arena_t *arena)
+{
+	ssize_t lg_dirty_mult;
+
+	malloc_mutex_lock(&arena->lock);
+	lg_dirty_mult = arena->lg_dirty_mult;
+	malloc_mutex_unlock(&arena->lock);
+
+	return (lg_dirty_mult);
+}
+
+bool
+arena_lg_dirty_mult_set(arena_t *arena, ssize_t lg_dirty_mult)
+{
+
+	if (!arena_lg_dirty_mult_valid(lg_dirty_mult))
+		return (true);
+
+	malloc_mutex_lock(&arena->lock);
+	arena->lg_dirty_mult = lg_dirty_mult;
+	arena_maybe_purge(arena);
+	malloc_mutex_unlock(&arena->lock);
+
+	return (false);
+}
+
+void
 arena_maybe_purge(arena_t *arena)
 {
-	size_t npurgeable, threshold;
 
 	/* Don't purge if the option is disabled. */
-	if (opt_lg_dirty_mult < 0)
+	if (arena->lg_dirty_mult < 0)
 		return;
-	/* Don't purge if all dirty pages are already being purged. */
-	if (arena->ndirty <= arena->npurgatory)
+	/* Don't recursively purge. */
+	if (arena->purging)
 		return;
-	npurgeable = arena->ndirty - arena->npurgatory;
-	threshold = (arena->nactive >> opt_lg_dirty_mult);
 	/*
-	 * Don't purge unless the number of purgeable pages exceeds the
-	 * threshold.
+	 * Iterate, since preventing recursive purging could otherwise leave too
+	 * many dirty pages.
 	 */
-	if (npurgeable <= threshold)
-		return;
-
-	arena_purge(arena, false);
+	while (true) {
+		size_t threshold = (arena->nactive >> arena->lg_dirty_mult);
+		if (threshold < chunk_npages)
+			threshold = chunk_npages;
+		/*
+		 * Don't purge unless the number of purgeable pages exceeds the
+		 * threshold.
+		 */
+		if (arena->ndirty <= threshold)
+			return;
+		arena_purge(arena, false);
+	}
 }
 
-static arena_chunk_t *
-chunks_dirty_iter_cb(arena_chunk_tree_t *tree, arena_chunk_t *chunk, void *arg)
+static size_t
+arena_dirty_count(arena_t *arena)
 {
-       size_t *ndirty = (size_t *)arg;
+	size_t ndirty = 0;
+	arena_runs_dirty_link_t *rdelm;
+	extent_node_t *chunkselm;
+
+	for (rdelm = qr_next(&arena->runs_dirty, rd_link),
+	    chunkselm = qr_next(&arena->chunks_cache, cc_link);
+	    rdelm != &arena->runs_dirty; rdelm = qr_next(rdelm, rd_link)) {
+		size_t npages;
+
+		if (rdelm == &chunkselm->rd) {
+			npages = extent_node_size_get(chunkselm) >> LG_PAGE;
+			chunkselm = qr_next(chunkselm, cc_link);
+		} else {
+			arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(
+			    rdelm);
+			arena_chunk_map_misc_t *miscelm =
+			    arena_rd_to_miscelm(rdelm);
+			size_t pageind = arena_miscelm_to_pageind(miscelm);
+			assert(arena_mapbits_allocated_get(chunk, pageind) ==
+			    0);
+			assert(arena_mapbits_large_get(chunk, pageind) == 0);
+			assert(arena_mapbits_dirty_get(chunk, pageind) != 0);
+			npages = arena_mapbits_unallocated_size_get(chunk,
+			    pageind) >> LG_PAGE;
+		}
+		ndirty += npages;
+	}
 
-       assert(chunk->ndirty != 0);
-       *ndirty += chunk->ndirty;
-       return (NULL);
+	return (ndirty);
 }
 
 static size_t
-arena_compute_npurgatory(arena_t *arena, bool all)
+arena_compute_npurge(arena_t *arena, bool all)
 {
-	size_t npurgatory, npurgeable;
+	size_t npurge;
 
 	/*
 	 * Compute the minimum number of pages that this thread should try to
 	 * purge.
 	 */
-	npurgeable = arena->ndirty - arena->npurgatory;
-
-	if (all == false) {
-		size_t threshold = (arena->nactive >> opt_lg_dirty_mult);
+	if (!all) {
+		size_t threshold = (arena->nactive >> arena->lg_dirty_mult);
+		threshold = threshold < chunk_npages ? chunk_npages : threshold;
 
-		npurgatory = npurgeable - threshold;
+		npurge = arena->ndirty - threshold;
 	} else
-		npurgatory = npurgeable;
+		npurge = arena->ndirty;
 
-	return (npurgatory);
+	return (npurge);
 }
 
-static void
-arena_chunk_stash_dirty(arena_t *arena, arena_chunk_t *chunk, bool all,
-    arena_chunk_mapelms_t *mapelms)
-{
-	size_t pageind, npages;
+static size_t
+arena_stash_dirty(arena_t *arena, chunk_hooks_t *chunk_hooks, bool all,
+    size_t npurge, arena_runs_dirty_link_t *purge_runs_sentinel,
+    extent_node_t *purge_chunks_sentinel)
+{
+	arena_runs_dirty_link_t *rdelm, *rdelm_next;
+	extent_node_t *chunkselm;
+	size_t nstashed = 0;
+
+	/* Stash at least npurge pages. */
+	for (rdelm = qr_next(&arena->runs_dirty, rd_link),
+	    chunkselm = qr_next(&arena->chunks_cache, cc_link);
+	    rdelm != &arena->runs_dirty; rdelm = rdelm_next) {
+		size_t npages;
+		rdelm_next = qr_next(rdelm, rd_link);
+
+		if (rdelm == &chunkselm->rd) {
+			extent_node_t *chunkselm_next;
+			bool zero;
+			UNUSED void *chunk;
 
-	/*
-	 * Temporarily allocate free dirty runs within chunk.  If all is false,
-	 * only operate on dirty runs that are fragments; otherwise operate on
-	 * all dirty runs.
-	 */
-	for (pageind = map_bias; pageind < chunk_npages; pageind += npages) {
-		arena_chunk_map_t *mapelm = arena_mapp_get(chunk, pageind);
-		if (arena_mapbits_allocated_get(chunk, pageind) == 0) {
+			chunkselm_next = qr_next(chunkselm, cc_link);
+			/*
+			 * Allocate.  chunkselm remains valid due to the
+			 * dalloc_node=false argument to chunk_alloc_cache().
+			 */
+			zero = false;
+			chunk = chunk_alloc_cache(arena, chunk_hooks,
+			    extent_node_addr_get(chunkselm),
+			    extent_node_size_get(chunkselm), chunksize, &zero,
+			    false);
+			assert(chunk == extent_node_addr_get(chunkselm));
+			assert(zero == extent_node_zeroed_get(chunkselm));
+			extent_node_dirty_insert(chunkselm, purge_runs_sentinel,
+			    purge_chunks_sentinel);
+			npages = extent_node_size_get(chunkselm) >> LG_PAGE;
+			chunkselm = chunkselm_next;
+		} else {
+			arena_chunk_t *chunk =
+			    (arena_chunk_t *)CHUNK_ADDR2BASE(rdelm);
+			arena_chunk_map_misc_t *miscelm =
+			    arena_rd_to_miscelm(rdelm);
+			size_t pageind = arena_miscelm_to_pageind(miscelm);
+			arena_run_t *run = &miscelm->run;
 			size_t run_size =
 			    arena_mapbits_unallocated_size_get(chunk, pageind);
 
 			npages = run_size >> LG_PAGE;
+
 			assert(pageind + npages <= chunk_npages);
 			assert(arena_mapbits_dirty_get(chunk, pageind) ==
 			    arena_mapbits_dirty_get(chunk, pageind+npages-1));
 
-			if (arena_mapbits_dirty_get(chunk, pageind) != 0 &&
-			    (all || arena_avail_adjac(chunk, pageind,
-			    npages))) {
-				arena_run_t *run = (arena_run_t *)((uintptr_t)
-				    chunk + (uintptr_t)(pageind << LG_PAGE));
-
-				arena_run_split_large(arena, run, run_size,
-				    false);
-				/* Append to list for later processing. */
-				ql_elm_new(mapelm, u.ql_link);
-				ql_tail_insert(mapelms, mapelm, u.ql_link);
-			}
-		} else {
-			/* Skip run. */
-			if (arena_mapbits_large_get(chunk, pageind) != 0) {
-				npages = arena_mapbits_large_size_get(chunk,
-				    pageind) >> LG_PAGE;
-			} else {
-				size_t binind;
-				arena_bin_info_t *bin_info;
-				arena_run_t *run = (arena_run_t *)((uintptr_t)
-				    chunk + (uintptr_t)(pageind << LG_PAGE));
-
-				assert(arena_mapbits_small_runind_get(chunk,
-				    pageind) == 0);
-				binind = arena_bin_index(arena, run->bin);
-				bin_info = &arena_bin_info[binind];
-				npages = bin_info->run_size >> LG_PAGE;
+			/*
+			 * If purging the spare chunk's run, make it available
+			 * prior to allocation.
+			 */
+			if (chunk == arena->spare)
+				arena_chunk_alloc(arena);
+
+			/* Temporarily allocate the free dirty run. */
+			arena_run_split_large(arena, run, run_size, false);
+			/* Stash. */
+			if (false)
+				qr_new(rdelm, rd_link); /* Redundant. */
+			else {
+				assert(qr_next(rdelm, rd_link) == rdelm);
+				assert(qr_prev(rdelm, rd_link) == rdelm);
 			}
+			qr_meld(purge_runs_sentinel, rdelm, rd_link);
 		}
+
+		nstashed += npages;
+		if (!all && nstashed >= npurge)
+			break;
 	}
-	assert(pageind == chunk_npages);
-	assert(chunk->ndirty == 0 || all == false);
-	assert(chunk->nruns_adjac == 0);
+
+	return (nstashed);
 }
 
 static size_t
-arena_chunk_purge_stashed(arena_t *arena, arena_chunk_t *chunk,
-    arena_chunk_mapelms_t *mapelms)
-{
-	size_t npurged, pageind, npages, nmadvise;
-	arena_chunk_map_t *mapelm;
+arena_purge_stashed(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    arena_runs_dirty_link_t *purge_runs_sentinel,
+    extent_node_t *purge_chunks_sentinel)
+{
+	size_t npurged, nmadvise;
+	arena_runs_dirty_link_t *rdelm;
+	extent_node_t *chunkselm;
 
-	malloc_mutex_unlock(&arena->lock);
 	if (config_stats)
 		nmadvise = 0;
 	npurged = 0;
-	ql_foreach(mapelm, mapelms, u.ql_link) {
-		bool unzeroed;
-		size_t flag_unzeroed, i;
-
-		pageind = (((uintptr_t)mapelm - (uintptr_t)chunk->map) /
-		    sizeof(arena_chunk_map_t)) + map_bias;
-		npages = arena_mapbits_large_size_get(chunk, pageind) >>
-		    LG_PAGE;
-		assert(pageind + npages <= chunk_npages);
-		unzeroed = pages_purge((void *)((uintptr_t)chunk + (pageind <<
-		    LG_PAGE)), (npages << LG_PAGE));
-		flag_unzeroed = unzeroed ? CHUNK_MAP_UNZEROED : 0;
-		/*
-		 * Set the unzeroed flag for all pages, now that pages_purge()
-		 * has returned whether the pages were zeroed as a side effect
-		 * of purging.  This chunk map modification is safe even though
-		 * the arena mutex isn't currently owned by this thread,
-		 * because the run is marked as allocated, thus protecting it
-		 * from being modified by any other thread.  As long as these
-		 * writes don't perturb the first and last elements'
-		 * CHUNK_MAP_ALLOCATED bits, behavior is well defined.
-		 */
-		for (i = 0; i < npages; i++) {
-			arena_mapbits_unzeroed_set(chunk, pageind+i,
-			    flag_unzeroed);
+
+	malloc_mutex_unlock(&arena->lock);
+	for (rdelm = qr_next(purge_runs_sentinel, rd_link),
+	    chunkselm = qr_next(purge_chunks_sentinel, cc_link);
+	    rdelm != purge_runs_sentinel; rdelm = qr_next(rdelm, rd_link)) {
+		size_t npages;
+
+		if (rdelm == &chunkselm->rd) {
+			/*
+			 * Don't actually purge the chunk here because 1)
+			 * chunkselm is embedded in the chunk and must remain
+			 * valid, and 2) we deallocate the chunk in
+			 * arena_unstash_purged(), where it is destroyed,
+			 * decommitted, or purged, depending on chunk
+			 * deallocation policy.
+			 */
+			size_t size = extent_node_size_get(chunkselm);
+			npages = size >> LG_PAGE;
+			chunkselm = qr_next(chunkselm, cc_link);
+		} else {
+			size_t pageind, run_size, flag_unzeroed, flags, i;
+			bool decommitted;
+			arena_chunk_t *chunk =
+			    (arena_chunk_t *)CHUNK_ADDR2BASE(rdelm);
+			arena_chunk_map_misc_t *miscelm =
+			    arena_rd_to_miscelm(rdelm);
+			pageind = arena_miscelm_to_pageind(miscelm);
+			run_size = arena_mapbits_large_size_get(chunk, pageind);
+			npages = run_size >> LG_PAGE;
+
+			assert(pageind + npages <= chunk_npages);
+			assert(!arena_mapbits_decommitted_get(chunk, pageind));
+			assert(!arena_mapbits_decommitted_get(chunk,
+			    pageind+npages-1));
+			decommitted = !chunk_hooks->decommit(chunk, chunksize,
+			    pageind << LG_PAGE, npages << LG_PAGE, arena->ind);
+			if (decommitted) {
+				flag_unzeroed = 0;
+				flags = CHUNK_MAP_DECOMMITTED;
+			} else {
+				flag_unzeroed = chunk_purge_wrapper(arena,
+				    chunk_hooks, chunk, chunksize, pageind <<
+				    LG_PAGE, run_size) ? CHUNK_MAP_UNZEROED : 0;
+				flags = flag_unzeroed;
+			}
+			arena_mapbits_large_set(chunk, pageind+npages-1, 0,
+			    flags);
+			arena_mapbits_large_set(chunk, pageind, run_size,
+			    flags);
+
+			/*
+			 * Set the unzeroed flag for internal pages, now that
+			 * chunk_purge_wrapper() has returned whether the pages
+			 * were zeroed as a side effect of purging.  This chunk
+			 * map modification is safe even though the arena mutex
+			 * isn't currently owned by this thread, because the run
+			 * is marked as allocated, thus protecting it from being
+			 * modified by any other thread.  As long as these
+			 * writes don't perturb the first and last elements'
+			 * CHUNK_MAP_ALLOCATED bits, behavior is well defined.
+			 */
+			for (i = 1; i < npages-1; i++) {
+				arena_mapbits_internal_set(chunk, pageind+i,
+				    flag_unzeroed);
+			}
 		}
+
 		npurged += npages;
 		if (config_stats)
 			nmadvise++;
 	}
 	malloc_mutex_lock(&arena->lock);
-	if (config_stats)
+
+	if (config_stats) {
 		arena->stats.nmadvise += nmadvise;
+		arena->stats.purged += npurged;
+	}
 
 	return (npurged);
 }
 
 static void
-arena_chunk_unstash_purged(arena_t *arena, arena_chunk_t *chunk,
-    arena_chunk_mapelms_t *mapelms)
-{
-	arena_chunk_map_t *mapelm;
-	size_t pageind;
-
-	/* Deallocate runs. */
-	for (mapelm = ql_first(mapelms); mapelm != NULL;
-	    mapelm = ql_first(mapelms)) {
-		arena_run_t *run;
-
-		pageind = (((uintptr_t)mapelm - (uintptr_t)chunk->map) /
-		    sizeof(arena_chunk_map_t)) + map_bias;
-		run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)(pageind <<
-		    LG_PAGE));
-		ql_remove(mapelms, mapelm, u.ql_link);
-		arena_run_dalloc(arena, run, false, true);
+arena_unstash_purged(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    arena_runs_dirty_link_t *purge_runs_sentinel,
+    extent_node_t *purge_chunks_sentinel)
+{
+	arena_runs_dirty_link_t *rdelm, *rdelm_next;
+	extent_node_t *chunkselm;
+
+	/* Deallocate chunks/runs. */
+	for (rdelm = qr_next(purge_runs_sentinel, rd_link),
+	    chunkselm = qr_next(purge_chunks_sentinel, cc_link);
+	    rdelm != purge_runs_sentinel; rdelm = rdelm_next) {
+		rdelm_next = qr_next(rdelm, rd_link);
+		if (rdelm == &chunkselm->rd) {
+			extent_node_t *chunkselm_next = qr_next(chunkselm,
+			    cc_link);
+			void *addr = extent_node_addr_get(chunkselm);
+			size_t size = extent_node_size_get(chunkselm);
+			bool zeroed = extent_node_zeroed_get(chunkselm);
+			bool committed = extent_node_committed_get(chunkselm);
+			extent_node_dirty_remove(chunkselm);
+			arena_node_dalloc(arena, chunkselm);
+			chunkselm = chunkselm_next;
+			chunk_dalloc_arena(arena, chunk_hooks, addr, size,
+			    zeroed, committed);
+		} else {
+			arena_chunk_t *chunk =
+			    (arena_chunk_t *)CHUNK_ADDR2BASE(rdelm);
+			arena_chunk_map_misc_t *miscelm =
+			    arena_rd_to_miscelm(rdelm);
+			size_t pageind = arena_miscelm_to_pageind(miscelm);
+			bool decommitted = (arena_mapbits_decommitted_get(chunk,
+			    pageind) != 0);
+			arena_run_t *run = &miscelm->run;
+			qr_remove(rdelm, rd_link);
+			arena_run_dalloc(arena, run, false, true, decommitted);
+		}
 	}
 }
 
-static inline size_t
-arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk, bool all)
+static void
+arena_purge(arena_t *arena, bool all)
 {
-	size_t npurged;
-	arena_chunk_mapelms_t mapelms;
+	chunk_hooks_t chunk_hooks = chunk_hooks_get(arena);
+	size_t npurge, npurgeable, npurged;
+	arena_runs_dirty_link_t purge_runs_sentinel;
+	extent_node_t purge_chunks_sentinel;
 
-	ql_new(&mapelms);
+	arena->purging = true;
 
 	/*
-	 * If chunk is the spare, temporarily re-allocate it, 1) so that its
-	 * run is reinserted into runs_avail, and 2) so that it cannot be
-	 * completely discarded by another thread while arena->lock is dropped
-	 * by this thread.  Note that the arena_run_dalloc() call will
-	 * implicitly deallocate the chunk, so no explicit action is required
-	 * in this function to deallocate the chunk.
-	 *
-	 * Note that once a chunk contains dirty pages, it cannot again contain
-	 * a single run unless 1) it is a dirty run, or 2) this function purges
-	 * dirty pages and causes the transition to a single clean run.  Thus
-	 * (chunk == arena->spare) is possible, but it is not possible for
-	 * this function to be called on the spare unless it contains a dirty
-	 * run.
-	 */
-	if (chunk == arena->spare) {
-		assert(arena_mapbits_dirty_get(chunk, map_bias) != 0);
-		assert(arena_mapbits_dirty_get(chunk, chunk_npages-1) != 0);
-
-		arena_chunk_alloc(arena);
-	}
-
-	if (config_stats)
-		arena->stats.purged += chunk->ndirty;
-
-	/*
-	 * Operate on all dirty runs if there is no clean/dirty run
-	 * fragmentation.
+	 * Calls to arena_dirty_count() are disabled even for debug builds
+	 * because overhead grows nonlinearly as memory usage increases.
 	 */
-	if (chunk->nruns_adjac == 0)
-		all = true;
-
-	arena_chunk_stash_dirty(arena, chunk, all, &mapelms);
-	npurged = arena_chunk_purge_stashed(arena, chunk, &mapelms);
-	arena_chunk_unstash_purged(arena, chunk, &mapelms);
-
-	return (npurged);
-}
-
-static void
-arena_purge(arena_t *arena, bool all)
-{
-	arena_chunk_t *chunk;
-	size_t npurgatory;
-	if (config_debug) {
-		size_t ndirty = 0;
-
-		arena_chunk_dirty_iter(&arena->chunks_dirty, NULL,
-		    chunks_dirty_iter_cb, (void *)&ndirty);
+	if (false && config_debug) {
+		size_t ndirty = arena_dirty_count(arena);
 		assert(ndirty == arena->ndirty);
 	}
-	assert(arena->ndirty > arena->npurgatory || all);
-	assert((arena->nactive >> opt_lg_dirty_mult) < (arena->ndirty -
-	    arena->npurgatory) || all);
+	assert((arena->nactive >> arena->lg_dirty_mult) < arena->ndirty || all);
 
 	if (config_stats)
 		arena->stats.npurge++;
 
-	/*
-	 * Add the minimum number of pages this thread should try to purge to
-	 * arena->npurgatory.  This will keep multiple threads from racing to
-	 * reduce ndirty below the threshold.
-	 */
-	npurgatory = arena_compute_npurgatory(arena, all);
-	arena->npurgatory += npurgatory;
-
-	while (npurgatory > 0) {
-		size_t npurgeable, npurged, nunpurged;
-
-		/* Get next chunk with dirty pages. */
-		chunk = arena_chunk_dirty_first(&arena->chunks_dirty);
-		if (chunk == NULL) {
-			/*
-			 * This thread was unable to purge as many pages as
-			 * originally intended, due to races with other threads
-			 * that either did some of the purging work, or re-used
-			 * dirty pages.
-			 */
-			arena->npurgatory -= npurgatory;
-			return;
-		}
-		npurgeable = chunk->ndirty;
-		assert(npurgeable != 0);
-
-		if (npurgeable > npurgatory && chunk->nruns_adjac == 0) {
-			/*
-			 * This thread will purge all the dirty pages in chunk,
-			 * so set npurgatory to reflect this thread's intent to
-			 * purge the pages.  This tends to reduce the chances
-			 * of the following scenario:
-			 *
-			 * 1) This thread sets arena->npurgatory such that
-			 *    (arena->ndirty - arena->npurgatory) is at the
-			 *    threshold.
-			 * 2) This thread drops arena->lock.
-			 * 3) Another thread causes one or more pages to be
-			 *    dirtied, and immediately determines that it must
-			 *    purge dirty pages.
-			 *
-			 * If this scenario *does* play out, that's okay,
-			 * because all of the purging work being done really
-			 * needs to happen.
-			 */
-			arena->npurgatory += npurgeable - npurgatory;
-			npurgatory = npurgeable;
-		}
+	npurge = arena_compute_npurge(arena, all);
+	qr_new(&purge_runs_sentinel, rd_link);
+	extent_node_dirty_linkage_init(&purge_chunks_sentinel);
+
+	npurgeable = arena_stash_dirty(arena, &chunk_hooks, all, npurge,
+	    &purge_runs_sentinel, &purge_chunks_sentinel);
+	assert(npurgeable >= npurge);
+	npurged = arena_purge_stashed(arena, &chunk_hooks, &purge_runs_sentinel,
+	    &purge_chunks_sentinel);
+	assert(npurged == npurgeable);
+	arena_unstash_purged(arena, &chunk_hooks, &purge_runs_sentinel,
+	    &purge_chunks_sentinel);
 
-		/*
-		 * Keep track of how many pages are purgeable, versus how many
-		 * actually get purged, and adjust counters accordingly.
-		 */
-		arena->npurgatory -= npurgeable;
-		npurgatory -= npurgeable;
-		npurged = arena_chunk_purge(arena, chunk, all);
-		nunpurged = npurgeable - npurged;
-		arena->npurgatory += nunpurged;
-		npurgatory += nunpurged;
-	}
+	arena->purging = false;
 }
 
 void
 arena_purge_all(arena_t *arena)
 {
 
@@ -1087,49 +1546,63 @@
 	arena_purge(arena, true);
 	malloc_mutex_unlock(&arena->lock);
 }
 
 static void
 arena_run_coalesce(arena_t *arena, arena_chunk_t *chunk, size_t *p_size,
-    size_t *p_run_ind, size_t *p_run_pages, size_t flag_dirty)
+    size_t *p_run_ind, size_t *p_run_pages, size_t flag_dirty,
+    size_t flag_decommitted)
 {
 	size_t size = *p_size;
 	size_t run_ind = *p_run_ind;
 	size_t run_pages = *p_run_pages;
 
 	/* Try to coalesce forward. */
 	if (run_ind + run_pages < chunk_npages &&
 	    arena_mapbits_allocated_get(chunk, run_ind+run_pages) == 0 &&
-	    arena_mapbits_dirty_get(chunk, run_ind+run_pages) == flag_dirty) {
+	    arena_mapbits_dirty_get(chunk, run_ind+run_pages) == flag_dirty &&
+	    arena_mapbits_decommitted_get(chunk, run_ind+run_pages) ==
+	    flag_decommitted) {
 		size_t nrun_size = arena_mapbits_unallocated_size_get(chunk,
 		    run_ind+run_pages);
 		size_t nrun_pages = nrun_size >> LG_PAGE;
 
 		/*
 		 * Remove successor from runs_avail; the coalesced run is
 		 * inserted later.
 		 */
 		assert(arena_mapbits_unallocated_size_get(chunk,
 		    run_ind+run_pages+nrun_pages-1) == nrun_size);
 		assert(arena_mapbits_dirty_get(chunk,
 		    run_ind+run_pages+nrun_pages-1) == flag_dirty);
-		arena_avail_remove(arena, chunk, run_ind+run_pages, nrun_pages,
-		    false, true);
+		assert(arena_mapbits_decommitted_get(chunk,
+		    run_ind+run_pages+nrun_pages-1) == flag_decommitted);
+		arena_avail_remove(arena, chunk, run_ind+run_pages, nrun_pages);
+
+		/*
+		 * If the successor is dirty, remove it from the set of dirty
+		 * pages.
+		 */
+		if (flag_dirty != 0) {
+			arena_run_dirty_remove(arena, chunk, run_ind+run_pages,
+			    nrun_pages);
+		}
 
 		size += nrun_size;
 		run_pages += nrun_pages;
 
 		arena_mapbits_unallocated_size_set(chunk, run_ind, size);
 		arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages-1,
 		    size);
 	}
 
 	/* Try to coalesce backward. */
 	if (run_ind > map_bias && arena_mapbits_allocated_get(chunk,
 	    run_ind-1) == 0 && arena_mapbits_dirty_get(chunk, run_ind-1) ==
-	    flag_dirty) {
+	    flag_dirty && arena_mapbits_decommitted_get(chunk, run_ind-1) ==
+	    flag_decommitted) {
 		size_t prun_size = arena_mapbits_unallocated_size_get(chunk,
 		    run_ind-1);
 		size_t prun_pages = prun_size >> LG_PAGE;
 
 		run_ind -= prun_pages;
 
@@ -1137,14 +1610,24 @@
 		 * Remove predecessor from runs_avail; the coalesced run is
 		 * inserted later.
 		 */
 		assert(arena_mapbits_unallocated_size_get(chunk, run_ind) ==
 		    prun_size);
 		assert(arena_mapbits_dirty_get(chunk, run_ind) == flag_dirty);
-		arena_avail_remove(arena, chunk, run_ind, prun_pages, true,
-		    false);
+		assert(arena_mapbits_decommitted_get(chunk, run_ind) ==
+		    flag_decommitted);
+		arena_avail_remove(arena, chunk, run_ind, prun_pages);
+
+		/*
+		 * If the predecessor is dirty, remove it from the set of dirty
+		 * pages.
+		 */
+		if (flag_dirty != 0) {
+			arena_run_dirty_remove(arena, chunk, run_ind,
+			    prun_pages);
+		}
 
 		size += prun_size;
 		run_pages += prun_pages;
 
 		arena_mapbits_unallocated_size_set(chunk, run_ind, size);
 		arena_mapbits_unallocated_size_set(chunk, run_ind+run_pages-1,
@@ -1153,75 +1636,109 @@
 
 	*p_size = size;
 	*p_run_ind = run_ind;
 	*p_run_pages = run_pages;
 }
 
-static void
-arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty, bool cleaned)
+static size_t
+arena_run_size_get(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
+    size_t run_ind)
 {
-	arena_chunk_t *chunk;
-	size_t size, run_ind, run_pages, flag_dirty;
+	size_t size;
 
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
-	run_ind = (size_t)(((uintptr_t)run - (uintptr_t)chunk) >> LG_PAGE);
 	assert(run_ind >= map_bias);
 	assert(run_ind < chunk_npages);
+
 	if (arena_mapbits_large_get(chunk, run_ind) != 0) {
 		size = arena_mapbits_large_size_get(chunk, run_ind);
-		assert(size == PAGE ||
-		    arena_mapbits_large_size_get(chunk,
+		assert(size == PAGE || arena_mapbits_large_size_get(chunk,
 		    run_ind+(size>>LG_PAGE)-1) == 0);
 	} else {
-		size_t binind = arena_bin_index(arena, run->bin);
-		arena_bin_info_t *bin_info = &arena_bin_info[binind];
+		arena_bin_info_t *bin_info = &arena_bin_info[run->binind];
 		size = bin_info->run_size;
 	}
+
+	return (size);
+}
+
+static bool
+arena_run_decommit(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run)
+{
+	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
+	size_t run_ind = arena_miscelm_to_pageind(miscelm);
+	size_t offset = run_ind << LG_PAGE;
+	size_t length = arena_run_size_get(arena, chunk, run, run_ind);
+
+	return (arena->chunk_hooks.decommit(chunk, chunksize, offset, length,
+	    arena->ind));
+}
+
+static void
+arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty, bool cleaned,
+    bool decommitted)
+{
+	arena_chunk_t *chunk;
+	arena_chunk_map_misc_t *miscelm;
+	size_t size, run_ind, run_pages, flag_dirty, flag_decommitted;
+
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
+	miscelm = arena_run_to_miscelm(run);
+	run_ind = arena_miscelm_to_pageind(miscelm);
+	assert(run_ind >= map_bias);
+	assert(run_ind < chunk_npages);
+	size = arena_run_size_get(arena, chunk, run, run_ind);
 	run_pages = (size >> LG_PAGE);
 	arena_cactive_update(arena, 0, run_pages);
 	arena->nactive -= run_pages;
 
 	/*
 	 * The run is dirty if the caller claims to have dirtied it, as well as
 	 * if it was already dirty before being allocated and the caller
 	 * doesn't claim to have cleaned it.
 	 */
 	assert(arena_mapbits_dirty_get(chunk, run_ind) ==
 	    arena_mapbits_dirty_get(chunk, run_ind+run_pages-1));
-	if (cleaned == false && arena_mapbits_dirty_get(chunk, run_ind) != 0)
+	if (!cleaned && !decommitted && arena_mapbits_dirty_get(chunk, run_ind)
+	    != 0)
 		dirty = true;
 	flag_dirty = dirty ? CHUNK_MAP_DIRTY : 0;
+	flag_decommitted = decommitted ? CHUNK_MAP_DECOMMITTED : 0;
 
 	/* Mark pages as unallocated in the chunk map. */
-	if (dirty) {
-		arena_mapbits_unallocated_set(chunk, run_ind, size,
-		    CHUNK_MAP_DIRTY);
+	if (dirty || decommitted) {
+		size_t flags = flag_dirty | flag_decommitted;
+		arena_mapbits_unallocated_set(chunk, run_ind, size, flags);
 		arena_mapbits_unallocated_set(chunk, run_ind+run_pages-1, size,
-		    CHUNK_MAP_DIRTY);
+		    flags);
 	} else {
 		arena_mapbits_unallocated_set(chunk, run_ind, size,
 		    arena_mapbits_unzeroed_get(chunk, run_ind));
 		arena_mapbits_unallocated_set(chunk, run_ind+run_pages-1, size,
 		    arena_mapbits_unzeroed_get(chunk, run_ind+run_pages-1));
 	}
 
 	arena_run_coalesce(arena, chunk, &size, &run_ind, &run_pages,
-	    flag_dirty);
+	    flag_dirty, flag_decommitted);
 
 	/* Insert into runs_avail, now that coalescing is complete. */
 	assert(arena_mapbits_unallocated_size_get(chunk, run_ind) ==
 	    arena_mapbits_unallocated_size_get(chunk, run_ind+run_pages-1));
 	assert(arena_mapbits_dirty_get(chunk, run_ind) ==
 	    arena_mapbits_dirty_get(chunk, run_ind+run_pages-1));
-	arena_avail_insert(arena, chunk, run_ind, run_pages, true, true);
+	assert(arena_mapbits_decommitted_get(chunk, run_ind) ==
+	    arena_mapbits_decommitted_get(chunk, run_ind+run_pages-1));
+	arena_avail_insert(arena, chunk, run_ind, run_pages);
+
+	if (dirty)
+		arena_run_dirty_insert(arena, chunk, run_ind, run_pages);
 
 	/* Deallocate chunk if it is now completely unused. */
-	if (size == arena_maxclass) {
+	if (size == arena_maxrun) {
 		assert(run_ind == map_bias);
-		assert(run_pages == (arena_maxclass >> LG_PAGE));
-		arena_chunk_dealloc(arena, chunk);
+		assert(run_pages == (arena_maxrun >> LG_PAGE));
+		arena_chunk_dalloc(arena, chunk);
 	}
 
 	/*
 	 * It is okay to do dirty page processing here even if the chunk was
 	 * deallocated above, since in that case it is the spare.  Waiting
 	 * until after possible chunk deallocation to do dirty processing
@@ -1230,119 +1747,133 @@
 	 */
 	if (dirty)
 		arena_maybe_purge(arena);
 }
 
 static void
+arena_run_dalloc_decommit(arena_t *arena, arena_chunk_t *chunk,
+    arena_run_t *run)
+{
+	bool committed = arena_run_decommit(arena, chunk, run);
+
+	arena_run_dalloc(arena, run, committed, false, !committed);
+}
+
+static void
 arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
     size_t oldsize, size_t newsize)
 {
-	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> LG_PAGE;
+	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
+	size_t pageind = arena_miscelm_to_pageind(miscelm);
 	size_t head_npages = (oldsize - newsize) >> LG_PAGE;
 	size_t flag_dirty = arena_mapbits_dirty_get(chunk, pageind);
+	size_t flag_decommitted = arena_mapbits_decommitted_get(chunk, pageind);
+	size_t flag_unzeroed_mask = (flag_dirty | flag_decommitted) == 0 ?
+	    CHUNK_MAP_UNZEROED : 0;
 
 	assert(oldsize > newsize);
 
 	/*
 	 * Update the chunk map so that arena_run_dalloc() can treat the
 	 * leading run as separately allocated.  Set the last element of each
 	 * run first, in case of single-page runs.
 	 */
 	assert(arena_mapbits_large_size_get(chunk, pageind) == oldsize);
-	arena_mapbits_large_set(chunk, pageind+head_npages-1, 0, flag_dirty);
-	arena_mapbits_large_set(chunk, pageind, oldsize-newsize, flag_dirty);
+	arena_mapbits_large_set(chunk, pageind+head_npages-1, 0, flag_dirty |
+	    (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk,
+	    pageind+head_npages-1)));
+	arena_mapbits_large_set(chunk, pageind, oldsize-newsize, flag_dirty |
+	    (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk, pageind)));
 
 	if (config_debug) {
 		UNUSED size_t tail_npages = newsize >> LG_PAGE;
 		assert(arena_mapbits_large_size_get(chunk,
 		    pageind+head_npages+tail_npages-1) == 0);
 		assert(arena_mapbits_dirty_get(chunk,
 		    pageind+head_npages+tail_npages-1) == flag_dirty);
 	}
 	arena_mapbits_large_set(chunk, pageind+head_npages, newsize,
-	    flag_dirty);
+	    flag_dirty | (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk,
+	    pageind+head_npages)));
 
-	arena_run_dalloc(arena, run, false, false);
+	arena_run_dalloc(arena, run, false, false, (flag_decommitted != 0));
 }
 
 static void
 arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
     size_t oldsize, size_t newsize, bool dirty)
 {
-	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> LG_PAGE;
+	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
+	size_t pageind = arena_miscelm_to_pageind(miscelm);
 	size_t head_npages = newsize >> LG_PAGE;
 	size_t flag_dirty = arena_mapbits_dirty_get(chunk, pageind);
+	size_t flag_decommitted = arena_mapbits_decommitted_get(chunk, pageind);
+	size_t flag_unzeroed_mask = (flag_dirty | flag_decommitted) == 0 ?
+	    CHUNK_MAP_UNZEROED : 0;
+	arena_chunk_map_misc_t *tail_miscelm;
+	arena_run_t *tail_run;
 
 	assert(oldsize > newsize);
 
 	/*
 	 * Update the chunk map so that arena_run_dalloc() can treat the
 	 * trailing run as separately allocated.  Set the last element of each
 	 * run first, in case of single-page runs.
 	 */
 	assert(arena_mapbits_large_size_get(chunk, pageind) == oldsize);
-	arena_mapbits_large_set(chunk, pageind+head_npages-1, 0, flag_dirty);
-	arena_mapbits_large_set(chunk, pageind, newsize, flag_dirty);
+	arena_mapbits_large_set(chunk, pageind+head_npages-1, 0, flag_dirty |
+	    (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk,
+	    pageind+head_npages-1)));
+	arena_mapbits_large_set(chunk, pageind, newsize, flag_dirty |
+	    (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk, pageind)));
 
 	if (config_debug) {
 		UNUSED size_t tail_npages = (oldsize - newsize) >> LG_PAGE;
 		assert(arena_mapbits_large_size_get(chunk,
 		    pageind+head_npages+tail_npages-1) == 0);
 		assert(arena_mapbits_dirty_get(chunk,
 		    pageind+head_npages+tail_npages-1) == flag_dirty);
 	}
 	arena_mapbits_large_set(chunk, pageind+head_npages, oldsize-newsize,
-	    flag_dirty);
+	    flag_dirty | (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk,
+	    pageind+head_npages)));
 
-	arena_run_dalloc(arena, (arena_run_t *)((uintptr_t)run + newsize),
-	    dirty, false);
+	tail_miscelm = arena_miscelm_get(chunk, pageind + head_npages);
+	tail_run = &tail_miscelm->run;
+	arena_run_dalloc(arena, tail_run, dirty, false, (flag_decommitted !=
+	    0));
 }
 
 static arena_run_t *
 arena_bin_runs_first(arena_bin_t *bin)
 {
-	arena_chunk_map_t *mapelm = arena_run_tree_first(&bin->runs);
-	if (mapelm != NULL) {
-		arena_chunk_t *chunk;
-		size_t pageind;
-		arena_run_t *run;
-
-		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(mapelm);
-		pageind = ((((uintptr_t)mapelm - (uintptr_t)chunk->map) /
-		    sizeof(arena_chunk_map_t))) + map_bias;
-		run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
-		    arena_mapbits_small_runind_get(chunk, pageind)) <<
-		    LG_PAGE));
-		return (run);
-	}
+	arena_chunk_map_misc_t *miscelm = arena_run_tree_first(&bin->runs);
+	if (miscelm != NULL)
+		return (&miscelm->run);
 
 	return (NULL);
 }
 
 static void
 arena_bin_runs_insert(arena_bin_t *bin, arena_run_t *run)
 {
-	arena_chunk_t *chunk = CHUNK_ADDR2BASE(run);
-	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> LG_PAGE;
-	arena_chunk_map_t *mapelm = arena_mapp_get(chunk, pageind);
+	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
 
-	assert(arena_run_tree_search(&bin->runs, mapelm) == NULL);
+	assert(arena_run_tree_search(&bin->runs, miscelm) == NULL);
 
-	arena_run_tree_insert(&bin->runs, mapelm);
+	arena_run_tree_insert(&bin->runs, miscelm);
 }
 
 static void
 arena_bin_runs_remove(arena_bin_t *bin, arena_run_t *run)
 {
-	arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
-	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> LG_PAGE;
-	arena_chunk_map_t *mapelm = arena_mapp_get(chunk, pageind);
+	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
 
-	assert(arena_run_tree_search(&bin->runs, mapelm) != NULL);
+	assert(arena_run_tree_search(&bin->runs, miscelm) != NULL);
 
-	arena_run_tree_remove(&bin->runs, mapelm);
+	arena_run_tree_remove(&bin->runs, miscelm);
 }
 
 static arena_run_t *
 arena_bin_nonfull_run_tryget(arena_bin_t *bin)
 {
 	arena_run_t *run = arena_bin_runs_first(bin);
@@ -1355,13 +1886,13 @@
 }
 
 static arena_run_t *
 arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin)
 {
 	arena_run_t *run;
-	size_t binind;
+	szind_t binind;
 	arena_bin_info_t *bin_info;
 
 	/* Look for a usable run. */
 	run = arena_bin_nonfull_run_tryget(bin);
 	if (run != NULL)
 		return (run);
@@ -1373,20 +1904,16 @@
 	/* Allocate a new run. */
 	malloc_mutex_unlock(&bin->lock);
 	/******************************/
 	malloc_mutex_lock(&arena->lock);
 	run = arena_run_alloc_small(arena, bin_info->run_size, binind);
 	if (run != NULL) {
-		bitmap_t *bitmap = (bitmap_t *)((uintptr_t)run +
-		    (uintptr_t)bin_info->bitmap_offset);
-
 		/* Initialize run internals. */
-		run->bin = bin;
-		run->nextind = 0;
+		run->binind = binind;
 		run->nfree = bin_info->nregs;
-		bitmap_init(bitmap, &bin_info->bitmap_info);
+		bitmap_init(run->bitmap, &bin_info->bitmap_info);
 	}
 	malloc_mutex_unlock(&arena->lock);
 	/********************************/
 	malloc_mutex_lock(&bin->lock);
 	if (run != NULL) {
 		if (config_stats) {
@@ -1409,26 +1936,26 @@
 }
 
 /* Re-fill bin->runcur, then call arena_run_reg_alloc(). */
 static void *
 arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin)
 {
-	void *ret;
-	size_t binind;
+	szind_t binind;
 	arena_bin_info_t *bin_info;
 	arena_run_t *run;
 
 	binind = arena_bin_index(arena, bin);
 	bin_info = &arena_bin_info[binind];
 	bin->runcur = NULL;
 	run = arena_bin_nonfull_run_get(arena, bin);
 	if (bin->runcur != NULL && bin->runcur->nfree > 0) {
 		/*
 		 * Another thread updated runcur while this one ran without the
 		 * bin lock in arena_bin_nonfull_run_get().
 		 */
+		void *ret;
 		assert(bin->runcur->nfree > 0);
 		ret = arena_run_reg_alloc(bin->runcur, bin_info);
 		if (run != NULL) {
 			arena_chunk_t *chunk;
 
 			/*
@@ -1456,45 +1983,56 @@
 	assert(bin->runcur->nfree > 0);
 
 	return (arena_run_reg_alloc(bin->runcur, bin_info));
 }
 
 void
-arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind,
+arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, szind_t binind,
     uint64_t prof_accumbytes)
 {
 	unsigned i, nfill;
 	arena_bin_t *bin;
-	arena_run_t *run;
-	void *ptr;
 
 	assert(tbin->ncached == 0);
 
 	if (config_prof && arena_prof_accum(arena, prof_accumbytes))
 		prof_idump();
 	bin = &arena->bins[binind];
 	malloc_mutex_lock(&bin->lock);
 	for (i = 0, nfill = (tcache_bin_info[binind].ncached_max >>
 	    tbin->lg_fill_div); i < nfill; i++) {
+		arena_run_t *run;
+		void *ptr;
 		if ((run = bin->runcur) != NULL && run->nfree > 0)
 			ptr = arena_run_reg_alloc(run, &arena_bin_info[binind]);
 		else
 			ptr = arena_bin_malloc_hard(arena, bin);
-		if (ptr == NULL)
+		if (ptr == NULL) {
+			/*
+			 * OOM.  tbin->avail isn't yet filled down to its first
+			 * element, so the successful allocations (if any) must
+			 * be moved to the base of tbin->avail before bailing
+			 * out.
+			 */
+			if (i > 0) {
+				memmove(tbin->avail, &tbin->avail[nfill - i],
+				    i * sizeof(void *));
+			}
 			break;
-		if (config_fill && opt_junk) {
+		}
+		if (config_fill && unlikely(opt_junk_alloc)) {
 			arena_alloc_junk_small(ptr, &arena_bin_info[binind],
 			    true);
 		}
 		/* Insert such that low regions get used first. */
 		tbin->avail[nfill - 1 - i] = ptr;
 	}
 	if (config_stats) {
-		bin->stats.allocated += i * arena_bin_info[binind].reg_size;
 		bin->stats.nmalloc += i;
 		bin->stats.nrequests += tbin->tstats.nrequests;
+		bin->stats.curregs += i;
 		bin->stats.nfills++;
 		tbin->tstats.nrequests = 0;
 	}
 	malloc_mutex_unlock(&bin->lock);
 	tbin->ncached = i;
 }
@@ -1535,35 +2073,41 @@
     JEMALLOC_N(arena_redzone_corruption_impl);
 #endif
 
 static void
 arena_redzones_validate(void *ptr, arena_bin_info_t *bin_info, bool reset)
 {
-	size_t size = bin_info->reg_size;
-	size_t redzone_size = bin_info->redzone_size;
-	size_t i;
 	bool error = false;
 
-	for (i = 1; i <= redzone_size; i++) {
-		uint8_t *byte = (uint8_t *)((uintptr_t)ptr - i);
-		if (*byte != 0xa5) {
-			error = true;
-			arena_redzone_corruption(ptr, size, false, i, *byte);
-			if (reset)
-				*byte = 0xa5;
-		}
-	}
-	for (i = 0; i < redzone_size; i++) {
-		uint8_t *byte = (uint8_t *)((uintptr_t)ptr + size + i);
-		if (*byte != 0xa5) {
-			error = true;
-			arena_redzone_corruption(ptr, size, true, i, *byte);
-			if (reset)
-				*byte = 0xa5;
+	if (opt_junk_alloc) {
+		size_t size = bin_info->reg_size;
+		size_t redzone_size = bin_info->redzone_size;
+		size_t i;
+
+		for (i = 1; i <= redzone_size; i++) {
+			uint8_t *byte = (uint8_t *)((uintptr_t)ptr - i);
+			if (*byte != 0xa5) {
+				error = true;
+				arena_redzone_corruption(ptr, size, false, i,
+				    *byte);
+				if (reset)
+					*byte = 0xa5;
+			}
+		}
+		for (i = 0; i < redzone_size; i++) {
+			uint8_t *byte = (uint8_t *)((uintptr_t)ptr + size + i);
+			if (*byte != 0xa5) {
+				error = true;
+				arena_redzone_corruption(ptr, size, true, i,
+				    *byte);
+				if (reset)
+					*byte = 0xa5;
+			}
 		}
 	}
+
 	if (opt_abort && error)
 		abort();
 }
 
 #ifdef JEMALLOC_JET
 #undef arena_dalloc_junk_small
@@ -1585,36 +2129,36 @@
     JEMALLOC_N(arena_dalloc_junk_small_impl);
 #endif
 
 void
 arena_quarantine_junk_small(void *ptr, size_t usize)
 {
-	size_t binind;
+	szind_t binind;
 	arena_bin_info_t *bin_info;
 	cassert(config_fill);
-	assert(opt_junk);
+	assert(opt_junk_free);
 	assert(opt_quarantine);
 	assert(usize <= SMALL_MAXCLASS);
 
-	binind = SMALL_SIZE2BIN(usize);
+	binind = size2index(usize);
 	bin_info = &arena_bin_info[binind];
 	arena_redzones_validate(ptr, bin_info, true);
 }
 
 void *
 arena_malloc_small(arena_t *arena, size_t size, bool zero)
 {
 	void *ret;
 	arena_bin_t *bin;
 	arena_run_t *run;
-	size_t binind;
+	szind_t binind;
 
-	binind = SMALL_SIZE2BIN(size);
+	binind = size2index(size);
 	assert(binind < NBINS);
 	bin = &arena->bins[binind];
-	size = arena_bin_info[binind].reg_size;
+	size = index2size(binind);
 
 	malloc_mutex_lock(&bin->lock);
 	if ((run = bin->runcur) != NULL && run->nfree > 0)
 		ret = arena_run_reg_alloc(run, &arena_bin_info[binind]);
 	else
 		ret = arena_bin_malloc_hard(arena, bin);
@@ -1622,170 +2166,259 @@
 	if (ret == NULL) {
 		malloc_mutex_unlock(&bin->lock);
 		return (NULL);
 	}
 
 	if (config_stats) {
-		bin->stats.allocated += size;
 		bin->stats.nmalloc++;
 		bin->stats.nrequests++;
+		bin->stats.curregs++;
 	}
 	malloc_mutex_unlock(&bin->lock);
-	if (config_prof && isthreaded == false && arena_prof_accum(arena, size))
+	if (config_prof && !isthreaded && arena_prof_accum(arena, size))
 		prof_idump();
 
-	if (zero == false) {
+	if (!zero) {
 		if (config_fill) {
-			if (opt_junk) {
+			if (unlikely(opt_junk_alloc)) {
 				arena_alloc_junk_small(ret,
 				    &arena_bin_info[binind], false);
-			} else if (opt_zero)
+			} else if (unlikely(opt_zero))
 				memset(ret, 0, size);
 		}
-		VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
 	} else {
-		if (config_fill && opt_junk) {
+		if (config_fill && unlikely(opt_junk_alloc)) {
 			arena_alloc_junk_small(ret, &arena_bin_info[binind],
 			    true);
 		}
-		VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
 		memset(ret, 0, size);
 	}
 
 	return (ret);
 }
 
 void *
 arena_malloc_large(arena_t *arena, size_t size, bool zero)
 {
 	void *ret;
+	size_t usize;
+	uintptr_t random_offset;
+	arena_run_t *run;
+	arena_chunk_map_misc_t *miscelm;
 	UNUSED bool idump;
 
 	/* Large allocation. */
-	size = PAGE_CEILING(size);
+	usize = s2u(size);
 	malloc_mutex_lock(&arena->lock);
-	ret = (void *)arena_run_alloc_large(arena, size, zero);
-	if (ret == NULL) {
+	if (config_cache_oblivious) {
+		uint64_t r;
+
+		/*
+		 * Compute a uniformly distributed offset within the first page
+		 * that is a multiple of the cacheline size, e.g. [0 .. 63) * 64
+		 * for 4 KiB pages and 64-byte cachelines.
+		 */
+		prng64(r, LG_PAGE - LG_CACHELINE, arena->offset_state,
+		    UINT64_C(6364136223846793009),
+		    UINT64_C(1442695040888963409));
+		random_offset = ((uintptr_t)r) << LG_CACHELINE;
+	} else
+		random_offset = 0;
+	run = arena_run_alloc_large(arena, usize + large_pad, zero);
+	if (run == NULL) {
 		malloc_mutex_unlock(&arena->lock);
 		return (NULL);
 	}
+	miscelm = arena_run_to_miscelm(run);
+	ret = (void *)((uintptr_t)arena_miscelm_to_rpages(miscelm) +
+	    random_offset);
 	if (config_stats) {
+		szind_t index = size2index(usize) - NBINS;
+
 		arena->stats.nmalloc_large++;
 		arena->stats.nrequests_large++;
-		arena->stats.allocated_large += size;
-		arena->stats.lstats[(size >> LG_PAGE) - 1].nmalloc++;
-		arena->stats.lstats[(size >> LG_PAGE) - 1].nrequests++;
-		arena->stats.lstats[(size >> LG_PAGE) - 1].curruns++;
+		arena->stats.allocated_large += usize;
+		arena->stats.lstats[index].nmalloc++;
+		arena->stats.lstats[index].nrequests++;
+		arena->stats.lstats[index].curruns++;
 	}
 	if (config_prof)
-		idump = arena_prof_accum_locked(arena, size);
+		idump = arena_prof_accum_locked(arena, usize);
 	malloc_mutex_unlock(&arena->lock);
 	if (config_prof && idump)
 		prof_idump();
 
-	if (zero == false) {
+	if (!zero) {
 		if (config_fill) {
-			if (opt_junk)
-				memset(ret, 0xa5, size);
-			else if (opt_zero)
-				memset(ret, 0, size);
+			if (unlikely(opt_junk_alloc))
+				memset(ret, 0xa5, usize);
+			else if (unlikely(opt_zero))
+				memset(ret, 0, usize);
 		}
 	}
 
 	return (ret);
 }
 
 /* Only handles large allocations that require more than page alignment. */
-void *
-arena_palloc(arena_t *arena, size_t size, size_t alignment, bool zero)
+static void *
+arena_palloc_large(tsd_t *tsd, arena_t *arena, size_t usize, size_t alignment,
+    bool zero)
 {
 	void *ret;
 	size_t alloc_size, leadsize, trailsize;
 	arena_run_t *run;
 	arena_chunk_t *chunk;
+	arena_chunk_map_misc_t *miscelm;
+	void *rpages;
 
-	assert((size & PAGE_MASK) == 0);
+	assert(usize == PAGE_CEILING(usize));
+
+	arena = arena_choose(tsd, arena);
+	if (unlikely(arena == NULL))
+		return (NULL);
 
 	alignment = PAGE_CEILING(alignment);
-	alloc_size = size + alignment - PAGE;
+	alloc_size = usize + large_pad + alignment - PAGE;
 
 	malloc_mutex_lock(&arena->lock);
 	run = arena_run_alloc_large(arena, alloc_size, false);
 	if (run == NULL) {
 		malloc_mutex_unlock(&arena->lock);
 		return (NULL);
 	}
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
+	miscelm = arena_run_to_miscelm(run);
+	rpages = arena_miscelm_to_rpages(miscelm);
 
-	leadsize = ALIGNMENT_CEILING((uintptr_t)run, alignment) -
-	    (uintptr_t)run;
-	assert(alloc_size >= leadsize + size);
-	trailsize = alloc_size - leadsize - size;
-	ret = (void *)((uintptr_t)run + leadsize);
+	leadsize = ALIGNMENT_CEILING((uintptr_t)rpages, alignment) -
+	    (uintptr_t)rpages;
+	assert(alloc_size >= leadsize + usize);
+	trailsize = alloc_size - leadsize - usize - large_pad;
 	if (leadsize != 0) {
-		arena_run_trim_head(arena, chunk, run, alloc_size, alloc_size -
-		    leadsize);
+		arena_chunk_map_misc_t *head_miscelm = miscelm;
+		arena_run_t *head_run = run;
+
+		miscelm = arena_miscelm_get(chunk,
+		    arena_miscelm_to_pageind(head_miscelm) + (leadsize >>
+		    LG_PAGE));
+		run = &miscelm->run;
+
+		arena_run_trim_head(arena, chunk, head_run, alloc_size,
+		    alloc_size - leadsize);
 	}
 	if (trailsize != 0) {
-		arena_run_trim_tail(arena, chunk, ret, size + trailsize, size,
-		    false);
+		arena_run_trim_tail(arena, chunk, run, usize + large_pad +
+		    trailsize, usize + large_pad, false);
+	}
+	if (arena_run_init_large(arena, run, usize + large_pad, zero)) {
+		size_t run_ind =
+		    arena_miscelm_to_pageind(arena_run_to_miscelm(run));
+		bool dirty = (arena_mapbits_dirty_get(chunk, run_ind) != 0);
+		bool decommitted = (arena_mapbits_decommitted_get(chunk,
+		    run_ind) != 0);
+
+		assert(decommitted); /* Cause of OOM. */
+		arena_run_dalloc(arena, run, dirty, false, decommitted);
+		malloc_mutex_unlock(&arena->lock);
+		return (NULL);
 	}
-	arena_run_init_large(arena, (arena_run_t *)ret, size, zero);
+	ret = arena_miscelm_to_rpages(miscelm);
 
 	if (config_stats) {
+		szind_t index = size2index(usize) - NBINS;
+
 		arena->stats.nmalloc_large++;
 		arena->stats.nrequests_large++;
-		arena->stats.allocated_large += size;
-		arena->stats.lstats[(size >> LG_PAGE) - 1].nmalloc++;
-		arena->stats.lstats[(size >> LG_PAGE) - 1].nrequests++;
-		arena->stats.lstats[(size >> LG_PAGE) - 1].curruns++;
+		arena->stats.allocated_large += usize;
+		arena->stats.lstats[index].nmalloc++;
+		arena->stats.lstats[index].nrequests++;
+		arena->stats.lstats[index].curruns++;
 	}
 	malloc_mutex_unlock(&arena->lock);
 
-	if (config_fill && zero == false) {
-		if (opt_junk)
-			memset(ret, 0xa5, size);
-		else if (opt_zero)
-			memset(ret, 0, size);
+	if (config_fill && !zero) {
+		if (unlikely(opt_junk_alloc))
+			memset(ret, 0xa5, usize);
+		else if (unlikely(opt_zero))
+			memset(ret, 0, usize);
+	}
+	return (ret);
+}
+
+void *
+arena_palloc(tsd_t *tsd, arena_t *arena, size_t usize, size_t alignment,
+    bool zero, tcache_t *tcache)
+{
+	void *ret;
+
+	if (usize <= SMALL_MAXCLASS && (alignment < PAGE || (alignment == PAGE
+	    && (usize & PAGE_MASK) == 0))) {
+		/* Small; alignment doesn't require special run placement. */
+		ret = arena_malloc(tsd, arena, usize, zero, tcache);
+	} else if (usize <= large_maxclass && alignment <= PAGE) {
+		/*
+		 * Large; alignment doesn't require special run placement.
+		 * However, the cached pointer may be at a random offset from
+		 * the base of the run, so do some bit manipulation to retrieve
+		 * the base.
+		 */
+		ret = arena_malloc(tsd, arena, usize, zero, tcache);
+		if (config_cache_oblivious)
+			ret = (void *)((uintptr_t)ret & ~PAGE_MASK);
+	} else {
+		if (likely(usize <= large_maxclass)) {
+			ret = arena_palloc_large(tsd, arena, usize, alignment,
+			    zero);
+		} else if (likely(alignment <= chunksize))
+			ret = huge_malloc(tsd, arena, usize, zero, tcache);
+		else {
+			ret = huge_palloc(tsd, arena, usize, alignment, zero,
+			    tcache);
+		}
 	}
 	return (ret);
 }
 
 void
 arena_prof_promoted(const void *ptr, size_t size)
 {
 	arena_chunk_t *chunk;
-	size_t pageind, binind;
+	size_t pageind;
+	szind_t binind;
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 	assert(CHUNK_ADDR2BASE(ptr) != ptr);
-	assert(isalloc(ptr, false) == PAGE);
-	assert(isalloc(ptr, true) == PAGE);
+	assert(isalloc(ptr, false) == LARGE_MINCLASS);
+	assert(isalloc(ptr, true) == LARGE_MINCLASS);
 	assert(size <= SMALL_MAXCLASS);
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-	binind = SMALL_SIZE2BIN(size);
+	binind = size2index(size);
 	assert(binind < NBINS);
 	arena_mapbits_large_binind_set(chunk, pageind, binind);
 
-	assert(isalloc(ptr, false) == PAGE);
+	assert(isalloc(ptr, false) == LARGE_MINCLASS);
 	assert(isalloc(ptr, true) == size);
 }
 
 static void
 arena_dissociate_bin_run(arena_chunk_t *chunk, arena_run_t *run,
     arena_bin_t *bin)
 {
 
 	/* Dissociate run from bin. */
 	if (run == bin->runcur)
 		bin->runcur = NULL;
 	else {
-		size_t binind = arena_bin_index(chunk->arena, bin);
+		szind_t binind = arena_bin_index(extent_node_arena_get(
+		    &chunk->node), bin);
 		arena_bin_info_t *bin_info = &arena_bin_info[binind];
 
 		if (bin_info->nregs != 1) {
 			/*
 			 * This block's conditional is necessary because if the
 			 * run only contains one region, then it never gets
@@ -1797,52 +2430,21 @@
 }
 
 static void
 arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
     arena_bin_t *bin)
 {
-	size_t binind;
-	arena_bin_info_t *bin_info;
-	size_t npages, run_ind, past;
 
 	assert(run != bin->runcur);
-	assert(arena_run_tree_search(&bin->runs,
-	    arena_mapp_get(chunk, ((uintptr_t)run-(uintptr_t)chunk)>>LG_PAGE))
-	    == NULL);
-
-	binind = arena_bin_index(chunk->arena, run->bin);
-	bin_info = &arena_bin_info[binind];
+	assert(arena_run_tree_search(&bin->runs, arena_run_to_miscelm(run)) ==
+	    NULL);
 
 	malloc_mutex_unlock(&bin->lock);
 	/******************************/
-	npages = bin_info->run_size >> LG_PAGE;
-	run_ind = (size_t)(((uintptr_t)run - (uintptr_t)chunk) >> LG_PAGE);
-	past = (size_t)(PAGE_CEILING((uintptr_t)run +
-	    (uintptr_t)bin_info->reg0_offset + (uintptr_t)(run->nextind *
-	    bin_info->reg_interval - bin_info->redzone_size) -
-	    (uintptr_t)chunk) >> LG_PAGE);
 	malloc_mutex_lock(&arena->lock);
-
-	/*
-	 * If the run was originally clean, and some pages were never touched,
-	 * trim the clean pages before deallocating the dirty portion of the
-	 * run.
-	 */
-	assert(arena_mapbits_dirty_get(chunk, run_ind) ==
-	    arena_mapbits_dirty_get(chunk, run_ind+npages-1));
-	if (arena_mapbits_dirty_get(chunk, run_ind) == 0 && past - run_ind <
-	    npages) {
-		/* Trim clean pages.  Convert to large run beforehand. */
-		assert(npages > 0);
-		arena_mapbits_large_set(chunk, run_ind, bin_info->run_size, 0);
-		arena_mapbits_large_set(chunk, run_ind+npages-1, 0, 0);
-		arena_run_trim_tail(arena, chunk, run, (npages << LG_PAGE),
-		    ((past - run_ind) << LG_PAGE), false);
-		/* npages = past - run_ind; */
-	}
-	arena_run_dalloc(arena, run, true, false);
+	arena_run_dalloc_decommit(arena, chunk, run);
 	malloc_mutex_unlock(&arena->lock);
 	/****************************/
 	malloc_mutex_lock(&bin->lock);
 	if (config_stats)
 		bin->stats.curruns--;
 }
@@ -1865,216 +2467,273 @@
 		if (config_stats)
 			bin->stats.reruns++;
 	} else
 		arena_bin_runs_insert(bin, run);
 }
 
-void
-arena_dalloc_bin_locked(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    arena_chunk_map_t *mapelm)
+static void
+arena_dalloc_bin_locked_impl(arena_t *arena, arena_chunk_t *chunk, void *ptr,
+    arena_chunk_map_bits_t *bitselm, bool junked)
 {
-	size_t pageind;
+	size_t pageind, rpages_ind;
 	arena_run_t *run;
 	arena_bin_t *bin;
 	arena_bin_info_t *bin_info;
-	size_t size, binind;
+	szind_t binind;
 
 	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-	run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
-	    arena_mapbits_small_runind_get(chunk, pageind)) << LG_PAGE));
-	bin = run->bin;
-	binind = arena_ptr_small_binind_get(ptr, mapelm->bits);
+	rpages_ind = pageind - arena_mapbits_small_runind_get(chunk, pageind);
+	run = &arena_miscelm_get(chunk, rpages_ind)->run;
+	binind = run->binind;
+	bin = &arena->bins[binind];
 	bin_info = &arena_bin_info[binind];
-	if (config_fill || config_stats)
-		size = bin_info->reg_size;
 
-	if (config_fill && opt_junk)
+	if (!junked && config_fill && unlikely(opt_junk_free))
 		arena_dalloc_junk_small(ptr, bin_info);
 
 	arena_run_reg_dalloc(run, ptr);
 	if (run->nfree == bin_info->nregs) {
 		arena_dissociate_bin_run(chunk, run, bin);
 		arena_dalloc_bin_run(arena, chunk, run, bin);
 	} else if (run->nfree == 1 && run != bin->runcur)
 		arena_bin_lower_run(arena, chunk, run, bin);
 
 	if (config_stats) {
-		bin->stats.allocated -= size;
 		bin->stats.ndalloc++;
+		bin->stats.curregs--;
 	}
 }
 
 void
+arena_dalloc_bin_junked_locked(arena_t *arena, arena_chunk_t *chunk, void *ptr,
+    arena_chunk_map_bits_t *bitselm)
+{
+
+	arena_dalloc_bin_locked_impl(arena, chunk, ptr, bitselm, true);
+}
+
+void
 arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    size_t pageind, arena_chunk_map_t *mapelm)
+    size_t pageind, arena_chunk_map_bits_t *bitselm)
 {
 	arena_run_t *run;
 	arena_bin_t *bin;
+	size_t rpages_ind;
 
-	run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
-	    arena_mapbits_small_runind_get(chunk, pageind)) << LG_PAGE));
-	bin = run->bin;
+	rpages_ind = pageind - arena_mapbits_small_runind_get(chunk, pageind);
+	run = &arena_miscelm_get(chunk, rpages_ind)->run;
+	bin = &arena->bins[run->binind];
 	malloc_mutex_lock(&bin->lock);
-	arena_dalloc_bin_locked(arena, chunk, ptr, mapelm);
+	arena_dalloc_bin_locked_impl(arena, chunk, ptr, bitselm, false);
 	malloc_mutex_unlock(&bin->lock);
 }
 
 void
 arena_dalloc_small(arena_t *arena, arena_chunk_t *chunk, void *ptr,
     size_t pageind)
 {
-	arena_chunk_map_t *mapelm;
+	arena_chunk_map_bits_t *bitselm;
 
 	if (config_debug) {
 		/* arena_ptr_small_binind_get() does extra sanity checking. */
 		assert(arena_ptr_small_binind_get(ptr, arena_mapbits_get(chunk,
 		    pageind)) != BININD_INVALID);
 	}
-	mapelm = arena_mapp_get(chunk, pageind);
-	arena_dalloc_bin(arena, chunk, ptr, pageind, mapelm);
+	bitselm = arena_bitselm_get(chunk, pageind);
+	arena_dalloc_bin(arena, chunk, ptr, pageind, bitselm);
 }
 
 #ifdef JEMALLOC_JET
 #undef arena_dalloc_junk_large
 #define	arena_dalloc_junk_large JEMALLOC_N(arena_dalloc_junk_large_impl)
 #endif
-static void
+void
 arena_dalloc_junk_large(void *ptr, size_t usize)
 {
 
-	if (config_fill && opt_junk)
+	if (config_fill && unlikely(opt_junk_free))
 		memset(ptr, 0x5a, usize);
 }
 #ifdef JEMALLOC_JET
 #undef arena_dalloc_junk_large
 #define	arena_dalloc_junk_large JEMALLOC_N(arena_dalloc_junk_large)
 arena_dalloc_junk_large_t *arena_dalloc_junk_large =
     JEMALLOC_N(arena_dalloc_junk_large_impl);
 #endif
 
-void
-arena_dalloc_large_locked(arena_t *arena, arena_chunk_t *chunk, void *ptr)
+static void
+arena_dalloc_large_locked_impl(arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, bool junked)
 {
+	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
+	arena_chunk_map_misc_t *miscelm = arena_miscelm_get(chunk, pageind);
+	arena_run_t *run = &miscelm->run;
 
 	if (config_fill || config_stats) {
-		size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-		size_t usize = arena_mapbits_large_size_get(chunk, pageind);
+		size_t usize = arena_mapbits_large_size_get(chunk, pageind) -
+		    large_pad;
 
-		arena_dalloc_junk_large(ptr, usize);
+		if (!junked)
+			arena_dalloc_junk_large(ptr, usize);
 		if (config_stats) {
+			szind_t index = size2index(usize) - NBINS;
+
 			arena->stats.ndalloc_large++;
 			arena->stats.allocated_large -= usize;
-			arena->stats.lstats[(usize >> LG_PAGE) - 1].ndalloc++;
-			arena->stats.lstats[(usize >> LG_PAGE) - 1].curruns--;
+			arena->stats.lstats[index].ndalloc++;
+			arena->stats.lstats[index].curruns--;
 		}
 	}
 
-	arena_run_dalloc(arena, (arena_run_t *)ptr, true, false);
+	arena_run_dalloc_decommit(arena, chunk, run);
+}
+
+void
+arena_dalloc_large_junked_locked(arena_t *arena, arena_chunk_t *chunk,
+    void *ptr)
+{
+
+	arena_dalloc_large_locked_impl(arena, chunk, ptr, true);
 }
 
 void
 arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr)
 {
 
 	malloc_mutex_lock(&arena->lock);
-	arena_dalloc_large_locked(arena, chunk, ptr);
+	arena_dalloc_large_locked_impl(arena, chunk, ptr, false);
 	malloc_mutex_unlock(&arena->lock);
 }
 
 static void
 arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr,
     size_t oldsize, size_t size)
 {
+	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
+	arena_chunk_map_misc_t *miscelm = arena_miscelm_get(chunk, pageind);
+	arena_run_t *run = &miscelm->run;
 
 	assert(size < oldsize);
 
 	/*
 	 * Shrink the run, and make trailing pages available for other
 	 * allocations.
 	 */
 	malloc_mutex_lock(&arena->lock);
-	arena_run_trim_tail(arena, chunk, (arena_run_t *)ptr, oldsize, size,
-	    true);
+	arena_run_trim_tail(arena, chunk, run, oldsize + large_pad, size +
+	    large_pad, true);
 	if (config_stats) {
+		szind_t oldindex = size2index(oldsize) - NBINS;
+		szind_t index = size2index(size) - NBINS;
+
 		arena->stats.ndalloc_large++;
 		arena->stats.allocated_large -= oldsize;
-		arena->stats.lstats[(oldsize >> LG_PAGE) - 1].ndalloc++;
-		arena->stats.lstats[(oldsize >> LG_PAGE) - 1].curruns--;
+		arena->stats.lstats[oldindex].ndalloc++;
+		arena->stats.lstats[oldindex].curruns--;
 
 		arena->stats.nmalloc_large++;
 		arena->stats.nrequests_large++;
 		arena->stats.allocated_large += size;
-		arena->stats.lstats[(size >> LG_PAGE) - 1].nmalloc++;
-		arena->stats.lstats[(size >> LG_PAGE) - 1].nrequests++;
-		arena->stats.lstats[(size >> LG_PAGE) - 1].curruns++;
+		arena->stats.lstats[index].nmalloc++;
+		arena->stats.lstats[index].nrequests++;
+		arena->stats.lstats[index].curruns++;
 	}
 	malloc_mutex_unlock(&arena->lock);
 }
 
 static bool
 arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    size_t oldsize, size_t size, size_t extra, bool zero)
+    size_t oldsize, size_t usize_min, size_t usize_max, bool zero)
 {
 	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-	size_t npages = oldsize >> LG_PAGE;
+	size_t npages = (oldsize + large_pad) >> LG_PAGE;
 	size_t followsize;
 
-	assert(oldsize == arena_mapbits_large_size_get(chunk, pageind));
+	assert(oldsize == arena_mapbits_large_size_get(chunk, pageind) -
+	    large_pad);
 
 	/* Try to extend the run. */
-	assert(size + extra > oldsize);
 	malloc_mutex_lock(&arena->lock);
-	if (pageind + npages < chunk_npages &&
-	    arena_mapbits_allocated_get(chunk, pageind+npages) == 0 &&
-	    (followsize = arena_mapbits_unallocated_size_get(chunk,
-	    pageind+npages)) >= size - oldsize) {
+	if (pageind+npages >= chunk_npages || arena_mapbits_allocated_get(chunk,
+	    pageind+npages) != 0)
+		goto label_fail;
+	followsize = arena_mapbits_unallocated_size_get(chunk, pageind+npages);
+	if (oldsize + followsize >= usize_min) {
 		/*
 		 * The next run is available and sufficiently large.  Split the
 		 * following run, then merge the first part with the existing
 		 * allocation.
 		 */
-		size_t flag_dirty;
-		size_t splitsize = (oldsize + followsize <= size + extra)
-		    ? followsize : size + extra - oldsize;
-		arena_run_split_large(arena, (arena_run_t *)((uintptr_t)chunk +
-		    ((pageind+npages) << LG_PAGE)), splitsize, zero);
+		arena_run_t *run;
+		size_t usize, splitsize, size, flag_dirty, flag_unzeroed_mask;
+
+		usize = usize_max;
+		while (oldsize + followsize < usize)
+			usize = index2size(size2index(usize)-1);
+		assert(usize >= usize_min);
+		assert(usize >= oldsize);
+		splitsize = usize - oldsize;
+		if (splitsize == 0)
+			goto label_fail;
+
+		run = &arena_miscelm_get(chunk, pageind+npages)->run;
+		if (arena_run_split_large(arena, run, splitsize, zero))
+			goto label_fail;
+
+		if (config_cache_oblivious && zero) {
+			/*
+			 * Zero the trailing bytes of the original allocation's
+			 * last page, since they are in an indeterminate state.
+			 */
+			assert(PAGE_CEILING(oldsize) == oldsize);
+			memset((void *)((uintptr_t)ptr + oldsize), 0,
+			    PAGE_CEILING((uintptr_t)ptr) - (uintptr_t)ptr);
+		}
 
 		size = oldsize + splitsize;
-		npages = size >> LG_PAGE;
+		npages = (size + large_pad) >> LG_PAGE;
 
 		/*
 		 * Mark the extended run as dirty if either portion of the run
 		 * was dirty before allocation.  This is rather pedantic,
 		 * because there's not actually any sequence of events that
 		 * could cause the resulting run to be passed to
 		 * arena_run_dalloc() with the dirty argument set to false
 		 * (which is when dirty flag consistency would really matter).
 		 */
 		flag_dirty = arena_mapbits_dirty_get(chunk, pageind) |
 		    arena_mapbits_dirty_get(chunk, pageind+npages-1);
-		arena_mapbits_large_set(chunk, pageind, size, flag_dirty);
-		arena_mapbits_large_set(chunk, pageind+npages-1, 0, flag_dirty);
+		flag_unzeroed_mask = flag_dirty == 0 ? CHUNK_MAP_UNZEROED : 0;
+		arena_mapbits_large_set(chunk, pageind, size + large_pad,
+		    flag_dirty | (flag_unzeroed_mask &
+		    arena_mapbits_unzeroed_get(chunk, pageind)));
+		arena_mapbits_large_set(chunk, pageind+npages-1, 0, flag_dirty |
+		    (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk,
+		    pageind+npages-1)));
 
 		if (config_stats) {
+			szind_t oldindex = size2index(oldsize) - NBINS;
+			szind_t index = size2index(size) - NBINS;
+
 			arena->stats.ndalloc_large++;
 			arena->stats.allocated_large -= oldsize;
-			arena->stats.lstats[(oldsize >> LG_PAGE) - 1].ndalloc++;
-			arena->stats.lstats[(oldsize >> LG_PAGE) - 1].curruns--;
+			arena->stats.lstats[oldindex].ndalloc++;
+			arena->stats.lstats[oldindex].curruns--;
 
 			arena->stats.nmalloc_large++;
 			arena->stats.nrequests_large++;
 			arena->stats.allocated_large += size;
-			arena->stats.lstats[(size >> LG_PAGE) - 1].nmalloc++;
-			arena->stats.lstats[(size >> LG_PAGE) - 1].nrequests++;
-			arena->stats.lstats[(size >> LG_PAGE) - 1].curruns++;
+			arena->stats.lstats[index].nmalloc++;
+			arena->stats.lstats[index].nrequests++;
+			arena->stats.lstats[index].curruns++;
 		}
 		malloc_mutex_unlock(&arena->lock);
 		return (false);
 	}
+label_fail:
 	malloc_mutex_unlock(&arena->lock);
-
 	return (true);
 }
 
 #ifdef JEMALLOC_JET
 #undef arena_ralloc_junk_large
 #define	arena_ralloc_junk_large JEMALLOC_N(arena_ralloc_junk_large_impl)
@@ -2080,13 +2739,13 @@
 #define	arena_ralloc_junk_large JEMALLOC_N(arena_ralloc_junk_large_impl)
 #endif
 static void
 arena_ralloc_junk_large(void *ptr, size_t old_usize, size_t usize)
 {
 
-	if (config_fill && opt_junk) {
+	if (config_fill && unlikely(opt_junk_free)) {
 		memset((void *)((uintptr_t)ptr + usize), 0x5a,
 		    old_usize - usize);
 	}
 }
 #ifdef JEMALLOC_JET
 #undef arena_ralloc_junk_large
@@ -2097,137 +2756,138 @@
 
 /*
  * Try to resize a large allocation, in order to avoid copying.  This will
  * always fail if growing an object, and the following run is already in use.
  */
 static bool
-arena_ralloc_large(void *ptr, size_t oldsize, size_t size, size_t extra,
-    bool zero)
+arena_ralloc_large(void *ptr, size_t oldsize, size_t usize_min,
+    size_t usize_max, bool zero)
 {
-	size_t psize;
+	arena_chunk_t *chunk;
+	arena_t *arena;
 
-	psize = PAGE_CEILING(size + extra);
-	if (psize == oldsize) {
-		/* Same size class. */
+	if (oldsize == usize_max) {
+		/* Current size class is compatible and maximal. */
 		return (false);
-	} else {
-		arena_chunk_t *chunk;
-		arena_t *arena;
+	}
 
-		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-		arena = chunk->arena;
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+	arena = extent_node_arena_get(&chunk->node);
 
-		if (psize < oldsize) {
-			/* Fill before shrinking in order avoid a race. */
-			arena_ralloc_junk_large(ptr, oldsize, psize);
-			arena_ralloc_large_shrink(arena, chunk, ptr, oldsize,
-			    psize);
-			return (false);
-		} else {
-			bool ret = arena_ralloc_large_grow(arena, chunk, ptr,
-			    oldsize, PAGE_CEILING(size),
-			    psize - PAGE_CEILING(size), zero);
-			if (config_fill && ret == false && zero == false) {
-				if (opt_junk) {
-					memset((void *)((uintptr_t)ptr +
-					    oldsize), 0xa5, isalloc(ptr,
-					    config_prof) - oldsize);
-				} else if (opt_zero) {
-					memset((void *)((uintptr_t)ptr +
-					    oldsize), 0, isalloc(ptr,
-					    config_prof) - oldsize);
-				}
+	if (oldsize < usize_max) {
+		bool ret = arena_ralloc_large_grow(arena, chunk, ptr, oldsize,
+		    usize_min, usize_max, zero);
+		if (config_fill && !ret && !zero) {
+			if (unlikely(opt_junk_alloc)) {
+				memset((void *)((uintptr_t)ptr + oldsize), 0xa5,
+				    isalloc(ptr, config_prof) - oldsize);
+			} else if (unlikely(opt_zero)) {
+				memset((void *)((uintptr_t)ptr + oldsize), 0,
+				    isalloc(ptr, config_prof) - oldsize);
 			}
-			return (ret);
 		}
+		return (ret);
 	}
+
+	assert(oldsize > usize_max);
+	/* Fill before shrinking in order avoid a race. */
+	arena_ralloc_junk_large(ptr, oldsize, usize_max);
+	arena_ralloc_large_shrink(arena, chunk, ptr, oldsize, usize_max);
+	return (false);
 }
 
 bool
 arena_ralloc_no_move(void *ptr, size_t oldsize, size_t size, size_t extra,
     bool zero)
 {
+	size_t usize_min, usize_max;
 
-	/*
-	 * Avoid moving the allocation if the size class can be left the same.
-	 */
-	if (oldsize <= arena_maxclass) {
+	usize_min = s2u(size);
+	usize_max = s2u(size + extra);
+	if (likely(oldsize <= large_maxclass && usize_min <= large_maxclass)) {
+		/*
+		 * Avoid moving the allocation if the size class can be left the
+		 * same.
+		 */
 		if (oldsize <= SMALL_MAXCLASS) {
-			assert(arena_bin_info[SMALL_SIZE2BIN(oldsize)].reg_size
-			    == oldsize);
-			if ((size + extra <= SMALL_MAXCLASS &&
-			    SMALL_SIZE2BIN(size + extra) ==
-			    SMALL_SIZE2BIN(oldsize)) || (size <= oldsize &&
-			    size + extra >= oldsize))
+			assert(arena_bin_info[size2index(oldsize)].reg_size ==
+			    oldsize);
+			if ((usize_max <= SMALL_MAXCLASS &&
+			    size2index(usize_max) == size2index(oldsize)) ||
+			    (size <= oldsize && usize_max >= oldsize))
 				return (false);
 		} else {
-			assert(size <= arena_maxclass);
-			if (size + extra > SMALL_MAXCLASS) {
-				if (arena_ralloc_large(ptr, oldsize, size,
-				    extra, zero) == false)
+			if (usize_max > SMALL_MAXCLASS) {
+				if (!arena_ralloc_large(ptr, oldsize, usize_min,
+				    usize_max, zero))
 					return (false);
 			}
 		}
+
+		/* Reallocation would require a move. */
+		return (true);
+	} else {
+		return (huge_ralloc_no_move(ptr, oldsize, usize_min, usize_max,
+		    zero));
 	}
+}
 
-	/* Reallocation would require a move. */
-	return (true);
+static void *
+arena_ralloc_move_helper(tsd_t *tsd, arena_t *arena, size_t usize,
+    size_t alignment, bool zero, tcache_t *tcache)
+{
+
+	if (alignment == 0)
+		return (arena_malloc(tsd, arena, usize, zero, tcache));
+	usize = sa2u(usize, alignment);
+	if (usize == 0)
+		return (NULL);
+	return (ipalloct(tsd, usize, alignment, zero, tcache, arena));
 }
 
 void *
-arena_ralloc(arena_t *arena, void *ptr, size_t oldsize, size_t size,
-    size_t extra, size_t alignment, bool zero, bool try_tcache_alloc,
-    bool try_tcache_dalloc)
+arena_ralloc(tsd_t *tsd, arena_t *arena, void *ptr, size_t oldsize, size_t size,
+    size_t alignment, bool zero, tcache_t *tcache)
 {
 	void *ret;
-	size_t copysize;
+	size_t usize;
 
-	/* Try to avoid moving the allocation. */
-	if (arena_ralloc_no_move(ptr, oldsize, size, extra, zero) == false)
-		return (ptr);
+	usize = s2u(size);
+	if (usize == 0)
+		return (NULL);
 
-	/*
-	 * size and oldsize are different enough that we need to move the
-	 * object.  In that case, fall back to allocating new space and
-	 * copying.
-	 */
-	if (alignment != 0) {
-		size_t usize = sa2u(size + extra, alignment);
-		if (usize == 0)
-			return (NULL);
-		ret = ipalloct(usize, alignment, zero, try_tcache_alloc, arena);
-	} else
-		ret = arena_malloc(arena, size + extra, zero, try_tcache_alloc);
+	if (likely(usize <= large_maxclass)) {
+		size_t copysize;
 
-	if (ret == NULL) {
-		if (extra == 0)
-			return (NULL);
-		/* Try again, this time without extra. */
-		if (alignment != 0) {
-			size_t usize = sa2u(size, alignment);
-			if (usize == 0)
-				return (NULL);
-			ret = ipalloct(usize, alignment, zero, try_tcache_alloc,
-			    arena);
-		} else
-			ret = arena_malloc(arena, size, zero, try_tcache_alloc);
+		/* Try to avoid moving the allocation. */
+		if (!arena_ralloc_no_move(ptr, oldsize, usize, 0, zero))
+			return (ptr);
 
+		/*
+		 * size and oldsize are different enough that we need to move
+		 * the object.  In that case, fall back to allocating new space
+		 * and copying.
+		 */
+		ret = arena_ralloc_move_helper(tsd, arena, usize, alignment,
+		    zero, tcache);
 		if (ret == NULL)
 			return (NULL);
-	}
 
-	/* Junk/zero-filling were already done by ipalloc()/arena_malloc(). */
+		/*
+		 * Junk/zero-filling were already done by
+		 * ipalloc()/arena_malloc().
+		 */
 
-	/*
-	 * Copy at most size bytes (not size+extra), since the caller has no
-	 * expectation that the extra bytes will be reliably preserved.
-	 */
-	copysize = (size < oldsize) ? size : oldsize;
-	VALGRIND_MAKE_MEM_UNDEFINED(ret, copysize);
-	memcpy(ret, ptr, copysize);
-	iqalloct(ptr, try_tcache_dalloc);
+		copysize = (usize < oldsize) ? usize : oldsize;
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, copysize);
+		memcpy(ret, ptr, copysize);
+		isqalloc(tsd, ptr, oldsize, tcache);
+	} else {
+		ret = huge_ralloc(tsd, arena, ptr, oldsize, usize, alignment,
+		    zero, tcache);
+	}
 	return (ret);
 }
 
 dss_prec_t
 arena_dss_prec_get(arena_t *arena)
 {
@@ -2236,157 +2896,226 @@
 	malloc_mutex_lock(&arena->lock);
 	ret = arena->dss_prec;
 	malloc_mutex_unlock(&arena->lock);
 	return (ret);
 }
 
-void
+bool
 arena_dss_prec_set(arena_t *arena, dss_prec_t dss_prec)
 {
 
+	if (!have_dss)
+		return (dss_prec != dss_prec_disabled);
 	malloc_mutex_lock(&arena->lock);
 	arena->dss_prec = dss_prec;
 	malloc_mutex_unlock(&arena->lock);
+	return (false);
+}
+
+ssize_t
+arena_lg_dirty_mult_default_get(void)
+{
+
+	return ((ssize_t)atomic_read_z((size_t *)&lg_dirty_mult_default));
+}
+
+bool
+arena_lg_dirty_mult_default_set(ssize_t lg_dirty_mult)
+{
+
+	if (!arena_lg_dirty_mult_valid(lg_dirty_mult))
+		return (true);
+	atomic_write_z((size_t *)&lg_dirty_mult_default, (size_t)lg_dirty_mult);
+	return (false);
 }
 
 void
-arena_stats_merge(arena_t *arena, const char **dss, size_t *nactive,
-    size_t *ndirty, arena_stats_t *astats, malloc_bin_stats_t *bstats,
-    malloc_large_stats_t *lstats)
+arena_stats_merge(arena_t *arena, const char **dss, ssize_t *lg_dirty_mult,
+    size_t *nactive, size_t *ndirty, arena_stats_t *astats,
+    malloc_bin_stats_t *bstats, malloc_large_stats_t *lstats,
+    malloc_huge_stats_t *hstats)
 {
 	unsigned i;
 
 	malloc_mutex_lock(&arena->lock);
 	*dss = dss_prec_names[arena->dss_prec];
+	*lg_dirty_mult = arena->lg_dirty_mult;
 	*nactive += arena->nactive;
 	*ndirty += arena->ndirty;
 
 	astats->mapped += arena->stats.mapped;
 	astats->npurge += arena->stats.npurge;
 	astats->nmadvise += arena->stats.nmadvise;
 	astats->purged += arena->stats.purged;
+	astats->metadata_mapped += arena->stats.metadata_mapped;
+	astats->metadata_allocated += arena_metadata_allocated_get(arena);
 	astats->allocated_large += arena->stats.allocated_large;
 	astats->nmalloc_large += arena->stats.nmalloc_large;
 	astats->ndalloc_large += arena->stats.ndalloc_large;
 	astats->nrequests_large += arena->stats.nrequests_large;
+	astats->allocated_huge += arena->stats.allocated_huge;
+	astats->nmalloc_huge += arena->stats.nmalloc_huge;
+	astats->ndalloc_huge += arena->stats.ndalloc_huge;
 
 	for (i = 0; i < nlclasses; i++) {
 		lstats[i].nmalloc += arena->stats.lstats[i].nmalloc;
 		lstats[i].ndalloc += arena->stats.lstats[i].ndalloc;
 		lstats[i].nrequests += arena->stats.lstats[i].nrequests;
 		lstats[i].curruns += arena->stats.lstats[i].curruns;
 	}
+
+	for (i = 0; i < nhclasses; i++) {
+		hstats[i].nmalloc += arena->stats.hstats[i].nmalloc;
+		hstats[i].ndalloc += arena->stats.hstats[i].ndalloc;
+		hstats[i].curhchunks += arena->stats.hstats[i].curhchunks;
+	}
 	malloc_mutex_unlock(&arena->lock);
 
 	for (i = 0; i < NBINS; i++) {
 		arena_bin_t *bin = &arena->bins[i];
 
 		malloc_mutex_lock(&bin->lock);
-		bstats[i].allocated += bin->stats.allocated;
 		bstats[i].nmalloc += bin->stats.nmalloc;
 		bstats[i].ndalloc += bin->stats.ndalloc;
 		bstats[i].nrequests += bin->stats.nrequests;
+		bstats[i].curregs += bin->stats.curregs;
 		if (config_tcache) {
 			bstats[i].nfills += bin->stats.nfills;
 			bstats[i].nflushes += bin->stats.nflushes;
 		}
 		bstats[i].nruns += bin->stats.nruns;
 		bstats[i].reruns += bin->stats.reruns;
 		bstats[i].curruns += bin->stats.curruns;
 		malloc_mutex_unlock(&bin->lock);
 	}
 }
 
-bool
-arena_new(arena_t *arena, unsigned ind)
+arena_t *
+arena_new(unsigned ind)
 {
+	arena_t *arena;
 	unsigned i;
 	arena_bin_t *bin;
 
+	/*
+	 * Allocate arena, arena->lstats, and arena->hstats contiguously, mainly
+	 * because there is no way to clean up if base_alloc() OOMs.
+	 */
+	if (config_stats) {
+		arena = (arena_t *)base_alloc(CACHELINE_CEILING(sizeof(arena_t))
+		    + QUANTUM_CEILING(nlclasses * sizeof(malloc_large_stats_t) +
+		    nhclasses) * sizeof(malloc_huge_stats_t));
+	} else
+		arena = (arena_t *)base_alloc(sizeof(arena_t));
+	if (arena == NULL)
+		return (NULL);
+
 	arena->ind = ind;
 	arena->nthreads = 0;
-
 	if (malloc_mutex_init(&arena->lock))
-		return (true);
+		return (NULL);
 
 	if (config_stats) {
 		memset(&arena->stats, 0, sizeof(arena_stats_t));
-		arena->stats.lstats =
-		    (malloc_large_stats_t *)base_alloc(nlclasses *
-		    sizeof(malloc_large_stats_t));
-		if (arena->stats.lstats == NULL)
-			return (true);
+		arena->stats.lstats = (malloc_large_stats_t *)((uintptr_t)arena
+		    + CACHELINE_CEILING(sizeof(arena_t)));
 		memset(arena->stats.lstats, 0, nlclasses *
 		    sizeof(malloc_large_stats_t));
+		arena->stats.hstats = (malloc_huge_stats_t *)((uintptr_t)arena
+		    + CACHELINE_CEILING(sizeof(arena_t)) +
+		    QUANTUM_CEILING(nlclasses * sizeof(malloc_large_stats_t)));
+		memset(arena->stats.hstats, 0, nhclasses *
+		    sizeof(malloc_huge_stats_t));
 		if (config_tcache)
 			ql_new(&arena->tcache_ql);
 	}
 
 	if (config_prof)
 		arena->prof_accumbytes = 0;
 
+	if (config_cache_oblivious) {
+		/*
+		 * A nondeterministic seed based on the address of arena reduces
+		 * the likelihood of lockstep non-uniform cache index
+		 * utilization among identical concurrent processes, but at the
+		 * cost of test repeatability.  For debug builds, instead use a
+		 * deterministic seed.
+		 */
+		arena->offset_state = config_debug ? ind :
+		    (uint64_t)(uintptr_t)arena;
+	}
+
 	arena->dss_prec = chunk_dss_prec_get();
 
-	/* Initialize chunks. */
-	arena_chunk_dirty_new(&arena->chunks_dirty);
 	arena->spare = NULL;
 
+	arena->lg_dirty_mult = arena_lg_dirty_mult_default_get();
+	arena->purging = false;
 	arena->nactive = 0;
 	arena->ndirty = 0;
-	arena->npurgatory = 0;
 
 	arena_avail_tree_new(&arena->runs_avail);
+	qr_new(&arena->runs_dirty, rd_link);
+	qr_new(&arena->chunks_cache, cc_link);
+
+	ql_new(&arena->huge);
+	if (malloc_mutex_init(&arena->huge_mtx))
+		return (NULL);
+
+	extent_tree_szad_new(&arena->chunks_szad_cached);
+	extent_tree_ad_new(&arena->chunks_ad_cached);
+	extent_tree_szad_new(&arena->chunks_szad_retained);
+	extent_tree_ad_new(&arena->chunks_ad_retained);
+	if (malloc_mutex_init(&arena->chunks_mtx))
+		return (NULL);
+	ql_new(&arena->node_cache);
+	if (malloc_mutex_init(&arena->node_cache_mtx))
+		return (NULL);
+
+	arena->chunk_hooks = chunk_hooks_default;
 
 	/* Initialize bins. */
 	for (i = 0; i < NBINS; i++) {
 		bin = &arena->bins[i];
 		if (malloc_mutex_init(&bin->lock))
-			return (true);
+			return (NULL);
 		bin->runcur = NULL;
 		arena_run_tree_new(&bin->runs);
 		if (config_stats)
 			memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
 	}
 
-	return (false);
+	return (arena);
 }
 
 /*
  * Calculate bin_info->run_size such that it meets the following constraints:
  *
- *   *) bin_info->run_size >= min_run_size
- *   *) bin_info->run_size <= arena_maxclass
- *   *) run header overhead <= RUN_MAX_OVRHD (or header overhead relaxed).
+ *   *) bin_info->run_size <= arena_maxrun
  *   *) bin_info->nregs <= RUN_MAXREGS
  *
- * bin_info->nregs, bin_info->bitmap_offset, and bin_info->reg0_offset are also
- * calculated here, since these settings are all interdependent.
+ * bin_info->nregs and bin_info->reg0_offset are also calculated here, since
+ * these settings are all interdependent.
  */
-static size_t
-bin_info_run_size_calc(arena_bin_info_t *bin_info, size_t min_run_size)
+static void
+bin_info_run_size_calc(arena_bin_info_t *bin_info)
 {
 	size_t pad_size;
-	size_t try_run_size, good_run_size;
-	uint32_t try_nregs, good_nregs;
-	uint32_t try_hdr_size, good_hdr_size;
-	uint32_t try_bitmap_offset, good_bitmap_offset;
-	uint32_t try_ctx0_offset, good_ctx0_offset;
-	uint32_t try_redzone0_offset, good_redzone0_offset;
-
-	assert(min_run_size >= PAGE);
-	assert(min_run_size <= arena_maxclass);
+	size_t try_run_size, perfect_run_size, actual_run_size;
+	uint32_t try_nregs, perfect_nregs, actual_nregs;
 
 	/*
 	 * Determine redzone size based on minimum alignment and minimum
 	 * redzone size.  Add padding to the end of the run if it is needed to
 	 * align the regions.  The padding allows each redzone to be half the
 	 * minimum alignment; without the padding, each redzone would have to
 	 * be twice as large in order to maintain alignment.
 	 */
-	if (config_fill && opt_redzone) {
-		size_t align_min = ZU(1) << (ffs(bin_info->reg_size) - 1);
+	if (config_fill && unlikely(opt_redzone)) {
+		size_t align_min = ZU(1) << (jemalloc_ffs(bin_info->reg_size) -
+		    1);
 		if (align_min <= REDZONE_MINSIZE) {
 			bin_info->redzone_size = REDZONE_MINSIZE;
 			pad_size = 0;
 		} else {
 			bin_info->redzone_size = align_min >> 1;
 			pad_size = bin_info->redzone_size;
@@ -2396,133 +3125,119 @@
 		pad_size = 0;
 	}
 	bin_info->reg_interval = bin_info->reg_size +
 	    (bin_info->redzone_size << 1);
 
 	/*
-	 * Calculate known-valid settings before entering the run_size
-	 * expansion loop, so that the first part of the loop always copies
-	 * valid settings.
-	 *
-	 * The do..while loop iteratively reduces the number of regions until
-	 * the run header and the regions no longer overlap.  A closed formula
-	 * would be quite messy, since there is an interdependency between the
-	 * header's mask length and the number of regions.
-	 */
-	try_run_size = min_run_size;
-	try_nregs = ((try_run_size - sizeof(arena_run_t)) /
-	    bin_info->reg_interval)
-	    + 1; /* Counter-act try_nregs-- in loop. */
-	if (try_nregs > RUN_MAXREGS) {
-		try_nregs = RUN_MAXREGS
-		    + 1; /* Counter-act try_nregs-- in loop. */
-	}
-	do {
-		try_nregs--;
-		try_hdr_size = sizeof(arena_run_t);
-		/* Pad to a long boundary. */
-		try_hdr_size = LONG_CEILING(try_hdr_size);
-		try_bitmap_offset = try_hdr_size;
-		/* Add space for bitmap. */
-		try_hdr_size += bitmap_size(try_nregs);
-		if (config_prof && opt_prof && prof_promote == false) {
-			/* Pad to a quantum boundary. */
-			try_hdr_size = QUANTUM_CEILING(try_hdr_size);
-			try_ctx0_offset = try_hdr_size;
-			/* Add space for one (prof_ctx_t *) per region. */
-			try_hdr_size += try_nregs * sizeof(prof_ctx_t *);
-		} else
-			try_ctx0_offset = 0;
-		try_redzone0_offset = try_run_size - (try_nregs *
-		    bin_info->reg_interval) - pad_size;
-	} while (try_hdr_size > try_redzone0_offset);
-
-	/* run_size expansion loop. */
+	 * Compute run size under ideal conditions (no redzones, no limit on run
+	 * size).
+	 */
+	try_run_size = PAGE;
+	try_nregs = try_run_size / bin_info->reg_size;
 	do {
-		/*
-		 * Copy valid settings before trying more aggressive settings.
-		 */
-		good_run_size = try_run_size;
-		good_nregs = try_nregs;
-		good_hdr_size = try_hdr_size;
-		good_bitmap_offset = try_bitmap_offset;
-		good_ctx0_offset = try_ctx0_offset;
-		good_redzone0_offset = try_redzone0_offset;
+		perfect_run_size = try_run_size;
+		perfect_nregs = try_nregs;
 
-		/* Try more aggressive settings. */
 		try_run_size += PAGE;
-		try_nregs = ((try_run_size - sizeof(arena_run_t) - pad_size) /
-		    bin_info->reg_interval)
-		    + 1; /* Counter-act try_nregs-- in loop. */
-		if (try_nregs > RUN_MAXREGS) {
-			try_nregs = RUN_MAXREGS
-			    + 1; /* Counter-act try_nregs-- in loop. */
-		}
-		do {
-			try_nregs--;
-			try_hdr_size = sizeof(arena_run_t);
-			/* Pad to a long boundary. */
-			try_hdr_size = LONG_CEILING(try_hdr_size);
-			try_bitmap_offset = try_hdr_size;
-			/* Add space for bitmap. */
-			try_hdr_size += bitmap_size(try_nregs);
-			if (config_prof && opt_prof && prof_promote == false) {
-				/* Pad to a quantum boundary. */
-				try_hdr_size = QUANTUM_CEILING(try_hdr_size);
-				try_ctx0_offset = try_hdr_size;
-				/*
-				 * Add space for one (prof_ctx_t *) per region.
-				 */
-				try_hdr_size += try_nregs *
-				    sizeof(prof_ctx_t *);
-			}
-			try_redzone0_offset = try_run_size - (try_nregs *
-			    bin_info->reg_interval) - pad_size;
-		} while (try_hdr_size > try_redzone0_offset);
-	} while (try_run_size <= arena_maxclass
-	    && RUN_MAX_OVRHD * (bin_info->reg_interval << 3) >
-	    RUN_MAX_OVRHD_RELAX
-	    && (try_redzone0_offset << RUN_BFP) > RUN_MAX_OVRHD * try_run_size
-	    && try_nregs < RUN_MAXREGS);
+		try_nregs = try_run_size / bin_info->reg_size;
+	} while (perfect_run_size != perfect_nregs * bin_info->reg_size);
+	assert(perfect_nregs <= RUN_MAXREGS);
+
+	actual_run_size = perfect_run_size;
+	actual_nregs = (actual_run_size - pad_size) / bin_info->reg_interval;
+
+	/*
+	 * Redzones can require enough padding that not even a single region can
+	 * fit within the number of pages that would normally be dedicated to a
+	 * run for this size class.  Increase the run size until at least one
+	 * region fits.
+	 */
+	while (actual_nregs == 0) {
+		assert(config_fill && unlikely(opt_redzone));
+
+		actual_run_size += PAGE;
+		actual_nregs = (actual_run_size - pad_size) /
+		    bin_info->reg_interval;
+	}
 
-	assert(good_hdr_size <= good_redzone0_offset);
+	/*
+	 * Make sure that the run will fit within an arena chunk.
+	 */
+	while (actual_run_size > arena_maxrun) {
+		actual_run_size -= PAGE;
+		actual_nregs = (actual_run_size - pad_size) /
+		    bin_info->reg_interval;
+	}
+	assert(actual_nregs > 0);
+	assert(actual_run_size == s2u(actual_run_size));
 
 	/* Copy final settings. */
-	bin_info->run_size = good_run_size;
-	bin_info->nregs = good_nregs;
-	bin_info->bitmap_offset = good_bitmap_offset;
-	bin_info->ctx0_offset = good_ctx0_offset;
-	bin_info->reg0_offset = good_redzone0_offset + bin_info->redzone_size;
+	bin_info->run_size = actual_run_size;
+	bin_info->nregs = actual_nregs;
+	bin_info->reg0_offset = actual_run_size - (actual_nregs *
+	    bin_info->reg_interval) - pad_size + bin_info->redzone_size;
+
+	if (actual_run_size > small_maxrun)
+		small_maxrun = actual_run_size;
 
 	assert(bin_info->reg0_offset - bin_info->redzone_size + (bin_info->nregs
 	    * bin_info->reg_interval) + pad_size == bin_info->run_size);
-
-	return (good_run_size);
 }
 
 static void
 bin_info_init(void)
 {
 	arena_bin_info_t *bin_info;
-	size_t prev_run_size = PAGE;
 
-#define	SIZE_CLASS(bin, delta, size)					\
-	bin_info = &arena_bin_info[bin];				\
+#define	BIN_INFO_INIT_bin_yes(index, size)				\
+	bin_info = &arena_bin_info[index];				\
 	bin_info->reg_size = size;					\
-	prev_run_size = bin_info_run_size_calc(bin_info, prev_run_size);\
+	bin_info_run_size_calc(bin_info);				\
 	bitmap_info_init(&bin_info->bitmap_info, bin_info->nregs);
+#define	BIN_INFO_INIT_bin_no(index, size)
+#define	SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup)	\
+	BIN_INFO_INIT_bin_##bin(index, (ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta))
 	SIZE_CLASSES
-#undef SIZE_CLASS
+#undef BIN_INFO_INIT_bin_yes
+#undef BIN_INFO_INIT_bin_no
+#undef SC
 }
 
-void
+static bool
+small_run_size_init(void)
+{
+
+	assert(small_maxrun != 0);
+
+	small_run_tab = (bool *)base_alloc(sizeof(bool) * (small_maxrun >>
+	    LG_PAGE));
+	if (small_run_tab == NULL)
+		return (true);
+
+#define	TAB_INIT_bin_yes(index, size) {					\
+		arena_bin_info_t *bin_info = &arena_bin_info[index];	\
+		small_run_tab[bin_info->run_size >> LG_PAGE] = true;	\
+	}
+#define	TAB_INIT_bin_no(index, size)
+#define	SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup)	\
+	TAB_INIT_bin_##bin(index, (ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta))
+	SIZE_CLASSES
+#undef TAB_INIT_bin_yes
+#undef TAB_INIT_bin_no
+#undef SC
+
+	return (false);
+}
+
+bool
 arena_boot(void)
 {
-	size_t header_size;
 	unsigned i;
 
+	arena_lg_dirty_mult_default_set(opt_lg_dirty_mult);
+
 	/*
 	 * Compute the header size such that it is large enough to contain the
 	 * page map.  The page map is biased to omit entries for the header
 	 * itself, so some iteration is necessary to compute the map bias.
 	 *
 	 * 1) Compute safe header_size and map_bias values that include enough
@@ -2531,47 +3246,73 @@
 	 *    map.  The resulting map_bias may be one too small.
 	 * 3) Refine map_bias based on (2).  The result will be >= the result
 	 *    from (2), and will always be correct.
 	 */
 	map_bias = 0;
 	for (i = 0; i < 3; i++) {
-		header_size = offsetof(arena_chunk_t, map) +
-		    (sizeof(arena_chunk_map_t) * (chunk_npages-map_bias));
-		map_bias = (header_size >> LG_PAGE) + ((header_size & PAGE_MASK)
-		    != 0);
+		size_t header_size = offsetof(arena_chunk_t, map_bits) +
+		    ((sizeof(arena_chunk_map_bits_t) +
+		    sizeof(arena_chunk_map_misc_t)) * (chunk_npages-map_bias));
+		map_bias = (header_size + PAGE_MASK) >> LG_PAGE;
 	}
 	assert(map_bias > 0);
 
-	arena_maxclass = chunksize - (map_bias << LG_PAGE);
+	map_misc_offset = offsetof(arena_chunk_t, map_bits) +
+	    sizeof(arena_chunk_map_bits_t) * (chunk_npages-map_bias);
+
+	arena_maxrun = chunksize - (map_bias << LG_PAGE);
+	assert(arena_maxrun > 0);
+	large_maxclass = index2size(size2index(chunksize)-1);
+	if (large_maxclass > arena_maxrun) {
+		/*
+		 * For small chunk sizes it's possible for there to be fewer
+		 * non-header pages available than are necessary to serve the
+		 * size classes just below chunksize.
+		 */
+		large_maxclass = arena_maxrun;
+	}
+	assert(large_maxclass > 0);
+	nlclasses = size2index(large_maxclass) - size2index(SMALL_MAXCLASS);
+	nhclasses = NSIZES - nlclasses - NBINS;
 
 	bin_info_init();
+	return (small_run_size_init());
 }
 
 void
 arena_prefork(arena_t *arena)
 {
 	unsigned i;
 
 	malloc_mutex_prefork(&arena->lock);
+	malloc_mutex_prefork(&arena->huge_mtx);
+	malloc_mutex_prefork(&arena->chunks_mtx);
+	malloc_mutex_prefork(&arena->node_cache_mtx);
 	for (i = 0; i < NBINS; i++)
 		malloc_mutex_prefork(&arena->bins[i].lock);
 }
 
 void
 arena_postfork_parent(arena_t *arena)
 {
 	unsigned i;
 
 	for (i = 0; i < NBINS; i++)
 		malloc_mutex_postfork_parent(&arena->bins[i].lock);
+	malloc_mutex_postfork_parent(&arena->node_cache_mtx);
+	malloc_mutex_postfork_parent(&arena->chunks_mtx);
+	malloc_mutex_postfork_parent(&arena->huge_mtx);
 	malloc_mutex_postfork_parent(&arena->lock);
 }
 
 void
 arena_postfork_child(arena_t *arena)
 {
 	unsigned i;
 
 	for (i = 0; i < NBINS; i++)
 		malloc_mutex_postfork_child(&arena->bins[i].lock);
+	malloc_mutex_postfork_child(&arena->node_cache_mtx);
+	malloc_mutex_postfork_child(&arena->chunks_mtx);
+	malloc_mutex_postfork_child(&arena->huge_mtx);
 	malloc_mutex_postfork_child(&arena->lock);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.d	2017-09-27 22:47:55.622963386 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.d	2017-09-27 22:49:18.278960357 +0800
@@ -1,20 +1,21 @@
 src/arena.o: src/arena.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.d	2017-09-27 22:47:55.706963383 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.d	2017-09-27 22:49:18.370960353 +0800
@@ -1,20 +1,21 @@
 src/atomic.o: src/atomic.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.c	2016-05-06 15:11:36.000000000 +0800
@@ -2,123 +2,155 @@
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 /* Data. */
 
 static malloc_mutex_t	base_mtx;
-
-/*
- * Current pages that are being used for internal memory allocations.  These
- * pages are carved up in cacheline-size quanta, so that there is no chance of
- * false cache line sharing.
- */
-static void		*base_pages;
-static void		*base_next_addr;
-static void		*base_past_addr; /* Addr immediately past base_pages. */
+static extent_tree_t	base_avail_szad;
 static extent_node_t	*base_nodes;
-
-/******************************************************************************/
-/* Function prototypes for non-inline static functions. */
-
-static bool	base_pages_alloc(size_t minsize);
+static size_t		base_allocated;
+static size_t		base_resident;
+static size_t		base_mapped;
 
 /******************************************************************************/
 
-static bool
-base_pages_alloc(size_t minsize)
+/* base_mtx must be held. */
+static extent_node_t *
+base_node_try_alloc(void)
 {
-	size_t csize;
-	bool zero;
+	extent_node_t *node;
 
-	assert(minsize != 0);
-	csize = CHUNK_CEILING(minsize);
-	zero = false;
-	base_pages = chunk_alloc(csize, chunksize, true, &zero,
-	    chunk_dss_prec_get());
-	if (base_pages == NULL)
-		return (true);
-	base_next_addr = base_pages;
-	base_past_addr = (void *)((uintptr_t)base_pages + csize);
-
-	return (false);
+	if (base_nodes == NULL)
+		return (NULL);
+	node = base_nodes;
+	base_nodes = *(extent_node_t **)node;
+	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, sizeof(extent_node_t));
+	return (node);
 }
 
-void *
-base_alloc(size_t size)
+/* base_mtx must be held. */
+static void
+base_node_dalloc(extent_node_t *node)
 {
-	void *ret;
-	size_t csize;
 
-	/* Round size up to nearest multiple of the cacheline size. */
-	csize = CACHELINE_CEILING(size);
+	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, sizeof(extent_node_t));
+	*(extent_node_t **)node = base_nodes;
+	base_nodes = node;
+}
 
-	malloc_mutex_lock(&base_mtx);
-	/* Make sure there's enough space for the allocation. */
-	if ((uintptr_t)base_next_addr + csize > (uintptr_t)base_past_addr) {
-		if (base_pages_alloc(csize)) {
-			malloc_mutex_unlock(&base_mtx);
-			return (NULL);
+/* base_mtx must be held. */
+static extent_node_t *
+base_chunk_alloc(size_t minsize)
+{
+	extent_node_t *node;
+	size_t csize, nsize;
+	void *addr;
+
+	assert(minsize != 0);
+	node = base_node_try_alloc();
+	/* Allocate enough space to also carve a node out if necessary. */
+	nsize = (node == NULL) ? CACHELINE_CEILING(sizeof(extent_node_t)) : 0;
+	csize = CHUNK_CEILING(minsize + nsize);
+	addr = chunk_alloc_base(csize);
+	if (addr == NULL) {
+		if (node != NULL)
+			base_node_dalloc(node);
+		return (NULL);
+	}
+	base_mapped += csize;
+	if (node == NULL) {
+		node = (extent_node_t *)addr;
+		addr = (void *)((uintptr_t)addr + nsize);
+		csize -= nsize;
+		if (config_stats) {
+			base_allocated += nsize;
+			base_resident += PAGE_CEILING(nsize);
 		}
 	}
-	/* Allocate. */
-	ret = base_next_addr;
-	base_next_addr = (void *)((uintptr_t)base_next_addr + csize);
-	malloc_mutex_unlock(&base_mtx);
-	VALGRIND_MAKE_MEM_UNDEFINED(ret, csize);
-
-	return (ret);
+	extent_node_init(node, NULL, addr, csize, true, true);
+	return (node);
 }
 
+/*
+ * base_alloc() guarantees demand-zeroed memory, in order to make multi-page
+ * sparse data structures such as radix tree nodes efficient with respect to
+ * physical memory usage.
+ */
 void *
-base_calloc(size_t number, size_t size)
-{
-	void *ret = base_alloc(number * size);
-
-	if (ret != NULL)
-		memset(ret, 0, number * size);
-
-	return (ret);
-}
-
-extent_node_t *
-base_node_alloc(void)
+base_alloc(size_t size)
 {
-	extent_node_t *ret;
+	void *ret;
+	size_t csize, usize;
+	extent_node_t *node;
+	extent_node_t key;
+
+	/*
+	 * Round size up to nearest multiple of the cacheline size, so that
+	 * there is no chance of false cache line sharing.
+	 */
+	csize = CACHELINE_CEILING(size);
 
+	usize = s2u(csize);
+	extent_node_init(&key, NULL, NULL, usize, false, false);
 	malloc_mutex_lock(&base_mtx);
-	if (base_nodes != NULL) {
-		ret = base_nodes;
-		base_nodes = *(extent_node_t **)ret;
-		malloc_mutex_unlock(&base_mtx);
-		VALGRIND_MAKE_MEM_UNDEFINED(ret, sizeof(extent_node_t));
+	node = extent_tree_szad_nsearch(&base_avail_szad, &key);
+	if (node != NULL) {
+		/* Use existing space. */
+		extent_tree_szad_remove(&base_avail_szad, node);
 	} else {
-		malloc_mutex_unlock(&base_mtx);
-		ret = (extent_node_t *)base_alloc(sizeof(extent_node_t));
+		/* Try to allocate more space. */
+		node = base_chunk_alloc(csize);
+	}
+	if (node == NULL) {
+		ret = NULL;
+		goto label_return;
 	}
 
+	ret = extent_node_addr_get(node);
+	if (extent_node_size_get(node) > csize) {
+		extent_node_addr_set(node, (void *)((uintptr_t)ret + csize));
+		extent_node_size_set(node, extent_node_size_get(node) - csize);
+		extent_tree_szad_insert(&base_avail_szad, node);
+	} else
+		base_node_dalloc(node);
+	if (config_stats) {
+		base_allocated += csize;
+		/*
+		 * Add one PAGE to base_resident for every page boundary that is
+		 * crossed by the new allocation.
+		 */
+		base_resident += PAGE_CEILING((uintptr_t)ret + csize) -
+		    PAGE_CEILING((uintptr_t)ret);
+	}
+	JEMALLOC_VALGRIND_MAKE_MEM_DEFINED(ret, csize);
+label_return:
+	malloc_mutex_unlock(&base_mtx);
 	return (ret);
 }
 
 void
-base_node_dealloc(extent_node_t *node)
+base_stats_get(size_t *allocated, size_t *resident, size_t *mapped)
 {
 
-	VALGRIND_MAKE_MEM_UNDEFINED(node, sizeof(extent_node_t));
 	malloc_mutex_lock(&base_mtx);
-	*(extent_node_t **)node = base_nodes;
-	base_nodes = node;
+	assert(base_allocated <= base_resident);
+	assert(base_resident <= base_mapped);
+	*allocated = base_allocated;
+	*resident = base_resident;
+	*mapped = base_mapped;
 	malloc_mutex_unlock(&base_mtx);
 }
 
 bool
 base_boot(void)
 {
 
-	base_nodes = NULL;
 	if (malloc_mutex_init(&base_mtx))
 		return (true);
+	extent_tree_szad_new(&base_avail_szad);
+	base_nodes = NULL;
 
 	return (false);
 }
 
 void
 base_prefork(void)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.d	2017-09-27 22:47:55.810963379 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.d	2017-09-27 22:49:18.490960349 +0800
@@ -1,20 +1,21 @@
 src/base.o: src/base.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,23 +1,10 @@
 #define	JEMALLOC_BITMAP_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
-/* Function prototypes for non-inline static functions. */
-
-static size_t	bits2groups(size_t nbits);
-
-/******************************************************************************/
-
-static size_t
-bits2groups(size_t nbits)
-{
-
-	return ((nbits >> LG_BITMAP_GROUP_NBITS) +
-	    !!(nbits & BITMAP_GROUP_NBITS_MASK));
-}
 
 void
 bitmap_info_init(bitmap_info_t *binfo, size_t nbits)
 {
 	unsigned i;
 	size_t group_count;
@@ -28,21 +15,22 @@
 	/*
 	 * Compute the number of groups necessary to store nbits bits, and
 	 * progressively work upward through the levels until reaching a level
 	 * that requires only one group.
 	 */
 	binfo->levels[0].group_offset = 0;
-	group_count = bits2groups(nbits);
+	group_count = BITMAP_BITS2GROUPS(nbits);
 	for (i = 1; group_count > 1; i++) {
 		assert(i < BITMAP_MAX_LEVELS);
 		binfo->levels[i].group_offset = binfo->levels[i-1].group_offset
 		    + group_count;
-		group_count = bits2groups(group_count);
+		group_count = BITMAP_BITS2GROUPS(group_count);
 	}
 	binfo->levels[i].group_offset = binfo->levels[i-1].group_offset
 	    + group_count;
+	assert(binfo->levels[i].group_offset <= BITMAP_GROUPS_MAX);
 	binfo->nlevels = i;
 	binfo->nbits = nbits;
 }
 
 size_t
 bitmap_info_ngroups(const bitmap_info_t *binfo)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.d	2017-09-27 22:47:55.914963375 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.d	2017-09-27 22:49:18.606960345 +0800
@@ -1,20 +1,21 @@
 src/bitmap.o: src/bitmap.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.c	2016-05-06 15:11:36.000000000 +0800
@@ -2,394 +2,760 @@
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 /* Data. */
 
 const char	*opt_dss = DSS_DEFAULT;
-size_t		opt_lg_chunk = LG_CHUNK_DEFAULT;
+size_t		opt_lg_chunk = 0;
 
-malloc_mutex_t	chunks_mtx;
-chunk_stats_t	stats_chunks;
+/* Used exclusively for gdump triggering. */
+static size_t	curchunks;
+static size_t	highchunks;
 
-/*
- * Trees of chunks that were previously allocated (trees differ only in node
- * ordering).  These are used when allocating chunks, in an attempt to re-use
- * address space.  Depending on function, different tree orderings are needed,
- * which is why there are two trees with the same contents.
- */
-static extent_tree_t	chunks_szad_mmap;
-static extent_tree_t	chunks_ad_mmap;
-static extent_tree_t	chunks_szad_dss;
-static extent_tree_t	chunks_ad_dss;
-
-rtree_t		*chunks_rtree;
+rtree_t		chunks_rtree;
 
 /* Various chunk-related settings. */
 size_t		chunksize;
 size_t		chunksize_mask; /* (chunksize - 1). */
 size_t		chunk_npages;
-size_t		map_bias;
-size_t		arena_maxclass; /* Max size class for arenas. */
+
+static void	*chunk_alloc_default(void *new_addr, size_t size,
+    size_t alignment, bool *zero, bool *commit, unsigned arena_ind);
+static bool	chunk_dalloc_default(void *chunk, size_t size, bool committed,
+    unsigned arena_ind);
+static bool	chunk_commit_default(void *chunk, size_t size, size_t offset,
+    size_t length, unsigned arena_ind);
+static bool	chunk_decommit_default(void *chunk, size_t size, size_t offset,
+    size_t length, unsigned arena_ind);
+static bool	chunk_purge_default(void *chunk, size_t size, size_t offset,
+    size_t length, unsigned arena_ind);
+static bool	chunk_split_default(void *chunk, size_t size, size_t size_a,
+    size_t size_b, bool committed, unsigned arena_ind);
+static bool	chunk_merge_default(void *chunk_a, size_t size_a, void *chunk_b,
+    size_t size_b, bool committed, unsigned arena_ind);
+
+const chunk_hooks_t	chunk_hooks_default = {
+	chunk_alloc_default,
+	chunk_dalloc_default,
+	chunk_commit_default,
+	chunk_decommit_default,
+	chunk_purge_default,
+	chunk_split_default,
+	chunk_merge_default
+};
 
 /******************************************************************************/
-/* Function prototypes for non-inline static functions. */
+/*
+ * Function prototypes for static functions that are referenced prior to
+ * definition.
+ */
 
-static void	*chunk_recycle(extent_tree_t *chunks_szad,
-    extent_tree_t *chunks_ad, size_t size, size_t alignment, bool base,
-    bool *zero);
-static void	chunk_record(extent_tree_t *chunks_szad,
-    extent_tree_t *chunks_ad, void *chunk, size_t size);
+static void	chunk_record(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    extent_tree_t *chunks_szad, extent_tree_t *chunks_ad, bool cache,
+    void *chunk, size_t size, bool zeroed, bool committed);
 
 /******************************************************************************/
 
+static chunk_hooks_t
+chunk_hooks_get_locked(arena_t *arena)
+{
+
+	return (arena->chunk_hooks);
+}
+
+chunk_hooks_t
+chunk_hooks_get(arena_t *arena)
+{
+	chunk_hooks_t chunk_hooks;
+
+	malloc_mutex_lock(&arena->chunks_mtx);
+	chunk_hooks = chunk_hooks_get_locked(arena);
+	malloc_mutex_unlock(&arena->chunks_mtx);
+
+	return (chunk_hooks);
+}
+
+chunk_hooks_t
+chunk_hooks_set(arena_t *arena, const chunk_hooks_t *chunk_hooks)
+{
+	chunk_hooks_t old_chunk_hooks;
+
+	malloc_mutex_lock(&arena->chunks_mtx);
+	old_chunk_hooks = arena->chunk_hooks;
+	/*
+	 * Copy each field atomically so that it is impossible for readers to
+	 * see partially updated pointers.  There are places where readers only
+	 * need one hook function pointer (therefore no need to copy the
+	 * entirety of arena->chunk_hooks), and stale reads do not affect
+	 * correctness, so they perform unlocked reads.
+	 */
+#define	ATOMIC_COPY_HOOK(n) do {					\
+	union {								\
+		chunk_##n##_t	**n;					\
+		void		**v;					\
+	} u;								\
+	u.n = &arena->chunk_hooks.n;					\
+	atomic_write_p(u.v, chunk_hooks->n);				\
+} while (0)
+	ATOMIC_COPY_HOOK(alloc);
+	ATOMIC_COPY_HOOK(dalloc);
+	ATOMIC_COPY_HOOK(commit);
+	ATOMIC_COPY_HOOK(decommit);
+	ATOMIC_COPY_HOOK(purge);
+	ATOMIC_COPY_HOOK(split);
+	ATOMIC_COPY_HOOK(merge);
+#undef ATOMIC_COPY_HOOK
+	malloc_mutex_unlock(&arena->chunks_mtx);
+
+	return (old_chunk_hooks);
+}
+
+static void
+chunk_hooks_assure_initialized_impl(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    bool locked)
+{
+	static const chunk_hooks_t uninitialized_hooks =
+	    CHUNK_HOOKS_INITIALIZER;
+
+	if (memcmp(chunk_hooks, &uninitialized_hooks, sizeof(chunk_hooks_t)) ==
+	    0) {
+		*chunk_hooks = locked ? chunk_hooks_get_locked(arena) :
+		    chunk_hooks_get(arena);
+	}
+}
+
+static void
+chunk_hooks_assure_initialized_locked(arena_t *arena,
+    chunk_hooks_t *chunk_hooks)
+{
+
+	chunk_hooks_assure_initialized_impl(arena, chunk_hooks, true);
+}
+
+static void
+chunk_hooks_assure_initialized(arena_t *arena, chunk_hooks_t *chunk_hooks)
+{
+
+	chunk_hooks_assure_initialized_impl(arena, chunk_hooks, false);
+}
+
+bool
+chunk_register(const void *chunk, const extent_node_t *node)
+{
+
+	assert(extent_node_addr_get(node) == chunk);
+
+	if (rtree_set(&chunks_rtree, (uintptr_t)chunk, node))
+		return (true);
+	if (config_prof && opt_prof) {
+		size_t size = extent_node_size_get(node);
+		size_t nadd = (size == 0) ? 1 : size / chunksize;
+		size_t cur = atomic_add_z(&curchunks, nadd);
+		size_t high = atomic_read_z(&highchunks);
+		while (cur > high && atomic_cas_z(&highchunks, high, cur)) {
+			/*
+			 * Don't refresh cur, because it may have decreased
+			 * since this thread lost the highchunks update race.
+			 */
+			high = atomic_read_z(&highchunks);
+		}
+		if (cur > high && prof_gdump_get_unlocked())
+			prof_gdump();
+	}
+
+	return (false);
+}
+
+void
+chunk_deregister(const void *chunk, const extent_node_t *node)
+{
+	bool err;
+
+	err = rtree_set(&chunks_rtree, (uintptr_t)chunk, NULL);
+	assert(!err);
+	if (config_prof && opt_prof) {
+		size_t size = extent_node_size_get(node);
+		size_t nsub = (size == 0) ? 1 : size / chunksize;
+		assert(atomic_read_z(&curchunks) >= nsub);
+		atomic_sub_z(&curchunks, nsub);
+	}
+}
+
+/*
+ * Do first-best-fit chunk selection, i.e. select the lowest chunk that best
+ * fits.
+ */
+static extent_node_t *
+chunk_first_best_fit(arena_t *arena, extent_tree_t *chunks_szad,
+    extent_tree_t *chunks_ad, size_t size)
+{
+	extent_node_t key;
+
+	assert(size == CHUNK_CEILING(size));
+
+	extent_node_init(&key, arena, NULL, size, false, false);
+	return (extent_tree_szad_nsearch(chunks_szad, &key));
+}
+
 static void *
-chunk_recycle(extent_tree_t *chunks_szad, extent_tree_t *chunks_ad, size_t size,
-    size_t alignment, bool base, bool *zero)
+chunk_recycle(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    extent_tree_t *chunks_szad, extent_tree_t *chunks_ad, bool cache,
+    void *new_addr, size_t size, size_t alignment, bool *zero, bool *commit,
+    bool dalloc_node)
 {
 	void *ret;
 	extent_node_t *node;
-	extent_node_t key;
 	size_t alloc_size, leadsize, trailsize;
-	bool zeroed;
+	bool zeroed, committed;
 
-	if (base) {
-		/*
-		 * This function may need to call base_node_{,de}alloc(), but
-		 * the current chunk allocation request is on behalf of the
-		 * base allocator.  Avoid deadlock (and if that weren't an
-		 * issue, potential for infinite recursion) by returning NULL.
-		 */
-		return (NULL);
-	}
+	assert(new_addr == NULL || alignment == chunksize);
+	/*
+	 * Cached chunks use the node linkage embedded in their headers, in
+	 * which case dalloc_node is true, and new_addr is non-NULL because
+	 * we're operating on a specific chunk.
+	 */
+	assert(dalloc_node || new_addr != NULL);
 
-	alloc_size = size + alignment - chunksize;
+	alloc_size = CHUNK_CEILING(s2u(size + alignment - chunksize));
 	/* Beware size_t wrap-around. */
 	if (alloc_size < size)
 		return (NULL);
-	key.addr = NULL;
-	key.size = alloc_size;
-	malloc_mutex_lock(&chunks_mtx);
-	node = extent_tree_szad_nsearch(chunks_szad, &key);
-	if (node == NULL) {
-		malloc_mutex_unlock(&chunks_mtx);
+	malloc_mutex_lock(&arena->chunks_mtx);
+	chunk_hooks_assure_initialized_locked(arena, chunk_hooks);
+	if (new_addr != NULL) {
+		extent_node_t key;
+		extent_node_init(&key, arena, new_addr, alloc_size, false,
+		    false);
+		node = extent_tree_ad_search(chunks_ad, &key);
+	} else {
+		node = chunk_first_best_fit(arena, chunks_szad, chunks_ad,
+		    alloc_size);
+	}
+	if (node == NULL || (new_addr != NULL && extent_node_size_get(node) <
+	    size)) {
+		malloc_mutex_unlock(&arena->chunks_mtx);
 		return (NULL);
 	}
-	leadsize = ALIGNMENT_CEILING((uintptr_t)node->addr, alignment) -
-	    (uintptr_t)node->addr;
-	assert(node->size >= leadsize + size);
-	trailsize = node->size - leadsize - size;
-	ret = (void *)((uintptr_t)node->addr + leadsize);
-	zeroed = node->zeroed;
+	leadsize = ALIGNMENT_CEILING((uintptr_t)extent_node_addr_get(node),
+	    alignment) - (uintptr_t)extent_node_addr_get(node);
+	assert(new_addr == NULL || leadsize == 0);
+	assert(extent_node_size_get(node) >= leadsize + size);
+	trailsize = extent_node_size_get(node) - leadsize - size;
+	ret = (void *)((uintptr_t)extent_node_addr_get(node) + leadsize);
+	zeroed = extent_node_zeroed_get(node);
 	if (zeroed)
-	    *zero = true;
+		*zero = true;
+	committed = extent_node_committed_get(node);
+	if (committed)
+		*commit = true;
+	/* Split the lead. */
+	if (leadsize != 0 &&
+	    chunk_hooks->split(extent_node_addr_get(node),
+	    extent_node_size_get(node), leadsize, size, false, arena->ind)) {
+		malloc_mutex_unlock(&arena->chunks_mtx);
+		return (NULL);
+	}
 	/* Remove node from the tree. */
 	extent_tree_szad_remove(chunks_szad, node);
 	extent_tree_ad_remove(chunks_ad, node);
+	arena_chunk_cache_maybe_remove(arena, node, cache);
 	if (leadsize != 0) {
 		/* Insert the leading space as a smaller chunk. */
-		node->size = leadsize;
+		extent_node_size_set(node, leadsize);
 		extent_tree_szad_insert(chunks_szad, node);
 		extent_tree_ad_insert(chunks_ad, node);
+		arena_chunk_cache_maybe_insert(arena, node, cache);
 		node = NULL;
 	}
 	if (trailsize != 0) {
+		/* Split the trail. */
+		if (chunk_hooks->split(ret, size + trailsize, size,
+		    trailsize, false, arena->ind)) {
+			if (dalloc_node && node != NULL)
+				arena_node_dalloc(arena, node);
+			malloc_mutex_unlock(&arena->chunks_mtx);
+			chunk_record(arena, chunk_hooks, chunks_szad, chunks_ad,
+			    cache, ret, size + trailsize, zeroed, committed);
+			return (NULL);
+		}
 		/* Insert the trailing space as a smaller chunk. */
 		if (node == NULL) {
-			/*
-			 * An additional node is required, but
-			 * base_node_alloc() can cause a new base chunk to be
-			 * allocated.  Drop chunks_mtx in order to avoid
-			 * deadlock, and if node allocation fails, deallocate
-			 * the result before returning an error.
-			 */
-			malloc_mutex_unlock(&chunks_mtx);
-			node = base_node_alloc();
+			node = arena_node_alloc(arena);
 			if (node == NULL) {
-				chunk_dealloc(ret, size, true);
+				malloc_mutex_unlock(&arena->chunks_mtx);
+				chunk_record(arena, chunk_hooks, chunks_szad,
+				    chunks_ad, cache, ret, size + trailsize,
+				    zeroed, committed);
 				return (NULL);
 			}
-			malloc_mutex_lock(&chunks_mtx);
 		}
-		node->addr = (void *)((uintptr_t)(ret) + size);
-		node->size = trailsize;
-		node->zeroed = zeroed;
+		extent_node_init(node, arena, (void *)((uintptr_t)(ret) + size),
+		    trailsize, zeroed, committed);
 		extent_tree_szad_insert(chunks_szad, node);
 		extent_tree_ad_insert(chunks_ad, node);
+		arena_chunk_cache_maybe_insert(arena, node, cache);
 		node = NULL;
 	}
-	malloc_mutex_unlock(&chunks_mtx);
+	if (!committed && chunk_hooks->commit(ret, size, 0, size, arena->ind)) {
+		malloc_mutex_unlock(&arena->chunks_mtx);
+		chunk_record(arena, chunk_hooks, chunks_szad, chunks_ad, cache,
+		    ret, size, zeroed, committed);
+		return (NULL);
+	}
+	malloc_mutex_unlock(&arena->chunks_mtx);
 
-	if (node != NULL)
-		base_node_dealloc(node);
+	assert(dalloc_node || node != NULL);
+	if (dalloc_node && node != NULL)
+		arena_node_dalloc(arena, node);
 	if (*zero) {
-		if (zeroed == false)
+		if (!zeroed)
 			memset(ret, 0, size);
 		else if (config_debug) {
 			size_t i;
 			size_t *p = (size_t *)(uintptr_t)ret;
 
-			VALGRIND_MAKE_MEM_DEFINED(ret, size);
+			JEMALLOC_VALGRIND_MAKE_MEM_DEFINED(ret, size);
 			for (i = 0; i < size / sizeof(size_t); i++)
 				assert(p[i] == 0);
 		}
 	}
 	return (ret);
 }
 
 /*
- * If the caller specifies (*zero == false), it is still possible to receive
- * zeroed memory, in which case *zero is toggled to true.  arena_chunk_alloc()
- * takes advantage of this to avoid demanding zeroed chunks, but taking
- * advantage of them if they are returned.
+ * If the caller specifies (!*zero), it is still possible to receive zeroed
+ * memory, in which case *zero is toggled to true.  arena_chunk_alloc() takes
+ * advantage of this to avoid demanding zeroed chunks, but taking advantage of
+ * them if they are returned.
  */
-void *
-chunk_alloc(size_t size, size_t alignment, bool base, bool *zero,
-    dss_prec_t dss_prec)
+static void *
+chunk_alloc_core(arena_t *arena, void *new_addr, size_t size, size_t alignment,
+    bool *zero, bool *commit, dss_prec_t dss_prec)
 {
 	void *ret;
+	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
 
 	assert(size != 0);
 	assert((size & chunksize_mask) == 0);
 	assert(alignment != 0);
 	assert((alignment & chunksize_mask) == 0);
 
+	/* Retained. */
+	if ((ret = chunk_recycle(arena, &chunk_hooks,
+	    &arena->chunks_szad_retained, &arena->chunks_ad_retained, false,
+	    new_addr, size, alignment, zero, commit, true)) != NULL)
+		return (ret);
+
 	/* "primary" dss. */
-	if (config_dss && dss_prec == dss_prec_primary) {
-		if ((ret = chunk_recycle(&chunks_szad_dss, &chunks_ad_dss, size,
-		    alignment, base, zero)) != NULL)
-			goto label_return;
-		if ((ret = chunk_alloc_dss(size, alignment, zero)) != NULL)
-			goto label_return;
-	}
-	/* mmap. */
-	if ((ret = chunk_recycle(&chunks_szad_mmap, &chunks_ad_mmap, size,
-	    alignment, base, zero)) != NULL)
-		goto label_return;
-	if ((ret = chunk_alloc_mmap(size, alignment, zero)) != NULL)
-		goto label_return;
+	if (have_dss && dss_prec == dss_prec_primary && (ret =
+	    chunk_alloc_dss(arena, new_addr, size, alignment, zero, commit)) !=
+	    NULL)
+		return (ret);
+	/*
+	 * mmap.  Requesting an address is not implemented for
+	 * chunk_alloc_mmap(), so only call it if (new_addr == NULL).
+	 */
+	if (new_addr == NULL && (ret = chunk_alloc_mmap(size, alignment, zero,
+	    commit)) != NULL)
+		return (ret);
 	/* "secondary" dss. */
-	if (config_dss && dss_prec == dss_prec_secondary) {
-		if ((ret = chunk_recycle(&chunks_szad_dss, &chunks_ad_dss, size,
-		    alignment, base, zero)) != NULL)
-			goto label_return;
-		if ((ret = chunk_alloc_dss(size, alignment, zero)) != NULL)
-			goto label_return;
-	}
+	if (have_dss && dss_prec == dss_prec_secondary && (ret =
+	    chunk_alloc_dss(arena, new_addr, size, alignment, zero, commit)) !=
+	    NULL)
+		return (ret);
 
 	/* All strategies for allocation failed. */
-	ret = NULL;
-label_return:
-	if (ret != NULL) {
-		if (config_ivsalloc && base == false) {
-			if (rtree_set(chunks_rtree, (uintptr_t)ret, 1)) {
-				chunk_dealloc(ret, size, true);
-				return (NULL);
-			}
-		}
-		if (config_stats || config_prof) {
-			bool gdump;
-			malloc_mutex_lock(&chunks_mtx);
-			if (config_stats)
-				stats_chunks.nchunks += (size / chunksize);
-			stats_chunks.curchunks += (size / chunksize);
-			if (stats_chunks.curchunks > stats_chunks.highchunks) {
-				stats_chunks.highchunks =
-				    stats_chunks.curchunks;
-				if (config_prof)
-					gdump = true;
-			} else if (config_prof)
-				gdump = false;
-			malloc_mutex_unlock(&chunks_mtx);
-			if (config_prof && opt_prof && opt_prof_gdump && gdump)
-				prof_gdump();
-		}
-		if (config_valgrind)
-			VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
-	}
-	assert(CHUNK_ADDR2BASE(ret) == ret);
+	return (NULL);
+}
+
+void *
+chunk_alloc_base(size_t size)
+{
+	void *ret;
+	bool zero, commit;
+
+	/*
+	 * Directly call chunk_alloc_mmap() rather than chunk_alloc_core()
+	 * because it's critical that chunk_alloc_base() return untouched
+	 * demand-zeroed virtual memory.
+	 */
+	zero = true;
+	commit = true;
+	ret = chunk_alloc_mmap(size, chunksize, &zero, &commit);
+	if (ret == NULL)
+		return (NULL);
+	if (config_valgrind)
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
+
 	return (ret);
 }
 
-static void
-chunk_record(extent_tree_t *chunks_szad, extent_tree_t *chunks_ad, void *chunk,
-    size_t size)
+void *
+chunk_alloc_cache(arena_t *arena, chunk_hooks_t *chunk_hooks, void *new_addr,
+    size_t size, size_t alignment, bool *zero, bool dalloc_node)
 {
-	bool unzeroed;
-	extent_node_t *xnode, *node, *prev, *xprev, key;
+	void *ret;
+	bool commit;
+
+	assert(size != 0);
+	assert((size & chunksize_mask) == 0);
+	assert(alignment != 0);
+	assert((alignment & chunksize_mask) == 0);
 
-	unzeroed = pages_purge(chunk, size);
-	VALGRIND_MAKE_MEM_NOACCESS(chunk, size);
+	commit = true;
+	ret = chunk_recycle(arena, chunk_hooks, &arena->chunks_szad_cached,
+	    &arena->chunks_ad_cached, true, new_addr, size, alignment, zero,
+	    &commit, dalloc_node);
+	if (ret == NULL)
+		return (NULL);
+	assert(commit);
+	if (config_valgrind)
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
+	return (ret);
+}
 
+static arena_t *
+chunk_arena_get(unsigned arena_ind)
+{
+	arena_t *arena;
+
+	/* Dodge tsd for a0 in order to avoid bootstrapping issues. */
+	arena = (arena_ind == 0) ? a0get() : arena_get(tsd_fetch(), arena_ind,
+	     false, true);
 	/*
-	 * Allocate a node before acquiring chunks_mtx even though it might not
-	 * be needed, because base_node_alloc() may cause a new base chunk to
-	 * be allocated, which could cause deadlock if chunks_mtx were already
-	 * held.
+	 * The arena we're allocating on behalf of must have been initialized
+	 * already.
 	 */
-	xnode = base_node_alloc();
-	/* Use xprev to implement conditional deferred deallocation of prev. */
-	xprev = NULL;
+	assert(arena != NULL);
+	return (arena);
+}
 
-	malloc_mutex_lock(&chunks_mtx);
-	key.addr = (void *)((uintptr_t)chunk + size);
+static void *
+chunk_alloc_default(void *new_addr, size_t size, size_t alignment, bool *zero,
+    bool *commit, unsigned arena_ind)
+{
+	void *ret;
+	arena_t *arena;
+
+	arena = chunk_arena_get(arena_ind);
+	ret = chunk_alloc_core(arena, new_addr, size, alignment, zero,
+	    commit, arena->dss_prec);
+	if (ret == NULL)
+		return (NULL);
+	if (config_valgrind)
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
+
+	return (ret);
+}
+
+void *
+chunk_alloc_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks, void *new_addr,
+    size_t size, size_t alignment, bool *zero, bool *commit)
+{
+	void *ret;
+
+	chunk_hooks_assure_initialized(arena, chunk_hooks);
+	ret = chunk_hooks->alloc(new_addr, size, alignment, zero, commit,
+	    arena->ind);
+	if (ret == NULL)
+		return (NULL);
+	if (config_valgrind && chunk_hooks->alloc != chunk_alloc_default)
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, chunksize);
+	return (ret);
+}
+
+static void
+chunk_record(arena_t *arena, chunk_hooks_t *chunk_hooks,
+    extent_tree_t *chunks_szad, extent_tree_t *chunks_ad, bool cache,
+    void *chunk, size_t size, bool zeroed, bool committed)
+{
+	bool unzeroed;
+	extent_node_t *node, *prev;
+	extent_node_t key;
+
+	assert(!cache || !zeroed);
+	unzeroed = cache || !zeroed;
+	JEMALLOC_VALGRIND_MAKE_MEM_NOACCESS(chunk, size);
+
+	malloc_mutex_lock(&arena->chunks_mtx);
+	chunk_hooks_assure_initialized_locked(arena, chunk_hooks);
+	extent_node_init(&key, arena, (void *)((uintptr_t)chunk + size), 0,
+	    false, false);
 	node = extent_tree_ad_nsearch(chunks_ad, &key);
 	/* Try to coalesce forward. */
-	if (node != NULL && node->addr == key.addr) {
+	if (node != NULL && extent_node_addr_get(node) ==
+	    extent_node_addr_get(&key) && extent_node_committed_get(node) ==
+	    committed && !chunk_hooks->merge(chunk, size,
+	    extent_node_addr_get(node), extent_node_size_get(node), false,
+	    arena->ind)) {
 		/*
 		 * Coalesce chunk with the following address range.  This does
 		 * not change the position within chunks_ad, so only
 		 * remove/insert from/into chunks_szad.
 		 */
 		extent_tree_szad_remove(chunks_szad, node);
-		node->addr = chunk;
-		node->size += size;
-		node->zeroed = (node->zeroed && (unzeroed == false));
+		arena_chunk_cache_maybe_remove(arena, node, cache);
+		extent_node_addr_set(node, chunk);
+		extent_node_size_set(node, size + extent_node_size_get(node));
+		extent_node_zeroed_set(node, extent_node_zeroed_get(node) &&
+		    !unzeroed);
 		extent_tree_szad_insert(chunks_szad, node);
+		arena_chunk_cache_maybe_insert(arena, node, cache);
 	} else {
 		/* Coalescing forward failed, so insert a new node. */
-		if (xnode == NULL) {
+		node = arena_node_alloc(arena);
+		if (node == NULL) {
 			/*
-			 * base_node_alloc() failed, which is an exceedingly
-			 * unlikely failure.  Leak chunk; its pages have
-			 * already been purged, so this is only a virtual
-			 * memory leak.
+			 * Node allocation failed, which is an exceedingly
+			 * unlikely failure.  Leak chunk after making sure its
+			 * pages have already been purged, so that this is only
+			 * a virtual memory leak.
 			 */
+			if (cache) {
+				chunk_purge_wrapper(arena, chunk_hooks, chunk,
+				    size, 0, size);
+			}
 			goto label_return;
 		}
-		node = xnode;
-		xnode = NULL; /* Prevent deallocation below. */
-		node->addr = chunk;
-		node->size = size;
-		node->zeroed = (unzeroed == false);
+		extent_node_init(node, arena, chunk, size, !unzeroed,
+		    committed);
 		extent_tree_ad_insert(chunks_ad, node);
 		extent_tree_szad_insert(chunks_szad, node);
+		arena_chunk_cache_maybe_insert(arena, node, cache);
 	}
 
 	/* Try to coalesce backward. */
 	prev = extent_tree_ad_prev(chunks_ad, node);
-	if (prev != NULL && (void *)((uintptr_t)prev->addr + prev->size) ==
-	    chunk) {
+	if (prev != NULL && (void *)((uintptr_t)extent_node_addr_get(prev) +
+	    extent_node_size_get(prev)) == chunk &&
+	    extent_node_committed_get(prev) == committed &&
+	    !chunk_hooks->merge(extent_node_addr_get(prev),
+	    extent_node_size_get(prev), chunk, size, false, arena->ind)) {
 		/*
 		 * Coalesce chunk with the previous address range.  This does
 		 * not change the position within chunks_ad, so only
 		 * remove/insert node from/into chunks_szad.
 		 */
 		extent_tree_szad_remove(chunks_szad, prev);
 		extent_tree_ad_remove(chunks_ad, prev);
-
+		arena_chunk_cache_maybe_remove(arena, prev, cache);
 		extent_tree_szad_remove(chunks_szad, node);
-		node->addr = prev->addr;
-		node->size += prev->size;
-		node->zeroed = (node->zeroed && prev->zeroed);
+		arena_chunk_cache_maybe_remove(arena, node, cache);
+		extent_node_addr_set(node, extent_node_addr_get(prev));
+		extent_node_size_set(node, extent_node_size_get(prev) +
+		    extent_node_size_get(node));
+		extent_node_zeroed_set(node, extent_node_zeroed_get(prev) &&
+		    extent_node_zeroed_get(node));
 		extent_tree_szad_insert(chunks_szad, node);
+		arena_chunk_cache_maybe_insert(arena, node, cache);
 
-		xprev = prev;
+		arena_node_dalloc(arena, prev);
 	}
 
 label_return:
-	malloc_mutex_unlock(&chunks_mtx);
-	/*
-	 * Deallocate xnode and/or xprev after unlocking chunks_mtx in order to
-	 * avoid potential deadlock.
-	 */
-	if (xnode != NULL)
-		base_node_dealloc(xnode);
-	if (xprev != NULL)
-		base_node_dealloc(xprev);
+	malloc_mutex_unlock(&arena->chunks_mtx);
 }
 
 void
-chunk_unmap(void *chunk, size_t size)
+chunk_dalloc_cache(arena_t *arena, chunk_hooks_t *chunk_hooks, void *chunk,
+    size_t size, bool committed)
 {
+
 	assert(chunk != NULL);
 	assert(CHUNK_ADDR2BASE(chunk) == chunk);
 	assert(size != 0);
 	assert((size & chunksize_mask) == 0);
 
-	if (config_dss && chunk_in_dss(chunk))
-		chunk_record(&chunks_szad_dss, &chunks_ad_dss, chunk, size);
-	else if (chunk_dealloc_mmap(chunk, size))
-		chunk_record(&chunks_szad_mmap, &chunks_ad_mmap, chunk, size);
+	chunk_record(arena, chunk_hooks, &arena->chunks_szad_cached,
+	    &arena->chunks_ad_cached, true, chunk, size, false, committed);
+	arena_maybe_purge(arena);
 }
 
 void
-chunk_dealloc(void *chunk, size_t size, bool unmap)
+chunk_dalloc_arena(arena_t *arena, chunk_hooks_t *chunk_hooks, void *chunk,
+    size_t size, bool zeroed, bool committed)
 {
 
 	assert(chunk != NULL);
 	assert(CHUNK_ADDR2BASE(chunk) == chunk);
 	assert(size != 0);
 	assert((size & chunksize_mask) == 0);
 
-	if (config_ivsalloc)
-		rtree_set(chunks_rtree, (uintptr_t)chunk, 0);
-	if (config_stats || config_prof) {
-		malloc_mutex_lock(&chunks_mtx);
-		assert(stats_chunks.curchunks >= (size / chunksize));
-		stats_chunks.curchunks -= (size / chunksize);
-		malloc_mutex_unlock(&chunks_mtx);
-	}
+	chunk_hooks_assure_initialized(arena, chunk_hooks);
+	/* Try to deallocate. */
+	if (!chunk_hooks->dalloc(chunk, size, committed, arena->ind))
+		return;
+	/* Try to decommit; purge if that fails. */
+	if (committed) {
+		committed = chunk_hooks->decommit(chunk, size, 0, size,
+		    arena->ind);
+	}
+	zeroed = !committed || !chunk_hooks->purge(chunk, size, 0, size,
+	    arena->ind);
+	chunk_record(arena, chunk_hooks, &arena->chunks_szad_retained,
+	    &arena->chunks_ad_retained, false, chunk, size, zeroed, committed);
+}
+
+static bool
+chunk_dalloc_default(void *chunk, size_t size, bool committed,
+    unsigned arena_ind)
+{
+
+	if (!have_dss || !chunk_in_dss(chunk))
+		return (chunk_dalloc_mmap(chunk, size));
+	return (true);
+}
+
+void
+chunk_dalloc_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks, void *chunk,
+    size_t size, bool committed)
+{
 
-	if (unmap)
-		chunk_unmap(chunk, size);
+	chunk_hooks_assure_initialized(arena, chunk_hooks);
+	chunk_hooks->dalloc(chunk, size, committed, arena->ind);
+	if (config_valgrind && chunk_hooks->dalloc != chunk_dalloc_default)
+		JEMALLOC_VALGRIND_MAKE_MEM_NOACCESS(chunk, size);
+}
+
+static bool
+chunk_commit_default(void *chunk, size_t size, size_t offset, size_t length,
+    unsigned arena_ind)
+{
+
+	return (pages_commit((void *)((uintptr_t)chunk + (uintptr_t)offset),
+	    length));
+}
+
+static bool
+chunk_decommit_default(void *chunk, size_t size, size_t offset, size_t length,
+    unsigned arena_ind)
+{
+
+	return (pages_decommit((void *)((uintptr_t)chunk + (uintptr_t)offset),
+	    length));
+}
+
+bool
+chunk_purge_arena(arena_t *arena, void *chunk, size_t offset, size_t length)
+{
+
+	assert(chunk != NULL);
+	assert(CHUNK_ADDR2BASE(chunk) == chunk);
+	assert((offset & PAGE_MASK) == 0);
+	assert(length != 0);
+	assert((length & PAGE_MASK) == 0);
+
+	return (pages_purge((void *)((uintptr_t)chunk + (uintptr_t)offset),
+	    length));
+}
+
+static bool
+chunk_purge_default(void *chunk, size_t size, size_t offset, size_t length,
+    unsigned arena_ind)
+{
+
+	return (chunk_purge_arena(chunk_arena_get(arena_ind), chunk, offset,
+	    length));
+}
+
+bool
+chunk_purge_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks, void *chunk,
+    size_t size, size_t offset, size_t length)
+{
+
+	chunk_hooks_assure_initialized(arena, chunk_hooks);
+	return (chunk_hooks->purge(chunk, size, offset, length, arena->ind));
+}
+
+static bool
+chunk_split_default(void *chunk, size_t size, size_t size_a, size_t size_b,
+    bool committed, unsigned arena_ind)
+{
+
+	if (!maps_coalesce)
+		return (true);
+	return (false);
+}
+
+static bool
+chunk_merge_default(void *chunk_a, size_t size_a, void *chunk_b, size_t size_b,
+    bool committed, unsigned arena_ind)
+{
+
+	if (!maps_coalesce)
+		return (true);
+	if (have_dss && chunk_in_dss(chunk_a) != chunk_in_dss(chunk_b))
+		return (true);
+
+	return (false);
+}
+
+static rtree_node_elm_t *
+chunks_rtree_node_alloc(size_t nelms)
+{
+
+	return ((rtree_node_elm_t *)base_alloc(nelms *
+	    sizeof(rtree_node_elm_t)));
 }
 
 bool
 chunk_boot(void)
 {
+#ifdef _WIN32
+	SYSTEM_INFO info;
+	GetSystemInfo(&info);
+
+	/*
+	 * Verify actual page size is equal to or an integral multiple of
+	 * configured page size.
+	 */
+	if (info.dwPageSize & ((1U << LG_PAGE) - 1))
+		return (true);
+
+	/*
+	 * Configure chunksize (if not set) to match granularity (usually 64K),
+	 * so pages_map will always take fast path.
+	 */
+	if (!opt_lg_chunk) {
+		opt_lg_chunk = jemalloc_ffs((int)info.dwAllocationGranularity)
+		    - 1;
+	}
+#else
+	if (!opt_lg_chunk)
+		opt_lg_chunk = LG_CHUNK_DEFAULT;
+#endif
 
 	/* Set variables according to the value of opt_lg_chunk. */
 	chunksize = (ZU(1) << opt_lg_chunk);
 	assert(chunksize >= PAGE);
 	chunksize_mask = chunksize - 1;
 	chunk_npages = (chunksize >> LG_PAGE);
 
-	if (config_stats || config_prof) {
-		if (malloc_mutex_init(&chunks_mtx))
-			return (true);
-		memset(&stats_chunks, 0, sizeof(chunk_stats_t));
-	}
-	if (config_dss && chunk_dss_boot())
+	if (have_dss && chunk_dss_boot())
+		return (true);
+	if (rtree_new(&chunks_rtree, (ZU(1) << (LG_SIZEOF_PTR+3)) -
+	    opt_lg_chunk, chunks_rtree_node_alloc, NULL))
 		return (true);
-	extent_tree_szad_new(&chunks_szad_mmap);
-	extent_tree_ad_new(&chunks_ad_mmap);
-	extent_tree_szad_new(&chunks_szad_dss);
-	extent_tree_ad_new(&chunks_ad_dss);
-	if (config_ivsalloc) {
-		chunks_rtree = rtree_new((ZU(1) << (LG_SIZEOF_PTR+3)) -
-		    opt_lg_chunk, base_alloc, NULL);
-		if (chunks_rtree == NULL)
-			return (true);
-	}
 
 	return (false);
 }
 
 void
 chunk_prefork(void)
 {
 
-	malloc_mutex_prefork(&chunks_mtx);
-	if (config_ivsalloc)
-		rtree_prefork(chunks_rtree);
 	chunk_dss_prefork();
 }
 
 void
 chunk_postfork_parent(void)
 {
 
 	chunk_dss_postfork_parent();
-	if (config_ivsalloc)
-		rtree_postfork_parent(chunks_rtree);
-	malloc_mutex_postfork_parent(&chunks_mtx);
 }
 
 void
 chunk_postfork_child(void)
 {
 
 	chunk_dss_postfork_child();
-	if (config_ivsalloc)
-		rtree_postfork_child(chunks_rtree);
-	malloc_mutex_postfork_child(&chunks_mtx);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.d	2017-09-27 22:47:56.030963371 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.d	2017-09-27 22:49:18.902960334 +0800
@@ -1,20 +1,21 @@
 src/chunk.o: src/chunk.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.c	2016-05-06 15:11:36.000000000 +0800
@@ -29,75 +29,83 @@
 /******************************************************************************/
 
 static void *
 chunk_dss_sbrk(intptr_t increment)
 {
 
-#ifdef JEMALLOC_HAVE_SBRK
+#ifdef JEMALLOC_DSS
 	return (sbrk(increment));
 #else
 	not_implemented();
 	return (NULL);
 #endif
 }
 
 dss_prec_t
 chunk_dss_prec_get(void)
 {
 	dss_prec_t ret;
 
-	if (config_dss == false)
+	if (!have_dss)
 		return (dss_prec_disabled);
 	malloc_mutex_lock(&dss_mtx);
 	ret = dss_prec_default;
 	malloc_mutex_unlock(&dss_mtx);
 	return (ret);
 }
 
 bool
 chunk_dss_prec_set(dss_prec_t dss_prec)
 {
 
-	if (config_dss == false)
-		return (true);
+	if (!have_dss)
+		return (dss_prec != dss_prec_disabled);
 	malloc_mutex_lock(&dss_mtx);
 	dss_prec_default = dss_prec;
 	malloc_mutex_unlock(&dss_mtx);
 	return (false);
 }
 
 void *
-chunk_alloc_dss(size_t size, size_t alignment, bool *zero)
+chunk_alloc_dss(arena_t *arena, void *new_addr, size_t size, size_t alignment,
+    bool *zero, bool *commit)
 {
-	void *ret;
-
-	cassert(config_dss);
+	cassert(have_dss);
 	assert(size > 0 && (size & chunksize_mask) == 0);
 	assert(alignment > 0 && (alignment & chunksize_mask) == 0);
 
 	/*
 	 * sbrk() uses a signed increment argument, so take care not to
 	 * interpret a huge allocation request as a negative increment.
 	 */
 	if ((intptr_t)size < 0)
 		return (NULL);
 
 	malloc_mutex_lock(&dss_mtx);
 	if (dss_prev != (void *)-1) {
-		size_t gap_size, cpad_size;
-		void *cpad, *dss_next;
-		intptr_t incr;
 
 		/*
 		 * The loop is necessary to recover from races with other
 		 * threads that are using the DSS for something other than
 		 * malloc.
 		 */
 		do {
+			void *ret, *cpad, *dss_next;
+			size_t gap_size, cpad_size;
+			intptr_t incr;
+			/* Avoid an unnecessary system call. */
+			if (new_addr != NULL && dss_max != new_addr)
+				break;
+
 			/* Get the current end of the DSS. */
 			dss_max = chunk_dss_sbrk(0);
+
+			/* Make sure the earlier condition still holds. */
+			if (new_addr != NULL && dss_max != new_addr)
+				break;
+
 			/*
 			 * Calculate how much padding is necessary to
 			 * chunk-align the end of the DSS.
 			 */
 			gap_size = (chunksize - CHUNK_ADDR2OFFSET(dss_max)) &
 			    chunksize_mask;
@@ -120,18 +128,26 @@
 			incr = gap_size + cpad_size + size;
 			dss_prev = chunk_dss_sbrk(incr);
 			if (dss_prev == dss_max) {
 				/* Success. */
 				dss_max = dss_next;
 				malloc_mutex_unlock(&dss_mtx);
-				if (cpad_size != 0)
-					chunk_unmap(cpad, cpad_size);
+				if (cpad_size != 0) {
+					chunk_hooks_t chunk_hooks =
+					    CHUNK_HOOKS_INITIALIZER;
+					chunk_dalloc_wrapper(arena,
+					    &chunk_hooks, cpad, cpad_size,
+					    true);
+				}
 				if (*zero) {
-					VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
+					JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(
+					    ret, size);
 					memset(ret, 0, size);
 				}
+				if (!*commit)
+					*commit = pages_decommit(ret, size);
 				return (ret);
 			}
 		} while (dss_prev != (void *)-1);
 	}
 	malloc_mutex_unlock(&dss_mtx);
 
@@ -140,13 +156,13 @@
 
 bool
 chunk_in_dss(void *chunk)
 {
 	bool ret;
 
-	cassert(config_dss);
+	cassert(have_dss);
 
 	malloc_mutex_lock(&dss_mtx);
 	if ((uintptr_t)chunk >= (uintptr_t)dss_base
 	    && (uintptr_t)chunk < (uintptr_t)dss_max)
 		ret = true;
 	else
@@ -157,13 +173,13 @@
 }
 
 bool
 chunk_dss_boot(void)
 {
 
-	cassert(config_dss);
+	cassert(have_dss);
 
 	if (malloc_mutex_init(&dss_mtx))
 		return (true);
 	dss_base = chunk_dss_sbrk(0);
 	dss_prev = dss_base;
 	dss_max = dss_base;
@@ -172,27 +188,27 @@
 }
 
 void
 chunk_dss_prefork(void)
 {
 
-	if (config_dss)
+	if (have_dss)
 		malloc_mutex_prefork(&dss_mtx);
 }
 
 void
 chunk_dss_postfork_parent(void)
 {
 
-	if (config_dss)
+	if (have_dss)
 		malloc_mutex_postfork_parent(&dss_mtx);
 }
 
 void
 chunk_dss_postfork_child(void)
 {
 
-	if (config_dss)
+	if (have_dss)
 		malloc_mutex_postfork_child(&dss_mtx);
 }
 
 /******************************************************************************/
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.d	2017-09-27 22:47:56.126963368 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.d	2017-09-27 22:49:19.022960330 +0800
@@ -1,21 +1,22 @@
 src/chunk_dss.o: src/chunk_dss.c \
  include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,173 +1,41 @@
 #define	JEMALLOC_CHUNK_MMAP_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
-/* Function prototypes for non-inline static functions. */
-
-static void	*pages_map(void *addr, size_t size);
-static void	pages_unmap(void *addr, size_t size);
-static void	*chunk_alloc_mmap_slow(size_t size, size_t alignment,
-    bool *zero);
-
-/******************************************************************************/
 
 static void *
-pages_map(void *addr, size_t size)
+chunk_alloc_mmap_slow(size_t size, size_t alignment, bool *zero, bool *commit)
 {
 	void *ret;
-
-	assert(size != 0);
-
-#ifdef _WIN32
-	/*
-	 * If VirtualAlloc can't allocate at the given address when one is
-	 * given, it fails and returns NULL.
-	 */
-	ret = VirtualAlloc(addr, size, MEM_COMMIT | MEM_RESERVE,
-	    PAGE_READWRITE);
-#else
-	/*
-	 * We don't use MAP_FIXED here, because it can cause the *replacement*
-	 * of existing mappings, and we only want to create new mappings.
-	 */
-	ret = mmap(addr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON,
-	    -1, 0);
-	assert(ret != NULL);
-
-	if (ret == MAP_FAILED)
-		ret = NULL;
-	else if (addr != NULL && ret != addr) {
-		/*
-		 * We succeeded in mapping memory, but not in the right place.
-		 */
-		if (munmap(ret, size) == -1) {
-			char buf[BUFERROR_BUF];
-
-			buferror(get_errno(), buf, sizeof(buf));
-			malloc_printf("<jemalloc: Error in munmap(): %s\n",
-			    buf);
-			if (opt_abort)
-				abort();
-		}
-		ret = NULL;
-	}
-#endif
-	assert(ret == NULL || (addr == NULL && ret != addr)
-	    || (addr != NULL && ret == addr));
-	return (ret);
-}
-
-static void
-pages_unmap(void *addr, size_t size)
-{
-
-#ifdef _WIN32
-	if (VirtualFree(addr, 0, MEM_RELEASE) == 0)
-#else
-	if (munmap(addr, size) == -1)
-#endif
-	{
-		char buf[BUFERROR_BUF];
-
-		buferror(get_errno(), buf, sizeof(buf));
-		malloc_printf("<jemalloc>: Error in "
-#ifdef _WIN32
-		              "VirtualFree"
-#else
-		              "munmap"
-#endif
-		              "(): %s\n", buf);
-		if (opt_abort)
-			abort();
-	}
-}
-
-static void *
-pages_trim(void *addr, size_t alloc_size, size_t leadsize, size_t size)
-{
-	void *ret = (void *)((uintptr_t)addr + leadsize);
-
-	assert(alloc_size >= leadsize + size);
-#ifdef _WIN32
-	{
-		void *new_addr;
-
-		pages_unmap(addr, alloc_size);
-		new_addr = pages_map(ret, size);
-		if (new_addr == ret)
-			return (ret);
-		if (new_addr)
-			pages_unmap(new_addr, size);
-		return (NULL);
-	}
-#else
-	{
-		size_t trailsize = alloc_size - leadsize - size;
-
-		if (leadsize != 0)
-			pages_unmap(addr, leadsize);
-		if (trailsize != 0)
-			pages_unmap((void *)((uintptr_t)ret + size), trailsize);
-		return (ret);
-	}
-#endif
-}
-
-bool
-pages_purge(void *addr, size_t length)
-{
-	bool unzeroed;
-
-#ifdef _WIN32
-	VirtualAlloc(addr, length, MEM_RESET, PAGE_READWRITE);
-	unzeroed = true;
-#else
-#  ifdef JEMALLOC_PURGE_MADVISE_DONTNEED
-#    define JEMALLOC_MADV_PURGE MADV_DONTNEED
-#    define JEMALLOC_MADV_ZEROS true
-#  elif defined(JEMALLOC_PURGE_MADVISE_FREE)
-#    define JEMALLOC_MADV_PURGE MADV_FREE
-#    define JEMALLOC_MADV_ZEROS false
-#  else
-#    error "No method defined for purging unused dirty pages."
-#  endif
-	int err = madvise(addr, length, JEMALLOC_MADV_PURGE);
-	unzeroed = (JEMALLOC_MADV_ZEROS == false || err != 0);
-#  undef JEMALLOC_MADV_PURGE
-#  undef JEMALLOC_MADV_ZEROS
-#endif
-	return (unzeroed);
-}
-
-static void *
-chunk_alloc_mmap_slow(size_t size, size_t alignment, bool *zero)
-{
-	void *ret, *pages;
-	size_t alloc_size, leadsize;
+	size_t alloc_size;
 
 	alloc_size = size + alignment - PAGE;
 	/* Beware size_t wrap-around. */
 	if (alloc_size < size)
 		return (NULL);
 	do {
+		void *pages;
+		size_t leadsize;
 		pages = pages_map(NULL, alloc_size);
 		if (pages == NULL)
 			return (NULL);
 		leadsize = ALIGNMENT_CEILING((uintptr_t)pages, alignment) -
 		    (uintptr_t)pages;
 		ret = pages_trim(pages, alloc_size, leadsize, size);
 	} while (ret == NULL);
 
 	assert(ret != NULL);
 	*zero = true;
+	if (!*commit)
+		*commit = pages_decommit(ret, size);
 	return (ret);
 }
 
 void *
-chunk_alloc_mmap(size_t size, size_t alignment, bool *zero)
+chunk_alloc_mmap(size_t size, size_t alignment, bool *zero, bool *commit)
 {
 	void *ret;
 	size_t offset;
 
 	/*
 	 * Ideally, there would be a way to specify alignment to mmap() (like
@@ -188,23 +56,25 @@
 	ret = pages_map(NULL, size);
 	if (ret == NULL)
 		return (NULL);
 	offset = ALIGNMENT_ADDR2OFFSET(ret, alignment);
 	if (offset != 0) {
 		pages_unmap(ret, size);
-		return (chunk_alloc_mmap_slow(size, alignment, zero));
+		return (chunk_alloc_mmap_slow(size, alignment, zero, commit));
 	}
 
 	assert(ret != NULL);
 	*zero = true;
+	if (!*commit)
+		*commit = pages_decommit(ret, size);
 	return (ret);
 }
 
 bool
-chunk_dealloc_mmap(void *chunk, size_t size)
+chunk_dalloc_mmap(void *chunk, size_t size)
 {
 
 	if (config_munmap)
 		pages_unmap(chunk, size);
 
-	return (config_munmap == false);
+	return (!config_munmap);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.d	2017-09-27 22:47:56.226963364 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.d	2017-09-27 22:49:19.126960326 +0800
@@ -1,21 +1,22 @@
 src/chunk_mmap.o: src/chunk_mmap.c \
  include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.c	2016-05-06 15:11:36.000000000 +0800
@@ -37,14 +37,14 @@
 #define	JEMALLOC_CKH_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
-static bool	ckh_grow(ckh_t *ckh);
-static void	ckh_shrink(ckh_t *ckh);
+static bool	ckh_grow(tsd_t *tsd, ckh_t *ckh);
+static void	ckh_shrink(tsd_t *tsd, ckh_t *ckh);
 
 /******************************************************************************/
 
 /*
  * Search bucket for key and return the cell number if found; SIZE_T_MAX
  * otherwise.
@@ -182,13 +182,13 @@
 			*argkey = key;
 			*argdata = data;
 			return (true);
 		}
 
 		bucket = tbucket;
-		if (ckh_try_bucket_insert(ckh, bucket, key, data) == false)
+		if (!ckh_try_bucket_insert(ckh, bucket, key, data))
 			return (false);
 	}
 }
 
 JEMALLOC_INLINE_C bool
 ckh_try_insert(ckh_t *ckh, void const**argkey, void const**argdata)
@@ -198,18 +198,18 @@
 	const void *data = *argdata;
 
 	ckh->hash(key, hashes);
 
 	/* Try to insert in primary bucket. */
 	bucket = hashes[0] & ((ZU(1) << ckh->lg_curbuckets) - 1);
-	if (ckh_try_bucket_insert(ckh, bucket, key, data) == false)
+	if (!ckh_try_bucket_insert(ckh, bucket, key, data))
 		return (false);
 
 	/* Try to insert in secondary bucket. */
 	bucket = hashes[1] & ((ZU(1) << ckh->lg_curbuckets) - 1);
-	if (ckh_try_bucket_insert(ckh, bucket, key, data) == false)
+	if (!ckh_try_bucket_insert(ckh, bucket, key, data))
 		return (false);
 
 	/*
 	 * Try to find a place for this item via iterative eviction/relocation.
 	 */
 	return (ckh_evict_reloc_insert(ckh, bucket, argkey, argdata));
@@ -240,13 +240,13 @@
 	}
 
 	return (false);
 }
 
 static bool
-ckh_grow(ckh_t *ckh)
+ckh_grow(tsd_t *tsd, ckh_t *ckh)
 {
 	bool ret;
 	ckhc_t *tab, *ttab;
 	size_t lg_curcells;
 	unsigned lg_prevbuckets;
 
@@ -267,41 +267,42 @@
 		lg_curcells++;
 		usize = sa2u(sizeof(ckhc_t) << lg_curcells, CACHELINE);
 		if (usize == 0) {
 			ret = true;
 			goto label_return;
 		}
-		tab = (ckhc_t *)ipalloc(usize, CACHELINE, true);
+		tab = (ckhc_t *)ipallocztm(tsd, usize, CACHELINE, true, NULL,
+		    true, NULL);
 		if (tab == NULL) {
 			ret = true;
 			goto label_return;
 		}
 		/* Swap in new table. */
 		ttab = ckh->tab;
 		ckh->tab = tab;
 		tab = ttab;
 		ckh->lg_curbuckets = lg_curcells - LG_CKH_BUCKET_CELLS;
 
-		if (ckh_rebuild(ckh, tab) == false) {
-			idalloc(tab);
+		if (!ckh_rebuild(ckh, tab)) {
+			idalloctm(tsd, tab, tcache_get(tsd, false), true);
 			break;
 		}
 
 		/* Rebuilding failed, so back out partially rebuilt table. */
-		idalloc(ckh->tab);
+		idalloctm(tsd, ckh->tab, tcache_get(tsd, false), true);
 		ckh->tab = tab;
 		ckh->lg_curbuckets = lg_prevbuckets;
 	}
 
 	ret = false;
 label_return:
 	return (ret);
 }
 
 static void
-ckh_shrink(ckh_t *ckh)
+ckh_shrink(tsd_t *tsd, ckh_t *ckh)
 {
 	ckhc_t *tab, *ttab;
 	size_t lg_curcells, usize;
 	unsigned lg_prevbuckets;
 
 	/*
@@ -310,13 +311,14 @@
 	 */
 	lg_prevbuckets = ckh->lg_curbuckets;
 	lg_curcells = ckh->lg_curbuckets + LG_CKH_BUCKET_CELLS - 1;
 	usize = sa2u(sizeof(ckhc_t) << lg_curcells, CACHELINE);
 	if (usize == 0)
 		return;
-	tab = (ckhc_t *)ipalloc(usize, CACHELINE, true);
+	tab = (ckhc_t *)ipallocztm(tsd, usize, CACHELINE, true, NULL, true,
+	    NULL);
 	if (tab == NULL) {
 		/*
 		 * An OOM error isn't worth propagating, since it doesn't
 		 * prevent this or future operations from proceeding.
 		 */
 		return;
@@ -324,31 +326,32 @@
 	/* Swap in new table. */
 	ttab = ckh->tab;
 	ckh->tab = tab;
 	tab = ttab;
 	ckh->lg_curbuckets = lg_curcells - LG_CKH_BUCKET_CELLS;
 
-	if (ckh_rebuild(ckh, tab) == false) {
-		idalloc(tab);
+	if (!ckh_rebuild(ckh, tab)) {
+		idalloctm(tsd, tab, tcache_get(tsd, false), true);
 #ifdef CKH_COUNT
 		ckh->nshrinks++;
 #endif
 		return;
 	}
 
 	/* Rebuilding failed, so back out partially rebuilt table. */
-	idalloc(ckh->tab);
+	idalloctm(tsd, ckh->tab, tcache_get(tsd, false), true);
 	ckh->tab = tab;
 	ckh->lg_curbuckets = lg_prevbuckets;
 #ifdef CKH_COUNT
 	ckh->nshrinkfails++;
 #endif
 }
 
 bool
-ckh_new(ckh_t *ckh, size_t minitems, ckh_hash_t *hash, ckh_keycomp_t *keycomp)
+ckh_new(tsd_t *tsd, ckh_t *ckh, size_t minitems, ckh_hash_t *hash,
+    ckh_keycomp_t *keycomp)
 {
 	bool ret;
 	size_t mincells, usize;
 	unsigned lg_mincells;
 
 	assert(minitems > 0);
@@ -363,16 +366,16 @@
 	ckh->nrelocs = 0;
 #endif
 	ckh->prng_state = 42; /* Value doesn't really matter. */
 	ckh->count = 0;
 
 	/*
-	 * Find the minimum power of 2 that is large enough to fit aBaseCount
+	 * Find the minimum power of 2 that is large enough to fit minitems
 	 * entries.  We are using (2+,2) cuckoo hashing, which has an expected
 	 * maximum load factor of at least ~0.86, so 0.75 is a conservative load
-	 * factor that will typically allow 2^aLgMinItems to fit without ever
+	 * factor that will typically allow mincells items to fit without ever
 	 * growing the table.
 	 */
 	assert(LG_CKH_BUCKET_CELLS > 0);
 	mincells = ((minitems + (3 - (minitems % 3))) / 3) << 2;
 	for (lg_mincells = LG_CKH_BUCKET_CELLS;
 	    (ZU(1) << lg_mincells) < mincells;
@@ -385,42 +388,43 @@
 
 	usize = sa2u(sizeof(ckhc_t) << lg_mincells, CACHELINE);
 	if (usize == 0) {
 		ret = true;
 		goto label_return;
 	}
-	ckh->tab = (ckhc_t *)ipalloc(usize, CACHELINE, true);
+	ckh->tab = (ckhc_t *)ipallocztm(tsd, usize, CACHELINE, true, NULL, true,
+	    NULL);
 	if (ckh->tab == NULL) {
 		ret = true;
 		goto label_return;
 	}
 
 	ret = false;
 label_return:
 	return (ret);
 }
 
 void
-ckh_delete(ckh_t *ckh)
+ckh_delete(tsd_t *tsd, ckh_t *ckh)
 {
 
 	assert(ckh != NULL);
 
 #ifdef CKH_VERBOSE
 	malloc_printf(
-	    "%s(%p): ngrows: %"PRIu64", nshrinks: %"PRIu64","
-	    " nshrinkfails: %"PRIu64", ninserts: %"PRIu64","
-	    " nrelocs: %"PRIu64"\n", __func__, ckh,
+	    "%s(%p): ngrows: %"FMTu64", nshrinks: %"FMTu64","
+	    " nshrinkfails: %"FMTu64", ninserts: %"FMTu64","
+	    " nrelocs: %"FMTu64"\n", __func__, ckh,
 	    (unsigned long long)ckh->ngrows,
 	    (unsigned long long)ckh->nshrinks,
 	    (unsigned long long)ckh->nshrinkfails,
 	    (unsigned long long)ckh->ninserts,
 	    (unsigned long long)ckh->nrelocs);
 #endif
 
-	idalloc(ckh->tab);
+	idalloctm(tsd, ckh->tab, tcache_get(tsd, false), true);
 	if (config_debug)
 		memset(ckh, 0x5a, sizeof(ckh_t));
 }
 
 size_t
 ckh_count(ckh_t *ckh)
@@ -449,37 +453,38 @@
 	}
 
 	return (true);
 }
 
 bool
-ckh_insert(ckh_t *ckh, const void *key, const void *data)
+ckh_insert(tsd_t *tsd, ckh_t *ckh, const void *key, const void *data)
 {
 	bool ret;
 
 	assert(ckh != NULL);
 	assert(ckh_search(ckh, key, NULL, NULL));
 
 #ifdef CKH_COUNT
 	ckh->ninserts++;
 #endif
 
 	while (ckh_try_insert(ckh, &key, &data)) {
-		if (ckh_grow(ckh)) {
+		if (ckh_grow(tsd, ckh)) {
 			ret = true;
 			goto label_return;
 		}
 	}
 
 	ret = false;
 label_return:
 	return (ret);
 }
 
 bool
-ckh_remove(ckh_t *ckh, const void *searchkey, void **key, void **data)
+ckh_remove(tsd_t *tsd, ckh_t *ckh, const void *searchkey, void **key,
+    void **data)
 {
 	size_t cell;
 
 	assert(ckh != NULL);
 
 	cell = ckh_isearch(ckh, searchkey);
@@ -494,13 +499,13 @@
 		ckh->count--;
 		/* Try to halve the table if it is less than 1/4 full. */
 		if (ckh->count < (ZU(1) << (ckh->lg_curbuckets
 		    + LG_CKH_BUCKET_CELLS - 2)) && ckh->lg_curbuckets
 		    > ckh->lg_minbuckets) {
 			/* Ignore error due to OOM. */
-			ckh_shrink(ckh);
+			ckh_shrink(tsd, ckh);
 		}
 
 		return (false);
 	}
 
 	return (true);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.d	2017-09-27 22:47:56.670963348 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.d	2017-09-27 22:49:19.550960310 +0800
@@ -1,20 +1,21 @@
 src/ckh.o: src/ckh.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.c	2016-05-06 15:11:36.000000000 +0800
@@ -4,43 +4,41 @@
 /******************************************************************************/
 /* Data. */
 
 /*
  * ctl_mtx protects the following:
  * - ctl_stats.*
- * - opt_prof_active
  */
 static malloc_mutex_t	ctl_mtx;
 static bool		ctl_initialized;
 static uint64_t		ctl_epoch;
 static ctl_stats_t	ctl_stats;
 
 /******************************************************************************/
 /* Helpers for named and indexed nodes. */
 
-static inline const ctl_named_node_t *
+JEMALLOC_INLINE_C const ctl_named_node_t *
 ctl_named_node(const ctl_node_t *node)
 {
 
 	return ((node->named) ? (const ctl_named_node_t *)node : NULL);
 }
 
-static inline const ctl_named_node_t *
+JEMALLOC_INLINE_C const ctl_named_node_t *
 ctl_named_children(const ctl_named_node_t *node, int index)
 {
 	const ctl_named_node_t *children = ctl_named_node(node->children);
 
 	return (children ? &children[index] : NULL);
 }
 
-static inline const ctl_indexed_node_t *
+JEMALLOC_INLINE_C const ctl_indexed_node_t *
 ctl_indexed_node(const ctl_node_t *node)
 {
 
-	return ((node->named == false) ? (const ctl_indexed_node_t *)node :
-	    NULL);
+	return (!node->named ? (const ctl_indexed_node_t *)node : NULL);
 }
 
 /******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
 #define	CTL_PROTO(n)							\
@@ -65,22 +63,23 @@
     size_t *mibp, size_t *depthp);
 
 CTL_PROTO(version)
 CTL_PROTO(epoch)
 CTL_PROTO(thread_tcache_enabled)
 CTL_PROTO(thread_tcache_flush)
+CTL_PROTO(thread_prof_name)
+CTL_PROTO(thread_prof_active)
 CTL_PROTO(thread_arena)
 CTL_PROTO(thread_allocated)
 CTL_PROTO(thread_allocatedp)
 CTL_PROTO(thread_deallocated)
 CTL_PROTO(thread_deallocatedp)
+CTL_PROTO(config_cache_oblivious)
 CTL_PROTO(config_debug)
-CTL_PROTO(config_dss)
 CTL_PROTO(config_fill)
 CTL_PROTO(config_lazy_lock)
-CTL_PROTO(config_mremap)
 CTL_PROTO(config_munmap)
 CTL_PROTO(config_prof)
 CTL_PROTO(config_prof_libgcc)
 CTL_PROTO(config_prof_libunwind)
 CTL_PROTO(config_stats)
 CTL_PROTO(config_tcache)
@@ -96,89 +95,109 @@
 CTL_PROTO(opt_stats_print)
 CTL_PROTO(opt_junk)
 CTL_PROTO(opt_zero)
 CTL_PROTO(opt_quarantine)
 CTL_PROTO(opt_redzone)
 CTL_PROTO(opt_utrace)
-CTL_PROTO(opt_valgrind)
 CTL_PROTO(opt_xmalloc)
 CTL_PROTO(opt_tcache)
 CTL_PROTO(opt_lg_tcache_max)
 CTL_PROTO(opt_prof)
 CTL_PROTO(opt_prof_prefix)
 CTL_PROTO(opt_prof_active)
+CTL_PROTO(opt_prof_thread_active_init)
 CTL_PROTO(opt_lg_prof_sample)
 CTL_PROTO(opt_lg_prof_interval)
 CTL_PROTO(opt_prof_gdump)
 CTL_PROTO(opt_prof_final)
 CTL_PROTO(opt_prof_leak)
 CTL_PROTO(opt_prof_accum)
+CTL_PROTO(tcache_create)
+CTL_PROTO(tcache_flush)
+CTL_PROTO(tcache_destroy)
 CTL_PROTO(arena_i_purge)
 static void	arena_purge(unsigned arena_ind);
 CTL_PROTO(arena_i_dss)
+CTL_PROTO(arena_i_lg_dirty_mult)
+CTL_PROTO(arena_i_chunk_hooks)
 INDEX_PROTO(arena_i)
 CTL_PROTO(arenas_bin_i_size)
 CTL_PROTO(arenas_bin_i_nregs)
 CTL_PROTO(arenas_bin_i_run_size)
 INDEX_PROTO(arenas_bin_i)
 CTL_PROTO(arenas_lrun_i_size)
 INDEX_PROTO(arenas_lrun_i)
+CTL_PROTO(arenas_hchunk_i_size)
+INDEX_PROTO(arenas_hchunk_i)
 CTL_PROTO(arenas_narenas)
 CTL_PROTO(arenas_initialized)
+CTL_PROTO(arenas_lg_dirty_mult)
 CTL_PROTO(arenas_quantum)
 CTL_PROTO(arenas_page)
 CTL_PROTO(arenas_tcache_max)
 CTL_PROTO(arenas_nbins)
 CTL_PROTO(arenas_nhbins)
 CTL_PROTO(arenas_nlruns)
-CTL_PROTO(arenas_purge)
+CTL_PROTO(arenas_nhchunks)
 CTL_PROTO(arenas_extend)
+CTL_PROTO(prof_thread_active_init)
 CTL_PROTO(prof_active)
 CTL_PROTO(prof_dump)
+CTL_PROTO(prof_gdump)
+CTL_PROTO(prof_reset)
 CTL_PROTO(prof_interval)
-CTL_PROTO(stats_chunks_current)
-CTL_PROTO(stats_chunks_total)
-CTL_PROTO(stats_chunks_high)
-CTL_PROTO(stats_huge_allocated)
-CTL_PROTO(stats_huge_nmalloc)
-CTL_PROTO(stats_huge_ndalloc)
+CTL_PROTO(lg_prof_sample)
 CTL_PROTO(stats_arenas_i_small_allocated)
 CTL_PROTO(stats_arenas_i_small_nmalloc)
 CTL_PROTO(stats_arenas_i_small_ndalloc)
 CTL_PROTO(stats_arenas_i_small_nrequests)
 CTL_PROTO(stats_arenas_i_large_allocated)
 CTL_PROTO(stats_arenas_i_large_nmalloc)
 CTL_PROTO(stats_arenas_i_large_ndalloc)
 CTL_PROTO(stats_arenas_i_large_nrequests)
-CTL_PROTO(stats_arenas_i_bins_j_allocated)
+CTL_PROTO(stats_arenas_i_huge_allocated)
+CTL_PROTO(stats_arenas_i_huge_nmalloc)
+CTL_PROTO(stats_arenas_i_huge_ndalloc)
+CTL_PROTO(stats_arenas_i_huge_nrequests)
 CTL_PROTO(stats_arenas_i_bins_j_nmalloc)
 CTL_PROTO(stats_arenas_i_bins_j_ndalloc)
 CTL_PROTO(stats_arenas_i_bins_j_nrequests)
+CTL_PROTO(stats_arenas_i_bins_j_curregs)
 CTL_PROTO(stats_arenas_i_bins_j_nfills)
 CTL_PROTO(stats_arenas_i_bins_j_nflushes)
 CTL_PROTO(stats_arenas_i_bins_j_nruns)
 CTL_PROTO(stats_arenas_i_bins_j_nreruns)
 CTL_PROTO(stats_arenas_i_bins_j_curruns)
 INDEX_PROTO(stats_arenas_i_bins_j)
 CTL_PROTO(stats_arenas_i_lruns_j_nmalloc)
 CTL_PROTO(stats_arenas_i_lruns_j_ndalloc)
 CTL_PROTO(stats_arenas_i_lruns_j_nrequests)
 CTL_PROTO(stats_arenas_i_lruns_j_curruns)
 INDEX_PROTO(stats_arenas_i_lruns_j)
+CTL_PROTO(stats_arenas_i_hchunks_j_nmalloc)
+CTL_PROTO(stats_arenas_i_hchunks_j_ndalloc)
+CTL_PROTO(stats_arenas_i_hchunks_j_nrequests)
+CTL_PROTO(stats_arenas_i_hchunks_j_curhchunks)
+INDEX_PROTO(stats_arenas_i_hchunks_j)
 CTL_PROTO(stats_arenas_i_nthreads)
 CTL_PROTO(stats_arenas_i_dss)
+CTL_PROTO(stats_arenas_i_lg_dirty_mult)
 CTL_PROTO(stats_arenas_i_pactive)
 CTL_PROTO(stats_arenas_i_pdirty)
 CTL_PROTO(stats_arenas_i_mapped)
 CTL_PROTO(stats_arenas_i_npurge)
 CTL_PROTO(stats_arenas_i_nmadvise)
 CTL_PROTO(stats_arenas_i_purged)
+CTL_PROTO(stats_arenas_i_metadata_mapped)
+CTL_PROTO(stats_arenas_i_metadata_allocated)
 INDEX_PROTO(stats_arenas_i)
 CTL_PROTO(stats_cactive)
 CTL_PROTO(stats_allocated)
 CTL_PROTO(stats_active)
+CTL_PROTO(stats_metadata)
+CTL_PROTO(stats_resident)
 CTL_PROTO(stats_mapped)
 
 /******************************************************************************/
 /* mallctl tree. */
 
 /* Maximum tree depth. */
@@ -194,225 +213,274 @@
 /*
  * Only handles internal indexed nodes, since there are currently no external
  * ones.
  */
 #define	INDEX(i)	{false},	i##_index
 
-static const ctl_named_node_t	tcache_node[] = {
+static const ctl_named_node_t	thread_tcache_node[] = {
 	{NAME("enabled"),	CTL(thread_tcache_enabled)},
 	{NAME("flush"),		CTL(thread_tcache_flush)}
 };
 
+static const ctl_named_node_t	thread_prof_node[] = {
+	{NAME("name"),		CTL(thread_prof_name)},
+	{NAME("active"),	CTL(thread_prof_active)}
+};
+
 static const ctl_named_node_t	thread_node[] = {
 	{NAME("arena"),		CTL(thread_arena)},
 	{NAME("allocated"),	CTL(thread_allocated)},
 	{NAME("allocatedp"),	CTL(thread_allocatedp)},
 	{NAME("deallocated"),	CTL(thread_deallocated)},
 	{NAME("deallocatedp"),	CTL(thread_deallocatedp)},
-	{NAME("tcache"),	CHILD(named, tcache)}
+	{NAME("tcache"),	CHILD(named, thread_tcache)},
+	{NAME("prof"),		CHILD(named, thread_prof)}
 };
 
 static const ctl_named_node_t	config_node[] = {
-	{NAME("debug"),			CTL(config_debug)},
-	{NAME("dss"),			CTL(config_dss)},
-	{NAME("fill"),			CTL(config_fill)},
-	{NAME("lazy_lock"),		CTL(config_lazy_lock)},
-	{NAME("mremap"),		CTL(config_mremap)},
-	{NAME("munmap"),		CTL(config_munmap)},
-	{NAME("prof"),			CTL(config_prof)},
-	{NAME("prof_libgcc"),		CTL(config_prof_libgcc)},
-	{NAME("prof_libunwind"),	CTL(config_prof_libunwind)},
-	{NAME("stats"),			CTL(config_stats)},
-	{NAME("tcache"),		CTL(config_tcache)},
-	{NAME("tls"),			CTL(config_tls)},
-	{NAME("utrace"),		CTL(config_utrace)},
-	{NAME("valgrind"),		CTL(config_valgrind)},
-	{NAME("xmalloc"),		CTL(config_xmalloc)}
+	{NAME("cache_oblivious"), CTL(config_cache_oblivious)},
+	{NAME("debug"),		CTL(config_debug)},
+	{NAME("fill"),		CTL(config_fill)},
+	{NAME("lazy_lock"),	CTL(config_lazy_lock)},
+	{NAME("munmap"),	CTL(config_munmap)},
+	{NAME("prof"),		CTL(config_prof)},
+	{NAME("prof_libgcc"),	CTL(config_prof_libgcc)},
+	{NAME("prof_libunwind"), CTL(config_prof_libunwind)},
+	{NAME("stats"),		CTL(config_stats)},
+	{NAME("tcache"),	CTL(config_tcache)},
+	{NAME("tls"),		CTL(config_tls)},
+	{NAME("utrace"),	CTL(config_utrace)},
+	{NAME("valgrind"),	CTL(config_valgrind)},
+	{NAME("xmalloc"),	CTL(config_xmalloc)}
 };
 
 static const ctl_named_node_t opt_node[] = {
-	{NAME("abort"),			CTL(opt_abort)},
-	{NAME("dss"),			CTL(opt_dss)},
-	{NAME("lg_chunk"),		CTL(opt_lg_chunk)},
-	{NAME("narenas"),		CTL(opt_narenas)},
-	{NAME("lg_dirty_mult"),		CTL(opt_lg_dirty_mult)},
-	{NAME("stats_print"),		CTL(opt_stats_print)},
-	{NAME("junk"),			CTL(opt_junk)},
-	{NAME("zero"),			CTL(opt_zero)},
-	{NAME("quarantine"),		CTL(opt_quarantine)},
-	{NAME("redzone"),		CTL(opt_redzone)},
-	{NAME("utrace"),		CTL(opt_utrace)},
-	{NAME("valgrind"),		CTL(opt_valgrind)},
-	{NAME("xmalloc"),		CTL(opt_xmalloc)},
-	{NAME("tcache"),		CTL(opt_tcache)},
-	{NAME("lg_tcache_max"),		CTL(opt_lg_tcache_max)},
-	{NAME("prof"),			CTL(opt_prof)},
-	{NAME("prof_prefix"),		CTL(opt_prof_prefix)},
-	{NAME("prof_active"),		CTL(opt_prof_active)},
-	{NAME("lg_prof_sample"),	CTL(opt_lg_prof_sample)},
-	{NAME("lg_prof_interval"),	CTL(opt_lg_prof_interval)},
-	{NAME("prof_gdump"),		CTL(opt_prof_gdump)},
-	{NAME("prof_final"),		CTL(opt_prof_final)},
-	{NAME("prof_leak"),		CTL(opt_prof_leak)},
-	{NAME("prof_accum"),		CTL(opt_prof_accum)}
+	{NAME("abort"),		CTL(opt_abort)},
+	{NAME("dss"),		CTL(opt_dss)},
+	{NAME("lg_chunk"),	CTL(opt_lg_chunk)},
+	{NAME("narenas"),	CTL(opt_narenas)},
+	{NAME("lg_dirty_mult"),	CTL(opt_lg_dirty_mult)},
+	{NAME("stats_print"),	CTL(opt_stats_print)},
+	{NAME("junk"),		CTL(opt_junk)},
+	{NAME("zero"),		CTL(opt_zero)},
+	{NAME("quarantine"),	CTL(opt_quarantine)},
+	{NAME("redzone"),	CTL(opt_redzone)},
+	{NAME("utrace"),	CTL(opt_utrace)},
+	{NAME("xmalloc"),	CTL(opt_xmalloc)},
+	{NAME("tcache"),	CTL(opt_tcache)},
+	{NAME("lg_tcache_max"),	CTL(opt_lg_tcache_max)},
+	{NAME("prof"),		CTL(opt_prof)},
+	{NAME("prof_prefix"),	CTL(opt_prof_prefix)},
+	{NAME("prof_active"),	CTL(opt_prof_active)},
+	{NAME("prof_thread_active_init"), CTL(opt_prof_thread_active_init)},
+	{NAME("lg_prof_sample"), CTL(opt_lg_prof_sample)},
+	{NAME("lg_prof_interval"), CTL(opt_lg_prof_interval)},
+	{NAME("prof_gdump"),	CTL(opt_prof_gdump)},
+	{NAME("prof_final"),	CTL(opt_prof_final)},
+	{NAME("prof_leak"),	CTL(opt_prof_leak)},
+	{NAME("prof_accum"),	CTL(opt_prof_accum)}
+};
+
+static const ctl_named_node_t	tcache_node[] = {
+	{NAME("create"),	CTL(tcache_create)},
+	{NAME("flush"),		CTL(tcache_flush)},
+	{NAME("destroy"),	CTL(tcache_destroy)}
 };
 
 static const ctl_named_node_t arena_i_node[] = {
-	{NAME("purge"),			CTL(arena_i_purge)},
-	{NAME("dss"),			CTL(arena_i_dss)}
+	{NAME("purge"),		CTL(arena_i_purge)},
+	{NAME("dss"),		CTL(arena_i_dss)},
+	{NAME("lg_dirty_mult"),	CTL(arena_i_lg_dirty_mult)},
+	{NAME("chunk_hooks"),	CTL(arena_i_chunk_hooks)}
 };
 static const ctl_named_node_t super_arena_i_node[] = {
-	{NAME(""),			CHILD(named, arena_i)}
+	{NAME(""),		CHILD(named, arena_i)}
 };
 
 static const ctl_indexed_node_t arena_node[] = {
 	{INDEX(arena_i)}
 };
 
 static const ctl_named_node_t arenas_bin_i_node[] = {
-	{NAME("size"),			CTL(arenas_bin_i_size)},
-	{NAME("nregs"),			CTL(arenas_bin_i_nregs)},
-	{NAME("run_size"),		CTL(arenas_bin_i_run_size)}
+	{NAME("size"),		CTL(arenas_bin_i_size)},
+	{NAME("nregs"),		CTL(arenas_bin_i_nregs)},
+	{NAME("run_size"),	CTL(arenas_bin_i_run_size)}
 };
 static const ctl_named_node_t super_arenas_bin_i_node[] = {
-	{NAME(""),			CHILD(named, arenas_bin_i)}
+	{NAME(""),		CHILD(named, arenas_bin_i)}
 };
 
 static const ctl_indexed_node_t arenas_bin_node[] = {
 	{INDEX(arenas_bin_i)}
 };
 
 static const ctl_named_node_t arenas_lrun_i_node[] = {
-	{NAME("size"),			CTL(arenas_lrun_i_size)}
+	{NAME("size"),		CTL(arenas_lrun_i_size)}
 };
 static const ctl_named_node_t super_arenas_lrun_i_node[] = {
-	{NAME(""),			CHILD(named, arenas_lrun_i)}
+	{NAME(""),		CHILD(named, arenas_lrun_i)}
 };
 
 static const ctl_indexed_node_t arenas_lrun_node[] = {
 	{INDEX(arenas_lrun_i)}
 };
 
+static const ctl_named_node_t arenas_hchunk_i_node[] = {
+	{NAME("size"),		CTL(arenas_hchunk_i_size)}
+};
+static const ctl_named_node_t super_arenas_hchunk_i_node[] = {
+	{NAME(""),		CHILD(named, arenas_hchunk_i)}
+};
+
+static const ctl_indexed_node_t arenas_hchunk_node[] = {
+	{INDEX(arenas_hchunk_i)}
+};
+
 static const ctl_named_node_t arenas_node[] = {
-	{NAME("narenas"),		CTL(arenas_narenas)},
-	{NAME("initialized"),		CTL(arenas_initialized)},
-	{NAME("quantum"),		CTL(arenas_quantum)},
-	{NAME("page"),			CTL(arenas_page)},
-	{NAME("tcache_max"),		CTL(arenas_tcache_max)},
-	{NAME("nbins"),			CTL(arenas_nbins)},
-	{NAME("nhbins"),		CTL(arenas_nhbins)},
-	{NAME("bin"),			CHILD(indexed, arenas_bin)},
-	{NAME("nlruns"),		CTL(arenas_nlruns)},
-	{NAME("lrun"),			CHILD(indexed, arenas_lrun)},
-	{NAME("purge"),			CTL(arenas_purge)},
-	{NAME("extend"),		CTL(arenas_extend)}
+	{NAME("narenas"),	CTL(arenas_narenas)},
+	{NAME("initialized"),	CTL(arenas_initialized)},
+	{NAME("lg_dirty_mult"),	CTL(arenas_lg_dirty_mult)},
+	{NAME("quantum"),	CTL(arenas_quantum)},
+	{NAME("page"),		CTL(arenas_page)},
+	{NAME("tcache_max"),	CTL(arenas_tcache_max)},
+	{NAME("nbins"),		CTL(arenas_nbins)},
+	{NAME("nhbins"),	CTL(arenas_nhbins)},
+	{NAME("bin"),		CHILD(indexed, arenas_bin)},
+	{NAME("nlruns"),	CTL(arenas_nlruns)},
+	{NAME("lrun"),		CHILD(indexed, arenas_lrun)},
+	{NAME("nhchunks"),	CTL(arenas_nhchunks)},
+	{NAME("hchunk"),	CHILD(indexed, arenas_hchunk)},
+	{NAME("extend"),	CTL(arenas_extend)}
 };
 
 static const ctl_named_node_t	prof_node[] = {
+	{NAME("thread_active_init"), CTL(prof_thread_active_init)},
 	{NAME("active"),	CTL(prof_active)},
 	{NAME("dump"),		CTL(prof_dump)},
-	{NAME("interval"),	CTL(prof_interval)}
+	{NAME("gdump"),		CTL(prof_gdump)},
+	{NAME("reset"),		CTL(prof_reset)},
+	{NAME("interval"),	CTL(prof_interval)},
+	{NAME("lg_sample"),	CTL(lg_prof_sample)}
 };
 
-static const ctl_named_node_t stats_chunks_node[] = {
-	{NAME("current"),		CTL(stats_chunks_current)},
-	{NAME("total"),			CTL(stats_chunks_total)},
-	{NAME("high"),			CTL(stats_chunks_high)}
-};
-
-static const ctl_named_node_t stats_huge_node[] = {
-	{NAME("allocated"),		CTL(stats_huge_allocated)},
-	{NAME("nmalloc"),		CTL(stats_huge_nmalloc)},
-	{NAME("ndalloc"),		CTL(stats_huge_ndalloc)}
+static const ctl_named_node_t stats_arenas_i_metadata_node[] = {
+	{NAME("mapped"),	CTL(stats_arenas_i_metadata_mapped)},
+	{NAME("allocated"),	CTL(stats_arenas_i_metadata_allocated)}
 };
 
 static const ctl_named_node_t stats_arenas_i_small_node[] = {
-	{NAME("allocated"),		CTL(stats_arenas_i_small_allocated)},
-	{NAME("nmalloc"),		CTL(stats_arenas_i_small_nmalloc)},
-	{NAME("ndalloc"),		CTL(stats_arenas_i_small_ndalloc)},
-	{NAME("nrequests"),		CTL(stats_arenas_i_small_nrequests)}
+	{NAME("allocated"),	CTL(stats_arenas_i_small_allocated)},
+	{NAME("nmalloc"),	CTL(stats_arenas_i_small_nmalloc)},
+	{NAME("ndalloc"),	CTL(stats_arenas_i_small_ndalloc)},
+	{NAME("nrequests"),	CTL(stats_arenas_i_small_nrequests)}
 };
 
 static const ctl_named_node_t stats_arenas_i_large_node[] = {
-	{NAME("allocated"),		CTL(stats_arenas_i_large_allocated)},
-	{NAME("nmalloc"),		CTL(stats_arenas_i_large_nmalloc)},
-	{NAME("ndalloc"),		CTL(stats_arenas_i_large_ndalloc)},
-	{NAME("nrequests"),		CTL(stats_arenas_i_large_nrequests)}
+	{NAME("allocated"),	CTL(stats_arenas_i_large_allocated)},
+	{NAME("nmalloc"),	CTL(stats_arenas_i_large_nmalloc)},
+	{NAME("ndalloc"),	CTL(stats_arenas_i_large_ndalloc)},
+	{NAME("nrequests"),	CTL(stats_arenas_i_large_nrequests)}
+};
+
+static const ctl_named_node_t stats_arenas_i_huge_node[] = {
+	{NAME("allocated"),	CTL(stats_arenas_i_huge_allocated)},
+	{NAME("nmalloc"),	CTL(stats_arenas_i_huge_nmalloc)},
+	{NAME("ndalloc"),	CTL(stats_arenas_i_huge_ndalloc)},
+	{NAME("nrequests"),	CTL(stats_arenas_i_huge_nrequests)}
 };
 
 static const ctl_named_node_t stats_arenas_i_bins_j_node[] = {
-	{NAME("allocated"),		CTL(stats_arenas_i_bins_j_allocated)},
-	{NAME("nmalloc"),		CTL(stats_arenas_i_bins_j_nmalloc)},
-	{NAME("ndalloc"),		CTL(stats_arenas_i_bins_j_ndalloc)},
-	{NAME("nrequests"),		CTL(stats_arenas_i_bins_j_nrequests)},
-	{NAME("nfills"),		CTL(stats_arenas_i_bins_j_nfills)},
-	{NAME("nflushes"),		CTL(stats_arenas_i_bins_j_nflushes)},
-	{NAME("nruns"),			CTL(stats_arenas_i_bins_j_nruns)},
-	{NAME("nreruns"),		CTL(stats_arenas_i_bins_j_nreruns)},
-	{NAME("curruns"),		CTL(stats_arenas_i_bins_j_curruns)}
+	{NAME("nmalloc"),	CTL(stats_arenas_i_bins_j_nmalloc)},
+	{NAME("ndalloc"),	CTL(stats_arenas_i_bins_j_ndalloc)},
+	{NAME("nrequests"),	CTL(stats_arenas_i_bins_j_nrequests)},
+	{NAME("curregs"),	CTL(stats_arenas_i_bins_j_curregs)},
+	{NAME("nfills"),	CTL(stats_arenas_i_bins_j_nfills)},
+	{NAME("nflushes"),	CTL(stats_arenas_i_bins_j_nflushes)},
+	{NAME("nruns"),		CTL(stats_arenas_i_bins_j_nruns)},
+	{NAME("nreruns"),	CTL(stats_arenas_i_bins_j_nreruns)},
+	{NAME("curruns"),	CTL(stats_arenas_i_bins_j_curruns)}
 };
 static const ctl_named_node_t super_stats_arenas_i_bins_j_node[] = {
-	{NAME(""),			CHILD(named, stats_arenas_i_bins_j)}
+	{NAME(""),		CHILD(named, stats_arenas_i_bins_j)}
 };
 
 static const ctl_indexed_node_t stats_arenas_i_bins_node[] = {
 	{INDEX(stats_arenas_i_bins_j)}
 };
 
 static const ctl_named_node_t stats_arenas_i_lruns_j_node[] = {
-	{NAME("nmalloc"),		CTL(stats_arenas_i_lruns_j_nmalloc)},
-	{NAME("ndalloc"),		CTL(stats_arenas_i_lruns_j_ndalloc)},
-	{NAME("nrequests"),		CTL(stats_arenas_i_lruns_j_nrequests)},
-	{NAME("curruns"),		CTL(stats_arenas_i_lruns_j_curruns)}
+	{NAME("nmalloc"),	CTL(stats_arenas_i_lruns_j_nmalloc)},
+	{NAME("ndalloc"),	CTL(stats_arenas_i_lruns_j_ndalloc)},
+	{NAME("nrequests"),	CTL(stats_arenas_i_lruns_j_nrequests)},
+	{NAME("curruns"),	CTL(stats_arenas_i_lruns_j_curruns)}
 };
 static const ctl_named_node_t super_stats_arenas_i_lruns_j_node[] = {
-	{NAME(""),			CHILD(named, stats_arenas_i_lruns_j)}
+	{NAME(""),		CHILD(named, stats_arenas_i_lruns_j)}
 };
 
 static const ctl_indexed_node_t stats_arenas_i_lruns_node[] = {
 	{INDEX(stats_arenas_i_lruns_j)}
 };
 
+static const ctl_named_node_t stats_arenas_i_hchunks_j_node[] = {
+	{NAME("nmalloc"),	CTL(stats_arenas_i_hchunks_j_nmalloc)},
+	{NAME("ndalloc"),	CTL(stats_arenas_i_hchunks_j_ndalloc)},
+	{NAME("nrequests"),	CTL(stats_arenas_i_hchunks_j_nrequests)},
+	{NAME("curhchunks"),	CTL(stats_arenas_i_hchunks_j_curhchunks)}
+};
+static const ctl_named_node_t super_stats_arenas_i_hchunks_j_node[] = {
+	{NAME(""),		CHILD(named, stats_arenas_i_hchunks_j)}
+};
+
+static const ctl_indexed_node_t stats_arenas_i_hchunks_node[] = {
+	{INDEX(stats_arenas_i_hchunks_j)}
+};
+
 static const ctl_named_node_t stats_arenas_i_node[] = {
-	{NAME("nthreads"),		CTL(stats_arenas_i_nthreads)},
-	{NAME("dss"),			CTL(stats_arenas_i_dss)},
-	{NAME("pactive"),		CTL(stats_arenas_i_pactive)},
-	{NAME("pdirty"),		CTL(stats_arenas_i_pdirty)},
-	{NAME("mapped"),		CTL(stats_arenas_i_mapped)},
-	{NAME("npurge"),		CTL(stats_arenas_i_npurge)},
-	{NAME("nmadvise"),		CTL(stats_arenas_i_nmadvise)},
-	{NAME("purged"),		CTL(stats_arenas_i_purged)},
-	{NAME("small"),			CHILD(named, stats_arenas_i_small)},
-	{NAME("large"),			CHILD(named, stats_arenas_i_large)},
-	{NAME("bins"),			CHILD(indexed, stats_arenas_i_bins)},
-	{NAME("lruns"),			CHILD(indexed, stats_arenas_i_lruns)}
+	{NAME("nthreads"),	CTL(stats_arenas_i_nthreads)},
+	{NAME("dss"),		CTL(stats_arenas_i_dss)},
+	{NAME("lg_dirty_mult"),	CTL(stats_arenas_i_lg_dirty_mult)},
+	{NAME("pactive"),	CTL(stats_arenas_i_pactive)},
+	{NAME("pdirty"),	CTL(stats_arenas_i_pdirty)},
+	{NAME("mapped"),	CTL(stats_arenas_i_mapped)},
+	{NAME("npurge"),	CTL(stats_arenas_i_npurge)},
+	{NAME("nmadvise"),	CTL(stats_arenas_i_nmadvise)},
+	{NAME("purged"),	CTL(stats_arenas_i_purged)},
+	{NAME("metadata"),	CHILD(named, stats_arenas_i_metadata)},
+	{NAME("small"),		CHILD(named, stats_arenas_i_small)},
+	{NAME("large"),		CHILD(named, stats_arenas_i_large)},
+	{NAME("huge"),		CHILD(named, stats_arenas_i_huge)},
+	{NAME("bins"),		CHILD(indexed, stats_arenas_i_bins)},
+	{NAME("lruns"),		CHILD(indexed, stats_arenas_i_lruns)},
+	{NAME("hchunks"),	CHILD(indexed, stats_arenas_i_hchunks)}
 };
 static const ctl_named_node_t super_stats_arenas_i_node[] = {
-	{NAME(""),			CHILD(named, stats_arenas_i)}
+	{NAME(""),		CHILD(named, stats_arenas_i)}
 };
 
 static const ctl_indexed_node_t stats_arenas_node[] = {
 	{INDEX(stats_arenas_i)}
 };
 
 static const ctl_named_node_t stats_node[] = {
-	{NAME("cactive"),		CTL(stats_cactive)},
-	{NAME("allocated"),		CTL(stats_allocated)},
-	{NAME("active"),		CTL(stats_active)},
-	{NAME("mapped"),		CTL(stats_mapped)},
-	{NAME("chunks"),		CHILD(named, stats_chunks)},
-	{NAME("huge"),			CHILD(named, stats_huge)},
-	{NAME("arenas"),		CHILD(indexed, stats_arenas)}
+	{NAME("cactive"),	CTL(stats_cactive)},
+	{NAME("allocated"),	CTL(stats_allocated)},
+	{NAME("active"),	CTL(stats_active)},
+	{NAME("metadata"),	CTL(stats_metadata)},
+	{NAME("resident"),	CTL(stats_resident)},
+	{NAME("mapped"),	CTL(stats_mapped)},
+	{NAME("arenas"),	CHILD(indexed, stats_arenas)}
 };
 
 static const ctl_named_node_t	root_node[] = {
 	{NAME("version"),	CTL(version)},
 	{NAME("epoch"),		CTL(epoch)},
 	{NAME("thread"),	CHILD(named, thread)},
 	{NAME("config"),	CHILD(named, config)},
 	{NAME("opt"),		CHILD(named, opt)},
+	{NAME("tcache"),	CHILD(named, tcache)},
 	{NAME("arena"),		CHILD(indexed, arena)},
 	{NAME("arenas"),	CHILD(named, arenas)},
 	{NAME("prof"),		CHILD(named, prof)},
 	{NAME("stats"),		CHILD(named, stats)}
 };
 static const ctl_named_node_t super_root_node[] = {
@@ -428,50 +496,62 @@
 
 static bool
 ctl_arena_init(ctl_arena_stats_t *astats)
 {
 
 	if (astats->lstats == NULL) {
-		astats->lstats = (malloc_large_stats_t *)base_alloc(nlclasses *
+		astats->lstats = (malloc_large_stats_t *)a0malloc(nlclasses *
 		    sizeof(malloc_large_stats_t));
 		if (astats->lstats == NULL)
 			return (true);
 	}
 
+	if (astats->hstats == NULL) {
+		astats->hstats = (malloc_huge_stats_t *)a0malloc(nhclasses *
+		    sizeof(malloc_huge_stats_t));
+		if (astats->hstats == NULL)
+			return (true);
+	}
+
 	return (false);
 }
 
 static void
 ctl_arena_clear(ctl_arena_stats_t *astats)
 {
 
 	astats->dss = dss_prec_names[dss_prec_limit];
+	astats->lg_dirty_mult = -1;
 	astats->pactive = 0;
 	astats->pdirty = 0;
 	if (config_stats) {
 		memset(&astats->astats, 0, sizeof(arena_stats_t));
 		astats->allocated_small = 0;
 		astats->nmalloc_small = 0;
 		astats->ndalloc_small = 0;
 		astats->nrequests_small = 0;
 		memset(astats->bstats, 0, NBINS * sizeof(malloc_bin_stats_t));
 		memset(astats->lstats, 0, nlclasses *
 		    sizeof(malloc_large_stats_t));
+		memset(astats->hstats, 0, nhclasses *
+		    sizeof(malloc_huge_stats_t));
 	}
 }
 
 static void
 ctl_arena_stats_amerge(ctl_arena_stats_t *cstats, arena_t *arena)
 {
 	unsigned i;
 
-	arena_stats_merge(arena, &cstats->dss, &cstats->pactive,
-	    &cstats->pdirty, &cstats->astats, cstats->bstats, cstats->lstats);
+	arena_stats_merge(arena, &cstats->dss, &cstats->lg_dirty_mult,
+	    &cstats->pactive, &cstats->pdirty, &cstats->astats, cstats->bstats,
+	    cstats->lstats, cstats->hstats);
 
 	for (i = 0; i < NBINS; i++) {
-		cstats->allocated_small += cstats->bstats[i].allocated;
+		cstats->allocated_small += cstats->bstats[i].curregs *
+		    index2size(i);
 		cstats->nmalloc_small += cstats->bstats[i].nmalloc;
 		cstats->ndalloc_small += cstats->bstats[i].ndalloc;
 		cstats->nrequests_small += cstats->bstats[i].nrequests;
 	}
 }
 
@@ -485,43 +565,56 @@
 
 	sstats->astats.mapped += astats->astats.mapped;
 	sstats->astats.npurge += astats->astats.npurge;
 	sstats->astats.nmadvise += astats->astats.nmadvise;
 	sstats->astats.purged += astats->astats.purged;
 
+	sstats->astats.metadata_mapped += astats->astats.metadata_mapped;
+	sstats->astats.metadata_allocated += astats->astats.metadata_allocated;
+
 	sstats->allocated_small += astats->allocated_small;
 	sstats->nmalloc_small += astats->nmalloc_small;
 	sstats->ndalloc_small += astats->ndalloc_small;
 	sstats->nrequests_small += astats->nrequests_small;
 
 	sstats->astats.allocated_large += astats->astats.allocated_large;
 	sstats->astats.nmalloc_large += astats->astats.nmalloc_large;
 	sstats->astats.ndalloc_large += astats->astats.ndalloc_large;
 	sstats->astats.nrequests_large += astats->astats.nrequests_large;
 
-	for (i = 0; i < nlclasses; i++) {
-		sstats->lstats[i].nmalloc += astats->lstats[i].nmalloc;
-		sstats->lstats[i].ndalloc += astats->lstats[i].ndalloc;
-		sstats->lstats[i].nrequests += astats->lstats[i].nrequests;
-		sstats->lstats[i].curruns += astats->lstats[i].curruns;
-	}
+	sstats->astats.allocated_huge += astats->astats.allocated_huge;
+	sstats->astats.nmalloc_huge += astats->astats.nmalloc_huge;
+	sstats->astats.ndalloc_huge += astats->astats.ndalloc_huge;
 
 	for (i = 0; i < NBINS; i++) {
-		sstats->bstats[i].allocated += astats->bstats[i].allocated;
 		sstats->bstats[i].nmalloc += astats->bstats[i].nmalloc;
 		sstats->bstats[i].ndalloc += astats->bstats[i].ndalloc;
 		sstats->bstats[i].nrequests += astats->bstats[i].nrequests;
+		sstats->bstats[i].curregs += astats->bstats[i].curregs;
 		if (config_tcache) {
 			sstats->bstats[i].nfills += astats->bstats[i].nfills;
 			sstats->bstats[i].nflushes +=
 			    astats->bstats[i].nflushes;
 		}
 		sstats->bstats[i].nruns += astats->bstats[i].nruns;
 		sstats->bstats[i].reruns += astats->bstats[i].reruns;
 		sstats->bstats[i].curruns += astats->bstats[i].curruns;
 	}
+
+	for (i = 0; i < nlclasses; i++) {
+		sstats->lstats[i].nmalloc += astats->lstats[i].nmalloc;
+		sstats->lstats[i].ndalloc += astats->lstats[i].ndalloc;
+		sstats->lstats[i].nrequests += astats->lstats[i].nrequests;
+		sstats->lstats[i].curruns += astats->lstats[i].curruns;
+	}
+
+	for (i = 0; i < nhclasses; i++) {
+		sstats->hstats[i].nmalloc += astats->hstats[i].nmalloc;
+		sstats->hstats[i].ndalloc += astats->hstats[i].ndalloc;
+		sstats->hstats[i].curhchunks += astats->hstats[i].curhchunks;
+	}
 }
 
 static void
 ctl_arena_refresh(arena_t *arena, unsigned i)
 {
 	ctl_arena_stats_t *astats = &ctl_stats.arenas[i];
@@ -544,149 +637,124 @@
 }
 
 static bool
 ctl_grow(void)
 {
 	ctl_arena_stats_t *astats;
-	arena_t **tarenas;
 
-	/* Allocate extended arena stats and arenas arrays. */
-	astats = (ctl_arena_stats_t *)imalloc((ctl_stats.narenas + 2) *
+	/* Initialize new arena. */
+	if (arena_init(ctl_stats.narenas) == NULL)
+		return (true);
+
+	/* Allocate extended arena stats. */
+	astats = (ctl_arena_stats_t *)a0malloc((ctl_stats.narenas + 2) *
 	    sizeof(ctl_arena_stats_t));
 	if (astats == NULL)
 		return (true);
-	tarenas = (arena_t **)imalloc((ctl_stats.narenas + 1) *
-	    sizeof(arena_t *));
-	if (tarenas == NULL) {
-		idalloc(astats);
-		return (true);
-	}
 
 	/* Initialize the new astats element. */
 	memcpy(astats, ctl_stats.arenas, (ctl_stats.narenas + 1) *
 	    sizeof(ctl_arena_stats_t));
 	memset(&astats[ctl_stats.narenas + 1], 0, sizeof(ctl_arena_stats_t));
 	if (ctl_arena_init(&astats[ctl_stats.narenas + 1])) {
-		idalloc(tarenas);
-		idalloc(astats);
+		a0dalloc(astats);
 		return (true);
 	}
 	/* Swap merged stats to their new location. */
 	{
 		ctl_arena_stats_t tstats;
 		memcpy(&tstats, &astats[ctl_stats.narenas],
 		    sizeof(ctl_arena_stats_t));
 		memcpy(&astats[ctl_stats.narenas],
 		    &astats[ctl_stats.narenas + 1], sizeof(ctl_arena_stats_t));
 		memcpy(&astats[ctl_stats.narenas + 1], &tstats,
 		    sizeof(ctl_arena_stats_t));
 	}
-	/* Initialize the new arenas element. */
-	tarenas[ctl_stats.narenas] = NULL;
-	{
-		arena_t **arenas_old = arenas;
-		/*
-		 * Swap extended arenas array into place.  Although ctl_mtx
-		 * protects this function from other threads extending the
-		 * array, it does not protect from other threads mutating it
-		 * (i.e. initializing arenas and setting array elements to
-		 * point to them).  Therefore, array copying must happen under
-		 * the protection of arenas_lock.
-		 */
-		malloc_mutex_lock(&arenas_lock);
-		arenas = tarenas;
-		memcpy(arenas, arenas_old, ctl_stats.narenas *
-		    sizeof(arena_t *));
-		narenas_total++;
-		arenas_extend(narenas_total - 1);
-		malloc_mutex_unlock(&arenas_lock);
-		/*
-		 * Deallocate arenas_old only if it came from imalloc() (not
-		 * base_alloc()).
-		 */
-		if (ctl_stats.narenas != narenas_auto)
-			idalloc(arenas_old);
-	}
+	a0dalloc(ctl_stats.arenas);
 	ctl_stats.arenas = astats;
 	ctl_stats.narenas++;
 
 	return (false);
 }
 
 static void
 ctl_refresh(void)
 {
+	tsd_t *tsd;
 	unsigned i;
+	bool refreshed;
 	VARIABLE_ARRAY(arena_t *, tarenas, ctl_stats.narenas);
 
-	if (config_stats) {
-		malloc_mutex_lock(&chunks_mtx);
-		ctl_stats.chunks.current = stats_chunks.curchunks;
-		ctl_stats.chunks.total = stats_chunks.nchunks;
-		ctl_stats.chunks.high = stats_chunks.highchunks;
-		malloc_mutex_unlock(&chunks_mtx);
-
-		malloc_mutex_lock(&huge_mtx);
-		ctl_stats.huge.allocated = huge_allocated;
-		ctl_stats.huge.nmalloc = huge_nmalloc;
-		ctl_stats.huge.ndalloc = huge_ndalloc;
-		malloc_mutex_unlock(&huge_mtx);
-	}
-
 	/*
 	 * Clear sum stats, since they will be merged into by
 	 * ctl_arena_refresh().
 	 */
 	ctl_stats.arenas[ctl_stats.narenas].nthreads = 0;
 	ctl_arena_clear(&ctl_stats.arenas[ctl_stats.narenas]);
 
-	malloc_mutex_lock(&arenas_lock);
-	memcpy(tarenas, arenas, sizeof(arena_t *) * ctl_stats.narenas);
+	tsd = tsd_fetch();
+	for (i = 0, refreshed = false; i < ctl_stats.narenas; i++) {
+		tarenas[i] = arena_get(tsd, i, false, false);
+		if (tarenas[i] == NULL && !refreshed) {
+			tarenas[i] = arena_get(tsd, i, false, true);
+			refreshed = true;
+		}
+	}
+
 	for (i = 0; i < ctl_stats.narenas; i++) {
-		if (arenas[i] != NULL)
-			ctl_stats.arenas[i].nthreads = arenas[i]->nthreads;
+		if (tarenas[i] != NULL)
+			ctl_stats.arenas[i].nthreads = arena_nbound(i);
 		else
 			ctl_stats.arenas[i].nthreads = 0;
 	}
-	malloc_mutex_unlock(&arenas_lock);
+
 	for (i = 0; i < ctl_stats.narenas; i++) {
 		bool initialized = (tarenas[i] != NULL);
 
 		ctl_stats.arenas[i].initialized = initialized;
 		if (initialized)
 			ctl_arena_refresh(tarenas[i], i);
 	}
 
 	if (config_stats) {
+		size_t base_allocated, base_resident, base_mapped;
+		base_stats_get(&base_allocated, &base_resident, &base_mapped);
 		ctl_stats.allocated =
-		    ctl_stats.arenas[ctl_stats.narenas].allocated_small
-		    + ctl_stats.arenas[ctl_stats.narenas].astats.allocated_large
-		    + ctl_stats.huge.allocated;
+		    ctl_stats.arenas[ctl_stats.narenas].allocated_small +
+		    ctl_stats.arenas[ctl_stats.narenas].astats.allocated_large +
+		    ctl_stats.arenas[ctl_stats.narenas].astats.allocated_huge;
 		ctl_stats.active =
-		    (ctl_stats.arenas[ctl_stats.narenas].pactive << LG_PAGE)
-		    + ctl_stats.huge.allocated;
-		ctl_stats.mapped = (ctl_stats.chunks.current << opt_lg_chunk);
+		    (ctl_stats.arenas[ctl_stats.narenas].pactive << LG_PAGE);
+		ctl_stats.metadata = base_allocated +
+		    ctl_stats.arenas[ctl_stats.narenas].astats.metadata_mapped +
+		    ctl_stats.arenas[ctl_stats.narenas].astats
+		    .metadata_allocated;
+		ctl_stats.resident = base_resident +
+		    ctl_stats.arenas[ctl_stats.narenas].astats.metadata_mapped +
+		    ((ctl_stats.arenas[ctl_stats.narenas].pactive +
+		    ctl_stats.arenas[ctl_stats.narenas].pdirty) << LG_PAGE);
+		ctl_stats.mapped = base_mapped +
+		    ctl_stats.arenas[ctl_stats.narenas].astats.mapped;
 	}
 
 	ctl_epoch++;
 }
 
 static bool
 ctl_init(void)
 {
 	bool ret;
 
 	malloc_mutex_lock(&ctl_mtx);
-	if (ctl_initialized == false) {
+	if (!ctl_initialized) {
 		/*
 		 * Allocate space for one extra arena stats element, which
 		 * contains summed stats across all arenas.
 		 */
-		assert(narenas_auto == narenas_total_get());
-		ctl_stats.narenas = narenas_auto;
-		ctl_stats.arenas = (ctl_arena_stats_t *)base_alloc(
+		ctl_stats.narenas = narenas_total_get();
+		ctl_stats.arenas = (ctl_arena_stats_t *)a0malloc(
 		    (ctl_stats.narenas + 1) * sizeof(ctl_arena_stats_t));
 		if (ctl_stats.arenas == NULL) {
 			ret = true;
 			goto label_return;
 		}
 		memset(ctl_stats.arenas, 0, (ctl_stats.narenas + 1) *
@@ -698,12 +766,21 @@
 		 * cause inconsistent state to be viewable by the application.
 		 */
 		if (config_stats) {
 			unsigned i;
 			for (i = 0; i <= ctl_stats.narenas; i++) {
 				if (ctl_arena_init(&ctl_stats.arenas[i])) {
+					unsigned j;
+					for (j = 0; j < i; j++) {
+						a0dalloc(
+						    ctl_stats.arenas[j].lstats);
+						a0dalloc(
+						    ctl_stats.arenas[j].hstats);
+					}
+					a0dalloc(ctl_stats.arenas);
+					ctl_stats.arenas = NULL;
 					ret = true;
 					goto label_return;
 				}
 			}
 		}
 		ctl_stats.arenas[ctl_stats.narenas].initialized = true;
@@ -823,13 +900,13 @@
 	int ret;
 	size_t depth;
 	ctl_node_t const *nodes[CTL_MAX_DEPTH];
 	size_t mib[CTL_MAX_DEPTH];
 	const ctl_named_node_t *node;
 
-	if (ctl_initialized == false && ctl_init()) {
+	if (!ctl_initialized && ctl_init()) {
 		ret = EAGAIN;
 		goto label_return;
 	}
 
 	depth = CTL_MAX_DEPTH;
 	ret = ctl_lookup(name, nodes, mib, &depth);
@@ -850,13 +927,13 @@
 
 int
 ctl_nametomib(const char *name, size_t *mibp, size_t *miblenp)
 {
 	int ret;
 
-	if (ctl_initialized == false && ctl_init()) {
+	if (!ctl_initialized && ctl_init()) {
 		ret = EAGAIN;
 		goto label_return;
 	}
 
 	ret = ctl_lookup(name, NULL, mibp, miblenp);
 label_return:
@@ -868,13 +945,13 @@
     void *newp, size_t newlen)
 {
 	int ret;
 	const ctl_named_node_t *node;
 	size_t i;
 
-	if (ctl_initialized == false && ctl_init()) {
+	if (!ctl_initialized && ctl_init()) {
 		ret = EAGAIN;
 		goto label_return;
 	}
 
 	/* Iterate down the tree. */
 	node = super_root_node;
@@ -960,22 +1037,30 @@
 	if (oldp != NULL || oldlenp != NULL) {				\
 		ret = EPERM;						\
 		goto label_return;					\
 	}								\
 } while (0)
 
+#define	READ_XOR_WRITE()	do {					\
+	if ((oldp != NULL && oldlenp != NULL) && (newp != NULL ||	\
+	    newlen != 0)) {						\
+		ret = EPERM;						\
+		goto label_return;					\
+	}								\
+} while (0)
+
 #define	READ(v, t)	do {						\
 	if (oldp != NULL && oldlenp != NULL) {				\
 		if (*oldlenp != sizeof(t)) {				\
 			size_t	copylen = (sizeof(t) <= *oldlenp)	\
 			    ? sizeof(t) : *oldlenp;			\
 			memcpy(oldp, (void *)&(v), copylen);		\
 			ret = EINVAL;					\
 			goto label_return;				\
-		} else							\
-			*(t *)oldp = (v);				\
+		}							\
+		*(t *)oldp = (v);					\
 	}								\
 } while (0)
 
 #define	WRITE(v, t)	do {						\
 	if (newp != NULL) {						\
 		if (newlen != sizeof(t)) {				\
@@ -995,13 +1080,13 @@
 n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
     void *newp, size_t newlen)						\
 {									\
 	int ret;							\
 	t oldval;							\
 									\
-	if ((c) == false)						\
+	if (!(c))							\
 		return (ENOENT);					\
 	if (l)								\
 		malloc_mutex_lock(&ctl_mtx);				\
 	READONLY();							\
 	oldval = (v);							\
 	READ(oldval, t);						\
@@ -1018,13 +1103,13 @@
 n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
     void *newp, size_t newlen)						\
 {									\
 	int ret;							\
 	t oldval;							\
 									\
-	if ((c) == false)						\
+	if (!(c))							\
 		return (ENOENT);					\
 	malloc_mutex_lock(&ctl_mtx);					\
 	READONLY();							\
 	oldval = (v);							\
 	READ(oldval, t);						\
 									\
@@ -1062,13 +1147,13 @@
 n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
     void *newp, size_t newlen)						\
 {									\
 	int ret;							\
 	t oldval;							\
 									\
-	if ((c) == false)						\
+	if (!(c))							\
 		return (ENOENT);					\
 	READONLY();							\
 	oldval = (v);							\
 	READ(oldval, t);						\
 									\
 	ret = 0;							\
@@ -1090,12 +1175,33 @@
 									\
 	ret = 0;							\
 label_return:								\
 	return (ret);							\
 }
 
+#define	CTL_TSD_RO_NL_CGEN(c, n, m, t)					\
+static int								\
+n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
+    void *newp, size_t newlen)						\
+{									\
+	int ret;							\
+	t oldval;							\
+	tsd_t *tsd;							\
+									\
+	if (!(c))							\
+		return (ENOENT);					\
+	READONLY();							\
+	tsd = tsd_fetch();						\
+	oldval = (m(tsd));						\
+	READ(oldval, t);						\
+									\
+	ret = 0;							\
+label_return:								\
+	return (ret);							\
+}
+
 #define	CTL_RO_BOOL_CONFIG_GEN(n)					\
 static int								\
 n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
     void *newp, size_t newlen)						\
 {									\
 	int ret;							\
@@ -1132,17 +1238,16 @@
 	malloc_mutex_unlock(&ctl_mtx);
 	return (ret);
 }
 
 /******************************************************************************/
 
+CTL_RO_BOOL_CONFIG_GEN(config_cache_oblivious)
 CTL_RO_BOOL_CONFIG_GEN(config_debug)
-CTL_RO_BOOL_CONFIG_GEN(config_dss)
 CTL_RO_BOOL_CONFIG_GEN(config_fill)
 CTL_RO_BOOL_CONFIG_GEN(config_lazy_lock)
-CTL_RO_BOOL_CONFIG_GEN(config_mremap)
 CTL_RO_BOOL_CONFIG_GEN(config_munmap)
 CTL_RO_BOOL_CONFIG_GEN(config_prof)
 CTL_RO_BOOL_CONFIG_GEN(config_prof_libgcc)
 CTL_RO_BOOL_CONFIG_GEN(config_prof_libunwind)
 CTL_RO_BOOL_CONFIG_GEN(config_stats)
 CTL_RO_BOOL_CONFIG_GEN(config_tcache)
@@ -1156,24 +1261,25 @@
 CTL_RO_NL_GEN(opt_abort, opt_abort, bool)
 CTL_RO_NL_GEN(opt_dss, opt_dss, const char *)
 CTL_RO_NL_GEN(opt_lg_chunk, opt_lg_chunk, size_t)
 CTL_RO_NL_GEN(opt_narenas, opt_narenas, size_t)
 CTL_RO_NL_GEN(opt_lg_dirty_mult, opt_lg_dirty_mult, ssize_t)
 CTL_RO_NL_GEN(opt_stats_print, opt_stats_print, bool)
-CTL_RO_NL_CGEN(config_fill, opt_junk, opt_junk, bool)
+CTL_RO_NL_CGEN(config_fill, opt_junk, opt_junk, const char *)
 CTL_RO_NL_CGEN(config_fill, opt_quarantine, opt_quarantine, size_t)
 CTL_RO_NL_CGEN(config_fill, opt_redzone, opt_redzone, bool)
 CTL_RO_NL_CGEN(config_fill, opt_zero, opt_zero, bool)
 CTL_RO_NL_CGEN(config_utrace, opt_utrace, opt_utrace, bool)
-CTL_RO_NL_CGEN(config_valgrind, opt_valgrind, opt_valgrind, bool)
 CTL_RO_NL_CGEN(config_xmalloc, opt_xmalloc, opt_xmalloc, bool)
 CTL_RO_NL_CGEN(config_tcache, opt_tcache, opt_tcache, bool)
 CTL_RO_NL_CGEN(config_tcache, opt_lg_tcache_max, opt_lg_tcache_max, ssize_t)
 CTL_RO_NL_CGEN(config_prof, opt_prof, opt_prof, bool)
 CTL_RO_NL_CGEN(config_prof, opt_prof_prefix, opt_prof_prefix, const char *)
-CTL_RO_CGEN(config_prof, opt_prof_active, opt_prof_active, bool) /* Mutable. */
+CTL_RO_NL_CGEN(config_prof, opt_prof_active, opt_prof_active, bool)
+CTL_RO_NL_CGEN(config_prof, opt_prof_thread_active_init,
+    opt_prof_thread_active_init, bool)
 CTL_RO_NL_CGEN(config_prof, opt_lg_prof_sample, opt_lg_prof_sample, size_t)
 CTL_RO_NL_CGEN(config_prof, opt_prof_accum, opt_prof_accum, bool)
 CTL_RO_NL_CGEN(config_prof, opt_lg_prof_interval, opt_lg_prof_interval, ssize_t)
 CTL_RO_NL_CGEN(config_prof, opt_prof_gdump, opt_prof_gdump, bool)
 CTL_RO_NL_CGEN(config_prof, opt_prof_final, opt_prof_final, bool)
 CTL_RO_NL_CGEN(config_prof, opt_prof_leak, opt_prof_leak, bool)
@@ -1182,75 +1288,74 @@
 
 static int
 thread_arena_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
     void *newp, size_t newlen)
 {
 	int ret;
+	tsd_t *tsd;
+	arena_t *oldarena;
 	unsigned newind, oldind;
 
+	tsd = tsd_fetch();
+	oldarena = arena_choose(tsd, NULL);
+	if (oldarena == NULL)
+		return (EAGAIN);
+
 	malloc_mutex_lock(&ctl_mtx);
-	newind = oldind = choose_arena(NULL)->ind;
+	newind = oldind = oldarena->ind;
 	WRITE(newind, unsigned);
 	READ(oldind, unsigned);
 	if (newind != oldind) {
-		arena_t *arena;
+		arena_t *newarena;
 
 		if (newind >= ctl_stats.narenas) {
 			/* New arena index is out of range. */
 			ret = EFAULT;
 			goto label_return;
 		}
 
 		/* Initialize arena if necessary. */
-		malloc_mutex_lock(&arenas_lock);
-		if ((arena = arenas[newind]) == NULL && (arena =
-		    arenas_extend(newind)) == NULL) {
-			malloc_mutex_unlock(&arenas_lock);
+		newarena = arena_get(tsd, newind, true, true);
+		if (newarena == NULL) {
 			ret = EAGAIN;
 			goto label_return;
 		}
-		assert(arena == arenas[newind]);
-		arenas[oldind]->nthreads--;
-		arenas[newind]->nthreads++;
-		malloc_mutex_unlock(&arenas_lock);
-
-		/* Set new arena association. */
+		/* Set new arena/tcache associations. */
+		arena_migrate(tsd, oldind, newind);
 		if (config_tcache) {
-			tcache_t *tcache;
-			if ((uintptr_t)(tcache = *tcache_tsd_get()) >
-			    (uintptr_t)TCACHE_STATE_MAX) {
-				tcache_arena_dissociate(tcache);
-				tcache_arena_associate(tcache, arena);
+			tcache_t *tcache = tsd_tcache_get(tsd);
+			if (tcache != NULL) {
+				tcache_arena_reassociate(tcache, oldarena,
+				    newarena);
 			}
 		}
-		arenas_tsd_set(&arena);
 	}
 
 	ret = 0;
 label_return:
 	malloc_mutex_unlock(&ctl_mtx);
 	return (ret);
 }
 
-CTL_RO_NL_CGEN(config_stats, thread_allocated,
-    thread_allocated_tsd_get()->allocated, uint64_t)
-CTL_RO_NL_CGEN(config_stats, thread_allocatedp,
-    &thread_allocated_tsd_get()->allocated, uint64_t *)
-CTL_RO_NL_CGEN(config_stats, thread_deallocated,
-    thread_allocated_tsd_get()->deallocated, uint64_t)
-CTL_RO_NL_CGEN(config_stats, thread_deallocatedp,
-    &thread_allocated_tsd_get()->deallocated, uint64_t *)
+CTL_TSD_RO_NL_CGEN(config_stats, thread_allocated, tsd_thread_allocated_get,
+    uint64_t)
+CTL_TSD_RO_NL_CGEN(config_stats, thread_allocatedp, tsd_thread_allocatedp_get,
+    uint64_t *)
+CTL_TSD_RO_NL_CGEN(config_stats, thread_deallocated, tsd_thread_deallocated_get,
+    uint64_t)
+CTL_TSD_RO_NL_CGEN(config_stats, thread_deallocatedp,
+    tsd_thread_deallocatedp_get, uint64_t *)
 
 static int
 thread_tcache_enabled_ctl(const size_t *mib, size_t miblen, void *oldp,
     size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	bool oldval;
 
-	if (config_tcache == false)
+	if (!config_tcache)
 		return (ENOENT);
 
 	oldval = tcache_enabled_get();
 	if (newp != NULL) {
 		if (newlen != sizeof(bool)) {
 			ret = EINVAL;
@@ -1268,36 +1373,189 @@
 static int
 thread_tcache_flush_ctl(const size_t *mib, size_t miblen, void *oldp,
     size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 
-	if (config_tcache == false)
+	if (!config_tcache)
 		return (ENOENT);
 
 	READONLY();
 	WRITEONLY();
 
 	tcache_flush();
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
+static int
+thread_prof_name_ctl(const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+
+	if (!config_prof)
+		return (ENOENT);
+
+	READ_XOR_WRITE();
+
+	if (newp != NULL) {
+		tsd_t *tsd;
+
+		if (newlen != sizeof(const char *)) {
+			ret = EINVAL;
+			goto label_return;
+		}
+
+		tsd = tsd_fetch();
+
+		if ((ret = prof_thread_name_set(tsd, *(const char **)newp)) !=
+		    0)
+			goto label_return;
+	} else {
+		const char *oldname = prof_thread_name_get();
+		READ(oldname, const char *);
+	}
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
+static int
+thread_prof_active_ctl(const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+	bool oldval;
+
+	if (!config_prof)
+		return (ENOENT);
+
+	oldval = prof_thread_active_get();
+	if (newp != NULL) {
+		if (newlen != sizeof(bool)) {
+			ret = EINVAL;
+			goto label_return;
+		}
+		if (prof_thread_active_set(*(bool *)newp)) {
+			ret = EAGAIN;
+			goto label_return;
+		}
+	}
+	READ(oldval, bool);
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
+/******************************************************************************/
+
+static int
+tcache_create_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
+    void *newp, size_t newlen)
+{
+	int ret;
+	tsd_t *tsd;
+	unsigned tcache_ind;
+
+	if (!config_tcache)
+		return (ENOENT);
+
+	tsd = tsd_fetch();
+
+	malloc_mutex_lock(&ctl_mtx);
+	READONLY();
+	if (tcaches_create(tsd, &tcache_ind)) {
+		ret = EFAULT;
+		goto label_return;
+	}
+	READ(tcache_ind, unsigned);
+
+	ret = 0;
+label_return:
+	malloc_mutex_unlock(&ctl_mtx);
+	return (ret);
+}
+
+static int
+tcache_flush_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
+    void *newp, size_t newlen)
+{
+	int ret;
+	tsd_t *tsd;
+	unsigned tcache_ind;
+
+	if (!config_tcache)
+		return (ENOENT);
+
+	tsd = tsd_fetch();
+
+	WRITEONLY();
+	tcache_ind = UINT_MAX;
+	WRITE(tcache_ind, unsigned);
+	if (tcache_ind == UINT_MAX) {
+		ret = EFAULT;
+		goto label_return;
+	}
+	tcaches_flush(tsd, tcache_ind);
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
+static int
+tcache_destroy_ctl(const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+	tsd_t *tsd;
+	unsigned tcache_ind;
+
+	if (!config_tcache)
+		return (ENOENT);
+
+	tsd = tsd_fetch();
+
+	WRITEONLY();
+	tcache_ind = UINT_MAX;
+	WRITE(tcache_ind, unsigned);
+	if (tcache_ind == UINT_MAX) {
+		ret = EFAULT;
+		goto label_return;
+	}
+	tcaches_destroy(tsd, tcache_ind);
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
 /******************************************************************************/
 
 /* ctl_mutex must be held during execution of this function. */
 static void
 arena_purge(unsigned arena_ind)
 {
+	tsd_t *tsd;
+	unsigned i;
+	bool refreshed;
 	VARIABLE_ARRAY(arena_t *, tarenas, ctl_stats.narenas);
 
-	malloc_mutex_lock(&arenas_lock);
-	memcpy(tarenas, arenas, sizeof(arena_t *) * ctl_stats.narenas);
-	malloc_mutex_unlock(&arenas_lock);
+	tsd = tsd_fetch();
+	for (i = 0, refreshed = false; i < ctl_stats.narenas; i++) {
+		tarenas[i] = arena_get(tsd, i, false, false);
+		if (tarenas[i] == NULL && !refreshed) {
+			tarenas[i] = arena_get(tsd, i, false, true);
+			refreshed = true;
+		}
+	}
 
 	if (arena_ind == ctl_stats.narenas) {
 		unsigned i;
 		for (i = 0; i < ctl_stats.narenas; i++) {
 			if (tarenas[i] != NULL)
 				arena_purge_all(tarenas[i]);
@@ -1327,53 +1585,123 @@
 }
 
 static int
 arena_i_dss_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
     void *newp, size_t newlen)
 {
-	int ret, i;
-	bool match, err;
-	const char *dss;
+	int ret;
+	const char *dss = NULL;
 	unsigned arena_ind = mib[1];
 	dss_prec_t dss_prec_old = dss_prec_limit;
 	dss_prec_t dss_prec = dss_prec_limit;
 
 	malloc_mutex_lock(&ctl_mtx);
 	WRITE(dss, const char *);
-	match = false;
-	for (i = 0; i < dss_prec_limit; i++) {
-		if (strcmp(dss_prec_names[i], dss) == 0) {
-			dss_prec = i;
-			match = true;
-			break;
+	if (dss != NULL) {
+		int i;
+		bool match = false;
+
+		for (i = 0; i < dss_prec_limit; i++) {
+			if (strcmp(dss_prec_names[i], dss) == 0) {
+				dss_prec = i;
+				match = true;
+				break;
+			}
+		}
+
+		if (!match) {
+			ret = EINVAL;
+			goto label_return;
 		}
-	}
-	if (match == false) {
-		ret = EINVAL;
-		goto label_return;
 	}
 
 	if (arena_ind < ctl_stats.narenas) {
-		arena_t *arena = arenas[arena_ind];
-		if (arena != NULL) {
-			dss_prec_old = arena_dss_prec_get(arena);
-			arena_dss_prec_set(arena, dss_prec);
-			err = false;
-		} else
-			err = true;
+		arena_t *arena = arena_get(tsd_fetch(), arena_ind, false, true);
+		if (arena == NULL || (dss_prec != dss_prec_limit &&
+		    arena_dss_prec_set(arena, dss_prec))) {
+			ret = EFAULT;
+			goto label_return;
+		}
+		dss_prec_old = arena_dss_prec_get(arena);
 	} else {
+		if (dss_prec != dss_prec_limit &&
+		    chunk_dss_prec_set(dss_prec)) {
+			ret = EFAULT;
+			goto label_return;
+		}
 		dss_prec_old = chunk_dss_prec_get();
-		err = chunk_dss_prec_set(dss_prec);
 	}
+
 	dss = dss_prec_names[dss_prec_old];
 	READ(dss, const char *);
-	if (err) {
+
+	ret = 0;
+label_return:
+	malloc_mutex_unlock(&ctl_mtx);
+	return (ret);
+}
+
+static int
+arena_i_lg_dirty_mult_ctl(const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+	unsigned arena_ind = mib[1];
+	arena_t *arena;
+
+	arena = arena_get(tsd_fetch(), arena_ind, false, true);
+	if (arena == NULL) {
 		ret = EFAULT;
 		goto label_return;
 	}
 
+	if (oldp != NULL && oldlenp != NULL) {
+		size_t oldval = arena_lg_dirty_mult_get(arena);
+		READ(oldval, ssize_t);
+	}
+	if (newp != NULL) {
+		if (newlen != sizeof(ssize_t)) {
+			ret = EINVAL;
+			goto label_return;
+		}
+		if (arena_lg_dirty_mult_set(arena, *(ssize_t *)newp)) {
+			ret = EFAULT;
+			goto label_return;
+		}
+	}
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
+static int
+arena_i_chunk_hooks_ctl(const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+	unsigned arena_ind = mib[1];
+	arena_t *arena;
+
+	malloc_mutex_lock(&ctl_mtx);
+	if (arena_ind < narenas_total_get() && (arena =
+	    arena_get(tsd_fetch(), arena_ind, false, true)) != NULL) {
+		if (newp != NULL) {
+			chunk_hooks_t old_chunk_hooks, new_chunk_hooks;
+			WRITE(new_chunk_hooks, chunk_hooks_t);
+			old_chunk_hooks = chunk_hooks_set(arena,
+			    &new_chunk_hooks);
+			READ(old_chunk_hooks, chunk_hooks_t);
+		} else {
+			chunk_hooks_t old_chunk_hooks = chunk_hooks_get(arena);
+			READ(old_chunk_hooks, chunk_hooks_t);
+		}
+	} else {
+		ret = EFAULT;
+		goto label_return;
+	}
 	ret = 0;
 label_return:
 	malloc_mutex_unlock(&ctl_mtx);
 	return (ret);
 }
 
@@ -1441,12 +1769,38 @@
 
 label_return:
 	malloc_mutex_unlock(&ctl_mtx);
 	return (ret);
 }
 
+static int
+arenas_lg_dirty_mult_ctl(const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+
+	if (oldp != NULL && oldlenp != NULL) {
+		size_t oldval = arena_lg_dirty_mult_default_get();
+		READ(oldval, ssize_t);
+	}
+	if (newp != NULL) {
+		if (newlen != sizeof(ssize_t)) {
+			ret = EINVAL;
+			goto label_return;
+		}
+		if (arena_lg_dirty_mult_default_set(*(ssize_t *)newp)) {
+			ret = EFAULT;
+			goto label_return;
+		}
+	}
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
 CTL_RO_NL_GEN(arenas_quantum, QUANTUM, size_t)
 CTL_RO_NL_GEN(arenas_page, PAGE, size_t)
 CTL_RO_NL_CGEN(config_tcache, arenas_tcache_max, tcache_maxclass, size_t)
 CTL_RO_NL_GEN(arenas_nbins, NBINS, unsigned)
 CTL_RO_NL_CGEN(config_tcache, arenas_nhbins, nhbins, unsigned)
 CTL_RO_NL_GEN(arenas_bin_i_size, arena_bin_info[mib[2]].reg_size, size_t)
@@ -1458,46 +1812,32 @@
 
 	if (i > NBINS)
 		return (NULL);
 	return (super_arenas_bin_i_node);
 }
 
-CTL_RO_NL_GEN(arenas_nlruns, nlclasses, size_t)
-CTL_RO_NL_GEN(arenas_lrun_i_size, ((mib[2]+1) << LG_PAGE), size_t)
+CTL_RO_NL_GEN(arenas_nlruns, nlclasses, unsigned)
+CTL_RO_NL_GEN(arenas_lrun_i_size, index2size(NBINS+mib[2]), size_t)
 static const ctl_named_node_t *
 arenas_lrun_i_index(const size_t *mib, size_t miblen, size_t i)
 {
 
 	if (i > nlclasses)
 		return (NULL);
 	return (super_arenas_lrun_i_node);
 }
 
-static int
-arenas_purge_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+CTL_RO_NL_GEN(arenas_nhchunks, nhclasses, unsigned)
+CTL_RO_NL_GEN(arenas_hchunk_i_size, index2size(NBINS+nlclasses+mib[2]), size_t)
+static const ctl_named_node_t *
+arenas_hchunk_i_index(const size_t *mib, size_t miblen, size_t i)
 {
-	int ret;
-	unsigned arena_ind;
-
-	malloc_mutex_lock(&ctl_mtx);
-	WRITEONLY();
-	arena_ind = UINT_MAX;
-	WRITE(arena_ind, unsigned);
-	if (newp != NULL && arena_ind >= ctl_stats.narenas)
-		ret = EFAULT;
-	else {
-		if (arena_ind == UINT_MAX)
-			arena_ind = ctl_stats.narenas;
-		arena_purge(arena_ind);
-		ret = 0;
-	}
 
-label_return:
-	malloc_mutex_unlock(&ctl_mtx);
-	return (ret);
+	if (i > nhclasses)
+		return (NULL);
+	return (super_arenas_hchunk_i_node);
 }
 
 static int
 arenas_extend_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
     void *newp, size_t newlen)
 {
@@ -1519,48 +1859,69 @@
 	return (ret);
 }
 
 /******************************************************************************/
 
 static int
+prof_thread_active_init_ctl(const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+	bool oldval;
+
+	if (!config_prof)
+		return (ENOENT);
+
+	if (newp != NULL) {
+		if (newlen != sizeof(bool)) {
+			ret = EINVAL;
+			goto label_return;
+		}
+		oldval = prof_thread_active_init_set(*(bool *)newp);
+	} else
+		oldval = prof_thread_active_init_get();
+	READ(oldval, bool);
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
+static int
 prof_active_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
     void *newp, size_t newlen)
 {
 	int ret;
 	bool oldval;
 
-	if (config_prof == false)
+	if (!config_prof)
 		return (ENOENT);
 
-	malloc_mutex_lock(&ctl_mtx); /* Protect opt_prof_active. */
-	oldval = opt_prof_active;
 	if (newp != NULL) {
-		/*
-		 * The memory barriers will tend to make opt_prof_active
-		 * propagate faster on systems with weak memory ordering.
-		 */
-		mb_write();
-		WRITE(opt_prof_active, bool);
-		mb_write();
-	}
+		if (newlen != sizeof(bool)) {
+			ret = EINVAL;
+			goto label_return;
+		}
+		oldval = prof_active_set(*(bool *)newp);
+	} else
+		oldval = prof_active_get();
 	READ(oldval, bool);
 
 	ret = 0;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
 	return (ret);
 }
 
 static int
 prof_dump_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
     void *newp, size_t newlen)
 {
 	int ret;
 	const char *filename = NULL;
 
-	if (config_prof == false)
+	if (!config_prof)
 		return (ENOENT);
 
 	WRITEONLY();
 	WRITE(filename, const char *);
 
 	if (prof_mdump(filename)) {
@@ -1570,41 +1931,92 @@
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
+static int
+prof_gdump_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
+    void *newp, size_t newlen)
+{
+	int ret;
+	bool oldval;
+
+	if (!config_prof)
+		return (ENOENT);
+
+	if (newp != NULL) {
+		if (newlen != sizeof(bool)) {
+			ret = EINVAL;
+			goto label_return;
+		}
+		oldval = prof_gdump_set(*(bool *)newp);
+	} else
+		oldval = prof_gdump_get();
+	READ(oldval, bool);
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
+static int
+prof_reset_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
+    void *newp, size_t newlen)
+{
+	int ret;
+	size_t lg_sample = lg_prof_sample;
+	tsd_t *tsd;
+
+	if (!config_prof)
+		return (ENOENT);
+
+	WRITEONLY();
+	WRITE(lg_sample, size_t);
+	if (lg_sample >= (sizeof(uint64_t) << 3))
+		lg_sample = (sizeof(uint64_t) << 3) - 1;
+
+	tsd = tsd_fetch();
+
+	prof_reset(tsd, lg_sample);
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
 CTL_RO_NL_CGEN(config_prof, prof_interval, prof_interval, uint64_t)
+CTL_RO_NL_CGEN(config_prof, lg_prof_sample, lg_prof_sample, size_t)
 
 /******************************************************************************/
 
 CTL_RO_CGEN(config_stats, stats_cactive, &stats_cactive, size_t *)
 CTL_RO_CGEN(config_stats, stats_allocated, ctl_stats.allocated, size_t)
 CTL_RO_CGEN(config_stats, stats_active, ctl_stats.active, size_t)
+CTL_RO_CGEN(config_stats, stats_metadata, ctl_stats.metadata, size_t)
+CTL_RO_CGEN(config_stats, stats_resident, ctl_stats.resident, size_t)
 CTL_RO_CGEN(config_stats, stats_mapped, ctl_stats.mapped, size_t)
 
-CTL_RO_CGEN(config_stats, stats_chunks_current, ctl_stats.chunks.current,
-    size_t)
-CTL_RO_CGEN(config_stats, stats_chunks_total, ctl_stats.chunks.total, uint64_t)
-CTL_RO_CGEN(config_stats, stats_chunks_high, ctl_stats.chunks.high, size_t)
-CTL_RO_CGEN(config_stats, stats_huge_allocated, huge_allocated, size_t)
-CTL_RO_CGEN(config_stats, stats_huge_nmalloc, huge_nmalloc, uint64_t)
-CTL_RO_CGEN(config_stats, stats_huge_ndalloc, huge_ndalloc, uint64_t)
-
 CTL_RO_GEN(stats_arenas_i_dss, ctl_stats.arenas[mib[2]].dss, const char *)
+CTL_RO_GEN(stats_arenas_i_lg_dirty_mult, ctl_stats.arenas[mib[2]].lg_dirty_mult,
+    ssize_t)
 CTL_RO_GEN(stats_arenas_i_nthreads, ctl_stats.arenas[mib[2]].nthreads, unsigned)
 CTL_RO_GEN(stats_arenas_i_pactive, ctl_stats.arenas[mib[2]].pactive, size_t)
 CTL_RO_GEN(stats_arenas_i_pdirty, ctl_stats.arenas[mib[2]].pdirty, size_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_mapped,
     ctl_stats.arenas[mib[2]].astats.mapped, size_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_npurge,
     ctl_stats.arenas[mib[2]].astats.npurge, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_nmadvise,
     ctl_stats.arenas[mib[2]].astats.nmadvise, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_purged,
     ctl_stats.arenas[mib[2]].astats.purged, uint64_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_metadata_mapped,
+    ctl_stats.arenas[mib[2]].astats.metadata_mapped, size_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_metadata_allocated,
+    ctl_stats.arenas[mib[2]].astats.metadata_allocated, size_t)
 
 CTL_RO_CGEN(config_stats, stats_arenas_i_small_allocated,
     ctl_stats.arenas[mib[2]].allocated_small, size_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_small_nmalloc,
     ctl_stats.arenas[mib[2]].nmalloc_small, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_small_ndalloc,
@@ -1616,21 +2028,29 @@
 CTL_RO_CGEN(config_stats, stats_arenas_i_large_nmalloc,
     ctl_stats.arenas[mib[2]].astats.nmalloc_large, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_large_ndalloc,
     ctl_stats.arenas[mib[2]].astats.ndalloc_large, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_large_nrequests,
     ctl_stats.arenas[mib[2]].astats.nrequests_large, uint64_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_huge_allocated,
+    ctl_stats.arenas[mib[2]].astats.allocated_huge, size_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_huge_nmalloc,
+    ctl_stats.arenas[mib[2]].astats.nmalloc_huge, uint64_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_huge_ndalloc,
+    ctl_stats.arenas[mib[2]].astats.ndalloc_huge, uint64_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_huge_nrequests,
+    ctl_stats.arenas[mib[2]].astats.nmalloc_huge, uint64_t) /* Intentional. */
 
-CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_allocated,
-    ctl_stats.arenas[mib[2]].bstats[mib[4]].allocated, size_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nmalloc,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].nmalloc, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_ndalloc,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].ndalloc, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nrequests,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].nrequests, uint64_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_curregs,
+    ctl_stats.arenas[mib[2]].bstats[mib[4]].curregs, size_t)
 CTL_RO_CGEN(config_stats && config_tcache, stats_arenas_i_bins_j_nfills,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].nfills, uint64_t)
 CTL_RO_CGEN(config_stats && config_tcache, stats_arenas_i_bins_j_nflushes,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].nflushes, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nruns,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].nruns, uint64_t)
@@ -1663,19 +2083,38 @@
 
 	if (j > nlclasses)
 		return (NULL);
 	return (super_stats_arenas_i_lruns_j_node);
 }
 
+CTL_RO_CGEN(config_stats, stats_arenas_i_hchunks_j_nmalloc,
+    ctl_stats.arenas[mib[2]].hstats[mib[4]].nmalloc, uint64_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_hchunks_j_ndalloc,
+    ctl_stats.arenas[mib[2]].hstats[mib[4]].ndalloc, uint64_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_hchunks_j_nrequests,
+    ctl_stats.arenas[mib[2]].hstats[mib[4]].nmalloc, /* Intentional. */
+    uint64_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_hchunks_j_curhchunks,
+    ctl_stats.arenas[mib[2]].hstats[mib[4]].curhchunks, size_t)
+
+static const ctl_named_node_t *
+stats_arenas_i_hchunks_j_index(const size_t *mib, size_t miblen, size_t j)
+{
+
+	if (j > nhclasses)
+		return (NULL);
+	return (super_stats_arenas_i_hchunks_j_node);
+}
+
 static const ctl_named_node_t *
 stats_arenas_i_index(const size_t *mib, size_t miblen, size_t i)
 {
 	const ctl_named_node_t * ret;
 
 	malloc_mutex_lock(&ctl_mtx);
-	if (i > ctl_stats.narenas || ctl_stats.arenas[i].initialized == false) {
+	if (i > ctl_stats.narenas || !ctl_stats.arenas[i].initialized) {
 		ret = NULL;
 		goto label_return;
 	}
 
 	ret = super_stats_arenas_i_node;
 label_return:
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.d	2017-09-27 22:47:57.486963318 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.d	2017-09-27 22:49:20.442960278 +0800
@@ -1,20 +1,21 @@
 src/ctl.o: src/ctl.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,39 +1,53 @@
 #define	JEMALLOC_EXTENT_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 
-static inline int
+JEMALLOC_INLINE_C size_t
+extent_quantize(size_t size)
+{
+
+	/*
+	 * Round down to the nearest chunk size that can actually be requested
+	 * during normal huge allocation.
+	 */
+	return (index2size(size2index(size + 1) - 1));
+}
+
+JEMALLOC_INLINE_C int
 extent_szad_comp(extent_node_t *a, extent_node_t *b)
 {
 	int ret;
-	size_t a_size = a->size;
-	size_t b_size = b->size;
+	size_t a_qsize = extent_quantize(extent_node_size_get(a));
+	size_t b_qsize = extent_quantize(extent_node_size_get(b));
 
-	ret = (a_size > b_size) - (a_size < b_size);
+	/*
+	 * Compare based on quantized size rather than size, in order to sort
+	 * equally useful extents only by address.
+	 */
+	ret = (a_qsize > b_qsize) - (a_qsize < b_qsize);
 	if (ret == 0) {
-		uintptr_t a_addr = (uintptr_t)a->addr;
-		uintptr_t b_addr = (uintptr_t)b->addr;
+		uintptr_t a_addr = (uintptr_t)extent_node_addr_get(a);
+		uintptr_t b_addr = (uintptr_t)extent_node_addr_get(b);
 
 		ret = (a_addr > b_addr) - (a_addr < b_addr);
 	}
 
 	return (ret);
 }
 
 /* Generate red-black tree functions. */
-rb_gen(, extent_tree_szad_, extent_tree_t, extent_node_t, link_szad,
+rb_gen(, extent_tree_szad_, extent_tree_t, extent_node_t, szad_link,
     extent_szad_comp)
 
-static inline int
+JEMALLOC_INLINE_C int
 extent_ad_comp(extent_node_t *a, extent_node_t *b)
 {
-	uintptr_t a_addr = (uintptr_t)a->addr;
-	uintptr_t b_addr = (uintptr_t)b->addr;
+	uintptr_t a_addr = (uintptr_t)extent_node_addr_get(a);
+	uintptr_t b_addr = (uintptr_t)extent_node_addr_get(b);
 
 	return ((a_addr > b_addr) - (a_addr < b_addr));
 }
 
 /* Generate red-black tree functions. */
-rb_gen(, extent_tree_ad_, extent_tree_t, extent_node_t, link_ad,
-    extent_ad_comp)
+rb_gen(, extent_tree_ad_, extent_tree_t, extent_node_t, ad_link, extent_ad_comp)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.d	2017-09-27 22:47:57.886963303 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.d	2017-09-27 22:49:20.922960260 +0800
@@ -1,20 +1,21 @@
 src/extent.o: src/extent.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.d	2017-09-27 22:47:57.970963300 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.d	2017-09-27 22:49:21.018960256 +0800
@@ -1,20 +1,21 @@
 src/hash.o: src/hash.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,347 +1,435 @@
 #define	JEMALLOC_HUGE_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
-/* Data. */
 
-uint64_t	huge_nmalloc;
-uint64_t	huge_ndalloc;
-size_t		huge_allocated;
+static extent_node_t *
+huge_node_get(const void *ptr)
+{
+	extent_node_t *node;
 
-malloc_mutex_t	huge_mtx;
+	node = chunk_lookup(ptr, true);
+	assert(!extent_node_achunk_get(node));
 
-/******************************************************************************/
+	return (node);
+}
+
+static bool
+huge_node_set(const void *ptr, extent_node_t *node)
+{
+
+	assert(extent_node_addr_get(node) == ptr);
+	assert(!extent_node_achunk_get(node));
+	return (chunk_register(ptr, node));
+}
 
-/* Tree of chunks that are stand-alone huge allocations. */
-static extent_tree_t	huge;
+static void
+huge_node_unset(const void *ptr, const extent_node_t *node)
+{
+
+	chunk_deregister(ptr, node);
+}
 
 void *
-huge_malloc(size_t size, bool zero, dss_prec_t dss_prec)
+huge_malloc(tsd_t *tsd, arena_t *arena, size_t size, bool zero,
+    tcache_t *tcache)
 {
+	size_t usize;
 
-	return (huge_palloc(size, chunksize, zero, dss_prec));
+	usize = s2u(size);
+	if (usize == 0) {
+		/* size_t overflow. */
+		return (NULL);
+	}
+
+	return (huge_palloc(tsd, arena, usize, chunksize, zero, tcache));
 }
 
 void *
-huge_palloc(size_t size, size_t alignment, bool zero, dss_prec_t dss_prec)
+huge_palloc(tsd_t *tsd, arena_t *arena, size_t size, size_t alignment,
+    bool zero, tcache_t *tcache)
 {
 	void *ret;
-	size_t csize;
+	size_t usize;
 	extent_node_t *node;
 	bool is_zeroed;
 
 	/* Allocate one or more contiguous chunks for this request. */
 
-	csize = CHUNK_CEILING(size);
-	if (csize == 0) {
-		/* size is large enough to cause size_t wrap-around. */
+	usize = sa2u(size, alignment);
+	if (unlikely(usize == 0))
 		return (NULL);
-	}
+	assert(usize >= chunksize);
 
 	/* Allocate an extent node with which to track the chunk. */
-	node = base_node_alloc();
+	node = ipallocztm(tsd, CACHELINE_CEILING(sizeof(extent_node_t)),
+	    CACHELINE, false, tcache, true, arena);
 	if (node == NULL)
 		return (NULL);
 
 	/*
 	 * Copy zero into is_zeroed and pass the copy to chunk_alloc(), so that
 	 * it is possible to make correct junk/zero fill decisions below.
 	 */
 	is_zeroed = zero;
-	ret = chunk_alloc(csize, alignment, false, &is_zeroed, dss_prec);
-	if (ret == NULL) {
-		base_node_dealloc(node);
+	arena = arena_choose(tsd, arena);
+	if (unlikely(arena == NULL) || (ret = arena_chunk_alloc_huge(arena,
+	    size, alignment, &is_zeroed)) == NULL) {
+		idalloctm(tsd, node, tcache, true);
 		return (NULL);
 	}
 
-	/* Insert node into huge. */
-	node->addr = ret;
-	node->size = csize;
-
-	malloc_mutex_lock(&huge_mtx);
-	extent_tree_ad_insert(&huge, node);
-	if (config_stats) {
-		stats_cactive_add(csize);
-		huge_nmalloc++;
-		huge_allocated += csize;
-	}
-	malloc_mutex_unlock(&huge_mtx);
-
-	if (config_fill && zero == false) {
-		if (opt_junk)
-			memset(ret, 0xa5, csize);
-		else if (opt_zero && is_zeroed == false)
-			memset(ret, 0, csize);
-	}
-
-	return (ret);
-}
-
-bool
-huge_ralloc_no_move(void *ptr, size_t oldsize, size_t size, size_t extra)
-{
-
-	/*
-	 * Avoid moving the allocation if the size class can be left the same.
-	 */
-	if (oldsize > arena_maxclass
-	    && CHUNK_CEILING(oldsize) >= CHUNK_CEILING(size)
-	    && CHUNK_CEILING(oldsize) <= CHUNK_CEILING(size+extra)) {
-		assert(CHUNK_CEILING(oldsize) == oldsize);
-		return (false);
-	}
-
-	/* Reallocation would require a move. */
-	return (true);
-}
-
-void *
-huge_ralloc(void *ptr, size_t oldsize, size_t size, size_t extra,
-    size_t alignment, bool zero, bool try_tcache_dalloc, dss_prec_t dss_prec)
-{
-	void *ret;
-	size_t copysize;
-
-	/* Try to avoid moving the allocation. */
-	if (huge_ralloc_no_move(ptr, oldsize, size, extra) == false)
-		return (ptr);
-
-	/*
-	 * size and oldsize are different enough that we need to use a
-	 * different size class.  In that case, fall back to allocating new
-	 * space and copying.
-	 */
-	if (alignment > chunksize)
-		ret = huge_palloc(size + extra, alignment, zero, dss_prec);
-	else
-		ret = huge_malloc(size + extra, zero, dss_prec);
-
-	if (ret == NULL) {
-		if (extra == 0)
-			return (NULL);
-		/* Try again, this time without extra. */
-		if (alignment > chunksize)
-			ret = huge_palloc(size, alignment, zero, dss_prec);
-		else
-			ret = huge_malloc(size, zero, dss_prec);
+	extent_node_init(node, arena, ret, size, is_zeroed, true);
 
-		if (ret == NULL)
-			return (NULL);
+	if (huge_node_set(ret, node)) {
+		arena_chunk_dalloc_huge(arena, ret, size);
+		idalloctm(tsd, node, tcache, true);
+		return (NULL);
 	}
 
-	/*
-	 * Copy at most size bytes (not size+extra), since the caller has no
-	 * expectation that the extra bytes will be reliably preserved.
-	 */
-	copysize = (size < oldsize) ? size : oldsize;
-
-#ifdef JEMALLOC_MREMAP
-	/*
-	 * Use mremap(2) if this is a huge-->huge reallocation, and neither the
-	 * source nor the destination are in dss.
-	 */
-	if (oldsize >= chunksize && (config_dss == false || (chunk_in_dss(ptr)
-	    == false && chunk_in_dss(ret) == false))) {
-		size_t newsize = huge_salloc(ret);
+	/* Insert node into huge. */
+	malloc_mutex_lock(&arena->huge_mtx);
+	ql_elm_new(node, ql_link);
+	ql_tail_insert(&arena->huge, node, ql_link);
+	malloc_mutex_unlock(&arena->huge_mtx);
+
+	if (zero || (config_fill && unlikely(opt_zero))) {
+		if (!is_zeroed)
+			memset(ret, 0, size);
+	} else if (config_fill && unlikely(opt_junk_alloc))
+		memset(ret, 0xa5, size);
 
-		/*
-		 * Remove ptr from the tree of huge allocations before
-		 * performing the remap operation, in order to avoid the
-		 * possibility of another thread acquiring that mapping before
-		 * this one removes it from the tree.
-		 */
-		huge_dalloc(ptr, false);
-		if (mremap(ptr, oldsize, newsize, MREMAP_MAYMOVE|MREMAP_FIXED,
-		    ret) == MAP_FAILED) {
-			/*
-			 * Assuming no chunk management bugs in the allocator,
-			 * the only documented way an error can occur here is
-			 * if the application changed the map type for a
-			 * portion of the old allocation.  This is firmly in
-			 * undefined behavior territory, so write a diagnostic
-			 * message, and optionally abort.
-			 */
-			char buf[BUFERROR_BUF];
-
-			buferror(get_errno(), buf, sizeof(buf));
-			malloc_printf("<jemalloc>: Error in mremap(): %s\n",
-			    buf);
-			if (opt_abort)
-				abort();
-			memcpy(ret, ptr, copysize);
-			chunk_dealloc_mmap(ptr, oldsize);
-		} else if (config_fill && zero == false && opt_junk && oldsize
-		    < newsize) {
-			/*
-			 * mremap(2) clobbers the original mapping, so
-			 * junk/zero filling is not preserved.  There is no
-			 * need to zero fill here, since any trailing
-			 * uninititialized memory is demand-zeroed by the
-			 * kernel, but junk filling must be redone.
-			 */
-			memset(ret + oldsize, 0xa5, newsize - oldsize);
-		}
-	} else
-#endif
-	{
-		memcpy(ret, ptr, copysize);
-		iqalloct(ptr, try_tcache_dalloc);
-	}
 	return (ret);
 }
 
 #ifdef JEMALLOC_JET
 #undef huge_dalloc_junk
 #define	huge_dalloc_junk JEMALLOC_N(huge_dalloc_junk_impl)
 #endif
 static void
 huge_dalloc_junk(void *ptr, size_t usize)
 {
 
-	if (config_fill && config_dss && opt_junk) {
+	if (config_fill && have_dss && unlikely(opt_junk_free)) {
 		/*
 		 * Only bother junk filling if the chunk isn't about to be
 		 * unmapped.
 		 */
-		if (config_munmap == false || (config_dss && chunk_in_dss(ptr)))
+		if (!config_munmap || (have_dss && chunk_in_dss(ptr)))
 			memset(ptr, 0x5a, usize);
 	}
 }
 #ifdef JEMALLOC_JET
 #undef huge_dalloc_junk
 #define	huge_dalloc_junk JEMALLOC_N(huge_dalloc_junk)
 huge_dalloc_junk_t *huge_dalloc_junk = JEMALLOC_N(huge_dalloc_junk_impl);
 #endif
 
-void
-huge_dalloc(void *ptr, bool unmap)
+static void
+huge_ralloc_no_move_similar(void *ptr, size_t oldsize, size_t usize_min,
+    size_t usize_max, bool zero)
 {
-	extent_node_t *node, key;
-
-	malloc_mutex_lock(&huge_mtx);
+	size_t usize, usize_next;
+	extent_node_t *node;
+	arena_t *arena;
+	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
+	bool pre_zeroed, post_zeroed;
+
+	/* Increase usize to incorporate extra. */
+	for (usize = usize_min; usize < usize_max && (usize_next = s2u(usize+1))
+	    <= oldsize; usize = usize_next)
+		; /* Do nothing. */
+
+	if (oldsize == usize)
+		return;
+
+	node = huge_node_get(ptr);
+	arena = extent_node_arena_get(node);
+	pre_zeroed = extent_node_zeroed_get(node);
+
+	/* Fill if necessary (shrinking). */
+	if (oldsize > usize) {
+		size_t sdiff = oldsize - usize;
+		if (config_fill && unlikely(opt_junk_free)) {
+			memset((void *)((uintptr_t)ptr + usize), 0x5a, sdiff);
+			post_zeroed = false;
+		} else {
+			post_zeroed = !chunk_purge_wrapper(arena, &chunk_hooks,
+			    ptr, CHUNK_CEILING(oldsize), usize, sdiff);
+		}
+	} else
+		post_zeroed = pre_zeroed;
 
-	/* Extract from tree of huge allocations. */
-	key.addr = ptr;
-	node = extent_tree_ad_search(&huge, &key);
-	assert(node != NULL);
-	assert(node->addr == ptr);
-	extent_tree_ad_remove(&huge, node);
-
-	if (config_stats) {
-		stats_cactive_sub(node->size);
-		huge_ndalloc++;
-		huge_allocated -= node->size;
+	malloc_mutex_lock(&arena->huge_mtx);
+	/* Update the size of the huge allocation. */
+	assert(extent_node_size_get(node) != usize);
+	extent_node_size_set(node, usize);
+	/* Update zeroed. */
+	extent_node_zeroed_set(node, post_zeroed);
+	malloc_mutex_unlock(&arena->huge_mtx);
+
+	arena_chunk_ralloc_huge_similar(arena, ptr, oldsize, usize);
+
+	/* Fill if necessary (growing). */
+	if (oldsize < usize) {
+		if (zero || (config_fill && unlikely(opt_zero))) {
+			if (!pre_zeroed) {
+				memset((void *)((uintptr_t)ptr + oldsize), 0,
+				    usize - oldsize);
+			}
+		} else if (config_fill && unlikely(opt_junk_alloc)) {
+			memset((void *)((uintptr_t)ptr + oldsize), 0xa5, usize -
+			    oldsize);
+		}
 	}
+}
+
+static bool
+huge_ralloc_no_move_shrink(void *ptr, size_t oldsize, size_t usize)
+{
+	extent_node_t *node;
+	arena_t *arena;
+	chunk_hooks_t chunk_hooks;
+	size_t cdiff;
+	bool pre_zeroed, post_zeroed;
+
+	node = huge_node_get(ptr);
+	arena = extent_node_arena_get(node);
+	pre_zeroed = extent_node_zeroed_get(node);
+	chunk_hooks = chunk_hooks_get(arena);
+
+	assert(oldsize > usize);
+
+	/* Split excess chunks. */
+	cdiff = CHUNK_CEILING(oldsize) - CHUNK_CEILING(usize);
+	if (cdiff != 0 && chunk_hooks.split(ptr, CHUNK_CEILING(oldsize),
+	    CHUNK_CEILING(usize), cdiff, true, arena->ind))
+		return (true);
 
-	malloc_mutex_unlock(&huge_mtx);
+	if (oldsize > usize) {
+		size_t sdiff = oldsize - usize;
+		if (config_fill && unlikely(opt_junk_free)) {
+			huge_dalloc_junk((void *)((uintptr_t)ptr + usize),
+			    sdiff);
+			post_zeroed = false;
+		} else {
+			post_zeroed = !chunk_purge_wrapper(arena, &chunk_hooks,
+			    CHUNK_ADDR2BASE((uintptr_t)ptr + usize),
+			    CHUNK_CEILING(oldsize),
+			    CHUNK_ADDR2OFFSET((uintptr_t)ptr + usize), sdiff);
+		}
+	} else
+		post_zeroed = pre_zeroed;
 
-	if (unmap)
-		huge_dalloc_junk(node->addr, node->size);
+	malloc_mutex_lock(&arena->huge_mtx);
+	/* Update the size of the huge allocation. */
+	extent_node_size_set(node, usize);
+	/* Update zeroed. */
+	extent_node_zeroed_set(node, post_zeroed);
+	malloc_mutex_unlock(&arena->huge_mtx);
 
-	chunk_dealloc(node->addr, node->size, unmap);
+	/* Zap the excess chunks. */
+	arena_chunk_ralloc_huge_shrink(arena, ptr, oldsize, usize);
 
-	base_node_dealloc(node);
+	return (false);
 }
 
-size_t
-huge_salloc(const void *ptr)
-{
-	size_t ret;
-	extent_node_t *node, key;
+static bool
+huge_ralloc_no_move_expand(void *ptr, size_t oldsize, size_t usize, bool zero) {
+	extent_node_t *node;
+	arena_t *arena;
+	bool is_zeroed_subchunk, is_zeroed_chunk;
 
-	malloc_mutex_lock(&huge_mtx);
+	node = huge_node_get(ptr);
+	arena = extent_node_arena_get(node);
+	malloc_mutex_lock(&arena->huge_mtx);
+	is_zeroed_subchunk = extent_node_zeroed_get(node);
+	malloc_mutex_unlock(&arena->huge_mtx);
 
-	/* Extract from tree of huge allocations. */
-	key.addr = __DECONST(void *, ptr);
-	node = extent_tree_ad_search(&huge, &key);
-	assert(node != NULL);
+	/*
+	 * Copy zero into is_zeroed_chunk and pass the copy to chunk_alloc(), so
+	 * that it is possible to make correct junk/zero fill decisions below.
+	 */
+	is_zeroed_chunk = zero;
 
-	ret = node->size;
+	if (arena_chunk_ralloc_huge_expand(arena, ptr, oldsize, usize,
+	     &is_zeroed_chunk))
+		return (true);
 
-	malloc_mutex_unlock(&huge_mtx);
+	malloc_mutex_lock(&arena->huge_mtx);
+	/* Update the size of the huge allocation. */
+	extent_node_size_set(node, usize);
+	malloc_mutex_unlock(&arena->huge_mtx);
+
+	if (zero || (config_fill && unlikely(opt_zero))) {
+		if (!is_zeroed_subchunk) {
+			memset((void *)((uintptr_t)ptr + oldsize), 0,
+			    CHUNK_CEILING(oldsize) - oldsize);
+		}
+		if (!is_zeroed_chunk) {
+			memset((void *)((uintptr_t)ptr +
+			    CHUNK_CEILING(oldsize)), 0, usize -
+			    CHUNK_CEILING(oldsize));
+		}
+	} else if (config_fill && unlikely(opt_junk_alloc)) {
+		memset((void *)((uintptr_t)ptr + oldsize), 0xa5, usize -
+		    oldsize);
+	}
 
-	return (ret);
+	return (false);
 }
 
-dss_prec_t
-huge_dss_prec_get(arena_t *arena)
+bool
+huge_ralloc_no_move(void *ptr, size_t oldsize, size_t usize_min,
+    size_t usize_max, bool zero)
 {
 
-	return (arena_dss_prec_get(choose_arena(arena)));
+	assert(s2u(oldsize) == oldsize);
+
+	/* Both allocations must be huge to avoid a move. */
+	if (oldsize < chunksize || usize_max < chunksize)
+		return (true);
+
+	if (CHUNK_CEILING(usize_max) > CHUNK_CEILING(oldsize)) {
+		/* Attempt to expand the allocation in-place. */
+		if (!huge_ralloc_no_move_expand(ptr, oldsize, usize_max, zero))
+			return (false);
+		/* Try again, this time with usize_min. */
+		if (usize_min < usize_max && CHUNK_CEILING(usize_min) >
+		    CHUNK_CEILING(oldsize) && huge_ralloc_no_move_expand(ptr,
+		    oldsize, usize_min, zero))
+			return (false);
+	}
+
+	/*
+	 * Avoid moving the allocation if the existing chunk size accommodates
+	 * the new size.
+	 */
+	if (CHUNK_CEILING(oldsize) >= CHUNK_CEILING(usize_min)
+	    && CHUNK_CEILING(oldsize) <= CHUNK_CEILING(usize_max)) {
+		huge_ralloc_no_move_similar(ptr, oldsize, usize_min, usize_max,
+		    zero);
+		return (false);
+	}
+
+	/* Attempt to shrink the allocation in-place. */
+	if (CHUNK_CEILING(oldsize) > CHUNK_CEILING(usize_max))
+		return (huge_ralloc_no_move_shrink(ptr, oldsize, usize_max));
+	return (true);
 }
 
-prof_ctx_t *
-huge_prof_ctx_get(const void *ptr)
+static void *
+huge_ralloc_move_helper(tsd_t *tsd, arena_t *arena, size_t usize,
+    size_t alignment, bool zero, tcache_t *tcache)
 {
-	prof_ctx_t *ret;
-	extent_node_t *node, key;
 
-	malloc_mutex_lock(&huge_mtx);
+	if (alignment <= chunksize)
+		return (huge_malloc(tsd, arena, usize, zero, tcache));
+	return (huge_palloc(tsd, arena, usize, alignment, zero, tcache));
+}
 
-	/* Extract from tree of huge allocations. */
-	key.addr = __DECONST(void *, ptr);
-	node = extent_tree_ad_search(&huge, &key);
-	assert(node != NULL);
+void *
+huge_ralloc(tsd_t *tsd, arena_t *arena, void *ptr, size_t oldsize, size_t usize,
+    size_t alignment, bool zero, tcache_t *tcache)
+{
+	void *ret;
+	size_t copysize;
 
-	ret = node->prof_ctx;
+	/* Try to avoid moving the allocation. */
+	if (!huge_ralloc_no_move(ptr, oldsize, usize, usize, zero))
+		return (ptr);
 
-	malloc_mutex_unlock(&huge_mtx);
+	/*
+	 * usize and oldsize are different enough that we need to use a
+	 * different size class.  In that case, fall back to allocating new
+	 * space and copying.
+	 */
+	ret = huge_ralloc_move_helper(tsd, arena, usize, alignment, zero,
+	    tcache);
+	if (ret == NULL)
+		return (NULL);
 
+	copysize = (usize < oldsize) ? usize : oldsize;
+	memcpy(ret, ptr, copysize);
+	isqalloc(tsd, ptr, oldsize, tcache);
 	return (ret);
 }
 
 void
-huge_prof_ctx_set(const void *ptr, prof_ctx_t *ctx)
+huge_dalloc(tsd_t *tsd, void *ptr, tcache_t *tcache)
 {
-	extent_node_t *node, key;
+	extent_node_t *node;
+	arena_t *arena;
 
-	malloc_mutex_lock(&huge_mtx);
+	node = huge_node_get(ptr);
+	arena = extent_node_arena_get(node);
+	huge_node_unset(ptr, node);
+	malloc_mutex_lock(&arena->huge_mtx);
+	ql_remove(&arena->huge, node, ql_link);
+	malloc_mutex_unlock(&arena->huge_mtx);
 
-	/* Extract from tree of huge allocations. */
-	key.addr = __DECONST(void *, ptr);
-	node = extent_tree_ad_search(&huge, &key);
-	assert(node != NULL);
+	huge_dalloc_junk(extent_node_addr_get(node),
+	    extent_node_size_get(node));
+	arena_chunk_dalloc_huge(extent_node_arena_get(node),
+	    extent_node_addr_get(node), extent_node_size_get(node));
+	idalloctm(tsd, node, tcache, true);
+}
 
-	node->prof_ctx = ctx;
+arena_t *
+huge_aalloc(const void *ptr)
+{
 
-	malloc_mutex_unlock(&huge_mtx);
+	return (extent_node_arena_get(huge_node_get(ptr)));
 }
 
-bool
-huge_boot(void)
+size_t
+huge_salloc(const void *ptr)
 {
+	size_t size;
+	extent_node_t *node;
+	arena_t *arena;
 
-	/* Initialize chunks data. */
-	if (malloc_mutex_init(&huge_mtx))
-		return (true);
-	extent_tree_ad_new(&huge);
-
-	if (config_stats) {
-		huge_nmalloc = 0;
-		huge_ndalloc = 0;
-		huge_allocated = 0;
-	}
+	node = huge_node_get(ptr);
+	arena = extent_node_arena_get(node);
+	malloc_mutex_lock(&arena->huge_mtx);
+	size = extent_node_size_get(node);
+	malloc_mutex_unlock(&arena->huge_mtx);
 
-	return (false);
+	return (size);
 }
 
-void
-huge_prefork(void)
+prof_tctx_t *
+huge_prof_tctx_get(const void *ptr)
 {
+	prof_tctx_t *tctx;
+	extent_node_t *node;
+	arena_t *arena;
+
+	node = huge_node_get(ptr);
+	arena = extent_node_arena_get(node);
+	malloc_mutex_lock(&arena->huge_mtx);
+	tctx = extent_node_prof_tctx_get(node);
+	malloc_mutex_unlock(&arena->huge_mtx);
 
-	malloc_mutex_prefork(&huge_mtx);
+	return (tctx);
 }
 
 void
-huge_postfork_parent(void)
+huge_prof_tctx_set(const void *ptr, prof_tctx_t *tctx)
 {
+	extent_node_t *node;
+	arena_t *arena;
 
-	malloc_mutex_postfork_parent(&huge_mtx);
+	node = huge_node_get(ptr);
+	arena = extent_node_arena_get(node);
+	malloc_mutex_lock(&arena->huge_mtx);
+	extent_node_prof_tctx_set(node, tctx);
+	malloc_mutex_unlock(&arena->huge_mtx);
 }
 
 void
-huge_postfork_child(void)
+huge_prof_tctx_reset(const void *ptr)
 {
 
-	malloc_mutex_postfork_child(&huge_mtx);
+	huge_prof_tctx_set(ptr, (prof_tctx_t *)(uintptr_t)1U);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.d	2017-09-27 22:47:58.122963295 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.d	2017-09-27 22:49:21.450960241 +0800
@@ -1,20 +1,21 @@
 src/huge.o: src/huge.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,49 +1,167 @@
 #define	JEMALLOC_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 /* Data. */
 
-malloc_tsd_data(, arenas, arena_t *, NULL)
-malloc_tsd_data(, thread_allocated, thread_allocated_t,
-    THREAD_ALLOCATED_INITIALIZER)
-
 /* Runtime configuration options. */
-const char	*je_malloc_conf;
+const char	*je_malloc_conf JEMALLOC_ATTR(weak);
 bool	opt_abort =
 #ifdef JEMALLOC_DEBUG
     true
 #else
     false
 #endif
     ;
-bool	opt_junk =
+const char	*opt_junk =
+#if (defined(JEMALLOC_DEBUG) && defined(JEMALLOC_FILL))
+    "true"
+#else
+    "false"
+#endif
+    ;
+bool	opt_junk_alloc =
 #if (defined(JEMALLOC_DEBUG) && defined(JEMALLOC_FILL))
     true
 #else
     false
 #endif
     ;
+bool	opt_junk_free =
+#if (defined(JEMALLOC_DEBUG) && defined(JEMALLOC_FILL))
+    true
+#else
+    false
+#endif
+    ;
+
 size_t	opt_quarantine = ZU(0);
 bool	opt_redzone = false;
 bool	opt_utrace = false;
-bool	opt_valgrind = false;
 bool	opt_xmalloc = false;
 bool	opt_zero = false;
 size_t	opt_narenas = 0;
 
-unsigned	ncpus;
+/* Initialized to true if the process is running inside Valgrind. */
+bool	in_valgrind;
 
-malloc_mutex_t		arenas_lock;
-arena_t			**arenas;
-unsigned		narenas_total;
-unsigned		narenas_auto;
+unsigned	ncpus;
 
-/* Set to true once the allocator has been initialized. */
-static bool		malloc_initialized = false;
+/* Protects arenas initialization (arenas, narenas_total). */
+static malloc_mutex_t	arenas_lock;
+/*
+ * Arenas that are used to service external requests.  Not all elements of the
+ * arenas array are necessarily used; arenas are created lazily as needed.
+ *
+ * arenas[0..narenas_auto) are used for automatic multiplexing of threads and
+ * arenas.  arenas[narenas_auto..narenas_total) are only used if the application
+ * takes some action to create them and allocate from them.
+ */
+static arena_t		**arenas;
+static unsigned		narenas_total;
+static arena_t		*a0; /* arenas[0]; read-only after initialization. */
+static unsigned		narenas_auto; /* Read-only after initialization. */
+
+typedef enum {
+	malloc_init_uninitialized	= 3,
+	malloc_init_a0_initialized	= 2,
+	malloc_init_recursible		= 1,
+	malloc_init_initialized		= 0 /* Common case --> jnz. */
+} malloc_init_t;
+static malloc_init_t	malloc_init_state = malloc_init_uninitialized;
+
+JEMALLOC_ALIGNED(CACHELINE)
+const size_t	index2size_tab[NSIZES] = {
+#define	SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup) \
+	((ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta)),
+	SIZE_CLASSES
+#undef SC
+};
+
+JEMALLOC_ALIGNED(CACHELINE)
+const uint8_t	size2index_tab[] = {
+#if LG_TINY_MIN == 0
+#warning "Dangerous LG_TINY_MIN"
+#define	S2B_0(i)	i,
+#elif LG_TINY_MIN == 1
+#warning "Dangerous LG_TINY_MIN"
+#define	S2B_1(i)	i,
+#elif LG_TINY_MIN == 2
+#warning "Dangerous LG_TINY_MIN"
+#define	S2B_2(i)	i,
+#elif LG_TINY_MIN == 3
+#define	S2B_3(i)	i,
+#elif LG_TINY_MIN == 4
+#define	S2B_4(i)	i,
+#elif LG_TINY_MIN == 5
+#define	S2B_5(i)	i,
+#elif LG_TINY_MIN == 6
+#define	S2B_6(i)	i,
+#elif LG_TINY_MIN == 7
+#define	S2B_7(i)	i,
+#elif LG_TINY_MIN == 8
+#define	S2B_8(i)	i,
+#elif LG_TINY_MIN == 9
+#define	S2B_9(i)	i,
+#elif LG_TINY_MIN == 10
+#define	S2B_10(i)	i,
+#elif LG_TINY_MIN == 11
+#define	S2B_11(i)	i,
+#else
+#error "Unsupported LG_TINY_MIN"
+#endif
+#if LG_TINY_MIN < 1
+#define	S2B_1(i)	S2B_0(i) S2B_0(i)
+#endif
+#if LG_TINY_MIN < 2
+#define	S2B_2(i)	S2B_1(i) S2B_1(i)
+#endif
+#if LG_TINY_MIN < 3
+#define	S2B_3(i)	S2B_2(i) S2B_2(i)
+#endif
+#if LG_TINY_MIN < 4
+#define	S2B_4(i)	S2B_3(i) S2B_3(i)
+#endif
+#if LG_TINY_MIN < 5
+#define	S2B_5(i)	S2B_4(i) S2B_4(i)
+#endif
+#if LG_TINY_MIN < 6
+#define	S2B_6(i)	S2B_5(i) S2B_5(i)
+#endif
+#if LG_TINY_MIN < 7
+#define	S2B_7(i)	S2B_6(i) S2B_6(i)
+#endif
+#if LG_TINY_MIN < 8
+#define	S2B_8(i)	S2B_7(i) S2B_7(i)
+#endif
+#if LG_TINY_MIN < 9
+#define	S2B_9(i)	S2B_8(i) S2B_8(i)
+#endif
+#if LG_TINY_MIN < 10
+#define	S2B_10(i)	S2B_9(i) S2B_9(i)
+#endif
+#if LG_TINY_MIN < 11
+#define	S2B_11(i)	S2B_10(i) S2B_10(i)
+#endif
+#define	S2B_no(i)
+#define	SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup) \
+	S2B_##lg_delta_lookup(index)
+	SIZE_CLASSES
+#undef S2B_3
+#undef S2B_4
+#undef S2B_5
+#undef S2B_6
+#undef S2B_7
+#undef S2B_8
+#undef S2B_9
+#undef S2B_10
+#undef S2B_11
+#undef S2B_no
+#undef SC
+};
 
 #ifdef JEMALLOC_THREADED_INIT
 /* Used to let the initializing thread recursively allocate. */
 #  define NO_INITIALIZER	((unsigned long)0)
 #  define INITIALIZER		pthread_self()
 #  define IS_INITIALIZER	(malloc_initializer == pthread_self())
@@ -54,41 +172,55 @@
 #  define IS_INITIALIZER	malloc_initializer
 static bool			malloc_initializer = NO_INITIALIZER;
 #endif
 
 /* Used to avoid initialization races. */
 #ifdef _WIN32
+#if _WIN32_WINNT >= 0x0600
+static malloc_mutex_t	init_lock = SRWLOCK_INIT;
+#else
 static malloc_mutex_t	init_lock;
+static bool init_lock_initialized = false;
 
 JEMALLOC_ATTR(constructor)
 static void WINAPI
 _init_init_lock(void)
 {
 
-	malloc_mutex_init(&init_lock);
+	/* If another constructor in the same binary is using mallctl to
+	 * e.g. setup chunk hooks, it may end up running before this one,
+	 * and malloc_init_hard will crash trying to lock the uninitialized
+	 * lock. So we force an initialization of the lock in
+	 * malloc_init_hard as well. We don't try to care about atomicity
+	 * of the accessed to the init_lock_initialized boolean, since it
+	 * really only matters early in the process creation, before any
+	 * separate thread normally starts doing anything. */
+	if (!init_lock_initialized)
+		malloc_mutex_init(&init_lock);
+	init_lock_initialized = true;
 }
 
 #ifdef _MSC_VER
 #  pragma section(".CRT$XCU", read)
 JEMALLOC_SECTION(".CRT$XCU") JEMALLOC_ATTR(used)
 static const void (WINAPI *init_init_lock)(void) = _init_init_lock;
 #endif
-
+#endif
 #else
 static malloc_mutex_t	init_lock = MALLOC_MUTEX_INITIALIZER;
 #endif
 
 typedef struct {
 	void	*p;	/* Input pointer (as in realloc(p, s)). */
 	size_t	s;	/* Request size. */
 	void	*r;	/* Result pointer. */
 } malloc_utrace_t;
 
 #ifdef JEMALLOC_UTRACE
 #  define UTRACE(a, b, c) do {						\
-	if (opt_utrace) {						\
+	if (unlikely(opt_utrace)) {					\
 		int utrace_serrno = errno;				\
 		malloc_utrace_t ut;					\
 		ut.p = (a);						\
 		ut.s = (b);						\
 		ut.r = (c);						\
 		utrace(&ut, sizeof(ut));				\
@@ -102,58 +234,357 @@
 /******************************************************************************/
 /*
  * Function prototypes for static functions that are referenced prior to
  * definition.
  */
 
+static bool	malloc_init_hard_a0(void);
 static bool	malloc_init_hard(void);
 
 /******************************************************************************/
 /*
  * Begin miscellaneous support functions.
  */
 
+JEMALLOC_ALWAYS_INLINE_C bool
+malloc_initialized(void)
+{
+
+	return (malloc_init_state == malloc_init_initialized);
+}
+
+JEMALLOC_ALWAYS_INLINE_C void
+malloc_thread_init(void)
+{
+
+	/*
+	 * TSD initialization can't be safely done as a side effect of
+	 * deallocation, because it is possible for a thread to do nothing but
+	 * deallocate its TLS data via free(), in which case writing to TLS
+	 * would cause write-after-free memory corruption.  The quarantine
+	 * facility *only* gets used as a side effect of deallocation, so make
+	 * a best effort attempt at initializing its TSD by hooking all
+	 * allocation events.
+	 */
+	if (config_fill && unlikely(opt_quarantine))
+		quarantine_alloc_hook();
+}
+
+JEMALLOC_ALWAYS_INLINE_C bool
+malloc_init_a0(void)
+{
+
+	if (unlikely(malloc_init_state == malloc_init_uninitialized))
+		return (malloc_init_hard_a0());
+	return (false);
+}
+
+JEMALLOC_ALWAYS_INLINE_C bool
+malloc_init(void)
+{
+
+	if (unlikely(!malloc_initialized()) && malloc_init_hard())
+		return (true);
+	malloc_thread_init();
+
+	return (false);
+}
+
+/*
+ * The a0*() functions are used instead of i[mcd]alloc() in situations that
+ * cannot tolerate TLS variable access.
+ */
+
+arena_t *
+a0get(void)
+{
+
+	assert(a0 != NULL);
+	return (a0);
+}
+
+static void *
+a0ialloc(size_t size, bool zero, bool is_metadata)
+{
+
+	if (unlikely(malloc_init_a0()))
+		return (NULL);
+
+	return (iallocztm(NULL, size, zero, false, is_metadata, a0get()));
+}
+
+static void
+a0idalloc(void *ptr, bool is_metadata)
+{
+
+	idalloctm(NULL, ptr, false, is_metadata);
+}
+
+void *
+a0malloc(size_t size)
+{
+
+	return (a0ialloc(size, false, true));
+}
+
+void
+a0dalloc(void *ptr)
+{
+
+	a0idalloc(ptr, true);
+}
+
+/*
+ * FreeBSD's libc uses the bootstrap_*() functions in bootstrap-senstive
+ * situations that cannot tolerate TLS variable access (TLS allocation and very
+ * early internal data structure initialization).
+ */
+
+void *
+bootstrap_malloc(size_t size)
+{
+
+	if (unlikely(size == 0))
+		size = 1;
+
+	return (a0ialloc(size, false, false));
+}
+
+void *
+bootstrap_calloc(size_t num, size_t size)
+{
+	size_t num_size;
+
+	num_size = num * size;
+	if (unlikely(num_size == 0)) {
+		assert(num == 0 || size == 0);
+		num_size = 1;
+	}
+
+	return (a0ialloc(num_size, true, false));
+}
+
+void
+bootstrap_free(void *ptr)
+{
+
+	if (unlikely(ptr == NULL))
+		return;
+
+	a0idalloc(ptr, false);
+}
+
 /* Create a new arena and insert it into the arenas array at index ind. */
+static arena_t *
+arena_init_locked(unsigned ind)
+{
+	arena_t *arena;
+
+	/* Expand arenas if necessary. */
+	assert(ind <= narenas_total);
+	if (ind > MALLOCX_ARENA_MAX)
+		return (NULL);
+	if (ind == narenas_total) {
+		unsigned narenas_new = narenas_total + 1;
+		arena_t **arenas_new =
+		    (arena_t **)a0malloc(CACHELINE_CEILING(narenas_new *
+		    sizeof(arena_t *)));
+		if (arenas_new == NULL)
+			return (NULL);
+		memcpy(arenas_new, arenas, narenas_total * sizeof(arena_t *));
+		arenas_new[ind] = NULL;
+		/*
+		 * Deallocate only if arenas came from a0malloc() (not
+		 * base_alloc()).
+		 */
+		if (narenas_total != narenas_auto)
+			a0dalloc(arenas);
+		arenas = arenas_new;
+		narenas_total = narenas_new;
+	}
+
+	/*
+	 * Another thread may have already initialized arenas[ind] if it's an
+	 * auto arena.
+	 */
+	arena = arenas[ind];
+	if (arena != NULL) {
+		assert(ind < narenas_auto);
+		return (arena);
+	}
+
+	/* Actually initialize the arena. */
+	arena = arenas[ind] = arena_new(ind);
+	return (arena);
+}
+
 arena_t *
-arenas_extend(unsigned ind)
+arena_init(unsigned ind)
 {
-	arena_t *ret;
+	arena_t *arena;
+
+	malloc_mutex_lock(&arenas_lock);
+	arena = arena_init_locked(ind);
+	malloc_mutex_unlock(&arenas_lock);
+	return (arena);
+}
+
+unsigned
+narenas_total_get(void)
+{
+	unsigned narenas;
+
+	malloc_mutex_lock(&arenas_lock);
+	narenas = narenas_total;
+	malloc_mutex_unlock(&arenas_lock);
 
-	ret = (arena_t *)base_alloc(sizeof(arena_t));
-	if (ret != NULL && arena_new(ret, ind) == false) {
-		arenas[ind] = ret;
-		return (ret);
+	return (narenas);
+}
+
+static void
+arena_bind_locked(tsd_t *tsd, unsigned ind)
+{
+	arena_t *arena;
+
+	arena = arenas[ind];
+	arena->nthreads++;
+
+	if (tsd_nominal(tsd))
+		tsd_arena_set(tsd, arena);
+}
+
+static void
+arena_bind(tsd_t *tsd, unsigned ind)
+{
+
+	malloc_mutex_lock(&arenas_lock);
+	arena_bind_locked(tsd, ind);
+	malloc_mutex_unlock(&arenas_lock);
+}
+
+void
+arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind)
+{
+	arena_t *oldarena, *newarena;
+
+	malloc_mutex_lock(&arenas_lock);
+	oldarena = arenas[oldind];
+	newarena = arenas[newind];
+	oldarena->nthreads--;
+	newarena->nthreads++;
+	malloc_mutex_unlock(&arenas_lock);
+	tsd_arena_set(tsd, newarena);
+}
+
+unsigned
+arena_nbound(unsigned ind)
+{
+	unsigned nthreads;
+
+	malloc_mutex_lock(&arenas_lock);
+	nthreads = arenas[ind]->nthreads;
+	malloc_mutex_unlock(&arenas_lock);
+	return (nthreads);
+}
+
+static void
+arena_unbind(tsd_t *tsd, unsigned ind)
+{
+	arena_t *arena;
+
+	malloc_mutex_lock(&arenas_lock);
+	arena = arenas[ind];
+	arena->nthreads--;
+	malloc_mutex_unlock(&arenas_lock);
+	tsd_arena_set(tsd, NULL);
+}
+
+arena_t *
+arena_get_hard(tsd_t *tsd, unsigned ind, bool init_if_missing)
+{
+	arena_t *arena;
+	arena_t **arenas_cache = tsd_arenas_cache_get(tsd);
+	unsigned narenas_cache = tsd_narenas_cache_get(tsd);
+	unsigned narenas_actual = narenas_total_get();
+
+	/* Deallocate old cache if it's too small. */
+	if (arenas_cache != NULL && narenas_cache < narenas_actual) {
+		a0dalloc(arenas_cache);
+		arenas_cache = NULL;
+		narenas_cache = 0;
+		tsd_arenas_cache_set(tsd, arenas_cache);
+		tsd_narenas_cache_set(tsd, narenas_cache);
+	}
+
+	/* Allocate cache if it's missing. */
+	if (arenas_cache == NULL) {
+		bool *arenas_cache_bypassp = tsd_arenas_cache_bypassp_get(tsd);
+		assert(ind < narenas_actual || !init_if_missing);
+		narenas_cache = (ind < narenas_actual) ? narenas_actual : ind+1;
+
+		if (tsd_nominal(tsd) && !*arenas_cache_bypassp) {
+			*arenas_cache_bypassp = true;
+			arenas_cache = (arena_t **)a0malloc(sizeof(arena_t *) *
+			    narenas_cache);
+			*arenas_cache_bypassp = false;
+		}
+		if (arenas_cache == NULL) {
+			/*
+			 * This function must always tell the truth, even if
+			 * it's slow, so don't let OOM, thread cleanup (note
+			 * tsd_nominal check), nor recursive allocation
+			 * avoidance (note arenas_cache_bypass check) get in the
+			 * way.
+			 */
+			if (ind >= narenas_actual)
+				return (NULL);
+			malloc_mutex_lock(&arenas_lock);
+			arena = arenas[ind];
+			malloc_mutex_unlock(&arenas_lock);
+			return (arena);
+		}
+		assert(tsd_nominal(tsd) && !*arenas_cache_bypassp);
+		tsd_arenas_cache_set(tsd, arenas_cache);
+		tsd_narenas_cache_set(tsd, narenas_cache);
 	}
-	/* Only reached if there is an OOM error. */
 
 	/*
-	 * OOM here is quite inconvenient to propagate, since dealing with it
-	 * would require a check for failure in the fast path.  Instead, punt
-	 * by using arenas[0].  In practice, this is an extremely unlikely
-	 * failure.
+	 * Copy to cache.  It's possible that the actual number of arenas has
+	 * increased since narenas_total_get() was called above, but that causes
+	 * no correctness issues unless two threads concurrently execute the
+	 * arenas.extend mallctl, which we trust mallctl synchronization to
+	 * prevent.
 	 */
-	malloc_write("<jemalloc>: Error initializing arena\n");
-	if (opt_abort)
-		abort();
+	malloc_mutex_lock(&arenas_lock);
+	memcpy(arenas_cache, arenas, sizeof(arena_t *) * narenas_actual);
+	malloc_mutex_unlock(&arenas_lock);
+	if (narenas_cache > narenas_actual) {
+		memset(&arenas_cache[narenas_actual], 0, sizeof(arena_t *) *
+		    (narenas_cache - narenas_actual));
+	}
 
-	return (arenas[0]);
+	/* Read the refreshed cache, and init the arena if necessary. */
+	arena = arenas_cache[ind];
+	if (init_if_missing && arena == NULL)
+		arena = arenas_cache[ind] = arena_init(ind);
+	return (arena);
 }
 
-/* Slow path, called only by choose_arena(). */
+/* Slow path, called only by arena_choose(). */
 arena_t *
-choose_arena_hard(void)
+arena_choose_hard(tsd_t *tsd)
 {
 	arena_t *ret;
 
 	if (narenas_auto > 1) {
 		unsigned i, choose, first_null;
 
 		choose = 0;
 		first_null = narenas_auto;
 		malloc_mutex_lock(&arenas_lock);
-		assert(arenas[0] != NULL);
+		assert(a0get() != NULL);
 		for (i = 1; i < narenas_auto; i++) {
 			if (arenas[i] != NULL) {
 				/*
 				 * Choose the first arena that has the lowest
 				 * number of threads assigned to it.
 				 */
@@ -180,28 +611,79 @@
 			 * Use an unloaded arena, or the least loaded arena if
 			 * all arenas are already initialized.
 			 */
 			ret = arenas[choose];
 		} else {
 			/* Initialize a new arena. */
-			ret = arenas_extend(first_null);
+			choose = first_null;
+			ret = arena_init_locked(choose);
+			if (ret == NULL) {
+				malloc_mutex_unlock(&arenas_lock);
+				return (NULL);
+			}
 		}
-		ret->nthreads++;
+		arena_bind_locked(tsd, choose);
 		malloc_mutex_unlock(&arenas_lock);
 	} else {
-		ret = arenas[0];
-		malloc_mutex_lock(&arenas_lock);
-		ret->nthreads++;
-		malloc_mutex_unlock(&arenas_lock);
+		ret = a0get();
+		arena_bind(tsd, 0);
 	}
 
-	arenas_tsd_set(&ret);
-
 	return (ret);
 }
 
+void
+thread_allocated_cleanup(tsd_t *tsd)
+{
+
+	/* Do nothing. */
+}
+
+void
+thread_deallocated_cleanup(tsd_t *tsd)
+{
+
+	/* Do nothing. */
+}
+
+void
+arena_cleanup(tsd_t *tsd)
+{
+	arena_t *arena;
+
+	arena = tsd_arena_get(tsd);
+	if (arena != NULL)
+		arena_unbind(tsd, arena->ind);
+}
+
+void
+arenas_cache_cleanup(tsd_t *tsd)
+{
+	arena_t **arenas_cache;
+
+	arenas_cache = tsd_arenas_cache_get(tsd);
+	if (arenas_cache != NULL) {
+		tsd_arenas_cache_set(tsd, NULL);
+		a0dalloc(arenas_cache);
+	}
+}
+
+void
+narenas_cache_cleanup(tsd_t *tsd)
+{
+
+	/* Do nothing. */
+}
+
+void
+arenas_cache_bypass_cleanup(tsd_t *tsd)
+{
+
+	/* Do nothing. */
+}
+
 static void
 stats_print_atexit(void)
 {
 
 	if (config_tcache && config_stats) {
 		unsigned narenas, i;
@@ -240,12 +722,25 @@
  */
 /******************************************************************************/
 /*
  * Begin initialization functions.
  */
 
+#ifndef JEMALLOC_HAVE_SECURE_GETENV
+static char *
+secure_getenv(const char *name)
+{
+
+#  ifdef JEMALLOC_HAVE_ISSETUGID
+	if (issetugid() != 0)
+		return (NULL);
+#  endif
+	return (getenv(name));
+}
+#endif
+
 static unsigned
 malloc_ncpus(void)
 {
 	long result;
 
 #ifdef _WIN32
@@ -255,60 +750,22 @@
 #else
 	result = sysconf(_SC_NPROCESSORS_ONLN);
 #endif
 	return ((result == -1) ? 1 : (unsigned)result);
 }
 
-void
-arenas_cleanup(void *arg)
-{
-	arena_t *arena = *(arena_t **)arg;
-
-	malloc_mutex_lock(&arenas_lock);
-	arena->nthreads--;
-	malloc_mutex_unlock(&arenas_lock);
-}
-
-JEMALLOC_ALWAYS_INLINE_C void
-malloc_thread_init(void)
-{
-
-	/*
-	 * TSD initialization can't be safely done as a side effect of
-	 * deallocation, because it is possible for a thread to do nothing but
-	 * deallocate its TLS data via free(), in which case writing to TLS
-	 * would cause write-after-free memory corruption.  The quarantine
-	 * facility *only* gets used as a side effect of deallocation, so make
-	 * a best effort attempt at initializing its TSD by hooking all
-	 * allocation events.
-	 */
-	if (config_fill && opt_quarantine)
-		quarantine_alloc_hook();
-}
-
-JEMALLOC_ALWAYS_INLINE_C bool
-malloc_init(void)
-{
-
-	if (malloc_initialized == false && malloc_init_hard())
-		return (true);
-	malloc_thread_init();
-
-	return (false);
-}
-
 static bool
 malloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,
     char const **v_p, size_t *vlen_p)
 {
 	bool accept;
 	const char *opts = *opts_p;
 
 	*k_p = opts;
 
-	for (accept = false; accept == false;) {
+	for (accept = false; !accept;) {
 		switch (*opts) {
 		case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
 		case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
 		case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
 		case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
 		case 'Y': case 'Z':
@@ -337,13 +794,13 @@
 		default:
 			malloc_write("<jemalloc>: Malformed conf string\n");
 			return (true);
 		}
 	}
 
-	for (accept = false; accept == false;) {
+	for (accept = false; !accept;) {
 		switch (*opts) {
 		case ',':
 			opts++;
 			/*
 			 * Look ahead one character here, because the next time
 			 * this function is called, it will assume that end of
@@ -391,20 +848,22 @@
 
 	/*
 	 * Automatically configure valgrind before processing options.  The
 	 * valgrind option remains in jemalloc 3.x for compatibility reasons.
 	 */
 	if (config_valgrind) {
-		opt_valgrind = (RUNNING_ON_VALGRIND != 0) ? true : false;
-		if (config_fill && opt_valgrind) {
-			opt_junk = false;
-			assert(opt_zero == false);
+		in_valgrind = (RUNNING_ON_VALGRIND != 0) ? true : false;
+		if (config_fill && unlikely(in_valgrind)) {
+			opt_junk = "false";
+			opt_junk_alloc = false;
+			opt_junk_free = false;
+			assert(!opt_zero);
 			opt_quarantine = JEMALLOC_VALGRIND_QUARANTINE_DEFAULT;
 			opt_redzone = true;
 		}
-		if (config_tcache && opt_valgrind)
+		if (config_tcache && unlikely(in_valgrind))
 			opt_tcache = false;
 	}
 
 	for (i = 0; i < 3; i++) {
 		/* Get runtime configuration. */
 		switch (i) {
@@ -438,13 +897,13 @@
 			 * symbolic link's name.
 			 */
 			linklen = readlink(linkname, buf, sizeof(buf) - 1);
 			if (linklen == -1) {
 				/* No configuration specified. */
 				linklen = 0;
-				/* restore errno */
+				/* Restore errno. */
 				set_errno(saved_errno);
 			}
 #endif
 			buf[linklen] = '\0';
 			opts = buf;
 			break;
@@ -454,13 +913,13 @@
 			    JEMALLOC_CPREFIX"MALLOC_CONF"
 #else
 			    "MALLOC_CONF"
 #endif
 			    ;
 
-			if ((opts = getenv(envname)) != NULL) {
+			if ((opts = secure_getenv(envname)) != NULL) {
 				/*
 				 * Do nothing; opts is already initialized to
 				 * the value of the MALLOC_CONF environment
 				 * variable.
 				 */
 			} else {
@@ -472,106 +931,106 @@
 		} default:
 			not_reached();
 			buf[0] = '\0';
 			opts = buf;
 		}
 
-		while (*opts != '\0' && malloc_conf_next(&opts, &k, &klen, &v,
-		    &vlen) == false) {
-#define	CONF_HANDLE_BOOL(o, n)						\
-			if (sizeof(n)-1 == klen && strncmp(n, k,	\
-			    klen) == 0) {				\
-				if (strncmp("true", v, vlen) == 0 &&	\
-				    vlen == sizeof("true")-1)		\
+		while (*opts != '\0' && !malloc_conf_next(&opts, &k, &klen, &v,
+		    &vlen)) {
+#define	CONF_MATCH(n)							\
+	(sizeof(n)-1 == klen && strncmp(n, k, klen) == 0)
+#define	CONF_MATCH_VALUE(n)						\
+	(sizeof(n)-1 == vlen && strncmp(n, v, vlen) == 0)
+#define	CONF_HANDLE_BOOL(o, n, cont)					\
+			if (CONF_MATCH(n)) {				\
+				if (CONF_MATCH_VALUE("true"))		\
 					o = true;			\
-				else if (strncmp("false", v, vlen) ==	\
-				    0 && vlen == sizeof("false")-1)	\
+				else if (CONF_MATCH_VALUE("false"))	\
 					o = false;			\
 				else {					\
 					malloc_conf_error(		\
 					    "Invalid conf value",	\
 					    k, klen, v, vlen);		\
 				}					\
-				continue;				\
+				if (cont)				\
+					continue;			\
 			}
 #define	CONF_HANDLE_SIZE_T(o, n, min, max, clip)			\
-			if (sizeof(n)-1 == klen && strncmp(n, k,	\
-			    klen) == 0) {				\
+			if (CONF_MATCH(n)) {				\
 				uintmax_t um;				\
 				char *end;				\
 									\
 				set_errno(0);				\
 				um = malloc_strtoumax(v, &end, 0);	\
 				if (get_errno() != 0 || (uintptr_t)end -\
 				    (uintptr_t)v != vlen) {		\
 					malloc_conf_error(		\
 					    "Invalid conf value",	\
 					    k, klen, v, vlen);		\
 				} else if (clip) {			\
-					if (min != 0 && um < min)	\
-						o = min;		\
-					else if (um > max)		\
-						o = max;		\
+					if ((min) != 0 && um < (min))	\
+						o = (min);		\
+					else if (um > (max))		\
+						o = (max);		\
 					else				\
 						o = um;			\
 				} else {				\
-					if ((min != 0 && um < min) ||	\
-					    um > max) {			\
+					if (((min) != 0 && um < (min))	\
+					    || um > (max)) {		\
 						malloc_conf_error(	\
 						    "Out-of-range "	\
 						    "conf value",	\
 						    k, klen, v, vlen);	\
 					} else				\
 						o = um;			\
 				}					\
 				continue;				\
 			}
 #define	CONF_HANDLE_SSIZE_T(o, n, min, max)				\
-			if (sizeof(n)-1 == klen && strncmp(n, k,	\
-			    klen) == 0) {				\
+			if (CONF_MATCH(n)) {				\
 				long l;					\
 				char *end;				\
 									\
 				set_errno(0);				\
 				l = strtol(v, &end, 0);			\
 				if (get_errno() != 0 || (uintptr_t)end -\
 				    (uintptr_t)v != vlen) {		\
 					malloc_conf_error(		\
 					    "Invalid conf value",	\
 					    k, klen, v, vlen);		\
-				} else if (l < (ssize_t)min || l >	\
-				    (ssize_t)max) {			\
+				} else if (l < (ssize_t)(min) || l >	\
+				    (ssize_t)(max)) {			\
 					malloc_conf_error(		\
 					    "Out-of-range conf value",	\
 					    k, klen, v, vlen);		\
 				} else					\
 					o = l;				\
 				continue;				\
 			}
 #define	CONF_HANDLE_CHAR_P(o, n, d)					\
-			if (sizeof(n)-1 == klen && strncmp(n, k,	\
-			    klen) == 0) {				\
+			if (CONF_MATCH(n)) {				\
 				size_t cpylen = (vlen <=		\
 				    sizeof(o)-1) ? vlen :		\
 				    sizeof(o)-1;			\
 				strncpy(o, v, cpylen);			\
 				o[cpylen] = '\0';			\
 				continue;				\
 			}
 
-			CONF_HANDLE_BOOL(opt_abort, "abort")
+			CONF_HANDLE_BOOL(opt_abort, "abort", true)
 			/*
-			 * Chunks always require at least one header page, plus
-			 * one data page in the absence of redzones, or three
-			 * pages in the presence of redzones.  In order to
-			 * simplify options processing, fix the limit based on
-			 * config_fill.
+			 * Chunks always require at least one header page,
+			 * as many as 2^(LG_SIZE_CLASS_GROUP+1) data pages, and
+			 * possibly an additional page in the presence of
+			 * redzones.  In order to simplify options processing,
+			 * use a conservative bound that accommodates all these
+			 * constraints.
 			 */
 			CONF_HANDLE_SIZE_T(opt_lg_chunk, "lg_chunk", LG_PAGE +
-			    (config_fill ? 2 : 1), (sizeof(size_t) << 3) - 1,
-			    true)
+			    LG_SIZE_CLASS_GROUP + (config_fill ? 2 : 1),
+			    (sizeof(size_t) << 3) - 1, true)
 			if (strncmp("dss", k, klen) == 0) {
 				int i;
 				bool match = false;
 				for (i = 0; i < dss_prec_limit; i++) {
 					if (strncmp(dss_prec_names[i], v, vlen)
 					    == 0) {
@@ -584,106 +1043,149 @@
 							    dss_prec_names[i];
 							match = true;
 							break;
 						}
 					}
 				}
-				if (match == false) {
+				if (!match) {
 					malloc_conf_error("Invalid conf value",
 					    k, klen, v, vlen);
 				}
 				continue;
 			}
 			CONF_HANDLE_SIZE_T(opt_narenas, "narenas", 1,
 			    SIZE_T_MAX, false)
 			CONF_HANDLE_SSIZE_T(opt_lg_dirty_mult, "lg_dirty_mult",
 			    -1, (sizeof(size_t) << 3) - 1)
-			CONF_HANDLE_BOOL(opt_stats_print, "stats_print")
+			CONF_HANDLE_BOOL(opt_stats_print, "stats_print", true)
 			if (config_fill) {
-				CONF_HANDLE_BOOL(opt_junk, "junk")
+				if (CONF_MATCH("junk")) {
+					if (CONF_MATCH_VALUE("true")) {
+						opt_junk = "true";
+						opt_junk_alloc = opt_junk_free =
+						    true;
+					} else if (CONF_MATCH_VALUE("false")) {
+						opt_junk = "false";
+						opt_junk_alloc = opt_junk_free =
+						    false;
+					} else if (CONF_MATCH_VALUE("alloc")) {
+						opt_junk = "alloc";
+						opt_junk_alloc = true;
+						opt_junk_free = false;
+					} else if (CONF_MATCH_VALUE("free")) {
+						opt_junk = "free";
+						opt_junk_alloc = false;
+						opt_junk_free = true;
+					} else {
+						malloc_conf_error(
+						    "Invalid conf value", k,
+						    klen, v, vlen);
+					}
+					continue;
+				}
 				CONF_HANDLE_SIZE_T(opt_quarantine, "quarantine",
 				    0, SIZE_T_MAX, false)
-				CONF_HANDLE_BOOL(opt_redzone, "redzone")
-				CONF_HANDLE_BOOL(opt_zero, "zero")
+				CONF_HANDLE_BOOL(opt_redzone, "redzone", true)
+				CONF_HANDLE_BOOL(opt_zero, "zero", true)
 			}
 			if (config_utrace) {
-				CONF_HANDLE_BOOL(opt_utrace, "utrace")
-			}
-			if (config_valgrind) {
-				CONF_HANDLE_BOOL(opt_valgrind, "valgrind")
+				CONF_HANDLE_BOOL(opt_utrace, "utrace", true)
 			}
 			if (config_xmalloc) {
-				CONF_HANDLE_BOOL(opt_xmalloc, "xmalloc")
+				CONF_HANDLE_BOOL(opt_xmalloc, "xmalloc", true)
 			}
 			if (config_tcache) {
-				CONF_HANDLE_BOOL(opt_tcache, "tcache")
+				CONF_HANDLE_BOOL(opt_tcache, "tcache",
+				    !config_valgrind || !in_valgrind)
+				if (CONF_MATCH("tcache")) {
+					assert(config_valgrind && in_valgrind);
+					if (opt_tcache) {
+						opt_tcache = false;
+						malloc_conf_error(
+						"tcache cannot be enabled "
+						"while running inside Valgrind",
+						k, klen, v, vlen);
+					}
+					continue;
+				}
 				CONF_HANDLE_SSIZE_T(opt_lg_tcache_max,
 				    "lg_tcache_max", -1,
 				    (sizeof(size_t) << 3) - 1)
 			}
 			if (config_prof) {
-				CONF_HANDLE_BOOL(opt_prof, "prof")
+				CONF_HANDLE_BOOL(opt_prof, "prof", true)
 				CONF_HANDLE_CHAR_P(opt_prof_prefix,
 				    "prof_prefix", "jeprof")
-				CONF_HANDLE_BOOL(opt_prof_active, "prof_active")
-				CONF_HANDLE_SSIZE_T(opt_lg_prof_sample,
+				CONF_HANDLE_BOOL(opt_prof_active, "prof_active",
+				    true)
+				CONF_HANDLE_BOOL(opt_prof_thread_active_init,
+				    "prof_thread_active_init", true)
+				CONF_HANDLE_SIZE_T(opt_lg_prof_sample,
 				    "lg_prof_sample", 0,
-				    (sizeof(uint64_t) << 3) - 1)
-				CONF_HANDLE_BOOL(opt_prof_accum, "prof_accum")
+				    (sizeof(uint64_t) << 3) - 1, true)
+				CONF_HANDLE_BOOL(opt_prof_accum, "prof_accum",
+				    true)
 				CONF_HANDLE_SSIZE_T(opt_lg_prof_interval,
 				    "lg_prof_interval", -1,
 				    (sizeof(uint64_t) << 3) - 1)
-				CONF_HANDLE_BOOL(opt_prof_gdump, "prof_gdump")
-				CONF_HANDLE_BOOL(opt_prof_final, "prof_final")
-				CONF_HANDLE_BOOL(opt_prof_leak, "prof_leak")
+				CONF_HANDLE_BOOL(opt_prof_gdump, "prof_gdump",
+				    true)
+				CONF_HANDLE_BOOL(opt_prof_final, "prof_final",
+				    true)
+				CONF_HANDLE_BOOL(opt_prof_leak, "prof_leak",
+				    true)
 			}
 			malloc_conf_error("Invalid conf pair", k, klen, v,
 			    vlen);
+#undef CONF_MATCH
 #undef CONF_HANDLE_BOOL
 #undef CONF_HANDLE_SIZE_T
 #undef CONF_HANDLE_SSIZE_T
 #undef CONF_HANDLE_CHAR_P
 		}
 	}
 }
 
+/* init_lock must be held. */
 static bool
-malloc_init_hard(void)
+malloc_init_hard_needed(void)
 {
-	arena_t *init_arenas[1];
 
-	malloc_mutex_lock(&init_lock);
-	if (malloc_initialized || IS_INITIALIZER) {
+	if (malloc_initialized() || (IS_INITIALIZER && malloc_init_state ==
+	    malloc_init_recursible)) {
 		/*
 		 * Another thread initialized the allocator before this one
 		 * acquired init_lock, or this thread is the initializing
 		 * thread, and it is recursively allocating.
 		 */
-		malloc_mutex_unlock(&init_lock);
 		return (false);
 	}
 #ifdef JEMALLOC_THREADED_INIT
-	if (malloc_initializer != NO_INITIALIZER && IS_INITIALIZER == false) {
+	if (malloc_initializer != NO_INITIALIZER && !IS_INITIALIZER) {
 		/* Busy-wait until the initializing thread completes. */
 		do {
 			malloc_mutex_unlock(&init_lock);
 			CPU_SPINWAIT;
 			malloc_mutex_lock(&init_lock);
-		} while (malloc_initialized == false);
-		malloc_mutex_unlock(&init_lock);
+		} while (!malloc_initialized());
 		return (false);
 	}
 #endif
+	return (true);
+}
+
+/* init_lock must be held. */
+static bool
+malloc_init_hard_a0_locked(void)
+{
+
 	malloc_initializer = INITIALIZER;
 
-	malloc_tsd_boot();
 	if (config_prof)
 		prof_boot0();
-
 	malloc_conf_init();
-
 	if (opt_stats_print) {
 		/* Print statistics at exit. */
 		if (atexit(stats_print_atexit) != 0) {
 			malloc_write("<jemalloc>: Error in atexit()\n");
 			if (opt_abort)
 				abort();
@@ -686,117 +1188,88 @@
 		if (atexit(stats_print_atexit) != 0) {
 			malloc_write("<jemalloc>: Error in atexit()\n");
 			if (opt_abort)
 				abort();
 		}
 	}
-
-	if (base_boot()) {
-		malloc_mutex_unlock(&init_lock);
+	if (base_boot())
 		return (true);
-	}
-
-	if (chunk_boot()) {
-		malloc_mutex_unlock(&init_lock);
+	if (chunk_boot())
 		return (true);
-	}
-
-	if (ctl_boot()) {
-		malloc_mutex_unlock(&init_lock);
+	if (ctl_boot())
 		return (true);
-	}
-
 	if (config_prof)
 		prof_boot1();
-
-	arena_boot();
-
-	if (config_tcache && tcache_boot0()) {
-		malloc_mutex_unlock(&init_lock);
+	if (arena_boot())
 		return (true);
-	}
-
-	if (huge_boot()) {
-		malloc_mutex_unlock(&init_lock);
+	if (config_tcache && tcache_boot())
 		return (true);
-	}
-
-	if (malloc_mutex_init(&arenas_lock)) {
-		malloc_mutex_unlock(&init_lock);
+	if (malloc_mutex_init(&arenas_lock))
 		return (true);
-	}
-
 	/*
 	 * Create enough scaffolding to allow recursive allocation in
 	 * malloc_ncpus().
 	 */
 	narenas_total = narenas_auto = 1;
-	arenas = init_arenas;
+	arenas = &a0;
 	memset(arenas, 0, sizeof(arena_t *) * narenas_auto);
-
 	/*
 	 * Initialize one arena here.  The rest are lazily created in
-	 * choose_arena_hard().
+	 * arena_choose_hard().
 	 */
-	arenas_extend(0);
-	if (arenas[0] == NULL) {
-		malloc_mutex_unlock(&init_lock);
-		return (true);
-	}
-
-	/* Initialize allocation counters before any allocations can occur. */
-	if (config_stats && thread_allocated_tsd_boot()) {
-		malloc_mutex_unlock(&init_lock);
+	if (arena_init(0) == NULL)
 		return (true);
-	}
-
-	if (arenas_tsd_boot()) {
-		malloc_mutex_unlock(&init_lock);
-		return (true);
-	}
+	malloc_init_state = malloc_init_a0_initialized;
+	return (false);
+}
 
-	if (config_tcache && tcache_boot1()) {
-		malloc_mutex_unlock(&init_lock);
-		return (true);
-	}
+static bool
+malloc_init_hard_a0(void)
+{
+	bool ret;
 
-	if (config_fill && quarantine_boot()) {
-		malloc_mutex_unlock(&init_lock);
-		return (true);
-	}
+	malloc_mutex_lock(&init_lock);
+	ret = malloc_init_hard_a0_locked();
+	malloc_mutex_unlock(&init_lock);
+	return (ret);
+}
 
-	if (config_prof && prof_boot2()) {
-		malloc_mutex_unlock(&init_lock);
-		return (true);
-	}
+/*
+ * Initialize data structures which may trigger recursive allocation.
+ *
+ * init_lock must be held.
+ */
+static void
+malloc_init_hard_recursible(void)
+{
 
+	malloc_init_state = malloc_init_recursible;
 	malloc_mutex_unlock(&init_lock);
-	/**********************************************************************/
-	/* Recursive allocation may follow. */
 
 	ncpus = malloc_ncpus();
 
 #if (!defined(JEMALLOC_MUTEX_INIT_CB) && !defined(JEMALLOC_ZONE) \
-    && !defined(_WIN32))
+    && !defined(_WIN32) && !defined(__native_client__))
 	/* LinuxThreads's pthread_atfork() allocates. */
 	if (pthread_atfork(jemalloc_prefork, jemalloc_postfork_parent,
 	    jemalloc_postfork_child) != 0) {
 		malloc_write("<jemalloc>: Error in pthread_atfork()\n");
 		if (opt_abort)
 			abort();
 	}
 #endif
-
-	/* Done recursively allocating. */
-	/**********************************************************************/
 	malloc_mutex_lock(&init_lock);
+}
 
-	if (mutex_boot()) {
-		malloc_mutex_unlock(&init_lock);
+/* init_lock must be held. */
+static bool
+malloc_init_hard_finish(void)
+{
+
+	if (mutex_boot())
 		return (true);
-	}
 
 	if (opt_narenas == 0) {
 		/*
 		 * For SMP systems, create more than one arena per CPU by
 		 * default.
 		 */
@@ -817,525 +1290,590 @@
 		    narenas_auto);
 	}
 	narenas_total = narenas_auto;
 
 	/* Allocate and initialize arenas. */
 	arenas = (arena_t **)base_alloc(sizeof(arena_t *) * narenas_total);
-	if (arenas == NULL) {
-		malloc_mutex_unlock(&init_lock);
+	if (arenas == NULL)
 		return (true);
-	}
 	/*
 	 * Zero the array.  In practice, this should always be pre-zeroed,
 	 * since it was just mmap()ed, but let's be sure.
 	 */
 	memset(arenas, 0, sizeof(arena_t *) * narenas_total);
 	/* Copy the pointer to the one arena that was already initialized. */
-	arenas[0] = init_arenas[0];
+	arenas[0] = a0;
 
-	malloc_initialized = true;
-	malloc_mutex_unlock(&init_lock);
+	malloc_init_state = malloc_init_initialized;
+	return (false);
+}
+
+static bool
+malloc_init_hard(void)
+{
+
+#if defined(_WIN32) && _WIN32_WINNT < 0x0600
+	_init_init_lock();
+#endif
+	malloc_mutex_lock(&init_lock);
+	if (!malloc_init_hard_needed()) {
+		malloc_mutex_unlock(&init_lock);
+		return (false);
+	}
+
+	if (malloc_init_state != malloc_init_a0_initialized &&
+	    malloc_init_hard_a0_locked()) {
+		malloc_mutex_unlock(&init_lock);
+		return (true);
+	}
+	if (malloc_tsd_boot0()) {
+		malloc_mutex_unlock(&init_lock);
+		return (true);
+	}
+	if (config_prof && prof_boot2()) {
+		malloc_mutex_unlock(&init_lock);
+		return (true);
+	}
+
+	malloc_init_hard_recursible();
 
+	if (malloc_init_hard_finish()) {
+		malloc_mutex_unlock(&init_lock);
+		return (true);
+	}
+
+	malloc_mutex_unlock(&init_lock);
+	malloc_tsd_boot1();
 	return (false);
 }
 
 /*
  * End initialization functions.
  */
 /******************************************************************************/
 /*
  * Begin malloc(3)-compatible functions.
  */
 
 static void *
-imalloc_prof_sample(size_t usize, prof_thr_cnt_t *cnt)
+imalloc_prof_sample(tsd_t *tsd, size_t usize, prof_tctx_t *tctx)
 {
 	void *p;
 
-	if (cnt == NULL)
+	if (tctx == NULL)
 		return (NULL);
-	if (prof_promote && usize <= SMALL_MAXCLASS) {
-		p = imalloc(SMALL_MAXCLASS+1);
+	if (usize <= SMALL_MAXCLASS) {
+		p = imalloc(tsd, LARGE_MINCLASS);
 		if (p == NULL)
 			return (NULL);
 		arena_prof_promoted(p, usize);
 	} else
-		p = imalloc(usize);
+		p = imalloc(tsd, usize);
 
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE_C void *
-imalloc_prof(size_t usize, prof_thr_cnt_t *cnt)
+imalloc_prof(tsd_t *tsd, size_t usize)
 {
 	void *p;
+	prof_tctx_t *tctx;
 
-	if ((uintptr_t)cnt != (uintptr_t)1U)
-		p = imalloc_prof_sample(usize, cnt);
+	tctx = prof_alloc_prep(tsd, usize, prof_active_get_unlocked(), true);
+	if (unlikely((uintptr_t)tctx != (uintptr_t)1U))
+		p = imalloc_prof_sample(tsd, usize, tctx);
 	else
-		p = imalloc(usize);
-	if (p == NULL)
+		p = imalloc(tsd, usize);
+	if (unlikely(p == NULL)) {
+		prof_alloc_rollback(tsd, tctx, true);
 		return (NULL);
-	prof_malloc(p, usize, cnt);
+	}
+	prof_malloc(p, usize, tctx);
 
 	return (p);
 }
 
-/*
- * MALLOC_BODY() is a macro rather than a function because its contents are in
- * the fast path, but inlining would cause reliability issues when determining
- * how many frames to discard from heap profiling backtraces.
- */
-#define	MALLOC_BODY(ret, size, usize) do {				\
-	if (malloc_init())						\
-		ret = NULL;						\
-	else {								\
-		if (config_prof && opt_prof) {				\
-			prof_thr_cnt_t *cnt;				\
-									\
-			usize = s2u(size);				\
-			/*						\
-			 * Call PROF_ALLOC_PREP() here rather than in	\
-			 * imalloc_prof() so that imalloc_prof() can be	\
-			 * inlined without introducing uncertainty	\
-			 * about the number of backtrace frames to	\
-			 * ignore.  imalloc_prof() is in the fast path	\
-			 * when heap profiling is enabled, so inlining	\
-			 * is critical to performance.  (For		\
-			 * consistency all callers of PROF_ALLOC_PREP()	\
-			 * are structured similarly, even though e.g.	\
-			 * realloc() isn't called enough for inlining	\
-			 * to be critical.)				\
-			 */						\
-			PROF_ALLOC_PREP(1, usize, cnt);			\
-			ret = imalloc_prof(usize, cnt);			\
-		} else {						\
-			if (config_stats || (config_valgrind &&		\
-			    opt_valgrind))				\
-				usize = s2u(size);			\
-			ret = imalloc(size);				\
-		}							\
-	}								\
-} while (0)
+JEMALLOC_ALWAYS_INLINE_C void *
+imalloc_body(size_t size, tsd_t **tsd, size_t *usize)
+{
+
+	if (unlikely(malloc_init()))
+		return (NULL);
+	*tsd = tsd_fetch();
+
+	if (config_prof && opt_prof) {
+		*usize = s2u(size);
+		if (unlikely(*usize == 0))
+			return (NULL);
+		return (imalloc_prof(*tsd, *usize));
+	}
 
-void *
+	if (config_stats || (config_valgrind && unlikely(in_valgrind)))
+		*usize = s2u(size);
+	return (imalloc(*tsd, size));
+}
+
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+void JEMALLOC_NOTHROW *
+JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
 je_malloc(size_t size)
 {
 	void *ret;
+	tsd_t *tsd;
 	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
 
 	if (size == 0)
 		size = 1;
 
-	MALLOC_BODY(ret, size, usize);
-
-	if (ret == NULL) {
-		if (config_xmalloc && opt_xmalloc) {
+	ret = imalloc_body(size, &tsd, &usize);
+	if (unlikely(ret == NULL)) {
+		if (config_xmalloc && unlikely(opt_xmalloc)) {
 			malloc_write("<jemalloc>: Error in malloc(): "
 			    "out of memory\n");
 			abort();
 		}
 		set_errno(ENOMEM);
 	}
-	if (config_stats && ret != NULL) {
+	if (config_stats && likely(ret != NULL)) {
 		assert(usize == isalloc(ret, config_prof));
-		thread_allocated_tsd_get()->allocated += usize;
+		*tsd_thread_allocatedp_get(tsd) += usize;
 	}
 	UTRACE(0, size, ret);
 	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, usize, false);
 	return (ret);
 }
 
 static void *
-imemalign_prof_sample(size_t alignment, size_t usize, prof_thr_cnt_t *cnt)
+imemalign_prof_sample(tsd_t *tsd, size_t alignment, size_t usize,
+    prof_tctx_t *tctx)
 {
 	void *p;
 
-	if (cnt == NULL)
+	if (tctx == NULL)
 		return (NULL);
-	if (prof_promote && usize <= SMALL_MAXCLASS) {
-		assert(sa2u(SMALL_MAXCLASS+1, alignment) != 0);
-		p = ipalloc(sa2u(SMALL_MAXCLASS+1, alignment), alignment,
-		    false);
+	if (usize <= SMALL_MAXCLASS) {
+		assert(sa2u(LARGE_MINCLASS, alignment) == LARGE_MINCLASS);
+		p = ipalloc(tsd, LARGE_MINCLASS, alignment, false);
 		if (p == NULL)
 			return (NULL);
 		arena_prof_promoted(p, usize);
 	} else
-		p = ipalloc(usize, alignment, false);
+		p = ipalloc(tsd, usize, alignment, false);
 
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE_C void *
-imemalign_prof(size_t alignment, size_t usize, prof_thr_cnt_t *cnt)
+imemalign_prof(tsd_t *tsd, size_t alignment, size_t usize)
 {
 	void *p;
+	prof_tctx_t *tctx;
 
-	if ((uintptr_t)cnt != (uintptr_t)1U)
-		p = imemalign_prof_sample(alignment, usize, cnt);
+	tctx = prof_alloc_prep(tsd, usize, prof_active_get_unlocked(), true);
+	if (unlikely((uintptr_t)tctx != (uintptr_t)1U))
+		p = imemalign_prof_sample(tsd, alignment, usize, tctx);
 	else
-		p = ipalloc(usize, alignment, false);
-	if (p == NULL)
+		p = ipalloc(tsd, usize, alignment, false);
+	if (unlikely(p == NULL)) {
+		prof_alloc_rollback(tsd, tctx, true);
 		return (NULL);
-	prof_malloc(p, usize, cnt);
+	}
+	prof_malloc(p, usize, tctx);
 
 	return (p);
 }
 
 JEMALLOC_ATTR(nonnull(1))
-#ifdef JEMALLOC_PROF
-/*
- * Avoid any uncertainty as to how many backtrace frames to ignore in
- * PROF_ALLOC_PREP().
- */
-JEMALLOC_NOINLINE
-#endif
 static int
 imemalign(void **memptr, size_t alignment, size_t size, size_t min_alignment)
 {
 	int ret;
+	tsd_t *tsd;
 	size_t usize;
 	void *result;
 
 	assert(min_alignment != 0);
 
-	if (malloc_init()) {
+	if (unlikely(malloc_init())) {
 		result = NULL;
 		goto label_oom;
-	} else {
-		if (size == 0)
-			size = 1;
-
-		/* Make sure that alignment is a large enough power of 2. */
-		if (((alignment - 1) & alignment) != 0
-		    || (alignment < min_alignment)) {
-			if (config_xmalloc && opt_xmalloc) {
-				malloc_write("<jemalloc>: Error allocating "
-				    "aligned memory: invalid alignment\n");
-				abort();
-			}
-			result = NULL;
-			ret = EINVAL;
-			goto label_return;
-		}
+	}
+	tsd = tsd_fetch();
+	if (size == 0)
+		size = 1;
 
-		usize = sa2u(size, alignment);
-		if (usize == 0) {
-			result = NULL;
-			goto label_oom;
+	/* Make sure that alignment is a large enough power of 2. */
+	if (unlikely(((alignment - 1) & alignment) != 0
+	    || (alignment < min_alignment))) {
+		if (config_xmalloc && unlikely(opt_xmalloc)) {
+			malloc_write("<jemalloc>: Error allocating "
+			    "aligned memory: invalid alignment\n");
+			abort();
 		}
+		result = NULL;
+		ret = EINVAL;
+		goto label_return;
+	}
 
-		if (config_prof && opt_prof) {
-			prof_thr_cnt_t *cnt;
-
-			PROF_ALLOC_PREP(2, usize, cnt);
-			result = imemalign_prof(alignment, usize, cnt);
-		} else
-			result = ipalloc(usize, alignment, false);
-		if (result == NULL)
-			goto label_oom;
+	usize = sa2u(size, alignment);
+	if (unlikely(usize == 0)) {
+		result = NULL;
+		goto label_oom;
 	}
 
+	if (config_prof && opt_prof)
+		result = imemalign_prof(tsd, alignment, usize);
+	else
+		result = ipalloc(tsd, usize, alignment, false);
+	if (unlikely(result == NULL))
+		goto label_oom;
+	assert(((uintptr_t)result & (alignment - 1)) == ZU(0));
+
 	*memptr = result;
 	ret = 0;
 label_return:
-	if (config_stats && result != NULL) {
+	if (config_stats && likely(result != NULL)) {
 		assert(usize == isalloc(result, config_prof));
-		thread_allocated_tsd_get()->allocated += usize;
+		*tsd_thread_allocatedp_get(tsd) += usize;
 	}
 	UTRACE(0, size, result);
 	return (ret);
 label_oom:
 	assert(result == NULL);
-	if (config_xmalloc && opt_xmalloc) {
+	if (config_xmalloc && unlikely(opt_xmalloc)) {
 		malloc_write("<jemalloc>: Error allocating aligned memory: "
 		    "out of memory\n");
 		abort();
 	}
 	ret = ENOMEM;
 	goto label_return;
 }
 
-int
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW
+JEMALLOC_ATTR(nonnull(1))
 je_posix_memalign(void **memptr, size_t alignment, size_t size)
 {
 	int ret = imemalign(memptr, alignment, size, sizeof(void *));
 	JEMALLOC_VALGRIND_MALLOC(ret == 0, *memptr, isalloc(*memptr,
 	    config_prof), false);
 	return (ret);
 }
 
-void *
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+void JEMALLOC_NOTHROW *
+JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(2)
 je_aligned_alloc(size_t alignment, size_t size)
 {
 	void *ret;
 	int err;
 
-	if ((err = imemalign(&ret, alignment, size, 1)) != 0) {
+	if (unlikely((err = imemalign(&ret, alignment, size, 1)) != 0)) {
 		ret = NULL;
 		set_errno(err);
 	}
 	JEMALLOC_VALGRIND_MALLOC(err == 0, ret, isalloc(ret, config_prof),
 	    false);
 	return (ret);
 }
 
 static void *
-icalloc_prof_sample(size_t usize, prof_thr_cnt_t *cnt)
+icalloc_prof_sample(tsd_t *tsd, size_t usize, prof_tctx_t *tctx)
 {
 	void *p;
 
-	if (cnt == NULL)
+	if (tctx == NULL)
 		return (NULL);
-	if (prof_promote && usize <= SMALL_MAXCLASS) {
-		p = icalloc(SMALL_MAXCLASS+1);
+	if (usize <= SMALL_MAXCLASS) {
+		p = icalloc(tsd, LARGE_MINCLASS);
 		if (p == NULL)
 			return (NULL);
 		arena_prof_promoted(p, usize);
 	} else
-		p = icalloc(usize);
+		p = icalloc(tsd, usize);
 
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE_C void *
-icalloc_prof(size_t usize, prof_thr_cnt_t *cnt)
+icalloc_prof(tsd_t *tsd, size_t usize)
 {
 	void *p;
+	prof_tctx_t *tctx;
 
-	if ((uintptr_t)cnt != (uintptr_t)1U)
-		p = icalloc_prof_sample(usize, cnt);
+	tctx = prof_alloc_prep(tsd, usize, prof_active_get_unlocked(), true);
+	if (unlikely((uintptr_t)tctx != (uintptr_t)1U))
+		p = icalloc_prof_sample(tsd, usize, tctx);
 	else
-		p = icalloc(usize);
-	if (p == NULL)
+		p = icalloc(tsd, usize);
+	if (unlikely(p == NULL)) {
+		prof_alloc_rollback(tsd, tctx, true);
 		return (NULL);
-	prof_malloc(p, usize, cnt);
+	}
+	prof_malloc(p, usize, tctx);
 
 	return (p);
 }
 
-void *
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+void JEMALLOC_NOTHROW *
+JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2)
 je_calloc(size_t num, size_t size)
 {
 	void *ret;
+	tsd_t *tsd;
 	size_t num_size;
 	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
 
-	if (malloc_init()) {
+	if (unlikely(malloc_init())) {
 		num_size = 0;
 		ret = NULL;
 		goto label_return;
 	}
+	tsd = tsd_fetch();
 
 	num_size = num * size;
-	if (num_size == 0) {
+	if (unlikely(num_size == 0)) {
 		if (num == 0 || size == 0)
 			num_size = 1;
 		else {
 			ret = NULL;
 			goto label_return;
 		}
 	/*
 	 * Try to avoid division here.  We know that it isn't possible to
 	 * overflow during multiplication if neither operand uses any of the
 	 * most significant half of the bits in a size_t.
 	 */
-	} else if (((num | size) & (SIZE_T_MAX << (sizeof(size_t) << 2)))
-	    && (num_size / size != num)) {
+	} else if (unlikely(((num | size) & (SIZE_T_MAX << (sizeof(size_t) <<
+	    2))) && (num_size / size != num))) {
 		/* size_t overflow. */
 		ret = NULL;
 		goto label_return;
 	}
 
 	if (config_prof && opt_prof) {
-		prof_thr_cnt_t *cnt;
-
 		usize = s2u(num_size);
-		PROF_ALLOC_PREP(1, usize, cnt);
-		ret = icalloc_prof(usize, cnt);
+		if (unlikely(usize == 0)) {
+			ret = NULL;
+			goto label_return;
+		}
+		ret = icalloc_prof(tsd, usize);
 	} else {
-		if (config_stats || (config_valgrind && opt_valgrind))
+		if (config_stats || (config_valgrind && unlikely(in_valgrind)))
 			usize = s2u(num_size);
-		ret = icalloc(num_size);
+		ret = icalloc(tsd, num_size);
 	}
 
 label_return:
-	if (ret == NULL) {
-		if (config_xmalloc && opt_xmalloc) {
+	if (unlikely(ret == NULL)) {
+		if (config_xmalloc && unlikely(opt_xmalloc)) {
 			malloc_write("<jemalloc>: Error in calloc(): out of "
 			    "memory\n");
 			abort();
 		}
 		set_errno(ENOMEM);
 	}
-	if (config_stats && ret != NULL) {
+	if (config_stats && likely(ret != NULL)) {
 		assert(usize == isalloc(ret, config_prof));
-		thread_allocated_tsd_get()->allocated += usize;
+		*tsd_thread_allocatedp_get(tsd) += usize;
 	}
 	UTRACE(0, num_size, ret);
 	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, usize, true);
 	return (ret);
 }
 
 static void *
-irealloc_prof_sample(void *oldptr, size_t usize, prof_thr_cnt_t *cnt)
+irealloc_prof_sample(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
+    prof_tctx_t *tctx)
 {
 	void *p;
 
-	if (cnt == NULL)
+	if (tctx == NULL)
 		return (NULL);
-	if (prof_promote && usize <= SMALL_MAXCLASS) {
-		p = iralloc(oldptr, SMALL_MAXCLASS+1, 0, 0, false);
+	if (usize <= SMALL_MAXCLASS) {
+		p = iralloc(tsd, old_ptr, old_usize, LARGE_MINCLASS, 0, false);
 		if (p == NULL)
 			return (NULL);
 		arena_prof_promoted(p, usize);
 	} else
-		p = iralloc(oldptr, usize, 0, 0, false);
+		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false);
 
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE_C void *
-irealloc_prof(void *oldptr, size_t old_usize, size_t usize, prof_thr_cnt_t *cnt)
+irealloc_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize)
 {
 	void *p;
-	prof_ctx_t *old_ctx;
+	bool prof_active;
+	prof_tctx_t *old_tctx, *tctx;
 
-	old_ctx = prof_ctx_get(oldptr);
-	if ((uintptr_t)cnt != (uintptr_t)1U)
-		p = irealloc_prof_sample(oldptr, usize, cnt);
+	prof_active = prof_active_get_unlocked();
+	old_tctx = prof_tctx_get(old_ptr);
+	tctx = prof_alloc_prep(tsd, usize, prof_active, true);
+	if (unlikely((uintptr_t)tctx != (uintptr_t)1U))
+		p = irealloc_prof_sample(tsd, old_ptr, old_usize, usize, tctx);
 	else
-		p = iralloc(oldptr, usize, 0, 0, false);
-	if (p == NULL)
+		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false);
+	if (unlikely(p == NULL)) {
+		prof_alloc_rollback(tsd, tctx, true);
 		return (NULL);
-	prof_realloc(p, usize, cnt, old_usize, old_ctx);
+	}
+	prof_realloc(tsd, p, usize, tctx, prof_active, true, old_ptr, old_usize,
+	    old_tctx);
 
 	return (p);
 }
 
 JEMALLOC_INLINE_C void
-ifree(void *ptr)
+ifree(tsd_t *tsd, void *ptr, tcache_t *tcache)
 {
 	size_t usize;
 	UNUSED size_t rzsize JEMALLOC_CC_SILENCE_INIT(0);
 
 	assert(ptr != NULL);
-	assert(malloc_initialized || IS_INITIALIZER);
+	assert(malloc_initialized() || IS_INITIALIZER);
 
 	if (config_prof && opt_prof) {
 		usize = isalloc(ptr, config_prof);
-		prof_free(ptr, usize);
+		prof_free(tsd, ptr, usize);
 	} else if (config_stats || config_valgrind)
 		usize = isalloc(ptr, config_prof);
 	if (config_stats)
-		thread_allocated_tsd_get()->deallocated += usize;
-	if (config_valgrind && opt_valgrind)
+		*tsd_thread_deallocatedp_get(tsd) += usize;
+	if (config_valgrind && unlikely(in_valgrind))
 		rzsize = p2rz(ptr);
-	iqalloc(ptr);
+	iqalloc(tsd, ptr, tcache);
 	JEMALLOC_VALGRIND_FREE(ptr, rzsize);
 }
 
-void *
+JEMALLOC_INLINE_C void
+isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache)
+{
+	UNUSED size_t rzsize JEMALLOC_CC_SILENCE_INIT(0);
+
+	assert(ptr != NULL);
+	assert(malloc_initialized() || IS_INITIALIZER);
+
+	if (config_prof && opt_prof)
+		prof_free(tsd, ptr, usize);
+	if (config_stats)
+		*tsd_thread_deallocatedp_get(tsd) += usize;
+	if (config_valgrind && unlikely(in_valgrind))
+		rzsize = p2rz(ptr);
+	isqalloc(tsd, ptr, usize, tcache);
+	JEMALLOC_VALGRIND_FREE(ptr, rzsize);
+}
+
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+void JEMALLOC_NOTHROW *
+JEMALLOC_ALLOC_SIZE(2)
 je_realloc(void *ptr, size_t size)
 {
 	void *ret;
+	tsd_t *tsd JEMALLOC_CC_SILENCE_INIT(NULL);
 	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
 	size_t old_usize = 0;
 	UNUSED size_t old_rzsize JEMALLOC_CC_SILENCE_INIT(0);
 
-	if (size == 0) {
+	if (unlikely(size == 0)) {
 		if (ptr != NULL) {
 			/* realloc(ptr, 0) is equivalent to free(ptr). */
 			UTRACE(ptr, 0, 0);
-			ifree(ptr);
+			tsd = tsd_fetch();
+			ifree(tsd, ptr, tcache_get(tsd, false));
 			return (NULL);
 		}
 		size = 1;
 	}
 
-	if (ptr != NULL) {
-		assert(malloc_initialized || IS_INITIALIZER);
+	if (likely(ptr != NULL)) {
+		assert(malloc_initialized() || IS_INITIALIZER);
 		malloc_thread_init();
+		tsd = tsd_fetch();
 
-		if ((config_prof && opt_prof) || config_stats ||
-		    (config_valgrind && opt_valgrind))
-			old_usize = isalloc(ptr, config_prof);
-		if (config_valgrind && opt_valgrind)
+		old_usize = isalloc(ptr, config_prof);
+		if (config_valgrind && unlikely(in_valgrind))
 			old_rzsize = config_prof ? p2rz(ptr) : u2rz(old_usize);
 
 		if (config_prof && opt_prof) {
-			prof_thr_cnt_t *cnt;
-
 			usize = s2u(size);
-			PROF_ALLOC_PREP(1, usize, cnt);
-			ret = irealloc_prof(ptr, old_usize, usize, cnt);
+			ret = unlikely(usize == 0) ? NULL : irealloc_prof(tsd,
+			    ptr, old_usize, usize);
 		} else {
-			if (config_stats || (config_valgrind && opt_valgrind))
+			if (config_stats || (config_valgrind &&
+			    unlikely(in_valgrind)))
 				usize = s2u(size);
-			ret = iralloc(ptr, size, 0, 0, false);
+			ret = iralloc(tsd, ptr, old_usize, size, 0, false);
 		}
 	} else {
 		/* realloc(NULL, size) is equivalent to malloc(size). */
-		MALLOC_BODY(ret, size, usize);
+		ret = imalloc_body(size, &tsd, &usize);
 	}
 
-	if (ret == NULL) {
-		if (config_xmalloc && opt_xmalloc) {
+	if (unlikely(ret == NULL)) {
+		if (config_xmalloc && unlikely(opt_xmalloc)) {
 			malloc_write("<jemalloc>: Error in realloc(): "
 			    "out of memory\n");
 			abort();
 		}
 		set_errno(ENOMEM);
 	}
-	if (config_stats && ret != NULL) {
-		thread_allocated_t *ta;
+	if (config_stats && likely(ret != NULL)) {
 		assert(usize == isalloc(ret, config_prof));
-		ta = thread_allocated_tsd_get();
-		ta->allocated += usize;
-		ta->deallocated += old_usize;
+		*tsd_thread_allocatedp_get(tsd) += usize;
+		*tsd_thread_deallocatedp_get(tsd) += old_usize;
 	}
 	UTRACE(ptr, size, ret);
-	JEMALLOC_VALGRIND_REALLOC(ret, usize, ptr, old_usize, old_rzsize,
-	    false);
+	JEMALLOC_VALGRIND_REALLOC(true, ret, usize, true, ptr, old_usize,
+	    old_rzsize, true, false);
 	return (ret);
 }
 
-void
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_free(void *ptr)
 {
 
 	UTRACE(ptr, 0, 0);
-	if (ptr != NULL)
-		ifree(ptr);
+	if (likely(ptr != NULL)) {
+		tsd_t *tsd = tsd_fetch();
+		ifree(tsd, ptr, tcache_get(tsd, false));
+	}
 }
 
 /*
  * End malloc(3)-compatible functions.
  */
 /******************************************************************************/
 /*
  * Begin non-standard override functions.
  */
 
 #ifdef JEMALLOC_OVERRIDE_MEMALIGN
-void *
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+void JEMALLOC_NOTHROW *
+JEMALLOC_ATTR(malloc)
 je_memalign(size_t alignment, size_t size)
 {
 	void *ret JEMALLOC_CC_SILENCE_INIT(NULL);
-	imemalign(&ret, alignment, size, 1);
+	if (unlikely(imemalign(&ret, alignment, size, 1) != 0))
+		ret = NULL;
 	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, size, false);
 	return (ret);
 }
 #endif
 
 #ifdef JEMALLOC_OVERRIDE_VALLOC
-void *
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+void JEMALLOC_NOTHROW *
+JEMALLOC_ATTR(malloc)
 je_valloc(size_t size)
 {
 	void *ret JEMALLOC_CC_SILENCE_INIT(NULL);
-	imemalign(&ret, PAGE, size, 1);
+	if (unlikely(imemalign(&ret, PAGE, size, 1) != 0))
+		ret = NULL;
 	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, size, false);
 	return (ret);
 }
 #endif
 
 /*
@@ -1343,619 +1881,618 @@
  * #define je_malloc malloc
  */
 #define	malloc_is_malloc 1
 #define	is_malloc_(a) malloc_is_ ## a
 #define	is_malloc(a) is_malloc_(a)
 
-#if ((is_malloc(je_malloc) == 1) && defined(__GLIBC__) && !defined(__UCLIBC__))
+#if ((is_malloc(je_malloc) == 1) && defined(JEMALLOC_GLIBC_MALLOC_HOOK))
 /*
  * glibc provides the RTLD_DEEPBIND flag for dlopen which can make it possible
  * to inconsistently reference libc's malloc(3)-compatible functions
  * (https://bugzilla.mozilla.org/show_bug.cgi?id=493541).
  *
  * These definitions interpose hooks in glibc.  The functions are actually
  * passed an extra argument for the caller return address, which will be
  * ignored.
  */
-JEMALLOC_EXPORT void (* __free_hook)(void *ptr) = je_free;
-JEMALLOC_EXPORT void *(* __malloc_hook)(size_t size) = je_malloc;
-JEMALLOC_EXPORT void *(* __realloc_hook)(void *ptr, size_t size) = je_realloc;
-JEMALLOC_EXPORT void *(* __memalign_hook)(size_t alignment, size_t size) =
+JEMALLOC_EXPORT void (*__free_hook)(void *ptr) = je_free;
+JEMALLOC_EXPORT void *(*__malloc_hook)(size_t size) = je_malloc;
+JEMALLOC_EXPORT void *(*__realloc_hook)(void *ptr, size_t size) = je_realloc;
+# ifdef JEMALLOC_GLIBC_MEMALIGN_HOOK
+JEMALLOC_EXPORT void *(*__memalign_hook)(size_t alignment, size_t size) =
     je_memalign;
+# endif
 #endif
 
 /*
  * End non-standard override functions.
  */
 /******************************************************************************/
 /*
  * Begin non-standard functions.
  */
 
-JEMALLOC_ALWAYS_INLINE_C void *
-imallocx(size_t usize, size_t alignment, bool zero, bool try_tcache,
-    arena_t *arena)
+JEMALLOC_ALWAYS_INLINE_C bool
+imallocx_flags_decode_hard(tsd_t *tsd, size_t size, int flags, size_t *usize,
+    size_t *alignment, bool *zero, tcache_t **tcache, arena_t **arena)
+{
+
+	if ((flags & MALLOCX_LG_ALIGN_MASK) == 0) {
+		*alignment = 0;
+		*usize = s2u(size);
+	} else {
+		*alignment = MALLOCX_ALIGN_GET_SPECIFIED(flags);
+		*usize = sa2u(size, *alignment);
+	}
+	assert(*usize != 0);
+	*zero = MALLOCX_ZERO_GET(flags);
+	if ((flags & MALLOCX_TCACHE_MASK) != 0) {
+		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE)
+			*tcache = NULL;
+		else
+			*tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
+	} else
+		*tcache = tcache_get(tsd, true);
+	if ((flags & MALLOCX_ARENA_MASK) != 0) {
+		unsigned arena_ind = MALLOCX_ARENA_GET(flags);
+		*arena = arena_get(tsd, arena_ind, true, true);
+		if (unlikely(*arena == NULL))
+			return (true);
+	} else
+		*arena = NULL;
+	return (false);
+}
+
+JEMALLOC_ALWAYS_INLINE_C bool
+imallocx_flags_decode(tsd_t *tsd, size_t size, int flags, size_t *usize,
+    size_t *alignment, bool *zero, tcache_t **tcache, arena_t **arena)
 {
 
-	assert(usize == ((alignment == 0) ? s2u(usize) : sa2u(usize,
-	    alignment)));
+	if (likely(flags == 0)) {
+		*usize = s2u(size);
+		assert(*usize != 0);
+		*alignment = 0;
+		*zero = false;
+		*tcache = tcache_get(tsd, true);
+		*arena = NULL;
+		return (false);
+	} else {
+		return (imallocx_flags_decode_hard(tsd, size, flags, usize,
+		    alignment, zero, tcache, arena));
+	}
+}
 
-	if (alignment != 0)
-		return (ipalloct(usize, alignment, zero, try_tcache, arena));
-	else if (zero)
-		return (icalloct(usize, try_tcache, arena));
-	else
-		return (imalloct(usize, try_tcache, arena));
+JEMALLOC_ALWAYS_INLINE_C void *
+imallocx_flags(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, arena_t *arena)
+{
+
+	if (unlikely(alignment != 0))
+		return (ipalloct(tsd, usize, alignment, zero, tcache, arena));
+	if (unlikely(zero))
+		return (icalloct(tsd, usize, tcache, arena));
+	return (imalloct(tsd, usize, tcache, arena));
 }
 
 static void *
-imallocx_prof_sample(size_t usize, size_t alignment, bool zero, bool try_tcache,
-    arena_t *arena, prof_thr_cnt_t *cnt)
+imallocx_prof_sample(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, arena_t *arena)
 {
 	void *p;
 
-	if (cnt == NULL)
-		return (NULL);
-	if (prof_promote && usize <= SMALL_MAXCLASS) {
-		size_t usize_promoted = (alignment == 0) ?
-		    s2u(SMALL_MAXCLASS+1) : sa2u(SMALL_MAXCLASS+1, alignment);
-		assert(usize_promoted != 0);
-		p = imallocx(usize_promoted, alignment, zero, try_tcache,
+	if (usize <= SMALL_MAXCLASS) {
+		assert(((alignment == 0) ? s2u(LARGE_MINCLASS) :
+		    sa2u(LARGE_MINCLASS, alignment)) == LARGE_MINCLASS);
+		p = imallocx_flags(tsd, LARGE_MINCLASS, alignment, zero, tcache,
 		    arena);
 		if (p == NULL)
 			return (NULL);
 		arena_prof_promoted(p, usize);
 	} else
-		p = imallocx(usize, alignment, zero, try_tcache, arena);
+		p = imallocx_flags(tsd, usize, alignment, zero, tcache, arena);
 
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE_C void *
-imallocx_prof(size_t usize, size_t alignment, bool zero, bool try_tcache,
-    arena_t *arena, prof_thr_cnt_t *cnt)
+imallocx_prof(tsd_t *tsd, size_t size, int flags, size_t *usize)
 {
 	void *p;
+	size_t alignment;
+	bool zero;
+	tcache_t *tcache;
+	arena_t *arena;
+	prof_tctx_t *tctx;
 
-	if ((uintptr_t)cnt != (uintptr_t)1U) {
-		p = imallocx_prof_sample(usize, alignment, zero, try_tcache,
-		    arena, cnt);
+	if (unlikely(imallocx_flags_decode(tsd, size, flags, usize, &alignment,
+	    &zero, &tcache, &arena)))
+		return (NULL);
+	tctx = prof_alloc_prep(tsd, *usize, prof_active_get_unlocked(), true);
+	if (likely((uintptr_t)tctx == (uintptr_t)1U))
+		p = imallocx_flags(tsd, *usize, alignment, zero, tcache, arena);
+	else if ((uintptr_t)tctx > (uintptr_t)1U) {
+		p = imallocx_prof_sample(tsd, *usize, alignment, zero, tcache,
+		    arena);
 	} else
-		p = imallocx(usize, alignment, zero, try_tcache, arena);
-	if (p == NULL)
+		p = NULL;
+	if (unlikely(p == NULL)) {
+		prof_alloc_rollback(tsd, tctx, true);
 		return (NULL);
-	prof_malloc(p, usize, cnt);
+	}
+	prof_malloc(p, *usize, tctx);
 
+	assert(alignment == 0 || ((uintptr_t)p & (alignment - 1)) == ZU(0));
 	return (p);
 }
 
-void *
-je_mallocx(size_t size, int flags)
+JEMALLOC_ALWAYS_INLINE_C void *
+imallocx_no_prof(tsd_t *tsd, size_t size, int flags, size_t *usize)
 {
 	void *p;
-	size_t usize;
-	size_t alignment = (ZU(1) << (flags & MALLOCX_LG_ALIGN_MASK)
-	    & (SIZE_T_MAX-1));
-	bool zero = flags & MALLOCX_ZERO;
-	unsigned arena_ind = ((unsigned)(flags >> 8)) - 1;
+	size_t alignment;
+	bool zero;
+	tcache_t *tcache;
 	arena_t *arena;
-	bool try_tcache;
 
-	assert(size != 0);
+	if (likely(flags == 0)) {
+		if (config_stats || (config_valgrind && unlikely(in_valgrind)))
+			*usize = s2u(size);
+		return (imalloc(tsd, size));
+	}
 
-	if (malloc_init())
-		goto label_oom;
+	if (unlikely(imallocx_flags_decode_hard(tsd, size, flags, usize,
+	    &alignment, &zero, &tcache, &arena)))
+		return (NULL);
+	p = imallocx_flags(tsd, *usize, alignment, zero, tcache, arena);
+	assert(alignment == 0 || ((uintptr_t)p & (alignment - 1)) == ZU(0));
+	return (p);
+}
 
-	if (arena_ind != UINT_MAX) {
-		arena = arenas[arena_ind];
-		try_tcache = false;
-	} else {
-		arena = NULL;
-		try_tcache = true;
-	}
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+void JEMALLOC_NOTHROW *
+JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
+je_mallocx(size_t size, int flags)
+{
+	tsd_t *tsd;
+	void *p;
+	size_t usize;
 
-	usize = (alignment == 0) ? s2u(size) : sa2u(size, alignment);
-	assert(usize != 0);
+	assert(size != 0);
 
-	if (config_prof && opt_prof) {
-		prof_thr_cnt_t *cnt;
+	if (unlikely(malloc_init()))
+		goto label_oom;
+	tsd = tsd_fetch();
 
-		PROF_ALLOC_PREP(1, usize, cnt);
-		p = imallocx_prof(usize, alignment, zero, try_tcache, arena,
-		    cnt);
-	} else
-		p = imallocx(usize, alignment, zero, try_tcache, arena);
-	if (p == NULL)
+	if (config_prof && opt_prof)
+		p = imallocx_prof(tsd, size, flags, &usize);
+	else
+		p = imallocx_no_prof(tsd, size, flags, &usize);
+	if (unlikely(p == NULL))
 		goto label_oom;
 
 	if (config_stats) {
 		assert(usize == isalloc(p, config_prof));
-		thread_allocated_tsd_get()->allocated += usize;
+		*tsd_thread_allocatedp_get(tsd) += usize;
 	}
 	UTRACE(0, size, p);
-	JEMALLOC_VALGRIND_MALLOC(true, p, usize, zero);
+	JEMALLOC_VALGRIND_MALLOC(true, p, usize, MALLOCX_ZERO_GET(flags));
 	return (p);
 label_oom:
-	if (config_xmalloc && opt_xmalloc) {
+	if (config_xmalloc && unlikely(opt_xmalloc)) {
 		malloc_write("<jemalloc>: Error in mallocx(): out of memory\n");
 		abort();
 	}
 	UTRACE(0, size, 0);
 	return (NULL);
 }
 
 static void *
-irallocx_prof_sample(void *oldptr, size_t size, size_t alignment, size_t usize,
-    bool zero, bool try_tcache_alloc, bool try_tcache_dalloc, arena_t *arena,
-    prof_thr_cnt_t *cnt)
+irallocx_prof_sample(tsd_t *tsd, void *old_ptr, size_t old_usize,
+    size_t usize, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena,
+    prof_tctx_t *tctx)
 {
 	void *p;
 
-	if (cnt == NULL)
+	if (tctx == NULL)
 		return (NULL);
-	if (prof_promote && usize <= SMALL_MAXCLASS) {
-		p = iralloct(oldptr, SMALL_MAXCLASS+1, (SMALL_MAXCLASS+1 >=
-		    size) ? 0 : size - (SMALL_MAXCLASS+1), alignment, zero,
-		    try_tcache_alloc, try_tcache_dalloc, arena);
+	if (usize <= SMALL_MAXCLASS) {
+		p = iralloct(tsd, old_ptr, old_usize, LARGE_MINCLASS, alignment,
+		    zero, tcache, arena);
 		if (p == NULL)
 			return (NULL);
 		arena_prof_promoted(p, usize);
 	} else {
-		p = iralloct(oldptr, size, 0, alignment, zero,
-		    try_tcache_alloc, try_tcache_dalloc, arena);
+		p = iralloct(tsd, old_ptr, old_usize, usize, alignment, zero,
+		    tcache, arena);
 	}
 
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE_C void *
-irallocx_prof(void *oldptr, size_t old_usize, size_t size, size_t alignment,
-    size_t *usize, bool zero, bool try_tcache_alloc, bool try_tcache_dalloc,
-    arena_t *arena, prof_thr_cnt_t *cnt)
+irallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,
+    size_t alignment, size_t *usize, bool zero, tcache_t *tcache,
+    arena_t *arena)
 {
 	void *p;
-	prof_ctx_t *old_ctx;
+	bool prof_active;
+	prof_tctx_t *old_tctx, *tctx;
 
-	old_ctx = prof_ctx_get(oldptr);
-	if ((uintptr_t)cnt != (uintptr_t)1U)
-		p = irallocx_prof_sample(oldptr, size, alignment, *usize, zero,
-		    try_tcache_alloc, try_tcache_dalloc, arena, cnt);
-	else {
-		p = iralloct(oldptr, size, 0, alignment, zero,
-		    try_tcache_alloc, try_tcache_dalloc, arena);
+	prof_active = prof_active_get_unlocked();
+	old_tctx = prof_tctx_get(old_ptr);
+	tctx = prof_alloc_prep(tsd, *usize, prof_active, true);
+	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
+		p = irallocx_prof_sample(tsd, old_ptr, old_usize, *usize,
+		    alignment, zero, tcache, arena, tctx);
+	} else {
+		p = iralloct(tsd, old_ptr, old_usize, size, alignment, zero,
+		    tcache, arena);
 	}
-	if (p == NULL)
+	if (unlikely(p == NULL)) {
+		prof_alloc_rollback(tsd, tctx, true);
 		return (NULL);
+	}
 
-	if (p == oldptr && alignment != 0) {
+	if (p == old_ptr && alignment != 0) {
 		/*
 		 * The allocation did not move, so it is possible that the size
 		 * class is smaller than would guarantee the requested
 		 * alignment, and that the alignment constraint was
 		 * serendipitously satisfied.  Additionally, old_usize may not
 		 * be the same as the current usize because of in-place large
 		 * reallocation.  Therefore, query the actual value of usize.
 		 */
 		*usize = isalloc(p, config_prof);
 	}
-	prof_realloc(p, *usize, cnt, old_usize, old_ctx);
+	prof_realloc(tsd, p, *usize, tctx, prof_active, true, old_ptr,
+	    old_usize, old_tctx);
 
 	return (p);
 }
 
-void *
+JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
+void JEMALLOC_NOTHROW *
+JEMALLOC_ALLOC_SIZE(2)
 je_rallocx(void *ptr, size_t size, int flags)
 {
 	void *p;
-	size_t usize, old_usize;
+	tsd_t *tsd;
+	size_t usize;
+	size_t old_usize;
 	UNUSED size_t old_rzsize JEMALLOC_CC_SILENCE_INIT(0);
-	size_t alignment = (ZU(1) << (flags & MALLOCX_LG_ALIGN_MASK)
-	    & (SIZE_T_MAX-1));
+	size_t alignment = MALLOCX_ALIGN_GET(flags);
 	bool zero = flags & MALLOCX_ZERO;
-	unsigned arena_ind = ((unsigned)(flags >> 8)) - 1;
-	bool try_tcache_alloc, try_tcache_dalloc;
 	arena_t *arena;
+	tcache_t *tcache;
 
 	assert(ptr != NULL);
 	assert(size != 0);
-	assert(malloc_initialized || IS_INITIALIZER);
+	assert(malloc_initialized() || IS_INITIALIZER);
 	malloc_thread_init();
+	tsd = tsd_fetch();
 
-	if (arena_ind != UINT_MAX) {
-		arena_chunk_t *chunk;
-		try_tcache_alloc = false;
-		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-		try_tcache_dalloc = (chunk == ptr || chunk->arena !=
-		    arenas[arena_ind]);
-		arena = arenas[arena_ind];
-	} else {
-		try_tcache_alloc = true;
-		try_tcache_dalloc = true;
+	if (unlikely((flags & MALLOCX_ARENA_MASK) != 0)) {
+		unsigned arena_ind = MALLOCX_ARENA_GET(flags);
+		arena = arena_get(tsd, arena_ind, true, true);
+		if (unlikely(arena == NULL))
+			goto label_oom;
+	} else
 		arena = NULL;
-	}
 
-	if ((config_prof && opt_prof) || config_stats ||
-	    (config_valgrind && opt_valgrind))
-		old_usize = isalloc(ptr, config_prof);
-	if (config_valgrind && opt_valgrind)
+	if (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {
+		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE)
+			tcache = NULL;
+		else
+			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
+	} else
+		tcache = tcache_get(tsd, true);
+
+	old_usize = isalloc(ptr, config_prof);
+	if (config_valgrind && unlikely(in_valgrind))
 		old_rzsize = u2rz(old_usize);
 
 	if (config_prof && opt_prof) {
-		prof_thr_cnt_t *cnt;
-
 		usize = (alignment == 0) ? s2u(size) : sa2u(size, alignment);
 		assert(usize != 0);
-		PROF_ALLOC_PREP(1, usize, cnt);
-		p = irallocx_prof(ptr, old_usize, size, alignment, &usize, zero,
-		    try_tcache_alloc, try_tcache_dalloc, arena, cnt);
-		if (p == NULL)
+		p = irallocx_prof(tsd, ptr, old_usize, size, alignment, &usize,
+		    zero, tcache, arena);
+		if (unlikely(p == NULL))
 			goto label_oom;
 	} else {
-		p = iralloct(ptr, size, 0, alignment, zero, try_tcache_alloc,
-		    try_tcache_dalloc, arena);
-		if (p == NULL)
+		p = iralloct(tsd, ptr, old_usize, size, alignment, zero,
+		     tcache, arena);
+		if (unlikely(p == NULL))
 			goto label_oom;
-		if (config_stats || (config_valgrind && opt_valgrind))
+		if (config_stats || (config_valgrind && unlikely(in_valgrind)))
 			usize = isalloc(p, config_prof);
 	}
+	assert(alignment == 0 || ((uintptr_t)p & (alignment - 1)) == ZU(0));
 
 	if (config_stats) {
-		thread_allocated_t *ta;
-		ta = thread_allocated_tsd_get();
-		ta->allocated += usize;
-		ta->deallocated += old_usize;
+		*tsd_thread_allocatedp_get(tsd) += usize;
+		*tsd_thread_deallocatedp_get(tsd) += old_usize;
 	}
 	UTRACE(ptr, size, p);
-	JEMALLOC_VALGRIND_REALLOC(p, usize, ptr, old_usize, old_rzsize, zero);
+	JEMALLOC_VALGRIND_REALLOC(true, p, usize, false, ptr, old_usize,
+	    old_rzsize, false, zero);
 	return (p);
 label_oom:
-	if (config_xmalloc && opt_xmalloc) {
+	if (config_xmalloc && unlikely(opt_xmalloc)) {
 		malloc_write("<jemalloc>: Error in rallocx(): out of memory\n");
 		abort();
 	}
 	UTRACE(ptr, size, 0);
 	return (NULL);
 }
 
 JEMALLOC_ALWAYS_INLINE_C size_t
 ixallocx_helper(void *ptr, size_t old_usize, size_t size, size_t extra,
-    size_t alignment, bool zero, arena_t *arena)
+    size_t alignment, bool zero)
 {
 	size_t usize;
 
-	if (ixalloc(ptr, size, extra, alignment, zero))
+	if (ixalloc(ptr, old_usize, size, extra, alignment, zero))
 		return (old_usize);
 	usize = isalloc(ptr, config_prof);
 
 	return (usize);
 }
 
 static size_t
 ixallocx_prof_sample(void *ptr, size_t old_usize, size_t size, size_t extra,
-    size_t alignment, size_t max_usize, bool zero, arena_t *arena,
-    prof_thr_cnt_t *cnt)
+    size_t alignment, bool zero, prof_tctx_t *tctx)
 {
 	size_t usize;
 
-	if (cnt == NULL)
+	if (tctx == NULL)
 		return (old_usize);
-	/* Use minimum usize to determine whether promotion may happen. */
-	if (prof_promote && ((alignment == 0) ? s2u(size) : sa2u(size,
-	    alignment)) <= SMALL_MAXCLASS) {
-		if (ixalloc(ptr, SMALL_MAXCLASS+1, (SMALL_MAXCLASS+1 >=
-		    size+extra) ? 0 : size+extra - (SMALL_MAXCLASS+1),
-		    alignment, zero))
-			return (old_usize);
-		usize = isalloc(ptr, config_prof);
-		if (max_usize < PAGE)
-			arena_prof_promoted(ptr, usize);
-	} else {
-		usize = ixallocx_helper(ptr, old_usize, size, extra, alignment,
-		    zero, arena);
-	}
+	usize = ixallocx_helper(ptr, old_usize, size, extra, alignment, zero);
 
 	return (usize);
 }
 
 JEMALLOC_ALWAYS_INLINE_C size_t
-ixallocx_prof(void *ptr, size_t old_usize, size_t size, size_t extra,
-    size_t alignment, size_t max_usize, bool zero, arena_t *arena,
-    prof_thr_cnt_t *cnt)
+ixallocx_prof(tsd_t *tsd, void *ptr, size_t old_usize, size_t size,
+    size_t extra, size_t alignment, bool zero)
 {
-	size_t usize;
-	prof_ctx_t *old_ctx;
+	size_t usize_max, usize;
+	bool prof_active;
+	prof_tctx_t *old_tctx, *tctx;
 
-	old_ctx = prof_ctx_get(ptr);
-	if ((uintptr_t)cnt != (uintptr_t)1U) {
+	prof_active = prof_active_get_unlocked();
+	old_tctx = prof_tctx_get(ptr);
+	/*
+	 * usize isn't knowable before ixalloc() returns when extra is non-zero.
+	 * Therefore, compute its maximum possible value and use that in
+	 * prof_alloc_prep() to decide whether to capture a backtrace.
+	 * prof_realloc() will use the actual usize to decide whether to sample.
+	 */
+	usize_max = (alignment == 0) ? s2u(size+extra) : sa2u(size+extra,
+	    alignment);
+	assert(usize_max != 0);
+	tctx = prof_alloc_prep(tsd, usize_max, prof_active, false);
+	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
 		usize = ixallocx_prof_sample(ptr, old_usize, size, extra,
-		    alignment, zero, max_usize, arena, cnt);
+		    alignment, zero, tctx);
 	} else {
 		usize = ixallocx_helper(ptr, old_usize, size, extra, alignment,
-		    zero, arena);
+		    zero);
 	}
-	if (usize == old_usize)
+	if (usize == old_usize) {
+		prof_alloc_rollback(tsd, tctx, false);
 		return (usize);
-	prof_realloc(ptr, usize, cnt, old_usize, old_ctx);
+	}
+	prof_realloc(tsd, ptr, usize, tctx, prof_active, false, ptr, old_usize,
+	    old_tctx);
 
 	return (usize);
 }
 
-size_t
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
 je_xallocx(void *ptr, size_t size, size_t extra, int flags)
 {
+	tsd_t *tsd;
 	size_t usize, old_usize;
 	UNUSED size_t old_rzsize JEMALLOC_CC_SILENCE_INIT(0);
-	size_t alignment = (ZU(1) << (flags & MALLOCX_LG_ALIGN_MASK)
-	    & (SIZE_T_MAX-1));
+	size_t alignment = MALLOCX_ALIGN_GET(flags);
 	bool zero = flags & MALLOCX_ZERO;
-	unsigned arena_ind = ((unsigned)(flags >> 8)) - 1;
-	arena_t *arena;
 
 	assert(ptr != NULL);
 	assert(size != 0);
 	assert(SIZE_T_MAX - size >= extra);
-	assert(malloc_initialized || IS_INITIALIZER);
+	assert(malloc_initialized() || IS_INITIALIZER);
 	malloc_thread_init();
-
-	if (arena_ind != UINT_MAX)
-		arena = arenas[arena_ind];
-	else
-		arena = NULL;
+	tsd = tsd_fetch();
 
 	old_usize = isalloc(ptr, config_prof);
-	if (config_valgrind && opt_valgrind)
+
+	/* Clamp extra if necessary to avoid (size + extra) overflow. */
+	if (unlikely(size + extra > HUGE_MAXCLASS)) {
+		/* Check for size overflow. */
+		if (unlikely(size > HUGE_MAXCLASS)) {
+			usize = old_usize;
+			goto label_not_resized;
+		}
+		extra = HUGE_MAXCLASS - size;
+	}
+
+	if (config_valgrind && unlikely(in_valgrind))
 		old_rzsize = u2rz(old_usize);
 
 	if (config_prof && opt_prof) {
-		prof_thr_cnt_t *cnt;
-		/*
-		 * usize isn't knowable before ixalloc() returns when extra is
-		 * non-zero.  Therefore, compute its maximum possible value and
-		 * use that in PROF_ALLOC_PREP() to decide whether to capture a
-		 * backtrace.  prof_realloc() will use the actual usize to
-		 * decide whether to sample.
-		 */
-		size_t max_usize = (alignment == 0) ? s2u(size+extra) :
-		    sa2u(size+extra, alignment);
-		PROF_ALLOC_PREP(1, max_usize, cnt);
-		usize = ixallocx_prof(ptr, old_usize, size, extra, alignment,
-		    max_usize, zero, arena, cnt);
+		usize = ixallocx_prof(tsd, ptr, old_usize, size, extra,
+		    alignment, zero);
 	} else {
 		usize = ixallocx_helper(ptr, old_usize, size, extra, alignment,
-		    zero, arena);
+		    zero);
 	}
-	if (usize == old_usize)
+	if (unlikely(usize == old_usize))
 		goto label_not_resized;
 
 	if (config_stats) {
-		thread_allocated_t *ta;
-		ta = thread_allocated_tsd_get();
-		ta->allocated += usize;
-		ta->deallocated += old_usize;
+		*tsd_thread_allocatedp_get(tsd) += usize;
+		*tsd_thread_deallocatedp_get(tsd) += old_usize;
 	}
-	JEMALLOC_VALGRIND_REALLOC(ptr, usize, ptr, old_usize, old_rzsize, zero);
+	JEMALLOC_VALGRIND_REALLOC(false, ptr, usize, false, ptr, old_usize,
+	    old_rzsize, false, zero);
 label_not_resized:
 	UTRACE(ptr, size, ptr);
 	return (usize);
 }
 
-size_t
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
+JEMALLOC_ATTR(pure)
 je_sallocx(const void *ptr, int flags)
 {
 	size_t usize;
 
-	assert(malloc_initialized || IS_INITIALIZER);
+	assert(malloc_initialized() || IS_INITIALIZER);
 	malloc_thread_init();
 
 	if (config_ivsalloc)
 		usize = ivsalloc(ptr, config_prof);
-	else {
-		assert(ptr != NULL);
+	else
 		usize = isalloc(ptr, config_prof);
-	}
 
 	return (usize);
 }
 
-void
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_dallocx(void *ptr, int flags)
 {
-	size_t usize;
-	UNUSED size_t rzsize JEMALLOC_CC_SILENCE_INIT(0);
-	unsigned arena_ind = ((unsigned)(flags >> 8)) - 1;
-	bool try_tcache;
+	tsd_t *tsd;
+	tcache_t *tcache;
 
 	assert(ptr != NULL);
-	assert(malloc_initialized || IS_INITIALIZER);
+	assert(malloc_initialized() || IS_INITIALIZER);
 
-	if (arena_ind != UINT_MAX) {
-		arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-		try_tcache = (chunk == ptr || chunk->arena !=
-		    arenas[arena_ind]);
+	tsd = tsd_fetch();
+	if (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {
+		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE)
+			tcache = NULL;
+		else
+			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
 	} else
-		try_tcache = true;
+		tcache = tcache_get(tsd, false);
 
 	UTRACE(ptr, 0, 0);
-	if (config_stats || config_valgrind)
-		usize = isalloc(ptr, config_prof);
-	if (config_prof && opt_prof) {
-		if (config_stats == false && config_valgrind == false)
-			usize = isalloc(ptr, config_prof);
-		prof_free(ptr, usize);
-	}
-	if (config_stats)
-		thread_allocated_tsd_get()->deallocated += usize;
-	if (config_valgrind && opt_valgrind)
-		rzsize = p2rz(ptr);
-	iqalloct(ptr, try_tcache);
-	JEMALLOC_VALGRIND_FREE(ptr, rzsize);
+	ifree(tsd_fetch(), ptr, tcache);
 }
 
-size_t
-je_nallocx(size_t size, int flags)
+JEMALLOC_ALWAYS_INLINE_C size_t
+inallocx(size_t size, int flags)
+{
+	size_t usize;
+
+	if (likely((flags & MALLOCX_LG_ALIGN_MASK) == 0))
+		usize = s2u(size);
+	else
+		usize = sa2u(size, MALLOCX_ALIGN_GET_SPECIFIED(flags));
+	assert(usize != 0);
+	return (usize);
+}
+
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW
+je_sdallocx(void *ptr, size_t size, int flags)
 {
+	tsd_t *tsd;
+	tcache_t *tcache;
 	size_t usize;
-	size_t alignment = (ZU(1) << (flags & MALLOCX_LG_ALIGN_MASK)
-	    & (SIZE_T_MAX-1));
+
+	assert(ptr != NULL);
+	assert(malloc_initialized() || IS_INITIALIZER);
+	usize = inallocx(size, flags);
+	assert(usize == isalloc(ptr, config_prof));
+
+	tsd = tsd_fetch();
+	if (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {
+		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE)
+			tcache = NULL;
+		else
+			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
+	} else
+		tcache = tcache_get(tsd, false);
+
+	UTRACE(ptr, 0, 0);
+	isfree(tsd, ptr, usize, tcache);
+}
+
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
+JEMALLOC_ATTR(pure)
+je_nallocx(size_t size, int flags)
+{
 
 	assert(size != 0);
 
-	if (malloc_init())
+	if (unlikely(malloc_init()))
 		return (0);
 
-	usize = (alignment == 0) ? s2u(size) : sa2u(size, alignment);
-	assert(usize != 0);
-	return (usize);
+	return (inallocx(size, flags));
 }
 
-int
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
     size_t newlen)
 {
 
-	if (malloc_init())
+	if (unlikely(malloc_init()))
 		return (EAGAIN);
 
 	return (ctl_byname(name, oldp, oldlenp, newp, newlen));
 }
 
-int
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp)
 {
 
-	if (malloc_init())
+	if (unlikely(malloc_init()))
 		return (EAGAIN);
 
 	return (ctl_nametomib(name, mibp, miblenp));
 }
 
-int
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
   void *newp, size_t newlen)
 {
 
-	if (malloc_init())
+	if (unlikely(malloc_init()))
 		return (EAGAIN);
 
 	return (ctl_bymib(mib, miblen, oldp, oldlenp, newp, newlen));
 }
 
-void
+JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *opts)
 {
 
 	stats_print(write_cb, cbopaque, opts);
 }
 
-size_t
+JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
 je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr)
 {
 	size_t ret;
 
-	assert(malloc_initialized || IS_INITIALIZER);
+	assert(malloc_initialized() || IS_INITIALIZER);
 	malloc_thread_init();
 
 	if (config_ivsalloc)
 		ret = ivsalloc(ptr, config_prof);
 	else
-		ret = (ptr != NULL) ? isalloc(ptr, config_prof) : 0;
+		ret = (ptr == NULL) ? 0 : isalloc(ptr, config_prof);
 
 	return (ret);
 }
 
 /*
  * End non-standard functions.
  */
 /******************************************************************************/
 /*
- * Begin experimental functions.
- */
-#ifdef JEMALLOC_EXPERIMENTAL
-
-int
-je_allocm(void **ptr, size_t *rsize, size_t size, int flags)
-{
-	void *p;
-
-	assert(ptr != NULL);
-
-	p = je_mallocx(size, flags);
-	if (p == NULL)
-		return (ALLOCM_ERR_OOM);
-	if (rsize != NULL)
-		*rsize = isalloc(p, config_prof);
-	*ptr = p;
-	return (ALLOCM_SUCCESS);
-}
-
-int
-je_rallocm(void **ptr, size_t *rsize, size_t size, size_t extra, int flags)
-{
-	int ret;
-	bool no_move = flags & ALLOCM_NO_MOVE;
-
-	assert(ptr != NULL);
-	assert(*ptr != NULL);
-	assert(size != 0);
-	assert(SIZE_T_MAX - size >= extra);
-
-	if (no_move) {
-		size_t usize = je_xallocx(*ptr, size, extra, flags);
-		ret = (usize >= size) ? ALLOCM_SUCCESS : ALLOCM_ERR_NOT_MOVED;
-		if (rsize != NULL)
-			*rsize = usize;
-	} else {
-		void *p = je_rallocx(*ptr, size+extra, flags);
-		if (p != NULL) {
-			*ptr = p;
-			ret = ALLOCM_SUCCESS;
-		} else
-			ret = ALLOCM_ERR_OOM;
-		if (rsize != NULL)
-			*rsize = isalloc(*ptr, config_prof);
-	}
-	return (ret);
-}
-
-int
-je_sallocm(const void *ptr, size_t *rsize, int flags)
-{
-
-	assert(rsize != NULL);
-	*rsize = je_sallocx(ptr, flags);
-	return (ALLOCM_SUCCESS);
-}
-
-int
-je_dallocm(void *ptr, int flags)
-{
-
-	je_dallocx(ptr, flags);
-	return (ALLOCM_SUCCESS);
-}
-
-int
-je_nallocm(size_t *rsize, size_t size, int flags)
-{
-	size_t usize;
-
-	usize = je_nallocx(size, flags);
-	if (usize == 0)
-		return (ALLOCM_ERR_OOM);
-	if (rsize != NULL)
-		*rsize = usize;
-	return (ALLOCM_SUCCESS);
-}
-
-#endif
-/*
- * End experimental functions.
- */
-/******************************************************************************/
-/*
  * The following functions are used by threading libraries for protection of
  * malloc during fork().
  */
 
 /*
  * If an application creates a thread before doing any allocation in the main
@@ -1963,15 +2500,15 @@
  * in the child process, a race can occur that results in deadlock within the
  * child: the main thread may have forked while the created thread had
  * partially initialized the allocator.  Ordinarily jemalloc prevents
  * fork/malloc races via the following functions it registers during
  * initialization using pthread_atfork(), but of course that does no good if
  * the allocator isn't fully initialized at fork time.  The following library
- * constructor is a partial solution to this problem.  It may still possible to
- * trigger the deadlock described above, but doing so would involve forking via
- * a library constructor that runs before jemalloc's runs.
+ * constructor is a partial solution to this problem.  It may still be possible
+ * to trigger the deadlock described above, but doing so would involve forking
+ * via a library constructor that runs before jemalloc's runs.
  */
 JEMALLOC_ATTR(constructor)
 static void
 jemalloc_constructor(void)
 {
 
@@ -1986,28 +2523,27 @@
 _malloc_prefork(void)
 #endif
 {
 	unsigned i;
 
 #ifdef JEMALLOC_MUTEX_INIT_CB
-	if (malloc_initialized == false)
+	if (!malloc_initialized())
 		return;
 #endif
-	assert(malloc_initialized);
+	assert(malloc_initialized());
 
 	/* Acquire all mutexes in a safe order. */
 	ctl_prefork();
 	prof_prefork();
 	malloc_mutex_prefork(&arenas_lock);
 	for (i = 0; i < narenas_total; i++) {
 		if (arenas[i] != NULL)
 			arena_prefork(arenas[i]);
 	}
 	chunk_prefork();
 	base_prefork();
-	huge_prefork();
 }
 
 #ifndef JEMALLOC_MUTEX_INIT_CB
 void
 jemalloc_postfork_parent(void)
 #else
@@ -2015,19 +2551,18 @@
 _malloc_postfork(void)
 #endif
 {
 	unsigned i;
 
 #ifdef JEMALLOC_MUTEX_INIT_CB
-	if (malloc_initialized == false)
+	if (!malloc_initialized())
 		return;
 #endif
-	assert(malloc_initialized);
+	assert(malloc_initialized());
 
 	/* Release all mutexes, now that fork() has completed. */
-	huge_postfork_parent();
 	base_postfork_parent();
 	chunk_postfork_parent();
 	for (i = 0; i < narenas_total; i++) {
 		if (arenas[i] != NULL)
 			arena_postfork_parent(arenas[i]);
 	}
@@ -2038,74 +2573,21 @@
 
 void
 jemalloc_postfork_child(void)
 {
 	unsigned i;
 
-	assert(malloc_initialized);
+	assert(malloc_initialized());
 
 	/* Release all mutexes, now that fork() has completed. */
-	huge_postfork_child();
 	base_postfork_child();
 	chunk_postfork_child();
 	for (i = 0; i < narenas_total; i++) {
 		if (arenas[i] != NULL)
 			arena_postfork_child(arenas[i]);
 	}
 	malloc_mutex_postfork_child(&arenas_lock);
 	prof_postfork_child();
 	ctl_postfork_child();
 }
 
 /******************************************************************************/
-/*
- * The following functions are used for TLS allocation/deallocation in static
- * binaries on FreeBSD.  The primary difference between these and i[mcd]alloc()
- * is that these avoid accessing TLS variables.
- */
-
-static void *
-a0alloc(size_t size, bool zero)
-{
-
-	if (malloc_init())
-		return (NULL);
-
-	if (size == 0)
-		size = 1;
-
-	if (size <= arena_maxclass)
-		return (arena_malloc(arenas[0], size, zero, false));
-	else
-		return (huge_malloc(size, zero, huge_dss_prec_get(arenas[0])));
-}
-
-void *
-a0malloc(size_t size)
-{
-
-	return (a0alloc(size, false));
-}
-
-void *
-a0calloc(size_t num, size_t size)
-{
-
-	return (a0alloc(num * size, true));
-}
-
-void
-a0free(void *ptr)
-{
-	arena_chunk_t *chunk;
-
-	if (ptr == NULL)
-		return;
-
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-	if (chunk != ptr)
-		arena_dalloc(chunk->arena, chunk, ptr, false);
-	else
-		huge_dalloc(ptr, true);
-}
-
-/******************************************************************************/
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.d	2017-09-27 22:47:54.518963427 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.d	2017-09-27 22:49:16.450960424 +0800
@@ -1,21 +1,22 @@
 src/jemalloc.o: src/jemalloc.c \
  include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.d	2017-09-27 22:47:58.206963291 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.d	2017-09-27 22:49:21.546960237 +0800
@@ -1,20 +1,21 @@
 src/mb.o: src/mb.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.c	2016-05-06 15:11:36.000000000 +0800
@@ -70,24 +70,28 @@
 
 bool
 malloc_mutex_init(malloc_mutex_t *mutex)
 {
 
 #ifdef _WIN32
+#  if _WIN32_WINNT >= 0x0600
+	InitializeSRWLock(&mutex->lock);
+#  else
 	if (!InitializeCriticalSectionAndSpinCount(&mutex->lock,
 	    _CRT_SPINCOUNT))
 		return (true);
+#  endif
 #elif (defined(JEMALLOC_OSSPIN))
 	mutex->lock = 0;
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 	if (postpone_init) {
 		mutex->postponed_next = postponed_mutexes;
 		postponed_mutexes = mutex;
 	} else {
-		if (_pthread_mutex_init_calloc_cb(&mutex->lock, base_calloc) !=
-		    0)
+		if (_pthread_mutex_init_calloc_cb(&mutex->lock,
+		    bootstrap_calloc) != 0)
 			return (true);
 	}
 #else
 	pthread_mutexattr_t attr;
 
 	if (pthread_mutexattr_init(&attr) != 0)
@@ -137,13 +141,13 @@
 {
 
 #ifdef JEMALLOC_MUTEX_INIT_CB
 	postpone_init = false;
 	while (postponed_mutexes != NULL) {
 		if (_pthread_mutex_init_calloc_cb(&postponed_mutexes->lock,
-		    base_calloc) != 0)
+		    bootstrap_calloc) != 0)
 			return (true);
 		postponed_mutexes = postponed_mutexes->postponed_next;
 	}
 #endif
 	return (false);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.d	2017-09-27 22:47:58.302963288 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.d	2017-09-27 22:49:21.650960233 +0800
@@ -1,20 +1,21 @@
 src/mutex.o: src/mutex.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src: pages.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src: pages.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src: pages.d
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src: pages.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.c	2016-05-06 15:11:36.000000000 +0800
@@ -11,48 +11,87 @@
 #include <unwind.h>
 #endif
 
 /******************************************************************************/
 /* Data. */
 
-malloc_tsd_data(, prof_tdata, prof_tdata_t *, NULL)
-
 bool		opt_prof = false;
 bool		opt_prof_active = true;
+bool		opt_prof_thread_active_init = true;
 size_t		opt_lg_prof_sample = LG_PROF_SAMPLE_DEFAULT;
 ssize_t		opt_lg_prof_interval = LG_PROF_INTERVAL_DEFAULT;
 bool		opt_prof_gdump = false;
-bool		opt_prof_final = true;
+bool		opt_prof_final = false;
 bool		opt_prof_leak = false;
 bool		opt_prof_accum = false;
 char		opt_prof_prefix[
     /* Minimize memory bloat for non-prof builds. */
 #ifdef JEMALLOC_PROF
     PATH_MAX +
 #endif
     1];
 
+/*
+ * Initialized as opt_prof_active, and accessed via
+ * prof_active_[gs]et{_unlocked,}().
+ */
+bool			prof_active;
+static malloc_mutex_t	prof_active_mtx;
+
+/*
+ * Initialized as opt_prof_thread_active_init, and accessed via
+ * prof_thread_active_init_[gs]et().
+ */
+static bool		prof_thread_active_init;
+static malloc_mutex_t	prof_thread_active_init_mtx;
+
+/*
+ * Initialized as opt_prof_gdump, and accessed via
+ * prof_gdump_[gs]et{_unlocked,}().
+ */
+bool			prof_gdump_val;
+static malloc_mutex_t	prof_gdump_mtx;
+
 uint64_t	prof_interval = 0;
-bool		prof_promote;
+
+size_t		lg_prof_sample;
 
 /*
- * Table of mutexes that are shared among ctx's.  These are leaf locks, so
- * there is no problem with using them for more than one ctx at the same time.
- * The primary motivation for this sharing though is that ctx's are ephemeral,
+ * Table of mutexes that are shared among gctx's.  These are leaf locks, so
+ * there is no problem with using them for more than one gctx at the same time.
+ * The primary motivation for this sharing though is that gctx's are ephemeral,
  * and destroying mutexes causes complications for systems that allocate when
  * creating/destroying mutexes.
  */
-static malloc_mutex_t	*ctx_locks;
-static unsigned		cum_ctxs; /* Atomic counter. */
+static malloc_mutex_t	*gctx_locks;
+static unsigned		cum_gctxs; /* Atomic counter. */
+
+/*
+ * Table of mutexes that are shared among tdata's.  No operations require
+ * holding multiple tdata locks, so there is no problem with using them for more
+ * than one tdata at the same time, even though a gctx lock may be acquired
+ * while holding a tdata lock.
+ */
+static malloc_mutex_t	*tdata_locks;
 
 /*
- * Global hash of (prof_bt_t *)-->(prof_ctx_t *).  This is the master data
+ * Global hash of (prof_bt_t *)-->(prof_gctx_t *).  This is the master data
  * structure that knows about all backtraces currently captured.
  */
-static ckh_t		bt2ctx;
-static malloc_mutex_t	bt2ctx_mtx;
+static ckh_t		bt2gctx;
+static malloc_mutex_t	bt2gctx_mtx;
+
+/*
+ * Tree of all extant prof_tdata_t structures, regardless of state,
+ * {attached,detached,expired}.
+ */
+static prof_tdata_tree_t	tdatas;
+static malloc_mutex_t	tdatas_mtx;
+
+static uint64_t		next_thr_uid;
+static malloc_mutex_t	next_thr_uid_mtx;
 
 static malloc_mutex_t	prof_dump_seq_mtx;
 static uint64_t		prof_dump_seq;
 static uint64_t		prof_dump_iseq;
 static uint64_t		prof_dump_mseq;
 static uint64_t		prof_dump_useq;
@@ -74,126 +113,216 @@
 static int		prof_dump_fd;
 
 /* Do not dump any profiles until bootstrapping is complete. */
 static bool		prof_booted = false;
 
 /******************************************************************************/
+/*
+ * Function prototypes for static functions that are referenced prior to
+ * definition.
+ */
+
+static bool	prof_tctx_should_destroy(prof_tctx_t *tctx);
+static void	prof_tctx_destroy(tsd_t *tsd, prof_tctx_t *tctx);
+static bool	prof_tdata_should_destroy(prof_tdata_t *tdata,
+    bool even_if_attached);
+static void	prof_tdata_destroy(tsd_t *tsd, prof_tdata_t *tdata,
+    bool even_if_attached);
+static char	*prof_thread_name_alloc(tsd_t *tsd, const char *thread_name);
+
+/******************************************************************************/
+/* Red-black trees. */
+
+JEMALLOC_INLINE_C int
+prof_tctx_comp(const prof_tctx_t *a, const prof_tctx_t *b)
+{
+	uint64_t a_thr_uid = a->thr_uid;
+	uint64_t b_thr_uid = b->thr_uid;
+	int ret = (a_thr_uid > b_thr_uid) - (a_thr_uid < b_thr_uid);
+	if (ret == 0) {
+		uint64_t a_thr_discrim = a->thr_discrim;
+		uint64_t b_thr_discrim = b->thr_discrim;
+		ret = (a_thr_discrim > b_thr_discrim) - (a_thr_discrim <
+		    b_thr_discrim);
+		if (ret == 0) {
+			uint64_t a_tctx_uid = a->tctx_uid;
+			uint64_t b_tctx_uid = b->tctx_uid;
+			ret = (a_tctx_uid > b_tctx_uid) - (a_tctx_uid <
+			    b_tctx_uid);
+		}
+	}
+	return (ret);
+}
+
+rb_gen(static UNUSED, tctx_tree_, prof_tctx_tree_t, prof_tctx_t,
+    tctx_link, prof_tctx_comp)
+
+JEMALLOC_INLINE_C int
+prof_gctx_comp(const prof_gctx_t *a, const prof_gctx_t *b)
+{
+	unsigned a_len = a->bt.len;
+	unsigned b_len = b->bt.len;
+	unsigned comp_len = (a_len < b_len) ? a_len : b_len;
+	int ret = memcmp(a->bt.vec, b->bt.vec, comp_len * sizeof(void *));
+	if (ret == 0)
+		ret = (a_len > b_len) - (a_len < b_len);
+	return (ret);
+}
+
+rb_gen(static UNUSED, gctx_tree_, prof_gctx_tree_t, prof_gctx_t, dump_link,
+    prof_gctx_comp)
+
+JEMALLOC_INLINE_C int
+prof_tdata_comp(const prof_tdata_t *a, const prof_tdata_t *b)
+{
+	int ret;
+	uint64_t a_uid = a->thr_uid;
+	uint64_t b_uid = b->thr_uid;
+
+	ret = ((a_uid > b_uid) - (a_uid < b_uid));
+	if (ret == 0) {
+		uint64_t a_discrim = a->thr_discrim;
+		uint64_t b_discrim = b->thr_discrim;
+
+		ret = ((a_discrim > b_discrim) - (a_discrim < b_discrim));
+	}
+	return (ret);
+}
+
+rb_gen(static UNUSED, tdata_tree_, prof_tdata_tree_t, prof_tdata_t, tdata_link,
+    prof_tdata_comp)
+
+/******************************************************************************/
 
 void
-bt_init(prof_bt_t *bt, void **vec)
+prof_alloc_rollback(tsd_t *tsd, prof_tctx_t *tctx, bool updated)
 {
+	prof_tdata_t *tdata;
 
 	cassert(config_prof);
 
-	bt->vec = vec;
-	bt->len = 0;
+	if (updated) {
+		/*
+		 * Compute a new sample threshold.  This isn't very important in
+		 * practice, because this function is rarely executed, so the
+		 * potential for sample bias is minimal except in contrived
+		 * programs.
+		 */
+		tdata = prof_tdata_get(tsd, true);
+		if (tdata != NULL)
+			prof_sample_threshold_update(tdata);
+	}
+
+	if ((uintptr_t)tctx > (uintptr_t)1U) {
+		malloc_mutex_lock(tctx->tdata->lock);
+		tctx->prepared = false;
+		if (prof_tctx_should_destroy(tctx))
+			prof_tctx_destroy(tsd, tctx);
+		else
+			malloc_mutex_unlock(tctx->tdata->lock);
+	}
 }
 
-static void
-bt_destroy(prof_bt_t *bt)
+void
+prof_malloc_sample_object(const void *ptr, size_t usize, prof_tctx_t *tctx)
 {
 
-	cassert(config_prof);
+	prof_tctx_set(ptr, usize, tctx);
 
-	idalloc(bt);
+	malloc_mutex_lock(tctx->tdata->lock);
+	tctx->cnts.curobjs++;
+	tctx->cnts.curbytes += usize;
+	if (opt_prof_accum) {
+		tctx->cnts.accumobjs++;
+		tctx->cnts.accumbytes += usize;
+	}
+	tctx->prepared = false;
+	malloc_mutex_unlock(tctx->tdata->lock);
 }
 
-static prof_bt_t *
-bt_dup(prof_bt_t *bt)
+void
+prof_free_sampled_object(tsd_t *tsd, size_t usize, prof_tctx_t *tctx)
 {
-	prof_bt_t *ret;
 
-	cassert(config_prof);
+	malloc_mutex_lock(tctx->tdata->lock);
+	assert(tctx->cnts.curobjs > 0);
+	assert(tctx->cnts.curbytes >= usize);
+	tctx->cnts.curobjs--;
+	tctx->cnts.curbytes -= usize;
+
+	if (prof_tctx_should_destroy(tctx))
+		prof_tctx_destroy(tsd, tctx);
+	else
+		malloc_mutex_unlock(tctx->tdata->lock);
+}
 
-	/*
-	 * Create a single allocation that has space for vec immediately
-	 * following the prof_bt_t structure.  The backtraces that get
-	 * stored in the backtrace caches are copied from stack-allocated
-	 * temporary variables, so size is known at creation time.  Making this
-	 * a contiguous object improves cache locality.
-	 */
-	ret = (prof_bt_t *)imalloc(QUANTUM_CEILING(sizeof(prof_bt_t)) +
-	    (bt->len * sizeof(void *)));
-	if (ret == NULL)
-		return (NULL);
-	ret->vec = (void **)((uintptr_t)ret +
-	    QUANTUM_CEILING(sizeof(prof_bt_t)));
-	memcpy(ret->vec, bt->vec, bt->len * sizeof(void *));
-	ret->len = bt->len;
+void
+bt_init(prof_bt_t *bt, void **vec)
+{
 
-	return (ret);
+	cassert(config_prof);
+
+	bt->vec = vec;
+	bt->len = 0;
 }
 
-static inline void
-prof_enter(prof_tdata_t *prof_tdata)
+JEMALLOC_INLINE_C void
+prof_enter(tsd_t *tsd, prof_tdata_t *tdata)
 {
 
 	cassert(config_prof);
+	assert(tdata == prof_tdata_get(tsd, false));
 
-	assert(prof_tdata->enq == false);
-	prof_tdata->enq = true;
+	if (tdata != NULL) {
+		assert(!tdata->enq);
+		tdata->enq = true;
+	}
 
-	malloc_mutex_lock(&bt2ctx_mtx);
+	malloc_mutex_lock(&bt2gctx_mtx);
 }
 
-static inline void
-prof_leave(prof_tdata_t *prof_tdata)
+JEMALLOC_INLINE_C void
+prof_leave(tsd_t *tsd, prof_tdata_t *tdata)
 {
-	bool idump, gdump;
 
 	cassert(config_prof);
+	assert(tdata == prof_tdata_get(tsd, false));
 
-	malloc_mutex_unlock(&bt2ctx_mtx);
+	malloc_mutex_unlock(&bt2gctx_mtx);
 
-	assert(prof_tdata->enq);
-	prof_tdata->enq = false;
-	idump = prof_tdata->enq_idump;
-	prof_tdata->enq_idump = false;
-	gdump = prof_tdata->enq_gdump;
-	prof_tdata->enq_gdump = false;
+	if (tdata != NULL) {
+		bool idump, gdump;
 
-	if (idump)
-		prof_idump();
-	if (gdump)
-		prof_gdump();
+		assert(tdata->enq);
+		tdata->enq = false;
+		idump = tdata->enq_idump;
+		tdata->enq_idump = false;
+		gdump = tdata->enq_gdump;
+		tdata->enq_gdump = false;
+
+		if (idump)
+			prof_idump();
+		if (gdump)
+			prof_gdump();
+	}
 }
 
 #ifdef JEMALLOC_PROF_LIBUNWIND
 void
-prof_backtrace(prof_bt_t *bt, unsigned nignore)
+prof_backtrace(prof_bt_t *bt)
 {
-	unw_context_t uc;
-	unw_cursor_t cursor;
-	unsigned i;
-	int err;
+	int nframes;
 
 	cassert(config_prof);
 	assert(bt->len == 0);
 	assert(bt->vec != NULL);
 
-	unw_getcontext(&uc);
-	unw_init_local(&cursor, &uc);
-
-	/* Throw away (nignore+1) stack frames, if that many exist. */
-	for (i = 0; i < nignore + 1; i++) {
-		err = unw_step(&cursor);
-		if (err <= 0)
-			return;
-	}
-
-	/*
-	 * Iterate over stack frames until there are no more, or until no space
-	 * remains in bt.
-	 */
-	for (i = 0; i < PROF_BT_MAX; i++) {
-		unw_get_reg(&cursor, UNW_REG_IP, (unw_word_t *)&bt->vec[i]);
-		bt->len++;
-		err = unw_step(&cursor);
-		if (err <= 0)
-			break;
-	}
+	nframes = unw_backtrace(bt->vec, PROF_BT_MAX);
+	if (nframes <= 0)
+		return;
+	bt->len = nframes;
 }
 #elif (defined(JEMALLOC_PROF_LIBGCC))
 static _Unwind_Reason_Code
 prof_unwind_init_callback(struct _Unwind_Context *context, void *arg)
 {
 
@@ -203,57 +332,54 @@
 }
 
 static _Unwind_Reason_Code
 prof_unwind_callback(struct _Unwind_Context *context, void *arg)
 {
 	prof_unwind_data_t *data = (prof_unwind_data_t *)arg;
+	void *ip;
 
 	cassert(config_prof);
 
-	if (data->nignore > 0)
-		data->nignore--;
-	else {
-		data->bt->vec[data->bt->len] = (void *)_Unwind_GetIP(context);
-		data->bt->len++;
-		if (data->bt->len == data->max)
-			return (_URC_END_OF_STACK);
-	}
+	ip = (void *)_Unwind_GetIP(context);
+	if (ip == NULL)
+		return (_URC_END_OF_STACK);
+	data->bt->vec[data->bt->len] = ip;
+	data->bt->len++;
+	if (data->bt->len == data->max)
+		return (_URC_END_OF_STACK);
 
 	return (_URC_NO_REASON);
 }
 
 void
-prof_backtrace(prof_bt_t *bt, unsigned nignore)
+prof_backtrace(prof_bt_t *bt)
 {
-	prof_unwind_data_t data = {bt, nignore, PROF_BT_MAX};
+	prof_unwind_data_t data = {bt, PROF_BT_MAX};
 
 	cassert(config_prof);
 
 	_Unwind_Backtrace(prof_unwind_callback, &data);
 }
 #elif (defined(JEMALLOC_PROF_GCC))
 void
-prof_backtrace(prof_bt_t *bt, unsigned nignore)
+prof_backtrace(prof_bt_t *bt)
 {
 #define	BT_FRAME(i)							\
-	if ((i) < nignore + PROF_BT_MAX) {				\
+	if ((i) < PROF_BT_MAX) {					\
 		void *p;						\
 		if (__builtin_frame_address(i) == 0)			\
 			return;						\
 		p = __builtin_return_address(i);			\
 		if (p == NULL)						\
 			return;						\
-		if (i >= nignore) {					\
-			bt->vec[(i) - nignore] = p;			\
-			bt->len = (i) - nignore + 1;			\
-		}							\
+		bt->vec[(i)] = p;					\
+		bt->len = (i) + 1;					\
 	} else								\
 		return;
 
 	cassert(config_prof);
-	assert(nignore <= 3);
 
 	BT_FRAME(0)
 	BT_FRAME(1)
 	BT_FRAME(2)
 	BT_FRAME(3)
 	BT_FRAME(4)
@@ -389,280 +515,413 @@
 	BT_FRAME(122)
 	BT_FRAME(123)
 	BT_FRAME(124)
 	BT_FRAME(125)
 	BT_FRAME(126)
 	BT_FRAME(127)
-
-	/* Extras to compensate for nignore. */
-	BT_FRAME(128)
-	BT_FRAME(129)
-	BT_FRAME(130)
 #undef BT_FRAME
 }
 #else
 void
-prof_backtrace(prof_bt_t *bt, unsigned nignore)
+prof_backtrace(prof_bt_t *bt)
 {
 
 	cassert(config_prof);
 	not_reached();
 }
 #endif
 
 static malloc_mutex_t *
-prof_ctx_mutex_choose(void)
+prof_gctx_mutex_choose(void)
 {
-	unsigned nctxs = atomic_add_u(&cum_ctxs, 1);
+	unsigned ngctxs = atomic_add_u(&cum_gctxs, 1);
 
-	return (&ctx_locks[(nctxs - 1) % PROF_NCTX_LOCKS]);
+	return (&gctx_locks[(ngctxs - 1) % PROF_NCTX_LOCKS]);
 }
 
-static void
-prof_ctx_init(prof_ctx_t *ctx, prof_bt_t *bt)
+static malloc_mutex_t *
+prof_tdata_mutex_choose(uint64_t thr_uid)
 {
 
-	ctx->bt = bt;
-	ctx->lock = prof_ctx_mutex_choose();
+	return (&tdata_locks[thr_uid % PROF_NTDATA_LOCKS]);
+}
+
+static prof_gctx_t *
+prof_gctx_create(tsd_t *tsd, prof_bt_t *bt)
+{
+	/*
+	 * Create a single allocation that has space for vec of length bt->len.
+	 */
+	prof_gctx_t *gctx = (prof_gctx_t *)iallocztm(tsd, offsetof(prof_gctx_t,
+	    vec) + (bt->len * sizeof(void *)), false, tcache_get(tsd, true),
+	    true, NULL);
+	if (gctx == NULL)
+		return (NULL);
+	gctx->lock = prof_gctx_mutex_choose();
 	/*
 	 * Set nlimbo to 1, in order to avoid a race condition with
-	 * prof_ctx_merge()/prof_ctx_destroy().
+	 * prof_tctx_destroy()/prof_gctx_try_destroy().
 	 */
-	ctx->nlimbo = 1;
-	ql_elm_new(ctx, dump_link);
-	memset(&ctx->cnt_merged, 0, sizeof(prof_cnt_t));
-	ql_new(&ctx->cnts_ql);
+	gctx->nlimbo = 1;
+	tctx_tree_new(&gctx->tctxs);
+	/* Duplicate bt. */
+	memcpy(gctx->vec, bt->vec, bt->len * sizeof(void *));
+	gctx->bt.vec = gctx->vec;
+	gctx->bt.len = bt->len;
+	return (gctx);
 }
 
 static void
-prof_ctx_destroy(prof_ctx_t *ctx)
+prof_gctx_try_destroy(tsd_t *tsd, prof_tdata_t *tdata_self, prof_gctx_t *gctx,
+    prof_tdata_t *tdata)
 {
-	prof_tdata_t *prof_tdata;
 
 	cassert(config_prof);
 
 	/*
-	 * Check that ctx is still unused by any thread cache before destroying
-	 * it.  prof_lookup() increments ctx->nlimbo in order to avoid a race
-	 * condition with this function, as does prof_ctx_merge() in order to
-	 * avoid a race between the main body of prof_ctx_merge() and entry
+	 * Check that gctx is still unused by any thread cache before destroying
+	 * it.  prof_lookup() increments gctx->nlimbo in order to avoid a race
+	 * condition with this function, as does prof_tctx_destroy() in order to
+	 * avoid a race between the main body of prof_tctx_destroy() and entry
 	 * into this function.
 	 */
-	prof_tdata = prof_tdata_get(false);
-	assert((uintptr_t)prof_tdata > (uintptr_t)PROF_TDATA_STATE_MAX);
-	prof_enter(prof_tdata);
-	malloc_mutex_lock(ctx->lock);
-	if (ql_first(&ctx->cnts_ql) == NULL && ctx->cnt_merged.curobjs == 0 &&
-	    ctx->nlimbo == 1) {
-		assert(ctx->cnt_merged.curbytes == 0);
-		assert(ctx->cnt_merged.accumobjs == 0);
-		assert(ctx->cnt_merged.accumbytes == 0);
-		/* Remove ctx from bt2ctx. */
-		if (ckh_remove(&bt2ctx, ctx->bt, NULL, NULL))
+	prof_enter(tsd, tdata_self);
+	malloc_mutex_lock(gctx->lock);
+	assert(gctx->nlimbo != 0);
+	if (tctx_tree_empty(&gctx->tctxs) && gctx->nlimbo == 1) {
+		/* Remove gctx from bt2gctx. */
+		if (ckh_remove(tsd, &bt2gctx, &gctx->bt, NULL, NULL))
 			not_reached();
-		prof_leave(prof_tdata);
-		/* Destroy ctx. */
-		malloc_mutex_unlock(ctx->lock);
-		bt_destroy(ctx->bt);
-		idalloc(ctx);
+		prof_leave(tsd, tdata_self);
+		/* Destroy gctx. */
+		malloc_mutex_unlock(gctx->lock);
+		idalloctm(tsd, gctx, tcache_get(tsd, false), true);
 	} else {
 		/*
-		 * Compensate for increment in prof_ctx_merge() or
+		 * Compensate for increment in prof_tctx_destroy() or
 		 * prof_lookup().
 		 */
-		ctx->nlimbo--;
-		malloc_mutex_unlock(ctx->lock);
-		prof_leave(prof_tdata);
+		gctx->nlimbo--;
+		malloc_mutex_unlock(gctx->lock);
+		prof_leave(tsd, tdata_self);
 	}
 }
 
-static void
-prof_ctx_merge(prof_ctx_t *ctx, prof_thr_cnt_t *cnt)
+/* tctx->tdata->lock must be held. */
+static bool
+prof_tctx_should_destroy(prof_tctx_t *tctx)
 {
-	bool destroy;
 
-	cassert(config_prof);
+	if (opt_prof_accum)
+		return (false);
+	if (tctx->cnts.curobjs != 0)
+		return (false);
+	if (tctx->prepared)
+		return (false);
+	return (true);
+}
 
-	/* Merge cnt stats and detach from ctx. */
-	malloc_mutex_lock(ctx->lock);
-	ctx->cnt_merged.curobjs += cnt->cnts.curobjs;
-	ctx->cnt_merged.curbytes += cnt->cnts.curbytes;
-	ctx->cnt_merged.accumobjs += cnt->cnts.accumobjs;
-	ctx->cnt_merged.accumbytes += cnt->cnts.accumbytes;
-	ql_remove(&ctx->cnts_ql, cnt, cnts_link);
-	if (opt_prof_accum == false && ql_first(&ctx->cnts_ql) == NULL &&
-	    ctx->cnt_merged.curobjs == 0 && ctx->nlimbo == 0) {
+static bool
+prof_gctx_should_destroy(prof_gctx_t *gctx)
+{
+
+	if (opt_prof_accum)
+		return (false);
+	if (!tctx_tree_empty(&gctx->tctxs))
+		return (false);
+	if (gctx->nlimbo != 0)
+		return (false);
+	return (true);
+}
+
+/* tctx->tdata->lock is held upon entry, and released before return. */
+static void
+prof_tctx_destroy(tsd_t *tsd, prof_tctx_t *tctx)
+{
+	prof_tdata_t *tdata = tctx->tdata;
+	prof_gctx_t *gctx = tctx->gctx;
+	bool destroy_tdata, destroy_tctx, destroy_gctx;
+
+	assert(tctx->cnts.curobjs == 0);
+	assert(tctx->cnts.curbytes == 0);
+	assert(!opt_prof_accum);
+	assert(tctx->cnts.accumobjs == 0);
+	assert(tctx->cnts.accumbytes == 0);
+
+	ckh_remove(tsd, &tdata->bt2tctx, &gctx->bt, NULL, NULL);
+	destroy_tdata = prof_tdata_should_destroy(tdata, false);
+	malloc_mutex_unlock(tdata->lock);
+
+	malloc_mutex_lock(gctx->lock);
+	switch (tctx->state) {
+	case prof_tctx_state_nominal:
+		tctx_tree_remove(&gctx->tctxs, tctx);
+		destroy_tctx = true;
+		if (prof_gctx_should_destroy(gctx)) {
+			/*
+			 * Increment gctx->nlimbo in order to keep another
+			 * thread from winning the race to destroy gctx while
+			 * this one has gctx->lock dropped.  Without this, it
+			 * would be possible for another thread to:
+			 *
+			 * 1) Sample an allocation associated with gctx.
+			 * 2) Deallocate the sampled object.
+			 * 3) Successfully prof_gctx_try_destroy(gctx).
+			 *
+			 * The result would be that gctx no longer exists by the
+			 * time this thread accesses it in
+			 * prof_gctx_try_destroy().
+			 */
+			gctx->nlimbo++;
+			destroy_gctx = true;
+		} else
+			destroy_gctx = false;
+		break;
+	case prof_tctx_state_dumping:
 		/*
-		 * Increment ctx->nlimbo in order to keep another thread from
-		 * winning the race to destroy ctx while this one has ctx->lock
-		 * dropped.  Without this, it would be possible for another
-		 * thread to:
-		 *
-		 * 1) Sample an allocation associated with ctx.
-		 * 2) Deallocate the sampled object.
-		 * 3) Successfully prof_ctx_destroy(ctx).
-		 *
-		 * The result would be that ctx no longer exists by the time
-		 * this thread accesses it in prof_ctx_destroy().
+		 * A dumping thread needs tctx to remain valid until dumping
+		 * has finished.  Change state such that the dumping thread will
+		 * complete destruction during a late dump iteration phase.
 		 */
-		ctx->nlimbo++;
-		destroy = true;
-	} else
-		destroy = false;
-	malloc_mutex_unlock(ctx->lock);
-	if (destroy)
-		prof_ctx_destroy(ctx);
+		tctx->state = prof_tctx_state_purgatory;
+		destroy_tctx = false;
+		destroy_gctx = false;
+		break;
+	default:
+		not_reached();
+		destroy_tctx = false;
+		destroy_gctx = false;
+	}
+	malloc_mutex_unlock(gctx->lock);
+	if (destroy_gctx) {
+		prof_gctx_try_destroy(tsd, prof_tdata_get(tsd, false), gctx,
+		    tdata);
+	}
+
+	if (destroy_tdata)
+		prof_tdata_destroy(tsd, tdata, false);
+
+	if (destroy_tctx)
+		idalloctm(tsd, tctx, tcache_get(tsd, false), true);
 }
 
 static bool
-prof_lookup_global(prof_bt_t *bt, prof_tdata_t *prof_tdata, void **p_btkey,
-    prof_ctx_t **p_ctx, bool *p_new_ctx)
+prof_lookup_global(tsd_t *tsd, prof_bt_t *bt, prof_tdata_t *tdata,
+    void **p_btkey, prof_gctx_t **p_gctx, bool *p_new_gctx)
 {
 	union {
-		prof_ctx_t	*p;
+		prof_gctx_t	*p;
 		void		*v;
-	} ctx;
+	} gctx;
 	union {
 		prof_bt_t	*p;
 		void		*v;
 	} btkey;
-	bool new_ctx;
+	bool new_gctx;
 
-	prof_enter(prof_tdata);
-	if (ckh_search(&bt2ctx, bt, &btkey.v, &ctx.v)) {
+	prof_enter(tsd, tdata);
+	if (ckh_search(&bt2gctx, bt, &btkey.v, &gctx.v)) {
 		/* bt has never been seen before.  Insert it. */
-		ctx.v = imalloc(sizeof(prof_ctx_t));
-		if (ctx.v == NULL) {
-			prof_leave(prof_tdata);
-			return (true);
-		}
-		btkey.p = bt_dup(bt);
-		if (btkey.v == NULL) {
-			prof_leave(prof_tdata);
-			idalloc(ctx.v);
+		gctx.p = prof_gctx_create(tsd, bt);
+		if (gctx.v == NULL) {
+			prof_leave(tsd, tdata);
 			return (true);
 		}
-		prof_ctx_init(ctx.p, btkey.p);
-		if (ckh_insert(&bt2ctx, btkey.v, ctx.v)) {
+		btkey.p = &gctx.p->bt;
+		if (ckh_insert(tsd, &bt2gctx, btkey.v, gctx.v)) {
 			/* OOM. */
-			prof_leave(prof_tdata);
-			idalloc(btkey.v);
-			idalloc(ctx.v);
+			prof_leave(tsd, tdata);
+			idalloctm(tsd, gctx.v, tcache_get(tsd, false), true);
 			return (true);
 		}
-		new_ctx = true;
+		new_gctx = true;
 	} else {
 		/*
 		 * Increment nlimbo, in order to avoid a race condition with
-		 * prof_ctx_merge()/prof_ctx_destroy().
+		 * prof_tctx_destroy()/prof_gctx_try_destroy().
 		 */
-		malloc_mutex_lock(ctx.p->lock);
-		ctx.p->nlimbo++;
-		malloc_mutex_unlock(ctx.p->lock);
-		new_ctx = false;
+		malloc_mutex_lock(gctx.p->lock);
+		gctx.p->nlimbo++;
+		malloc_mutex_unlock(gctx.p->lock);
+		new_gctx = false;
 	}
-	prof_leave(prof_tdata);
+	prof_leave(tsd, tdata);
 
 	*p_btkey = btkey.v;
-	*p_ctx = ctx.p;
-	*p_new_ctx = new_ctx;
+	*p_gctx = gctx.p;
+	*p_new_gctx = new_gctx;
 	return (false);
 }
 
-prof_thr_cnt_t *
-prof_lookup(prof_bt_t *bt)
+prof_tctx_t *
+prof_lookup(tsd_t *tsd, prof_bt_t *bt)
 {
 	union {
-		prof_thr_cnt_t	*p;
+		prof_tctx_t	*p;
 		void		*v;
 	} ret;
-	prof_tdata_t *prof_tdata;
+	prof_tdata_t *tdata;
+	bool not_found;
 
 	cassert(config_prof);
 
-	prof_tdata = prof_tdata_get(false);
-	if ((uintptr_t)prof_tdata <= (uintptr_t)PROF_TDATA_STATE_MAX)
+	tdata = prof_tdata_get(tsd, false);
+	if (tdata == NULL)
 		return (NULL);
 
-	if (ckh_search(&prof_tdata->bt2cnt, bt, NULL, &ret.v)) {
+	malloc_mutex_lock(tdata->lock);
+	not_found = ckh_search(&tdata->bt2tctx, bt, NULL, &ret.v);
+	if (!not_found) /* Note double negative! */
+		ret.p->prepared = true;
+	malloc_mutex_unlock(tdata->lock);
+	if (not_found) {
+		tcache_t *tcache;
 		void *btkey;
-		prof_ctx_t *ctx;
-		bool new_ctx;
+		prof_gctx_t *gctx;
+		bool new_gctx, error;
 
 		/*
 		 * This thread's cache lacks bt.  Look for it in the global
 		 * cache.
 		 */
-		if (prof_lookup_global(bt, prof_tdata, &btkey, &ctx, &new_ctx))
+		if (prof_lookup_global(tsd, bt, tdata, &btkey, &gctx,
+		    &new_gctx))
 			return (NULL);
 
-		/* Link a prof_thd_cnt_t into ctx for this thread. */
-		if (ckh_count(&prof_tdata->bt2cnt) == PROF_TCMAX) {
-			assert(ckh_count(&prof_tdata->bt2cnt) > 0);
-			/*
-			 * Flush the least recently used cnt in order to keep
-			 * bt2cnt from becoming too large.
-			 */
-			ret.p = ql_last(&prof_tdata->lru_ql, lru_link);
-			assert(ret.v != NULL);
-			if (ckh_remove(&prof_tdata->bt2cnt, ret.p->ctx->bt,
-			    NULL, NULL))
-				not_reached();
-			ql_remove(&prof_tdata->lru_ql, ret.p, lru_link);
-			prof_ctx_merge(ret.p->ctx, ret.p);
-			/* ret can now be re-used. */
-		} else {
-			assert(ckh_count(&prof_tdata->bt2cnt) < PROF_TCMAX);
-			/* Allocate and partially initialize a new cnt. */
-			ret.v = imalloc(sizeof(prof_thr_cnt_t));
-			if (ret.p == NULL) {
-				if (new_ctx)
-					prof_ctx_destroy(ctx);
-				return (NULL);
-			}
-			ql_elm_new(ret.p, cnts_link);
-			ql_elm_new(ret.p, lru_link);
+		/* Link a prof_tctx_t into gctx for this thread. */
+		tcache = tcache_get(tsd, true);
+		ret.v = iallocztm(tsd, sizeof(prof_tctx_t), false, tcache, true,
+		    NULL);
+		if (ret.p == NULL) {
+			if (new_gctx)
+				prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
+			return (NULL);
 		}
-		/* Finish initializing ret. */
-		ret.p->ctx = ctx;
-		ret.p->epoch = 0;
+		ret.p->tdata = tdata;
+		ret.p->thr_uid = tdata->thr_uid;
+		ret.p->thr_discrim = tdata->thr_discrim;
 		memset(&ret.p->cnts, 0, sizeof(prof_cnt_t));
-		if (ckh_insert(&prof_tdata->bt2cnt, btkey, ret.v)) {
-			if (new_ctx)
-				prof_ctx_destroy(ctx);
-			idalloc(ret.v);
+		ret.p->gctx = gctx;
+		ret.p->tctx_uid = tdata->tctx_uid_next++;
+		ret.p->prepared = true;
+		ret.p->state = prof_tctx_state_initializing;
+		malloc_mutex_lock(tdata->lock);
+		error = ckh_insert(tsd, &tdata->bt2tctx, btkey, ret.v);
+		malloc_mutex_unlock(tdata->lock);
+		if (error) {
+			if (new_gctx)
+				prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
+			idalloctm(tsd, ret.v, tcache, true);
 			return (NULL);
 		}
-		ql_head_insert(&prof_tdata->lru_ql, ret.p, lru_link);
-		malloc_mutex_lock(ctx->lock);
-		ql_tail_insert(&ctx->cnts_ql, ret.p, cnts_link);
-		ctx->nlimbo--;
-		malloc_mutex_unlock(ctx->lock);
-	} else {
-		/* Move ret to the front of the LRU. */
-		ql_remove(&prof_tdata->lru_ql, ret.p, lru_link);
-		ql_head_insert(&prof_tdata->lru_ql, ret.p, lru_link);
+		malloc_mutex_lock(gctx->lock);
+		ret.p->state = prof_tctx_state_nominal;
+		tctx_tree_insert(&gctx->tctxs, ret.p);
+		gctx->nlimbo--;
+		malloc_mutex_unlock(gctx->lock);
 	}
 
 	return (ret.p);
 }
 
+void
+prof_sample_threshold_update(prof_tdata_t *tdata)
+{
+	/*
+	 * The body of this function is compiled out unless heap profiling is
+	 * enabled, so that it is possible to compile jemalloc with floating
+	 * point support completely disabled.  Avoiding floating point code is
+	 * important on memory-constrained systems, but it also enables a
+	 * workaround for versions of glibc that don't properly save/restore
+	 * floating point registers during dynamic lazy symbol loading (which
+	 * internally calls into whatever malloc implementation happens to be
+	 * integrated into the application).  Note that some compilers (e.g.
+	 * gcc 4.8) may use floating point registers for fast memory moves, so
+	 * jemalloc must be compiled with such optimizations disabled (e.g.
+	 * -mno-sse) in order for the workaround to be complete.
+	 */
+#ifdef JEMALLOC_PROF
+	uint64_t r;
+	double u;
+
+	if (!config_prof)
+		return;
+
+	if (lg_prof_sample == 0) {
+		tdata->bytes_until_sample = 0;
+		return;
+	}
+
+	/*
+	 * Compute sample interval as a geometrically distributed random
+	 * variable with mean (2^lg_prof_sample).
+	 *
+	 *                             __        __
+	 *                             |  log(u)  |                     1
+	 * tdata->bytes_until_sample = | -------- |, where p = ---------------
+	 *                             | log(1-p) |             lg_prof_sample
+	 *                                                     2
+	 *
+	 * For more information on the math, see:
+	 *
+	 *   Non-Uniform Random Variate Generation
+	 *   Luc Devroye
+	 *   Springer-Verlag, New York, 1986
+	 *   pp 500
+	 *   (http://luc.devroye.org/rnbookindex.html)
+	 */
+	prng64(r, 53, tdata->prng_state, UINT64_C(6364136223846793005),
+	    UINT64_C(1442695040888963407));
+	u = (double)r * (1.0/9007199254740992.0L);
+	tdata->bytes_until_sample = (uint64_t)(log(u) /
+	    log(1.0 - (1.0 / (double)((uint64_t)1U << lg_prof_sample))))
+	    + (uint64_t)1U;
+#endif
+}
+
+#ifdef JEMALLOC_JET
+static prof_tdata_t *
+prof_tdata_count_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata, void *arg)
+{
+	size_t *tdata_count = (size_t *)arg;
+
+	(*tdata_count)++;
+
+	return (NULL);
+}
+
+size_t
+prof_tdata_count(void)
+{
+	size_t tdata_count = 0;
+
+	malloc_mutex_lock(&tdatas_mtx);
+	tdata_tree_iter(&tdatas, NULL, prof_tdata_count_iter,
+	    (void *)&tdata_count);
+	malloc_mutex_unlock(&tdatas_mtx);
+
+	return (tdata_count);
+}
+#endif
+
 #ifdef JEMALLOC_JET
 size_t
 prof_bt_count(void)
 {
 	size_t bt_count;
-	prof_tdata_t *prof_tdata;
+	tsd_t *tsd;
+	prof_tdata_t *tdata;
 
-	prof_tdata = prof_tdata_get(false);
-	if ((uintptr_t)prof_tdata <= (uintptr_t)PROF_TDATA_STATE_MAX)
+	tsd = tsd_fetch();
+	tdata = prof_tdata_get(tsd, false);
+	if (tdata == NULL)
 		return (0);
 
-	prof_enter(prof_tdata);
-	bt_count = ckh_count(&bt2ctx);
-	prof_leave(prof_tdata);
+	malloc_mutex_lock(&bt2gctx_mtx);
+	bt_count = ckh_count(&bt2gctx);
+	malloc_mutex_unlock(&bt2gctx_mtx);
 
 	return (bt_count);
 }
 #endif
 
 #ifdef JEMALLOC_JET
@@ -672,13 +931,13 @@
 static int
 prof_dump_open(bool propagate_err, const char *filename)
 {
 	int fd;
 
 	fd = creat(filename, 0644);
-	if (fd == -1 && propagate_err == false) {
+	if (fd == -1 && !propagate_err) {
 		malloc_printf("<jemalloc>: creat(\"%s\"), 0644) failed\n",
 		    filename);
 		if (opt_abort)
 			abort();
 	}
 
@@ -697,13 +956,13 @@
 	ssize_t err;
 
 	cassert(config_prof);
 
 	err = write(prof_dump_fd, prof_dump_buf, prof_dump_buf_end);
 	if (err == -1) {
-		if (propagate_err == false) {
+		if (!propagate_err) {
 			malloc_write("<jemalloc>: write() failed during heap "
 			    "profile flush\n");
 			if (opt_abort)
 				abort();
 		}
 		ret = true;
@@ -753,13 +1012,13 @@
 		i += n;
 	}
 
 	return (false);
 }
 
-JEMALLOC_ATTR(format(printf, 2, 3))
+JEMALLOC_FORMAT_PRINTF(2, 3)
 static bool
 prof_dump_printf(bool propagate_err, const char *format, ...)
 {
 	bool ret;
 	va_list ap;
 	char buf[PROF_PRINTF_BUFSIZE];
@@ -769,182 +1028,373 @@
 	va_end(ap);
 	ret = prof_dump_write(propagate_err, buf);
 
 	return (ret);
 }
 
+/* tctx->tdata->lock is held. */
 static void
-prof_dump_ctx_prep(prof_ctx_t *ctx, prof_cnt_t *cnt_all, size_t *leak_nctx,
-    prof_ctx_list_t *ctx_ql)
+prof_tctx_merge_tdata(prof_tctx_t *tctx, prof_tdata_t *tdata)
 {
-	prof_thr_cnt_t *thr_cnt;
-	prof_cnt_t tcnt;
-
-	cassert(config_prof);
-
-	malloc_mutex_lock(ctx->lock);
-
-	/*
-	 * Increment nlimbo so that ctx won't go away before dump.
-	 * Additionally, link ctx into the dump list so that it is included in
-	 * prof_dump()'s second pass.
-	 */
-	ctx->nlimbo++;
-	ql_tail_insert(ctx_ql, ctx, dump_link);
-
-	memcpy(&ctx->cnt_summed, &ctx->cnt_merged, sizeof(prof_cnt_t));
-	ql_foreach(thr_cnt, &ctx->cnts_ql, cnts_link) {
-		volatile unsigned *epoch = &thr_cnt->epoch;
 
-		while (true) {
-			unsigned epoch0 = *epoch;
+	malloc_mutex_lock(tctx->gctx->lock);
 
-			/* Make sure epoch is even. */
-			if (epoch0 & 1U)
-				continue;
-
-			memcpy(&tcnt, &thr_cnt->cnts, sizeof(prof_cnt_t));
+	switch (tctx->state) {
+	case prof_tctx_state_initializing:
+		malloc_mutex_unlock(tctx->gctx->lock);
+		return;
+	case prof_tctx_state_nominal:
+		tctx->state = prof_tctx_state_dumping;
+		malloc_mutex_unlock(tctx->gctx->lock);
 
-			/* Terminate if epoch didn't change while reading. */
-			if (*epoch == epoch0)
-				break;
-		}
+		memcpy(&tctx->dump_cnts, &tctx->cnts, sizeof(prof_cnt_t));
 
-		ctx->cnt_summed.curobjs += tcnt.curobjs;
-		ctx->cnt_summed.curbytes += tcnt.curbytes;
+		tdata->cnt_summed.curobjs += tctx->dump_cnts.curobjs;
+		tdata->cnt_summed.curbytes += tctx->dump_cnts.curbytes;
 		if (opt_prof_accum) {
-			ctx->cnt_summed.accumobjs += tcnt.accumobjs;
-			ctx->cnt_summed.accumbytes += tcnt.accumbytes;
+			tdata->cnt_summed.accumobjs +=
+			    tctx->dump_cnts.accumobjs;
+			tdata->cnt_summed.accumbytes +=
+			    tctx->dump_cnts.accumbytes;
 		}
+		break;
+	case prof_tctx_state_dumping:
+	case prof_tctx_state_purgatory:
+		not_reached();
 	}
+}
 
-	if (ctx->cnt_summed.curobjs != 0)
-		(*leak_nctx)++;
+/* gctx->lock is held. */
+static void
+prof_tctx_merge_gctx(prof_tctx_t *tctx, prof_gctx_t *gctx)
+{
 
-	/* Add to cnt_all. */
-	cnt_all->curobjs += ctx->cnt_summed.curobjs;
-	cnt_all->curbytes += ctx->cnt_summed.curbytes;
+	gctx->cnt_summed.curobjs += tctx->dump_cnts.curobjs;
+	gctx->cnt_summed.curbytes += tctx->dump_cnts.curbytes;
 	if (opt_prof_accum) {
-		cnt_all->accumobjs += ctx->cnt_summed.accumobjs;
-		cnt_all->accumbytes += ctx->cnt_summed.accumbytes;
+		gctx->cnt_summed.accumobjs += tctx->dump_cnts.accumobjs;
+		gctx->cnt_summed.accumbytes += tctx->dump_cnts.accumbytes;
+	}
+}
+
+/* tctx->gctx is held. */
+static prof_tctx_t *
+prof_tctx_merge_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg)
+{
+
+	switch (tctx->state) {
+	case prof_tctx_state_nominal:
+		/* New since dumping started; ignore. */
+		break;
+	case prof_tctx_state_dumping:
+	case prof_tctx_state_purgatory:
+		prof_tctx_merge_gctx(tctx, tctx->gctx);
+		break;
+	default:
+		not_reached();
 	}
 
-	malloc_mutex_unlock(ctx->lock);
+	return (NULL);
 }
 
-static bool
-prof_dump_header(bool propagate_err, const prof_cnt_t *cnt_all)
+/* gctx->lock is held. */
+static prof_tctx_t *
+prof_tctx_dump_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg)
 {
+	bool propagate_err = *(bool *)arg;
 
-	if (opt_lg_prof_sample == 0) {
+	switch (tctx->state) {
+	case prof_tctx_state_initializing:
+	case prof_tctx_state_nominal:
+		/* Not captured by this dump. */
+		break;
+	case prof_tctx_state_dumping:
+	case prof_tctx_state_purgatory:
 		if (prof_dump_printf(propagate_err,
-		    "heap profile: %"PRId64": %"PRId64
-		    " [%"PRIu64": %"PRIu64"] @ heapprofile\n",
-		    cnt_all->curobjs, cnt_all->curbytes,
-		    cnt_all->accumobjs, cnt_all->accumbytes))
-			return (true);
-	} else {
-		if (prof_dump_printf(propagate_err,
-		    "heap profile: %"PRId64": %"PRId64
-		    " [%"PRIu64": %"PRIu64"] @ heap_v2/%"PRIu64"\n",
-		    cnt_all->curobjs, cnt_all->curbytes,
-		    cnt_all->accumobjs, cnt_all->accumbytes,
-		    ((uint64_t)1U << opt_lg_prof_sample)))
-			return (true);
+		    "  t%"FMTu64": %"FMTu64": %"FMTu64" [%"FMTu64": "
+		    "%"FMTu64"]\n", tctx->thr_uid, tctx->dump_cnts.curobjs,
+		    tctx->dump_cnts.curbytes, tctx->dump_cnts.accumobjs,
+		    tctx->dump_cnts.accumbytes))
+			return (tctx);
+		break;
+	default:
+		not_reached();
+	}
+	return (NULL);
+}
+
+/* tctx->gctx is held. */
+static prof_tctx_t *
+prof_tctx_finish_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg)
+{
+	prof_tctx_t *ret;
+
+	switch (tctx->state) {
+	case prof_tctx_state_nominal:
+		/* New since dumping started; ignore. */
+		break;
+	case prof_tctx_state_dumping:
+		tctx->state = prof_tctx_state_nominal;
+		break;
+	case prof_tctx_state_purgatory:
+		ret = tctx;
+		goto label_return;
+	default:
+		not_reached();
 	}
 
-	return (false);
+	ret = NULL;
+label_return:
+	return (ret);
 }
 
 static void
-prof_dump_ctx_cleanup_locked(prof_ctx_t *ctx, prof_ctx_list_t *ctx_ql)
+prof_dump_gctx_prep(prof_gctx_t *gctx, prof_gctx_tree_t *gctxs)
+{
+
+	cassert(config_prof);
+
+	malloc_mutex_lock(gctx->lock);
+
+	/*
+	 * Increment nlimbo so that gctx won't go away before dump.
+	 * Additionally, link gctx into the dump list so that it is included in
+	 * prof_dump()'s second pass.
+	 */
+	gctx->nlimbo++;
+	gctx_tree_insert(gctxs, gctx);
+
+	memset(&gctx->cnt_summed, 0, sizeof(prof_cnt_t));
+
+	malloc_mutex_unlock(gctx->lock);
+}
+
+static prof_gctx_t *
+prof_gctx_merge_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *arg)
 {
+	size_t *leak_ngctx = (size_t *)arg;
+
+	malloc_mutex_lock(gctx->lock);
+	tctx_tree_iter(&gctx->tctxs, NULL, prof_tctx_merge_iter, NULL);
+	if (gctx->cnt_summed.curobjs != 0)
+		(*leak_ngctx)++;
+	malloc_mutex_unlock(gctx->lock);
 
-	ctx->nlimbo--;
-	ql_remove(ctx_ql, ctx, dump_link);
+	return (NULL);
 }
 
 static void
-prof_dump_ctx_cleanup(prof_ctx_t *ctx, prof_ctx_list_t *ctx_ql)
+prof_gctx_finish(tsd_t *tsd, prof_gctx_tree_t *gctxs)
 {
+	prof_tdata_t *tdata = prof_tdata_get(tsd, false);
+	prof_gctx_t *gctx;
 
-	malloc_mutex_lock(ctx->lock);
-	prof_dump_ctx_cleanup_locked(ctx, ctx_ql);
-	malloc_mutex_unlock(ctx->lock);
+	/*
+	 * Standard tree iteration won't work here, because as soon as we
+	 * decrement gctx->nlimbo and unlock gctx, another thread can
+	 * concurrently destroy it, which will corrupt the tree.  Therefore,
+	 * tear down the tree one node at a time during iteration.
+	 */
+	while ((gctx = gctx_tree_first(gctxs)) != NULL) {
+		gctx_tree_remove(gctxs, gctx);
+		malloc_mutex_lock(gctx->lock);
+		{
+			prof_tctx_t *next;
+
+			next = NULL;
+			do {
+				prof_tctx_t *to_destroy =
+				    tctx_tree_iter(&gctx->tctxs, next,
+				    prof_tctx_finish_iter, NULL);
+				if (to_destroy != NULL) {
+					next = tctx_tree_next(&gctx->tctxs,
+					    to_destroy);
+					tctx_tree_remove(&gctx->tctxs,
+					    to_destroy);
+					idalloctm(tsd, to_destroy,
+					    tcache_get(tsd, false), true);
+				} else
+					next = NULL;
+			} while (next != NULL);
+		}
+		gctx->nlimbo--;
+		if (prof_gctx_should_destroy(gctx)) {
+			gctx->nlimbo++;
+			malloc_mutex_unlock(gctx->lock);
+			prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
+		} else
+			malloc_mutex_unlock(gctx->lock);
+	}
 }
 
+static prof_tdata_t *
+prof_tdata_merge_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata, void *arg)
+{
+	prof_cnt_t *cnt_all = (prof_cnt_t *)arg;
+
+	malloc_mutex_lock(tdata->lock);
+	if (!tdata->expired) {
+		size_t tabind;
+		union {
+			prof_tctx_t	*p;
+			void		*v;
+		} tctx;
+
+		tdata->dumping = true;
+		memset(&tdata->cnt_summed, 0, sizeof(prof_cnt_t));
+		for (tabind = 0; !ckh_iter(&tdata->bt2tctx, &tabind, NULL,
+		    &tctx.v);)
+			prof_tctx_merge_tdata(tctx.p, tdata);
+
+		cnt_all->curobjs += tdata->cnt_summed.curobjs;
+		cnt_all->curbytes += tdata->cnt_summed.curbytes;
+		if (opt_prof_accum) {
+			cnt_all->accumobjs += tdata->cnt_summed.accumobjs;
+			cnt_all->accumbytes += tdata->cnt_summed.accumbytes;
+		}
+	} else
+		tdata->dumping = false;
+	malloc_mutex_unlock(tdata->lock);
+
+	return (NULL);
+}
+
+static prof_tdata_t *
+prof_tdata_dump_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata, void *arg)
+{
+	bool propagate_err = *(bool *)arg;
+
+	if (!tdata->dumping)
+		return (NULL);
+
+	if (prof_dump_printf(propagate_err,
+	    "  t%"FMTu64": %"FMTu64": %"FMTu64" [%"FMTu64": %"FMTu64"]%s%s\n",
+	    tdata->thr_uid, tdata->cnt_summed.curobjs,
+	    tdata->cnt_summed.curbytes, tdata->cnt_summed.accumobjs,
+	    tdata->cnt_summed.accumbytes,
+	    (tdata->thread_name != NULL) ? " " : "",
+	    (tdata->thread_name != NULL) ? tdata->thread_name : ""))
+		return (tdata);
+	return (NULL);
+}
+
+#ifdef JEMALLOC_JET
+#undef prof_dump_header
+#define	prof_dump_header JEMALLOC_N(prof_dump_header_impl)
+#endif
 static bool
-prof_dump_ctx(bool propagate_err, prof_ctx_t *ctx, const prof_bt_t *bt,
-    prof_ctx_list_t *ctx_ql)
+prof_dump_header(bool propagate_err, const prof_cnt_t *cnt_all)
+{
+	bool ret;
+
+	if (prof_dump_printf(propagate_err,
+	    "heap_v2/%"FMTu64"\n"
+	    "  t*: %"FMTu64": %"FMTu64" [%"FMTu64": %"FMTu64"]\n",
+	    ((uint64_t)1U << lg_prof_sample), cnt_all->curobjs,
+	    cnt_all->curbytes, cnt_all->accumobjs, cnt_all->accumbytes))
+		return (true);
+
+	malloc_mutex_lock(&tdatas_mtx);
+	ret = (tdata_tree_iter(&tdatas, NULL, prof_tdata_dump_iter,
+	    (void *)&propagate_err) != NULL);
+	malloc_mutex_unlock(&tdatas_mtx);
+	return (ret);
+}
+#ifdef JEMALLOC_JET
+#undef prof_dump_header
+#define	prof_dump_header JEMALLOC_N(prof_dump_header)
+prof_dump_header_t *prof_dump_header = JEMALLOC_N(prof_dump_header_impl);
+#endif
+
+/* gctx->lock is held. */
+static bool
+prof_dump_gctx(bool propagate_err, prof_gctx_t *gctx, const prof_bt_t *bt,
+    prof_gctx_tree_t *gctxs)
 {
 	bool ret;
 	unsigned i;
 
 	cassert(config_prof);
 
-	/*
-	 * Current statistics can sum to 0 as a result of unmerged per thread
-	 * statistics.  Additionally, interval- and growth-triggered dumps can
-	 * occur between the time a ctx is created and when its statistics are
-	 * filled in.  Avoid dumping any ctx that is an artifact of either
-	 * implementation detail.
-	 */
-	malloc_mutex_lock(ctx->lock);
-	if ((opt_prof_accum == false && ctx->cnt_summed.curobjs == 0) ||
-	    (opt_prof_accum && ctx->cnt_summed.accumobjs == 0)) {
-		assert(ctx->cnt_summed.curobjs == 0);
-		assert(ctx->cnt_summed.curbytes == 0);
-		assert(ctx->cnt_summed.accumobjs == 0);
-		assert(ctx->cnt_summed.accumbytes == 0);
+	/* Avoid dumping such gctx's that have no useful data. */
+	if ((!opt_prof_accum && gctx->cnt_summed.curobjs == 0) ||
+	    (opt_prof_accum && gctx->cnt_summed.accumobjs == 0)) {
+		assert(gctx->cnt_summed.curobjs == 0);
+		assert(gctx->cnt_summed.curbytes == 0);
+		assert(gctx->cnt_summed.accumobjs == 0);
+		assert(gctx->cnt_summed.accumbytes == 0);
 		ret = false;
 		goto label_return;
 	}
 
-	if (prof_dump_printf(propagate_err, "%"PRId64": %"PRId64
-	    " [%"PRIu64": %"PRIu64"] @",
-	    ctx->cnt_summed.curobjs, ctx->cnt_summed.curbytes,
-	    ctx->cnt_summed.accumobjs, ctx->cnt_summed.accumbytes)) {
+	if (prof_dump_printf(propagate_err, "@")) {
 		ret = true;
 		goto label_return;
 	}
-
 	for (i = 0; i < bt->len; i++) {
-		if (prof_dump_printf(propagate_err, " %#"PRIxPTR,
+		if (prof_dump_printf(propagate_err, " %#"FMTxPTR,
 		    (uintptr_t)bt->vec[i])) {
 			ret = true;
 			goto label_return;
 		}
 	}
 
-	if (prof_dump_write(propagate_err, "\n")) {
+	if (prof_dump_printf(propagate_err,
+	    "\n"
+	    "  t*: %"FMTu64": %"FMTu64" [%"FMTu64": %"FMTu64"]\n",
+	    gctx->cnt_summed.curobjs, gctx->cnt_summed.curbytes,
+	    gctx->cnt_summed.accumobjs, gctx->cnt_summed.accumbytes)) {
+		ret = true;
+		goto label_return;
+	}
+
+	if (tctx_tree_iter(&gctx->tctxs, NULL, prof_tctx_dump_iter,
+	    (void *)&propagate_err) != NULL) {
 		ret = true;
 		goto label_return;
 	}
 
 	ret = false;
 label_return:
-	prof_dump_ctx_cleanup_locked(ctx, ctx_ql);
-	malloc_mutex_unlock(ctx->lock);
 	return (ret);
 }
 
+JEMALLOC_FORMAT_PRINTF(1, 2)
+static int
+prof_open_maps(const char *format, ...)
+{
+	int mfd;
+	va_list ap;
+	char filename[PATH_MAX + 1];
+
+	va_start(ap, format);
+	malloc_vsnprintf(filename, sizeof(filename), format, ap);
+	va_end(ap);
+	mfd = open(filename, O_RDONLY);
+
+	return (mfd);
+}
+
 static bool
 prof_dump_maps(bool propagate_err)
 {
 	bool ret;
 	int mfd;
-	char filename[PATH_MAX + 1];
 
 	cassert(config_prof);
 #ifdef __FreeBSD__
-	malloc_snprintf(filename, sizeof(filename), "/proc/curproc/map");
+	mfd = prof_open_maps("/proc/curproc/map");
 #else
-	malloc_snprintf(filename, sizeof(filename), "/proc/%d/maps",
-	    (int)getpid());
+	{
+		int pid = getpid();
+
+		mfd = prof_open_maps("/proc/%d/task/%d/maps", pid, pid);
+		if (mfd == -1)
+			mfd = prof_open_maps("/proc/%d/maps", pid);
+	}
 #endif
-	mfd = open(filename, O_RDONLY);
 	if (mfd != -1) {
 		ssize_t nread;
 
 		if (prof_dump_write(propagate_err, "\nMAPPED_LIBRARIES:\n") &&
 		    propagate_err) {
 			ret = true;
@@ -974,208 +1424,249 @@
 	if (mfd != -1)
 		close(mfd);
 	return (ret);
 }
 
 static void
-prof_leakcheck(const prof_cnt_t *cnt_all, size_t leak_nctx,
+prof_leakcheck(const prof_cnt_t *cnt_all, size_t leak_ngctx,
     const char *filename)
 {
 
 	if (cnt_all->curbytes != 0) {
-		malloc_printf("<jemalloc>: Leak summary: %"PRId64" byte%s, %"
-		    PRId64" object%s, %zu context%s\n",
+		malloc_printf("<jemalloc>: Leak summary: %"FMTu64" byte%s, %"
+		    FMTu64" object%s, %zu context%s\n",
 		    cnt_all->curbytes, (cnt_all->curbytes != 1) ? "s" : "",
 		    cnt_all->curobjs, (cnt_all->curobjs != 1) ? "s" : "",
-		    leak_nctx, (leak_nctx != 1) ? "s" : "");
+		    leak_ngctx, (leak_ngctx != 1) ? "s" : "");
 		malloc_printf(
-		    "<jemalloc>: Run pprof on \"%s\" for leak detail\n",
+		    "<jemalloc>: Run jeprof on \"%s\" for leak detail\n",
 		    filename);
 	}
 }
 
+static prof_gctx_t *
+prof_gctx_dump_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *arg)
+{
+	prof_gctx_t *ret;
+	bool propagate_err = *(bool *)arg;
+
+	malloc_mutex_lock(gctx->lock);
+
+	if (prof_dump_gctx(propagate_err, gctx, &gctx->bt, gctxs)) {
+		ret = gctx;
+		goto label_return;
+	}
+
+	ret = NULL;
+label_return:
+	malloc_mutex_unlock(gctx->lock);
+	return (ret);
+}
+
 static bool
-prof_dump(bool propagate_err, const char *filename, bool leakcheck)
+prof_dump(tsd_t *tsd, bool propagate_err, const char *filename, bool leakcheck)
 {
-	prof_tdata_t *prof_tdata;
+	prof_tdata_t *tdata;
 	prof_cnt_t cnt_all;
 	size_t tabind;
 	union {
-		prof_ctx_t	*p;
+		prof_gctx_t	*p;
 		void		*v;
-	} ctx;
-	size_t leak_nctx;
-	prof_ctx_list_t ctx_ql;
+	} gctx;
+	size_t leak_ngctx;
+	prof_gctx_tree_t gctxs;
 
 	cassert(config_prof);
 
-	prof_tdata = prof_tdata_get(false);
-	if ((uintptr_t)prof_tdata <= (uintptr_t)PROF_TDATA_STATE_MAX)
+	tdata = prof_tdata_get(tsd, true);
+	if (tdata == NULL)
 		return (true);
 
 	malloc_mutex_lock(&prof_dump_mtx);
+	prof_enter(tsd, tdata);
 
-	/* Merge per thread profile stats, and sum them in cnt_all. */
+	/*
+	 * Put gctx's in limbo and clear their counters in preparation for
+	 * summing.
+	 */
+	gctx_tree_new(&gctxs);
+	for (tabind = 0; !ckh_iter(&bt2gctx, &tabind, NULL, &gctx.v);)
+		prof_dump_gctx_prep(gctx.p, &gctxs);
+
+	/*
+	 * Iterate over tdatas, and for the non-expired ones snapshot their tctx
+	 * stats and merge them into the associated gctx's.
+	 */
 	memset(&cnt_all, 0, sizeof(prof_cnt_t));
-	leak_nctx = 0;
-	ql_new(&ctx_ql);
-	prof_enter(prof_tdata);
-	for (tabind = 0; ckh_iter(&bt2ctx, &tabind, NULL, &ctx.v) == false;)
-		prof_dump_ctx_prep(ctx.p, &cnt_all, &leak_nctx, &ctx_ql);
-	prof_leave(prof_tdata);
+	malloc_mutex_lock(&tdatas_mtx);
+	tdata_tree_iter(&tdatas, NULL, prof_tdata_merge_iter, (void *)&cnt_all);
+	malloc_mutex_unlock(&tdatas_mtx);
+
+	/* Merge tctx stats into gctx's. */
+	leak_ngctx = 0;
+	gctx_tree_iter(&gctxs, NULL, prof_gctx_merge_iter, (void *)&leak_ngctx);
+
+	prof_leave(tsd, tdata);
 
 	/* Create dump file. */
 	if ((prof_dump_fd = prof_dump_open(propagate_err, filename)) == -1)
 		goto label_open_close_error;
 
 	/* Dump profile header. */
 	if (prof_dump_header(propagate_err, &cnt_all))
 		goto label_write_error;
 
-	/* Dump per ctx profile stats. */
-	while ((ctx.p = ql_first(&ctx_ql)) != NULL) {
-		if (prof_dump_ctx(propagate_err, ctx.p, ctx.p->bt, &ctx_ql))
-			goto label_write_error;
-	}
+	/* Dump per gctx profile stats. */
+	if (gctx_tree_iter(&gctxs, NULL, prof_gctx_dump_iter,
+	    (void *)&propagate_err) != NULL)
+		goto label_write_error;
 
 	/* Dump /proc/<pid>/maps if possible. */
 	if (prof_dump_maps(propagate_err))
 		goto label_write_error;
 
 	if (prof_dump_close(propagate_err))
 		goto label_open_close_error;
 
+	prof_gctx_finish(tsd, &gctxs);
 	malloc_mutex_unlock(&prof_dump_mtx);
 
 	if (leakcheck)
-		prof_leakcheck(&cnt_all, leak_nctx, filename);
+		prof_leakcheck(&cnt_all, leak_ngctx, filename);
 
 	return (false);
 label_write_error:
 	prof_dump_close(propagate_err);
 label_open_close_error:
-	while ((ctx.p = ql_first(&ctx_ql)) != NULL)
-		prof_dump_ctx_cleanup(ctx.p, &ctx_ql);
+	prof_gctx_finish(tsd, &gctxs);
 	malloc_mutex_unlock(&prof_dump_mtx);
 	return (true);
 }
 
 #define	DUMP_FILENAME_BUFSIZE	(PATH_MAX + 1)
 #define	VSEQ_INVALID		UINT64_C(0xffffffffffffffff)
 static void
-prof_dump_filename(char *filename, char v, int64_t vseq)
+prof_dump_filename(char *filename, char v, uint64_t vseq)
 {
 
 	cassert(config_prof);
 
 	if (vseq != VSEQ_INVALID) {
 	        /* "<prefix>.<pid>.<seq>.v<vseq>.heap" */
 		malloc_snprintf(filename, DUMP_FILENAME_BUFSIZE,
-		    "%s.%d.%"PRIu64".%c%"PRId64".heap",
+		    "%s.%d.%"FMTu64".%c%"FMTu64".heap",
 		    opt_prof_prefix, (int)getpid(), prof_dump_seq, v, vseq);
 	} else {
 	        /* "<prefix>.<pid>.<seq>.<v>.heap" */
 		malloc_snprintf(filename, DUMP_FILENAME_BUFSIZE,
-		    "%s.%d.%"PRIu64".%c.heap",
+		    "%s.%d.%"FMTu64".%c.heap",
 		    opt_prof_prefix, (int)getpid(), prof_dump_seq, v);
 	}
 	prof_dump_seq++;
 }
 
 static void
 prof_fdump(void)
 {
+	tsd_t *tsd;
 	char filename[DUMP_FILENAME_BUFSIZE];
 
 	cassert(config_prof);
+	assert(opt_prof_final);
+	assert(opt_prof_prefix[0] != '\0');
 
-	if (prof_booted == false)
+	if (!prof_booted)
 		return;
+	tsd = tsd_fetch();
 
-	if (opt_prof_final && opt_prof_prefix[0] != '\0') {
-		malloc_mutex_lock(&prof_dump_seq_mtx);
-		prof_dump_filename(filename, 'f', VSEQ_INVALID);
-		malloc_mutex_unlock(&prof_dump_seq_mtx);
-		prof_dump(false, filename, opt_prof_leak);
-	}
+	malloc_mutex_lock(&prof_dump_seq_mtx);
+	prof_dump_filename(filename, 'f', VSEQ_INVALID);
+	malloc_mutex_unlock(&prof_dump_seq_mtx);
+	prof_dump(tsd, false, filename, opt_prof_leak);
 }
 
 void
 prof_idump(void)
 {
-	prof_tdata_t *prof_tdata;
-	char filename[PATH_MAX + 1];
+	tsd_t *tsd;
+	prof_tdata_t *tdata;
 
 	cassert(config_prof);
 
-	if (prof_booted == false)
+	if (!prof_booted)
 		return;
-	prof_tdata = prof_tdata_get(false);
-	if ((uintptr_t)prof_tdata <= (uintptr_t)PROF_TDATA_STATE_MAX)
+	tsd = tsd_fetch();
+	tdata = prof_tdata_get(tsd, false);
+	if (tdata == NULL)
 		return;
-	if (prof_tdata->enq) {
-		prof_tdata->enq_idump = true;
+	if (tdata->enq) {
+		tdata->enq_idump = true;
 		return;
 	}
 
 	if (opt_prof_prefix[0] != '\0') {
+		char filename[PATH_MAX + 1];
 		malloc_mutex_lock(&prof_dump_seq_mtx);
 		prof_dump_filename(filename, 'i', prof_dump_iseq);
 		prof_dump_iseq++;
 		malloc_mutex_unlock(&prof_dump_seq_mtx);
-		prof_dump(false, filename, false);
+		prof_dump(tsd, false, filename, false);
 	}
 }
 
 bool
 prof_mdump(const char *filename)
 {
+	tsd_t *tsd;
 	char filename_buf[DUMP_FILENAME_BUFSIZE];
 
 	cassert(config_prof);
 
-	if (opt_prof == false || prof_booted == false)
+	if (!opt_prof || !prof_booted)
 		return (true);
+	tsd = tsd_fetch();
 
 	if (filename == NULL) {
 		/* No filename specified, so automatically generate one. */
 		if (opt_prof_prefix[0] == '\0')
 			return (true);
 		malloc_mutex_lock(&prof_dump_seq_mtx);
 		prof_dump_filename(filename_buf, 'm', prof_dump_mseq);
 		prof_dump_mseq++;
 		malloc_mutex_unlock(&prof_dump_seq_mtx);
 		filename = filename_buf;
 	}
-	return (prof_dump(true, filename, false));
+	return (prof_dump(tsd, true, filename, false));
 }
 
 void
 prof_gdump(void)
 {
-	prof_tdata_t *prof_tdata;
-	char filename[DUMP_FILENAME_BUFSIZE];
+	tsd_t *tsd;
+	prof_tdata_t *tdata;
 
 	cassert(config_prof);
 
-	if (prof_booted == false)
+	if (!prof_booted)
 		return;
-	prof_tdata = prof_tdata_get(false);
-	if ((uintptr_t)prof_tdata <= (uintptr_t)PROF_TDATA_STATE_MAX)
+	tsd = tsd_fetch();
+	tdata = prof_tdata_get(tsd, false);
+	if (tdata == NULL)
 		return;
-	if (prof_tdata->enq) {
-		prof_tdata->enq_gdump = true;
+	if (tdata->enq) {
+		tdata->enq_gdump = true;
 		return;
 	}
 
 	if (opt_prof_prefix[0] != '\0') {
+		char filename[DUMP_FILENAME_BUFSIZE];
 		malloc_mutex_lock(&prof_dump_seq_mtx);
 		prof_dump_filename(filename, 'u', prof_dump_useq);
 		prof_dump_useq++;
 		malloc_mutex_unlock(&prof_dump_seq_mtx);
-		prof_dump(false, filename, false);
+		prof_dump(tsd, false, filename, false);
 	}
 }
 
 static void
 prof_bt_hash(const void *key, size_t r_hash[2])
 {
@@ -1196,94 +1687,381 @@
 
 	if (bt1->len != bt2->len)
 		return (false);
 	return (memcmp(bt1->vec, bt2->vec, bt1->len * sizeof(void *)) == 0);
 }
 
-prof_tdata_t *
-prof_tdata_init(void)
+JEMALLOC_INLINE_C uint64_t
+prof_thr_uid_alloc(void)
+{
+	uint64_t thr_uid;
+
+	malloc_mutex_lock(&next_thr_uid_mtx);
+	thr_uid = next_thr_uid;
+	next_thr_uid++;
+	malloc_mutex_unlock(&next_thr_uid_mtx);
+
+	return (thr_uid);
+}
+
+static prof_tdata_t *
+prof_tdata_init_impl(tsd_t *tsd, uint64_t thr_uid, uint64_t thr_discrim,
+    char *thread_name, bool active)
 {
-	prof_tdata_t *prof_tdata;
+	prof_tdata_t *tdata;
+	tcache_t *tcache;
 
 	cassert(config_prof);
 
 	/* Initialize an empty cache for this thread. */
-	prof_tdata = (prof_tdata_t *)imalloc(sizeof(prof_tdata_t));
-	if (prof_tdata == NULL)
+	tcache = tcache_get(tsd, true);
+	tdata = (prof_tdata_t *)iallocztm(tsd, sizeof(prof_tdata_t), false,
+	    tcache, true, NULL);
+	if (tdata == NULL)
 		return (NULL);
 
-	if (ckh_new(&prof_tdata->bt2cnt, PROF_CKH_MINITEMS,
+	tdata->lock = prof_tdata_mutex_choose(thr_uid);
+	tdata->thr_uid = thr_uid;
+	tdata->thr_discrim = thr_discrim;
+	tdata->thread_name = thread_name;
+	tdata->attached = true;
+	tdata->expired = false;
+	tdata->tctx_uid_next = 0;
+
+	if (ckh_new(tsd, &tdata->bt2tctx, PROF_CKH_MINITEMS,
 	    prof_bt_hash, prof_bt_keycomp)) {
-		idalloc(prof_tdata);
+		idalloctm(tsd, tdata, tcache, true);
 		return (NULL);
 	}
-	ql_new(&prof_tdata->lru_ql);
 
-	prof_tdata->vec = imalloc(sizeof(void *) * PROF_BT_MAX);
-	if (prof_tdata->vec == NULL) {
-		ckh_delete(&prof_tdata->bt2cnt);
-		idalloc(prof_tdata);
-		return (NULL);
-	}
+	tdata->prng_state = (uint64_t)(uintptr_t)tdata;
+	prof_sample_threshold_update(tdata);
 
-	prof_tdata->prng_state = 0;
-	prof_tdata->threshold = 0;
-	prof_tdata->accum = 0;
+	tdata->enq = false;
+	tdata->enq_idump = false;
+	tdata->enq_gdump = false;
 
-	prof_tdata->enq = false;
-	prof_tdata->enq_idump = false;
-	prof_tdata->enq_gdump = false;
+	tdata->dumping = false;
+	tdata->active = active;
 
-	prof_tdata_tsd_set(&prof_tdata);
+	malloc_mutex_lock(&tdatas_mtx);
+	tdata_tree_insert(&tdatas, tdata);
+	malloc_mutex_unlock(&tdatas_mtx);
 
-	return (prof_tdata);
+	return (tdata);
 }
 
-void
-prof_tdata_cleanup(void *arg)
+prof_tdata_t *
+prof_tdata_init(tsd_t *tsd)
 {
-	prof_thr_cnt_t *cnt;
-	prof_tdata_t *prof_tdata = *(prof_tdata_t **)arg;
 
-	cassert(config_prof);
+	return (prof_tdata_init_impl(tsd, prof_thr_uid_alloc(), 0, NULL,
+	    prof_thread_active_init_get()));
+}
 
-	if (prof_tdata == PROF_TDATA_STATE_REINCARNATED) {
-		/*
-		 * Another destructor deallocated memory after this destructor
-		 * was called.  Reset prof_tdata to PROF_TDATA_STATE_PURGATORY
-		 * in order to receive another callback.
-		 */
-		prof_tdata = PROF_TDATA_STATE_PURGATORY;
-		prof_tdata_tsd_set(&prof_tdata);
-	} else if (prof_tdata == PROF_TDATA_STATE_PURGATORY) {
-		/*
-		 * The previous time this destructor was called, we set the key
-		 * to PROF_TDATA_STATE_PURGATORY so that other destructors
-		 * wouldn't cause re-creation of the prof_tdata.  This time, do
-		 * nothing, so that the destructor will not be called again.
-		 */
-	} else if (prof_tdata != NULL) {
-		/*
-		 * Delete the hash table.  All of its contents can still be
-		 * iterated over via the LRU.
-		 */
-		ckh_delete(&prof_tdata->bt2cnt);
+/* tdata->lock must be held. */
+static bool
+prof_tdata_should_destroy(prof_tdata_t *tdata, bool even_if_attached)
+{
+
+	if (tdata->attached && !even_if_attached)
+		return (false);
+	if (ckh_count(&tdata->bt2tctx) != 0)
+		return (false);
+	return (true);
+}
+
+/* tdatas_mtx must be held. */
+static void
+prof_tdata_destroy_locked(tsd_t *tsd, prof_tdata_t *tdata,
+    bool even_if_attached)
+{
+	tcache_t *tcache;
+
+	assert(prof_tdata_should_destroy(tdata, even_if_attached));
+	assert(tsd_prof_tdata_get(tsd) != tdata);
+
+	tdata_tree_remove(&tdatas, tdata);
+
+	tcache = tcache_get(tsd, false);
+	if (tdata->thread_name != NULL)
+		idalloctm(tsd, tdata->thread_name, tcache, true);
+	ckh_delete(tsd, &tdata->bt2tctx);
+	idalloctm(tsd, tdata, tcache, true);
+}
+
+static void
+prof_tdata_destroy(tsd_t *tsd, prof_tdata_t *tdata, bool even_if_attached)
+{
+
+	malloc_mutex_lock(&tdatas_mtx);
+	prof_tdata_destroy_locked(tsd, tdata, even_if_attached);
+	malloc_mutex_unlock(&tdatas_mtx);
+}
+
+static void
+prof_tdata_detach(tsd_t *tsd, prof_tdata_t *tdata)
+{
+	bool destroy_tdata;
+
+	malloc_mutex_lock(tdata->lock);
+	if (tdata->attached) {
+		destroy_tdata = prof_tdata_should_destroy(tdata, true);
 		/*
-		 * Iteratively merge cnt's into the global stats and delete
-		 * them.
+		 * Only detach if !destroy_tdata, because detaching would allow
+		 * another thread to win the race to destroy tdata.
 		 */
-		while ((cnt = ql_last(&prof_tdata->lru_ql, lru_link)) != NULL) {
-			ql_remove(&prof_tdata->lru_ql, cnt, lru_link);
-			prof_ctx_merge(cnt->ctx, cnt);
-			idalloc(cnt);
-		}
-		idalloc(prof_tdata->vec);
-		idalloc(prof_tdata);
-		prof_tdata = PROF_TDATA_STATE_PURGATORY;
-		prof_tdata_tsd_set(&prof_tdata);
-	}
+		if (!destroy_tdata)
+			tdata->attached = false;
+		tsd_prof_tdata_set(tsd, NULL);
+	} else
+		destroy_tdata = false;
+	malloc_mutex_unlock(tdata->lock);
+	if (destroy_tdata)
+		prof_tdata_destroy(tsd, tdata, true);
+}
+
+prof_tdata_t *
+prof_tdata_reinit(tsd_t *tsd, prof_tdata_t *tdata)
+{
+	uint64_t thr_uid = tdata->thr_uid;
+	uint64_t thr_discrim = tdata->thr_discrim + 1;
+	char *thread_name = (tdata->thread_name != NULL) ?
+	    prof_thread_name_alloc(tsd, tdata->thread_name) : NULL;
+	bool active = tdata->active;
+
+	prof_tdata_detach(tsd, tdata);
+	return (prof_tdata_init_impl(tsd, thr_uid, thr_discrim, thread_name,
+	    active));
+}
+
+static bool
+prof_tdata_expire(prof_tdata_t *tdata)
+{
+	bool destroy_tdata;
+
+	malloc_mutex_lock(tdata->lock);
+	if (!tdata->expired) {
+		tdata->expired = true;
+		destroy_tdata = tdata->attached ? false :
+		    prof_tdata_should_destroy(tdata, false);
+	} else
+		destroy_tdata = false;
+	malloc_mutex_unlock(tdata->lock);
+
+	return (destroy_tdata);
+}
+
+static prof_tdata_t *
+prof_tdata_reset_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata, void *arg)
+{
+
+	return (prof_tdata_expire(tdata) ? tdata : NULL);
+}
+
+void
+prof_reset(tsd_t *tsd, size_t lg_sample)
+{
+	prof_tdata_t *next;
+
+	assert(lg_sample < (sizeof(uint64_t) << 3));
+
+	malloc_mutex_lock(&prof_dump_mtx);
+	malloc_mutex_lock(&tdatas_mtx);
+
+	lg_prof_sample = lg_sample;
+
+	next = NULL;
+	do {
+		prof_tdata_t *to_destroy = tdata_tree_iter(&tdatas, next,
+		    prof_tdata_reset_iter, NULL);
+		if (to_destroy != NULL) {
+			next = tdata_tree_next(&tdatas, to_destroy);
+			prof_tdata_destroy_locked(tsd, to_destroy, false);
+		} else
+			next = NULL;
+	} while (next != NULL);
+
+	malloc_mutex_unlock(&tdatas_mtx);
+	malloc_mutex_unlock(&prof_dump_mtx);
+}
+
+void
+prof_tdata_cleanup(tsd_t *tsd)
+{
+	prof_tdata_t *tdata;
+
+	if (!config_prof)
+		return;
+
+	tdata = tsd_prof_tdata_get(tsd);
+	if (tdata != NULL)
+		prof_tdata_detach(tsd, tdata);
+}
+
+bool
+prof_active_get(void)
+{
+	bool prof_active_current;
+
+	malloc_mutex_lock(&prof_active_mtx);
+	prof_active_current = prof_active;
+	malloc_mutex_unlock(&prof_active_mtx);
+	return (prof_active_current);
+}
+
+bool
+prof_active_set(bool active)
+{
+	bool prof_active_old;
+
+	malloc_mutex_lock(&prof_active_mtx);
+	prof_active_old = prof_active;
+	prof_active = active;
+	malloc_mutex_unlock(&prof_active_mtx);
+	return (prof_active_old);
+}
+
+const char *
+prof_thread_name_get(void)
+{
+	tsd_t *tsd;
+	prof_tdata_t *tdata;
+
+	tsd = tsd_fetch();
+	tdata = prof_tdata_get(tsd, true);
+	if (tdata == NULL)
+		return ("");
+	return (tdata->thread_name != NULL ? tdata->thread_name : "");
+}
+
+static char *
+prof_thread_name_alloc(tsd_t *tsd, const char *thread_name)
+{
+	char *ret;
+	size_t size;
+
+	if (thread_name == NULL)
+		return (NULL);
+
+	size = strlen(thread_name) + 1;
+	if (size == 1)
+		return ("");
+
+	ret = iallocztm(tsd, size, false, tcache_get(tsd, true), true, NULL);
+	if (ret == NULL)
+		return (NULL);
+	memcpy(ret, thread_name, size);
+	return (ret);
+}
+
+int
+prof_thread_name_set(tsd_t *tsd, const char *thread_name)
+{
+	prof_tdata_t *tdata;
+	unsigned i;
+	char *s;
+
+	tdata = prof_tdata_get(tsd, true);
+	if (tdata == NULL)
+		return (EAGAIN);
+
+	/* Validate input. */
+	if (thread_name == NULL)
+		return (EFAULT);
+	for (i = 0; thread_name[i] != '\0'; i++) {
+		char c = thread_name[i];
+		if (!isgraph(c) && !isblank(c))
+			return (EFAULT);
+	}
+
+	s = prof_thread_name_alloc(tsd, thread_name);
+	if (s == NULL)
+		return (EAGAIN);
+
+	if (tdata->thread_name != NULL) {
+		idalloctm(tsd, tdata->thread_name, tcache_get(tsd, false),
+		    true);
+		tdata->thread_name = NULL;
+	}
+	if (strlen(s) > 0)
+		tdata->thread_name = s;
+	return (0);
+}
+
+bool
+prof_thread_active_get(void)
+{
+	tsd_t *tsd;
+	prof_tdata_t *tdata;
+
+	tsd = tsd_fetch();
+	tdata = prof_tdata_get(tsd, true);
+	if (tdata == NULL)
+		return (false);
+	return (tdata->active);
+}
+
+bool
+prof_thread_active_set(bool active)
+{
+	tsd_t *tsd;
+	prof_tdata_t *tdata;
+
+	tsd = tsd_fetch();
+	tdata = prof_tdata_get(tsd, true);
+	if (tdata == NULL)
+		return (true);
+	tdata->active = active;
+	return (false);
+}
+
+bool
+prof_thread_active_init_get(void)
+{
+	bool active_init;
+
+	malloc_mutex_lock(&prof_thread_active_init_mtx);
+	active_init = prof_thread_active_init;
+	malloc_mutex_unlock(&prof_thread_active_init_mtx);
+	return (active_init);
+}
+
+bool
+prof_thread_active_init_set(bool active_init)
+{
+	bool active_init_old;
+
+	malloc_mutex_lock(&prof_thread_active_init_mtx);
+	active_init_old = prof_thread_active_init;
+	prof_thread_active_init = active_init;
+	malloc_mutex_unlock(&prof_thread_active_init_mtx);
+	return (active_init_old);
+}
+
+bool
+prof_gdump_get(void)
+{
+	bool prof_gdump_current;
+
+	malloc_mutex_lock(&prof_gdump_mtx);
+	prof_gdump_current = prof_gdump_val;
+	malloc_mutex_unlock(&prof_gdump_mtx);
+	return (prof_gdump_current);
+}
+
+bool
+prof_gdump_set(bool gdump)
+{
+	bool prof_gdump_old;
+
+	malloc_mutex_lock(&prof_gdump_mtx);
+	prof_gdump_old = prof_gdump_val;
+	prof_gdump_val = gdump;
+	malloc_mutex_unlock(&prof_gdump_mtx);
+	return (prof_gdump_old);
 }
 
 void
 prof_boot0(void)
 {
 
@@ -1297,70 +2075,97 @@
 prof_boot1(void)
 {
 
 	cassert(config_prof);
 
 	/*
-	 * opt_prof and prof_promote must be in their final state before any
-	 * arenas are initialized, so this function must be executed early.
+	 * opt_prof must be in its final state before any arenas are
+	 * initialized, so this function must be executed early.
 	 */
 
-	if (opt_prof_leak && opt_prof == false) {
+	if (opt_prof_leak && !opt_prof) {
 		/*
 		 * Enable opt_prof, but in such a way that profiles are never
 		 * automatically dumped.
 		 */
 		opt_prof = true;
 		opt_prof_gdump = false;
 	} else if (opt_prof) {
 		if (opt_lg_prof_interval >= 0) {
 			prof_interval = (((uint64_t)1U) <<
 			    opt_lg_prof_interval);
 		}
 	}
-
-	prof_promote = (opt_prof && opt_lg_prof_sample > LG_PAGE);
 }
 
 bool
 prof_boot2(void)
 {
 
 	cassert(config_prof);
 
 	if (opt_prof) {
+		tsd_t *tsd;
 		unsigned i;
 
-		if (ckh_new(&bt2ctx, PROF_CKH_MINITEMS, prof_bt_hash,
+		lg_prof_sample = opt_lg_prof_sample;
+
+		prof_active = opt_prof_active;
+		if (malloc_mutex_init(&prof_active_mtx))
+			return (true);
+
+		prof_gdump_val = opt_prof_gdump;
+		if (malloc_mutex_init(&prof_gdump_mtx))
+			return (true);
+
+		prof_thread_active_init = opt_prof_thread_active_init;
+		if (malloc_mutex_init(&prof_thread_active_init_mtx))
+			return (true);
+
+		tsd = tsd_fetch();
+		if (ckh_new(tsd, &bt2gctx, PROF_CKH_MINITEMS, prof_bt_hash,
 		    prof_bt_keycomp))
 			return (true);
-		if (malloc_mutex_init(&bt2ctx_mtx))
+		if (malloc_mutex_init(&bt2gctx_mtx))
+			return (true);
+
+		tdata_tree_new(&tdatas);
+		if (malloc_mutex_init(&tdatas_mtx))
+			return (true);
+
+		next_thr_uid = 0;
+		if (malloc_mutex_init(&next_thr_uid_mtx))
 			return (true);
-		if (prof_tdata_tsd_boot()) {
-			malloc_write(
-			    "<jemalloc>: Error in pthread_key_create()\n");
-			abort();
-		}
 
 		if (malloc_mutex_init(&prof_dump_seq_mtx))
 			return (true);
 		if (malloc_mutex_init(&prof_dump_mtx))
 			return (true);
 
-		if (atexit(prof_fdump) != 0) {
+		if (opt_prof_final && opt_prof_prefix[0] != '\0' &&
+		    atexit(prof_fdump) != 0) {
 			malloc_write("<jemalloc>: Error in atexit()\n");
 			if (opt_abort)
 				abort();
 		}
 
-		ctx_locks = (malloc_mutex_t *)base_alloc(PROF_NCTX_LOCKS *
+		gctx_locks = (malloc_mutex_t *)base_alloc(PROF_NCTX_LOCKS *
 		    sizeof(malloc_mutex_t));
-		if (ctx_locks == NULL)
+		if (gctx_locks == NULL)
 			return (true);
 		for (i = 0; i < PROF_NCTX_LOCKS; i++) {
-			if (malloc_mutex_init(&ctx_locks[i]))
+			if (malloc_mutex_init(&gctx_locks[i]))
+				return (true);
+		}
+
+		tdata_locks = (malloc_mutex_t *)base_alloc(PROF_NTDATA_LOCKS *
+		    sizeof(malloc_mutex_t));
+		if (tdata_locks == NULL)
+			return (true);
+		for (i = 0; i < PROF_NTDATA_LOCKS; i++) {
+			if (malloc_mutex_init(&tdata_locks[i]))
 				return (true);
 		}
 	}
 
 #ifdef JEMALLOC_PROF_LIBGCC
 	/*
@@ -1379,42 +2184,54 @@
 prof_prefork(void)
 {
 
 	if (opt_prof) {
 		unsigned i;
 
-		malloc_mutex_prefork(&bt2ctx_mtx);
+		malloc_mutex_prefork(&tdatas_mtx);
+		malloc_mutex_prefork(&bt2gctx_mtx);
+		malloc_mutex_prefork(&next_thr_uid_mtx);
 		malloc_mutex_prefork(&prof_dump_seq_mtx);
 		for (i = 0; i < PROF_NCTX_LOCKS; i++)
-			malloc_mutex_prefork(&ctx_locks[i]);
+			malloc_mutex_prefork(&gctx_locks[i]);
+		for (i = 0; i < PROF_NTDATA_LOCKS; i++)
+			malloc_mutex_prefork(&tdata_locks[i]);
 	}
 }
 
 void
 prof_postfork_parent(void)
 {
 
 	if (opt_prof) {
 		unsigned i;
 
+		for (i = 0; i < PROF_NTDATA_LOCKS; i++)
+			malloc_mutex_postfork_parent(&tdata_locks[i]);
 		for (i = 0; i < PROF_NCTX_LOCKS; i++)
-			malloc_mutex_postfork_parent(&ctx_locks[i]);
+			malloc_mutex_postfork_parent(&gctx_locks[i]);
 		malloc_mutex_postfork_parent(&prof_dump_seq_mtx);
-		malloc_mutex_postfork_parent(&bt2ctx_mtx);
+		malloc_mutex_postfork_parent(&next_thr_uid_mtx);
+		malloc_mutex_postfork_parent(&bt2gctx_mtx);
+		malloc_mutex_postfork_parent(&tdatas_mtx);
 	}
 }
 
 void
 prof_postfork_child(void)
 {
 
 	if (opt_prof) {
 		unsigned i;
 
+		for (i = 0; i < PROF_NTDATA_LOCKS; i++)
+			malloc_mutex_postfork_child(&tdata_locks[i]);
 		for (i = 0; i < PROF_NCTX_LOCKS; i++)
-			malloc_mutex_postfork_child(&ctx_locks[i]);
+			malloc_mutex_postfork_child(&gctx_locks[i]);
 		malloc_mutex_postfork_child(&prof_dump_seq_mtx);
-		malloc_mutex_postfork_child(&bt2ctx_mtx);
+		malloc_mutex_postfork_child(&next_thr_uid_mtx);
+		malloc_mutex_postfork_child(&bt2gctx_mtx);
+		malloc_mutex_postfork_child(&tdatas_mtx);
 	}
 }
 
 /******************************************************************************/
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.d	2017-09-27 22:47:58.842963268 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.d	2017-09-27 22:49:22.142960215 +0800
@@ -1,20 +1,21 @@
 src/prof.o: src/prof.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,58 +1,74 @@
 #define	JEMALLOC_QUARANTINE_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /*
- * quarantine pointers close to NULL are used to encode state information that
+ * Quarantine pointers close to NULL are used to encode state information that
  * is used for cleaning up during thread shutdown.
  */
 #define	QUARANTINE_STATE_REINCARNATED	((quarantine_t *)(uintptr_t)1)
 #define	QUARANTINE_STATE_PURGATORY	((quarantine_t *)(uintptr_t)2)
 #define	QUARANTINE_STATE_MAX		QUARANTINE_STATE_PURGATORY
 
 /******************************************************************************/
-/* Data. */
-
-malloc_tsd_data(, quarantine, quarantine_t *, NULL)
-
-/******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
-static quarantine_t	*quarantine_grow(quarantine_t *quarantine);
-static void	quarantine_drain_one(quarantine_t *quarantine);
-static void	quarantine_drain(quarantine_t *quarantine, size_t upper_bound);
+static quarantine_t	*quarantine_grow(tsd_t *tsd, quarantine_t *quarantine);
+static void	quarantine_drain_one(tsd_t *tsd, quarantine_t *quarantine);
+static void	quarantine_drain(tsd_t *tsd, quarantine_t *quarantine,
+    size_t upper_bound);
 
 /******************************************************************************/
 
-quarantine_t *
-quarantine_init(size_t lg_maxobjs)
+static quarantine_t *
+quarantine_init(tsd_t *tsd, size_t lg_maxobjs)
 {
 	quarantine_t *quarantine;
 
-	quarantine = (quarantine_t *)imalloc(offsetof(quarantine_t, objs) +
-	    ((ZU(1) << lg_maxobjs) * sizeof(quarantine_obj_t)));
+	assert(tsd_nominal(tsd));
+
+	quarantine = (quarantine_t *)iallocztm(tsd, offsetof(quarantine_t, objs)
+	    + ((ZU(1) << lg_maxobjs) * sizeof(quarantine_obj_t)), false,
+	    tcache_get(tsd, true), true, NULL);
 	if (quarantine == NULL)
 		return (NULL);
 	quarantine->curbytes = 0;
 	quarantine->curobjs = 0;
 	quarantine->first = 0;
 	quarantine->lg_maxobjs = lg_maxobjs;
 
-	quarantine_tsd_set(&quarantine);
-
 	return (quarantine);
 }
 
+void
+quarantine_alloc_hook_work(tsd_t *tsd)
+{
+	quarantine_t *quarantine;
+
+	if (!tsd_nominal(tsd))
+		return;
+
+	quarantine = quarantine_init(tsd, LG_MAXOBJS_INIT);
+	/*
+	 * Check again whether quarantine has been initialized, because
+	 * quarantine_init() may have triggered recursive initialization.
+	 */
+	if (tsd_quarantine_get(tsd) == NULL)
+		tsd_quarantine_set(tsd, quarantine);
+	else
+		idalloctm(tsd, quarantine, tcache_get(tsd, false), true);
+}
+
 static quarantine_t *
-quarantine_grow(quarantine_t *quarantine)
+quarantine_grow(tsd_t *tsd, quarantine_t *quarantine)
 {
 	quarantine_t *ret;
 
-	ret = quarantine_init(quarantine->lg_maxobjs + 1);
+	ret = quarantine_init(tsd, quarantine->lg_maxobjs + 1);
 	if (ret == NULL) {
-		quarantine_drain_one(quarantine);
+		quarantine_drain_one(tsd, quarantine);
 		return (quarantine);
 	}
 
 	ret->curbytes = quarantine->curbytes;
 	ret->curobjs = quarantine->curobjs;
 	if (quarantine->first + quarantine->curobjs <= (ZU(1) <<
@@ -68,132 +84,100 @@
 
 		memcpy(ret->objs, &quarantine->objs[quarantine->first], ncopy_a
 		    * sizeof(quarantine_obj_t));
 		memcpy(&ret->objs[ncopy_a], quarantine->objs, ncopy_b *
 		    sizeof(quarantine_obj_t));
 	}
-	idalloc(quarantine);
+	idalloctm(tsd, quarantine, tcache_get(tsd, false), true);
 
+	tsd_quarantine_set(tsd, ret);
 	return (ret);
 }
 
 static void
-quarantine_drain_one(quarantine_t *quarantine)
+quarantine_drain_one(tsd_t *tsd, quarantine_t *quarantine)
 {
 	quarantine_obj_t *obj = &quarantine->objs[quarantine->first];
 	assert(obj->usize == isalloc(obj->ptr, config_prof));
-	idalloc(obj->ptr);
+	idalloctm(tsd, obj->ptr, NULL, false);
 	quarantine->curbytes -= obj->usize;
 	quarantine->curobjs--;
 	quarantine->first = (quarantine->first + 1) & ((ZU(1) <<
 	    quarantine->lg_maxobjs) - 1);
 }
 
 static void
-quarantine_drain(quarantine_t *quarantine, size_t upper_bound)
+quarantine_drain(tsd_t *tsd, quarantine_t *quarantine, size_t upper_bound)
 {
 
 	while (quarantine->curbytes > upper_bound && quarantine->curobjs > 0)
-		quarantine_drain_one(quarantine);
+		quarantine_drain_one(tsd, quarantine);
 }
 
 void
-quarantine(void *ptr)
+quarantine(tsd_t *tsd, void *ptr)
 {
 	quarantine_t *quarantine;
 	size_t usize = isalloc(ptr, config_prof);
 
 	cassert(config_fill);
 	assert(opt_quarantine);
 
-	quarantine = *quarantine_tsd_get();
-	if ((uintptr_t)quarantine <= (uintptr_t)QUARANTINE_STATE_MAX) {
-		if (quarantine == QUARANTINE_STATE_PURGATORY) {
-			/*
-			 * Make a note that quarantine() was called after
-			 * quarantine_cleanup() was called.
-			 */
-			quarantine = QUARANTINE_STATE_REINCARNATED;
-			quarantine_tsd_set(&quarantine);
-		}
-		idalloc(ptr);
+	if ((quarantine = tsd_quarantine_get(tsd)) == NULL) {
+		idalloctm(tsd, ptr, NULL, false);
 		return;
 	}
 	/*
 	 * Drain one or more objects if the quarantine size limit would be
 	 * exceeded by appending ptr.
 	 */
 	if (quarantine->curbytes + usize > opt_quarantine) {
 		size_t upper_bound = (opt_quarantine >= usize) ? opt_quarantine
 		    - usize : 0;
-		quarantine_drain(quarantine, upper_bound);
+		quarantine_drain(tsd, quarantine, upper_bound);
 	}
 	/* Grow the quarantine ring buffer if it's full. */
 	if (quarantine->curobjs == (ZU(1) << quarantine->lg_maxobjs))
-		quarantine = quarantine_grow(quarantine);
+		quarantine = quarantine_grow(tsd, quarantine);
 	/* quarantine_grow() must free a slot if it fails to grow. */
 	assert(quarantine->curobjs < (ZU(1) << quarantine->lg_maxobjs));
 	/* Append ptr if its size doesn't exceed the quarantine size. */
 	if (quarantine->curbytes + usize <= opt_quarantine) {
 		size_t offset = (quarantine->first + quarantine->curobjs) &
 		    ((ZU(1) << quarantine->lg_maxobjs) - 1);
 		quarantine_obj_t *obj = &quarantine->objs[offset];
 		obj->ptr = ptr;
 		obj->usize = usize;
 		quarantine->curbytes += usize;
 		quarantine->curobjs++;
-		if (config_fill && opt_junk) {
+		if (config_fill && unlikely(opt_junk_free)) {
 			/*
 			 * Only do redzone validation if Valgrind isn't in
 			 * operation.
 			 */
-			if ((config_valgrind == false || opt_valgrind == false)
+			if ((!config_valgrind || likely(!in_valgrind))
 			    && usize <= SMALL_MAXCLASS)
 				arena_quarantine_junk_small(ptr, usize);
 			else
 				memset(ptr, 0x5a, usize);
 		}
 	} else {
 		assert(quarantine->curbytes == 0);
-		idalloc(ptr);
+		idalloctm(tsd, ptr, NULL, false);
 	}
 }
 
 void
-quarantine_cleanup(void *arg)
-{
-	quarantine_t *quarantine = *(quarantine_t **)arg;
-
-	if (quarantine == QUARANTINE_STATE_REINCARNATED) {
-		/*
-		 * Another destructor deallocated memory after this destructor
-		 * was called.  Reset quarantine to QUARANTINE_STATE_PURGATORY
-		 * in order to receive another callback.
-		 */
-		quarantine = QUARANTINE_STATE_PURGATORY;
-		quarantine_tsd_set(&quarantine);
-	} else if (quarantine == QUARANTINE_STATE_PURGATORY) {
-		/*
-		 * The previous time this destructor was called, we set the key
-		 * to QUARANTINE_STATE_PURGATORY so that other destructors
-		 * wouldn't cause re-creation of the quarantine.  This time, do
-		 * nothing, so that the destructor will not be called again.
-		 */
-	} else if (quarantine != NULL) {
-		quarantine_drain(quarantine, 0);
-		idalloc(quarantine);
-		quarantine = QUARANTINE_STATE_PURGATORY;
-		quarantine_tsd_set(&quarantine);
-	}
-}
-
-bool
-quarantine_boot(void)
+quarantine_cleanup(tsd_t *tsd)
 {
+	quarantine_t *quarantine;
 
-	cassert(config_fill);
-
-	if (quarantine_tsd_boot())
-		return (true);
+	if (!config_fill)
+		return;
 
-	return (false);
+	quarantine = tsd_quarantine_get(tsd);
+	if (quarantine != NULL) {
+		quarantine_drain(tsd, quarantine, 0);
+		idalloctm(tsd, quarantine, tcache_get(tsd, false), true);
+		tsd_quarantine_set(tsd, NULL);
+	}
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.d	2017-09-27 22:47:59.114963258 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.d	2017-09-27 22:49:22.390960206 +0800
@@ -1,21 +1,22 @@
 src/quarantine.o: src/quarantine.c \
  include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,105 +1,127 @@
 #define	JEMALLOC_RTREE_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
-rtree_t *
-rtree_new(unsigned bits, rtree_alloc_t *alloc, rtree_dalloc_t *dalloc)
+static unsigned
+hmin(unsigned ha, unsigned hb)
 {
-	rtree_t *ret;
-	unsigned bits_per_level, bits_in_leaf, height, i;
+
+	return (ha < hb ? ha : hb);
+}
+
+/* Only the most significant bits of keys passed to rtree_[gs]et() are used. */
+bool
+rtree_new(rtree_t *rtree, unsigned bits, rtree_node_alloc_t *alloc,
+    rtree_node_dalloc_t *dalloc)
+{
+	unsigned bits_in_leaf, height, i;
 
 	assert(bits > 0 && bits <= (sizeof(uintptr_t) << 3));
 
-	bits_per_level = ffs(pow2_ceil((RTREE_NODESIZE / sizeof(void *)))) - 1;
-	bits_in_leaf = ffs(pow2_ceil((RTREE_NODESIZE / sizeof(uint8_t)))) - 1;
+	bits_in_leaf = (bits % RTREE_BITS_PER_LEVEL) == 0 ? RTREE_BITS_PER_LEVEL
+	    : (bits % RTREE_BITS_PER_LEVEL);
 	if (bits > bits_in_leaf) {
-		height = 1 + (bits - bits_in_leaf) / bits_per_level;
-		if ((height-1) * bits_per_level + bits_in_leaf != bits)
+		height = 1 + (bits - bits_in_leaf) / RTREE_BITS_PER_LEVEL;
+		if ((height-1) * RTREE_BITS_PER_LEVEL + bits_in_leaf != bits)
 			height++;
-	} else {
+	} else
 		height = 1;
-	}
-	assert((height-1) * bits_per_level + bits_in_leaf >= bits);
+	assert((height-1) * RTREE_BITS_PER_LEVEL + bits_in_leaf == bits);
 
-	ret = (rtree_t*)alloc(offsetof(rtree_t, level2bits) +
-	    (sizeof(unsigned) * height));
-	if (ret == NULL)
-		return (NULL);
-	memset(ret, 0, offsetof(rtree_t, level2bits) + (sizeof(unsigned) *
-	    height));
-
-	ret->alloc = alloc;
-	ret->dalloc = dalloc;
-	if (malloc_mutex_init(&ret->mutex)) {
-		if (dalloc != NULL)
-			dalloc(ret);
-		return (NULL);
+	rtree->alloc = alloc;
+	rtree->dalloc = dalloc;
+	rtree->height = height;
+
+	/* Root level. */
+	rtree->levels[0].subtree = NULL;
+	rtree->levels[0].bits = (height > 1) ? RTREE_BITS_PER_LEVEL :
+	    bits_in_leaf;
+	rtree->levels[0].cumbits = rtree->levels[0].bits;
+	/* Interior levels. */
+	for (i = 1; i < height-1; i++) {
+		rtree->levels[i].subtree = NULL;
+		rtree->levels[i].bits = RTREE_BITS_PER_LEVEL;
+		rtree->levels[i].cumbits = rtree->levels[i-1].cumbits +
+		    RTREE_BITS_PER_LEVEL;
 	}
-	ret->height = height;
+	/* Leaf level. */
 	if (height > 1) {
-		if ((height-1) * bits_per_level + bits_in_leaf > bits) {
-			ret->level2bits[0] = (bits - bits_in_leaf) %
-			    bits_per_level;
-		} else
-			ret->level2bits[0] = bits_per_level;
-		for (i = 1; i < height-1; i++)
-			ret->level2bits[i] = bits_per_level;
-		ret->level2bits[height-1] = bits_in_leaf;
-	} else
-		ret->level2bits[0] = bits;
+		rtree->levels[height-1].subtree = NULL;
+		rtree->levels[height-1].bits = bits_in_leaf;
+		rtree->levels[height-1].cumbits = bits;
+	}
 
-	ret->root = (void**)alloc(sizeof(void *) << ret->level2bits[0]);
-	if (ret->root == NULL) {
-		if (dalloc != NULL)
-			dalloc(ret);
-		return (NULL);
+	/* Compute lookup table to be used by rtree_start_level(). */
+	for (i = 0; i < RTREE_HEIGHT_MAX; i++) {
+		rtree->start_level[i] = hmin(RTREE_HEIGHT_MAX - 1 - i, height -
+		    1);
 	}
-	memset(ret->root, 0, sizeof(void *) << ret->level2bits[0]);
 
-	return (ret);
+	return (false);
 }
 
 static void
-rtree_delete_subtree(rtree_t *rtree, void **node, unsigned level)
+rtree_delete_subtree(rtree_t *rtree, rtree_node_elm_t *node, unsigned level)
 {
 
-	if (level < rtree->height - 1) {
+	if (level + 1 < rtree->height) {
 		size_t nchildren, i;
 
-		nchildren = ZU(1) << rtree->level2bits[level];
+		nchildren = ZU(1) << rtree->levels[level].bits;
 		for (i = 0; i < nchildren; i++) {
-			void **child = (void **)node[i];
+			rtree_node_elm_t *child = node[i].child;
 			if (child != NULL)
 				rtree_delete_subtree(rtree, child, level + 1);
 		}
 	}
 	rtree->dalloc(node);
 }
 
 void
 rtree_delete(rtree_t *rtree)
 {
+	unsigned i;
 
-	rtree_delete_subtree(rtree, rtree->root, 0);
-	rtree->dalloc(rtree);
+	for (i = 0; i < rtree->height; i++) {
+		rtree_node_elm_t *subtree = rtree->levels[i].subtree;
+		if (subtree != NULL)
+			rtree_delete_subtree(rtree, subtree, i);
+	}
 }
 
-void
-rtree_prefork(rtree_t *rtree)
+static rtree_node_elm_t *
+rtree_node_init(rtree_t *rtree, unsigned level, rtree_node_elm_t **elmp)
 {
+	rtree_node_elm_t *node;
+
+	if (atomic_cas_p((void **)elmp, NULL, RTREE_NODE_INITIALIZING)) {
+		/*
+		 * Another thread is already in the process of initializing.
+		 * Spin-wait until initialization is complete.
+		 */
+		do {
+			CPU_SPINWAIT;
+			node = atomic_read_p((void **)elmp);
+		} while (node == RTREE_NODE_INITIALIZING);
+	} else {
+		node = rtree->alloc(ZU(1) << rtree->levels[level].bits);
+		if (node == NULL)
+			return (NULL);
+		atomic_write_p((void **)elmp, node);
+	}
 
-	malloc_mutex_prefork(&rtree->mutex);
+	return (node);
 }
 
-void
-rtree_postfork_parent(rtree_t *rtree)
+rtree_node_elm_t *
+rtree_subtree_read_hard(rtree_t *rtree, unsigned level)
 {
 
-	malloc_mutex_postfork_parent(&rtree->mutex);
+	return (rtree_node_init(rtree, level, &rtree->levels[level].subtree));
 }
 
-void
-rtree_postfork_child(rtree_t *rtree)
+rtree_node_elm_t *
+rtree_child_read_hard(rtree_t *rtree, rtree_node_elm_t *elm, unsigned level)
 {
 
-	malloc_mutex_postfork_child(&rtree->mutex);
+	return (rtree_node_init(rtree, level, &elm->child));
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.d	2017-09-27 22:47:59.274963252 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.d	2017-09-27 22:49:22.558960200 +0800
@@ -1,20 +1,21 @@
 src/rtree.o: src/rtree.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.c	2016-05-06 15:11:36.000000000 +0800
@@ -3,37 +3,28 @@
 
 #define	CTL_GET(n, v, t) do {						\
 	size_t sz = sizeof(t);						\
 	xmallctl(n, v, &sz, NULL, 0);					\
 } while (0)
 
-#define	CTL_I_GET(n, v, t) do {						\
+#define	CTL_M2_GET(n, i, v, t) do {					\
 	size_t mib[6];							\
 	size_t miblen = sizeof(mib) / sizeof(size_t);			\
 	size_t sz = sizeof(t);						\
 	xmallctlnametomib(n, mib, &miblen);				\
-	mib[2] = i;							\
+	mib[2] = (i);							\
 	xmallctlbymib(mib, miblen, v, &sz, NULL, 0);			\
 } while (0)
 
-#define	CTL_J_GET(n, v, t) do {						\
+#define	CTL_M2_M4_GET(n, i, j, v, t) do {				\
 	size_t mib[6];							\
 	size_t miblen = sizeof(mib) / sizeof(size_t);			\
 	size_t sz = sizeof(t);						\
 	xmallctlnametomib(n, mib, &miblen);				\
-	mib[2] = j;							\
-	xmallctlbymib(mib, miblen, v, &sz, NULL, 0);			\
-} while (0)
-
-#define	CTL_IJ_GET(n, v, t) do {					\
-	size_t mib[6];							\
-	size_t miblen = sizeof(mib) / sizeof(size_t);			\
-	size_t sz = sizeof(t);						\
-	xmallctlnametomib(n, mib, &miblen);				\
-	mib[2] = i;							\
-	mib[4] = j;							\
+	mib[2] = (i);							\
+	mib[4] = (j);							\
 	xmallctlbymib(mib, miblen, v, &sz, NULL, 0);			\
 } while (0)
 
 /******************************************************************************/
 /* Data. */
 
@@ -45,227 +36,327 @@
 /* Function prototypes for non-inline static functions. */
 
 static void	stats_arena_bins_print(void (*write_cb)(void *, const char *),
     void *cbopaque, unsigned i);
 static void	stats_arena_lruns_print(void (*write_cb)(void *, const char *),
     void *cbopaque, unsigned i);
+static void	stats_arena_hchunks_print(
+    void (*write_cb)(void *, const char *), void *cbopaque, unsigned i);
 static void	stats_arena_print(void (*write_cb)(void *, const char *),
-    void *cbopaque, unsigned i, bool bins, bool large);
+    void *cbopaque, unsigned i, bool bins, bool large, bool huge);
 
 /******************************************************************************/
 
 static void
 stats_arena_bins_print(void (*write_cb)(void *, const char *), void *cbopaque,
     unsigned i)
 {
 	size_t page;
-	bool config_tcache;
-	unsigned nbins, j, gap_start;
+	bool config_tcache, in_gap;
+	unsigned nbins, j;
 
 	CTL_GET("arenas.page", &page, size_t);
 
 	CTL_GET("config.tcache", &config_tcache, bool);
 	if (config_tcache) {
 		malloc_cprintf(write_cb, cbopaque,
-		    "bins:     bin  size regs pgs    allocated      nmalloc"
-		    "      ndalloc    nrequests       nfills     nflushes"
-		    "      newruns       reruns      curruns\n");
+		    "bins:           size ind    allocated      nmalloc"
+		    "      ndalloc    nrequests      curregs      curruns regs"
+		    " pgs  util       nfills     nflushes      newruns"
+		    "       reruns\n");
 	} else {
 		malloc_cprintf(write_cb, cbopaque,
-		    "bins:     bin  size regs pgs    allocated      nmalloc"
-		    "      ndalloc      newruns       reruns      curruns\n");
+		    "bins:           size ind    allocated      nmalloc"
+		    "      ndalloc    nrequests      curregs      curruns regs"
+		    " pgs  util      newruns       reruns\n");
 	}
 	CTL_GET("arenas.nbins", &nbins, unsigned);
-	for (j = 0, gap_start = UINT_MAX; j < nbins; j++) {
+	for (j = 0, in_gap = false; j < nbins; j++) {
 		uint64_t nruns;
 
-		CTL_IJ_GET("stats.arenas.0.bins.0.nruns", &nruns, uint64_t);
-		if (nruns == 0) {
-			if (gap_start == UINT_MAX)
-				gap_start = j;
-		} else {
-			size_t reg_size, run_size, allocated;
+		CTL_M2_M4_GET("stats.arenas.0.bins.0.nruns", i, j, &nruns,
+		    uint64_t);
+		if (nruns == 0)
+			in_gap = true;
+		else {
+			size_t reg_size, run_size, curregs, availregs, milli;
+			size_t curruns;
 			uint32_t nregs;
 			uint64_t nmalloc, ndalloc, nrequests, nfills, nflushes;
 			uint64_t reruns;
-			size_t curruns;
+			char util[6]; /* "x.yyy". */
 
-			if (gap_start != UINT_MAX) {
-				if (j > gap_start + 1) {
-					/* Gap of more than one size class. */
-					malloc_cprintf(write_cb, cbopaque,
-					    "[%u..%u]\n", gap_start,
-					    j - 1);
-				} else {
-					/* Gap of one size class. */
-					malloc_cprintf(write_cb, cbopaque,
-					    "[%u]\n", gap_start);
-				}
-				gap_start = UINT_MAX;
+			if (in_gap) {
+				malloc_cprintf(write_cb, cbopaque,
+				    "                     ---\n");
+				in_gap = false;
 			}
-			CTL_J_GET("arenas.bin.0.size", &reg_size, size_t);
-			CTL_J_GET("arenas.bin.0.nregs", &nregs, uint32_t);
-			CTL_J_GET("arenas.bin.0.run_size", &run_size, size_t);
-			CTL_IJ_GET("stats.arenas.0.bins.0.allocated",
-			    &allocated, size_t);
-			CTL_IJ_GET("stats.arenas.0.bins.0.nmalloc",
+			CTL_M2_GET("arenas.bin.0.size", j, &reg_size, size_t);
+			CTL_M2_GET("arenas.bin.0.nregs", j, &nregs, uint32_t);
+			CTL_M2_GET("arenas.bin.0.run_size", j, &run_size,
+			    size_t);
+			CTL_M2_M4_GET("stats.arenas.0.bins.0.nmalloc", i, j,
 			    &nmalloc, uint64_t);
-			CTL_IJ_GET("stats.arenas.0.bins.0.ndalloc",
+			CTL_M2_M4_GET("stats.arenas.0.bins.0.ndalloc", i, j,
 			    &ndalloc, uint64_t);
+			CTL_M2_M4_GET("stats.arenas.0.bins.0.curregs", i, j,
+			    &curregs, size_t);
+			CTL_M2_M4_GET("stats.arenas.0.bins.0.nrequests", i, j,
+			    &nrequests, uint64_t);
 			if (config_tcache) {
-				CTL_IJ_GET("stats.arenas.0.bins.0.nrequests",
-				    &nrequests, uint64_t);
-				CTL_IJ_GET("stats.arenas.0.bins.0.nfills",
-				    &nfills, uint64_t);
-				CTL_IJ_GET("stats.arenas.0.bins.0.nflushes",
-				    &nflushes, uint64_t);
+				CTL_M2_M4_GET("stats.arenas.0.bins.0.nfills", i,
+				    j, &nfills, uint64_t);
+				CTL_M2_M4_GET("stats.arenas.0.bins.0.nflushes",
+				    i, j, &nflushes, uint64_t);
 			}
-			CTL_IJ_GET("stats.arenas.0.bins.0.nreruns", &reruns,
-			    uint64_t);
-			CTL_IJ_GET("stats.arenas.0.bins.0.curruns", &curruns,
-			    size_t);
+			CTL_M2_M4_GET("stats.arenas.0.bins.0.nreruns", i, j,
+			    &reruns, uint64_t);
+			CTL_M2_M4_GET("stats.arenas.0.bins.0.curruns", i, j,
+			    &curruns, size_t);
+
+			availregs = nregs * curruns;
+			milli = (availregs != 0) ? (1000 * curregs) / availregs
+			    : 1000;
+			assert(milli <= 1000);
+			if (milli < 10) {
+				malloc_snprintf(util, sizeof(util),
+				    "0.00%zu", milli);
+			} else if (milli < 100) {
+				malloc_snprintf(util, sizeof(util), "0.0%zu",
+				    milli);
+			} else if (milli < 1000) {
+				malloc_snprintf(util, sizeof(util), "0.%zu",
+				    milli);
+			} else
+				malloc_snprintf(util, sizeof(util), "1");
+
 			if (config_tcache) {
 				malloc_cprintf(write_cb, cbopaque,
-				    "%13u %5zu %4u %3zu %12zu %12"PRIu64
-				    " %12"PRIu64" %12"PRIu64" %12"PRIu64
-				    " %12"PRIu64" %12"PRIu64" %12"PRIu64
-				    " %12zu\n",
-				    j, reg_size, nregs, run_size / page,
-				    allocated, nmalloc, ndalloc, nrequests,
-				    nfills, nflushes, nruns, reruns, curruns);
+				    "%20zu %3u %12zu %12"FMTu64
+				    " %12"FMTu64" %12"FMTu64" %12zu"
+				    " %12zu %4u %3zu %-5s %12"FMTu64
+				    " %12"FMTu64" %12"FMTu64" %12"FMTu64"\n",
+				    reg_size, j, curregs * reg_size, nmalloc,
+				    ndalloc, nrequests, curregs, curruns, nregs,
+				    run_size / page, util, nfills, nflushes,
+				    nruns, reruns);
 			} else {
 				malloc_cprintf(write_cb, cbopaque,
-				    "%13u %5zu %4u %3zu %12zu %12"PRIu64
-				    " %12"PRIu64" %12"PRIu64" %12"PRIu64
-				    " %12zu\n",
-				    j, reg_size, nregs, run_size / page,
-				    allocated, nmalloc, ndalloc, nruns, reruns,
-				    curruns);
+				    "%20zu %3u %12zu %12"FMTu64
+				    " %12"FMTu64" %12"FMTu64" %12zu"
+				    " %12zu %4u %3zu %-5s %12"FMTu64
+				    " %12"FMTu64"\n",
+				    reg_size, j, curregs * reg_size, nmalloc,
+				    ndalloc, nrequests, curregs, curruns, nregs,
+				    run_size / page, util, nruns, reruns);
 			}
 		}
 	}
-	if (gap_start != UINT_MAX) {
-		if (j > gap_start + 1) {
-			/* Gap of more than one size class. */
-			malloc_cprintf(write_cb, cbopaque, "[%u..%u]\n",
-			    gap_start, j - 1);
-		} else {
-			/* Gap of one size class. */
-			malloc_cprintf(write_cb, cbopaque, "[%u]\n", gap_start);
-		}
+	if (in_gap) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "                     ---\n");
 	}
 }
 
 static void
 stats_arena_lruns_print(void (*write_cb)(void *, const char *), void *cbopaque,
     unsigned i)
 {
-	size_t page, nlruns, j;
-	ssize_t gap_start;
-
-	CTL_GET("arenas.page", &page, size_t);
+	unsigned nbins, nlruns, j;
+	bool in_gap;
 
 	malloc_cprintf(write_cb, cbopaque,
-	    "large:   size pages      nmalloc      ndalloc    nrequests"
-	    "      curruns\n");
-	CTL_GET("arenas.nlruns", &nlruns, size_t);
-	for (j = 0, gap_start = -1; j < nlruns; j++) {
+	    "large:          size ind    allocated      nmalloc      ndalloc"
+	    "    nrequests      curruns\n");
+	CTL_GET("arenas.nbins", &nbins, unsigned);
+	CTL_GET("arenas.nlruns", &nlruns, unsigned);
+	for (j = 0, in_gap = false; j < nlruns; j++) {
 		uint64_t nmalloc, ndalloc, nrequests;
 		size_t run_size, curruns;
 
-		CTL_IJ_GET("stats.arenas.0.lruns.0.nmalloc", &nmalloc,
-		    uint64_t);
-		CTL_IJ_GET("stats.arenas.0.lruns.0.ndalloc", &ndalloc,
+		CTL_M2_M4_GET("stats.arenas.0.lruns.0.nmalloc", i, j, &nmalloc,
 		    uint64_t);
-		CTL_IJ_GET("stats.arenas.0.lruns.0.nrequests", &nrequests,
+		CTL_M2_M4_GET("stats.arenas.0.lruns.0.ndalloc", i, j, &ndalloc,
 		    uint64_t);
-		if (nrequests == 0) {
-			if (gap_start == -1)
-				gap_start = j;
-		} else {
-			CTL_J_GET("arenas.lrun.0.size", &run_size, size_t);
-			CTL_IJ_GET("stats.arenas.0.lruns.0.curruns", &curruns,
+		CTL_M2_M4_GET("stats.arenas.0.lruns.0.nrequests", i, j,
+		    &nrequests, uint64_t);
+		if (nrequests == 0)
+			in_gap = true;
+		else {
+			CTL_M2_GET("arenas.lrun.0.size", j, &run_size, size_t);
+			CTL_M2_M4_GET("stats.arenas.0.lruns.0.curruns", i, j,
+			    &curruns, size_t);
+			if (in_gap) {
+				malloc_cprintf(write_cb, cbopaque,
+				    "                     ---\n");
+				in_gap = false;
+			}
+			malloc_cprintf(write_cb, cbopaque,
+			    "%20zu %3u %12zu %12"FMTu64" %12"FMTu64
+			    " %12"FMTu64" %12zu\n",
+			    run_size, nbins + j, curruns * run_size, nmalloc,
+			    ndalloc, nrequests, curruns);
+		}
+	}
+	if (in_gap) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "                     ---\n");
+	}
+}
+
+static void
+stats_arena_hchunks_print(void (*write_cb)(void *, const char *),
+    void *cbopaque, unsigned i)
+{
+	unsigned nbins, nlruns, nhchunks, j;
+	bool in_gap;
+
+	malloc_cprintf(write_cb, cbopaque,
+	    "huge:           size ind    allocated      nmalloc      ndalloc"
+	    "    nrequests   curhchunks\n");
+	CTL_GET("arenas.nbins", &nbins, unsigned);
+	CTL_GET("arenas.nlruns", &nlruns, unsigned);
+	CTL_GET("arenas.nhchunks", &nhchunks, unsigned);
+	for (j = 0, in_gap = false; j < nhchunks; j++) {
+		uint64_t nmalloc, ndalloc, nrequests;
+		size_t hchunk_size, curhchunks;
+
+		CTL_M2_M4_GET("stats.arenas.0.hchunks.0.nmalloc", i, j,
+		    &nmalloc, uint64_t);
+		CTL_M2_M4_GET("stats.arenas.0.hchunks.0.ndalloc", i, j,
+		    &ndalloc, uint64_t);
+		CTL_M2_M4_GET("stats.arenas.0.hchunks.0.nrequests", i, j,
+		    &nrequests, uint64_t);
+		if (nrequests == 0)
+			in_gap = true;
+		else {
+			CTL_M2_GET("arenas.hchunk.0.size", j, &hchunk_size,
 			    size_t);
-			if (gap_start != -1) {
-				malloc_cprintf(write_cb, cbopaque, "[%zu]\n",
-				    j - gap_start);
-				gap_start = -1;
+			CTL_M2_M4_GET("stats.arenas.0.hchunks.0.curhchunks", i,
+			    j, &curhchunks, size_t);
+			if (in_gap) {
+				malloc_cprintf(write_cb, cbopaque,
+				    "                     ---\n");
+				in_gap = false;
 			}
 			malloc_cprintf(write_cb, cbopaque,
-			    "%13zu %5zu %12"PRIu64" %12"PRIu64" %12"PRIu64
-			    " %12zu\n",
-			    run_size, run_size / page, nmalloc, ndalloc,
-			    nrequests, curruns);
+			    "%20zu %3u %12zu %12"FMTu64" %12"FMTu64
+			    " %12"FMTu64" %12zu\n",
+			    hchunk_size, nbins + nlruns + j,
+			    curhchunks * hchunk_size, nmalloc, ndalloc,
+			    nrequests, curhchunks);
 		}
 	}
-	if (gap_start != -1)
-		malloc_cprintf(write_cb, cbopaque, "[%zu]\n", j - gap_start);
+	if (in_gap) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "                     ---\n");
+	}
 }
 
 static void
 stats_arena_print(void (*write_cb)(void *, const char *), void *cbopaque,
-    unsigned i, bool bins, bool large)
+    unsigned i, bool bins, bool large, bool huge)
 {
 	unsigned nthreads;
 	const char *dss;
+	ssize_t lg_dirty_mult;
 	size_t page, pactive, pdirty, mapped;
+	size_t metadata_mapped, metadata_allocated;
 	uint64_t npurge, nmadvise, purged;
 	size_t small_allocated;
 	uint64_t small_nmalloc, small_ndalloc, small_nrequests;
 	size_t large_allocated;
 	uint64_t large_nmalloc, large_ndalloc, large_nrequests;
+	size_t huge_allocated;
+	uint64_t huge_nmalloc, huge_ndalloc, huge_nrequests;
 
 	CTL_GET("arenas.page", &page, size_t);
 
-	CTL_I_GET("stats.arenas.0.nthreads", &nthreads, unsigned);
+	CTL_M2_GET("stats.arenas.0.nthreads", i, &nthreads, unsigned);
 	malloc_cprintf(write_cb, cbopaque,
 	    "assigned threads: %u\n", nthreads);
-	CTL_I_GET("stats.arenas.0.dss", &dss, const char *);
+	CTL_M2_GET("stats.arenas.0.dss", i, &dss, const char *);
 	malloc_cprintf(write_cb, cbopaque, "dss allocation precedence: %s\n",
 	    dss);
-	CTL_I_GET("stats.arenas.0.pactive", &pactive, size_t);
-	CTL_I_GET("stats.arenas.0.pdirty", &pdirty, size_t);
-	CTL_I_GET("stats.arenas.0.npurge", &npurge, uint64_t);
-	CTL_I_GET("stats.arenas.0.nmadvise", &nmadvise, uint64_t);
-	CTL_I_GET("stats.arenas.0.purged", &purged, uint64_t);
-	malloc_cprintf(write_cb, cbopaque,
-	    "dirty pages: %zu:%zu active:dirty, %"PRIu64" sweep%s,"
-	    " %"PRIu64" madvise%s, %"PRIu64" purged\n",
-	    pactive, pdirty, npurge, npurge == 1 ? "" : "s",
-	    nmadvise, nmadvise == 1 ? "" : "s", purged);
-
-	malloc_cprintf(write_cb, cbopaque,
-	    "            allocated      nmalloc      ndalloc    nrequests\n");
-	CTL_I_GET("stats.arenas.0.small.allocated", &small_allocated, size_t);
-	CTL_I_GET("stats.arenas.0.small.nmalloc", &small_nmalloc, uint64_t);
-	CTL_I_GET("stats.arenas.0.small.ndalloc", &small_ndalloc, uint64_t);
-	CTL_I_GET("stats.arenas.0.small.nrequests", &small_nrequests, uint64_t);
+	CTL_M2_GET("stats.arenas.0.lg_dirty_mult", i, &lg_dirty_mult, ssize_t);
+	if (lg_dirty_mult >= 0) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "min active:dirty page ratio: %u:1\n",
+		    (1U << lg_dirty_mult));
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "min active:dirty page ratio: N/A\n");
+	}
+	CTL_M2_GET("stats.arenas.0.pactive", i, &pactive, size_t);
+	CTL_M2_GET("stats.arenas.0.pdirty", i, &pdirty, size_t);
+	CTL_M2_GET("stats.arenas.0.npurge", i, &npurge, uint64_t);
+	CTL_M2_GET("stats.arenas.0.nmadvise", i, &nmadvise, uint64_t);
+	CTL_M2_GET("stats.arenas.0.purged", i, &purged, uint64_t);
 	malloc_cprintf(write_cb, cbopaque,
-	    "small:   %12zu %12"PRIu64" %12"PRIu64" %12"PRIu64"\n",
+	    "dirty pages: %zu:%zu active:dirty, %"FMTu64" sweep%s, %"FMTu64
+	    " madvise%s, %"FMTu64" purged\n", pactive, pdirty, npurge, npurge ==
+	    1 ? "" : "s", nmadvise, nmadvise == 1 ? "" : "s", purged);
+
+	malloc_cprintf(write_cb, cbopaque,
+	    "                            allocated      nmalloc      ndalloc"
+	    "    nrequests\n");
+	CTL_M2_GET("stats.arenas.0.small.allocated", i, &small_allocated,
+	    size_t);
+	CTL_M2_GET("stats.arenas.0.small.nmalloc", i, &small_nmalloc, uint64_t);
+	CTL_M2_GET("stats.arenas.0.small.ndalloc", i, &small_ndalloc, uint64_t);
+	CTL_M2_GET("stats.arenas.0.small.nrequests", i, &small_nrequests,
+	    uint64_t);
+	malloc_cprintf(write_cb, cbopaque,
+	    "small:                   %12zu %12"FMTu64" %12"FMTu64
+	    " %12"FMTu64"\n",
 	    small_allocated, small_nmalloc, small_ndalloc, small_nrequests);
-	CTL_I_GET("stats.arenas.0.large.allocated", &large_allocated, size_t);
-	CTL_I_GET("stats.arenas.0.large.nmalloc", &large_nmalloc, uint64_t);
-	CTL_I_GET("stats.arenas.0.large.ndalloc", &large_ndalloc, uint64_t);
-	CTL_I_GET("stats.arenas.0.large.nrequests", &large_nrequests, uint64_t);
+	CTL_M2_GET("stats.arenas.0.large.allocated", i, &large_allocated,
+	    size_t);
+	CTL_M2_GET("stats.arenas.0.large.nmalloc", i, &large_nmalloc, uint64_t);
+	CTL_M2_GET("stats.arenas.0.large.ndalloc", i, &large_ndalloc, uint64_t);
+	CTL_M2_GET("stats.arenas.0.large.nrequests", i, &large_nrequests,
+	    uint64_t);
 	malloc_cprintf(write_cb, cbopaque,
-	    "large:   %12zu %12"PRIu64" %12"PRIu64" %12"PRIu64"\n",
+	    "large:                   %12zu %12"FMTu64" %12"FMTu64
+	    " %12"FMTu64"\n",
 	    large_allocated, large_nmalloc, large_ndalloc, large_nrequests);
+	CTL_M2_GET("stats.arenas.0.huge.allocated", i, &huge_allocated, size_t);
+	CTL_M2_GET("stats.arenas.0.huge.nmalloc", i, &huge_nmalloc, uint64_t);
+	CTL_M2_GET("stats.arenas.0.huge.ndalloc", i, &huge_ndalloc, uint64_t);
+	CTL_M2_GET("stats.arenas.0.huge.nrequests", i, &huge_nrequests,
+	    uint64_t);
+	malloc_cprintf(write_cb, cbopaque,
+	    "huge:                    %12zu %12"FMTu64" %12"FMTu64
+	    " %12"FMTu64"\n",
+	    huge_allocated, huge_nmalloc, huge_ndalloc, huge_nrequests);
 	malloc_cprintf(write_cb, cbopaque,
-	    "total:   %12zu %12"PRIu64" %12"PRIu64" %12"PRIu64"\n",
-	    small_allocated + large_allocated,
-	    small_nmalloc + large_nmalloc,
-	    small_ndalloc + large_ndalloc,
-	    small_nrequests + large_nrequests);
-	malloc_cprintf(write_cb, cbopaque, "active:  %12zu\n", pactive * page);
-	CTL_I_GET("stats.arenas.0.mapped", &mapped, size_t);
-	malloc_cprintf(write_cb, cbopaque, "mapped:  %12zu\n", mapped);
+	    "total:                   %12zu %12"FMTu64" %12"FMTu64
+	    " %12"FMTu64"\n",
+	    small_allocated + large_allocated + huge_allocated,
+	    small_nmalloc + large_nmalloc + huge_nmalloc,
+	    small_ndalloc + large_ndalloc + huge_ndalloc,
+	    small_nrequests + large_nrequests + huge_nrequests);
+	malloc_cprintf(write_cb, cbopaque,
+	    "active:                  %12zu\n", pactive * page);
+	CTL_M2_GET("stats.arenas.0.mapped", i, &mapped, size_t);
+	malloc_cprintf(write_cb, cbopaque,
+	    "mapped:                  %12zu\n", mapped);
+	CTL_M2_GET("stats.arenas.0.metadata.mapped", i, &metadata_mapped,
+	    size_t);
+	CTL_M2_GET("stats.arenas.0.metadata.allocated", i, &metadata_allocated,
+	    size_t);
+	malloc_cprintf(write_cb, cbopaque,
+	    "metadata: mapped: %zu, allocated: %zu\n",
+	    metadata_mapped, metadata_allocated);
 
 	if (bins)
 		stats_arena_bins_print(write_cb, cbopaque, i);
 	if (large)
 		stats_arena_lruns_print(write_cb, cbopaque, i);
+	if (huge)
+		stats_arena_hchunks_print(write_cb, cbopaque, i);
 }
 
 void
 stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *opts)
 {
@@ -274,12 +365,13 @@
 	size_t u64sz;
 	bool general = true;
 	bool merged = true;
 	bool unmerged = true;
 	bool bins = true;
 	bool large = true;
+	bool huge = true;
 
 	/*
 	 * Refresh stats, in case mallctl() was called by the application.
 	 *
 	 * Check for OOM here, since refreshing the ctl cache can trigger
 	 * allocation.  In practice, none of the subsequent mallctl()-related
@@ -316,21 +408,23 @@
 			case 'b':
 				bins = false;
 				break;
 			case 'l':
 				large = false;
 				break;
+			case 'h':
+				huge = false;
+				break;
 			default:;
 			}
 		}
 	}
 
 	malloc_cprintf(write_cb, cbopaque,
 	    "___ Begin jemalloc statistics ___\n");
 	if (general) {
-		int err;
 		const char *cpv;
 		bool bv;
 		unsigned uv;
 		ssize_t ssv;
 		size_t sv, bsz, ssz, sssz, cpsz;
 
@@ -343,64 +437,81 @@
 		malloc_cprintf(write_cb, cbopaque, "Version: %s\n", cpv);
 		CTL_GET("config.debug", &bv, bool);
 		malloc_cprintf(write_cb, cbopaque, "Assertions %s\n",
 		    bv ? "enabled" : "disabled");
 
 #define	OPT_WRITE_BOOL(n)						\
-		if ((err = je_mallctl("opt."#n, &bv, &bsz, NULL, 0))	\
-		    == 0) {						\
+		if (je_mallctl("opt."#n, &bv, &bsz, NULL, 0) == 0) {	\
 			malloc_cprintf(write_cb, cbopaque,		\
 			    "  opt."#n": %s\n", bv ? "true" : "false");	\
 		}
+#define	OPT_WRITE_BOOL_MUTABLE(n, m) {					\
+		bool bv2;						\
+		if (je_mallctl("opt."#n, &bv, &bsz, NULL, 0) == 0 &&	\
+		    je_mallctl(#m, &bv2, &bsz, NULL, 0) == 0) {		\
+			malloc_cprintf(write_cb, cbopaque,		\
+			    "  opt."#n": %s ("#m": %s)\n", bv ? "true"	\
+			    : "false", bv2 ? "true" : "false");		\
+		}							\
+}
 #define	OPT_WRITE_SIZE_T(n)						\
-		if ((err = je_mallctl("opt."#n, &sv, &ssz, NULL, 0))	\
-		    == 0) {						\
+		if (je_mallctl("opt."#n, &sv, &ssz, NULL, 0) == 0) {	\
 			malloc_cprintf(write_cb, cbopaque,		\
 			"  opt."#n": %zu\n", sv);			\
 		}
 #define	OPT_WRITE_SSIZE_T(n)						\
-		if ((err = je_mallctl("opt."#n, &ssv, &sssz, NULL, 0))	\
-		    == 0) {						\
+		if (je_mallctl("opt."#n, &ssv, &sssz, NULL, 0) == 0) {	\
 			malloc_cprintf(write_cb, cbopaque,		\
 			    "  opt."#n": %zd\n", ssv);			\
 		}
+#define	OPT_WRITE_SSIZE_T_MUTABLE(n, m) {				\
+		ssize_t ssv2;						\
+		if (je_mallctl("opt."#n, &ssv, &sssz, NULL, 0) == 0 &&	\
+		    je_mallctl(#m, &ssv2, &sssz, NULL, 0) == 0) {	\
+			malloc_cprintf(write_cb, cbopaque,		\
+			    "  opt."#n": %zd ("#m": %zd)\n",		\
+			    ssv, ssv2);					\
+		}							\
+}
 #define	OPT_WRITE_CHAR_P(n)						\
-		if ((err = je_mallctl("opt."#n, &cpv, &cpsz, NULL, 0))	\
-		    == 0) {						\
+		if (je_mallctl("opt."#n, &cpv, &cpsz, NULL, 0) == 0) {	\
 			malloc_cprintf(write_cb, cbopaque,		\
 			    "  opt."#n": \"%s\"\n", cpv);		\
 		}
 
 		malloc_cprintf(write_cb, cbopaque,
 		    "Run-time option settings:\n");
 		OPT_WRITE_BOOL(abort)
 		OPT_WRITE_SIZE_T(lg_chunk)
 		OPT_WRITE_CHAR_P(dss)
 		OPT_WRITE_SIZE_T(narenas)
-		OPT_WRITE_SSIZE_T(lg_dirty_mult)
+		OPT_WRITE_SSIZE_T_MUTABLE(lg_dirty_mult, arenas.lg_dirty_mult)
 		OPT_WRITE_BOOL(stats_print)
-		OPT_WRITE_BOOL(junk)
+		OPT_WRITE_CHAR_P(junk)
 		OPT_WRITE_SIZE_T(quarantine)
 		OPT_WRITE_BOOL(redzone)
 		OPT_WRITE_BOOL(zero)
 		OPT_WRITE_BOOL(utrace)
 		OPT_WRITE_BOOL(valgrind)
 		OPT_WRITE_BOOL(xmalloc)
 		OPT_WRITE_BOOL(tcache)
 		OPT_WRITE_SSIZE_T(lg_tcache_max)
 		OPT_WRITE_BOOL(prof)
 		OPT_WRITE_CHAR_P(prof_prefix)
-		OPT_WRITE_BOOL(prof_active)
+		OPT_WRITE_BOOL_MUTABLE(prof_active, prof.active)
+		OPT_WRITE_BOOL_MUTABLE(prof_thread_active_init,
+		    prof.thread_active_init)
 		OPT_WRITE_SSIZE_T(lg_prof_sample)
 		OPT_WRITE_BOOL(prof_accum)
 		OPT_WRITE_SSIZE_T(lg_prof_interval)
 		OPT_WRITE_BOOL(prof_gdump)
 		OPT_WRITE_BOOL(prof_final)
 		OPT_WRITE_BOOL(prof_leak)
 
 #undef OPT_WRITE_BOOL
+#undef OPT_WRITE_BOOL_MUTABLE
 #undef OPT_WRITE_SIZE_T
 #undef OPT_WRITE_SSIZE_T
 #undef OPT_WRITE_CHAR_P
 
 		malloc_cprintf(write_cb, cbopaque, "CPUs: %u\n", ncpus);
 
@@ -408,91 +519,70 @@
 		malloc_cprintf(write_cb, cbopaque, "Arenas: %u\n", uv);
 
 		malloc_cprintf(write_cb, cbopaque, "Pointer size: %zu\n",
 		    sizeof(void *));
 
 		CTL_GET("arenas.quantum", &sv, size_t);
-		malloc_cprintf(write_cb, cbopaque, "Quantum size: %zu\n", sv);
+		malloc_cprintf(write_cb, cbopaque, "Quantum size: %zu\n",
+		    sv);
 
 		CTL_GET("arenas.page", &sv, size_t);
 		malloc_cprintf(write_cb, cbopaque, "Page size: %zu\n", sv);
 
-		CTL_GET("opt.lg_dirty_mult", &ssv, ssize_t);
+		CTL_GET("arenas.lg_dirty_mult", &ssv, ssize_t);
 		if (ssv >= 0) {
 			malloc_cprintf(write_cb, cbopaque,
 			    "Min active:dirty page ratio per arena: %u:1\n",
 			    (1U << ssv));
 		} else {
 			malloc_cprintf(write_cb, cbopaque,
 			    "Min active:dirty page ratio per arena: N/A\n");
 		}
-		if ((err = je_mallctl("arenas.tcache_max", &sv, &ssz, NULL, 0))
-		    == 0) {
+		if (je_mallctl("arenas.tcache_max", &sv, &ssz, NULL, 0) == 0) {
 			malloc_cprintf(write_cb, cbopaque,
 			    "Maximum thread-cached size class: %zu\n", sv);
 		}
-		if ((err = je_mallctl("opt.prof", &bv, &bsz, NULL, 0)) == 0 &&
-		    bv) {
-			CTL_GET("opt.lg_prof_sample", &sv, size_t);
+		if (je_mallctl("opt.prof", &bv, &bsz, NULL, 0) == 0 && bv) {
+			CTL_GET("prof.lg_sample", &sv, size_t);
 			malloc_cprintf(write_cb, cbopaque,
-			    "Average profile sample interval: %"PRIu64
+			    "Average profile sample interval: %"FMTu64
 			    " (2^%zu)\n", (((uint64_t)1U) << sv), sv);
 
 			CTL_GET("opt.lg_prof_interval", &ssv, ssize_t);
 			if (ssv >= 0) {
 				malloc_cprintf(write_cb, cbopaque,
-				    "Average profile dump interval: %"PRIu64
+				    "Average profile dump interval: %"FMTu64
 				    " (2^%zd)\n",
 				    (((uint64_t)1U) << ssv), ssv);
 			} else {
 				malloc_cprintf(write_cb, cbopaque,
 				    "Average profile dump interval: N/A\n");
 			}
 		}
 		CTL_GET("opt.lg_chunk", &sv, size_t);
-		malloc_cprintf(write_cb, cbopaque, "Chunk size: %zu (2^%zu)\n",
-		    (ZU(1) << sv), sv);
+		malloc_cprintf(write_cb, cbopaque,
+		    "Chunk size: %zu (2^%zu)\n", (ZU(1) << sv), sv);
 	}
 
 	if (config_stats) {
 		size_t *cactive;
-		size_t allocated, active, mapped;
-		size_t chunks_current, chunks_high;
-		uint64_t chunks_total;
-		size_t huge_allocated;
-		uint64_t huge_nmalloc, huge_ndalloc;
+		size_t allocated, active, metadata, resident, mapped;
 
 		CTL_GET("stats.cactive", &cactive, size_t *);
 		CTL_GET("stats.allocated", &allocated, size_t);
 		CTL_GET("stats.active", &active, size_t);
+		CTL_GET("stats.metadata", &metadata, size_t);
+		CTL_GET("stats.resident", &resident, size_t);
 		CTL_GET("stats.mapped", &mapped, size_t);
 		malloc_cprintf(write_cb, cbopaque,
-		    "Allocated: %zu, active: %zu, mapped: %zu\n",
-		    allocated, active, mapped);
-		malloc_cprintf(write_cb, cbopaque,
-		    "Current active ceiling: %zu\n", atomic_read_z(cactive));
-
-		/* Print chunk stats. */
-		CTL_GET("stats.chunks.total", &chunks_total, uint64_t);
-		CTL_GET("stats.chunks.high", &chunks_high, size_t);
-		CTL_GET("stats.chunks.current", &chunks_current, size_t);
-		malloc_cprintf(write_cb, cbopaque, "chunks: nchunks   "
-		    "highchunks    curchunks\n");
-		malloc_cprintf(write_cb, cbopaque,
-		    "  %13"PRIu64" %12zu %12zu\n",
-		    chunks_total, chunks_high, chunks_current);
-
-		/* Print huge stats. */
-		CTL_GET("stats.huge.nmalloc", &huge_nmalloc, uint64_t);
-		CTL_GET("stats.huge.ndalloc", &huge_ndalloc, uint64_t);
-		CTL_GET("stats.huge.allocated", &huge_allocated, size_t);
-		malloc_cprintf(write_cb, cbopaque,
-		    "huge: nmalloc      ndalloc    allocated\n");
+		    "Allocated: %zu, active: %zu, metadata: %zu,"
+		    " resident: %zu, mapped: %zu\n",
+		    allocated, active, metadata, resident, mapped);
 		malloc_cprintf(write_cb, cbopaque,
-		    " %12"PRIu64" %12"PRIu64" %12zu\n",
-		    huge_nmalloc, huge_ndalloc, huge_allocated);
+		    "Current active ceiling: %zu\n",
+		    atomic_read_z(cactive));
 
 		if (merged) {
 			unsigned narenas;
 
 			CTL_GET("arenas.narenas", &narenas, unsigned);
 			{
@@ -505,18 +595,18 @@
 				    &isz, NULL, 0);
 				for (i = ninitialized = 0; i < narenas; i++) {
 					if (initialized[i])
 						ninitialized++;
 				}
 
-				if (ninitialized > 1 || unmerged == false) {
+				if (ninitialized > 1 || !unmerged) {
 					/* Print merged arena stats. */
 					malloc_cprintf(write_cb, cbopaque,
 					    "\nMerged arenas stats:\n");
 					stats_arena_print(write_cb, cbopaque,
-					    narenas, bins, large);
+					    narenas, bins, large, huge);
 				}
 			}
 		}
 
 		if (unmerged) {
 			unsigned narenas;
@@ -536,13 +626,14 @@
 				for (i = 0; i < narenas; i++) {
 					if (initialized[i]) {
 						malloc_cprintf(write_cb,
 						    cbopaque,
 						    "\narenas[%u]:\n", i);
 						stats_arena_print(write_cb,
-						    cbopaque, i, bins, large);
+						    cbopaque, i, bins, large,
+						    huge);
 					}
 				}
 			}
 		}
 	}
 	malloc_cprintf(write_cb, cbopaque, "--- End jemalloc statistics ---\n");
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.d	2017-09-27 22:47:59.506963244 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.d	2017-09-27 22:49:22.830960190 +0800
@@ -1,20 +1,21 @@
 src/stats.o: src/stats.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,49 +1,55 @@
 #define	JEMALLOC_TCACHE_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 /* Data. */
 
-malloc_tsd_data(, tcache, tcache_t *, NULL)
-malloc_tsd_data(, tcache_enabled, tcache_enabled_t, tcache_enabled_default)
-
 bool	opt_tcache = true;
 ssize_t	opt_lg_tcache_max = LG_TCACHE_MAXCLASS_DEFAULT;
 
 tcache_bin_info_t	*tcache_bin_info;
 static unsigned		stack_nelms; /* Total stack elms per tcache. */
 
 size_t			nhbins;
 size_t			tcache_maxclass;
 
+tcaches_t		*tcaches;
+
+/* Index of first element within tcaches that has never been used. */
+static unsigned		tcaches_past;
+
+/* Head of singly linked list tracking available tcaches elements. */
+static tcaches_t	*tcaches_avail;
+
 /******************************************************************************/
 
 size_t	tcache_salloc(const void *ptr)
 {
 
 	return (arena_salloc(ptr, false));
 }
 
 void
-tcache_event_hard(tcache_t *tcache)
+tcache_event_hard(tsd_t *tsd, tcache_t *tcache)
 {
-	size_t binind = tcache->next_gc_bin;
+	szind_t binind = tcache->next_gc_bin;
 	tcache_bin_t *tbin = &tcache->tbins[binind];
 	tcache_bin_info_t *tbin_info = &tcache_bin_info[binind];
 
 	if (tbin->low_water > 0) {
 		/*
 		 * Flush (ceiling) 3/4 of the objects below the low water mark.
 		 */
 		if (binind < NBINS) {
-			tcache_bin_flush_small(tbin, binind, tbin->ncached -
-			    tbin->low_water + (tbin->low_water >> 2), tcache);
+			tcache_bin_flush_small(tsd, tcache, tbin, binind,
+			    tbin->ncached - tbin->low_water + (tbin->low_water
+			    >> 2));
 		} else {
-			tcache_bin_flush_large(tbin, binind, tbin->ncached -
-			    tbin->low_water + (tbin->low_water >> 2), tcache);
+			tcache_bin_flush_large(tsd, tbin, binind, tbin->ncached
+			    - tbin->low_water + (tbin->low_water >> 2), tcache);
 		}
 		/*
 		 * Reduce fill count by 2X.  Limit lg_fill_div such that the
 		 * fill count is always at least 1.
 		 */
 		if ((tbin_info->ncached_max >> (tbin->lg_fill_div+1)) >= 1)
@@ -62,73 +68,73 @@
 	if (tcache->next_gc_bin == nhbins)
 		tcache->next_gc_bin = 0;
 	tcache->ev_cnt = 0;
 }
 
 void *
-tcache_alloc_small_hard(tcache_t *tcache, tcache_bin_t *tbin, size_t binind)
+tcache_alloc_small_hard(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
+    tcache_bin_t *tbin, szind_t binind)
 {
 	void *ret;
 
-	arena_tcache_fill_small(tcache->arena, tbin, binind,
-	    config_prof ? tcache->prof_accumbytes : 0);
+	arena_tcache_fill_small(arena, tbin, binind, config_prof ?
+	    tcache->prof_accumbytes : 0);
 	if (config_prof)
 		tcache->prof_accumbytes = 0;
 	ret = tcache_alloc_easy(tbin);
 
 	return (ret);
 }
 
 void
-tcache_bin_flush_small(tcache_bin_t *tbin, size_t binind, unsigned rem,
-    tcache_t *tcache)
+tcache_bin_flush_small(tsd_t *tsd, tcache_t *tcache, tcache_bin_t *tbin,
+    szind_t binind, unsigned rem)
 {
+	arena_t *arena;
 	void *ptr;
 	unsigned i, nflush, ndeferred;
 	bool merged_stats = false;
 
 	assert(binind < NBINS);
 	assert(rem <= tbin->ncached);
 
+	arena = arena_choose(tsd, NULL);
+	assert(arena != NULL);
 	for (nflush = tbin->ncached - rem; nflush > 0; nflush = ndeferred) {
 		/* Lock the arena bin associated with the first object. */
 		arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(
 		    tbin->avail[0]);
-		arena_t *arena = chunk->arena;
-		arena_bin_t *bin = &arena->bins[binind];
+		arena_t *bin_arena = extent_node_arena_get(&chunk->node);
+		arena_bin_t *bin = &bin_arena->bins[binind];
 
-		if (config_prof && arena == tcache->arena) {
+		if (config_prof && bin_arena == arena) {
 			if (arena_prof_accum(arena, tcache->prof_accumbytes))
 				prof_idump();
 			tcache->prof_accumbytes = 0;
 		}
 
 		malloc_mutex_lock(&bin->lock);
-		if (config_stats && arena == tcache->arena) {
-			assert(merged_stats == false);
+		if (config_stats && bin_arena == arena) {
+			assert(!merged_stats);
 			merged_stats = true;
 			bin->stats.nflushes++;
 			bin->stats.nrequests += tbin->tstats.nrequests;
 			tbin->tstats.nrequests = 0;
 		}
 		ndeferred = 0;
 		for (i = 0; i < nflush; i++) {
 			ptr = tbin->avail[i];
 			assert(ptr != NULL);
 			chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-			if (chunk->arena == arena) {
+			if (extent_node_arena_get(&chunk->node) == bin_arena) {
 				size_t pageind = ((uintptr_t)ptr -
 				    (uintptr_t)chunk) >> LG_PAGE;
-				arena_chunk_map_t *mapelm =
-				    arena_mapp_get(chunk, pageind);
-				if (config_fill && opt_junk) {
-					arena_alloc_junk_small(ptr,
-					    &arena_bin_info[binind], true);
-				}
-				arena_dalloc_bin_locked(arena, chunk, ptr,
-				    mapelm);
+				arena_chunk_map_bits_t *bitselm =
+				    arena_bitselm_get(chunk, pageind);
+				arena_dalloc_bin_junked_locked(bin_arena, chunk,
+				    ptr, bitselm);
 			} else {
 				/*
 				 * This object was allocated via a different
 				 * arena bin than the one that is currently
 				 * locked.  Stash the object, so that it can be
 				 * handled in a future pass.
@@ -136,18 +142,18 @@
 				tbin->avail[ndeferred] = ptr;
 				ndeferred++;
 			}
 		}
 		malloc_mutex_unlock(&bin->lock);
 	}
-	if (config_stats && merged_stats == false) {
+	if (config_stats && !merged_stats) {
 		/*
 		 * The flush loop didn't happen to flush to this thread's
 		 * arena, so the stats didn't get merged.  Manually do so now.
 		 */
-		arena_bin_t *bin = &tcache->arena->bins[binind];
+		arena_bin_t *bin = &arena->bins[binind];
 		malloc_mutex_lock(&bin->lock);
 		bin->stats.nflushes++;
 		bin->stats.nrequests += tbin->tstats.nrequests;
 		tbin->tstats.nrequests = 0;
 		malloc_mutex_unlock(&bin->lock);
 	}
@@ -157,33 +163,36 @@
 	tbin->ncached = rem;
 	if ((int)tbin->ncached < tbin->low_water)
 		tbin->low_water = tbin->ncached;
 }
 
 void
-tcache_bin_flush_large(tcache_bin_t *tbin, size_t binind, unsigned rem,
-    tcache_t *tcache)
+tcache_bin_flush_large(tsd_t *tsd, tcache_bin_t *tbin, szind_t binind,
+    unsigned rem, tcache_t *tcache)
 {
+	arena_t *arena;
 	void *ptr;
 	unsigned i, nflush, ndeferred;
 	bool merged_stats = false;
 
 	assert(binind < nhbins);
 	assert(rem <= tbin->ncached);
 
+	arena = arena_choose(tsd, NULL);
+	assert(arena != NULL);
 	for (nflush = tbin->ncached - rem; nflush > 0; nflush = ndeferred) {
 		/* Lock the arena associated with the first object. */
 		arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(
 		    tbin->avail[0]);
-		arena_t *arena = chunk->arena;
+		arena_t *locked_arena = extent_node_arena_get(&chunk->node);
 		UNUSED bool idump;
 
 		if (config_prof)
 			idump = false;
-		malloc_mutex_lock(&arena->lock);
-		if ((config_prof || config_stats) && arena == tcache->arena) {
+		malloc_mutex_lock(&locked_arena->lock);
+		if ((config_prof || config_stats) && locked_arena == arena) {
 			if (config_prof) {
 				idump = arena_prof_accum_locked(arena,
 				    tcache->prof_accumbytes);
 				tcache->prof_accumbytes = 0;
 			}
 			if (config_stats) {
@@ -197,35 +206,36 @@
 		}
 		ndeferred = 0;
 		for (i = 0; i < nflush; i++) {
 			ptr = tbin->avail[i];
 			assert(ptr != NULL);
 			chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
-			if (chunk->arena == arena)
-				arena_dalloc_large_locked(arena, chunk, ptr);
-			else {
+			if (extent_node_arena_get(&chunk->node) ==
+			    locked_arena) {
+				arena_dalloc_large_junked_locked(locked_arena,
+				    chunk, ptr);
+			} else {
 				/*
 				 * This object was allocated via a different
 				 * arena than the one that is currently locked.
 				 * Stash the object, so that it can be handled
 				 * in a future pass.
 				 */
 				tbin->avail[ndeferred] = ptr;
 				ndeferred++;
 			}
 		}
-		malloc_mutex_unlock(&arena->lock);
+		malloc_mutex_unlock(&locked_arena->lock);
 		if (config_prof && idump)
 			prof_idump();
 	}
-	if (config_stats && merged_stats == false) {
+	if (config_stats && !merged_stats) {
 		/*
 		 * The flush loop didn't happen to flush to this thread's
 		 * arena, so the stats didn't get merged.  Manually do so now.
 		 */
-		arena_t *arena = tcache->arena;
 		malloc_mutex_lock(&arena->lock);
 		arena->stats.nrequests_large += tbin->tstats.nrequests;
 		arena->stats.lstats[binind - NBINS].nrequests +=
 		    tbin->tstats.nrequests;
 		tbin->tstats.nrequests = 0;
 		malloc_mutex_unlock(&arena->lock);
@@ -246,57 +256,78 @@
 		/* Link into list of extant tcaches. */
 		malloc_mutex_lock(&arena->lock);
 		ql_elm_new(tcache, link);
 		ql_tail_insert(&arena->tcache_ql, tcache, link);
 		malloc_mutex_unlock(&arena->lock);
 	}
-	tcache->arena = arena;
 }
 
 void
-tcache_arena_dissociate(tcache_t *tcache)
+tcache_arena_reassociate(tcache_t *tcache, arena_t *oldarena, arena_t *newarena)
+{
+
+	tcache_arena_dissociate(tcache, oldarena);
+	tcache_arena_associate(tcache, newarena);
+}
+
+void
+tcache_arena_dissociate(tcache_t *tcache, arena_t *arena)
 {
 
 	if (config_stats) {
 		/* Unlink from list of extant tcaches. */
-		malloc_mutex_lock(&tcache->arena->lock);
-		ql_remove(&tcache->arena->tcache_ql, tcache, link);
-		tcache_stats_merge(tcache, tcache->arena);
-		malloc_mutex_unlock(&tcache->arena->lock);
+		malloc_mutex_lock(&arena->lock);
+		if (config_debug) {
+			bool in_ql = false;
+			tcache_t *iter;
+			ql_foreach(iter, &arena->tcache_ql, link) {
+				if (iter == tcache) {
+					in_ql = true;
+					break;
+				}
+			}
+			assert(in_ql);
+		}
+		ql_remove(&arena->tcache_ql, tcache, link);
+		tcache_stats_merge(tcache, arena);
+		malloc_mutex_unlock(&arena->lock);
 	}
 }
 
 tcache_t *
-tcache_create(arena_t *arena)
+tcache_get_hard(tsd_t *tsd)
+{
+	arena_t *arena;
+
+	if (!tcache_enabled_get()) {
+		if (tsd_nominal(tsd))
+			tcache_enabled_set(false); /* Memoize. */
+		return (NULL);
+	}
+	arena = arena_choose(tsd, NULL);
+	if (unlikely(arena == NULL))
+		return (NULL);
+	return (tcache_create(tsd, arena));
+}
+
+tcache_t *
+tcache_create(tsd_t *tsd, arena_t *arena)
 {
 	tcache_t *tcache;
 	size_t size, stack_offset;
 	unsigned i;
 
 	size = offsetof(tcache_t, tbins) + (sizeof(tcache_bin_t) * nhbins);
 	/* Naturally align the pointer stacks. */
 	size = PTR_CEILING(size);
 	stack_offset = size;
 	size += stack_nelms * sizeof(void *);
-	/*
-	 * Round up to the nearest multiple of the cacheline size, in order to
-	 * avoid the possibility of false cacheline sharing.
-	 *
-	 * That this works relies on the same logic as in ipalloc(), but we
-	 * cannot directly call ipalloc() here due to tcache bootstrapping
-	 * issues.
-	 */
-	size = (size + CACHELINE_MASK) & (-CACHELINE);
-
-	if (size <= SMALL_MAXCLASS)
-		tcache = (tcache_t *)arena_malloc_small(arena, size, true);
-	else if (size <= tcache_maxclass)
-		tcache = (tcache_t *)arena_malloc_large(arena, size, true);
-	else
-		tcache = (tcache_t *)icalloct(size, false, arena);
+	/* Avoid false cacheline sharing. */
+	size = sa2u(size, CACHELINE);
 
+	tcache = ipallocztm(tsd, size, CACHELINE, true, false, true, a0get());
 	if (tcache == NULL)
 		return (NULL);
 
 	tcache_arena_associate(tcache, arena);
 
 	assert((TCACHE_NSLOTS_SMALL_MAX & 1U) == 0);
@@ -304,102 +335,75 @@
 		tcache->tbins[i].lg_fill_div = 1;
 		tcache->tbins[i].avail = (void **)((uintptr_t)tcache +
 		    (uintptr_t)stack_offset);
 		stack_offset += tcache_bin_info[i].ncached_max * sizeof(void *);
 	}
 
-	tcache_tsd_set(&tcache);
-
 	return (tcache);
 }
 
-void
-tcache_destroy(tcache_t *tcache)
+static void
+tcache_destroy(tsd_t *tsd, tcache_t *tcache)
 {
+	arena_t *arena;
 	unsigned i;
-	size_t tcache_size;
 
-	tcache_arena_dissociate(tcache);
+	arena = arena_choose(tsd, NULL);
+	tcache_arena_dissociate(tcache, arena);
 
 	for (i = 0; i < NBINS; i++) {
 		tcache_bin_t *tbin = &tcache->tbins[i];
-		tcache_bin_flush_small(tbin, i, 0, tcache);
+		tcache_bin_flush_small(tsd, tcache, tbin, i, 0);
 
 		if (config_stats && tbin->tstats.nrequests != 0) {
-			arena_t *arena = tcache->arena;
 			arena_bin_t *bin = &arena->bins[i];
 			malloc_mutex_lock(&bin->lock);
 			bin->stats.nrequests += tbin->tstats.nrequests;
 			malloc_mutex_unlock(&bin->lock);
 		}
 	}
 
 	for (; i < nhbins; i++) {
 		tcache_bin_t *tbin = &tcache->tbins[i];
-		tcache_bin_flush_large(tbin, i, 0, tcache);
+		tcache_bin_flush_large(tsd, tbin, i, 0, tcache);
 
 		if (config_stats && tbin->tstats.nrequests != 0) {
-			arena_t *arena = tcache->arena;
 			malloc_mutex_lock(&arena->lock);
 			arena->stats.nrequests_large += tbin->tstats.nrequests;
 			arena->stats.lstats[i - NBINS].nrequests +=
 			    tbin->tstats.nrequests;
 			malloc_mutex_unlock(&arena->lock);
 		}
 	}
 
 	if (config_prof && tcache->prof_accumbytes > 0 &&
-	    arena_prof_accum(tcache->arena, tcache->prof_accumbytes))
+	    arena_prof_accum(arena, tcache->prof_accumbytes))
 		prof_idump();
 
-	tcache_size = arena_salloc(tcache, false);
-	if (tcache_size <= SMALL_MAXCLASS) {
-		arena_chunk_t *chunk = CHUNK_ADDR2BASE(tcache);
-		arena_t *arena = chunk->arena;
-		size_t pageind = ((uintptr_t)tcache - (uintptr_t)chunk) >>
-		    LG_PAGE;
-		arena_chunk_map_t *mapelm = arena_mapp_get(chunk, pageind);
+	idalloctm(tsd, tcache, false, true);
+}
+
+void
+tcache_cleanup(tsd_t *tsd)
+{
+	tcache_t *tcache;
 
-		arena_dalloc_bin(arena, chunk, tcache, pageind, mapelm);
-	} else if (tcache_size <= tcache_maxclass) {
-		arena_chunk_t *chunk = CHUNK_ADDR2BASE(tcache);
-		arena_t *arena = chunk->arena;
+	if (!config_tcache)
+		return;
 
-		arena_dalloc_large(arena, chunk, tcache);
-	} else
-		idalloct(tcache, false);
+	if ((tcache = tsd_tcache_get(tsd)) != NULL) {
+		tcache_destroy(tsd, tcache);
+		tsd_tcache_set(tsd, NULL);
+	}
 }
 
 void
-tcache_thread_cleanup(void *arg)
+tcache_enabled_cleanup(tsd_t *tsd)
 {
-	tcache_t *tcache = *(tcache_t **)arg;
 
-	if (tcache == TCACHE_STATE_DISABLED) {
-		/* Do nothing. */
-	} else if (tcache == TCACHE_STATE_REINCARNATED) {
-		/*
-		 * Another destructor called an allocator function after this
-		 * destructor was called.  Reset tcache to
-		 * TCACHE_STATE_PURGATORY in order to receive another callback.
-		 */
-		tcache = TCACHE_STATE_PURGATORY;
-		tcache_tsd_set(&tcache);
-	} else if (tcache == TCACHE_STATE_PURGATORY) {
-		/*
-		 * The previous time this destructor was called, we set the key
-		 * to TCACHE_STATE_PURGATORY so that other destructors wouldn't
-		 * cause re-creation of the tcache.  This time, do nothing, so
-		 * that the destructor will not be called again.
-		 */
-	} else if (tcache != NULL) {
-		assert(tcache != TCACHE_STATE_PURGATORY);
-		tcache_destroy(tcache);
-		tcache = TCACHE_STATE_PURGATORY;
-		tcache_tsd_set(&tcache);
-	}
+	/* Do nothing. */
 }
 
 /* Caller must own arena->lock. */
 void
 tcache_stats_merge(tcache_t *tcache, arena_t *arena)
 {
@@ -424,37 +428,101 @@
 		lstats->nrequests += tbin->tstats.nrequests;
 		tbin->tstats.nrequests = 0;
 	}
 }
 
 bool
-tcache_boot0(void)
+tcaches_create(tsd_t *tsd, unsigned *r_ind)
+{
+	tcache_t *tcache;
+	tcaches_t *elm;
+
+	if (tcaches == NULL) {
+		tcaches = base_alloc(sizeof(tcache_t *) *
+		    (MALLOCX_TCACHE_MAX+1));
+		if (tcaches == NULL)
+			return (true);
+	}
+
+	if (tcaches_avail == NULL && tcaches_past > MALLOCX_TCACHE_MAX)
+		return (true);
+	tcache = tcache_create(tsd, a0get());
+	if (tcache == NULL)
+		return (true);
+
+	if (tcaches_avail != NULL) {
+		elm = tcaches_avail;
+		tcaches_avail = tcaches_avail->next;
+		elm->tcache = tcache;
+		*r_ind = elm - tcaches;
+	} else {
+		elm = &tcaches[tcaches_past];
+		elm->tcache = tcache;
+		*r_ind = tcaches_past;
+		tcaches_past++;
+	}
+
+	return (false);
+}
+
+static void
+tcaches_elm_flush(tsd_t *tsd, tcaches_t *elm)
+{
+
+	if (elm->tcache == NULL)
+		return;
+	tcache_destroy(tsd, elm->tcache);
+	elm->tcache = NULL;
+}
+
+void
+tcaches_flush(tsd_t *tsd, unsigned ind)
+{
+
+	tcaches_elm_flush(tsd, &tcaches[ind]);
+}
+
+void
+tcaches_destroy(tsd_t *tsd, unsigned ind)
+{
+	tcaches_t *elm = &tcaches[ind];
+	tcaches_elm_flush(tsd, elm);
+	elm->next = tcaches_avail;
+	tcaches_avail = elm;
+}
+
+bool
+tcache_boot(void)
 {
 	unsigned i;
 
 	/*
-	 * If necessary, clamp opt_lg_tcache_max, now that arena_maxclass is
+	 * If necessary, clamp opt_lg_tcache_max, now that large_maxclass is
 	 * known.
 	 */
 	if (opt_lg_tcache_max < 0 || (1U << opt_lg_tcache_max) < SMALL_MAXCLASS)
 		tcache_maxclass = SMALL_MAXCLASS;
-	else if ((1U << opt_lg_tcache_max) > arena_maxclass)
-		tcache_maxclass = arena_maxclass;
+	else if ((1U << opt_lg_tcache_max) > large_maxclass)
+		tcache_maxclass = large_maxclass;
 	else
 		tcache_maxclass = (1U << opt_lg_tcache_max);
 
-	nhbins = NBINS + (tcache_maxclass >> LG_PAGE);
+	nhbins = size2index(tcache_maxclass) + 1;
 
 	/* Initialize tcache_bin_info. */
 	tcache_bin_info = (tcache_bin_info_t *)base_alloc(nhbins *
 	    sizeof(tcache_bin_info_t));
 	if (tcache_bin_info == NULL)
 		return (true);
 	stack_nelms = 0;
 	for (i = 0; i < NBINS; i++) {
-		if ((arena_bin_info[i].nregs << 1) <= TCACHE_NSLOTS_SMALL_MAX) {
+		if ((arena_bin_info[i].nregs << 1) <= TCACHE_NSLOTS_SMALL_MIN) {
+			tcache_bin_info[i].ncached_max =
+			    TCACHE_NSLOTS_SMALL_MIN;
+		} else if ((arena_bin_info[i].nregs << 1) <=
+		    TCACHE_NSLOTS_SMALL_MAX) {
 			tcache_bin_info[i].ncached_max =
 			    (arena_bin_info[i].nregs << 1);
 		} else {
 			tcache_bin_info[i].ncached_max =
 			    TCACHE_NSLOTS_SMALL_MAX;
 		}
@@ -464,16 +532,6 @@
 		tcache_bin_info[i].ncached_max = TCACHE_NSLOTS_LARGE;
 		stack_nelms += tcache_bin_info[i].ncached_max;
 	}
 
 	return (false);
 }
-
-bool
-tcache_boot1(void)
-{
-
-	if (tcache_tsd_boot() || tcache_enabled_tsd_boot())
-		return (true);
-
-	return (false);
-}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.d	2017-09-27 22:47:59.758963235 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.d	2017-09-27 22:49:23.154960178 +0800
@@ -1,20 +1,21 @@
 src/tcache.o: src/tcache.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.c	2016-05-06 15:11:36.000000000 +0800
@@ -4,27 +4,28 @@
 /******************************************************************************/
 /* Data. */
 
 static unsigned ncleanups;
 static malloc_tsd_cleanup_t cleanups[MALLOC_TSD_CLEANUPS_MAX];
 
+malloc_tsd_data(, , tsd_t, TSD_INITIALIZER)
+
 /******************************************************************************/
 
 void *
 malloc_tsd_malloc(size_t size)
 {
 
-	/* Avoid choose_arena() in order to dodge bootstrapping issues. */
-	return (arena_malloc(arenas[0], size, false, false));
+	return (a0malloc(CACHELINE_CEILING(size)));
 }
 
 void
 malloc_tsd_dalloc(void *wrapper)
 {
 
-	idalloct(wrapper, false);
+	a0dalloc(wrapper);
 }
 
 void
 malloc_tsd_no_cleanup(void *arg)
 {
 
@@ -64,16 +65,67 @@
 	assert(ncleanups < MALLOC_TSD_CLEANUPS_MAX);
 	cleanups[ncleanups] = f;
 	ncleanups++;
 }
 
 void
-malloc_tsd_boot(void)
+tsd_cleanup(void *arg)
+{
+	tsd_t *tsd = (tsd_t *)arg;
+
+	switch (tsd->state) {
+	case tsd_state_uninitialized:
+		/* Do nothing. */
+		break;
+	case tsd_state_nominal:
+#define O(n, t)								\
+		n##_cleanup(tsd);
+MALLOC_TSD
+#undef O
+		tsd->state = tsd_state_purgatory;
+		tsd_set(tsd);
+		break;
+	case tsd_state_purgatory:
+		/*
+		 * The previous time this destructor was called, we set the
+		 * state to tsd_state_purgatory so that other destructors
+		 * wouldn't cause re-creation of the tsd.  This time, do
+		 * nothing, and do not request another callback.
+		 */
+		break;
+	case tsd_state_reincarnated:
+		/*
+		 * Another destructor deallocated memory after this destructor
+		 * was called.  Reset state to tsd_state_purgatory and request
+		 * another callback.
+		 */
+		tsd->state = tsd_state_purgatory;
+		tsd_set(tsd);
+		break;
+	default:
+		not_reached();
+	}
+}
+
+bool
+malloc_tsd_boot0(void)
 {
 
 	ncleanups = 0;
+	if (tsd_boot0())
+		return (true);
+	*tsd_arenas_cache_bypassp_get(tsd_fetch()) = true;
+	return (false);
+}
+
+void
+malloc_tsd_boot1(void)
+{
+
+	tsd_boot1();
+	*tsd_arenas_cache_bypassp_get(tsd_fetch()) = false;
 }
 
 #ifdef _WIN32
 static BOOL WINAPI
 _tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 {
@@ -99,13 +151,13 @@
 #  else
 #    pragma comment(linker, "/INCLUDE:_tls_used")
 #  endif
 #  pragma section(".CRT$XLY",long,read)
 #endif
 JEMALLOC_SECTION(".CRT$XLY") JEMALLOC_ATTR(used)
-static const BOOL	(WINAPI *tls_callback)(HINSTANCE hinstDLL,
+static BOOL	(WINAPI *const tls_callback)(HINSTANCE hinstDLL,
     DWORD fdwReason, LPVOID lpvReserved) = _tls_callback;
 #endif
 
 #if (!defined(JEMALLOC_MALLOC_THREAD_CLEANUP) && !defined(JEMALLOC_TLS) && \
     !defined(_WIN32))
 void *
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.d	2017-09-27 22:48:00.270963216 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.d	2017-09-27 22:49:23.666960159 +0800
@@ -1,20 +1,21 @@
 src/tsd.o: src/tsd.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.c	2016-05-06 15:11:36.000000000 +0800
@@ -78,16 +78,16 @@
  */
 int
 buferror(int err, char *buf, size_t buflen)
 {
 
 #ifdef _WIN32
-	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
+	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err, 0,
 	    (LPSTR)buf, buflen, NULL);
 	return (0);
-#elif defined(_GNU_SOURCE)
+#elif defined(__GLIBC__) && defined(_GNU_SOURCE)
 	char *b = strerror_r(err, buf, buflen);
 	if (b != buf) {
 		strncpy(buf, b, buflen);
 		buf[buflen-1] = '\0';
 	}
 	return (0);
@@ -97,13 +97,13 @@
 }
 
 uintmax_t
 malloc_strtoumax(const char *restrict nptr, char **restrict endptr, int base)
 {
 	uintmax_t ret, digit;
-	int b;
+	unsigned b;
 	bool neg;
 	const char *p, *ns;
 
 	p = nptr;
 	if (base < 0 || base == 1 || base > 36) {
 		ns = p;
@@ -263,13 +263,13 @@
 		x = -x;
 	s = u2s(x, 10, false, s, slen_p);
 	if (neg)
 		sign = '-';
 	switch (sign) {
 	case '-':
-		if (neg == false)
+		if (!neg)
 			break;
 		/* Fall through. */
 	case ' ':
 	case '+':
 		s--;
 		(*slen_p)++;
@@ -326,13 +326,13 @@
 	i += slen;							\
 } while (0)
 #define	APPEND_PADDED_S(s, slen, width, left_justify) do {		\
 	/* Left padding. */						\
 	size_t pad_len = (width == -1) ? 0 : ((slen < (size_t)width) ?	\
 	    (size_t)width - slen : 0);					\
-	if (left_justify == false && pad_len != 0) {			\
+	if (!left_justify && pad_len != 0) {				\
 		size_t j;						\
 		for (j = 0; j < pad_len; j++)				\
 			APPEND_C(' ');					\
 	}								\
 	/* Value. */							\
 	APPEND_S(s, slen);						\
@@ -378,13 +378,15 @@
 	case 'z' | 0x80:						\
 		val = va_arg(ap, size_t);				\
 		break;							\
 	case 'p': /* Synthetic; used for %p. */				\
 		val = va_arg(ap, uintptr_t);				\
 		break;							\
-	default: not_reached();						\
+	default:							\
+		not_reached();						\
+		val = 0;						\
 	}								\
 } while (0)
 
 	i = 0;
 	f = format;
 	while (true) {
@@ -401,25 +403,25 @@
 
 			f++;
 			/* Flags. */
 			while (true) {
 				switch (*f) {
 				case '#':
-					assert(alt_form == false);
+					assert(!alt_form);
 					alt_form = true;
 					break;
 				case '-':
-					assert(left_justify == false);
+					assert(!left_justify);
 					left_justify = true;
 					break;
 				case ' ':
-					assert(plus_space == false);
+					assert(!plus_space);
 					plus_space = true;
 					break;
 				case '+':
-					assert(plus_plus == false);
+					assert(!plus_plus);
 					plus_plus = true;
 					break;
 				default: goto label_width;
 				}
 				f++;
 			}
@@ -545,13 +547,13 @@
 				f++;
 				break;
 			} case 's':
 				assert(len == '?' || len == 'l');
 				assert_not_implemented(len != 'l');
 				s = va_arg(ap, char *);
-				slen = (prec < 0) ? strlen(s) : prec;
+				slen = (prec < 0) ? strlen(s) : (size_t)prec;
 				APPEND_PADDED_S(s, slen, width, left_justify);
 				f++;
 				break;
 			case 'p': {
 				uintmax_t val;
 				char buf[X2S_BUFSIZE];
@@ -581,13 +583,13 @@
 #undef APPEND_S
 #undef APPEND_PADDED_S
 #undef GET_ARG_NUMERIC
 	return (ret);
 }
 
-JEMALLOC_ATTR(format(printf, 3, 4))
+JEMALLOC_FORMAT_PRINTF(3, 4)
 int
 malloc_snprintf(char *str, size_t size, const char *format, ...)
 {
 	int ret;
 	va_list ap;
 
@@ -620,26 +622,26 @@
 }
 
 /*
  * Print to a callback function in such a way as to (hopefully) avoid memory
  * allocation.
  */
-JEMALLOC_ATTR(format(printf, 3, 4))
+JEMALLOC_FORMAT_PRINTF(3, 4)
 void
 malloc_cprintf(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *format, ...)
 {
 	va_list ap;
 
 	va_start(ap, format);
 	malloc_vcprintf(write_cb, cbopaque, format, ap);
 	va_end(ap);
 }
 
 /* Print to stderr in such a way as to avoid memory allocation. */
-JEMALLOC_ATTR(format(printf, 1, 2))
+JEMALLOC_FORMAT_PRINTF(1, 2)
 void
 malloc_printf(const char *format, ...)
 {
 	va_list ap;
 
 	va_start(ap, format);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.d	2017-09-27 22:48:00.162963220 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.d	2017-09-27 22:49:23.550960164 +0800
@@ -1,20 +1,21 @@
 src/util.o: src/util.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
+ include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
  include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
  include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/util.h include/jemalloc/internal/atomic.h \
- include/jemalloc/internal/prng.h include/jemalloc/internal/ckh.h \
- include/jemalloc/internal/size_classes.h \
+ include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
  include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
- include/jemalloc/internal/base.h include/jemalloc/internal/chunk.h \
+ include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
+ include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
  include/jemalloc/internal/chunk_mmap.h include/jemalloc/internal/huge.h \
- include/jemalloc/internal/rtree.h include/jemalloc/internal/tcache.h \
- include/jemalloc/internal/hash.h include/jemalloc/internal/quarantine.h \
- include/jemalloc/internal/prof.h
+ include/jemalloc/internal/tcache.h include/jemalloc/internal/hash.h \
+ include/jemalloc/internal/quarantine.h include/jemalloc/internal/prof.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src: valgrind.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/zone.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/zone.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/zone.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/zone.c	2016-05-06 15:11:36.000000000 +0800
@@ -173,12 +173,13 @@
 
 	/*
 	 * If something else replaced the system default zone allocator, don't
 	 * register jemalloc's.
 	 */
 	malloc_zone_t *default_zone = malloc_default_zone();
+	malloc_zone_t *purgeable_zone = NULL;
 	if (!default_zone->zone_name ||
 	    strcmp(default_zone->zone_name, "DefaultMallocZone") != 0) {
 		return;
 	}
 
 	zone.size = (void *)zone_size;
@@ -234,25 +235,40 @@
 	 * default purgeable zone is created when the default zone is still
 	 * a scalable_zone.  As purgeable zones only exist on >= 10.6, we need
 	 * to check for the existence of malloc_default_purgeable_zone() at
 	 * run time.
 	 */
 	if (malloc_default_purgeable_zone != NULL)
-		malloc_default_purgeable_zone();
+		purgeable_zone = malloc_default_purgeable_zone();
 
 	/* Register the custom zone.  At this point it won't be the default. */
 	malloc_zone_register(&zone);
 
-	/*
-	 * Unregister and reregister the default zone.  On OSX >= 10.6,
-	 * unregistering takes the last registered zone and places it at the
-	 * location of the specified zone.  Unregistering the default zone thus
-	 * makes the last registered one the default.  On OSX < 10.6,
-	 * unregistering shifts all registered zones.  The first registered zone
-	 * then becomes the default.
-	 */
 	do {
 		default_zone = malloc_default_zone();
+		/*
+		 * Unregister and reregister the default zone.  On OSX >= 10.6,
+		 * unregistering takes the last registered zone and places it
+		 * at the location of the specified zone.  Unregistering the
+		 * default zone thus makes the last registered one the default.
+		 * On OSX < 10.6, unregistering shifts all registered zones.
+		 * The first registered zone then becomes the default.
+		 */
 		malloc_zone_unregister(default_zone);
 		malloc_zone_register(default_zone);
+		/*
+		 * On OSX 10.6, having the default purgeable zone appear before
+		 * the default zone makes some things crash because it thinks it
+		 * owns the default zone allocated pointers.  We thus
+		 * unregister/re-register it in order to ensure it's always
+		 * after the default zone.  On OSX < 10.6, there is no purgeable
+		 * zone, so this does nothing.  On OSX >= 10.6, unregistering
+		 * replaces the purgeable zone with the last registered zone
+		 * above, i.e. the default zone.  Registering it again then puts
+		 * it at the end, obviously after the default zone.
+		 */
+		if (purgeable_zone) {
+			malloc_zone_unregister(purgeable_zone);
+			malloc_zone_register(purgeable_zone);
+		}
 	} while (malloc_default_zone() != &zone);
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test: btalloc.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/jemalloc_test_defs.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/jemalloc_test_defs.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/jemalloc_test_defs.h	2017-09-27 22:47:53.334963470 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/jemalloc_test_defs.h	2017-09-27 22:49:15.138960472 +0800
@@ -1,6 +1,10 @@
 /* test/include/test/jemalloc_test_defs.h.  Generated from jemalloc_test_defs.h.in by configure.  */
 #include "jemalloc/internal/jemalloc_internal_defs.h"
+#include "jemalloc/internal/jemalloc_internal_decls.h"
 
-/* For use by SFMT. */
-#define HAVE_SSE2 
+/*
+ * For use by SFMT.  configure.ac doesn't actually define HAVE_SSE2 because its
+ * dependencies are notoriously unportable in practice.
+ */
+/* #undef HAVE_SSE2 */
 /* #undef HAVE_ALTIVEC */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/jemalloc_test_defs.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/jemalloc_test_defs.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/jemalloc_test_defs.h.in	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/jemalloc_test_defs.h.in	2016-05-06 15:11:36.000000000 +0800
@@ -1,5 +1,9 @@
 #include "jemalloc/internal/jemalloc_internal_defs.h"
+#include "jemalloc/internal/jemalloc_internal_decls.h"
 
-/* For use by SFMT. */
+/*
+ * For use by SFMT.  configure.ac doesn't actually define HAVE_SSE2 because its
+ * dependencies are notoriously unportable in practice.
+ */
 #undef HAVE_SSE2
 #undef HAVE_ALTIVEC
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/jemalloc_test.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/jemalloc_test.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/jemalloc_test.h	2017-09-27 22:47:53.286963472 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/jemalloc_test.h	2017-09-27 22:49:15.074960474 +0800
@@ -1,16 +1,24 @@
+#include <limits.h>
+#ifndef SIZE_T_MAX
+#  define SIZE_T_MAX	SIZE_MAX
+#endif
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <errno.h>
-#include <inttypes.h>
 #include <math.h>
 #include <string.h>
+#ifdef _WIN32
+#  include "msvc_compat/strings.h"
+#endif
+#include <sys/time.h>
 
 #ifdef _WIN32
 #  include <windows.h>
+#  include "msvc_compat/windows_extra.h"
 #else
 #  include <pthread.h>
 #endif
 
 /******************************************************************************/
 /*
@@ -129,13 +137,15 @@
 #endif
 
 /******************************************************************************/
 /*
  * Common test utilities.
  */
+#include "test/btalloc.h"
 #include "test/math.h"
 #include "test/mtx.h"
 #include "test/mq.h"
 #include "test/test.h"
+#include "test/timer.h"
 #include "test/thd.h"
 #define	MEXP 19937
 #include "test/SFMT.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/jemalloc_test.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/jemalloc_test.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/jemalloc_test.h.in	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/jemalloc_test.h.in	2016-05-06 15:11:36.000000000 +0800
@@ -1,16 +1,24 @@
+#include <limits.h>
+#ifndef SIZE_T_MAX
+#  define SIZE_T_MAX	SIZE_MAX
+#endif
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <errno.h>
-#include <inttypes.h>
 #include <math.h>
 #include <string.h>
+#ifdef _WIN32
+#  include "msvc_compat/strings.h"
+#endif
+#include <sys/time.h>
 
 #ifdef _WIN32
 #  include <windows.h>
+#  include "msvc_compat/windows_extra.h"
 #else
 #  include <pthread.h>
 #endif
 
 /******************************************************************************/
 /*
@@ -129,13 +137,15 @@
 #endif
 
 /******************************************************************************/
 /*
  * Common test utilities.
  */
+#include "test/btalloc.h"
 #include "test/math.h"
 #include "test/mtx.h"
 #include "test/mq.h"
 #include "test/test.h"
+#include "test/timer.h"
 #include "test/thd.h"
 #define	MEXP 19937
 #include "test/SFMT.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/math.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/math.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/math.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/math.h	2016-05-06 15:11:36.000000000 +0800
@@ -296,13 +296,13 @@
 
 	return (ch);
 }
 
 /*
  * Given a value p in [0..1] and Gamma distribution shape and scale parameters,
- * compute the upper limit on the definite integeral from [0..z] that satisfies
+ * compute the upper limit on the definite integral from [0..z] that satisfies
  * p.
  */
 JEMALLOC_INLINE double
 pt_gamma(double p, double shape, double scale, double ln_gamma_shape)
 {
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/mq.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/mq.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/mq.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/mq.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,6 +1,8 @@
+void	mq_nanosleep(unsigned ns);
+
 /*
  * Simple templated message queue implementation that relies on only mutexes for
  * synchronization (which reduces portability issues).  Given the following
  * setup:
  *
  *   typedef struct mq_msg_s mq_msg_t;
@@ -72,32 +74,29 @@
 	return (msg);							\
 }									\
 a_attr a_mq_msg_type *							\
 a_prefix##get(a_mq_type *mq)						\
 {									\
 	a_mq_msg_type *msg;						\
-	struct timespec timeout;					\
+	unsigned ns;							\
 									\
 	msg = a_prefix##tryget(mq);					\
 	if (msg != NULL)						\
 		return (msg);						\
 									\
-	timeout.tv_sec = 0;						\
-	timeout.tv_nsec = 1;						\
+	ns = 1;								\
 	while (true) {							\
-		nanosleep(&timeout, NULL);				\
+		mq_nanosleep(ns);					\
 		msg = a_prefix##tryget(mq);				\
 		if (msg != NULL)					\
 			return (msg);					\
-		if (timeout.tv_sec == 0) {				\
+		if (ns < 1000*1000*1000) {				\
 			/* Double sleep time, up to max 1 second. */	\
-			timeout.tv_nsec <<= 1;				\
-			if (timeout.tv_nsec >= 1000*1000*1000) {	\
-				timeout.tv_sec = 1;			\
-				timeout.tv_nsec = 0;			\
-			}						\
+			ns <<= 1;					\
+			if (ns > 1000*1000*1000)			\
+				ns = 1000*1000*1000;			\
 		}							\
 	}								\
 }									\
 a_attr void								\
 a_prefix##put(a_mq_type *mq, a_mq_msg_type *msg)			\
 {									\
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/test.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/test.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/test.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/test.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,287 +1,287 @@
 #define	ASSERT_BUFSIZE	256
 
-#define	assert_cmp(t, a, b, cmp, neg_cmp, pri, fmt...) do {		\
+#define	assert_cmp(t, a, b, cmp, neg_cmp, pri, ...) do {		\
 	t a_ = (a);							\
 	t b_ = (b);							\
 	if (!(a_ cmp b_)) {						\
 		char prefix[ASSERT_BUFSIZE];				\
 		char message[ASSERT_BUFSIZE];				\
 		malloc_snprintf(prefix, sizeof(prefix),			\
 		    "%s:%s:%d: Failed assertion: "			\
 		    "(%s) "#cmp" (%s) --> "				\
 		    "%"pri" "#neg_cmp" %"pri": ",			\
 		    __func__, __FILE__, __LINE__,			\
 		    #a, #b, a_, b_);					\
-		malloc_snprintf(message, sizeof(message), fmt);		\
+		malloc_snprintf(message, sizeof(message), __VA_ARGS__);	\
 		p_test_fail(prefix, message);				\
 	}								\
 } while (0)
 
-#define	assert_ptr_eq(a, b, fmt...)	assert_cmp(void *, a, b, ==,	\
-    !=, "p", fmt)
-#define	assert_ptr_ne(a, b, fmt...)	assert_cmp(void *, a, b, !=,	\
-    ==, "p", fmt)
-#define	assert_ptr_null(a, fmt...)	assert_cmp(void *, a, NULL, ==,	\
-    !=, "p", fmt)
-#define	assert_ptr_not_null(a, fmt...)	assert_cmp(void *, a, NULL, !=,	\
-    ==, "p", fmt)
-
-#define	assert_c_eq(a, b, fmt...)	assert_cmp(char, a, b, ==, !=, "c", fmt)
-#define	assert_c_ne(a, b, fmt...)	assert_cmp(char, a, b, !=, ==, "c", fmt)
-#define	assert_c_lt(a, b, fmt...)	assert_cmp(char, a, b, <, >=, "c", fmt)
-#define	assert_c_le(a, b, fmt...)	assert_cmp(char, a, b, <=, >, "c", fmt)
-#define	assert_c_ge(a, b, fmt...)	assert_cmp(char, a, b, >=, <, "c", fmt)
-#define	assert_c_gt(a, b, fmt...)	assert_cmp(char, a, b, >, <=, "c", fmt)
-
-#define	assert_x_eq(a, b, fmt...)	assert_cmp(int, a, b, ==, !=, "#x", fmt)
-#define	assert_x_ne(a, b, fmt...)	assert_cmp(int, a, b, !=, ==, "#x", fmt)
-#define	assert_x_lt(a, b, fmt...)	assert_cmp(int, a, b, <, >=, "#x", fmt)
-#define	assert_x_le(a, b, fmt...)	assert_cmp(int, a, b, <=, >, "#x", fmt)
-#define	assert_x_ge(a, b, fmt...)	assert_cmp(int, a, b, >=, <, "#x", fmt)
-#define	assert_x_gt(a, b, fmt...)	assert_cmp(int, a, b, >, <=, "#x", fmt)
-
-#define	assert_d_eq(a, b, fmt...)	assert_cmp(int, a, b, ==, !=, "d", fmt)
-#define	assert_d_ne(a, b, fmt...)	assert_cmp(int, a, b, !=, ==, "d", fmt)
-#define	assert_d_lt(a, b, fmt...)	assert_cmp(int, a, b, <, >=, "d", fmt)
-#define	assert_d_le(a, b, fmt...)	assert_cmp(int, a, b, <=, >, "d", fmt)
-#define	assert_d_ge(a, b, fmt...)	assert_cmp(int, a, b, >=, <, "d", fmt)
-#define	assert_d_gt(a, b, fmt...)	assert_cmp(int, a, b, >, <=, "d", fmt)
-
-#define	assert_u_eq(a, b, fmt...)	assert_cmp(int, a, b, ==, !=, "u", fmt)
-#define	assert_u_ne(a, b, fmt...)	assert_cmp(int, a, b, !=, ==, "u", fmt)
-#define	assert_u_lt(a, b, fmt...)	assert_cmp(int, a, b, <, >=, "u", fmt)
-#define	assert_u_le(a, b, fmt...)	assert_cmp(int, a, b, <=, >, "u", fmt)
-#define	assert_u_ge(a, b, fmt...)	assert_cmp(int, a, b, >=, <, "u", fmt)
-#define	assert_u_gt(a, b, fmt...)	assert_cmp(int, a, b, >, <=, "u", fmt)
-
-#define	assert_ld_eq(a, b, fmt...)	assert_cmp(long, a, b, ==,	\
-    !=, "ld", fmt)
-#define	assert_ld_ne(a, b, fmt...)	assert_cmp(long, a, b, !=,	\
-    ==, "ld", fmt)
-#define	assert_ld_lt(a, b, fmt...)	assert_cmp(long, a, b, <,	\
-    >=, "ld", fmt)
-#define	assert_ld_le(a, b, fmt...)	assert_cmp(long, a, b, <=,	\
-    >, "ld", fmt)
-#define	assert_ld_ge(a, b, fmt...)	assert_cmp(long, a, b, >=,	\
-    <, "ld", fmt)
-#define	assert_ld_gt(a, b, fmt...)	assert_cmp(long, a, b, >,	\
-    <=, "ld", fmt)
-
-#define	assert_lu_eq(a, b, fmt...)	assert_cmp(unsigned long,	\
-    a, b, ==, !=, "lu", fmt)
-#define	assert_lu_ne(a, b, fmt...)	assert_cmp(unsigned long,	\
-    a, b, !=, ==, "lu", fmt)
-#define	assert_lu_lt(a, b, fmt...)	assert_cmp(unsigned long,	\
-    a, b, <, >=, "lu", fmt)
-#define	assert_lu_le(a, b, fmt...)	assert_cmp(unsigned long,	\
-    a, b, <=, >, "lu", fmt)
-#define	assert_lu_ge(a, b, fmt...)	assert_cmp(unsigned long,	\
-    a, b, >=, <, "lu", fmt)
-#define	assert_lu_gt(a, b, fmt...)	assert_cmp(unsigned long,	\
-    a, b, >, <=, "lu", fmt)
-
-#define	assert_qd_eq(a, b, fmt...)	assert_cmp(long long, a, b, ==,	\
-    !=, "qd", fmt)
-#define	assert_qd_ne(a, b, fmt...)	assert_cmp(long long, a, b, !=,	\
-    ==, "qd", fmt)
-#define	assert_qd_lt(a, b, fmt...)	assert_cmp(long long, a, b, <,	\
-    >=, "qd", fmt)
-#define	assert_qd_le(a, b, fmt...)	assert_cmp(long long, a, b, <=,	\
-    >, "qd", fmt)
-#define	assert_qd_ge(a, b, fmt...)	assert_cmp(long long, a, b, >=,	\
-    <, "qd", fmt)
-#define	assert_qd_gt(a, b, fmt...)	assert_cmp(long long, a, b, >,	\
-    <=, "qd", fmt)
-
-#define	assert_qu_eq(a, b, fmt...)	assert_cmp(unsigned long long,	\
-    a, b, ==, !=, "qu", fmt)
-#define	assert_qu_ne(a, b, fmt...)	assert_cmp(unsigned long long,	\
-    a, b, !=, ==, "qu", fmt)
-#define	assert_qu_lt(a, b, fmt...)	assert_cmp(unsigned long long,	\
-    a, b, <, >=, "qu", fmt)
-#define	assert_qu_le(a, b, fmt...)	assert_cmp(unsigned long long,	\
-    a, b, <=, >, "qu", fmt)
-#define	assert_qu_ge(a, b, fmt...)	assert_cmp(unsigned long long,	\
-    a, b, >=, <, "qu", fmt)
-#define	assert_qu_gt(a, b, fmt...)	assert_cmp(unsigned long long,	\
-    a, b, >, <=, "qu", fmt)
-
-#define	assert_jd_eq(a, b, fmt...)	assert_cmp(intmax_t, a, b, ==,	\
-    !=, "jd", fmt)
-#define	assert_jd_ne(a, b, fmt...)	assert_cmp(intmax_t, a, b, !=,	\
-    ==, "jd", fmt)
-#define	assert_jd_lt(a, b, fmt...)	assert_cmp(intmax_t, a, b, <,	\
-    >=, "jd", fmt)
-#define	assert_jd_le(a, b, fmt...)	assert_cmp(intmax_t, a, b, <=,	\
-    >, "jd", fmt)
-#define	assert_jd_ge(a, b, fmt...)	assert_cmp(intmax_t, a, b, >=,	\
-    <, "jd", fmt)
-#define	assert_jd_gt(a, b, fmt...)	assert_cmp(intmax_t, a, b, >,	\
-    <=, "jd", fmt)
-
-#define	assert_ju_eq(a, b, fmt...)	assert_cmp(uintmax_t, a, b, ==,	\
-    !=, "ju", fmt)
-#define	assert_ju_ne(a, b, fmt...)	assert_cmp(uintmax_t, a, b, !=,	\
-    ==, "ju", fmt)
-#define	assert_ju_lt(a, b, fmt...)	assert_cmp(uintmax_t, a, b, <,	\
-    >=, "ju", fmt)
-#define	assert_ju_le(a, b, fmt...)	assert_cmp(uintmax_t, a, b, <=,	\
-    >, "ju", fmt)
-#define	assert_ju_ge(a, b, fmt...)	assert_cmp(uintmax_t, a, b, >=,	\
-    <, "ju", fmt)
-#define	assert_ju_gt(a, b, fmt...)	assert_cmp(uintmax_t, a, b, >,	\
-    <=, "ju", fmt)
-
-#define	assert_zd_eq(a, b, fmt...)	assert_cmp(ssize_t, a, b, ==,	\
-    !=, "zd", fmt)
-#define	assert_zd_ne(a, b, fmt...)	assert_cmp(ssize_t, a, b, !=,	\
-    ==, "zd", fmt)
-#define	assert_zd_lt(a, b, fmt...)	assert_cmp(ssize_t, a, b, <,	\
-    >=, "zd", fmt)
-#define	assert_zd_le(a, b, fmt...)	assert_cmp(ssize_t, a, b, <=,	\
-    >, "zd", fmt)
-#define	assert_zd_ge(a, b, fmt...)	assert_cmp(ssize_t, a, b, >=,	\
-    <, "zd", fmt)
-#define	assert_zd_gt(a, b, fmt...)	assert_cmp(ssize_t, a, b, >,	\
-    <=, "zd", fmt)
-
-#define	assert_zu_eq(a, b, fmt...)	assert_cmp(size_t, a, b, ==,	\
-    !=, "zu", fmt)
-#define	assert_zu_ne(a, b, fmt...)	assert_cmp(size_t, a, b, !=,	\
-    ==, "zu", fmt)
-#define	assert_zu_lt(a, b, fmt...)	assert_cmp(size_t, a, b, <,	\
-    >=, "zu", fmt)
-#define	assert_zu_le(a, b, fmt...)	assert_cmp(size_t, a, b, <=,	\
-    >, "zu", fmt)
-#define	assert_zu_ge(a, b, fmt...)	assert_cmp(size_t, a, b, >=,	\
-    <, "zu", fmt)
-#define	assert_zu_gt(a, b, fmt...)	assert_cmp(size_t, a, b, >,	\
-    <=, "zu", fmt)
-
-#define	assert_d32_eq(a, b, fmt...)	assert_cmp(int32_t, a, b, ==,	\
-    !=, PRId32, fmt)
-#define	assert_d32_ne(a, b, fmt...)	assert_cmp(int32_t, a, b, !=,	\
-    ==, PRId32, fmt)
-#define	assert_d32_lt(a, b, fmt...)	assert_cmp(int32_t, a, b, <,	\
-    >=, PRId32, fmt)
-#define	assert_d32_le(a, b, fmt...)	assert_cmp(int32_t, a, b, <=,	\
-    >, PRId32, fmt)
-#define	assert_d32_ge(a, b, fmt...)	assert_cmp(int32_t, a, b, >=,	\
-    <, PRId32, fmt)
-#define	assert_d32_gt(a, b, fmt...)	assert_cmp(int32_t, a, b, >,	\
-    <=, PRId32, fmt)
-
-#define	assert_u32_eq(a, b, fmt...)	assert_cmp(uint32_t, a, b, ==,	\
-    !=, PRIu32, fmt)
-#define	assert_u32_ne(a, b, fmt...)	assert_cmp(uint32_t, a, b, !=,	\
-    ==, PRIu32, fmt)
-#define	assert_u32_lt(a, b, fmt...)	assert_cmp(uint32_t, a, b, <,	\
-    >=, PRIu32, fmt)
-#define	assert_u32_le(a, b, fmt...)	assert_cmp(uint32_t, a, b, <=,	\
-    >, PRIu32, fmt)
-#define	assert_u32_ge(a, b, fmt...)	assert_cmp(uint32_t, a, b, >=,	\
-    <, PRIu32, fmt)
-#define	assert_u32_gt(a, b, fmt...)	assert_cmp(uint32_t, a, b, >,	\
-    <=, PRIu32, fmt)
-
-#define	assert_d64_eq(a, b, fmt...)	assert_cmp(int64_t, a, b, ==,	\
-    !=, PRId64, fmt)
-#define	assert_d64_ne(a, b, fmt...)	assert_cmp(int64_t, a, b, !=,	\
-    ==, PRId64, fmt)
-#define	assert_d64_lt(a, b, fmt...)	assert_cmp(int64_t, a, b, <,	\
-    >=, PRId64, fmt)
-#define	assert_d64_le(a, b, fmt...)	assert_cmp(int64_t, a, b, <=,	\
-    >, PRId64, fmt)
-#define	assert_d64_ge(a, b, fmt...)	assert_cmp(int64_t, a, b, >=,	\
-    <, PRId64, fmt)
-#define	assert_d64_gt(a, b, fmt...)	assert_cmp(int64_t, a, b, >,	\
-    <=, PRId64, fmt)
-
-#define	assert_u64_eq(a, b, fmt...)	assert_cmp(uint64_t, a, b, ==,	\
-    !=, PRIu64, fmt)
-#define	assert_u64_ne(a, b, fmt...)	assert_cmp(uint64_t, a, b, !=,	\
-    ==, PRIu64, fmt)
-#define	assert_u64_lt(a, b, fmt...)	assert_cmp(uint64_t, a, b, <,	\
-    >=, PRIu64, fmt)
-#define	assert_u64_le(a, b, fmt...)	assert_cmp(uint64_t, a, b, <=,	\
-    >, PRIu64, fmt)
-#define	assert_u64_ge(a, b, fmt...)	assert_cmp(uint64_t, a, b, >=,	\
-    <, PRIu64, fmt)
-#define	assert_u64_gt(a, b, fmt...)	assert_cmp(uint64_t, a, b, >,	\
-    <=, PRIu64, fmt)
+#define	assert_ptr_eq(a, b, ...)	assert_cmp(void *, a, b, ==,	\
+    !=, "p", __VA_ARGS__)
+#define	assert_ptr_ne(a, b, ...)	assert_cmp(void *, a, b, !=,	\
+    ==, "p", __VA_ARGS__)
+#define	assert_ptr_null(a, ...)		assert_cmp(void *, a, NULL, ==,	\
+    !=, "p", __VA_ARGS__)
+#define	assert_ptr_not_null(a, ...)	assert_cmp(void *, a, NULL, !=,	\
+    ==, "p", __VA_ARGS__)
+
+#define	assert_c_eq(a, b, ...)	assert_cmp(char, a, b, ==, !=, "c", __VA_ARGS__)
+#define	assert_c_ne(a, b, ...)	assert_cmp(char, a, b, !=, ==, "c", __VA_ARGS__)
+#define	assert_c_lt(a, b, ...)	assert_cmp(char, a, b, <, >=, "c", __VA_ARGS__)
+#define	assert_c_le(a, b, ...)	assert_cmp(char, a, b, <=, >, "c", __VA_ARGS__)
+#define	assert_c_ge(a, b, ...)	assert_cmp(char, a, b, >=, <, "c", __VA_ARGS__)
+#define	assert_c_gt(a, b, ...)	assert_cmp(char, a, b, >, <=, "c", __VA_ARGS__)
+
+#define	assert_x_eq(a, b, ...)	assert_cmp(int, a, b, ==, !=, "#x", __VA_ARGS__)
+#define	assert_x_ne(a, b, ...)	assert_cmp(int, a, b, !=, ==, "#x", __VA_ARGS__)
+#define	assert_x_lt(a, b, ...)	assert_cmp(int, a, b, <, >=, "#x", __VA_ARGS__)
+#define	assert_x_le(a, b, ...)	assert_cmp(int, a, b, <=, >, "#x", __VA_ARGS__)
+#define	assert_x_ge(a, b, ...)	assert_cmp(int, a, b, >=, <, "#x", __VA_ARGS__)
+#define	assert_x_gt(a, b, ...)	assert_cmp(int, a, b, >, <=, "#x", __VA_ARGS__)
+
+#define	assert_d_eq(a, b, ...)	assert_cmp(int, a, b, ==, !=, "d", __VA_ARGS__)
+#define	assert_d_ne(a, b, ...)	assert_cmp(int, a, b, !=, ==, "d", __VA_ARGS__)
+#define	assert_d_lt(a, b, ...)	assert_cmp(int, a, b, <, >=, "d", __VA_ARGS__)
+#define	assert_d_le(a, b, ...)	assert_cmp(int, a, b, <=, >, "d", __VA_ARGS__)
+#define	assert_d_ge(a, b, ...)	assert_cmp(int, a, b, >=, <, "d", __VA_ARGS__)
+#define	assert_d_gt(a, b, ...)	assert_cmp(int, a, b, >, <=, "d", __VA_ARGS__)
+
+#define	assert_u_eq(a, b, ...)	assert_cmp(int, a, b, ==, !=, "u", __VA_ARGS__)
+#define	assert_u_ne(a, b, ...)	assert_cmp(int, a, b, !=, ==, "u", __VA_ARGS__)
+#define	assert_u_lt(a, b, ...)	assert_cmp(int, a, b, <, >=, "u", __VA_ARGS__)
+#define	assert_u_le(a, b, ...)	assert_cmp(int, a, b, <=, >, "u", __VA_ARGS__)
+#define	assert_u_ge(a, b, ...)	assert_cmp(int, a, b, >=, <, "u", __VA_ARGS__)
+#define	assert_u_gt(a, b, ...)	assert_cmp(int, a, b, >, <=, "u", __VA_ARGS__)
+
+#define	assert_ld_eq(a, b, ...)	assert_cmp(long, a, b, ==,	\
+    !=, "ld", __VA_ARGS__)
+#define	assert_ld_ne(a, b, ...)	assert_cmp(long, a, b, !=,	\
+    ==, "ld", __VA_ARGS__)
+#define	assert_ld_lt(a, b, ...)	assert_cmp(long, a, b, <,	\
+    >=, "ld", __VA_ARGS__)
+#define	assert_ld_le(a, b, ...)	assert_cmp(long, a, b, <=,	\
+    >, "ld", __VA_ARGS__)
+#define	assert_ld_ge(a, b, ...)	assert_cmp(long, a, b, >=,	\
+    <, "ld", __VA_ARGS__)
+#define	assert_ld_gt(a, b, ...)	assert_cmp(long, a, b, >,	\
+    <=, "ld", __VA_ARGS__)
+
+#define	assert_lu_eq(a, b, ...)	assert_cmp(unsigned long,	\
+    a, b, ==, !=, "lu", __VA_ARGS__)
+#define	assert_lu_ne(a, b, ...)	assert_cmp(unsigned long,	\
+    a, b, !=, ==, "lu", __VA_ARGS__)
+#define	assert_lu_lt(a, b, ...)	assert_cmp(unsigned long,	\
+    a, b, <, >=, "lu", __VA_ARGS__)
+#define	assert_lu_le(a, b, ...)	assert_cmp(unsigned long,	\
+    a, b, <=, >, "lu", __VA_ARGS__)
+#define	assert_lu_ge(a, b, ...)	assert_cmp(unsigned long,	\
+    a, b, >=, <, "lu", __VA_ARGS__)
+#define	assert_lu_gt(a, b, ...)	assert_cmp(unsigned long,	\
+    a, b, >, <=, "lu", __VA_ARGS__)
+
+#define	assert_qd_eq(a, b, ...)	assert_cmp(long long, a, b, ==,	\
+    !=, "qd", __VA_ARGS__)
+#define	assert_qd_ne(a, b, ...)	assert_cmp(long long, a, b, !=,	\
+    ==, "qd", __VA_ARGS__)
+#define	assert_qd_lt(a, b, ...)	assert_cmp(long long, a, b, <,	\
+    >=, "qd", __VA_ARGS__)
+#define	assert_qd_le(a, b, ...)	assert_cmp(long long, a, b, <=,	\
+    >, "qd", __VA_ARGS__)
+#define	assert_qd_ge(a, b, ...)	assert_cmp(long long, a, b, >=,	\
+    <, "qd", __VA_ARGS__)
+#define	assert_qd_gt(a, b, ...)	assert_cmp(long long, a, b, >,	\
+    <=, "qd", __VA_ARGS__)
+
+#define	assert_qu_eq(a, b, ...)	assert_cmp(unsigned long long,	\
+    a, b, ==, !=, "qu", __VA_ARGS__)
+#define	assert_qu_ne(a, b, ...)	assert_cmp(unsigned long long,	\
+    a, b, !=, ==, "qu", __VA_ARGS__)
+#define	assert_qu_lt(a, b, ...)	assert_cmp(unsigned long long,	\
+    a, b, <, >=, "qu", __VA_ARGS__)
+#define	assert_qu_le(a, b, ...)	assert_cmp(unsigned long long,	\
+    a, b, <=, >, "qu", __VA_ARGS__)
+#define	assert_qu_ge(a, b, ...)	assert_cmp(unsigned long long,	\
+    a, b, >=, <, "qu", __VA_ARGS__)
+#define	assert_qu_gt(a, b, ...)	assert_cmp(unsigned long long,	\
+    a, b, >, <=, "qu", __VA_ARGS__)
+
+#define	assert_jd_eq(a, b, ...)	assert_cmp(intmax_t, a, b, ==,	\
+    !=, "jd", __VA_ARGS__)
+#define	assert_jd_ne(a, b, ...)	assert_cmp(intmax_t, a, b, !=,	\
+    ==, "jd", __VA_ARGS__)
+#define	assert_jd_lt(a, b, ...)	assert_cmp(intmax_t, a, b, <,	\
+    >=, "jd", __VA_ARGS__)
+#define	assert_jd_le(a, b, ...)	assert_cmp(intmax_t, a, b, <=,	\
+    >, "jd", __VA_ARGS__)
+#define	assert_jd_ge(a, b, ...)	assert_cmp(intmax_t, a, b, >=,	\
+    <, "jd", __VA_ARGS__)
+#define	assert_jd_gt(a, b, ...)	assert_cmp(intmax_t, a, b, >,	\
+    <=, "jd", __VA_ARGS__)
+
+#define	assert_ju_eq(a, b, ...)	assert_cmp(uintmax_t, a, b, ==,	\
+    !=, "ju", __VA_ARGS__)
+#define	assert_ju_ne(a, b, ...)	assert_cmp(uintmax_t, a, b, !=,	\
+    ==, "ju", __VA_ARGS__)
+#define	assert_ju_lt(a, b, ...)	assert_cmp(uintmax_t, a, b, <,	\
+    >=, "ju", __VA_ARGS__)
+#define	assert_ju_le(a, b, ...)	assert_cmp(uintmax_t, a, b, <=,	\
+    >, "ju", __VA_ARGS__)
+#define	assert_ju_ge(a, b, ...)	assert_cmp(uintmax_t, a, b, >=,	\
+    <, "ju", __VA_ARGS__)
+#define	assert_ju_gt(a, b, ...)	assert_cmp(uintmax_t, a, b, >,	\
+    <=, "ju", __VA_ARGS__)
+
+#define	assert_zd_eq(a, b, ...)	assert_cmp(ssize_t, a, b, ==,	\
+    !=, "zd", __VA_ARGS__)
+#define	assert_zd_ne(a, b, ...)	assert_cmp(ssize_t, a, b, !=,	\
+    ==, "zd", __VA_ARGS__)
+#define	assert_zd_lt(a, b, ...)	assert_cmp(ssize_t, a, b, <,	\
+    >=, "zd", __VA_ARGS__)
+#define	assert_zd_le(a, b, ...)	assert_cmp(ssize_t, a, b, <=,	\
+    >, "zd", __VA_ARGS__)
+#define	assert_zd_ge(a, b, ...)	assert_cmp(ssize_t, a, b, >=,	\
+    <, "zd", __VA_ARGS__)
+#define	assert_zd_gt(a, b, ...)	assert_cmp(ssize_t, a, b, >,	\
+    <=, "zd", __VA_ARGS__)
+
+#define	assert_zu_eq(a, b, ...)	assert_cmp(size_t, a, b, ==,	\
+    !=, "zu", __VA_ARGS__)
+#define	assert_zu_ne(a, b, ...)	assert_cmp(size_t, a, b, !=,	\
+    ==, "zu", __VA_ARGS__)
+#define	assert_zu_lt(a, b, ...)	assert_cmp(size_t, a, b, <,	\
+    >=, "zu", __VA_ARGS__)
+#define	assert_zu_le(a, b, ...)	assert_cmp(size_t, a, b, <=,	\
+    >, "zu", __VA_ARGS__)
+#define	assert_zu_ge(a, b, ...)	assert_cmp(size_t, a, b, >=,	\
+    <, "zu", __VA_ARGS__)
+#define	assert_zu_gt(a, b, ...)	assert_cmp(size_t, a, b, >,	\
+    <=, "zu", __VA_ARGS__)
+
+#define	assert_d32_eq(a, b, ...)	assert_cmp(int32_t, a, b, ==,	\
+    !=, FMTd32, __VA_ARGS__)
+#define	assert_d32_ne(a, b, ...)	assert_cmp(int32_t, a, b, !=,	\
+    ==, FMTd32, __VA_ARGS__)
+#define	assert_d32_lt(a, b, ...)	assert_cmp(int32_t, a, b, <,	\
+    >=, FMTd32, __VA_ARGS__)
+#define	assert_d32_le(a, b, ...)	assert_cmp(int32_t, a, b, <=,	\
+    >, FMTd32, __VA_ARGS__)
+#define	assert_d32_ge(a, b, ...)	assert_cmp(int32_t, a, b, >=,	\
+    <, FMTd32, __VA_ARGS__)
+#define	assert_d32_gt(a, b, ...)	assert_cmp(int32_t, a, b, >,	\
+    <=, FMTd32, __VA_ARGS__)
+
+#define	assert_u32_eq(a, b, ...)	assert_cmp(uint32_t, a, b, ==,	\
+    !=, FMTu32, __VA_ARGS__)
+#define	assert_u32_ne(a, b, ...)	assert_cmp(uint32_t, a, b, !=,	\
+    ==, FMTu32, __VA_ARGS__)
+#define	assert_u32_lt(a, b, ...)	assert_cmp(uint32_t, a, b, <,	\
+    >=, FMTu32, __VA_ARGS__)
+#define	assert_u32_le(a, b, ...)	assert_cmp(uint32_t, a, b, <=,	\
+    >, FMTu32, __VA_ARGS__)
+#define	assert_u32_ge(a, b, ...)	assert_cmp(uint32_t, a, b, >=,	\
+    <, FMTu32, __VA_ARGS__)
+#define	assert_u32_gt(a, b, ...)	assert_cmp(uint32_t, a, b, >,	\
+    <=, FMTu32, __VA_ARGS__)
+
+#define	assert_d64_eq(a, b, ...)	assert_cmp(int64_t, a, b, ==,	\
+    !=, FMTd64, __VA_ARGS__)
+#define	assert_d64_ne(a, b, ...)	assert_cmp(int64_t, a, b, !=,	\
+    ==, FMTd64, __VA_ARGS__)
+#define	assert_d64_lt(a, b, ...)	assert_cmp(int64_t, a, b, <,	\
+    >=, FMTd64, __VA_ARGS__)
+#define	assert_d64_le(a, b, ...)	assert_cmp(int64_t, a, b, <=,	\
+    >, FMTd64, __VA_ARGS__)
+#define	assert_d64_ge(a, b, ...)	assert_cmp(int64_t, a, b, >=,	\
+    <, FMTd64, __VA_ARGS__)
+#define	assert_d64_gt(a, b, ...)	assert_cmp(int64_t, a, b, >,	\
+    <=, FMTd64, __VA_ARGS__)
+
+#define	assert_u64_eq(a, b, ...)	assert_cmp(uint64_t, a, b, ==,	\
+    !=, FMTu64, __VA_ARGS__)
+#define	assert_u64_ne(a, b, ...)	assert_cmp(uint64_t, a, b, !=,	\
+    ==, FMTu64, __VA_ARGS__)
+#define	assert_u64_lt(a, b, ...)	assert_cmp(uint64_t, a, b, <,	\
+    >=, FMTu64, __VA_ARGS__)
+#define	assert_u64_le(a, b, ...)	assert_cmp(uint64_t, a, b, <=,	\
+    >, FMTu64, __VA_ARGS__)
+#define	assert_u64_ge(a, b, ...)	assert_cmp(uint64_t, a, b, >=,	\
+    <, FMTu64, __VA_ARGS__)
+#define	assert_u64_gt(a, b, ...)	assert_cmp(uint64_t, a, b, >,	\
+    <=, FMTu64, __VA_ARGS__)
 
-#define	assert_b_eq(a, b, fmt...) do {					\
+#define	assert_b_eq(a, b, ...) do {					\
 	bool a_ = (a);							\
 	bool b_ = (b);							\
 	if (!(a_ == b_)) {						\
 		char prefix[ASSERT_BUFSIZE];				\
 		char message[ASSERT_BUFSIZE];				\
 		malloc_snprintf(prefix, sizeof(prefix),			\
 		    "%s:%s:%d: Failed assertion: "			\
 		    "(%s) == (%s) --> %s != %s: ",			\
 		    __func__, __FILE__, __LINE__,			\
 		    #a, #b, a_ ? "true" : "false",			\
 		    b_ ? "true" : "false");				\
-		malloc_snprintf(message, sizeof(message), fmt);		\
+		malloc_snprintf(message, sizeof(message), __VA_ARGS__);	\
 		p_test_fail(prefix, message);				\
 	}								\
 } while (0)
-#define	assert_b_ne(a, b, fmt...) do {					\
+#define	assert_b_ne(a, b, ...) do {					\
 	bool a_ = (a);							\
 	bool b_ = (b);							\
 	if (!(a_ != b_)) {						\
 		char prefix[ASSERT_BUFSIZE];				\
 		char message[ASSERT_BUFSIZE];				\
 		malloc_snprintf(prefix, sizeof(prefix),			\
 		    "%s:%s:%d: Failed assertion: "			\
 		    "(%s) != (%s) --> %s == %s: ",			\
 		    __func__, __FILE__, __LINE__,			\
 		    #a, #b, a_ ? "true" : "false",			\
 		    b_ ? "true" : "false");				\
-		malloc_snprintf(message, sizeof(message), fmt);		\
+		malloc_snprintf(message, sizeof(message), __VA_ARGS__);	\
 		p_test_fail(prefix, message);				\
 	}								\
 } while (0)
-#define	assert_true(a, fmt...)	assert_b_eq(a, true, fmt)
-#define	assert_false(a, fmt...)	assert_b_eq(a, false, fmt)
+#define	assert_true(a, ...)	assert_b_eq(a, true, __VA_ARGS__)
+#define	assert_false(a, ...)	assert_b_eq(a, false, __VA_ARGS__)
 
-#define	assert_str_eq(a, b, fmt...) do {				\
+#define	assert_str_eq(a, b, ...) do {				\
 	if (strcmp((a), (b))) {						\
 		char prefix[ASSERT_BUFSIZE];				\
 		char message[ASSERT_BUFSIZE];				\
 		malloc_snprintf(prefix, sizeof(prefix),			\
 		    "%s:%s:%d: Failed assertion: "			\
 		    "(%s) same as (%s) --> "				\
 		    "\"%s\" differs from \"%s\": ",			\
 		    __func__, __FILE__, __LINE__, #a, #b, a, b);	\
-		malloc_snprintf(message, sizeof(message), fmt);		\
+		malloc_snprintf(message, sizeof(message), __VA_ARGS__);	\
 		p_test_fail(prefix, message);				\
 	}								\
 } while (0)
-#define	assert_str_ne(a, b, fmt...) do {				\
+#define	assert_str_ne(a, b, ...) do {				\
 	if (!strcmp((a), (b))) {					\
 		char prefix[ASSERT_BUFSIZE];				\
 		char message[ASSERT_BUFSIZE];				\
 		malloc_snprintf(prefix, sizeof(prefix),			\
 		    "%s:%s:%d: Failed assertion: "			\
 		    "(%s) differs from (%s) --> "			\
 		    "\"%s\" same as \"%s\": ",				\
 		    __func__, __FILE__, __LINE__, #a, #b, a, b);	\
-		malloc_snprintf(message, sizeof(message), fmt);		\
+		malloc_snprintf(message, sizeof(message), __VA_ARGS__);	\
 		p_test_fail(prefix, message);				\
 	}								\
 } while (0)
 
-#define	assert_not_reached(fmt...) do {					\
+#define	assert_not_reached(...) do {					\
 	char prefix[ASSERT_BUFSIZE];					\
 	char message[ASSERT_BUFSIZE];					\
 	malloc_snprintf(prefix, sizeof(prefix),				\
 	    "%s:%s:%d: Unreachable code reached: ",			\
 	    __func__, __FILE__, __LINE__);				\
-	malloc_snprintf(message, sizeof(message), fmt);			\
+	malloc_snprintf(message, sizeof(message), __VA_ARGS__);		\
 	p_test_fail(prefix, message);					\
 } while (0)
 
 /*
  * If this enum changes, corresponding changes in test/test.sh.in are also
  * necessary.
@@ -305,25 +305,25 @@
 #define	TEST_END							\
 	goto label_test_end;						\
 label_test_end:								\
 	p_test_fini();							\
 }
 
-#define	test(tests...)							\
-	p_test(tests, NULL)
+#define	test(...)							\
+	p_test(__VA_ARGS__, NULL)
 
 #define	test_skip_if(e) do {						\
 	if (e) {							\
 		test_skip("%s:%s:%d: Test skipped: (%s)",		\
 		    __func__, __FILE__, __LINE__, #e);			\
 		goto label_test_end;					\
 	}								\
 } while (0)
 
-void	test_skip(const char *format, ...) JEMALLOC_ATTR(format(printf, 1, 2));
-void	test_fail(const char *format, ...) JEMALLOC_ATTR(format(printf, 1, 2));
+void	test_skip(const char *format, ...) JEMALLOC_FORMAT_PRINTF(1, 2);
+void	test_fail(const char *format, ...) JEMALLOC_FORMAT_PRINTF(1, 2);
 
 /* For private use by macros. */
-test_status_t	p_test(test_t* t, ...);
+test_status_t	p_test(test_t *t, ...);
 void	p_test_init(const char *name);
 void	p_test_fini(void);
 void	p_test_fail(const char *prefix, const char *message);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/thd.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/thd.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/include/test/thd.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test/thd.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,7 +1,7 @@
-/* Abstraction layer for threading in tests */
+/* Abstraction layer for threading in tests. */
 #ifdef _WIN32
 typedef HANDLE thd_t;
 #else
 typedef pthread_t thd_t;
 #endif
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/include/test: timer.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration: allocm.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration: chunk.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration/MALLOCX_ARENA.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration/MALLOCX_ARENA.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration/MALLOCX_ARENA.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration/MALLOCX_ARENA.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,10 +1,18 @@
 #include "test/jemalloc_test.h"
 
 #define	NTHREADS 10
 
+static bool have_dss =
+#ifdef JEMALLOC_DSS
+    true
+#else
+    false
+#endif
+    ;
+
 void *
 thd_start(void *arg)
 {
 	unsigned thread_ind = (unsigned)(uintptr_t)arg;
 	unsigned arena_ind;
 	void *p;
@@ -15,29 +23,32 @@
 	    "Error in arenas.extend");
 
 	if (thread_ind % 4 != 3) {
 		size_t mib[3];
 		size_t miblen = sizeof(mib) / sizeof(size_t);
 		const char *dss_precs[] = {"disabled", "primary", "secondary"};
-		const char *dss = dss_precs[thread_ind %
-		    (sizeof(dss_precs)/sizeof(char*))];
+		unsigned prec_ind = thread_ind %
+		    (sizeof(dss_precs)/sizeof(char*));
+		const char *dss = dss_precs[prec_ind];
+		int expected_err = (have_dss || prec_ind == 0) ? 0 : EFAULT;
 		assert_d_eq(mallctlnametomib("arena.0.dss", mib, &miblen), 0,
 		    "Error in mallctlnametomib()");
 		mib[1] = arena_ind;
 		assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, (void *)&dss,
-		    sizeof(const char *)), 0, "Error in mallctlbymib()");
+		    sizeof(const char *)), expected_err,
+		    "Error in mallctlbymib()");
 	}
 
 	p = mallocx(1, MALLOCX_ARENA(arena_ind));
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 	dallocx(p, 0);
 
 	return (NULL);
 }
 
-TEST_BEGIN(test_ALLOCM_ARENA)
+TEST_BEGIN(test_MALLOCX_ARENA)
 {
 	thd_t thds[NTHREADS];
 	unsigned i;
 
 	for (i = 0; i < NTHREADS; i++) {
 		thd_create(&thds[i], thd_start,
@@ -51,8 +62,8 @@
 
 int
 main(void)
 {
 
 	return (test(
-	    test_ALLOCM_ARENA));
+	    test_MALLOCX_ARENA));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration/mallocx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration/mallocx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration/mallocx.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration/mallocx.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,43 +1,125 @@
 #include "test/jemalloc_test.h"
 
-#define	CHUNK 0x400000
-#define	MAXALIGN (((size_t)1) << 25)
-#define	NITER 4
+static unsigned
+get_nsizes_impl(const char *cmd)
+{
+	unsigned ret;
+	size_t z;
+
+	z = sizeof(unsigned);
+	assert_d_eq(mallctl(cmd, &ret, &z, NULL, 0), 0,
+	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
+
+	return (ret);
+}
+
+static unsigned
+get_nhuge(void)
+{
+
+	return (get_nsizes_impl("arenas.nhchunks"));
+}
+
+static size_t
+get_size_impl(const char *cmd, size_t ind)
+{
+	size_t ret;
+	size_t z;
+	size_t mib[4];
+	size_t miblen = 4;
+
+	z = sizeof(size_t);
+	assert_d_eq(mallctlnametomib(cmd, mib, &miblen),
+	    0, "Unexpected mallctlnametomib(\"%s\", ...) failure", cmd);
+	mib[2] = ind;
+	z = sizeof(size_t);
+	assert_d_eq(mallctlbymib(mib, miblen, &ret, &z, NULL, 0),
+	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
+
+	return (ret);
+}
+
+static size_t
+get_huge_size(size_t ind)
+{
+
+	return (get_size_impl("arenas.hchunk.0.size", ind));
+}
+
+TEST_BEGIN(test_oom)
+{
+	size_t hugemax, size, alignment;
+
+	hugemax = get_huge_size(get_nhuge()-1);
+
+	/*
+	 * It should be impossible to allocate two objects that each consume
+	 * more than half the virtual address space.
+	 */
+	{
+		void *p;
+
+		p = mallocx(hugemax, 0);
+		if (p != NULL) {
+			assert_ptr_null(mallocx(hugemax, 0),
+			    "Expected OOM for mallocx(size=%#zx, 0)", hugemax);
+			dallocx(p, 0);
+		}
+	}
+
+#if LG_SIZEOF_PTR == 3
+	size      = ZU(0x8000000000000000);
+	alignment = ZU(0x8000000000000000);
+#else
+	size      = ZU(0x80000000);
+	alignment = ZU(0x80000000);
+#endif
+	assert_ptr_null(mallocx(size, MALLOCX_ALIGN(alignment)),
+	    "Expected OOM for mallocx(size=%#zx, MALLOCX_ALIGN(%#zx)", size,
+	    alignment);
+}
+TEST_END
 
 TEST_BEGIN(test_basic)
 {
-	size_t nsz, rsz, sz;
-	void *p;
+#define	MAXSZ (((size_t)1) << 26)
+	size_t sz;
 
-	sz = 42;
-	nsz = nallocx(sz, 0);
-	assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
-	p = mallocx(sz, 0);
-	assert_ptr_not_null(p, "Unexpected mallocx() error");
-	rsz = sallocx(p, 0);
-	assert_zu_ge(rsz, sz, "Real size smaller than expected");
-	assert_zu_eq(nsz, rsz, "nallocx()/sallocx() size mismatch");
-	dallocx(p, 0);
-
-	p = mallocx(sz, 0);
-	assert_ptr_not_null(p, "Unexpected mallocx() error");
-	dallocx(p, 0);
-
-	nsz = nallocx(sz, MALLOCX_ZERO);
-	assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
-	p = mallocx(sz, MALLOCX_ZERO);
-	assert_ptr_not_null(p, "Unexpected mallocx() error");
-	rsz = sallocx(p, 0);
-	assert_zu_eq(nsz, rsz, "nallocx()/sallocx() rsize mismatch");
-	dallocx(p, 0);
+	for (sz = 1; sz < MAXSZ; sz = nallocx(sz, 0) + 1) {
+		size_t nsz, rsz;
+		void *p;
+		nsz = nallocx(sz, 0);
+		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
+		p = mallocx(sz, 0);
+		assert_ptr_not_null(p, "Unexpected mallocx() error");
+		rsz = sallocx(p, 0);
+		assert_zu_ge(rsz, sz, "Real size smaller than expected");
+		assert_zu_eq(nsz, rsz, "nallocx()/sallocx() size mismatch");
+		dallocx(p, 0);
+
+		p = mallocx(sz, 0);
+		assert_ptr_not_null(p, "Unexpected mallocx() error");
+		dallocx(p, 0);
+
+		nsz = nallocx(sz, MALLOCX_ZERO);
+		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
+		p = mallocx(sz, MALLOCX_ZERO);
+		assert_ptr_not_null(p, "Unexpected mallocx() error");
+		rsz = sallocx(p, 0);
+		assert_zu_eq(nsz, rsz, "nallocx()/sallocx() rsize mismatch");
+		dallocx(p, 0);
+	}
+#undef MAXSZ
 }
 TEST_END
 
 TEST_BEGIN(test_alignment_and_size)
 {
+#define	MAXALIGN (((size_t)1) << 25)
+#define	NITER 4
 	size_t nsz, rsz, sz, alignment, total;
 	unsigned i;
 	void *ps[NITER];
 
 	for (i = 0; i < NITER; i++)
 		ps[i] = NULL;
@@ -81,17 +163,20 @@
 					dallocx(ps[i], 0);
 					ps[i] = NULL;
 				}
 			}
 		}
 	}
+#undef MAXALIGN
+#undef NITER
 }
 TEST_END
 
 int
 main(void)
 {
 
 	return (test(
+	    test_oom,
 	    test_basic,
 	    test_alignment_and_size));
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration: mremap.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration: overflow.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration: rallocm.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration/rallocx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration/rallocx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration/rallocx.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration/rallocx.c	2016-05-06 15:11:36.000000000 +0800
@@ -19,13 +19,13 @@
 			q = rallocx(p, szs[j-1]+1, 0);
 			assert_ptr_not_null(q,
 			    "Unexpected rallocx() error for size=%zu-->%zu",
 			    szs[j-1], szs[j-1]+1);
 			szs[j] = sallocx(q, 0);
 			assert_zu_ne(szs[j], szs[j-1]+1,
-			    "Expected size to at least: %zu", szs[j-1]+1);
+			    "Expected size to be at least: %zu", szs[j-1]+1);
 			p = q;
 		}
 
 		for (j--; j > 0; j--) {
 			q = rallocx(p, szs[j-1], 0);
 			assert_ptr_not_null(q,
@@ -52,14 +52,15 @@
 	const uint8_t *buf = (const uint8_t *)p;
 	size_t i;
 
 	for (i = 0; i < len; i++) {
 		uint8_t b = buf[offset+i];
 		if (b != c) {
-			test_fail("Allocation at %p contains %#x rather than "
-			    "%#x at offset %zu", p, b, c, offset+i);
+			test_fail("Allocation at %p (len=%zu) contains %#x "
+			    "rather than %#x at offset %zu", p, len, b, c,
+			    offset+i);
 			ret = true;
 		}
 	}
 
 	return (ret);
 }
@@ -92,13 +93,14 @@
 				assert_false(validate_fill(q, FILL_BYTE, 0,
 				    psz), "Expected filled memory");
 				assert_false(validate_fill(q, 0, psz, qsz-psz),
 				    "Expected zeroed memory");
 			}
 			if (psz != qsz) {
-				memset(q+psz, FILL_BYTE, qsz-psz);
+				memset((void *)((uintptr_t)q+psz), FILL_BYTE,
+				    qsz-psz);
 				psz = qsz;
 			}
 			p = q;
 		}
 		assert_false(validate_fill(p, FILL_BYTE, 0, psz),
 		    "Expected filled memory");
@@ -156,14 +158,15 @@
 		if ((sz << 1) <= MAX_VALIDATE) {
 			assert_false(validate_fill(q, 0, 0, sz),
 			    "Expected zeroed memory");
 		} else {
 			assert_false(validate_fill(q, 0, 0, MAX_VALIDATE),
 			    "Expected zeroed memory");
-			assert_false(validate_fill(q+sz-MAX_VALIDATE, 0, 0,
-			    MAX_VALIDATE), "Expected zeroed memory");
+			assert_false(validate_fill(
+			    (void *)((uintptr_t)q+sz-MAX_VALIDATE),
+			    0, 0, MAX_VALIDATE), "Expected zeroed memory");
 		}
 		p = q;
 	}
 	dallocx(p, 0);
 #undef MAX_VALIDATE
 #undef MAX_LG_ALIGN
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration: sdallocx.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration/xallocx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration/xallocx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/integration/xallocx.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/integration/xallocx.c	2016-05-06 15:11:36.000000000 +0800
@@ -45,15 +45,427 @@
 	assert_zu_eq(tsz, sz, "Unexpected size change: %zu --> %zu", sz, tsz);
 
 	dallocx(p, 0);
 }
 TEST_END
 
+static unsigned
+get_nsizes_impl(const char *cmd)
+{
+	unsigned ret;
+	size_t z;
+
+	z = sizeof(unsigned);
+	assert_d_eq(mallctl(cmd, &ret, &z, NULL, 0), 0,
+	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
+
+	return (ret);
+}
+
+static unsigned
+get_nsmall(void)
+{
+
+	return (get_nsizes_impl("arenas.nbins"));
+}
+
+static unsigned
+get_nlarge(void)
+{
+
+	return (get_nsizes_impl("arenas.nlruns"));
+}
+
+static unsigned
+get_nhuge(void)
+{
+
+	return (get_nsizes_impl("arenas.nhchunks"));
+}
+
+static size_t
+get_size_impl(const char *cmd, size_t ind)
+{
+	size_t ret;
+	size_t z;
+	size_t mib[4];
+	size_t miblen = 4;
+
+	z = sizeof(size_t);
+	assert_d_eq(mallctlnametomib(cmd, mib, &miblen),
+	    0, "Unexpected mallctlnametomib(\"%s\", ...) failure", cmd);
+	mib[2] = ind;
+	z = sizeof(size_t);
+	assert_d_eq(mallctlbymib(mib, miblen, &ret, &z, NULL, 0),
+	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
+
+	return (ret);
+}
+
+static size_t
+get_small_size(size_t ind)
+{
+
+	return (get_size_impl("arenas.bin.0.size", ind));
+}
+
+static size_t
+get_large_size(size_t ind)
+{
+
+	return (get_size_impl("arenas.lrun.0.size", ind));
+}
+
+static size_t
+get_huge_size(size_t ind)
+{
+
+	return (get_size_impl("arenas.hchunk.0.size", ind));
+}
+
+TEST_BEGIN(test_size)
+{
+	size_t small0, hugemax;
+	void *p;
+
+	/* Get size classes. */
+	small0 = get_small_size(0);
+	hugemax = get_huge_size(get_nhuge()-1);
+
+	p = mallocx(small0, 0);
+	assert_ptr_not_null(p, "Unexpected mallocx() error");
+
+	/* Test smallest supported size. */
+	assert_zu_eq(xallocx(p, 1, 0, 0), small0,
+	    "Unexpected xallocx() behavior");
+
+	/* Test largest supported size. */
+	assert_zu_le(xallocx(p, hugemax, 0, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+
+	/* Test size overflow. */
+	assert_zu_le(xallocx(p, hugemax+1, 0, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+	assert_zu_le(xallocx(p, SIZE_T_MAX, 0, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+
+	dallocx(p, 0);
+}
+TEST_END
+
+TEST_BEGIN(test_size_extra_overflow)
+{
+	size_t small0, hugemax;
+	void *p;
+
+	/* Get size classes. */
+	small0 = get_small_size(0);
+	hugemax = get_huge_size(get_nhuge()-1);
+
+	p = mallocx(small0, 0);
+	assert_ptr_not_null(p, "Unexpected mallocx() error");
+
+	/* Test overflows that can be resolved by clamping extra. */
+	assert_zu_le(xallocx(p, hugemax-1, 2, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+	assert_zu_le(xallocx(p, hugemax, 1, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+
+	/* Test overflow such that hugemax-size underflows. */
+	assert_zu_le(xallocx(p, hugemax+1, 2, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+	assert_zu_le(xallocx(p, hugemax+2, 3, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+	assert_zu_le(xallocx(p, SIZE_T_MAX-2, 2, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+	assert_zu_le(xallocx(p, SIZE_T_MAX-1, 1, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+
+	dallocx(p, 0);
+}
+TEST_END
+
+TEST_BEGIN(test_extra_small)
+{
+	size_t small0, small1, hugemax;
+	void *p;
+
+	/* Get size classes. */
+	small0 = get_small_size(0);
+	small1 = get_small_size(1);
+	hugemax = get_huge_size(get_nhuge()-1);
+
+	p = mallocx(small0, 0);
+	assert_ptr_not_null(p, "Unexpected mallocx() error");
+
+	assert_zu_eq(xallocx(p, small1, 0, 0), small0,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_eq(xallocx(p, small1, 0, 0), small0,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_eq(xallocx(p, small0, small1 - small0, 0), small0,
+	    "Unexpected xallocx() behavior");
+
+	/* Test size+extra overflow. */
+	assert_zu_eq(xallocx(p, small0, hugemax - small0 + 1, 0), small0,
+	    "Unexpected xallocx() behavior");
+	assert_zu_eq(xallocx(p, small0, SIZE_T_MAX - small0, 0), small0,
+	    "Unexpected xallocx() behavior");
+
+	dallocx(p, 0);
+}
+TEST_END
+
+TEST_BEGIN(test_extra_large)
+{
+	size_t smallmax, large0, large1, large2, huge0, hugemax;
+	void *p;
+
+	/* Get size classes. */
+	smallmax = get_small_size(get_nsmall()-1);
+	large0 = get_large_size(0);
+	large1 = get_large_size(1);
+	large2 = get_large_size(2);
+	huge0 = get_huge_size(0);
+	hugemax = get_huge_size(get_nhuge()-1);
+
+	p = mallocx(large2, 0);
+	assert_ptr_not_null(p, "Unexpected mallocx() error");
+
+	assert_zu_eq(xallocx(p, large2, 0, 0), large2,
+	    "Unexpected xallocx() behavior");
+	/* Test size decrease with zero extra. */
+	assert_zu_eq(xallocx(p, large0, 0, 0), large0,
+	    "Unexpected xallocx() behavior");
+	assert_zu_eq(xallocx(p, smallmax, 0, 0), large0,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_eq(xallocx(p, large2, 0, 0), large2,
+	    "Unexpected xallocx() behavior");
+	/* Test size decrease with non-zero extra. */
+	assert_zu_eq(xallocx(p, large0, large2 - large0, 0), large2,
+	    "Unexpected xallocx() behavior");
+	assert_zu_eq(xallocx(p, large1, large2 - large1, 0), large2,
+	    "Unexpected xallocx() behavior");
+	assert_zu_eq(xallocx(p, large0, large1 - large0, 0), large1,
+	    "Unexpected xallocx() behavior");
+	assert_zu_eq(xallocx(p, smallmax, large0 - smallmax, 0), large0,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_eq(xallocx(p, large0, 0, 0), large0,
+	    "Unexpected xallocx() behavior");
+	/* Test size increase with zero extra. */
+	assert_zu_eq(xallocx(p, large2, 0, 0), large2,
+	    "Unexpected xallocx() behavior");
+	assert_zu_eq(xallocx(p, huge0, 0, 0), large2,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_eq(xallocx(p, large0, 0, 0), large0,
+	    "Unexpected xallocx() behavior");
+	/* Test size increase with non-zero extra. */
+	assert_zu_lt(xallocx(p, large0, huge0 - large0, 0), huge0,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_eq(xallocx(p, large0, 0, 0), large0,
+	    "Unexpected xallocx() behavior");
+	/* Test size increase with non-zero extra. */
+	assert_zu_eq(xallocx(p, large0, large2 - large0, 0), large2,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_eq(xallocx(p, large2, 0, 0), large2,
+	    "Unexpected xallocx() behavior");
+	/* Test size+extra overflow. */
+	assert_zu_lt(xallocx(p, large2, hugemax - large2 + 1, 0), huge0,
+	    "Unexpected xallocx() behavior");
+
+	dallocx(p, 0);
+}
+TEST_END
+
+TEST_BEGIN(test_extra_huge)
+{
+	size_t largemax, huge0, huge1, huge2, hugemax;
+	void *p;
+
+	/* Get size classes. */
+	largemax = get_large_size(get_nlarge()-1);
+	huge0 = get_huge_size(0);
+	huge1 = get_huge_size(1);
+	huge2 = get_huge_size(2);
+	hugemax = get_huge_size(get_nhuge()-1);
+
+	p = mallocx(huge2, 0);
+	assert_ptr_not_null(p, "Unexpected mallocx() error");
+
+	assert_zu_eq(xallocx(p, huge2, 0, 0), huge2,
+	    "Unexpected xallocx() behavior");
+	/* Test size decrease with zero extra. */
+	assert_zu_ge(xallocx(p, huge0, 0, 0), huge0,
+	    "Unexpected xallocx() behavior");
+	assert_zu_ge(xallocx(p, largemax, 0, 0), huge0,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_eq(xallocx(p, huge2, 0, 0), huge2,
+	    "Unexpected xallocx() behavior");
+	/* Test size decrease with non-zero extra. */
+	assert_zu_eq(xallocx(p, huge0, huge2 - huge0, 0), huge2,
+	    "Unexpected xallocx() behavior");
+	assert_zu_eq(xallocx(p, huge1, huge2 - huge1, 0), huge2,
+	    "Unexpected xallocx() behavior");
+	assert_zu_eq(xallocx(p, huge0, huge1 - huge0, 0), huge1,
+	    "Unexpected xallocx() behavior");
+	assert_zu_ge(xallocx(p, largemax, huge0 - largemax, 0), huge0,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_ge(xallocx(p, huge0, 0, 0), huge0,
+	    "Unexpected xallocx() behavior");
+	/* Test size increase with zero extra. */
+	assert_zu_le(xallocx(p, huge2, 0, 0), huge2,
+	    "Unexpected xallocx() behavior");
+	assert_zu_le(xallocx(p, hugemax+1, 0, 0), huge2,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_ge(xallocx(p, huge0, 0, 0), huge0,
+	    "Unexpected xallocx() behavior");
+	/* Test size increase with non-zero extra. */
+	assert_zu_le(xallocx(p, huge0, SIZE_T_MAX - huge0, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_ge(xallocx(p, huge0, 0, 0), huge0,
+	    "Unexpected xallocx() behavior");
+	/* Test size increase with non-zero extra. */
+	assert_zu_le(xallocx(p, huge0, huge2 - huge0, 0), huge2,
+	    "Unexpected xallocx() behavior");
+
+	assert_zu_eq(xallocx(p, huge2, 0, 0), huge2,
+	    "Unexpected xallocx() behavior");
+	/* Test size+extra overflow. */
+	assert_zu_le(xallocx(p, huge2, hugemax - huge2 + 1, 0), hugemax,
+	    "Unexpected xallocx() behavior");
+
+	dallocx(p, 0);
+}
+TEST_END
+
+static void
+print_filled_extents(const void *p, uint8_t c, size_t len)
+{
+	const uint8_t *pc = (const uint8_t *)p;
+	size_t i, range0;
+	uint8_t c0;
+
+	malloc_printf("  p=%p, c=%#x, len=%zu:", p, c, len);
+	range0 = 0;
+	c0 = pc[0];
+	for (i = 0; i < len; i++) {
+		if (pc[i] != c0) {
+			malloc_printf(" %#x[%zu..%zu)", c0, range0, i);
+			range0 = i;
+			c0 = pc[i];
+		}
+	}
+	malloc_printf(" %#x[%zu..%zu)\n", c0, range0, i);
+}
+
+static bool
+validate_fill(const void *p, uint8_t c, size_t offset, size_t len)
+{
+	const uint8_t *pc = (const uint8_t *)p;
+	bool err;
+	size_t i;
+
+	for (i = offset, err = false; i < offset+len; i++) {
+		if (pc[i] != c)
+			err = true;
+	}
+
+	if (err)
+		print_filled_extents(p, c, offset + len);
+
+	return (err);
+}
+
+static void
+test_zero(size_t szmin, size_t szmax)
+{
+	size_t sz, nsz;
+	void *p;
+#define	FILL_BYTE 0x7aU
+
+	sz = szmax;
+	p = mallocx(sz, MALLOCX_ZERO);
+	assert_ptr_not_null(p, "Unexpected mallocx() error");
+	assert_false(validate_fill(p, 0x00, 0, sz), "Memory not filled: sz=%zu",
+	    sz);
+
+	/*
+	 * Fill with non-zero so that non-debug builds are more likely to detect
+	 * errors.
+	 */
+	memset(p, FILL_BYTE, sz);
+	assert_false(validate_fill(p, FILL_BYTE, 0, sz),
+	    "Memory not filled: sz=%zu", sz);
+
+	/* Shrink in place so that we can expect growing in place to succeed. */
+	sz = szmin;
+	assert_zu_eq(xallocx(p, sz, 0, MALLOCX_ZERO), sz,
+	    "Unexpected xallocx() error");
+	assert_false(validate_fill(p, FILL_BYTE, 0, sz),
+	    "Memory not filled: sz=%zu", sz);
+
+	for (sz = szmin; sz < szmax; sz = nsz) {
+		nsz = nallocx(sz+1, MALLOCX_ZERO);
+		assert_zu_eq(xallocx(p, sz+1, 0, MALLOCX_ZERO), nsz,
+		    "Unexpected xallocx() failure");
+		assert_false(validate_fill(p, FILL_BYTE, 0, sz),
+		    "Memory not filled: sz=%zu", sz);
+		assert_false(validate_fill(p, 0x00, sz, nsz-sz),
+		    "Memory not filled: sz=%zu, nsz-sz=%zu", sz, nsz-sz);
+		memset((void *)((uintptr_t)p + sz), FILL_BYTE, nsz-sz);
+		assert_false(validate_fill(p, FILL_BYTE, 0, nsz),
+		    "Memory not filled: nsz=%zu", nsz);
+	}
+
+	dallocx(p, 0);
+}
+
+TEST_BEGIN(test_zero_large)
+{
+	size_t large0, largemax;
+
+	/* Get size classes. */
+	large0 = get_large_size(0);
+	largemax = get_large_size(get_nlarge()-1);
+
+	test_zero(large0, largemax);
+}
+TEST_END
+
+TEST_BEGIN(test_zero_huge)
+{
+	size_t huge0, huge1;
+
+	/* Get size classes. */
+	huge0 = get_huge_size(0);
+	huge1 = get_huge_size(1);
+
+	test_zero(huge1, huge0 * 2);
+}
+TEST_END
+
 int
 main(void)
 {
 
 	return (test(
 	    test_same_size,
 	    test_extra_no_move,
-	    test_no_move_fail));
+	    test_no_move_fail,
+	    test_size,
+	    test_size_extra_overflow,
+	    test_extra_small,
+	    test_extra_large,
+	    test_extra_huge,
+	    test_zero_large,
+	    test_zero_huge));
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src: btalloc_0.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src: btalloc_1.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src: btalloc.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src: mq.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/src/mtx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src/mtx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/src/mtx.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src/mtx.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,8 +1,12 @@
 #include "test/jemalloc_test.h"
 
+#ifndef _CRT_SPINCOUNT
+#define	_CRT_SPINCOUNT 4000
+#endif
+
 bool
 mtx_init(mtx_t *mtx)
 {
 
 #ifdef _WIN32
 	if (!InitializeCriticalSectionAndSpinCount(&mtx->lock, _CRT_SPINCOUNT))
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/src/SFMT.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src/SFMT.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/src/SFMT.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src/SFMT.c	2016-05-06 15:11:36.000000000 +0800
@@ -508,13 +508,13 @@
 }
 
 /* Generate a random integer in [0..limit). */
 uint64_t gen_rand64_range(sfmt_t *ctx, uint64_t limit) {
     uint64_t ret, above;
 
-    above = 0xffffffffffffffffLLU - (0xffffffffffffffffLLU  % limit);
+    above = KQU(0xffffffffffffffff) - (KQU(0xffffffffffffffff) % limit);
     while (1) {
         ret = gen_rand64(ctx);
         if (ret < above) {
             ret %= limit;
             break;
         }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/src/test.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src/test.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/src/test.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src/test.c	2016-05-06 15:11:36.000000000 +0800
@@ -2,26 +2,26 @@
 
 static unsigned		test_count = 0;
 static test_status_t	test_counts[test_status_count] = {0, 0, 0};
 static test_status_t	test_status = test_status_pass;
 static const char *	test_name = "";
 
-JEMALLOC_ATTR(format(printf, 1, 2))
+JEMALLOC_FORMAT_PRINTF(1, 2)
 void
 test_skip(const char *format, ...)
 {
 	va_list ap;
 
 	va_start(ap, format);
 	malloc_vcprintf(NULL, NULL, format, ap);
 	va_end(ap);
 	malloc_printf("\n");
 	test_status = test_status_skip;
 }
 
-JEMALLOC_ATTR(format(printf, 1, 2))
+JEMALLOC_FORMAT_PRINTF(1, 2)
 void
 test_fail(const char *format, ...)
 {
 	va_list ap;
 
 	va_start(ap, format);
@@ -58,19 +58,32 @@
 
 	test_counts[test_status]++;
 	malloc_printf("%s: %s\n", test_name, test_status_string(test_status));
 }
 
 test_status_t
-p_test(test_t* t, ...)
+p_test(test_t *t, ...)
 {
-	test_status_t ret = test_status_pass;
+	test_status_t ret;
 	va_list ap;
 
+	/*
+	 * Make sure initialization occurs prior to running tests.  Tests are
+	 * special because they may use internal facilities prior to triggering
+	 * initialization as a side effect of calling into the public API.  This
+	 * is a final safety that works even if jemalloc_constructor() doesn't
+	 * run, as for MSVC builds.
+	 */
+	if (nallocx(1, 0) == 0) {
+		malloc_printf("Initialization error");
+		return (test_status_fail);
+	}
+
+	ret = test_status_pass;
 	va_start(ap, t);
-	for (; t != NULL; t = va_arg(ap, test_t*)) {
+	for (; t != NULL; t = va_arg(ap, test_t *)) {
 		t();
 		if (test_status > ret)
 			ret = test_status;
 	}
 	va_end(ap);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/src/thd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src/thd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/src/thd.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src/thd.c	2016-05-06 15:11:36.000000000 +0800
@@ -11,13 +11,17 @@
 }
 
 void
 thd_join(thd_t thd, void **ret)
 {
 
-	WaitForSingleObject(thd, INFINITE);
+	if (WaitForSingleObject(thd, INFINITE) == WAIT_OBJECT_0 && ret) {
+		DWORD exit_code;
+		GetExitCodeThread(thd, (LPDWORD) &exit_code);
+		*ret = (void *)(uintptr_t)exit_code;
+	}
 }
 
 #else
 void
 thd_create(thd_t *thd, void *(*proc)(void *), void *arg)
 {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/src: timer.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test: stress
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/test.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/test.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/test.sh	2017-09-27 22:47:53.274963472 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/test.sh	2017-09-27 22:49:15.058960475 +0800
@@ -21,13 +21,13 @@
 fail_count=0
 for t in $@; do
   if [ $pass_count -ne 0 -o $skip_count -ne 0 -o $fail_count != 0 ] ; then
     echo
   fi
   echo "=== ${t} ==="
-  ${t} /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/
+  ${t} /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/
   result_code=$?
   case ${result_code} in
     ${pass_code})
       pass_count=$((pass_count+1))
       ;;
     ${skip_code})
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit: atomic.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/bitmap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/bitmap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/bitmap.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/bitmap.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,38 +1,32 @@
 #include "test/jemalloc_test.h"
 
-#if (LG_BITMAP_MAXBITS > 12)
-#  define MAXBITS	4500
-#else
-#  define MAXBITS	(1U << LG_BITMAP_MAXBITS)
-#endif
-
 TEST_BEGIN(test_bitmap_size)
 {
 	size_t i, prev_size;
 
 	prev_size = 0;
-	for (i = 1; i <= MAXBITS; i++) {
+	for (i = 1; i <= BITMAP_MAXBITS; i++) {
 		size_t size = bitmap_size(i);
 		assert_true(size >= prev_size,
 		    "Bitmap size is smaller than expected");
 		prev_size = size;
 	}
 }
 TEST_END
 
 TEST_BEGIN(test_bitmap_init)
 {
 	size_t i;
 
-	for (i = 1; i <= MAXBITS; i++) {
+	for (i = 1; i <= BITMAP_MAXBITS; i++) {
 		bitmap_info_t binfo;
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+			bitmap_t *bitmap = (bitmap_t *)malloc(sizeof(bitmap_t) *
 				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++) {
 				assert_false(bitmap_get(bitmap, &binfo, j),
 				    "Bit should be unset");
@@ -44,18 +38,18 @@
 TEST_END
 
 TEST_BEGIN(test_bitmap_set)
 {
 	size_t i;
 
-	for (i = 1; i <= MAXBITS; i++) {
+	for (i = 1; i <= BITMAP_MAXBITS; i++) {
 		bitmap_info_t binfo;
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+			bitmap_t *bitmap = (bitmap_t *)malloc(sizeof(bitmap_t) *
 				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert_true(bitmap_full(bitmap, &binfo),
@@ -67,18 +61,18 @@
 TEST_END
 
 TEST_BEGIN(test_bitmap_unset)
 {
 	size_t i;
 
-	for (i = 1; i <= MAXBITS; i++) {
+	for (i = 1; i <= BITMAP_MAXBITS; i++) {
 		bitmap_info_t binfo;
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+			bitmap_t *bitmap = (bitmap_t *)malloc(sizeof(bitmap_t) *
 				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert_true(bitmap_full(bitmap, &binfo),
@@ -96,18 +90,18 @@
 TEST_END
 
 TEST_BEGIN(test_bitmap_sfu)
 {
 	size_t i;
 
-	for (i = 1; i <= MAXBITS; i++) {
+	for (i = 1; i <= BITMAP_MAXBITS; i++) {
 		bitmap_info_t binfo;
 		bitmap_info_init(&binfo, i);
 		{
 			ssize_t j;
-			bitmap_t *bitmap = malloc(sizeof(bitmap_t) *
+			bitmap_t *bitmap = (bitmap_t *)malloc(sizeof(bitmap_t) *
 				bitmap_info_ngroups(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			/* Iteratively set bits starting at the beginning. */
 			for (j = 0; j < i; j++) {
 				assert_zd_eq(bitmap_sfu(bitmap, &binfo), j,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/ckh.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/ckh.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/ckh.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/ckh.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,43 +1,49 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_new_delete)
 {
+	tsd_t *tsd;
 	ckh_t ckh;
 
-	assert_false(ckh_new(&ckh, 2, ckh_string_hash, ckh_string_keycomp),
-	    "Unexpected ckh_new() error");
-	ckh_delete(&ckh);
+	tsd = tsd_fetch();
 
-	assert_false(ckh_new(&ckh, 3, ckh_pointer_hash, ckh_pointer_keycomp),
+	assert_false(ckh_new(tsd, &ckh, 2, ckh_string_hash, ckh_string_keycomp),
 	    "Unexpected ckh_new() error");
-	ckh_delete(&ckh);
+	ckh_delete(tsd, &ckh);
+
+	assert_false(ckh_new(tsd, &ckh, 3, ckh_pointer_hash,
+	    ckh_pointer_keycomp), "Unexpected ckh_new() error");
+	ckh_delete(tsd, &ckh);
 }
 TEST_END
 
 TEST_BEGIN(test_count_insert_search_remove)
 {
+	tsd_t *tsd;
 	ckh_t ckh;
 	const char *strs[] = {
 	    "a string",
 	    "A string",
 	    "a string.",
 	    "A string."
 	};
 	const char *missing = "A string not in the hash table.";
 	size_t i;
 
-	assert_false(ckh_new(&ckh, 2, ckh_string_hash, ckh_string_keycomp),
+	tsd = tsd_fetch();
+
+	assert_false(ckh_new(tsd, &ckh, 2, ckh_string_hash, ckh_string_keycomp),
 	    "Unexpected ckh_new() error");
 	assert_zu_eq(ckh_count(&ckh), 0,
 	    "ckh_count() should return %zu, but it returned %zu", ZU(0),
 	    ckh_count(&ckh));
 
 	/* Insert. */
 	for (i = 0; i < sizeof(strs)/sizeof(const char *); i++) {
-		ckh_insert(&ckh, strs[i], strs[i]);
+		ckh_insert(tsd, &ckh, strs[i], strs[i]);
 		assert_zu_eq(ckh_count(&ckh), i+1,
 		    "ckh_count() should return %zu, but it returned %zu", i+1,
 		    ckh_count(&ckh));
 	}
 
 	/* Search. */
@@ -55,16 +61,16 @@
 		v.p = NULL;
 		assert_false(ckh_search(&ckh, strs[i], kp, vp),
 		    "Unexpected ckh_search() error");
 
 		ks = (i & 1) ? strs[i] : (const char *)NULL;
 		vs = (i & 2) ? strs[i] : (const char *)NULL;
-		assert_ptr_eq((void *)ks, (void *)k.s,
-		    "Key mismatch, i=%zu", i);
-		assert_ptr_eq((void *)vs, (void *)v.s,
-		    "Value mismatch, i=%zu", i);
+		assert_ptr_eq((void *)ks, (void *)k.s, "Key mismatch, i=%zu",
+		    i);
+		assert_ptr_eq((void *)vs, (void *)v.s, "Value mismatch, i=%zu",
+		    i);
 	}
 	assert_true(ckh_search(&ckh, missing, NULL, NULL),
 	    "Unexpected ckh_search() success");
 
 	/* Remove. */
 	for (i = 0; i < sizeof(strs)/sizeof(const char *); i++) {
@@ -76,53 +82,56 @@
 		const char *ks, *vs;
 
 		kp = (i & 1) ? &k.p : NULL;
 		vp = (i & 2) ? &v.p : NULL;
 		k.p = NULL;
 		v.p = NULL;
-		assert_false(ckh_remove(&ckh, strs[i], kp, vp),
+		assert_false(ckh_remove(tsd, &ckh, strs[i], kp, vp),
 		    "Unexpected ckh_remove() error");
 
 		ks = (i & 1) ? strs[i] : (const char *)NULL;
 		vs = (i & 2) ? strs[i] : (const char *)NULL;
-		assert_ptr_eq((void *)ks, (void *)k.s,
-		    "Key mismatch, i=%zu", i);
-		assert_ptr_eq((void *)vs, (void *)v.s,
-		    "Value mismatch, i=%zu", i);
+		assert_ptr_eq((void *)ks, (void *)k.s, "Key mismatch, i=%zu",
+		    i);
+		assert_ptr_eq((void *)vs, (void *)v.s, "Value mismatch, i=%zu",
+		    i);
 		assert_zu_eq(ckh_count(&ckh),
 		    sizeof(strs)/sizeof(const char *) - i - 1,
 		    "ckh_count() should return %zu, but it returned %zu",
-		    sizeof(strs)/sizeof(const char *) - i - 1,
+		        sizeof(strs)/sizeof(const char *) - i - 1,
 		    ckh_count(&ckh));
 	}
 
-	ckh_delete(&ckh);
+	ckh_delete(tsd, &ckh);
 }
 TEST_END
 
 TEST_BEGIN(test_insert_iter_remove)
 {
 #define	NITEMS ZU(1000)
+	tsd_t *tsd;
 	ckh_t ckh;
 	void **p[NITEMS];
 	void *q, *r;
 	size_t i;
 
-	assert_false(ckh_new(&ckh, 2, ckh_pointer_hash, ckh_pointer_keycomp),
-	    "Unexpected ckh_new() error");
+	tsd = tsd_fetch();
+
+	assert_false(ckh_new(tsd, &ckh, 2, ckh_pointer_hash,
+	    ckh_pointer_keycomp), "Unexpected ckh_new() error");
 
 	for (i = 0; i < NITEMS; i++) {
 		p[i] = mallocx(i+1, 0);
 		assert_ptr_not_null(p[i], "Unexpected mallocx() failure");
 	}
 
 	for (i = 0; i < NITEMS; i++) {
 		size_t j;
 
 		for (j = i; j < NITEMS; j++) {
-			assert_false(ckh_insert(&ckh, p[j], p[j]),
+			assert_false(ckh_insert(tsd, &ckh, p[j], p[j]),
 			    "Unexpected ckh_insert() failure");
 			assert_false(ckh_search(&ckh, p[j], &q, &r),
 			    "Unexpected ckh_search() failure");
 			assert_ptr_eq(p[j], q, "Key pointer mismatch");
 			assert_ptr_eq(p[j], r, "Value pointer mismatch");
 		}
@@ -131,30 +140,29 @@
 		    "ckh_count() should return %zu, but it returned %zu",
 		    NITEMS, ckh_count(&ckh));
 
 		for (j = i + 1; j < NITEMS; j++) {
 			assert_false(ckh_search(&ckh, p[j], NULL, NULL),
 			    "Unexpected ckh_search() failure");
-			assert_false(ckh_remove(&ckh, p[j], &q, &r),
+			assert_false(ckh_remove(tsd, &ckh, p[j], &q, &r),
 			    "Unexpected ckh_remove() failure");
 			assert_ptr_eq(p[j], q, "Key pointer mismatch");
 			assert_ptr_eq(p[j], r, "Value pointer mismatch");
 			assert_true(ckh_search(&ckh, p[j], NULL, NULL),
 			    "Unexpected ckh_search() success");
-			assert_true(ckh_remove(&ckh, p[j], &q, &r),
+			assert_true(ckh_remove(tsd, &ckh, p[j], &q, &r),
 			    "Unexpected ckh_remove() success");
 		}
 
 		{
 			bool seen[NITEMS];
 			size_t tabind;
 
 			memset(seen, 0, sizeof(seen));
 
-			for (tabind = 0; ckh_iter(&ckh, &tabind, &q, &r) ==
-			    false;) {
+			for (tabind = 0; !ckh_iter(&ckh, &tabind, &q, &r);) {
 				size_t k;
 
 				assert_ptr_eq(q, r, "Key and val not equal");
 
 				for (k = 0; k < NITEMS; k++) {
 					if (p[k] == q) {
@@ -173,27 +181,27 @@
 		}
 	}
 
 	for (i = 0; i < NITEMS; i++) {
 		assert_false(ckh_search(&ckh, p[i], NULL, NULL),
 		    "Unexpected ckh_search() failure");
-		assert_false(ckh_remove(&ckh, p[i], &q, &r),
+		assert_false(ckh_remove(tsd, &ckh, p[i], &q, &r),
 		    "Unexpected ckh_remove() failure");
 		assert_ptr_eq(p[i], q, "Key pointer mismatch");
 		assert_ptr_eq(p[i], r, "Value pointer mismatch");
 		assert_true(ckh_search(&ckh, p[i], NULL, NULL),
 		    "Unexpected ckh_search() success");
-		assert_true(ckh_remove(&ckh, p[i], &q, &r),
+		assert_true(ckh_remove(tsd, &ckh, p[i], &q, &r),
 		    "Unexpected ckh_remove() success");
 		dallocx(p[i], 0);
 	}
 
 	assert_zu_eq(ckh_count(&ckh), 0,
-	    "ckh_count() should return %zu, but it returned %zu", ZU(0),
-	    ckh_count(&ckh));
-	ckh_delete(&ckh);
+	    "ckh_count() should return %zu, but it returned %zu",
+	    ZU(0), ckh_count(&ckh));
+	ckh_delete(tsd, &ckh);
 #undef NITEMS
 }
 TEST_END
 
 int
 main(void)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/hash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/hash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/hash.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/hash.c	2016-05-06 15:11:36.000000000 +0800
@@ -61,14 +61,14 @@
 
 static void
 hash_variant_verify(hash_variant_t variant)
 {
 	const size_t hashbytes = hash_variant_bits(variant) / 8;
 	uint8_t key[256];
-	uint8_t hashes[hashbytes * 256];
-	uint8_t final[hashbytes];
+	VARIABLE_ARRAY(uint8_t, hashes, hashbytes * 256);
+	VARIABLE_ARRAY(uint8_t, final, hashbytes);
 	unsigned i;
 	uint32_t computed, expected;
 
 	memset(key, 0, sizeof(key));
 	memset(hashes, 0, sizeof(hashes));
 	memset(final, 0, sizeof(final));
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit: junk_alloc.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/junk.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/junk.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/junk.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/junk.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,30 +1,43 @@
 #include "test/jemalloc_test.h"
 
 #ifdef JEMALLOC_FILL
+#  ifndef JEMALLOC_TEST_JUNK_OPT
+#    define JEMALLOC_TEST_JUNK_OPT "junk:true"
+#  endif
 const char *malloc_conf =
-    "abort:false,junk:true,zero:false,redzone:true,quarantine:0";
+    "abort:false,zero:false,redzone:true,quarantine:0," JEMALLOC_TEST_JUNK_OPT;
 #endif
 
 static arena_dalloc_junk_small_t *arena_dalloc_junk_small_orig;
 static arena_dalloc_junk_large_t *arena_dalloc_junk_large_orig;
 static huge_dalloc_junk_t *huge_dalloc_junk_orig;
-static void *most_recently_junked;
+static void *watch_for_junking;
+static bool saw_junking;
+
+static void
+watch_junking(void *p)
+{
+
+	watch_for_junking = p;
+	saw_junking = false;
+}
 
 static void
 arena_dalloc_junk_small_intercept(void *ptr, arena_bin_info_t *bin_info)
 {
 	size_t i;
 
 	arena_dalloc_junk_small_orig(ptr, bin_info);
 	for (i = 0; i < bin_info->reg_size; i++) {
 		assert_c_eq(((char *)ptr)[i], 0x5a,
 		    "Missing junk fill for byte %zu/%zu of deallocated region",
 		    i, bin_info->reg_size);
 	}
-	most_recently_junked = ptr;
+	if (ptr == watch_for_junking)
+		saw_junking = true;
 }
 
 static void
 arena_dalloc_junk_large_intercept(void *ptr, size_t usize)
 {
 	size_t i;
@@ -32,40 +45,44 @@
 	arena_dalloc_junk_large_orig(ptr, usize);
 	for (i = 0; i < usize; i++) {
 		assert_c_eq(((char *)ptr)[i], 0x5a,
 		    "Missing junk fill for byte %zu/%zu of deallocated region",
 		    i, usize);
 	}
-	most_recently_junked = ptr;
+	if (ptr == watch_for_junking)
+		saw_junking = true;
 }
 
 static void
 huge_dalloc_junk_intercept(void *ptr, size_t usize)
 {
 
 	huge_dalloc_junk_orig(ptr, usize);
 	/*
 	 * The conditions under which junk filling actually occurs are nuanced
 	 * enough that it doesn't make sense to duplicate the decision logic in
 	 * test code, so don't actually check that the region is junk-filled.
 	 */
-	most_recently_junked = ptr;
+	if (ptr == watch_for_junking)
+		saw_junking = true;
 }
 
 static void
 test_junk(size_t sz_min, size_t sz_max)
 {
 	char *s;
 	size_t sz_prev, sz, i;
 
-	arena_dalloc_junk_small_orig = arena_dalloc_junk_small;
-	arena_dalloc_junk_small = arena_dalloc_junk_small_intercept;
-	arena_dalloc_junk_large_orig = arena_dalloc_junk_large;
-	arena_dalloc_junk_large = arena_dalloc_junk_large_intercept;
-	huge_dalloc_junk_orig = huge_dalloc_junk;
-	huge_dalloc_junk = huge_dalloc_junk_intercept;
+	if (opt_junk_free) {
+		arena_dalloc_junk_small_orig = arena_dalloc_junk_small;
+		arena_dalloc_junk_small = arena_dalloc_junk_small_intercept;
+		arena_dalloc_junk_large_orig = arena_dalloc_junk_large;
+		arena_dalloc_junk_large = arena_dalloc_junk_large_intercept;
+		huge_dalloc_junk_orig = huge_dalloc_junk;
+		huge_dalloc_junk = huge_dalloc_junk_intercept;
+	}
 
 	sz_prev = 0;
 	s = (char *)mallocx(sz_min, 0);
 	assert_ptr_not_null((void *)s, "Unexpected mallocx() failure");
 
 	for (sz = sallocx(s, 0); sz <= sz_max;
@@ -77,40 +94,41 @@
 			assert_c_eq(s[sz_prev-1], 'a',
 			    "Previously allocated byte %zu/%zu is corrupted",
 			    sz_prev-1, sz_prev);
 		}
 
 		for (i = sz_prev; i < sz; i++) {
-			assert_c_eq(s[i], 0xa5,
-			    "Newly allocated byte %zu/%zu isn't junk-filled",
-			    i, sz);
+			if (opt_junk_alloc) {
+				assert_c_eq(s[i], 0xa5,
+				    "Newly allocated byte %zu/%zu isn't "
+				    "junk-filled", i, sz);
+			}
 			s[i] = 'a';
 		}
 
 		if (xallocx(s, sz+1, 0, 0) == sz) {
-			void *junked = (void *)s;
-
+			watch_junking(s);
 			s = (char *)rallocx(s, sz+1, 0);
 			assert_ptr_not_null((void *)s,
 			    "Unexpected rallocx() failure");
-			if (!config_mremap || sz+1 <= arena_maxclass) {
-				assert_ptr_eq(most_recently_junked, junked,
-				    "Expected region of size %zu to be "
-				    "junk-filled",
-				    sz);
-			}
+			assert_true(!opt_junk_free || saw_junking,
+			    "Expected region of size %zu to be junk-filled",
+			    sz);
 		}
 	}
 
+	watch_junking(s);
 	dallocx(s, 0);
-	assert_ptr_eq(most_recently_junked, (void *)s,
+	assert_true(!opt_junk_free || saw_junking,
 	    "Expected region of size %zu to be junk-filled", sz);
 
-	arena_dalloc_junk_small = arena_dalloc_junk_small_orig;
-	arena_dalloc_junk_large = arena_dalloc_junk_large_orig;
-	huge_dalloc_junk = huge_dalloc_junk_orig;
+	if (opt_junk_free) {
+		arena_dalloc_junk_small = arena_dalloc_junk_small_orig;
+		arena_dalloc_junk_large = arena_dalloc_junk_large_orig;
+		huge_dalloc_junk = huge_dalloc_junk_orig;
+	}
 }
 
 TEST_BEGIN(test_junk_small)
 {
 
 	test_skip_if(!config_fill);
@@ -119,48 +137,60 @@
 TEST_END
 
 TEST_BEGIN(test_junk_large)
 {
 
 	test_skip_if(!config_fill);
-	test_junk(SMALL_MAXCLASS+1, arena_maxclass);
+	test_junk(SMALL_MAXCLASS+1, large_maxclass);
 }
 TEST_END
 
 TEST_BEGIN(test_junk_huge)
 {
 
 	test_skip_if(!config_fill);
-	test_junk(arena_maxclass+1, chunksize*2);
+	test_junk(large_maxclass+1, chunksize*2);
 }
 TEST_END
 
 arena_ralloc_junk_large_t *arena_ralloc_junk_large_orig;
 static void *most_recently_trimmed;
 
+static size_t
+shrink_size(size_t size)
+{
+	size_t shrink_size;
+
+	for (shrink_size = size - 1; nallocx(shrink_size, 0) == size;
+	    shrink_size--)
+		; /* Do nothing. */
+
+	return (shrink_size);
+}
+
 static void
 arena_ralloc_junk_large_intercept(void *ptr, size_t old_usize, size_t usize)
 {
 
 	arena_ralloc_junk_large_orig(ptr, old_usize, usize);
-	assert_zu_eq(old_usize, arena_maxclass, "Unexpected old_usize");
-	assert_zu_eq(usize, arena_maxclass-PAGE, "Unexpected usize");
+	assert_zu_eq(old_usize, large_maxclass, "Unexpected old_usize");
+	assert_zu_eq(usize, shrink_size(large_maxclass), "Unexpected usize");
 	most_recently_trimmed = ptr;
 }
 
 TEST_BEGIN(test_junk_large_ralloc_shrink)
 {
 	void *p1, *p2;
 
-	p1 = mallocx(arena_maxclass, 0);
+	p1 = mallocx(large_maxclass, 0);
 	assert_ptr_not_null(p1, "Unexpected mallocx() failure");
 
 	arena_ralloc_junk_large_orig = arena_ralloc_junk_large;
 	arena_ralloc_junk_large = arena_ralloc_junk_large_intercept;
 
-	p2 = rallocx(p1, arena_maxclass-PAGE, 0);
+	p2 = rallocx(p1, shrink_size(large_maxclass), 0);
 	assert_ptr_eq(p1, p2, "Unexpected move during shrink");
 
 	arena_ralloc_junk_large = arena_ralloc_junk_large_orig;
 
 	assert_ptr_eq(most_recently_trimmed, p1,
 	    "Expected trimmed portion of region to be junk-filled");
@@ -180,12 +210,13 @@
 TEST_BEGIN(test_junk_redzone)
 {
 	char *s;
 	arena_redzone_corruption_t *arena_redzone_corruption_orig;
 
 	test_skip_if(!config_fill);
+	test_skip_if(!opt_junk_alloc || !opt_junk_free);
 
 	arena_redzone_corruption_orig = arena_redzone_corruption;
 	arena_redzone_corruption = arena_redzone_corruption_replacement;
 
 	/* Test underflow. */
 	detected_redzone_corruption = false;
@@ -210,12 +241,13 @@
 TEST_END
 
 int
 main(void)
 {
 
+	assert(!config_fill || opt_junk_alloc || opt_junk_free);
 	return (test(
 	    test_junk_small,
 	    test_junk_large,
 	    test_junk_huge,
 	    test_junk_large_ralloc_shrink,
 	    test_junk_redzone));
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit: junk_free.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit: lg_chunk.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/mallctl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/mallctl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/mallctl.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/mallctl.c	2016-05-06 15:11:36.000000000 +0800
@@ -123,17 +123,16 @@
 	assert_d_eq(mallctl("config."#config, &oldval, &sz, NULL, 0),	\
 	    0, "Unexpected mallctl() failure");				\
 	assert_b_eq(oldval, config_##config, "Incorrect config value");	\
 	assert_zu_eq(sz, sizeof(oldval), "Unexpected output size");	\
 } while (0)
 
+	TEST_MALLCTL_CONFIG(cache_oblivious);
 	TEST_MALLCTL_CONFIG(debug);
-	TEST_MALLCTL_CONFIG(dss);
 	TEST_MALLCTL_CONFIG(fill);
 	TEST_MALLCTL_CONFIG(lazy_lock);
-	TEST_MALLCTL_CONFIG(mremap);
 	TEST_MALLCTL_CONFIG(munmap);
 	TEST_MALLCTL_CONFIG(prof);
 	TEST_MALLCTL_CONFIG(prof_libgcc);
 	TEST_MALLCTL_CONFIG(prof_libunwind);
 	TEST_MALLCTL_CONFIG(stats);
 	TEST_MALLCTL_CONFIG(tcache);
@@ -163,18 +162,17 @@
 	TEST_MALLCTL_OPT(bool, abort, always);
 	TEST_MALLCTL_OPT(size_t, lg_chunk, always);
 	TEST_MALLCTL_OPT(const char *, dss, always);
 	TEST_MALLCTL_OPT(size_t, narenas, always);
 	TEST_MALLCTL_OPT(ssize_t, lg_dirty_mult, always);
 	TEST_MALLCTL_OPT(bool, stats_print, always);
-	TEST_MALLCTL_OPT(bool, junk, fill);
+	TEST_MALLCTL_OPT(const char *, junk, fill);
 	TEST_MALLCTL_OPT(size_t, quarantine, fill);
 	TEST_MALLCTL_OPT(bool, redzone, fill);
 	TEST_MALLCTL_OPT(bool, zero, fill);
 	TEST_MALLCTL_OPT(bool, utrace, utrace);
-	TEST_MALLCTL_OPT(bool, valgrind, valgrind);
 	TEST_MALLCTL_OPT(bool, xmalloc, xmalloc);
 	TEST_MALLCTL_OPT(bool, tcache, tcache);
 	TEST_MALLCTL_OPT(size_t, lg_tcache_max, tcache);
 	TEST_MALLCTL_OPT(bool, prof, prof);
 	TEST_MALLCTL_OPT(const char *, prof_prefix, prof);
 	TEST_MALLCTL_OPT(bool, prof_active, prof);
@@ -211,12 +209,132 @@
 		    0, "Unexpected mallctlbymib() failure");
 		/* Do something with bin_size... */
 	}
 }
 TEST_END
 
+TEST_BEGIN(test_tcache_none)
+{
+	void *p0, *q, *p1;
+
+	test_skip_if(!config_tcache);
+
+	/* Allocate p and q. */
+	p0 = mallocx(42, 0);
+	assert_ptr_not_null(p0, "Unexpected mallocx() failure");
+	q = mallocx(42, 0);
+	assert_ptr_not_null(q, "Unexpected mallocx() failure");
+
+	/* Deallocate p and q, but bypass the tcache for q. */
+	dallocx(p0, 0);
+	dallocx(q, MALLOCX_TCACHE_NONE);
+
+	/* Make sure that tcache-based allocation returns p, not q. */
+	p1 = mallocx(42, 0);
+	assert_ptr_not_null(p1, "Unexpected mallocx() failure");
+	assert_ptr_eq(p0, p1, "Expected tcache to allocate cached region");
+
+	/* Clean up. */
+	dallocx(p1, MALLOCX_TCACHE_NONE);
+}
+TEST_END
+
+TEST_BEGIN(test_tcache)
+{
+#define	NTCACHES	10
+	unsigned tis[NTCACHES];
+	void *ps[NTCACHES];
+	void *qs[NTCACHES];
+	unsigned i;
+	size_t sz, psz, qsz;
+
+	test_skip_if(!config_tcache);
+
+	psz = 42;
+	qsz = nallocx(psz, 0) + 1;
+
+	/* Create tcaches. */
+	for (i = 0; i < NTCACHES; i++) {
+		sz = sizeof(unsigned);
+		assert_d_eq(mallctl("tcache.create", &tis[i], &sz, NULL, 0), 0,
+		    "Unexpected mallctl() failure, i=%u", i);
+	}
+
+	/* Exercise tcache ID recycling. */
+	for (i = 0; i < NTCACHES; i++) {
+		assert_d_eq(mallctl("tcache.destroy", NULL, NULL, &tis[i],
+		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
+		    i);
+	}
+	for (i = 0; i < NTCACHES; i++) {
+		sz = sizeof(unsigned);
+		assert_d_eq(mallctl("tcache.create", &tis[i], &sz, NULL, 0), 0,
+		    "Unexpected mallctl() failure, i=%u", i);
+	}
+
+	/* Flush empty tcaches. */
+	for (i = 0; i < NTCACHES; i++) {
+		assert_d_eq(mallctl("tcache.flush", NULL, NULL, &tis[i],
+		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
+		    i);
+	}
+
+	/* Cache some allocations. */
+	for (i = 0; i < NTCACHES; i++) {
+		ps[i] = mallocx(psz, MALLOCX_TCACHE(tis[i]));
+		assert_ptr_not_null(ps[i], "Unexpected mallocx() failure, i=%u",
+		    i);
+		dallocx(ps[i], MALLOCX_TCACHE(tis[i]));
+
+		qs[i] = mallocx(qsz, MALLOCX_TCACHE(tis[i]));
+		assert_ptr_not_null(qs[i], "Unexpected mallocx() failure, i=%u",
+		    i);
+		dallocx(qs[i], MALLOCX_TCACHE(tis[i]));
+	}
+
+	/* Verify that tcaches allocate cached regions. */
+	for (i = 0; i < NTCACHES; i++) {
+		void *p0 = ps[i];
+		ps[i] = mallocx(psz, MALLOCX_TCACHE(tis[i]));
+		assert_ptr_not_null(ps[i], "Unexpected mallocx() failure, i=%u",
+		    i);
+		assert_ptr_eq(ps[i], p0,
+		    "Expected mallocx() to allocate cached region, i=%u", i);
+	}
+
+	/* Verify that reallocation uses cached regions. */
+	for (i = 0; i < NTCACHES; i++) {
+		void *q0 = qs[i];
+		qs[i] = rallocx(ps[i], qsz, MALLOCX_TCACHE(tis[i]));
+		assert_ptr_not_null(qs[i], "Unexpected rallocx() failure, i=%u",
+		    i);
+		assert_ptr_eq(qs[i], q0,
+		    "Expected rallocx() to allocate cached region, i=%u", i);
+		/* Avoid undefined behavior in case of test failure. */
+		if (qs[i] == NULL)
+			qs[i] = ps[i];
+	}
+	for (i = 0; i < NTCACHES; i++)
+		dallocx(qs[i], MALLOCX_TCACHE(tis[i]));
+
+	/* Flush some non-empty tcaches. */
+	for (i = 0; i < NTCACHES/2; i++) {
+		assert_d_eq(mallctl("tcache.flush", NULL, NULL, &tis[i],
+		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
+		    i);
+	}
+
+	/* Destroy tcaches. */
+	for (i = 0; i < NTCACHES; i++) {
+		assert_d_eq(mallctl("tcache.destroy", NULL, NULL, &tis[i],
+		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
+		    i);
+	}
+}
+TEST_END
+
 TEST_BEGIN(test_thread_arena)
 {
 	unsigned arena_old, arena_new, narenas;
 	size_t sz = sizeof(unsigned);
 
 	assert_d_eq(mallctl("arenas.narenas", &narenas, &sz, NULL, 0), 0,
@@ -228,12 +346,44 @@
 	arena_new = 0;
 	assert_d_eq(mallctl("thread.arena", &arena_old, &sz, &arena_new,
 	    sizeof(unsigned)), 0, "Unexpected mallctl() failure");
 }
 TEST_END
 
+TEST_BEGIN(test_arena_i_lg_dirty_mult)
+{
+	ssize_t lg_dirty_mult, orig_lg_dirty_mult, prev_lg_dirty_mult;
+	size_t sz = sizeof(ssize_t);
+
+	assert_d_eq(mallctl("arena.0.lg_dirty_mult", &orig_lg_dirty_mult, &sz,
+	    NULL, 0), 0, "Unexpected mallctl() failure");
+
+	lg_dirty_mult = -2;
+	assert_d_eq(mallctl("arena.0.lg_dirty_mult", NULL, NULL,
+	    &lg_dirty_mult, sizeof(ssize_t)), EFAULT,
+	    "Unexpected mallctl() success");
+
+	lg_dirty_mult = (sizeof(size_t) << 3);
+	assert_d_eq(mallctl("arena.0.lg_dirty_mult", NULL, NULL,
+	    &lg_dirty_mult, sizeof(ssize_t)), EFAULT,
+	    "Unexpected mallctl() success");
+
+	for (prev_lg_dirty_mult = orig_lg_dirty_mult, lg_dirty_mult = -1;
+	    lg_dirty_mult < (ssize_t)(sizeof(size_t) << 3); prev_lg_dirty_mult
+	    = lg_dirty_mult, lg_dirty_mult++) {
+		ssize_t old_lg_dirty_mult;
+
+		assert_d_eq(mallctl("arena.0.lg_dirty_mult", &old_lg_dirty_mult,
+		    &sz, &lg_dirty_mult, sizeof(ssize_t)), 0,
+		    "Unexpected mallctl() failure");
+		assert_zd_eq(old_lg_dirty_mult, prev_lg_dirty_mult,
+		    "Unexpected old arena.0.lg_dirty_mult");
+	}
+}
+TEST_END
+
 TEST_BEGIN(test_arena_i_purge)
 {
 	unsigned narenas;
 	size_t sz = sizeof(unsigned);
 	size_t mib[3];
 	size_t miblen = 3;
@@ -252,53 +402,99 @@
 TEST_END
 
 TEST_BEGIN(test_arena_i_dss)
 {
 	const char *dss_prec_old, *dss_prec_new;
 	size_t sz = sizeof(dss_prec_old);
+	size_t mib[3];
+	size_t miblen;
+
+	miblen = sizeof(mib)/sizeof(size_t);
+	assert_d_eq(mallctlnametomib("arena.0.dss", mib, &miblen), 0,
+	    "Unexpected mallctlnametomib() error");
 
-	dss_prec_new = "primary";
-	assert_d_eq(mallctl("arena.0.dss", &dss_prec_old, &sz, &dss_prec_new,
+	dss_prec_new = "disabled";
+	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_old, &sz, &dss_prec_new,
 	    sizeof(dss_prec_new)), 0, "Unexpected mallctl() failure");
 	assert_str_ne(dss_prec_old, "primary",
 	    "Unexpected default for dss precedence");
 
-	assert_d_eq(mallctl("arena.0.dss", &dss_prec_new, &sz, &dss_prec_old,
+	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_new, &sz, &dss_prec_old,
 	    sizeof(dss_prec_old)), 0, "Unexpected mallctl() failure");
-}
-TEST_END
 
-TEST_BEGIN(test_arenas_purge)
-{
-	unsigned arena = 0;
+	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_old, &sz, NULL, 0), 0,
+	    "Unexpected mallctl() failure");
+	assert_str_ne(dss_prec_old, "primary",
+	    "Unexpected value for dss precedence");
 
-	assert_d_eq(mallctl("arenas.purge", NULL, NULL, &arena, sizeof(arena)),
-	    0, "Unexpected mallctl() failure");
+	mib[1] = narenas_total_get();
+	dss_prec_new = "disabled";
+	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_old, &sz, &dss_prec_new,
+	    sizeof(dss_prec_new)), 0, "Unexpected mallctl() failure");
+	assert_str_ne(dss_prec_old, "primary",
+	    "Unexpected default for dss precedence");
 
-	assert_d_eq(mallctl("arenas.purge", NULL, NULL, NULL, 0), 0,
+	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_new, &sz, &dss_prec_old,
+	    sizeof(dss_prec_new)), 0, "Unexpected mallctl() failure");
+
+	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_old, &sz, NULL, 0), 0,
 	    "Unexpected mallctl() failure");
+	assert_str_ne(dss_prec_old, "primary",
+	    "Unexpected value for dss precedence");
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_initialized)
 {
 	unsigned narenas;
 	size_t sz = sizeof(narenas);
 
 	assert_d_eq(mallctl("arenas.narenas", &narenas, &sz, NULL, 0), 0,
 	    "Unexpected mallctl() failure");
 	{
-		bool initialized[narenas];
+		VARIABLE_ARRAY(bool, initialized, narenas);
 
 		sz = narenas * sizeof(bool);
 		assert_d_eq(mallctl("arenas.initialized", initialized, &sz,
 		    NULL, 0), 0, "Unexpected mallctl() failure");
 	}
 }
 TEST_END
 
+TEST_BEGIN(test_arenas_lg_dirty_mult)
+{
+	ssize_t lg_dirty_mult, orig_lg_dirty_mult, prev_lg_dirty_mult;
+	size_t sz = sizeof(ssize_t);
+
+	assert_d_eq(mallctl("arenas.lg_dirty_mult", &orig_lg_dirty_mult, &sz,
+	    NULL, 0), 0, "Unexpected mallctl() failure");
+
+	lg_dirty_mult = -2;
+	assert_d_eq(mallctl("arenas.lg_dirty_mult", NULL, NULL,
+	    &lg_dirty_mult, sizeof(ssize_t)), EFAULT,
+	    "Unexpected mallctl() success");
+
+	lg_dirty_mult = (sizeof(size_t) << 3);
+	assert_d_eq(mallctl("arenas.lg_dirty_mult", NULL, NULL,
+	    &lg_dirty_mult, sizeof(ssize_t)), EFAULT,
+	    "Unexpected mallctl() success");
+
+	for (prev_lg_dirty_mult = orig_lg_dirty_mult, lg_dirty_mult = -1;
+	    lg_dirty_mult < (ssize_t)(sizeof(size_t) << 3); prev_lg_dirty_mult =
+	    lg_dirty_mult, lg_dirty_mult++) {
+		ssize_t old_lg_dirty_mult;
+
+		assert_d_eq(mallctl("arenas.lg_dirty_mult", &old_lg_dirty_mult,
+		    &sz, &lg_dirty_mult, sizeof(ssize_t)), 0,
+		    "Unexpected mallctl() failure");
+		assert_zd_eq(old_lg_dirty_mult, prev_lg_dirty_mult,
+		    "Unexpected old arenas.lg_dirty_mult");
+	}
+}
+TEST_END
+
 TEST_BEGIN(test_arenas_constants)
 {
 
 #define	TEST_ARENAS_CONSTANT(t, name, expected) do {			\
 	t name;								\
 	size_t sz = sizeof(t);						\
@@ -307,13 +503,14 @@
 	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
 } while (0)
 
 	TEST_ARENAS_CONSTANT(size_t, quantum, QUANTUM);
 	TEST_ARENAS_CONSTANT(size_t, page, PAGE);
 	TEST_ARENAS_CONSTANT(unsigned, nbins, NBINS);
-	TEST_ARENAS_CONSTANT(size_t, nlruns, nlclasses);
+	TEST_ARENAS_CONSTANT(unsigned, nlruns, nlclasses);
+	TEST_ARENAS_CONSTANT(unsigned, nhchunks, nhclasses);
 
 #undef TEST_ARENAS_CONSTANT
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_bin_constants)
@@ -343,18 +540,35 @@
 	size_t sz = sizeof(t);						\
 	assert_d_eq(mallctl("arenas.lrun.0."#name, &name, &sz, NULL,	\
 	    0), 0, "Unexpected mallctl() failure");			\
 	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
 } while (0)
 
-	TEST_ARENAS_LRUN_CONSTANT(size_t, size, (1 << LG_PAGE));
+	TEST_ARENAS_LRUN_CONSTANT(size_t, size, LARGE_MINCLASS);
 
 #undef TEST_ARENAS_LRUN_CONSTANT
 }
 TEST_END
 
+TEST_BEGIN(test_arenas_hchunk_constants)
+{
+
+#define	TEST_ARENAS_HCHUNK_CONSTANT(t, name, expected) do {		\
+	t name;								\
+	size_t sz = sizeof(t);						\
+	assert_d_eq(mallctl("arenas.hchunk.0."#name, &name, &sz, NULL,	\
+	    0), 0, "Unexpected mallctl() failure");			\
+	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
+} while (0)
+
+	TEST_ARENAS_HCHUNK_CONSTANT(size_t, size, chunksize);
+
+#undef TEST_ARENAS_HCHUNK_CONSTANT
+}
+TEST_END
+
 TEST_BEGIN(test_arenas_extend)
 {
 	unsigned narenas_before, arena, narenas_after;
 	size_t sz = sizeof(unsigned);
 
 	assert_d_eq(mallctl("arenas.narenas", &narenas_before, &sz, NULL, 0), 0,
@@ -399,17 +613,21 @@
 	    test_mallctlbymib_errors,
 	    test_mallctl_read_write,
 	    test_mallctlnametomib_short_mib,
 	    test_mallctl_config,
 	    test_mallctl_opt,
 	    test_manpage_example,
+	    test_tcache_none,
+	    test_tcache,
 	    test_thread_arena,
+	    test_arena_i_lg_dirty_mult,
 	    test_arena_i_purge,
 	    test_arena_i_dss,
-	    test_arenas_purge,
 	    test_arenas_initialized,
+	    test_arenas_lg_dirty_mult,
 	    test_arenas_constants,
 	    test_arenas_bin_constants,
 	    test_arenas_lrun_constants,
+	    test_arenas_hchunk_constants,
 	    test_arenas_extend,
 	    test_stats_arenas));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/math.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/math.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/math.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/math.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,11 +1,17 @@
 #include "test/jemalloc_test.h"
 
 #define	MAX_REL_ERR 1.0e-9
 #define	MAX_ABS_ERR 1.0e-9
 
+#include <float.h>
+
+#ifndef INFINITY
+#define	INFINITY (DBL_MAX + DBL_MAX)
+#endif
+
 static bool
 double_eq_rel(double a, double b, double max_rel_err, double max_abs_err)
 {
 	double rel_err;
 
 	if (fabs(a - b) < max_abs_err)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/mq.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/mq.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/mq.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/mq.c	2016-05-06 15:11:36.000000000 +0800
@@ -51,13 +51,13 @@
 	unsigned i;
 
 	for (i = 0; i < NMSGS; i++) {
 		mq_msg_t *msg;
 		void *p;
 		p = mallocx(sizeof(mq_msg_t), 0);
-		assert_ptr_not_null(p, "Unexpected allocm() failure");
+		assert_ptr_not_null(p, "Unexpected mallocx() failure");
 		msg = (mq_msg_t *)p;
 		mq_put(mq, msg);
 	}
 	return (NULL);
 }
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit: prof_accum_a.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit: prof_accum_b.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/prof_accum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/prof_accum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/prof_accum.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/prof_accum.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,7 +1,12 @@
-#include "prof_accum.h"
+#include "test/jemalloc_test.h"
+
+#define	NTHREADS		4
+#define	NALLOCS_PER_THREAD	50
+#define	DUMP_INTERVAL		1
+#define	BT_COUNT_CHECK_INTERVAL	5
 
 #ifdef JEMALLOC_PROF
 const char *malloc_conf =
     "prof:true,prof_accum:true,prof_active:false,lg_prof_sample:0";
 #endif
 
@@ -17,13 +22,13 @@
 }
 
 static void *
 alloc_from_permuted_backtrace(unsigned thd_ind, unsigned iteration)
 {
 
-	return (alloc_0(thd_ind*NALLOCS_PER_THREAD + iteration));
+	return (btalloc(1, thd_ind*NALLOCS_PER_THREAD + iteration));
 }
 
 static void *
 thd_start(void *varg)
 {
 	unsigned thd_ind = *(unsigned *)varg;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit: prof_accum.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit: prof_active.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/prof_gdump.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/prof_gdump.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/prof_gdump.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/prof_gdump.c	2016-05-06 15:11:36.000000000 +0800
@@ -18,14 +18,15 @@
 
 	return (fd);
 }
 
 TEST_BEGIN(test_gdump)
 {
-	bool active;
-	void *p, *q;
+	bool active, gdump, gdump_old;
+	void *p, *q, *r, *s;
+	size_t sz;
 
 	test_skip_if(!config_prof);
 
 	active = true;
 	assert_d_eq(mallctl("prof.active", NULL, NULL, &active, sizeof(active)),
 	    0, "Unexpected mallctl failure while activating profiling");
@@ -39,14 +40,38 @@
 
 	did_prof_dump_open = false;
 	q = mallocx(chunksize, 0);
 	assert_ptr_not_null(q, "Unexpected mallocx() failure");
 	assert_true(did_prof_dump_open, "Expected a profile dump");
 
+	gdump = false;
+	sz = sizeof(gdump_old);
+	assert_d_eq(mallctl("prof.gdump", &gdump_old, &sz, &gdump,
+	    sizeof(gdump)), 0,
+	    "Unexpected mallctl failure while disabling prof.gdump");
+	assert(gdump_old);
+	did_prof_dump_open = false;
+	r = mallocx(chunksize, 0);
+	assert_ptr_not_null(q, "Unexpected mallocx() failure");
+	assert_false(did_prof_dump_open, "Unexpected profile dump");
+
+	gdump = true;
+	sz = sizeof(gdump_old);
+	assert_d_eq(mallctl("prof.gdump", &gdump_old, &sz, &gdump,
+	    sizeof(gdump)), 0,
+	    "Unexpected mallctl failure while enabling prof.gdump");
+	assert(!gdump_old);
+	did_prof_dump_open = false;
+	s = mallocx(chunksize, 0);
+	assert_ptr_not_null(q, "Unexpected mallocx() failure");
+	assert_true(did_prof_dump_open, "Expected a profile dump");
+
 	dallocx(p, 0);
 	dallocx(q, 0);
+	dallocx(r, 0);
+	dallocx(s, 0);
 }
 TEST_END
 
 int
 main(void)
 {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit: prof_reset.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit: prof_thread_name.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/rb.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/rb.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/rb.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/rb.c	2016-05-06 15:11:36.000000000 +0800
@@ -2,13 +2,13 @@
 
 #define	rbtn_black_height(a_type, a_field, a_rbt, r_height) do {	\
     a_type *rbp_bh_t;							\
     for (rbp_bh_t = (a_rbt)->rbt_root, (r_height) = 0;			\
       rbp_bh_t != &(a_rbt)->rbt_nil;					\
       rbp_bh_t = rbtn_left_get(a_type, a_field, rbp_bh_t)) {		\
-	if (rbtn_red_get(a_type, a_field, rbp_bh_t) == false) {		\
+	if (!rbtn_red_get(a_type, a_field, rbp_bh_t)) {			\
 	    (r_height)++;						\
 	}								\
     }									\
 } while (0)
 
 typedef struct node_s node_t;
@@ -46,12 +46,13 @@
 {
 	tree_t tree;
 	node_t key;
 
 	tree_new(&tree);
 
+	assert_true(tree_empty(&tree), "Tree should be empty");
 	assert_ptr_null(tree_first(&tree), "Unexpected node");
 	assert_ptr_null(tree_last(&tree), "Unexpected node");
 
 	key.key = 0;
 	key.magic = NODE_MAGIC;
 	assert_ptr_null(tree_search(&tree, &key), "Unexpected node");
@@ -71,13 +72,13 @@
     node_t *nil)
 {
 	unsigned ret = 0;
 	node_t *left_node = rbtn_left_get(node_t, link, node);
 	node_t *right_node = rbtn_right_get(node_t, link, node);
 
-	if (rbtn_red_get(node_t, link, node) == false)
+	if (!rbtn_red_get(node_t, link, node))
 		black_depth++;
 
 	/* Red nodes must be interleaved with black nodes. */
 	if (rbtn_red_get(node_t, link, node)) {
 		assert_false(rbtn_red_get(node_t, link, left_node),
 		    "Node should be black");
@@ -262,12 +263,14 @@
 
 				assert_u_eq(tree_iterate(&tree), k+1,
 				    "Unexpected node iteration count");
 				assert_u_eq(tree_iterate_reverse(&tree), k+1,
 				    "Unexpected node iteration count");
 
+				assert_false(tree_empty(&tree),
+				    "Tree should not be empty");
 				assert_ptr_not_null(tree_first(&tree),
 				    "Tree should not be empty");
 				assert_ptr_not_null(tree_last(&tree),
 				    "Tree should not be empty");
 
 				tree_next(&tree, &nodes[k]);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/rtree.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/rtree.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/rtree.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/rtree.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,107 +1,140 @@
 #include "test/jemalloc_test.h"
 
+static rtree_node_elm_t *
+node_alloc(size_t nelms)
+{
+
+	return ((rtree_node_elm_t *)calloc(nelms, sizeof(rtree_node_elm_t)));
+}
+
+static void
+node_dalloc(rtree_node_elm_t *node)
+{
+
+	free(node);
+}
+
 TEST_BEGIN(test_rtree_get_empty)
 {
 	unsigned i;
 
 	for (i = 1; i <= (sizeof(uintptr_t) << 3); i++) {
-		rtree_t *rtree = rtree_new(i, imalloc, idalloc);
-		assert_u_eq(rtree_get(rtree, 0), 0,
+		rtree_t rtree;
+		assert_false(rtree_new(&rtree, i, node_alloc, node_dalloc),
+		    "Unexpected rtree_new() failure");
+		assert_ptr_null(rtree_get(&rtree, 0, false),
 		    "rtree_get() should return NULL for empty tree");
-		rtree_delete(rtree);
+		rtree_delete(&rtree);
 	}
 }
 TEST_END
 
 TEST_BEGIN(test_rtree_extrema)
 {
 	unsigned i;
+	extent_node_t node_a, node_b;
 
 	for (i = 1; i <= (sizeof(uintptr_t) << 3); i++) {
-		rtree_t *rtree = rtree_new(i, imalloc, idalloc);
-
-		rtree_set(rtree, 0, 1);
-		assert_u_eq(rtree_get(rtree, 0), 1,
+		rtree_t rtree;
+		assert_false(rtree_new(&rtree, i, node_alloc, node_dalloc),
+		    "Unexpected rtree_new() failure");
+
+		assert_false(rtree_set(&rtree, 0, &node_a),
+		    "Unexpected rtree_set() failure");
+		assert_ptr_eq(rtree_get(&rtree, 0, true), &node_a,
 		    "rtree_get() should return previously set value");
 
-		rtree_set(rtree, ~((uintptr_t)0), 1);
-		assert_u_eq(rtree_get(rtree, ~((uintptr_t)0)), 1,
+		assert_false(rtree_set(&rtree, ~((uintptr_t)0), &node_b),
+		    "Unexpected rtree_set() failure");
+		assert_ptr_eq(rtree_get(&rtree, ~((uintptr_t)0), true), &node_b,
 		    "rtree_get() should return previously set value");
 
-		rtree_delete(rtree);
+		rtree_delete(&rtree);
 	}
 }
 TEST_END
 
 TEST_BEGIN(test_rtree_bits)
 {
 	unsigned i, j, k;
 
 	for (i = 1; i < (sizeof(uintptr_t) << 3); i++) {
 		uintptr_t keys[] = {0, 1,
 		    (((uintptr_t)1) << (sizeof(uintptr_t)*8-i)) - 1};
-		rtree_t *rtree = rtree_new(i, imalloc, idalloc);
+		extent_node_t node;
+		rtree_t rtree;
+
+		assert_false(rtree_new(&rtree, i, node_alloc, node_dalloc),
+		    "Unexpected rtree_new() failure");
 
 		for (j = 0; j < sizeof(keys)/sizeof(uintptr_t); j++) {
-			rtree_set(rtree, keys[j], 1);
+			assert_false(rtree_set(&rtree, keys[j], &node),
+			    "Unexpected rtree_set() failure");
 			for (k = 0; k < sizeof(keys)/sizeof(uintptr_t); k++) {
-				assert_u_eq(rtree_get(rtree, keys[k]), 1,
-				    "rtree_get() should return previously set "
-				    "value and ignore insignificant key bits; "
-				    "i=%u, j=%u, k=%u, set key=%#"PRIxPTR", "
-				    "get key=%#"PRIxPTR, i, j, k, keys[j],
-				    keys[k]);
+				assert_ptr_eq(rtree_get(&rtree, keys[k], true),
+				    &node, "rtree_get() should return "
+				    "previously set value and ignore "
+				    "insignificant key bits; i=%u, j=%u, k=%u, "
+				    "set key=%#"FMTxPTR", get key=%#"FMTxPTR, i,
+				    j, k, keys[j], keys[k]);
 			}
-			assert_u_eq(rtree_get(rtree,
-			    (((uintptr_t)1) << (sizeof(uintptr_t)*8-i))), 0,
+			assert_ptr_null(rtree_get(&rtree,
+			    (((uintptr_t)1) << (sizeof(uintptr_t)*8-i)), false),
 			    "Only leftmost rtree leaf should be set; "
 			    "i=%u, j=%u", i, j);
-			rtree_set(rtree, keys[j], 0);
+			assert_false(rtree_set(&rtree, keys[j], NULL),
+			    "Unexpected rtree_set() failure");
 		}
 
-		rtree_delete(rtree);
+		rtree_delete(&rtree);
 	}
 }
 TEST_END
 
 TEST_BEGIN(test_rtree_random)
 {
 	unsigned i;
 	sfmt_t *sfmt;
-#define	NSET 100
+#define	NSET 16
 #define	SEED 42
 
 	sfmt = init_gen_rand(SEED);
 	for (i = 1; i <= (sizeof(uintptr_t) << 3); i++) {
-		rtree_t *rtree = rtree_new(i, imalloc, idalloc);
 		uintptr_t keys[NSET];
+		extent_node_t node;
 		unsigned j;
+		rtree_t rtree;
+
+		assert_false(rtree_new(&rtree, i, node_alloc, node_dalloc),
+		    "Unexpected rtree_new() failure");
 
 		for (j = 0; j < NSET; j++) {
 			keys[j] = (uintptr_t)gen_rand64(sfmt);
-			rtree_set(rtree, keys[j], 1);
-			assert_u_eq(rtree_get(rtree, keys[j]), 1,
+			assert_false(rtree_set(&rtree, keys[j], &node),
+			    "Unexpected rtree_set() failure");
+			assert_ptr_eq(rtree_get(&rtree, keys[j], true), &node,
 			    "rtree_get() should return previously set value");
 		}
 		for (j = 0; j < NSET; j++) {
-			assert_u_eq(rtree_get(rtree, keys[j]), 1,
+			assert_ptr_eq(rtree_get(&rtree, keys[j], true), &node,
 			    "rtree_get() should return previously set value");
 		}
 
 		for (j = 0; j < NSET; j++) {
-			rtree_set(rtree, keys[j], 0);
-			assert_u_eq(rtree_get(rtree, keys[j]), 0,
+			assert_false(rtree_set(&rtree, keys[j], NULL),
+			    "Unexpected rtree_set() failure");
+			assert_ptr_null(rtree_get(&rtree, keys[j], true),
 			    "rtree_get() should return previously set value");
 		}
 		for (j = 0; j < NSET; j++) {
-			assert_u_eq(rtree_get(rtree, keys[j]), 0,
+			assert_ptr_null(rtree_get(&rtree, keys[j], true),
 			    "rtree_get() should return previously set value");
 		}
 
-		rtree_delete(rtree);
+		rtree_delete(&rtree);
 	}
 	fini_gen_rand(sfmt);
 #undef NSET
 #undef SEED
 }
 TEST_END
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/SFMT.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/SFMT.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/SFMT.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/SFMT.c	2016-05-06 15:11:36.000000000 +0800
@@ -442,1014 +442,1014 @@
 	3121097946U, 2603440486U, 2560820391U, 1012930944U, 2313499967U,
 	 584489368U, 3431165766U,  897384869U, 2062537737U, 2847889234U,
 	3742362450U, 2951174585U, 4204621084U, 1109373893U, 3668075775U,
 	2750138839U, 3518055702U,  733072558U, 4169325400U,  788493625U
 };
 static const uint64_t init_gen_rand_64_expected[] = {
-	QU(16924766246869039260LLU), QU( 8201438687333352714LLU),
-	QU( 2265290287015001750LLU), QU(18397264611805473832LLU),
-	QU( 3375255223302384358LLU), QU( 6345559975416828796LLU),
-	QU(18229739242790328073LLU), QU( 7596792742098800905LLU),
-	QU(  255338647169685981LLU), QU( 2052747240048610300LLU),
-	QU(18328151576097299343LLU), QU(12472905421133796567LLU),
-	QU(11315245349717600863LLU), QU(16594110197775871209LLU),
-	QU(15708751964632456450LLU), QU(10452031272054632535LLU),
-	QU(11097646720811454386LLU), QU( 4556090668445745441LLU),
-	QU(17116187693090663106LLU), QU(14931526836144510645LLU),
-	QU( 9190752218020552591LLU), QU( 9625800285771901401LLU),
-	QU(13995141077659972832LLU), QU( 5194209094927829625LLU),
-	QU( 4156788379151063303LLU), QU( 8523452593770139494LLU),
-	QU(14082382103049296727LLU), QU( 2462601863986088483LLU),
-	QU( 3030583461592840678LLU), QU( 5221622077872827681LLU),
-	QU( 3084210671228981236LLU), QU(13956758381389953823LLU),
-	QU(13503889856213423831LLU), QU(15696904024189836170LLU),
-	QU( 4612584152877036206LLU), QU( 6231135538447867881LLU),
-	QU(10172457294158869468LLU), QU( 6452258628466708150LLU),
-	QU(14044432824917330221LLU), QU(  370168364480044279LLU),
-	QU(10102144686427193359LLU), QU(  667870489994776076LLU),
-	QU( 2732271956925885858LLU), QU(18027788905977284151LLU),
-	QU(15009842788582923859LLU), QU( 7136357960180199542LLU),
-	QU(15901736243475578127LLU), QU(16951293785352615701LLU),
-	QU(10551492125243691632LLU), QU(17668869969146434804LLU),
-	QU(13646002971174390445LLU), QU( 9804471050759613248LLU),
-	QU( 5511670439655935493LLU), QU(18103342091070400926LLU),
-	QU(17224512747665137533LLU), QU(15534627482992618168LLU),
-	QU( 1423813266186582647LLU), QU(15821176807932930024LLU),
-	QU(   30323369733607156LLU), QU(11599382494723479403LLU),
-	QU(  653856076586810062LLU), QU( 3176437395144899659LLU),
-	QU(14028076268147963917LLU), QU(16156398271809666195LLU),
-	QU( 3166955484848201676LLU), QU( 5746805620136919390LLU),
-	QU(17297845208891256593LLU), QU(11691653183226428483LLU),
-	QU(17900026146506981577LLU), QU(15387382115755971042LLU),
-	QU(16923567681040845943LLU), QU( 8039057517199388606LLU),
-	QU(11748409241468629263LLU), QU(  794358245539076095LLU),
-	QU(13438501964693401242LLU), QU(14036803236515618962LLU),
-	QU( 5252311215205424721LLU), QU(17806589612915509081LLU),
-	QU( 6802767092397596006LLU), QU(14212120431184557140LLU),
-	QU( 1072951366761385712LLU), QU(13098491780722836296LLU),
-	QU( 9466676828710797353LLU), QU(12673056849042830081LLU),
-	QU(12763726623645357580LLU), QU(16468961652999309493LLU),
-	QU(15305979875636438926LLU), QU(17444713151223449734LLU),
-	QU( 5692214267627883674LLU), QU(13049589139196151505LLU),
-	QU(  880115207831670745LLU), QU( 1776529075789695498LLU),
-	QU(16695225897801466485LLU), QU(10666901778795346845LLU),
-	QU( 6164389346722833869LLU), QU( 2863817793264300475LLU),
-	QU( 9464049921886304754LLU), QU( 3993566636740015468LLU),
-	QU( 9983749692528514136LLU), QU(16375286075057755211LLU),
-	QU(16042643417005440820LLU), QU(11445419662923489877LLU),
-	QU( 7999038846885158836LLU), QU( 6721913661721511535LLU),
-	QU( 5363052654139357320LLU), QU( 1817788761173584205LLU),
-	QU(13290974386445856444LLU), QU( 4650350818937984680LLU),
-	QU( 8219183528102484836LLU), QU( 1569862923500819899LLU),
-	QU( 4189359732136641860LLU), QU(14202822961683148583LLU),
-	QU( 4457498315309429058LLU), QU(13089067387019074834LLU),
-	QU(11075517153328927293LLU), QU(10277016248336668389LLU),
-	QU( 7070509725324401122LLU), QU(17808892017780289380LLU),
-	QU(13143367339909287349LLU), QU( 1377743745360085151LLU),
-	QU( 5749341807421286485LLU), QU(14832814616770931325LLU),
-	QU( 7688820635324359492LLU), QU(10960474011539770045LLU),
-	QU(   81970066653179790LLU), QU(12619476072607878022LLU),
-	QU( 4419566616271201744LLU), QU(15147917311750568503LLU),
-	QU( 5549739182852706345LLU), QU( 7308198397975204770LLU),
-	QU(13580425496671289278LLU), QU(17070764785210130301LLU),
-	QU( 8202832846285604405LLU), QU( 6873046287640887249LLU),
-	QU( 6927424434308206114LLU), QU( 6139014645937224874LLU),
-	QU(10290373645978487639LLU), QU(15904261291701523804LLU),
-	QU( 9628743442057826883LLU), QU(18383429096255546714LLU),
-	QU( 4977413265753686967LLU), QU( 7714317492425012869LLU),
-	QU( 9025232586309926193LLU), QU(14627338359776709107LLU),
-	QU(14759849896467790763LLU), QU(10931129435864423252LLU),
-	QU( 4588456988775014359LLU), QU(10699388531797056724LLU),
-	QU(  468652268869238792LLU), QU( 5755943035328078086LLU),
-	QU( 2102437379988580216LLU), QU( 9986312786506674028LLU),
-	QU( 2654207180040945604LLU), QU( 8726634790559960062LLU),
-	QU(  100497234871808137LLU), QU( 2800137176951425819LLU),
-	QU( 6076627612918553487LLU), QU( 5780186919186152796LLU),
-	QU( 8179183595769929098LLU), QU( 6009426283716221169LLU),
-	QU( 2796662551397449358LLU), QU( 1756961367041986764LLU),
-	QU( 6972897917355606205LLU), QU(14524774345368968243LLU),
-	QU( 2773529684745706940LLU), QU( 4853632376213075959LLU),
-	QU( 4198177923731358102LLU), QU( 8271224913084139776LLU),
-	QU( 2741753121611092226LLU), QU(16782366145996731181LLU),
-	QU(15426125238972640790LLU), QU(13595497100671260342LLU),
-	QU( 3173531022836259898LLU), QU( 6573264560319511662LLU),
-	QU(18041111951511157441LLU), QU( 2351433581833135952LLU),
-	QU( 3113255578908173487LLU), QU( 1739371330877858784LLU),
-	QU(16046126562789165480LLU), QU( 8072101652214192925LLU),
-	QU(15267091584090664910LLU), QU( 9309579200403648940LLU),
-	QU( 5218892439752408722LLU), QU(14492477246004337115LLU),
-	QU(17431037586679770619LLU), QU( 7385248135963250480LLU),
-	QU( 9580144956565560660LLU), QU( 4919546228040008720LLU),
-	QU(15261542469145035584LLU), QU(18233297270822253102LLU),
-	QU( 5453248417992302857LLU), QU( 9309519155931460285LLU),
-	QU(10342813012345291756LLU), QU(15676085186784762381LLU),
-	QU(15912092950691300645LLU), QU( 9371053121499003195LLU),
-	QU( 9897186478226866746LLU), QU(14061858287188196327LLU),
-	QU(  122575971620788119LLU), QU(12146750969116317754LLU),
-	QU( 4438317272813245201LLU), QU( 8332576791009527119LLU),
-	QU(13907785691786542057LLU), QU(10374194887283287467LLU),
-	QU( 2098798755649059566LLU), QU( 3416235197748288894LLU),
-	QU( 8688269957320773484LLU), QU( 7503964602397371571LLU),
-	QU(16724977015147478236LLU), QU( 9461512855439858184LLU),
-	QU(13259049744534534727LLU), QU( 3583094952542899294LLU),
-	QU( 8764245731305528292LLU), QU(13240823595462088985LLU),
-	QU(13716141617617910448LLU), QU(18114969519935960955LLU),
-	QU( 2297553615798302206LLU), QU( 4585521442944663362LLU),
-	QU(17776858680630198686LLU), QU( 4685873229192163363LLU),
-	QU(  152558080671135627LLU), QU(15424900540842670088LLU),
-	QU(13229630297130024108LLU), QU(17530268788245718717LLU),
-	QU(16675633913065714144LLU), QU( 3158912717897568068LLU),
-	QU(15399132185380087288LLU), QU( 7401418744515677872LLU),
-	QU(13135412922344398535LLU), QU( 6385314346100509511LLU),
-	QU(13962867001134161139LLU), QU(10272780155442671999LLU),
-	QU(12894856086597769142LLU), QU(13340877795287554994LLU),
-	QU(12913630602094607396LLU), QU(12543167911119793857LLU),
-	QU(17343570372251873096LLU), QU(10959487764494150545LLU),
-	QU( 6966737953093821128LLU), QU(13780699135496988601LLU),
-	QU( 4405070719380142046LLU), QU(14923788365607284982LLU),
-	QU( 2869487678905148380LLU), QU( 6416272754197188403LLU),
-	QU(15017380475943612591LLU), QU( 1995636220918429487LLU),
-	QU( 3402016804620122716LLU), QU(15800188663407057080LLU),
-	QU(11362369990390932882LLU), QU(15262183501637986147LLU),
-	QU(10239175385387371494LLU), QU( 9352042420365748334LLU),
-	QU( 1682457034285119875LLU), QU( 1724710651376289644LLU),
-	QU( 2038157098893817966LLU), QU( 9897825558324608773LLU),
-	QU( 1477666236519164736LLU), QU(16835397314511233640LLU),
-	QU(10370866327005346508LLU), QU(10157504370660621982LLU),
-	QU(12113904045335882069LLU), QU(13326444439742783008LLU),
-	QU(11302769043000765804LLU), QU(13594979923955228484LLU),
-	QU(11779351762613475968LLU), QU( 3786101619539298383LLU),
-	QU( 8021122969180846063LLU), QU(15745904401162500495LLU),
-	QU(10762168465993897267LLU), QU(13552058957896319026LLU),
-	QU(11200228655252462013LLU), QU( 5035370357337441226LLU),
-	QU( 7593918984545500013LLU), QU( 5418554918361528700LLU),
-	QU( 4858270799405446371LLU), QU( 9974659566876282544LLU),
-	QU(18227595922273957859LLU), QU( 2772778443635656220LLU),
-	QU(14285143053182085385LLU), QU( 9939700992429600469LLU),
-	QU(12756185904545598068LLU), QU( 2020783375367345262LLU),
-	QU(   57026775058331227LLU), QU(  950827867930065454LLU),
-	QU( 6602279670145371217LLU), QU( 2291171535443566929LLU),
-	QU( 5832380724425010313LLU), QU( 1220343904715982285LLU),
-	QU(17045542598598037633LLU), QU(15460481779702820971LLU),
-	QU(13948388779949365130LLU), QU(13975040175430829518LLU),
-	QU(17477538238425541763LLU), QU(11104663041851745725LLU),
-	QU(15860992957141157587LLU), QU(14529434633012950138LLU),
-	QU( 2504838019075394203LLU), QU( 7512113882611121886LLU),
-	QU( 4859973559980886617LLU), QU( 1258601555703250219LLU),
-	QU(15594548157514316394LLU), QU( 4516730171963773048LLU),
-	QU(11380103193905031983LLU), QU( 6809282239982353344LLU),
-	QU(18045256930420065002LLU), QU( 2453702683108791859LLU),
-	QU(  977214582986981460LLU), QU( 2006410402232713466LLU),
-	QU( 6192236267216378358LLU), QU( 3429468402195675253LLU),
-	QU(18146933153017348921LLU), QU(17369978576367231139LLU),
-	QU( 1246940717230386603LLU), QU(11335758870083327110LLU),
-	QU(14166488801730353682LLU), QU( 9008573127269635732LLU),
-	QU(10776025389820643815LLU), QU(15087605441903942962LLU),
-	QU( 1359542462712147922LLU), QU(13898874411226454206LLU),
-	QU(17911176066536804411LLU), QU( 9435590428600085274LLU),
-	QU(  294488509967864007LLU), QU( 8890111397567922046LLU),
-	QU( 7987823476034328778LLU), QU(13263827582440967651LLU),
-	QU( 7503774813106751573LLU), QU(14974747296185646837LLU),
-	QU( 8504765037032103375LLU), QU(17340303357444536213LLU),
-	QU( 7704610912964485743LLU), QU( 8107533670327205061LLU),
-	QU( 9062969835083315985LLU), QU(16968963142126734184LLU),
-	QU(12958041214190810180LLU), QU( 2720170147759570200LLU),
-	QU( 2986358963942189566LLU), QU(14884226322219356580LLU),
-	QU(  286224325144368520LLU), QU(11313800433154279797LLU),
-	QU(18366849528439673248LLU), QU(17899725929482368789LLU),
-	QU( 3730004284609106799LLU), QU( 1654474302052767205LLU),
-	QU( 5006698007047077032LLU), QU( 8196893913601182838LLU),
-	QU(15214541774425211640LLU), QU(17391346045606626073LLU),
-	QU( 8369003584076969089LLU), QU( 3939046733368550293LLU),
-	QU(10178639720308707785LLU), QU( 2180248669304388697LLU),
-	QU(   62894391300126322LLU), QU( 9205708961736223191LLU),
-	QU( 6837431058165360438LLU), QU( 3150743890848308214LLU),
-	QU(17849330658111464583LLU), QU(12214815643135450865LLU),
-	QU(13410713840519603402LLU), QU( 3200778126692046802LLU),
-	QU(13354780043041779313LLU), QU(  800850022756886036LLU),
-	QU(15660052933953067433LLU), QU( 6572823544154375676LLU),
-	QU(11030281857015819266LLU), QU(12682241941471433835LLU),
-	QU(11654136407300274693LLU), QU( 4517795492388641109LLU),
-	QU( 9757017371504524244LLU), QU(17833043400781889277LLU),
-	QU(12685085201747792227LLU), QU(10408057728835019573LLU),
-	QU(   98370418513455221LLU), QU( 6732663555696848598LLU),
-	QU(13248530959948529780LLU), QU( 3530441401230622826LLU),
-	QU(18188251992895660615LLU), QU( 1847918354186383756LLU),
-	QU( 1127392190402660921LLU), QU(11293734643143819463LLU),
-	QU( 3015506344578682982LLU), QU(13852645444071153329LLU),
-	QU( 2121359659091349142LLU), QU( 1294604376116677694LLU),
-	QU( 5616576231286352318LLU), QU( 7112502442954235625LLU),
-	QU(11676228199551561689LLU), QU(12925182803007305359LLU),
-	QU( 7852375518160493082LLU), QU( 1136513130539296154LLU),
-	QU( 5636923900916593195LLU), QU( 3221077517612607747LLU),
-	QU(17784790465798152513LLU), QU( 3554210049056995938LLU),
-	QU(17476839685878225874LLU), QU( 3206836372585575732LLU),
-	QU( 2765333945644823430LLU), QU(10080070903718799528LLU),
-	QU( 5412370818878286353LLU), QU( 9689685887726257728LLU),
-	QU( 8236117509123533998LLU), QU( 1951139137165040214LLU),
-	QU( 4492205209227980349LLU), QU(16541291230861602967LLU),
-	QU( 1424371548301437940LLU), QU( 9117562079669206794LLU),
-	QU(14374681563251691625LLU), QU(13873164030199921303LLU),
-	QU( 6680317946770936731LLU), QU(15586334026918276214LLU),
-	QU(10896213950976109802LLU), QU( 9506261949596413689LLU),
-	QU( 9903949574308040616LLU), QU( 6038397344557204470LLU),
-	QU(  174601465422373648LLU), QU(15946141191338238030LLU),
-	QU(17142225620992044937LLU), QU( 7552030283784477064LLU),
-	QU( 2947372384532947997LLU), QU(  510797021688197711LLU),
-	QU( 4962499439249363461LLU), QU(   23770320158385357LLU),
-	QU(  959774499105138124LLU), QU( 1468396011518788276LLU),
-	QU( 2015698006852312308LLU), QU( 4149400718489980136LLU),
-	QU( 5992916099522371188LLU), QU(10819182935265531076LLU),
-	QU(16189787999192351131LLU), QU(  342833961790261950LLU),
-	QU(12470830319550495336LLU), QU(18128495041912812501LLU),
-	QU( 1193600899723524337LLU), QU( 9056793666590079770LLU),
-	QU( 2154021227041669041LLU), QU( 4963570213951235735LLU),
-	QU( 4865075960209211409LLU), QU( 2097724599039942963LLU),
-	QU( 2024080278583179845LLU), QU(11527054549196576736LLU),
-	QU(10650256084182390252LLU), QU( 4808408648695766755LLU),
-	QU( 1642839215013788844LLU), QU(10607187948250398390LLU),
-	QU( 7076868166085913508LLU), QU(  730522571106887032LLU),
-	QU(12500579240208524895LLU), QU( 4484390097311355324LLU),
-	QU(15145801330700623870LLU), QU( 8055827661392944028LLU),
-	QU( 5865092976832712268LLU), QU(15159212508053625143LLU),
-	QU( 3560964582876483341LLU), QU( 4070052741344438280LLU),
-	QU( 6032585709886855634LLU), QU(15643262320904604873LLU),
-	QU( 2565119772293371111LLU), QU(  318314293065348260LLU),
-	QU(15047458749141511872LLU), QU( 7772788389811528730LLU),
-	QU( 7081187494343801976LLU), QU( 6465136009467253947LLU),
-	QU(10425940692543362069LLU), QU(  554608190318339115LLU),
-	QU(14796699860302125214LLU), QU( 1638153134431111443LLU),
-	QU(10336967447052276248LLU), QU( 8412308070396592958LLU),
-	QU( 4004557277152051226LLU), QU( 8143598997278774834LLU),
-	QU(16413323996508783221LLU), QU(13139418758033994949LLU),
-	QU( 9772709138335006667LLU), QU( 2818167159287157659LLU),
-	QU(17091740573832523669LLU), QU(14629199013130751608LLU),
-	QU(18268322711500338185LLU), QU( 8290963415675493063LLU),
-	QU( 8830864907452542588LLU), QU( 1614839084637494849LLU),
-	QU(14855358500870422231LLU), QU( 3472996748392519937LLU),
-	QU(15317151166268877716LLU), QU( 5825895018698400362LLU),
-	QU(16730208429367544129LLU), QU(10481156578141202800LLU),
-	QU( 4746166512382823750LLU), QU(12720876014472464998LLU),
-	QU( 8825177124486735972LLU), QU(13733447296837467838LLU),
-	QU( 6412293741681359625LLU), QU( 8313213138756135033LLU),
-	QU(11421481194803712517LLU), QU( 7997007691544174032LLU),
-	QU( 6812963847917605930LLU), QU( 9683091901227558641LLU),
-	QU(14703594165860324713LLU), QU( 1775476144519618309LLU),
-	QU( 2724283288516469519LLU), QU(  717642555185856868LLU),
-	QU( 8736402192215092346LLU), QU(11878800336431381021LLU),
-	QU( 4348816066017061293LLU), QU( 6115112756583631307LLU),
-	QU( 9176597239667142976LLU), QU(12615622714894259204LLU),
-	QU(10283406711301385987LLU), QU( 5111762509485379420LLU),
-	QU( 3118290051198688449LLU), QU( 7345123071632232145LLU),
-	QU( 9176423451688682359LLU), QU( 4843865456157868971LLU),
-	QU(12008036363752566088LLU), QU(12058837181919397720LLU),
-	QU( 2145073958457347366LLU), QU( 1526504881672818067LLU),
-	QU( 3488830105567134848LLU), QU(13208362960674805143LLU),
-	QU( 4077549672899572192LLU), QU( 7770995684693818365LLU),
-	QU( 1398532341546313593LLU), QU(12711859908703927840LLU),
-	QU( 1417561172594446813LLU), QU(17045191024194170604LLU),
-	QU( 4101933177604931713LLU), QU(14708428834203480320LLU),
-	QU(17447509264469407724LLU), QU(14314821973983434255LLU),
-	QU(17990472271061617265LLU), QU( 5087756685841673942LLU),
-	QU(12797820586893859939LLU), QU( 1778128952671092879LLU),
-	QU( 3535918530508665898LLU), QU( 9035729701042481301LLU),
-	QU(14808661568277079962LLU), QU(14587345077537747914LLU),
-	QU(11920080002323122708LLU), QU( 6426515805197278753LLU),
-	QU( 3295612216725984831LLU), QU(11040722532100876120LLU),
-	QU(12305952936387598754LLU), QU(16097391899742004253LLU),
-	QU( 4908537335606182208LLU), QU(12446674552196795504LLU),
-	QU(16010497855816895177LLU), QU( 9194378874788615551LLU),
-	QU( 3382957529567613384LLU), QU( 5154647600754974077LLU),
-	QU( 9801822865328396141LLU), QU( 9023662173919288143LLU),
-	QU(17623115353825147868LLU), QU( 8238115767443015816LLU),
-	QU(15811444159859002560LLU), QU( 9085612528904059661LLU),
-	QU( 6888601089398614254LLU), QU(  258252992894160189LLU),
-	QU( 6704363880792428622LLU), QU( 6114966032147235763LLU),
-	QU(11075393882690261875LLU), QU( 8797664238933620407LLU),
-	QU( 5901892006476726920LLU), QU( 5309780159285518958LLU),
-	QU(14940808387240817367LLU), QU(14642032021449656698LLU),
-	QU( 9808256672068504139LLU), QU( 3670135111380607658LLU),
-	QU(11211211097845960152LLU), QU( 1474304506716695808LLU),
-	QU(15843166204506876239LLU), QU( 7661051252471780561LLU),
-	QU(10170905502249418476LLU), QU( 7801416045582028589LLU),
-	QU( 2763981484737053050LLU), QU( 9491377905499253054LLU),
-	QU(16201395896336915095LLU), QU( 9256513756442782198LLU),
-	QU( 5411283157972456034LLU), QU( 5059433122288321676LLU),
-	QU( 4327408006721123357LLU), QU( 9278544078834433377LLU),
-	QU( 7601527110882281612LLU), QU(11848295896975505251LLU),
-	QU(12096998801094735560LLU), QU(14773480339823506413LLU),
-	QU(15586227433895802149LLU), QU(12786541257830242872LLU),
-	QU( 6904692985140503067LLU), QU( 5309011515263103959LLU),
-	QU(12105257191179371066LLU), QU(14654380212442225037LLU),
-	QU( 2556774974190695009LLU), QU( 4461297399927600261LLU),
-	QU(14888225660915118646LLU), QU(14915459341148291824LLU),
-	QU( 2738802166252327631LLU), QU( 6047155789239131512LLU),
-	QU(12920545353217010338LLU), QU(10697617257007840205LLU),
-	QU( 2751585253158203504LLU), QU(13252729159780047496LLU),
-	QU(14700326134672815469LLU), QU(14082527904374600529LLU),
-	QU(16852962273496542070LLU), QU(17446675504235853907LLU),
-	QU(15019600398527572311LLU), QU(12312781346344081551LLU),
-	QU(14524667935039810450LLU), QU( 5634005663377195738LLU),
-	QU(11375574739525000569LLU), QU( 2423665396433260040LLU),
-	QU( 5222836914796015410LLU), QU( 4397666386492647387LLU),
-	QU( 4619294441691707638LLU), QU(  665088602354770716LLU),
-	QU(13246495665281593610LLU), QU( 6564144270549729409LLU),
-	QU(10223216188145661688LLU), QU( 3961556907299230585LLU),
-	QU(11543262515492439914LLU), QU(16118031437285993790LLU),
-	QU( 7143417964520166465LLU), QU(13295053515909486772LLU),
-	QU(   40434666004899675LLU), QU(17127804194038347164LLU),
-	QU( 8599165966560586269LLU), QU( 8214016749011284903LLU),
-	QU(13725130352140465239LLU), QU( 5467254474431726291LLU),
-	QU( 7748584297438219877LLU), QU(16933551114829772472LLU),
-	QU( 2169618439506799400LLU), QU( 2169787627665113463LLU),
-	QU(17314493571267943764LLU), QU(18053575102911354912LLU),
-	QU(11928303275378476973LLU), QU(11593850925061715550LLU),
-	QU(17782269923473589362LLU), QU( 3280235307704747039LLU),
-	QU( 6145343578598685149LLU), QU(17080117031114086090LLU),
-	QU(18066839902983594755LLU), QU( 6517508430331020706LLU),
-	QU( 8092908893950411541LLU), QU(12558378233386153732LLU),
-	QU( 4476532167973132976LLU), QU(16081642430367025016LLU),
-	QU( 4233154094369139361LLU), QU( 8693630486693161027LLU),
-	QU(11244959343027742285LLU), QU(12273503967768513508LLU),
-	QU(14108978636385284876LLU), QU( 7242414665378826984LLU),
-	QU( 6561316938846562432LLU), QU( 8601038474994665795LLU),
-	QU(17532942353612365904LLU), QU(17940076637020912186LLU),
-	QU( 7340260368823171304LLU), QU( 7061807613916067905LLU),
-	QU(10561734935039519326LLU), QU(17990796503724650862LLU),
-	QU( 6208732943911827159LLU), QU(  359077562804090617LLU),
-	QU(14177751537784403113LLU), QU(10659599444915362902LLU),
-	QU(15081727220615085833LLU), QU(13417573895659757486LLU),
-	QU(15513842342017811524LLU), QU(11814141516204288231LLU),
-	QU( 1827312513875101814LLU), QU( 2804611699894603103LLU),
-	QU(17116500469975602763LLU), QU(12270191815211952087LLU),
-	QU(12256358467786024988LLU), QU(18435021722453971267LLU),
-	QU(  671330264390865618LLU), QU(  476504300460286050LLU),
-	QU(16465470901027093441LLU), QU( 4047724406247136402LLU),
-	QU( 1322305451411883346LLU), QU( 1388308688834322280LLU),
-	QU( 7303989085269758176LLU), QU( 9323792664765233642LLU),
-	QU( 4542762575316368936LLU), QU(17342696132794337618LLU),
-	QU( 4588025054768498379LLU), QU(13415475057390330804LLU),
-	QU(17880279491733405570LLU), QU(10610553400618620353LLU),
-	QU( 3180842072658960139LLU), QU(13002966655454270120LLU),
-	QU( 1665301181064982826LLU), QU( 7083673946791258979LLU),
-	QU(  190522247122496820LLU), QU(17388280237250677740LLU),
-	QU( 8430770379923642945LLU), QU(12987180971921668584LLU),
-	QU( 2311086108365390642LLU), QU( 2870984383579822345LLU),
-	QU(14014682609164653318LLU), QU(14467187293062251484LLU),
-	QU(  192186361147413298LLU), QU(15171951713531796524LLU),
-	QU( 9900305495015948728LLU), QU(17958004775615466344LLU),
-	QU(14346380954498606514LLU), QU(18040047357617407096LLU),
-	QU( 5035237584833424532LLU), QU(15089555460613972287LLU),
-	QU( 4131411873749729831LLU), QU( 1329013581168250330LLU),
-	QU(10095353333051193949LLU), QU(10749518561022462716LLU),
-	QU( 9050611429810755847LLU), QU(15022028840236655649LLU),
-	QU( 8775554279239748298LLU), QU(13105754025489230502LLU),
-	QU(15471300118574167585LLU), QU(   89864764002355628LLU),
-	QU( 8776416323420466637LLU), QU( 5280258630612040891LLU),
-	QU( 2719174488591862912LLU), QU( 7599309137399661994LLU),
-	QU(15012887256778039979LLU), QU(14062981725630928925LLU),
-	QU(12038536286991689603LLU), QU( 7089756544681775245LLU),
-	QU(10376661532744718039LLU), QU( 1265198725901533130LLU),
-	QU(13807996727081142408LLU), QU( 2935019626765036403LLU),
-	QU( 7651672460680700141LLU), QU( 3644093016200370795LLU),
-	QU( 2840982578090080674LLU), QU(17956262740157449201LLU),
-	QU(18267979450492880548LLU), QU(11799503659796848070LLU),
-	QU( 9942537025669672388LLU), QU(11886606816406990297LLU),
-	QU( 5488594946437447576LLU), QU( 7226714353282744302LLU),
-	QU( 3784851653123877043LLU), QU(  878018453244803041LLU),
-	QU(12110022586268616085LLU), QU(  734072179404675123LLU),
-	QU(11869573627998248542LLU), QU(  469150421297783998LLU),
-	QU(  260151124912803804LLU), QU(11639179410120968649LLU),
-	QU( 9318165193840846253LLU), QU(12795671722734758075LLU),
-	QU(15318410297267253933LLU), QU(  691524703570062620LLU),
-	QU( 5837129010576994601LLU), QU(15045963859726941052LLU),
-	QU( 5850056944932238169LLU), QU(12017434144750943807LLU),
-	QU( 7447139064928956574LLU), QU( 3101711812658245019LLU),
-	QU(16052940704474982954LLU), QU(18195745945986994042LLU),
-	QU( 8932252132785575659LLU), QU(13390817488106794834LLU),
-	QU(11582771836502517453LLU), QU( 4964411326683611686LLU),
-	QU( 2195093981702694011LLU), QU(14145229538389675669LLU),
-	QU(16459605532062271798LLU), QU(  866316924816482864LLU),
-	QU( 4593041209937286377LLU), QU( 8415491391910972138LLU),
-	QU( 4171236715600528969LLU), QU(16637569303336782889LLU),
-	QU( 2002011073439212680LLU), QU(17695124661097601411LLU),
-	QU( 4627687053598611702LLU), QU( 7895831936020190403LLU),
-	QU( 8455951300917267802LLU), QU( 2923861649108534854LLU),
-	QU( 8344557563927786255LLU), QU( 6408671940373352556LLU),
-	QU(12210227354536675772LLU), QU(14294804157294222295LLU),
-	QU(10103022425071085127LLU), QU(10092959489504123771LLU),
-	QU( 6554774405376736268LLU), QU(12629917718410641774LLU),
-	QU( 6260933257596067126LLU), QU( 2460827021439369673LLU),
-	QU( 2541962996717103668LLU), QU(  597377203127351475LLU),
-	QU( 5316984203117315309LLU), QU( 4811211393563241961LLU),
-	QU(13119698597255811641LLU), QU( 8048691512862388981LLU),
-	QU(10216818971194073842LLU), QU( 4612229970165291764LLU),
-	QU(10000980798419974770LLU), QU( 6877640812402540687LLU),
-	QU( 1488727563290436992LLU), QU( 2227774069895697318LLU),
-	QU(11237754507523316593LLU), QU(13478948605382290972LLU),
-	QU( 1963583846976858124LLU), QU( 5512309205269276457LLU),
-	QU( 3972770164717652347LLU), QU( 3841751276198975037LLU),
-	QU(10283343042181903117LLU), QU( 8564001259792872199LLU),
-	QU(16472187244722489221LLU), QU( 8953493499268945921LLU),
-	QU( 3518747340357279580LLU), QU( 4003157546223963073LLU),
-	QU( 3270305958289814590LLU), QU( 3966704458129482496LLU),
-	QU( 8122141865926661939LLU), QU(14627734748099506653LLU),
-	QU(13064426990862560568LLU), QU( 2414079187889870829LLU),
-	QU( 5378461209354225306LLU), QU(10841985740128255566LLU),
-	QU(  538582442885401738LLU), QU( 7535089183482905946LLU),
-	QU(16117559957598879095LLU), QU( 8477890721414539741LLU),
-	QU( 1459127491209533386LLU), QU(17035126360733620462LLU),
-	QU( 8517668552872379126LLU), QU(10292151468337355014LLU),
-	QU(17081267732745344157LLU), QU(13751455337946087178LLU),
-	QU(14026945459523832966LLU), QU( 6653278775061723516LLU),
-	QU(10619085543856390441LLU), QU( 2196343631481122885LLU),
-	QU(10045966074702826136LLU), QU(10082317330452718282LLU),
-	QU( 5920859259504831242LLU), QU( 9951879073426540617LLU),
-	QU( 7074696649151414158LLU), QU(15808193543879464318LLU),
-	QU( 7385247772746953374LLU), QU( 3192003544283864292LLU),
-	QU(18153684490917593847LLU), QU(12423498260668568905LLU),
-	QU(10957758099756378169LLU), QU(11488762179911016040LLU),
-	QU( 2099931186465333782LLU), QU(11180979581250294432LLU),
-	QU( 8098916250668367933LLU), QU( 3529200436790763465LLU),
-	QU(12988418908674681745LLU), QU( 6147567275954808580LLU),
-	QU( 3207503344604030989LLU), QU(10761592604898615360LLU),
-	QU(  229854861031893504LLU), QU( 8809853962667144291LLU),
-	QU(13957364469005693860LLU), QU( 7634287665224495886LLU),
-	QU(12353487366976556874LLU), QU( 1134423796317152034LLU),
-	QU( 2088992471334107068LLU), QU( 7393372127190799698LLU),
-	QU( 1845367839871058391LLU), QU(  207922563987322884LLU),
-	QU(11960870813159944976LLU), QU(12182120053317317363LLU),
-	QU(17307358132571709283LLU), QU(13871081155552824936LLU),
-	QU(18304446751741566262LLU), QU( 7178705220184302849LLU),
-	QU(10929605677758824425LLU), QU(16446976977835806844LLU),
-	QU(13723874412159769044LLU), QU( 6942854352100915216LLU),
-	QU( 1726308474365729390LLU), QU( 2150078766445323155LLU),
-	QU(15345558947919656626LLU), QU(12145453828874527201LLU),
-	QU( 2054448620739726849LLU), QU( 2740102003352628137LLU),
-	QU(11294462163577610655LLU), QU(  756164283387413743LLU),
-	QU(17841144758438810880LLU), QU(10802406021185415861LLU),
-	QU( 8716455530476737846LLU), QU( 6321788834517649606LLU),
-	QU(14681322910577468426LLU), QU(17330043563884336387LLU),
-	QU(12701802180050071614LLU), QU(14695105111079727151LLU),
-	QU( 5112098511654172830LLU), QU( 4957505496794139973LLU),
-	QU( 8270979451952045982LLU), QU(12307685939199120969LLU),
-	QU(12425799408953443032LLU), QU( 8376410143634796588LLU),
-	QU(16621778679680060464LLU), QU( 3580497854566660073LLU),
-	QU( 1122515747803382416LLU), QU(  857664980960597599LLU),
-	QU( 6343640119895925918LLU), QU(12878473260854462891LLU),
-	QU(10036813920765722626LLU), QU(14451335468363173812LLU),
-	QU( 5476809692401102807LLU), QU(16442255173514366342LLU),
-	QU(13060203194757167104LLU), QU(14354124071243177715LLU),
-	QU(15961249405696125227LLU), QU(13703893649690872584LLU),
-	QU(  363907326340340064LLU), QU( 6247455540491754842LLU),
-	QU(12242249332757832361LLU), QU(  156065475679796717LLU),
-	QU( 9351116235749732355LLU), QU( 4590350628677701405LLU),
-	QU( 1671195940982350389LLU), QU(13501398458898451905LLU),
-	QU( 6526341991225002255LLU), QU( 1689782913778157592LLU),
-	QU( 7439222350869010334LLU), QU(13975150263226478308LLU),
-	QU(11411961169932682710LLU), QU(17204271834833847277LLU),
-	QU(  541534742544435367LLU), QU( 6591191931218949684LLU),
-	QU( 2645454775478232486LLU), QU( 4322857481256485321LLU),
-	QU( 8477416487553065110LLU), QU(12902505428548435048LLU),
-	QU(  971445777981341415LLU), QU(14995104682744976712LLU),
-	QU( 4243341648807158063LLU), QU( 8695061252721927661LLU),
-	QU( 5028202003270177222LLU), QU( 2289257340915567840LLU),
-	QU(13870416345121866007LLU), QU(13994481698072092233LLU),
-	QU( 6912785400753196481LLU), QU( 2278309315841980139LLU),
-	QU( 4329765449648304839LLU), QU( 5963108095785485298LLU),
-	QU( 4880024847478722478LLU), QU(16015608779890240947LLU),
-	QU( 1866679034261393544LLU), QU(  914821179919731519LLU),
-	QU( 9643404035648760131LLU), QU( 2418114953615593915LLU),
-	QU(  944756836073702374LLU), QU(15186388048737296834LLU),
-	QU( 7723355336128442206LLU), QU( 7500747479679599691LLU),
-	QU(18013961306453293634LLU), QU( 2315274808095756456LLU),
-	QU(13655308255424029566LLU), QU(17203800273561677098LLU),
-	QU( 1382158694422087756LLU), QU( 5090390250309588976LLU),
-	QU(  517170818384213989LLU), QU( 1612709252627729621LLU),
-	QU( 1330118955572449606LLU), QU(  300922478056709885LLU),
-	QU(18115693291289091987LLU), QU(13491407109725238321LLU),
-	QU(15293714633593827320LLU), QU( 5151539373053314504LLU),
-	QU( 5951523243743139207LLU), QU(14459112015249527975LLU),
-	QU( 5456113959000700739LLU), QU( 3877918438464873016LLU),
-	QU(12534071654260163555LLU), QU(15871678376893555041LLU),
-	QU(11005484805712025549LLU), QU(16353066973143374252LLU),
-	QU( 4358331472063256685LLU), QU( 8268349332210859288LLU),
-	QU(12485161590939658075LLU), QU(13955993592854471343LLU),
-	QU( 5911446886848367039LLU), QU(14925834086813706974LLU),
-	QU( 6590362597857994805LLU), QU( 1280544923533661875LLU),
-	QU( 1637756018947988164LLU), QU( 4734090064512686329LLU),
-	QU(16693705263131485912LLU), QU( 6834882340494360958LLU),
-	QU( 8120732176159658505LLU), QU( 2244371958905329346LLU),
-	QU(10447499707729734021LLU), QU( 7318742361446942194LLU),
-	QU( 8032857516355555296LLU), QU(14023605983059313116LLU),
-	QU( 1032336061815461376LLU), QU( 9840995337876562612LLU),
-	QU( 9869256223029203587LLU), QU(12227975697177267636LLU),
-	QU(12728115115844186033LLU), QU( 7752058479783205470LLU),
-	QU(  729733219713393087LLU), QU(12954017801239007622LLU)
+	KQU(16924766246869039260), KQU( 8201438687333352714),
+	KQU( 2265290287015001750), KQU(18397264611805473832),
+	KQU( 3375255223302384358), KQU( 6345559975416828796),
+	KQU(18229739242790328073), KQU( 7596792742098800905),
+	KQU(  255338647169685981), KQU( 2052747240048610300),
+	KQU(18328151576097299343), KQU(12472905421133796567),
+	KQU(11315245349717600863), KQU(16594110197775871209),
+	KQU(15708751964632456450), KQU(10452031272054632535),
+	KQU(11097646720811454386), KQU( 4556090668445745441),
+	KQU(17116187693090663106), KQU(14931526836144510645),
+	KQU( 9190752218020552591), KQU( 9625800285771901401),
+	KQU(13995141077659972832), KQU( 5194209094927829625),
+	KQU( 4156788379151063303), KQU( 8523452593770139494),
+	KQU(14082382103049296727), KQU( 2462601863986088483),
+	KQU( 3030583461592840678), KQU( 5221622077872827681),
+	KQU( 3084210671228981236), KQU(13956758381389953823),
+	KQU(13503889856213423831), KQU(15696904024189836170),
+	KQU( 4612584152877036206), KQU( 6231135538447867881),
+	KQU(10172457294158869468), KQU( 6452258628466708150),
+	KQU(14044432824917330221), KQU(  370168364480044279),
+	KQU(10102144686427193359), KQU(  667870489994776076),
+	KQU( 2732271956925885858), KQU(18027788905977284151),
+	KQU(15009842788582923859), KQU( 7136357960180199542),
+	KQU(15901736243475578127), KQU(16951293785352615701),
+	KQU(10551492125243691632), KQU(17668869969146434804),
+	KQU(13646002971174390445), KQU( 9804471050759613248),
+	KQU( 5511670439655935493), KQU(18103342091070400926),
+	KQU(17224512747665137533), KQU(15534627482992618168),
+	KQU( 1423813266186582647), KQU(15821176807932930024),
+	KQU(   30323369733607156), KQU(11599382494723479403),
+	KQU(  653856076586810062), KQU( 3176437395144899659),
+	KQU(14028076268147963917), KQU(16156398271809666195),
+	KQU( 3166955484848201676), KQU( 5746805620136919390),
+	KQU(17297845208891256593), KQU(11691653183226428483),
+	KQU(17900026146506981577), KQU(15387382115755971042),
+	KQU(16923567681040845943), KQU( 8039057517199388606),
+	KQU(11748409241468629263), KQU(  794358245539076095),
+	KQU(13438501964693401242), KQU(14036803236515618962),
+	KQU( 5252311215205424721), KQU(17806589612915509081),
+	KQU( 6802767092397596006), KQU(14212120431184557140),
+	KQU( 1072951366761385712), KQU(13098491780722836296),
+	KQU( 9466676828710797353), KQU(12673056849042830081),
+	KQU(12763726623645357580), KQU(16468961652999309493),
+	KQU(15305979875636438926), KQU(17444713151223449734),
+	KQU( 5692214267627883674), KQU(13049589139196151505),
+	KQU(  880115207831670745), KQU( 1776529075789695498),
+	KQU(16695225897801466485), KQU(10666901778795346845),
+	KQU( 6164389346722833869), KQU( 2863817793264300475),
+	KQU( 9464049921886304754), KQU( 3993566636740015468),
+	KQU( 9983749692528514136), KQU(16375286075057755211),
+	KQU(16042643417005440820), KQU(11445419662923489877),
+	KQU( 7999038846885158836), KQU( 6721913661721511535),
+	KQU( 5363052654139357320), KQU( 1817788761173584205),
+	KQU(13290974386445856444), KQU( 4650350818937984680),
+	KQU( 8219183528102484836), KQU( 1569862923500819899),
+	KQU( 4189359732136641860), KQU(14202822961683148583),
+	KQU( 4457498315309429058), KQU(13089067387019074834),
+	KQU(11075517153328927293), KQU(10277016248336668389),
+	KQU( 7070509725324401122), KQU(17808892017780289380),
+	KQU(13143367339909287349), KQU( 1377743745360085151),
+	KQU( 5749341807421286485), KQU(14832814616770931325),
+	KQU( 7688820635324359492), KQU(10960474011539770045),
+	KQU(   81970066653179790), KQU(12619476072607878022),
+	KQU( 4419566616271201744), KQU(15147917311750568503),
+	KQU( 5549739182852706345), KQU( 7308198397975204770),
+	KQU(13580425496671289278), KQU(17070764785210130301),
+	KQU( 8202832846285604405), KQU( 6873046287640887249),
+	KQU( 6927424434308206114), KQU( 6139014645937224874),
+	KQU(10290373645978487639), KQU(15904261291701523804),
+	KQU( 9628743442057826883), KQU(18383429096255546714),
+	KQU( 4977413265753686967), KQU( 7714317492425012869),
+	KQU( 9025232586309926193), KQU(14627338359776709107),
+	KQU(14759849896467790763), KQU(10931129435864423252),
+	KQU( 4588456988775014359), KQU(10699388531797056724),
+	KQU(  468652268869238792), KQU( 5755943035328078086),
+	KQU( 2102437379988580216), KQU( 9986312786506674028),
+	KQU( 2654207180040945604), KQU( 8726634790559960062),
+	KQU(  100497234871808137), KQU( 2800137176951425819),
+	KQU( 6076627612918553487), KQU( 5780186919186152796),
+	KQU( 8179183595769929098), KQU( 6009426283716221169),
+	KQU( 2796662551397449358), KQU( 1756961367041986764),
+	KQU( 6972897917355606205), KQU(14524774345368968243),
+	KQU( 2773529684745706940), KQU( 4853632376213075959),
+	KQU( 4198177923731358102), KQU( 8271224913084139776),
+	KQU( 2741753121611092226), KQU(16782366145996731181),
+	KQU(15426125238972640790), KQU(13595497100671260342),
+	KQU( 3173531022836259898), KQU( 6573264560319511662),
+	KQU(18041111951511157441), KQU( 2351433581833135952),
+	KQU( 3113255578908173487), KQU( 1739371330877858784),
+	KQU(16046126562789165480), KQU( 8072101652214192925),
+	KQU(15267091584090664910), KQU( 9309579200403648940),
+	KQU( 5218892439752408722), KQU(14492477246004337115),
+	KQU(17431037586679770619), KQU( 7385248135963250480),
+	KQU( 9580144956565560660), KQU( 4919546228040008720),
+	KQU(15261542469145035584), KQU(18233297270822253102),
+	KQU( 5453248417992302857), KQU( 9309519155931460285),
+	KQU(10342813012345291756), KQU(15676085186784762381),
+	KQU(15912092950691300645), KQU( 9371053121499003195),
+	KQU( 9897186478226866746), KQU(14061858287188196327),
+	KQU(  122575971620788119), KQU(12146750969116317754),
+	KQU( 4438317272813245201), KQU( 8332576791009527119),
+	KQU(13907785691786542057), KQU(10374194887283287467),
+	KQU( 2098798755649059566), KQU( 3416235197748288894),
+	KQU( 8688269957320773484), KQU( 7503964602397371571),
+	KQU(16724977015147478236), KQU( 9461512855439858184),
+	KQU(13259049744534534727), KQU( 3583094952542899294),
+	KQU( 8764245731305528292), KQU(13240823595462088985),
+	KQU(13716141617617910448), KQU(18114969519935960955),
+	KQU( 2297553615798302206), KQU( 4585521442944663362),
+	KQU(17776858680630198686), KQU( 4685873229192163363),
+	KQU(  152558080671135627), KQU(15424900540842670088),
+	KQU(13229630297130024108), KQU(17530268788245718717),
+	KQU(16675633913065714144), KQU( 3158912717897568068),
+	KQU(15399132185380087288), KQU( 7401418744515677872),
+	KQU(13135412922344398535), KQU( 6385314346100509511),
+	KQU(13962867001134161139), KQU(10272780155442671999),
+	KQU(12894856086597769142), KQU(13340877795287554994),
+	KQU(12913630602094607396), KQU(12543167911119793857),
+	KQU(17343570372251873096), KQU(10959487764494150545),
+	KQU( 6966737953093821128), KQU(13780699135496988601),
+	KQU( 4405070719380142046), KQU(14923788365607284982),
+	KQU( 2869487678905148380), KQU( 6416272754197188403),
+	KQU(15017380475943612591), KQU( 1995636220918429487),
+	KQU( 3402016804620122716), KQU(15800188663407057080),
+	KQU(11362369990390932882), KQU(15262183501637986147),
+	KQU(10239175385387371494), KQU( 9352042420365748334),
+	KQU( 1682457034285119875), KQU( 1724710651376289644),
+	KQU( 2038157098893817966), KQU( 9897825558324608773),
+	KQU( 1477666236519164736), KQU(16835397314511233640),
+	KQU(10370866327005346508), KQU(10157504370660621982),
+	KQU(12113904045335882069), KQU(13326444439742783008),
+	KQU(11302769043000765804), KQU(13594979923955228484),
+	KQU(11779351762613475968), KQU( 3786101619539298383),
+	KQU( 8021122969180846063), KQU(15745904401162500495),
+	KQU(10762168465993897267), KQU(13552058957896319026),
+	KQU(11200228655252462013), KQU( 5035370357337441226),
+	KQU( 7593918984545500013), KQU( 5418554918361528700),
+	KQU( 4858270799405446371), KQU( 9974659566876282544),
+	KQU(18227595922273957859), KQU( 2772778443635656220),
+	KQU(14285143053182085385), KQU( 9939700992429600469),
+	KQU(12756185904545598068), KQU( 2020783375367345262),
+	KQU(   57026775058331227), KQU(  950827867930065454),
+	KQU( 6602279670145371217), KQU( 2291171535443566929),
+	KQU( 5832380724425010313), KQU( 1220343904715982285),
+	KQU(17045542598598037633), KQU(15460481779702820971),
+	KQU(13948388779949365130), KQU(13975040175430829518),
+	KQU(17477538238425541763), KQU(11104663041851745725),
+	KQU(15860992957141157587), KQU(14529434633012950138),
+	KQU( 2504838019075394203), KQU( 7512113882611121886),
+	KQU( 4859973559980886617), KQU( 1258601555703250219),
+	KQU(15594548157514316394), KQU( 4516730171963773048),
+	KQU(11380103193905031983), KQU( 6809282239982353344),
+	KQU(18045256930420065002), KQU( 2453702683108791859),
+	KQU(  977214582986981460), KQU( 2006410402232713466),
+	KQU( 6192236267216378358), KQU( 3429468402195675253),
+	KQU(18146933153017348921), KQU(17369978576367231139),
+	KQU( 1246940717230386603), KQU(11335758870083327110),
+	KQU(14166488801730353682), KQU( 9008573127269635732),
+	KQU(10776025389820643815), KQU(15087605441903942962),
+	KQU( 1359542462712147922), KQU(13898874411226454206),
+	KQU(17911176066536804411), KQU( 9435590428600085274),
+	KQU(  294488509967864007), KQU( 8890111397567922046),
+	KQU( 7987823476034328778), KQU(13263827582440967651),
+	KQU( 7503774813106751573), KQU(14974747296185646837),
+	KQU( 8504765037032103375), KQU(17340303357444536213),
+	KQU( 7704610912964485743), KQU( 8107533670327205061),
+	KQU( 9062969835083315985), KQU(16968963142126734184),
+	KQU(12958041214190810180), KQU( 2720170147759570200),
+	KQU( 2986358963942189566), KQU(14884226322219356580),
+	KQU(  286224325144368520), KQU(11313800433154279797),
+	KQU(18366849528439673248), KQU(17899725929482368789),
+	KQU( 3730004284609106799), KQU( 1654474302052767205),
+	KQU( 5006698007047077032), KQU( 8196893913601182838),
+	KQU(15214541774425211640), KQU(17391346045606626073),
+	KQU( 8369003584076969089), KQU( 3939046733368550293),
+	KQU(10178639720308707785), KQU( 2180248669304388697),
+	KQU(   62894391300126322), KQU( 9205708961736223191),
+	KQU( 6837431058165360438), KQU( 3150743890848308214),
+	KQU(17849330658111464583), KQU(12214815643135450865),
+	KQU(13410713840519603402), KQU( 3200778126692046802),
+	KQU(13354780043041779313), KQU(  800850022756886036),
+	KQU(15660052933953067433), KQU( 6572823544154375676),
+	KQU(11030281857015819266), KQU(12682241941471433835),
+	KQU(11654136407300274693), KQU( 4517795492388641109),
+	KQU( 9757017371504524244), KQU(17833043400781889277),
+	KQU(12685085201747792227), KQU(10408057728835019573),
+	KQU(   98370418513455221), KQU( 6732663555696848598),
+	KQU(13248530959948529780), KQU( 3530441401230622826),
+	KQU(18188251992895660615), KQU( 1847918354186383756),
+	KQU( 1127392190402660921), KQU(11293734643143819463),
+	KQU( 3015506344578682982), KQU(13852645444071153329),
+	KQU( 2121359659091349142), KQU( 1294604376116677694),
+	KQU( 5616576231286352318), KQU( 7112502442954235625),
+	KQU(11676228199551561689), KQU(12925182803007305359),
+	KQU( 7852375518160493082), KQU( 1136513130539296154),
+	KQU( 5636923900916593195), KQU( 3221077517612607747),
+	KQU(17784790465798152513), KQU( 3554210049056995938),
+	KQU(17476839685878225874), KQU( 3206836372585575732),
+	KQU( 2765333945644823430), KQU(10080070903718799528),
+	KQU( 5412370818878286353), KQU( 9689685887726257728),
+	KQU( 8236117509123533998), KQU( 1951139137165040214),
+	KQU( 4492205209227980349), KQU(16541291230861602967),
+	KQU( 1424371548301437940), KQU( 9117562079669206794),
+	KQU(14374681563251691625), KQU(13873164030199921303),
+	KQU( 6680317946770936731), KQU(15586334026918276214),
+	KQU(10896213950976109802), KQU( 9506261949596413689),
+	KQU( 9903949574308040616), KQU( 6038397344557204470),
+	KQU(  174601465422373648), KQU(15946141191338238030),
+	KQU(17142225620992044937), KQU( 7552030283784477064),
+	KQU( 2947372384532947997), KQU(  510797021688197711),
+	KQU( 4962499439249363461), KQU(   23770320158385357),
+	KQU(  959774499105138124), KQU( 1468396011518788276),
+	KQU( 2015698006852312308), KQU( 4149400718489980136),
+	KQU( 5992916099522371188), KQU(10819182935265531076),
+	KQU(16189787999192351131), KQU(  342833961790261950),
+	KQU(12470830319550495336), KQU(18128495041912812501),
+	KQU( 1193600899723524337), KQU( 9056793666590079770),
+	KQU( 2154021227041669041), KQU( 4963570213951235735),
+	KQU( 4865075960209211409), KQU( 2097724599039942963),
+	KQU( 2024080278583179845), KQU(11527054549196576736),
+	KQU(10650256084182390252), KQU( 4808408648695766755),
+	KQU( 1642839215013788844), KQU(10607187948250398390),
+	KQU( 7076868166085913508), KQU(  730522571106887032),
+	KQU(12500579240208524895), KQU( 4484390097311355324),
+	KQU(15145801330700623870), KQU( 8055827661392944028),
+	KQU( 5865092976832712268), KQU(15159212508053625143),
+	KQU( 3560964582876483341), KQU( 4070052741344438280),
+	KQU( 6032585709886855634), KQU(15643262320904604873),
+	KQU( 2565119772293371111), KQU(  318314293065348260),
+	KQU(15047458749141511872), KQU( 7772788389811528730),
+	KQU( 7081187494343801976), KQU( 6465136009467253947),
+	KQU(10425940692543362069), KQU(  554608190318339115),
+	KQU(14796699860302125214), KQU( 1638153134431111443),
+	KQU(10336967447052276248), KQU( 8412308070396592958),
+	KQU( 4004557277152051226), KQU( 8143598997278774834),
+	KQU(16413323996508783221), KQU(13139418758033994949),
+	KQU( 9772709138335006667), KQU( 2818167159287157659),
+	KQU(17091740573832523669), KQU(14629199013130751608),
+	KQU(18268322711500338185), KQU( 8290963415675493063),
+	KQU( 8830864907452542588), KQU( 1614839084637494849),
+	KQU(14855358500870422231), KQU( 3472996748392519937),
+	KQU(15317151166268877716), KQU( 5825895018698400362),
+	KQU(16730208429367544129), KQU(10481156578141202800),
+	KQU( 4746166512382823750), KQU(12720876014472464998),
+	KQU( 8825177124486735972), KQU(13733447296837467838),
+	KQU( 6412293741681359625), KQU( 8313213138756135033),
+	KQU(11421481194803712517), KQU( 7997007691544174032),
+	KQU( 6812963847917605930), KQU( 9683091901227558641),
+	KQU(14703594165860324713), KQU( 1775476144519618309),
+	KQU( 2724283288516469519), KQU(  717642555185856868),
+	KQU( 8736402192215092346), KQU(11878800336431381021),
+	KQU( 4348816066017061293), KQU( 6115112756583631307),
+	KQU( 9176597239667142976), KQU(12615622714894259204),
+	KQU(10283406711301385987), KQU( 5111762509485379420),
+	KQU( 3118290051198688449), KQU( 7345123071632232145),
+	KQU( 9176423451688682359), KQU( 4843865456157868971),
+	KQU(12008036363752566088), KQU(12058837181919397720),
+	KQU( 2145073958457347366), KQU( 1526504881672818067),
+	KQU( 3488830105567134848), KQU(13208362960674805143),
+	KQU( 4077549672899572192), KQU( 7770995684693818365),
+	KQU( 1398532341546313593), KQU(12711859908703927840),
+	KQU( 1417561172594446813), KQU(17045191024194170604),
+	KQU( 4101933177604931713), KQU(14708428834203480320),
+	KQU(17447509264469407724), KQU(14314821973983434255),
+	KQU(17990472271061617265), KQU( 5087756685841673942),
+	KQU(12797820586893859939), KQU( 1778128952671092879),
+	KQU( 3535918530508665898), KQU( 9035729701042481301),
+	KQU(14808661568277079962), KQU(14587345077537747914),
+	KQU(11920080002323122708), KQU( 6426515805197278753),
+	KQU( 3295612216725984831), KQU(11040722532100876120),
+	KQU(12305952936387598754), KQU(16097391899742004253),
+	KQU( 4908537335606182208), KQU(12446674552196795504),
+	KQU(16010497855816895177), KQU( 9194378874788615551),
+	KQU( 3382957529567613384), KQU( 5154647600754974077),
+	KQU( 9801822865328396141), KQU( 9023662173919288143),
+	KQU(17623115353825147868), KQU( 8238115767443015816),
+	KQU(15811444159859002560), KQU( 9085612528904059661),
+	KQU( 6888601089398614254), KQU(  258252992894160189),
+	KQU( 6704363880792428622), KQU( 6114966032147235763),
+	KQU(11075393882690261875), KQU( 8797664238933620407),
+	KQU( 5901892006476726920), KQU( 5309780159285518958),
+	KQU(14940808387240817367), KQU(14642032021449656698),
+	KQU( 9808256672068504139), KQU( 3670135111380607658),
+	KQU(11211211097845960152), KQU( 1474304506716695808),
+	KQU(15843166204506876239), KQU( 7661051252471780561),
+	KQU(10170905502249418476), KQU( 7801416045582028589),
+	KQU( 2763981484737053050), KQU( 9491377905499253054),
+	KQU(16201395896336915095), KQU( 9256513756442782198),
+	KQU( 5411283157972456034), KQU( 5059433122288321676),
+	KQU( 4327408006721123357), KQU( 9278544078834433377),
+	KQU( 7601527110882281612), KQU(11848295896975505251),
+	KQU(12096998801094735560), KQU(14773480339823506413),
+	KQU(15586227433895802149), KQU(12786541257830242872),
+	KQU( 6904692985140503067), KQU( 5309011515263103959),
+	KQU(12105257191179371066), KQU(14654380212442225037),
+	KQU( 2556774974190695009), KQU( 4461297399927600261),
+	KQU(14888225660915118646), KQU(14915459341148291824),
+	KQU( 2738802166252327631), KQU( 6047155789239131512),
+	KQU(12920545353217010338), KQU(10697617257007840205),
+	KQU( 2751585253158203504), KQU(13252729159780047496),
+	KQU(14700326134672815469), KQU(14082527904374600529),
+	KQU(16852962273496542070), KQU(17446675504235853907),
+	KQU(15019600398527572311), KQU(12312781346344081551),
+	KQU(14524667935039810450), KQU( 5634005663377195738),
+	KQU(11375574739525000569), KQU( 2423665396433260040),
+	KQU( 5222836914796015410), KQU( 4397666386492647387),
+	KQU( 4619294441691707638), KQU(  665088602354770716),
+	KQU(13246495665281593610), KQU( 6564144270549729409),
+	KQU(10223216188145661688), KQU( 3961556907299230585),
+	KQU(11543262515492439914), KQU(16118031437285993790),
+	KQU( 7143417964520166465), KQU(13295053515909486772),
+	KQU(   40434666004899675), KQU(17127804194038347164),
+	KQU( 8599165966560586269), KQU( 8214016749011284903),
+	KQU(13725130352140465239), KQU( 5467254474431726291),
+	KQU( 7748584297438219877), KQU(16933551114829772472),
+	KQU( 2169618439506799400), KQU( 2169787627665113463),
+	KQU(17314493571267943764), KQU(18053575102911354912),
+	KQU(11928303275378476973), KQU(11593850925061715550),
+	KQU(17782269923473589362), KQU( 3280235307704747039),
+	KQU( 6145343578598685149), KQU(17080117031114086090),
+	KQU(18066839902983594755), KQU( 6517508430331020706),
+	KQU( 8092908893950411541), KQU(12558378233386153732),
+	KQU( 4476532167973132976), KQU(16081642430367025016),
+	KQU( 4233154094369139361), KQU( 8693630486693161027),
+	KQU(11244959343027742285), KQU(12273503967768513508),
+	KQU(14108978636385284876), KQU( 7242414665378826984),
+	KQU( 6561316938846562432), KQU( 8601038474994665795),
+	KQU(17532942353612365904), KQU(17940076637020912186),
+	KQU( 7340260368823171304), KQU( 7061807613916067905),
+	KQU(10561734935039519326), KQU(17990796503724650862),
+	KQU( 6208732943911827159), KQU(  359077562804090617),
+	KQU(14177751537784403113), KQU(10659599444915362902),
+	KQU(15081727220615085833), KQU(13417573895659757486),
+	KQU(15513842342017811524), KQU(11814141516204288231),
+	KQU( 1827312513875101814), KQU( 2804611699894603103),
+	KQU(17116500469975602763), KQU(12270191815211952087),
+	KQU(12256358467786024988), KQU(18435021722453971267),
+	KQU(  671330264390865618), KQU(  476504300460286050),
+	KQU(16465470901027093441), KQU( 4047724406247136402),
+	KQU( 1322305451411883346), KQU( 1388308688834322280),
+	KQU( 7303989085269758176), KQU( 9323792664765233642),
+	KQU( 4542762575316368936), KQU(17342696132794337618),
+	KQU( 4588025054768498379), KQU(13415475057390330804),
+	KQU(17880279491733405570), KQU(10610553400618620353),
+	KQU( 3180842072658960139), KQU(13002966655454270120),
+	KQU( 1665301181064982826), KQU( 7083673946791258979),
+	KQU(  190522247122496820), KQU(17388280237250677740),
+	KQU( 8430770379923642945), KQU(12987180971921668584),
+	KQU( 2311086108365390642), KQU( 2870984383579822345),
+	KQU(14014682609164653318), KQU(14467187293062251484),
+	KQU(  192186361147413298), KQU(15171951713531796524),
+	KQU( 9900305495015948728), KQU(17958004775615466344),
+	KQU(14346380954498606514), KQU(18040047357617407096),
+	KQU( 5035237584833424532), KQU(15089555460613972287),
+	KQU( 4131411873749729831), KQU( 1329013581168250330),
+	KQU(10095353333051193949), KQU(10749518561022462716),
+	KQU( 9050611429810755847), KQU(15022028840236655649),
+	KQU( 8775554279239748298), KQU(13105754025489230502),
+	KQU(15471300118574167585), KQU(   89864764002355628),
+	KQU( 8776416323420466637), KQU( 5280258630612040891),
+	KQU( 2719174488591862912), KQU( 7599309137399661994),
+	KQU(15012887256778039979), KQU(14062981725630928925),
+	KQU(12038536286991689603), KQU( 7089756544681775245),
+	KQU(10376661532744718039), KQU( 1265198725901533130),
+	KQU(13807996727081142408), KQU( 2935019626765036403),
+	KQU( 7651672460680700141), KQU( 3644093016200370795),
+	KQU( 2840982578090080674), KQU(17956262740157449201),
+	KQU(18267979450492880548), KQU(11799503659796848070),
+	KQU( 9942537025669672388), KQU(11886606816406990297),
+	KQU( 5488594946437447576), KQU( 7226714353282744302),
+	KQU( 3784851653123877043), KQU(  878018453244803041),
+	KQU(12110022586268616085), KQU(  734072179404675123),
+	KQU(11869573627998248542), KQU(  469150421297783998),
+	KQU(  260151124912803804), KQU(11639179410120968649),
+	KQU( 9318165193840846253), KQU(12795671722734758075),
+	KQU(15318410297267253933), KQU(  691524703570062620),
+	KQU( 5837129010576994601), KQU(15045963859726941052),
+	KQU( 5850056944932238169), KQU(12017434144750943807),
+	KQU( 7447139064928956574), KQU( 3101711812658245019),
+	KQU(16052940704474982954), KQU(18195745945986994042),
+	KQU( 8932252132785575659), KQU(13390817488106794834),
+	KQU(11582771836502517453), KQU( 4964411326683611686),
+	KQU( 2195093981702694011), KQU(14145229538389675669),
+	KQU(16459605532062271798), KQU(  866316924816482864),
+	KQU( 4593041209937286377), KQU( 8415491391910972138),
+	KQU( 4171236715600528969), KQU(16637569303336782889),
+	KQU( 2002011073439212680), KQU(17695124661097601411),
+	KQU( 4627687053598611702), KQU( 7895831936020190403),
+	KQU( 8455951300917267802), KQU( 2923861649108534854),
+	KQU( 8344557563927786255), KQU( 6408671940373352556),
+	KQU(12210227354536675772), KQU(14294804157294222295),
+	KQU(10103022425071085127), KQU(10092959489504123771),
+	KQU( 6554774405376736268), KQU(12629917718410641774),
+	KQU( 6260933257596067126), KQU( 2460827021439369673),
+	KQU( 2541962996717103668), KQU(  597377203127351475),
+	KQU( 5316984203117315309), KQU( 4811211393563241961),
+	KQU(13119698597255811641), KQU( 8048691512862388981),
+	KQU(10216818971194073842), KQU( 4612229970165291764),
+	KQU(10000980798419974770), KQU( 6877640812402540687),
+	KQU( 1488727563290436992), KQU( 2227774069895697318),
+	KQU(11237754507523316593), KQU(13478948605382290972),
+	KQU( 1963583846976858124), KQU( 5512309205269276457),
+	KQU( 3972770164717652347), KQU( 3841751276198975037),
+	KQU(10283343042181903117), KQU( 8564001259792872199),
+	KQU(16472187244722489221), KQU( 8953493499268945921),
+	KQU( 3518747340357279580), KQU( 4003157546223963073),
+	KQU( 3270305958289814590), KQU( 3966704458129482496),
+	KQU( 8122141865926661939), KQU(14627734748099506653),
+	KQU(13064426990862560568), KQU( 2414079187889870829),
+	KQU( 5378461209354225306), KQU(10841985740128255566),
+	KQU(  538582442885401738), KQU( 7535089183482905946),
+	KQU(16117559957598879095), KQU( 8477890721414539741),
+	KQU( 1459127491209533386), KQU(17035126360733620462),
+	KQU( 8517668552872379126), KQU(10292151468337355014),
+	KQU(17081267732745344157), KQU(13751455337946087178),
+	KQU(14026945459523832966), KQU( 6653278775061723516),
+	KQU(10619085543856390441), KQU( 2196343631481122885),
+	KQU(10045966074702826136), KQU(10082317330452718282),
+	KQU( 5920859259504831242), KQU( 9951879073426540617),
+	KQU( 7074696649151414158), KQU(15808193543879464318),
+	KQU( 7385247772746953374), KQU( 3192003544283864292),
+	KQU(18153684490917593847), KQU(12423498260668568905),
+	KQU(10957758099756378169), KQU(11488762179911016040),
+	KQU( 2099931186465333782), KQU(11180979581250294432),
+	KQU( 8098916250668367933), KQU( 3529200436790763465),
+	KQU(12988418908674681745), KQU( 6147567275954808580),
+	KQU( 3207503344604030989), KQU(10761592604898615360),
+	KQU(  229854861031893504), KQU( 8809853962667144291),
+	KQU(13957364469005693860), KQU( 7634287665224495886),
+	KQU(12353487366976556874), KQU( 1134423796317152034),
+	KQU( 2088992471334107068), KQU( 7393372127190799698),
+	KQU( 1845367839871058391), KQU(  207922563987322884),
+	KQU(11960870813159944976), KQU(12182120053317317363),
+	KQU(17307358132571709283), KQU(13871081155552824936),
+	KQU(18304446751741566262), KQU( 7178705220184302849),
+	KQU(10929605677758824425), KQU(16446976977835806844),
+	KQU(13723874412159769044), KQU( 6942854352100915216),
+	KQU( 1726308474365729390), KQU( 2150078766445323155),
+	KQU(15345558947919656626), KQU(12145453828874527201),
+	KQU( 2054448620739726849), KQU( 2740102003352628137),
+	KQU(11294462163577610655), KQU(  756164283387413743),
+	KQU(17841144758438810880), KQU(10802406021185415861),
+	KQU( 8716455530476737846), KQU( 6321788834517649606),
+	KQU(14681322910577468426), KQU(17330043563884336387),
+	KQU(12701802180050071614), KQU(14695105111079727151),
+	KQU( 5112098511654172830), KQU( 4957505496794139973),
+	KQU( 8270979451952045982), KQU(12307685939199120969),
+	KQU(12425799408953443032), KQU( 8376410143634796588),
+	KQU(16621778679680060464), KQU( 3580497854566660073),
+	KQU( 1122515747803382416), KQU(  857664980960597599),
+	KQU( 6343640119895925918), KQU(12878473260854462891),
+	KQU(10036813920765722626), KQU(14451335468363173812),
+	KQU( 5476809692401102807), KQU(16442255173514366342),
+	KQU(13060203194757167104), KQU(14354124071243177715),
+	KQU(15961249405696125227), KQU(13703893649690872584),
+	KQU(  363907326340340064), KQU( 6247455540491754842),
+	KQU(12242249332757832361), KQU(  156065475679796717),
+	KQU( 9351116235749732355), KQU( 4590350628677701405),
+	KQU( 1671195940982350389), KQU(13501398458898451905),
+	KQU( 6526341991225002255), KQU( 1689782913778157592),
+	KQU( 7439222350869010334), KQU(13975150263226478308),
+	KQU(11411961169932682710), KQU(17204271834833847277),
+	KQU(  541534742544435367), KQU( 6591191931218949684),
+	KQU( 2645454775478232486), KQU( 4322857481256485321),
+	KQU( 8477416487553065110), KQU(12902505428548435048),
+	KQU(  971445777981341415), KQU(14995104682744976712),
+	KQU( 4243341648807158063), KQU( 8695061252721927661),
+	KQU( 5028202003270177222), KQU( 2289257340915567840),
+	KQU(13870416345121866007), KQU(13994481698072092233),
+	KQU( 6912785400753196481), KQU( 2278309315841980139),
+	KQU( 4329765449648304839), KQU( 5963108095785485298),
+	KQU( 4880024847478722478), KQU(16015608779890240947),
+	KQU( 1866679034261393544), KQU(  914821179919731519),
+	KQU( 9643404035648760131), KQU( 2418114953615593915),
+	KQU(  944756836073702374), KQU(15186388048737296834),
+	KQU( 7723355336128442206), KQU( 7500747479679599691),
+	KQU(18013961306453293634), KQU( 2315274808095756456),
+	KQU(13655308255424029566), KQU(17203800273561677098),
+	KQU( 1382158694422087756), KQU( 5090390250309588976),
+	KQU(  517170818384213989), KQU( 1612709252627729621),
+	KQU( 1330118955572449606), KQU(  300922478056709885),
+	KQU(18115693291289091987), KQU(13491407109725238321),
+	KQU(15293714633593827320), KQU( 5151539373053314504),
+	KQU( 5951523243743139207), KQU(14459112015249527975),
+	KQU( 5456113959000700739), KQU( 3877918438464873016),
+	KQU(12534071654260163555), KQU(15871678376893555041),
+	KQU(11005484805712025549), KQU(16353066973143374252),
+	KQU( 4358331472063256685), KQU( 8268349332210859288),
+	KQU(12485161590939658075), KQU(13955993592854471343),
+	KQU( 5911446886848367039), KQU(14925834086813706974),
+	KQU( 6590362597857994805), KQU( 1280544923533661875),
+	KQU( 1637756018947988164), KQU( 4734090064512686329),
+	KQU(16693705263131485912), KQU( 6834882340494360958),
+	KQU( 8120732176159658505), KQU( 2244371958905329346),
+	KQU(10447499707729734021), KQU( 7318742361446942194),
+	KQU( 8032857516355555296), KQU(14023605983059313116),
+	KQU( 1032336061815461376), KQU( 9840995337876562612),
+	KQU( 9869256223029203587), KQU(12227975697177267636),
+	KQU(12728115115844186033), KQU( 7752058479783205470),
+	KQU(  729733219713393087), KQU(12954017801239007622)
 };
 static const uint64_t init_by_array_64_expected[] = {
-	QU( 2100341266307895239LLU), QU( 8344256300489757943LLU),
-	QU(15687933285484243894LLU), QU( 8268620370277076319LLU),
-	QU(12371852309826545459LLU), QU( 8800491541730110238LLU),
-	QU(18113268950100835773LLU), QU( 2886823658884438119LLU),
-	QU( 3293667307248180724LLU), QU( 9307928143300172731LLU),
-	QU( 7688082017574293629LLU), QU(  900986224735166665LLU),
-	QU( 9977972710722265039LLU), QU( 6008205004994830552LLU),
-	QU(  546909104521689292LLU), QU( 7428471521869107594LLU),
-	QU(14777563419314721179LLU), QU(16116143076567350053LLU),
-	QU( 5322685342003142329LLU), QU( 4200427048445863473LLU),
-	QU( 4693092150132559146LLU), QU(13671425863759338582LLU),
-	QU( 6747117460737639916LLU), QU( 4732666080236551150LLU),
-	QU( 5912839950611941263LLU), QU( 3903717554504704909LLU),
-	QU( 2615667650256786818LLU), QU(10844129913887006352LLU),
-	QU(13786467861810997820LLU), QU(14267853002994021570LLU),
-	QU(13767807302847237439LLU), QU(16407963253707224617LLU),
-	QU( 4802498363698583497LLU), QU( 2523802839317209764LLU),
-	QU( 3822579397797475589LLU), QU( 8950320572212130610LLU),
-	QU( 3745623504978342534LLU), QU(16092609066068482806LLU),
-	QU( 9817016950274642398LLU), QU(10591660660323829098LLU),
-	QU(11751606650792815920LLU), QU( 5122873818577122211LLU),
-	QU(17209553764913936624LLU), QU( 6249057709284380343LLU),
-	QU(15088791264695071830LLU), QU(15344673071709851930LLU),
-	QU( 4345751415293646084LLU), QU( 2542865750703067928LLU),
-	QU(13520525127852368784LLU), QU(18294188662880997241LLU),
-	QU( 3871781938044881523LLU), QU( 2873487268122812184LLU),
-	QU(15099676759482679005LLU), QU(15442599127239350490LLU),
-	QU( 6311893274367710888LLU), QU( 3286118760484672933LLU),
-	QU( 4146067961333542189LLU), QU(13303942567897208770LLU),
-	QU( 8196013722255630418LLU), QU( 4437815439340979989LLU),
-	QU(15433791533450605135LLU), QU( 4254828956815687049LLU),
-	QU( 1310903207708286015LLU), QU(10529182764462398549LLU),
-	QU(14900231311660638810LLU), QU( 9727017277104609793LLU),
-	QU( 1821308310948199033LLU), QU(11628861435066772084LLU),
-	QU( 9469019138491546924LLU), QU( 3145812670532604988LLU),
-	QU( 9938468915045491919LLU), QU( 1562447430672662142LLU),
-	QU(13963995266697989134LLU), QU( 3356884357625028695LLU),
-	QU( 4499850304584309747LLU), QU( 8456825817023658122LLU),
-	QU(10859039922814285279LLU), QU( 8099512337972526555LLU),
-	QU(  348006375109672149LLU), QU(11919893998241688603LLU),
-	QU( 1104199577402948826LLU), QU(16689191854356060289LLU),
-	QU(10992552041730168078LLU), QU( 7243733172705465836LLU),
-	QU( 5668075606180319560LLU), QU(18182847037333286970LLU),
-	QU( 4290215357664631322LLU), QU( 4061414220791828613LLU),
-	QU(13006291061652989604LLU), QU( 7140491178917128798LLU),
-	QU(12703446217663283481LLU), QU( 5500220597564558267LLU),
-	QU(10330551509971296358LLU), QU(15958554768648714492LLU),
-	QU( 5174555954515360045LLU), QU( 1731318837687577735LLU),
-	QU( 3557700801048354857LLU), QU(13764012341928616198LLU),
-	QU(13115166194379119043LLU), QU( 7989321021560255519LLU),
-	QU( 2103584280905877040LLU), QU( 9230788662155228488LLU),
-	QU(16396629323325547654LLU), QU(  657926409811318051LLU),
-	QU(15046700264391400727LLU), QU( 5120132858771880830LLU),
-	QU( 7934160097989028561LLU), QU( 6963121488531976245LLU),
-	QU(17412329602621742089LLU), QU(15144843053931774092LLU),
-	QU(17204176651763054532LLU), QU(13166595387554065870LLU),
-	QU( 8590377810513960213LLU), QU( 5834365135373991938LLU),
-	QU( 7640913007182226243LLU), QU( 3479394703859418425LLU),
-	QU(16402784452644521040LLU), QU( 4993979809687083980LLU),
-	QU(13254522168097688865LLU), QU(15643659095244365219LLU),
-	QU( 5881437660538424982LLU), QU(11174892200618987379LLU),
-	QU(  254409966159711077LLU), QU(17158413043140549909LLU),
-	QU( 3638048789290376272LLU), QU( 1376816930299489190LLU),
-	QU( 4622462095217761923LLU), QU(15086407973010263515LLU),
-	QU(13253971772784692238LLU), QU( 5270549043541649236LLU),
-	QU(11182714186805411604LLU), QU(12283846437495577140LLU),
-	QU( 5297647149908953219LLU), QU(10047451738316836654LLU),
-	QU( 4938228100367874746LLU), QU(12328523025304077923LLU),
-	QU( 3601049438595312361LLU), QU( 9313624118352733770LLU),
-	QU(13322966086117661798LLU), QU(16660005705644029394LLU),
-	QU(11337677526988872373LLU), QU(13869299102574417795LLU),
-	QU(15642043183045645437LLU), QU( 3021755569085880019LLU),
-	QU( 4979741767761188161LLU), QU(13679979092079279587LLU),
-	QU( 3344685842861071743LLU), QU(13947960059899588104LLU),
-	QU(  305806934293368007LLU), QU( 5749173929201650029LLU),
-	QU(11123724852118844098LLU), QU(15128987688788879802LLU),
-	QU(15251651211024665009LLU), QU( 7689925933816577776LLU),
-	QU(16732804392695859449LLU), QU(17087345401014078468LLU),
-	QU(14315108589159048871LLU), QU( 4820700266619778917LLU),
-	QU(16709637539357958441LLU), QU( 4936227875177351374LLU),
-	QU( 2137907697912987247LLU), QU(11628565601408395420LLU),
-	QU( 2333250549241556786LLU), QU( 5711200379577778637LLU),
-	QU( 5170680131529031729LLU), QU(12620392043061335164LLU),
-	QU(   95363390101096078LLU), QU( 5487981914081709462LLU),
-	QU( 1763109823981838620LLU), QU( 3395861271473224396LLU),
-	QU( 1300496844282213595LLU), QU( 6894316212820232902LLU),
-	QU(10673859651135576674LLU), QU( 5911839658857903252LLU),
-	QU(17407110743387299102LLU), QU( 8257427154623140385LLU),
-	QU(11389003026741800267LLU), QU( 4070043211095013717LLU),
-	QU(11663806997145259025LLU), QU(15265598950648798210LLU),
-	QU(  630585789434030934LLU), QU( 3524446529213587334LLU),
-	QU( 7186424168495184211LLU), QU(10806585451386379021LLU),
-	QU(11120017753500499273LLU), QU( 1586837651387701301LLU),
-	QU(17530454400954415544LLU), QU( 9991670045077880430LLU),
-	QU( 7550997268990730180LLU), QU( 8640249196597379304LLU),
-	QU( 3522203892786893823LLU), QU(10401116549878854788LLU),
-	QU(13690285544733124852LLU), QU( 8295785675455774586LLU),
-	QU(15535716172155117603LLU), QU( 3112108583723722511LLU),
-	QU(17633179955339271113LLU), QU(18154208056063759375LLU),
-	QU( 1866409236285815666LLU), QU(13326075895396412882LLU),
-	QU( 8756261842948020025LLU), QU( 6281852999868439131LLU),
-	QU(15087653361275292858LLU), QU(10333923911152949397LLU),
-	QU( 5265567645757408500LLU), QU(12728041843210352184LLU),
-	QU( 6347959327507828759LLU), QU(  154112802625564758LLU),
-	QU(18235228308679780218LLU), QU( 3253805274673352418LLU),
-	QU( 4849171610689031197LLU), QU(17948529398340432518LLU),
-	QU(13803510475637409167LLU), QU(13506570190409883095LLU),
-	QU(15870801273282960805LLU), QU( 8451286481299170773LLU),
-	QU( 9562190620034457541LLU), QU( 8518905387449138364LLU),
-	QU(12681306401363385655LLU), QU( 3788073690559762558LLU),
-	QU( 5256820289573487769LLU), QU( 2752021372314875467LLU),
-	QU( 6354035166862520716LLU), QU( 4328956378309739069LLU),
-	QU(  449087441228269600LLU), QU( 5533508742653090868LLU),
-	QU( 1260389420404746988LLU), QU(18175394473289055097LLU),
-	QU( 1535467109660399420LLU), QU( 8818894282874061442LLU),
-	QU(12140873243824811213LLU), QU(15031386653823014946LLU),
-	QU( 1286028221456149232LLU), QU( 6329608889367858784LLU),
-	QU( 9419654354945132725LLU), QU( 6094576547061672379LLU),
-	QU(17706217251847450255LLU), QU( 1733495073065878126LLU),
-	QU(16918923754607552663LLU), QU( 8881949849954945044LLU),
-	QU(12938977706896313891LLU), QU(14043628638299793407LLU),
-	QU(18393874581723718233LLU), QU( 6886318534846892044LLU),
-	QU(14577870878038334081LLU), QU(13541558383439414119LLU),
-	QU(13570472158807588273LLU), QU(18300760537910283361LLU),
-	QU(  818368572800609205LLU), QU( 1417000585112573219LLU),
-	QU(12337533143867683655LLU), QU(12433180994702314480LLU),
-	QU(  778190005829189083LLU), QU(13667356216206524711LLU),
-	QU( 9866149895295225230LLU), QU(11043240490417111999LLU),
-	QU( 1123933826541378598LLU), QU( 6469631933605123610LLU),
-	QU(14508554074431980040LLU), QU(13918931242962026714LLU),
-	QU( 2870785929342348285LLU), QU(14786362626740736974LLU),
-	QU(13176680060902695786LLU), QU( 9591778613541679456LLU),
-	QU( 9097662885117436706LLU), QU(  749262234240924947LLU),
-	QU( 1944844067793307093LLU), QU( 4339214904577487742LLU),
-	QU( 8009584152961946551LLU), QU(16073159501225501777LLU),
-	QU( 3335870590499306217LLU), QU(17088312653151202847LLU),
-	QU( 3108893142681931848LLU), QU(16636841767202792021LLU),
-	QU(10423316431118400637LLU), QU( 8008357368674443506LLU),
-	QU(11340015231914677875LLU), QU(17687896501594936090LLU),
-	QU(15173627921763199958LLU), QU(  542569482243721959LLU),
-	QU(15071714982769812975LLU), QU( 4466624872151386956LLU),
-	QU( 1901780715602332461LLU), QU( 9822227742154351098LLU),
-	QU( 1479332892928648780LLU), QU( 6981611948382474400LLU),
-	QU( 7620824924456077376LLU), QU(14095973329429406782LLU),
-	QU( 7902744005696185404LLU), QU(15830577219375036920LLU),
-	QU(10287076667317764416LLU), QU(12334872764071724025LLU),
-	QU( 4419302088133544331LLU), QU(14455842851266090520LLU),
-	QU(12488077416504654222LLU), QU( 7953892017701886766LLU),
-	QU( 6331484925529519007LLU), QU( 4902145853785030022LLU),
-	QU(17010159216096443073LLU), QU(11945354668653886087LLU),
-	QU(15112022728645230829LLU), QU(17363484484522986742LLU),
-	QU( 4423497825896692887LLU), QU( 8155489510809067471LLU),
-	QU(  258966605622576285LLU), QU( 5462958075742020534LLU),
-	QU( 6763710214913276228LLU), QU( 2368935183451109054LLU),
-	QU(14209506165246453811LLU), QU( 2646257040978514881LLU),
-	QU( 3776001911922207672LLU), QU( 1419304601390147631LLU),
-	QU(14987366598022458284LLU), QU( 3977770701065815721LLU),
-	QU(  730820417451838898LLU), QU( 3982991703612885327LLU),
-	QU( 2803544519671388477LLU), QU(17067667221114424649LLU),
-	QU( 2922555119737867166LLU), QU( 1989477584121460932LLU),
-	QU(15020387605892337354LLU), QU( 9293277796427533547LLU),
-	QU(10722181424063557247LLU), QU(16704542332047511651LLU),
-	QU( 5008286236142089514LLU), QU(16174732308747382540LLU),
-	QU(17597019485798338402LLU), QU(13081745199110622093LLU),
-	QU( 8850305883842258115LLU), QU(12723629125624589005LLU),
-	QU( 8140566453402805978LLU), QU(15356684607680935061LLU),
-	QU(14222190387342648650LLU), QU(11134610460665975178LLU),
-	QU( 1259799058620984266LLU), QU(13281656268025610041LLU),
-	QU(  298262561068153992LLU), QU(12277871700239212922LLU),
-	QU(13911297774719779438LLU), QU(16556727962761474934LLU),
-	QU(17903010316654728010LLU), QU( 9682617699648434744LLU),
-	QU(14757681836838592850LLU), QU( 1327242446558524473LLU),
-	QU(11126645098780572792LLU), QU( 1883602329313221774LLU),
-	QU( 2543897783922776873LLU), QU(15029168513767772842LLU),
-	QU(12710270651039129878LLU), QU(16118202956069604504LLU),
-	QU(15010759372168680524LLU), QU( 2296827082251923948LLU),
-	QU(10793729742623518101LLU), QU(13829764151845413046LLU),
-	QU(17769301223184451213LLU), QU( 3118268169210783372LLU),
-	QU(17626204544105123127LLU), QU( 7416718488974352644LLU),
-	QU(10450751996212925994LLU), QU( 9352529519128770586LLU),
-	QU(  259347569641110140LLU), QU( 8048588892269692697LLU),
-	QU( 1774414152306494058LLU), QU(10669548347214355622LLU),
-	QU(13061992253816795081LLU), QU(18432677803063861659LLU),
-	QU( 8879191055593984333LLU), QU(12433753195199268041LLU),
-	QU(14919392415439730602LLU), QU( 6612848378595332963LLU),
-	QU( 6320986812036143628LLU), QU(10465592420226092859LLU),
-	QU( 4196009278962570808LLU), QU( 3747816564473572224LLU),
-	QU(17941203486133732898LLU), QU( 2350310037040505198LLU),
-	QU( 5811779859134370113LLU), QU(10492109599506195126LLU),
-	QU( 7699650690179541274LLU), QU( 1954338494306022961LLU),
-	QU(14095816969027231152LLU), QU( 5841346919964852061LLU),
-	QU(14945969510148214735LLU), QU( 3680200305887550992LLU),
-	QU( 6218047466131695792LLU), QU( 8242165745175775096LLU),
-	QU(11021371934053307357LLU), QU( 1265099502753169797LLU),
-	QU( 4644347436111321718LLU), QU( 3609296916782832859LLU),
-	QU( 8109807992218521571LLU), QU(18387884215648662020LLU),
-	QU(14656324896296392902LLU), QU(17386819091238216751LLU),
-	QU(17788300878582317152LLU), QU( 7919446259742399591LLU),
-	QU( 4466613134576358004LLU), QU(12928181023667938509LLU),
-	QU(13147446154454932030LLU), QU(16552129038252734620LLU),
-	QU( 8395299403738822450LLU), QU(11313817655275361164LLU),
-	QU(  434258809499511718LLU), QU( 2074882104954788676LLU),
-	QU( 7929892178759395518LLU), QU( 9006461629105745388LLU),
-	QU( 5176475650000323086LLU), QU(11128357033468341069LLU),
-	QU(12026158851559118955LLU), QU(14699716249471156500LLU),
-	QU(  448982497120206757LLU), QU( 4156475356685519900LLU),
-	QU( 6063816103417215727LLU), QU(10073289387954971479LLU),
-	QU( 8174466846138590962LLU), QU( 2675777452363449006LLU),
-	QU( 9090685420572474281LLU), QU( 6659652652765562060LLU),
-	QU(12923120304018106621LLU), QU(11117480560334526775LLU),
-	QU(  937910473424587511LLU), QU( 1838692113502346645LLU),
-	QU(11133914074648726180LLU), QU( 7922600945143884053LLU),
-	QU(13435287702700959550LLU), QU( 5287964921251123332LLU),
-	QU(11354875374575318947LLU), QU(17955724760748238133LLU),
-	QU(13728617396297106512LLU), QU( 4107449660118101255LLU),
-	QU( 1210269794886589623LLU), QU(11408687205733456282LLU),
-	QU( 4538354710392677887LLU), QU(13566803319341319267LLU),
-	QU(17870798107734050771LLU), QU( 3354318982568089135LLU),
-	QU( 9034450839405133651LLU), QU(13087431795753424314LLU),
-	QU(  950333102820688239LLU), QU( 1968360654535604116LLU),
-	QU(16840551645563314995LLU), QU( 8867501803892924995LLU),
-	QU(11395388644490626845LLU), QU( 1529815836300732204LLU),
-	QU(13330848522996608842LLU), QU( 1813432878817504265LLU),
-	QU( 2336867432693429560LLU), QU(15192805445973385902LLU),
-	QU( 2528593071076407877LLU), QU(  128459777936689248LLU),
-	QU( 9976345382867214866LLU), QU( 6208885766767996043LLU),
-	QU(14982349522273141706LLU), QU( 3099654362410737822LLU),
-	QU(13776700761947297661LLU), QU( 8806185470684925550LLU),
-	QU( 8151717890410585321LLU), QU(  640860591588072925LLU),
-	QU(14592096303937307465LLU), QU( 9056472419613564846LLU),
-	QU(14861544647742266352LLU), QU(12703771500398470216LLU),
-	QU( 3142372800384138465LLU), QU( 6201105606917248196LLU),
-	QU(18337516409359270184LLU), QU(15042268695665115339LLU),
-	QU(15188246541383283846LLU), QU(12800028693090114519LLU),
-	QU( 5992859621101493472LLU), QU(18278043971816803521LLU),
-	QU( 9002773075219424560LLU), QU( 7325707116943598353LLU),
-	QU( 7930571931248040822LLU), QU( 5645275869617023448LLU),
-	QU( 7266107455295958487LLU), QU( 4363664528273524411LLU),
-	QU(14313875763787479809LLU), QU(17059695613553486802LLU),
-	QU( 9247761425889940932LLU), QU(13704726459237593128LLU),
-	QU( 2701312427328909832LLU), QU(17235532008287243115LLU),
-	QU(14093147761491729538LLU), QU( 6247352273768386516LLU),
-	QU( 8268710048153268415LLU), QU( 7985295214477182083LLU),
-	QU(15624495190888896807LLU), QU( 3772753430045262788LLU),
-	QU( 9133991620474991698LLU), QU( 5665791943316256028LLU),
-	QU( 7551996832462193473LLU), QU(13163729206798953877LLU),
-	QU( 9263532074153846374LLU), QU( 1015460703698618353LLU),
-	QU(17929874696989519390LLU), QU(18257884721466153847LLU),
-	QU(16271867543011222991LLU), QU( 3905971519021791941LLU),
-	QU(16814488397137052085LLU), QU( 1321197685504621613LLU),
-	QU( 2870359191894002181LLU), QU(14317282970323395450LLU),
-	QU(13663920845511074366LLU), QU( 2052463995796539594LLU),
-	QU(14126345686431444337LLU), QU( 1727572121947022534LLU),
-	QU(17793552254485594241LLU), QU( 6738857418849205750LLU),
-	QU( 1282987123157442952LLU), QU(16655480021581159251LLU),
-	QU( 6784587032080183866LLU), QU(14726758805359965162LLU),
-	QU( 7577995933961987349LLU), QU(12539609320311114036LLU),
-	QU(10789773033385439494LLU), QU( 8517001497411158227LLU),
-	QU(10075543932136339710LLU), QU(14838152340938811081LLU),
-	QU( 9560840631794044194LLU), QU(17445736541454117475LLU),
-	QU(10633026464336393186LLU), QU(15705729708242246293LLU),
-	QU( 1117517596891411098LLU), QU( 4305657943415886942LLU),
-	QU( 4948856840533979263LLU), QU(16071681989041789593LLU),
-	QU(13723031429272486527LLU), QU( 7639567622306509462LLU),
-	QU(12670424537483090390LLU), QU( 9715223453097197134LLU),
-	QU( 5457173389992686394LLU), QU(  289857129276135145LLU),
-	QU(17048610270521972512LLU), QU(  692768013309835485LLU),
-	QU(14823232360546632057LLU), QU(18218002361317895936LLU),
-	QU( 3281724260212650204LLU), QU(16453957266549513795LLU),
-	QU( 8592711109774511881LLU), QU(  929825123473369579LLU),
-	QU(15966784769764367791LLU), QU( 9627344291450607588LLU),
-	QU(10849555504977813287LLU), QU( 9234566913936339275LLU),
-	QU( 6413807690366911210LLU), QU(10862389016184219267LLU),
-	QU(13842504799335374048LLU), QU( 1531994113376881174LLU),
-	QU( 2081314867544364459LLU), QU(16430628791616959932LLU),
-	QU( 8314714038654394368LLU), QU( 9155473892098431813LLU),
-	QU(12577843786670475704LLU), QU( 4399161106452401017LLU),
-	QU( 1668083091682623186LLU), QU( 1741383777203714216LLU),
-	QU( 2162597285417794374LLU), QU(15841980159165218736LLU),
-	QU( 1971354603551467079LLU), QU( 1206714764913205968LLU),
-	QU( 4790860439591272330LLU), QU(14699375615594055799LLU),
-	QU( 8374423871657449988LLU), QU(10950685736472937738LLU),
-	QU(  697344331343267176LLU), QU(10084998763118059810LLU),
-	QU(12897369539795983124LLU), QU(12351260292144383605LLU),
-	QU( 1268810970176811234LLU), QU( 7406287800414582768LLU),
-	QU(  516169557043807831LLU), QU( 5077568278710520380LLU),
-	QU( 3828791738309039304LLU), QU( 7721974069946943610LLU),
-	QU( 3534670260981096460LLU), QU( 4865792189600584891LLU),
-	QU(16892578493734337298LLU), QU( 9161499464278042590LLU),
-	QU(11976149624067055931LLU), QU(13219479887277343990LLU),
-	QU(14161556738111500680LLU), QU(14670715255011223056LLU),
-	QU( 4671205678403576558LLU), QU(12633022931454259781LLU),
-	QU(14821376219869187646LLU), QU(  751181776484317028LLU),
-	QU( 2192211308839047070LLU), QU(11787306362361245189LLU),
-	QU(10672375120744095707LLU), QU( 4601972328345244467LLU),
-	QU(15457217788831125879LLU), QU( 8464345256775460809LLU),
-	QU(10191938789487159478LLU), QU( 6184348739615197613LLU),
-	QU(11425436778806882100LLU), QU( 2739227089124319793LLU),
-	QU(  461464518456000551LLU), QU( 4689850170029177442LLU),
-	QU( 6120307814374078625LLU), QU(11153579230681708671LLU),
-	QU( 7891721473905347926LLU), QU(10281646937824872400LLU),
-	QU( 3026099648191332248LLU), QU( 8666750296953273818LLU),
-	QU(14978499698844363232LLU), QU(13303395102890132065LLU),
-	QU( 8182358205292864080LLU), QU(10560547713972971291LLU),
-	QU(11981635489418959093LLU), QU( 3134621354935288409LLU),
-	QU(11580681977404383968LLU), QU(14205530317404088650LLU),
-	QU( 5997789011854923157LLU), QU(13659151593432238041LLU),
-	QU(11664332114338865086LLU), QU( 7490351383220929386LLU),
-	QU( 7189290499881530378LLU), QU(15039262734271020220LLU),
-	QU( 2057217285976980055LLU), QU(  555570804905355739LLU),
-	QU(11235311968348555110LLU), QU(13824557146269603217LLU),
-	QU(16906788840653099693LLU), QU( 7222878245455661677LLU),
-	QU( 5245139444332423756LLU), QU( 4723748462805674292LLU),
-	QU(12216509815698568612LLU), QU(17402362976648951187LLU),
-	QU(17389614836810366768LLU), QU( 4880936484146667711LLU),
-	QU( 9085007839292639880LLU), QU(13837353458498535449LLU),
-	QU(11914419854360366677LLU), QU(16595890135313864103LLU),
-	QU( 6313969847197627222LLU), QU(18296909792163910431LLU),
-	QU(10041780113382084042LLU), QU( 2499478551172884794LLU),
-	QU(11057894246241189489LLU), QU( 9742243032389068555LLU),
-	QU(12838934582673196228LLU), QU(13437023235248490367LLU),
-	QU(13372420669446163240LLU), QU( 6752564244716909224LLU),
-	QU( 7157333073400313737LLU), QU(12230281516370654308LLU),
-	QU( 1182884552219419117LLU), QU( 2955125381312499218LLU),
-	QU(10308827097079443249LLU), QU( 1337648572986534958LLU),
-	QU(16378788590020343939LLU), QU(  108619126514420935LLU),
-	QU( 3990981009621629188LLU), QU( 5460953070230946410LLU),
-	QU( 9703328329366531883LLU), QU(13166631489188077236LLU),
-	QU( 1104768831213675170LLU), QU( 3447930458553877908LLU),
-	QU( 8067172487769945676LLU), QU( 5445802098190775347LLU),
-	QU( 3244840981648973873LLU), QU(17314668322981950060LLU),
-	QU( 5006812527827763807LLU), QU(18158695070225526260LLU),
-	QU( 2824536478852417853LLU), QU(13974775809127519886LLU),
-	QU( 9814362769074067392LLU), QU(17276205156374862128LLU),
-	QU(11361680725379306967LLU), QU( 3422581970382012542LLU),
-	QU(11003189603753241266LLU), QU(11194292945277862261LLU),
-	QU( 6839623313908521348LLU), QU(11935326462707324634LLU),
-	QU( 1611456788685878444LLU), QU(13112620989475558907LLU),
-	QU(  517659108904450427LLU), QU(13558114318574407624LLU),
-	QU(15699089742731633077LLU), QU( 4988979278862685458LLU),
-	QU( 8111373583056521297LLU), QU( 3891258746615399627LLU),
-	QU( 8137298251469718086LLU), QU(12748663295624701649LLU),
-	QU( 4389835683495292062LLU), QU( 5775217872128831729LLU),
-	QU( 9462091896405534927LLU), QU( 8498124108820263989LLU),
-	QU( 8059131278842839525LLU), QU(10503167994254090892LLU),
-	QU(11613153541070396656LLU), QU(18069248738504647790LLU),
-	QU(  570657419109768508LLU), QU( 3950574167771159665LLU),
-	QU( 5514655599604313077LLU), QU( 2908460854428484165LLU),
-	QU(10777722615935663114LLU), QU(12007363304839279486LLU),
-	QU( 9800646187569484767LLU), QU( 8795423564889864287LLU),
-	QU(14257396680131028419LLU), QU( 6405465117315096498LLU),
-	QU( 7939411072208774878LLU), QU(17577572378528990006LLU),
-	QU(14785873806715994850LLU), QU(16770572680854747390LLU),
-	QU(18127549474419396481LLU), QU(11637013449455757750LLU),
-	QU(14371851933996761086LLU), QU( 3601181063650110280LLU),
-	QU( 4126442845019316144LLU), QU(10198287239244320669LLU),
-	QU(18000169628555379659LLU), QU(18392482400739978269LLU),
-	QU( 6219919037686919957LLU), QU( 3610085377719446052LLU),
-	QU( 2513925039981776336LLU), QU(16679413537926716955LLU),
-	QU(12903302131714909434LLU), QU( 5581145789762985009LLU),
-	QU(12325955044293303233LLU), QU(17216111180742141204LLU),
-	QU( 6321919595276545740LLU), QU( 3507521147216174501LLU),
-	QU( 9659194593319481840LLU), QU(11473976005975358326LLU),
-	QU(14742730101435987026LLU), QU(  492845897709954780LLU),
-	QU(16976371186162599676LLU), QU(17712703422837648655LLU),
-	QU( 9881254778587061697LLU), QU( 8413223156302299551LLU),
-	QU( 1563841828254089168LLU), QU( 9996032758786671975LLU),
-	QU(  138877700583772667LLU), QU(13003043368574995989LLU),
-	QU( 4390573668650456587LLU), QU( 8610287390568126755LLU),
-	QU(15126904974266642199LLU), QU( 6703637238986057662LLU),
-	QU( 2873075592956810157LLU), QU( 6035080933946049418LLU),
-	QU(13382846581202353014LLU), QU( 7303971031814642463LLU),
-	QU(18418024405307444267LLU), QU( 5847096731675404647LLU),
-	QU( 4035880699639842500LLU), QU(11525348625112218478LLU),
-	QU( 3041162365459574102LLU), QU( 2604734487727986558LLU),
-	QU(15526341771636983145LLU), QU(14556052310697370254LLU),
-	QU(12997787077930808155LLU), QU( 9601806501755554499LLU),
-	QU(11349677952521423389LLU), QU(14956777807644899350LLU),
-	QU(16559736957742852721LLU), QU(12360828274778140726LLU),
-	QU( 6685373272009662513LLU), QU(16932258748055324130LLU),
-	QU(15918051131954158508LLU), QU( 1692312913140790144LLU),
-	QU(  546653826801637367LLU), QU( 5341587076045986652LLU),
-	QU(14975057236342585662LLU), QU(12374976357340622412LLU),
-	QU(10328833995181940552LLU), QU(12831807101710443149LLU),
-	QU(10548514914382545716LLU), QU( 2217806727199715993LLU),
-	QU(12627067369242845138LLU), QU( 4598965364035438158LLU),
-	QU(  150923352751318171LLU), QU(14274109544442257283LLU),
-	QU( 4696661475093863031LLU), QU( 1505764114384654516LLU),
-	QU(10699185831891495147LLU), QU( 2392353847713620519LLU),
-	QU( 3652870166711788383LLU), QU( 8640653276221911108LLU),
-	QU( 3894077592275889704LLU), QU( 4918592872135964845LLU),
-	QU(16379121273281400789LLU), QU(12058465483591683656LLU),
-	QU(11250106829302924945LLU), QU( 1147537556296983005LLU),
-	QU( 6376342756004613268LLU), QU(14967128191709280506LLU),
-	QU(18007449949790627628LLU), QU( 9497178279316537841LLU),
-	QU( 7920174844809394893LLU), QU(10037752595255719907LLU),
-	QU(15875342784985217697LLU), QU(15311615921712850696LLU),
-	QU( 9552902652110992950LLU), QU(14054979450099721140LLU),
-	QU( 5998709773566417349LLU), QU(18027910339276320187LLU),
-	QU( 8223099053868585554LLU), QU( 7842270354824999767LLU),
-	QU( 4896315688770080292LLU), QU(12969320296569787895LLU),
-	QU( 2674321489185759961LLU), QU( 4053615936864718439LLU),
-	QU(11349775270588617578LLU), QU( 4743019256284553975LLU),
-	QU( 5602100217469723769LLU), QU(14398995691411527813LLU),
-	QU( 7412170493796825470LLU), QU(  836262406131744846LLU),
-	QU( 8231086633845153022LLU), QU( 5161377920438552287LLU),
-	QU( 8828731196169924949LLU), QU(16211142246465502680LLU),
-	QU( 3307990879253687818LLU), QU( 5193405406899782022LLU),
-	QU( 8510842117467566693LLU), QU( 6070955181022405365LLU),
-	QU(14482950231361409799LLU), QU(12585159371331138077LLU),
-	QU( 3511537678933588148LLU), QU( 2041849474531116417LLU),
-	QU(10944936685095345792LLU), QU(18303116923079107729LLU),
-	QU( 2720566371239725320LLU), QU( 4958672473562397622LLU),
-	QU( 3032326668253243412LLU), QU(13689418691726908338LLU),
-	QU( 1895205511728843996LLU), QU( 8146303515271990527LLU),
-	QU(16507343500056113480LLU), QU(  473996939105902919LLU),
-	QU( 9897686885246881481LLU), QU(14606433762712790575LLU),
-	QU( 6732796251605566368LLU), QU( 1399778120855368916LLU),
-	QU(  935023885182833777LLU), QU(16066282816186753477LLU),
-	QU( 7291270991820612055LLU), QU(17530230393129853844LLU),
-	QU(10223493623477451366LLU), QU(15841725630495676683LLU),
-	QU(17379567246435515824LLU), QU( 8588251429375561971LLU),
-	QU(18339511210887206423LLU), QU(17349587430725976100LLU),
-	QU(12244876521394838088LLU), QU( 6382187714147161259LLU),
-	QU(12335807181848950831LLU), QU(16948885622305460665LLU),
-	QU(13755097796371520506LLU), QU(14806740373324947801LLU),
-	QU( 4828699633859287703LLU), QU( 8209879281452301604LLU),
-	QU(12435716669553736437LLU), QU(13970976859588452131LLU),
-	QU( 6233960842566773148LLU), QU(12507096267900505759LLU),
-	QU( 1198713114381279421LLU), QU(14989862731124149015LLU),
-	QU(15932189508707978949LLU), QU( 2526406641432708722LLU),
-	QU(   29187427817271982LLU), QU( 1499802773054556353LLU),
-	QU(10816638187021897173LLU), QU( 5436139270839738132LLU),
-	QU( 6659882287036010082LLU), QU( 2154048955317173697LLU),
-	QU(10887317019333757642LLU), QU(16281091802634424955LLU),
-	QU(10754549879915384901LLU), QU(10760611745769249815LLU),
-	QU( 2161505946972504002LLU), QU( 5243132808986265107LLU),
-	QU(10129852179873415416LLU), QU(  710339480008649081LLU),
-	QU( 7802129453068808528LLU), QU(17967213567178907213LLU),
-	QU(15730859124668605599LLU), QU(13058356168962376502LLU),
-	QU( 3701224985413645909LLU), QU(14464065869149109264LLU),
-	QU( 9959272418844311646LLU), QU(10157426099515958752LLU),
-	QU(14013736814538268528LLU), QU(17797456992065653951LLU),
-	QU(17418878140257344806LLU), QU(15457429073540561521LLU),
-	QU( 2184426881360949378LLU), QU( 2062193041154712416LLU),
-	QU( 8553463347406931661LLU), QU( 4913057625202871854LLU),
-	QU( 2668943682126618425LLU), QU(17064444737891172288LLU),
-	QU( 4997115903913298637LLU), QU(12019402608892327416LLU),
-	QU(17603584559765897352LLU), QU(11367529582073647975LLU),
-	QU( 8211476043518436050LLU), QU( 8676849804070323674LLU),
-	QU(18431829230394475730LLU), QU(10490177861361247904LLU),
-	QU( 9508720602025651349LLU), QU( 7409627448555722700LLU),
-	QU( 5804047018862729008LLU), QU(11943858176893142594LLU),
-	QU(11908095418933847092LLU), QU( 5415449345715887652LLU),
-	QU( 1554022699166156407LLU), QU( 9073322106406017161LLU),
-	QU( 7080630967969047082LLU), QU(18049736940860732943LLU),
-	QU(12748714242594196794LLU), QU( 1226992415735156741LLU),
-	QU(17900981019609531193LLU), QU(11720739744008710999LLU),
-	QU( 3006400683394775434LLU), QU(11347974011751996028LLU),
-	QU( 3316999628257954608LLU), QU( 8384484563557639101LLU),
-	QU(18117794685961729767LLU), QU( 1900145025596618194LLU),
-	QU(17459527840632892676LLU), QU( 5634784101865710994LLU),
-	QU( 7918619300292897158LLU), QU( 3146577625026301350LLU),
-	QU( 9955212856499068767LLU), QU( 1873995843681746975LLU),
-	QU( 1561487759967972194LLU), QU( 8322718804375878474LLU),
-	QU(11300284215327028366LLU), QU( 4667391032508998982LLU),
-	QU( 9820104494306625580LLU), QU(17922397968599970610LLU),
-	QU( 1784690461886786712LLU), QU(14940365084341346821LLU),
-	QU( 5348719575594186181LLU), QU(10720419084507855261LLU),
-	QU(14210394354145143274LLU), QU( 2426468692164000131LLU),
-	QU(16271062114607059202LLU), QU(14851904092357070247LLU),
-	QU( 6524493015693121897LLU), QU( 9825473835127138531LLU),
-	QU(14222500616268569578LLU), QU(15521484052007487468LLU),
-	QU(14462579404124614699LLU), QU(11012375590820665520LLU),
-	QU(11625327350536084927LLU), QU(14452017765243785417LLU),
-	QU( 9989342263518766305LLU), QU( 3640105471101803790LLU),
-	QU( 4749866455897513242LLU), QU(13963064946736312044LLU),
-	QU(10007416591973223791LLU), QU(18314132234717431115LLU),
-	QU( 3286596588617483450LLU), QU( 7726163455370818765LLU),
-	QU( 7575454721115379328LLU), QU( 5308331576437663422LLU),
-	QU(18288821894903530934LLU), QU( 8028405805410554106LLU),
-	QU(15744019832103296628LLU), QU(  149765559630932100LLU),
-	QU( 6137705557200071977LLU), QU(14513416315434803615LLU),
-	QU(11665702820128984473LLU), QU(  218926670505601386LLU),
-	QU( 6868675028717769519LLU), QU(15282016569441512302LLU),
-	QU( 5707000497782960236LLU), QU( 6671120586555079567LLU),
-	QU( 2194098052618985448LLU), QU(16849577895477330978LLU),
-	QU(12957148471017466283LLU), QU( 1997805535404859393LLU),
-	QU( 1180721060263860490LLU), QU(13206391310193756958LLU),
-	QU(12980208674461861797LLU), QU( 3825967775058875366LLU),
-	QU(17543433670782042631LLU), QU( 1518339070120322730LLU),
-	QU(16344584340890991669LLU), QU( 2611327165318529819LLU),
-	QU(11265022723283422529LLU), QU( 4001552800373196817LLU),
-	QU(14509595890079346161LLU), QU( 3528717165416234562LLU),
-	QU(18153222571501914072LLU), QU( 9387182977209744425LLU),
-	QU(10064342315985580021LLU), QU(11373678413215253977LLU),
-	QU( 2308457853228798099LLU), QU( 9729042942839545302LLU),
-	QU( 7833785471140127746LLU), QU( 6351049900319844436LLU),
-	QU(14454610627133496067LLU), QU(12533175683634819111LLU),
-	QU(15570163926716513029LLU), QU(13356980519185762498LLU)
+	KQU( 2100341266307895239), KQU( 8344256300489757943),
+	KQU(15687933285484243894), KQU( 8268620370277076319),
+	KQU(12371852309826545459), KQU( 8800491541730110238),
+	KQU(18113268950100835773), KQU( 2886823658884438119),
+	KQU( 3293667307248180724), KQU( 9307928143300172731),
+	KQU( 7688082017574293629), KQU(  900986224735166665),
+	KQU( 9977972710722265039), KQU( 6008205004994830552),
+	KQU(  546909104521689292), KQU( 7428471521869107594),
+	KQU(14777563419314721179), KQU(16116143076567350053),
+	KQU( 5322685342003142329), KQU( 4200427048445863473),
+	KQU( 4693092150132559146), KQU(13671425863759338582),
+	KQU( 6747117460737639916), KQU( 4732666080236551150),
+	KQU( 5912839950611941263), KQU( 3903717554504704909),
+	KQU( 2615667650256786818), KQU(10844129913887006352),
+	KQU(13786467861810997820), KQU(14267853002994021570),
+	KQU(13767807302847237439), KQU(16407963253707224617),
+	KQU( 4802498363698583497), KQU( 2523802839317209764),
+	KQU( 3822579397797475589), KQU( 8950320572212130610),
+	KQU( 3745623504978342534), KQU(16092609066068482806),
+	KQU( 9817016950274642398), KQU(10591660660323829098),
+	KQU(11751606650792815920), KQU( 5122873818577122211),
+	KQU(17209553764913936624), KQU( 6249057709284380343),
+	KQU(15088791264695071830), KQU(15344673071709851930),
+	KQU( 4345751415293646084), KQU( 2542865750703067928),
+	KQU(13520525127852368784), KQU(18294188662880997241),
+	KQU( 3871781938044881523), KQU( 2873487268122812184),
+	KQU(15099676759482679005), KQU(15442599127239350490),
+	KQU( 6311893274367710888), KQU( 3286118760484672933),
+	KQU( 4146067961333542189), KQU(13303942567897208770),
+	KQU( 8196013722255630418), KQU( 4437815439340979989),
+	KQU(15433791533450605135), KQU( 4254828956815687049),
+	KQU( 1310903207708286015), KQU(10529182764462398549),
+	KQU(14900231311660638810), KQU( 9727017277104609793),
+	KQU( 1821308310948199033), KQU(11628861435066772084),
+	KQU( 9469019138491546924), KQU( 3145812670532604988),
+	KQU( 9938468915045491919), KQU( 1562447430672662142),
+	KQU(13963995266697989134), KQU( 3356884357625028695),
+	KQU( 4499850304584309747), KQU( 8456825817023658122),
+	KQU(10859039922814285279), KQU( 8099512337972526555),
+	KQU(  348006375109672149), KQU(11919893998241688603),
+	KQU( 1104199577402948826), KQU(16689191854356060289),
+	KQU(10992552041730168078), KQU( 7243733172705465836),
+	KQU( 5668075606180319560), KQU(18182847037333286970),
+	KQU( 4290215357664631322), KQU( 4061414220791828613),
+	KQU(13006291061652989604), KQU( 7140491178917128798),
+	KQU(12703446217663283481), KQU( 5500220597564558267),
+	KQU(10330551509971296358), KQU(15958554768648714492),
+	KQU( 5174555954515360045), KQU( 1731318837687577735),
+	KQU( 3557700801048354857), KQU(13764012341928616198),
+	KQU(13115166194379119043), KQU( 7989321021560255519),
+	KQU( 2103584280905877040), KQU( 9230788662155228488),
+	KQU(16396629323325547654), KQU(  657926409811318051),
+	KQU(15046700264391400727), KQU( 5120132858771880830),
+	KQU( 7934160097989028561), KQU( 6963121488531976245),
+	KQU(17412329602621742089), KQU(15144843053931774092),
+	KQU(17204176651763054532), KQU(13166595387554065870),
+	KQU( 8590377810513960213), KQU( 5834365135373991938),
+	KQU( 7640913007182226243), KQU( 3479394703859418425),
+	KQU(16402784452644521040), KQU( 4993979809687083980),
+	KQU(13254522168097688865), KQU(15643659095244365219),
+	KQU( 5881437660538424982), KQU(11174892200618987379),
+	KQU(  254409966159711077), KQU(17158413043140549909),
+	KQU( 3638048789290376272), KQU( 1376816930299489190),
+	KQU( 4622462095217761923), KQU(15086407973010263515),
+	KQU(13253971772784692238), KQU( 5270549043541649236),
+	KQU(11182714186805411604), KQU(12283846437495577140),
+	KQU( 5297647149908953219), KQU(10047451738316836654),
+	KQU( 4938228100367874746), KQU(12328523025304077923),
+	KQU( 3601049438595312361), KQU( 9313624118352733770),
+	KQU(13322966086117661798), KQU(16660005705644029394),
+	KQU(11337677526988872373), KQU(13869299102574417795),
+	KQU(15642043183045645437), KQU( 3021755569085880019),
+	KQU( 4979741767761188161), KQU(13679979092079279587),
+	KQU( 3344685842861071743), KQU(13947960059899588104),
+	KQU(  305806934293368007), KQU( 5749173929201650029),
+	KQU(11123724852118844098), KQU(15128987688788879802),
+	KQU(15251651211024665009), KQU( 7689925933816577776),
+	KQU(16732804392695859449), KQU(17087345401014078468),
+	KQU(14315108589159048871), KQU( 4820700266619778917),
+	KQU(16709637539357958441), KQU( 4936227875177351374),
+	KQU( 2137907697912987247), KQU(11628565601408395420),
+	KQU( 2333250549241556786), KQU( 5711200379577778637),
+	KQU( 5170680131529031729), KQU(12620392043061335164),
+	KQU(   95363390101096078), KQU( 5487981914081709462),
+	KQU( 1763109823981838620), KQU( 3395861271473224396),
+	KQU( 1300496844282213595), KQU( 6894316212820232902),
+	KQU(10673859651135576674), KQU( 5911839658857903252),
+	KQU(17407110743387299102), KQU( 8257427154623140385),
+	KQU(11389003026741800267), KQU( 4070043211095013717),
+	KQU(11663806997145259025), KQU(15265598950648798210),
+	KQU(  630585789434030934), KQU( 3524446529213587334),
+	KQU( 7186424168495184211), KQU(10806585451386379021),
+	KQU(11120017753500499273), KQU( 1586837651387701301),
+	KQU(17530454400954415544), KQU( 9991670045077880430),
+	KQU( 7550997268990730180), KQU( 8640249196597379304),
+	KQU( 3522203892786893823), KQU(10401116549878854788),
+	KQU(13690285544733124852), KQU( 8295785675455774586),
+	KQU(15535716172155117603), KQU( 3112108583723722511),
+	KQU(17633179955339271113), KQU(18154208056063759375),
+	KQU( 1866409236285815666), KQU(13326075895396412882),
+	KQU( 8756261842948020025), KQU( 6281852999868439131),
+	KQU(15087653361275292858), KQU(10333923911152949397),
+	KQU( 5265567645757408500), KQU(12728041843210352184),
+	KQU( 6347959327507828759), KQU(  154112802625564758),
+	KQU(18235228308679780218), KQU( 3253805274673352418),
+	KQU( 4849171610689031197), KQU(17948529398340432518),
+	KQU(13803510475637409167), KQU(13506570190409883095),
+	KQU(15870801273282960805), KQU( 8451286481299170773),
+	KQU( 9562190620034457541), KQU( 8518905387449138364),
+	KQU(12681306401363385655), KQU( 3788073690559762558),
+	KQU( 5256820289573487769), KQU( 2752021372314875467),
+	KQU( 6354035166862520716), KQU( 4328956378309739069),
+	KQU(  449087441228269600), KQU( 5533508742653090868),
+	KQU( 1260389420404746988), KQU(18175394473289055097),
+	KQU( 1535467109660399420), KQU( 8818894282874061442),
+	KQU(12140873243824811213), KQU(15031386653823014946),
+	KQU( 1286028221456149232), KQU( 6329608889367858784),
+	KQU( 9419654354945132725), KQU( 6094576547061672379),
+	KQU(17706217251847450255), KQU( 1733495073065878126),
+	KQU(16918923754607552663), KQU( 8881949849954945044),
+	KQU(12938977706896313891), KQU(14043628638299793407),
+	KQU(18393874581723718233), KQU( 6886318534846892044),
+	KQU(14577870878038334081), KQU(13541558383439414119),
+	KQU(13570472158807588273), KQU(18300760537910283361),
+	KQU(  818368572800609205), KQU( 1417000585112573219),
+	KQU(12337533143867683655), KQU(12433180994702314480),
+	KQU(  778190005829189083), KQU(13667356216206524711),
+	KQU( 9866149895295225230), KQU(11043240490417111999),
+	KQU( 1123933826541378598), KQU( 6469631933605123610),
+	KQU(14508554074431980040), KQU(13918931242962026714),
+	KQU( 2870785929342348285), KQU(14786362626740736974),
+	KQU(13176680060902695786), KQU( 9591778613541679456),
+	KQU( 9097662885117436706), KQU(  749262234240924947),
+	KQU( 1944844067793307093), KQU( 4339214904577487742),
+	KQU( 8009584152961946551), KQU(16073159501225501777),
+	KQU( 3335870590499306217), KQU(17088312653151202847),
+	KQU( 3108893142681931848), KQU(16636841767202792021),
+	KQU(10423316431118400637), KQU( 8008357368674443506),
+	KQU(11340015231914677875), KQU(17687896501594936090),
+	KQU(15173627921763199958), KQU(  542569482243721959),
+	KQU(15071714982769812975), KQU( 4466624872151386956),
+	KQU( 1901780715602332461), KQU( 9822227742154351098),
+	KQU( 1479332892928648780), KQU( 6981611948382474400),
+	KQU( 7620824924456077376), KQU(14095973329429406782),
+	KQU( 7902744005696185404), KQU(15830577219375036920),
+	KQU(10287076667317764416), KQU(12334872764071724025),
+	KQU( 4419302088133544331), KQU(14455842851266090520),
+	KQU(12488077416504654222), KQU( 7953892017701886766),
+	KQU( 6331484925529519007), KQU( 4902145853785030022),
+	KQU(17010159216096443073), KQU(11945354668653886087),
+	KQU(15112022728645230829), KQU(17363484484522986742),
+	KQU( 4423497825896692887), KQU( 8155489510809067471),
+	KQU(  258966605622576285), KQU( 5462958075742020534),
+	KQU( 6763710214913276228), KQU( 2368935183451109054),
+	KQU(14209506165246453811), KQU( 2646257040978514881),
+	KQU( 3776001911922207672), KQU( 1419304601390147631),
+	KQU(14987366598022458284), KQU( 3977770701065815721),
+	KQU(  730820417451838898), KQU( 3982991703612885327),
+	KQU( 2803544519671388477), KQU(17067667221114424649),
+	KQU( 2922555119737867166), KQU( 1989477584121460932),
+	KQU(15020387605892337354), KQU( 9293277796427533547),
+	KQU(10722181424063557247), KQU(16704542332047511651),
+	KQU( 5008286236142089514), KQU(16174732308747382540),
+	KQU(17597019485798338402), KQU(13081745199110622093),
+	KQU( 8850305883842258115), KQU(12723629125624589005),
+	KQU( 8140566453402805978), KQU(15356684607680935061),
+	KQU(14222190387342648650), KQU(11134610460665975178),
+	KQU( 1259799058620984266), KQU(13281656268025610041),
+	KQU(  298262561068153992), KQU(12277871700239212922),
+	KQU(13911297774719779438), KQU(16556727962761474934),
+	KQU(17903010316654728010), KQU( 9682617699648434744),
+	KQU(14757681836838592850), KQU( 1327242446558524473),
+	KQU(11126645098780572792), KQU( 1883602329313221774),
+	KQU( 2543897783922776873), KQU(15029168513767772842),
+	KQU(12710270651039129878), KQU(16118202956069604504),
+	KQU(15010759372168680524), KQU( 2296827082251923948),
+	KQU(10793729742623518101), KQU(13829764151845413046),
+	KQU(17769301223184451213), KQU( 3118268169210783372),
+	KQU(17626204544105123127), KQU( 7416718488974352644),
+	KQU(10450751996212925994), KQU( 9352529519128770586),
+	KQU(  259347569641110140), KQU( 8048588892269692697),
+	KQU( 1774414152306494058), KQU(10669548347214355622),
+	KQU(13061992253816795081), KQU(18432677803063861659),
+	KQU( 8879191055593984333), KQU(12433753195199268041),
+	KQU(14919392415439730602), KQU( 6612848378595332963),
+	KQU( 6320986812036143628), KQU(10465592420226092859),
+	KQU( 4196009278962570808), KQU( 3747816564473572224),
+	KQU(17941203486133732898), KQU( 2350310037040505198),
+	KQU( 5811779859134370113), KQU(10492109599506195126),
+	KQU( 7699650690179541274), KQU( 1954338494306022961),
+	KQU(14095816969027231152), KQU( 5841346919964852061),
+	KQU(14945969510148214735), KQU( 3680200305887550992),
+	KQU( 6218047466131695792), KQU( 8242165745175775096),
+	KQU(11021371934053307357), KQU( 1265099502753169797),
+	KQU( 4644347436111321718), KQU( 3609296916782832859),
+	KQU( 8109807992218521571), KQU(18387884215648662020),
+	KQU(14656324896296392902), KQU(17386819091238216751),
+	KQU(17788300878582317152), KQU( 7919446259742399591),
+	KQU( 4466613134576358004), KQU(12928181023667938509),
+	KQU(13147446154454932030), KQU(16552129038252734620),
+	KQU( 8395299403738822450), KQU(11313817655275361164),
+	KQU(  434258809499511718), KQU( 2074882104954788676),
+	KQU( 7929892178759395518), KQU( 9006461629105745388),
+	KQU( 5176475650000323086), KQU(11128357033468341069),
+	KQU(12026158851559118955), KQU(14699716249471156500),
+	KQU(  448982497120206757), KQU( 4156475356685519900),
+	KQU( 6063816103417215727), KQU(10073289387954971479),
+	KQU( 8174466846138590962), KQU( 2675777452363449006),
+	KQU( 9090685420572474281), KQU( 6659652652765562060),
+	KQU(12923120304018106621), KQU(11117480560334526775),
+	KQU(  937910473424587511), KQU( 1838692113502346645),
+	KQU(11133914074648726180), KQU( 7922600945143884053),
+	KQU(13435287702700959550), KQU( 5287964921251123332),
+	KQU(11354875374575318947), KQU(17955724760748238133),
+	KQU(13728617396297106512), KQU( 4107449660118101255),
+	KQU( 1210269794886589623), KQU(11408687205733456282),
+	KQU( 4538354710392677887), KQU(13566803319341319267),
+	KQU(17870798107734050771), KQU( 3354318982568089135),
+	KQU( 9034450839405133651), KQU(13087431795753424314),
+	KQU(  950333102820688239), KQU( 1968360654535604116),
+	KQU(16840551645563314995), KQU( 8867501803892924995),
+	KQU(11395388644490626845), KQU( 1529815836300732204),
+	KQU(13330848522996608842), KQU( 1813432878817504265),
+	KQU( 2336867432693429560), KQU(15192805445973385902),
+	KQU( 2528593071076407877), KQU(  128459777936689248),
+	KQU( 9976345382867214866), KQU( 6208885766767996043),
+	KQU(14982349522273141706), KQU( 3099654362410737822),
+	KQU(13776700761947297661), KQU( 8806185470684925550),
+	KQU( 8151717890410585321), KQU(  640860591588072925),
+	KQU(14592096303937307465), KQU( 9056472419613564846),
+	KQU(14861544647742266352), KQU(12703771500398470216),
+	KQU( 3142372800384138465), KQU( 6201105606917248196),
+	KQU(18337516409359270184), KQU(15042268695665115339),
+	KQU(15188246541383283846), KQU(12800028693090114519),
+	KQU( 5992859621101493472), KQU(18278043971816803521),
+	KQU( 9002773075219424560), KQU( 7325707116943598353),
+	KQU( 7930571931248040822), KQU( 5645275869617023448),
+	KQU( 7266107455295958487), KQU( 4363664528273524411),
+	KQU(14313875763787479809), KQU(17059695613553486802),
+	KQU( 9247761425889940932), KQU(13704726459237593128),
+	KQU( 2701312427328909832), KQU(17235532008287243115),
+	KQU(14093147761491729538), KQU( 6247352273768386516),
+	KQU( 8268710048153268415), KQU( 7985295214477182083),
+	KQU(15624495190888896807), KQU( 3772753430045262788),
+	KQU( 9133991620474991698), KQU( 5665791943316256028),
+	KQU( 7551996832462193473), KQU(13163729206798953877),
+	KQU( 9263532074153846374), KQU( 1015460703698618353),
+	KQU(17929874696989519390), KQU(18257884721466153847),
+	KQU(16271867543011222991), KQU( 3905971519021791941),
+	KQU(16814488397137052085), KQU( 1321197685504621613),
+	KQU( 2870359191894002181), KQU(14317282970323395450),
+	KQU(13663920845511074366), KQU( 2052463995796539594),
+	KQU(14126345686431444337), KQU( 1727572121947022534),
+	KQU(17793552254485594241), KQU( 6738857418849205750),
+	KQU( 1282987123157442952), KQU(16655480021581159251),
+	KQU( 6784587032080183866), KQU(14726758805359965162),
+	KQU( 7577995933961987349), KQU(12539609320311114036),
+	KQU(10789773033385439494), KQU( 8517001497411158227),
+	KQU(10075543932136339710), KQU(14838152340938811081),
+	KQU( 9560840631794044194), KQU(17445736541454117475),
+	KQU(10633026464336393186), KQU(15705729708242246293),
+	KQU( 1117517596891411098), KQU( 4305657943415886942),
+	KQU( 4948856840533979263), KQU(16071681989041789593),
+	KQU(13723031429272486527), KQU( 7639567622306509462),
+	KQU(12670424537483090390), KQU( 9715223453097197134),
+	KQU( 5457173389992686394), KQU(  289857129276135145),
+	KQU(17048610270521972512), KQU(  692768013309835485),
+	KQU(14823232360546632057), KQU(18218002361317895936),
+	KQU( 3281724260212650204), KQU(16453957266549513795),
+	KQU( 8592711109774511881), KQU(  929825123473369579),
+	KQU(15966784769764367791), KQU( 9627344291450607588),
+	KQU(10849555504977813287), KQU( 9234566913936339275),
+	KQU( 6413807690366911210), KQU(10862389016184219267),
+	KQU(13842504799335374048), KQU( 1531994113376881174),
+	KQU( 2081314867544364459), KQU(16430628791616959932),
+	KQU( 8314714038654394368), KQU( 9155473892098431813),
+	KQU(12577843786670475704), KQU( 4399161106452401017),
+	KQU( 1668083091682623186), KQU( 1741383777203714216),
+	KQU( 2162597285417794374), KQU(15841980159165218736),
+	KQU( 1971354603551467079), KQU( 1206714764913205968),
+	KQU( 4790860439591272330), KQU(14699375615594055799),
+	KQU( 8374423871657449988), KQU(10950685736472937738),
+	KQU(  697344331343267176), KQU(10084998763118059810),
+	KQU(12897369539795983124), KQU(12351260292144383605),
+	KQU( 1268810970176811234), KQU( 7406287800414582768),
+	KQU(  516169557043807831), KQU( 5077568278710520380),
+	KQU( 3828791738309039304), KQU( 7721974069946943610),
+	KQU( 3534670260981096460), KQU( 4865792189600584891),
+	KQU(16892578493734337298), KQU( 9161499464278042590),
+	KQU(11976149624067055931), KQU(13219479887277343990),
+	KQU(14161556738111500680), KQU(14670715255011223056),
+	KQU( 4671205678403576558), KQU(12633022931454259781),
+	KQU(14821376219869187646), KQU(  751181776484317028),
+	KQU( 2192211308839047070), KQU(11787306362361245189),
+	KQU(10672375120744095707), KQU( 4601972328345244467),
+	KQU(15457217788831125879), KQU( 8464345256775460809),
+	KQU(10191938789487159478), KQU( 6184348739615197613),
+	KQU(11425436778806882100), KQU( 2739227089124319793),
+	KQU(  461464518456000551), KQU( 4689850170029177442),
+	KQU( 6120307814374078625), KQU(11153579230681708671),
+	KQU( 7891721473905347926), KQU(10281646937824872400),
+	KQU( 3026099648191332248), KQU( 8666750296953273818),
+	KQU(14978499698844363232), KQU(13303395102890132065),
+	KQU( 8182358205292864080), KQU(10560547713972971291),
+	KQU(11981635489418959093), KQU( 3134621354935288409),
+	KQU(11580681977404383968), KQU(14205530317404088650),
+	KQU( 5997789011854923157), KQU(13659151593432238041),
+	KQU(11664332114338865086), KQU( 7490351383220929386),
+	KQU( 7189290499881530378), KQU(15039262734271020220),
+	KQU( 2057217285976980055), KQU(  555570804905355739),
+	KQU(11235311968348555110), KQU(13824557146269603217),
+	KQU(16906788840653099693), KQU( 7222878245455661677),
+	KQU( 5245139444332423756), KQU( 4723748462805674292),
+	KQU(12216509815698568612), KQU(17402362976648951187),
+	KQU(17389614836810366768), KQU( 4880936484146667711),
+	KQU( 9085007839292639880), KQU(13837353458498535449),
+	KQU(11914419854360366677), KQU(16595890135313864103),
+	KQU( 6313969847197627222), KQU(18296909792163910431),
+	KQU(10041780113382084042), KQU( 2499478551172884794),
+	KQU(11057894246241189489), KQU( 9742243032389068555),
+	KQU(12838934582673196228), KQU(13437023235248490367),
+	KQU(13372420669446163240), KQU( 6752564244716909224),
+	KQU( 7157333073400313737), KQU(12230281516370654308),
+	KQU( 1182884552219419117), KQU( 2955125381312499218),
+	KQU(10308827097079443249), KQU( 1337648572986534958),
+	KQU(16378788590020343939), KQU(  108619126514420935),
+	KQU( 3990981009621629188), KQU( 5460953070230946410),
+	KQU( 9703328329366531883), KQU(13166631489188077236),
+	KQU( 1104768831213675170), KQU( 3447930458553877908),
+	KQU( 8067172487769945676), KQU( 5445802098190775347),
+	KQU( 3244840981648973873), KQU(17314668322981950060),
+	KQU( 5006812527827763807), KQU(18158695070225526260),
+	KQU( 2824536478852417853), KQU(13974775809127519886),
+	KQU( 9814362769074067392), KQU(17276205156374862128),
+	KQU(11361680725379306967), KQU( 3422581970382012542),
+	KQU(11003189603753241266), KQU(11194292945277862261),
+	KQU( 6839623313908521348), KQU(11935326462707324634),
+	KQU( 1611456788685878444), KQU(13112620989475558907),
+	KQU(  517659108904450427), KQU(13558114318574407624),
+	KQU(15699089742731633077), KQU( 4988979278862685458),
+	KQU( 8111373583056521297), KQU( 3891258746615399627),
+	KQU( 8137298251469718086), KQU(12748663295624701649),
+	KQU( 4389835683495292062), KQU( 5775217872128831729),
+	KQU( 9462091896405534927), KQU( 8498124108820263989),
+	KQU( 8059131278842839525), KQU(10503167994254090892),
+	KQU(11613153541070396656), KQU(18069248738504647790),
+	KQU(  570657419109768508), KQU( 3950574167771159665),
+	KQU( 5514655599604313077), KQU( 2908460854428484165),
+	KQU(10777722615935663114), KQU(12007363304839279486),
+	KQU( 9800646187569484767), KQU( 8795423564889864287),
+	KQU(14257396680131028419), KQU( 6405465117315096498),
+	KQU( 7939411072208774878), KQU(17577572378528990006),
+	KQU(14785873806715994850), KQU(16770572680854747390),
+	KQU(18127549474419396481), KQU(11637013449455757750),
+	KQU(14371851933996761086), KQU( 3601181063650110280),
+	KQU( 4126442845019316144), KQU(10198287239244320669),
+	KQU(18000169628555379659), KQU(18392482400739978269),
+	KQU( 6219919037686919957), KQU( 3610085377719446052),
+	KQU( 2513925039981776336), KQU(16679413537926716955),
+	KQU(12903302131714909434), KQU( 5581145789762985009),
+	KQU(12325955044293303233), KQU(17216111180742141204),
+	KQU( 6321919595276545740), KQU( 3507521147216174501),
+	KQU( 9659194593319481840), KQU(11473976005975358326),
+	KQU(14742730101435987026), KQU(  492845897709954780),
+	KQU(16976371186162599676), KQU(17712703422837648655),
+	KQU( 9881254778587061697), KQU( 8413223156302299551),
+	KQU( 1563841828254089168), KQU( 9996032758786671975),
+	KQU(  138877700583772667), KQU(13003043368574995989),
+	KQU( 4390573668650456587), KQU( 8610287390568126755),
+	KQU(15126904974266642199), KQU( 6703637238986057662),
+	KQU( 2873075592956810157), KQU( 6035080933946049418),
+	KQU(13382846581202353014), KQU( 7303971031814642463),
+	KQU(18418024405307444267), KQU( 5847096731675404647),
+	KQU( 4035880699639842500), KQU(11525348625112218478),
+	KQU( 3041162365459574102), KQU( 2604734487727986558),
+	KQU(15526341771636983145), KQU(14556052310697370254),
+	KQU(12997787077930808155), KQU( 9601806501755554499),
+	KQU(11349677952521423389), KQU(14956777807644899350),
+	KQU(16559736957742852721), KQU(12360828274778140726),
+	KQU( 6685373272009662513), KQU(16932258748055324130),
+	KQU(15918051131954158508), KQU( 1692312913140790144),
+	KQU(  546653826801637367), KQU( 5341587076045986652),
+	KQU(14975057236342585662), KQU(12374976357340622412),
+	KQU(10328833995181940552), KQU(12831807101710443149),
+	KQU(10548514914382545716), KQU( 2217806727199715993),
+	KQU(12627067369242845138), KQU( 4598965364035438158),
+	KQU(  150923352751318171), KQU(14274109544442257283),
+	KQU( 4696661475093863031), KQU( 1505764114384654516),
+	KQU(10699185831891495147), KQU( 2392353847713620519),
+	KQU( 3652870166711788383), KQU( 8640653276221911108),
+	KQU( 3894077592275889704), KQU( 4918592872135964845),
+	KQU(16379121273281400789), KQU(12058465483591683656),
+	KQU(11250106829302924945), KQU( 1147537556296983005),
+	KQU( 6376342756004613268), KQU(14967128191709280506),
+	KQU(18007449949790627628), KQU( 9497178279316537841),
+	KQU( 7920174844809394893), KQU(10037752595255719907),
+	KQU(15875342784985217697), KQU(15311615921712850696),
+	KQU( 9552902652110992950), KQU(14054979450099721140),
+	KQU( 5998709773566417349), KQU(18027910339276320187),
+	KQU( 8223099053868585554), KQU( 7842270354824999767),
+	KQU( 4896315688770080292), KQU(12969320296569787895),
+	KQU( 2674321489185759961), KQU( 4053615936864718439),
+	KQU(11349775270588617578), KQU( 4743019256284553975),
+	KQU( 5602100217469723769), KQU(14398995691411527813),
+	KQU( 7412170493796825470), KQU(  836262406131744846),
+	KQU( 8231086633845153022), KQU( 5161377920438552287),
+	KQU( 8828731196169924949), KQU(16211142246465502680),
+	KQU( 3307990879253687818), KQU( 5193405406899782022),
+	KQU( 8510842117467566693), KQU( 6070955181022405365),
+	KQU(14482950231361409799), KQU(12585159371331138077),
+	KQU( 3511537678933588148), KQU( 2041849474531116417),
+	KQU(10944936685095345792), KQU(18303116923079107729),
+	KQU( 2720566371239725320), KQU( 4958672473562397622),
+	KQU( 3032326668253243412), KQU(13689418691726908338),
+	KQU( 1895205511728843996), KQU( 8146303515271990527),
+	KQU(16507343500056113480), KQU(  473996939105902919),
+	KQU( 9897686885246881481), KQU(14606433762712790575),
+	KQU( 6732796251605566368), KQU( 1399778120855368916),
+	KQU(  935023885182833777), KQU(16066282816186753477),
+	KQU( 7291270991820612055), KQU(17530230393129853844),
+	KQU(10223493623477451366), KQU(15841725630495676683),
+	KQU(17379567246435515824), KQU( 8588251429375561971),
+	KQU(18339511210887206423), KQU(17349587430725976100),
+	KQU(12244876521394838088), KQU( 6382187714147161259),
+	KQU(12335807181848950831), KQU(16948885622305460665),
+	KQU(13755097796371520506), KQU(14806740373324947801),
+	KQU( 4828699633859287703), KQU( 8209879281452301604),
+	KQU(12435716669553736437), KQU(13970976859588452131),
+	KQU( 6233960842566773148), KQU(12507096267900505759),
+	KQU( 1198713114381279421), KQU(14989862731124149015),
+	KQU(15932189508707978949), KQU( 2526406641432708722),
+	KQU(   29187427817271982), KQU( 1499802773054556353),
+	KQU(10816638187021897173), KQU( 5436139270839738132),
+	KQU( 6659882287036010082), KQU( 2154048955317173697),
+	KQU(10887317019333757642), KQU(16281091802634424955),
+	KQU(10754549879915384901), KQU(10760611745769249815),
+	KQU( 2161505946972504002), KQU( 5243132808986265107),
+	KQU(10129852179873415416), KQU(  710339480008649081),
+	KQU( 7802129453068808528), KQU(17967213567178907213),
+	KQU(15730859124668605599), KQU(13058356168962376502),
+	KQU( 3701224985413645909), KQU(14464065869149109264),
+	KQU( 9959272418844311646), KQU(10157426099515958752),
+	KQU(14013736814538268528), KQU(17797456992065653951),
+	KQU(17418878140257344806), KQU(15457429073540561521),
+	KQU( 2184426881360949378), KQU( 2062193041154712416),
+	KQU( 8553463347406931661), KQU( 4913057625202871854),
+	KQU( 2668943682126618425), KQU(17064444737891172288),
+	KQU( 4997115903913298637), KQU(12019402608892327416),
+	KQU(17603584559765897352), KQU(11367529582073647975),
+	KQU( 8211476043518436050), KQU( 8676849804070323674),
+	KQU(18431829230394475730), KQU(10490177861361247904),
+	KQU( 9508720602025651349), KQU( 7409627448555722700),
+	KQU( 5804047018862729008), KQU(11943858176893142594),
+	KQU(11908095418933847092), KQU( 5415449345715887652),
+	KQU( 1554022699166156407), KQU( 9073322106406017161),
+	KQU( 7080630967969047082), KQU(18049736940860732943),
+	KQU(12748714242594196794), KQU( 1226992415735156741),
+	KQU(17900981019609531193), KQU(11720739744008710999),
+	KQU( 3006400683394775434), KQU(11347974011751996028),
+	KQU( 3316999628257954608), KQU( 8384484563557639101),
+	KQU(18117794685961729767), KQU( 1900145025596618194),
+	KQU(17459527840632892676), KQU( 5634784101865710994),
+	KQU( 7918619300292897158), KQU( 3146577625026301350),
+	KQU( 9955212856499068767), KQU( 1873995843681746975),
+	KQU( 1561487759967972194), KQU( 8322718804375878474),
+	KQU(11300284215327028366), KQU( 4667391032508998982),
+	KQU( 9820104494306625580), KQU(17922397968599970610),
+	KQU( 1784690461886786712), KQU(14940365084341346821),
+	KQU( 5348719575594186181), KQU(10720419084507855261),
+	KQU(14210394354145143274), KQU( 2426468692164000131),
+	KQU(16271062114607059202), KQU(14851904092357070247),
+	KQU( 6524493015693121897), KQU( 9825473835127138531),
+	KQU(14222500616268569578), KQU(15521484052007487468),
+	KQU(14462579404124614699), KQU(11012375590820665520),
+	KQU(11625327350536084927), KQU(14452017765243785417),
+	KQU( 9989342263518766305), KQU( 3640105471101803790),
+	KQU( 4749866455897513242), KQU(13963064946736312044),
+	KQU(10007416591973223791), KQU(18314132234717431115),
+	KQU( 3286596588617483450), KQU( 7726163455370818765),
+	KQU( 7575454721115379328), KQU( 5308331576437663422),
+	KQU(18288821894903530934), KQU( 8028405805410554106),
+	KQU(15744019832103296628), KQU(  149765559630932100),
+	KQU( 6137705557200071977), KQU(14513416315434803615),
+	KQU(11665702820128984473), KQU(  218926670505601386),
+	KQU( 6868675028717769519), KQU(15282016569441512302),
+	KQU( 5707000497782960236), KQU( 6671120586555079567),
+	KQU( 2194098052618985448), KQU(16849577895477330978),
+	KQU(12957148471017466283), KQU( 1997805535404859393),
+	KQU( 1180721060263860490), KQU(13206391310193756958),
+	KQU(12980208674461861797), KQU( 3825967775058875366),
+	KQU(17543433670782042631), KQU( 1518339070120322730),
+	KQU(16344584340890991669), KQU( 2611327165318529819),
+	KQU(11265022723283422529), KQU( 4001552800373196817),
+	KQU(14509595890079346161), KQU( 3528717165416234562),
+	KQU(18153222571501914072), KQU( 9387182977209744425),
+	KQU(10064342315985580021), KQU(11373678413215253977),
+	KQU( 2308457853228798099), KQU( 9729042942839545302),
+	KQU( 7833785471140127746), KQU( 6351049900319844436),
+	KQU(14454610627133496067), KQU(12533175683634819111),
+	KQU(15570163926716513029), KQU(13356980519185762498)
 };
 
 TEST_BEGIN(test_gen_rand_32)
 {
 	uint32_t array32[BLOCK_SIZE] JEMALLOC_ATTR(aligned(16));
 	uint32_t array32_2[BLOCK_SIZE] JEMALLOC_ATTR(aligned(16));
@@ -1540,19 +1540,19 @@
 		if (i < COUNT_1) {
 			assert_u64_eq(array64[i], init_gen_rand_64_expected[i],
 			    "Output mismatch for i=%d", i);
 		}
 		r = gen_rand64(ctx);
 		assert_u64_eq(r, array64[i],
-		    "Mismatch at array64[%d]=%"PRIx64", gen=%"PRIx64, i,
+		    "Mismatch at array64[%d]=%"FMTx64", gen=%"FMTx64, i,
 		    array64[i], r);
 	}
 	for (i = 0; i < COUNT_2; i++) {
 		r = gen_rand64(ctx);
 		assert_u64_eq(r, array64_2[i],
-		    "Mismatch at array64_2[%d]=%"PRIx64" gen=%"PRIx64"", i,
+		    "Mismatch at array64_2[%d]=%"FMTx64" gen=%"FMTx64"", i,
 		    array64_2[i], r);
 	}
 	fini_gen_rand(ctx);
 }
 TEST_END
 
@@ -1577,19 +1577,19 @@
 		if (i < COUNT_1) {
 			assert_u64_eq(array64[i], init_by_array_64_expected[i],
 			    "Output mismatch for i=%d", i);
 		}
 		r = gen_rand64(ctx);
 		assert_u64_eq(r, array64[i],
-		    "Mismatch at array64[%d]=%"PRIx64" gen=%"PRIx64, i,
+		    "Mismatch at array64[%d]=%"FMTx64" gen=%"FMTx64, i,
 		    array64[i], r);
 	}
 	for (i = 0; i < COUNT_2; i++) {
 		r = gen_rand64(ctx);
 		assert_u64_eq(r, array64_2[i],
-		    "Mismatch at array64_2[%d]=%"PRIx64" gen=%"PRIx64, i,
+		    "Mismatch at array64_2[%d]=%"FMTx64" gen=%"FMTx64, i,
 		    array64_2[i], r);
 	}
 	fini_gen_rand(ctx);
 }
 TEST_END
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit: size_classes.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/stats.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/stats.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/stats.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/stats.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,116 +1,100 @@
 #include "test/jemalloc_test.h"
 
 TEST_BEGIN(test_stats_summary)
 {
 	size_t *cactive;
-	size_t sz, allocated, active, mapped;
+	size_t sz, allocated, active, resident, mapped;
 	int expected = config_stats ? 0 : ENOENT;
 
 	sz = sizeof(cactive);
 	assert_d_eq(mallctl("stats.cactive", &cactive, &sz, NULL, 0), expected,
 	    "Unexpected mallctl() result");
 
 	sz = sizeof(size_t);
 	assert_d_eq(mallctl("stats.allocated", &allocated, &sz, NULL, 0),
 	    expected, "Unexpected mallctl() result");
 	assert_d_eq(mallctl("stats.active", &active, &sz, NULL, 0), expected,
 	    "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.resident", &resident, &sz, NULL, 0),
+	    expected, "Unexpected mallctl() result");
 	assert_d_eq(mallctl("stats.mapped", &mapped, &sz, NULL, 0), expected,
 	    "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_zu_le(active, *cactive,
 		    "active should be no larger than cactive");
 		assert_zu_le(allocated, active,
 		    "allocated should be no larger than active");
-		assert_zu_le(active, mapped,
-		    "active should be no larger than mapped");
-	}
-}
-TEST_END
-
-TEST_BEGIN(test_stats_chunks)
-{
-	size_t current, high;
-	uint64_t total;
-	size_t sz;
-	int expected = config_stats ? 0 : ENOENT;
-
-	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.chunks.current", &current, &sz, NULL, 0),
-	    expected, "Unexpected mallctl() result");
-	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.chunks.total", &total, &sz, NULL, 0),
-	    expected, "Unexpected mallctl() result");
-	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.chunks.high", &high, &sz, NULL, 0), expected,
-	    "Unexpected mallctl() result");
-
-	if (config_stats) {
-		assert_zu_le(current, high,
-		    "current should be no larger than high");
-		assert_u64_le((uint64_t)high, total,
-		    "high should be no larger than total");
+		assert_zu_lt(active, resident,
+		    "active should be less than resident");
+		assert_zu_lt(active, mapped,
+		    "active should be less than mapped");
 	}
 }
 TEST_END
 
 TEST_BEGIN(test_stats_huge)
 {
 	void *p;
 	uint64_t epoch;
 	size_t allocated;
-	uint64_t nmalloc, ndalloc;
+	uint64_t nmalloc, ndalloc, nrequests;
 	size_t sz;
 	int expected = config_stats ? 0 : ENOENT;
 
-	p = mallocx(arena_maxclass+1, 0);
+	p = mallocx(large_maxclass+1, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
 	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
 	    "Unexpected mallctl() failure");
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.huge.allocated", &allocated, &sz, NULL, 0),
-	    expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.allocated", &allocated, &sz,
+	    NULL, 0), expected, "Unexpected mallctl() result");
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.huge.nmalloc", &nmalloc, &sz, NULL, 0),
-	    expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.huge.ndalloc", &ndalloc, &sz, NULL, 0),
-	    expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.nmalloc", &nmalloc, &sz, NULL,
+	    0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.ndalloc", &ndalloc, &sz, NULL,
+	    0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.nrequests", &nrequests, &sz,
+	    NULL, 0), expected, "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_zu_gt(allocated, 0,
 		    "allocated should be greater than zero");
 		assert_u64_ge(nmalloc, ndalloc,
 		    "nmalloc should be at least as large as ndalloc");
+		assert_u64_le(nmalloc, nrequests,
+		    "nmalloc should no larger than nrequests");
 	}
 
 	dallocx(p, 0);
 }
 TEST_END
 
 TEST_BEGIN(test_stats_arenas_summary)
 {
 	unsigned arena;
-	void *small, *large;
+	void *little, *large, *huge;
 	uint64_t epoch;
 	size_t sz;
 	int expected = config_stats ? 0 : ENOENT;
 	size_t mapped;
 	uint64_t npurge, nmadvise, purged;
 
 	arena = 0;
 	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
 	    0, "Unexpected mallctl() failure");
 
-	small = mallocx(SMALL_MAXCLASS, 0);
-	assert_ptr_not_null(small, "Unexpected mallocx() failure");
-	large = mallocx(arena_maxclass, 0);
+	little = mallocx(SMALL_MAXCLASS, 0);
+	assert_ptr_not_null(little, "Unexpected mallocx() failure");
+	large = mallocx(large_maxclass, 0);
 	assert_ptr_not_null(large, "Unexpected mallocx() failure");
+	huge = mallocx(chunksize, 0);
+	assert_ptr_not_null(huge, "Unexpected mallocx() failure");
 
 	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl() failure");
 
 	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
 	    "Unexpected mallctl() failure");
@@ -130,14 +114,15 @@
 		assert_u64_gt(npurge, 0,
 		    "At least one purge should have occurred");
 		assert_u64_le(nmadvise, purged,
 		    "nmadvise should be no greater than purged");
 	}
 
-	dallocx(small, 0);
+	dallocx(little, 0);
 	dallocx(large, 0);
+	dallocx(huge, 0);
 }
 TEST_END
 
 void *
 thd_start(void *arg)
 {
@@ -212,13 +197,13 @@
 	int expected = config_stats ? 0 : ENOENT;
 
 	arena = 0;
 	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
 	    0, "Unexpected mallctl() failure");
 
-	p = mallocx(arena_maxclass, 0);
+	p = mallocx(large_maxclass, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
 	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
 	    "Unexpected mallctl() failure");
 
 	sz = sizeof(size_t);
@@ -244,17 +229,57 @@
 	}
 
 	dallocx(p, 0);
 }
 TEST_END
 
+TEST_BEGIN(test_stats_arenas_huge)
+{
+	unsigned arena;
+	void *p;
+	size_t sz, allocated;
+	uint64_t epoch, nmalloc, ndalloc;
+	int expected = config_stats ? 0 : ENOENT;
+
+	arena = 0;
+	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
+	    0, "Unexpected mallctl() failure");
+
+	p = mallocx(chunksize, 0);
+	assert_ptr_not_null(p, "Unexpected mallocx() failure");
+
+	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
+	    "Unexpected mallctl() failure");
+
+	sz = sizeof(size_t);
+	assert_d_eq(mallctl("stats.arenas.0.huge.allocated", &allocated, &sz,
+	    NULL, 0), expected, "Unexpected mallctl() result");
+	sz = sizeof(uint64_t);
+	assert_d_eq(mallctl("stats.arenas.0.huge.nmalloc", &nmalloc, &sz,
+	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.ndalloc", &ndalloc, &sz,
+	    NULL, 0), expected, "Unexpected mallctl() result");
+
+	if (config_stats) {
+		assert_zu_gt(allocated, 0,
+		    "allocated should be greater than zero");
+		assert_zu_gt(nmalloc, 0,
+		    "nmalloc should be greater than zero");
+		assert_zu_ge(nmalloc, ndalloc,
+		    "nmalloc should be at least as large as ndalloc");
+	}
+
+	dallocx(p, 0);
+}
+TEST_END
+
 TEST_BEGIN(test_stats_arenas_bins)
 {
 	unsigned arena;
 	void *p;
-	size_t sz, allocated, curruns;
+	size_t sz, curruns, curregs;
 	uint64_t epoch, nmalloc, ndalloc, nrequests, nfills, nflushes;
 	uint64_t nruns, nreruns;
 	int expected = config_stats ? 0 : ENOENT;
 
 	arena = 0;
 	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
@@ -266,23 +291,24 @@
 	assert_d_eq(mallctl("thread.tcache.flush", NULL, NULL, NULL, 0),
 	    config_tcache ? 0 : ENOENT, "Unexpected mallctl() result");
 
 	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
 	    "Unexpected mallctl() failure");
 
-	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.allocated", &allocated, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
 	sz = sizeof(uint64_t);
 	assert_d_eq(mallctl("stats.arenas.0.bins.0.nmalloc", &nmalloc, &sz,
 	    NULL, 0), expected, "Unexpected mallctl() result");
 	assert_d_eq(mallctl("stats.arenas.0.bins.0.ndalloc", &ndalloc, &sz,
 	    NULL, 0), expected, "Unexpected mallctl() result");
 	assert_d_eq(mallctl("stats.arenas.0.bins.0.nrequests", &nrequests, &sz,
 	    NULL, 0), expected, "Unexpected mallctl() result");
+	sz = sizeof(size_t);
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.curregs", &curregs, &sz,
+	    NULL, 0), expected, "Unexpected mallctl() result");
 
+	sz = sizeof(uint64_t);
 	assert_d_eq(mallctl("stats.arenas.0.bins.0.nfills", &nfills, &sz,
 	    NULL, 0), config_tcache ? expected : ENOENT,
 	    "Unexpected mallctl() result");
 	assert_d_eq(mallctl("stats.arenas.0.bins.0.nflushes", &nflushes, &sz,
 	    NULL, 0), config_tcache ? expected : ENOENT,
 	    "Unexpected mallctl() result");
@@ -293,20 +319,20 @@
 	    NULL, 0), expected, "Unexpected mallctl() result");
 	sz = sizeof(size_t);
 	assert_d_eq(mallctl("stats.arenas.0.bins.0.curruns", &curruns, &sz,
 	    NULL, 0), expected, "Unexpected mallctl() result");
 
 	if (config_stats) {
-		assert_zu_gt(allocated, 0,
-		    "allocated should be greater than zero");
 		assert_u64_gt(nmalloc, 0,
 		    "nmalloc should be greater than zero");
 		assert_u64_ge(nmalloc, ndalloc,
 		    "nmalloc should be at least as large as ndalloc");
 		assert_u64_gt(nrequests, 0,
 		    "nrequests should be greater than zero");
+		assert_zu_gt(curregs, 0,
+		    "allocated should be greater than zero");
 		if (config_tcache) {
 			assert_u64_gt(nfills, 0,
 			    "At least one fill should have occurred");
 			assert_u64_gt(nflushes, 0,
 			    "At least one flush should have occurred");
 		}
@@ -329,13 +355,13 @@
 	int expected = config_stats ? 0 : ENOENT;
 
 	arena = 0;
 	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
 	    0, "Unexpected mallctl() failure");
 
-	p = mallocx(SMALL_MAXCLASS+1, 0);
+	p = mallocx(LARGE_MINCLASS, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
 	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
 	    "Unexpected mallctl() failure");
 
 	sz = sizeof(uint64_t);
@@ -361,20 +387,61 @@
 	}
 
 	dallocx(p, 0);
 }
 TEST_END
 
+TEST_BEGIN(test_stats_arenas_hchunks)
+{
+	unsigned arena;
+	void *p;
+	uint64_t epoch, nmalloc, ndalloc;
+	size_t curhchunks, sz;
+	int expected = config_stats ? 0 : ENOENT;
+
+	arena = 0;
+	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
+	    0, "Unexpected mallctl() failure");
+
+	p = mallocx(chunksize, 0);
+	assert_ptr_not_null(p, "Unexpected mallocx() failure");
+
+	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
+	    "Unexpected mallctl() failure");
+
+	sz = sizeof(uint64_t);
+	assert_d_eq(mallctl("stats.arenas.0.hchunks.0.nmalloc", &nmalloc, &sz,
+	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.hchunks.0.ndalloc", &ndalloc, &sz,
+	    NULL, 0), expected, "Unexpected mallctl() result");
+	sz = sizeof(size_t);
+	assert_d_eq(mallctl("stats.arenas.0.hchunks.0.curhchunks", &curhchunks,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+
+	if (config_stats) {
+		assert_u64_gt(nmalloc, 0,
+		    "nmalloc should be greater than zero");
+		assert_u64_ge(nmalloc, ndalloc,
+		    "nmalloc should be at least as large as ndalloc");
+		assert_u64_gt(curhchunks, 0,
+		    "At least one chunk should be currently allocated");
+	}
+
+	dallocx(p, 0);
+}
+TEST_END
+
 int
 main(void)
 {
 
 	return (test(
 	    test_stats_summary,
-	    test_stats_chunks,
 	    test_stats_huge,
 	    test_stats_arenas_summary,
 	    test_stats_arenas_small,
 	    test_stats_arenas_large,
+	    test_stats_arenas_huge,
 	    test_stats_arenas_bins,
-	    test_stats_arenas_lruns));
+	    test_stats_arenas_lruns,
+	    test_stats_arenas_hchunks));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/tsd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/tsd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/tsd.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/tsd.c	2016-05-06 15:11:36.000000000 +0800
@@ -3,43 +3,79 @@
 #define	THREAD_DATA 0x72b65c10
 
 typedef unsigned int data_t;
 
 static bool data_cleanup_executed;
 
+malloc_tsd_types(data_, data_t)
+malloc_tsd_protos(, data_, data_t)
+
 void
 data_cleanup(void *arg)
 {
 	data_t *data = (data_t *)arg;
 
-	assert_x_eq(*data, THREAD_DATA,
-	    "Argument passed into cleanup function should match tsd value");
+	if (!data_cleanup_executed) {
+		assert_x_eq(*data, THREAD_DATA,
+		    "Argument passed into cleanup function should match tsd "
+		    "value");
+	}
 	data_cleanup_executed = true;
+
+	/*
+	 * Allocate during cleanup for two rounds, in order to assure that
+	 * jemalloc's internal tsd reinitialization happens.
+	 */
+	switch (*data) {
+	case THREAD_DATA:
+		*data = 1;
+		data_tsd_set(data);
+		break;
+	case 1:
+		*data = 2;
+		data_tsd_set(data);
+		break;
+	case 2:
+		return;
+	default:
+		not_reached();
+	}
+
+	{
+		void *p = mallocx(1, 0);
+		assert_ptr_not_null(p, "Unexpeced mallocx() failure");
+		dallocx(p, 0);
+	}
 }
 
-malloc_tsd_protos(, data, data_t)
-malloc_tsd_externs(data, data_t)
+malloc_tsd_externs(data_, data_t)
 #define	DATA_INIT 0x12345678
-malloc_tsd_data(, data, data_t, DATA_INIT)
-malloc_tsd_funcs(, data, data_t, DATA_INIT, data_cleanup)
+malloc_tsd_data(, data_, data_t, DATA_INIT)
+malloc_tsd_funcs(, data_, data_t, DATA_INIT, data_cleanup)
 
 static void *
 thd_start(void *arg)
 {
 	data_t d = (data_t)(uintptr_t)arg;
+	void *p;
+
 	assert_x_eq(*data_tsd_get(), DATA_INIT,
 	    "Initial tsd get should return initialization value");
 
+	p = malloc(1);
+	assert_ptr_not_null(p, "Unexpected malloc() failure");
+
 	data_tsd_set(&d);
 	assert_x_eq(*data_tsd_get(), d,
 	    "After tsd set, tsd get should return value that was set");
 
 	d = 0;
 	assert_x_eq(*data_tsd_get(), (data_t)(uintptr_t)arg,
 	    "Resetting local data should have no effect on tsd");
 
+	free(p);
 	return (NULL);
 }
 
 TEST_BEGIN(test_tsd_main_thread)
 {
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/util.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/util.c	2016-05-06 15:11:36.000000000 +0800
@@ -49,69 +49,69 @@
 		const char *expected_remainder;
 		int base;
 		int expected_errno;
 		const char *expected_errno_name;
 		uintmax_t expected_x;
 	};
-#define	ERR(e)	e, #e
-#define	UMAX(x)	((uintmax_t)x##ULL)
+#define	ERR(e)		e, #e
+#define	KUMAX(x)	((uintmax_t)x##ULL)
 	struct test_s tests[] = {
 		{"0",		"0",	-1,	ERR(EINVAL),	UINTMAX_MAX},
 		{"0",		"0",	1,	ERR(EINVAL),	UINTMAX_MAX},
 		{"0",		"0",	37,	ERR(EINVAL),	UINTMAX_MAX},
 
 		{"",		"",	0,	ERR(EINVAL),	UINTMAX_MAX},
 		{"+",		"+",	0,	ERR(EINVAL),	UINTMAX_MAX},
 		{"++3",		"++3",	0,	ERR(EINVAL),	UINTMAX_MAX},
 		{"-",		"-",	0,	ERR(EINVAL),	UINTMAX_MAX},
 
-		{"42",		"",	0,	ERR(0),		UMAX(42)},
-		{"+42",		"",	0,	ERR(0),		UMAX(42)},
-		{"-42",		"",	0,	ERR(0),		UMAX(-42)},
-		{"042",		"",	0,	ERR(0),		UMAX(042)},
-		{"+042",	"",	0,	ERR(0),		UMAX(042)},
-		{"-042",	"",	0,	ERR(0),		UMAX(-042)},
-		{"0x42",	"",	0,	ERR(0),		UMAX(0x42)},
-		{"+0x42",	"",	0,	ERR(0),		UMAX(0x42)},
-		{"-0x42",	"",	0,	ERR(0),		UMAX(-0x42)},
-
-		{"0",		"",	0,	ERR(0),		UMAX(0)},
-		{"1",		"",	0,	ERR(0),		UMAX(1)},
-
-		{"42",		"",	0,	ERR(0),		UMAX(42)},
-		{" 42",		"",	0,	ERR(0),		UMAX(42)},
-		{"42 ",		" ",	0,	ERR(0),		UMAX(42)},
-		{"0x",		"x",	0,	ERR(0),		UMAX(0)},
-		{"42x",		"x",	0,	ERR(0),		UMAX(42)},
-
-		{"07",		"",	0,	ERR(0),		UMAX(7)},
-		{"010",		"",	0,	ERR(0),		UMAX(8)},
-		{"08",		"8",	0,	ERR(0),		UMAX(0)},
-		{"0_",		"_",	0,	ERR(0),		UMAX(0)},
-
-		{"0x",		"x",	0,	ERR(0),		UMAX(0)},
-		{"0X",		"X",	0,	ERR(0),		UMAX(0)},
-		{"0xg",		"xg",	0,	ERR(0),		UMAX(0)},
-		{"0XA",		"",	0,	ERR(0),		UMAX(10)},
-
-		{"010",		"",	10,	ERR(0),		UMAX(10)},
-		{"0x3",		"x3",	10,	ERR(0),		UMAX(0)},
-
-		{"12",		"2",	2,	ERR(0),		UMAX(1)},
-		{"78",		"8",	8,	ERR(0),		UMAX(7)},
-		{"9a",		"a",	10,	ERR(0),		UMAX(9)},
-		{"9A",		"A",	10,	ERR(0),		UMAX(9)},
-		{"fg",		"g",	16,	ERR(0),		UMAX(15)},
-		{"FG",		"G",	16,	ERR(0),		UMAX(15)},
-		{"0xfg",	"g",	16,	ERR(0),		UMAX(15)},
-		{"0XFG",	"G",	16,	ERR(0),		UMAX(15)},
-		{"z_",		"_",	36,	ERR(0),		UMAX(35)},
-		{"Z_",		"_",	36,	ERR(0),		UMAX(35)}
+		{"42",		"",	0,	ERR(0),		KUMAX(42)},
+		{"+42",		"",	0,	ERR(0),		KUMAX(42)},
+		{"-42",		"",	0,	ERR(0),		KUMAX(-42)},
+		{"042",		"",	0,	ERR(0),		KUMAX(042)},
+		{"+042",	"",	0,	ERR(0),		KUMAX(042)},
+		{"-042",	"",	0,	ERR(0),		KUMAX(-042)},
+		{"0x42",	"",	0,	ERR(0),		KUMAX(0x42)},
+		{"+0x42",	"",	0,	ERR(0),		KUMAX(0x42)},
+		{"-0x42",	"",	0,	ERR(0),		KUMAX(-0x42)},
+
+		{"0",		"",	0,	ERR(0),		KUMAX(0)},
+		{"1",		"",	0,	ERR(0),		KUMAX(1)},
+
+		{"42",		"",	0,	ERR(0),		KUMAX(42)},
+		{" 42",		"",	0,	ERR(0),		KUMAX(42)},
+		{"42 ",		" ",	0,	ERR(0),		KUMAX(42)},
+		{"0x",		"x",	0,	ERR(0),		KUMAX(0)},
+		{"42x",		"x",	0,	ERR(0),		KUMAX(42)},
+
+		{"07",		"",	0,	ERR(0),		KUMAX(7)},
+		{"010",		"",	0,	ERR(0),		KUMAX(8)},
+		{"08",		"8",	0,	ERR(0),		KUMAX(0)},
+		{"0_",		"_",	0,	ERR(0),		KUMAX(0)},
+
+		{"0x",		"x",	0,	ERR(0),		KUMAX(0)},
+		{"0X",		"X",	0,	ERR(0),		KUMAX(0)},
+		{"0xg",		"xg",	0,	ERR(0),		KUMAX(0)},
+		{"0XA",		"",	0,	ERR(0),		KUMAX(10)},
+
+		{"010",		"",	10,	ERR(0),		KUMAX(10)},
+		{"0x3",		"x3",	10,	ERR(0),		KUMAX(0)},
+
+		{"12",		"2",	2,	ERR(0),		KUMAX(1)},
+		{"78",		"8",	8,	ERR(0),		KUMAX(7)},
+		{"9a",		"a",	10,	ERR(0),		KUMAX(9)},
+		{"9A",		"A",	10,	ERR(0),		KUMAX(9)},
+		{"fg",		"g",	16,	ERR(0),		KUMAX(15)},
+		{"FG",		"G",	16,	ERR(0),		KUMAX(15)},
+		{"0xfg",	"g",	16,	ERR(0),		KUMAX(15)},
+		{"0XFG",	"G",	16,	ERR(0),		KUMAX(15)},
+		{"z_",		"_",	36,	ERR(0),		KUMAX(35)},
+		{"Z_",		"_",	36,	ERR(0),		KUMAX(35)}
 	};
 #undef ERR
-#undef UMAX
+#undef KUMAX
 	unsigned i;
 
 	for (i = 0; i < sizeof(tests)/sizeof(struct test_s); i++) {
 		struct test_s *test = &tests[i];
 		int err;
 		uintmax_t result;
@@ -138,14 +138,14 @@
 TEST_BEGIN(test_malloc_snprintf_truncated)
 {
 #define	BUFLEN	15
 	char buf[BUFLEN];
 	int result;
 	size_t len;
-#define TEST(expected_str_untruncated, fmt...) do {			\
-	result = malloc_snprintf(buf, len, fmt);			\
+#define TEST(expected_str_untruncated, ...) do {			\
+	result = malloc_snprintf(buf, len, __VA_ARGS__);		\
 	assert_d_eq(strncmp(buf, expected_str_untruncated, len-1), 0,	\
 	    "Unexpected string inequality (\"%s\" vs \"%s\")",		\
 	    buf, expected_str_untruncated);		\
 	assert_d_eq(result, strlen(expected_str_untruncated),		\
 	    "Unexpected result");					\
 } while (0)
@@ -170,14 +170,14 @@
 
 TEST_BEGIN(test_malloc_snprintf)
 {
 #define	BUFLEN	128
 	char buf[BUFLEN];
 	int result;
-#define	TEST(expected_str, fmt...) do {					\
-	result = malloc_snprintf(buf, sizeof(buf), fmt);		\
+#define	TEST(expected_str, ...) do {					\
+	result = malloc_snprintf(buf, sizeof(buf), __VA_ARGS__);	\
 	assert_str_eq(buf, expected_str, "Unexpected output");		\
 	assert_d_eq(result, strlen(expected_str), "Unexpected result");	\
 } while (0)
 
 	TEST("hello", "hello");
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/zero.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/zero.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/test/unit/zero.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/test/unit/zero.c	2016-05-06 15:11:36.000000000 +0800
@@ -52,21 +52,21 @@
 TEST_END
 
 TEST_BEGIN(test_zero_large)
 {
 
 	test_skip_if(!config_fill);
-	test_zero(SMALL_MAXCLASS+1, arena_maxclass);
+	test_zero(SMALL_MAXCLASS+1, large_maxclass);
 }
 TEST_END
 
 TEST_BEGIN(test_zero_huge)
 {
 
 	test_skip_if(!config_fill);
-	test_zero(arena_maxclass+1, chunksize*2);
+	test_zero(large_maxclass+1, chunksize*2);
 }
 TEST_END
 
 int
 main(void)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/VERSION /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/VERSION
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/VERSION	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/VERSION	2016-05-06 15:11:36.000000000 +0800
@@ -1 +1 @@
-3.6.0-0-g46c0af68bd248b04df75e4f92d5fb804c3d75340
+4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/example.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/example.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/example.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/example.c	2016-05-06 15:11:36.000000000 +0800
@@ -8,12 +8,21 @@
     if (buf[0] == 'h') {
         linenoiseAddCompletion(lc,"hello");
         linenoiseAddCompletion(lc,"hello there");
     }
 }
 
+char *hints(const char *buf, int *color, int *bold) {
+    if (!strcasecmp(buf,"hello")) {
+        *color = 35;
+        *bold = 0;
+        return " World";
+    }
+    return NULL;
+}
+
 int main(int argc, char **argv) {
     char *line;
     char *prgname = argv[0];
 
     /* Parse options, with --multiline we enable multi line editing. */
     while(argc > 1) {
@@ -31,12 +40,13 @@
         }
     }
 
     /* Set the completion callback. This will be called every time the
      * user uses the <tab> key. */
     linenoiseSetCompletionCallback(completion);
+    linenoiseSetHintsCallback(hints);
 
     /* Load history from file. The history file is just a plain text file
      * where entries are separated by newlines. */
     linenoiseHistoryLoad("history.txt"); /* Load the history at startup */
 
     /* Now this is the main loop of the typical linenoise-based application.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.c	2016-05-06 15:11:36.000000000 +0800
@@ -7,13 +7,13 @@
  *
  * Does a number of crazy assumptions that happen to be true in 99.9999% of
  * the 2010 UNIX computers around.
  *
  * ------------------------------------------------------------------------
  *
- * Copyright (c) 2010-2013, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2010-2016, Salvatore Sanfilippo <antirez at gmail dot com>
  * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
  *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -117,12 +117,14 @@
 #include "linenoise.h"
 
 #define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
 #define LINENOISE_MAX_LINE 4096
 static char *unsupported_term[] = {"dumb","cons25","emacs",NULL};
 static linenoiseCompletionCallback *completionCallback = NULL;
+static linenoiseHintsCallback *hintsCallback = NULL;
+static linenoiseFreeHintsCallback *freeHintsCallback = NULL;
 
 static struct termios orig_termios; /* In order to restore at exit.*/
 static int rawmode = 0; /* For atexit() function to check if restore is needed*/
 static int mlmode = 0;  /* Multi line mode. Default is single line. */
 static int atexit_registered = 0; /* Register atexit just 1 time. */
 static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
@@ -404,12 +406,24 @@
 
 /* Register a callback function to be called for tab-completion. */
 void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
     completionCallback = fn;
 }
 
+/* Register a hits function to be called to show hits to the user at the
+ * right of the prompt. */
+void linenoiseSetHintsCallback(linenoiseHintsCallback *fn) {
+    hintsCallback = fn;
+}
+
+/* Register a function to free the hints returned by the hints callback
+ * registered with linenoiseSetHintsCallback(). */
+void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *fn) {
+    freeHintsCallback = fn;
+}
+
 /* This function is used by the callback function registered by the user
  * in order to add completion options given the input string when the
  * user typed <tab>. See the example.c source code for a very easy to
  * understand example. */
 void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
     size_t len = strlen(str);
@@ -453,12 +467,36 @@
 }
 
 static void abFree(struct abuf *ab) {
     free(ab->b);
 }
 
+/* Helper of refreshSingleLine() and refreshMultiLine() to show hints
+ * to the right of the prompt. */
+void refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {
+    char seq[64];
+    if (hintsCallback && plen+l->len < l->cols) {
+        int color = -1, bold = 0;
+        char *hint = hintsCallback(l->buf,&color,&bold);
+        if (hint) {
+            int hintlen = strlen(hint);
+            int hintmaxlen = l->cols-(plen+l->len);
+            if (hintlen > hintmaxlen) hintlen = hintmaxlen;
+            if (bold == 1 && color == -1) color = 37;
+            if (color != -1 || bold != 0)
+                snprintf(seq,64,"\033[%d;%d;49m",bold,color);
+            abAppend(ab,seq,strlen(seq));
+            abAppend(ab,hint,hintlen);
+            if (color != -1 || bold != 0)
+                abAppend(ab,"\033[0m",4);
+            /* Call the function to free the hint returned. */
+            if (freeHintsCallback) freeHintsCallback(hint);
+        }
+    }
+}
+
 /* Single line low level line refresh.
  *
  * Rewrite the currently edited line accordingly to the buffer content,
  * cursor position, and number of columns of the terminal. */
 static void refreshSingleLine(struct linenoiseState *l) {
     char seq[64];
@@ -482,12 +520,14 @@
     /* Cursor to left edge */
     snprintf(seq,64,"\r");
     abAppend(&ab,seq,strlen(seq));
     /* Write the prompt and the current buffer content */
     abAppend(&ab,l->prompt,strlen(l->prompt));
     abAppend(&ab,buf,len);
+    /* Show hits if any. */
+    refreshShowHints(&ab,l,plen);
     /* Erase to right */
     snprintf(seq,64,"\x1b[0K");
     abAppend(&ab,seq,strlen(seq));
     /* Move cursor to original position. */
     snprintf(seq,64,"\r\x1b[%dC", (int)(pos+plen));
     abAppend(&ab,seq,strlen(seq));
@@ -535,12 +575,15 @@
     abAppend(&ab,seq,strlen(seq));
 
     /* Write the prompt and the current buffer content */
     abAppend(&ab,l->prompt,strlen(l->prompt));
     abAppend(&ab,l->buf,l->len);
 
+    /* Show hits if any. */
+    refreshShowHints(&ab,l,plen);
+
     /* If we are at the very end of the screen with our prompt, we need to
      * emit a newline and move the prompt to the first column. */
     if (l->pos &&
         l->pos == l->len &&
         (l->pos+plen) % l->cols == 0)
     {
@@ -595,13 +638,13 @@
     if (l->len < l->buflen) {
         if (l->len == l->pos) {
             l->buf[l->pos] = c;
             l->pos++;
             l->len++;
             l->buf[l->len] = '\0';
-            if ((!mlmode && l->plen+l->len < l->cols) /* || mlmode */) {
+            if ((!mlmode && l->plen+l->len < l->cols && !hintsCallback)) {
                 /* Avoid a full update of the line in the
                  * trivial case. */
                 if (write(l->ofd,&c,1) == -1) return -1;
             } else {
                 refreshLine(l);
             }
@@ -769,12 +812,20 @@
 
         switch(c) {
         case ENTER:    /* enter */
             history_len--;
             free(history[history_len]);
             if (mlmode) linenoiseEditMoveEnd(&l);
+            if (hintsCallback) {
+                /* Force a refresh without hints to leave the previous
+                 * line as the user typed it after a newline. */
+                linenoiseHintsCallback *hc = hintsCallback;
+                hintsCallback = NULL;
+                refreshLine(&l);
+                hintsCallback = hc;
+            }
             return (int)l.len;
         case CTRL_C:     /* ctrl-c */
             errno = EAGAIN;
             return -1;
         case BACKSPACE:   /* backspace */
         case 8:     /* ctrl-h */
@@ -931,40 +982,70 @@
     int count;
 
     if (buflen == 0) {
         errno = EINVAL;
         return -1;
     }
-    if (!isatty(STDIN_FILENO)) {
-        /* Not a tty: read from file / pipe. */
-        if (fgets(buf, buflen, stdin) == NULL) return -1;
-        count = strlen(buf);
-        if (count && buf[count-1] == '\n') {
-            count--;
-            buf[count] = '\0';
+
+    if (enableRawMode(STDIN_FILENO) == -1) return -1;
+    count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
+    disableRawMode(STDIN_FILENO);
+    printf("\n");
+    return count;
+}
+
+/* This function is called when linenoise() is called with the standard
+ * input file descriptor not attached to a TTY. So for example when the
+ * program using linenoise is called in pipe or with a file redirected
+ * to its standard input. In this case, we want to be able to return the
+ * line regardless of its length (by default we are limited to 4k). */
+static char *linenoiseNoTTY(void) {
+    char *line = NULL;
+    size_t len = 0, maxlen = 0;
+
+    while(1) {
+        if (len == maxlen) {
+            if (maxlen == 0) maxlen = 16;
+            maxlen *= 2;
+            char *oldval = line;
+            line = realloc(line,maxlen);
+            if (line == NULL) {
+                if (oldval) free(oldval);
+                return NULL;
+            }
+        }
+        int c = fgetc(stdin);
+        if (c == EOF || c == '\n') {
+            if (c == EOF && len == 0) {
+                free(line);
+                return NULL;
+            } else {
+                line[len] = '\0';
+                return line;
+            }
+        } else {
+            line[len] = c;
+            len++;
         }
-    } else {
-        /* Interactive editing. */
-        if (enableRawMode(STDIN_FILENO) == -1) return -1;
-        count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
-        disableRawMode(STDIN_FILENO);
-        printf("\n");
     }
-    return count;
 }
 
 /* The high level function that is the main API of the linenoise library.
  * This function checks if the terminal has basic capabilities, just checking
  * for a blacklist of stupid terminals, and later either calls the line
  * editing function or uses dummy fgets() so that you will be able to type
  * something even in the most desperate of the conditions. */
 char *linenoise(const char *prompt) {
     char buf[LINENOISE_MAX_LINE];
     int count;
 
-    if (isUnsupportedTerm()) {
+    if (!isatty(STDIN_FILENO)) {
+        /* Not a tty: read from file / pipe. In this mode we don't want any
+         * limit to the line size, so we call a function to handle that. */
+        return linenoiseNoTTY();
+    } else if (isUnsupportedTerm()) {
         size_t len;
 
         printf("%s",prompt);
         fflush(stdout);
         if (fgets(buf,LINENOISE_MAX_LINE,stdin) == NULL) return NULL;
         len = strlen(buf);
@@ -977,12 +1058,20 @@
         count = linenoiseRaw(buf,LINENOISE_MAX_LINE,prompt);
         if (count == -1) return NULL;
         return strdup(buf);
     }
 }
 
+/* This is just a wrapper the user may want to call in order to make sure
+ * the linenoise returned buffer is freed with the same allocator it was
+ * created with. Useful when the main program is using an alternative
+ * allocator. */
+void linenoiseFree(void *ptr) {
+    free(ptr);
+}
+
 /* ================================ History ================================= */
 
 /* Free the history, but does not reset it. Only used when we have to
  * exit() to avoid memory leaks are reported by valgrind & co. */
 static void freeHistory(void) {
     if (history) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,15 +1,17 @@
-/* linenoise.h -- guerrilla line editing library against the idea that a
- * line editing lib needs to be 20,000 lines of C code.
+/* linenoise.h -- VERSION 1.0
+ *
+ * Guerrilla line editing library against the idea that a line editing lib
+ * needs to be 20,000 lines of C code.
  *
  * See linenoise.c for more information.
  *
  * ------------------------------------------------------------------------
  *
- * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>
- * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ * Copyright (c) 2010-2014, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
  *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
  * met:
@@ -44,16 +46,21 @@
 typedef struct linenoiseCompletions {
   size_t len;
   char **cvec;
 } linenoiseCompletions;
 
 typedef void(linenoiseCompletionCallback)(const char *, linenoiseCompletions *);
+typedef char*(linenoiseHintsCallback)(const char *, int *color, int *bold);
+typedef void(linenoiseFreeHintsCallback)(void *);
 void linenoiseSetCompletionCallback(linenoiseCompletionCallback *);
+void linenoiseSetHintsCallback(linenoiseHintsCallback *);
+void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *);
 void linenoiseAddCompletion(linenoiseCompletions *, const char *);
 
 char *linenoise(const char *prompt);
+void linenoiseFree(void *ptr);
 int linenoiseHistoryAdd(const char *line);
 int linenoiseHistorySetMaxLen(int len);
 int linenoiseHistorySave(const char *filename);
 int linenoiseHistoryLoad(const char *filename);
 void linenoiseClearScreen(void);
 void linenoiseSetMultiLine(int ml);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/README.markdown /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/README.markdown
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/README.markdown	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/README.markdown	2016-05-06 15:11:36.000000000 +0800
@@ -3,12 +3,13 @@
 A minimal, zero-config, BSD licensed, readline replacement used in Redis,
 MongoDB, and Android.
 
 * Single and multi line editing mode with the usual key bindings implemented.
 * History handling.
 * Completion.
+* Hints (suggestions at the right of the prompt as you type).
 * About 1,100 lines of BSD license source code.
 * Only uses a subset of VT100 escapes (ANSI.SYS compatible).
 
 ## Can a line editing library be 20k lines of code?
 
 Line editing with some support for history is a really important feature for command line utilities. Instead of retyping almost the same stuff again and again it's just much better to hit the up arrow and edit on syntax errors, or in order to try a slightly different command. But apparently code dealing with terminals is some sort of Black Magic: readline is 30k lines of code, libedit 20k. Is it reasonable to link small utilities to huge libraries just to get a minimal support for line editing?
@@ -17,13 +18,13 @@
 
  * Large programs with configure scripts disabling line editing if readline is not present in the system, or not supporting it at all since readline is GPL licensed and libedit (the BSD clone) is not as known and available as readline is (Real world example of this problem: Tclsh).
  * Smaller programs not using a configure script not supporting line editing at all (A problem we had with Redis-cli for instance).
  
 The result is a pollution of binaries without line editing support.
 
-So I spent more or less two hours doing a reality check resulting in this little library: is it *really* needed for a line editing library to be 20k lines of code? Apparently not, it is possibe to get a very small, zero configuration, trivial to embed library, that solves the problem. Smaller programs will just include this, supporing line editing out of the box. Larger programs may use this little library or just checking with configure if readline/libedit is available and resorting to linenoise if not.
+So I spent more or less two hours doing a reality check resulting in this little library: is it *really* needed for a line editing library to be 20k lines of code? Apparently not, it is possibe to get a very small, zero configuration, trivial to embed library, that solves the problem. Smaller programs will just include this, supporing line editing out of the box. Larger programs may use this little library or just checking with configure if readline/libedit is available and resorting to Linenoise if not.
 
 ## Terminals, in 2010.
 
 Apparently almost every terminal you can happen to use today has some kind of support for basic VT100 escape sequences. So I tried to write a lib using just very basic VT100 features. The resulting library appears to work everywhere I tried to use it, and now can work even on ANSI.SYS compatible terminals, since no
 VT220 specific sequences are used anymore.
 
@@ -38,15 +39,186 @@
  * Mac OS X iTerm ($TERM = xterm)
  * Mac OS X default Terminal.app ($TERM = xterm)
  * OpenBSD 4.5 through an OSX Terminal.app ($TERM = screen)
  * IBM AIX 6.1
  * FreeBSD xterm ($TERM = xterm)
  * ANSI.SYS
+ * Emacs comint mode ($TERM = dumb)
 
 Please test it everywhere you can and report back!
 
 ## Let's push this forward!
 
-Patches should be provided in the respect of linenoise sensibility for small
+Patches should be provided in the respect of Linenoise sensibility for small
 easy to understand code.
 
 Send feedbacks to antirez at gmail
+
+# The API
+
+Linenoise is very easy to use, and reading the example shipped with the
+library should get you up to speed ASAP. Here is a list of API calls
+and how to use them.
+
+    char *linenoise(const char *prompt);
+
+This is the main Linenoise call: it shows the user a prompt with line editing
+and history capabilities. The prompt you specify is used as a prompt, that is,
+it will be printed to the left of the cursor. The library returns a buffer
+with the line composed by the user, or NULL on end of file or when there
+is an out of memory condition.
+
+When a tty is detected (the user is actually typing into a terminal session)
+the maximum editable line length is `LINENOISE_MAX_LINE`. When instead the
+standard input is not a tty, which happens every time you redirect a file
+to a program, or use it in an Unix pipeline, there are no limits to the
+length of the line that can be returned.
+
+The returned line should be freed with the `free()` standard system call.
+However sometimes it could happen that your program uses a different dynamic
+allocation library, so you may also used `linenoiseFree` to make sure the
+line is freed with the same allocator it was created.
+
+The canonical loop used by a program using Linenoise will be something like
+this:
+
+    while((line = linenoise("hello> ")) != NULL) {
+        printf("You wrote: %s\n", line);
+        linenoiseFree(line); /* Or just free(line) if you use libc malloc. */
+    }
+
+## Single line VS multi line editing
+
+By default, Linenoise uses single line editing, that is, a single row on the
+screen will be used, and as the user types more, the text will scroll towards
+left to make room. This works if your program is one where the user is
+unlikely to write a lot of text, otherwise multi line editing, where multiple
+screens rows are used, can be a lot more comfortable.
+
+In order to enable multi line editing use the following API call:
+
+    linenoiseSetMultiLine(1);
+
+You can disable it using `0` as argument.
+
+## History
+
+Linenoise supporst history, so that the user does not have to retype
+again and again the same things, but can use the down and up arrows in order
+to search and re-edit already inserted lines of text.
+
+The followings are the history API calls:
+
+    int linenoiseHistoryAdd(const char *line);
+    int linenoiseHistorySetMaxLen(int len);
+    int linenoiseHistorySave(const char *filename);
+    int linenoiseHistoryLoad(const char *filename);
+
+Use `linenoiseHistoryAdd` every time you want to add a new element
+to the top of the history (it will be the first the user will see when
+using the up arrow).
+
+Note that for history to work, you have to set a length for the history
+(which is zero by default, so history will be disabled if you don't set
+a proper one). This is accomplished using the `linenoiseHistorySetMaxLen`
+function.
+
+Linenoise has direct support for persisting the history into an history
+file. The functions `linenoiseHistorySave` and `linenoiseHistoryLoad` do
+just that. Both functions return -1 on error and 0 on success.
+
+## Completion
+
+Linenoise supports completion, which is the ability to complete the user
+input when she or he presses the `<TAB>` key.
+
+In order to use completion, you need to register a completion callback, which
+is called every time the user presses `<TAB>`. Your callback will return a
+list of items that are completions for the current string.
+
+The following is an example of registering a completion callback:
+
+    linenoiseSetCompletionCallback(completion);
+
+The completion must be a function returning `void` and getting as input
+a `const char` pointer, which is the line the user has typed so far, and
+a `linenoiseCompletions` object pointer, which is used as argument of
+`linenoiseAddCompletion` in order to add completions inside the callback.
+An example will make it more clear:
+
+    void completion(const char *buf, linenoiseCompletions *lc) {
+        if (buf[0] == 'h') {
+            linenoiseAddCompletion(lc,"hello");
+            linenoiseAddCompletion(lc,"hello there");
+        }
+    }
+
+Basically in your completion callback, you inspect the input, and return
+a list of items that are good completions by using `linenoiseAddCompletion`.
+
+If you want to test the completion feature, compile the example program
+with `make`, run it, type `h` and press `<TAB>`.
+
+## Hints
+
+Linenoise has a feature called *hints* which is very useful when you
+use Linenoise in order to implement a REPL (Read Eval Print Loop) for
+a program that accepts commands and arguments, but may also be useful in
+other conditions.
+
+The feature shows, on the right of the cursor, as the user types, hints that
+may be useful. The hints can be displayed using a different color compared
+to the color the user is typing, and can also be bold.
+
+For example as the user starts to type `"git remote add"`, with hints it's
+possible to show on the right of the prompt a string `<name> <url>`.
+
+The feature works similarly to the history feature, using a callback.
+To register the callback we use:
+
+    linenoiseSetHintsCallback(hints);
+
+The callback itself is implemented like this:
+
+    char *hints(const char *buf, int *color, int *bold) {
+        if (!strcasecmp(buf,"git remote add")) {
+            *color = 35;
+            *bold = 0;
+            return " <name> <url>";
+        }
+        return NULL;
+    }
+
+The callback function returns the string that should be displayed or NULL
+if no hint is available for the text the user currently typed. The returned
+string will be trimmed as needed depending on the number of columns available
+on the screen.
+
+It is possible to return a string allocated in dynamic way, by also registering
+a function to deallocate the hint string once used:
+
+    void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *);
+
+The free hint callback will just receive the pointer and free the string
+as needed (depending on how the hits callback allocated it).
+
+As you can see in the example above, a `color` (in xterm color terminal codes)
+can be provided together with a `bold` attribute. If no color is set, the
+current terminal foreground color is used. If no bold attribute is set,
+non-bold text is printed.
+
+Color codes are:
+
+    red = 31
+    green = 32
+    yellow = 33
+    blue = 34
+    magenta = 35
+    cyan = 36
+    white = 37;
+
+## Screen handling
+
+Sometimes you may want to clear the screen as a result of something the
+user typed. You can do this by calling the following function:
+
+    void linenoiseClearScreen(void);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/fpconv.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/fpconv.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lapi.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lapi.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lauxlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lauxlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lbaselib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lbaselib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lcode.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lcode.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldblib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldblib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldebug.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldebug.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldo.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldo.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldump.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldump.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lfunc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lfunc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lgc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lgc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/liblua.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/liblua.a differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/linit.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/linit.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/liolib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/liolib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/llex.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/llex.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmathlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmathlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmem.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmem.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loadlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loadlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lobject.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lobject.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lopcodes.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lopcodes.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loslib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loslib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lparser.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lparser.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstate.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstate.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstring.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstring.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstrlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstrlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltable.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltable.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltablib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltablib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltm.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltm.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_bit.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_bit.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/luac.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/luac.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cjson.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cjson.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cmsgpack.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cmsgpack.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cmsgpack.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cmsgpack.c	2016-05-06 15:11:36.000000000 +0800
@@ -88,13 +88,12 @@
  * This is a simple implementation of string buffers. The only operation
  * supported is creating empty buffers and appending bytes to it.
  * The string buffer uses 2x preallocation on every realloc for O(N) append
  * behavior.  */
 
 typedef struct mp_buf {
-    lua_State *L;
     unsigned char *b;
     size_t len, free;
 } mp_buf;
 
 void *mp_realloc(lua_State *L, void *target, size_t osize,size_t nsize) {
     void *(*local_realloc) (void *, void *, size_t osize, size_t nsize) = NULL;
@@ -108,33 +107,32 @@
 mp_buf *mp_buf_new(lua_State *L) {
     mp_buf *buf = NULL;
 
     /* Old size = 0; new size = sizeof(*buf) */
     buf = (mp_buf*)mp_realloc(L, NULL, 0, sizeof(*buf));
 
-    buf->L = L;
     buf->b = NULL;
     buf->len = buf->free = 0;
     return buf;
 }
 
-void mp_buf_append(mp_buf *buf, const unsigned char *s, size_t len) {
+void mp_buf_append(lua_State *L, mp_buf *buf, const unsigned char *s, size_t len) {
     if (buf->free < len) {
-        size_t newlen = buf->len+len;
+        size_t newsize = (buf->len+len)*2;
 
-        buf->b = (unsigned char*)mp_realloc(buf->L, buf->b, buf->len, newlen*2);
-        buf->free = newlen;
+        buf->b = (unsigned char*)mp_realloc(L, buf->b, buf->len + buf->free, newsize);
+        buf->free = newsize - buf->len;
     }
     memcpy(buf->b+buf->len,s,len);
     buf->len += len;
     buf->free -= len;
 }
 
-void mp_buf_free(mp_buf *buf) {
-    mp_realloc(buf->L, buf->b, buf->len, 0); /* realloc to 0 = free */
-    mp_realloc(buf->L, buf, sizeof(*buf), 0);
+void mp_buf_free(lua_State *L, mp_buf *buf) {
+    mp_realloc(L, buf->b, buf->len + buf->free, 0); /* realloc to 0 = free */
+    mp_realloc(L, buf, sizeof(*buf), 0);
 }
 
 /* ---------------------------- String cursor ----------------------------------
  * This simple data structure is used for parsing. Basically you create a cursor
  * using a string pointer and a length, then it is possible to access the
  * current string position with cursor->p, check the remaining length
@@ -170,13 +168,13 @@
         return; \
     } \
 } while(0)
 
 /* ------------------------- Low level MP encoding -------------------------- */
 
-void mp_encode_bytes(mp_buf *buf, const unsigned char *s, size_t len) {
+void mp_encode_bytes(lua_State *L, mp_buf *buf, const unsigned char *s, size_t len) {
     unsigned char hdr[5];
     int hdrlen;
 
     if (len < 32) {
         hdr[0] = 0xa0 | (len&0xff); /* fix raw */
         hdrlen = 1;
@@ -194,36 +192,36 @@
         hdr[1] = (len&0xff000000)>>24;
         hdr[2] = (len&0xff0000)>>16;
         hdr[3] = (len&0xff00)>>8;
         hdr[4] = len&0xff;
         hdrlen = 5;
     }
-    mp_buf_append(buf,hdr,hdrlen);
-    mp_buf_append(buf,s,len);
+    mp_buf_append(L,buf,hdr,hdrlen);
+    mp_buf_append(L,buf,s,len);
 }
 
 /* we assume IEEE 754 internal format for single and double precision floats. */
-void mp_encode_double(mp_buf *buf, double d) {
+void mp_encode_double(lua_State *L, mp_buf *buf, double d) {
     unsigned char b[9];
     float f = d;
 
     assert(sizeof(f) == 4 && sizeof(d) == 8);
     if (d == (double)f) {
         b[0] = 0xca;    /* float IEEE 754 */
         memcpy(b+1,&f,4);
         memrevifle(b+1,4);
-        mp_buf_append(buf,b,5);
+        mp_buf_append(L,buf,b,5);
     } else if (sizeof(d) == 8) {
         b[0] = 0xcb;    /* double IEEE 754 */
         memcpy(b+1,&d,8);
         memrevifle(b+1,8);
-        mp_buf_append(buf,b,9);
+        mp_buf_append(L,buf,b,9);
     }
 }
 
-void mp_encode_int(mp_buf *buf, int64_t n) {
+void mp_encode_int(lua_State *L, mp_buf *buf, int64_t n) {
     unsigned char b[9];
     int enclen;
 
     if (n >= 0) {
         if (n <= 127) {
             b[0] = n & 0x7f;    /* positive fixnum */
@@ -286,16 +284,16 @@
             b[6] = (n & 0xff0000) >> 16;
             b[7] = (n & 0xff00) >> 8;
             b[8] = n & 0xff;
             enclen = 9;
         }
     }
-    mp_buf_append(buf,b,enclen);
+    mp_buf_append(L,buf,b,enclen);
 }
 
-void mp_encode_array(mp_buf *buf, int64_t n) {
+void mp_encode_array(lua_State *L, mp_buf *buf, int64_t n) {
     unsigned char b[5];
     int enclen;
 
     if (n <= 15) {
         b[0] = 0x90 | (n & 0xf);    /* fix array */
         enclen = 1;
@@ -309,16 +307,16 @@
         b[1] = (n & 0xff000000) >> 24;
         b[2] = (n & 0xff0000) >> 16;
         b[3] = (n & 0xff00) >> 8;
         b[4] = n & 0xff;
         enclen = 5;
     }
-    mp_buf_append(buf,b,enclen);
+    mp_buf_append(L,buf,b,enclen);
 }
 
-void mp_encode_map(mp_buf *buf, int64_t n) {
+void mp_encode_map(lua_State *L, mp_buf *buf, int64_t n) {
     unsigned char b[5];
     int enclen;
 
     if (n <= 15) {
         b[0] = 0x80 | (n & 0xf);    /* fix map */
         enclen = 1;
@@ -332,50 +330,50 @@
         b[1] = (n & 0xff000000) >> 24;
         b[2] = (n & 0xff0000) >> 16;
         b[3] = (n & 0xff00) >> 8;
         b[4] = n & 0xff;
         enclen = 5;
     }
-    mp_buf_append(buf,b,enclen);
+    mp_buf_append(L,buf,b,enclen);
 }
 
 /* --------------------------- Lua types encoding --------------------------- */
 
 void mp_encode_lua_string(lua_State *L, mp_buf *buf) {
     size_t len;
     const char *s;
 
     s = lua_tolstring(L,-1,&len);
-    mp_encode_bytes(buf,(const unsigned char*)s,len);
+    mp_encode_bytes(L,buf,(const unsigned char*)s,len);
 }
 
 void mp_encode_lua_bool(lua_State *L, mp_buf *buf) {
     unsigned char b = lua_toboolean(L,-1) ? 0xc3 : 0xc2;
-    mp_buf_append(buf,&b,1);
+    mp_buf_append(L,buf,&b,1);
 }
 
 /* Lua 5.3 has a built in 64-bit integer type */
 void mp_encode_lua_integer(lua_State *L, mp_buf *buf) {
 #if (LUA_VERSION_NUM < 503) && BITS_32
     lua_Number i = lua_tonumber(L,-1);
 #else
     lua_Integer i = lua_tointeger(L,-1);
 #endif
-    mp_encode_int(buf, (int64_t)i);
+    mp_encode_int(L, buf, (int64_t)i);
 }
 
 /* Lua 5.2 and lower only has 64-bit doubles, so we need to
  * detect if the double may be representable as an int
  * for Lua < 5.3 */
 void mp_encode_lua_number(lua_State *L, mp_buf *buf) {
     lua_Number n = lua_tonumber(L,-1);
 
     if (IS_INT64_EQUIVALENT(n)) {
         mp_encode_lua_integer(L, buf);
     } else {
-        mp_encode_double(buf,(double)n);
+        mp_encode_double(L,buf,(double)n);
     }
 }
 
 void mp_encode_lua_type(lua_State *L, mp_buf *buf, int level);
 
 /* Convert a lua table into a message pack list. */
@@ -383,13 +381,13 @@
 #if LUA_VERSION_NUM < 502
     size_t len = lua_objlen(L,-1), j;
 #else
     size_t len = lua_rawlen(L,-1), j;
 #endif
 
-    mp_encode_array(buf,len);
+    mp_encode_array(L,buf,len);
     for (j = 1; j <= len; j++) {
         lua_pushnumber(L,j);
         lua_gettable(L,-2);
         mp_encode_lua_type(L,buf,level+1);
     }
 }
@@ -406,13 +404,13 @@
     while(lua_next(L,-2)) {
         lua_pop(L,1); /* remove value, keep key for next iteration. */
         len++;
     }
 
     /* Step two: actually encoding of the map. */
-    mp_encode_map(buf,len);
+    mp_encode_map(L,buf,len);
     lua_pushnil(L);
     while(lua_next(L,-2)) {
         /* Stack: ... key value */
         lua_pushvalue(L,-2); /* Stack: ... key value key */
         mp_encode_lua_type(L,buf,level+1); /* encode key */
         mp_encode_lua_type(L,buf,level+1); /* encode val */
@@ -471,16 +469,15 @@
     else
         mp_encode_lua_table_as_map(L,buf,level);
 }
 
 void mp_encode_lua_null(lua_State *L, mp_buf *buf) {
     unsigned char b[1];
-    (void)L;
 
     b[0] = 0xc0;
-    mp_buf_append(buf,b,1);
+    mp_buf_append(L,buf,b,1);
 }
 
 void mp_encode_lua_type(lua_State *L, mp_buf *buf, int level) {
     int t = lua_type(L,-1);
 
     /* Limit the encoding of nested tables to a specified maximum depth, so that
@@ -531,13 +528,13 @@
         /* Reuse the buffer for the next operation by
          * setting its free count to the total buffer size
          * and the current position to zero. */
         buf->free += buf->len;
         buf->len = 0;
     }
-    mp_buf_free(buf);
+    mp_buf_free(L, buf);
 
     /* Concatenate all nargs buffers together */
     lua_concat(L, nargs);
     return 1;
 }
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cmsgpack.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cmsgpack.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cmsgpack.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cmsgpack.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_struct.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_struct.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lundump.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lundump.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lvm.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lvm.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lzio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lzio.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/print.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/print.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/strbuf.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/strbuf.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/Makefile	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/Makefile	2016-05-06 15:11:36.000000000 +0800
@@ -33,12 +33,13 @@
 endif
 
 distclean:
 	-(cd hiredis && $(MAKE) clean) > /dev/null || true
 	-(cd linenoise && $(MAKE) clean) > /dev/null || true
 	-(cd lua && $(MAKE) clean) > /dev/null || true
+	-(cd geohash-int && $(MAKE) clean) > /dev/null || true
 	-(cd jemalloc && [ -f Makefile ] && $(MAKE) distclean) > /dev/null || true
 	-(rm -f .make-*)
 
 .PHONY: distclean
 
 hiredis: .make-prerequisites
@@ -55,13 +56,13 @@
 
 ifeq ($(uname_S),SunOS)
 	# Make isinf() available
 	LUA_CFLAGS= -D__C99FEATURES__=1
 endif
 
-LUA_CFLAGS+= -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL $(CFLAGS)
+LUA_CFLAGS+= -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC='' $(CFLAGS)
 LUA_LDFLAGS+= $(LDFLAGS)
 # lua's Makefile defines AR="ar rcu", which is unusual, and makes it more
 # challenging to cross-compile lua (and redis).  These defines make it easier
 # to fit redis into cross-compilation environments, which typically set AR.
 AR=ar
 ARFLAGS=rcu
@@ -78,6 +79,12 @@
 jemalloc: .make-prerequisites
 	@printf '%b %b\n' $(MAKECOLOR)MAKE$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR)
 	cd jemalloc && ./configure --with-jemalloc-prefix=je_ --enable-cc-silence CFLAGS="$(JEMALLOC_CFLAGS)" LDFLAGS="$(JEMALLOC_LDFLAGS)"
 	cd jemalloc && $(MAKE) CFLAGS="$(JEMALLOC_CFLAGS)" LDFLAGS="$(JEMALLOC_LDFLAGS)" lib/libjemalloc.a
 
 .PHONY: jemalloc
+
+geohash-int: .make-prerequisites
+	@printf '%b %b\n' $(MAKECOLOR)MAKE$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR)
+	cd geohash-int && $(MAKE)
+
+.PHONY: geohash-int
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps: README.md
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/.gitignore /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/.gitignore
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/.gitignore	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/.gitignore	2016-05-06 15:11:36.000000000 +0800
@@ -1,12 +1,13 @@
 .*.swp
 *.o
 *.log
 dump.rdb
 redis-benchmark
 redis-check-aof
+redis-check-rdb
 redis-check-dump
 redis-cli
 redis-sentinel
 redis-server
 doc-tools
 release
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7: README
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0: README.md
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/redis.conf /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/redis.conf
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/redis.conf	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/redis.conf	2016-05-06 15:11:36.000000000 +0800
@@ -32,45 +32,71 @@
 # If instead you are interested in using includes to override configuration
 # options, it is better to use include as the last line.
 #
 # include /path/to/local.conf
 # include /path/to/other.conf
 
-################################ GENERAL  #####################################
+################################## NETWORK #####################################
 
-# By default Redis does not run as a daemon. Use 'yes' if you need it.
-# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
-daemonize no
-
-# When running daemonized, Redis writes a pid file in /var/run/redis.pid by
-# default. You can specify a custom pid file location here.
-pidfile /var/run/redis.pid
+# By default, if no "bind" configuration directive is specified, Redis listens
+# for connections from all the network interfaces available on the server.
+# It is possible to listen to just one or multiple selected interfaces using
+# the "bind" configuration directive, followed by one or more IP addresses.
+#
+# Examples:
+#
+# bind 192.168.1.100 10.0.0.1
+# bind 127.0.0.1 ::1
+#
+# ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
+# internet, binding to all the interfaces is dangerous and will expose the
+# instance to everybody on the internet. So by default we uncomment the
+# following bind directive, that will force Redis to listen only into
+# the IPv4 lookback interface address (this means Redis will be able to
+# accept connections only from clients running into the same computer it
+# is running).
+#
+# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
+# JUST COMMENT THE FOLLOWING LINE.
+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+bind 127.0.0.1
+
+# Protected mode is a layer of security protection, in order to avoid that
+# Redis instances left open on the internet are accessed and exploited.
+#
+# When protected mode is on and if:
+#
+# 1) The server is not binding explicitly to a set of addresses using the
+#    "bind" directive.
+# 2) No password is configured.
+#
+# The server only accepts connections from clients connecting from the
+# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
+# sockets.
+#
+# By default protected mode is enabled. You should disable it only if
+# you are sure you want clients from other hosts to connect to Redis
+# even if no authentication is configured, nor a specific set of interfaces
+# are explicitly listed using the "bind" directive.
+protected-mode yes
 
-# Accept connections on the specified port, default is 6379.
+# Accept connections on the specified port, default is 6379 (IANA #815344).
 # If port 0 is specified Redis will not listen on a TCP socket.
 port 6379
 
 # TCP listen() backlog.
 #
 # In high requests-per-second environments you need an high backlog in order
 # to avoid slow clients connections issues. Note that the Linux kernel
 # will silently truncate it to the value of /proc/sys/net/core/somaxconn so
 # make sure to raise both the value of somaxconn and tcp_max_syn_backlog
 # in order to get the desired effect.
 tcp-backlog 511
 
-# By default Redis listens for connections from all the network interfaces
-# available on the server. It is possible to listen to just one or multiple
-# interfaces using the "bind" configuration directive, followed by one or
-# more IP addresses.
-#
-# Examples:
+# Unix socket.
 #
-# bind 192.168.1.100 10.0.0.1
-# bind 127.0.0.1
-
 # Specify the path for the Unix socket that will be used to listen for
 # incoming connections. There is no default, so Redis will not listen
 # on a unix socket when not specified.
 #
 # unixsocket /tmp/redis.sock
 # unixsocketperm 700
@@ -91,12 +117,40 @@
 # Note that to close the connection the double of the time is needed.
 # On other kernels the period depends on the kernel configuration.
 #
 # A reasonable value for this option is 60 seconds.
 tcp-keepalive 0
 
+################################# GENERAL #####################################
+
+# By default Redis does not run as a daemon. Use 'yes' if you need it.
+# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
+daemonize no
+
+# If you run Redis from upstart or systemd, Redis can interact with your
+# supervision tree. Options:
+#   supervised no      - no supervision interaction
+#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode
+#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET
+#   supervised auto    - detect upstart or systemd method based on
+#                        UPSTART_JOB or NOTIFY_SOCKET environment variables
+# Note: these supervision methods only signal "process is ready."
+#       They do not enable continuous liveness pings back to your supervisor.
+supervised no
+
+# If a pid file is specified, Redis writes it where specified at startup
+# and removes it at exit.
+#
+# When the server runs non daemonized, no pid file is created if none is
+# specified in the configuration. When the server is daemonized, the pid file
+# is used even if not specified, defaulting to "/var/run/redis.pid".
+#
+# Creating a pid file is best effort: if Redis is not able to create it
+# nothing bad happens, the server will start and run normally.
+pidfile /var/run/redis.pid
+
 # Specify the server verbosity level.
 # This can be one of:
 # debug (a lot of information, useful for development/testing)
 # verbose (many rarely useful info, but not a mess like the debug level)
 # notice (moderately verbose, what you want in production probably)
 # warning (only very important / critical messages are logged)
@@ -826,17 +880,42 @@
 # Hashes are encoded using a memory efficient data structure when they have a
 # small number of entries, and the biggest entry does not exceed a given
 # threshold. These thresholds can be configured using the following directives.
 hash-max-ziplist-entries 512
 hash-max-ziplist-value 64
 
-# Similarly to hashes, small lists are also encoded in a special way in order
-# to save a lot of space. The special representation is only used when
-# you are under the following limits:
-list-max-ziplist-entries 512
-list-max-ziplist-value 64
+# Lists are also encoded in a special way to save a lot of space.
+# The number of entries allowed per internal list node can be specified
+# as a fixed maximum size or a maximum number of elements.
+# For a fixed maximum size, use -5 through -1, meaning:
+# -5: max size: 64 Kb  <-- not recommended for normal workloads
+# -4: max size: 32 Kb  <-- not recommended
+# -3: max size: 16 Kb  <-- probably not recommended
+# -2: max size: 8 Kb   <-- good
+# -1: max size: 4 Kb   <-- good
+# Positive numbers mean store up to _exactly_ that number of elements
+# per list node.
+# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
+# but if your use case is unique, adjust the settings as necessary.
+list-max-ziplist-size -2
+
+# Lists may also be compressed.
+# Compress depth is the number of quicklist ziplist nodes from *each* side of
+# the list to *exclude* from compression.  The head and tail of the list
+# are always uncompressed for fast push/pop operations.  Settings are:
+# 0: disable all list compression
+# 1: depth 1 means "don't start compressing until after 1 node into the list,
+#    going from either the head or tail"
+#    So: [head]->node->node->...->node->[tail]
+#    [head], [tail] will always be uncompressed; inner nodes will compress.
+# 2: [head]->[next]->node->node->...->node->[prev]->[tail]
+#    2 here means: don't compress head or head->next or tail->prev or tail,
+#    but compress all nodes between them.
+# 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]
+# etc.
+list-compress-depth 0
 
 # Sets have a special encoding in just one case: when a set is composed
 # of just strings that happen to be integers in radix 10 in the range
 # of 64 bit signed integers.
 # The following configuration setting sets the limit in the size of the
 # set in order to use this special memory saving encoding.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/adlist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/adlist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/adlist.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/adlist.c	2016-05-06 15:11:36.000000000 +0800
@@ -239,40 +239,37 @@
  * the original node is used as value of the copied node.
  *
  * The original list both on success or error is never modified. */
 list *listDup(list *orig)
 {
     list *copy;
-    listIter *iter;
+    listIter iter;
     listNode *node;
 
     if ((copy = listCreate()) == NULL)
         return NULL;
     copy->dup = orig->dup;
     copy->free = orig->free;
     copy->match = orig->match;
-    iter = listGetIterator(orig, AL_START_HEAD);
-    while((node = listNext(iter)) != NULL) {
+    listRewind(orig, &iter);
+    while((node = listNext(&iter)) != NULL) {
         void *value;
 
         if (copy->dup) {
             value = copy->dup(node->value);
             if (value == NULL) {
                 listRelease(copy);
-                listReleaseIterator(iter);
                 return NULL;
             }
         } else
             value = node->value;
         if (listAddNodeTail(copy, value) == NULL) {
             listRelease(copy);
-            listReleaseIterator(iter);
             return NULL;
         }
     }
-    listReleaseIterator(iter);
     return copy;
 }
 
 /* Search the list for a node matching a given key.
  * The match is performed using the 'match' method
  * set with listSetMatchMethod(). If no 'match' method
@@ -281,30 +278,27 @@
  *
  * On success the first matching node pointer is returned
  * (search starts from head). If no matching node exists
  * NULL is returned. */
 listNode *listSearchKey(list *list, void *key)
 {
-    listIter *iter;
+    listIter iter;
     listNode *node;
 
-    iter = listGetIterator(list, AL_START_HEAD);
-    while((node = listNext(iter)) != NULL) {
+    listRewind(list, &iter);
+    while((node = listNext(&iter)) != NULL) {
         if (list->match) {
             if (list->match(node->value, key)) {
-                listReleaseIterator(iter);
                 return node;
             }
         } else {
             if (key == node->value) {
-                listReleaseIterator(iter);
                 return node;
             }
         }
     }
-    listReleaseIterator(iter);
     return NULL;
 }
 
 /* Return the element at the specified zero-based index
  * where 0 is the head, 1 is the element next to head
  * and so on. Negative integers are used in order to count
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/adlist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/adlist.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/adlist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/adlist.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.c	2016-05-06 15:11:36.000000000 +0800
@@ -218,27 +218,18 @@
     eventLoop->timeEventHead = te;
     return id;
 }
 
 int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
 {
-    aeTimeEvent *te, *prev = NULL;
-
-    te = eventLoop->timeEventHead;
+    aeTimeEvent *te = eventLoop->timeEventHead;
     while(te) {
         if (te->id == id) {
-            if (prev == NULL)
-                eventLoop->timeEventHead = te->next;
-            else
-                prev->next = te->next;
-            if (te->finalizerProc)
-                te->finalizerProc(eventLoop, te->clientData);
-            zfree(te);
+            te->id = AE_DELETED_EVENT_ID;
             return AE_OK;
         }
-        prev = te;
         te = te->next;
     }
     return AE_ERR; /* NO event with the specified ID found */
 }
 
 /* Search the first timer to fire.
@@ -267,13 +258,13 @@
     return nearest;
 }
 
 /* Process time events */
 static int processTimeEvents(aeEventLoop *eventLoop) {
     int processed = 0;
-    aeTimeEvent *te;
+    aeTimeEvent *te, *prev;
     long long maxId;
     time_t now = time(NULL);
 
     /* If the system clock is moved to the future, and then set back to the
      * right value, time events may be delayed in a random way. Often this
      * means that scheduled operations will not be performed soon enough.
@@ -288,18 +279,38 @@
             te->when_sec = 0;
             te = te->next;
         }
     }
     eventLoop->lastTime = now;
 
+    prev = NULL;
     te = eventLoop->timeEventHead;
     maxId = eventLoop->timeEventNextId-1;
     while(te) {
         long now_sec, now_ms;
         long long id;
 
+        /* Remove events scheduled for deletion. */
+        if (te->id == AE_DELETED_EVENT_ID) {
+            aeTimeEvent *next = te->next;
+            if (prev == NULL)
+                eventLoop->timeEventHead = te->next;
+            else
+                prev->next = te->next;
+            if (te->finalizerProc)
+                te->finalizerProc(eventLoop, te->clientData);
+            zfree(te);
+            te = next;
+            continue;
+        }
+
+        /* Make sure we don't process time events created by time events in
+         * this iteration. Note that this check is currently useless: we always
+         * add new timers on the head, however if we change the implementation
+         * detail, this check may be useful again: we keep it here for future
+         * defense. */
         if (te->id > maxId) {
             te = te->next;
             continue;
         }
         aeGetTime(&now_sec, &now_ms);
         if (now_sec > te->when_sec ||
@@ -307,34 +318,20 @@
         {
             int retval;
 
             id = te->id;
             retval = te->timeProc(eventLoop, id, te->clientData);
             processed++;
-            /* After an event is processed our time event list may
-             * no longer be the same, so we restart from head.
-             * Still we make sure to don't process events registered
-             * by event handlers itself in order to don't loop forever.
-             * To do so we saved the max ID we want to handle.
-             *
-             * FUTURE OPTIMIZATIONS:
-             * Note that this is NOT great algorithmically. Redis uses
-             * a single time event so it's not a problem but the right
-             * way to do this is to add the new elements on head, and
-             * to flag deleted elements in a special way for later
-             * deletion (putting references to the nodes to delete into
-             * another linked list). */
             if (retval != AE_NOMORE) {
                 aeAddMillisecondsToNow(retval,&te->when_sec,&te->when_ms);
             } else {
-                aeDeleteTimeEvent(eventLoop, id);
+                te->id = AE_DELETED_EVENT_ID;
             }
-            te = eventLoop->timeEventHead;
-        } else {
-            te = te->next;
         }
+        prev = te;
+        te = te->next;
     }
     return processed;
 }
 
 /* Process every pending time event, then every pending file event
  * (that may be registered by time event callbacks just processed).
@@ -368,25 +365,28 @@
 
         if (flags & AE_TIME_EVENTS && !(flags & AE_DONT_WAIT))
             shortest = aeSearchNearestTimer(eventLoop);
         if (shortest) {
             long now_sec, now_ms;
 
-            /* Calculate the time missing for the nearest
-             * timer to fire. */
             aeGetTime(&now_sec, &now_ms);
             tvp = &tv;
-            tvp->tv_sec = shortest->when_sec - now_sec;
-            if (shortest->when_ms < now_ms) {
-                tvp->tv_usec = ((shortest->when_ms+1000) - now_ms)*1000;
-                tvp->tv_sec --;
+
+            /* How many milliseconds we need to wait for the next
+             * time event to fire? */
+            long long ms =
+                (shortest->when_sec - now_sec)*1000 +
+                shortest->when_ms - now_ms;
+
+            if (ms > 0) {
+                tvp->tv_sec = ms/1000;
+                tvp->tv_usec = (ms % 1000)*1000;
             } else {
-                tvp->tv_usec = (shortest->when_ms - now_ms)*1000;
+                tvp->tv_sec = 0;
+                tvp->tv_usec = 0;
             }
-            if (tvp->tv_sec < 0) tvp->tv_sec = 0;
-            if (tvp->tv_usec < 0) tvp->tv_usec = 0;
         } else {
             /* If we have to check for events but need to return
              * ASAP because of AE_DONT_WAIT we need to set the timeout
              * to zero */
             if (flags & AE_DONT_WAIT) {
                 tv.tv_sec = tv.tv_usec = 0;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae_epoll.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae_epoll.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae_epoll.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae_epoll.c	2016-05-06 15:11:36.000000000 +0800
@@ -69,37 +69,35 @@
     zfree(state->events);
     zfree(state);
 }
 
 static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
     aeApiState *state = eventLoop->apidata;
-    struct epoll_event ee;
+    struct epoll_event ee = {0}; /* avoid valgrind warning */
     /* If the fd was already monitored for some event, we need a MOD
      * operation. Otherwise we need an ADD operation. */
     int op = eventLoop->events[fd].mask == AE_NONE ?
             EPOLL_CTL_ADD : EPOLL_CTL_MOD;
 
     ee.events = 0;
     mask |= eventLoop->events[fd].mask; /* Merge old events */
     if (mask & AE_READABLE) ee.events |= EPOLLIN;
     if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
-    ee.data.u64 = 0; /* avoid valgrind warning */
     ee.data.fd = fd;
     if (epoll_ctl(state->epfd,op,fd,&ee) == -1) return -1;
     return 0;
 }
 
 static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {
     aeApiState *state = eventLoop->apidata;
-    struct epoll_event ee;
+    struct epoll_event ee = {0}; /* avoid valgrind warning */
     int mask = eventLoop->events[fd].mask & (~delmask);
 
     ee.events = 0;
     if (mask & AE_READABLE) ee.events |= EPOLLIN;
     if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
-    ee.data.u64 = 0; /* avoid valgrind warning */
     ee.data.fd = fd;
     if (mask != AE_NONE) {
         epoll_ctl(state->epfd,EPOLL_CTL_MOD,fd,&ee);
     } else {
         /* Note, Kernel < 2.6.9 requires a non null event pointer even for
          * EPOLL_CTL_DEL. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.h	2016-05-06 15:11:36.000000000 +0800
@@ -30,12 +30,14 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __AE_H__
 #define __AE_H__
 
+#include <time.h>
+
 #define AE_OK 0
 #define AE_ERR -1
 
 #define AE_NONE 0
 #define AE_READABLE 1
 #define AE_WRITABLE 2
@@ -43,12 +45,13 @@
 #define AE_FILE_EVENTS 1
 #define AE_TIME_EVENTS 2
 #define AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)
 #define AE_DONT_WAIT 4
 
 #define AE_NOMORE -1
+#define AE_DELETED_EVENT_ID -1
 
 /* Macros */
 #define AE_NOTUSED(V) ((void) V)
 
 struct aeEventLoop;
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.c	2016-05-06 15:11:36.000000000 +0800
@@ -406,28 +406,28 @@
 }
 
 /* Like read(2) but make sure 'count' is read before to return
  * (unless error or EOF condition is encountered) */
 int anetRead(int fd, char *buf, int count)
 {
-    int nread, totlen = 0;
+    ssize_t nread, totlen = 0;
     while(totlen != count) {
         nread = read(fd,buf,count-totlen);
         if (nread == 0) return totlen;
         if (nread == -1) return -1;
         totlen += nread;
         buf += nread;
     }
     return totlen;
 }
 
-/* Like write(2) but make sure 'count' is read before to return
+/* Like write(2) but make sure 'count' is written before to return
  * (unless error is encountered) */
 int anetWrite(int fd, char *buf, int count)
 {
-    int nwritten, totlen = 0;
+    ssize_t nwritten, totlen = 0;
     while(totlen != count) {
         nwritten = write(fd,buf,count-totlen);
         if (nwritten == 0) return totlen;
         if (nwritten == -1) return -1;
         totlen += nwritten;
         buf += nwritten;
@@ -604,12 +604,29 @@
         }
     }
     if (port) *port = 0;
     return -1;
 }
 
+/* Format an IP,port pair into something easy to parse. If IP is IPv6
+ * (matches for ":"), the ip is surrounded by []. IP and port are just
+ * separated by colons. This the standard to display addresses within Redis. */
+int anetFormatAddr(char *buf, size_t buf_len, char *ip, int port) {
+    return snprintf(buf,buf_len, strchr(ip,':') ?
+           "[%s]:%d" : "%s:%d", ip, port);
+}
+
+/* Like anetFormatAddr() but extract ip and port from the socket's peer. */
+int anetFormatPeer(int fd, char *buf, size_t buf_len) {
+    char ip[INET6_ADDRSTRLEN];
+    int port;
+
+    anetPeerToString(fd,ip,sizeof(ip),&port);
+    return anetFormatAddr(buf, buf_len, ip, port);
+}
+
 int anetSockName(int fd, char *ip, size_t ip_len, int *port) {
     struct sockaddr_storage sa;
     socklen_t salen = sizeof(sa);
 
     if (getsockname(fd,(struct sockaddr*)&sa,&salen) == -1) {
         if (port) *port = 0;
@@ -625,6 +642,14 @@
         struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
         if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
         if (port) *port = ntohs(s->sin6_port);
     }
     return 0;
 }
+
+int anetFormatSock(int fd, char *fmt, size_t fmt_len) {
+    char ip[INET6_ADDRSTRLEN];
+    int port;
+
+    anetSockName(fd,ip,sizeof(ip),&port);
+    return anetFormatAddr(fmt, fmt_len, ip, port);
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.h	2016-05-06 15:11:36.000000000 +0800
@@ -28,12 +28,14 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef ANET_H
 #define ANET_H
 
+#include <sys/types.h>
+
 #define ANET_OK 0
 #define ANET_ERR -1
 #define ANET_ERR_LEN 256
 
 /* Flags used with certain functions. */
 #define ANET_NONE 0
@@ -68,8 +70,11 @@
 int anetDisableTcpNoDelay(char *err, int fd);
 int anetTcpKeepAlive(char *err, int fd);
 int anetSendTimeout(char *err, int fd, long long ms);
 int anetPeerToString(int fd, char *ip, size_t ip_len, int *port);
 int anetKeepAlive(char *err, int fd, int interval);
 int anetSockName(int fd, char *ip, size_t ip_len, int *port);
+int anetFormatAddr(char *fmt, size_t fmt_len, char *ip, int port);
+int anetFormatPeer(int fd, char *fmt, size_t fmt_len);
+int anetFormatSock(int fd, char *fmt, size_t fmt_len);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/aof.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/aof.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/aof.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/aof.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,23 +24,24 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include "bio.h"
 #include "rio.h"
 
 #include <signal.h>
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <sys/wait.h>
+#include <sys/param.h>
 
 void aofUpdateCurrentSize(void);
 void aofClosePipes(void);
 
 /* ----------------------------------------------------------------------------
  * AOF rewrite buffer implementation.
@@ -92,16 +93,16 @@
  * rewrite. We send pieces of our AOF differences buffer so that the final
  * write when the child finishes the rewrite will be small. */
 void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {
     listNode *ln;
     aofrwblock *block;
     ssize_t nwritten;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(fd);
-    REDIS_NOTUSED(privdata);
-    REDIS_NOTUSED(mask);
+    UNUSED(el);
+    UNUSED(fd);
+    UNUSED(privdata);
+    UNUSED(mask);
 
     while(1) {
         ln = listFirst(server.aof_rewrite_buf_blocks);
         block = ln ? ln->value : NULL;
         if (server.aof_stop_sending_diff || !block) {
             aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,
@@ -147,15 +148,15 @@
             listAddNodeTail(server.aof_rewrite_buf_blocks,block);
 
             /* Log every time we cross more 10 or 100 blocks, respectively
              * as a notice or warning. */
             numblocks = listLength(server.aof_rewrite_buf_blocks);
             if (((numblocks+1) % 10) == 0) {
-                int level = ((numblocks+1) % 100) == 0 ? REDIS_WARNING :
-                                                         REDIS_NOTICE;
-                redisLog(level,"Background AOF buffer size: %lu MB",
+                int level = ((numblocks+1) % 100) == 0 ? LL_WARNING :
+                                                         LL_NOTICE;
+                serverLog(level,"Background AOF buffer size: %lu MB",
                     aofRewriteBufferSize()/(1024*1024));
             }
         }
     }
 
     /* Install a file event to send data to the rewrite child if there is
@@ -195,34 +196,35 @@
  * AOF file implementation
  * ------------------------------------------------------------------------- */
 
 /* Starts a background task that performs fsync() against the specified
  * file descriptor (the one of the AOF file) in another thread. */
 void aof_background_fsync(int fd) {
-    bioCreateBackgroundJob(REDIS_BIO_AOF_FSYNC,(void*)(long)fd,NULL,NULL);
+    bioCreateBackgroundJob(BIO_AOF_FSYNC,(void*)(long)fd,NULL,NULL);
 }
 
 /* Called when the user switches from "appendonly yes" to "appendonly no"
  * at runtime using the CONFIG command. */
 void stopAppendOnly(void) {
-    redisAssert(server.aof_state != REDIS_AOF_OFF);
+    serverAssert(server.aof_state != AOF_OFF);
     flushAppendOnlyFile(1);
     aof_fsync(server.aof_fd);
     close(server.aof_fd);
 
     server.aof_fd = -1;
     server.aof_selected_db = -1;
-    server.aof_state = REDIS_AOF_OFF;
+    server.aof_state = AOF_OFF;
     /* rewrite operation in progress? kill it, wait child exit */
     if (server.aof_child_pid != -1) {
         int statloc;
 
-        redisLog(REDIS_NOTICE,"Killing running AOF rewrite child: %ld",
+        serverLog(LL_NOTICE,"Killing running AOF rewrite child: %ld",
             (long) server.aof_child_pid);
-        if (kill(server.aof_child_pid,SIGUSR1) != -1)
-            wait3(&statloc,0,NULL);
+        if (kill(server.aof_child_pid,SIGUSR1) != -1) {
+            while(wait3(&statloc,0,NULL) != server.aof_child_pid);
+        }
         /* reset the buffer accumulating changes while the child saves */
         aofRewriteBufferReset();
         aofRemoveTempFile(server.aof_child_pid);
         server.aof_child_pid = -1;
         server.aof_rewrite_time_start = -1;
         /* close pipes used for IPC between the two processes. */
@@ -230,28 +232,37 @@
     }
 }
 
 /* Called when the user switches from "appendonly no" to "appendonly yes"
  * at runtime using the CONFIG command. */
 int startAppendOnly(void) {
+    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */
+
     server.aof_last_fsync = server.unixtime;
     server.aof_fd = open(server.aof_filename,O_WRONLY|O_APPEND|O_CREAT,0644);
-    redisAssert(server.aof_state == REDIS_AOF_OFF);
+    serverAssert(server.aof_state == AOF_OFF);
     if (server.aof_fd == -1) {
-        redisLog(REDIS_WARNING,"Redis needs to enable the AOF but can't open the append only file: %s",strerror(errno));
-        return REDIS_ERR;
+        char *cwdp = getcwd(cwd,MAXPATHLEN);
+
+        serverLog(LL_WARNING,
+            "Redis needs to enable the AOF but can't open the "
+            "append only file %s (in server root dir %s): %s",
+            server.aof_filename,
+            cwdp ? cwdp : "unknown",
+            strerror(errno));
+        return C_ERR;
     }
-    if (rewriteAppendOnlyFileBackground() == REDIS_ERR) {
+    if (rewriteAppendOnlyFileBackground() == C_ERR) {
         close(server.aof_fd);
-        redisLog(REDIS_WARNING,"Redis needs to enable the AOF but can't trigger a background AOF rewrite operation. Check the above logs for more info about the error.");
-        return REDIS_ERR;
+        serverLog(LL_WARNING,"Redis needs to enable the AOF but can't trigger a background AOF rewrite operation. Check the above logs for more info about the error.");
+        return C_ERR;
     }
     /* We correctly switched on AOF, now wait for the rewrite to be complete
      * in order to append data on disk. */
-    server.aof_state = REDIS_AOF_WAIT_REWRITE;
-    return REDIS_OK;
+    server.aof_state = AOF_WAIT_REWRITE;
+    return C_OK;
 }
 
 /* Write the append only file buffer on disk.
  *
  * Since we are required to write the AOF before replying to the client,
  * and the only way the client socket can get a write is entering when the
@@ -275,13 +286,13 @@
     int sync_in_progress = 0;
     mstime_t latency;
 
     if (sdslen(server.aof_buf) == 0) return;
 
     if (server.aof_fsync == AOF_FSYNC_EVERYSEC)
-        sync_in_progress = bioPendingJobsOfType(REDIS_BIO_AOF_FSYNC) != 0;
+        sync_in_progress = bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
 
     if (server.aof_fsync == AOF_FSYNC_EVERYSEC && !force) {
         /* With this append fsync policy we do background fsyncing.
          * If the fsync is still in progress we can try to delay
          * the write for a couple of seconds. */
         if (sync_in_progress) {
@@ -295,13 +306,13 @@
                  * than two seconds this is still ok. Postpone again. */
                 return;
             }
             /* Otherwise fall trough, and go write since we can't wait
              * over two seconds. */
             server.aof_delayed_fsync++;
-            redisLog(REDIS_NOTICE,"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.");
+            serverLog(LL_NOTICE,"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.");
         }
     }
     /* We want to perform a single write. This should be guaranteed atomic
      * at least if the filesystem we are writing is a real physical one.
      * While this will save us against the server being killed I don't think
      * there is much to do about the whole server stopping for power problems
@@ -337,28 +348,28 @@
             last_write_error_log = server.unixtime;
         }
 
         /* Log the AOF write error and record the error code. */
         if (nwritten == -1) {
             if (can_log) {
-                redisLog(REDIS_WARNING,"Error writing to the AOF file: %s",
+                serverLog(LL_WARNING,"Error writing to the AOF file: %s",
                     strerror(errno));
                 server.aof_last_write_errno = errno;
             }
         } else {
             if (can_log) {
-                redisLog(REDIS_WARNING,"Short write while writing to "
+                serverLog(LL_WARNING,"Short write while writing to "
                                        "the AOF file: (nwritten=%lld, "
                                        "expected=%lld)",
                                        (long long)nwritten,
                                        (long long)sdslen(server.aof_buf));
             }
 
             if (ftruncate(server.aof_fd, server.aof_current_size) == -1) {
                 if (can_log) {
-                    redisLog(REDIS_WARNING, "Could not remove short write "
+                    serverLog(LL_WARNING, "Could not remove short write "
                              "from the append-only file.  Redis may refuse "
                              "to load the AOF the next time it starts.  "
                              "ftruncate: %s", strerror(errno));
                 }
             } else {
                 /* If the ftruncate() succeeded we can set nwritten to
@@ -371,35 +382,35 @@
         /* Handle the AOF write error. */
         if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
             /* We can't recover when the fsync policy is ALWAYS since the
              * reply for the client is already in the output buffers, and we
              * have the contract with the user that on acknowledged write data
              * is synced on disk. */
-            redisLog(REDIS_WARNING,"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting...");
+            serverLog(LL_WARNING,"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting...");
             exit(1);
         } else {
             /* Recover from failed write leaving data into the buffer. However
              * set an error to stop accepting writes as long as the error
              * condition is not cleared. */
-            server.aof_last_write_status = REDIS_ERR;
+            server.aof_last_write_status = C_ERR;
 
             /* Trim the sds buffer if there was a partial write, and there
              * was no way to undo it with ftruncate(2). */
             if (nwritten > 0) {
                 server.aof_current_size += nwritten;
                 sdsrange(server.aof_buf,nwritten,-1);
             }
             return; /* We'll try again on the next call... */
         }
     } else {
         /* Successful write(2). If AOF was in error state, restore the
          * OK state and log the event. */
-        if (server.aof_last_write_status == REDIS_ERR) {
-            redisLog(REDIS_WARNING,
+        if (server.aof_last_write_status == C_ERR) {
+            serverLog(LL_WARNING,
                 "AOF write error looks solved, Redis can write again.");
-            server.aof_last_write_status = REDIS_OK;
+            server.aof_last_write_status = C_OK;
         }
     }
     server.aof_current_size += nwritten;
 
     /* Re-use AOF buffer when it is small enough. The maximum comes from the
      * arena size of 4k minus some overhead (but is otherwise arbitrary). */
@@ -528,13 +539,13 @@
         buf = catAppendOnlyGenericCommand(buf,argc,argv);
     }
 
     /* Append to the AOF buffer. This will be flushed on disk just before
      * of re-entering the event loop, so before the client will get a
      * positive reply about the operation performed. */
-    if (server.aof_state == REDIS_AOF_ON)
+    if (server.aof_state == AOF_ON)
         server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));
 
     /* If a background append only file rewriting is in progress we want to
      * accumulate the differences between the child DB and the current one
      * in a buffer, so that when the child process will do its work we
      * can append the differences to the new append only file. */
@@ -547,80 +558,80 @@
 /* ----------------------------------------------------------------------------
  * AOF loading
  * ------------------------------------------------------------------------- */
 
 /* In Redis commands are always executed in the context of a client, so in
  * order to load the append only file we need to create a fake client. */
-struct redisClient *createFakeClient(void) {
-    struct redisClient *c = zmalloc(sizeof(*c));
+struct client *createFakeClient(void) {
+    struct client *c = zmalloc(sizeof(*c));
 
     selectDb(c,0);
     c->fd = -1;
     c->name = NULL;
     c->querybuf = sdsempty();
     c->querybuf_peak = 0;
     c->argc = 0;
     c->argv = NULL;
     c->bufpos = 0;
     c->flags = 0;
-    c->btype = REDIS_BLOCKED_NONE;
+    c->btype = BLOCKED_NONE;
     /* We set the fake client as a slave waiting for the synchronization
      * so that Redis will not try to send replies to this client. */
-    c->replstate = REDIS_REPL_WAIT_BGSAVE_START;
+    c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
     c->reply = listCreate();
     c->reply_bytes = 0;
     c->obuf_soft_limit_reached_time = 0;
     c->watched_keys = listCreate();
     c->peerid = NULL;
     listSetFreeMethod(c->reply,decrRefCountVoid);
     listSetDupMethod(c->reply,dupClientReplyValue);
     initClientMultiState(c);
     return c;
 }
 
-void freeFakeClientArgv(struct redisClient *c) {
+void freeFakeClientArgv(struct client *c) {
     int j;
 
     for (j = 0; j < c->argc; j++)
         decrRefCount(c->argv[j]);
     zfree(c->argv);
 }
 
-void freeFakeClient(struct redisClient *c) {
+void freeFakeClient(struct client *c) {
     sdsfree(c->querybuf);
     listRelease(c->reply);
     listRelease(c->watched_keys);
     freeClientMultiState(c);
     zfree(c);
 }
 
-/* Replay the append log file. On success REDIS_OK is returned. On non fatal
- * error (the append only file is zero-length) REDIS_ERR is returned. On
+/* Replay the append log file. On success C_OK is returned. On non fatal
+ * error (the append only file is zero-length) C_ERR is returned. On
  * fatal error an error message is logged and the program exists. */
 int loadAppendOnlyFile(char *filename) {
-    struct redisClient *fakeClient;
+    struct client *fakeClient;
     FILE *fp = fopen(filename,"r");
     struct redis_stat sb;
     int old_aof_state = server.aof_state;
     long loops = 0;
     off_t valid_up_to = 0; /* Offset of the latest well-formed command loaded. */
 
     if (fp && redis_fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
         server.aof_current_size = 0;
         fclose(fp);
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     if (fp == NULL) {
-        redisLog(REDIS_WARNING,"Fatal error: can't open the append log file for reading: %s",strerror(errno));
+        serverLog(LL_WARNING,"Fatal error: can't open the append log file for reading: %s",strerror(errno));
         exit(1);
     }
 
     /* Temporarily disable AOF, to prevent EXEC from feeding a MULTI
      * to the same file we're about to read. */
-    server.aof_state = REDIS_AOF_OFF;
+    server.aof_state = AOF_OFF;
 
     fakeClient = createFakeClient();
     startLoading(fp);
 
     while(1) {
         int argc, j;
@@ -663,334 +674,314 @@
             if (len && fread(argsds,len,1,fp) == 0) {
                 sdsfree(argsds);
                 fakeClient->argc = j; /* Free up to j-1. */
                 freeFakeClientArgv(fakeClient);
                 goto readerr;
             }
-            argv[j] = createObject(REDIS_STRING,argsds);
+            argv[j] = createObject(OBJ_STRING,argsds);
             if (fread(buf,2,1,fp) == 0) {
                 fakeClient->argc = j+1; /* Free up to j. */
                 freeFakeClientArgv(fakeClient);
                 goto readerr; /* discard CRLF */
             }
         }
 
         /* Command lookup */
         cmd = lookupCommand(argv[0]->ptr);
         if (!cmd) {
-            redisLog(REDIS_WARNING,"Unknown command '%s' reading the append only file", (char*)argv[0]->ptr);
+            serverLog(LL_WARNING,"Unknown command '%s' reading the append only file", (char*)argv[0]->ptr);
             exit(1);
         }
 
         /* Run the command in the context of a fake client */
         cmd->proc(fakeClient);
 
         /* The fake client should not have a reply */
-        redisAssert(fakeClient->bufpos == 0 && listLength(fakeClient->reply) == 0);
+        serverAssert(fakeClient->bufpos == 0 && listLength(fakeClient->reply) == 0);
         /* The fake client should never get blocked */
-        redisAssert((fakeClient->flags & REDIS_BLOCKED) == 0);
+        serverAssert((fakeClient->flags & CLIENT_BLOCKED) == 0);
 
         /* Clean up. Command code may have changed argv/argc so we use the
          * argv/argc of the client instead of the local variables. */
         freeFakeClientArgv(fakeClient);
         if (server.aof_load_truncated) valid_up_to = ftello(fp);
     }
 
     /* This point can only be reached when EOF is reached without errors.
      * If the client is in the middle of a MULTI/EXEC, log error and quit. */
-    if (fakeClient->flags & REDIS_MULTI) goto uxeof;
+    if (fakeClient->flags & CLIENT_MULTI) goto uxeof;
 
-loaded_ok: /* DB loaded, cleanup and return REDIS_OK to the caller. */
+loaded_ok: /* DB loaded, cleanup and return C_OK to the caller. */
     fclose(fp);
     freeFakeClient(fakeClient);
     server.aof_state = old_aof_state;
     stopLoading();
     aofUpdateCurrentSize();
     server.aof_rewrite_base_size = server.aof_current_size;
-    return REDIS_OK;
+    return C_OK;
 
 readerr: /* Read error. If feof(fp) is true, fall through to unexpected EOF. */
     if (!feof(fp)) {
-        redisLog(REDIS_WARNING,"Unrecoverable error reading the append only file: %s", strerror(errno));
+        if (fakeClient) freeFakeClient(fakeClient); /* avoid valgrind warning */
+        serverLog(LL_WARNING,"Unrecoverable error reading the append only file: %s", strerror(errno));
         exit(1);
     }
 
 uxeof: /* Unexpected AOF end of file. */
     if (server.aof_load_truncated) {
-        redisLog(REDIS_WARNING,"!!! Warning: short read while loading the AOF file !!!");
-        redisLog(REDIS_WARNING,"!!! Truncating the AOF at offset %llu !!!",
+        serverLog(LL_WARNING,"!!! Warning: short read while loading the AOF file !!!");
+        serverLog(LL_WARNING,"!!! Truncating the AOF at offset %llu !!!",
             (unsigned long long) valid_up_to);
         if (valid_up_to == -1 || truncate(filename,valid_up_to) == -1) {
             if (valid_up_to == -1) {
-                redisLog(REDIS_WARNING,"Last valid command offset is invalid");
+                serverLog(LL_WARNING,"Last valid command offset is invalid");
             } else {
-                redisLog(REDIS_WARNING,"Error truncating the AOF file: %s",
+                serverLog(LL_WARNING,"Error truncating the AOF file: %s",
                     strerror(errno));
             }
         } else {
             /* Make sure the AOF file descriptor points to the end of the
              * file after the truncate call. */
             if (server.aof_fd != -1 && lseek(server.aof_fd,0,SEEK_END) == -1) {
-                redisLog(REDIS_WARNING,"Can't seek the end of the AOF file: %s",
+                serverLog(LL_WARNING,"Can't seek the end of the AOF file: %s",
                     strerror(errno));
             } else {
-                redisLog(REDIS_WARNING,
+                serverLog(LL_WARNING,
                     "AOF loaded anyway because aof-load-truncated is enabled");
                 goto loaded_ok;
             }
         }
     }
-    redisLog(REDIS_WARNING,"Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix <filename>. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server.");
+    if (fakeClient) freeFakeClient(fakeClient); /* avoid valgrind warning */
+    serverLog(LL_WARNING,"Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix <filename>. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server.");
     exit(1);
 
 fmterr: /* Format error. */
-    redisLog(REDIS_WARNING,"Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>");
+    if (fakeClient) freeFakeClient(fakeClient); /* avoid valgrind warning */
+    serverLog(LL_WARNING,"Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>");
     exit(1);
 }
 
 /* ----------------------------------------------------------------------------
  * AOF rewrite
  * ------------------------------------------------------------------------- */
 
 /* Delegate writing an object to writing a bulk string or bulk long long.
- * This is not placed in rio.c since that adds the redis.h dependency. */
+ * This is not placed in rio.c since that adds the server.h dependency. */
 int rioWriteBulkObject(rio *r, robj *obj) {
     /* Avoid using getDecodedObject to help copy-on-write (we are often
      * in a child process when this function is called). */
-    if (obj->encoding == REDIS_ENCODING_INT) {
+    if (obj->encoding == OBJ_ENCODING_INT) {
         return rioWriteBulkLongLong(r,(long)obj->ptr);
     } else if (sdsEncodedObject(obj)) {
         return rioWriteBulkString(r,obj->ptr,sdslen(obj->ptr));
     } else {
-        redisPanic("Unknown string encoding");
+        serverPanic("Unknown string encoding");
     }
 }
 
 /* Emit the commands needed to rebuild a list object.
  * The function returns 0 on error, 1 on success. */
 int rewriteListObject(rio *r, robj *key, robj *o) {
     long long count = 0, items = listTypeLength(o);
 
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
-        unsigned char *zl = o->ptr;
-        unsigned char *p = ziplistIndex(zl,0);
-        unsigned char *vstr;
-        unsigned int vlen;
-        long long vlong;
+    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
+        quicklist *list = o->ptr;
+        quicklistIter *li = quicklistGetIterator(list, AL_START_HEAD);
+        quicklistEntry entry;
 
-        while(ziplistGet(p,&vstr,&vlen,&vlong)) {
+        while (quicklistNext(li,&entry)) {
             if (count == 0) {
-                int cmd_items = (items > REDIS_AOF_REWRITE_ITEMS_PER_CMD) ?
-                    REDIS_AOF_REWRITE_ITEMS_PER_CMD : items;
-
+                int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
+                    AOF_REWRITE_ITEMS_PER_CMD : items;
                 if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
                 if (rioWriteBulkString(r,"RPUSH",5) == 0) return 0;
                 if (rioWriteBulkObject(r,key) == 0) return 0;
             }
-            if (vstr) {
-                if (rioWriteBulkString(r,(char*)vstr,vlen) == 0) return 0;
-            } else {
-                if (rioWriteBulkLongLong(r,vlong) == 0) return 0;
-            }
-            p = ziplistNext(zl,p);
-            if (++count == REDIS_AOF_REWRITE_ITEMS_PER_CMD) count = 0;
-            items--;
-        }
-    } else if (o->encoding == REDIS_ENCODING_LINKEDLIST) {
-        list *list = o->ptr;
-        listNode *ln;
-        listIter li;
-
-        listRewind(list,&li);
-        while((ln = listNext(&li))) {
-            robj *eleobj = listNodeValue(ln);
-
-            if (count == 0) {
-                int cmd_items = (items > REDIS_AOF_REWRITE_ITEMS_PER_CMD) ?
-                    REDIS_AOF_REWRITE_ITEMS_PER_CMD : items;
 
-                if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
-                if (rioWriteBulkString(r,"RPUSH",5) == 0) return 0;
-                if (rioWriteBulkObject(r,key) == 0) return 0;
+            if (entry.value) {
+                if (rioWriteBulkString(r,(char*)entry.value,entry.sz) == 0) return 0;
+            } else {
+                if (rioWriteBulkLongLong(r,entry.longval) == 0) return 0;
             }
-            if (rioWriteBulkObject(r,eleobj) == 0) return 0;
-            if (++count == REDIS_AOF_REWRITE_ITEMS_PER_CMD) count = 0;
+            if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
+        quicklistReleaseIterator(li);
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
     return 1;
 }
 
 /* Emit the commands needed to rebuild a set object.
  * The function returns 0 on error, 1 on success. */
 int rewriteSetObject(rio *r, robj *key, robj *o) {
     long long count = 0, items = setTypeSize(o);
 
-    if (o->encoding == REDIS_ENCODING_INTSET) {
+    if (o->encoding == OBJ_ENCODING_INTSET) {
         int ii = 0;
         int64_t llval;
 
         while(intsetGet(o->ptr,ii++,&llval)) {
             if (count == 0) {
-                int cmd_items = (items > REDIS_AOF_REWRITE_ITEMS_PER_CMD) ?
-                    REDIS_AOF_REWRITE_ITEMS_PER_CMD : items;
+                int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
+                    AOF_REWRITE_ITEMS_PER_CMD : items;
 
                 if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
                 if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
                 if (rioWriteBulkObject(r,key) == 0) return 0;
             }
             if (rioWriteBulkLongLong(r,llval) == 0) return 0;
-            if (++count == REDIS_AOF_REWRITE_ITEMS_PER_CMD) count = 0;
+            if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
-    } else if (o->encoding == REDIS_ENCODING_HT) {
+    } else if (o->encoding == OBJ_ENCODING_HT) {
         dictIterator *di = dictGetIterator(o->ptr);
         dictEntry *de;
 
         while((de = dictNext(di)) != NULL) {
             robj *eleobj = dictGetKey(de);
             if (count == 0) {
-                int cmd_items = (items > REDIS_AOF_REWRITE_ITEMS_PER_CMD) ?
-                    REDIS_AOF_REWRITE_ITEMS_PER_CMD : items;
+                int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
+                    AOF_REWRITE_ITEMS_PER_CMD : items;
 
                 if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
                 if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
                 if (rioWriteBulkObject(r,key) == 0) return 0;
             }
             if (rioWriteBulkObject(r,eleobj) == 0) return 0;
-            if (++count == REDIS_AOF_REWRITE_ITEMS_PER_CMD) count = 0;
+            if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
         dictReleaseIterator(di);
     } else {
-        redisPanic("Unknown set encoding");
+        serverPanic("Unknown set encoding");
     }
     return 1;
 }
 
 /* Emit the commands needed to rebuild a sorted set object.
  * The function returns 0 on error, 1 on success. */
 int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
     long long count = 0, items = zsetLength(o);
 
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = o->ptr;
         unsigned char *eptr, *sptr;
         unsigned char *vstr;
         unsigned int vlen;
         long long vll;
         double score;
 
         eptr = ziplistIndex(zl,0);
-        redisAssert(eptr != NULL);
+        serverAssert(eptr != NULL);
         sptr = ziplistNext(zl,eptr);
-        redisAssert(sptr != NULL);
+        serverAssert(sptr != NULL);
 
         while (eptr != NULL) {
-            redisAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
+            serverAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
             score = zzlGetScore(sptr);
 
             if (count == 0) {
-                int cmd_items = (items > REDIS_AOF_REWRITE_ITEMS_PER_CMD) ?
-                    REDIS_AOF_REWRITE_ITEMS_PER_CMD : items;
+                int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
+                    AOF_REWRITE_ITEMS_PER_CMD : items;
 
                 if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) return 0;
                 if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
                 if (rioWriteBulkObject(r,key) == 0) return 0;
             }
             if (rioWriteBulkDouble(r,score) == 0) return 0;
             if (vstr != NULL) {
                 if (rioWriteBulkString(r,(char*)vstr,vlen) == 0) return 0;
             } else {
                 if (rioWriteBulkLongLong(r,vll) == 0) return 0;
             }
             zzlNext(zl,&eptr,&sptr);
-            if (++count == REDIS_AOF_REWRITE_ITEMS_PER_CMD) count = 0;
+            if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
-    } else if (o->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = o->ptr;
         dictIterator *di = dictGetIterator(zs->dict);
         dictEntry *de;
 
         while((de = dictNext(di)) != NULL) {
             robj *eleobj = dictGetKey(de);
             double *score = dictGetVal(de);
 
             if (count == 0) {
-                int cmd_items = (items > REDIS_AOF_REWRITE_ITEMS_PER_CMD) ?
-                    REDIS_AOF_REWRITE_ITEMS_PER_CMD : items;
+                int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
+                    AOF_REWRITE_ITEMS_PER_CMD : items;
 
                 if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) return 0;
                 if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
                 if (rioWriteBulkObject(r,key) == 0) return 0;
             }
             if (rioWriteBulkDouble(r,*score) == 0) return 0;
             if (rioWriteBulkObject(r,eleobj) == 0) return 0;
-            if (++count == REDIS_AOF_REWRITE_ITEMS_PER_CMD) count = 0;
+            if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
         dictReleaseIterator(di);
     } else {
-        redisPanic("Unknown sorted zset encoding");
+        serverPanic("Unknown sorted zset encoding");
     }
     return 1;
 }
 
 /* Write either the key or the value of the currently selected item of a hash.
  * The 'hi' argument passes a valid Redis hash iterator.
  * The 'what' filed specifies if to write a key or a value and can be
- * either REDIS_HASH_KEY or REDIS_HASH_VALUE.
+ * either OBJ_HASH_KEY or OBJ_HASH_VALUE.
  *
  * The function returns 0 on error, non-zero on success. */
 static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {
-    if (hi->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
         if (vstr) {
             return rioWriteBulkString(r, (char*)vstr, vlen);
         } else {
             return rioWriteBulkLongLong(r, vll);
         }
 
-    } else if (hi->encoding == REDIS_ENCODING_HT) {
+    } else if (hi->encoding == OBJ_ENCODING_HT) {
         robj *value;
 
         hashTypeCurrentFromHashTable(hi, what, &value);
         return rioWriteBulkObject(r, value);
     }
 
-    redisPanic("Unknown hash encoding");
+    serverPanic("Unknown hash encoding");
     return 0;
 }
 
 /* Emit the commands needed to rebuild a hash object.
  * The function returns 0 on error, 1 on success. */
 int rewriteHashObject(rio *r, robj *key, robj *o) {
     hashTypeIterator *hi;
     long long count = 0, items = hashTypeLength(o);
 
     hi = hashTypeInitIterator(o);
-    while (hashTypeNext(hi) != REDIS_ERR) {
+    while (hashTypeNext(hi) != C_ERR) {
         if (count == 0) {
-            int cmd_items = (items > REDIS_AOF_REWRITE_ITEMS_PER_CMD) ?
-                REDIS_AOF_REWRITE_ITEMS_PER_CMD : items;
+            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
+                AOF_REWRITE_ITEMS_PER_CMD : items;
 
             if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) return 0;
             if (rioWriteBulkString(r,"HMSET",5) == 0) return 0;
             if (rioWriteBulkObject(r,key) == 0) return 0;
         }
 
-        if (rioWriteHashIteratorCursor(r, hi, REDIS_HASH_KEY) == 0) return 0;
-        if (rioWriteHashIteratorCursor(r, hi, REDIS_HASH_VALUE) == 0) return 0;
-        if (++count == REDIS_AOF_REWRITE_ITEMS_PER_CMD) count = 0;
+        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) return 0;
+        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) return 0;
+        if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
         items--;
     }
 
     hashTypeReleaseIterator(hi);
 
     return 1;
@@ -1013,13 +1004,13 @@
 
 /* Write a sequence of commands able to fully rebuild the dataset into
  * "filename". Used both by REWRITEAOF and BGREWRITEAOF.
  *
  * In order to minimize the number of commands needed in the rewritten
  * log Redis uses variadic commands when possible, such as RPUSH, SADD
- * and ZADD. However at max REDIS_AOF_REWRITE_ITEMS_PER_CMD items per time
+ * and ZADD. However at max AOF_REWRITE_ITEMS_PER_CMD items per time
  * are inserted using a single command. */
 int rewriteAppendOnlyFile(char *filename) {
     dictIterator *di = NULL;
     dictEntry *de;
     rio aof;
     FILE *fp;
@@ -1031,29 +1022,29 @@
 
     /* Note that we have to use a different temp name here compared to the
      * one used by rewriteAppendOnlyFileBackground() function. */
     snprintf(tmpfile,256,"temp-rewriteaof-%d.aof", (int) getpid());
     fp = fopen(tmpfile,"w");
     if (!fp) {
-        redisLog(REDIS_WARNING, "Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s", strerror(errno));
-        return REDIS_ERR;
+        serverLog(LL_WARNING, "Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s", strerror(errno));
+        return C_ERR;
     }
 
     server.aof_child_diff = sdsempty();
     rioInitWithFile(&aof,fp);
     if (server.aof_rewrite_incremental_fsync)
-        rioSetAutoSync(&aof,REDIS_AOF_AUTOSYNC_BYTES);
+        rioSetAutoSync(&aof,AOF_AUTOSYNC_BYTES);
     for (j = 0; j < server.dbnum; j++) {
         char selectcmd[] = "*2\r\n$6\r\nSELECT\r\n";
         redisDb *db = server.db+j;
         dict *d = db->dict;
         if (dictSize(d) == 0) continue;
         di = dictGetSafeIterator(d);
         if (!di) {
             fclose(fp);
-            return REDIS_ERR;
+            return C_ERR;
         }
 
         /* SELECT the new DB */
         if (rioWrite(&aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
         if (rioWriteBulkLongLong(&aof,j) == 0) goto werr;
 
@@ -1070,29 +1061,29 @@
             expiretime = getExpire(db,&key);
 
             /* If this key is already expired skip it */
             if (expiretime != -1 && expiretime < now) continue;
 
             /* Save the key and associated value */
-            if (o->type == REDIS_STRING) {
+            if (o->type == OBJ_STRING) {
                 /* Emit a SET command */
                 char cmd[]="*3\r\n$3\r\nSET\r\n";
                 if (rioWrite(&aof,cmd,sizeof(cmd)-1) == 0) goto werr;
                 /* Key and value */
                 if (rioWriteBulkObject(&aof,&key) == 0) goto werr;
                 if (rioWriteBulkObject(&aof,o) == 0) goto werr;
-            } else if (o->type == REDIS_LIST) {
+            } else if (o->type == OBJ_LIST) {
                 if (rewriteListObject(&aof,&key,o) == 0) goto werr;
-            } else if (o->type == REDIS_SET) {
+            } else if (o->type == OBJ_SET) {
                 if (rewriteSetObject(&aof,&key,o) == 0) goto werr;
-            } else if (o->type == REDIS_ZSET) {
+            } else if (o->type == OBJ_ZSET) {
                 if (rewriteSortedSetObject(&aof,&key,o) == 0) goto werr;
-            } else if (o->type == REDIS_HASH) {
+            } else if (o->type == OBJ_HASH) {
                 if (rewriteHashObject(&aof,&key,o) == 0) goto werr;
             } else {
-                redisPanic("Unknown object type");
+                serverPanic("Unknown object type");
             }
             /* Save the expire time */
             if (expiretime != -1) {
                 char cmd[]="*3\r\n$9\r\nPEXPIREAT\r\n";
                 if (rioWrite(&aof,cmd,sizeof(cmd)-1) == 0) goto werr;
                 if (rioWriteBulkObject(&aof,&key) == 0) goto werr;
@@ -1138,19 +1129,19 @@
         goto werr;
     /* We read the ACK from the server using a 10 seconds timeout. Normally
      * it should reply ASAP, but just in case we lose its reply, we are sure
      * the child will eventually get terminated. */
     if (syncRead(server.aof_pipe_read_ack_from_parent,&byte,1,5000) != 1 ||
         byte != '!') goto werr;
-    redisLog(REDIS_NOTICE,"Parent agreed to stop sending diffs. Finalizing AOF...");
+    serverLog(LL_NOTICE,"Parent agreed to stop sending diffs. Finalizing AOF...");
 
     /* Read the final diff if any. */
     aofReadDiffFromParent();
 
     /* Write the received diff to the file. */
-    redisLog(REDIS_NOTICE,
+    serverLog(LL_NOTICE,
         "Concatenating %.2f MB of AOF diff received from parent.",
         (double) sdslen(server.aof_child_diff) / (1024*1024));
     if (rioWrite(&aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == 0)
         goto werr;
 
     /* Make sure data will not remain on the OS's output buffers */
@@ -1158,49 +1149,49 @@
     if (fsync(fileno(fp)) == -1) goto werr;
     if (fclose(fp) == EOF) goto werr;
 
     /* Use RENAME to make sure the DB file is changed atomically only
      * if the generate DB file is ok. */
     if (rename(tmpfile,filename) == -1) {
-        redisLog(REDIS_WARNING,"Error moving temp append only file on the final destination: %s", strerror(errno));
+        serverLog(LL_WARNING,"Error moving temp append only file on the final destination: %s", strerror(errno));
         unlink(tmpfile);
-        return REDIS_ERR;
+        return C_ERR;
     }
-    redisLog(REDIS_NOTICE,"SYNC append only file rewrite performed");
-    return REDIS_OK;
+    serverLog(LL_NOTICE,"SYNC append only file rewrite performed");
+    return C_OK;
 
 werr:
-    redisLog(REDIS_WARNING,"Write error writing append only file on disk: %s", strerror(errno));
+    serverLog(LL_WARNING,"Write error writing append only file on disk: %s", strerror(errno));
     fclose(fp);
     unlink(tmpfile);
     if (di) dictReleaseIterator(di);
-    return REDIS_ERR;
+    return C_ERR;
 }
 
 /* ----------------------------------------------------------------------------
  * AOF rewrite pipes for IPC
  * -------------------------------------------------------------------------- */
 
 /* This event handler is called when the AOF rewriting child sends us a
  * single '!' char to signal we should stop sending buffer diffs. The
  * parent sends a '!' as well to acknowledge. */
 void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
     char byte;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(privdata);
-    REDIS_NOTUSED(mask);
+    UNUSED(el);
+    UNUSED(privdata);
+    UNUSED(mask);
 
     if (read(fd,&byte,1) == 1 && byte == '!') {
-        redisLog(REDIS_NOTICE,"AOF rewrite child asks to stop sending diffs.");
+        serverLog(LL_NOTICE,"AOF rewrite child asks to stop sending diffs.");
         server.aof_stop_sending_diff = 1;
         if (write(server.aof_pipe_write_ack_to_child,"!",1) != 1) {
             /* If we can't send the ack, inform the user, but don't try again
              * since in the other side the children will use a timeout if the
              * kernel can't buffer our write, or, the children was
              * terminated. */
-            redisLog(REDIS_WARNING,"Can't send ACK to AOF child: %s",
+            serverLog(LL_WARNING,"Can't send ACK to AOF child: %s",
                 strerror(errno));
         }
     }
     /* Remove the handler since this can be called only one time during a
      * rewrite. */
     aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
@@ -1227,19 +1218,19 @@
     server.aof_pipe_read_data_from_parent = fds[0];
     server.aof_pipe_write_ack_to_parent = fds[3];
     server.aof_pipe_read_ack_from_child = fds[2];
     server.aof_pipe_write_ack_to_child = fds[5];
     server.aof_pipe_read_ack_from_parent = fds[4];
     server.aof_stop_sending_diff = 0;
-    return REDIS_OK;
+    return C_OK;
 
 error:
-    redisLog(REDIS_WARNING,"Error opening /setting AOF rewrite IPC pipes: %s",
+    serverLog(LL_WARNING,"Error opening /setting AOF rewrite IPC pipes: %s",
         strerror(errno));
     for (j = 0; j < 6; j++) if(fds[j] != -1) close(fds[j]);
-    return REDIS_ERR;
+    return C_ERR;
 }
 
 void aofClosePipes(void) {
     aeDeleteFileEvent(server.el,server.aof_pipe_read_ack_from_child,AE_READABLE);
     aeDeleteFileEvent(server.el,server.aof_pipe_write_data_to_child,AE_WRITABLE);
     close(server.aof_pipe_write_data_to_child);
@@ -1267,27 +1258,27 @@
  *    The the new file is reopened as the new append only file. Profit!
  */
 int rewriteAppendOnlyFileBackground(void) {
     pid_t childpid;
     long long start;
 
-    if (server.aof_child_pid != -1) return REDIS_ERR;
-    if (aofCreatePipes() != REDIS_OK) return REDIS_ERR;
+    if (server.aof_child_pid != -1) return C_ERR;
+    if (aofCreatePipes() != C_OK) return C_ERR;
     start = ustime();
     if ((childpid = fork()) == 0) {
         char tmpfile[256];
 
         /* Child */
         closeListeningSockets(0);
         redisSetProcTitle("redis-aof-rewrite");
         snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) getpid());
-        if (rewriteAppendOnlyFile(tmpfile) == REDIS_OK) {
+        if (rewriteAppendOnlyFile(tmpfile) == C_OK) {
             size_t private_dirty = zmalloc_get_private_dirty();
 
             if (private_dirty) {
-                redisLog(REDIS_NOTICE,
+                serverLog(LL_NOTICE,
                     "AOF rewrite: %zu MB of memory used by copy-on-write",
                     private_dirty/(1024*1024));
             }
             exitFromChild(0);
         } else {
             exitFromChild(1);
@@ -1295,41 +1286,41 @@
     } else {
         /* Parent */
         server.stat_fork_time = ustime()-start;
         server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */
         latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
         if (childpid == -1) {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "Can't rewrite append only file in background: fork: %s",
                 strerror(errno));
-            return REDIS_ERR;
+            return C_ERR;
         }
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Background append only file rewriting started by pid %d",childpid);
         server.aof_rewrite_scheduled = 0;
         server.aof_rewrite_time_start = time(NULL);
         server.aof_child_pid = childpid;
         updateDictResizePolicy();
         /* We set appendseldb to -1 in order to force the next call to the
          * feedAppendOnlyFile() to issue a SELECT command, so the differences
          * accumulated by the parent into server.aof_rewrite_buf will start
          * with a SELECT statement and it will be safe to merge. */
         server.aof_selected_db = -1;
         replicationScriptCacheFlush();
-        return REDIS_OK;
+        return C_OK;
     }
-    return REDIS_OK; /* unreached */
+    return C_OK; /* unreached */
 }
 
-void bgrewriteaofCommand(redisClient *c) {
+void bgrewriteaofCommand(client *c) {
     if (server.aof_child_pid != -1) {
         addReplyError(c,"Background append only file rewriting already in progress");
     } else if (server.rdb_child_pid != -1) {
         server.aof_rewrite_scheduled = 1;
         addReplyStatus(c,"Background append only file rewriting scheduled");
-    } else if (rewriteAppendOnlyFileBackground() == REDIS_OK) {
+    } else if (rewriteAppendOnlyFileBackground() == C_OK) {
         addReplyStatus(c,"Background append only file rewriting started");
     } else {
         addReply(c,shared.err);
     }
 }
 
@@ -1347,13 +1338,13 @@
 void aofUpdateCurrentSize(void) {
     struct redis_stat sb;
     mstime_t latency;
 
     latencyStartMonitor(latency);
     if (redis_fstat(server.aof_fd,&sb) == -1) {
-        redisLog(REDIS_WARNING,"Unable to obtain the AOF file length. stat: %s",
+        serverLog(LL_WARNING,"Unable to obtain the AOF file length. stat: %s",
             strerror(errno));
     } else {
         server.aof_current_size = sb.st_size;
     }
     latencyEndMonitor(latency);
     latencyAddSampleIfNeeded("aof-fstat",latency);
@@ -1365,37 +1356,37 @@
     if (!bysignal && exitcode == 0) {
         int newfd, oldfd;
         char tmpfile[256];
         long long now = ustime();
         mstime_t latency;
 
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Background AOF rewrite terminated with success");
 
         /* Flush the differences accumulated by the parent to the
          * rewritten AOF. */
         latencyStartMonitor(latency);
         snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof",
             (int)server.aof_child_pid);
         newfd = open(tmpfile,O_WRONLY|O_APPEND);
         if (newfd == -1) {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "Unable to open the temporary AOF produced by the child: %s", strerror(errno));
             goto cleanup;
         }
 
         if (aofRewriteBufferWrite(newfd) == -1) {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "Error trying to flush the parent diff to the rewritten AOF: %s", strerror(errno));
             close(newfd);
             goto cleanup;
         }
         latencyEndMonitor(latency);
         latencyAddSampleIfNeeded("aof-rewrite-diff-write",latency);
 
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Residual parent diff successfully flushed to the rewritten AOF (%.2f MB)", (double) aofRewriteBufferSize() / (1024*1024));
 
         /* The only remaining thing to do is to rename the temporary file to
          * the configured file and switch the file descriptor used to do AOF
          * writes. We don't want close(2) or rename(2) calls to block the
          * server on old file deletion.
@@ -1435,14 +1426,17 @@
         }
 
         /* Rename the temporary file. This will not unlink the target file if
          * it exists, because we reference it with "oldfd". */
         latencyStartMonitor(latency);
         if (rename(tmpfile,server.aof_filename) == -1) {
-            redisLog(REDIS_WARNING,
-                "Error trying to rename the temporary AOF file: %s", strerror(errno));
+            serverLog(LL_WARNING,
+                "Error trying to rename the temporary AOF file %s into %s: %s",
+                tmpfile,
+                server.aof_filename,
+                strerror(errno));
             close(newfd);
             if (oldfd != -1) close(oldfd);
             goto cleanup;
         }
         latencyEndMonitor(latency);
         latencyAddSampleIfNeeded("aof-rename",latency);
@@ -1466,41 +1460,43 @@
             /* Clear regular AOF buffer since its contents was just written to
              * the new AOF from the background rewrite buffer. */
             sdsfree(server.aof_buf);
             server.aof_buf = sdsempty();
         }
 
-        server.aof_lastbgrewrite_status = REDIS_OK;
+        server.aof_lastbgrewrite_status = C_OK;
 
-        redisLog(REDIS_NOTICE, "Background AOF rewrite finished successfully");
+        serverLog(LL_NOTICE, "Background AOF rewrite finished successfully");
         /* Change state from WAIT_REWRITE to ON if needed */
-        if (server.aof_state == REDIS_AOF_WAIT_REWRITE)
-            server.aof_state = REDIS_AOF_ON;
+        if (server.aof_state == AOF_WAIT_REWRITE)
+            server.aof_state = AOF_ON;
 
         /* Asynchronously close the overwritten AOF. */
-        if (oldfd != -1) bioCreateBackgroundJob(REDIS_BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);
+        if (oldfd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)oldfd,NULL,NULL);
 
-        redisLog(REDIS_VERBOSE,
+        serverLog(LL_VERBOSE,
             "Background AOF rewrite signal handler took %lldus", ustime()-now);
     } else if (!bysignal && exitcode != 0) {
-        server.aof_lastbgrewrite_status = REDIS_ERR;
-
-        redisLog(REDIS_WARNING,
+        /* SIGUSR1 is whitelisted, so we have a way to kill a child without
+         * tirggering an error conditon. */
+        if (bysignal != SIGUSR1)
+            server.aof_lastbgrewrite_status = C_ERR;
+        serverLog(LL_WARNING,
             "Background AOF rewrite terminated with error");
     } else {
-        server.aof_lastbgrewrite_status = REDIS_ERR;
+        server.aof_lastbgrewrite_status = C_ERR;
 
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Background AOF rewrite terminated by signal %d", bysignal);
     }
 
 cleanup:
     aofClosePipes();
     aofRewriteBufferReset();
     aofRemoveTempFile(server.aof_child_pid);
     server.aof_child_pid = -1;
     server.aof_rewrite_time_last = time(NULL)-server.aof_rewrite_time_start;
     server.aof_rewrite_time_start = -1;
     /* Schedule a new rewrite if we are waiting for it to switch the AOF ON. */
-    if (server.aof_state == REDIS_AOF_WAIT_REWRITE)
+    if (server.aof_state == AOF_WAIT_REWRITE)
         server.aof_rewrite_scheduled = 1;
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/aof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/aof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/aof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/aof.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.c	2016-05-06 15:11:36.000000000 +0800
@@ -55,26 +55,26 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 
-#include "redis.h"
+#include "server.h"
 #include "bio.h"
 
-static pthread_t bio_threads[REDIS_BIO_NUM_OPS];
-static pthread_mutex_t bio_mutex[REDIS_BIO_NUM_OPS];
-static pthread_cond_t bio_condvar[REDIS_BIO_NUM_OPS];
-static list *bio_jobs[REDIS_BIO_NUM_OPS];
+static pthread_t bio_threads[BIO_NUM_OPS];
+static pthread_mutex_t bio_mutex[BIO_NUM_OPS];
+static pthread_cond_t bio_condvar[BIO_NUM_OPS];
+static list *bio_jobs[BIO_NUM_OPS];
 /* The following array is used to hold the number of pending jobs for every
  * OP type. This allows us to export the bioPendingJobsOfType() API that is
  * useful when the main thread wants to perform some operation that may involve
  * objects shared with the background thread. The main thread will just wait
  * that there are no longer jobs of this type to be executed before performing
  * the sensible operation. This data is also useful for reporting. */
-static unsigned long long bio_pending[REDIS_BIO_NUM_OPS];
+static unsigned long long bio_pending[BIO_NUM_OPS];
 
 /* This structure represents a background Job. It is only used locally to this
  * file as the API does not expose the internals at all. */
 struct bio_job {
     time_t time; /* Time at which the job was created. */
     /* Job specific arguments pointers. If we need to pass more than three
@@ -93,13 +93,13 @@
     pthread_attr_t attr;
     pthread_t thread;
     size_t stacksize;
     int j;
 
     /* Initialization of state vars and objects */
-    for (j = 0; j < REDIS_BIO_NUM_OPS; j++) {
+    for (j = 0; j < BIO_NUM_OPS; j++) {
         pthread_mutex_init(&bio_mutex[j],NULL);
         pthread_cond_init(&bio_condvar[j],NULL);
         bio_jobs[j] = listCreate();
         bio_pending[j] = 0;
     }
 
@@ -110,16 +110,16 @@
     while (stacksize < REDIS_THREAD_STACK_SIZE) stacksize *= 2;
     pthread_attr_setstacksize(&attr, stacksize);
 
     /* Ready to spawn our threads. We use the single argument the thread
      * function accepts in order to pass the job ID the thread is
      * responsible of. */
-    for (j = 0; j < REDIS_BIO_NUM_OPS; j++) {
+    for (j = 0; j < BIO_NUM_OPS; j++) {
         void *arg = (void*)(unsigned long) j;
         if (pthread_create(&thread,&attr,bioProcessBackgroundJobs,arg) != 0) {
-            redisLog(REDIS_WARNING,"Fatal: Can't initialize Background Jobs.");
+            serverLog(LL_WARNING,"Fatal: Can't initialize Background Jobs.");
             exit(1);
         }
         bio_threads[j] = thread;
     }
 }
 
@@ -139,24 +139,31 @@
 
 void *bioProcessBackgroundJobs(void *arg) {
     struct bio_job *job;
     unsigned long type = (unsigned long) arg;
     sigset_t sigset;
 
+    /* Check that the type is within the right interval. */
+    if (type >= BIO_NUM_OPS) {
+        serverLog(LL_WARNING,
+            "Warning: bio thread started with wrong type %lu",type);
+        return NULL;
+    }
+
     /* Make the thread killable at any time, so that bioKillThreads()
      * can work reliably. */
     pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
     pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
 
     pthread_mutex_lock(&bio_mutex[type]);
     /* Block SIGALRM so we are sure that only the main thread will
      * receive the watchdog signal. */
     sigemptyset(&sigset);
     sigaddset(&sigset, SIGALRM);
     if (pthread_sigmask(SIG_BLOCK, &sigset, NULL))
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Warning: can't mask SIGALRM in bio.c thread: %s", strerror(errno));
 
     while(1) {
         listNode *ln;
 
         /* The loop always starts with the lock hold. */
@@ -169,18 +176,18 @@
         job = ln->value;
         /* It is now possible to unlock the background system as we know have
          * a stand alone job structure to process.*/
         pthread_mutex_unlock(&bio_mutex[type]);
 
         /* Process the job accordingly to its type. */
-        if (type == REDIS_BIO_CLOSE_FILE) {
+        if (type == BIO_CLOSE_FILE) {
             close((long)job->arg1);
-        } else if (type == REDIS_BIO_AOF_FSYNC) {
+        } else if (type == BIO_AOF_FSYNC) {
             aof_fsync((long)job->arg1);
         } else {
-            redisPanic("Wrong job type in bioProcessBackgroundJobs().");
+            serverPanic("Wrong job type in bioProcessBackgroundJobs().");
         }
         zfree(job);
 
         /* Lock again before reiterating the loop, if there are no longer
          * jobs to process we'll block again in pthread_cond_wait(). */
         pthread_mutex_lock(&bio_mutex[type]);
@@ -202,19 +209,19 @@
  * used only when it's critical to stop the threads for some reason.
  * Currently Redis does this only on crash (for instance on SIGSEGV) in order
  * to perform a fast memory check without other threads messing with memory. */
 void bioKillThreads(void) {
     int err, j;
 
-    for (j = 0; j < REDIS_BIO_NUM_OPS; j++) {
+    for (j = 0; j < BIO_NUM_OPS; j++) {
         if (pthread_cancel(bio_threads[j]) == 0) {
             if ((err = pthread_join(bio_threads[j],NULL)) != 0) {
-                redisLog(REDIS_WARNING,
+                serverLog(LL_WARNING,
                     "Bio thread for job type #%d can be joined: %s",
                         j, strerror(err));
             } else {
-                redisLog(REDIS_WARNING,
+                serverLog(LL_WARNING,
                     "Bio thread for job type #%d terminated",j);
             }
         }
     }
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.h	2016-05-06 15:11:36.000000000 +0800
@@ -33,9 +33,9 @@
 unsigned long long bioPendingJobsOfType(int type);
 void bioWaitPendingJobsLE(int type, unsigned long long num);
 time_t bioOlderJobOfType(int type);
 void bioKillThreads(void);
 
 /* Background job opcodes */
-#define REDIS_BIO_CLOSE_FILE    0 /* Deferred close(2) syscall. */
-#define REDIS_BIO_AOF_FSYNC     1 /* Deferred AOF fsync. */
-#define REDIS_BIO_NUM_OPS       2
+#define BIO_CLOSE_FILE    0 /* Deferred close(2) syscall. */
+#define BIO_AOF_FSYNC     1 /* Deferred AOF fsync. */
+#define BIO_NUM_OPS       2
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bitops.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bitops.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bitops.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bitops.c	2016-05-06 15:11:36.000000000 +0800
@@ -25,39 +25,18 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 /* -----------------------------------------------------------------------------
  * Helpers and low level bit functions.
  * -------------------------------------------------------------------------- */
 
-/* This helper function used by GETBIT / SETBIT parses the bit offset argument
- * making sure an error is returned if it is negative or if it overflows
- * Redis 512 MB limit for the string value. */
-static int getBitOffsetFromArgument(redisClient *c, robj *o, size_t *offset) {
-    long long loffset;
-    char *err = "bit offset is not an integer or out of range";
-
-    if (getLongLongFromObjectOrReply(c,o,&loffset,err) != REDIS_OK)
-        return REDIS_ERR;
-
-    /* Limit offset to 512MB in bytes */
-    if ((loffset < 0) || ((unsigned long long)loffset >> 3) >= (512*1024*1024))
-    {
-        addReplyError(c,err);
-        return REDIS_ERR;
-    }
-
-    *offset = (size_t)loffset;
-    return REDIS_OK;
-}
-
 /* Count number of bits set in the binary array pointed by 's' and long
  * 'count' bytes. The implementation of this function is required to
  * work with a input string length up to 512 MB. */
 size_t redisPopcount(void *s, long count) {
     size_t bits = 0;
     unsigned char *p = s;
@@ -192,87 +171,366 @@
         pos++;
         one >>= 1;
     }
 
     /* If we reached this point, there is a bug in the algorithm, since
      * the case of no match is handled as a special case before. */
-    redisPanic("End of redisBitpos() reached.");
+    serverPanic("End of redisBitpos() reached.");
     return 0; /* Just to avoid warnings. */
 }
 
+/* The following set.*Bitfield and get.*Bitfield functions implement setting
+ * and getting arbitrary size (up to 64 bits) signed and unsigned integers
+ * at arbitrary positions into a bitmap.
+ *
+ * The representation considers the bitmap as having the bit number 0 to be
+ * the most significant bit of the first byte, and so forth, so for example
+ * setting a 5 bits unsigned integer to value 23 at offset 7 into a bitmap
+ * previously set to all zeroes, will produce the following representation:
+ *
+ * +--------+--------+
+ * |00000001|01110000|
+ * +--------+--------+
+ *
+ * When offsets and integer sizes are aligned to bytes boundaries, this is the
+ * same as big endian, however when such alignment does not exist, its important
+ * to also understand how the bits inside a byte are ordered.
+ *
+ * Note that this format follows the same convention as SETBIT and related
+ * commands.
+ */
+
+void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {
+    uint64_t byte, bit, byteval, bitval, j;
+
+    for (j = 0; j < bits; j++) {
+        bitval = (value & ((uint64_t)1<<(bits-1-j))) != 0;
+        byte = offset >> 3;
+        bit = 7 - (offset & 0x7);
+        byteval = p[byte];
+        byteval &= ~(1 << bit);
+        byteval |= bitval << bit;
+        p[byte] = byteval & 0xff;
+        offset++;
+    }
+}
+
+void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {
+    uint64_t uv;
+
+    if (value >= 0)
+        uv = value;
+    else
+        uv = UINT64_MAX + value + 1;
+    setUnsignedBitfield(p,offset,bits,uv);
+}
+
+uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
+    uint64_t byte, bit, byteval, bitval, j, value = 0;
+
+    for (j = 0; j < bits; j++) {
+        byte = offset >> 3;
+        bit = 7 - (offset & 0x7);
+        byteval = p[byte];
+        bitval = (byteval >> bit) & 1;
+        value = (value<<1) | bitval;
+        offset++;
+    }
+    return value;
+}
+
+int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
+    int64_t value = getUnsignedBitfield(p,offset,bits);
+    /* If the top significant bit is 1, propagate it to all the
+     * higher bits for two complement representation of signed
+     * integers. */
+    if (value & ((uint64_t)1 << (bits-1)))
+        value |= ((uint64_t)-1) << bits;
+    return value;
+}
+
+/* The following two functions detect overflow of a value in the context
+ * of storing it as an unsigned or signed integer with the specified
+ * number of bits. The functions both take the value and a possible increment.
+ * If no overflow could happen and the value+increment fit inside the limits,
+ * then zero is returned, otherwise in case of overflow, 1 is returned,
+ * otherwise in case of underflow, -1 is returned.
+ *
+ * When non-zero is returned (oferflow or underflow), if not NULL, *limit is
+ * set to the value the operation should result when an overflow happens,
+ * depending on the specified overflow semantics:
+ *
+ * For BFOVERFLOW_SAT if 1 is returned, *limit it is set maximum value that
+ * you can store in that integer. when -1 is returned, *limit is set to the
+ * minimum value that an integer of that size can represent.
+ *
+ * For BFOVERFLOW_WRAP *limit is set by performing the operation in order to
+ * "wrap" around towards zero for unsigned integers, or towards the most
+ * negative number that is possible to represent for signed integers. */
+
+#define BFOVERFLOW_WRAP 0
+#define BFOVERFLOW_SAT 1
+#define BFOVERFLOW_FAIL 2 /* Used by the BITFIELD command implementation. */
+
+int checkUnsignedBitfieldOverflow(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit) {
+    uint64_t max = (bits == 64) ? UINT64_MAX : (((uint64_t)1<<bits)-1);
+    int64_t maxincr = max-value;
+    int64_t minincr = -value;
+
+    if (value > max || (incr > 0 && incr > maxincr)) {
+        if (limit) {
+            if (owtype == BFOVERFLOW_WRAP) {
+                goto handle_wrap;
+            } else if (owtype == BFOVERFLOW_SAT) {
+                *limit = max;
+            }
+        }
+        return 1;
+    } else if (incr < 0 && incr < minincr) {
+        if (limit) {
+            if (owtype == BFOVERFLOW_WRAP) {
+                goto handle_wrap;
+            } else if (owtype == BFOVERFLOW_SAT) {
+                *limit = 0;
+            }
+        }
+        return -1;
+    }
+    return 0;
+
+handle_wrap:
+    {
+        uint64_t mask = ((int64_t)-1) << bits;
+        uint64_t res = value+incr;
+
+        res &= ~mask;
+        *limit = res;
+    }
+    return 1;
+}
+
+int checkSignedBitfieldOverflow(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit) {
+    int64_t max = (bits == 64) ? INT64_MAX : (((int64_t)1<<(bits-1))-1);
+    int64_t min = (-max)-1;
+
+    /* Note that maxincr and minincr could overflow, but we use the values
+     * only after checking 'value' range, so when we use it no overflow
+     * happens. */
+    int64_t maxincr = max-value;
+    int64_t minincr = min-value;
+
+    if (value > max || (bits != 64 && incr > maxincr) || (value >= 0 && incr > 0 && incr > maxincr))
+    {
+        if (limit) {
+            if (owtype == BFOVERFLOW_WRAP) {
+                goto handle_wrap;
+            } else if (owtype == BFOVERFLOW_SAT) {
+                *limit = max;
+            }
+        }
+        return 1;
+    } else if (value < min || (bits != 64 && incr < minincr) || (value < 0 && incr < 0 && incr < minincr)) {
+        if (limit) {
+            if (owtype == BFOVERFLOW_WRAP) {
+                goto handle_wrap;
+            } else if (owtype == BFOVERFLOW_SAT) {
+                *limit = min;
+            }
+        }
+        return -1;
+    }
+    return 0;
+
+handle_wrap:
+    {
+        uint64_t mask = ((int64_t)-1) << bits;
+        uint64_t msb = (uint64_t)1 << (bits-1);
+        uint64_t a = value, b = incr, c;
+        c = a+b; /* Perform addition as unsigned so that's defined. */
+
+        /* If the sign bit is set, propagate to all the higher order
+         * bits, to cap the negative value. If it's clear, mask to
+         * the positive integer limit. */
+        if (c & msb) {
+            c |= mask;
+        } else {
+            c &= ~mask;
+        }
+        *limit = c;
+    }
+    return 1;
+}
+
+/* Debugging function. Just show bits in the specified bitmap. Not used
+ * but here for not having to rewrite it when debugging is needed. */
+void printBits(unsigned char *p, unsigned long count) {
+    unsigned long j, i, byte;
+
+    for (j = 0; j < count; j++) {
+        byte = p[j];
+        for (i = 0x80; i > 0; i /= 2)
+            printf("%c", (byte & i) ? '1' : '0');
+        printf("|");
+    }
+    printf("\n");
+}
+
 /* -----------------------------------------------------------------------------
  * Bits related string commands: GETBIT, SETBIT, BITCOUNT, BITOP.
  * -------------------------------------------------------------------------- */
 
 #define BITOP_AND   0
 #define BITOP_OR    1
 #define BITOP_XOR   2
 #define BITOP_NOT   3
 
+#define BITFIELDOP_GET 0
+#define BITFIELDOP_SET 1
+#define BITFIELDOP_INCRBY 2
+
+/* This helper function used by GETBIT / SETBIT parses the bit offset argument
+ * making sure an error is returned if it is negative or if it overflows
+ * Redis 512 MB limit for the string value.
+ *
+ * If the 'hash' argument is true, and 'bits is positive, then the command
+ * will also parse bit offsets prefixed by "#". In such a case the offset
+ * is multiplied by 'bits'. This is useful for the BITFIELD command. */
+int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int bits) {
+    long long loffset;
+    char *err = "bit offset is not an integer or out of range";
+    char *p = o->ptr;
+    size_t plen = sdslen(p);
+    int usehash = 0;
+
+    /* Handle #<offset> form. */
+    if (p[0] == '#' && hash && bits > 0) usehash = 1;
+
+    if (string2ll(p+usehash,plen-usehash,&loffset) == 0) {
+        addReplyError(c,err);
+        return C_ERR;
+    }
+
+    /* Adjust the offset by 'bits' for #<offset> form. */
+    if (usehash) loffset *= bits;
+
+    /* Limit offset to 512MB in bytes */
+    if ((loffset < 0) || ((unsigned long long)loffset >> 3) >= (512*1024*1024))
+    {
+        addReplyError(c,err);
+        return C_ERR;
+    }
+
+    *offset = (size_t)loffset;
+    return C_OK;
+}
+
+/* This helper function for BITFIELD parses a bitfield type in the form
+ * <sign><bits> where sign is 'u' or 'i' for unsigned and signed, and
+ * the bits is a value between 1 and 64. However 64 bits unsigned integers
+ * are reported as an error because of current limitations of Redis protocol
+ * to return unsigned integer values greater than INT64_MAX.
+ *
+ * On error C_ERR is returned and an error is sent to the client. */
+int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {
+    char *p = o->ptr;
+    char *err = "Invalid bitfield type. Use something like i16 u8. Note that u64 is not supported but i64 is.";
+    long long llbits;
+
+    if (p[0] == 'i') {
+        *sign = 1;
+    } else if (p[0] == 'u') {
+        *sign = 0;
+    } else {
+        addReplyError(c,err);
+        return C_ERR;
+    }
+
+    if ((string2ll(p+1,strlen(p+1),&llbits)) == 0 ||
+        llbits < 1 ||
+        (*sign == 1 && llbits > 64) ||
+        (*sign == 0 && llbits > 63))
+    {
+        addReplyError(c,err);
+        return C_ERR;
+    }
+    *bits = llbits;
+    return C_OK;
+}
+
+/* This is an helper function for commands implementations that need to write
+ * bits to a string object. The command creates or pad with zeroes the string
+ * so that the 'maxbit' bit can be addressed. The object is finally
+ * returned. Otherwise if the key holds a wrong type NULL is returned and
+ * an error is sent to the client. */
+robj *lookupStringForBitCommand(client *c, size_t maxbit) {
+    size_t byte = maxbit >> 3;
+    robj *o = lookupKeyWrite(c->db,c->argv[1]);
+
+    if (o == NULL) {
+        o = createObject(OBJ_STRING,sdsnewlen(NULL, byte+1));
+        dbAdd(c->db,c->argv[1],o);
+    } else {
+        if (checkType(c,o,OBJ_STRING)) return NULL;
+        o = dbUnshareStringValue(c->db,c->argv[1],o);
+        o->ptr = sdsgrowzero(o->ptr,byte+1);
+    }
+    return o;
+}
+
 /* SETBIT key offset bitvalue */
-void setbitCommand(redisClient *c) {
+void setbitCommand(client *c) {
     robj *o;
     char *err = "bit is not an integer or out of range";
     size_t bitoffset;
-    int byte, bit;
+    ssize_t byte, bit;
     int byteval, bitval;
     long on;
 
-    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset) != REDIS_OK)
+    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
         return;
 
-    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != REDIS_OK)
+    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK)
         return;
 
     /* Bits can only be set or cleared... */
     if (on & ~1) {
         addReplyError(c,err);
         return;
     }
 
-    o = lookupKeyWrite(c->db,c->argv[1]);
-    if (o == NULL) {
-        o = createObject(REDIS_STRING,sdsempty());
-        dbAdd(c->db,c->argv[1],o);
-    } else {
-        if (checkType(c,o,REDIS_STRING)) return;
-        o = dbUnshareStringValue(c->db,c->argv[1],o);
-    }
-
-    /* Grow sds value to the right length if necessary */
-    byte = bitoffset >> 3;
-    o->ptr = sdsgrowzero(o->ptr,byte+1);
+    if ((o = lookupStringForBitCommand(c,bitoffset)) == NULL) return;
 
     /* Get current values */
+    byte = bitoffset >> 3;
     byteval = ((uint8_t*)o->ptr)[byte];
     bit = 7 - (bitoffset & 0x7);
     bitval = byteval & (1 << bit);
 
     /* Update byte with new bit value and return original value */
     byteval &= ~(1 << bit);
     byteval |= ((on & 0x1) << bit);
     ((uint8_t*)o->ptr)[byte] = byteval;
     signalModifiedKey(c->db,c->argv[1]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
     server.dirty++;
     addReply(c, bitval ? shared.cone : shared.czero);
 }
 
 /* GETBIT key offset */
-void getbitCommand(redisClient *c) {
+void getbitCommand(client *c) {
     robj *o;
     char llbuf[32];
     size_t bitoffset;
     size_t byte, bit;
     size_t bitval = 0;
 
-    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset) != REDIS_OK)
+    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
         return;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,REDIS_STRING)) return;
+        checkType(c,o,OBJ_STRING)) return;
 
     byte = bitoffset >> 3;
     bit = 7 - (bitoffset & 0x7);
     if (sdsEncodedObject(o)) {
         if (byte < sdslen(o->ptr))
             bitval = ((uint8_t*)o->ptr)[byte] & (1 << bit);
@@ -282,13 +540,13 @@
     }
 
     addReply(c, bitval ? shared.cone : shared.czero);
 }
 
 /* BITOP op_name target_key src_key1 src_key2 src_key3 ... src_keyN */
-void bitopCommand(redisClient *c) {
+void bitopCommand(client *c) {
     char *opname = c->argv[1]->ptr;
     robj *o, *targetkey = c->argv[2];
     unsigned long op, j, numkeys;
     robj **objects;      /* Array of source objects. */
     unsigned char **src; /* Array of source strings pointers. */
     unsigned long *len, maxlen = 0; /* Array of length of src strings,
@@ -329,13 +587,13 @@
             src[j] = NULL;
             len[j] = 0;
             minlen = 0;
             continue;
         }
         /* Return an error if one of the keys is not a string. */
-        if (checkType(c,o,REDIS_STRING)) {
+        if (checkType(c,o,OBJ_STRING)) {
             unsigned long i;
             for (i = 0; i < j; i++) {
                 if (objects[i])
                     decrRefCount(objects[i]);
             }
             zfree(src);
@@ -443,50 +701,50 @@
     zfree(src);
     zfree(len);
     zfree(objects);
 
     /* Store the computed value into the target key */
     if (maxlen) {
-        o = createObject(REDIS_STRING,res);
+        o = createObject(OBJ_STRING,res);
         setKey(c->db,targetkey,o);
-        notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"set",targetkey,c->db->id);
+        notifyKeyspaceEvent(NOTIFY_STRING,"set",targetkey,c->db->id);
         decrRefCount(o);
     } else if (dbDelete(c->db,targetkey)) {
         signalModifiedKey(c->db,targetkey);
-        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",targetkey,c->db->id);
+        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",targetkey,c->db->id);
     }
     server.dirty++;
     addReplyLongLong(c,maxlen); /* Return the output string length in bytes. */
 }
 
 /* BITCOUNT key [start end] */
-void bitcountCommand(redisClient *c) {
+void bitcountCommand(client *c) {
     robj *o;
     long start, end, strlen;
     unsigned char *p;
     char llbuf[32];
 
     /* Lookup, check for type, and return 0 for non existing keys. */
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,REDIS_STRING)) return;
+        checkType(c,o,OBJ_STRING)) return;
 
     /* Set the 'p' pointer to the string, that can be just a stack allocated
      * array if our string was integer encoded. */
-    if (o->encoding == REDIS_ENCODING_INT) {
+    if (o->encoding == OBJ_ENCODING_INT) {
         p = (unsigned char*) llbuf;
         strlen = ll2string(llbuf,sizeof(llbuf),(long)o->ptr);
     } else {
         p = (unsigned char*) o->ptr;
         strlen = sdslen(o->ptr);
     }
 
     /* Parse start/end range if any. */
     if (c->argc == 4) {
-        if (getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != REDIS_OK)
+        if (getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
             return;
-        if (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != REDIS_OK)
+        if (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
             return;
         /* Convert negative indexes */
         if (start < 0) start = strlen+start;
         if (end < 0) end = strlen+end;
         if (start < 0) start = 0;
         if (end < 0) end = 0;
@@ -510,22 +768,22 @@
 
         addReplyLongLong(c,redisPopcount(p+start,bytes));
     }
 }
 
 /* BITPOS key bit [start [end]] */
-void bitposCommand(redisClient *c) {
+void bitposCommand(client *c) {
     robj *o;
     long bit, start, end, strlen;
     unsigned char *p;
     char llbuf[32];
     int end_given = 0;
 
     /* Parse the bit argument to understand what we are looking for, set
      * or clear bits. */
-    if (getLongFromObjectOrReply(c,c->argv[2],&bit,NULL) != REDIS_OK)
+    if (getLongFromObjectOrReply(c,c->argv[2],&bit,NULL) != C_OK)
         return;
     if (bit != 0 && bit != 1) {
         addReplyError(c, "The bit argument must be 1 or 0.");
         return;
     }
 
@@ -533,30 +791,30 @@
      * array of 0 bits. If the user is looking for the fist clear bit return 0,
      * If the user is looking for the first set bit, return -1. */
     if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
         addReplyLongLong(c, bit ? -1 : 0);
         return;
     }
-    if (checkType(c,o,REDIS_STRING)) return;
+    if (checkType(c,o,OBJ_STRING)) return;
 
     /* Set the 'p' pointer to the string, that can be just a stack allocated
      * array if our string was integer encoded. */
-    if (o->encoding == REDIS_ENCODING_INT) {
+    if (o->encoding == OBJ_ENCODING_INT) {
         p = (unsigned char*) llbuf;
         strlen = ll2string(llbuf,sizeof(llbuf),(long)o->ptr);
     } else {
         p = (unsigned char*) o->ptr;
         strlen = sdslen(o->ptr);
     }
 
     /* Parse start/end range if any. */
     if (c->argc == 4 || c->argc == 5) {
-        if (getLongFromObjectOrReply(c,c->argv[3],&start,NULL) != REDIS_OK)
+        if (getLongFromObjectOrReply(c,c->argv[3],&start,NULL) != C_OK)
             return;
         if (c->argc == 5) {
-            if (getLongFromObjectOrReply(c,c->argv[4],&end,NULL) != REDIS_OK)
+            if (getLongFromObjectOrReply(c,c->argv[4],&end,NULL) != C_OK)
                 return;
             end_given = 1;
         } else {
             end = strlen-1;
         }
         /* Convert negative indexes */
@@ -595,6 +853,223 @@
             return;
         }
         if (pos != -1) pos += start*8; /* Adjust for the bytes we skipped. */
         addReplyLongLong(c,pos);
     }
 }
+
+/* BITFIELD key subcommmand-1 arg ... subcommand-2 arg ... subcommand-N ...
+ *
+ * Supported subcommands:
+ *
+ * GET <type> <offset>
+ * SET <type> <offset> <value>
+ * INCRBY <type> <offset> <increment>
+ * OVERFLOW [WRAP|SAT|FAIL]
+ */
+
+struct bitfieldOp {
+    uint64_t offset;    /* Bitfield offset. */
+    int64_t i64;        /* Increment amount (INCRBY) or SET value */
+    int opcode;         /* Operation id. */
+    int owtype;         /* Overflow type to use. */
+    int bits;           /* Integer bitfield bits width. */
+    int sign;           /* True if signed, otherwise unsigned op. */
+};
+
+void bitfieldCommand(client *c) {
+    robj *o;
+    size_t bitoffset;
+    int j, numops = 0, changes = 0;
+    struct bitfieldOp *ops = NULL; /* Array of ops to execute at end. */
+    int owtype = BFOVERFLOW_WRAP; /* Overflow type. */
+
+    for (j = 2; j < c->argc; j++) {
+        int remargs = c->argc-j-1; /* Remaining args other than current. */
+        char *subcmd = c->argv[j]->ptr; /* Current command name. */
+        int opcode; /* Current operation code. */
+        long long i64 = 0;  /* Signed SET value. */
+        int sign = 0; /* Signed or unsigned type? */
+        int bits = 0; /* Bitfield width in bits. */
+
+        if (!strcasecmp(subcmd,"get") && remargs >= 2)
+            opcode = BITFIELDOP_GET;
+        else if (!strcasecmp(subcmd,"set") && remargs >= 3)
+            opcode = BITFIELDOP_SET;
+        else if (!strcasecmp(subcmd,"incrby") && remargs >= 3)
+            opcode = BITFIELDOP_INCRBY;
+        else if (!strcasecmp(subcmd,"overflow") && remargs >= 1) {
+            char *owtypename = c->argv[j+1]->ptr;
+            j++;
+            if (!strcasecmp(owtypename,"wrap"))
+                owtype = BFOVERFLOW_WRAP;
+            else if (!strcasecmp(owtypename,"sat"))
+                owtype = BFOVERFLOW_SAT;
+            else if (!strcasecmp(owtypename,"fail"))
+                owtype = BFOVERFLOW_FAIL;
+            else {
+                addReplyError(c,"Invalid OVERFLOW type specified");
+                zfree(ops);
+                return;
+            }
+            continue;
+        } else {
+            addReply(c,shared.syntaxerr);
+            zfree(ops);
+            return;
+        }
+
+        /* Get the type and offset arguments, common to all the ops. */
+        if (getBitfieldTypeFromArgument(c,c->argv[j+1],&sign,&bits) != C_OK) {
+            zfree(ops);
+            return;
+        }
+
+        if (getBitOffsetFromArgument(c,c->argv[j+2],&bitoffset,1,bits) != C_OK){
+            zfree(ops);
+            return;
+        }
+
+        /* INCRBY and SET require another argument. */
+        if (opcode != BITFIELDOP_GET) {
+            if (getLongLongFromObjectOrReply(c,c->argv[j+3],&i64,NULL) != C_OK){
+                zfree(ops);
+                return;
+            }
+        }
+
+        /* Populate the array of operations we'll process. */
+        ops = zrealloc(ops,sizeof(*ops)*(numops+1));
+        ops[numops].offset = bitoffset;
+        ops[numops].i64 = i64;
+        ops[numops].opcode = opcode;
+        ops[numops].owtype = owtype;
+        ops[numops].bits = bits;
+        ops[numops].sign = sign;
+        numops++;
+
+        j += 3 - (opcode == BITFIELDOP_GET);
+    }
+
+    addReplyMultiBulkLen(c,numops);
+
+    /* Actually process the operations. */
+    for (j = 0; j < numops; j++) {
+        struct bitfieldOp *thisop = ops+j;
+
+        /* Execute the operation. */
+        if (thisop->opcode == BITFIELDOP_SET ||
+            thisop->opcode == BITFIELDOP_INCRBY)
+        {
+            /* SET and INCRBY: We handle both with the same code path
+             * for simplicity. SET return value is the previous value so
+             * we need fetch & store as well. */
+
+            /* Lookup by making room up to the farest bit reached by
+             * this operation. */
+            if ((o = lookupStringForBitCommand(c,
+                thisop->offset + (thisop->bits-1))) == NULL) return;
+
+            /* We need two different but very similar code paths for signed
+             * and unsigned operations, since the set of functions to get/set
+             * the integers and the used variables types are different. */
+            if (thisop->sign) {
+                int64_t oldval, newval, wrapped, retval;
+                int overflow;
+
+                oldval = getSignedBitfield(o->ptr,thisop->offset,
+                        thisop->bits);
+
+                if (thisop->opcode == BITFIELDOP_INCRBY) {
+                    newval = oldval + thisop->i64;
+                    overflow = checkSignedBitfieldOverflow(oldval,
+                            thisop->i64,thisop->bits,thisop->owtype,&wrapped);
+                    if (overflow) newval = wrapped;
+                    retval = newval;
+                } else {
+                    newval = thisop->i64;
+                    overflow = checkSignedBitfieldOverflow(newval,
+                            0,thisop->bits,thisop->owtype,&wrapped);
+                    if (overflow) newval = wrapped;
+                    retval = oldval;
+                }
+
+                /* On overflow of type is "FAIL", don't write and return
+                 * NULL to signal the condition. */
+                if (!(overflow && thisop->owtype == BFOVERFLOW_FAIL)) {
+                    addReplyLongLong(c,retval);
+                    setSignedBitfield(o->ptr,thisop->offset,
+                                      thisop->bits,newval);
+                } else {
+                    addReply(c,shared.nullbulk);
+                }
+            } else {
+                uint64_t oldval, newval, wrapped, retval;
+                int overflow;
+
+                oldval = getUnsignedBitfield(o->ptr,thisop->offset,
+                        thisop->bits);
+
+                if (thisop->opcode == BITFIELDOP_INCRBY) {
+                    newval = oldval + thisop->i64;
+                    overflow = checkUnsignedBitfieldOverflow(oldval,
+                            thisop->i64,thisop->bits,thisop->owtype,&wrapped);
+                    if (overflow) newval = wrapped;
+                    retval = newval;
+                } else {
+                    newval = thisop->i64;
+                    overflow = checkUnsignedBitfieldOverflow(newval,
+                            0,thisop->bits,thisop->owtype,&wrapped);
+                    if (overflow) newval = wrapped;
+                    retval = oldval;
+                }
+                /* On overflow of type is "FAIL", don't write and return
+                 * NULL to signal the condition. */
+                if (!(overflow && thisop->owtype == BFOVERFLOW_FAIL)) {
+                    addReplyLongLong(c,retval);
+                    setUnsignedBitfield(o->ptr,thisop->offset,
+                                        thisop->bits,newval);
+                } else {
+                    addReply(c,shared.nullbulk);
+                }
+            }
+            changes++;
+        } else {
+            /* GET */
+            o = lookupKeyRead(c->db,c->argv[1]);
+            size_t olen = (o == NULL) ? 0 : sdslen(o->ptr);
+            unsigned char buf[9];
+
+            /* For GET we use a trick: before executing the operation
+             * copy up to 9 bytes to a local buffer, so that we can easily
+             * execute up to 64 bit operations that are at actual string
+             * object boundaries. */
+            memset(buf,0,9);
+            unsigned char *src = o ? o->ptr : NULL;
+            int i;
+            size_t byte = thisop->offset >> 3;
+            for (i = 0; i < 9; i++) {
+                if (src == NULL || i+byte >= olen) break;
+                buf[i] = src[i+byte];
+            }
+
+            /* Now operate on the copied buffer which is guaranteed
+             * to be zero-padded. */
+            if (thisop->sign) {
+                int64_t val = getSignedBitfield(buf,thisop->offset-(byte*8),
+                                            thisop->bits);
+                addReplyLongLong(c,val);
+            } else {
+                uint64_t val = getUnsignedBitfield(buf,thisop->offset-(byte*8),
+                                            thisop->bits);
+                addReplyLongLong(c,val);
+            }
+        }
+    }
+
+    if (changes) {
+        signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
+        server.dirty += changes;
+    }
+    zfree(ops);
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bitops.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bitops.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bitops.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bitops.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/blocked.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/blocked.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/blocked.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/blocked.c	2016-05-06 15:11:36.000000000 +0800
@@ -31,23 +31,23 @@
  *
  * API:
  *
  * getTimeoutFromObjectOrReply() is just an utility function to parse a
  * timeout argument since blocking operations usually require a timeout.
  *
- * blockClient() set the REDIS_BLOCKED flag in the client, and set the
- * specified block type 'btype' filed to one of REDIS_BLOCKED_* macros.
+ * blockClient() set the CLIENT_BLOCKED flag in the client, and set the
+ * specified block type 'btype' filed to one of BLOCKED_* macros.
  *
  * unblockClient() unblocks the client doing the following:
  * 1) It calls the btype-specific function to cleanup the state.
- * 2) It unblocks the client by unsetting the REDIS_BLOCKED flag.
+ * 2) It unblocks the client by unsetting the CLIENT_BLOCKED flag.
  * 3) It puts the client into a list of just unblocked clients that are
  *    processed ASAP in the beforeSleep() event loop callback, so that
  *    if there is some query buffer to process, we do it. This is also
  *    required because otherwise there is no 'readable' event fired, we
- *    already read the pending commands. We also set the REDIS_UNBLOCKED
+ *    already read the pending commands. We also set the CLIENT_UNBLOCKED
  *    flag to remember the client is in the unblocked_clients list.
  *
  * processUnblockedClients() is called inside the beforeSleep() function
  * to process the query buffer from unblocked clients and remove the clients
  * from the blocked_clients queue.
  *
@@ -60,103 +60,110 @@
  * should modify unblockClient() and replyToBlockedClientTimedOut() in order
  * to handle the btype-specific behavior of this two functions.
  * If the blocking operation waits for certain keys to change state, the
  * clusterRedirectBlockedClientIfNeeded() function should also be updated.
  */
 
-#include "redis.h"
+#include "server.h"
 
 /* Get a timeout value from an object and store it into 'timeout'.
  * The final timeout is always stored as milliseconds as a time where the
  * timeout will expire, however the parsing is performed according to
  * the 'unit' that can be seconds or milliseconds.
  *
  * Note that if the timeout is zero (usually from the point of view of
  * commands API this means no timeout) the value stored into 'timeout'
  * is zero. */
-int getTimeoutFromObjectOrReply(redisClient *c, robj *object, mstime_t *timeout, int unit) {
+int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit) {
     long long tval;
 
     if (getLongLongFromObjectOrReply(c,object,&tval,
-        "timeout is not an integer or out of range") != REDIS_OK)
-        return REDIS_ERR;
+        "timeout is not an integer or out of range") != C_OK)
+        return C_ERR;
 
     if (tval < 0) {
         addReplyError(c,"timeout is negative");
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     if (tval > 0) {
         if (unit == UNIT_SECONDS) tval *= 1000;
         tval += mstime();
     }
     *timeout = tval;
 
-    return REDIS_OK;
+    return C_OK;
 }
 
-/* Block a client for the specific operation type. Once the REDIS_BLOCKED
+/* Block a client for the specific operation type. Once the CLIENT_BLOCKED
  * flag is set client query buffer is not longer processed, but accumulated,
  * and will be processed when the client is unblocked. */
-void blockClient(redisClient *c, int btype) {
-    c->flags |= REDIS_BLOCKED;
+void blockClient(client *c, int btype) {
+    c->flags |= CLIENT_BLOCKED;
     c->btype = btype;
     server.bpop_blocked_clients++;
 }
 
 /* This function is called in the beforeSleep() function of the event loop
  * in order to process the pending input buffer of clients that were
  * unblocked after a blocking operation. */
 void processUnblockedClients(void) {
     listNode *ln;
-    redisClient *c;
+    client *c;
 
     while (listLength(server.unblocked_clients)) {
         ln = listFirst(server.unblocked_clients);
-        redisAssert(ln != NULL);
+        serverAssert(ln != NULL);
         c = ln->value;
         listDelNode(server.unblocked_clients,ln);
-        c->flags &= ~REDIS_UNBLOCKED;
+        c->flags &= ~CLIENT_UNBLOCKED;
 
-        /* Process remaining data in the input buffer. */
-        if (c->querybuf && sdslen(c->querybuf) > 0) {
-            server.current_client = c;
-            processInputBuffer(c);
-            server.current_client = NULL;
+        /* Process remaining data in the input buffer, unless the client
+         * is blocked again. Actually processInputBuffer() checks that the
+         * client is not blocked before to proceed, but things may change and
+         * the code is conceptually more correct this way. */
+        if (!(c->flags & CLIENT_BLOCKED)) {
+            if (c->querybuf && sdslen(c->querybuf) > 0) {
+                processInputBuffer(c);
+            }
         }
     }
 }
 
 /* Unblock a client calling the right function depending on the kind
  * of operation the client is blocking for. */
-void unblockClient(redisClient *c) {
-    if (c->btype == REDIS_BLOCKED_LIST) {
+void unblockClient(client *c) {
+    if (c->btype == BLOCKED_LIST) {
         unblockClientWaitingData(c);
-    } else if (c->btype == REDIS_BLOCKED_WAIT) {
+    } else if (c->btype == BLOCKED_WAIT) {
         unblockClientWaitingReplicas(c);
     } else {
-        redisPanic("Unknown btype in unblockClient().");
+        serverPanic("Unknown btype in unblockClient().");
     }
     /* Clear the flags, and put the client in the unblocked list so that
      * we'll process new commands in its query buffer ASAP. */
-    c->flags &= ~REDIS_BLOCKED;
-    c->flags |= REDIS_UNBLOCKED;
-    c->btype = REDIS_BLOCKED_NONE;
+    c->flags &= ~CLIENT_BLOCKED;
+    c->btype = BLOCKED_NONE;
     server.bpop_blocked_clients--;
-    listAddNodeTail(server.unblocked_clients,c);
+    /* The client may already be into the unblocked list because of a previous
+     * blocking operation, don't add back it into the list multiple times. */
+    if (!(c->flags & CLIENT_UNBLOCKED)) {
+        c->flags |= CLIENT_UNBLOCKED;
+        listAddNodeTail(server.unblocked_clients,c);
+    }
 }
 
 /* This function gets called when a blocked client timed out in order to
  * send it a reply of some kind. */
-void replyToBlockedClientTimedOut(redisClient *c) {
-    if (c->btype == REDIS_BLOCKED_LIST) {
+void replyToBlockedClientTimedOut(client *c) {
+    if (c->btype == BLOCKED_LIST) {
         addReply(c,shared.nullmultibulk);
-    } else if (c->btype == REDIS_BLOCKED_WAIT) {
+    } else if (c->btype == BLOCKED_WAIT) {
         addReplyLongLong(c,replicationCountAcksByOffset(c->bpop.reploffset));
     } else {
-        redisPanic("Unknown btype in replyToBlockedClientTimedOut().");
+        serverPanic("Unknown btype in replyToBlockedClientTimedOut().");
     }
 }
 
 /* Mass-unblock clients because something changed in the instance that makes
  * blocking no longer safe. For example clients blocked in list operations
  * in an instance which turns from master to slave is unsafe, so this function
@@ -167,17 +174,17 @@
 void disconnectAllBlockedClients(void) {
     listNode *ln;
     listIter li;
 
     listRewind(server.clients,&li);
     while((ln = listNext(&li))) {
-        redisClient *c = listNodeValue(ln);
+        client *c = listNodeValue(ln);
 
-        if (c->flags & REDIS_BLOCKED) {
+        if (c->flags & CLIENT_BLOCKED) {
             addReplySds(c,sdsnew(
                 "-UNBLOCKED force unblock from blocking operation, "
                 "instance state changed (master -> slave?)\r\n"));
             unblockClient(c);
-            c->flags |= REDIS_CLOSE_AFTER_REPLY;
+            c->flags |= CLIENT_CLOSE_AFTER_REPLY;
         }
     }
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/blocked.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/blocked.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/blocked.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/blocked.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/build_ir.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/build_ir.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/build_ir.sh	2017-09-27 22:48:10.630962836 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/build_ir.sh	2017-09-27 22:49:35.694959719 +0800
@@ -11,617 +11,642 @@
 	then
 		succ=`expr $succ + 1`;
 	fi
 	total=`expr $total + 1`;
 }
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/net.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/net.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/net.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/net.c.bc
 check
-echo "1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/net.c to bc" >&2
+echo "1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/net.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/hiredis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/hiredis.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/hiredis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/hiredis.c.bc
 check
-echo "2 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/hiredis.c to bc" >&2
+echo "2 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/hiredis.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.c.bc
 check
-echo "3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.c to bc" >&2
+echo "3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/async.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/async.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/async.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/async.c.bc
 check
-echo "4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/async.c to bc" >&2
+echo "4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/async.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.c.bc
 check
-echo "5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.c to bc" >&2
+echo "5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lapi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lapi.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lapi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lapi.c.bc
 check
-echo "6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lapi.c to bc" >&2
+echo "6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lapi.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lcode.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lcode.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lcode.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lcode.c.bc
 check
-echo "7 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lcode.c to bc" >&2
+echo "7 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lcode.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldebug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldebug.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldebug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldebug.c.bc
 check
-echo "8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldebug.c to bc" >&2
+echo "8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldebug.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldo.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldo.c.bc
 check
-echo "9 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldo.c to bc" >&2
+echo "9 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldo.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldump.c.bc
 check
-echo "10 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldump.c to bc" >&2
+echo "10 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldump.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lfunc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lfunc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lfunc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lfunc.c.bc
 check
-echo "11 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lfunc.c to bc" >&2
+echo "11 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lfunc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lgc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lgc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lgc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lgc.c.bc
 check
-echo "12 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lgc.c to bc" >&2
+echo "12 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lgc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/llex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/llex.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/llex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/llex.c.bc
 check
-echo "13 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/llex.c to bc" >&2
+echo "13 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/llex.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmem.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmem.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmem.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmem.c.bc
 check
-echo "14 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmem.c to bc" >&2
+echo "14 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmem.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lobject.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lobject.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lobject.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lobject.c.bc
 check
-echo "15 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lobject.c to bc" >&2
+echo "15 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lobject.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lopcodes.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lopcodes.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lopcodes.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lopcodes.c.bc
 check
-echo "16 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lopcodes.c to bc" >&2
+echo "16 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lopcodes.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lparser.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lparser.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lparser.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lparser.c.bc
 check
-echo "17 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lparser.c to bc" >&2
+echo "17 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lparser.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstate.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstate.c.bc
 check
-echo "18 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstate.c to bc" >&2
+echo "18 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstate.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstring.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstring.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstring.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstring.c.bc
 check
-echo "19 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstring.c to bc" >&2
+echo "19 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstring.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltable.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltable.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltable.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltable.c.bc
 check
-echo "20 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltable.c to bc" >&2
+echo "20 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltable.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltm.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltm.c.bc
 check
-echo "21 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltm.c to bc" >&2
+echo "21 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltm.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lundump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lundump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lundump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lundump.c.bc
 check
-echo "22 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lundump.c to bc" >&2
+echo "22 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lundump.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lvm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lvm.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lvm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lvm.c.bc
 check
-echo "23 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lvm.c to bc" >&2
+echo "23 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lvm.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lzio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lzio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lzio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lzio.c.bc
 check
-echo "24 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lzio.c to bc" >&2
+echo "24 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lzio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/strbuf.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/strbuf.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/strbuf.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/strbuf.c.bc
 check
-echo "25 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/strbuf.c to bc" >&2
+echo "25 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/strbuf.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/fpconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/fpconv.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/fpconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/fpconv.c.bc
 check
-echo "26 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/fpconv.c to bc" >&2
+echo "26 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/fpconv.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lauxlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lauxlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lauxlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lauxlib.c.bc
 check
-echo "27 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lauxlib.c to bc" >&2
+echo "27 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lauxlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lbaselib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lbaselib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lbaselib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lbaselib.c.bc
 check
-echo "28 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lbaselib.c to bc" >&2
+echo "28 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lbaselib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldblib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldblib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldblib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldblib.c.bc
 check
-echo "29 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldblib.c to bc" >&2
+echo "29 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldblib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/liolib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/liolib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/liolib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/liolib.c.bc
 check
-echo "30 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/liolib.c to bc" >&2
+echo "30 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/liolib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmathlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmathlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmathlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmathlib.c.bc
 check
-echo "31 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmathlib.c to bc" >&2
+echo "31 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmathlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loslib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loslib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loslib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loslib.c.bc
 check
-echo "32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loslib.c to bc" >&2
+echo "32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loslib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltablib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltablib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltablib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltablib.c.bc
 check
-echo "33 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltablib.c to bc" >&2
+echo "33 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltablib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstrlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstrlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstrlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstrlib.c.bc
 check
-echo "34 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstrlib.c to bc" >&2
+echo "34 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstrlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loadlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loadlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loadlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loadlib.c.bc
 check
-echo "35 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loadlib.c to bc" >&2
+echo "35 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loadlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/linit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/linit.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/linit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/linit.c.bc
 check
-echo "36 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/linit.c to bc" >&2
+echo "36 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/linit.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cjson.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cjson.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cjson.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cjson.c.bc
 check
-echo "37 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cjson.c to bc" >&2
+echo "37 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cjson.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_struct.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_struct.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_struct.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_struct.c.bc
 check
-echo "38 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_struct.c to bc" >&2
+echo "38 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_struct.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cmsgpack.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cmsgpack.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cmsgpack.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cmsgpack.c.bc
 check
-echo "39 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cmsgpack.c to bc" >&2
+echo "39 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cmsgpack.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_bit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_bit.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_bit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_bit.c.bc
 check
-echo "40 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_bit.c to bc" >&2
+echo "40 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_bit.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua.c.bc
 check
-echo "41 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua.c to bc" >&2
+echo "41 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/luac.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/luac.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/luac.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/luac.c.bc
 check
-echo "42 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/luac.c to bc" >&2
+echo "42 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/luac.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/print.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/print.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/print.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/print.c.bc
 check
-echo "43 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/print.c to bc" >&2
+echo "43 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/print.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash.c.bc
 check
-echo "44 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c to bc" >&2
+echo "44 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -c /tmp/cgfvTMPi/dummy.c -o /tmp/cgfvTMPi/dummy.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash_helper.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash_helper.c.bc
 check
-echo "45 /tmp/cgfvTMPi/dummy.c to bc" >&2
+echo "45 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash_helper.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c.bc
 check
-echo "46 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.c to bc" >&2
+echo "46 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -c /tmp/cg72vH6G/dummy.c -o /tmp/cg72vH6G/dummy.c.bc
 check
-echo "47 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.c to bc" >&2
+echo "47 /tmp/cg72vH6G/dummy.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.c.bc
 check
-echo "48 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.c to bc" >&2
+echo "48 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.c.bc
 check
-echo "49 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.c to bc" >&2
+echo "49 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.c.bc
 check
-echo "50 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.c to bc" >&2
+echo "50 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.c.bc
 check
-echo "51 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.c to bc" >&2
+echo "51 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.c.bc
 check
-echo "52 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.c to bc" >&2
+echo "52 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.c.bc
 check
-echo "53 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.c to bc" >&2
+echo "53 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.c.bc
 check
-echo "54 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.c to bc" >&2
+echo "54 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.c.bc
 check
-echo "55 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.c to bc" >&2
+echo "55 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.c.bc
 check
-echo "56 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.c to bc" >&2
+echo "56 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.c.bc
 check
-echo "57 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.c to bc" >&2
+echo "57 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.c.bc
 check
-echo "58 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.c to bc" >&2
+echo "58 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.c.bc
 check
-echo "59 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.c to bc" >&2
+echo "59 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.c.bc
 check
-echo "60 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.c to bc" >&2
+echo "60 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.c.bc
 check
-echo "61 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.c to bc" >&2
+echo "61 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.c.bc
 check
-echo "62 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.c to bc" >&2
+echo "62 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/pages.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/pages.c.bc
 check
-echo "63 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.c to bc" >&2
+echo "63 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/pages.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.c.bc
 check
-echo "64 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.c to bc" >&2
+echo "64 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.c.bc
 check
-echo "65 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.c to bc" >&2
+echo "65 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.c.bc
 check
-echo "66 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.c to bc" >&2
+echo "66 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.c.bc
 check
-echo "67 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.c to bc" >&2
+echo "67 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/adlist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/adlist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.c.bc
 check
-echo "68 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/adlist.c to bc" >&2
+echo "68 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.c.bc
 check
-echo "69 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.c to bc" >&2
+echo "69 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.c.bc
 check
-echo "70 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.c to bc" >&2
+echo "70 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/adlist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/adlist.c.bc
 check
-echo "71 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.c to bc" >&2
+echo "71 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/adlist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/quicklist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/quicklist.c.bc
 check
-echo "72 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis.c to bc" >&2
+echo "72 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/quicklist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.c.bc
 check
-echo "73 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.c to bc" >&2
+echo "73 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.c.bc
 check
-echo "74 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.c to bc" >&2
+echo "74 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_c.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_c.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.c.bc
 check
-echo "75 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_c.c to bc" >&2
+echo "75 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_d.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_d.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/server.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/server.c.bc
 check
-echo "76 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_d.c to bc" >&2
+echo "76 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/server.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pqsort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pqsort.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.c.bc
 check
-echo "77 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pqsort.c to bc" >&2
+echo "77 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.c.bc
 check
-echo "78 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.c to bc" >&2
+echo "78 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_c.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_c.c.bc
 check
-echo "79 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.c to bc" >&2
+echo "79 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_c.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_d.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_d.c.bc
 check
-echo "80 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.c to bc" >&2
+echo "80 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_d.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/release.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/release.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pqsort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pqsort.c.bc
 check
-echo "81 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/release.c to bc" >&2
+echo "81 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pqsort.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/networking.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/networking.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.c.bc
 check
-echo "82 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/networking.c to bc" >&2
+echo "82 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.c.bc
 check
-echo "83 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.c to bc" >&2
+echo "83 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/object.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/object.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.c.bc
 check
-echo "84 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/object.c to bc" >&2
+echo "84 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/db.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/db.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/release.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/release.c.bc
 check
-echo "85 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/db.c to bc" >&2
+echo "85 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/release.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/replication.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/replication.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/networking.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/networking.c.bc
 check
-echo "86 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/replication.c to bc" >&2
+echo "86 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/networking.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.c.bc
 check
-echo "87 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.c to bc" >&2
+echo "87 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_string.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_string.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/object.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/object.c.bc
 check
-echo "88 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_string.c to bc" >&2
+echo "88 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/object.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_list.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_list.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/db.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/db.c.bc
 check
-echo "89 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_list.c to bc" >&2
+echo "89 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/db.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_set.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_set.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/replication.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/replication.c.bc
 check
-echo "90 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_set.c to bc" >&2
+echo "90 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/replication.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_zset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_zset.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.c.bc
 check
-echo "91 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_zset.c to bc" >&2
+echo "91 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_hash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_string.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_string.c.bc
 check
-echo "92 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_hash.c to bc" >&2
+echo "92 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_string.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_list.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_list.c.bc
 check
-echo "93 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.c to bc" >&2
+echo "93 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_list.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/aof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_set.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_set.c.bc
 check
-echo "94 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/aof.c to bc" >&2
+echo "94 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_set.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pubsub.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pubsub.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_zset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_zset.c.bc
 check
-echo "95 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pubsub.c to bc" >&2
+echo "95 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_zset.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/multi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/multi.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_hash.c.bc
 check
-echo "96 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/multi.c to bc" >&2
+echo "96 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_hash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/debug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/debug.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.c.bc
 check
-echo "97 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/debug.c to bc" >&2
+echo "97 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sort.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/aof.c.bc
 check
-echo "98 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sort.c to bc" >&2
+echo "98 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/aof.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pubsub.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pubsub.c.bc
 check
-echo "99 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.c to bc" >&2
+echo "99 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pubsub.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/syncio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/syncio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/multi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/multi.c.bc
 check
-echo "100 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/syncio.c to bc" >&2
+echo "100 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/multi.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/debug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/debug.c.bc
 check
-echo "101 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.c to bc" >&2
+echo "101 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/debug.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc16.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc16.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sort.c.bc
 check
-echo "102 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc16.c to bc" >&2
+echo "102 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sort.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.c.bc
 check
-echo "103 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.c to bc" >&2
+echo "103 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/syncio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/syncio.c.bc
 check
-echo "104 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.c to bc" >&2
+echo "104 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/syncio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/scripting.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/scripting.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.c.bc
 check
-echo "105 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/scripting.c to bc" >&2
+echo "105 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc16.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc16.c.bc
 check
-echo "106 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.c to bc" >&2
+echo "106 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc16.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.c.bc
 check
-echo "107 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.c to bc" >&2
+echo "107 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rand.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rand.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.c.bc
 check
-echo "108 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rand.c to bc" >&2
+echo "108 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/memtest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/memtest.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/scripting.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/scripting.c.bc
 check
-echo "109 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/memtest.c to bc" >&2
+echo "109 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/scripting.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.c.bc
 check
-echo "110 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.c to bc" >&2
+echo "110 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bitops.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bitops.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.c.bc
 check
-echo "111 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bitops.c to bc" >&2
+echo "111 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sentinel.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sentinel.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rand.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rand.c.bc
 check
-echo "112 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sentinel.c to bc" >&2
+echo "112 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rand.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/notify.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/notify.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/memtest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/memtest.c.bc
 check
-echo "113 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/notify.c to bc" >&2
+echo "113 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/memtest.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/setproctitle.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/setproctitle.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.c.bc
 check
-echo "114 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/setproctitle.c to bc" >&2
+echo "114 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/blocked.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/blocked.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bitops.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bitops.c.bc
 check
-echo "115 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/blocked.c to bc" >&2
+echo "115 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bitops.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/hyperloglog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/hyperloglog.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sentinel.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sentinel.c.bc
 check
-echo "116 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/hyperloglog.c to bc" >&2
+echo "116 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sentinel.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/latency.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/latency.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/notify.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/notify.c.bc
 check
-echo "117 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/latency.c to bc" >&2
+echo "117 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/notify.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sparkline.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sparkline.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/setproctitle.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/setproctitle.c.bc
 check
-echo "118 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sparkline.c to bc" >&2
+echo "118 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/setproctitle.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/blocked.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/blocked.c.bc
 check
-echo "119 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli.c to bc" >&2
+echo "119 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/blocked.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/hyperloglog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/hyperloglog.c.bc
 check
-echo "120 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark.c to bc" >&2
+echo "120 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/hyperloglog.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-dump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-dump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/latency.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/latency.c.bc
 check
-echo "121 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-dump.c to bc" >&2
+echo "121 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/latency.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-aof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sparkline.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sparkline.c.bc
 check
-echo "122 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-aof.c to bc" >&2
+echo "122 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sparkline.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-rdb.c.bc
+check
+echo "123 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-rdb.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/geo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/geo.c.bc
+check
+echo "124 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/geo.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli.c.bc
+check
+echo "125 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark.c.bc
+check
+echo "126 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-aof.c.bc
+check
+echo "127 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-aof.c to bc" >&2
 echo "Total ir $total" >&2
 echo "Succ ir $succ" >&2
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.c	2016-05-06 15:11:36.000000000 +0800
@@ -25,13 +25,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include "cluster.h"
 #include "endianconv.h"
 
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <arpa/inet.h>
@@ -70,58 +70,58 @@
 void clusterDoBeforeSleep(int flags);
 void clusterSendUpdate(clusterLink *link, clusterNode *node);
 void resetManualFailover(void);
 void clusterCloseAllSlots(void);
 void clusterSetNodeAsMaster(clusterNode *n);
 void clusterDelNode(clusterNode *delnode);
-sds representRedisNodeFlags(sds ci, uint16_t flags);
+sds representClusterNodeFlags(sds ci, uint16_t flags);
 uint64_t clusterGetMaxEpoch(void);
 int clusterBumpConfigEpochWithoutConsensus(void);
 
 /* -----------------------------------------------------------------------------
  * Initialization
  * -------------------------------------------------------------------------- */
 
 /* Load the cluster config from 'filename'.
  *
  * If the file does not exist or is zero-length (this may happen because
  * when we lock the nodes.conf file, we create a zero-length one for the
- * sake of locking if it does not already exist), REDIS_ERR is returned.
- * If the configuration was loaded from the file, REDIS_OK is returned. */
+ * sake of locking if it does not already exist), C_ERR is returned.
+ * If the configuration was loaded from the file, C_OK is returned. */
 int clusterLoadConfig(char *filename) {
     FILE *fp = fopen(filename,"r");
     struct stat sb;
     char *line;
     int maxline, j;
 
     if (fp == NULL) {
         if (errno == ENOENT) {
-            return REDIS_ERR;
+            return C_ERR;
         } else {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "Loading the cluster node config from %s: %s",
                 filename, strerror(errno));
             exit(1);
         }
     }
 
-    /* Check if the file is zero-length: if so return REDIS_ERR to signal
+    /* Check if the file is zero-length: if so return C_ERR to signal
      * we have to write the config. */
     if (fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
         fclose(fp);
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     /* Parse the file. Note that single lines of the cluster config file can
      * be really long as they include all the hash slots of the node.
      * This means in the worst possible case, half of the Redis slots will be
      * present in a single line, possibly in importing or migrating state, so
      * together with the node ID of the sender/receiver.
      *
-     * To simplify we allocate 1024+REDIS_CLUSTER_SLOTS*128 bytes per line. */
-    maxline = 1024+REDIS_CLUSTER_SLOTS*128;
+     * To simplify we allocate 1024+CLUSTER_SLOTS*128 bytes per line. */
+    maxline = 1024+CLUSTER_SLOTS*128;
     line = zmalloc(maxline);
     while(fgets(line,maxline,fp) != NULL) {
         int argc;
         sds *argv;
         clusterNode *n, *master;
         char *p, *s;
@@ -143,13 +143,13 @@
                     server.cluster->currentEpoch =
                             strtoull(argv[j+1],NULL,10);
                 } else if (strcasecmp(argv[j],"lastVoteEpoch") == 0) {
                     server.cluster->lastVoteEpoch =
                             strtoull(argv[j+1],NULL,10);
                 } else {
-                    redisLog(REDIS_WARNING,
+                    serverLog(LL_WARNING,
                         "Skipping unknown cluster config variable '%s'",
                         argv[j]);
                 }
             }
             sdsfreesplitres(argv,argc);
             continue;
@@ -173,32 +173,32 @@
         /* Parse flags */
         p = s = argv[2];
         while(p) {
             p = strchr(s,',');
             if (p) *p = '\0';
             if (!strcasecmp(s,"myself")) {
-                redisAssert(server.cluster->myself == NULL);
+                serverAssert(server.cluster->myself == NULL);
                 myself = server.cluster->myself = n;
-                n->flags |= REDIS_NODE_MYSELF;
+                n->flags |= CLUSTER_NODE_MYSELF;
             } else if (!strcasecmp(s,"master")) {
-                n->flags |= REDIS_NODE_MASTER;
+                n->flags |= CLUSTER_NODE_MASTER;
             } else if (!strcasecmp(s,"slave")) {
-                n->flags |= REDIS_NODE_SLAVE;
+                n->flags |= CLUSTER_NODE_SLAVE;
             } else if (!strcasecmp(s,"fail?")) {
-                n->flags |= REDIS_NODE_PFAIL;
+                n->flags |= CLUSTER_NODE_PFAIL;
             } else if (!strcasecmp(s,"fail")) {
-                n->flags |= REDIS_NODE_FAIL;
+                n->flags |= CLUSTER_NODE_FAIL;
                 n->fail_time = mstime();
             } else if (!strcasecmp(s,"handshake")) {
-                n->flags |= REDIS_NODE_HANDSHAKE;
+                n->flags |= CLUSTER_NODE_HANDSHAKE;
             } else if (!strcasecmp(s,"noaddr")) {
-                n->flags |= REDIS_NODE_NOADDR;
+                n->flags |= CLUSTER_NODE_NOADDR;
             } else if (!strcasecmp(s,"noflags")) {
                 /* nothing to do */
             } else {
-                redisPanic("Unknown flag in redis cluster config file");
+                serverPanic("Unknown flag in redis cluster config file");
             }
             if (p) s = p+1;
         }
 
         /* Get master if any. Set the master and populate master's
          * slave list. */
@@ -227,13 +227,13 @@
                 /* Here we handle migrating / importing slots */
                 int slot;
                 char direction;
                 clusterNode *cn;
 
                 p = strchr(argv[j],'-');
-                redisAssert(p != NULL);
+                serverAssert(p != NULL);
                 *p = '\0';
                 direction = p[1]; /* Either '>' or '<' */
                 slot = atoi(argv[j]+1);
                 p += 3;
                 cn = clusterLookupNode(p);
                 if (!cn) {
@@ -261,24 +261,24 @@
     /* Config sanity check */
     if (server.cluster->myself == NULL) goto fmterr;
 
     zfree(line);
     fclose(fp);
 
-    redisLog(REDIS_NOTICE,"Node configuration loaded, I'm %.40s", myself->name);
+    serverLog(LL_NOTICE,"Node configuration loaded, I'm %.40s", myself->name);
 
     /* Something that should never happen: currentEpoch smaller than
      * the max epoch found in the nodes configuration. However we handle this
      * as some form of protection against manual editing of critical files. */
     if (clusterGetMaxEpoch() > server.cluster->currentEpoch) {
         server.cluster->currentEpoch = clusterGetMaxEpoch();
     }
-    return REDIS_OK;
+    return C_OK;
 
 fmterr:
-    redisLog(REDIS_WARNING,
+    serverLog(LL_WARNING,
         "Unrecoverable error: corrupted cluster config file.");
     zfree(line);
     if (fp) fclose(fp);
     exit(1);
 }
 
@@ -301,13 +301,13 @@
     int fd;
 
     server.cluster->todo_before_sleep &= ~CLUSTER_TODO_SAVE_CONFIG;
 
     /* Get the nodes description and concatenate our "vars" directive to
      * save currentEpoch and lastVoteEpoch. */
-    ci = clusterGenNodesDescription(REDIS_NODE_HANDSHAKE);
+    ci = clusterGenNodesDescription(CLUSTER_NODE_HANDSHAKE);
     ci = sdscatprintf(ci,"vars currentEpoch %llu lastVoteEpoch %llu\n",
         (unsigned long long) server.cluster->currentEpoch,
         (unsigned long long) server.cluster->lastVoteEpoch);
     content_size = sdslen(ci);
 
     if ((fd = open(server.cluster_configfile,O_WRONLY|O_CREAT,0644))
@@ -340,131 +340,131 @@
     sdsfree(ci);
     return -1;
 }
 
 void clusterSaveConfigOrDie(int do_fsync) {
     if (clusterSaveConfig(do_fsync) == -1) {
-        redisLog(REDIS_WARNING,"Fatal: can't update cluster config file.");
+        serverLog(LL_WARNING,"Fatal: can't update cluster config file.");
         exit(1);
     }
 }
 
 /* Lock the cluster config using flock(), and leaks the file descritor used to
  * acquire the lock so that the file will be locked forever.
  *
  * This works because we always update nodes.conf with a new version
  * in-place, reopening the file, and writing to it in place (later adjusting
  * the length with ftruncate()).
  *
- * On success REDIS_OK is returned, otherwise an error is logged and
- * the function returns REDIS_ERR to signal a lock was not acquired. */
+ * On success C_OK is returned, otherwise an error is logged and
+ * the function returns C_ERR to signal a lock was not acquired. */
 int clusterLockConfig(char *filename) {
 /* flock() does not exist on Solaris
  * and a fcntl-based solution won't help, as we constantly re-open that file,
  * which will release _all_ locks anyway
  */
 #if !defined(__sun)
     /* To lock it, we need to open the file in a way it is created if
      * it does not exist, otherwise there is a race condition with other
      * processes. */
     int fd = open(filename,O_WRONLY|O_CREAT,0644);
     if (fd == -1) {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Can't open %s in order to acquire a lock: %s",
             filename, strerror(errno));
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     if (flock(fd,LOCK_EX|LOCK_NB) == -1) {
         if (errno == EWOULDBLOCK) {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                  "Sorry, the cluster configuration file %s is already used "
                  "by a different Redis Cluster node. Please make sure that "
                  "different nodes use different cluster configuration "
                  "files.", filename);
         } else {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "Impossible to lock %s: %s", filename, strerror(errno));
         }
         close(fd);
-        return REDIS_ERR;
+        return C_ERR;
     }
     /* Lock acquired: leak the 'fd' by not closing it, so that we'll retain the
      * lock to the file as long as the process exists. */
 #endif /* __sun */
 
-    return REDIS_OK;
+    return C_OK;
 }
 
 void clusterInit(void) {
     int saveconf = 0;
 
     server.cluster = zmalloc(sizeof(clusterState));
     server.cluster->myself = NULL;
     server.cluster->currentEpoch = 0;
-    server.cluster->state = REDIS_CLUSTER_FAIL;
+    server.cluster->state = CLUSTER_FAIL;
     server.cluster->size = 1;
     server.cluster->todo_before_sleep = 0;
     server.cluster->nodes = dictCreate(&clusterNodesDictType,NULL);
     server.cluster->nodes_black_list =
         dictCreate(&clusterNodesBlackListDictType,NULL);
     server.cluster->failover_auth_time = 0;
     server.cluster->failover_auth_count = 0;
     server.cluster->failover_auth_rank = 0;
     server.cluster->failover_auth_epoch = 0;
-    server.cluster->cant_failover_reason = REDIS_CLUSTER_CANT_FAILOVER_NONE;
+    server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
     server.cluster->lastVoteEpoch = 0;
     server.cluster->stats_bus_messages_sent = 0;
     server.cluster->stats_bus_messages_received = 0;
     memset(server.cluster->slots,0, sizeof(server.cluster->slots));
     clusterCloseAllSlots();
 
     /* Lock the cluster config file to make sure every node uses
      * its own nodes.conf. */
-    if (clusterLockConfig(server.cluster_configfile) == REDIS_ERR)
+    if (clusterLockConfig(server.cluster_configfile) == C_ERR)
         exit(1);
 
     /* Load or create a new nodes configuration. */
-    if (clusterLoadConfig(server.cluster_configfile) == REDIS_ERR) {
+    if (clusterLoadConfig(server.cluster_configfile) == C_ERR) {
         /* No configuration found. We will just use the random name provided
          * by the createClusterNode() function. */
         myself = server.cluster->myself =
-            createClusterNode(NULL,REDIS_NODE_MYSELF|REDIS_NODE_MASTER);
-        redisLog(REDIS_NOTICE,"No cluster configuration found, I'm %.40s",
+            createClusterNode(NULL,CLUSTER_NODE_MYSELF|CLUSTER_NODE_MASTER);
+        serverLog(LL_NOTICE,"No cluster configuration found, I'm %.40s",
             myself->name);
         clusterAddNode(myself);
         saveconf = 1;
     }
     if (saveconf) clusterSaveConfigOrDie(1);
 
     /* We need a listening TCP port for our cluster messaging needs. */
     server.cfd_count = 0;
 
     /* Port sanity check II
      * The other handshake port check is triggered too late to stop
      * us from trying to use a too-high cluster port number. */
-    if (server.port > (65535-REDIS_CLUSTER_PORT_INCR)) {
-        redisLog(REDIS_WARNING, "Redis port number too high. "
+    if (server.port > (65535-CLUSTER_PORT_INCR)) {
+        serverLog(LL_WARNING, "Redis port number too high. "
                    "Cluster communication port is 10,000 port "
                    "numbers higher than your Redis port. "
                    "Your Redis port number must be "
                    "lower than 55535.");
         exit(1);
     }
 
-    if (listenToPort(server.port+REDIS_CLUSTER_PORT_INCR,
-        server.cfd,&server.cfd_count) == REDIS_ERR)
+    if (listenToPort(server.port+CLUSTER_PORT_INCR,
+        server.cfd,&server.cfd_count) == C_ERR)
     {
         exit(1);
     } else {
         int j;
 
         for (j = 0; j < server.cfd_count; j++) {
             if (aeCreateFileEvent(server.el, server.cfd[j], AE_READABLE,
                 clusterAcceptHandler, NULL) == AE_ERR)
-                    redisPanic("Unrecoverable error creating Redis Cluster "
+                    serverPanic("Unrecoverable error creating Redis Cluster "
                                 "file event.");
         }
     }
 
     /* The slots -> keys map is a sorted set. Init it. */
     server.cluster->slots_to_keys = zslCreate();
@@ -500,13 +500,13 @@
 
     /* Close slots, reset manual failover state. */
     clusterCloseAllSlots();
     resetManualFailover();
 
     /* Unassign all the slots. */
-    for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) clusterDelSlot(j);
+    for (j = 0; j < CLUSTER_SLOTS; j++) clusterDelSlot(j);
 
     /* Forget all the nodes, but myself. */
     di = dictGetSafeIterator(server.cluster->nodes);
     while((de = dictNext(di)) != NULL) {
         clusterNode *node = dictGetVal(de);
 
@@ -519,21 +519,22 @@
     if (hard) {
         sds oldname;
 
         server.cluster->currentEpoch = 0;
         server.cluster->lastVoteEpoch = 0;
         myself->configEpoch = 0;
-        redisLog(REDIS_WARNING, "configEpoch set to 0 via CLUSTER RESET HARD");
+        serverLog(LL_WARNING, "configEpoch set to 0 via CLUSTER RESET HARD");
 
         /* To change the Node ID we need to remove the old name from the
          * nodes table, change the ID, and re-add back with new name. */
-        oldname = sdsnewlen(myself->name, REDIS_CLUSTER_NAMELEN);
+        oldname = sdsnewlen(myself->name, CLUSTER_NAMELEN);
         dictDelete(server.cluster->nodes,oldname);
         sdsfree(oldname);
-        getRandomHexChars(myself->name, REDIS_CLUSTER_NAMELEN);
+        getRandomHexChars(myself->name, CLUSTER_NAMELEN);
         clusterAddNode(myself);
+        serverLog(LL_NOTICE,"Node hard reset, now I'm %.40s", myself->name);
     }
 
     /* Make sure to persist the new config and update the state. */
     clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                          CLUSTER_TODO_UPDATE_STATE|
                          CLUSTER_TODO_FSYNC_CONFIG);
@@ -570,35 +571,35 @@
 }
 
 #define MAX_CLUSTER_ACCEPTS_PER_CALL 1000
 void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     int cport, cfd;
     int max = MAX_CLUSTER_ACCEPTS_PER_CALL;
-    char cip[REDIS_IP_STR_LEN];
+    char cip[NET_IP_STR_LEN];
     clusterLink *link;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(mask);
-    REDIS_NOTUSED(privdata);
+    UNUSED(el);
+    UNUSED(mask);
+    UNUSED(privdata);
 
     /* If the server is starting up, don't accept cluster connections:
      * UPDATE messages may interact with the database content. */
     if (server.masterhost == NULL && server.loading) return;
 
     while(max--) {
         cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
         if (cfd == ANET_ERR) {
             if (errno != EWOULDBLOCK)
-                redisLog(REDIS_VERBOSE,
+                serverLog(LL_VERBOSE,
                     "Error accepting cluster node: %s", server.neterr);
             return;
         }
         anetNonBlock(NULL,cfd);
         anetEnableTcpNoDelay(NULL,cfd);
 
         /* Use non-blocking I/O for cluster messages. */
-        redisLog(REDIS_VERBOSE,"Accepted cluster node %s:%d", cip, cport);
+        serverLog(LL_VERBOSE,"Accepted cluster node %s:%d", cip, cport);
         /* Create a link object we use to handle the connection.
          * It gets passed to the readable handler when data is available.
          * Initiallly the link->node pointer is set to NULL as we don't know
          * which node is, but the right node is references once we know the
          * node identity. */
         link = createClusterLink(NULL);
@@ -650,15 +651,15 @@
  * The node is created and returned to the user, but it is not automatically
  * added to the nodes hash table. */
 clusterNode *createClusterNode(char *nodename, int flags) {
     clusterNode *node = zmalloc(sizeof(*node));
 
     if (nodename)
-        memcpy(node->name, nodename, REDIS_CLUSTER_NAMELEN);
+        memcpy(node->name, nodename, CLUSTER_NAMELEN);
     else
-        getRandomHexChars(node->name, REDIS_CLUSTER_NAMELEN);
+        getRandomHexChars(node->name, CLUSTER_NAMELEN);
     node->ctime = mstime();
     node->configEpoch = 0;
     node->flags = flags;
     memset(node->slots,0,sizeof(node->slots));
     node->numslots = 0;
     node->numslaves = 0;
@@ -721,13 +722,13 @@
 void clusterNodeCleanupFailureReports(clusterNode *node) {
     list *l = node->fail_reports;
     listNode *ln;
     listIter li;
     clusterNodeFailReport *fr;
     mstime_t maxtime = server.cluster_node_timeout *
-                     REDIS_CLUSTER_FAIL_REPORT_VALIDITY_MULT;
+                     CLUSTER_FAIL_REPORT_VALIDITY_MULT;
     mstime_t now = mstime();
 
     listRewind(l,&li);
     while ((ln = listNext(&li)) != NULL) {
         fr = ln->value;
         if (now - fr->time > maxtime) listDelNode(l,ln);
@@ -782,31 +783,31 @@
                 int remaining_slaves = (master->numslaves - j) - 1;
                 memmove(master->slaves+j,master->slaves+(j+1),
                         (sizeof(*master->slaves) * remaining_slaves));
             }
             master->numslaves--;
             if (master->numslaves == 0)
-                master->flags &= ~REDIS_NODE_MIGRATE_TO;
-            return REDIS_OK;
+                master->flags &= ~CLUSTER_NODE_MIGRATE_TO;
+            return C_OK;
         }
     }
-    return REDIS_ERR;
+    return C_ERR;
 }
 
 int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {
     int j;
 
     /* If it's already a slave, don't add it again. */
     for (j = 0; j < master->numslaves; j++)
-        if (master->slaves[j] == slave) return REDIS_ERR;
+        if (master->slaves[j] == slave) return C_ERR;
     master->slaves = zrealloc(master->slaves,
         sizeof(clusterNode*)*(master->numslaves+1));
     master->slaves[master->numslaves] = slave;
     master->numslaves++;
-    master->flags |= REDIS_NODE_MIGRATE_TO;
-    return REDIS_OK;
+    master->flags |= CLUSTER_NODE_MIGRATE_TO;
+    return C_OK;
 }
 
 int clusterCountNonFailingSlaves(clusterNode *n) {
     int j, okslaves = 0;
 
     for (j = 0; j < n->numslaves; j++)
@@ -825,14 +826,14 @@
         n->slaves[j]->slaveof = NULL;
 
     /* Remove this node from the list of slaves of its master. */
     if (nodeIsSlave(n) && n->slaveof) clusterNodeRemoveSlave(n->slaveof,n);
 
     /* Unlink from the set of nodes. */
-    nodename = sdsnewlen(n->name, REDIS_CLUSTER_NAMELEN);
-    redisAssert(dictDelete(server.cluster->nodes,nodename) == DICT_OK);
+    nodename = sdsnewlen(n->name, CLUSTER_NAMELEN);
+    serverAssert(dictDelete(server.cluster->nodes,nodename) == DICT_OK);
     sdsfree(nodename);
 
     /* Release link and associated data structures. */
     if (n->link) freeClusterLink(n->link);
     listRelease(n->fail_reports);
     zfree(n->slaves);
@@ -841,14 +842,14 @@
 
 /* Add a node to the nodes hash table */
 int clusterAddNode(clusterNode *node) {
     int retval;
 
     retval = dictAdd(server.cluster->nodes,
-            sdsnewlen(node->name,REDIS_CLUSTER_NAMELEN), node);
-    return (retval == DICT_OK) ? REDIS_OK : REDIS_ERR;
+            sdsnewlen(node->name,CLUSTER_NAMELEN), node);
+    return (retval == DICT_OK) ? C_OK : C_ERR;
 }
 
 /* Remove a node from the cluster. The functio performs the high level
  * cleanup, calling freeClusterNode() for the low level cleanup.
  * Here we do the following:
  *
@@ -862,13 +863,13 @@
 void clusterDelNode(clusterNode *delnode) {
     int j;
     dictIterator *di;
     dictEntry *de;
 
     /* 1) Mark slots as unassigned. */
-    for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+    for (j = 0; j < CLUSTER_SLOTS; j++) {
         if (server.cluster->importing_slots_from[j] == delnode)
             server.cluster->importing_slots_from[j] = NULL;
         if (server.cluster->migrating_slots_to[j] == delnode)
             server.cluster->migrating_slots_to[j] = NULL;
         if (server.cluster->slots[j] == delnode)
             clusterDelSlot(j);
@@ -887,13 +888,13 @@
     /* 3) Free the node, unlinking it from the cluster. */
     freeClusterNode(delnode);
 }
 
 /* Node lookup by name */
 clusterNode *clusterLookupNode(char *name) {
-    sds s = sdsnewlen(name, REDIS_CLUSTER_NAMELEN);
+    sds s = sdsnewlen(name, CLUSTER_NAMELEN);
     dictEntry *de;
 
     de = dictFind(server.cluster->nodes,s);
     sdsfree(s);
     if (de == NULL) return NULL;
     return dictGetVal(de);
@@ -902,20 +903,20 @@
 /* This is only used after the handshake. When we connect a given IP/PORT
  * as a result of CLUSTER MEET we don't have the node name yet, so we
  * pick a random one, and will fix it when we receive the PONG request using
  * this function. */
 void clusterRenameNode(clusterNode *node, char *newname) {
     int retval;
-    sds s = sdsnewlen(node->name, REDIS_CLUSTER_NAMELEN);
+    sds s = sdsnewlen(node->name, CLUSTER_NAMELEN);
 
-    redisLog(REDIS_DEBUG,"Renaming node %.40s into %.40s",
+    serverLog(LL_DEBUG,"Renaming node %.40s into %.40s",
         node->name, newname);
     retval = dictDelete(server.cluster->nodes, s);
     sdsfree(s);
-    redisAssert(retval == DICT_OK);
-    memcpy(node->name, newname, REDIS_CLUSTER_NAMELEN);
+    serverAssert(retval == DICT_OK);
+    memcpy(node->name, newname, CLUSTER_NAMELEN);
     clusterAddNode(node);
 }
 
 /* -----------------------------------------------------------------------------
  * CLUSTER config epoch handling
  * -------------------------------------------------------------------------- */
@@ -942,23 +943,23 @@
  *
  * 1) Generate a new config epoch, incrementing the current epoch.
  * 2) Assign the new epoch to this node, WITHOUT any consensus.
  * 3) Persist the configuration on disk before sending packets with the
  *    new configuration.
  *
- * If the new config epoch is generated and assigend, REDIS_OK is returned,
- * otherwise REDIS_ERR is returned (since the node has already the greatest
+ * If the new config epoch is generated and assigend, C_OK is returned,
+ * otherwise C_ERR is returned (since the node has already the greatest
  * configuration around) and no operation is performed.
  *
  * Important note: this function violates the principle that config epochs
  * should be generated with consensus and should be unique across the cluster.
  * However Redis Cluster uses this auto-generated new config epochs in two
  * cases:
  *
  * 1) When slots are closed after importing. Otherwise resharding would be
- *    too expansive.
+ *    too expensive.
  * 2) When CLUSTER FAILOVER is called with options that force a slave to
  *    failover its master even if there is not master majority able to
  *    create a new configuration epoch.
  *
  * Redis Cluster will not explode using this function, even in the case of
  * a collision between this node and another node, generating the same
@@ -973,18 +974,18 @@
         myself->configEpoch != maxEpoch)
     {
         server.cluster->currentEpoch++;
         myself->configEpoch = server.cluster->currentEpoch;
         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                              CLUSTER_TODO_FSYNC_CONFIG);
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "New configEpoch set to %llu",
             (unsigned long long) myself->configEpoch);
-        return REDIS_OK;
+        return C_OK;
     } else {
-        return REDIS_ERR;
+        return C_ERR;
     }
 }
 
 /* This function is called when this node is a master, and we receive from
  * another master a configuration epoch that is equal to our configuration
  * epoch.
@@ -1033,47 +1034,47 @@
  */
 void clusterHandleConfigEpochCollision(clusterNode *sender) {
     /* Prerequisites: nodes have the same configEpoch and are both masters. */
     if (sender->configEpoch != myself->configEpoch ||
         !nodeIsMaster(sender) || !nodeIsMaster(myself)) return;
     /* Don't act if the colliding node has a smaller Node ID. */
-    if (memcmp(sender->name,myself->name,REDIS_CLUSTER_NAMELEN) <= 0) return;
+    if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) return;
     /* Get the next ID available at the best of this node knowledge. */
     server.cluster->currentEpoch++;
     myself->configEpoch = server.cluster->currentEpoch;
     clusterSaveConfigOrDie(1);
-    redisLog(REDIS_VERBOSE,
+    serverLog(LL_VERBOSE,
         "WARNING: configEpoch collision with node %.40s."
         " configEpoch set to %llu",
         sender->name,
         (unsigned long long) myself->configEpoch);
 }
 
 /* -----------------------------------------------------------------------------
  * CLUSTER nodes blacklist
  *
  * The nodes blacklist is just a way to ensure that a given node with a given
  * Node ID is not readded before some time elapsed (this time is specified
- * in seconds in REDIS_CLUSTER_BLACKLIST_TTL).
+ * in seconds in CLUSTER_BLACKLIST_TTL).
  *
  * This is useful when we want to remove a node from the cluster completely:
  * when CLUSTER FORGET is called, it also puts the node into the blacklist so
  * that even if we receive gossip messages from other nodes that still remember
  * about the node we want to remove, we don't re-add it before some time.
  *
- * Currently the REDIS_CLUSTER_BLACKLIST_TTL is set to 1 minute, this means
+ * Currently the CLUSTER_BLACKLIST_TTL is set to 1 minute, this means
  * that redis-trib has 60 seconds to send CLUSTER FORGET messages to nodes
  * in the cluster without dealing with the problem of other nodes re-adding
  * back the node to nodes we already sent the FORGET command to.
  *
  * The data structure used is a hash table with an sds string representing
  * the node ID as key, and the time when it is ok to re-add the node as
  * value.
  * -------------------------------------------------------------------------- */
 
-#define REDIS_CLUSTER_BLACKLIST_TTL 60      /* 1 minute. */
+#define CLUSTER_BLACKLIST_TTL 60      /* 1 minute. */
 
 
 /* Before of the addNode() or Exists() operations we always remove expired
  * entries from the black list. This is an O(N) operation but it is not a
  * problem since add / exists operations are called very infrequently and
  * the hash table is supposed to contain very little elements at max.
@@ -1093,30 +1094,30 @@
     dictReleaseIterator(di);
 }
 
 /* Cleanup the blacklist and add a new node ID to the black list. */
 void clusterBlacklistAddNode(clusterNode *node) {
     dictEntry *de;
-    sds id = sdsnewlen(node->name,REDIS_CLUSTER_NAMELEN);
+    sds id = sdsnewlen(node->name,CLUSTER_NAMELEN);
 
     clusterBlacklistCleanup();
     if (dictAdd(server.cluster->nodes_black_list,id,NULL) == DICT_OK) {
         /* If the key was added, duplicate the sds string representation of
          * the key for the next lookup. We'll free it at the end. */
         id = sdsdup(id);
     }
     de = dictFind(server.cluster->nodes_black_list,id);
-    dictSetUnsignedIntegerVal(de,time(NULL)+REDIS_CLUSTER_BLACKLIST_TTL);
+    dictSetUnsignedIntegerVal(de,time(NULL)+CLUSTER_BLACKLIST_TTL);
     sdsfree(id);
 }
 
 /* Return non-zero if the specified node ID exists in the blacklist.
  * You don't need to pass an sds string here, any pointer to 40 bytes
  * will work. */
 int clusterBlacklistExists(char *nodeid) {
-    sds id = sdsnewlen(nodeid,REDIS_CLUSTER_NAMELEN);
+    sds id = sdsnewlen(nodeid,CLUSTER_NAMELEN);
     int retval;
 
     clusterBlacklistCleanup();
     retval = dictFind(server.cluster->nodes_black_list,id) != NULL;
     sdsfree(id);
     return retval;
@@ -1156,18 +1157,18 @@
 
     failures = clusterNodeFailureReportsCount(node);
     /* Also count myself as a voter if I'm a master. */
     if (nodeIsMaster(myself)) failures++;
     if (failures < needed_quorum) return; /* No weak agreement from masters. */
 
-    redisLog(REDIS_NOTICE,
+    serverLog(LL_NOTICE,
         "Marking node %.40s as failing (quorum reached).", node->name);
 
     /* Mark the node as failing. */
-    node->flags &= ~REDIS_NODE_PFAIL;
-    node->flags |= REDIS_NODE_FAIL;
+    node->flags &= ~CLUSTER_NODE_PFAIL;
+    node->flags |= CLUSTER_NODE_FAIL;
     node->fail_time = mstime();
 
     /* Broadcast the failing node name to everybody, forcing all the other
      * reachable nodes to flag the node as FAIL. */
     if (nodeIsMaster(myself)) clusterSendFail(node->name);
     clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
@@ -1176,37 +1177,37 @@
 /* This function is called only if a node is marked as FAIL, but we are able
  * to reach it again. It checks if there are the conditions to undo the FAIL
  * state. */
 void clearNodeFailureIfNeeded(clusterNode *node) {
     mstime_t now = mstime();
 
-    redisAssert(nodeFailed(node));
+    serverAssert(nodeFailed(node));
 
     /* For slaves we always clear the FAIL flag if we can contact the
      * node again. */
     if (nodeIsSlave(node) || node->numslots == 0) {
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Clear FAIL state for node %.40s: %s is reachable again.",
                 node->name,
                 nodeIsSlave(node) ? "slave" : "master without slots");
-        node->flags &= ~REDIS_NODE_FAIL;
+        node->flags &= ~CLUSTER_NODE_FAIL;
         clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
     }
 
     /* If it is a master and...
      * 1) The FAIL state is old enough.
      * 2) It is yet serving slots from our point of view (not failed over).
      * Apparently no one is going to fix these slots, clear the FAIL flag. */
     if (nodeIsMaster(node) && node->numslots > 0 &&
         (now - node->fail_time) >
-        (server.cluster_node_timeout * REDIS_CLUSTER_FAIL_UNDO_TIME_MULT))
+        (server.cluster_node_timeout * CLUSTER_FAIL_UNDO_TIME_MULT))
     {
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Clear FAIL state for node %.40s: is reachable again and nobody is serving its slots after some time.",
                 node->name);
-        node->flags &= ~REDIS_NODE_FAIL;
+        node->flags &= ~CLUSTER_NODE_FAIL;
         clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
     }
 }
 
 /* Return true if we already have a node in HANDSHAKE state matching the
  * specified ip address and port number. This function is used in order to
@@ -1232,13 +1233,13 @@
  * following values:
  *
  * EAGAIN - There is already an handshake in progress for this address.
  * EINVAL - IP or port are not valid. */
 int clusterStartHandshake(char *ip, int port) {
     clusterNode *n;
-    char norm_ip[REDIS_IP_STR_LEN];
+    char norm_ip[NET_IP_STR_LEN];
     struct sockaddr_storage sa;
 
     /* IP sanity check */
     if (inet_pton(AF_INET,ip,
             &(((struct sockaddr_in *)&sa)->sin_addr)))
     {
@@ -1250,38 +1251,38 @@
     } else {
         errno = EINVAL;
         return 0;
     }
 
     /* Port sanity check */
-    if (port <= 0 || port > (65535-REDIS_CLUSTER_PORT_INCR)) {
+    if (port <= 0 || port > (65535-CLUSTER_PORT_INCR)) {
         errno = EINVAL;
         return 0;
     }
 
     /* Set norm_ip as the normalized string representation of the node
      * IP address. */
-    memset(norm_ip,0,REDIS_IP_STR_LEN);
+    memset(norm_ip,0,NET_IP_STR_LEN);
     if (sa.ss_family == AF_INET)
         inet_ntop(AF_INET,
             (void*)&(((struct sockaddr_in *)&sa)->sin_addr),
-            norm_ip,REDIS_IP_STR_LEN);
+            norm_ip,NET_IP_STR_LEN);
     else
         inet_ntop(AF_INET6,
             (void*)&(((struct sockaddr_in6 *)&sa)->sin6_addr),
-            norm_ip,REDIS_IP_STR_LEN);
+            norm_ip,NET_IP_STR_LEN);
 
     if (clusterHandshakeInProgress(norm_ip,port)) {
         errno = EAGAIN;
         return 0;
     }
 
     /* Add the node with a random address (NULL as first argument to
      * createClusterNode()). Everything will be fixed during the
      * handshake. */
-    n = createClusterNode(NULL,REDIS_NODE_HANDSHAKE|REDIS_NODE_MEET);
+    n = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET);
     memcpy(n->ip,norm_ip,sizeof(n->ip));
     n->port = port;
     clusterAddNode(n);
     return 1;
 }
 
@@ -1296,61 +1297,66 @@
 
     while(count--) {
         uint16_t flags = ntohs(g->flags);
         clusterNode *node;
         sds ci;
 
-        ci = representRedisNodeFlags(sdsempty(), flags);
-        redisLog(REDIS_DEBUG,"GOSSIP %.40s %s:%d %s",
+        ci = representClusterNodeFlags(sdsempty(), flags);
+        serverLog(LL_DEBUG,"GOSSIP %.40s %s:%d %s",
             g->nodename,
             g->ip,
             ntohs(g->port),
             ci);
         sdsfree(ci);
 
         /* Update our state accordingly to the gossip sections */
         node = clusterLookupNode(g->nodename);
         if (node) {
             /* We already know this node.
                Handle failure reports, only when the sender is a master. */
             if (sender && nodeIsMaster(sender) && node != myself) {
-                if (flags & (REDIS_NODE_FAIL|REDIS_NODE_PFAIL)) {
+                if (flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) {
                     if (clusterNodeAddFailureReport(node,sender)) {
-                        redisLog(REDIS_VERBOSE,
+                        serverLog(LL_VERBOSE,
                             "Node %.40s reported node %.40s as not reachable.",
                             sender->name, node->name);
                     }
                     markNodeAsFailingIfNeeded(node);
                 } else {
                     if (clusterNodeDelFailureReport(node,sender)) {
-                        redisLog(REDIS_VERBOSE,
+                        serverLog(LL_VERBOSE,
                             "Node %.40s reported node %.40s is back online.",
                             sender->name, node->name);
                     }
                 }
             }
 
             /* If we already know this node, but it is not reachable, and
-             * we see a different address in the gossip section, start an
-             * handshake with the (possibly) new address: this will result
-             * into a node address update if the handshake will be
-             * successful. */
-            if (node->flags & (REDIS_NODE_FAIL|REDIS_NODE_PFAIL) &&
+             * we see a different address in the gossip section of a node that
+             * can talk with this other node, update the address, disconnect
+             * the old link if any, so that we'll attempt to connect with the
+             * new address. */
+            if (node->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL) &&
+                !(flags & CLUSTER_NODE_NOADDR) &&
+                !(flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &&
                 (strcasecmp(node->ip,g->ip) || node->port != ntohs(g->port)))
             {
-                clusterStartHandshake(g->ip,ntohs(g->port));
+                if (node->link) freeClusterLink(node->link);
+                memcpy(node->ip,g->ip,NET_IP_STR_LEN);
+                node->port = ntohs(g->port);
+                node->flags &= ~CLUSTER_NODE_NOADDR;
             }
         } else {
             /* If it's not in NOADDR state and we don't have it, we
              * start a handshake process against this IP/PORT pairs.
              *
              * Note that we require that the sender of this gossip message
              * is a well known node in our cluster, otherwise we risk
              * joining another cluster. */
             if (sender &&
-                !(flags & REDIS_NODE_NOADDR) &&
+                !(flags & CLUSTER_NODE_NOADDR) &&
                 !clusterBlacklistExists(g->nodename))
             {
                 clusterStartHandshake(g->ip,ntohs(g->port));
             }
         }
 
@@ -1358,13 +1364,13 @@
         g++;
     }
 }
 
 /* IP -> string conversion. 'buf' is supposed to at least be 46 bytes. */
 void nodeIp2String(char *buf, clusterLink *link) {
-    anetPeerToString(link->fd, buf, REDIS_IP_STR_LEN, NULL);
+    anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL);
 }
 
 /* Update the node address to the IP address that can be extracted
  * from link->fd, and at the specified port.
  * Also disconnect the node link so that we'll connect again to the new
  * address.
@@ -1372,13 +1378,13 @@
  * If the ip/port pair are already correct no operation is performed at
  * all.
  *
  * The function returns 0 if the node address is still the same,
  * otherwise 1 is returned. */
 int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link, int port) {
-    char ip[REDIS_IP_STR_LEN] = {0};
+    char ip[NET_IP_STR_LEN] = {0};
 
     /* We don't proceed if the link is the same as the sender link, as this
      * function is designed to see if the node link is consistent with the
      * symmetric link that is used to receive PINGs from the node.
      *
      * As a side effect this function never frees the passed 'link', so
@@ -1389,14 +1395,14 @@
     if (node->port == port && strcmp(ip,node->ip) == 0) return 0;
 
     /* IP / port is different, update it. */
     memcpy(node->ip,ip,sizeof(ip));
     node->port = port;
     if (node->link) freeClusterLink(node->link);
-    node->flags &= ~REDIS_NODE_NOADDR;
-    redisLog(REDIS_WARNING,"Address updated for node %.40s, now %s:%d",
+    node->flags &= ~CLUSTER_NODE_NOADDR;
+    serverLog(LL_WARNING,"Address updated for node %.40s, now %s:%d",
         node->name, node->ip, node->port);
 
     /* Check if this is our master and we have to change the
      * replication target as well. */
     if (nodeIsSlave(myself) && myself->slaveof == node)
         replicationSetMaster(node->ip, node->port);
@@ -1408,16 +1414,16 @@
  * update the state of the node. */
 void clusterSetNodeAsMaster(clusterNode *n) {
     if (nodeIsMaster(n)) return;
 
     if (n->slaveof) {
         clusterNodeRemoveSlave(n->slaveof,n);
-        if (n != myself) n->flags |= REDIS_NODE_MIGRATE_TO;
+        if (n != myself) n->flags |= CLUSTER_NODE_MIGRATE_TO;
     }
-    n->flags &= ~REDIS_NODE_SLAVE;
-    n->flags |= REDIS_NODE_MASTER;
+    n->flags &= ~CLUSTER_NODE_SLAVE;
+    n->flags |= CLUSTER_NODE_MASTER;
     n->slaveof = NULL;
 
     /* Update config and state. */
     clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                          CLUSTER_TODO_UPDATE_STATE);
 }
@@ -1440,26 +1446,26 @@
      * while having still keys inside. This usually happens after a failover
      * or after a manual cluster reconfiguration operated by the admin.
      *
      * If the update message is not able to demote a master to slave (in this
      * case we'll resync with the master updating the whole key space), we
      * need to delete all the keys in the slots we lost ownership. */
-    uint16_t dirty_slots[REDIS_CLUSTER_SLOTS];
+    uint16_t dirty_slots[CLUSTER_SLOTS];
     int dirty_slots_count = 0;
 
     /* Here we set curmaster to this node or the node this node
      * replicates to if it's a slave. In the for loop we are
      * interested to check if slots are taken away from curmaster. */
     curmaster = nodeIsMaster(myself) ? myself : myself->slaveof;
 
     if (sender == myself) {
-        redisLog(REDIS_WARNING,"Discarding UPDATE message about myself.");
+        serverLog(LL_WARNING,"Discarding UPDATE message about myself.");
         return;
     }
 
-    for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+    for (j = 0; j < CLUSTER_SLOTS; j++) {
         if (bitmapTestBit(slots,j)) {
             /* The slot is already bound to the sender of this message. */
             if (server.cluster->slots[j] == sender) continue;
 
             /* The slot is in importing state, it should be modified only
              * manually via redis-trib (example: a resharding is in progress
@@ -1500,13 +1506,13 @@
      * 1) We are a master left without slots. This means that we were
      *    failed over and we should turn into a replica of the new
      *    master.
      * 2) We are a slave and our master is left without slots. We need
      *    to replicate to the new slots owner. */
     if (newmaster && curmaster->numslots == 0) {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Configuration change detected. Reconfiguring myself "
             "as a replica of %.40s", sender->name);
         clusterSetMaster(sender);
         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                              CLUSTER_TODO_UPDATE_STATE|
                              CLUSTER_TODO_FSYNC_CONFIG);
@@ -1535,13 +1541,13 @@
 int clusterProcessPacket(clusterLink *link) {
     clusterMsg *hdr = (clusterMsg*) link->rcvbuf;
     uint32_t totlen = ntohl(hdr->totlen);
     uint16_t type = ntohs(hdr->type);
 
     server.cluster->stats_bus_messages_received++;
-    redisLog(REDIS_DEBUG,"--- Processing packet of type %d, %lu bytes",
+    serverLog(LL_DEBUG,"--- Processing packet of type %d, %lu bytes",
         type, (unsigned long) totlen);
 
     /* Perform sanity checks */
     if (totlen < 16) return 1; /* At least signature, version, totlen, count. */
     if (totlen > sdslen(link->rcvbuf)) return 1;
 
@@ -1613,22 +1619,22 @@
             nodeIsSlave(myself) &&
             myself->slaveof == sender &&
             hdr->mflags[0] & CLUSTERMSG_FLAG0_PAUSED &&
             server.cluster->mf_master_offset == 0)
         {
             server.cluster->mf_master_offset = sender->repl_offset;
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "Received replication offset for paused "
                 "master manual failover: %lld",
                 server.cluster->mf_master_offset);
         }
     }
 
     /* Initial processing of PING and MEET requests replying with a PONG. */
     if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_MEET) {
-        redisLog(REDIS_DEBUG,"Ping packet received: %p", (void*)link->node);
+        serverLog(LL_DEBUG,"Ping packet received: %p", (void*)link->node);
 
         /* We use incoming MEET messages in order to set the address
          * for 'myself', since only other cluster nodes will send us
          * MEET messagses on handshakes, when the cluster joins, or
          * later if we changed address, and those nodes will use our
          * official address to connect to us. So by obtaining this address
@@ -1636,32 +1642,32 @@
          * address in the cluster without it being hardcoded in the config.
          *
          * However if we don't have an address at all, we update the address
          * even with a normal PING packet. If it's wrong it will be fixed
          * by MEET later. */
         if (type == CLUSTERMSG_TYPE_MEET || myself->ip[0] == '\0') {
-            char ip[REDIS_IP_STR_LEN];
+            char ip[NET_IP_STR_LEN];
 
             if (anetSockName(link->fd,ip,sizeof(ip),NULL) != -1 &&
                 strcmp(ip,myself->ip))
             {
-                memcpy(myself->ip,ip,REDIS_IP_STR_LEN);
-                redisLog(REDIS_WARNING,"IP address for this node updated to %s",
+                memcpy(myself->ip,ip,NET_IP_STR_LEN);
+                serverLog(LL_WARNING,"IP address for this node updated to %s",
                     myself->ip);
                 clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
             }
         }
 
         /* Add this node if it is new for us and the msg type is MEET.
          * In this stage we don't try to add the node with the right
          * flags, slaveof pointer, and so forth, as this details will be
          * resolved when we'll receive PONGs from the node. */
         if (!sender && type == CLUSTERMSG_TYPE_MEET) {
             clusterNode *node;
 
-            node = createClusterNode(NULL,REDIS_NODE_HANDSHAKE);
+            node = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE);
             nodeIp2String(node->ip,link);
             node->port = ntohs(hdr->port);
             clusterAddNode(node);
             clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
         }
 
@@ -1676,21 +1682,21 @@
     }
 
     /* PING, PONG, MEET: process config information. */
     if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_PONG ||
         type == CLUSTERMSG_TYPE_MEET)
     {
-        redisLog(REDIS_DEBUG,"%s packet received: %p",
+        serverLog(LL_DEBUG,"%s packet received: %p",
             type == CLUSTERMSG_TYPE_PING ? "ping" : "pong",
             (void*)link->node);
         if (link->node) {
             if (nodeInHandshake(link->node)) {
                 /* If we already have this node, try to change the
                  * IP/port of the node with the new one. */
                 if (sender) {
-                    redisLog(REDIS_VERBOSE,
+                    serverLog(LL_VERBOSE,
                         "Handshake: we already know node %.40s, "
                         "updating the address if needed.", sender->name);
                     if (nodeUpdateAddressIfNeeded(sender,link,ntohs(hdr->port)))
                     {
                         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                                              CLUSTER_TODO_UPDATE_STATE);
@@ -1701,25 +1707,28 @@
                     return 0;
                 }
 
                 /* First thing to do is replacing the random name with the
                  * right node name if this was a handshake stage. */
                 clusterRenameNode(link->node, hdr->sender);
-                redisLog(REDIS_DEBUG,"Handshake with node %.40s completed.",
+                serverLog(LL_DEBUG,"Handshake with node %.40s completed.",
                     link->node->name);
-                link->node->flags &= ~REDIS_NODE_HANDSHAKE;
-                link->node->flags |= flags&(REDIS_NODE_MASTER|REDIS_NODE_SLAVE);
+                link->node->flags &= ~CLUSTER_NODE_HANDSHAKE;
+                link->node->flags |= flags&(CLUSTER_NODE_MASTER|CLUSTER_NODE_SLAVE);
                 clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
             } else if (memcmp(link->node->name,hdr->sender,
-                        REDIS_CLUSTER_NAMELEN) != 0)
+                        CLUSTER_NAMELEN) != 0)
             {
                 /* If the reply has a non matching node ID we
                  * disconnect this node and set it as not having an associated
                  * address. */
-                redisLog(REDIS_DEBUG,"PONG contains mismatching sender ID");
-                link->node->flags |= REDIS_NODE_NOADDR;
+                serverLog(LL_DEBUG,"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d",
+                    link->node->name,
+                    (int)(mstime()-(link->node->ctime)),
+                    link->node->flags);
+                link->node->flags |= CLUSTER_NODE_NOADDR;
                 link->node->ip[0] = '\0';
                 link->node->port = 0;
                 freeClusterLink(link);
                 clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
                 return 0;
             }
@@ -1743,37 +1752,37 @@
              * help if it is momentary (that is, if it does not
              * turn into a FAIL state).
              *
              * The FAIL condition is also reversible under specific
              * conditions detected by clearNodeFailureIfNeeded(). */
             if (nodeTimedOut(link->node)) {
-                link->node->flags &= ~REDIS_NODE_PFAIL;
+                link->node->flags &= ~CLUSTER_NODE_PFAIL;
                 clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                                      CLUSTER_TODO_UPDATE_STATE);
             } else if (nodeFailed(link->node)) {
                 clearNodeFailureIfNeeded(link->node);
             }
         }
 
         /* Check for role switch: slave -> master or master -> slave. */
         if (sender) {
-            if (!memcmp(hdr->slaveof,REDIS_NODE_NULL_NAME,
+            if (!memcmp(hdr->slaveof,CLUSTER_NODE_NULL_NAME,
                 sizeof(hdr->slaveof)))
             {
                 /* Node is a master. */
                 clusterSetNodeAsMaster(sender);
             } else {
                 /* Node is a slave. */
                 clusterNode *master = clusterLookupNode(hdr->slaveof);
 
                 if (nodeIsMaster(sender)) {
                     /* Master turned into a slave! Reconfigure the node. */
                     clusterDelNodeSlots(sender);
-                    sender->flags &= ~(REDIS_NODE_MASTER|
-                                       REDIS_NODE_MIGRATE_TO);
-                    sender->flags |= REDIS_NODE_SLAVE;
+                    sender->flags &= ~(CLUSTER_NODE_MASTER|
+                                       CLUSTER_NODE_MIGRATE_TO);
+                    sender->flags |= CLUSTER_NODE_SLAVE;
 
                     /* Update config and state. */
                     clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                                          CLUSTER_TODO_UPDATE_STATE);
                 }
 
@@ -1790,13 +1799,13 @@
             }
         }
 
         /* Update our info about served slots.
          *
          * Note: this MUST happen after we update the master/slave state
-         * so that REDIS_NODE_MASTER flag will be set. */
+         * so that CLUSTER_NODE_MASTER flag will be set. */
 
         /* Many checks are only needed if the set of served slots this
          * instance claims is different compared to the set of slots we have
          * for it. Check this ASAP to avoid other computational expansive
          * checks later. */
         clusterNode *sender_master = NULL; /* Sender or its master if slave. */
@@ -1834,20 +1843,20 @@
          * new configuration, so other nodes that have an updated table must
          * do it. In this way A will stop to act as a master (or can try to
          * failover if there are the conditions to win the election). */
         if (sender && dirty_slots) {
             int j;
 
-            for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+            for (j = 0; j < CLUSTER_SLOTS; j++) {
                 if (bitmapTestBit(hdr->myslots,j)) {
                     if (server.cluster->slots[j] == sender ||
                         server.cluster->slots[j] == NULL) continue;
                     if (server.cluster->slots[j]->configEpoch >
                         senderConfigEpoch)
                     {
-                        redisLog(REDIS_VERBOSE,
+                        serverLog(LL_VERBOSE,
                             "Node %.40s has old slots configuration, sending "
                             "an UPDATE message about %.40s",
                                 sender->name, server.cluster->slots[j]->name);
                         clusterSendUpdate(sender->link,
                             server.cluster->slots[j]);
 
@@ -1874,25 +1883,25 @@
     } else if (type == CLUSTERMSG_TYPE_FAIL) {
         clusterNode *failing;
 
         if (sender) {
             failing = clusterLookupNode(hdr->data.fail.about.nodename);
             if (failing &&
-                !(failing->flags & (REDIS_NODE_FAIL|REDIS_NODE_MYSELF)))
+                !(failing->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_MYSELF)))
             {
-                redisLog(REDIS_NOTICE,
+                serverLog(LL_NOTICE,
                     "FAIL message received from %.40s about %.40s",
                     hdr->sender, hdr->data.fail.about.nodename);
-                failing->flags |= REDIS_NODE_FAIL;
+                failing->flags |= CLUSTER_NODE_FAIL;
                 failing->fail_time = mstime();
-                failing->flags &= ~REDIS_NODE_PFAIL;
+                failing->flags &= ~CLUSTER_NODE_PFAIL;
                 clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                                      CLUSTER_TODO_UPDATE_STATE);
             }
         } else {
-            redisLog(REDIS_NOTICE,
+            serverLog(LL_NOTICE,
                 "Ignoring FAIL message from unknown node %.40s about %.40s",
                 hdr->sender, hdr->data.fail.about.nodename);
         }
     } else if (type == CLUSTERMSG_TYPE_PUBLISH) {
         robj *channel, *message;
         uint32_t channel_len, message_len;
@@ -1933,16 +1942,16 @@
         /* This message is acceptable only if I'm a master and the sender
          * is one of my slaves. */
         if (!sender || sender->slaveof != myself) return 1;
         /* Manual failover requested from slaves. Initialize the state
          * accordingly. */
         resetManualFailover();
-        server.cluster->mf_end = mstime() + REDIS_CLUSTER_MF_TIMEOUT;
+        server.cluster->mf_end = mstime() + CLUSTER_MF_TIMEOUT;
         server.cluster->mf_slave = sender;
-        pauseClients(mstime()+(REDIS_CLUSTER_MF_TIMEOUT*2));
-        redisLog(REDIS_WARNING,"Manual failover requested by slave %.40s.",
+        pauseClients(mstime()+(CLUSTER_MF_TIMEOUT*2));
+        serverLog(LL_WARNING,"Manual failover requested by slave %.40s.",
             sender->name);
     } else if (type == CLUSTERMSG_TYPE_UPDATE) {
         clusterNode *n; /* The node the update is about. */
         uint64_t reportedConfigEpoch =
                     ntohu64(hdr->data.update.nodecfg.configEpoch);
 
@@ -1961,13 +1970,13 @@
 
         /* Check the bitmap of served slots and update our
          * config accordingly. */
         clusterUpdateSlotsConfigWith(n,reportedConfigEpoch,
             hdr->data.update.nodecfg.slots);
     } else {
-        redisLog(REDIS_WARNING,"Received unknown packet type: %d", type);
+        serverLog(LL_WARNING,"Received unknown packet type: %d", type);
     }
     return 1;
 }
 
 /* This function is called when we detect the link with this node is lost.
    We set the node as no longer connected. The Cluster Cron will detect
@@ -1982,18 +1991,18 @@
 /* Send data. This is handled using a trivial send buffer that gets
  * consumed by write(). We don't try to optimize this for speed too much
  * as this is a very low traffic channel. */
 void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     clusterLink *link = (clusterLink*) privdata;
     ssize_t nwritten;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(mask);
+    UNUSED(el);
+    UNUSED(mask);
 
     nwritten = write(fd, link->sndbuf, sdslen(link->sndbuf));
     if (nwritten <= 0) {
-        redisLog(REDIS_DEBUG,"I/O error writing to node link: %s",
+        serverLog(LL_DEBUG,"I/O error writing to node link: %s",
             strerror(errno));
         handleLinkIOError(link);
         return;
     }
     sdsrange(link->sndbuf,nwritten,-1);
     if (sdslen(link->sndbuf) == 0)
@@ -2006,14 +2015,14 @@
 void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     char buf[sizeof(clusterMsg)];
     ssize_t nread;
     clusterMsg *hdr;
     clusterLink *link = (clusterLink*) privdata;
     unsigned int readlen, rcvbuflen;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(mask);
+    UNUSED(el);
+    UNUSED(mask);
 
     while(1) { /* Read as long as there is data to read. */
         rcvbuflen = sdslen(link->rcvbuf);
         if (rcvbuflen < 8) {
             /* First, obtain the first 8 bytes to get the full message
              * length. */
@@ -2024,13 +2033,13 @@
             if (rcvbuflen == 8) {
                 /* Perform some sanity check on the message signature
                  * and length. */
                 if (memcmp(hdr->sig,"RCmb",4) != 0 ||
                     ntohl(hdr->totlen) < CLUSTERMSG_MIN_LEN)
                 {
-                    redisLog(REDIS_WARNING,
+                    serverLog(LL_WARNING,
                         "Bad message length or signature received "
                         "from Cluster bus.");
                     handleLinkIOError(link);
                     return;
                 }
             }
@@ -2040,13 +2049,13 @@
 
         nread = read(fd,buf,readlen);
         if (nread == -1 && errno == EAGAIN) return; /* No more data ready. */
 
         if (nread <= 0) {
             /* I/O error... */
-            redisLog(REDIS_DEBUG,"I/O error reading from node link: %s",
+            serverLog(LL_DEBUG,"I/O error reading from node link: %s",
                 (nread == 0) ? "connection closed" : strerror(errno));
             handleLinkIOError(link);
             return;
         } else {
             /* Read data and recast the pointer to the new buffer. */
             link->rcvbuf = sdscatlen(link->rcvbuf,buf,nread);
@@ -2092,13 +2101,13 @@
 
     di = dictGetSafeIterator(server.cluster->nodes);
     while((de = dictNext(di)) != NULL) {
         clusterNode *node = dictGetVal(de);
 
         if (!node->link) continue;
-        if (node->flags & (REDIS_NODE_MYSELF|REDIS_NODE_HANDSHAKE))
+        if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
             continue;
         clusterSendMessage(node->link,buf,len);
     }
     dictReleaseIterator(di);
 }
 
@@ -2120,18 +2129,18 @@
     hdr->ver = htons(CLUSTER_PROTO_VER);
     hdr->sig[0] = 'R';
     hdr->sig[1] = 'C';
     hdr->sig[2] = 'm';
     hdr->sig[3] = 'b';
     hdr->type = htons(type);
-    memcpy(hdr->sender,myself->name,REDIS_CLUSTER_NAMELEN);
+    memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN);
 
     memcpy(hdr->myslots,master->slots,sizeof(hdr->myslots));
-    memset(hdr->slaveof,0,REDIS_CLUSTER_NAMELEN);
+    memset(hdr->slaveof,0,CLUSTER_NAMELEN);
     if (myself->slaveof != NULL)
-        memcpy(hdr->slaveof,myself->slaveof->name, REDIS_CLUSTER_NAMELEN);
+        memcpy(hdr->slaveof,myself->slaveof->name, CLUSTER_NAMELEN);
     hdr->port = htons(server.port);
     hdr->flags = htons(myself->flags);
     hdr->state = server.cluster->state;
 
     /* Set the currentEpoch and configEpochs. */
     hdr->currentEpoch = htonu64(server.cluster->currentEpoch);
@@ -2232,38 +2241,38 @@
         /* Don't include this node: the whole packet header is about us
          * already, so we just gossip about other nodes. */
         if (this == myself) continue;
 
         /* Give a bias to FAIL/PFAIL nodes. */
         if (maxiterations > wanted*2 &&
-            !(this->flags & (REDIS_NODE_PFAIL|REDIS_NODE_FAIL)))
+            !(this->flags & (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL)))
             continue;
 
         /* In the gossip section don't include:
          * 1) Nodes in HANDSHAKE state.
          * 3) Nodes with the NOADDR flag set.
          * 4) Disconnected nodes if they don't have configured slots.
          */
-        if (this->flags & (REDIS_NODE_HANDSHAKE|REDIS_NODE_NOADDR) ||
+        if (this->flags & (CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_NOADDR) ||
             (this->link == NULL && this->numslots == 0))
         {
             freshnodes--; /* Tecnically not correct, but saves CPU. */
             continue;
         }
 
         /* Check if we already added this node */
         for (j = 0; j < gossipcount; j++) {
             if (memcmp(hdr->data.ping.gossip[j].nodename,this->name,
-                    REDIS_CLUSTER_NAMELEN) == 0) break;
+                    CLUSTER_NAMELEN) == 0) break;
         }
         if (j != gossipcount) continue;
 
         /* Add it */
         freshnodes--;
         gossip = &(hdr->data.ping.gossip[gossipcount]);
-        memcpy(gossip->nodename,this->name,REDIS_CLUSTER_NAMELEN);
+        memcpy(gossip->nodename,this->name,CLUSTER_NAMELEN);
         gossip->ping_sent = htonl(this->ping_sent);
         gossip->pong_received = htonl(this->pong_received);
         memcpy(gossip->ip,this->ip,sizeof(this->ip));
         gossip->port = htons(this->port);
         gossip->flags = htons(this->flags);
         gossip->notused1 = 0;
@@ -2361,34 +2370,34 @@
     decrRefCount(message);
     if (payload != buf) zfree(payload);
 }
 
 /* Send a FAIL message to all the nodes we are able to contact.
  * The FAIL message is sent when we detect that a node is failing
- * (REDIS_NODE_PFAIL) and we also receive a gossip confirmation of this:
- * we switch the node state to REDIS_NODE_FAIL and ask all the other
+ * (CLUSTER_NODE_PFAIL) and we also receive a gossip confirmation of this:
+ * we switch the node state to CLUSTER_NODE_FAIL and ask all the other
  * nodes to do the same ASAP. */
 void clusterSendFail(char *nodename) {
     unsigned char buf[sizeof(clusterMsg)];
     clusterMsg *hdr = (clusterMsg*) buf;
 
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_FAIL);
-    memcpy(hdr->data.fail.about.nodename,nodename,REDIS_CLUSTER_NAMELEN);
+    memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);
     clusterBroadcastMessage(buf,ntohl(hdr->totlen));
 }
 
 /* Send an UPDATE message to the specified link carrying the specified 'node'
  * slots configuration. The node name, slots bitmap, and configEpoch info
  * are included. */
 void clusterSendUpdate(clusterLink *link, clusterNode *node) {
     unsigned char buf[sizeof(clusterMsg)];
     clusterMsg *hdr = (clusterMsg*) buf;
 
     if (link == NULL) return;
     clusterBuildMessageHdr(hdr,CLUSTERMSG_TYPE_UPDATE);
-    memcpy(hdr->data.update.nodecfg.nodename,node->name,REDIS_CLUSTER_NAMELEN);
+    memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN);
     hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);
     memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));
     clusterSendMessage(link,buf,ntohl(hdr->totlen));
 }
 
 /* -----------------------------------------------------------------------------
@@ -2470,23 +2479,23 @@
 
     /* Request epoch must be >= our currentEpoch.
      * Note that it is impossible for it to actually be greater since
      * our currentEpoch was updated as a side effect of receiving this
      * request, if the request epoch was greater. */
     if (requestCurrentEpoch < server.cluster->currentEpoch) {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Failover auth denied to %.40s: reqEpoch (%llu) < curEpoch(%llu)",
             node->name,
             (unsigned long long) requestCurrentEpoch,
             (unsigned long long) server.cluster->currentEpoch);
         return;
     }
 
     /* I already voted for this epoch? Return ASAP. */
     if (server.cluster->lastVoteEpoch == server.cluster->currentEpoch) {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
                 "Failover auth denied to %.40s: already voted for epoch %llu",
                 node->name,
                 (unsigned long long) server.cluster->currentEpoch);
         return;
     }
 
@@ -2494,68 +2503,68 @@
      * The master can be non failing if the request is flagged
      * with CLUSTERMSG_FLAG0_FORCEACK (manual failover). */
     if (nodeIsMaster(node) || master == NULL ||
         (!nodeFailed(master) && !force_ack))
     {
         if (nodeIsMaster(node)) {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                     "Failover auth denied to %.40s: it is a master node",
                     node->name);
         } else if (master == NULL) {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                     "Failover auth denied to %.40s: I don't know its master",
                     node->name);
         } else if (!nodeFailed(master)) {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                     "Failover auth denied to %.40s: its master is up",
                     node->name);
         }
         return;
     }
 
     /* We did not voted for a slave about this master for two
      * times the node timeout. This is not strictly needed for correctness
      * of the algorithm but makes the base case more linear. */
     if (mstime() - node->slaveof->voted_time < server.cluster_node_timeout * 2)
     {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
                 "Failover auth denied to %.40s: "
                 "can't vote about this master before %lld milliseconds",
                 node->name,
                 (long long) ((server.cluster_node_timeout*2)-
                              (mstime() - node->slaveof->voted_time)));
         return;
     }
 
     /* The slave requesting the vote must have a configEpoch for the claimed
      * slots that is >= the one of the masters currently serving the same
      * slots in the current configuration. */
-    for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+    for (j = 0; j < CLUSTER_SLOTS; j++) {
         if (bitmapTestBit(claimed_slots, j) == 0) continue;
         if (server.cluster->slots[j] == NULL ||
             server.cluster->slots[j]->configEpoch <= requestConfigEpoch)
         {
             continue;
         }
         /* If we reached this point we found a slot that in our current slots
          * is served by a master with a greater configEpoch than the one claimed
          * by the slave requesting our vote. Refuse to vote for this slave. */
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
                 "Failover auth denied to %.40s: "
                 "slot %d epoch (%llu) > reqEpoch (%llu)",
                 node->name, j,
                 (unsigned long long) server.cluster->slots[j]->configEpoch,
                 (unsigned long long) requestConfigEpoch);
         return;
     }
 
     /* We can vote for this slave. */
     clusterSendFailoverAuth(node);
     server.cluster->lastVoteEpoch = server.cluster->currentEpoch;
     node->slaveof->voted_time = mstime();
-    redisLog(REDIS_WARNING, "Failover auth granted to %.40s for epoch %llu",
+    serverLog(LL_WARNING, "Failover auth granted to %.40s for epoch %llu",
         node->name, (unsigned long long) server.cluster->currentEpoch);
 }
 
 /* This function returns the "rank" of this instance, a slave, in the context
  * of its master-slaves ring. The rank of the slave is given by the number of
  * other slaves for the same master that have a better replication offset
@@ -2570,13 +2579,13 @@
  * offsets are more likely to win. */
 int clusterGetSlaveRank(void) {
     long long myoffset;
     int j, rank = 0;
     clusterNode *master;
 
-    redisAssert(nodeIsSlave(myself));
+    serverAssert(nodeIsSlave(myself));
     master = myself->slaveof;
     if (master == NULL) return 0; /* Never called by slaves without master. */
 
     myoffset = replicationGetSlaveOffset();
     for (j = 0; j < master->numslaves; j++)
         if (master->slaves[j] != myself &&
@@ -2594,61 +2603,61 @@
  *
  * 1) The reason for which the failover can't be initiated changed.
  *    The reasons also include a NONE reason we reset the state to
  *    when the slave finds that its master is fine (no FAIL flag).
  * 2) Also, the log is emitted again if the master is still down and
  *    the reason for not failing over is still the same, but more than
- *    REDIS_CLUSTER_CANT_FAILOVER_RELOG_PERIOD seconds elapsed.
+ *    CLUSTER_CANT_FAILOVER_RELOG_PERIOD seconds elapsed.
  * 3) Finally, the function only logs if the slave is down for more than
  *    five seconds + NODE_TIMEOUT. This way nothing is logged when a
  *    failover starts in a reasonable time.
  *
  * The function is called with the reason why the slave can't failover
- * which is one of the integer macros REDIS_CLUSTER_CANT_FAILOVER_*.
+ * which is one of the integer macros CLUSTER_CANT_FAILOVER_*.
  *
  * The function is guaranteed to be called only if 'myself' is a slave. */
 void clusterLogCantFailover(int reason) {
     char *msg;
     static time_t lastlog_time = 0;
     mstime_t nolog_fail_time = server.cluster_node_timeout + 5000;
 
     /* Don't log if we have the same reason for some time. */
     if (reason == server.cluster->cant_failover_reason &&
-        time(NULL)-lastlog_time < REDIS_CLUSTER_CANT_FAILOVER_RELOG_PERIOD)
+        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)
         return;
 
     server.cluster->cant_failover_reason = reason;
 
     /* We also don't emit any log if the master failed no long ago, the
      * goal of this function is to log slaves in a stalled condition for
      * a long time. */
     if (myself->slaveof &&
         nodeFailed(myself->slaveof) &&
         (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;
 
     switch(reason) {
-    case REDIS_CLUSTER_CANT_FAILOVER_DATA_AGE:
+    case CLUSTER_CANT_FAILOVER_DATA_AGE:
         msg = "Disconnected from master for longer than allowed. "
               "Please check the 'cluster-slave-validity-factor' configuration "
               "option.";
         break;
-    case REDIS_CLUSTER_CANT_FAILOVER_WAITING_DELAY:
+    case CLUSTER_CANT_FAILOVER_WAITING_DELAY:
         msg = "Waiting the delay before I can start a new failover.";
         break;
-    case REDIS_CLUSTER_CANT_FAILOVER_EXPIRED:
+    case CLUSTER_CANT_FAILOVER_EXPIRED:
         msg = "Failover attempt expired.";
         break;
-    case REDIS_CLUSTER_CANT_FAILOVER_WAITING_VOTES:
+    case CLUSTER_CANT_FAILOVER_WAITING_VOTES:
         msg = "Waiting for votes, but majority still not reached.";
         break;
     default:
         msg = "Unknown reason code.";
         break;
     }
     lastlog_time = time(NULL);
-    redisLog(REDIS_WARNING,"Currently unable to failover: %s", msg);
+    serverLog(LL_WARNING,"Currently unable to failover: %s", msg);
 }
 
 /* This function implements the final part of automatic and manual failovers,
  * where the slave grabs its master's hash slots, and propagates the new
  * configuration.
  *
@@ -2662,13 +2671,13 @@
 
     /* 1) Turn this node into a master. */
     clusterSetNodeAsMaster(myself);
     replicationUnsetMaster();
 
     /* 2) Claim all the slots assigned to our master. */
-    for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+    for (j = 0; j < CLUSTER_SLOTS; j++) {
         if (clusterNodeGetSlotBit(oldmaster,j)) {
             clusterDelSlot(j);
             clusterAddSlot(myself,j);
         }
     }
 
@@ -2722,19 +2731,19 @@
         myself->slaveof == NULL ||
         (!nodeFailed(myself->slaveof) && !manual_failover) ||
         myself->slaveof->numslots == 0)
     {
         /* There are no reasons to failover, so we set the reason why we
          * are returning without failing over to NONE. */
-        server.cluster->cant_failover_reason = REDIS_CLUSTER_CANT_FAILOVER_NONE;
+        server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
         return;
     }
 
     /* Set data_age to the number of seconds we are disconnected from
      * the master. */
-    if (server.repl_state == REDIS_REPL_CONNECTED) {
+    if (server.repl_state == REPL_STATE_CONNECTED) {
         data_age = (mstime_t)(server.unixtime - server.master->lastinteraction)
                    * 1000;
     } else {
         data_age = (mstime_t)(server.unixtime - server.repl_down_since) * 1000;
     }
 
@@ -2751,13 +2760,13 @@
     if (server.cluster_slave_validity_factor &&
         data_age >
         (((mstime_t)server.repl_ping_slave_period * 1000) +
          (server.cluster_node_timeout * server.cluster_slave_validity_factor)))
     {
         if (!manual_failover) {
-            clusterLogCantFailover(REDIS_CLUSTER_CANT_FAILOVER_DATA_AGE);
+            clusterLogCantFailover(CLUSTER_CANT_FAILOVER_DATA_AGE);
             return;
         }
     }
 
     /* If the previous failover attempt timedout and the retry time has
      * elapsed, we can setup a new one. */
@@ -2775,13 +2784,13 @@
             server.cluster->failover_auth_rank * 1000;
         /* However if this is a manual failover, no delay is needed. */
         if (server.cluster->mf_end) {
             server.cluster->failover_auth_time = mstime();
             server.cluster->failover_auth_rank = 0;
         }
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Start of election delayed for %lld milliseconds "
             "(rank #%d, offset %lld).",
             server.cluster->failover_auth_time - mstime(),
             server.cluster->failover_auth_rank,
             replicationGetSlaveOffset());
         /* Now that we have a scheduled election, broadcast our offset
@@ -2802,35 +2811,35 @@
         int newrank = clusterGetSlaveRank();
         if (newrank > server.cluster->failover_auth_rank) {
             long long added_delay =
                 (newrank - server.cluster->failover_auth_rank) * 1000;
             server.cluster->failover_auth_time += added_delay;
             server.cluster->failover_auth_rank = newrank;
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "Slave rank updated to #%d, added %lld milliseconds of delay.",
                 newrank, added_delay);
         }
     }
 
     /* Return ASAP if we can't still start the election. */
     if (mstime() < server.cluster->failover_auth_time) {
-        clusterLogCantFailover(REDIS_CLUSTER_CANT_FAILOVER_WAITING_DELAY);
+        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_DELAY);
         return;
     }
 
     /* Return ASAP if the election is too old to be valid. */
     if (auth_age > auth_timeout) {
-        clusterLogCantFailover(REDIS_CLUSTER_CANT_FAILOVER_EXPIRED);
+        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_EXPIRED);
         return;
     }
 
     /* Ask for votes if needed. */
     if (server.cluster->failover_auth_sent == 0) {
         server.cluster->currentEpoch++;
         server.cluster->failover_auth_epoch = server.cluster->currentEpoch;
-        redisLog(REDIS_WARNING,"Starting a failover election for epoch %llu.",
+        serverLog(LL_WARNING,"Starting a failover election for epoch %llu.",
             (unsigned long long) server.cluster->currentEpoch);
         clusterRequestFailoverAuth();
         server.cluster->failover_auth_sent = 1;
         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                              CLUSTER_TODO_UPDATE_STATE|
                              CLUSTER_TODO_FSYNC_CONFIG);
@@ -2838,27 +2847,27 @@
     }
 
     /* Check if we reached the quorum. */
     if (server.cluster->failover_auth_count >= needed_quorum) {
         /* We have the quorum, we can finally failover the master. */
 
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Failover election won: I'm the new master.");
 
         /* Update my configEpoch to the epoch of the election. */
         if (myself->configEpoch < server.cluster->failover_auth_epoch) {
             myself->configEpoch = server.cluster->failover_auth_epoch;
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "configEpoch set to %llu after successful failover",
                 (unsigned long long) myself->configEpoch);
         }
 
         /* Take responsability for the cluster slots. */
         clusterFailoverReplaceYourMaster();
     } else {
-        clusterLogCantFailover(REDIS_CLUSTER_CANT_FAILOVER_WAITING_VOTES);
+        clusterLogCantFailover(CLUSTER_CANT_FAILOVER_WAITING_VOTES);
     }
 }
 
 /* -----------------------------------------------------------------------------
  * CLUSTER slave migration
  *
@@ -2890,13 +2899,13 @@
     int j, okslaves = 0;
     clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;
     dictIterator *di;
     dictEntry *de;
 
     /* Step 1: Don't migrate if the cluster state is not ok. */
-    if (server.cluster->state != REDIS_CLUSTER_OK) return;
+    if (server.cluster->state != CLUSTER_OK) return;
 
     /* Step 2: Don't migrate if my master will not be left with at least
      *         'migration-barrier' slaves after my migration. */
     if (mymaster == NULL) return;
     for (j = 0; j < mymaster->numslaves; j++)
         if (!nodeFailed(mymaster->slaves[j]) &&
@@ -2921,13 +2930,13 @@
 
         /* We want to migrate only if this master is working, orphaned, and
          * used to have slaves or if failed over a master that had slaves
          * (MIGRATE_TO flag). This way we only migrate to instances that were
          * supposed to have replicas. */
         if (nodeIsSlave(node) || nodeFailed(node)) is_orphaned = 0;
-        if (!(node->flags & REDIS_NODE_MIGRATE_TO)) is_orphaned = 0;
+        if (!(node->flags & CLUSTER_NODE_MIGRATE_TO)) is_orphaned = 0;
 
         /* Check number of working slaves. */
         if (nodeIsMaster(node)) okslaves = clusterCountNonFailingSlaves(node);
         if (okslaves > 0) is_orphaned = 0;
 
         if (is_orphaned) {
@@ -2944,13 +2953,13 @@
          * to a master with the maximum number of slaves and with the smallest
          * node ID. */
         if (okslaves == max_slaves) {
             for (j = 0; j < node->numslaves; j++) {
                 if (memcmp(node->slaves[j]->name,
                            candidate->name,
-                           REDIS_CLUSTER_NAMELEN) < 0)
+                           CLUSTER_NAMELEN) < 0)
                 {
                     candidate = node->slaves[j];
                 }
             }
         }
     }
@@ -2959,15 +2968,15 @@
     /* Step 4: perform the migration if there is a target, and if I'm the
      * candidate, but only if the master is continuously orphaned for a
      * couple of seconds, so that during failovers, we give some time to
      * the natural slaves of this instance to advertise their switch from
      * the old master to the new one. */
     if (target && candidate == myself &&
-        (mstime()-target->orphaned_time) > REDIS_CLUSTER_SLAVE_MIGRATION_DELAY)
+        (mstime()-target->orphaned_time) > CLUSTER_SLAVE_MIGRATION_DELAY)
     {
-        redisLog(REDIS_WARNING,"Migrating to orphaned master %.40s",
+        serverLog(LL_WARNING,"Migrating to orphaned master %.40s",
             target->name);
         clusterSetMaster(target);
     }
 }
 
 /* -----------------------------------------------------------------------------
@@ -2975,13 +2984,13 @@
  *
  * This are the important steps performed by slaves during a manual failover:
  * 1) User send CLUSTER FAILOVER command. The failover state is initialized
  *    setting mf_end to the millisecond unix time at which we'll abort the
  *    attempt.
  * 2) Slave sends a MFSTART message to the master requesting to pause clients
- *    for two times the manual failover timeout REDIS_CLUSTER_MF_TIMEOUT.
+ *    for two times the manual failover timeout CLUSTER_MF_TIMEOUT.
  *    When master is paused for manual failover, it also starts to flag
  *    packets with CLUSTERMSG_FLAG0_PAUSED.
  * 3) Slave waits for master to send its replication offset flagged as PAUSED.
  * 4) If slave received the offset from the master, and its offset matches,
  *    mf_can_start is set to 1, and clusterHandleSlaveFailover() will perform
  *    the failover as usually, with the difference that the vote request
@@ -3015,13 +3024,13 @@
     server.cluster->mf_master_offset = 0;
 }
 
 /* If a manual failover timed out, abort it. */
 void manualFailoverCheckTimeout(void) {
     if (server.cluster->mf_end && server.cluster->mf_end < mstime()) {
-        redisLog(REDIS_WARNING,"Manual failover timed out.");
+        serverLog(LL_WARNING,"Manual failover timed out.");
         resetManualFailover();
     }
 }
 
 /* This function is called from the cluster cron function in order to go
  * forward with a manual failover state machine. */
@@ -3036,13 +3045,13 @@
     if (server.cluster->mf_master_offset == 0) return; /* Wait for offset... */
 
     if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {
         /* Our replication offset matches the master replication offset
          * announced after clients were paused. We can start the failover. */
         server.cluster->mf_can_start = 1;
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "All master replication stream processed, "
             "manual failover can start.");
     }
 }
 
 /* -----------------------------------------------------------------------------
@@ -3073,13 +3082,13 @@
 
     /* Check if we have disconnected nodes and re-establish the connection. */
     di = dictGetSafeIterator(server.cluster->nodes);
     while((de = dictNext(di)) != NULL) {
         clusterNode *node = dictGetVal(de);
 
-        if (node->flags & (REDIS_NODE_MYSELF|REDIS_NODE_NOADDR)) continue;
+        if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) continue;
 
         /* A Node in HANDSHAKE state has a limited lifespan equal to the
          * configured node timeout. */
         if (nodeInHandshake(node) && now - node->ctime > handshake_timeout) {
             clusterDelNode(node);
             continue;
@@ -3088,23 +3097,23 @@
         if (node->link == NULL) {
             int fd;
             mstime_t old_ping_sent;
             clusterLink *link;
 
             fd = anetTcpNonBlockBindConnect(server.neterr, node->ip,
-                node->port+REDIS_CLUSTER_PORT_INCR, REDIS_BIND_ADDR);
+                node->port+CLUSTER_PORT_INCR, NET_FIRST_BIND_ADDR);
             if (fd == -1) {
                 /* We got a synchronous error from connect before
                  * clusterSendPing() had a chance to be called.
                  * If node->ping_sent is zero, failure detection can't work,
                  * so we claim we actually sent a ping now (that will
                  * be really sent as soon as the link is obtained). */
                 if (node->ping_sent == 0) node->ping_sent = mstime();
-                redisLog(REDIS_DEBUG, "Unable to connect to "
+                serverLog(LL_DEBUG, "Unable to connect to "
                     "Cluster Node [%s]:%d -> %s", node->ip,
-                    node->port+REDIS_CLUSTER_PORT_INCR,
+                    node->port+CLUSTER_PORT_INCR,
                     server.neterr);
                 continue;
             }
             link = createClusterLink(node);
             link->fd = fd;
             node->link = link;
@@ -3114,29 +3123,29 @@
              * to avoid false positives in failure detection.
              *
              * If the node is flagged as MEET, we send a MEET message instead
              * of a PING one, to force the receiver to add us in its node
              * table. */
             old_ping_sent = node->ping_sent;
-            clusterSendPing(link, node->flags & REDIS_NODE_MEET ?
+            clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?
                     CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);
             if (old_ping_sent) {
                 /* If there was an active ping before the link was
                  * disconnected, we want to restore the ping time, otherwise
                  * replaced by the clusterSendPing() call. */
                 node->ping_sent = old_ping_sent;
             }
             /* We can clear the flag after the first packet is sent.
              * If we'll never receive a PONG, we'll never send new packets
              * to this node. Instead after the PONG is received and we
              * are no longer in meet/handshake status, we want to send
              * normal PING packets. */
-            node->flags &= ~REDIS_NODE_MEET;
+            node->flags &= ~CLUSTER_NODE_MEET;
 
-            redisLog(REDIS_DEBUG,"Connecting with Node %.40s at %s:%d",
-                    node->name, node->ip, node->port+REDIS_CLUSTER_PORT_INCR);
+            serverLog(LL_DEBUG,"Connecting with Node %.40s at %s:%d",
+                    node->name, node->ip, node->port+CLUSTER_PORT_INCR);
         }
     }
     dictReleaseIterator(di);
 
     /* Ping some random node 1 time every 10 iterations, so that we usually ping
      * one random node every second. */
@@ -3148,21 +3157,21 @@
         for (j = 0; j < 5; j++) {
             de = dictGetRandomKey(server.cluster->nodes);
             clusterNode *this = dictGetVal(de);
 
             /* Don't ping nodes disconnected or with a ping currently active. */
             if (this->link == NULL || this->ping_sent != 0) continue;
-            if (this->flags & (REDIS_NODE_MYSELF|REDIS_NODE_HANDSHAKE))
+            if (this->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
                 continue;
             if (min_pong_node == NULL || min_pong > this->pong_received) {
                 min_pong_node = this;
                 min_pong = this->pong_received;
             }
         }
         if (min_pong_node) {
-            redisLog(REDIS_DEBUG,"Pinging node %.40s", min_pong_node->name);
+            serverLog(LL_DEBUG,"Pinging node %.40s", min_pong_node->name);
             clusterSendPing(min_pong_node->link, CLUSTERMSG_TYPE_PING);
         }
     }
 
     /* Iterate nodes to check if we need to flag something as failing.
      * This loop is also responsible to:
@@ -3177,25 +3186,25 @@
     while((de = dictNext(di)) != NULL) {
         clusterNode *node = dictGetVal(de);
         now = mstime(); /* Use an updated time at every iteration. */
         mstime_t delay;
 
         if (node->flags &
-            (REDIS_NODE_MYSELF|REDIS_NODE_NOADDR|REDIS_NODE_HANDSHAKE))
+            (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
                 continue;
 
         /* Orphaned master check, useful only if the current instance
          * is a slave that may migrate to another master. */
         if (nodeIsSlave(myself) && nodeIsMaster(node) && !nodeFailed(node)) {
             int okslaves = clusterCountNonFailingSlaves(node);
 
             /* A master is orphaned if it is serving a non-zero number of
              * slots, have no working slaves, but used to have at least one
              * slave, or failed over a master that used to have slaves. */
             if (okslaves == 0 && node->numslots > 0 &&
-                node->flags & REDIS_NODE_MIGRATE_TO)
+                node->flags & CLUSTER_NODE_MIGRATE_TO)
             {
                 orphaned_masters++;
             }
             if (okslaves > max_slaves) max_slaves = okslaves;
             if (nodeIsSlave(myself) && myself->slaveof == node)
                 this_slaves = okslaves;
@@ -3247,16 +3256,16 @@
          * code at all. */
         delay = now - node->ping_sent;
 
         if (delay > server.cluster_node_timeout) {
             /* Timeout reached. Set the node as possibly failing if it is
              * not already in this state. */
-            if (!(node->flags & (REDIS_NODE_PFAIL|REDIS_NODE_FAIL))) {
-                redisLog(REDIS_DEBUG,"*** NODE %.40s possibly failing",
+            if (!(node->flags & (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL))) {
+                serverLog(LL_DEBUG,"*** NODE %.40s possibly failing",
                     node->name);
-                node->flags |= REDIS_NODE_PFAIL;
+                node->flags |= CLUSTER_NODE_PFAIL;
                 update_state = 1;
             }
         }
     }
     dictReleaseIterator(di);
 
@@ -3283,13 +3292,13 @@
          * a migration if there is no master with at least *two* working
          * slaves. */
         if (orphaned_masters && max_slaves >= 2 && this_slaves == max_slaves)
             clusterHandleSlaveMigration(max_slaves);
     }
 
-    if (update_state || server.cluster->state == REDIS_CLUSTER_FAIL)
+    if (update_state || server.cluster->state == CLUSTER_FAIL)
         clusterUpdateState();
 }
 
 /* This function is called before the event handler returns to sleep for
  * events. It is useful to perform operations that must be done ASAP in
  * reaction to events fired but that are not safe to perform inside event
@@ -3344,17 +3353,51 @@
 void bitmapClearBit(unsigned char *bitmap, int pos) {
     off_t byte = pos/8;
     int bit = pos&7;
     bitmap[byte] &= ~(1<<bit);
 }
 
+/* Return non-zero if there is at least one master with slaves in the cluster.
+ * Otherwise zero is returned. Used by clusterNodeSetSlotBit() to set the
+ * MIGRATE_TO flag the when a master gets the first slot. */
+int clusterMastersHaveSlaves(void) {
+    dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
+    dictEntry *de;
+    int slaves = 0;
+    while((de = dictNext(di)) != NULL) {
+        clusterNode *node = dictGetVal(de);
+
+        if (nodeIsSlave(node)) continue;
+        slaves += node->numslaves;
+    }
+    dictReleaseIterator(di);
+    return slaves != 0;
+}
+
 /* Set the slot bit and return the old value. */
 int clusterNodeSetSlotBit(clusterNode *n, int slot) {
     int old = bitmapTestBit(n->slots,slot);
     bitmapSetBit(n->slots,slot);
-    if (!old) n->numslots++;
+    if (!old) {
+        n->numslots++;
+        /* When a master gets its first slot, even if it has no slaves,
+         * it gets flagged with MIGRATE_TO, that is, the master is a valid
+         * target for replicas migration, if and only if at least one of
+         * the other masters has slaves right now.
+         *
+         * Normally masters are valid targerts of replica migration if:
+         * 1. The used to have slaves (but no longer have).
+         * 2. They are slaves failing over a master that used to have slaves.
+         *
+         * However new masters with slots assigned are considered valid
+         * migration tagets if the rest of the cluster is not a slave-less.
+         *
+         * See https://github.com/antirez/redis/issues/3043 for more info. */
+        if (n->numslots == 1 && clusterMastersHaveSlaves())
+            n->flags |= CLUSTER_NODE_MIGRATE_TO;
+    }
     return old;
 }
 
 /* Clear the slot bit and return the old value. */
 int clusterNodeClearSlotBit(clusterNode *n, int slot) {
     int old = bitmapTestBit(n->slots,slot);
@@ -3366,40 +3409,40 @@
 /* Return the slot bit from the cluster node structure. */
 int clusterNodeGetSlotBit(clusterNode *n, int slot) {
     return bitmapTestBit(n->slots,slot);
 }
 
 /* Add the specified slot to the list of slots that node 'n' will
- * serve. Return REDIS_OK if the operation ended with success.
+ * serve. Return C_OK if the operation ended with success.
  * If the slot is already assigned to another instance this is considered
- * an error and REDIS_ERR is returned. */
+ * an error and C_ERR is returned. */
 int clusterAddSlot(clusterNode *n, int slot) {
-    if (server.cluster->slots[slot]) return REDIS_ERR;
+    if (server.cluster->slots[slot]) return C_ERR;
     clusterNodeSetSlotBit(n,slot);
     server.cluster->slots[slot] = n;
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* Delete the specified slot marking it as unassigned.
- * Returns REDIS_OK if the slot was assigned, otherwise if the slot was
- * already unassigned REDIS_ERR is returned. */
+ * Returns C_OK if the slot was assigned, otherwise if the slot was
+ * already unassigned C_ERR is returned. */
 int clusterDelSlot(int slot) {
     clusterNode *n = server.cluster->slots[slot];
 
-    if (!n) return REDIS_ERR;
-    redisAssert(clusterNodeClearSlotBit(n,slot) == 1);
+    if (!n) return C_ERR;
+    serverAssert(clusterNodeClearSlotBit(n,slot) == 1);
     server.cluster->slots[slot] = NULL;
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* Delete all the slots associated with the specified node.
  * The number of deleted slots is returned. */
 int clusterDelNodeSlots(clusterNode *node) {
     int deleted = 0, j;
 
-    for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+    for (j = 0; j < CLUSTER_SLOTS; j++) {
         if (clusterNodeGetSlotBit(node,j)) clusterDelSlot(j);
         deleted++;
     }
     return deleted;
 }
 
@@ -3417,15 +3460,15 @@
  * -------------------------------------------------------------------------- */
 
 /* The following are defines that are only used in the evaluation function
  * and are based on heuristics. Actaully the main point about the rejoin and
  * writable delay is that they should be a few orders of magnitude larger
  * than the network latency. */
-#define REDIS_CLUSTER_MAX_REJOIN_DELAY 5000
-#define REDIS_CLUSTER_MIN_REJOIN_DELAY 500
-#define REDIS_CLUSTER_WRITABLE_DELAY 2000
+#define CLUSTER_MAX_REJOIN_DELAY 5000
+#define CLUSTER_MIN_REJOIN_DELAY 500
+#define CLUSTER_WRITABLE_DELAY 2000
 
 void clusterUpdateState(void) {
     int j, new_state;
     int reachable_masters = 0;
     static mstime_t among_minority_time;
     static mstime_t first_call_time = 0;
@@ -3437,26 +3480,26 @@
      * master, after a reboot, without giving the cluster a chance to
      * reconfigure this node. Note that the delay is calculated starting from
      * the first call to this function and not since the server start, in order
      * to don't count the DB loading time. */
     if (first_call_time == 0) first_call_time = mstime();
     if (nodeIsMaster(myself) &&
-        server.cluster->state == REDIS_CLUSTER_FAIL &&
-        mstime() - first_call_time < REDIS_CLUSTER_WRITABLE_DELAY) return;
+        server.cluster->state == CLUSTER_FAIL &&
+        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;
 
     /* Start assuming the state is OK. We'll turn it into FAIL if there
      * are the right conditions. */
-    new_state = REDIS_CLUSTER_OK;
+    new_state = CLUSTER_OK;
 
     /* Check if all the slots are covered. */
     if (server.cluster_require_full_coverage) {
-        for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+        for (j = 0; j < CLUSTER_SLOTS; j++) {
             if (server.cluster->slots[j] == NULL ||
-                server.cluster->slots[j]->flags & (REDIS_NODE_FAIL))
+                server.cluster->slots[j]->flags & (CLUSTER_NODE_FAIL))
             {
-                new_state = REDIS_CLUSTER_FAIL;
+                new_state = CLUSTER_FAIL;
                 break;
             }
         }
     }
 
     /* Compute the cluster size, that is the number of master nodes
@@ -3472,53 +3515,53 @@
         di = dictGetSafeIterator(server.cluster->nodes);
         while((de = dictNext(di)) != NULL) {
             clusterNode *node = dictGetVal(de);
 
             if (nodeIsMaster(node) && node->numslots) {
                 server.cluster->size++;
-                if ((node->flags & (REDIS_NODE_FAIL|REDIS_NODE_PFAIL)) == 0)
+                if ((node->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) == 0)
                     reachable_masters++;
             }
         }
         dictReleaseIterator(di);
     }
 
     /* If we are in a minority partition, change the cluster state
      * to FAIL. */
     {
         int needed_quorum = (server.cluster->size / 2) + 1;
 
         if (reachable_masters < needed_quorum) {
-            new_state = REDIS_CLUSTER_FAIL;
+            new_state = CLUSTER_FAIL;
             among_minority_time = mstime();
         }
     }
 
     /* Log a state change */
     if (new_state != server.cluster->state) {
         mstime_t rejoin_delay = server.cluster_node_timeout;
 
         /* If the instance is a master and was partitioned away with the
          * minority, don't let it accept queries for some time after the
          * partition heals, to make sure there is enough time to receive
          * a configuration update. */
-        if (rejoin_delay > REDIS_CLUSTER_MAX_REJOIN_DELAY)
-            rejoin_delay = REDIS_CLUSTER_MAX_REJOIN_DELAY;
-        if (rejoin_delay < REDIS_CLUSTER_MIN_REJOIN_DELAY)
-            rejoin_delay = REDIS_CLUSTER_MIN_REJOIN_DELAY;
+        if (rejoin_delay > CLUSTER_MAX_REJOIN_DELAY)
+            rejoin_delay = CLUSTER_MAX_REJOIN_DELAY;
+        if (rejoin_delay < CLUSTER_MIN_REJOIN_DELAY)
+            rejoin_delay = CLUSTER_MIN_REJOIN_DELAY;
 
-        if (new_state == REDIS_CLUSTER_OK &&
+        if (new_state == CLUSTER_OK &&
             nodeIsMaster(myself) &&
             mstime() - among_minority_time < rejoin_delay)
         {
             return;
         }
 
         /* Change the state and log the event. */
-        redisLog(REDIS_WARNING,"Cluster state changed: %s",
-            new_state == REDIS_CLUSTER_OK ? "ok" : "fail");
+        serverLog(LL_WARNING,"Cluster state changed: %s",
+            new_state == CLUSTER_OK ? "ok" : "fail");
         server.cluster->state = new_state;
     }
 }
 
 /* This function is called after the node startup in order to verify that data
  * loaded from disk is in agreement with the cluster configuration:
@@ -3528,39 +3571,39 @@
  *    A) If no other node is in charge according to the current cluster
  *       configuration, we add these slots to our node.
  *    B) If according to our config other nodes are already in charge for
  *       this lots, we set the slots as IMPORTING from our point of view
  *       in order to justify we have those slots, and in order to make
  *       redis-trib aware of the issue, so that it can try to fix it.
- * 2) If we find data in a DB different than DB0 we return REDIS_ERR to
+ * 2) If we find data in a DB different than DB0 we return C_ERR to
  *    signal the caller it should quit the server with an error message
  *    or take other actions.
  *
- * The function always returns REDIS_OK even if it will try to correct
+ * The function always returns C_OK even if it will try to correct
  * the error described in "1". However if data is found in DB different
- * from DB0, REDIS_ERR is returned.
+ * from DB0, C_ERR is returned.
  *
  * The function also uses the logging facility in order to warn the user
  * about desynchronizations between the data we have in memory and the
  * cluster configuration. */
 int verifyClusterConfigWithData(void) {
     int j;
     int update_config = 0;
 
     /* If this node is a slave, don't perform the check at all as we
      * completely depend on the replication stream. */
-    if (nodeIsSlave(myself)) return REDIS_OK;
+    if (nodeIsSlave(myself)) return C_OK;
 
     /* Make sure we only have keys in DB0. */
     for (j = 1; j < server.dbnum; j++) {
-        if (dictSize(server.db[j].dict)) return REDIS_ERR;
+        if (dictSize(server.db[j].dict)) return C_ERR;
     }
 
     /* Check that all the slots we see populated memory have a corresponding
      * entry in the cluster table. Otherwise fix the table. */
-    for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+    for (j = 0; j < CLUSTER_SLOTS; j++) {
         if (!countKeysInSlot(j)) continue; /* No keys in this slot. */
         /* Check if we are assigned to this slot or if we are importing it.
          * In both cases check the next slot as the configuration makes
          * sense. */
         if (server.cluster->slots[j] == myself ||
             server.cluster->importing_slots_from[j] != NULL) continue;
@@ -3569,39 +3612,39 @@
          * slot 'j' populated even if we are not importing it, nor we are
          * assigned to this slot. Fix this condition. */
 
         update_config++;
         /* Case A: slot is unassigned. Take responsibility for it. */
         if (server.cluster->slots[j] == NULL) {
-            redisLog(REDIS_WARNING, "I have keys for unassigned slot %d. "
+            serverLog(LL_WARNING, "I have keys for unassigned slot %d. "
                                     "Taking responsibility for it.",j);
             clusterAddSlot(myself,j);
         } else {
-            redisLog(REDIS_WARNING, "I have keys for slot %d, but the slot is "
+            serverLog(LL_WARNING, "I have keys for slot %d, but the slot is "
                                     "assigned to another node. "
                                     "Setting it to importing state.",j);
             server.cluster->importing_slots_from[j] = server.cluster->slots[j];
         }
     }
     if (update_config) clusterSaveConfigOrDie(1);
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* -----------------------------------------------------------------------------
  * SLAVE nodes handling
  * -------------------------------------------------------------------------- */
 
 /* Set the specified node 'n' as master for this node.
  * If this node is currently a master, it is turned into a slave. */
 void clusterSetMaster(clusterNode *n) {
-    redisAssert(n != myself);
-    redisAssert(myself->numslots == 0);
+    serverAssert(n != myself);
+    serverAssert(myself->numslots == 0);
 
     if (nodeIsMaster(myself)) {
-        myself->flags &= ~(REDIS_NODE_MASTER|REDIS_NODE_MIGRATE_TO);
-        myself->flags |= REDIS_NODE_SLAVE;
+        myself->flags &= ~(CLUSTER_NODE_MASTER|CLUSTER_NODE_MIGRATE_TO);
+        myself->flags |= CLUSTER_NODE_SLAVE;
         clusterCloseAllSlots();
     } else {
         if (myself->slaveof)
             clusterNodeRemoveSlave(myself->slaveof,myself);
     }
     myself->slaveof = n;
@@ -3617,24 +3660,24 @@
 struct redisNodeFlags {
     uint16_t flag;
     char *name;
 };
 
 static struct redisNodeFlags redisNodeFlagsTable[] = {
-    {REDIS_NODE_MYSELF,    "myself,"},
-    {REDIS_NODE_MASTER,    "master,"},
-    {REDIS_NODE_SLAVE,     "slave,"},
-    {REDIS_NODE_PFAIL,     "fail?,"},
-    {REDIS_NODE_FAIL,      "fail,"},
-    {REDIS_NODE_HANDSHAKE, "handshake,"},
-    {REDIS_NODE_NOADDR,    "noaddr,"}
+    {CLUSTER_NODE_MYSELF,       "myself,"},
+    {CLUSTER_NODE_MASTER,       "master,"},
+    {CLUSTER_NODE_SLAVE,        "slave,"},
+    {CLUSTER_NODE_PFAIL,        "fail?,"},
+    {CLUSTER_NODE_FAIL,         "fail,"},
+    {CLUSTER_NODE_HANDSHAKE,    "handshake,"},
+    {CLUSTER_NODE_NOADDR,       "noaddr,"}
 };
 
 /* Concatenate the comma separated list of node flags to the given SDS
  * string 'ci'. */
-sds representRedisNodeFlags(sds ci, uint16_t flags) {
+sds representClusterNodeFlags(sds ci, uint16_t flags) {
     if (flags == 0) {
         ci = sdscat(ci,"noflags,");
     } else {
         int i, size = sizeof(redisNodeFlagsTable)/sizeof(struct redisNodeFlags);
         for (i = 0; i < size; i++) {
             struct redisNodeFlags *nodeflag = redisNodeFlagsTable + i;
@@ -3657,38 +3700,38 @@
     ci = sdscatprintf(sdsempty(),"%.40s %s:%d ",
         node->name,
         node->ip,
         node->port);
 
     /* Flags */
-    ci = representRedisNodeFlags(ci, node->flags);
+    ci = representClusterNodeFlags(ci, node->flags);
 
     /* Slave of... or just "-" */
     if (node->slaveof)
         ci = sdscatprintf(ci," %.40s ",node->slaveof->name);
     else
         ci = sdscatlen(ci," - ",3);
 
     /* Latency from the POV of this node, config epoch, link status */
     ci = sdscatprintf(ci,"%lld %lld %llu %s",
         (long long) node->ping_sent,
         (long long) node->pong_received,
         (unsigned long long) node->configEpoch,
-        (node->link || node->flags & REDIS_NODE_MYSELF) ?
+        (node->link || node->flags & CLUSTER_NODE_MYSELF) ?
                     "connected" : "disconnected");
 
     /* Slots served by this instance */
     start = -1;
-    for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+    for (j = 0; j < CLUSTER_SLOTS; j++) {
         int bit;
 
         if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {
             if (start == -1) start = j;
         }
-        if (start != -1 && (!bit || j == REDIS_CLUSTER_SLOTS-1)) {
-            if (bit && j == REDIS_CLUSTER_SLOTS-1) j++;
+        if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {
+            if (bit && j == CLUSTER_SLOTS-1) j++;
 
             if (start == j-1) {
                 ci = sdscatprintf(ci," %d",start);
             } else {
                 ci = sdscatprintf(ci," %d-%d",start,j-1);
             }
@@ -3696,14 +3739,14 @@
         }
     }
 
     /* Just for MYSELF node we also dump info about slots that
      * we are migrating to other instances or importing from other
      * instances. */
-    if (node->flags & REDIS_NODE_MYSELF) {
-        for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+    if (node->flags & CLUSTER_NODE_MYSELF) {
+        for (j = 0; j < CLUSTER_SLOTS; j++) {
             if (server.cluster->migrating_slots_to[j]) {
                 ci = sdscatprintf(ci," [%d->-%.40s]",j,
                     server.cluster->migrating_slots_to[j]->name);
             } else if (server.cluster->importing_slots_from[j]) {
                 ci = sdscatprintf(ci," [%d-<-%.40s]",j,
                     server.cluster->importing_slots_from[j]->name);
@@ -3745,31 +3788,33 @@
 }
 
 /* -----------------------------------------------------------------------------
  * CLUSTER command
  * -------------------------------------------------------------------------- */
 
-int getSlotOrReply(redisClient *c, robj *o) {
+int getSlotOrReply(client *c, robj *o) {
     long long slot;
 
-    if (getLongLongFromObject(o,&slot) != REDIS_OK ||
-        slot < 0 || slot >= REDIS_CLUSTER_SLOTS)
+    if (getLongLongFromObject(o,&slot) != C_OK ||
+        slot < 0 || slot >= CLUSTER_SLOTS)
     {
         addReplyError(c,"Invalid or out of range slot");
         return -1;
     }
     return (int) slot;
 }
 
-void clusterReplyMultiBulkSlots(redisClient *c) {
+void clusterReplyMultiBulkSlots(client *c) {
     /* Format: 1) 1) start slot
      *            2) end slot
      *            3) 1) master IP
      *               2) master port
+     *               3) node ID
      *            4) 1) replica IP
      *               2) replica port
+     *               3) node ID
      *           ... continued until done
      */
 
     int num_masters = 0;
     void *slot_replylen = addDeferredMultiBulkLength(c);
 
@@ -3780,23 +3825,23 @@
         int j = 0, start = -1;
 
         /* Skip slaves (that are iterated when producing the output of their
          * master) and  masters not serving any slot. */
         if (!nodeIsMaster(node) || node->numslots == 0) continue;
 
-        for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+        for (j = 0; j < CLUSTER_SLOTS; j++) {
             int bit, i;
 
             if ((bit = clusterNodeGetSlotBit(node,j)) != 0) {
                 if (start == -1) start = j;
             }
-            if (start != -1 && (!bit || j == REDIS_CLUSTER_SLOTS-1)) {
+            if (start != -1 && (!bit || j == CLUSTER_SLOTS-1)) {
                 int nested_elements = 3; /* slots (2) + master addr (1). */
                 void *nested_replylen = addDeferredMultiBulkLength(c);
 
-                if (bit && j == REDIS_CLUSTER_SLOTS-1) j++;
+                if (bit && j == CLUSTER_SLOTS-1) j++;
 
                 /* If slot exists in output map, add to it's list.
                  * else, create a new output map for this slot */
                 if (start == j-1) {
                     addReplyLongLong(c, start); /* only one slot; low==high */
                     addReplyLongLong(c, start);
@@ -3804,45 +3849,47 @@
                     addReplyLongLong(c, start); /* low */
                     addReplyLongLong(c, j-1);   /* high */
                 }
                 start = -1;
 
                 /* First node reply position is always the master */
-                addReplyMultiBulkLen(c, 2);
+                addReplyMultiBulkLen(c, 3);
                 addReplyBulkCString(c, node->ip);
                 addReplyLongLong(c, node->port);
+                addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);
 
                 /* Remaining nodes in reply are replicas for slot range */
                 for (i = 0; i < node->numslaves; i++) {
                     /* This loop is copy/pasted from clusterGenNodeDescription()
                      * with modifications for per-slot node aggregation */
                     if (nodeFailed(node->slaves[i])) continue;
-                    addReplyMultiBulkLen(c, 2);
+                    addReplyMultiBulkLen(c, 3);
                     addReplyBulkCString(c, node->slaves[i]->ip);
                     addReplyLongLong(c, node->slaves[i]->port);
+                    addReplyBulkCBuffer(c, node->slaves[i]->name, CLUSTER_NAMELEN);
                     nested_elements++;
                 }
                 setDeferredMultiBulkLength(c, nested_replylen, nested_elements);
                 num_masters++;
             }
         }
     }
     dictReleaseIterator(di);
     setDeferredMultiBulkLength(c, slot_replylen, num_masters);
 }
 
-void clusterCommand(redisClient *c) {
+void clusterCommand(client *c) {
     if (server.cluster_enabled == 0) {
         addReplyError(c,"This instance has cluster support disabled");
         return;
     }
 
     if (!strcasecmp(c->argv[1]->ptr,"meet") && c->argc == 4) {
         long long port;
 
-        if (getLongLongFromObject(c->argv[3], &port) != REDIS_OK) {
+        if (getLongLongFromObject(c->argv[3], &port) != C_OK) {
             addReplyErrorFormat(c,"Invalid TCP port specified: %s",
                                 (char*)c->argv[3]->ptr);
             return;
         }
 
         if (clusterStartHandshake(c->argv[2]->ptr,port) == 0 &&
@@ -3855,18 +3902,18 @@
         }
     } else if (!strcasecmp(c->argv[1]->ptr,"nodes") && c->argc == 2) {
         /* CLUSTER NODES */
         robj *o;
         sds ci = clusterGenNodesDescription(0);
 
-        o = createObject(REDIS_STRING,ci);
+        o = createObject(OBJ_STRING,ci);
         addReplyBulk(c,o);
         decrRefCount(o);
     } else if (!strcasecmp(c->argv[1]->ptr,"myid") && c->argc == 2) {
         /* CLUSTER MYID */
-        addReplyBulkCBuffer(c,myself->name, REDIS_CLUSTER_NAMELEN);
+        addReplyBulkCBuffer(c,myself->name, CLUSTER_NAMELEN);
     } else if (!strcasecmp(c->argv[1]->ptr,"slots") && c->argc == 2) {
         /* CLUSTER SLOTS */
         clusterReplyMultiBulkSlots(c);
     } else if (!strcasecmp(c->argv[1]->ptr,"flushslots") && c->argc == 2) {
         /* CLUSTER FLUSHSLOTS */
         if (dictSize(server.db[0].dict) != 0) {
@@ -3879,16 +3926,16 @@
     } else if ((!strcasecmp(c->argv[1]->ptr,"addslots") ||
                !strcasecmp(c->argv[1]->ptr,"delslots")) && c->argc >= 3)
     {
         /* CLUSTER ADDSLOTS <slot> [slot] ... */
         /* CLUSTER DELSLOTS <slot> [slot] ... */
         int j, slot;
-        unsigned char *slots = zmalloc(REDIS_CLUSTER_SLOTS);
+        unsigned char *slots = zmalloc(CLUSTER_SLOTS);
         int del = !strcasecmp(c->argv[1]->ptr,"delslots");
 
-        memset(slots,0,REDIS_CLUSTER_SLOTS);
+        memset(slots,0,CLUSTER_SLOTS);
         /* Check that all the arguments are parseable and that all the
          * slots are not already busy. */
         for (j = 2; j < c->argc; j++) {
             if ((slot = getSlotOrReply(c,c->argv[j])) == -1) {
                 zfree(slots);
                 return;
@@ -3906,24 +3953,24 @@
                 addReplyErrorFormat(c,"Slot %d specified multiple times",
                     (int)slot);
                 zfree(slots);
                 return;
             }
         }
-        for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+        for (j = 0; j < CLUSTER_SLOTS; j++) {
             if (slots[j]) {
                 int retval;
 
                 /* If this slot was set as importing we can clear this
                  * state as now we are the real owner of the slot. */
                 if (server.cluster->importing_slots_from[j])
                     server.cluster->importing_slots_from[j] = NULL;
 
                 retval = del ? clusterDelSlot(j) :
                                clusterAddSlot(myself,j);
-                redisAssertWithInfo(c,NULL,retval == REDIS_OK);
+                serverAssertWithInfo(c,NULL,retval == C_OK);
             }
         }
         zfree(slots);
         clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"setslot") && c->argc >= 4) {
@@ -4005,14 +4052,14 @@
                  *
                  * Note that if this ever results in a collision with another
                  * node getting the same configEpoch, for example because a
                  * failover happens at the same time we close the slot, the
                  * configEpoch collision resolution will fix it assigning
                  * a different epoch to each node. */
-                if (clusterBumpConfigEpochWithoutConsensus() == REDIS_OK) {
-                    redisLog(REDIS_WARNING,
+                if (clusterBumpConfigEpochWithoutConsensus() == C_OK) {
+                    serverLog(LL_WARNING,
                         "configEpoch updated after importing slot %d", slot);
                 }
                 server.cluster->importing_slots_from[slot] = NULL;
             }
             clusterDelSlot(slot);
             clusterAddSlot(n,slot);
@@ -4024,23 +4071,23 @@
         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_UPDATE_STATE);
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"bumpepoch") && c->argc == 2) {
         /* CLUSTER BUMPEPOCH */
         int retval = clusterBumpConfigEpochWithoutConsensus();
         sds reply = sdscatprintf(sdsempty(),"+%s %llu\r\n",
-                (retval == REDIS_OK) ? "BUMPED" : "STILL",
+                (retval == C_OK) ? "BUMPED" : "STILL",
                 (unsigned long long) myself->configEpoch);
         addReplySds(c,reply);
     } else if (!strcasecmp(c->argv[1]->ptr,"info") && c->argc == 2) {
         /* CLUSTER INFO */
         char *statestr[] = {"ok","fail","needhelp"};
         int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;
         uint64_t myepoch;
         int j;
 
-        for (j = 0; j < REDIS_CLUSTER_SLOTS; j++) {
+        for (j = 0; j < CLUSTER_SLOTS; j++) {
             clusterNode *n = server.cluster->slots[j];
 
             if (n == NULL) continue;
             slots_assigned++;
             if (nodeFailed(n)) {
                 slots_fail++;
@@ -4096,31 +4143,31 @@
 
         addReplyLongLong(c,keyHashSlot(key,sdslen(key)));
     } else if (!strcasecmp(c->argv[1]->ptr,"countkeysinslot") && c->argc == 3) {
         /* CLUSTER COUNTKEYSINSLOT <slot> */
         long long slot;
 
-        if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != REDIS_OK)
+        if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != C_OK)
             return;
-        if (slot < 0 || slot >= REDIS_CLUSTER_SLOTS) {
+        if (slot < 0 || slot >= CLUSTER_SLOTS) {
             addReplyError(c,"Invalid slot");
             return;
         }
         addReplyLongLong(c,countKeysInSlot(slot));
     } else if (!strcasecmp(c->argv[1]->ptr,"getkeysinslot") && c->argc == 4) {
         /* CLUSTER GETKEYSINSLOT <slot> <count> */
         long long maxkeys, slot;
         unsigned int numkeys, j;
         robj **keys;
 
-        if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != REDIS_OK)
+        if (getLongLongFromObjectOrReply(c,c->argv[2],&slot,NULL) != C_OK)
             return;
         if (getLongLongFromObjectOrReply(c,c->argv[3],&maxkeys,NULL)
-            != REDIS_OK)
+            != C_OK)
             return;
-        if (slot < 0 || slot >= REDIS_CLUSTER_SLOTS || maxkeys < 0) {
+        if (slot < 0 || slot >= CLUSTER_SLOTS || maxkeys < 0) {
             addReplyError(c,"Invalid slot or number of keys");
             return;
         }
 
         keys = zmalloc(sizeof(robj*)*maxkeys);
         numkeys = getKeysInSlot(slot, keys, maxkeys);
@@ -4248,30 +4295,30 @@
         {
             addReplyError(c,"Master is down or failed, "
                             "please use CLUSTER FAILOVER FORCE");
             return;
         }
         resetManualFailover();
-        server.cluster->mf_end = mstime() + REDIS_CLUSTER_MF_TIMEOUT;
+        server.cluster->mf_end = mstime() + CLUSTER_MF_TIMEOUT;
 
         if (takeover) {
             /* A takeover does not perform any initial check. It just
              * generates a new configuration epoch for this node without
              * consensus, claims the master's slots, and broadcast the new
              * configuration. */
-            redisLog(REDIS_WARNING,"Taking over the master (user request).");
+            serverLog(LL_WARNING,"Taking over the master (user request).");
             clusterBumpConfigEpochWithoutConsensus();
             clusterFailoverReplaceYourMaster();
         } else if (force) {
             /* If this is a forced failover, we don't need to talk with our
              * master to agree about the offset. We just failover taking over
              * it without coordination. */
-            redisLog(REDIS_WARNING,"Forced failover user request accepted.");
+            serverLog(LL_WARNING,"Forced failover user request accepted.");
             server.cluster->mf_can_start = 1;
         } else {
-            redisLog(REDIS_WARNING,"Manual failover user request accepted.");
+            serverLog(LL_WARNING,"Manual failover user request accepted.");
             clusterSendMFStart(myself->slaveof);
         }
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"set-config-epoch") && c->argc == 3)
     {
         /* CLUSTER SET-CONFIG-EPOCH <epoch>
@@ -4280,25 +4327,25 @@
          * totally fresh: no config epoch, no other known node, and so forth.
          * This happens at cluster creation time to start with a cluster where
          * every node has a different node ID, without to rely on the conflicts
          * resolution system which is too slow when a big cluster is created. */
         long long epoch;
 
-        if (getLongLongFromObjectOrReply(c,c->argv[2],&epoch,NULL) != REDIS_OK)
+        if (getLongLongFromObjectOrReply(c,c->argv[2],&epoch,NULL) != C_OK)
             return;
 
         if (epoch < 0) {
             addReplyErrorFormat(c,"Invalid config epoch specified: %lld",epoch);
         } else if (dictSize(server.cluster->nodes) > 1) {
             addReplyError(c,"The user can assign a config epoch only when the "
                             "node does not know any other node.");
         } else if (myself->configEpoch != 0) {
             addReplyError(c,"Node config epoch is already non-zero");
         } else {
             myself->configEpoch = epoch;
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH",
                 (unsigned long long) myself->configEpoch);
 
             if (server.cluster->currentEpoch < (uint64_t)epoch)
                 server.cluster->currentEpoch = epoch;
             /* No need to fsync the config here since in the unlucky event
@@ -4350,61 +4397,61 @@
     unsigned char buf[2];
     uint64_t crc;
 
     /* Serialize the object in a RDB-like format. It consist of an object type
      * byte followed by the serialized object. This is understood by RESTORE. */
     rioInitWithBuffer(payload,sdsempty());
-    redisAssert(rdbSaveObjectType(payload,o));
-    redisAssert(rdbSaveObject(payload,o));
+    serverAssert(rdbSaveObjectType(payload,o));
+    serverAssert(rdbSaveObject(payload,o));
 
     /* Write the footer, this is how it looks like:
      * ----------------+---------------------+---------------+
      * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |
      * ----------------+---------------------+---------------+
      * RDB version and CRC are both in little endian.
      */
 
     /* RDB version */
-    buf[0] = REDIS_RDB_VERSION & 0xff;
-    buf[1] = (REDIS_RDB_VERSION >> 8) & 0xff;
+    buf[0] = RDB_VERSION & 0xff;
+    buf[1] = (RDB_VERSION >> 8) & 0xff;
     payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,buf,2);
 
     /* CRC64 */
     crc = crc64(0,(unsigned char*)payload->io.buffer.ptr,
                 sdslen(payload->io.buffer.ptr));
     memrev64ifbe(&crc);
     payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,&crc,8);
 }
 
 /* Verify that the RDB version of the dump payload matches the one of this Redis
  * instance and that the checksum is ok.
- * If the DUMP payload looks valid REDIS_OK is returned, otherwise REDIS_ERR
+ * If the DUMP payload looks valid C_OK is returned, otherwise C_ERR
  * is returned. */
 int verifyDumpPayload(unsigned char *p, size_t len) {
     unsigned char *footer;
     uint16_t rdbver;
     uint64_t crc;
 
     /* At least 2 bytes of RDB version and 8 of CRC64 should be present. */
-    if (len < 10) return REDIS_ERR;
+    if (len < 10) return C_ERR;
     footer = p+(len-10);
 
     /* Verify RDB version */
     rdbver = (footer[1] << 8) | footer[0];
-    if (rdbver != REDIS_RDB_VERSION) return REDIS_ERR;
+    if (rdbver != RDB_VERSION) return C_ERR;
 
     /* Verify CRC64 */
     crc = crc64(0,p,len-8);
     memrev64ifbe(&crc);
-    return (memcmp(&crc,footer+2,8) == 0) ? REDIS_OK : REDIS_ERR;
+    return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;
 }
 
 /* DUMP keyname
  * DUMP is actually not used by Redis Cluster but it is the obvious
  * complement of RESTORE and can be useful for different applications. */
-void dumpCommand(redisClient *c) {
+void dumpCommand(client *c) {
     robj *o, *dumpobj;
     rio payload;
 
     /* Check if the key is here. */
     if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
         addReply(c,shared.nullbulk);
@@ -4412,20 +4459,20 @@
     }
 
     /* Create the DUMP encoded representation. */
     createDumpPayload(&payload,o);
 
     /* Transfer to the client */
-    dumpobj = createObject(REDIS_STRING,payload.io.buffer.ptr);
+    dumpobj = createObject(OBJ_STRING,payload.io.buffer.ptr);
     addReplyBulk(c,dumpobj);
     decrRefCount(dumpobj);
     return;
 }
 
 /* RESTORE key ttl serialized-value [REPLACE] */
-void restoreCommand(redisClient *c) {
+void restoreCommand(client *c) {
     long long ttl;
     rio payload;
     int j, type, replace = 0;
     robj *obj;
 
     /* Parse additional options */
@@ -4442,21 +4489,21 @@
     if (!replace && lookupKeyWrite(c->db,c->argv[1]) != NULL) {
         addReply(c,shared.busykeyerr);
         return;
     }
 
     /* Check if the TTL value makes sense */
-    if (getLongLongFromObjectOrReply(c,c->argv[2],&ttl,NULL) != REDIS_OK) {
+    if (getLongLongFromObjectOrReply(c,c->argv[2],&ttl,NULL) != C_OK) {
         return;
     } else if (ttl < 0) {
         addReplyError(c,"Invalid TTL value, must be >= 0");
         return;
     }
 
     /* Verify RDB version and data checksum. */
-    if (verifyDumpPayload(c->argv[3]->ptr,sdslen(c->argv[3]->ptr)) == REDIS_ERR)
+    if (verifyDumpPayload(c->argv[3]->ptr,sdslen(c->argv[3]->ptr)) == C_ERR)
     {
         addReplyError(c,"DUMP payload version or checksum are wrong");
         return;
     }
 
     rioInitWithBuffer(&payload,c->argv[3]->ptr);
@@ -4501,13 +4548,13 @@
  * Otherwise on success the socket is returned, and the caller should not
  * attempt to free it after usage.
  *
  * If the caller detects an error while using the socket, migrateCloseSocket()
  * should be called so that the connection will be created from scratch
  * the next time. */
-migrateCachedSocket* migrateGetSocket(redisClient *c, robj *host, robj *port, long timeout) {
+migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long timeout) {
     int fd;
     sds name = sdsempty();
     migrateCachedSocket *cs;
 
     /* Check if we have an already cached socket for this ip:port pair. */
     name = sdscatlen(name,host->ptr,sdslen(host->ptr));
@@ -4597,13 +4644,13 @@
 
 /* MIGRATE host port key dbid timeout [COPY | REPLACE]
  *
  * On in the multiple keys form:
  *
  * MIGRATE host port "" dbid timeout [COPY | REPLACE] KEYS key1 key2 ... keyN */
-void migrateCommand(redisClient *c) {
+void migrateCommand(client *c) {
     migrateCachedSocket *cs;
     int copy, replace, j;
     long timeout;
     long dbid;
     long long ttl, expireat;
     robj **ov = NULL; /* Objects to migrate. */
@@ -4642,14 +4689,14 @@
             addReply(c,shared.syntaxerr);
             return;
         }
     }
 
     /* Sanity check */
-    if (getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL) != REDIS_OK ||
-        getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL) != REDIS_OK)
+    if (getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL) != C_OK ||
+        getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL) != C_OK)
     {
         return;
     }
     if (timeout <= 0) timeout = 1000;
 
     /* Check if the keys are here. If at least one key is to migrate, do it
@@ -4686,47 +4733,47 @@
 
     rioInitWithBuffer(&cmd,sdsempty());
 
     /* Send the SELECT command if the current DB is not already selected. */
     int select = cs->last_dbid != dbid; /* Should we emit SELECT? */
     if (select) {
-        redisAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',2));
-        redisAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"SELECT",6));
-        redisAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,dbid));
+        serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',2));
+        serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"SELECT",6));
+        serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,dbid));
     }
 
     /* Create RESTORE payload and generate the protocol to call the command. */
     for (j = 0; j < num_keys; j++) {
         expireat = getExpire(c->db,kv[j]);
         if (expireat != -1) {
             ttl = expireat-mstime();
             if (ttl < 1) ttl = 1;
         }
-        redisAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',replace ? 5 : 4));
+        serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',replace ? 5 : 4));
         if (server.cluster_enabled)
-            redisAssertWithInfo(c,NULL,
+            serverAssertWithInfo(c,NULL,
                 rioWriteBulkString(&cmd,"RESTORE-ASKING",14));
         else
-            redisAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"RESTORE",7));
-        redisAssertWithInfo(c,NULL,sdsEncodedObject(kv[j]));
-        redisAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,kv[j]->ptr,
+            serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"RESTORE",7));
+        serverAssertWithInfo(c,NULL,sdsEncodedObject(kv[j]));
+        serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,kv[j]->ptr,
                 sdslen(kv[j]->ptr)));
-        redisAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,ttl));
+        serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,ttl));
 
         /* Emit the payload argument, that is the serialized object using
          * the DUMP format. */
         createDumpPayload(&payload,ov[j]);
-        redisAssertWithInfo(c,NULL,
+        serverAssertWithInfo(c,NULL,
             rioWriteBulkString(&cmd,payload.io.buffer.ptr,
                                sdslen(payload.io.buffer.ptr)));
         sdsfree(payload.io.buffer.ptr);
 
         /* Add the REPLACE option to the RESTORE command if it was specified
          * as a MIGRATE option. */
         if (replace)
-            redisAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"REPLACE",7));
+            serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"REPLACE",7));
     }
 
     /* Transfer the query to the other node in 64K chunks. */
     errno = 0;
     {
         sds buf = cmd.io.buffer.ptr;
@@ -4862,36 +4909,36 @@
  * -------------------------------------------------------------------------- */
 
 /* The ASKING command is required after a -ASK redirection.
  * The client should issue ASKING before to actually send the command to
  * the target instance. See the Redis Cluster specification for more
  * information. */
-void askingCommand(redisClient *c) {
+void askingCommand(client *c) {
     if (server.cluster_enabled == 0) {
         addReplyError(c,"This instance has cluster support disabled");
         return;
     }
-    c->flags |= REDIS_ASKING;
+    c->flags |= CLIENT_ASKING;
     addReply(c,shared.ok);
 }
 
 /* The READONLY command is used by clients to enter the read-only mode.
  * In this mode slaves will not redirect clients as long as clients access
  * with read-only commands to keys that are served by the slave's master. */
-void readonlyCommand(redisClient *c) {
+void readonlyCommand(client *c) {
     if (server.cluster_enabled == 0) {
         addReplyError(c,"This instance has cluster support disabled");
         return;
     }
-    c->flags |= REDIS_READONLY;
+    c->flags |= CLIENT_READONLY;
     addReply(c,shared.ok);
 }
 
 /* The READWRITE command just clears the READONLY command state. */
-void readwriteCommand(redisClient *c) {
-    c->flags &= ~REDIS_READONLY;
+void readwriteCommand(client *c) {
+    c->flags &= ~CLIENT_READONLY;
     addReply(c,shared.ok);
 }
 
 /* Return the pointer to the cluster node that is able to serve the command.
  * For the function to succeed the command should only target either:
  *
@@ -4899,48 +4946,51 @@
  * 2) Multiple keys in the same hash slot, while the slot is stable (no
  *    resharding in progress).
  *
  * On success the function returns the node that is able to serve the request.
  * If the node is not 'myself' a redirection must be perfomed. The kind of
  * redirection is specified setting the integer passed by reference
- * 'error_code', which will be set to REDIS_CLUSTER_REDIR_ASK or
- * REDIS_CLUSTER_REDIR_MOVED.
+ * 'error_code', which will be set to CLUSTER_REDIR_ASK or
+ * CLUSTER_REDIR_MOVED.
  *
- * When the node is 'myself' 'error_code' is set to REDIS_CLUSTER_REDIR_NONE.
+ * When the node is 'myself' 'error_code' is set to CLUSTER_REDIR_NONE.
  *
  * If the command fails NULL is returned, and the reason of the failure is
  * provided via 'error_code', which will be set to:
  *
- * REDIS_CLUSTER_REDIR_CROSS_SLOT if the request contains multiple keys that
+ * CLUSTER_REDIR_CROSS_SLOT if the request contains multiple keys that
  * don't belong to the same hash slot.
  *
- * REDIS_CLUSTER_REDIR_UNSTABLE if the request contains multiple keys
+ * CLUSTER_REDIR_UNSTABLE if the request contains multiple keys
  * belonging to the same slot, but the slot is not stable (in migration or
  * importing state, likely because a resharding is in progress).
  *
- * REDIS_CLUSTER_REDIR_DOWN_UNBOUND if the request addresses a slot which is
+ * CLUSTER_REDIR_DOWN_UNBOUND if the request addresses a slot which is
  * not bound to any node. In this case the cluster global state should be
  * already "down" but it is fragile to rely on the update of the global state,
- * so we also handle it here. */
-clusterNode *getNodeByQuery(redisClient *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {
+ * so we also handle it here.
+ *
+ * CLUSTER_REDIR_DOWN_STATE if the cluster is down but the user attempts to
+ * execute a command that addresses one or more keys. */
+clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {
     clusterNode *n = NULL;
     robj *firstkey = NULL;
     int multiple_keys = 0;
     multiState *ms, _ms;
     multiCmd mc;
     int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0;
 
     /* Set error code optimistically for the base case. */
-    if (error_code) *error_code = REDIS_CLUSTER_REDIR_NONE;
+    if (error_code) *error_code = CLUSTER_REDIR_NONE;
 
     /* We handle all the cases as if they were EXEC commands, so we have
      * a common code path for everything */
     if (cmd->proc == execCommand) {
-        /* If REDIS_MULTI flag is not set EXEC is just going to return an
+        /* If CLIENT_MULTI flag is not set EXEC is just going to return an
          * error. */
-        if (!(c->flags & REDIS_MULTI)) return myself;
+        if (!(c->flags & CLIENT_MULTI)) return myself;
         ms = &c->mstate;
     } else {
         /* In order to have a single codepath create a fake Multi State
          * structure if the client is not in MULTI/EXEC state, this way
          * we have a single codepath below. */
         ms = &_ms;
@@ -4979,13 +5029,13 @@
                  * state. However the state is yet to be updated, so this was
                  * not trapped earlier in processCommand(). Report the same
                  * error to the client. */
                 if (n == NULL) {
                     getKeysFreeResult(keyindex);
                     if (error_code)
-                        *error_code = REDIS_CLUSTER_REDIR_DOWN_UNBOUND;
+                        *error_code = CLUSTER_REDIR_DOWN_UNBOUND;
                     return NULL;
                 }
 
                 /* If we are migrating or importing this slot, we need to check
                  * if we have all the keys in the request (the only way we
                  * can safely serve the request, otherwise we return a TRYAGAIN
@@ -5003,13 +5053,13 @@
                  * the same key as the first we saw. */
                 if (!equalStringObjects(firstkey,thiskey)) {
                     if (slot != thisslot) {
                         /* Error: multiple keys from different slots. */
                         getKeysFreeResult(keyindex);
                         if (error_code)
-                            *error_code = REDIS_CLUSTER_REDIR_CROSS_SLOT;
+                            *error_code = CLUSTER_REDIR_CROSS_SLOT;
                         return NULL;
                     } else {
                         /* Flag this request as one with multiple different
                          * keys. */
                         multiple_keys = 1;
                     }
@@ -5024,91 +5074,97 @@
             }
         }
         getKeysFreeResult(keyindex);
     }
 
     /* No key at all in command? then we can serve the request
-     * without redirections or errors. */
+     * without redirections or errors in all the cases. */
     if (n == NULL) return myself;
 
+    /* Cluster is globally down but we got keys? We can't serve the request. */
+    if (server.cluster->state != CLUSTER_OK) {
+        if (error_code) *error_code = CLUSTER_REDIR_DOWN_STATE;
+        return NULL;
+    }
+
     /* Return the hashslot by reference. */
     if (hashslot) *hashslot = slot;
 
     /* MIGRATE always works in the context of the local node if the slot
      * is open (migrating or importing state). We need to be able to freely
      * move keys among instances in this case. */
     if ((migrating_slot || importing_slot) && cmd->proc == migrateCommand)
         return myself;
 
     /* If we don't have all the keys and we are migrating the slot, send
      * an ASK redirection. */
     if (migrating_slot && missing_keys) {
-        if (error_code) *error_code = REDIS_CLUSTER_REDIR_ASK;
+        if (error_code) *error_code = CLUSTER_REDIR_ASK;
         return server.cluster->migrating_slots_to[slot];
     }
 
     /* If we are receiving the slot, and the client correctly flagged the
      * request as "ASKING", we can serve the request. However if the request
      * involves multiple keys and we don't have them all, the only option is
      * to send a TRYAGAIN error. */
     if (importing_slot &&
-        (c->flags & REDIS_ASKING || cmd->flags & REDIS_CMD_ASKING))
+        (c->flags & CLIENT_ASKING || cmd->flags & CMD_ASKING))
     {
         if (multiple_keys && missing_keys) {
-            if (error_code) *error_code = REDIS_CLUSTER_REDIR_UNSTABLE;
+            if (error_code) *error_code = CLUSTER_REDIR_UNSTABLE;
             return NULL;
         } else {
             return myself;
         }
     }
 
     /* Handle the read-only client case reading from a slave: if this
      * node is a slave and the request is about an hash slot our master
      * is serving, we can reply without redirection. */
-    if (c->flags & REDIS_READONLY &&
-        cmd->flags & REDIS_CMD_READONLY &&
+    if (c->flags & CLIENT_READONLY &&
+        cmd->flags & CMD_READONLY &&
         nodeIsSlave(myself) &&
         myself->slaveof == n)
     {
         return myself;
     }
 
     /* Base case: just return the right node. However if this node is not
      * myself, set error_code to MOVED since we need to issue a rediretion. */
-    if (n != myself && error_code) *error_code = REDIS_CLUSTER_REDIR_MOVED;
+    if (n != myself && error_code) *error_code = CLUSTER_REDIR_MOVED;
     return n;
 }
 
 /* Send the client the right redirection code, according to error_code
- * that should be set to one of REDIS_CLUSTER_REDIR_* macros.
+ * that should be set to one of CLUSTER_REDIR_* macros.
  *
- * If REDIS_CLUSTER_REDIR_ASK or REDIS_CLUSTER_REDIR_MOVED error codes
+ * If CLUSTER_REDIR_ASK or CLUSTER_REDIR_MOVED error codes
  * are used, then the node 'n' should not be NULL, but should be the
  * node we want to mention in the redirection. Moreover hashslot should
  * be set to the hash slot that caused the redirection. */
-void clusterRedirectClient(redisClient *c, clusterNode *n, int hashslot, int error_code) {
-    if (error_code == REDIS_CLUSTER_REDIR_CROSS_SLOT) {
+void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {
+    if (error_code == CLUSTER_REDIR_CROSS_SLOT) {
         addReplySds(c,sdsnew("-CROSSSLOT Keys in request don't hash to the same slot\r\n"));
-    } else if (error_code == REDIS_CLUSTER_REDIR_UNSTABLE) {
+    } else if (error_code == CLUSTER_REDIR_UNSTABLE) {
         /* The request spawns mutliple keys in the same slot,
          * but the slot is not "stable" currently as there is
          * a migration or import in progress. */
         addReplySds(c,sdsnew("-TRYAGAIN Multiple keys request during rehashing of slot\r\n"));
-    } else if (error_code == REDIS_CLUSTER_REDIR_DOWN_STATE) {
+    } else if (error_code == CLUSTER_REDIR_DOWN_STATE) {
         addReplySds(c,sdsnew("-CLUSTERDOWN The cluster is down\r\n"));
-    } else if (error_code == REDIS_CLUSTER_REDIR_DOWN_UNBOUND) {
+    } else if (error_code == CLUSTER_REDIR_DOWN_UNBOUND) {
         addReplySds(c,sdsnew("-CLUSTERDOWN Hash slot not served\r\n"));
-    } else if (error_code == REDIS_CLUSTER_REDIR_MOVED ||
-               error_code == REDIS_CLUSTER_REDIR_ASK)
+    } else if (error_code == CLUSTER_REDIR_MOVED ||
+               error_code == CLUSTER_REDIR_ASK)
     {
         addReplySds(c,sdscatprintf(sdsempty(),
             "-%s %d %s:%d\r\n",
-            (error_code == REDIS_CLUSTER_REDIR_ASK) ? "ASK" : "MOVED",
+            (error_code == CLUSTER_REDIR_ASK) ? "ASK" : "MOVED",
             hashslot,n->ip,n->port));
     } else {
-        redisPanic("getNodeByQuery() unknown error.");
+        serverPanic("getNodeByQuery() unknown error.");
     }
 }
 
 /* This function is called by the function processing clients incrementally
  * to detect timeouts, in order to handle the following case:
  *
@@ -5117,20 +5173,20 @@
  * 3) The client may remain blocked forever (or up to the max timeout time)
  *    waiting for a key change that will never happen.
  *
  * If the client is found to be blocked into an hash slot this node no
  * longer handles, the client is sent a redirection error, and the function
  * returns 1. Otherwise 0 is returned and no operation is performed. */
-int clusterRedirectBlockedClientIfNeeded(redisClient *c) {
-    if (c->flags & REDIS_BLOCKED && c->btype == REDIS_BLOCKED_LIST) {
+int clusterRedirectBlockedClientIfNeeded(client *c) {
+    if (c->flags & CLIENT_BLOCKED && c->btype == BLOCKED_LIST) {
         dictEntry *de;
         dictIterator *di;
 
         /* If the cluster is down, unblock the client with the right error. */
-        if (server.cluster->state == REDIS_CLUSTER_FAIL) {
-            clusterRedirectClient(c,NULL,0,REDIS_CLUSTER_REDIR_DOWN_STATE);
+        if (server.cluster->state == CLUSTER_FAIL) {
+            clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);
             return 1;
         }
 
         di = dictGetIterator(c->bpop.keys);
         while((de = dictNext(di)) != NULL) {
             robj *key = dictGetKey(de);
@@ -5142,16 +5198,16 @@
              * 2) The slot is not handled by this node, nor being imported. */
             if (node != myself &&
                 server.cluster->importing_slots_from[slot] == NULL)
             {
                 if (node == NULL) {
                     clusterRedirectClient(c,NULL,0,
-                        REDIS_CLUSTER_REDIR_DOWN_UNBOUND);
+                        CLUSTER_REDIR_DOWN_UNBOUND);
                 } else {
                     clusterRedirectClient(c,node,slot,
-                        REDIS_CLUSTER_REDIR_MOVED);
+                        CLUSTER_REDIR_MOVED);
                 }
                 return 1;
             }
         }
         dictReleaseIterator(di);
     }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,41 +1,41 @@
-#ifndef __REDIS_CLUSTER_H
-#define __REDIS_CLUSTER_H
+#ifndef __CLUSTER_H
+#define __CLUSTER_H
 
 /*-----------------------------------------------------------------------------
  * Redis cluster data structures, defines, exported API.
  *----------------------------------------------------------------------------*/
 
-#define REDIS_CLUSTER_SLOTS 16384
-#define REDIS_CLUSTER_OK 0          /* Everything looks ok */
-#define REDIS_CLUSTER_FAIL 1        /* The cluster can't work */
-#define REDIS_CLUSTER_NAMELEN 40    /* sha1 hex length */
-#define REDIS_CLUSTER_PORT_INCR 10000 /* Cluster port = baseport + PORT_INCR */
+#define CLUSTER_SLOTS 16384
+#define CLUSTER_OK 0          /* Everything looks ok */
+#define CLUSTER_FAIL 1        /* The cluster can't work */
+#define CLUSTER_NAMELEN 40    /* sha1 hex length */
+#define CLUSTER_PORT_INCR 10000 /* Cluster port = baseport + PORT_INCR */
 
 /* The following defines are amount of time, sometimes expressed as
  * multiplicators of the node timeout value (when ending with MULT). */
-#define REDIS_CLUSTER_DEFAULT_NODE_TIMEOUT 15000
-#define REDIS_CLUSTER_DEFAULT_SLAVE_VALIDITY 10 /* Slave max data age factor. */
-#define REDIS_CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE 1
-#define REDIS_CLUSTER_FAIL_REPORT_VALIDITY_MULT 2 /* Fail report validity. */
-#define REDIS_CLUSTER_FAIL_UNDO_TIME_MULT 2 /* Undo fail if master is back. */
-#define REDIS_CLUSTER_FAIL_UNDO_TIME_ADD 10 /* Some additional time. */
-#define REDIS_CLUSTER_FAILOVER_DELAY 5 /* Seconds */
-#define REDIS_CLUSTER_DEFAULT_MIGRATION_BARRIER 1
-#define REDIS_CLUSTER_MF_TIMEOUT 5000 /* Milliseconds to do a manual failover. */
-#define REDIS_CLUSTER_MF_PAUSE_MULT 2 /* Master pause manual failover mult. */
-#define REDIS_CLUSTER_SLAVE_MIGRATION_DELAY 5000 /* Delay for slave migration */
+#define CLUSTER_DEFAULT_NODE_TIMEOUT 15000
+#define CLUSTER_DEFAULT_SLAVE_VALIDITY 10 /* Slave max data age factor. */
+#define CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE 1
+#define CLUSTER_FAIL_REPORT_VALIDITY_MULT 2 /* Fail report validity. */
+#define CLUSTER_FAIL_UNDO_TIME_MULT 2 /* Undo fail if master is back. */
+#define CLUSTER_FAIL_UNDO_TIME_ADD 10 /* Some additional time. */
+#define CLUSTER_FAILOVER_DELAY 5 /* Seconds */
+#define CLUSTER_DEFAULT_MIGRATION_BARRIER 1
+#define CLUSTER_MF_TIMEOUT 5000 /* Milliseconds to do a manual failover. */
+#define CLUSTER_MF_PAUSE_MULT 2 /* Master pause manual failover mult. */
+#define CLUSTER_SLAVE_MIGRATION_DELAY 5000 /* Delay for slave migration. */
 
 /* Redirection errors returned by getNodeByQuery(). */
-#define REDIS_CLUSTER_REDIR_NONE 0          /* Node can serve the request. */
-#define REDIS_CLUSTER_REDIR_CROSS_SLOT 1    /* -CROSSSLOT request. */
-#define REDIS_CLUSTER_REDIR_UNSTABLE 2      /* -TRYAGAIN redirection required */
-#define REDIS_CLUSTER_REDIR_ASK 3           /* -ASK redirection required. */
-#define REDIS_CLUSTER_REDIR_MOVED 4         /* -MOVED redirection required. */
-#define REDIS_CLUSTER_REDIR_DOWN_STATE 5    /* -CLUSTERDOWN, global state. */
-#define REDIS_CLUSTER_REDIR_DOWN_UNBOUND 6  /* -CLUSTERDOWN, unbound slot. */
+#define CLUSTER_REDIR_NONE 0          /* Node can serve the request. */
+#define CLUSTER_REDIR_CROSS_SLOT 1    /* -CROSSSLOT request. */
+#define CLUSTER_REDIR_UNSTABLE 2      /* -TRYAGAIN redirection required */
+#define CLUSTER_REDIR_ASK 3           /* -ASK redirection required. */
+#define CLUSTER_REDIR_MOVED 4         /* -MOVED redirection required. */
+#define CLUSTER_REDIR_DOWN_STATE 5    /* -CLUSTERDOWN, global state. */
+#define CLUSTER_REDIR_DOWN_UNBOUND 6  /* -CLUSTERDOWN, unbound slot. */
 
 struct clusterNode;
 
 /* clusterLink encapsulates everything needed to talk with a remote node. */
 typedef struct clusterLink {
     mstime_t ctime;             /* Link creation time */
@@ -43,51 +43,51 @@
     sds sndbuf;                 /* Packet send buffer */
     sds rcvbuf;                 /* Packet reception buffer */
     struct clusterNode *node;   /* Node related to this link if any, or NULL */
 } clusterLink;
 
 /* Cluster node flags and macros. */
-#define REDIS_NODE_MASTER 1     /* The node is a master */
-#define REDIS_NODE_SLAVE 2      /* The node is a slave */
-#define REDIS_NODE_PFAIL 4      /* Failure? Need acknowledge */
-#define REDIS_NODE_FAIL 8       /* The node is believed to be malfunctioning */
-#define REDIS_NODE_MYSELF 16    /* This node is myself */
-#define REDIS_NODE_HANDSHAKE 32 /* We have still to exchange the first ping */
-#define REDIS_NODE_NOADDR   64  /* We don't know the address of this node */
-#define REDIS_NODE_MEET 128     /* Send a MEET message to this node */
-#define REDIS_NODE_MIGRATE_TO 256 /* Master elegible for replica migration. */
-#define REDIS_NODE_NULL_NAME "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
-
-#define nodeIsMaster(n) ((n)->flags & REDIS_NODE_MASTER)
-#define nodeIsSlave(n) ((n)->flags & REDIS_NODE_SLAVE)
-#define nodeInHandshake(n) ((n)->flags & REDIS_NODE_HANDSHAKE)
-#define nodeHasAddr(n) (!((n)->flags & REDIS_NODE_NOADDR))
-#define nodeWithoutAddr(n) ((n)->flags & REDIS_NODE_NOADDR)
-#define nodeTimedOut(n) ((n)->flags & REDIS_NODE_PFAIL)
-#define nodeFailed(n) ((n)->flags & REDIS_NODE_FAIL)
+#define CLUSTER_NODE_MASTER 1     /* The node is a master */
+#define CLUSTER_NODE_SLAVE 2      /* The node is a slave */
+#define CLUSTER_NODE_PFAIL 4      /* Failure? Need acknowledge */
+#define CLUSTER_NODE_FAIL 8       /* The node is believed to be malfunctioning */
+#define CLUSTER_NODE_MYSELF 16    /* This node is myself */
+#define CLUSTER_NODE_HANDSHAKE 32 /* We have still to exchange the first ping */
+#define CLUSTER_NODE_NOADDR   64  /* We don't know the address of this node */
+#define CLUSTER_NODE_MEET 128     /* Send a MEET message to this node */
+#define CLUSTER_NODE_MIGRATE_TO 256 /* Master elegible for replica migration. */
+#define CLUSTER_NODE_NULL_NAME "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+
+#define nodeIsMaster(n) ((n)->flags & CLUSTER_NODE_MASTER)
+#define nodeIsSlave(n) ((n)->flags & CLUSTER_NODE_SLAVE)
+#define nodeInHandshake(n) ((n)->flags & CLUSTER_NODE_HANDSHAKE)
+#define nodeHasAddr(n) (!((n)->flags & CLUSTER_NODE_NOADDR))
+#define nodeWithoutAddr(n) ((n)->flags & CLUSTER_NODE_NOADDR)
+#define nodeTimedOut(n) ((n)->flags & CLUSTER_NODE_PFAIL)
+#define nodeFailed(n) ((n)->flags & CLUSTER_NODE_FAIL)
 
 /* Reasons why a slave is not able to failover. */
-#define REDIS_CLUSTER_CANT_FAILOVER_NONE 0
-#define REDIS_CLUSTER_CANT_FAILOVER_DATA_AGE 1
-#define REDIS_CLUSTER_CANT_FAILOVER_WAITING_DELAY 2
-#define REDIS_CLUSTER_CANT_FAILOVER_EXPIRED 3
-#define REDIS_CLUSTER_CANT_FAILOVER_WAITING_VOTES 4
-#define REDIS_CLUSTER_CANT_FAILOVER_RELOG_PERIOD (60*5) /* seconds. */
+#define CLUSTER_CANT_FAILOVER_NONE 0
+#define CLUSTER_CANT_FAILOVER_DATA_AGE 1
+#define CLUSTER_CANT_FAILOVER_WAITING_DELAY 2
+#define CLUSTER_CANT_FAILOVER_EXPIRED 3
+#define CLUSTER_CANT_FAILOVER_WAITING_VOTES 4
+#define CLUSTER_CANT_FAILOVER_RELOG_PERIOD (60*5) /* seconds. */
 
 /* This structure represent elements of node->fail_reports. */
 typedef struct clusterNodeFailReport {
     struct clusterNode *node;  /* Node reporting the failure condition. */
     mstime_t time;             /* Time of the last report from this node. */
 } clusterNodeFailReport;
 
 typedef struct clusterNode {
     mstime_t ctime; /* Node object creation time. */
-    char name[REDIS_CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */
-    int flags;      /* REDIS_NODE_... */
+    char name[CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */
+    int flags;      /* CLUSTER_NODE_... */
     uint64_t configEpoch; /* Last configEpoch observed for this node */
-    unsigned char slots[REDIS_CLUSTER_SLOTS/8]; /* slots handled by this node */
+    unsigned char slots[CLUSTER_SLOTS/8]; /* slots handled by this node */
     int numslots;   /* Number of slots handled by this node */
     int numslaves;  /* Number of slave nodes, if this is a master */
     struct clusterNode **slaves; /* pointers to slave nodes */
     struct clusterNode *slaveof; /* pointer to the master node. Note that it
                                     may be NULL even if the node is a slave
                                     if we don't have the master node in our
@@ -96,28 +96,28 @@
     mstime_t pong_received;  /* Unix time we received the pong */
     mstime_t fail_time;      /* Unix time when FAIL flag was set */
     mstime_t voted_time;     /* Last time we voted for a slave of this master */
     mstime_t repl_offset_time;  /* Unix time we received offset for this node */
     mstime_t orphaned_time;     /* Starting time of orphaned master condition */
     long long repl_offset;      /* Last known repl offset for this node. */
-    char ip[REDIS_IP_STR_LEN];  /* Latest known IP address of this node */
+    char ip[NET_IP_STR_LEN];  /* Latest known IP address of this node */
     int port;                   /* Latest known port of this node */
     clusterLink *link;          /* TCP/IP link with this node */
     list *fail_reports;         /* List of nodes signaling this as failing */
 } clusterNode;
 
 typedef struct clusterState {
     clusterNode *myself;  /* This node */
     uint64_t currentEpoch;
-    int state;            /* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... */
+    int state;            /* CLUSTER_OK, CLUSTER_FAIL, ... */
     int size;             /* Num of master nodes with at least one slot */
     dict *nodes;          /* Hash table of name -> clusterNode structures */
     dict *nodes_black_list; /* Nodes we don't re-add for a few seconds. */
-    clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];
-    clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];
-    clusterNode *slots[REDIS_CLUSTER_SLOTS];
+    clusterNode *migrating_slots_to[CLUSTER_SLOTS];
+    clusterNode *importing_slots_from[CLUSTER_SLOTS];
+    clusterNode *slots[CLUSTER_SLOTS];
     zskiplist *slots_to_keys;
     /* The following fields are used to take the slave state on elections. */
     mstime_t failover_auth_time; /* Time of previous or next election. */
     int failover_auth_count;    /* Number of votes received so far. */
     int failover_auth_sent;     /* True if we already asked for votes. */
     int failover_auth_rank;     /* This slave rank for current auth request. */
@@ -164,24 +164,24 @@
 #define CLUSTERMSG_TYPE_MFSTART 8       /* Pause clients for manual failover */
 
 /* Initially we don't know our "name", but we'll find it once we connect
  * to the first node, using the getsockname() function. Then we'll use this
  * address for all the next messages. */
 typedef struct {
-    char nodename[REDIS_CLUSTER_NAMELEN];
+    char nodename[CLUSTER_NAMELEN];
     uint32_t ping_sent;
     uint32_t pong_received;
-    char ip[REDIS_IP_STR_LEN];  /* IP address last time it was seen */
+    char ip[NET_IP_STR_LEN];  /* IP address last time it was seen */
     uint16_t port;              /* port last time it was seen */
     uint16_t flags;             /* node->flags copy */
     uint16_t notused1;          /* Some room for future improvements. */
     uint32_t notused2;
 } clusterMsgDataGossip;
 
 typedef struct {
-    char nodename[REDIS_CLUSTER_NAMELEN];
+    char nodename[CLUSTER_NAMELEN];
 } clusterMsgDataFail;
 
 typedef struct {
     uint32_t channel_len;
     uint32_t message_len;
     /* We can't reclare bulk_data as bulk_data[] since this structure is
@@ -189,14 +189,14 @@
      * length computation. */
     unsigned char bulk_data[8];
 } clusterMsgDataPublish;
 
 typedef struct {
     uint64_t configEpoch; /* Config epoch of the specified instance. */
-    char nodename[REDIS_CLUSTER_NAMELEN]; /* Name of the slots owner. */
-    unsigned char slots[REDIS_CLUSTER_SLOTS/8]; /* Slots bitmap. */
+    char nodename[CLUSTER_NAMELEN]; /* Name of the slots owner. */
+    unsigned char slots[CLUSTER_SLOTS/8]; /* Slots bitmap. */
 } clusterMsgDataUpdate;
 
 union clusterMsgData {
     /* PING, MEET and PONG */
     struct {
         /* Array of N clusterMsgDataGossip structures */
@@ -231,15 +231,15 @@
     uint64_t currentEpoch;  /* The epoch accordingly to the sending node. */
     uint64_t configEpoch;   /* The config epoch if it's a master, or the last
                                epoch advertised by its master if it is a
                                slave. */
     uint64_t offset;    /* Master replication offset if node is a master or
                            processed replication offset if node is a slave. */
-    char sender[REDIS_CLUSTER_NAMELEN]; /* Name of the sender node */
-    unsigned char myslots[REDIS_CLUSTER_SLOTS/8];
-    char slaveof[REDIS_CLUSTER_NAMELEN];
+    char sender[CLUSTER_NAMELEN]; /* Name of the sender node */
+    unsigned char myslots[CLUSTER_SLOTS/8];
+    char slaveof[CLUSTER_NAMELEN];
     char notused1[32];  /* 32 bytes reserved for future usage. */
     uint16_t port;      /* Sender TCP base port */
     uint16_t flags;     /* Sender node flags */
     unsigned char state; /* Cluster state from the POV of the sender */
     unsigned char mflags[3]; /* Message flags: CLUSTERMSG_FLAG[012]_... */
     union clusterMsgData data;
@@ -251,11 +251,11 @@
  * provide some information about the node state. */
 #define CLUSTERMSG_FLAG0_PAUSED (1<<0) /* Master paused for manual failover. */
 #define CLUSTERMSG_FLAG0_FORCEACK (1<<1) /* Give ACK to AUTH_REQUEST even if
                                             master is up. */
 
 /* ---------------------- API exported outside cluster.c -------------------- */
-clusterNode *getNodeByQuery(redisClient *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *ask);
-int clusterRedirectBlockedClientIfNeeded(redisClient *c);
-void clusterRedirectClient(redisClient *c, clusterNode *n, int hashslot, int error_code);
+clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *ask);
+int clusterRedirectBlockedClientIfNeeded(client *c);
+void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code);
 
-#endif /* __REDIS_CLUSTER_H */
+#endif /* __CLUSTER_H */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/compile_commands.json /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/compile_commands.json
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/compile_commands.json	2017-09-27 22:48:10.626962836 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/compile_commands.json	2017-09-27 22:49:35.686959719 +0800
@@ -1,1213 +1,1351 @@
 [
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb net.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/net.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/net.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb hiredis.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/hiredis.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/hiredis.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb sds.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb async.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/async.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/async.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise",
   "command": "cc -Wall -Os -g -c linenoise.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lapi.o lapi.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lapi.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lapi.o lapi.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lapi.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lcode.o lcode.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lcode.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lcode.o lcode.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lcode.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o ldebug.o ldebug.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldebug.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldebug.o ldebug.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldebug.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o ldo.o ldo.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldo.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldo.o ldo.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldo.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o ldump.o ldump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldump.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldump.o ldump.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldump.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lfunc.o lfunc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lfunc.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lfunc.o lfunc.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lfunc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lgc.o lgc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lgc.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lgc.o lgc.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lgc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o llex.o llex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/llex.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o llex.o llex.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/llex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lmem.o lmem.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmem.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lmem.o lmem.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmem.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lobject.o lobject.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lobject.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lobject.o lobject.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lobject.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lopcodes.o lopcodes.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lopcodes.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lopcodes.o lopcodes.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lopcodes.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lparser.o lparser.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lparser.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lparser.o lparser.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lparser.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lstate.o lstate.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstate.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lstate.o lstate.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstate.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lstring.o lstring.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstring.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lstring.o lstring.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstring.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o ltable.o ltable.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltable.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ltable.o ltable.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltable.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o ltm.o ltm.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltm.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ltm.o ltm.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltm.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lundump.o lundump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lundump.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lundump.o lundump.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lundump.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lvm.o lvm.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lvm.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lvm.o lvm.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lvm.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lzio.o lzio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lzio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lzio.o lzio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lzio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o strbuf.o strbuf.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/strbuf.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o strbuf.o strbuf.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/strbuf.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o fpconv.o fpconv.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/fpconv.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o fpconv.o fpconv.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/fpconv.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lauxlib.o lauxlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lauxlib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lauxlib.o lauxlib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lauxlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lbaselib.o lbaselib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lbaselib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lbaselib.o lbaselib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lbaselib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o ldblib.o ldblib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldblib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldblib.o ldblib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldblib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o liolib.o liolib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/liolib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o liolib.o liolib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/liolib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lmathlib.o lmathlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmathlib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lmathlib.o lmathlib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmathlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o loslib.o loslib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loslib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o loslib.o loslib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loslib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o ltablib.o ltablib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltablib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ltablib.o ltablib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltablib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lstrlib.o lstrlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstrlib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lstrlib.o lstrlib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstrlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o loadlib.o loadlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loadlib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o loadlib.o loadlib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loadlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o linit.o linit.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/linit.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o linit.o linit.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/linit.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lua_cjson.o lua_cjson.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cjson.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_cjson.o lua_cjson.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cjson.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lua_struct.o lua_struct.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_struct.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_struct.o lua_struct.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_struct.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lua_cmsgpack.o lua_cmsgpack.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cmsgpack.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_cmsgpack.o lua_cmsgpack.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cmsgpack.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lua_bit.o lua_bit.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_bit.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_bit.o lua_bit.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_bit.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o lua.o lua.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua.o lua.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o luac.o luac.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/luac.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o luac.o luac.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/luac.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src",
-  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -c -o print.o print.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/print.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o print.o print.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/print.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int",
+  "command": "cc -Wall -O2 -g -c geohash.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int",
+  "command": "cc -Wall -O2 -g -c geohash_helper.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash_helper.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -g conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
-  "command": "cc -c -o /tmp/cgfvTMPi/dummy.o /tmp/cgfvTMPi/dummy.c",
-  "file": "/tmp/cgfvTMPi/dummy.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "cc -c -o /tmp/cg72vH6G/dummy.o /tmp/cg72vH6G/dummy.c",
+  "file": "/tmp/cg72vH6G/dummy.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
-  "command": "cc -E /tmp/cgfvTMPi/dummy.c",
-  "file": "/tmp/cgfvTMPi/dummy.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "cc -E /tmp/cg72vH6G/dummy.c",
+  "file": "/tmp/cg72vH6G/dummy.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -E -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -E -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/jemalloc.o src/jemalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/jemalloc.o -o src/jemalloc.d src/jemalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/arena.o src/arena.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/arena.o -o src/arena.d src/arena.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/atomic.o src/atomic.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/atomic.o -o src/atomic.d src/atomic.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/base.o src/base.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/base.o -o src/base.d src/base.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/bitmap.o src/bitmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/bitmap.o -o src/bitmap.d src/bitmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk.o src/chunk.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk.o -o src/chunk.d src/chunk.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk_dss.o src/chunk_dss.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk_dss.o -o src/chunk_dss.d src/chunk_dss.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk_mmap.o src/chunk_mmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk_mmap.o -o src/chunk_mmap.d src/chunk_mmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ckh.o src/ckh.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/ckh.o -o src/ckh.d src/ckh.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ctl.o src/ctl.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/ctl.o -o src/ctl.d src/ctl.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/extent.o src/extent.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/extent.o -o src/extent.d src/extent.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/hash.o src/hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/hash.o -o src/hash.d src/hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/huge.o src/huge.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/huge.o -o src/huge.d src/huge.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mb.o src/mb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/mb.o -o src/mb.d src/mb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mutex.o src/mutex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/mutex.o -o src/mutex.d src/mutex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/pages.o src/pages.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/pages.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
+  "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/pages.o -o src/pages.d src/pages.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/pages.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/prof.o src/prof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/prof.o -o src/prof.d src/prof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/quarantine.o src/quarantine.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/quarantine.o -o src/quarantine.d src/quarantine.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/rtree.o src/rtree.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/rtree.o -o src/rtree.d src/rtree.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/stats.o src/stats.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/stats.o -o src/stats.d src/stats.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tcache.o src/tcache.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/tcache.o -o src/tcache.d src/tcache.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/util.o src/util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/util.o -o src/util.d src/util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tsd.o src/tsd.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/tsd.o -o src/tsd.d src/tsd.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c adlist.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/adlist.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c quicklist.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/quicklist.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c adlist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/adlist.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ae.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ae.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c anet.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c anet.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c dict.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c dict.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c server.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/server.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sds.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sds.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zmalloc.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zmalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_c.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_c.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_c.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_c.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_d.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_d.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_d.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_d.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pqsort.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pqsort.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pqsort.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pqsort.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zipmap.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zipmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sha1.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sha1.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ziplist.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ziplist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c release.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/release.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c release.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/release.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c networking.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/networking.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c networking.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/networking.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c util.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c object.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/object.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c object.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/object.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c db.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/db.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c db.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/db.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c replication.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/replication.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c replication.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/replication.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rdb.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rdb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_string.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_string.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_string.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_string.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_list.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_list.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_list.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_list.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_set.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_set.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_set.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_set.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_zset.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_zset.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_zset.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_zset.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_hash.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_hash.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c config.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c config.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c aof.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/aof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c aof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/aof.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pubsub.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pubsub.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pubsub.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pubsub.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c multi.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/multi.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c multi.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/multi.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c debug.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/debug.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c debug.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/debug.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sort.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sort.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sort.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sort.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c intset.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c intset.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c syncio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/syncio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c syncio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/syncio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c cluster.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c cluster.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc16.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc16.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc16.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc16.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c endianconv.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c endianconv.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c slowlog.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c slowlog.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c scripting.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/scripting.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c scripting.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/scripting.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rand.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rand.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rand.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rand.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c memtest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/memtest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c memtest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/memtest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc64.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc64.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bitops.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bitops.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bitops.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bitops.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sentinel.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sentinel.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sentinel.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sentinel.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c notify.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/notify.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c notify.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/notify.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c setproctitle.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/setproctitle.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c setproctitle.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/setproctitle.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c blocked.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/blocked.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c blocked.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/blocked.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c hyperloglog.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/hyperloglog.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c hyperloglog.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/hyperloglog.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c latency.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/latency.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c latency.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/latency.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sparkline.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sparkline.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sparkline.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sparkline.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-rdb.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-rdb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-cli.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c geo.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/geo.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-benchmark.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-cli.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-dump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-dump.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-benchmark.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src",
-  "command": "cc -std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-aof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-aof.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-aof.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-aof.c"
 }
 ]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/compiled_files.def /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/compiled_files.def
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/compiled_files.def	2017-09-27 22:48:10.630962836 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/compiled_files.def	2017-09-27 22:49:35.694959719 +0800
@@ -1,122 +1,127 @@
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/net.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/hiredis.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/sds.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/hiredis/async.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/linenoise/linenoise.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lapi.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lcode.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldebug.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldo.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lfunc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lgc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/llex.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmem.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lobject.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lopcodes.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lparser.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstate.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstring.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltable.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltm.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lundump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lvm.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lzio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/strbuf.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/fpconv.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lauxlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lbaselib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ldblib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/liolib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lmathlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loslib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/ltablib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lstrlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/loadlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/linit.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cjson.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_struct.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_cmsgpack.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua_bit.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/lua.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/luac.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/lua/src/print.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/conftest.c
-/tmp/cgfvTMPi/dummy.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/jemalloc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/arena.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/atomic.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/base.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/bitmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_dss.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/chunk_mmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ckh.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/ctl.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/extent.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/hash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/huge.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/mutex.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/prof.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/quarantine.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/rtree.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/stats.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tcache.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/util.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/deps/jemalloc/src/tsd.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/adlist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ae.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/anet.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_c.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_d.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pqsort.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/release.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/networking.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/object.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/db.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/replication.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_string.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_list.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_set.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_zset.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_hash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/aof.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pubsub.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/multi.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/debug.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sort.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/syncio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/cluster.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc16.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/scripting.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rand.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/memtest.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/bitops.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sentinel.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/notify.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/setproctitle.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/blocked.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/hyperloglog.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/latency.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sparkline.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-dump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-aof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/net.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/hiredis.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/sds.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/hiredis/async.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/linenoise/linenoise.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lapi.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lcode.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldebug.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldo.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldump.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lfunc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lgc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/llex.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmem.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lobject.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lopcodes.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lparser.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstate.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstring.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltable.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltm.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lundump.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lvm.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lzio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/strbuf.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/fpconv.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lauxlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lbaselib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ldblib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/liolib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lmathlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loslib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/ltablib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lstrlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/loadlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/linit.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cjson.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_struct.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_cmsgpack.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua_bit.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/lua.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/luac.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/lua/src/print.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/geohash-int/geohash_helper.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/conftest.c
+/tmp/cg72vH6G/dummy.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/jemalloc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/arena.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/atomic.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/base.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/bitmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_dss.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/chunk_mmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ckh.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/ctl.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/extent.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/hash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/huge.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/mutex.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/pages.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/prof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/quarantine.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/rtree.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/stats.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tcache.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/util.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/deps/jemalloc/src/tsd.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/adlist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/quicklist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ae.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/anet.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/server.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_c.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_d.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pqsort.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/release.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/networking.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/object.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/db.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/replication.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_string.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_list.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_set.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_zset.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_hash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/aof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pubsub.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/multi.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/debug.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sort.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/syncio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/cluster.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc16.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/scripting.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rand.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/memtest.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/bitops.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sentinel.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/notify.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/setproctitle.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/blocked.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/hyperloglog.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/latency.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sparkline.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-rdb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/geo.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-aof.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.c	2016-05-06 15:11:36.000000000 +0800
@@ -25,41 +25,115 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include "cluster.h"
 
 #include <fcntl.h>
 #include <sys/stat.h>
 
-static struct {
-    const char     *name;
-    const int       value;
-} validSyslogFacilities[] = {
+/*-----------------------------------------------------------------------------
+ * Config file name-value maps.
+ *----------------------------------------------------------------------------*/
+
+typedef struct configEnum {
+    const char *name;
+    const int val;
+} configEnum;
+
+configEnum maxmemory_policy_enum[] = {
+    {"volatile-lru", MAXMEMORY_VOLATILE_LRU},
+    {"volatile-random",MAXMEMORY_VOLATILE_RANDOM},
+    {"volatile-ttl",MAXMEMORY_VOLATILE_TTL},
+    {"allkeys-lru",MAXMEMORY_ALLKEYS_LRU},
+    {"allkeys-random",MAXMEMORY_ALLKEYS_RANDOM},
+    {"noeviction",MAXMEMORY_NO_EVICTION},
+    {NULL, 0}
+};
+
+configEnum syslog_facility_enum[] = {
     {"user",    LOG_USER},
     {"local0",  LOG_LOCAL0},
     {"local1",  LOG_LOCAL1},
     {"local2",  LOG_LOCAL2},
     {"local3",  LOG_LOCAL3},
     {"local4",  LOG_LOCAL4},
     {"local5",  LOG_LOCAL5},
     {"local6",  LOG_LOCAL6},
     {"local7",  LOG_LOCAL7},
     {NULL, 0}
 };
 
-clientBufferLimitsConfig clientBufferLimitsDefaults[REDIS_CLIENT_TYPE_COUNT] = {
+configEnum loglevel_enum[] = {
+    {"debug", LL_DEBUG},
+    {"verbose", LL_VERBOSE},
+    {"notice", LL_NOTICE},
+    {"warning", LL_WARNING},
+    {NULL,0}
+};
+
+configEnum supervised_mode_enum[] = {
+    {"upstart", SUPERVISED_UPSTART},
+    {"systemd", SUPERVISED_SYSTEMD},
+    {"auto", SUPERVISED_AUTODETECT},
+    {"no", SUPERVISED_NONE},
+    {NULL, 0}
+};
+
+configEnum aof_fsync_enum[] = {
+    {"everysec", AOF_FSYNC_EVERYSEC},
+    {"always", AOF_FSYNC_ALWAYS},
+    {"no", AOF_FSYNC_NO},
+    {NULL, 0}
+};
+
+/* Output buffer limits presets. */
+clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {
     {0, 0, 0}, /* normal */
     {1024*1024*256, 1024*1024*64, 60}, /* slave */
     {1024*1024*32, 1024*1024*8, 60}  /* pubsub */
 };
 
 /*-----------------------------------------------------------------------------
+ * Enum access functions
+ *----------------------------------------------------------------------------*/
+
+/* Get enum value from name. If there is no match INT_MIN is returned. */
+int configEnumGetValue(configEnum *ce, char *name) {
+    while(ce->name != NULL) {
+        if (!strcasecmp(ce->name,name)) return ce->val;
+        ce++;
+    }
+    return INT_MIN;
+}
+
+/* Get enum name from value. If no match is found NULL is returned. */
+const char *configEnumGetName(configEnum *ce, int val) {
+    while(ce->name != NULL) {
+        if (ce->val == val) return ce->name;
+        ce++;
+    }
+    return NULL;
+}
+
+/* Wrapper for configEnumGetName() returning "unknown" insetad of NULL if
+ * there is no match. */
+const char *configEnumGetNameOrUnknown(configEnum *ce, int val) {
+    const char *name = configEnumGetName(ce,val);
+    return name ? name : "unknown";
+}
+
+/* Used for INFO generation. */
+const char *evictPolicyToString(void) {
+    return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);
+}
+
+/*-----------------------------------------------------------------------------
  * Config file parsing
  *----------------------------------------------------------------------------*/
 
 int yesnotoi(char *s) {
     if (!strcasecmp(s,"yes")) return 1;
     else if (!strcasecmp(s,"no")) return 0;
@@ -119,12 +193,16 @@
             }
         } else if (!strcasecmp(argv[0],"tcp-keepalive") && argc == 2) {
             server.tcpkeepalive = atoi(argv[1]);
             if (server.tcpkeepalive < 0) {
                 err = "Invalid tcp-keepalive value"; goto loaderr;
             }
+        } else if (!strcasecmp(argv[0],"protected-mode") && argc == 2) {
+            if ((server.protected_mode = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
         } else if (!strcasecmp(argv[0],"port") && argc == 2) {
             server.port = atoi(argv[1]);
             if (server.port < 0 || server.port > 65535) {
                 err = "Invalid port"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"tcp-backlog") && argc == 2) {
@@ -132,13 +210,13 @@
             if (server.tcp_backlog < 0) {
                 err = "Invalid backlog value"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"bind") && argc >= 2) {
             int j, addresses = argc-1;
 
-            if (addresses > REDIS_BINDADDR_MAX) {
+            if (addresses > CONFIG_BINDADDR_MAX) {
                 err = "Too many bind addresses specified"; goto loaderr;
             }
             for (j = 0; j < addresses; j++)
                 server.bindaddr[j] = zstrdup(argv[j+1]);
             server.bindaddr_count = addresses;
         } else if (!strcasecmp(argv[0],"unixsocket") && argc == 2) {
@@ -159,23 +237,21 @@
                 appendServerSaveParams(seconds,changes);
             } else if (argc == 2 && !strcasecmp(argv[1],"")) {
                 resetServerSaveParams();
             }
         } else if (!strcasecmp(argv[0],"dir") && argc == 2) {
             if (chdir(argv[1]) == -1) {
-                redisLog(REDIS_WARNING,"Can't chdir to '%s': %s",
+                serverLog(LL_WARNING,"Can't chdir to '%s': %s",
                     argv[1], strerror(errno));
                 exit(1);
             }
         } else if (!strcasecmp(argv[0],"loglevel") && argc == 2) {
-            if (!strcasecmp(argv[1],"debug")) server.verbosity = REDIS_DEBUG;
-            else if (!strcasecmp(argv[1],"verbose")) server.verbosity = REDIS_VERBOSE;
-            else if (!strcasecmp(argv[1],"notice")) server.verbosity = REDIS_NOTICE;
-            else if (!strcasecmp(argv[1],"warning")) server.verbosity = REDIS_WARNING;
-            else {
-                err = "Invalid log level. Must be one of debug, notice, warning";
+            server.verbosity = configEnumGetValue(loglevel_enum,argv[1]);
+            if (server.verbosity == INT_MIN) {
+                err = "Invalid log level. "
+                      "Must be one of debug, verbose, notice, warning";
                 goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"logfile") && argc == 2) {
             FILE *logfp;
 
             zfree(server.logfile);
@@ -196,22 +272,15 @@
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"syslog-ident") && argc == 2) {
             if (server.syslog_ident) zfree(server.syslog_ident);
             server.syslog_ident = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"syslog-facility") && argc == 2) {
-            int i;
-
-            for (i = 0; validSyslogFacilities[i].name; i++) {
-                if (!strcasecmp(validSyslogFacilities[i].name, argv[1])) {
-                    server.syslog_facility = validSyslogFacilities[i].value;
-                    break;
-                }
-            }
-
-            if (!validSyslogFacilities[i].name) {
+            server.syslog_facility =
+                configEnumGetValue(syslog_facility_enum,argv[1]);
+            if (server.syslog_facility == INT_MIN) {
                 err = "Invalid log facility. Must be one of USER or between LOCAL0-LOCAL7";
                 goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"databases") && argc == 2) {
             server.dbnum = atoi(argv[1]);
             if (server.dbnum < 1) {
@@ -224,25 +293,15 @@
             if (server.maxclients < 1) {
                 err = "Invalid max clients limit"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"maxmemory") && argc == 2) {
             server.maxmemory = memtoll(argv[1],NULL);
         } else if (!strcasecmp(argv[0],"maxmemory-policy") && argc == 2) {
-            if (!strcasecmp(argv[1],"volatile-lru")) {
-                server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU;
-            } else if (!strcasecmp(argv[1],"volatile-random")) {
-                server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_RANDOM;
-            } else if (!strcasecmp(argv[1],"volatile-ttl")) {
-                server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_TTL;
-            } else if (!strcasecmp(argv[1],"allkeys-lru")) {
-                server.maxmemory_policy = REDIS_MAXMEMORY_ALLKEYS_LRU;
-            } else if (!strcasecmp(argv[1],"allkeys-random")) {
-                server.maxmemory_policy = REDIS_MAXMEMORY_ALLKEYS_RANDOM;
-            } else if (!strcasecmp(argv[1],"noeviction")) {
-                server.maxmemory_policy = REDIS_MAXMEMORY_NO_EVICTION;
-            } else {
+            server.maxmemory_policy =
+                configEnumGetValue(maxmemory_policy_enum,argv[1]);
+            if (server.maxmemory_policy == INT_MIN) {
                 err = "Invalid maxmemory policy";
                 goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"maxmemory-samples") && argc == 2) {
             server.maxmemory_samples = atoi(argv[1]);
             if (server.maxmemory_samples <= 0) {
@@ -250,13 +309,13 @@
                 goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"slaveof") && argc == 3) {
             slaveof_linenum = linenum;
             server.masterhost = sdsnew(argv[1]);
             server.masterport = atoi(argv[2]);
-            server.repl_state = REDIS_REPL_CONNECT;
+            server.repl_state = REPL_STATE_CONNECT;
         } else if (!strcasecmp(argv[0],"repl-ping-slave-period") && argc == 2) {
             server.repl_ping_slave_period = atoi(argv[1]);
             if (server.repl_ping_slave_period <= 0) {
                 err = "repl-ping-slave-period must be 1 or greater";
                 goto loaderr;
             }
@@ -291,12 +350,13 @@
             server.repl_backlog_time_limit = atoi(argv[1]);
             if (server.repl_backlog_time_limit < 0) {
                 err = "repl-backlog-ttl can't be negative ";
                 goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"masterauth") && argc == 2) {
+            zfree(server.masterauth);
             server.masterauth = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"slave-serve-stale-data") && argc == 2) {
             if ((server.repl_serve_stale_data = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"slave-read-only") && argc == 2) {
@@ -318,21 +378,21 @@
         } else if (!strcasecmp(argv[0],"daemonize") && argc == 2) {
             if ((server.daemonize = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"hz") && argc == 2) {
             server.hz = atoi(argv[1]);
-            if (server.hz < REDIS_MIN_HZ) server.hz = REDIS_MIN_HZ;
-            if (server.hz > REDIS_MAX_HZ) server.hz = REDIS_MAX_HZ;
+            if (server.hz < CONFIG_MIN_HZ) server.hz = CONFIG_MIN_HZ;
+            if (server.hz > CONFIG_MAX_HZ) server.hz = CONFIG_MAX_HZ;
         } else if (!strcasecmp(argv[0],"appendonly") && argc == 2) {
             int yes;
 
             if ((yes = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
-            server.aof_state = yes ? REDIS_AOF_ON : REDIS_AOF_OFF;
+            server.aof_state = yes ? AOF_ON : AOF_OFF;
         } else if (!strcasecmp(argv[0],"appendfilename") && argc == 2) {
             if (!pathIsBaseName(argv[1])) {
                 err = "appendfilename can't be a path, just a filename";
                 goto loaderr;
             }
             zfree(server.aof_filename);
@@ -340,19 +400,14 @@
         } else if (!strcasecmp(argv[0],"no-appendfsync-on-rewrite")
                    && argc == 2) {
             if ((server.aof_no_fsync_on_rewrite= yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"appendfsync") && argc == 2) {
-            if (!strcasecmp(argv[1],"no")) {
-                server.aof_fsync = AOF_FSYNC_NO;
-            } else if (!strcasecmp(argv[1],"always")) {
-                server.aof_fsync = AOF_FSYNC_ALWAYS;
-            } else if (!strcasecmp(argv[1],"everysec")) {
-                server.aof_fsync = AOF_FSYNC_EVERYSEC;
-            } else {
+            server.aof_fsync = configEnumGetValue(aof_fsync_enum,argv[1]);
+            if (server.aof_fsync == INT_MIN) {
                 err = "argument must be 'no', 'always' or 'everysec'";
                 goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"auto-aof-rewrite-percentage") &&
                    argc == 2)
         {
@@ -374,14 +429,14 @@
             }
         } else if (!strcasecmp(argv[0],"aof-load-truncated") && argc == 2) {
             if ((server.aof_load_truncated = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"requirepass") && argc == 2) {
-            if (strlen(argv[1]) > REDIS_AUTHPASS_MAX_LEN) {
-                err = "Password is longer than REDIS_AUTHPASS_MAX_LEN";
+            if (strlen(argv[1]) > CONFIG_AUTHPASS_MAX_LEN) {
+                err = "Password is longer than CONFIG_AUTHPASS_MAX_LEN";
                 goto loaderr;
             }
             server.requirepass = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"pidfile") && argc == 2) {
             zfree(server.pidfile);
             server.pidfile = zstrdup(argv[1]);
@@ -394,15 +449,19 @@
             server.rdb_filename = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"hash-max-ziplist-entries") && argc == 2) {
             server.hash_max_ziplist_entries = memtoll(argv[1], NULL);
         } else if (!strcasecmp(argv[0],"hash-max-ziplist-value") && argc == 2) {
             server.hash_max_ziplist_value = memtoll(argv[1], NULL);
         } else if (!strcasecmp(argv[0],"list-max-ziplist-entries") && argc == 2){
-            server.list_max_ziplist_entries = memtoll(argv[1], NULL);
+            /* DEAD OPTION */
         } else if (!strcasecmp(argv[0],"list-max-ziplist-value") && argc == 2) {
-            server.list_max_ziplist_value = memtoll(argv[1], NULL);
+            /* DEAD OPTION */
+        } else if (!strcasecmp(argv[0],"list-max-ziplist-size") && argc == 2) {
+            server.list_max_ziplist_size = atoi(argv[1]);
+        } else if (!strcasecmp(argv[0],"list-compress-depth") && argc == 2) {
+            server.list_compress_depth = atoi(argv[1]);
         } else if (!strcasecmp(argv[0],"set-max-intset-entries") && argc == 2) {
             server.set_max_intset_entries = memtoll(argv[1], NULL);
         } else if (!strcasecmp(argv[0],"zset-max-ziplist-entries") && argc == 2) {
             server.zset_max_ziplist_entries = memtoll(argv[1], NULL);
         } else if (!strcasecmp(argv[0],"zset-max-ziplist-value") && argc == 2) {
             server.zset_max_ziplist_value = memtoll(argv[1], NULL);
@@ -417,13 +476,13 @@
                 goto loaderr;
             }
 
             /* If the target command name is the empty string we just
              * remove it from the command table. */
             retval = dictDelete(server.commands, argv[1]);
-            redisAssert(retval == DICT_OK);
+            serverAssert(retval == DICT_OK);
 
             /* Otherwise we re-add the command under a different name. */
             if (sdslen(argv[2]) != 0) {
                 sds copy = sdsdup(argv[2]);
 
                 retval = dictAdd(server.commands, copy, cmd);
@@ -526,12 +585,21 @@
 
             if (flags == -1) {
                 err = "Invalid event class character. Use 'g$lshzxeA'.";
                 goto loaderr;
             }
             server.notify_keyspace_events = flags;
+        } else if (!strcasecmp(argv[0],"supervised") && argc == 2) {
+            server.supervised_mode =
+                configEnumGetValue(supervised_mode_enum,argv[1]);
+
+            if (server.supervised_mode == INT_MIN) {
+                err = "Invalid option for 'supervised'. "
+                    "Allowed values: 'upstart', 'systemd', 'auto', or 'no'";
+                goto loaderr;
+            }
         } else if (!strcasecmp(argv[0],"sentinel")) {
             /* argc == 1 is handled by main() as we need to enter the sentinel
              * mode ASAP. */
             if (argc != 1) {
                 if (!server.sentinel_mode) {
                     err = "sentinel directive while not in sentinel mode";
@@ -571,28 +639,28 @@
  *
  * Both filename and options can be NULL, in such a case are considered
  * empty. This way loadServerConfig can be used to just load a file or
  * just load a string. */
 void loadServerConfig(char *filename, char *options) {
     sds config = sdsempty();
-    char buf[REDIS_CONFIGLINE_MAX+1];
+    char buf[CONFIG_MAX_LINE+1];
 
     /* Load the file content */
     if (filename) {
         FILE *fp;
 
         if (filename[0] == '-' && filename[1] == '\0') {
             fp = stdin;
         } else {
             if ((fp = fopen(filename,"r")) == NULL) {
-                redisLog(REDIS_WARNING,
+                serverLog(LL_WARNING,
                     "Fatal error, can't open config file '%s'", filename);
                 exit(1);
             }
         }
-        while(fgets(buf,REDIS_CONFIGLINE_MAX+1,fp) != NULL)
+        while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL)
             config = sdscat(config,buf);
         if (fp != stdin) fclose(fp);
     }
     /* Append the additional options */
     if (options) {
         config = sdscat(config,"\n");
@@ -603,148 +671,107 @@
 }
 
 /*-----------------------------------------------------------------------------
  * CONFIG SET implementation
  *----------------------------------------------------------------------------*/
 
-void configSetCommand(redisClient *c) {
+#define config_set_bool_field(_name,_var) \
+    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \
+        int yn = yesnotoi(o->ptr); \
+        if (yn == -1) goto badfmt; \
+        _var = yn;
+
+#define config_set_numerical_field(_name,_var,min,max) \
+    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \
+        if (getLongLongFromObject(o,&ll) == C_ERR || ll < 0) goto badfmt; \
+        if (min != LLONG_MIN && ll < min) goto badfmt; \
+        if (max != LLONG_MAX && ll > max) goto badfmt; \
+        _var = ll;
+
+#define config_set_memory_field(_name,_var) \
+    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \
+        ll = memtoll(o->ptr,&err); \
+        if (err || ll < 0) goto badfmt; \
+        _var = ll;
+
+#define config_set_enum_field(_name,_var,_enumvar) \
+    } else if (!strcasecmp(c->argv[2]->ptr,_name)) { \
+        int enumval = configEnumGetValue(_enumvar,o->ptr); \
+        if (enumval == INT_MIN) goto badfmt; \
+        _var = enumval;
+
+#define config_set_special_field(_name) \
+    } else if (!strcasecmp(c->argv[2]->ptr,_name)) {
+
+#define config_set_else } else
+
+void configSetCommand(client *c) {
     robj *o;
     long long ll;
     int err;
-    redisAssertWithInfo(c,c->argv[2],sdsEncodedObject(c->argv[2]));
-    redisAssertWithInfo(c,c->argv[3],sdsEncodedObject(c->argv[3]));
+    serverAssertWithInfo(c,c->argv[2],sdsEncodedObject(c->argv[2]));
+    serverAssertWithInfo(c,c->argv[3],sdsEncodedObject(c->argv[3]));
     o = c->argv[3];
 
-    if (!strcasecmp(c->argv[2]->ptr,"dbfilename")) {
+    if (0) { /* this starts the config_set macros else-if chain. */
+
+    /* Special fields that can't be handled with general macros. */
+    config_set_special_field("dbfilename") {
         if (!pathIsBaseName(o->ptr)) {
             addReplyError(c, "dbfilename can't be a path, just a filename");
             return;
         }
         zfree(server.rdb_filename);
         server.rdb_filename = zstrdup(o->ptr);
-    } else if (!strcasecmp(c->argv[2]->ptr,"requirepass")) {
-        if (sdslen(o->ptr) > REDIS_AUTHPASS_MAX_LEN) goto badfmt;
+    } config_set_special_field("requirepass") {
+        if (sdslen(o->ptr) > CONFIG_AUTHPASS_MAX_LEN) goto badfmt;
         zfree(server.requirepass);
         server.requirepass = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
-    } else if (!strcasecmp(c->argv[2]->ptr,"masterauth")) {
+    } config_set_special_field("masterauth") {
         zfree(server.masterauth);
         server.masterauth = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
-    } else if (!strcasecmp(c->argv[2]->ptr,"maxmemory")) {
-        ll = memtoll(o->ptr,&err);
-        if (err || ll < 0) goto badfmt;
-        server.maxmemory = ll;
-        if (server.maxmemory) {
-            if (server.maxmemory < zmalloc_used_memory()) {
-                redisLog(REDIS_WARNING,"WARNING: the new maxmemory value set via CONFIG SET is smaller than the current memory usage. This will result in keys eviction and/or inability to accept new write commands depending on the maxmemory-policy.");
-            }
-            freeMemoryIfNeeded();
-        }
-    } else if (!strcasecmp(c->argv[2]->ptr,"maxclients")) {
+    } config_set_special_field("maxclients") {
         int orig_value = server.maxclients;
 
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 1) goto badfmt;
+        if (getLongLongFromObject(o,&ll) == C_ERR || ll < 1) goto badfmt;
 
         /* Try to check if the OS is capable of supporting so many FDs. */
         server.maxclients = ll;
         if (ll > orig_value) {
             adjustOpenFilesLimit();
             if (server.maxclients != ll) {
                 addReplyErrorFormat(c,"The operating system is not able to handle the specified number of clients, try with %d", server.maxclients);
                 server.maxclients = orig_value;
                 return;
             }
             if ((unsigned int) aeGetSetSize(server.el) <
-                server.maxclients + REDIS_EVENTLOOP_FDSET_INCR)
+                server.maxclients + CONFIG_FDSET_INCR)
             {
                 if (aeResizeSetSize(server.el,
-                    server.maxclients + REDIS_EVENTLOOP_FDSET_INCR) == AE_ERR)
+                    server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)
                 {
                     addReplyError(c,"The event loop API used by Redis is not able to handle the specified number of clients");
                     server.maxclients = orig_value;
                     return;
                 }
             }
         }
-    } else if (!strcasecmp(c->argv[2]->ptr,"hz")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.hz = ll;
-        if (server.hz < REDIS_MIN_HZ) server.hz = REDIS_MIN_HZ;
-        if (server.hz > REDIS_MAX_HZ) server.hz = REDIS_MAX_HZ;
-    } else if (!strcasecmp(c->argv[2]->ptr,"maxmemory-policy")) {
-        if (!strcasecmp(o->ptr,"volatile-lru")) {
-            server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU;
-        } else if (!strcasecmp(o->ptr,"volatile-random")) {
-            server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_RANDOM;
-        } else if (!strcasecmp(o->ptr,"volatile-ttl")) {
-            server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_TTL;
-        } else if (!strcasecmp(o->ptr,"allkeys-lru")) {
-            server.maxmemory_policy = REDIS_MAXMEMORY_ALLKEYS_LRU;
-        } else if (!strcasecmp(o->ptr,"allkeys-random")) {
-            server.maxmemory_policy = REDIS_MAXMEMORY_ALLKEYS_RANDOM;
-        } else if (!strcasecmp(o->ptr,"noeviction")) {
-            server.maxmemory_policy = REDIS_MAXMEMORY_NO_EVICTION;
-        } else {
-            goto badfmt;
-        }
-    } else if (!strcasecmp(c->argv[2]->ptr,"maxmemory-samples")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll <= 0) goto badfmt;
-        server.maxmemory_samples = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"timeout")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll < 0 || ll > LONG_MAX) goto badfmt;
-        server.maxidletime = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"tcp-keepalive")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll < 0 || ll > INT_MAX) goto badfmt;
-        server.tcpkeepalive = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"appendfsync")) {
-        if (!strcasecmp(o->ptr,"no")) {
-            server.aof_fsync = AOF_FSYNC_NO;
-        } else if (!strcasecmp(o->ptr,"everysec")) {
-            server.aof_fsync = AOF_FSYNC_EVERYSEC;
-        } else if (!strcasecmp(o->ptr,"always")) {
-            server.aof_fsync = AOF_FSYNC_ALWAYS;
-        } else {
-            goto badfmt;
-        }
-    } else if (!strcasecmp(c->argv[2]->ptr,"no-appendfsync-on-rewrite")) {
-        int yn = yesnotoi(o->ptr);
-
-        if (yn == -1) goto badfmt;
-        server.aof_no_fsync_on_rewrite = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"appendonly")) {
+    } config_set_special_field("appendonly") {
         int enable = yesnotoi(o->ptr);
 
         if (enable == -1) goto badfmt;
-        if (enable == 0 && server.aof_state != REDIS_AOF_OFF) {
+        if (enable == 0 && server.aof_state != AOF_OFF) {
             stopAppendOnly();
-        } else if (enable && server.aof_state == REDIS_AOF_OFF) {
-            if (startAppendOnly() == REDIS_ERR) {
+        } else if (enable && server.aof_state == AOF_OFF) {
+            if (startAppendOnly() == C_ERR) {
                 addReplyError(c,
                     "Unable to turn on AOF. Check server logs.");
                 return;
             }
         }
-    } else if (!strcasecmp(c->argv[2]->ptr,"auto-aof-rewrite-percentage")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.aof_rewrite_perc = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"auto-aof-rewrite-min-size")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.aof_rewrite_min_size = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"aof-rewrite-incremental-fsync")) {
-        int yn = yesnotoi(o->ptr);
-
-        if (yn == -1) goto badfmt;
-        server.aof_rewrite_incremental_fsync = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"aof-load-truncated")) {
-        int yn = yesnotoi(o->ptr);
-
-        if (yn == -1) goto badfmt;
-        server.aof_load_truncated = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"save")) {
+    } config_set_special_field("save") {
         int vlen, j;
         sds *v = sdssplitlen(o->ptr,sdslen(o->ptr)," ",1,&vlen);
 
         /* Perform sanity check before setting the new config:
          * - Even number of args
          * - Seconds >= 1, changes >= 0 */
@@ -772,81 +799,18 @@
 
             seconds = strtoll(v[j],NULL,10);
             changes = strtoll(v[j+1],NULL,10);
             appendServerSaveParams(seconds, changes);
         }
         sdsfreesplitres(v,vlen);
-    } else if (!strcasecmp(c->argv[2]->ptr,"slave-serve-stale-data")) {
-        int yn = yesnotoi(o->ptr);
-
-        if (yn == -1) goto badfmt;
-        server.repl_serve_stale_data = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"slave-read-only")) {
-        int yn = yesnotoi(o->ptr);
-
-        if (yn == -1) goto badfmt;
-        server.repl_slave_ro = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"activerehashing")) {
-        int yn = yesnotoi(o->ptr);
-
-        if (yn == -1) goto badfmt;
-        server.activerehashing = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"dir")) {
+    } config_set_special_field("dir") {
         if (chdir((char*)o->ptr) == -1) {
             addReplyErrorFormat(c,"Changing directory: %s", strerror(errno));
             return;
         }
-    } else if (!strcasecmp(c->argv[2]->ptr,"hash-max-ziplist-entries")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.hash_max_ziplist_entries = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"hash-max-ziplist-value")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.hash_max_ziplist_value = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"list-max-ziplist-entries")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.list_max_ziplist_entries = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"list-max-ziplist-value")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.list_max_ziplist_value = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"set-max-intset-entries")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.set_max_intset_entries = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"zset-max-ziplist-entries")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.zset_max_ziplist_entries = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"zset-max-ziplist-value")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.zset_max_ziplist_value = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"hll-sparse-max-bytes")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.hll_sparse_max_bytes = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"lua-time-limit")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.lua_time_limit = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"slowlog-log-slower-than")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR) goto badfmt;
-        server.slowlog_log_slower_than = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"slowlog-max-len")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.slowlog_max_len = (unsigned)ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"latency-monitor-threshold")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.latency_monitor_threshold = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"loglevel")) {
-        if (!strcasecmp(o->ptr,"warning")) {
-            server.verbosity = REDIS_WARNING;
-        } else if (!strcasecmp(o->ptr,"notice")) {
-            server.verbosity = REDIS_NOTICE;
-        } else if (!strcasecmp(o->ptr,"verbose")) {
-            server.verbosity = REDIS_VERBOSE;
-        } else if (!strcasecmp(o->ptr,"debug")) {
-            server.verbosity = REDIS_DEBUG;
-        } else {
-            goto badfmt;
-        }
-    } else if (!strcasecmp(c->argv[2]->ptr,"client-output-buffer-limit")) {
+    } config_set_special_field("client-output-buffer-limit") {
         int vlen, j;
         sds *v = sdssplitlen(o->ptr,sdslen(o->ptr)," ",1,&vlen);
 
         /* We need a multiple of 4: <class> <hard> <soft> <soft_seconds> */
         if (vlen % 4) {
             sdsfreesplitres(v,vlen);
@@ -885,96 +849,147 @@
 
             server.client_obuf_limits[class].hard_limit_bytes = hard;
             server.client_obuf_limits[class].soft_limit_bytes = soft;
             server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;
         }
         sdsfreesplitres(v,vlen);
-    } else if (!strcasecmp(c->argv[2]->ptr,"stop-writes-on-bgsave-error")) {
-        int yn = yesnotoi(o->ptr);
-
-        if (yn == -1) goto badfmt;
-        server.stop_writes_on_bgsave_err = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"repl-ping-slave-period")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll <= 0) goto badfmt;
-        server.repl_ping_slave_period = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"repl-timeout")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll <= 0) goto badfmt;
-        server.repl_timeout = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"repl-backlog-size")) {
-        ll = memtoll(o->ptr,&err);
-        if (err || ll < 0) goto badfmt;
-        resizeReplicationBacklog(ll);
-    } else if (!strcasecmp(c->argv[2]->ptr,"repl-backlog-ttl")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        server.repl_backlog_time_limit = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"watchdog-period")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
-        if (ll)
-            enableWatchdog(ll);
-        else
-            disableWatchdog();
-    } else if (!strcasecmp(c->argv[2]->ptr,"rdbcompression")) {
-        int yn = yesnotoi(o->ptr);
-
-        if (yn == -1) goto badfmt;
-        server.rdb_compression = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"notify-keyspace-events")) {
+    } config_set_special_field("notify-keyspace-events") {
         int flags = keyspaceEventsStringToFlags(o->ptr);
 
         if (flags == -1) goto badfmt;
         server.notify_keyspace_events = flags;
-    } else if (!strcasecmp(c->argv[2]->ptr,"repl-disable-tcp-nodelay")) {
-        int yn = yesnotoi(o->ptr);
 
-        if (yn == -1) goto badfmt;
-        server.repl_disable_tcp_nodelay = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"repl-diskless-sync")) {
-        int yn = yesnotoi(o->ptr);
-
-        if (yn == -1) goto badfmt;
-        server.repl_diskless_sync = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"repl-diskless-sync-delay")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll < 0) goto badfmt;
-        server.repl_diskless_sync_delay = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"slave-priority")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll < 0) goto badfmt;
-        server.slave_priority = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"min-slaves-to-write")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll < 0) goto badfmt;
-        server.repl_min_slaves_to_write = ll;
+    /* Boolean fields.
+     * config_set_bool_field(name,var). */
+    } config_set_bool_field(
+      "rdbcompression", server.rdb_compression) {
+    } config_set_bool_field(
+      "repl-disable-tcp-nodelay",server.repl_disable_tcp_nodelay) {
+    } config_set_bool_field(
+      "repl-diskless-sync",server.repl_diskless_sync) {
+    } config_set_bool_field(
+      "cluster-require-full-coverage",server.cluster_require_full_coverage) {
+    } config_set_bool_field(
+      "aof-rewrite-incremental-fsync",server.aof_rewrite_incremental_fsync) {
+    } config_set_bool_field(
+      "aof-load-truncated",server.aof_load_truncated) {
+    } config_set_bool_field(
+      "slave-serve-stale-data",server.repl_serve_stale_data) {
+    } config_set_bool_field(
+      "slave-read-only",server.repl_slave_ro) {
+    } config_set_bool_field(
+      "activerehashing",server.activerehashing) {
+    } config_set_bool_field(
+      "protected-mode",server.protected_mode) {
+    } config_set_bool_field(
+      "stop-writes-on-bgsave-error",server.stop_writes_on_bgsave_err) {
+    } config_set_bool_field(
+      "no-appendfsync-on-rewrite",server.aof_no_fsync_on_rewrite) {
+
+    /* Numerical fields.
+     * config_set_numerical_field(name,var,min,max) */
+    } config_set_numerical_field(
+      "tcp-keepalive",server.tcpkeepalive,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "maxmemory-samples",server.maxmemory_samples,1,LLONG_MAX) {
+    } config_set_numerical_field(
+      "timeout",server.maxidletime,0,LONG_MAX) {
+    } config_set_numerical_field(
+      "auto-aof-rewrite-percentage",server.aof_rewrite_perc,0,LLONG_MAX){
+    } config_set_numerical_field(
+      "auto-aof-rewrite-min-size",server.aof_rewrite_min_size,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "hash-max-ziplist-entries",server.hash_max_ziplist_entries,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "hash-max-ziplist-value",server.hash_max_ziplist_value,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "list-max-ziplist-size",server.list_max_ziplist_size,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "list-compress-depth",server.list_compress_depth,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "set-max-intset-entries",server.set_max_intset_entries,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "zset-max-ziplist-entries",server.zset_max_ziplist_entries,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "zset-max-ziplist-value",server.zset_max_ziplist_value,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "hll-sparse-max-bytes",server.hll_sparse_max_bytes,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "lua-time-limit",server.lua_time_limit,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "slowlog-log-slower-than",server.slowlog_log_slower_than,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "slowlog-max-len",ll,0,LLONG_MAX) {
+      /* Cast to unsigned. */
+        server.slowlog_max_len = (unsigned)ll;
+    } config_set_numerical_field(
+      "latency-monitor-threshold",server.latency_monitor_threshold,0,LLONG_MAX){
+    } config_set_numerical_field(
+      "repl-ping-slave-period",server.repl_ping_slave_period,1,LLONG_MAX) {
+    } config_set_numerical_field(
+      "repl-timeout",server.repl_timeout,1,LLONG_MAX) {
+    } config_set_numerical_field(
+      "repl-backlog-ttl",server.repl_backlog_time_limit,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "repl-diskless-sync-delay",server.repl_diskless_sync_delay,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "slave-priority",server.slave_priority,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "min-slaves-to-write",server.repl_min_slaves_to_write,0,LLONG_MAX) {
         refreshGoodSlavesCount();
-    } else if (!strcasecmp(c->argv[2]->ptr,"min-slaves-max-lag")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll < 0) goto badfmt;
-        server.repl_min_slaves_max_lag = ll;
+    } config_set_numerical_field(
+      "min-slaves-max-lag",server.repl_min_slaves_max_lag,0,LLONG_MAX) {
         refreshGoodSlavesCount();
-    } else if (!strcasecmp(c->argv[2]->ptr,"cluster-require-full-coverage")) {
-        int yn = yesnotoi(o->ptr);
+    } config_set_numerical_field(
+      "cluster-node-timeout",server.cluster_node_timeout,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "cluster-migration-barrier",server.cluster_migration_barrier,0,LLONG_MAX){
+    } config_set_numerical_field(
+      "cluster-slave-validity-factor",server.cluster_slave_validity_factor,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "hz",server.hz,0,LLONG_MAX) {
+        /* Hz is more an hint from the user, so we accept values out of range
+         * but cap them to reasonable values. */
+        if (server.hz < CONFIG_MIN_HZ) server.hz = CONFIG_MIN_HZ;
+        if (server.hz > CONFIG_MAX_HZ) server.hz = CONFIG_MAX_HZ;
+    } config_set_numerical_field(
+      "watchdog-period",ll,0,LLONG_MAX) {
+        if (ll)
+            enableWatchdog(ll);
+        else
+            disableWatchdog();
 
-        if (yn == -1) goto badfmt;
-        server.cluster_require_full_coverage = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"cluster-node-timeout")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll <= 0) goto badfmt;
-        server.cluster_node_timeout = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"cluster-migration-barrier")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll < 0) goto badfmt;
-        server.cluster_migration_barrier = ll;
-    } else if (!strcasecmp(c->argv[2]->ptr,"cluster-slave-validity-factor")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll < 0) goto badfmt;
-        server.cluster_slave_validity_factor = ll;
-    } else {
+    /* Memory fields.
+     * config_set_memory_field(name,var) */
+    } config_set_memory_field("maxmemory",server.maxmemory) {
+        if (server.maxmemory) {
+            if (server.maxmemory < zmalloc_used_memory()) {
+                serverLog(LL_WARNING,"WARNING: the new maxmemory value set via CONFIG SET is smaller than the current memory usage. This will result in keys eviction and/or inability to accept new write commands depending on the maxmemory-policy.");
+            }
+            freeMemoryIfNeeded();
+        }
+    } config_set_memory_field("repl-backlog-size",ll) {
+        resizeReplicationBacklog(ll);
+
+    /* Enumeration fields.
+     * config_set_enum_field(name,var,enum_var) */
+    } config_set_enum_field(
+      "loglevel",server.verbosity,loglevel_enum) {
+    } config_set_enum_field(
+      "maxmemory-policy",server.maxmemory_policy,maxmemory_policy_enum) {
+    } config_set_enum_field(
+      "appendfsync",server.aof_fsync,aof_fsync_enum) {
+
+    /* Everyhing else is an error... */
+    } config_set_else {
         addReplyErrorFormat(c,"Unsupported CONFIG parameter: %s",
             (char*)c->argv[2]->ptr);
         return;
     }
+
+    /* On success we just return a generic OK for all the options. */
     addReply(c,shared.ok);
     return;
 
 badfmt: /* Bad format errors */
     addReplyErrorFormat(c,"Invalid argument '%s' for CONFIG SET '%s'",
             (char*)o->ptr,
@@ -1007,19 +1022,27 @@
         addReplyBulkCString(c,_name); \
         addReplyBulkCString(c,buf); \
         matches++; \
     } \
 } while(0);
 
-void configGetCommand(redisClient *c) {
+#define config_get_enum_field(_name,_var,_enumvar) do { \
+    if (stringmatch(pattern,_name,0)) { \
+        addReplyBulkCString(c,_name); \
+        addReplyBulkCString(c,configEnumGetNameOrUnknown(_enumvar,_var)); \
+        matches++; \
+    } \
+} while(0);
+
+void configGetCommand(client *c) {
     robj *o = c->argv[2];
     void *replylen = addDeferredMultiBulkLength(c);
     char *pattern = o->ptr;
     char buf[128];
     int matches = 0;
-    redisAssertWithInfo(c,o,sdsEncodedObject(o));
+    serverAssertWithInfo(c,o,sdsEncodedObject(o));
 
     /* String values */
     config_get_string_field("dbfilename",server.rdb_filename);
     config_get_string_field("requirepass",server.requirepass);
     config_get_string_field("masterauth",server.masterauth);
     config_get_string_field("unixsocket",server.unixsocket);
@@ -1027,25 +1050,24 @@
     config_get_string_field("pidfile",server.pidfile);
 
     /* Numerical values */
     config_get_numerical_field("maxmemory",server.maxmemory);
     config_get_numerical_field("maxmemory-samples",server.maxmemory_samples);
     config_get_numerical_field("timeout",server.maxidletime);
-    config_get_numerical_field("tcp-keepalive",server.tcpkeepalive);
     config_get_numerical_field("auto-aof-rewrite-percentage",
             server.aof_rewrite_perc);
     config_get_numerical_field("auto-aof-rewrite-min-size",
             server.aof_rewrite_min_size);
     config_get_numerical_field("hash-max-ziplist-entries",
             server.hash_max_ziplist_entries);
     config_get_numerical_field("hash-max-ziplist-value",
             server.hash_max_ziplist_value);
-    config_get_numerical_field("list-max-ziplist-entries",
-            server.list_max_ziplist_entries);
-    config_get_numerical_field("list-max-ziplist-value",
-            server.list_max_ziplist_value);
+    config_get_numerical_field("list-max-ziplist-size",
+            server.list_max_ziplist_size);
+    config_get_numerical_field("list-compress-depth",
+            server.list_compress_depth);
     config_get_numerical_field("set-max-intset-entries",
             server.set_max_intset_entries);
     config_get_numerical_field("zset-max-ziplist-entries",
             server.zset_max_ziplist_entries);
     config_get_numerical_field("zset-max-ziplist-value",
             server.zset_max_ziplist_value);
@@ -1072,12 +1094,13 @@
     config_get_numerical_field("min-slaves-max-lag",server.repl_min_slaves_max_lag);
     config_get_numerical_field("hz",server.hz);
     config_get_numerical_field("cluster-node-timeout",server.cluster_node_timeout);
     config_get_numerical_field("cluster-migration-barrier",server.cluster_migration_barrier);
     config_get_numerical_field("cluster-slave-validity-factor",server.cluster_slave_validity_factor);
     config_get_numerical_field("repl-diskless-sync-delay",server.repl_diskless_sync_delay);
+    config_get_numerical_field("tcp-keepalive",server.tcpkeepalive);
 
     /* Bool (yes/no) values */
     config_get_bool_field("cluster-require-full-coverage",
             server.cluster_require_full_coverage);
     config_get_bool_field("no-appendfsync-on-rewrite",
             server.aof_no_fsync_on_rewrite);
@@ -1088,67 +1111,51 @@
     config_get_bool_field("stop-writes-on-bgsave-error",
             server.stop_writes_on_bgsave_err);
     config_get_bool_field("daemonize", server.daemonize);
     config_get_bool_field("rdbcompression", server.rdb_compression);
     config_get_bool_field("rdbchecksum", server.rdb_checksum);
     config_get_bool_field("activerehashing", server.activerehashing);
+    config_get_bool_field("protected-mode", server.protected_mode);
     config_get_bool_field("repl-disable-tcp-nodelay",
             server.repl_disable_tcp_nodelay);
     config_get_bool_field("repl-diskless-sync",
             server.repl_diskless_sync);
     config_get_bool_field("aof-rewrite-incremental-fsync",
             server.aof_rewrite_incremental_fsync);
     config_get_bool_field("aof-load-truncated",
             server.aof_load_truncated);
 
+    /* Enum values */
+    config_get_enum_field("maxmemory-policy",
+            server.maxmemory_policy,maxmemory_policy_enum);
+    config_get_enum_field("loglevel",
+            server.verbosity,loglevel_enum);
+    config_get_enum_field("supervised",
+            server.supervised_mode,supervised_mode_enum);
+    config_get_enum_field("appendfsync",
+            server.aof_fsync,aof_fsync_enum);
+    config_get_enum_field("syslog-facility",
+            server.syslog_facility,syslog_facility_enum);
+
     /* Everything we can't handle with macros follows. */
 
     if (stringmatch(pattern,"appendonly",0)) {
         addReplyBulkCString(c,"appendonly");
-        addReplyBulkCString(c,server.aof_state == REDIS_AOF_OFF ? "no" : "yes");
+        addReplyBulkCString(c,server.aof_state == AOF_OFF ? "no" : "yes");
         matches++;
     }
     if (stringmatch(pattern,"dir",0)) {
         char buf[1024];
 
         if (getcwd(buf,sizeof(buf)) == NULL)
             buf[0] = '\0';
 
         addReplyBulkCString(c,"dir");
         addReplyBulkCString(c,buf);
         matches++;
     }
-    if (stringmatch(pattern,"maxmemory-policy",0)) {
-        char *s;
-
-        switch(server.maxmemory_policy) {
-        case REDIS_MAXMEMORY_VOLATILE_LRU: s = "volatile-lru"; break;
-        case REDIS_MAXMEMORY_VOLATILE_TTL: s = "volatile-ttl"; break;
-        case REDIS_MAXMEMORY_VOLATILE_RANDOM: s = "volatile-random"; break;
-        case REDIS_MAXMEMORY_ALLKEYS_LRU: s = "allkeys-lru"; break;
-        case REDIS_MAXMEMORY_ALLKEYS_RANDOM: s = "allkeys-random"; break;
-        case REDIS_MAXMEMORY_NO_EVICTION: s = "noeviction"; break;
-        default: s = "unknown"; break; /* too harmless to panic */
-        }
-        addReplyBulkCString(c,"maxmemory-policy");
-        addReplyBulkCString(c,s);
-        matches++;
-    }
-    if (stringmatch(pattern,"appendfsync",0)) {
-        char *policy;
-
-        switch(server.aof_fsync) {
-        case AOF_FSYNC_NO: policy = "no"; break;
-        case AOF_FSYNC_EVERYSEC: policy = "everysec"; break;
-        case AOF_FSYNC_ALWAYS: policy = "always"; break;
-        default: policy = "unknown"; break; /* too harmless to panic */
-        }
-        addReplyBulkCString(c,"appendfsync");
-        addReplyBulkCString(c,policy);
-        matches++;
-    }
     if (stringmatch(pattern,"save",0)) {
         sds buf = sdsempty();
         int j;
 
         for (j = 0; j < server.saveparamslen; j++) {
             buf = sdscatprintf(buf,"%jd %d",
@@ -1159,37 +1166,23 @@
         }
         addReplyBulkCString(c,"save");
         addReplyBulkCString(c,buf);
         sdsfree(buf);
         matches++;
     }
-    if (stringmatch(pattern,"loglevel",0)) {
-        char *s;
-
-        switch(server.verbosity) {
-        case REDIS_WARNING: s = "warning"; break;
-        case REDIS_VERBOSE: s = "verbose"; break;
-        case REDIS_NOTICE: s = "notice"; break;
-        case REDIS_DEBUG: s = "debug"; break;
-        default: s = "unknown"; break; /* too harmless to panic */
-        }
-        addReplyBulkCString(c,"loglevel");
-        addReplyBulkCString(c,s);
-        matches++;
-    }
     if (stringmatch(pattern,"client-output-buffer-limit",0)) {
         sds buf = sdsempty();
         int j;
 
-        for (j = 0; j < REDIS_CLIENT_TYPE_COUNT; j++) {
+        for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
             buf = sdscatprintf(buf,"%s %llu %llu %ld",
                     getClientTypeName(j),
                     server.client_obuf_limits[j].hard_limit_bytes,
                     server.client_obuf_limits[j].soft_limit_bytes,
                     (long) server.client_obuf_limits[j].soft_limit_seconds);
-            if (j != REDIS_CLIENT_TYPE_COUNT-1)
+            if (j != CLIENT_TYPE_OBUF_COUNT-1)
                 buf = sdscatlen(buf," ",1);
         }
         addReplyBulkCString(c,"client-output-buffer-limit");
         addReplyBulkCString(c,buf);
         sdsfree(buf);
         matches++;
@@ -1211,13 +1204,13 @@
         else
             buf[0] = '\0';
         addReplyBulkCString(c,buf);
         matches++;
     }
     if (stringmatch(pattern,"notify-keyspace-events",0)) {
-        robj *flagsobj = createObject(REDIS_STRING,
+        robj *flagsobj = createObject(OBJ_STRING,
             keyspaceEventsFlagsToString(server.notify_keyspace_events));
 
         addReplyBulkCString(c,"notify-keyspace-events");
         addReplyBulk(c,flagsobj);
         decrRefCount(flagsobj);
         matches++;
@@ -1297,13 +1290,13 @@
 }
 
 /* Add the specified option to the set of processed options.
  * This is useful as only unused lines of processed options will be blanked
  * in the config file, while options the rewrite process does not understand
  * remain untouched. */
-void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, char *option) {
+void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {
     sds opt = sdsnew(option);
 
     if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);
 }
 
 /* Read the old file, split it into lines to populate a newly created
@@ -1311,26 +1304,26 @@
  *
  * If it is impossible to read the old file, NULL is returned.
  * If the old file does not exist at all, an empty state is returned. */
 struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
     FILE *fp = fopen(path,"r");
     struct rewriteConfigState *state = zmalloc(sizeof(*state));
-    char buf[REDIS_CONFIGLINE_MAX+1];
+    char buf[CONFIG_MAX_LINE+1];
     int linenum = -1;
 
     if (fp == NULL && errno != ENOENT) return NULL;
 
     state->option_to_line = dictCreate(&optionToLineDictType,NULL);
     state->rewritten = dictCreate(&optionSetDictType,NULL);
     state->numlines = 0;
     state->lines = NULL;
     state->has_tail = 0;
     if (fp == NULL) return state;
 
     /* Read the old file line by line, populate the state. */
-    while(fgets(buf,REDIS_CONFIGLINE_MAX+1,fp) != NULL) {
+    while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {
         int argc;
         sds *argv;
         sds line = sdstrim(sdsnew(buf),"\r\n\t ");
 
         linenum++; /* Zero based, so we init at -1 */
 
@@ -1381,13 +1374,13 @@
  * The first time a line is appended into a configuration file, a comment
  * is added to show that starting from that point the config file was generated
  * by CONFIG REWRITE.
  *
  * "line" is either used, or freed, so the caller does not need to free it
  * in any way. */
-void rewriteConfigRewriteLine(struct rewriteConfigState *state, char *option, sds line, int force) {
+void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {
     sds o = sdsnew(option);
     list *l = dictFetchValue(state->option_to_line,o);
 
     rewriteConfigMarkAsProcessed(state,option);
 
     if (!l && !force) {
@@ -1492,51 +1485,32 @@
     int force = value != defvalue;
     sds line = sdscatprintf(sdsempty(),"%s %o",option,value);
 
     rewriteConfigRewriteLine(state,option,line,force);
 }
 
-/* Rewrite an enumeration option, after the "value" every enum/value pair
- * is specified, terminated by NULL. After NULL the default value is
- * specified. See how the function is used for more information. */
-void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, ...) {
-    va_list ap;
-    char *enum_name, *matching_name = NULL;
-    int enum_val, def_val, force;
+/* Rewrite an enumeration option. It takes as usually state and option name,
+ * and in addition the enumeration array and the default value for the
+ * option. */
+void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, configEnum *ce, int defval) {
     sds line;
+    const char *name = configEnumGetNameOrUnknown(ce,value);
+    int force = value != defval;
 
-    va_start(ap, value);
-    while(1) {
-        enum_name = va_arg(ap,char*);
-        enum_val = va_arg(ap,int);
-        if (enum_name == NULL) {
-            def_val = enum_val;
-            break;
-        }
-        if (value == enum_val) matching_name = enum_name;
-    }
-    va_end(ap);
-
-    force = value != def_val;
-    line = sdscatprintf(sdsempty(),"%s %s",option,matching_name);
+    line = sdscatprintf(sdsempty(),"%s %s",option,name);
     rewriteConfigRewriteLine(state,option,line,force);
 }
 
 /* Rewrite the syslog-facility option. */
 void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {
-    int value = server.syslog_facility, j;
+    int value = server.syslog_facility;
     int force = value != LOG_LOCAL0;
-    char *name = NULL, *option = "syslog-facility";
+    const char *name = NULL, *option = "syslog-facility";
     sds line;
 
-    for (j = 0; validSyslogFacilities[j].name; j++) {
-        if (validSyslogFacilities[j].value == value) {
-            name = (char*) validSyslogFacilities[j].name;
-            break;
-        }
-    }
+    name = configEnumGetNameOrUnknown(syslog_facility_enum,value);
     line = sdscatprintf(sdsempty(),"%s %s",option,name);
     rewriteConfigRewriteLine(state,option,line,force);
 }
 
 /* Rewrite the save option. */
 void rewriteConfigSaveOption(struct rewriteConfigState *state) {
@@ -1599,13 +1573,13 @@
 
 /* Rewrite the client-output-buffer-limit option. */
 void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {
     int j;
     char *option = "client-output-buffer-limit";
 
-    for (j = 0; j < REDIS_CLIENT_TYPE_COUNT; j++) {
+    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
         int force = (server.client_obuf_limits[j].hard_limit_bytes !=
                     clientBufferLimitsDefaults[j].hard_limit_bytes) ||
                     (server.client_obuf_limits[j].soft_limit_bytes !=
                     clientBufferLimitsDefaults[j].soft_limit_bytes) ||
                     (server.client_obuf_limits[j].soft_limit_seconds !=
                     clientBufferLimitsDefaults[j].soft_limit_seconds);
@@ -1690,13 +1664,13 @@
         list *l = dictGetVal(de);
         sds option = dictGetKey(de);
 
         /* Don't blank lines about options the rewrite process
          * don't understand. */
         if (dictFind(state->rewritten,option) == NULL) {
-            redisLog(REDIS_DEBUG,"Not rewritten option: %s", option);
+            serverLog(LL_DEBUG,"Not rewritten option: %s", option);
             continue;
         }
 
         while(listLength(l)) {
             listNode *ln = listFirst(l);
             int linenum = (long) ln->value;
@@ -1783,97 +1757,85 @@
     if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
 
     /* Step 2: rewrite every single option, replacing or appending it inside
      * the rewrite state. */
 
     rewriteConfigYesNoOption(state,"daemonize",server.daemonize,0);
-    rewriteConfigStringOption(state,"pidfile",server.pidfile,REDIS_DEFAULT_PID_FILE);
-    rewriteConfigNumericalOption(state,"port",server.port,REDIS_SERVERPORT);
-    rewriteConfigNumericalOption(state,"tcp-backlog",server.tcp_backlog,REDIS_TCP_BACKLOG);
+    rewriteConfigStringOption(state,"pidfile",server.pidfile,CONFIG_DEFAULT_PID_FILE);
+    rewriteConfigNumericalOption(state,"port",server.port,CONFIG_DEFAULT_SERVER_PORT);
+    rewriteConfigNumericalOption(state,"tcp-backlog",server.tcp_backlog,CONFIG_DEFAULT_TCP_BACKLOG);
     rewriteConfigBindOption(state);
     rewriteConfigStringOption(state,"unixsocket",server.unixsocket,NULL);
-    rewriteConfigOctalOption(state,"unixsocketperm",server.unixsocketperm,REDIS_DEFAULT_UNIX_SOCKET_PERM);
-    rewriteConfigNumericalOption(state,"timeout",server.maxidletime,REDIS_MAXIDLETIME);
-    rewriteConfigNumericalOption(state,"tcp-keepalive",server.tcpkeepalive,REDIS_DEFAULT_TCP_KEEPALIVE);
-    rewriteConfigEnumOption(state,"loglevel",server.verbosity,
-        "debug", REDIS_DEBUG,
-        "verbose", REDIS_VERBOSE,
-        "notice", REDIS_NOTICE,
-        "warning", REDIS_WARNING,
-        NULL, REDIS_DEFAULT_VERBOSITY);
-    rewriteConfigStringOption(state,"logfile",server.logfile,REDIS_DEFAULT_LOGFILE);
-    rewriteConfigYesNoOption(state,"syslog-enabled",server.syslog_enabled,REDIS_DEFAULT_SYSLOG_ENABLED);
-    rewriteConfigStringOption(state,"syslog-ident",server.syslog_ident,REDIS_DEFAULT_SYSLOG_IDENT);
+    rewriteConfigOctalOption(state,"unixsocketperm",server.unixsocketperm,CONFIG_DEFAULT_UNIX_SOCKET_PERM);
+    rewriteConfigNumericalOption(state,"timeout",server.maxidletime,CONFIG_DEFAULT_CLIENT_TIMEOUT);
+    rewriteConfigNumericalOption(state,"tcp-keepalive",server.tcpkeepalive,CONFIG_DEFAULT_TCP_KEEPALIVE);
+    rewriteConfigEnumOption(state,"loglevel",server.verbosity,loglevel_enum,CONFIG_DEFAULT_VERBOSITY);
+    rewriteConfigStringOption(state,"logfile",server.logfile,CONFIG_DEFAULT_LOGFILE);
+    rewriteConfigYesNoOption(state,"syslog-enabled",server.syslog_enabled,CONFIG_DEFAULT_SYSLOG_ENABLED);
+    rewriteConfigStringOption(state,"syslog-ident",server.syslog_ident,CONFIG_DEFAULT_SYSLOG_IDENT);
     rewriteConfigSyslogfacilityOption(state);
     rewriteConfigSaveOption(state);
-    rewriteConfigNumericalOption(state,"databases",server.dbnum,REDIS_DEFAULT_DBNUM);
-    rewriteConfigYesNoOption(state,"stop-writes-on-bgsave-error",server.stop_writes_on_bgsave_err,REDIS_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR);
-    rewriteConfigYesNoOption(state,"rdbcompression",server.rdb_compression,REDIS_DEFAULT_RDB_COMPRESSION);
-    rewriteConfigYesNoOption(state,"rdbchecksum",server.rdb_checksum,REDIS_DEFAULT_RDB_CHECKSUM);
-    rewriteConfigStringOption(state,"dbfilename",server.rdb_filename,REDIS_DEFAULT_RDB_FILENAME);
+    rewriteConfigNumericalOption(state,"databases",server.dbnum,CONFIG_DEFAULT_DBNUM);
+    rewriteConfigYesNoOption(state,"stop-writes-on-bgsave-error",server.stop_writes_on_bgsave_err,CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR);
+    rewriteConfigYesNoOption(state,"rdbcompression",server.rdb_compression,CONFIG_DEFAULT_RDB_COMPRESSION);
+    rewriteConfigYesNoOption(state,"rdbchecksum",server.rdb_checksum,CONFIG_DEFAULT_RDB_CHECKSUM);
+    rewriteConfigStringOption(state,"dbfilename",server.rdb_filename,CONFIG_DEFAULT_RDB_FILENAME);
     rewriteConfigDirOption(state);
     rewriteConfigSlaveofOption(state);
     rewriteConfigStringOption(state,"masterauth",server.masterauth,NULL);
-    rewriteConfigYesNoOption(state,"slave-serve-stale-data",server.repl_serve_stale_data,REDIS_DEFAULT_SLAVE_SERVE_STALE_DATA);
-    rewriteConfigYesNoOption(state,"slave-read-only",server.repl_slave_ro,REDIS_DEFAULT_SLAVE_READ_ONLY);
-    rewriteConfigNumericalOption(state,"repl-ping-slave-period",server.repl_ping_slave_period,REDIS_REPL_PING_SLAVE_PERIOD);
-    rewriteConfigNumericalOption(state,"repl-timeout",server.repl_timeout,REDIS_REPL_TIMEOUT);
-    rewriteConfigBytesOption(state,"repl-backlog-size",server.repl_backlog_size,REDIS_DEFAULT_REPL_BACKLOG_SIZE);
-    rewriteConfigBytesOption(state,"repl-backlog-ttl",server.repl_backlog_time_limit,REDIS_DEFAULT_REPL_BACKLOG_TIME_LIMIT);
-    rewriteConfigYesNoOption(state,"repl-disable-tcp-nodelay",server.repl_disable_tcp_nodelay,REDIS_DEFAULT_REPL_DISABLE_TCP_NODELAY);
-    rewriteConfigYesNoOption(state,"repl-diskless-sync",server.repl_diskless_sync,REDIS_DEFAULT_REPL_DISKLESS_SYNC);
-    rewriteConfigNumericalOption(state,"repl-diskless-sync-delay",server.repl_diskless_sync_delay,REDIS_DEFAULT_REPL_DISKLESS_SYNC_DELAY);
-    rewriteConfigNumericalOption(state,"slave-priority",server.slave_priority,REDIS_DEFAULT_SLAVE_PRIORITY);
-    rewriteConfigNumericalOption(state,"min-slaves-to-write",server.repl_min_slaves_to_write,REDIS_DEFAULT_MIN_SLAVES_TO_WRITE);
-    rewriteConfigNumericalOption(state,"min-slaves-max-lag",server.repl_min_slaves_max_lag,REDIS_DEFAULT_MIN_SLAVES_MAX_LAG);
+    rewriteConfigYesNoOption(state,"slave-serve-stale-data",server.repl_serve_stale_data,CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA);
+    rewriteConfigYesNoOption(state,"slave-read-only",server.repl_slave_ro,CONFIG_DEFAULT_SLAVE_READ_ONLY);
+    rewriteConfigNumericalOption(state,"repl-ping-slave-period",server.repl_ping_slave_period,CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD);
+    rewriteConfigNumericalOption(state,"repl-timeout",server.repl_timeout,CONFIG_DEFAULT_REPL_TIMEOUT);
+    rewriteConfigBytesOption(state,"repl-backlog-size",server.repl_backlog_size,CONFIG_DEFAULT_REPL_BACKLOG_SIZE);
+    rewriteConfigBytesOption(state,"repl-backlog-ttl",server.repl_backlog_time_limit,CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT);
+    rewriteConfigYesNoOption(state,"repl-disable-tcp-nodelay",server.repl_disable_tcp_nodelay,CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY);
+    rewriteConfigYesNoOption(state,"repl-diskless-sync",server.repl_diskless_sync,CONFIG_DEFAULT_REPL_DISKLESS_SYNC);
+    rewriteConfigNumericalOption(state,"repl-diskless-sync-delay",server.repl_diskless_sync_delay,CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY);
+    rewriteConfigNumericalOption(state,"slave-priority",server.slave_priority,CONFIG_DEFAULT_SLAVE_PRIORITY);
+    rewriteConfigNumericalOption(state,"min-slaves-to-write",server.repl_min_slaves_to_write,CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE);
+    rewriteConfigNumericalOption(state,"min-slaves-max-lag",server.repl_min_slaves_max_lag,CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG);
     rewriteConfigStringOption(state,"requirepass",server.requirepass,NULL);
-    rewriteConfigNumericalOption(state,"maxclients",server.maxclients,REDIS_MAX_CLIENTS);
-    rewriteConfigBytesOption(state,"maxmemory",server.maxmemory,REDIS_DEFAULT_MAXMEMORY);
-    rewriteConfigEnumOption(state,"maxmemory-policy",server.maxmemory_policy,
-        "volatile-lru", REDIS_MAXMEMORY_VOLATILE_LRU,
-        "allkeys-lru", REDIS_MAXMEMORY_ALLKEYS_LRU,
-        "volatile-random", REDIS_MAXMEMORY_VOLATILE_RANDOM,
-        "allkeys-random", REDIS_MAXMEMORY_ALLKEYS_RANDOM,
-        "volatile-ttl", REDIS_MAXMEMORY_VOLATILE_TTL,
-        "noeviction", REDIS_MAXMEMORY_NO_EVICTION,
-        NULL, REDIS_DEFAULT_MAXMEMORY_POLICY);
-    rewriteConfigNumericalOption(state,"maxmemory-samples",server.maxmemory_samples,REDIS_DEFAULT_MAXMEMORY_SAMPLES);
-    rewriteConfigYesNoOption(state,"appendonly",server.aof_state != REDIS_AOF_OFF,0);
-    rewriteConfigStringOption(state,"appendfilename",server.aof_filename,REDIS_DEFAULT_AOF_FILENAME);
-    rewriteConfigEnumOption(state,"appendfsync",server.aof_fsync,
-        "everysec", AOF_FSYNC_EVERYSEC,
-        "always", AOF_FSYNC_ALWAYS,
-        "no", AOF_FSYNC_NO,
-        NULL, REDIS_DEFAULT_AOF_FSYNC);
-    rewriteConfigYesNoOption(state,"no-appendfsync-on-rewrite",server.aof_no_fsync_on_rewrite,REDIS_DEFAULT_AOF_NO_FSYNC_ON_REWRITE);
-    rewriteConfigNumericalOption(state,"auto-aof-rewrite-percentage",server.aof_rewrite_perc,REDIS_AOF_REWRITE_PERC);
-    rewriteConfigBytesOption(state,"auto-aof-rewrite-min-size",server.aof_rewrite_min_size,REDIS_AOF_REWRITE_MIN_SIZE);
-    rewriteConfigNumericalOption(state,"lua-time-limit",server.lua_time_limit,REDIS_LUA_TIME_LIMIT);
+    rewriteConfigNumericalOption(state,"maxclients",server.maxclients,CONFIG_DEFAULT_MAX_CLIENTS);
+    rewriteConfigBytesOption(state,"maxmemory",server.maxmemory,CONFIG_DEFAULT_MAXMEMORY);
+    rewriteConfigEnumOption(state,"maxmemory-policy",server.maxmemory_policy,maxmemory_policy_enum,CONFIG_DEFAULT_MAXMEMORY_POLICY);
+    rewriteConfigNumericalOption(state,"maxmemory-samples",server.maxmemory_samples,CONFIG_DEFAULT_MAXMEMORY_SAMPLES);
+    rewriteConfigYesNoOption(state,"appendonly",server.aof_state != AOF_OFF,0);
+    rewriteConfigStringOption(state,"appendfilename",server.aof_filename,CONFIG_DEFAULT_AOF_FILENAME);
+    rewriteConfigEnumOption(state,"appendfsync",server.aof_fsync,aof_fsync_enum,CONFIG_DEFAULT_AOF_FSYNC);
+    rewriteConfigYesNoOption(state,"no-appendfsync-on-rewrite",server.aof_no_fsync_on_rewrite,CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE);
+    rewriteConfigNumericalOption(state,"auto-aof-rewrite-percentage",server.aof_rewrite_perc,AOF_REWRITE_PERC);
+    rewriteConfigBytesOption(state,"auto-aof-rewrite-min-size",server.aof_rewrite_min_size,AOF_REWRITE_MIN_SIZE);
+    rewriteConfigNumericalOption(state,"lua-time-limit",server.lua_time_limit,LUA_SCRIPT_TIME_LIMIT);
     rewriteConfigYesNoOption(state,"cluster-enabled",server.cluster_enabled,0);
-    rewriteConfigStringOption(state,"cluster-config-file",server.cluster_configfile,REDIS_DEFAULT_CLUSTER_CONFIG_FILE);
-    rewriteConfigYesNoOption(state,"cluster-require-full-coverage",server.cluster_require_full_coverage,REDIS_CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE);
-    rewriteConfigNumericalOption(state,"cluster-node-timeout",server.cluster_node_timeout,REDIS_CLUSTER_DEFAULT_NODE_TIMEOUT);
-    rewriteConfigNumericalOption(state,"cluster-migration-barrier",server.cluster_migration_barrier,REDIS_CLUSTER_DEFAULT_MIGRATION_BARRIER);
-    rewriteConfigNumericalOption(state,"cluster-slave-validity-factor",server.cluster_slave_validity_factor,REDIS_CLUSTER_DEFAULT_SLAVE_VALIDITY);
-    rewriteConfigNumericalOption(state,"slowlog-log-slower-than",server.slowlog_log_slower_than,REDIS_SLOWLOG_LOG_SLOWER_THAN);
-    rewriteConfigNumericalOption(state,"latency-monitor-threshold",server.latency_monitor_threshold,REDIS_DEFAULT_LATENCY_MONITOR_THRESHOLD);
-    rewriteConfigNumericalOption(state,"slowlog-max-len",server.slowlog_max_len,REDIS_SLOWLOG_MAX_LEN);
+    rewriteConfigStringOption(state,"cluster-config-file",server.cluster_configfile,CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);
+    rewriteConfigYesNoOption(state,"cluster-require-full-coverage",server.cluster_require_full_coverage,CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE);
+    rewriteConfigNumericalOption(state,"cluster-node-timeout",server.cluster_node_timeout,CLUSTER_DEFAULT_NODE_TIMEOUT);
+    rewriteConfigNumericalOption(state,"cluster-migration-barrier",server.cluster_migration_barrier,CLUSTER_DEFAULT_MIGRATION_BARRIER);
+    rewriteConfigNumericalOption(state,"cluster-slave-validity-factor",server.cluster_slave_validity_factor,CLUSTER_DEFAULT_SLAVE_VALIDITY);
+    rewriteConfigNumericalOption(state,"slowlog-log-slower-than",server.slowlog_log_slower_than,CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN);
+    rewriteConfigNumericalOption(state,"latency-monitor-threshold",server.latency_monitor_threshold,CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD);
+    rewriteConfigNumericalOption(state,"slowlog-max-len",server.slowlog_max_len,CONFIG_DEFAULT_SLOWLOG_MAX_LEN);
     rewriteConfigNotifykeyspaceeventsOption(state);
-    rewriteConfigNumericalOption(state,"hash-max-ziplist-entries",server.hash_max_ziplist_entries,REDIS_HASH_MAX_ZIPLIST_ENTRIES);
-    rewriteConfigNumericalOption(state,"hash-max-ziplist-value",server.hash_max_ziplist_value,REDIS_HASH_MAX_ZIPLIST_VALUE);
-    rewriteConfigNumericalOption(state,"list-max-ziplist-entries",server.list_max_ziplist_entries,REDIS_LIST_MAX_ZIPLIST_ENTRIES);
-    rewriteConfigNumericalOption(state,"list-max-ziplist-value",server.list_max_ziplist_value,REDIS_LIST_MAX_ZIPLIST_VALUE);
-    rewriteConfigNumericalOption(state,"set-max-intset-entries",server.set_max_intset_entries,REDIS_SET_MAX_INTSET_ENTRIES);
-    rewriteConfigNumericalOption(state,"zset-max-ziplist-entries",server.zset_max_ziplist_entries,REDIS_ZSET_MAX_ZIPLIST_ENTRIES);
-    rewriteConfigNumericalOption(state,"zset-max-ziplist-value",server.zset_max_ziplist_value,REDIS_ZSET_MAX_ZIPLIST_VALUE);
-    rewriteConfigNumericalOption(state,"hll-sparse-max-bytes",server.hll_sparse_max_bytes,REDIS_DEFAULT_HLL_SPARSE_MAX_BYTES);
-    rewriteConfigYesNoOption(state,"activerehashing",server.activerehashing,REDIS_DEFAULT_ACTIVE_REHASHING);
+    rewriteConfigNumericalOption(state,"hash-max-ziplist-entries",server.hash_max_ziplist_entries,OBJ_HASH_MAX_ZIPLIST_ENTRIES);
+    rewriteConfigNumericalOption(state,"hash-max-ziplist-value",server.hash_max_ziplist_value,OBJ_HASH_MAX_ZIPLIST_VALUE);
+    rewriteConfigNumericalOption(state,"list-max-ziplist-size",server.list_max_ziplist_size,OBJ_LIST_MAX_ZIPLIST_SIZE);
+    rewriteConfigNumericalOption(state,"list-compress-depth",server.list_compress_depth,OBJ_LIST_COMPRESS_DEPTH);
+    rewriteConfigNumericalOption(state,"set-max-intset-entries",server.set_max_intset_entries,OBJ_SET_MAX_INTSET_ENTRIES);
+    rewriteConfigNumericalOption(state,"zset-max-ziplist-entries",server.zset_max_ziplist_entries,OBJ_ZSET_MAX_ZIPLIST_ENTRIES);
+    rewriteConfigNumericalOption(state,"zset-max-ziplist-value",server.zset_max_ziplist_value,OBJ_ZSET_MAX_ZIPLIST_VALUE);
+    rewriteConfigNumericalOption(state,"hll-sparse-max-bytes",server.hll_sparse_max_bytes,CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES);
+    rewriteConfigYesNoOption(state,"activerehashing",server.activerehashing,CONFIG_DEFAULT_ACTIVE_REHASHING);
+    rewriteConfigYesNoOption(state,"protected-mode",server.protected_mode,CONFIG_DEFAULT_PROTECTED_MODE);
     rewriteConfigClientoutputbufferlimitOption(state);
-    rewriteConfigNumericalOption(state,"hz",server.hz,REDIS_DEFAULT_HZ);
-    rewriteConfigYesNoOption(state,"aof-rewrite-incremental-fsync",server.aof_rewrite_incremental_fsync,REDIS_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC);
-    rewriteConfigYesNoOption(state,"aof-load-truncated",server.aof_load_truncated,REDIS_DEFAULT_AOF_LOAD_TRUNCATED);
+    rewriteConfigNumericalOption(state,"hz",server.hz,CONFIG_DEFAULT_HZ);
+    rewriteConfigYesNoOption(state,"aof-rewrite-incremental-fsync",server.aof_rewrite_incremental_fsync,CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC);
+    rewriteConfigYesNoOption(state,"aof-load-truncated",server.aof_load_truncated,CONFIG_DEFAULT_AOF_LOAD_TRUNCATED);
+    rewriteConfigEnumOption(state,"supervised",server.supervised_mode,supervised_mode_enum,SUPERVISED_NONE);
+
+    /* Rewrite Sentinel config if in Sentinel mode. */
     if (server.sentinel_mode) rewriteConfigSentinelOption(state);
 
     /* Step 3: remove all the orphaned lines in the old file, that is, lines
      * that were used by a config option and are no longer used, like in case
      * of multiple "save" options or duplicated options. */
     rewriteConfigRemoveOrphaned(state);
@@ -1889,13 +1851,19 @@
 }
 
 /*-----------------------------------------------------------------------------
  * CONFIG command entry point
  *----------------------------------------------------------------------------*/
 
-void configCommand(redisClient *c) {
+void configCommand(client *c) {
+    /* Only allow CONFIG GET while loading. */
+    if (server.loading && strcasecmp(c->argv[1]->ptr,"get")) {
+        addReplyError(c,"Only CONFIG GET is allowed during loading");
+        return;
+    }
+
     if (!strcasecmp(c->argv[1]->ptr,"set")) {
         if (c->argc != 4) goto badarity;
         configSetCommand(c);
     } else if (!strcasecmp(c->argv[1]->ptr,"get")) {
         if (c->argc != 3) goto badarity;
         configGetCommand(c);
@@ -1908,16 +1876,16 @@
         if (c->argc != 2) goto badarity;
         if (server.configfile == NULL) {
             addReplyError(c,"The server is running without a config file");
             return;
         }
         if (rewriteConfig(server.configfile) == -1) {
-            redisLog(REDIS_WARNING,"CONFIG REWRITE failed: %s", strerror(errno));
+            serverLog(LL_WARNING,"CONFIG REWRITE failed: %s", strerror(errno));
             addReplyErrorFormat(c,"Rewriting config file: %s", strerror(errno));
         } else {
-            redisLog(REDIS_WARNING,"CONFIG REWRITE executed with success.");
+            serverLog(LL_WARNING,"CONFIG REWRITE executed with success.");
             addReply(c,shared.ok);
         }
     } else {
         addReplyError(c,
             "CONFIG subcommand must be one of GET, SET, RESETSTAT, REWRITE");
     }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.h	2016-05-06 15:11:36.000000000 +0800
@@ -63,12 +63,17 @@
 
 /* Test for backtrace() */
 #if defined(__APPLE__) || (defined(__linux__) && defined(__GLIBC__))
 #define HAVE_BACKTRACE 1
 #endif
 
+/* MSG_NOSIGNAL. */
+#ifdef __linux__
+#define HAVE_MSG_NOSIGNAL 1
+#endif
+
 /* Test for polling API */
 #ifdef __linux__
 #define HAVE_EPOLL 1
 #endif
 
 #if (defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined (__NetBSD__)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/config.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/config.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc16.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc16.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc16.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc16.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,7 +1,7 @@
-#include "redis.h"
+#include "server.h"
 
 /*
  * Copyright 2001-2010 Georges Menie (www.menie.org)
  * Copyright 2010-2012 Salvatore Sanfilippo (adapted to Redis coding style)
  * All rights reserved.
  *
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc16.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc16.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc16.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc16.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.c	2016-05-06 15:11:36.000000000 +0800
@@ -178,14 +178,18 @@
         crc = crc64_tab[(uint8_t)crc ^ byte] ^ (crc >> 8);
     }
     return crc;
 }
 
 /* Test main */
-#ifdef TEST_MAIN
+#ifdef REDIS_TEST
 #include <stdio.h>
-int main(void) {
+
+#define UNUSED(x) (void)(x)
+int crc64Test(int argc, char *argv[]) {
+    UNUSED(argc);
+    UNUSED(argv);
     printf("e9c6d914c4b8d9ca == %016llx\n",
         (unsigned long long) crc64(0,(unsigned char*)"123456789",9));
     return 0;
 }
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.h	2016-05-06 15:11:36.000000000 +0800
@@ -2,7 +2,11 @@
 #define CRC64_H
 
 #include <stdint.h>
 
 uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);
 
+#ifdef REDIS_TEST
+int crc64Test(int argc, char *argv[]);
+#endif
+
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/crc64.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/crc64.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/db.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/db.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/db.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/db.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,13 +24,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include "cluster.h"
 
 #include <signal.h>
 #include <ctype.h>
 
 void slotToKeyAdd(robj *key);
@@ -57,13 +57,38 @@
     }
 }
 
 robj *lookupKeyRead(redisDb *db, robj *key) {
     robj *val;
 
-    expireIfNeeded(db,key);
+    if (expireIfNeeded(db,key) == 1) {
+        /* Key expired. If we are in the context of a master, expireIfNeeded()
+         * returns 0 only when the key does not exist at all, so it's save
+         * to return NULL ASAP. */
+        if (server.masterhost == NULL) return NULL;
+
+        /* However if we are in the context of a slave, expireIfNeeded() will
+         * not really try to expire the key, it only returns information
+         * about the "logical" status of the key: key expiring is up to the
+         * master in order to have a consistent view of master's data set.
+         *
+         * However, if the command caller is not the master, and as additional
+         * safety measure, the command invoked is a read-only command, we can
+         * safely return NULL here, and provide a more consistent behavior
+         * to clients accessign expired values in a read-only fashion, that
+         * will say the key as non exisitng.
+         *
+         * Notably this covers GETs when slaves are used to scale reads. */
+        if (server.current_client &&
+            server.current_client != server.master &&
+            server.current_client->cmd &&
+            server.current_client->cmd->flags & CMD_READONLY)
+        {
+            return NULL;
+        }
+    }
     val = lookupKey(db,key);
     if (val == NULL)
         server.stat_keyspace_misses++;
     else
         server.stat_keyspace_hits++;
     return val;
@@ -71,19 +96,19 @@
 
 robj *lookupKeyWrite(redisDb *db, robj *key) {
     expireIfNeeded(db,key);
     return lookupKey(db,key);
 }
 
-robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply) {
+robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {
     robj *o = lookupKeyRead(c->db, key);
     if (!o) addReply(c,reply);
     return o;
 }
 
-robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply) {
+robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {
     robj *o = lookupKeyWrite(c->db, key);
     if (!o) addReply(c,reply);
     return o;
 }
 
 /* Add the key to the DB. It's up to the caller to increment the reference
@@ -91,26 +116,26 @@
  *
  * The program is aborted if the key already exists. */
 void dbAdd(redisDb *db, robj *key, robj *val) {
     sds copy = sdsdup(key->ptr);
     int retval = dictAdd(db->dict, copy, val);
 
-    redisAssertWithInfo(NULL,key,retval == REDIS_OK);
-    if (val->type == REDIS_LIST) signalListAsReady(db, key);
+    serverAssertWithInfo(NULL,key,retval == DICT_OK);
+    if (val->type == OBJ_LIST) signalListAsReady(db, key);
     if (server.cluster_enabled) slotToKeyAdd(key);
  }
 
 /* Overwrite an existing key with a new value. Incrementing the reference
  * count of the new value is up to the caller.
  * This function does not modify the expire time of the existing key.
  *
  * The program is aborted if the key was not already present. */
 void dbOverwrite(redisDb *db, robj *key, robj *val) {
     dictEntry *de = dictFind(db->dict,key->ptr);
 
-    redisAssertWithInfo(NULL,key,de != NULL);
+    serverAssertWithInfo(NULL,key,de != NULL);
     dictReplace(db->dict, key->ptr, val);
 }
 
 /* High level Set operation. This function can be used in order to set
  * a key, whatever it was existing or not, to a new object.
  *
@@ -189,21 +214,21 @@
  * USAGE:
  *
  * The object 'o' is what the caller already obtained by looking up 'key'
  * in 'db', the usage pattern looks like this:
  *
  * o = lookupKeyWrite(db,key);
- * if (checkType(c,o,REDIS_STRING)) return;
+ * if (checkType(c,o,OBJ_STRING)) return;
  * o = dbUnshareStringValue(db,key,o);
  *
  * At this point the caller is ready to modify the object, for example
  * using an sdscat() call to append some data, or anything else.
  */
 robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
-    redisAssert(o->type == REDIS_STRING);
-    if (o->refcount != 1 || o->encoding != REDIS_ENCODING_RAW) {
+    serverAssert(o->type == OBJ_STRING);
+    if (o->refcount != 1 || o->encoding != OBJ_ENCODING_RAW) {
         robj *decoded = getDecodedObject(o);
         o = createRawStringObject(decoded->ptr, sdslen(decoded->ptr));
         decrRefCount(decoded);
         dbOverwrite(db,key,o);
     }
     return o;
@@ -219,17 +244,17 @@
         dictEmpty(server.db[j].expires,callback);
     }
     if (server.cluster_enabled) slotToKeyFlush();
     return removed;
 }
 
-int selectDb(redisClient *c, int id) {
+int selectDb(client *c, int id) {
     if (id < 0 || id >= server.dbnum)
-        return REDIS_ERR;
+        return C_ERR;
     c->db = &server.db[id];
-    return REDIS_OK;
+    return C_OK;
 }
 
 /*-----------------------------------------------------------------------------
  * Hooks for key space changes.
  *
  * Every time a key in the database is modified the function
@@ -247,22 +272,22 @@
 }
 
 /*-----------------------------------------------------------------------------
  * Type agnostic commands operating on the key space
  *----------------------------------------------------------------------------*/
 
-void flushdbCommand(redisClient *c) {
+void flushdbCommand(client *c) {
     server.dirty += dictSize(c->db->dict);
     signalFlushedDb(c->db->id);
     dictEmpty(c->db->dict,NULL);
     dictEmpty(c->db->expires,NULL);
     if (server.cluster_enabled) slotToKeyFlush();
     addReply(c,shared.ok);
 }
 
-void flushallCommand(redisClient *c) {
+void flushallCommand(client *c) {
     signalFlushedDb(-1);
     server.dirty += emptyDb(NULL);
     addReply(c,shared.ok);
     if (server.rdb_child_pid != -1) {
         kill(server.rdb_child_pid,SIGUSR1);
         rdbRemoveTempFile(server.rdb_child_pid);
@@ -274,72 +299,72 @@
         rdbSave(server.rdb_filename);
         server.dirty = saved_dirty;
     }
     server.dirty++;
 }
 
-void delCommand(redisClient *c) {
+void delCommand(client *c) {
     int deleted = 0, j;
 
     for (j = 1; j < c->argc; j++) {
         expireIfNeeded(c->db,c->argv[j]);
         if (dbDelete(c->db,c->argv[j])) {
             signalModifiedKey(c->db,c->argv[j]);
-            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,
+            notifyKeyspaceEvent(NOTIFY_GENERIC,
                 "del",c->argv[j],c->db->id);
             server.dirty++;
             deleted++;
         }
     }
     addReplyLongLong(c,deleted);
 }
 
 /* EXISTS key1 key2 ... key_N.
  * Return value is the number of keys existing. */
-void existsCommand(redisClient *c) {
+void existsCommand(client *c) {
     long long count = 0;
     int j;
 
     for (j = 1; j < c->argc; j++) {
         expireIfNeeded(c->db,c->argv[j]);
         if (dbExists(c->db,c->argv[j])) count++;
     }
     addReplyLongLong(c,count);
 }
 
-void selectCommand(redisClient *c) {
+void selectCommand(client *c) {
     long id;
 
     if (getLongFromObjectOrReply(c, c->argv[1], &id,
-        "invalid DB index") != REDIS_OK)
+        "invalid DB index") != C_OK)
         return;
 
     if (server.cluster_enabled && id != 0) {
         addReplyError(c,"SELECT is not allowed in cluster mode");
         return;
     }
-    if (selectDb(c,id) == REDIS_ERR) {
+    if (selectDb(c,id) == C_ERR) {
         addReplyError(c,"invalid DB index");
     } else {
         addReply(c,shared.ok);
     }
 }
 
-void randomkeyCommand(redisClient *c) {
+void randomkeyCommand(client *c) {
     robj *key;
 
     if ((key = dbRandomKey(c->db)) == NULL) {
         addReply(c,shared.nullbulk);
         return;
     }
 
     addReplyBulk(c,key);
     decrRefCount(key);
 }
 
-void keysCommand(redisClient *c) {
+void keysCommand(client *c) {
     dictIterator *di;
     dictEntry *de;
     sds pattern = c->argv[1]->ptr;
     int plen = sdslen(pattern), allkeys;
     unsigned long numkeys = 0;
     void *replylen = addDeferredMultiBulkLength(c);
@@ -371,49 +396,49 @@
     robj *o = pd[1];
     robj *key, *val = NULL;
 
     if (o == NULL) {
         sds sdskey = dictGetKey(de);
         key = createStringObject(sdskey, sdslen(sdskey));
-    } else if (o->type == REDIS_SET) {
+    } else if (o->type == OBJ_SET) {
         key = dictGetKey(de);
         incrRefCount(key);
-    } else if (o->type == REDIS_HASH) {
+    } else if (o->type == OBJ_HASH) {
         key = dictGetKey(de);
         incrRefCount(key);
         val = dictGetVal(de);
         incrRefCount(val);
-    } else if (o->type == REDIS_ZSET) {
+    } else if (o->type == OBJ_ZSET) {
         key = dictGetKey(de);
         incrRefCount(key);
         val = createStringObjectFromLongDouble(*(double*)dictGetVal(de),0);
     } else {
-        redisPanic("Type not handled in SCAN callback.");
+        serverPanic("Type not handled in SCAN callback.");
     }
 
     listAddNodeTail(keys, key);
     if (val) listAddNodeTail(keys, val);
 }
 
 /* Try to parse a SCAN cursor stored at object 'o':
  * if the cursor is valid, store it as unsigned integer into *cursor and
- * returns REDIS_OK. Otherwise return REDIS_ERR and send an error to the
+ * returns C_OK. Otherwise return C_ERR and send an error to the
  * client. */
-int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor) {
+int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {
     char *eptr;
 
     /* Use strtoul() because we need an *unsigned* long, so
      * getLongLongFromObject() does not cover the whole cursor space. */
     errno = 0;
     *cursor = strtoul(o->ptr, &eptr, 10);
     if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' || errno == ERANGE)
     {
         addReplyError(c, "invalid cursor");
-        return REDIS_ERR;
+        return C_ERR;
     }
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* This command implements SCAN, HSCAN and SSCAN commands.
  * If object 'o' is passed, then it must be a Hash or Set object, otherwise
  * if 'o' is NULL the command will operate on the dictionary associated with
  * the current database.
@@ -421,35 +446,35 @@
  * When 'o' is not NULL the function assumes that the first argument in
  * the client arguments vector is a key so it skips it before iterating
  * in order to parse options.
  *
  * In the case of a Hash object the function returns both the field and value
  * of every element on the Hash. */
-void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor) {
+void scanGenericCommand(client *c, robj *o, unsigned long cursor) {
     int i, j;
     list *keys = listCreate();
     listNode *node, *nextnode;
     long count = 10;
-    sds pat;
-    int patlen, use_pattern = 0;
+    sds pat = NULL;
+    int patlen = 0, use_pattern = 0;
     dict *ht;
 
     /* Object must be NULL (to iterate keys names), or the type of the object
      * must be Set, Sorted Set, or Hash. */
-    redisAssert(o == NULL || o->type == REDIS_SET || o->type == REDIS_HASH ||
-                o->type == REDIS_ZSET);
+    serverAssert(o == NULL || o->type == OBJ_SET || o->type == OBJ_HASH ||
+                o->type == OBJ_ZSET);
 
     /* Set i to the first option argument. The previous one is the cursor. */
     i = (o == NULL) ? 2 : 3; /* Skip the key argument if needed. */
 
     /* Step 1: Parse options. */
     while (i < c->argc) {
         j = c->argc - i;
         if (!strcasecmp(c->argv[i]->ptr, "count") && j >= 2) {
             if (getLongFromObjectOrReply(c, c->argv[i+1], &count, NULL)
-                != REDIS_OK)
+                != C_OK)
             {
                 goto cleanup;
             }
 
             if (count < 1) {
                 addReply(c,shared.syntaxerr);
@@ -481,18 +506,18 @@
      * cursor to zero to signal the end of the iteration. */
 
     /* Handle the case of a hash table. */
     ht = NULL;
     if (o == NULL) {
         ht = c->db->dict;
-    } else if (o->type == REDIS_SET && o->encoding == REDIS_ENCODING_HT) {
+    } else if (o->type == OBJ_SET && o->encoding == OBJ_ENCODING_HT) {
         ht = o->ptr;
-    } else if (o->type == REDIS_HASH && o->encoding == REDIS_ENCODING_HT) {
+    } else if (o->type == OBJ_HASH && o->encoding == OBJ_ENCODING_HT) {
         ht = o->ptr;
         count *= 2; /* We return key / value for this type. */
-    } else if (o->type == REDIS_ZSET && o->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (o->type == OBJ_ZSET && o->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = o->ptr;
         ht = zs->dict;
         count *= 2; /* We return key / value for this type. */
     }
 
     if (ht) {
@@ -510,20 +535,20 @@
         privdata[1] = o;
         do {
             cursor = dictScan(ht, cursor, scanCallback, privdata);
         } while (cursor &&
               maxiterations-- &&
               listLength(keys) < (unsigned long)count);
-    } else if (o->type == REDIS_SET) {
+    } else if (o->type == OBJ_SET) {
         int pos = 0;
         int64_t ll;
 
         while(intsetGet(o->ptr,pos++,&ll))
             listAddNodeTail(keys,createStringObjectFromLongLong(ll));
         cursor = 0;
-    } else if (o->type == REDIS_HASH || o->type == REDIS_ZSET) {
+    } else if (o->type == OBJ_HASH || o->type == OBJ_ZSET) {
         unsigned char *p = ziplistIndex(o->ptr,0);
         unsigned char *vstr;
         unsigned int vlen;
         long long vll;
 
         while(p) {
@@ -532,13 +557,13 @@
                 (vstr != NULL) ? createStringObject((char*)vstr,vlen) :
                                  createStringObjectFromLongLong(vll));
             p = ziplistNext(o->ptr,p);
         }
         cursor = 0;
     } else {
-        redisPanic("Not handled encoding in SCAN.");
+        serverPanic("Not handled encoding in SCAN.");
     }
 
     /* Step 3: Filter elements. */
     node = listFirst(keys);
     while (node) {
         robj *kobj = listNodeValue(node);
@@ -548,16 +573,16 @@
         /* Filter element if it does not match the pattern. */
         if (!filter && use_pattern) {
             if (sdsEncodedObject(kobj)) {
                 if (!stringmatchlen(pat, patlen, kobj->ptr, sdslen(kobj->ptr), 0))
                     filter = 1;
             } else {
-                char buf[REDIS_LONGSTR_SIZE];
+                char buf[LONG_STR_SIZE];
                 int len;
 
-                redisAssert(kobj->encoding == REDIS_ENCODING_INT);
+                serverAssert(kobj->encoding == OBJ_ENCODING_INT);
                 len = ll2string(buf,sizeof(buf),(long)kobj->ptr);
                 if (!stringmatchlen(pat, patlen, buf, len, 0)) filter = 1;
             }
         }
 
         /* Filter element if it is an expired key. */
@@ -569,13 +594,13 @@
             listDelNode(keys, node);
         }
 
         /* If this is a hash or a sorted set, we have a flat list of
          * key-value elements, so if this element was filtered, remove the
          * value, or skip it if it was not filtered: we only match keys. */
-        if (o && (o->type == REDIS_ZSET || o->type == REDIS_HASH)) {
+        if (o && (o->type == OBJ_ZSET || o->type == OBJ_HASH)) {
             node = nextnode;
             nextnode = listNextNode(node);
             if (filter) {
                 kobj = listNodeValue(node);
                 decrRefCount(kobj);
                 listDelNode(keys, node);
@@ -599,87 +624,91 @@
 cleanup:
     listSetFreeMethod(keys,decrRefCountVoid);
     listRelease(keys);
 }
 
 /* The SCAN command completely relies on scanGenericCommand. */
-void scanCommand(redisClient *c) {
+void scanCommand(client *c) {
     unsigned long cursor;
-    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == REDIS_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) return;
     scanGenericCommand(c,NULL,cursor);
 }
 
-void dbsizeCommand(redisClient *c) {
+void dbsizeCommand(client *c) {
     addReplyLongLong(c,dictSize(c->db->dict));
 }
 
-void lastsaveCommand(redisClient *c) {
+void lastsaveCommand(client *c) {
     addReplyLongLong(c,server.lastsave);
 }
 
-void typeCommand(redisClient *c) {
+void typeCommand(client *c) {
     robj *o;
     char *type;
 
     o = lookupKeyRead(c->db,c->argv[1]);
     if (o == NULL) {
         type = "none";
     } else {
         switch(o->type) {
-        case REDIS_STRING: type = "string"; break;
-        case REDIS_LIST: type = "list"; break;
-        case REDIS_SET: type = "set"; break;
-        case REDIS_ZSET: type = "zset"; break;
-        case REDIS_HASH: type = "hash"; break;
+        case OBJ_STRING: type = "string"; break;
+        case OBJ_LIST: type = "list"; break;
+        case OBJ_SET: type = "set"; break;
+        case OBJ_ZSET: type = "zset"; break;
+        case OBJ_HASH: type = "hash"; break;
         default: type = "unknown"; break;
         }
     }
     addReplyStatus(c,type);
 }
 
-void shutdownCommand(redisClient *c) {
+void shutdownCommand(client *c) {
     int flags = 0;
 
     if (c->argc > 2) {
         addReply(c,shared.syntaxerr);
         return;
     } else if (c->argc == 2) {
         if (!strcasecmp(c->argv[1]->ptr,"nosave")) {
-            flags |= REDIS_SHUTDOWN_NOSAVE;
+            flags |= SHUTDOWN_NOSAVE;
         } else if (!strcasecmp(c->argv[1]->ptr,"save")) {
-            flags |= REDIS_SHUTDOWN_SAVE;
+            flags |= SHUTDOWN_SAVE;
         } else {
             addReply(c,shared.syntaxerr);
             return;
         }
     }
     /* When SHUTDOWN is called while the server is loading a dataset in
      * memory we need to make sure no attempt is performed to save
      * the dataset on shutdown (otherwise it could overwrite the current DB
      * with half-read data).
      *
      * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */
     if (server.loading || server.sentinel_mode)
-        flags = (flags & ~REDIS_SHUTDOWN_SAVE) | REDIS_SHUTDOWN_NOSAVE;
-    if (prepareForShutdown(flags) == REDIS_OK) exit(0);
+        flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;
+    if (prepareForShutdown(flags) == C_OK) exit(0);
     addReplyError(c,"Errors trying to SHUTDOWN. Check logs.");
 }
 
-void renameGenericCommand(redisClient *c, int nx) {
+void renameGenericCommand(client *c, int nx) {
     robj *o;
     long long expire;
+    int samekey = 0;
 
-    /* To use the same key as src and dst is probably an error */
-    if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) {
-        addReply(c,shared.sameobjecterr);
-        return;
-    }
+    /* When source and dest key is the same, no operation is performed,
+     * if the key exists, however we still return an error on unexisting key. */
+    if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) samekey = 1;
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
         return;
 
+    if (samekey) {
+        addReply(c,nx ? shared.czero : shared.ok);
+        return;
+    }
+
     incrRefCount(o);
     expire = getExpire(c->db,c->argv[1]);
     if (lookupKeyWrite(c->db,c->argv[2]) != NULL) {
         if (nx) {
             decrRefCount(o);
             addReply(c,shared.czero);
@@ -691,29 +720,29 @@
     }
     dbAdd(c->db,c->argv[2],o);
     if (expire != -1) setExpire(c->db,c->argv[2],expire);
     dbDelete(c->db,c->argv[1]);
     signalModifiedKey(c->db,c->argv[1]);
     signalModifiedKey(c->db,c->argv[2]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"rename_from",
+    notifyKeyspaceEvent(NOTIFY_GENERIC,"rename_from",
         c->argv[1],c->db->id);
-    notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"rename_to",
+    notifyKeyspaceEvent(NOTIFY_GENERIC,"rename_to",
         c->argv[2],c->db->id);
     server.dirty++;
     addReply(c,nx ? shared.cone : shared.ok);
 }
 
-void renameCommand(redisClient *c) {
+void renameCommand(client *c) {
     renameGenericCommand(c,0);
 }
 
-void renamenxCommand(redisClient *c) {
+void renamenxCommand(client *c) {
     renameGenericCommand(c,1);
 }
 
-void moveCommand(redisClient *c) {
+void moveCommand(client *c) {
     robj *o;
     redisDb *src, *dst;
     int srcid;
     long long dbid, expire;
 
     if (server.cluster_enabled) {
@@ -722,15 +751,15 @@
     }
 
     /* Obtain source and target DB pointers */
     src = c->db;
     srcid = c->db->id;
 
-    if (getLongLongFromObject(c->argv[2],&dbid) == REDIS_ERR ||
+    if (getLongLongFromObject(c->argv[2],&dbid) == C_ERR ||
         dbid < INT_MIN || dbid > INT_MAX ||
-        selectDb(c,dbid) == REDIS_ERR)
+        selectDb(c,dbid) == C_ERR)
     {
         addReply(c,shared.outofrangeerr);
         return;
     }
     dst = c->db;
     selectDb(c,srcid); /* Back to the source DB */
@@ -769,22 +798,22 @@
  * Expires API
  *----------------------------------------------------------------------------*/
 
 int removeExpire(redisDb *db, robj *key) {
     /* An expire may only be removed if there is a corresponding entry in the
      * main dict. Otherwise, the key will never be freed. */
-    redisAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
+    serverAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
     return dictDelete(db->expires,key->ptr) == DICT_OK;
 }
 
 void setExpire(redisDb *db, robj *key, long long when) {
     dictEntry *kde, *de;
 
     /* Reuse the sds from the main dict in the expire dict */
     kde = dictFind(db->dict,key->ptr);
-    redisAssertWithInfo(NULL,key,kde != NULL);
+    serverAssertWithInfo(NULL,key,kde != NULL);
     de = dictReplaceRaw(db->expires,dictGetKey(kde));
     dictSetSignedIntegerVal(de,when);
 }
 
 /* Return the expire time of the specified key, or -1 if no expire
  * is associated with this key (i.e. the key is non volatile) */
@@ -794,13 +823,13 @@
     /* No expire? return ASAP */
     if (dictSize(db->expires) == 0 ||
        (de = dictFind(db->expires,key->ptr)) == NULL) return -1;
 
     /* The entry was found in the expire dict, this means it should also
      * be present in the main dict (safety check). */
-    redisAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
+    serverAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
     return dictGetSignedIntegerVal(de);
 }
 
 /* Propagate expires into slaves and the AOF file.
  * When a key expires in the master, a DEL operation for this key is sent
  * to all the slaves and the AOF file if enabled.
@@ -814,13 +843,13 @@
 
     argv[0] = shared.del;
     argv[1] = key;
     incrRefCount(argv[0]);
     incrRefCount(argv[1]);
 
-    if (server.aof_state != REDIS_AOF_OFF)
+    if (server.aof_state != AOF_OFF)
         feedAppendOnlyFile(server.delCommand,db->id,argv,2);
     replicationFeedSlaves(server.slaves,db->id,argv,2);
 
     decrRefCount(argv[0]);
     decrRefCount(argv[1]);
 }
@@ -853,13 +882,13 @@
     /* Return when this key has not expired */
     if (now <= when) return 0;
 
     /* Delete the key */
     server.stat_expiredkeys++;
     propagateExpire(db,key);
-    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,
+    notifyKeyspaceEvent(NOTIFY_EXPIRED,
         "expired",key,db->id);
     return dbDelete(db,key);
 }
 
 /*-----------------------------------------------------------------------------
  * Expires Commands
@@ -869,24 +898,24 @@
  * and PEXPIREAT. Because the commad second argument may be relative or absolute
  * the "basetime" argument is used to signal what the base time is (either 0
  * for *AT variants of the command, or the current time for relative expires).
  *
  * unit is either UNIT_SECONDS or UNIT_MILLISECONDS, and is only used for
  * the argv[2] parameter. The basetime is always specified in milliseconds. */
-void expireGenericCommand(redisClient *c, long long basetime, int unit) {
+void expireGenericCommand(client *c, long long basetime, int unit) {
     robj *key = c->argv[1], *param = c->argv[2];
     long long when; /* unix time in milliseconds when the key will expire. */
 
-    if (getLongLongFromObjectOrReply(c, param, &when, NULL) != REDIS_OK)
+    if (getLongLongFromObjectOrReply(c, param, &when, NULL) != C_OK)
         return;
 
     if (unit == UNIT_SECONDS) when *= 1000;
     when += basetime;
 
     /* No key, return zero. */
-    if (lookupKeyRead(c->db,key) == NULL) {
+    if (lookupKeyWrite(c->db,key) == NULL) {
         addReply(c,shared.czero);
         return;
     }
 
     /* EXPIRE with negative TTL, or EXPIREAT with a timestamp into the past
      * should never be executed as a DEL when load the AOF or in the context
@@ -894,50 +923,50 @@
      *
      * Instead we take the other branch of the IF statement setting an expire
      * (possibly in the past) and wait for an explicit DEL from the master. */
     if (when <= mstime() && !server.loading && !server.masterhost) {
         robj *aux;
 
-        redisAssertWithInfo(c,key,dbDelete(c->db,key));
+        serverAssertWithInfo(c,key,dbDelete(c->db,key));
         server.dirty++;
 
         /* Replicate/AOF this as an explicit DEL. */
         aux = createStringObject("DEL",3);
         rewriteClientCommandVector(c,2,aux,key);
         decrRefCount(aux);
         signalModifiedKey(c->db,key);
-        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",key,c->db->id);
+        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
         addReply(c, shared.cone);
         return;
     } else {
         setExpire(c->db,key,when);
         addReply(c,shared.cone);
         signalModifiedKey(c->db,key);
-        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"expire",key,c->db->id);
+        notifyKeyspaceEvent(NOTIFY_GENERIC,"expire",key,c->db->id);
         server.dirty++;
         return;
     }
 }
 
-void expireCommand(redisClient *c) {
+void expireCommand(client *c) {
     expireGenericCommand(c,mstime(),UNIT_SECONDS);
 }
 
-void expireatCommand(redisClient *c) {
+void expireatCommand(client *c) {
     expireGenericCommand(c,0,UNIT_SECONDS);
 }
 
-void pexpireCommand(redisClient *c) {
+void pexpireCommand(client *c) {
     expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);
 }
 
-void pexpireatCommand(redisClient *c) {
+void pexpireatCommand(client *c) {
     expireGenericCommand(c,0,UNIT_MILLISECONDS);
 }
 
-void ttlGenericCommand(redisClient *c, int output_ms) {
+void ttlGenericCommand(client *c, int output_ms) {
     long long expire, ttl = -1;
 
     /* If the key does not exist at all, return -2 */
     if (lookupKeyRead(c->db,c->argv[1]) == NULL) {
         addReplyLongLong(c,-2);
         return;
@@ -953,21 +982,21 @@
         addReplyLongLong(c,-1);
     } else {
         addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
     }
 }
 
-void ttlCommand(redisClient *c) {
+void ttlCommand(client *c) {
     ttlGenericCommand(c, 0);
 }
 
-void pttlCommand(redisClient *c) {
+void pttlCommand(client *c) {
     ttlGenericCommand(c, 1);
 }
 
-void persistCommand(redisClient *c) {
+void persistCommand(client *c) {
     dictEntry *de;
 
     de = dictFind(c->db->dict,c->argv[1]->ptr);
     if (de == NULL) {
         addReply(c,shared.czero);
     } else {
@@ -985,23 +1014,23 @@
  * ---------------------------------------------------------------------------*/
 
 /* The base case is to use the keys position as given in the command table
  * (firstkey, lastkey, step). */
 int *getKeysUsingCommandTable(struct redisCommand *cmd,robj **argv, int argc, int *numkeys) {
     int j, i = 0, last, *keys;
-    REDIS_NOTUSED(argv);
+    UNUSED(argv);
 
     if (cmd->firstkey == 0) {
         *numkeys = 0;
         return NULL;
     }
     last = cmd->lastkey;
     if (last < 0) last = argc+last;
     keys = zmalloc(sizeof(int)*((last - cmd->firstkey)+1));
     for (j = cmd->firstkey; j <= last; j += cmd->keystep) {
-        redisAssert(j < argc);
+        serverAssert(j < argc);
         keys[i++] = j;
     }
     *numkeys = i;
     return keys;
 }
 
@@ -1031,13 +1060,13 @@
 
 /* Helper function to extract keys from following commands:
  * ZUNIONSTORE <destkey> <num-keys> <key> <key> ... <key> <options>
  * ZINTERSTORE <destkey> <num-keys> <key> <key> ... <key> <options> */
 int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
     int i, num, *keys;
-    REDIS_NOTUSED(cmd);
+    UNUSED(cmd);
 
     num = atoi(argv[2]->ptr);
     /* Sanity check. Don't return any key if the command is going to
      * reply with syntax error. */
     if (num > (argc-3)) {
         *numkeys = 0;
@@ -1060,13 +1089,13 @@
 
 /* Helper function to extract keys from the following commands:
  * EVAL <script> <num-keys> <key> <key> ... <key> [more stuff]
  * EVALSHA <script> <num-keys> <key> <key> ... <key> [more stuff] */
 int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
     int i, num, *keys;
-    REDIS_NOTUSED(cmd);
+    UNUSED(cmd);
 
     num = atoi(argv[2]->ptr);
     /* Sanity check. Don't return any key if the command is going to
      * reply with syntax error. */
     if (num > (argc-3)) {
         *numkeys = 0;
@@ -1088,13 +1117,13 @@
  *
  * The first argument of SORT is always a key, however a list of options
  * follow in SQL-alike style. Here we parse just the minimum in order to
  * correctly identify keys in the "STORE" option. */
 int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
     int i, j, num, *keys, found_store = 0;
-    REDIS_NOTUSED(cmd);
+    UNUSED(cmd);
 
     num = 0;
     keys = zmalloc(sizeof(int)*2); /* Alloc 2 places for the worst case. */
 
     keys[num++] = 1; /* <sort-key> is always present. */
 
@@ -1130,13 +1159,13 @@
     *numkeys = num + found_store;
     return keys;
 }
 
 int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
     int i, num, first, *keys;
-    REDIS_NOTUSED(cmd);
+    UNUSED(cmd);
 
     /* Assume the obvious form. */
     first = 3;
     num = 1;
 
     /* But check for the extended one with the KEYS option. */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/db.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/db.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/db.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/db.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/debug.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/debug.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/debug.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/debug.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,13 +24,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include "sha1.h"   /* SHA1 is used for DEBUG DIGEST */
 #include "crc64.h"
 
 #include <arpa/inet.h>
 #include <signal.h>
 
@@ -147,49 +147,49 @@
 
             aux = htonl(o->type);
             mixDigest(digest,&aux,sizeof(aux));
             expiretime = getExpire(db,keyobj);
 
             /* Save the key and associated value */
-            if (o->type == REDIS_STRING) {
+            if (o->type == OBJ_STRING) {
                 mixObjectDigest(digest,o);
-            } else if (o->type == REDIS_LIST) {
-                listTypeIterator *li = listTypeInitIterator(o,0,REDIS_TAIL);
+            } else if (o->type == OBJ_LIST) {
+                listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);
                 listTypeEntry entry;
                 while(listTypeNext(li,&entry)) {
                     robj *eleobj = listTypeGet(&entry);
                     mixObjectDigest(digest,eleobj);
                     decrRefCount(eleobj);
                 }
                 listTypeReleaseIterator(li);
-            } else if (o->type == REDIS_SET) {
+            } else if (o->type == OBJ_SET) {
                 setTypeIterator *si = setTypeInitIterator(o);
                 robj *ele;
                 while((ele = setTypeNextObject(si)) != NULL) {
                     xorObjectDigest(digest,ele);
                     decrRefCount(ele);
                 }
                 setTypeReleaseIterator(si);
-            } else if (o->type == REDIS_ZSET) {
+            } else if (o->type == OBJ_ZSET) {
                 unsigned char eledigest[20];
 
-                if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+                if (o->encoding == OBJ_ENCODING_ZIPLIST) {
                     unsigned char *zl = o->ptr;
                     unsigned char *eptr, *sptr;
                     unsigned char *vstr;
                     unsigned int vlen;
                     long long vll;
                     double score;
 
                     eptr = ziplistIndex(zl,0);
-                    redisAssert(eptr != NULL);
+                    serverAssert(eptr != NULL);
                     sptr = ziplistNext(zl,eptr);
-                    redisAssert(sptr != NULL);
+                    serverAssert(sptr != NULL);
 
                     while (eptr != NULL) {
-                        redisAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
+                        serverAssert(ziplistGet(eptr,&vstr,&vlen,&vll));
                         score = zzlGetScore(sptr);
 
                         memset(eledigest,0,20);
                         if (vstr != NULL) {
                             mixDigest(eledigest,vstr,vlen);
                         } else {
@@ -199,13 +199,13 @@
 
                         snprintf(buf,sizeof(buf),"%.17g",score);
                         mixDigest(eledigest,buf,strlen(buf));
                         xorDigest(digest,eledigest,20);
                         zzlNext(zl,&eptr,&sptr);
                     }
-                } else if (o->encoding == REDIS_ENCODING_SKIPLIST) {
+                } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
                     zset *zs = o->ptr;
                     dictIterator *di = dictGetIterator(zs->dict);
                     dictEntry *de;
 
                     while((de = dictNext(di)) != NULL) {
                         robj *eleobj = dictGetKey(de);
@@ -216,75 +216,145 @@
                         mixObjectDigest(eledigest,eleobj);
                         mixDigest(eledigest,buf,strlen(buf));
                         xorDigest(digest,eledigest,20);
                     }
                     dictReleaseIterator(di);
                 } else {
-                    redisPanic("Unknown sorted set encoding");
+                    serverPanic("Unknown sorted set encoding");
                 }
-            } else if (o->type == REDIS_HASH) {
+            } else if (o->type == OBJ_HASH) {
                 hashTypeIterator *hi;
                 robj *obj;
 
                 hi = hashTypeInitIterator(o);
-                while (hashTypeNext(hi) != REDIS_ERR) {
+                while (hashTypeNext(hi) != C_ERR) {
                     unsigned char eledigest[20];
 
                     memset(eledigest,0,20);
-                    obj = hashTypeCurrentObject(hi,REDIS_HASH_KEY);
+                    obj = hashTypeCurrentObject(hi,OBJ_HASH_KEY);
                     mixObjectDigest(eledigest,obj);
                     decrRefCount(obj);
-                    obj = hashTypeCurrentObject(hi,REDIS_HASH_VALUE);
+                    obj = hashTypeCurrentObject(hi,OBJ_HASH_VALUE);
                     mixObjectDigest(eledigest,obj);
                     decrRefCount(obj);
                     xorDigest(digest,eledigest,20);
                 }
                 hashTypeReleaseIterator(hi);
             } else {
-                redisPanic("Unknown object type");
+                serverPanic("Unknown object type");
             }
             /* If the key has an expire, add it to the mix */
             if (expiretime != -1) xorDigest(digest,"!!expire!!",10);
             /* We can finally xor the key-val digest to the final digest */
             xorDigest(final,digest,20);
             decrRefCount(keyobj);
         }
         dictReleaseIterator(di);
     }
 }
 
-void debugCommand(redisClient *c) {
-    if (!strcasecmp(c->argv[1]->ptr,"segfault")) {
+#if defined(USE_JEMALLOC)
+void inputCatSds(void *result, const char *str) {
+    /* result is actually a (sds *), so re-cast it here */
+    sds *info = (sds *)result;
+    *info = sdscat(*info, str);
+}
+#endif
+
+void debugCommand(client *c) {
+    if (c->argc == 1) {
+        addReplyError(c,"You must specify a subcommand for DEBUG. Try DEBUG HELP for info.");
+        return;
+    }
+
+    if (!strcasecmp(c->argv[1]->ptr,"help")) {
+        void *blenp = addDeferredMultiBulkLength(c);
+        int blen = 0;
+        blen++; addReplyStatus(c,
+        "DEBUG <subcommand> arg arg ... arg. Subcommands:");
+        blen++; addReplyStatus(c,
+        "segfault -- Crash the server with sigsegv.");
+        blen++; addReplyStatus(c,
+        "restart  -- Graceful restart: save config, db, restart.");
+        blen++; addReplyStatus(c,
+        "crash-and-recovery <milliseconds> -- Hard crash and restart after <milliseconds> delay.");
+        blen++; addReplyStatus(c,
+        "assert   -- Crash by assertion failed.");
+        blen++; addReplyStatus(c,
+        "reload   -- Save the RDB on disk and reload it back in memory.");
+        blen++; addReplyStatus(c,
+        "loadaof  -- Flush the AOF buffers on disk and reload the AOF in memory.");
+        blen++; addReplyStatus(c,
+        "object <key> -- Show low level info about key and associated value.");
+        blen++; addReplyStatus(c,
+        "sdslen <key> -- Show low level SDS string info representing key and value.");
+        blen++; addReplyStatus(c,
+        "populate <count> [prefix] -- Create <count> string keys named key:<num>. If a prefix is specified is used instead of the 'key' prefix.");
+        blen++; addReplyStatus(c,
+        "digest   -- Outputs an hex signature representing the current DB content.");
+        blen++; addReplyStatus(c,
+        "sleep <seconds> -- Stop the server for <seconds>. Decimals allowed.");
+        blen++; addReplyStatus(c,
+        "set-active-expire (0|1) -- Setting it to 0 disables expiring keys in background when they are not accessed (otherwise the Redis behavior). Setting it to 1 reenables back the default.");
+        blen++; addReplyStatus(c,
+        "lua-always-replicate-commands (0|1) -- Setting it to 1 makes Lua replication defaulting to replicating single commands, without the script having to enable effects replication.");
+        blen++; addReplyStatus(c,
+        "error <string> -- Return a Redis protocol error with <string> as message. Useful for clients unit tests to simulate Redis errors.");
+        blen++; addReplyStatus(c,
+        "structsize -- Return the size of different Redis core C structures.");
+        blen++; addReplyStatus(c,
+        "htstats <dbid> -- Return hash table statistics of the specified Redis database.");
+        blen++; addReplyStatus(c,
+        "jemalloc info  -- Show internal jemalloc statistics.");
+        blen++; addReplyStatus(c,
+        "jemalloc purge -- Force jemalloc to release unused memory.");
+        setDeferredMultiBulkLength(c,blenp,blen);
+    } else if (!strcasecmp(c->argv[1]->ptr,"segfault")) {
         *((char*)-1) = 'x';
+    } else if (!strcasecmp(c->argv[1]->ptr,"restart") ||
+               !strcasecmp(c->argv[1]->ptr,"crash-and-recover"))
+    {
+        long long delay = 0;
+        if (c->argc >= 3) {
+            if (getLongLongFromObjectOrReply(c, c->argv[2], &delay, NULL)
+                != C_OK) return;
+            if (delay < 0) delay = 0;
+        }
+        int flags = !strcasecmp(c->argv[1]->ptr,"restart") ?
+            (RESTART_SERVER_GRACEFULLY|RESTART_SERVER_CONFIG_REWRITE) :
+             RESTART_SERVER_NONE;
+        restartServer(flags,delay);
+        addReplyError(c,"failed to restart the server. Check server logs.");
     } else if (!strcasecmp(c->argv[1]->ptr,"oom")) {
         void *ptr = zmalloc(ULONG_MAX); /* Should trigger an out of memory. */
         zfree(ptr);
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"assert")) {
         if (c->argc >= 3) c->argv[2] = tryObjectEncoding(c->argv[2]);
-        redisAssertWithInfo(c,c->argv[0],1 == 2);
+        serverAssertWithInfo(c,c->argv[0],1 == 2);
     } else if (!strcasecmp(c->argv[1]->ptr,"reload")) {
-        if (rdbSave(server.rdb_filename) != REDIS_OK) {
+        if (rdbSave(server.rdb_filename) != C_OK) {
             addReply(c,shared.err);
             return;
         }
         emptyDb(NULL);
-        if (rdbLoad(server.rdb_filename) != REDIS_OK) {
+        if (rdbLoad(server.rdb_filename) != C_OK) {
             addReplyError(c,"Error trying to load the RDB dump");
             return;
         }
-        redisLog(REDIS_WARNING,"DB reloaded by DEBUG RELOAD");
+        serverLog(LL_WARNING,"DB reloaded by DEBUG RELOAD");
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"loadaof")) {
+        if (server.aof_state == AOF_ON) flushAppendOnlyFile(1);
         emptyDb(NULL);
-        if (loadAppendOnlyFile(server.aof_filename) != REDIS_OK) {
+        if (loadAppendOnlyFile(server.aof_filename) != C_OK) {
             addReply(c,shared.err);
             return;
         }
         server.dirty = 0; /* Prevent AOF / replication */
-        redisLog(REDIS_WARNING,"Append Only File loaded by DEBUG LOADAOF");
+        serverLog(LL_WARNING,"Append Only File loaded by DEBUG LOADAOF");
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"object") && c->argc == 3) {
         dictEntry *de;
         robj *val;
         char *strenc;
 
@@ -292,32 +362,65 @@
             addReply(c,shared.nokeyerr);
             return;
         }
         val = dictGetVal(de);
         strenc = strEncoding(val->encoding);
 
+        char extra[128] = {0};
+        if (val->encoding == OBJ_ENCODING_QUICKLIST) {
+            char *nextra = extra;
+            int remaining = sizeof(extra);
+            quicklist *ql = val->ptr;
+            /* Add number of quicklist nodes */
+            int used = snprintf(nextra, remaining, " ql_nodes:%u", ql->len);
+            nextra += used;
+            remaining -= used;
+            /* Add average quicklist fill factor */
+            double avg = (double)ql->count/ql->len;
+            used = snprintf(nextra, remaining, " ql_avg_node:%.2f", avg);
+            nextra += used;
+            remaining -= used;
+            /* Add quicklist fill level / max ziplist size */
+            used = snprintf(nextra, remaining, " ql_ziplist_max:%d", ql->fill);
+            nextra += used;
+            remaining -= used;
+            /* Add isCompressed? */
+            int compressed = ql->compress != 0;
+            used = snprintf(nextra, remaining, " ql_compressed:%d", compressed);
+            nextra += used;
+            remaining -= used;
+            /* Add total uncompressed size */
+            unsigned long sz = 0;
+            for (quicklistNode *node = ql->head; node; node = node->next) {
+                sz += node->sz;
+            }
+            used = snprintf(nextra, remaining, " ql_uncompressed_size:%lu", sz);
+            nextra += used;
+            remaining -= used;
+        }
+
         addReplyStatusFormat(c,
             "Value at:%p refcount:%d "
-            "encoding:%s serializedlength:%lld "
-            "lru:%d lru_seconds_idle:%llu",
+            "encoding:%s serializedlength:%zu "
+            "lru:%d lru_seconds_idle:%llu%s",
             (void*)val, val->refcount,
-            strenc, (long long) rdbSavedObjectLen(val),
-            val->lru, estimateObjectIdleTime(val)/1000);
+            strenc, rdbSavedObjectLen(val),
+            val->lru, estimateObjectIdleTime(val)/1000, extra);
     } else if (!strcasecmp(c->argv[1]->ptr,"sdslen") && c->argc == 3) {
         dictEntry *de;
         robj *val;
         sds key;
 
         if ((de = dictFind(c->db->dict,c->argv[2]->ptr)) == NULL) {
             addReply(c,shared.nokeyerr);
             return;
         }
         val = dictGetVal(de);
         key = dictGetKey(de);
 
-        if (val->type != REDIS_STRING || !sdsEncodedObject(val)) {
+        if (val->type != OBJ_STRING || !sdsEncodedObject(val)) {
             addReplyError(c,"Not an sds encoded string.");
         } else {
             addReplyStatusFormat(c,
                 "key_sds_len:%lld, key_sds_avail:%lld, "
                 "val_sds_len:%lld, val_sds_avail:%lld",
                 (long long) sdslen(key),
@@ -328,26 +431,27 @@
     } else if (!strcasecmp(c->argv[1]->ptr,"populate") &&
                (c->argc == 3 || c->argc == 4)) {
         long keys, j;
         robj *key, *val;
         char buf[128];
 
-        if (getLongFromObjectOrReply(c, c->argv[2], &keys, NULL) != REDIS_OK)
+        if (getLongFromObjectOrReply(c, c->argv[2], &keys, NULL) != C_OK)
             return;
         dictExpand(c->db->dict,keys);
         for (j = 0; j < keys; j++) {
             snprintf(buf,sizeof(buf),"%s:%lu",
                 (c->argc == 3) ? "key" : (char*)c->argv[3]->ptr, j);
             key = createStringObject(buf,strlen(buf));
-            if (lookupKeyRead(c->db,key) != NULL) {
+            if (lookupKeyWrite(c->db,key) != NULL) {
                 decrRefCount(key);
                 continue;
             }
             snprintf(buf,sizeof(buf),"value:%lu",j);
             val = createStringObject(buf,strlen(buf));
             dbAdd(c->db,key,val);
+            signalModifiedKey(c->db,key);
             decrRefCount(key);
         }
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"digest") && c->argc == 2) {
         unsigned char digest[20];
         sds d = sdsempty();
@@ -369,116 +473,177 @@
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"set-active-expire") &&
                c->argc == 3)
     {
         server.active_expire_enabled = atoi(c->argv[2]->ptr);
         addReply(c,shared.ok);
+    } else if (!strcasecmp(c->argv[1]->ptr,"lua-always-replicate-commands") &&
+               c->argc == 3)
+    {
+        server.lua_always_replicate_commands = atoi(c->argv[2]->ptr);
+        addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"error") && c->argc == 3) {
         sds errstr = sdsnewlen("-",1);
 
         errstr = sdscatsds(errstr,c->argv[2]->ptr);
         errstr = sdsmapchars(errstr,"\n\r","  ",2); /* no newlines in errors. */
         errstr = sdscatlen(errstr,"\r\n",2);
         addReplySds(c,errstr);
+    } else if (!strcasecmp(c->argv[1]->ptr,"structsize") && c->argc == 2) {
+        sds sizes = sdsempty();
+        sizes = sdscatprintf(sizes,"bits:%d ",(sizeof(void*) == 8)?64:32);
+        sizes = sdscatprintf(sizes,"robj:%d ",(int)sizeof(robj));
+        sizes = sdscatprintf(sizes,"dictentry:%d ",(int)sizeof(dictEntry));
+        sizes = sdscatprintf(sizes,"sdshdr5:%d ",(int)sizeof(struct sdshdr5));
+        sizes = sdscatprintf(sizes,"sdshdr8:%d ",(int)sizeof(struct sdshdr8));
+        sizes = sdscatprintf(sizes,"sdshdr16:%d ",(int)sizeof(struct sdshdr16));
+        sizes = sdscatprintf(sizes,"sdshdr32:%d ",(int)sizeof(struct sdshdr32));
+        sizes = sdscatprintf(sizes,"sdshdr64:%d ",(int)sizeof(struct sdshdr64));
+        addReplyBulkSds(c,sizes);
+    } else if (!strcasecmp(c->argv[1]->ptr,"htstats") && c->argc == 3) {
+        long dbid;
+        sds stats = sdsempty();
+        char buf[4096];
+
+        if (getLongFromObjectOrReply(c, c->argv[2], &dbid, NULL) != C_OK)
+            return;
+        if (dbid < 0 || dbid >= server.dbnum) {
+            addReplyError(c,"Out of range database");
+            return;
+        }
+
+        stats = sdscatprintf(stats,"[Dictionary HT]\n");
+        dictGetStats(buf,sizeof(buf),server.db[dbid].dict);
+        stats = sdscat(stats,buf);
+
+        stats = sdscatprintf(stats,"[Expires HT]\n");
+        dictGetStats(buf,sizeof(buf),server.db[dbid].expires);
+        stats = sdscat(stats,buf);
+
+        addReplyBulkSds(c,stats);
+    } else if (!strcasecmp(c->argv[1]->ptr,"jemalloc") && c->argc == 3) {
+#if defined(USE_JEMALLOC)
+        if (!strcasecmp(c->argv[2]->ptr, "info")) {
+            sds info = sdsempty();
+            je_malloc_stats_print(inputCatSds, &info, NULL);
+            addReplyBulkSds(c, info);
+        } else if (!strcasecmp(c->argv[2]->ptr, "purge")) {
+            char tmp[32];
+            unsigned narenas = 0;
+            size_t sz = sizeof(unsigned);
+            if (!je_mallctl("arenas.narenas", &narenas, &sz, NULL, 0)) {
+                sprintf(tmp, "arena.%d.purge", narenas);
+                if (!je_mallctl(tmp, NULL, 0, NULL, 0)) {
+                    addReply(c, shared.ok);
+                    return;
+                }
+            }
+            addReplyError(c, "Error purging dirty pages");
+        } else {
+            addReplyErrorFormat(c, "Valid jemalloc debug fields: info, purge");
+        }
+#else
+        addReplyErrorFormat(c, "jemalloc support not available");
+#endif
     } else {
         addReplyErrorFormat(c, "Unknown DEBUG subcommand or wrong number of arguments for '%s'",
             (char*)c->argv[1]->ptr);
     }
 }
 
 /* =========================== Crash handling  ============================== */
 
-void _redisAssert(char *estr, char *file, int line) {
+void _serverAssert(char *estr, char *file, int line) {
     bugReportStart();
-    redisLog(REDIS_WARNING,"=== ASSERTION FAILED ===");
-    redisLog(REDIS_WARNING,"==> %s:%d '%s' is not true",file,line,estr);
+    serverLog(LL_WARNING,"=== ASSERTION FAILED ===");
+    serverLog(LL_WARNING,"==> %s:%d '%s' is not true",file,line,estr);
 #ifdef HAVE_BACKTRACE
     server.assert_failed = estr;
     server.assert_file = file;
     server.assert_line = line;
-    redisLog(REDIS_WARNING,"(forcing SIGSEGV to print the bug report.)");
+    serverLog(LL_WARNING,"(forcing SIGSEGV to print the bug report.)");
 #endif
     *((char*)-1) = 'x';
 }
 
-void _redisAssertPrintClientInfo(redisClient *c) {
+void _serverAssertPrintClientInfo(client *c) {
     int j;
 
     bugReportStart();
-    redisLog(REDIS_WARNING,"=== ASSERTION FAILED CLIENT CONTEXT ===");
-    redisLog(REDIS_WARNING,"client->flags = %d", c->flags);
-    redisLog(REDIS_WARNING,"client->fd = %d", c->fd);
-    redisLog(REDIS_WARNING,"client->argc = %d", c->argc);
+    serverLog(LL_WARNING,"=== ASSERTION FAILED CLIENT CONTEXT ===");
+    serverLog(LL_WARNING,"client->flags = %d", c->flags);
+    serverLog(LL_WARNING,"client->fd = %d", c->fd);
+    serverLog(LL_WARNING,"client->argc = %d", c->argc);
     for (j=0; j < c->argc; j++) {
         char buf[128];
         char *arg;
 
-        if (c->argv[j]->type == REDIS_STRING && sdsEncodedObject(c->argv[j])) {
+        if (c->argv[j]->type == OBJ_STRING && sdsEncodedObject(c->argv[j])) {
             arg = (char*) c->argv[j]->ptr;
         } else {
             snprintf(buf,sizeof(buf),"Object type: %u, encoding: %u",
                 c->argv[j]->type, c->argv[j]->encoding);
             arg = buf;
         }
-        redisLog(REDIS_WARNING,"client->argv[%d] = \"%s\" (refcount: %d)",
+        serverLog(LL_WARNING,"client->argv[%d] = \"%s\" (refcount: %d)",
             j, arg, c->argv[j]->refcount);
     }
 }
 
-void redisLogObjectDebugInfo(robj *o) {
-    redisLog(REDIS_WARNING,"Object type: %d", o->type);
-    redisLog(REDIS_WARNING,"Object encoding: %d", o->encoding);
-    redisLog(REDIS_WARNING,"Object refcount: %d", o->refcount);
-    if (o->type == REDIS_STRING && sdsEncodedObject(o)) {
-        redisLog(REDIS_WARNING,"Object raw string len: %zu", sdslen(o->ptr));
+void serverLogObjectDebugInfo(robj *o) {
+    serverLog(LL_WARNING,"Object type: %d", o->type);
+    serverLog(LL_WARNING,"Object encoding: %d", o->encoding);
+    serverLog(LL_WARNING,"Object refcount: %d", o->refcount);
+    if (o->type == OBJ_STRING && sdsEncodedObject(o)) {
+        serverLog(LL_WARNING,"Object raw string len: %zu", sdslen(o->ptr));
         if (sdslen(o->ptr) < 4096) {
             sds repr = sdscatrepr(sdsempty(),o->ptr,sdslen(o->ptr));
-            redisLog(REDIS_WARNING,"Object raw string content: %s", repr);
+            serverLog(LL_WARNING,"Object raw string content: %s", repr);
             sdsfree(repr);
         }
-    } else if (o->type == REDIS_LIST) {
-        redisLog(REDIS_WARNING,"List length: %d", (int) listTypeLength(o));
-    } else if (o->type == REDIS_SET) {
-        redisLog(REDIS_WARNING,"Set size: %d", (int) setTypeSize(o));
-    } else if (o->type == REDIS_HASH) {
-        redisLog(REDIS_WARNING,"Hash size: %d", (int) hashTypeLength(o));
-    } else if (o->type == REDIS_ZSET) {
-        redisLog(REDIS_WARNING,"Sorted set size: %d", (int) zsetLength(o));
-        if (o->encoding == REDIS_ENCODING_SKIPLIST)
-            redisLog(REDIS_WARNING,"Skiplist level: %d", (int) ((zset*)o->ptr)->zsl->level);
+    } else if (o->type == OBJ_LIST) {
+        serverLog(LL_WARNING,"List length: %d", (int) listTypeLength(o));
+    } else if (o->type == OBJ_SET) {
+        serverLog(LL_WARNING,"Set size: %d", (int) setTypeSize(o));
+    } else if (o->type == OBJ_HASH) {
+        serverLog(LL_WARNING,"Hash size: %d", (int) hashTypeLength(o));
+    } else if (o->type == OBJ_ZSET) {
+        serverLog(LL_WARNING,"Sorted set size: %d", (int) zsetLength(o));
+        if (o->encoding == OBJ_ENCODING_SKIPLIST)
+            serverLog(LL_WARNING,"Skiplist level: %d", (int) ((zset*)o->ptr)->zsl->level);
     }
 }
 
-void _redisAssertPrintObject(robj *o) {
+void _serverAssertPrintObject(robj *o) {
     bugReportStart();
-    redisLog(REDIS_WARNING,"=== ASSERTION FAILED OBJECT CONTEXT ===");
-    redisLogObjectDebugInfo(o);
+    serverLog(LL_WARNING,"=== ASSERTION FAILED OBJECT CONTEXT ===");
+    serverLogObjectDebugInfo(o);
 }
 
-void _redisAssertWithInfo(redisClient *c, robj *o, char *estr, char *file, int line) {
-    if (c) _redisAssertPrintClientInfo(c);
-    if (o) _redisAssertPrintObject(o);
-    _redisAssert(estr,file,line);
+void _serverAssertWithInfo(client *c, robj *o, char *estr, char *file, int line) {
+    if (c) _serverAssertPrintClientInfo(c);
+    if (o) _serverAssertPrintObject(o);
+    _serverAssert(estr,file,line);
 }
 
-void _redisPanic(char *msg, char *file, int line) {
+void _serverPanic(char *msg, char *file, int line) {
     bugReportStart();
-    redisLog(REDIS_WARNING,"------------------------------------------------");
-    redisLog(REDIS_WARNING,"!!! Software Failure. Press left mouse button to continue");
-    redisLog(REDIS_WARNING,"Guru Meditation: %s #%s:%d",msg,file,line);
+    serverLog(LL_WARNING,"------------------------------------------------");
+    serverLog(LL_WARNING,"!!! Software Failure. Press left mouse button to continue");
+    serverLog(LL_WARNING,"Guru Meditation: %s #%s:%d",msg,file,line);
 #ifdef HAVE_BACKTRACE
-    redisLog(REDIS_WARNING,"(forcing SIGSEGV in order to print the stack trace)");
+    serverLog(LL_WARNING,"(forcing SIGSEGV in order to print the stack trace)");
 #endif
-    redisLog(REDIS_WARNING,"------------------------------------------------");
+    serverLog(LL_WARNING,"------------------------------------------------");
     *((char*)-1) = 'x';
 }
 
 void bugReportStart(void) {
     if (server.bug_report_start == 0) {
-        redisLog(REDIS_WARNING,
-            "\n\n=== REDIS BUG REPORT START: Cut & paste starting from here ===");
+        serverLogRaw(LL_WARNING|LL_RAW,
+        "\n\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\n");
         server.bug_report_start = 1;
     }
 }
 
 #ifdef HAVE_BACKTRACE
 static void *getMcontextEip(ucontext_t *uc) {
@@ -516,26 +681,26 @@
     int i;
     for (i = 15; i >= 0; i--) {
         unsigned long addr = (unsigned long) sp+i;
         unsigned long val = (unsigned long) sp[i];
 
         if (sizeof(long) == 4)
-            redisLog(REDIS_WARNING, "(%08lx) -> %08lx", addr, val);
+            serverLog(LL_WARNING, "(%08lx) -> %08lx", addr, val);
         else
-            redisLog(REDIS_WARNING, "(%016lx) -> %016lx", addr, val);
+            serverLog(LL_WARNING, "(%016lx) -> %016lx", addr, val);
     }
 }
 
 void logRegisters(ucontext_t *uc) {
-    redisLog(REDIS_WARNING, "--- REGISTERS");
+    serverLog(LL_WARNING|LL_RAW, "\n------ REGISTERS ------\n");
 
 /* OSX */
 #if defined(__APPLE__) && defined(MAC_OS_X_VERSION_10_6)
   /* OSX AMD64 */
     #if defined(_STRUCT_X86_THREAD_STATE64) && !defined(__i386__)
-    redisLog(REDIS_WARNING,
+    serverLog(LL_WARNING,
     "\n"
     "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
     "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
     "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
     "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
     "RIP:%016lx EFL:%016lx\nCS :%016lx FS:%016lx  GS:%016lx",
@@ -561,13 +726,13 @@
         (unsigned long) uc->uc_mcontext->__ss.__fs,
         (unsigned long) uc->uc_mcontext->__ss.__gs
     );
     logStackContent((void**)uc->uc_mcontext->__ss.__rsp);
     #else
     /* OSX x86 */
-    redisLog(REDIS_WARNING,
+    serverLog(LL_WARNING,
     "\n"
     "EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n"
     "EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n"
     "SS:%08lx  EFL:%08lx EIP:%08lx CS :%08lx\n"
     "DS:%08lx  ES:%08lx  FS :%08lx GS :%08lx",
         (unsigned long) uc->uc_mcontext->__ss.__eax,
@@ -590,13 +755,13 @@
     logStackContent((void**)uc->uc_mcontext->__ss.__esp);
     #endif
 /* Linux */
 #elif defined(__linux__)
     /* Linux x86 */
     #if defined(__i386__)
-    redisLog(REDIS_WARNING,
+    serverLog(LL_WARNING,
     "\n"
     "EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n"
     "EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n"
     "SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\n"
     "DS :%08lx ES :%08lx FS :%08lx GS:%08lx",
         (unsigned long) uc->uc_mcontext.gregs[11],
@@ -616,13 +781,13 @@
         (unsigned long) uc->uc_mcontext.gregs[1],
         (unsigned long) uc->uc_mcontext.gregs[0]
     );
     logStackContent((void**)uc->uc_mcontext.gregs[7]);
     #elif defined(__X86_64__) || defined(__x86_64__)
     /* Linux AMD64 */
-    redisLog(REDIS_WARNING,
+    serverLog(LL_WARNING,
     "\n"
     "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
     "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
     "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
     "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
     "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
@@ -646,96 +811,122 @@
         (unsigned long) uc->uc_mcontext.gregs[17],
         (unsigned long) uc->uc_mcontext.gregs[18]
     );
     logStackContent((void**)uc->uc_mcontext.gregs[15]);
     #endif
 #else
-    redisLog(REDIS_WARNING,
+    serverLog(LL_WARNING,
         "  Dumping of registers not supported for this OS/arch");
 #endif
 }
 
+/* Return a file descriptor to write directly to the Redis log with the
+ * write(2) syscall, that can be used in critical sections of the code
+ * where the rest of Redis can't be trusted (for example during the memory
+ * test) or when an API call requires a raw fd.
+ *
+ * Close it with closeDirectLogFiledes(). */
+int openDirectLogFiledes(void) {
+    int log_to_stdout = server.logfile[0] == '\0';
+    int fd = log_to_stdout ?
+        STDOUT_FILENO :
+        open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
+    return fd;
+}
+
+/* Used to close what closeDirectLogFiledes() returns. */
+void closeDirectLogFiledes(int fd) {
+    int log_to_stdout = server.logfile[0] == '\0';
+    if (!log_to_stdout) close(fd);
+}
+
 /* Logs the stack trace using the backtrace() call. This function is designed
  * to be called from signal handlers safely. */
 void logStackTrace(ucontext_t *uc) {
-    void *trace[100];
-    int trace_size = 0, fd;
-    int log_to_stdout = server.logfile[0] == '\0';
+    void *trace[101];
+    int trace_size = 0, fd = openDirectLogFiledes();
 
-    /* Open the log file in append mode. */
-    fd = log_to_stdout ?
-        STDOUT_FILENO :
-        open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
-    if (fd == -1) return;
+    if (fd == -1) return; /* If we can't log there is anything to do. */
 
     /* Generate the stack trace */
-    trace_size = backtrace(trace, 100);
+    trace_size = backtrace(trace+1, 100);
 
-    /* overwrite sigaction with caller's address */
-    if (getMcontextEip(uc) != NULL)
-        trace[1] = getMcontextEip(uc);
+    if (getMcontextEip(uc) != NULL) {
+        char *msg1 = "EIP:\n";
+        char *msg2 = "\nBacktrace:\n";
+        if (write(fd,msg1,strlen(msg1)) == -1) {/* Avoid warning. */};
+        trace[0] = getMcontextEip(uc);
+        backtrace_symbols_fd(trace, 1, fd);
+        if (write(fd,msg2,strlen(msg2)) == -1) {/* Avoid warning. */};
+    }
 
     /* Write symbols to log file */
-    backtrace_symbols_fd(trace, trace_size, fd);
+    backtrace_symbols_fd(trace+1, trace_size, fd);
 
     /* Cleanup */
-    if (!log_to_stdout) close(fd);
+    closeDirectLogFiledes(fd);
 }
 
 /* Log information about the "current" client, that is, the client that is
  * currently being served by Redis. May be NULL if Redis is not serving a
  * client right now. */
 void logCurrentClient(void) {
     if (server.current_client == NULL) return;
 
-    redisClient *cc = server.current_client;
+    client *cc = server.current_client;
     sds client;
     int j;
 
-    redisLog(REDIS_WARNING, "--- CURRENT CLIENT INFO");
+    serverLogRaw(LL_WARNING|LL_RAW, "\n------ CURRENT CLIENT INFO ------\n");
     client = catClientInfoString(sdsempty(),cc);
-    redisLog(REDIS_WARNING,"client: %s", client);
+    serverLog(LL_WARNING|LL_RAW,"%s\n", client);
     sdsfree(client);
     for (j = 0; j < cc->argc; j++) {
         robj *decoded;
 
         decoded = getDecodedObject(cc->argv[j]);
-        redisLog(REDIS_WARNING,"argv[%d]: '%s'", j, (char*)decoded->ptr);
+        serverLog(LL_WARNING|LL_RAW,"argv[%d]: '%s'\n", j,
+            (char*)decoded->ptr);
         decrRefCount(decoded);
     }
     /* Check if the first argument, usually a key, is found inside the
      * selected DB, and if so print info about the associated object. */
     if (cc->argc >= 1) {
         robj *val, *key;
         dictEntry *de;
 
         key = getDecodedObject(cc->argv[1]);
         de = dictFind(cc->db->dict, key->ptr);
         if (de) {
             val = dictGetVal(de);
-            redisLog(REDIS_WARNING,"key '%s' found in DB containing the following object:", (char*)key->ptr);
-            redisLogObjectDebugInfo(val);
+            serverLog(LL_WARNING,"key '%s' found in DB containing the following object:", (char*)key->ptr);
+            serverLogObjectDebugInfo(val);
         }
         decrRefCount(key);
     }
 }
 
 #if defined(HAVE_PROC_MAPS)
-void memtest_non_destructive_invert(void *addr, size_t size);
-void memtest_non_destructive_swap(void *addr, size_t size);
+
 #define MEMTEST_MAX_REGIONS 128
 
+/* A non destructive memory test executed during segfauls. */
 int memtest_test_linux_anonymous_maps(void) {
-    FILE *fp = fopen("/proc/self/maps","r");
+    FILE *fp;
     char line[1024];
+    char logbuf[1024];
     size_t start_addr, end_addr, size;
     size_t start_vect[MEMTEST_MAX_REGIONS];
     size_t size_vect[MEMTEST_MAX_REGIONS];
     int regions = 0, j;
-    uint64_t crc1 = 0, crc2 = 0, crc3 = 0;
 
+    int fd = openDirectLogFiledes();
+    if (!fd) return 0;
+
+    fp = fopen("/proc/self/maps","r");
+    if (!fp) return 0;
     while(fgets(line,sizeof(line),fp) != NULL) {
         char *start, *end, *p = line;
 
         start = p;
         p = strchr(p,'-');
         if (!p) continue;
@@ -753,118 +944,102 @@
         start_addr = strtoul(start,NULL,16);
         end_addr = strtoul(end,NULL,16);
         size = end_addr-start_addr;
 
         start_vect[regions] = start_addr;
         size_vect[regions] = size;
-        printf("Testing %lx %lu\n", (unsigned long) start_vect[regions],
-                                    (unsigned long) size_vect[regions]);
+        snprintf(logbuf,sizeof(logbuf),
+            "*** Preparing to test memory region %lx (%lu bytes)\n",
+                (unsigned long) start_vect[regions],
+                (unsigned long) size_vect[regions]);
+        if (write(fd,logbuf,strlen(logbuf)) == -1) { /* Nothing to do. */ }
         regions++;
     }
 
-    /* Test all the regions as an unique sequential region.
-     * 1) Take the CRC64 of the memory region. */
+    int errors = 0;
     for (j = 0; j < regions; j++) {
-        crc1 = crc64(crc1,(void*)start_vect[j],size_vect[j]);
+        if (write(fd,".",1) == -1) { /* Nothing to do. */ }
+        errors += memtest_preserving_test((void*)start_vect[j],size_vect[j],1);
+        if (write(fd, errors ? "E" : "O",1) == -1) { /* Nothing to do. */ }
     }
-
-    /* 2) Invert bits, swap adjacent words, swap again, invert bits.
-     * This is the error amplification step. */
-    for (j = 0; j < regions; j++)
-        memtest_non_destructive_invert((void*)start_vect[j],size_vect[j]);
-    for (j = 0; j < regions; j++)
-        memtest_non_destructive_swap((void*)start_vect[j],size_vect[j]);
-    for (j = 0; j < regions; j++)
-        memtest_non_destructive_swap((void*)start_vect[j],size_vect[j]);
-    for (j = 0; j < regions; j++)
-        memtest_non_destructive_invert((void*)start_vect[j],size_vect[j]);
-
-    /* 3) Take the CRC64 sum again. */
-    for (j = 0; j < regions; j++)
-        crc2 = crc64(crc2,(void*)start_vect[j],size_vect[j]);
-
-    /* 4) Swap + Swap again */
-    for (j = 0; j < regions; j++)
-        memtest_non_destructive_swap((void*)start_vect[j],size_vect[j]);
-    for (j = 0; j < regions; j++)
-        memtest_non_destructive_swap((void*)start_vect[j],size_vect[j]);
-
-    /* 5) Take the CRC64 sum again. */
-    for (j = 0; j < regions; j++)
-        crc3 = crc64(crc3,(void*)start_vect[j],size_vect[j]);
+    if (write(fd,"\n",1) == -1) { /* Nothing to do. */ }
 
     /* NOTE: It is very important to close the file descriptor only now
      * because closing it before may result into unmapping of some memory
      * region that we are testing. */
     fclose(fp);
-
-    /* If the two CRC are not the same, we trapped a memory error. */
-    return crc1 != crc2 || crc2 != crc3;
+    closeDirectLogFiledes(fd);
+    return errors;
 }
 #endif
 
 void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
     ucontext_t *uc = (ucontext_t*) secret;
+    void *eip = getMcontextEip(uc);
     sds infostring, clients;
     struct sigaction act;
-    REDIS_NOTUSED(info);
+    UNUSED(info);
 
     bugReportStart();
-    redisLog(REDIS_WARNING,
-        "    Redis %s crashed by signal: %d", REDIS_VERSION, sig);
-    if (sig == SIGSEGV) {
-        redisLog(REDIS_WARNING,
-        "    SIGSEGV caused by address: %p", (void*)info->si_addr);
+    serverLog(LL_WARNING,
+        "Redis %s crashed by signal: %d", REDIS_VERSION, sig);
+    if (eip != NULL) {
+        serverLog(LL_WARNING,
+        "Crashed running the instuction at: %p", eip);
+    }
+    if (sig == SIGSEGV || sig == SIGBUS) {
+        serverLog(LL_WARNING,
+        "Accessing address: %p", (void*)info->si_addr);
     }
-    redisLog(REDIS_WARNING,
-        "    Failed assertion: %s (%s:%d)", server.assert_failed,
+    serverLog(LL_WARNING,
+        "Failed assertion: %s (%s:%d)", server.assert_failed,
                         server.assert_file, server.assert_line);
 
     /* Log the stack trace */
-    redisLog(REDIS_WARNING, "--- STACK TRACE");
+    serverLogRaw(LL_WARNING|LL_RAW, "\n------ STACK TRACE ------\n");
     logStackTrace(uc);
 
     /* Log INFO and CLIENT LIST */
-    redisLog(REDIS_WARNING, "--- INFO OUTPUT");
+    serverLogRaw(LL_WARNING|LL_RAW, "\n------ INFO OUTPUT ------\n");
     infostring = genRedisInfoString("all");
     infostring = sdscatprintf(infostring, "hash_init_value: %u\n",
         dictGetHashFunctionSeed());
-    redisLogRaw(REDIS_WARNING, infostring);
-    redisLog(REDIS_WARNING, "--- CLIENT LIST OUTPUT");
+    serverLogRaw(LL_WARNING|LL_RAW, infostring);
+    serverLogRaw(LL_WARNING|LL_RAW, "\n------ CLIENT LIST OUTPUT ------\n");
     clients = getAllClientsInfoString();
-    redisLogRaw(REDIS_WARNING, clients);
+    serverLogRaw(LL_WARNING|LL_RAW, clients);
     sdsfree(infostring);
     sdsfree(clients);
 
     /* Log the current client */
     logCurrentClient();
 
     /* Log dump of processor registers */
     logRegisters(uc);
 
 #if defined(HAVE_PROC_MAPS)
     /* Test memory */
-    redisLog(REDIS_WARNING, "--- FAST MEMORY TEST");
+    serverLogRaw(LL_WARNING|LL_RAW, "\n------ FAST MEMORY TEST ------\n");
     bioKillThreads();
     if (memtest_test_linux_anonymous_maps()) {
-        redisLog(REDIS_WARNING,
+        serverLogRaw(LL_WARNING|LL_RAW,
             "!!! MEMORY ERROR DETECTED! Check your memory ASAP !!!");
     } else {
-        redisLog(REDIS_WARNING,
+        serverLogRaw(LL_WARNING|LL_RAW,
             "Fast memory test PASSED, however your memory can still be broken. Please run a memory test for several hours if possible.");
     }
 #endif
 
-    redisLog(REDIS_WARNING,
+    serverLogRaw(LL_WARNING|LL_RAW,
 "\n=== REDIS BUG REPORT END. Make sure to include from START to END. ===\n\n"
 "       Please report the crash by opening an issue on github:\n\n"
 "           http://github.com/antirez/redis/issues\n\n"
 "  Suspect RAM error? Use redis-server --test-memory to verify it.\n\n"
 );
     /* free(messages); Don't call free() with possibly corrupted memory. */
-    if (server.daemonize) unlink(server.pidfile);
+    if (server.daemonize && server.supervised == 0) unlink(server.pidfile);
 
     /* Make sure we exit with the right signal at the end. So for instance
      * the core will be dumped if enabled. */
     sigemptyset (&act.sa_mask);
     act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
     act.sa_handler = SIG_DFL;
@@ -872,51 +1047,51 @@
     kill(getpid(),sig);
 }
 #endif /* HAVE_BACKTRACE */
 
 /* ==================== Logging functions for debugging ===================== */
 
-void redisLogHexDump(int level, char *descr, void *value, size_t len) {
+void serverLogHexDump(int level, char *descr, void *value, size_t len) {
     char buf[65], *b;
     unsigned char *v = value;
     char charset[] = "0123456789abcdef";
 
-    redisLog(level,"%s (hexdump):", descr);
+    serverLog(level,"%s (hexdump):", descr);
     b = buf;
     while(len) {
         b[0] = charset[(*v)>>4];
         b[1] = charset[(*v)&0xf];
         b[2] = '\0';
         b += 2;
         len--;
         v++;
         if (b-buf == 64 || len == 0) {
-            redisLogRaw(level|REDIS_LOG_RAW,buf);
+            serverLogRaw(level|LL_RAW,buf);
             b = buf;
         }
     }
-    redisLogRaw(level|REDIS_LOG_RAW,"\n");
+    serverLogRaw(level|LL_RAW,"\n");
 }
 
 /* =========================== Software Watchdog ============================ */
 #include <sys/time.h>
 
 void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {
 #ifdef HAVE_BACKTRACE
     ucontext_t *uc = (ucontext_t*) secret;
 #endif
-    REDIS_NOTUSED(info);
-    REDIS_NOTUSED(sig);
+    UNUSED(info);
+    UNUSED(sig);
 
-    redisLogFromHandler(REDIS_WARNING,"\n--- WATCHDOG TIMER EXPIRED ---");
+    serverLogFromHandler(LL_WARNING,"\n--- WATCHDOG TIMER EXPIRED ---");
 #ifdef HAVE_BACKTRACE
     logStackTrace(uc);
 #else
-    redisLogFromHandler(REDIS_WARNING,"Sorry: no support for backtrace().");
+    serverLogFromHandler(LL_WARNING,"Sorry: no support for backtrace().");
 #endif
-    redisLogFromHandler(REDIS_WARNING,"--------\n");
+    serverLogFromHandler(LL_WARNING,"--------\n");
 }
 
 /* Schedule a SIGALRM delivery after the specified period in milliseconds.
  * If a timer is already scheduled, this function will re-schedule it to the
  * specified time. If period is 0 the current timer is disabled. */
 void watchdogScheduleSignal(int period) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/debug.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/debug.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/debug.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/debug.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.c	2016-05-06 15:11:36.000000000 +0800
@@ -353,13 +353,16 @@
 
     /* Get the index of the new element, or -1 if
      * the element already exists. */
     if ((index = _dictKeyIndex(d, key)) == -1)
         return NULL;
 
-    /* Allocate the memory and store the new entry */
+    /* Allocate the memory and store the new entry.
+     * Insert the element in top, with the assumption that in a database
+     * system it is more likely that recently added entries are accessed
+     * more frequently. */
     ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];
     entry = zmalloc(sizeof(*entry));
     entry->next = ht->table[index];
     ht->table[index] = entry;
     ht->used++;
 
@@ -418,13 +421,13 @@
 
     for (table = 0; table <= 1; table++) {
         idx = h & d->ht[table].sizemask;
         he = d->ht[table].table[idx];
         prevHe = NULL;
         while(he) {
-            if (dictCompareKeys(d, key, he->key)) {
+            if (key==he->key || dictCompareKeys(d, key, he->key)) {
                 /* Unlink the element from the list */
                 if (prevHe)
                     prevHe->next = he->next;
                 else
                     d->ht[table].table[idx] = he->next;
                 if (!nofree) {
@@ -488,20 +491,20 @@
 
 dictEntry *dictFind(dict *d, const void *key)
 {
     dictEntry *he;
     unsigned int h, idx, table;
 
-    if (d->ht[0].size == 0) return NULL; /* We don't have a table at all */
+    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
     if (dictIsRehashing(d)) _dictRehashStep(d);
     h = dictHashKey(d, key);
     for (table = 0; table <= 1; table++) {
         idx = h & d->ht[table].sizemask;
         he = d->ht[table].table[idx];
         while(he) {
-            if (dictCompareKeys(d, key, he->key))
+            if (key==he->key || dictCompareKeys(d, key, he->key))
                 return he;
             he = he->next;
         }
         if (!dictIsRehashing(d)) return NULL;
     }
     return NULL;
@@ -681,16 +684,16 @@
  * Note that this function is not suitable when you need a good distribution
  * of the returned items, but only when you need to "sample" a given number
  * of continuous elements to run some kind of algorithm or to produce
  * statistics. However the function is much faster than dictGetRandomKey()
  * at producing N elements. */
 unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {
-    unsigned int j; /* internal hash table id, 0 or 1. */
-    unsigned int tables; /* 1 or 2 tables? */
-    unsigned int stored = 0, maxsizemask;
-    unsigned int maxsteps;
+    unsigned long j; /* internal hash table id, 0 or 1. */
+    unsigned long tables; /* 1 or 2 tables? */
+    unsigned long stored = 0, maxsizemask;
+    unsigned long maxsteps;
 
     if (dictSize(d) < count) count = dictSize(d);
     maxsteps = count*10;
 
     /* Try to do a rehashing work proportional to 'count'. */
     for (j = 0; j < count; j++) {
@@ -703,20 +706,20 @@
     tables = dictIsRehashing(d) ? 2 : 1;
     maxsizemask = d->ht[0].sizemask;
     if (tables > 1 && maxsizemask < d->ht[1].sizemask)
         maxsizemask = d->ht[1].sizemask;
 
     /* Pick a random point inside the larger table. */
-    unsigned int i = random() & maxsizemask;
-    unsigned int emptylen = 0; /* Continuous empty entries so far. */
+    unsigned long i = random() & maxsizemask;
+    unsigned long emptylen = 0; /* Continuous empty entries so far. */
     while(stored < count && maxsteps--) {
         for (j = 0; j < tables; j++) {
             /* Invariant of the dict.c rehashing: up to the indexes already
              * visited in ht[0] during the rehashing, there are no populated
              * buckets, so we can skip ht[0] for indexes between 0 and idx-1. */
-            if (tables == 2 && j == 0 && i < (unsigned int) d->rehashidx) {
+            if (tables == 2 && j == 0 && i < (unsigned long) d->rehashidx) {
                 /* Moreover, if we are currently out of range in the second
                  * table, there will be no elements in both tables up to
                  * the current rehashing index, so we jump if possible.
                  * (this happens when going from big to small table). */
                 if (i >= d->ht[1].size) i = d->rehashidx;
                 continue;
@@ -972,13 +975,13 @@
     h = dictHashKey(d, key);
     for (table = 0; table <= 1; table++) {
         idx = h & d->ht[table].sizemask;
         /* Search if this slot does not already contain the given key */
         he = d->ht[table].table[idx];
         while(he) {
-            if (dictCompareKeys(d, key, he->key))
+            if (key==he->key || dictCompareKeys(d, key, he->key))
                 return -1;
             he = he->next;
         }
         if (!dictIsRehashing(d)) break;
     }
     return idx;
@@ -996,30 +999,27 @@
 }
 
 void dictDisableResize(void) {
     dict_can_resize = 0;
 }
 
-#if 0
-
-/* The following is code that we don't use for Redis currently, but that is part
-of the library. */
-
-/* ----------------------- Debugging ------------------------*/
+/* ------------------------------- Debugging ---------------------------------*/
 
 #define DICT_STATS_VECTLEN 50
-static void _dictPrintStatsHt(dictht *ht) {
+size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {
     unsigned long i, slots = 0, chainlen, maxchainlen = 0;
     unsigned long totchainlen = 0;
     unsigned long clvector[DICT_STATS_VECTLEN];
+    size_t l = 0;
 
     if (ht->used == 0) {
-        printf("No stats available for empty dictionaries\n");
-        return;
+        return snprintf(buf,bufsize,
+            "No stats available for empty dictionaries\n");
     }
 
+    /* Compute stats. */
     for (i = 0; i < DICT_STATS_VECTLEN; i++) clvector[i] = 0;
     for (i = 0; i < ht->size; i++) {
         dictEntry *he;
 
         if (ht->table[i] == NULL) {
             clvector[0]++;
@@ -1034,92 +1034,49 @@
             he = he->next;
         }
         clvector[(chainlen < DICT_STATS_VECTLEN) ? chainlen : (DICT_STATS_VECTLEN-1)]++;
         if (chainlen > maxchainlen) maxchainlen = chainlen;
         totchainlen += chainlen;
     }
-    printf("Hash table stats:\n");
-    printf(" table size: %ld\n", ht->size);
-    printf(" number of elements: %ld\n", ht->used);
-    printf(" different slots: %ld\n", slots);
-    printf(" max chain length: %ld\n", maxchainlen);
-    printf(" avg chain length (counted): %.02f\n", (float)totchainlen/slots);
-    printf(" avg chain length (computed): %.02f\n", (float)ht->used/slots);
-    printf(" Chain length distribution:\n");
+
+    /* Generate human readable stats. */
+    l += snprintf(buf+l,bufsize-l,
+        "Hash table %d stats (%s):\n"
+        " table size: %ld\n"
+        " number of elements: %ld\n"
+        " different slots: %ld\n"
+        " max chain length: %ld\n"
+        " avg chain length (counted): %.02f\n"
+        " avg chain length (computed): %.02f\n"
+        " Chain length distribution:\n",
+        tableid, (tableid == 0) ? "main hash table" : "rehashing target",
+        ht->size, ht->used, slots, maxchainlen,
+        (float)totchainlen/slots, (float)ht->used/slots);
+
     for (i = 0; i < DICT_STATS_VECTLEN-1; i++) {
         if (clvector[i] == 0) continue;
-        printf("   %s%ld: %ld (%.02f%%)\n",(i == DICT_STATS_VECTLEN-1)?">= ":"", i, clvector[i], ((float)clvector[i]/ht->size)*100);
-    }
-}
-
-void dictPrintStats(dict *d) {
-    _dictPrintStatsHt(&d->ht[0]);
-    if (dictIsRehashing(d)) {
-        printf("-- Rehashing into ht[1]:\n");
-        _dictPrintStatsHt(&d->ht[1]);
+        if (l >= bufsize) break;
+        l += snprintf(buf+l,bufsize-l,
+            "   %s%ld: %ld (%.02f%%)\n",
+            (i == DICT_STATS_VECTLEN-1)?">= ":"",
+            i, clvector[i], ((float)clvector[i]/ht->size)*100);
+    }
+
+    /* Unlike snprintf(), teturn the number of characters actually written. */
+    if (bufsize) buf[bufsize-1] = '\0';
+    return strlen(buf);
+}
+
+void dictGetStats(char *buf, size_t bufsize, dict *d) {
+    size_t l;
+    char *orig_buf = buf;
+    size_t orig_bufsize = bufsize;
+
+    l = _dictGetStatsHt(buf,bufsize,&d->ht[0],0);
+    buf += l;
+    bufsize -= l;
+    if (dictIsRehashing(d) && bufsize > 0) {
+        _dictGetStatsHt(buf,bufsize,&d->ht[1],1);
     }
+    /* Make sure there is a NULL term at the end. */
+    if (orig_bufsize) orig_buf[orig_bufsize-1] = '\0';
 }
-
-/* ----------------------- StringCopy Hash Table Type ------------------------*/
-
-static unsigned int _dictStringCopyHTHashFunction(const void *key)
-{
-    return dictGenHashFunction(key, strlen(key));
-}
-
-static void *_dictStringDup(void *privdata, const void *key)
-{
-    int len = strlen(key);
-    char *copy = zmalloc(len+1);
-    DICT_NOTUSED(privdata);
-
-    memcpy(copy, key, len);
-    copy[len] = '\0';
-    return copy;
-}
-
-static int _dictStringCopyHTKeyCompare(void *privdata, const void *key1,
-        const void *key2)
-{
-    DICT_NOTUSED(privdata);
-
-    return strcmp(key1, key2) == 0;
-}
-
-static void _dictStringDestructor(void *privdata, void *key)
-{
-    DICT_NOTUSED(privdata);
-
-    zfree(key);
-}
-
-dictType dictTypeHeapStringCopyKey = {
-    _dictStringCopyHTHashFunction, /* hash function */
-    _dictStringDup,                /* key dup */
-    NULL,                          /* val dup */
-    _dictStringCopyHTKeyCompare,   /* key compare */
-    _dictStringDestructor,         /* key destructor */
-    NULL                           /* val destructor */
-};
-
-/* This is like StringCopy but does not auto-duplicate the key.
- * It's used for intepreter's shared strings. */
-dictType dictTypeHeapStrings = {
-    _dictStringCopyHTHashFunction, /* hash function */
-    NULL,                          /* key dup */
-    NULL,                          /* val dup */
-    _dictStringCopyHTKeyCompare,   /* key compare */
-    _dictStringDestructor,         /* key destructor */
-    NULL                           /* val destructor */
-};
-
-/* This is like StringCopy but also automatically handle dynamic
- * allocated C strings as values. */
-dictType dictTypeHeapStringCopyKeyValue = {
-    _dictStringCopyHTHashFunction, /* hash function */
-    _dictStringDup,                /* key dup */
-    _dictStringDup,                /* val dup */
-    _dictStringCopyHTKeyCompare,   /* key compare */
-    _dictStringDestructor,         /* key destructor */
-    _dictStringDestructor,         /* val destructor */
-};
-#endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.h	2016-05-06 15:11:36.000000000 +0800
@@ -162,13 +162,13 @@
 dictIterator *dictGetIterator(dict *d);
 dictIterator *dictGetSafeIterator(dict *d);
 dictEntry *dictNext(dictIterator *iter);
 void dictReleaseIterator(dictIterator *iter);
 dictEntry *dictGetRandomKey(dict *d);
 unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count);
-void dictPrintStats(dict *d);
+void dictGetStats(char *buf, size_t bufsize, dict *d);
 unsigned int dictGenHashFunction(const void *key, int len);
 unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len);
 void dictEmpty(dict *d, void(callback)(void*));
 void dictEnableResize(void);
 void dictDisableResize(void);
 int dictRehash(dict *d, int n);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/dict.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/dict.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.c	2016-05-06 15:11:36.000000000 +0800
@@ -98,18 +98,22 @@
 
 uint64_t intrev64(uint64_t v) {
     memrev64(&v);
     return v;
 }
 
-#ifdef TESTMAIN
+#ifdef REDIS_TEST
 #include <stdio.h>
 
-int main(void) {
+#define UNUSED(x) (void)(x)
+int endianconvTest(int argc, char *argv[]) {
     char buf[32];
 
+    UNUSED(argc);
+    UNUSED(argv);
+
     sprintf(buf,"ciaoroma");
     memrev16(buf);
     printf("%s\n", buf);
 
     sprintf(buf,"ciaoroma");
     memrev32(buf);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.h	2016-05-06 15:11:36.000000000 +0800
@@ -68,7 +68,11 @@
 #define ntohu64(v) (v)
 #else
 #define htonu64(v) intrev64(v)
 #define ntohu64(v) intrev64(v)
 #endif
 
+#ifdef REDIS_TEST
+int endianconvTest(int argc, char *argv[]);
+#endif
+
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/endianconv.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/endianconv.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: geo.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: geo.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: geo.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: geo.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/help.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/help.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/help.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/help.h	2016-05-06 15:11:36.000000000 +0800
@@ -810,14 +810,14 @@
     { "SORT",
     "key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]",
     "Sort the elements in a list, set or sorted set",
     0,
     "1.0.0" },
     { "SPOP",
-    "key",
-    "Remove and return a random member from a set",
+    "key [count]",
+    "Remove and return one or multiple random members from a set",
     3,
     "1.0.0" },
     { "SRANDMEMBER",
     "key [count]",
     "Get one or multiple random members from a set",
     3,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/hyperloglog.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/hyperloglog.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/hyperloglog.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/hyperloglog.c	2016-05-06 15:11:36.000000000 +0800
@@ -26,13 +26,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 #include <stdint.h>
 #include <math.h>
 
 /* The Redis HyperLogLog implementation is based on the following ideas:
  *
@@ -560,23 +560,23 @@
 /* ================== Sparse representation implementation  ================= */
 
 /* Convert the HLL with sparse representation given as input in its dense
  * representation. Both representations are represented by SDS strings, and
  * the input representation is freed as a side effect.
  *
- * The function returns REDIS_OK if the sparse representation was valid,
- * otherwise REDIS_ERR is returned if the representation was corrupted. */
+ * The function returns C_OK if the sparse representation was valid,
+ * otherwise C_ERR is returned if the representation was corrupted. */
 int hllSparseToDense(robj *o) {
     sds sparse = o->ptr, dense;
     struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;
     int idx = 0, runlen, regval;
     uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);
 
     /* If the representation is already the right one return ASAP. */
     hdr = (struct hllhdr*) sparse;
-    if (hdr->encoding == HLL_DENSE) return REDIS_OK;
+    if (hdr->encoding == HLL_DENSE) return C_OK;
 
     /* Create a string of the right size filled with zero bytes.
      * Note that the cached cardinality is set to 0 as a side effect
      * that is exactly the cardinality of an empty HLL. */
     dense = sdsnewlen(NULL,HLL_DENSE_SIZE);
     hdr = (struct hllhdr*) dense;
@@ -607,19 +607,19 @@
     }
 
     /* If the sparse representation was valid, we expect to find idx
      * set to HLL_REGISTERS. */
     if (idx != HLL_REGISTERS) {
         sdsfree(dense);
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     /* Free the old representation and set the new one. */
     sdsfree(o->ptr);
     o->ptr = dense;
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* "Add" the element in the sparse hyperloglog data structure.
  * Actually nothing is added, but the max 0 pattern counter of the subset
  * the element belongs to is incremented if needed.
  *
@@ -863,24 +863,24 @@
     /* Invalidate the cached cardinality. */
     hdr = o->ptr;
     HLL_INVALIDATE_CACHE(hdr);
     return 1;
 
 promote: /* Promote to dense representation. */
-    if (hllSparseToDense(o) == REDIS_ERR) return -1; /* Corrupted HLL. */
+    if (hllSparseToDense(o) == C_ERR) return -1; /* Corrupted HLL. */
     hdr = o->ptr;
 
     /* We need to call hllDenseAdd() to perform the operation after the
      * conversion. However the result must be 1, since if we need to
      * convert from sparse to dense a register requires to be updated.
      *
      * Note that this in turn means that PFADD will make sure the command
      * is propagated to slaves / AOF, so if there is a sparse -> dense
      * convertion, it will be performed in all the slaves as well. */
     int dense_retval = hllDenseAdd(hdr->registers, ele, elesize);
-    redisAssert(dense_retval == 1);
+    serverAssert(dense_retval == 1);
     return dense_retval;
 }
 
 /* Compute SUM(2^-reg) in the sparse representation.
  * PE is an array with a pre-computer table of values 2^-reg indexed by reg.
  * As a side effect the integer pointed by 'ezp' is set to the number
@@ -988,13 +988,13 @@
     } else if (hdr->encoding == HLL_SPARSE) {
         E = hllSparseSum(hdr->registers,
                          sdslen((sds)hdr)-HLL_HDR_SIZE,PE,&ez,invalid);
     } else if (hdr->encoding == HLL_RAW) {
         E = hllRawSum(hdr->registers,PE,&ez);
     } else {
-        redisPanic("Unknown HyperLogLog encoding in hllCount()");
+        serverPanic("Unknown HyperLogLog encoding in hllCount()");
     }
 
     /* Muliply the inverse of E for alpha_m * m^2 to have the raw estimate. */
     E = (1/E)*alpha*m*m;
 
     /* Use the LINEARCOUNTING algorithm for small cardinalities.
@@ -1036,13 +1036,13 @@
 /* Merge by computing MAX(registers[i],hll[i]) the HyperLogLog 'hll'
  * with an array of uint8_t HLL_REGISTERS registers pointed by 'max'.
  *
  * The hll object must be already validated via isHLLObjectOrReply()
  * or in some other way.
  *
- * If the HyperLogLog is sparse and is found to be invalid, REDIS_ERR
+ * If the HyperLogLog is sparse and is found to be invalid, C_ERR
  * is returned, otherwise the function always succeeds. */
 int hllMerge(uint8_t *max, robj *hll) {
     struct hllhdr *hdr = hll->ptr;
     int i;
 
     if (hdr->encoding == HLL_DENSE) {
@@ -1074,15 +1074,15 @@
                     if (regval > max[i]) max[i] = regval;
                     i++;
                 }
                 p++;
             }
         }
-        if (i != HLL_REGISTERS) return REDIS_ERR;
+        if (i != HLL_REGISTERS) return C_ERR;
     }
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* ========================== HyperLogLog commands ========================== */
 
 /* Create an HLL object. We always create the HLL using sparse encoding.
  * This will be upgraded to the dense representation as needed. */
@@ -1105,31 +1105,31 @@
         int xzero = HLL_SPARSE_XZERO_MAX_LEN;
         if (xzero > aux) xzero = aux;
         HLL_SPARSE_XZERO_SET(p,xzero);
         p += 2;
         aux -= xzero;
     }
-    redisAssert((p-(uint8_t*)s) == sparselen);
+    serverAssert((p-(uint8_t*)s) == sparselen);
 
     /* Create the actual object. */
-    o = createObject(REDIS_STRING,s);
+    o = createObject(OBJ_STRING,s);
     hdr = o->ptr;
     memcpy(hdr->magic,"HYLL",4);
     hdr->encoding = HLL_SPARSE;
     return o;
 }
 
 /* Check if the object is a String with a valid HLL representation.
- * Return REDIS_OK if this is true, otherwise reply to the client
- * with an error and return REDIS_ERR. */
-int isHLLObjectOrReply(redisClient *c, robj *o) {
+ * Return C_OK if this is true, otherwise reply to the client
+ * with an error and return C_ERR. */
+int isHLLObjectOrReply(client *c, robj *o) {
     struct hllhdr *hdr;
 
     /* Key exists, check type */
-    if (checkType(c,o,REDIS_STRING))
-        return REDIS_ERR; /* Error already sent. */
+    if (checkType(c,o,OBJ_STRING))
+        return C_ERR; /* Error already sent. */
 
     if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
     hdr = o->ptr;
 
     /* Magic should be "HYLL". */
     if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
@@ -1139,36 +1139,36 @@
 
     /* Dense representation string length should match exactly. */
     if (hdr->encoding == HLL_DENSE &&
         stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;
 
     /* All tests passed. */
-    return REDIS_OK;
+    return C_OK;
 
 invalid:
     addReplySds(c,
         sdsnew("-WRONGTYPE Key is not a valid "
                "HyperLogLog string value.\r\n"));
-    return REDIS_ERR;
+    return C_ERR;
 }
 
 /* PFADD var ele ele ele ... ele => :0 or :1 */
-void pfaddCommand(redisClient *c) {
+void pfaddCommand(client *c) {
     robj *o = lookupKeyWrite(c->db,c->argv[1]);
     struct hllhdr *hdr;
     int updated = 0, j;
 
     if (o == NULL) {
         /* Create the key with a string value of the exact length to
          * hold our HLL data structure. sdsnewlen() when NULL is passed
          * is guaranteed to return bytes initialized to zero. */
         o = createHLLObject();
         dbAdd(c->db,c->argv[1],o);
         updated++;
     } else {
-        if (isHLLObjectOrReply(c,o) != REDIS_OK) return;
+        if (isHLLObjectOrReply(c,o) != C_OK) return;
         o = dbUnshareStringValue(c->db,c->argv[1],o);
     }
     /* Perform the low level ADD operation for every element. */
     for (j = 2; j < c->argc; j++) {
         int retval = hllAdd(o, (unsigned char*)c->argv[j]->ptr,
                                sdslen(c->argv[j]->ptr));
@@ -1181,21 +1181,21 @@
             return;
         }
     }
     hdr = o->ptr;
     if (updated) {
         signalModifiedKey(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
         server.dirty++;
         HLL_INVALIDATE_CACHE(hdr);
     }
     addReply(c, updated ? shared.cone : shared.czero);
 }
 
 /* PFCOUNT var -> approximated cardinality of set. */
-void pfcountCommand(redisClient *c) {
+void pfcountCommand(client *c) {
     robj *o;
     struct hllhdr *hdr;
     uint64_t card;
 
     /* Case 1: multi-key keys, cardinality of the union.
      *
@@ -1211,17 +1211,17 @@
         hdr->encoding = HLL_RAW; /* Special internal-only encoding. */
         registers = max + HLL_HDR_SIZE;
         for (j = 1; j < c->argc; j++) {
             /* Check type and size. */
             robj *o = lookupKeyRead(c->db,c->argv[j]);
             if (o == NULL) continue; /* Assume empty HLL for non existing var.*/
-            if (isHLLObjectOrReply(c,o) != REDIS_OK) return;
+            if (isHLLObjectOrReply(c,o) != C_OK) return;
 
             /* Merge with this HLL with our 'max' HHL by setting max[i]
              * to MAX(max[i],hll[i]). */
-            if (hllMerge(registers,o) == REDIS_ERR) {
+            if (hllMerge(registers,o) == C_ERR) {
                 addReplySds(c,sdsnew(invalid_hll_err));
                 return;
             }
         }
 
         /* Compute cardinality of the resulting set. */
@@ -1230,19 +1230,19 @@
     }
 
     /* Case 2: cardinality of the single HLL.
      *
      * The user specified a single key. Either return the cached value
      * or compute one and update the cache. */
-    o = lookupKeyRead(c->db,c->argv[1]);
+    o = lookupKeyWrite(c->db,c->argv[1]);
     if (o == NULL) {
         /* No key? Cardinality is zero since no element was added, otherwise
          * we would have a key as HLLADD creates it as a side effect. */
         addReply(c,shared.czero);
     } else {
-        if (isHLLObjectOrReply(c,o) != REDIS_OK) return;
+        if (isHLLObjectOrReply(c,o) != C_OK) return;
         o = dbUnshareStringValue(c->db,c->argv[1],o);
 
         /* Check if the cached cardinality is valid. */
         hdr = o->ptr;
         if (HLL_VALID_CACHE(hdr)) {
             /* Just return the cached value. */
@@ -1279,30 +1279,30 @@
         }
         addReplyLongLong(c,card);
     }
 }
 
 /* PFMERGE dest src1 src2 src3 ... srcN => OK */
-void pfmergeCommand(redisClient *c) {
+void pfmergeCommand(client *c) {
     uint8_t max[HLL_REGISTERS];
     struct hllhdr *hdr;
     int j;
 
     /* Compute an HLL with M[i] = MAX(M[i]_j).
      * We we the maximum into the max array of registers. We'll write
      * it to the target variable later. */
     memset(max,0,sizeof(max));
     for (j = 1; j < c->argc; j++) {
         /* Check type and size. */
         robj *o = lookupKeyRead(c->db,c->argv[j]);
         if (o == NULL) continue; /* Assume empty HLL for non existing var. */
-        if (isHLLObjectOrReply(c,o) != REDIS_OK) return;
+        if (isHLLObjectOrReply(c,o) != C_OK) return;
 
         /* Merge with this HLL with our 'max' HHL by setting max[i]
          * to MAX(max[i],hll[i]). */
-        if (hllMerge(max,o) == REDIS_ERR) {
+        if (hllMerge(max,o) == C_ERR) {
             addReplySds(c,sdsnew(invalid_hll_err));
             return;
         }
     }
 
     /* Create / unshare the destination key's value if needed. */
@@ -1318,13 +1318,13 @@
          * since we checked when merging the different HLLs, so we
          * don't check again. */
         o = dbUnshareStringValue(c->db,c->argv[1],o);
     }
 
     /* Only support dense objects as destination. */
-    if (hllSparseToDense(o) == REDIS_ERR) {
+    if (hllSparseToDense(o) == C_ERR) {
         addReplySds(c,sdsnew(invalid_hll_err));
         return;
     }
 
     /* Write the resulting HLL to the destination HLL registers and
      * invalidate the cached value. */
@@ -1334,24 +1334,24 @@
     }
     HLL_INVALIDATE_CACHE(hdr);
 
     signalModifiedKey(c->db,c->argv[1]);
     /* We generate an PFADD event for PFMERGE for semantical simplicity
      * since in theory this is a mass-add of elements. */
-    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
     server.dirty++;
     addReply(c,shared.ok);
 }
 
 /* ========================== Testing / Debugging  ========================== */
 
 /* PFSELFTEST
  * This command performs a self-test of the HLL registers implementation.
  * Something that is not easy to test from within the outside. */
 #define HLL_TEST_CYCLES 1000
-void pfselftestCommand(redisClient *c) {
+void pfselftestCommand(client *c) {
     unsigned int j, i;
     sds bitcounters = sdsnewlen(NULL,HLL_DENSE_SIZE);
     struct hllhdr *hdr = (struct hllhdr*) bitcounters, *hdr2;
     robj *o = NULL;
     uint8_t bytecounters[HLL_REGISTERS];
 
@@ -1449,33 +1449,33 @@
     sdsfree(bitcounters);
     if (o) decrRefCount(o);
 }
 
 /* PFDEBUG <subcommand> <key> ... args ...
  * Different debugging related operations about the HLL implementation. */
-void pfdebugCommand(redisClient *c) {
+void pfdebugCommand(client *c) {
     char *cmd = c->argv[1]->ptr;
     struct hllhdr *hdr;
     robj *o;
     int j;
 
-    o = lookupKeyRead(c->db,c->argv[2]);
+    o = lookupKeyWrite(c->db,c->argv[2]);
     if (o == NULL) {
         addReplyError(c,"The specified key does not exist");
         return;
     }
-    if (isHLLObjectOrReply(c,o) != REDIS_OK) return;
+    if (isHLLObjectOrReply(c,o) != C_OK) return;
     o = dbUnshareStringValue(c->db,c->argv[2],o);
     hdr = o->ptr;
 
     /* PFDEBUG GETREG <key> */
     if (!strcasecmp(cmd,"getreg")) {
         if (c->argc != 3) goto arityerr;
 
         if (hdr->encoding == HLL_SPARSE) {
-            if (hllSparseToDense(o) == REDIS_ERR) {
+            if (hllSparseToDense(o) == C_ERR) {
                 addReplySds(c,sdsnew(invalid_hll_err));
                 return;
             }
             server.dirty++; /* Force propagation on encoding change. */
         }
 
@@ -1533,13 +1533,13 @@
     /* PFDEBUG TODENSE <key> */
     else if (!strcasecmp(cmd,"todense")) {
         int conv = 0;
         if (c->argc != 3) goto arityerr;
 
         if (hdr->encoding == HLL_SPARSE) {
-            if (hllSparseToDense(o) == REDIS_ERR) {
+            if (hllSparseToDense(o) == C_ERR) {
                 addReplySds(c,sdsnew(invalid_hll_err));
                 return;
             }
             conv = 1;
             server.dirty++; /* Force propagation on encoding change. */
         }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/hyperloglog.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/hyperloglog.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/hyperloglog.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/hyperloglog.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.c	2016-05-06 15:11:36.000000000 +0800
@@ -278,64 +278,64 @@
 
 /* Return intset blob size in bytes. */
 size_t intsetBlobLen(intset *is) {
     return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);
 }
 
-#ifdef INTSET_TEST_MAIN
+#ifdef REDIS_TEST
 #include <sys/time.h>
+#include <time.h>
 
-void intsetRepr(intset *is) {
-    int i;
-    for (i = 0; i < intrev32ifbe(is->length); i++) {
+#if 0
+static void intsetRepr(intset *is) {
+    for (uint32_t i = 0; i < intrev32ifbe(is->length); i++) {
         printf("%lld\n", (uint64_t)_intsetGet(is,i));
     }
     printf("\n");
 }
 
-void error(char *err) {
+static void error(char *err) {
     printf("%s\n", err);
     exit(1);
 }
+#endif
 
-void ok(void) {
+static void ok(void) {
     printf("OK\n");
 }
 
-long long usec(void) {
+static long long usec(void) {
     struct timeval tv;
     gettimeofday(&tv,NULL);
     return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
 }
 
 #define assert(_e) ((_e)?(void)0:(_assert(#_e,__FILE__,__LINE__),exit(1)))
-void _assert(char *estr, char *file, int line) {
+static void _assert(char *estr, char *file, int line) {
     printf("\n\n=== ASSERTION FAILED ===\n");
     printf("==> %s:%d '%s' is not true\n",file,line,estr);
 }
 
-intset *createSet(int bits, int size) {
+static intset *createSet(int bits, int size) {
     uint64_t mask = (1<<bits)-1;
-    uint64_t i, value;
+    uint64_t value;
     intset *is = intsetNew();
 
-    for (i = 0; i < size; i++) {
+    for (int i = 0; i < size; i++) {
         if (bits > 32) {
             value = (rand()*rand()) & mask;
         } else {
             value = rand() & mask;
         }
         is = intsetAdd(is,value,NULL);
     }
     return is;
 }
 
-void checkConsistency(intset *is) {
-    int i;
-
-    for (i = 0; i < (intrev32ifbe(is->length)-1); i++) {
+static void checkConsistency(intset *is) {
+    for (uint32_t i = 0; i < (intrev32ifbe(is->length)-1); i++) {
         uint32_t encoding = intrev32ifbe(is->encoding);
 
         if (encoding == INTSET_ENC_INT16) {
             int16_t *i16 = (int16_t*)is->contents;
             assert(i16[i] < i16[i+1]);
         } else if (encoding == INTSET_ENC_INT32) {
@@ -345,29 +345,35 @@
             int64_t *i64 = (int64_t*)is->contents;
             assert(i64[i] < i64[i+1]);
         }
     }
 }
 
-int main(int argc, char **argv) {
+#define UNUSED(x) (void)(x)
+int intsetTest(int argc, char **argv) {
     uint8_t success;
     int i;
     intset *is;
-    sranddev();
+    srand(time(NULL));
+
+    UNUSED(argc);
+    UNUSED(argv);
 
     printf("Value encodings: "); {
         assert(_intsetValueEncoding(-32768) == INTSET_ENC_INT16);
         assert(_intsetValueEncoding(+32767) == INTSET_ENC_INT16);
         assert(_intsetValueEncoding(-32769) == INTSET_ENC_INT32);
         assert(_intsetValueEncoding(+32768) == INTSET_ENC_INT32);
         assert(_intsetValueEncoding(-2147483648) == INTSET_ENC_INT32);
         assert(_intsetValueEncoding(+2147483647) == INTSET_ENC_INT32);
         assert(_intsetValueEncoding(-2147483649) == INTSET_ENC_INT64);
         assert(_intsetValueEncoding(+2147483648) == INTSET_ENC_INT64);
-        assert(_intsetValueEncoding(-9223372036854775808ull) == INTSET_ENC_INT64);
-        assert(_intsetValueEncoding(+9223372036854775807ull) == INTSET_ENC_INT64);
+        assert(_intsetValueEncoding(-9223372036854775808ull) ==
+                    INTSET_ENC_INT64);
+        assert(_intsetValueEncoding(+9223372036854775807ull) ==
+                    INTSET_ENC_INT64);
         ok();
     }
 
     printf("Basic adding: "); {
         is = intsetNew();
         is = intsetAdd(is,5,&success); assert(success);
@@ -375,13 +381,13 @@
         is = intsetAdd(is,4,&success); assert(success);
         is = intsetAdd(is,4,&success); assert(!success);
         ok();
     }
 
     printf("Large number of random adds: "); {
-        int inserts = 0;
+        uint32_t inserts = 0;
         is = intsetNew();
         for (i = 0; i < 1024; i++) {
             is = intsetAdd(is,rand()%0x800,&success);
             if (success) inserts++;
         }
         assert(intrev32ifbe(is->length) == inserts);
@@ -458,13 +464,14 @@
         long long start;
         is = createSet(bits,size);
         checkConsistency(is);
 
         start = usec();
         for (i = 0; i < num; i++) intsetSearch(is,rand() % ((1<<bits)-1),NULL);
-        printf("%ld lookups, %ld element set, %lldusec\n",num,size,usec()-start);
+        printf("%ld lookups, %ld element set, %lldusec\n",
+               num,size,usec()-start);
     }
 
     printf("Stress add+delete: "); {
         int i, v1, v2;
         is = intsetNew();
         for (i = 0; i < 0xffff; i++) {
@@ -476,8 +483,10 @@
             is = intsetRemove(is,v2,NULL);
             assert(!intsetFind(is,v2));
         }
         checkConsistency(is);
         ok();
     }
+
+    return 0;
 }
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.h	2016-05-06 15:11:36.000000000 +0800
@@ -44,7 +44,11 @@
 uint8_t intsetFind(intset *is, int64_t value);
 int64_t intsetRandom(intset *is);
 uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);
 uint32_t intsetLen(intset *is);
 size_t intsetBlobLen(intset *is);
 
+#ifdef REDIS_TEST
+int intsetTest(int argc, char *argv[]);
+#endif
+
 #endif // __INTSET_H
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/intset.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/intset.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/latency.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/latency.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/latency.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/latency.c	2016-05-06 15:11:36.000000000 +0800
@@ -30,17 +30,17 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 /* Dictionary type for latency events. */
 int dictStringKeyCompare(void *privdata, const void *key1, const void *key2) {
-    REDIS_NOTUSED(privdata);
+    UNUSED(privdata);
     return strcmp(key1,key2) == 0;
 }
 
 unsigned int dictStringHash(const void *key) {
     return dictGenHashFunction(key, strlen(key));
 }
@@ -471,13 +471,13 @@
 }
 
 /* ---------------------- Latency command implementation -------------------- */
 
 /* latencyCommand() helper to produce a time-delay reply for all the samples
  * in memory for the specified time series. */
-void latencyCommandReplyWithSamples(redisClient *c, struct latencyTimeSeries *ts) {
+void latencyCommandReplyWithSamples(client *c, struct latencyTimeSeries *ts) {
     void *replylen = addDeferredMultiBulkLength(c);
     int samples = 0, j;
 
     for (j = 0; j < LATENCY_TS_LEN; j++) {
         int i = (ts->idx + j) % LATENCY_TS_LEN;
 
@@ -489,13 +489,13 @@
     }
     setDeferredMultiBulkLength(c,replylen,samples);
 }
 
 /* latencyCommand() helper to produce the reply for the LATEST subcommand,
  * listing the last latency sample for every event type registered so far. */
-void latencyCommandReplyWithLatestEvents(redisClient *c) {
+void latencyCommandReplyWithLatestEvents(client *c) {
     dictIterator *di;
     dictEntry *de;
 
     addReplyMultiBulkLen(c,dictSize(server.latency_events));
     di = dictGetIterator(server.latency_events);
     while((de = dictNext(di)) != NULL) {
@@ -561,13 +561,13 @@
  *
  * LATENCY SAMPLES: return time-latency samples for the specified event.
  * LATENCY LATEST: return the latest latency for all the events classes.
  * LATENCY DOCTOR: returns an human readable analysis of instance latency.
  * LATENCY GRAPH: provide an ASCII graph of the latency of the specified event.
  */
-void latencyCommand(redisClient *c) {
+void latencyCommand(client *c) {
     struct latencyTimeSeries *ts;
 
     if (!strcasecmp(c->argv[1]->ptr,"history") && c->argc == 3) {
         /* LATENCY HISTORY <event> */
         ts = dictFetchValue(server.latency_events,c->argv[2]->ptr);
         if (ts == NULL) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/latency.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/latency.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/latency.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/latency.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_c.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_c.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_c.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_c.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2000-2008 Marc Alexander Lehmann <schmorp@schmorp.de>
+ * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>
  *
  * Redistribution and use in source and binary forms, with or without modifica-
  * tion, are permitted provided that the following conditions are met:
  *
  *   1.  Redistributions of source code must retain the above copyright notice,
  *       this list of conditions and the following disclaimer.
@@ -37,14 +37,14 @@
 #include "lzfP.h"
 
 #define HSIZE (1 << (HLOG))
 
 /*
  * don't play with this unless you benchmark!
- * decompression is not dependent on the hash function
- * the hashing function might seem strange, just believe me
+ * the data format is not dependent on the hash function.
+ * the hash function might seem strange, just believe me,
  * it works ;)
  */
 #ifndef FRST
 # define FRST(p) (((p[0]) << 8) | p[1])
 # define NEXT(v,p) (((v) << 8) | p[2])
 # if ULTRA_FAST
@@ -86,15 +86,15 @@
 #define expect_false(expr) expect ((expr) != 0, 0)
 #define expect_true(expr)  expect ((expr) != 0, 1)
 
 /*
  * compressed format
  *
- * 000LLLLL <L+1>    ; literal
- * LLLooooo oooooooo ; backref L
- * 111ooooo LLLLLLLL oooooooo ; backref L+7
+ * 000LLLLL <L+1>    ; literal, L+1=1..33 octets
+ * LLLooooo oooooooo ; backref L+1=1..7 octets, o+1=1..4096 offset
+ * 111ooooo LLLLLLLL oooooooo ; backref L+8 octets, o+1=1..4096 offset
  *
  */
 
 unsigned int
 lzf_compress (const void *const in_data, unsigned int in_len,
 	      void *out_data, unsigned int out_len
@@ -103,13 +103,12 @@
 #endif
               )
 {
 #if !LZF_STATE_ARG
   LZF_STATE htab;
 #endif
-  const u8 **hslot;
   const u8 *ip = (const u8 *)in_data;
         u8 *op = (u8 *)out_data;
   const u8 *in_end  = ip + in_len;
         u8 *out_end = op + out_len;
   const u8 *ref;
 
@@ -130,55 +129,51 @@
 
   if (!in_len || !out_len)
     return 0;
 
 #if INIT_HTAB
   memset (htab, 0, sizeof (htab));
-# if 0
-  for (hslot = htab; hslot < htab + HSIZE; hslot++)
-    *hslot++ = ip;
-# endif
 #endif
 
   lit = 0; op++; /* start run */
 
   hval = FRST (ip);
   while (ip < in_end - 2)
     {
+      LZF_HSLOT *hslot;
+
       hval = NEXT (hval, ip);
       hslot = htab + IDX (hval);
-      ref = *hslot; *hslot = ip;
+      ref = *hslot + LZF_HSLOT_BIAS; *hslot = ip - LZF_HSLOT_BIAS;
 
       if (1
 #if INIT_HTAB
           && ref < ip /* the next test will actually take care of this, but this is faster */
 #endif
           && (off = ip - ref - 1) < MAX_OFF
-          && ip + 4 < in_end
           && ref > (u8 *)in_data
-#if STRICT_ALIGN
-          && ref[0] == ip[0]
-          && ref[1] == ip[1]
           && ref[2] == ip[2]
+#if STRICT_ALIGN
+          && ((ref[1] << 8) | ref[0]) == ((ip[1] << 8) | ip[0])
 #else
           && *(u16 *)ref == *(u16 *)ip
-          && ref[2] == ip[2]
 #endif
         )
         {
           /* match found at *ref++ */
           unsigned int len = 2;
           unsigned int maxlen = in_end - ip - len;
           maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;
 
+          if (expect_false (op + 3 + 1 >= out_end)) /* first a faster conservative test */
+            if (op - !lit + 3 + 1 >= out_end) /* second the exact but rare test */
+              return 0;
+
           op [- lit - 1] = lit - 1; /* stop run */
           op -= !lit; /* undo run if length is zero */
 
-          if (expect_false (op + 3 + 1 >= out_end))
-            return 0;
-
           for (;;)
             {
               if (expect_true (maxlen > 16))
                 {
                   len++; if (ref [len] != ip [len]) break;
                   len++; if (ref [len] != ip [len]) break;
@@ -234,27 +230,27 @@
 # if VERY_FAST && !ULTRA_FAST
           --ip;
 # endif
           hval = FRST (ip);
 
           hval = NEXT (hval, ip);
-          htab[IDX (hval)] = ip;
+          htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
           ip++;
 
 # if VERY_FAST && !ULTRA_FAST
           hval = NEXT (hval, ip);
-          htab[IDX (hval)] = ip;
+          htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
           ip++;
 # endif
 #else
           ip -= len + 1;
 
           do
             {
               hval = NEXT (hval, ip);
-              htab[IDX (hval)] = ip;
+              htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
               ip++;
             }
           while (len--);
 #endif
         }
       else
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_c.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_c.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_c.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_c.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_d.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_d.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_d.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_d.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2000-2007 Marc Alexander Lehmann <schmorp@schmorp.de>
+ * Copyright (c) 2000-2010 Marc Alexander Lehmann <schmorp@schmorp.de>
  *
  * Redistribution and use in source and binary forms, with or without modifica-
  * tion, are permitted provided that the following conditions are met:
  *
  *   1.  Redistributions of source code must retain the above copyright notice,
  *       this list of conditions and the following disclaimer.
@@ -40,20 +40,20 @@
 # define SET_ERRNO(n)
 #else
 # include <errno.h>
 # define SET_ERRNO(n) errno = (n)
 #endif
 
-/*
+#if USE_REP_MOVSB /* small win on amd, big loss on intel */
 #if (__i386 || __amd64) && __GNUC__ >= 3
 # define lzf_movsb(dst, src, len)                \
    asm ("rep movsb"                              \
         : "=D" (dst), "=S" (src), "=c" (len)     \
         :  "0" (dst),  "1" (src),  "2" (len));
 #endif
-*/
+#endif
 
 unsigned int
 lzf_decompress (const void *const in_data,  unsigned int in_len,
                 void             *out_data, unsigned int out_len)
 {
   u8 const *ip = (const u8 *)in_data;
@@ -83,15 +83,23 @@
             }
 #endif
 
 #ifdef lzf_movsb
           lzf_movsb (op, ip, ctrl);
 #else
-          do
-            *op++ = *ip++;
-          while (--ctrl);
+          switch (ctrl)
+            {
+              case 32: *op++ = *ip++; case 31: *op++ = *ip++; case 30: *op++ = *ip++; case 29: *op++ = *ip++;
+              case 28: *op++ = *ip++; case 27: *op++ = *ip++; case 26: *op++ = *ip++; case 25: *op++ = *ip++;
+              case 24: *op++ = *ip++; case 23: *op++ = *ip++; case 22: *op++ = *ip++; case 21: *op++ = *ip++;
+              case 20: *op++ = *ip++; case 19: *op++ = *ip++; case 18: *op++ = *ip++; case 17: *op++ = *ip++;
+              case 16: *op++ = *ip++; case 15: *op++ = *ip++; case 14: *op++ = *ip++; case 13: *op++ = *ip++;
+              case 12: *op++ = *ip++; case 11: *op++ = *ip++; case 10: *op++ = *ip++; case  9: *op++ = *ip++;
+              case  8: *op++ = *ip++; case  7: *op++ = *ip++; case  6: *op++ = *ip++; case  5: *op++ = *ip++;
+              case  4: *op++ = *ip++; case  3: *op++ = *ip++; case  2: *op++ = *ip++; case  1: *op++ = *ip++;
+            }
 #endif
         }
       else /* back reference */
         {
           unsigned int len = ctrl >> 5;
 
@@ -131,18 +139,45 @@
             }
 
 #ifdef lzf_movsb
           len += 2;
           lzf_movsb (op, ref, len);
 #else
-          *op++ = *ref++;
-          *op++ = *ref++;
+          switch (len)
+            {
+              default:
+                len += 2;
 
-          do
-            *op++ = *ref++;
-          while (--len);
+                if (op >= ref + len)
+                  {
+                    /* disjunct areas */
+                    memcpy (op, ref, len);
+                    op += len;
+                  }
+                else
+                  {
+                    /* overlapping, use octte by octte copying */
+                    do
+                      *op++ = *ref++;
+                    while (--len);
+                  }
+
+                break;
+
+              case 9: *op++ = *ref++;
+              case 8: *op++ = *ref++;
+              case 7: *op++ = *ref++;
+              case 6: *op++ = *ref++;
+              case 5: *op++ = *ref++;
+              case 4: *op++ = *ref++;
+              case 3: *op++ = *ref++;
+              case 2: *op++ = *ref++;
+              case 1: *op++ = *ref++;
+              case 0: *op++ = *ref++; /* two octets more */
+                      *op++ = *ref++;
+            }
 #endif
         }
     }
   while (ip < in_end);
 
   return op - (u8 *)out_data;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_d.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_d.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzf_d.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzf_d.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzfP.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzfP.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/lzfP.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/lzfP.h	2016-05-06 15:11:36.000000000 +0800
@@ -46,13 +46,13 @@
 /*
  * Size of hashtable is (1 << HLOG) * sizeof (char *)
  * decompression is independent of the hash table size
  * the difference between 15 and 14 is very small
  * for small blocks (and 14 is usually a bit faster).
  * For a low-memory/faster configuration, use HLOG == 13;
- * For best compression, use 15 or 16 (or more, up to 23).
+ * For best compression, use 15 or 16 (or more, up to 22).
  */
 #ifndef HLOG
 # define HLOG 16
 #endif
 
 /*
@@ -91,13 +91,13 @@
 # define INIT_HTAB 0
 #endif
 
 /*
  * Avoid assigning values to errno variable? for some embedding purposes
  * (linux kernel for example), this is necessary. NOTE: this breaks
- * the documentation in lzf.h.
+ * the documentation in lzf.h. Avoiding errno has no speed impact.
  */
 #ifndef AVOID_ERRNO
 # define AVOID_ERRNO 0
 #endif
 
 /*
@@ -118,42 +118,68 @@
  * (<1% slowdown), but might slow down older cpus considerably.
  */
 #ifndef CHECK_INPUT
 # define CHECK_INPUT 1
 #endif
 
+/*
+ * Whether to store pointers or offsets inside the hash table. On
+ * 64 bit architetcures, pointers take up twice as much space,
+ * and might also be slower. Default is to autodetect.
+ */
+/*#define LZF_USER_OFFSETS autodetect */
+
 /*****************************************************************************/
 /* nothing should be changed below */
 
+#ifdef __cplusplus
+# include <cstring>
+# include <climits>
+using namespace std;
+#else
+# include <string.h>
+# include <limits.h>
+#endif
+
+#ifndef LZF_USE_OFFSETS
+# if defined (WIN32)
+#  define LZF_USE_OFFSETS defined(_M_X64)
+# else
+#  if __cplusplus > 199711L
+#   include <cstdint>
+#  else
+#   include <stdint.h>
+#  endif
+#  define LZF_USE_OFFSETS (UINTPTR_MAX > 0xffffffffU)
+# endif
+#endif
+
 typedef unsigned char u8;
 
-typedef const u8 *LZF_STATE[1 << (HLOG)];
+#if LZF_USE_OFFSETS
+# define LZF_HSLOT_BIAS ((const u8 *)in_data)
+  typedef unsigned int LZF_HSLOT;
+#else
+# define LZF_HSLOT_BIAS 0
+  typedef const u8 *LZF_HSLOT;
+#endif
+
+typedef LZF_HSLOT LZF_STATE[1 << (HLOG)];
 
 #if !STRICT_ALIGN
 /* for unaligned accesses we need a 16 bit datatype. */
-# include <limits.h>
 # if USHRT_MAX == 65535
     typedef unsigned short u16;
 # elif UINT_MAX == 65535
     typedef unsigned int u16;
 # else
 #  undef STRICT_ALIGN
 #  define STRICT_ALIGN 1
 # endif
 #endif
 
 #if ULTRA_FAST
-# if defined(VERY_FAST)
-#  undef VERY_FAST
-# endif
-#endif
-
-#if INIT_HTAB
-# ifdef __cplusplus
-#  include <cstring>
-# else
-#  include <string.h>
-# endif
+# undef VERY_FAST
 #endif
 
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/Makefile	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/Makefile	2016-05-06 15:11:36.000000000 +0800
@@ -12,16 +12,16 @@
 # Dependencies are stored in the Makefile.dep file. To rebuild this file
 # Just use 'make dep', but this is only needed by developers.
 
 release_hdr := $(shell sh -c './mkreleasehdr.sh')
 uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')
 OPTIMIZATION?=-O2
-DEPENDENCY_TARGETS=hiredis linenoise lua
+DEPENDENCY_TARGETS=hiredis linenoise lua geohash-int
 
 # Default settings
-STD=-std=c99 -pedantic
+STD=-std=c99 -pedantic -DREDIS_STATIC=''
 WARN=-Wall -W
 OPT=$(OPTIMIZATION)
 
 PREFIX?=/usr/local
 INSTALL_BIN=$(PREFIX)/bin
 INSTALL=install
@@ -43,16 +43,20 @@
 endif
 
 ifeq ($(USE_JEMALLOC),yes)
 	MALLOC=jemalloc
 endif
 
+ifeq ($(USE_JEMALLOC),no)
+	MALLOC=libc
+endif
+
 # Override default settings if possible
 -include .make-settings
 
-FINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)
+FINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS) -I../deps/geohash-int
 FINAL_LDFLAGS=$(LDFLAGS) $(REDIS_LDFLAGS) $(DEBUG)
 FINAL_LIBS=-lm
 DEBUG=-g -ggdb
 
 ifeq ($(uname_S),SunOS)
 	# SunOS
@@ -110,23 +114,23 @@
 QUIET_LINK = @printf '    %b %b\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
 QUIET_INSTALL = @printf '    %b %b\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
 endif
 
 REDIS_SERVER_NAME=redis-server
 REDIS_SENTINEL_NAME=redis-sentinel
-REDIS_SERVER_OBJ=adlist.o ae.o anet.o dict.o redis.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o
+REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o geo.o
+REDIS_GEOHASH_OBJ=../deps/geohash-int/geohash.o ../deps/geohash-int/geohash_helper.o
 REDIS_CLI_NAME=redis-cli
-REDIS_CLI_OBJ=anet.o sds.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o
+REDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o
 REDIS_BENCHMARK_NAME=redis-benchmark
-REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o sds.o adlist.o zmalloc.o redis-benchmark.o
-REDIS_CHECK_DUMP_NAME=redis-check-dump
-REDIS_CHECK_DUMP_OBJ=redis-check-dump.o lzf_c.o lzf_d.o crc64.o
+REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o
+REDIS_CHECK_RDB_NAME=redis-check-rdb
 REDIS_CHECK_AOF_NAME=redis-check-aof
 REDIS_CHECK_AOF_OBJ=redis-check-aof.o
 
-all: $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_DUMP_NAME) $(REDIS_CHECK_AOF_NAME)
+all: $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME)
 	@echo ""
 	@echo "Hint: It's a good idea to run 'make test' ;)"
 	@echo ""
 
 .PHONY: all
 
@@ -165,42 +169,42 @@
 ifneq ($(strip $(PREV_FINAL_LDFLAGS)), $(strip $(FINAL_LDFLAGS)))
 .make-prerequisites: persist-settings
 endif
 
 # redis-server
 $(REDIS_SERVER_NAME): $(REDIS_SERVER_OBJ)
-	$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a $(FINAL_LIBS)
+	$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a $(REDIS_GEOHASH_OBJ) $(FINAL_LIBS)
 
 # redis-sentinel
 $(REDIS_SENTINEL_NAME): $(REDIS_SERVER_NAME)
 	$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME)
 
+# redis-check-rdb
+$(REDIS_CHECK_RDB_NAME): $(REDIS_SERVER_NAME)
+	$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_RDB_NAME)
+
 # redis-cli
 $(REDIS_CLI_NAME): $(REDIS_CLI_OBJ)
 	$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o $(FINAL_LIBS)
 
 # redis-benchmark
 $(REDIS_BENCHMARK_NAME): $(REDIS_BENCHMARK_OBJ)
 	$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a $(FINAL_LIBS)
 
-# redis-check-dump
-$(REDIS_CHECK_DUMP_NAME): $(REDIS_CHECK_DUMP_OBJ)
-	$(REDIS_LD) -o $@ $^ $(FINAL_LIBS)
-
 # redis-check-aof
 $(REDIS_CHECK_AOF_NAME): $(REDIS_CHECK_AOF_OBJ)
 	$(REDIS_LD) -o $@ $^ $(FINAL_LIBS)
 
 # Because the jemalloc.h header is generated as a part of the jemalloc build,
 # building it should complete before building any other object. Instead of
 # depending on a single artifact, build all dependencies first.
 %.o: %.c .make-prerequisites
 	$(REDIS_CC) -c $<
 
 clean:
-	rm -rf $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_DUMP_NAME) $(REDIS_CHECK_AOF_NAME) *.o *.gcda *.gcno *.gcov redis.info lcov-html
+	rm -rf $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME) *.o *.gcda *.gcno *.gcov redis.info lcov-html
 
 .PHONY: clean
 
 distclean: clean
 	-(cd ../deps && $(MAKE) distclean)
 	-(rm -f .make-*)
@@ -218,12 +222,16 @@
 lcov:
 	$(MAKE) gcov
 	@(set -e; cd ..; ./runtest --clients 1)
 	@geninfo -o redis.info .
 	@genhtml --legend -o lcov-html redis.info
 
+test-sds: sds.c sds.h
+	$(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN -o /tmp/sds_test
+	/tmp/sds_test
+
 .PHONY: lcov
 
 bench: $(REDIS_BENCHMARK_NAME)
 	./$(REDIS_BENCHMARK_NAME)
 
 32bit:
@@ -246,9 +254,9 @@
 
 install: all
 	@mkdir -p $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_BENCHMARK_NAME) $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_CLI_NAME) $(INSTALL_BIN)
-	$(REDIS_INSTALL) $(REDIS_CHECK_DUMP_NAME) $(INSTALL_BIN)
+	$(REDIS_INSTALL) $(REDIS_CHECK_RDB_NAME) $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_CHECK_AOF_NAME) $(INSTALL_BIN)
 	@ln -sf $(REDIS_SERVER_NAME) $(INSTALL_BIN)/$(REDIS_SENTINEL_NAME)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/Makefile.dep /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/Makefile.dep
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/Makefile.dep	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/Makefile.dep	2016-05-06 15:11:36.000000000 +0800
@@ -2,141 +2,180 @@
 ae.o: ae.c ae.h zmalloc.h config.h ae_kqueue.c ae_epoll.c ae_select.c ae_evport.c
 ae_epoll.o: ae_epoll.c
 ae_evport.o: ae_evport.c
 ae_kqueue.o: ae_kqueue.c
 ae_select.o: ae_select.c
 anet.o: anet.c fmacros.h anet.h
-aof.o: aof.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
+aof.o: aof.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
  bio.h
-bio.o: bio.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
+bio.o: bio.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
  bio.h
-bitops.o: bitops.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-blocked.o: blocked.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-cluster.o: cluster.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
- cluster.h endianconv.h
-config.o: config.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
+bitops.o: bitops.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+blocked.o: blocked.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+cluster.o: cluster.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
  cluster.h
-crc16.o: crc16.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
+config.o: config.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
+ cluster.h
+crc16.o: crc16.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
 crc64.o: crc64.c
-db.o: db.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
+db.o: db.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
  cluster.h
-debug.o: debug.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
- sha1.h crc64.h bio.h
+debug.o: debug.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
+ bio.h
 dict.o: dict.c fmacros.h dict.h zmalloc.h redisassert.h
 endianconv.o: endianconv.c
-hyperloglog.o: hyperloglog.c redis.h fmacros.h config.h \
+geo.o: geo.c geo.h server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
+ ../deps/geohash-int/geohash_helper.h ../deps/geohash-int/geohash.h
+hyperloglog.o: hyperloglog.c server.h fmacros.h config.h solarisfixes.h \
  ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
  adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
- sparkline.h rdb.h rio.h
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
 intset.o: intset.c intset.h zmalloc.h endianconv.h config.h
-latency.o: latency.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
+latency.o: latency.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
 lzf_c.o: lzf_c.c lzfP.h
 lzf_d.o: lzf_d.c lzfP.h
 memtest.o: memtest.c config.h
-multi.o: multi.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-networking.o: networking.c redis.h fmacros.h config.h \
+multi.o: multi.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+networking.o: networking.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+notify.o: notify.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+object.o: object.c server.h fmacros.h config.h solarisfixes.h \
  ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
  adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
- sparkline.h rdb.h rio.h
-notify.o: notify.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-object.o: object.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
 pqsort.o: pqsort.c
-pubsub.o: pubsub.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
+pubsub.o: pubsub.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+quicklist.o: quicklist.c quicklist.h zmalloc.h ziplist.h util.h sds.h \
+ lzf.h
 rand.o: rand.c
-rdb.o: rdb.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
- lzf.h zipmap.h endianconv.h
-redis-benchmark.o: redis-benchmark.c fmacros.h ae.h \
- ../deps/hiredis/hiredis.h sds.h adlist.h zmalloc.h
+rdb.o: rdb.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
+ lzf.h
+redis-benchmark.o: redis-benchmark.c fmacros.h ../deps/hiredis/sds.h ae.h \
+ ../deps/hiredis/hiredis.h adlist.h zmalloc.h
 redis-check-aof.o: redis-check-aof.c fmacros.h config.h
-redis-check-dump.o: redis-check-dump.c lzf.h crc64.h
+redis-check-rdb.o: redis-check-rdb.c server.h fmacros.h config.h \
+ solarisfixes.h ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h \
+ sds.h dict.h adlist.h zmalloc.h anet.h ziplist.h intset.h version.h \
+ util.h latency.h sparkline.h quicklist.h zipmap.h sha1.h endianconv.h \
+ crc64.h rdb.h rio.h lzf.h
 redis-cli.o: redis-cli.c fmacros.h version.h ../deps/hiredis/hiredis.h \
- sds.h zmalloc.h ../deps/linenoise/linenoise.h help.h anet.h ae.h
-redis.o: redis.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
- cluster.h slowlog.h bio.h asciilogo.h
+ ../deps/hiredis/sds.h zmalloc.h ../deps/linenoise/linenoise.h help.h \
+ anet.h ae.h
 release.o: release.c release.h version.h crc64.h
-replication.o: replication.c redis.h fmacros.h config.h \
+replication.o: replication.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+rio.o: rio.c fmacros.h rio.h sds.h util.h crc64.h config.h server.h \
+ solarisfixes.h ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h \
+ dict.h adlist.h zmalloc.h anet.h ziplist.h intset.h version.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h rdb.h
+scripting.o: scripting.c server.h fmacros.h config.h solarisfixes.h \
  ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
  adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
- sparkline.h rdb.h rio.h
-rio.o: rio.c fmacros.h rio.h sds.h util.h crc64.h config.h redis.h \
- ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h dict.h adlist.h \
- zmalloc.h anet.h ziplist.h intset.h version.h latency.h sparkline.h \
- rdb.h
-scripting.o: scripting.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
- sha1.h rand.h ../deps/lua/src/lauxlib.h ../deps/lua/src/lua.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
+ rand.h cluster.h ../deps/lua/src/lauxlib.h ../deps/lua/src/lua.h \
  ../deps/lua/src/lualib.h
-sds.o: sds.c sds.h zmalloc.h
-sentinel.o: sentinel.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
+sds.o: sds.c sds.h sdsalloc.h zmalloc.h
+sentinel.o: sentinel.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
  ../deps/hiredis/hiredis.h ../deps/hiredis/async.h \
  ../deps/hiredis/hiredis.h
+server.o: server.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
+ cluster.h slowlog.h bio.h asciilogo.h
 setproctitle.o: setproctitle.c
-sha1.o: sha1.c sha1.h config.h
-slowlog.o: slowlog.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
+sha1.o: sha1.c solarisfixes.h sha1.h config.h
+slowlog.o: slowlog.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
  slowlog.h
-sort.o: sort.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h \
+sort.o: sort.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h \
  pqsort.h
-sparkline.o: sparkline.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-syncio.o: syncio.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-t_hash.o: t_hash.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-t_list.o: t_list.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-t_set.o: t_set.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-t_string.o: t_string.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-t_zset.o: t_zset.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
- ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
- ziplist.h intset.h version.h util.h latency.h sparkline.h rdb.h rio.h
-util.o: util.c fmacros.h util.h sds.h
+sparkline.o: sparkline.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+syncio.o: syncio.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+t_hash.o: t_hash.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+t_list.o: t_list.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+t_set.o: t_set.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+t_string.o: t_string.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+t_zset.o: t_zset.c server.h fmacros.h config.h solarisfixes.h \
+ ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
+ adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h latency.h \
+ sparkline.h quicklist.h zipmap.h sha1.h endianconv.h crc64.h rdb.h rio.h
+util.o: util.c fmacros.h util.h sds.h sha1.h
 ziplist.o: ziplist.c zmalloc.h util.h sds.h ziplist.h endianconv.h \
  config.h redisassert.h
 zipmap.o: zipmap.c zmalloc.h endianconv.h config.h
 zmalloc.o: zmalloc.c config.h zmalloc.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/.make-settings /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/.make-settings
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/.make-settings	2017-09-27 22:47:47.026963701 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/.make-settings	2017-09-27 22:49:08.246960725 +0800
@@ -1,10 +1,10 @@
-STD=-std=c99 -pedantic
+STD=-std=c99 -pedantic -DREDIS_STATIC=
 WARN=-Wall -W
 OPT=-O2
 MALLOC=jemalloc
 CFLAGS=
 LDFLAGS=
 REDIS_CFLAGS=
 REDIS_LDFLAGS=
-PREV_FINAL_CFLAGS=-std=c99 -pedantic -Wall -W -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include
+PREV_FINAL_CFLAGS=-std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include
 PREV_FINAL_LDFLAGS= -g -ggdb -rdynamic
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/memtest.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/memtest.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/memtest.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/memtest.c	2016-05-06 15:11:36.000000000 +0800
@@ -23,13 +23,13 @@
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-
+#include <stdint.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <assert.h>
 #include <limits.h>
 #include <errno.h>
@@ -87,72 +87,84 @@
     fflush(stdout);
 }
 
 /* Test that addressing is fine. Every location is populated with its own
  * address, and finally verified. This test is very fast but may detect
  * ASAP big issues with the memory subsystem. */
-void memtest_addressing(unsigned long *l, size_t bytes) {
+int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {
     unsigned long words = bytes/sizeof(unsigned long);
     unsigned long j, *p;
 
     /* Fill */
     p = l;
     for (j = 0; j < words; j++) {
         *p = (unsigned long)p;
         p++;
-        if ((j & 0xffff) == 0) memtest_progress_step(j,words*2,'A');
+        if ((j & 0xffff) == 0 && interactive)
+            memtest_progress_step(j,words*2,'A');
     }
     /* Test */
     p = l;
     for (j = 0; j < words; j++) {
         if (*p != (unsigned long)p) {
-            printf("\n*** MEMORY ADDRESSING ERROR: %p contains %lu\n",
-                (void*) p, *p);
-            exit(1);
+            if (interactive) {
+                printf("\n*** MEMORY ADDRESSING ERROR: %p contains %lu\n",
+                    (void*) p, *p);
+                exit(1);
+            }
+            return 1;
         }
         p++;
-        if ((j & 0xffff) == 0) memtest_progress_step(j+words,words*2,'A');
+        if ((j & 0xffff) == 0 && interactive)
+            memtest_progress_step(j+words,words*2,'A');
     }
+    return 0;
 }
 
 /* Fill words stepping a single page at every write, so we continue to
  * touch all the pages in the smallest amount of time reducing the
  * effectiveness of caches, and making it hard for the OS to transfer
- * pages on the swap. */
-void memtest_fill_random(unsigned long *l, size_t bytes) {
+ * pages on the swap.
+ *
+ * In this test we can't call rand() since the system may be completely
+ * unable to handle library calls, so we have to resort to our own
+ * PRNG that only uses local state. We use an xorshift* PRNG. */
+#define xorshift64star_next() do { \
+        rseed ^= rseed >> 12; \
+        rseed ^= rseed << 25; \
+        rseed ^= rseed >> 27; \
+        rout = rseed * UINT64_C(2685821657736338717); \
+} while(0)
+
+void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {
     unsigned long step = 4096/sizeof(unsigned long);
     unsigned long words = bytes/sizeof(unsigned long)/2;
     unsigned long iwords = words/step;  /* words per iteration */
     unsigned long off, w, *l1, *l2;
+    uint64_t rseed = UINT64_C(0xd13133de9afdb566); /* Just a random seed. */
+    uint64_t rout = 0;
 
     assert((bytes & 4095) == 0);
     for (off = 0; off < step; off++) {
         l1 = l+off;
         l2 = l1+words;
         for (w = 0; w < iwords; w++) {
-#ifdef MEMTEST_32BIT
-            *l1 = *l2 = ((unsigned long)     (rand()&0xffff)) |
-                        (((unsigned long)    (rand()&0xffff)) << 16);
-#else
-            *l1 = *l2 = ((unsigned long)     (rand()&0xffff)) |
-                        (((unsigned long)    (rand()&0xffff)) << 16) |
-                        (((unsigned long)    (rand()&0xffff)) << 32) |
-                        (((unsigned long)    (rand()&0xffff)) << 48);
-#endif
+            xorshift64star_next();
+            *l1 = *l2 = (unsigned long) rout;
             l1 += step;
             l2 += step;
-            if ((w & 0xffff) == 0)
+            if ((w & 0xffff) == 0 && interactive)
                 memtest_progress_step(w+iwords*off,words,'R');
         }
     }
 }
 
 /* Like memtest_fill_random() but uses the two specified values to fill
  * memory, in an alternated way (v1|v2|v1|v2|...) */
 void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,
-                        unsigned long v2, char sym)
+                        unsigned long v2, char sym, int interactive)
 {
     unsigned long step = 4096/sizeof(unsigned long);
     unsigned long words = bytes/sizeof(unsigned long)/2;
     unsigned long iwords = words/step;  /* words per iteration */
     unsigned long off, w, *l1, *l2, v;
 
@@ -170,114 +182,179 @@
                         (((unsigned long)    v) << 16) |
                         (((unsigned long)    v) << 32) |
                         (((unsigned long)    v) << 48);
 #endif
             l1 += step;
             l2 += step;
-            if ((w & 0xffff) == 0)
+            if ((w & 0xffff) == 0 && interactive)
                 memtest_progress_step(w+iwords*off,words,sym);
         }
     }
 }
 
-void memtest_compare(unsigned long *l, size_t bytes) {
+int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
     unsigned long words = bytes/sizeof(unsigned long)/2;
     unsigned long w, *l1, *l2;
 
     assert((bytes & 4095) == 0);
     l1 = l;
     l2 = l1+words;
     for (w = 0; w < words; w++) {
         if (*l1 != *l2) {
-            printf("\n*** MEMORY ERROR DETECTED: %p != %p (%lu vs %lu)\n",
-                (void*)l1, (void*)l2, *l1, *l2);
-            exit(1);
+            if (interactive) {
+                printf("\n*** MEMORY ERROR DETECTED: %p != %p (%lu vs %lu)\n",
+                    (void*)l1, (void*)l2, *l1, *l2);
+                exit(1);
+            }
+            return 1;
         }
         l1 ++;
         l2 ++;
-        if ((w & 0xffff) == 0) memtest_progress_step(w,words,'=');
+        if ((w & 0xffff) == 0 && interactive)
+            memtest_progress_step(w,words,'=');
     }
+    return 0;
 }
 
-void memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times) {
+int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,
+                          int interactive)
+{
     int j;
+    int errors = 0;
 
     for (j = 0; j < times; j++) {
-        memtest_progress_start("Compare",pass);
-        memtest_compare(m,bytes);
-        memtest_progress_end();
+        if (interactive) memtest_progress_start("Compare",pass);
+        errors += memtest_compare(m,bytes,interactive);
+        if (interactive) memtest_progress_end();
     }
+    return errors;
 }
 
-void memtest_test(size_t megabytes, int passes) {
-    size_t bytes = megabytes*1024*1024;
-    unsigned long *m = malloc(bytes);
+/* Test the specified memory. The number of bytes must be multiple of 4096.
+ * If interactive is true the program exists with an error and prints
+ * ASCII arts to show progresses. Instead when interactive is 0, it can
+ * be used as an API call, and returns 1 if memory errors were found or
+ * 0 if there were no errors detected. */
+int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {
     int pass = 0;
+    int errors = 0;
 
-    if (m == NULL) {
-        fprintf(stderr,"Unable to allocate %zu megabytes: %s",
-            megabytes, strerror(errno));
-        exit(1);
-    }
     while (pass != passes) {
         pass++;
 
-        memtest_progress_start("Addressing test",pass);
-        memtest_addressing(m,bytes);
-        memtest_progress_end();
-
-        memtest_progress_start("Random fill",pass);
-        memtest_fill_random(m,bytes);
-        memtest_progress_end();
-        memtest_compare_times(m,bytes,pass,4);
-
-        memtest_progress_start("Solid fill",pass);
-        memtest_fill_value(m,bytes,0,(unsigned long)-1,'S');
-        memtest_progress_end();
-        memtest_compare_times(m,bytes,pass,4);
-
-        memtest_progress_start("Checkerboard fill",pass);
-        memtest_fill_value(m,bytes,ULONG_ONEZERO,ULONG_ZEROONE,'C');
-        memtest_progress_end();
-        memtest_compare_times(m,bytes,pass,4);
+        if (interactive) memtest_progress_start("Addressing test",pass);
+        errors += memtest_addressing(m,bytes,interactive);
+        if (interactive) memtest_progress_end();
+
+        if (interactive) memtest_progress_start("Random fill",pass);
+        memtest_fill_random(m,bytes,interactive);
+        if (interactive) memtest_progress_end();
+        errors += memtest_compare_times(m,bytes,pass,4,interactive);
+
+        if (interactive) memtest_progress_start("Solid fill",pass);
+        memtest_fill_value(m,bytes,0,(unsigned long)-1,'S',interactive);
+        if (interactive) memtest_progress_end();
+        errors += memtest_compare_times(m,bytes,pass,4,interactive);
+
+        if (interactive) memtest_progress_start("Checkerboard fill",pass);
+        memtest_fill_value(m,bytes,ULONG_ONEZERO,ULONG_ZEROONE,'C',interactive);
+        if (interactive) memtest_progress_end();
+        errors += memtest_compare_times(m,bytes,pass,4,interactive);
     }
-    free(m);
+    return errors;
+}
+
+/* A version of memtest_test() that tests memory in small pieces
+ * in order to restore the memory content at exit.
+ *
+ * One problem we have with this approach, is that the cache can avoid
+ * real memory accesses, and we can't test big chunks of memory at the
+ * same time, because we need to backup them on the stack (the allocator
+ * may not be usable or we may be already in an out of memory condition).
+ * So what we do is to try to trash the cache with useless memory accesses
+ * between the fill and compare cycles. */
+#define MEMTEST_BACKUP_WORDS (1024*(1024/sizeof(long)))
+/* Random accesses of MEMTEST_DECACHE_SIZE are performed at the start and
+ * end of the region between fill and compare cycles in order to trash
+ * the cache. */
+#define MEMTEST_DECACHE_SIZE (1024*8)
+int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {
+    unsigned long backup[MEMTEST_BACKUP_WORDS];
+    unsigned long *p = m;
+    unsigned long *end = (unsigned long*) (((unsigned char*)m)+(bytes-MEMTEST_DECACHE_SIZE));
+    size_t left = bytes;
+    int errors = 0;
+
+    if (bytes & 4095) return 0; /* Can't test across 4k page boundaries. */
+    if (bytes < 4096*2) return 0; /* Can't test a single page. */
+
+    while(left) {
+        /* If we have to test a single final page, go back a single page
+         * so that we can test two pages, since the code can't test a single
+         * page but at least two. */
+        if (left == 4096) {
+            left += 4096;
+            p -= 4096/sizeof(unsigned long);
+        }
+
+        int pass = 0;
+        size_t len = (left > sizeof(backup)) ? sizeof(backup) : left;
+
+        /* Always test an even number of pages. */
+        if (len/4096 % 2) len -= 4096;
+
+        memcpy(backup,p,len); /* Backup. */
+        while(pass != passes) {
+            pass++;
+            errors += memtest_addressing(p,len,0);
+            memtest_fill_random(p,len,0);
+            if (bytes >= MEMTEST_DECACHE_SIZE) {
+                memtest_compare_times(m,MEMTEST_DECACHE_SIZE,pass,1,0);
+                memtest_compare_times(end,MEMTEST_DECACHE_SIZE,pass,1,0);
+            }
+            errors += memtest_compare_times(p,len,pass,4,0);
+            memtest_fill_value(p,len,0,(unsigned long)-1,'S',0);
+            if (bytes >= MEMTEST_DECACHE_SIZE) {
+                memtest_compare_times(m,MEMTEST_DECACHE_SIZE,pass,1,0);
+                memtest_compare_times(end,MEMTEST_DECACHE_SIZE,pass,1,0);
+            }
+            errors += memtest_compare_times(p,len,pass,4,0);
+            memtest_fill_value(p,len,ULONG_ONEZERO,ULONG_ZEROONE,'C',0);
+            if (bytes >= MEMTEST_DECACHE_SIZE) {
+                memtest_compare_times(m,MEMTEST_DECACHE_SIZE,pass,1,0);
+                memtest_compare_times(end,MEMTEST_DECACHE_SIZE,pass,1,0);
+            }
+            errors += memtest_compare_times(p,len,pass,4,0);
+        }
+        memcpy(p,backup,len); /* Restore. */
+        left -= len;
+        p += len/sizeof(unsigned long);
+    }
+    return errors;
 }
 
-void memtest_non_destructive_invert(void *addr, size_t size) {
-    volatile unsigned long *p = addr;
-    size_t words = size / sizeof(unsigned long);
-    size_t j;
-
-    /* Invert */
-    for (j = 0; j < words; j++)
-        p[j] = ~p[j];
-}
-
-void memtest_non_destructive_swap(void *addr, size_t size) {
-    volatile unsigned long *p = addr;
-    size_t words = size / sizeof(unsigned long);
-    size_t j;
-
-    /* Swap */
-    for (j = 0; j < words; j += 2) {
-        unsigned long a, b;
-
-        a = p[j];
-        b = p[j+1];
-        p[j] = b;
-        p[j+1] = a;
+/* Perform an interactive test allocating the specified number of megabytes. */
+void memtest_alloc_and_test(size_t megabytes, int passes) {
+    size_t bytes = megabytes*1024*1024;
+    unsigned long *m = malloc(bytes);
+
+    if (m == NULL) {
+        fprintf(stderr,"Unable to allocate %zu megabytes: %s",
+            megabytes, strerror(errno));
+        exit(1);
     }
+    memtest_test(m,bytes,passes,1);
+    free(m);
 }
 
 void memtest(size_t megabytes, int passes) {
     if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
         ws.ws_col = 80;
         ws.ws_row = 20;
     }
-    memtest_test(megabytes,passes);
+    memtest_alloc_and_test(megabytes,passes);
     printf("\nYour memory passed this test.\n");
     printf("Please if you are still in doubt use the following two tools:\n");
     printf("1) memtest86: http://www.memtest86.com/\n");
     printf("2) memtester: http://pyropus.ca/software/memtester/\n");
     exit(0);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/memtest.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/memtest.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/memtest.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/memtest.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/multi.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/multi.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/multi.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/multi.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,24 +24,24 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 /* ================================ MULTI/EXEC ============================== */
 
 /* Client state initialization for MULTI/EXEC */
-void initClientMultiState(redisClient *c) {
+void initClientMultiState(client *c) {
     c->mstate.commands = NULL;
     c->mstate.count = 0;
 }
 
 /* Release all the resources associated with MULTI/EXEC state */
-void freeClientMultiState(redisClient *c) {
+void freeClientMultiState(client *c) {
     int j;
 
     for (j = 0; j < c->mstate.count; j++) {
         int i;
         multiCmd *mc = c->mstate.commands+j;
 
@@ -50,13 +50,13 @@
         zfree(mc->argv);
     }
     zfree(c->mstate.commands);
 }
 
 /* Add a new command into the MULTI commands queue */
-void queueMultiCommand(redisClient *c) {
+void queueMultiCommand(client *c) {
     multiCmd *mc;
     int j;
 
     c->mstate.commands = zrealloc(c->mstate.commands,
             sizeof(multiCmd)*(c->mstate.count+1));
     mc = c->mstate.commands+c->mstate.count;
@@ -66,74 +66,74 @@
     memcpy(mc->argv,c->argv,sizeof(robj*)*c->argc);
     for (j = 0; j < c->argc; j++)
         incrRefCount(mc->argv[j]);
     c->mstate.count++;
 }
 
-void discardTransaction(redisClient *c) {
+void discardTransaction(client *c) {
     freeClientMultiState(c);
     initClientMultiState(c);
-    c->flags &= ~(REDIS_MULTI|REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC);
+    c->flags &= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);
     unwatchAllKeys(c);
 }
 
 /* Flag the transacation as DIRTY_EXEC so that EXEC will fail.
  * Should be called every time there is an error while queueing a command. */
-void flagTransaction(redisClient *c) {
-    if (c->flags & REDIS_MULTI)
-        c->flags |= REDIS_DIRTY_EXEC;
+void flagTransaction(client *c) {
+    if (c->flags & CLIENT_MULTI)
+        c->flags |= CLIENT_DIRTY_EXEC;
 }
 
-void multiCommand(redisClient *c) {
-    if (c->flags & REDIS_MULTI) {
+void multiCommand(client *c) {
+    if (c->flags & CLIENT_MULTI) {
         addReplyError(c,"MULTI calls can not be nested");
         return;
     }
-    c->flags |= REDIS_MULTI;
+    c->flags |= CLIENT_MULTI;
     addReply(c,shared.ok);
 }
 
-void discardCommand(redisClient *c) {
-    if (!(c->flags & REDIS_MULTI)) {
+void discardCommand(client *c) {
+    if (!(c->flags & CLIENT_MULTI)) {
         addReplyError(c,"DISCARD without MULTI");
         return;
     }
     discardTransaction(c);
     addReply(c,shared.ok);
 }
 
 /* Send a MULTI command to all the slaves and AOF file. Check the execCommand
  * implementation for more information. */
-void execCommandPropagateMulti(redisClient *c) {
+void execCommandPropagateMulti(client *c) {
     robj *multistring = createStringObject("MULTI",5);
 
     propagate(server.multiCommand,c->db->id,&multistring,1,
-              REDIS_PROPAGATE_AOF|REDIS_PROPAGATE_REPL);
+              PROPAGATE_AOF|PROPAGATE_REPL);
     decrRefCount(multistring);
 }
 
-void execCommand(redisClient *c) {
+void execCommand(client *c) {
     int j;
     robj **orig_argv;
     int orig_argc;
     struct redisCommand *orig_cmd;
     int must_propagate = 0; /* Need to propagate MULTI/EXEC to AOF / slaves? */
 
-    if (!(c->flags & REDIS_MULTI)) {
+    if (!(c->flags & CLIENT_MULTI)) {
         addReplyError(c,"EXEC without MULTI");
         return;
     }
 
     /* Check if we need to abort the EXEC because:
      * 1) Some WATCHed key was touched.
      * 2) There was a previous error while queueing commands.
      * A failed EXEC in the first case returns a multi bulk nil object
      * (technically it is not an error but a special behavior), while
      * in the second an EXECABORT error is returned. */
-    if (c->flags & (REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC)) {
-        addReply(c, c->flags & REDIS_DIRTY_EXEC ? shared.execaborterr :
+    if (c->flags & (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC)) {
+        addReply(c, c->flags & CLIENT_DIRTY_EXEC ? shared.execaborterr :
                                                   shared.nullmultibulk);
         discardTransaction(c);
         goto handle_monitor;
     }
 
     /* Exec all the queued commands */
@@ -148,18 +148,18 @@
         c->cmd = c->mstate.commands[j].cmd;
 
         /* Propagate a MULTI request once we encounter the first write op.
          * This way we'll deliver the MULTI/..../EXEC block as a whole and
          * both the AOF and the replication link will have the same consistency
          * and atomicity guarantees. */
-        if (!must_propagate && !(c->cmd->flags & REDIS_CMD_READONLY)) {
+        if (!must_propagate && !(c->cmd->flags & CMD_READONLY)) {
             execCommandPropagateMulti(c);
             must_propagate = 1;
         }
 
-        call(c,REDIS_CALL_FULL);
+        call(c,CMD_CALL_FULL);
 
         /* Commands may alter argc/argv, restore mstate. */
         c->mstate.commands[j].argc = c->argc;
         c->mstate.commands[j].argv = c->argv;
         c->mstate.commands[j].cmd = c->cmd;
     }
@@ -172,13 +172,13 @@
     if (must_propagate) server.dirty++;
 
 handle_monitor:
     /* Send EXEC to clients waiting data from MONITOR. We do it here
      * since the natural order of commands execution is actually:
      * MUTLI, EXEC, ... commands inside transaction ...
-     * Instead EXEC is flagged as REDIS_CMD_SKIP_MONITOR in the command
+     * Instead EXEC is flagged as CMD_SKIP_MONITOR in the command
      * table, and we do it here with correct ordering. */
     if (listLength(server.monitors) && !server.loading)
         replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
 }
 
 /* ===================== WATCH (CAS alike for MULTI/EXEC) ===================
@@ -196,13 +196,13 @@
 typedef struct watchedKey {
     robj *key;
     redisDb *db;
 } watchedKey;
 
 /* Watch for the specified key */
-void watchForKey(redisClient *c, robj *key) {
+void watchForKey(client *c, robj *key) {
     list *clients = NULL;
     listIter li;
     listNode *ln;
     watchedKey *wk;
 
     /* Check if we are already watching for this key */
@@ -227,13 +227,13 @@
     incrRefCount(key);
     listAddNodeTail(c->watched_keys,wk);
 }
 
 /* Unwatch all the keys watched by this client. To clean the EXEC dirty
  * flag is up to the caller. */
-void unwatchAllKeys(redisClient *c) {
+void unwatchAllKeys(client *c) {
     listIter li;
     listNode *ln;
 
     if (listLength(c->watched_keys) == 0) return;
     listRewind(c->watched_keys,&li);
     while((ln = listNext(&li))) {
@@ -241,13 +241,13 @@
         watchedKey *wk;
 
         /* Lookup the watched key -> clients list and remove the client
          * from the list */
         wk = listNodeValue(ln);
         clients = dictFetchValue(wk->db->watched_keys, wk->key);
-        redisAssertWithInfo(c,NULL,clients != NULL);
+        serverAssertWithInfo(c,NULL,clients != NULL);
         listDelNode(clients,listSearchKey(clients,c));
         /* Kill the entry at all if this was the only client */
         if (listLength(clients) == 0)
             dictDelete(wk->db->watched_keys, wk->key);
         /* Remove this watched key from the client->watched list */
         listDelNode(c->watched_keys,ln);
@@ -264,19 +264,19 @@
     listNode *ln;
 
     if (dictSize(db->watched_keys) == 0) return;
     clients = dictFetchValue(db->watched_keys, key);
     if (!clients) return;
 
-    /* Mark all the clients watching this key as REDIS_DIRTY_CAS */
+    /* Mark all the clients watching this key as CLIENT_DIRTY_CAS */
     /* Check if we are already watching for this key */
     listRewind(clients,&li);
     while((ln = listNext(&li))) {
-        redisClient *c = listNodeValue(ln);
+        client *c = listNodeValue(ln);
 
-        c->flags |= REDIS_DIRTY_CAS;
+        c->flags |= CLIENT_DIRTY_CAS;
     }
 }
 
 /* On FLUSHDB or FLUSHALL all the watched keys that are present before the
  * flush but will be deleted as effect of the flushing operation should
  * be touched. "dbid" is the DB that's getting the flush. -1 if it is
@@ -285,39 +285,39 @@
     listIter li1, li2;
     listNode *ln;
 
     /* For every client, check all the waited keys */
     listRewind(server.clients,&li1);
     while((ln = listNext(&li1))) {
-        redisClient *c = listNodeValue(ln);
+        client *c = listNodeValue(ln);
         listRewind(c->watched_keys,&li2);
         while((ln = listNext(&li2))) {
             watchedKey *wk = listNodeValue(ln);
 
             /* For every watched key matching the specified DB, if the
              * key exists, mark the client as dirty, as the key will be
              * removed. */
             if (dbid == -1 || wk->db->id == dbid) {
                 if (dictFind(wk->db->dict, wk->key->ptr) != NULL)
-                    c->flags |= REDIS_DIRTY_CAS;
+                    c->flags |= CLIENT_DIRTY_CAS;
             }
         }
     }
 }
 
-void watchCommand(redisClient *c) {
+void watchCommand(client *c) {
     int j;
 
-    if (c->flags & REDIS_MULTI) {
+    if (c->flags & CLIENT_MULTI) {
         addReplyError(c,"WATCH inside MULTI is not allowed");
         return;
     }
     for (j = 1; j < c->argc; j++)
         watchForKey(c,c->argv[j]);
     addReply(c,shared.ok);
 }
 
-void unwatchCommand(redisClient *c) {
+void unwatchCommand(client *c) {
     unwatchAllKeys(c);
-    c->flags &= (~REDIS_DIRTY_CAS);
+    c->flags &= (~CLIENT_DIRTY_CAS);
     addReply(c,shared.ok);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/multi.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/multi.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/multi.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/multi.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/networking.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/networking.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/networking.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/networking.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,33 +24,33 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include <sys/uio.h>
 #include <math.h>
 
-static void setProtocolError(redisClient *c, int pos);
+static void setProtocolError(client *c, int pos);
 
-/* To evaluate the output buffer size of a client we need to get size of
- * allocated objects, however we can't used zmalloc_size() directly on sds
- * strings because of the trick they use to work (the header is before the
- * returned pointer), so we use this helper function. */
-size_t zmalloc_size_sds(sds s) {
-    return zmalloc_size(s-sizeof(struct sdshdr));
+/* Return the size consumed from the allocator, for the specified SDS string,
+ * including internal fragmentation. This function is used in order to compute
+ * the client output buffer size. */
+size_t sdsZmallocSize(sds s) {
+    void *sh = sdsAllocPtr(s);
+    return zmalloc_size(sh);
 }
 
 /* Return the amount of memory used by the sds string at object->ptr
  * for a string object. */
 size_t getStringObjectSdsUsedMemory(robj *o) {
-    redisAssertWithInfo(NULL,o,o->type == REDIS_STRING);
+    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
     switch(o->encoding) {
-    case REDIS_ENCODING_RAW: return zmalloc_size_sds(o->ptr);
-    case REDIS_ENCODING_EMBSTR: return sdslen(o->ptr);
+    case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
+    case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
     default: return 0; /* Just integer encoding for now. */
     }
 }
 
 void *dupClientReplyValue(void *o) {
     incrRefCount((robj*)o);
@@ -58,17 +58,17 @@
 }
 
 int listMatchObjects(void *a, void *b) {
     return equalStringObjects(a,b);
 }
 
-redisClient *createClient(int fd) {
-    redisClient *c = zmalloc(sizeof(redisClient));
+client *createClient(int fd) {
+    client *c = zmalloc(sizeof(client));
 
     /* passing -1 as fd it is possible to create a non connected client.
-     * This is useful since all the Redis commands needs to be executed
+     * This is useful since all the commands needs to be executed
      * in the context of a client. When commands are executed in other
      * contexts (for instance a Lua script) we need a non connected client. */
     if (fd != -1) {
         anetNonBlock(NULL,fd);
         anetEnableTcpNoDelay(NULL,fd);
         if (server.tcpkeepalive)
@@ -96,25 +96,25 @@
     c->multibulklen = 0;
     c->bulklen = -1;
     c->sentlen = 0;
     c->flags = 0;
     c->ctime = c->lastinteraction = server.unixtime;
     c->authenticated = 0;
-    c->replstate = REDIS_REPL_NONE;
+    c->replstate = REPL_STATE_NONE;
     c->repl_put_online_on_ack = 0;
     c->reploff = 0;
     c->repl_ack_off = 0;
     c->repl_ack_time = 0;
     c->slave_listening_port = 0;
     c->slave_capa = SLAVE_CAPA_NONE;
     c->reply = listCreate();
     c->reply_bytes = 0;
     c->obuf_soft_limit_reached_time = 0;
     listSetFreeMethod(c->reply,decrRefCountVoid);
     listSetDupMethod(c->reply,dupClientReplyValue);
-    c->btype = REDIS_BLOCKED_NONE;
+    c->btype = BLOCKED_NONE;
     c->bpop.timeout = 0;
     c->bpop.keys = dictCreate(&setDictType,NULL);
     c->bpop.target = NULL;
     c->bpop.numreplicas = 0;
     c->bpop.reploffset = 0;
     c->woff = 0;
@@ -130,67 +130,74 @@
 }
 
 /* This function is called every time we are going to transmit new data
  * to the client. The behavior is the following:
  *
  * If the client should receive new data (normal clients will) the function
- * returns REDIS_OK, and make sure to install the write handler in our event
+ * returns C_OK, and make sure to install the write handler in our event
  * loop so that when the socket is writable new data gets written.
  *
  * If the client should not receive new data, because it is a fake client
  * (used to load AOF in memory), a master or because the setup of the write
- * handler failed, the function returns REDIS_ERR.
+ * handler failed, the function returns C_ERR.
  *
- * The function may return REDIS_OK without actually installing the write
+ * The function may return C_OK without actually installing the write
  * event handler in the following cases:
  *
  * 1) The event handler should already be installed since the output buffer
  *    already contained something.
  * 2) The client is a slave but not yet online, so we want to just accumulate
  *    writes in the buffer but not actually sending them yet.
  *
  * Typically gets called every time a reply is built, before adding more
- * data to the clients output buffers. If the function returns REDIS_ERR no
+ * data to the clients output buffers. If the function returns C_ERR no
  * data should be appended to the output buffers. */
-int prepareClientToWrite(redisClient *c) {
+int prepareClientToWrite(client *c) {
     /* If it's the Lua client we always return ok without installing any
      * handler since there is no socket at all. */
-    if (c->flags & REDIS_LUA_CLIENT) return REDIS_OK;
+    if (c->flags & CLIENT_LUA) return C_OK;
 
-    /* Masters don't receive replies, unless REDIS_MASTER_FORCE_REPLY flag
+    /* CLIENT REPLY OFF / SKIP handling: don't send replies. */
+    if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;
+
+    /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag
      * is set. */
-    if ((c->flags & REDIS_MASTER) &&
-        !(c->flags & REDIS_MASTER_FORCE_REPLY)) return REDIS_ERR;
+    if ((c->flags & CLIENT_MASTER) &&
+        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;
 
-    if (c->fd <= 0) return REDIS_ERR; /* Fake client for AOF loading. */
+    if (c->fd <= 0) return C_ERR; /* Fake client for AOF loading. */
 
-    /* Only install the handler if not already installed and, in case of
-     * slaves, if the client can actually receive writes. */
-    if (c->bufpos == 0 && listLength(c->reply) == 0 &&
-        (c->replstate == REDIS_REPL_NONE ||
-         (c->replstate == REDIS_REPL_ONLINE && !c->repl_put_online_on_ack)))
+    /* Schedule the client to write the output buffers to the socket only
+     * if not already done (there were no pending writes already and the client
+     * was yet not flagged), and, for slaves, if the slave can actually
+     * receive writes at this stage. */
+    if (!clientHasPendingReplies(c) &&
+        !(c->flags & CLIENT_PENDING_WRITE) &&
+        (c->replstate == REPL_STATE_NONE ||
+         (c->replstate == SLAVE_STATE_ONLINE && !c->repl_put_online_on_ack)))
     {
-        /* Try to install the write handler. */
-        if (aeCreateFileEvent(server.el, c->fd, AE_WRITABLE,
-                sendReplyToClient, c) == AE_ERR)
-        {
-            freeClientAsync(c);
-            return REDIS_ERR;
-        }
+        /* Here instead of installing the write handler, we just flag the
+         * client and put it into a list of clients that have something
+         * to write to the socket. This way before re-entering the event
+         * loop, we can try to directly write to the client sockets avoiding
+         * a system call. We'll only really install the write handler if
+         * we'll not be able to write the whole reply at once. */
+        c->flags |= CLIENT_PENDING_WRITE;
+        listAddNodeHead(server.clients_pending_write,c);
     }
 
     /* Authorize the caller to queue in the output buffer of this client. */
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* Create a duplicate of the last object in the reply list when
  * it is not exclusively owned by the reply list. */
 robj *dupLastObjectIfNeeded(list *reply) {
     robj *new, *cur;
     listNode *ln;
-    redisAssert(listLength(reply) > 0);
+    serverAssert(listLength(reply) > 0);
     ln = listLast(reply);
     cur = listNodeValue(ln);
     if (cur->refcount > 1) {
         new = dupStringObject(cur);
         decrRefCount(cur);
         listNodeValue(ln) = new;
@@ -199,113 +206,113 @@
 }
 
 /* -----------------------------------------------------------------------------
  * Low level functions to add more data to output buffers.
  * -------------------------------------------------------------------------- */
 
-int _addReplyToBuffer(redisClient *c, char *s, size_t len) {
+int _addReplyToBuffer(client *c, const char *s, size_t len) {
     size_t available = sizeof(c->buf)-c->bufpos;
 
-    if (c->flags & REDIS_CLOSE_AFTER_REPLY) return REDIS_OK;
+    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return C_OK;
 
     /* If there already are entries in the reply list, we cannot
      * add anything more to the static buffer. */
-    if (listLength(c->reply) > 0) return REDIS_ERR;
+    if (listLength(c->reply) > 0) return C_ERR;
 
     /* Check that the buffer has enough space available for this string. */
-    if (len > available) return REDIS_ERR;
+    if (len > available) return C_ERR;
 
     memcpy(c->buf+c->bufpos,s,len);
     c->bufpos+=len;
-    return REDIS_OK;
+    return C_OK;
 }
 
-void _addReplyObjectToList(redisClient *c, robj *o) {
+void _addReplyObjectToList(client *c, robj *o) {
     robj *tail;
 
-    if (c->flags & REDIS_CLOSE_AFTER_REPLY) return;
+    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;
 
     if (listLength(c->reply) == 0) {
         incrRefCount(o);
         listAddNodeTail(c->reply,o);
         c->reply_bytes += getStringObjectSdsUsedMemory(o);
     } else {
         tail = listNodeValue(listLast(c->reply));
 
         /* Append to this object when possible. */
         if (tail->ptr != NULL &&
-            tail->encoding == REDIS_ENCODING_RAW &&
-            sdslen(tail->ptr)+sdslen(o->ptr) <= REDIS_REPLY_CHUNK_BYTES)
+            tail->encoding == OBJ_ENCODING_RAW &&
+            sdslen(tail->ptr)+sdslen(o->ptr) <= PROTO_REPLY_CHUNK_BYTES)
         {
-            c->reply_bytes -= zmalloc_size_sds(tail->ptr);
+            c->reply_bytes -= sdsZmallocSize(tail->ptr);
             tail = dupLastObjectIfNeeded(c->reply);
             tail->ptr = sdscatlen(tail->ptr,o->ptr,sdslen(o->ptr));
-            c->reply_bytes += zmalloc_size_sds(tail->ptr);
+            c->reply_bytes += sdsZmallocSize(tail->ptr);
         } else {
             incrRefCount(o);
             listAddNodeTail(c->reply,o);
             c->reply_bytes += getStringObjectSdsUsedMemory(o);
         }
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
 }
 
 /* This method takes responsibility over the sds. When it is no longer
  * needed it will be free'd, otherwise it ends up in a robj. */
-void _addReplySdsToList(redisClient *c, sds s) {
+void _addReplySdsToList(client *c, sds s) {
     robj *tail;
 
-    if (c->flags & REDIS_CLOSE_AFTER_REPLY) {
+    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
         sdsfree(s);
         return;
     }
 
     if (listLength(c->reply) == 0) {
-        listAddNodeTail(c->reply,createObject(REDIS_STRING,s));
-        c->reply_bytes += zmalloc_size_sds(s);
+        listAddNodeTail(c->reply,createObject(OBJ_STRING,s));
+        c->reply_bytes += sdsZmallocSize(s);
     } else {
         tail = listNodeValue(listLast(c->reply));
 
         /* Append to this object when possible. */
-        if (tail->ptr != NULL && tail->encoding == REDIS_ENCODING_RAW &&
-            sdslen(tail->ptr)+sdslen(s) <= REDIS_REPLY_CHUNK_BYTES)
+        if (tail->ptr != NULL && tail->encoding == OBJ_ENCODING_RAW &&
+            sdslen(tail->ptr)+sdslen(s) <= PROTO_REPLY_CHUNK_BYTES)
         {
-            c->reply_bytes -= zmalloc_size_sds(tail->ptr);
+            c->reply_bytes -= sdsZmallocSize(tail->ptr);
             tail = dupLastObjectIfNeeded(c->reply);
             tail->ptr = sdscatlen(tail->ptr,s,sdslen(s));
-            c->reply_bytes += zmalloc_size_sds(tail->ptr);
+            c->reply_bytes += sdsZmallocSize(tail->ptr);
             sdsfree(s);
         } else {
-            listAddNodeTail(c->reply,createObject(REDIS_STRING,s));
-            c->reply_bytes += zmalloc_size_sds(s);
+            listAddNodeTail(c->reply,createObject(OBJ_STRING,s));
+            c->reply_bytes += sdsZmallocSize(s);
         }
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
 }
 
-void _addReplyStringToList(redisClient *c, char *s, size_t len) {
+void _addReplyStringToList(client *c, const char *s, size_t len) {
     robj *tail;
 
-    if (c->flags & REDIS_CLOSE_AFTER_REPLY) return;
+    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;
 
     if (listLength(c->reply) == 0) {
         robj *o = createStringObject(s,len);
 
         listAddNodeTail(c->reply,o);
         c->reply_bytes += getStringObjectSdsUsedMemory(o);
     } else {
         tail = listNodeValue(listLast(c->reply));
 
         /* Append to this object when possible. */
-        if (tail->ptr != NULL && tail->encoding == REDIS_ENCODING_RAW &&
-            sdslen(tail->ptr)+len <= REDIS_REPLY_CHUNK_BYTES)
+        if (tail->ptr != NULL && tail->encoding == OBJ_ENCODING_RAW &&
+            sdslen(tail->ptr)+len <= PROTO_REPLY_CHUNK_BYTES)
         {
-            c->reply_bytes -= zmalloc_size_sds(tail->ptr);
+            c->reply_bytes -= sdsZmallocSize(tail->ptr);
             tail = dupLastObjectIfNeeded(c->reply);
             tail->ptr = sdscatlen(tail->ptr,s,len);
-            c->reply_bytes += zmalloc_size_sds(tail->ptr);
+            c->reply_bytes += sdsZmallocSize(tail->ptr);
         } else {
             robj *o = createStringObject(s,len);
 
             listAddNodeTail(c->reply,o);
             c->reply_bytes += getStringObjectSdsUsedMemory(o);
         }
@@ -315,79 +322,79 @@
 
 /* -----------------------------------------------------------------------------
  * Higher level functions to queue data on the client output buffer.
  * The following functions are the ones that commands implementations will call.
  * -------------------------------------------------------------------------- */
 
-void addReply(redisClient *c, robj *obj) {
-    if (prepareClientToWrite(c) != REDIS_OK) return;
+void addReply(client *c, robj *obj) {
+    if (prepareClientToWrite(c) != C_OK) return;
 
     /* This is an important place where we can avoid copy-on-write
      * when there is a saving child running, avoiding touching the
      * refcount field of the object if it's not needed.
      *
      * If the encoding is RAW and there is room in the static buffer
      * we'll be able to send the object to the client without
      * messing with its page. */
     if (sdsEncodedObject(obj)) {
-        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)
+        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK)
             _addReplyObjectToList(c,obj);
-    } else if (obj->encoding == REDIS_ENCODING_INT) {
+    } else if (obj->encoding == OBJ_ENCODING_INT) {
         /* Optimization: if there is room in the static buffer for 32 bytes
          * (more than the max chars a 64 bit integer can take as string) we
          * avoid decoding the object and go for the lower level approach. */
         if (listLength(c->reply) == 0 && (sizeof(c->buf) - c->bufpos) >= 32) {
             char buf[32];
             int len;
 
             len = ll2string(buf,sizeof(buf),(long)obj->ptr);
-            if (_addReplyToBuffer(c,buf,len) == REDIS_OK)
+            if (_addReplyToBuffer(c,buf,len) == C_OK)
                 return;
             /* else... continue with the normal code path, but should never
              * happen actually since we verified there is room. */
         }
         obj = getDecodedObject(obj);
-        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)
+        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != C_OK)
             _addReplyObjectToList(c,obj);
         decrRefCount(obj);
     } else {
-        redisPanic("Wrong obj->encoding in addReply()");
+        serverPanic("Wrong obj->encoding in addReply()");
     }
 }
 
-void addReplySds(redisClient *c, sds s) {
-    if (prepareClientToWrite(c) != REDIS_OK) {
+void addReplySds(client *c, sds s) {
+    if (prepareClientToWrite(c) != C_OK) {
         /* The caller expects the sds to be free'd. */
         sdsfree(s);
         return;
     }
-    if (_addReplyToBuffer(c,s,sdslen(s)) == REDIS_OK) {
+    if (_addReplyToBuffer(c,s,sdslen(s)) == C_OK) {
         sdsfree(s);
     } else {
         /* This method free's the sds when it is no longer needed. */
         _addReplySdsToList(c,s);
     }
 }
 
-void addReplyString(redisClient *c, char *s, size_t len) {
-    if (prepareClientToWrite(c) != REDIS_OK) return;
-    if (_addReplyToBuffer(c,s,len) != REDIS_OK)
+void addReplyString(client *c, const char *s, size_t len) {
+    if (prepareClientToWrite(c) != C_OK) return;
+    if (_addReplyToBuffer(c,s,len) != C_OK)
         _addReplyStringToList(c,s,len);
 }
 
-void addReplyErrorLength(redisClient *c, char *s, size_t len) {
+void addReplyErrorLength(client *c, const char *s, size_t len) {
     addReplyString(c,"-ERR ",5);
     addReplyString(c,s,len);
     addReplyString(c,"\r\n",2);
 }
 
-void addReplyError(redisClient *c, char *err) {
+void addReplyError(client *c, const char *err) {
     addReplyErrorLength(c,err,strlen(err));
 }
 
-void addReplyErrorFormat(redisClient *c, const char *fmt, ...) {
+void addReplyErrorFormat(client *c, const char *fmt, ...) {
     size_t l, j;
     va_list ap;
     va_start(ap,fmt);
     sds s = sdscatvprintf(sdsempty(),fmt,ap);
     va_end(ap);
     /* Make sure there are no newlines in the string, otherwise invalid protocol
@@ -397,71 +404,71 @@
         if (s[j] == '\r' || s[j] == '\n') s[j] = ' ';
     }
     addReplyErrorLength(c,s,sdslen(s));
     sdsfree(s);
 }
 
-void addReplyStatusLength(redisClient *c, char *s, size_t len) {
+void addReplyStatusLength(client *c, const char *s, size_t len) {
     addReplyString(c,"+",1);
     addReplyString(c,s,len);
     addReplyString(c,"\r\n",2);
 }
 
-void addReplyStatus(redisClient *c, char *status) {
+void addReplyStatus(client *c, const char *status) {
     addReplyStatusLength(c,status,strlen(status));
 }
 
-void addReplyStatusFormat(redisClient *c, const char *fmt, ...) {
+void addReplyStatusFormat(client *c, const char *fmt, ...) {
     va_list ap;
     va_start(ap,fmt);
     sds s = sdscatvprintf(sdsempty(),fmt,ap);
     va_end(ap);
     addReplyStatusLength(c,s,sdslen(s));
     sdsfree(s);
 }
 
 /* Adds an empty object to the reply list that will contain the multi bulk
  * length, which is not known when this function is called. */
-void *addDeferredMultiBulkLength(redisClient *c) {
+void *addDeferredMultiBulkLength(client *c) {
     /* Note that we install the write event here even if the object is not
      * ready to be sent, since we are sure that before returning to the
      * event loop setDeferredMultiBulkLength() will be called. */
-    if (prepareClientToWrite(c) != REDIS_OK) return NULL;
-    listAddNodeTail(c->reply,createObject(REDIS_STRING,NULL));
+    if (prepareClientToWrite(c) != C_OK) return NULL;
+    listAddNodeTail(c->reply,createObject(OBJ_STRING,NULL));
     return listLast(c->reply);
 }
 
 /* Populate the length object and try gluing it to the next chunk. */
-void setDeferredMultiBulkLength(redisClient *c, void *node, long length) {
+void setDeferredMultiBulkLength(client *c, void *node, long length) {
     listNode *ln = (listNode*)node;
     robj *len, *next;
 
     /* Abort when *node is NULL (see addDeferredMultiBulkLength). */
     if (node == NULL) return;
 
     len = listNodeValue(ln);
     len->ptr = sdscatprintf(sdsempty(),"*%ld\r\n",length);
-    len->encoding = REDIS_ENCODING_RAW; /* in case it was an EMBSTR. */
-    c->reply_bytes += zmalloc_size_sds(len->ptr);
+    len->encoding = OBJ_ENCODING_RAW; /* in case it was an EMBSTR. */
+    c->reply_bytes += sdsZmallocSize(len->ptr);
     if (ln->next != NULL) {
         next = listNodeValue(ln->next);
 
         /* Only glue when the next node is non-NULL (an sds in this case) */
         if (next->ptr != NULL) {
-            c->reply_bytes -= zmalloc_size_sds(len->ptr);
+            c->reply_bytes -= sdsZmallocSize(len->ptr);
             c->reply_bytes -= getStringObjectSdsUsedMemory(next);
             len->ptr = sdscatlen(len->ptr,next->ptr,sdslen(next->ptr));
-            c->reply_bytes += zmalloc_size_sds(len->ptr);
+            c->reply_bytes += sdsZmallocSize(len->ptr);
             listDelNode(c->reply,ln->next);
         }
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
 }
 
 /* Add a double as a bulk reply */
-void addReplyDouble(redisClient *c, double d) {
+void addReplyDouble(client *c, double d) {
     char dbuf[128], sbuf[128];
     int dlen, slen;
     if (isinf(d)) {
         /* Libc in odd systems (Hi Solaris!) will format infinite in a
          * different way, so better to handle it in an explicit way. */
         addReplyBulkCString(c, d > 0 ? "inf" : "-inf");
@@ -469,54 +476,63 @@
         dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
         slen = snprintf(sbuf,sizeof(sbuf),"$%d\r\n%s\r\n",dlen,dbuf);
         addReplyString(c,sbuf,slen);
     }
 }
 
+/* Add a long double as a bulk reply, but uses a human readable formatting
+ * of the double instead of exposing the crude behavior of doubles to the
+ * dear user. */
+void addReplyHumanLongDouble(client *c, long double d) {
+    robj *o = createStringObjectFromLongDouble(d,1);
+    addReplyBulk(c,o);
+    decrRefCount(o);
+}
+
 /* Add a long long as integer reply or bulk len / multi bulk count.
  * Basically this is used to output <prefix><long long><crlf>. */
-void addReplyLongLongWithPrefix(redisClient *c, long long ll, char prefix) {
+void addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {
     char buf[128];
     int len;
 
     /* Things like $3\r\n or *2\r\n are emitted very often by the protocol
      * so we have a few shared objects to use if the integer is small
      * like it is most of the times. */
-    if (prefix == '*' && ll < REDIS_SHARED_BULKHDR_LEN) {
+    if (prefix == '*' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {
         addReply(c,shared.mbulkhdr[ll]);
         return;
-    } else if (prefix == '$' && ll < REDIS_SHARED_BULKHDR_LEN) {
+    } else if (prefix == '$' && ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0) {
         addReply(c,shared.bulkhdr[ll]);
         return;
     }
 
     buf[0] = prefix;
     len = ll2string(buf+1,sizeof(buf)-1,ll);
     buf[len+1] = '\r';
     buf[len+2] = '\n';
     addReplyString(c,buf,len+3);
 }
 
-void addReplyLongLong(redisClient *c, long long ll) {
+void addReplyLongLong(client *c, long long ll) {
     if (ll == 0)
         addReply(c,shared.czero);
     else if (ll == 1)
         addReply(c,shared.cone);
     else
         addReplyLongLongWithPrefix(c,ll,':');
 }
 
-void addReplyMultiBulkLen(redisClient *c, long length) {
-    if (length < REDIS_SHARED_BULKHDR_LEN)
+void addReplyMultiBulkLen(client *c, long length) {
+    if (length < OBJ_SHARED_BULKHDR_LEN)
         addReply(c,shared.mbulkhdr[length]);
     else
         addReplyLongLongWithPrefix(c,length,'*');
 }
 
 /* Create the length prefix of a bulk reply, example: $2234 */
-void addReplyBulkLen(redisClient *c, robj *obj) {
+void addReplyBulkLen(client *c, robj *obj) {
     size_t len;
 
     if (sdsEncodedObject(obj)) {
         len = sdslen(obj->ptr);
     } else {
         long n = (long)obj->ptr;
@@ -529,66 +545,80 @@
         }
         while((n = n/10) != 0) {
             len++;
         }
     }
 
-    if (len < REDIS_SHARED_BULKHDR_LEN)
+    if (len < OBJ_SHARED_BULKHDR_LEN)
         addReply(c,shared.bulkhdr[len]);
     else
         addReplyLongLongWithPrefix(c,len,'$');
 }
 
 /* Add a Redis Object as a bulk reply */
-void addReplyBulk(redisClient *c, robj *obj) {
+void addReplyBulk(client *c, robj *obj) {
     addReplyBulkLen(c,obj);
     addReply(c,obj);
     addReply(c,shared.crlf);
 }
 
 /* Add a C buffer as bulk reply */
-void addReplyBulkCBuffer(redisClient *c, void *p, size_t len) {
+void addReplyBulkCBuffer(client *c, const void *p, size_t len) {
     addReplyLongLongWithPrefix(c,len,'$');
     addReplyString(c,p,len);
     addReply(c,shared.crlf);
 }
 
+/* Add sds to reply (takes ownership of sds and frees it) */
+void addReplyBulkSds(client *c, sds s)  {
+    addReplySds(c,sdscatfmt(sdsempty(),"$%u\r\n",
+        (unsigned long)sdslen(s)));
+    addReplySds(c,s);
+    addReply(c,shared.crlf);
+}
+
 /* Add a C nul term string as bulk reply */
-void addReplyBulkCString(redisClient *c, char *s) {
+void addReplyBulkCString(client *c, const char *s) {
     if (s == NULL) {
         addReply(c,shared.nullbulk);
     } else {
         addReplyBulkCBuffer(c,s,strlen(s));
     }
 }
 
 /* Add a long long as a bulk reply */
-void addReplyBulkLongLong(redisClient *c, long long ll) {
+void addReplyBulkLongLong(client *c, long long ll) {
     char buf[64];
     int len;
 
     len = ll2string(buf,64,ll);
     addReplyBulkCBuffer(c,buf,len);
 }
 
 /* Copy 'src' client output buffers into 'dst' client output buffers.
  * The function takes care of freeing the old output buffers of the
  * destination client. */
-void copyClientOutputBuffer(redisClient *dst, redisClient *src) {
+void copyClientOutputBuffer(client *dst, client *src) {
     listRelease(dst->reply);
     dst->reply = listDup(src->reply);
     memcpy(dst->buf,src->buf,src->bufpos);
     dst->bufpos = src->bufpos;
     dst->reply_bytes = src->reply_bytes;
 }
 
+/* Return true if the specified client has pending reply buffers to write to
+ * the socket. */
+int clientHasPendingReplies(client *c) {
+    return c->bufpos || listLength(c->reply);
+}
+
 #define MAX_ACCEPTS_PER_CALL 1000
-static void acceptCommonHandler(int fd, int flags) {
-    redisClient *c;
+static void acceptCommonHandler(int fd, int flags, char *ip) {
+    client *c;
     if ((c = createClient(fd)) == NULL) {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Error registering fd event for the new client: %s (fd=%d)",
             strerror(errno),fd);
         close(fd); /* May be already closed, just ignore errors */
         return;
     }
     /* If maxclient directive is set and this is one client more... close the
@@ -603,56 +633,98 @@
             /* Nothing to do, Just to avoid the warning... */
         }
         server.stat_rejected_conn++;
         freeClient(c);
         return;
     }
+
+    /* If the server is running in protected mode (the default) and there
+     * is no password set, nor a specific interface is bound, we don't accept
+     * requests from non loopback interfaces. Instead we try to explain the
+     * user what to do to fix it if needed. */
+    if (server.protected_mode &&
+        server.bindaddr_count == 0 &&
+        server.requirepass == NULL &&
+        !(flags & CLIENT_UNIX_SOCKET) &&
+        ip != NULL)
+    {
+        if (strcmp(ip,"127.0.0.1") && strcmp(ip,"::1")) {
+            char *err =
+                "-DENIED Redis is running in protected mode because protected "
+                "mode is enabled, no bind address was specified, no "
+                "authentication password is requested to clients. In this mode "
+                "connections are only accepted from the loopback interface. "
+                "If you want to connect from external computers to Redis you "
+                "may adopt one of the following solutions: "
+                "1) Just disable protected mode sending the command "
+                "'CONFIG SET protected-mode no' from the loopback interface "
+                "by connecting to Redis from the same host the server is "
+                "running, however MAKE SURE Redis is not publicly accessible "
+                "from internet if you do so. Use CONFIG REWRITE to make this "
+                "change permanent. "
+                "2) Alternatively you can just disable the protected mode by "
+                "editing the Redis configuration file, and setting the protected "
+                "mode option to 'no', and then restarting the server. "
+                "3) If you started the server manually just for testing, restart "
+                "it with the '--protected-mode no' option. "
+                "4) Setup a bind address or an authentication password. "
+                "NOTE: You only need to do one of the above things in order for "
+                "the server to start accepting connections from the outside.\r\n";
+            if (write(c->fd,err,strlen(err)) == -1) {
+                /* Nothing to do, Just to avoid the warning... */
+            }
+            server.stat_rejected_conn++;
+            freeClient(c);
+            return;
+        }
+    }
+
     server.stat_numconnections++;
     c->flags |= flags;
 }
 
 void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
-    char cip[REDIS_IP_STR_LEN];
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(mask);
-    REDIS_NOTUSED(privdata);
+    char cip[NET_IP_STR_LEN];
+    UNUSED(el);
+    UNUSED(mask);
+    UNUSED(privdata);
 
     while(max--) {
         cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
         if (cfd == ANET_ERR) {
             if (errno != EWOULDBLOCK)
-                redisLog(REDIS_WARNING,
+                serverLog(LL_WARNING,
                     "Accepting client connection: %s", server.neterr);
             return;
         }
-        redisLog(REDIS_VERBOSE,"Accepted %s:%d", cip, cport);
-        acceptCommonHandler(cfd,0);
+        serverLog(LL_VERBOSE,"Accepted %s:%d", cip, cport);
+        acceptCommonHandler(cfd,0,cip);
     }
 }
 
 void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     int cfd, max = MAX_ACCEPTS_PER_CALL;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(mask);
-    REDIS_NOTUSED(privdata);
+    UNUSED(el);
+    UNUSED(mask);
+    UNUSED(privdata);
 
     while(max--) {
         cfd = anetUnixAccept(server.neterr, fd);
         if (cfd == ANET_ERR) {
             if (errno != EWOULDBLOCK)
-                redisLog(REDIS_WARNING,
+                serverLog(LL_WARNING,
                     "Accepting client connection: %s", server.neterr);
             return;
         }
-        redisLog(REDIS_VERBOSE,"Accepted connection to %s", server.unixsocket);
-        acceptCommonHandler(cfd,REDIS_UNIX_SOCKET);
+        serverLog(LL_VERBOSE,"Accepted connection to %s", server.unixsocket);
+        acceptCommonHandler(cfd,CLIENT_UNIX_SOCKET,NULL);
     }
 }
 
-static void freeClientArgv(redisClient *c) {
+static void freeClientArgv(client *c) {
     int j;
     for (j = 0; j < c->argc; j++)
         decrRefCount(c->argv[j]);
     c->argc = 0;
     c->cmd = NULL;
 }
@@ -660,116 +732,140 @@
 /* Close all the slaves connections. This is useful in chained replication
  * when we resync with our own master and want to force all our slaves to
  * resync with us as well. */
 void disconnectSlaves(void) {
     while (listLength(server.slaves)) {
         listNode *ln = listFirst(server.slaves);
-        freeClient((redisClient*)ln->value);
+        freeClient((client*)ln->value);
     }
 }
 
-void freeClient(redisClient *c) {
+/* Remove the specified client from global lists where the client could
+ * be referenced, not including the Pub/Sub channels.
+ * This is used by freeClient() and replicationCacheMaster(). */
+void unlinkClient(client *c) {
     listNode *ln;
 
-    /* If this is marked as current client unset it */
+    /* If this is marked as current client unset it. */
     if (server.current_client == c) server.current_client = NULL;
 
+    /* Certain operations must be done only if the client has an active socket.
+     * If the client was already unlinked or if it's a "fake client" the
+     * fd is already set to -1. */
+    if (c->fd != -1) {
+        /* Remove from the list of active clients. */
+        ln = listSearchKey(server.clients,c);
+        serverAssert(ln != NULL);
+        listDelNode(server.clients,ln);
+
+        /* Unregister async I/O handlers and close the socket. */
+        aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
+        aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
+        close(c->fd);
+        c->fd = -1;
+    }
+
+    /* Remove from the list of pending writes if needed. */
+    if (c->flags & CLIENT_PENDING_WRITE) {
+        ln = listSearchKey(server.clients_pending_write,c);
+        serverAssert(ln != NULL);
+        listDelNode(server.clients_pending_write,ln);
+        c->flags &= ~CLIENT_PENDING_WRITE;
+    }
+
+    /* When client was just unblocked because of a blocking operation,
+     * remove it from the list of unblocked clients. */
+    if (c->flags & CLIENT_UNBLOCKED) {
+        ln = listSearchKey(server.unblocked_clients,c);
+        serverAssert(ln != NULL);
+        listDelNode(server.unblocked_clients,ln);
+        c->flags &= ~CLIENT_UNBLOCKED;
+    }
+}
+
+void freeClient(client *c) {
+    listNode *ln;
+
     /* If it is our master that's beging disconnected we should make sure
      * to cache the state to try a partial resynchronization later.
      *
      * Note that before doing this we make sure that the client is not in
      * some unexpected state, by checking its flags. */
-    if (server.master && c->flags & REDIS_MASTER) {
-        redisLog(REDIS_WARNING,"Connection with master lost.");
-        if (!(c->flags & (REDIS_CLOSE_AFTER_REPLY|
-                          REDIS_CLOSE_ASAP|
-                          REDIS_BLOCKED|
-                          REDIS_UNBLOCKED)))
+    if (server.master && c->flags & CLIENT_MASTER) {
+        serverLog(LL_WARNING,"Connection with master lost.");
+        if (!(c->flags & (CLIENT_CLOSE_AFTER_REPLY|
+                          CLIENT_CLOSE_ASAP|
+                          CLIENT_BLOCKED|
+                          CLIENT_UNBLOCKED)))
         {
             replicationCacheMaster(c);
             return;
         }
     }
 
     /* Log link disconnection with slave */
-    if ((c->flags & REDIS_SLAVE) && !(c->flags & REDIS_MONITOR)) {
-        redisLog(REDIS_WARNING,"Connection with slave %s lost.",
+    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR)) {
+        serverLog(LL_WARNING,"Connection with slave %s lost.",
             replicationGetSlaveName(c));
     }
 
     /* Free the query buffer */
     sdsfree(c->querybuf);
     c->querybuf = NULL;
 
     /* Deallocate structures used to block on blocking ops. */
-    if (c->flags & REDIS_BLOCKED) unblockClient(c);
+    if (c->flags & CLIENT_BLOCKED) unblockClient(c);
     dictRelease(c->bpop.keys);
 
     /* UNWATCH all the keys */
     unwatchAllKeys(c);
     listRelease(c->watched_keys);
 
     /* Unsubscribe from all the pubsub channels */
     pubsubUnsubscribeAllChannels(c,0);
     pubsubUnsubscribeAllPatterns(c,0);
     dictRelease(c->pubsub_channels);
     listRelease(c->pubsub_patterns);
 
-    /* Close socket, unregister events, and remove list of replies and
-     * accumulated arguments. */
-    if (c->fd != -1) {
-        aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
-        aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
-        close(c->fd);
-    }
+    /* Free data structures. */
     listRelease(c->reply);
     freeClientArgv(c);
 
-    /* Remove from the list of clients */
-    if (c->fd != -1) {
-        ln = listSearchKey(server.clients,c);
-        redisAssert(ln != NULL);
-        listDelNode(server.clients,ln);
-    }
-
-    /* When client was just unblocked because of a blocking operation,
-     * remove it from the list of unblocked clients. */
-    if (c->flags & REDIS_UNBLOCKED) {
-        ln = listSearchKey(server.unblocked_clients,c);
-        redisAssert(ln != NULL);
-        listDelNode(server.unblocked_clients,ln);
-    }
+    /* Unlink the client: this will close the socket, remove the I/O
+     * handlers, and remove references of the client from different
+     * places where active clients may be referenced. */
+    unlinkClient(c);
 
     /* Master/slave cleanup Case 1:
      * we lost the connection with a slave. */
-    if (c->flags & REDIS_SLAVE) {
-        if (c->replstate == REDIS_REPL_SEND_BULK) {
+    if (c->flags & CLIENT_SLAVE) {
+        if (c->replstate == SLAVE_STATE_SEND_BULK) {
             if (c->repldbfd != -1) close(c->repldbfd);
             if (c->replpreamble) sdsfree(c->replpreamble);
         }
-        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;
+        list *l = (c->flags & CLIENT_MONITOR) ? server.monitors : server.slaves;
         ln = listSearchKey(l,c);
-        redisAssert(ln != NULL);
+        serverAssert(ln != NULL);
         listDelNode(l,ln);
         /* We need to remember the time when we started to have zero
          * attached slaves, as after some time we'll free the replication
          * backlog. */
-        if (c->flags & REDIS_SLAVE && listLength(server.slaves) == 0)
+        if (c->flags & CLIENT_SLAVE && listLength(server.slaves) == 0)
             server.repl_no_slaves_since = server.unixtime;
         refreshGoodSlavesCount();
     }
 
     /* Master/slave cleanup Case 2:
      * we lost the connection with the master. */
-    if (c->flags & REDIS_MASTER) replicationHandleMasterDisconnection();
+    if (c->flags & CLIENT_MASTER) replicationHandleMasterDisconnection();
 
     /* If this client was scheduled for async freeing we need to remove it
      * from the queue. */
-    if (c->flags & REDIS_CLOSE_ASAP) {
+    if (c->flags & CLIENT_CLOSE_ASAP) {
         ln = listSearchKey(server.clients_to_close,c);
-        redisAssert(ln != NULL);
+        serverAssert(ln != NULL);
         listDelNode(server.clients_to_close,ln);
     }
 
     /* Release other dynamically allocated client structure fields,
      * and finally release the client structure itself. */
     if (c->name) decrRefCount(c->name);
@@ -780,47 +876,47 @@
 }
 
 /* Schedule a client to free it at a safe time in the serverCron() function.
  * This function is useful when we need to terminate a client but we are in
  * a context where calling freeClient() is not possible, because the client
  * should be valid for the continuation of the flow of the program. */
-void freeClientAsync(redisClient *c) {
-    if (c->flags & REDIS_CLOSE_ASAP || c->flags & REDIS_LUA_CLIENT) return;
-    c->flags |= REDIS_CLOSE_ASAP;
+void freeClientAsync(client *c) {
+    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) return;
+    c->flags |= CLIENT_CLOSE_ASAP;
     listAddNodeTail(server.clients_to_close,c);
 }
 
 void freeClientsInAsyncFreeQueue(void) {
     while (listLength(server.clients_to_close)) {
         listNode *ln = listFirst(server.clients_to_close);
-        redisClient *c = listNodeValue(ln);
+        client *c = listNodeValue(ln);
 
-        c->flags &= ~REDIS_CLOSE_ASAP;
+        c->flags &= ~CLIENT_CLOSE_ASAP;
         freeClient(c);
         listDelNode(server.clients_to_close,ln);
     }
 }
 
-void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {
-    redisClient *c = privdata;
-    int nwritten = 0, totwritten = 0, objlen;
+/* Write data in output buffers to client. Return C_OK if the client
+ * is still valid after the call, C_ERR if it was freed. */
+int writeToClient(int fd, client *c, int handler_installed) {
+    ssize_t nwritten = 0, totwritten = 0;
+    size_t objlen;
     size_t objmem;
     robj *o;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(mask);
 
-    while(c->bufpos > 0 || listLength(c->reply)) {
+    while(clientHasPendingReplies(c)) {
         if (c->bufpos > 0) {
             nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
             if (nwritten <= 0) break;
             c->sentlen += nwritten;
             totwritten += nwritten;
 
             /* If the buffer was sent, set bufpos to zero to continue with
              * the remainder of the reply. */
-            if (c->sentlen == c->bufpos) {
+            if ((int)c->sentlen == c->bufpos) {
                 c->bufpos = 0;
                 c->sentlen = 0;
             }
         } else {
             o = listNodeValue(listFirst(c->reply));
             objlen = sdslen(o->ptr);
@@ -841,53 +937,94 @@
             if (c->sentlen == objlen) {
                 listDelNode(c->reply,listFirst(c->reply));
                 c->sentlen = 0;
                 c->reply_bytes -= objmem;
             }
         }
-        /* Note that we avoid to send more than REDIS_MAX_WRITE_PER_EVENT
+        /* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT
          * bytes, in a single threaded server it's a good idea to serve
          * other clients as well, even if a very large request comes from
          * super fast link that is always able to accept data (in real world
          * scenario think about 'KEYS *' against the loopback interface).
          *
          * However if we are over the maxmemory limit we ignore that and
          * just deliver as much data as it is possible to deliver. */
         server.stat_net_output_bytes += totwritten;
-        if (totwritten > REDIS_MAX_WRITE_PER_EVENT &&
+        if (totwritten > NET_MAX_WRITES_PER_EVENT &&
             (server.maxmemory == 0 ||
              zmalloc_used_memory() < server.maxmemory)) break;
     }
     if (nwritten == -1) {
         if (errno == EAGAIN) {
             nwritten = 0;
         } else {
-            redisLog(REDIS_VERBOSE,
+            serverLog(LL_VERBOSE,
                 "Error writing to client: %s", strerror(errno));
             freeClient(c);
-            return;
+            return C_ERR;
         }
     }
     if (totwritten > 0) {
         /* For clients representing masters we don't count sending data
          * as an interaction, since we always send REPLCONF ACK commands
          * that take some time to just fill the socket output buffer.
          * We just rely on data / pings received for timeout detection. */
-        if (!(c->flags & REDIS_MASTER)) c->lastinteraction = server.unixtime;
+        if (!(c->flags & CLIENT_MASTER)) c->lastinteraction = server.unixtime;
     }
-    if (c->bufpos == 0 && listLength(c->reply) == 0) {
+    if (!clientHasPendingReplies(c)) {
         c->sentlen = 0;
-        aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
+        if (handler_installed) aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
 
         /* Close connection after entire reply has been sent. */
-        if (c->flags & REDIS_CLOSE_AFTER_REPLY) freeClient(c);
+        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
+            freeClient(c);
+            return C_ERR;
+        }
+    }
+    return C_OK;
+}
+
+/* Write event handler. Just send data to the client. */
+void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {
+    UNUSED(el);
+    UNUSED(mask);
+    writeToClient(fd,privdata,1);
+}
+
+/* This function is called just before entering the event loop, in the hope
+ * we can just write the replies to the client output buffer without any
+ * need to use a syscall in order to install the writable event handler,
+ * get it called, and so forth. */
+int handleClientsWithPendingWrites(void) {
+    listIter li;
+    listNode *ln;
+    int processed = listLength(server.clients_pending_write);
+
+    listRewind(server.clients_pending_write,&li);
+    while((ln = listNext(&li))) {
+        client *c = listNodeValue(ln);
+        c->flags &= ~CLIENT_PENDING_WRITE;
+        listDelNode(server.clients_pending_write,ln);
+
+        /* Try to write buffers to the client socket. */
+        if (writeToClient(c->fd,c,0) == C_ERR) continue;
+
+        /* If there is nothing left, do nothing. Otherwise install
+         * the write handler. */
+        if (clientHasPendingReplies(c) &&
+            aeCreateFileEvent(server.el, c->fd, AE_WRITABLE,
+                sendReplyToClient, c) == AE_ERR)
+        {
+            freeClientAsync(c);
+        }
     }
+    return processed;
 }
 
 /* resetClient prepare the client to process the next command */
-void resetClient(redisClient *c) {
+void resetClient(client *c) {
     redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;
 
     freeClientArgv(c);
     c->reqtype = 0;
     c->multibulklen = 0;
     c->bulklen = -1;
@@ -888,34 +1025,44 @@
     redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;
 
     freeClientArgv(c);
     c->reqtype = 0;
     c->multibulklen = 0;
     c->bulklen = -1;
+
     /* We clear the ASKING flag as well if we are not inside a MULTI, and
      * if what we just executed is not the ASKING command itself. */
-    if (!(c->flags & REDIS_MULTI) && prevcmd != askingCommand)
-        c->flags &= (~REDIS_ASKING);
+    if (!(c->flags & CLIENT_MULTI) && prevcmd != askingCommand)
+        c->flags &= ~CLIENT_ASKING;
+
+    /* Remove the CLIENT_REPLY_SKIP flag if any so that the reply
+     * to the next command will be sent, but set the flag if the command
+     * we just processed was "CLIENT REPLY SKIP". */
+    c->flags &= ~CLIENT_REPLY_SKIP;
+    if (c->flags & CLIENT_REPLY_SKIP_NEXT) {
+        c->flags |= CLIENT_REPLY_SKIP;
+        c->flags &= ~CLIENT_REPLY_SKIP_NEXT;
+    }
 }
 
-int processInlineBuffer(redisClient *c) {
+int processInlineBuffer(client *c) {
     char *newline;
     int argc, j;
     sds *argv, aux;
     size_t querylen;
 
     /* Search for end of line */
     newline = strchr(c->querybuf,'\n');
 
     /* Nothing to do without a \r\n */
     if (newline == NULL) {
-        if (sdslen(c->querybuf) > REDIS_INLINE_MAX_SIZE) {
+        if (sdslen(c->querybuf) > PROTO_INLINE_MAX_SIZE) {
             addReplyError(c,"Protocol error: too big inline request");
             setProtocolError(c,0);
         }
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     /* Handle the \r\n case. */
     if (newline && newline != c->querybuf && *(newline-1) == '\r')
         newline--;
 
@@ -924,19 +1071,19 @@
     aux = sdsnewlen(c->querybuf,querylen);
     argv = sdssplitargs(aux,&argc);
     sdsfree(aux);
     if (argv == NULL) {
         addReplyError(c,"Protocol error: unbalanced quotes in request");
         setProtocolError(c,0);
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     /* Newline from slaves can be used to refresh the last ACK time.
      * This is useful for a slave to ping back while loading a big
      * RDB file. */
-    if (querylen == 0 && c->flags & REDIS_SLAVE)
+    if (querylen == 0 && c->flags & CLIENT_SLAVE)
         c->repl_ack_time = server.unixtime;
 
     /* Leave data after the first line of the query in the buffer */
     sdsrange(c->querybuf,querylen+2,-1);
 
     /* Setup argv array on client structure */
@@ -945,92 +1092,92 @@
         c->argv = zmalloc(sizeof(robj*)*argc);
     }
 
     /* Create redis objects for all arguments. */
     for (c->argc = 0, j = 0; j < argc; j++) {
         if (sdslen(argv[j])) {
-            c->argv[c->argc] = createObject(REDIS_STRING,argv[j]);
+            c->argv[c->argc] = createObject(OBJ_STRING,argv[j]);
             c->argc++;
         } else {
             sdsfree(argv[j]);
         }
     }
     zfree(argv);
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* Helper function. Trims query buffer to make the function that processes
  * multi bulk requests idempotent. */
-static void setProtocolError(redisClient *c, int pos) {
-    if (server.verbosity <= REDIS_VERBOSE) {
+static void setProtocolError(client *c, int pos) {
+    if (server.verbosity <= LL_VERBOSE) {
         sds client = catClientInfoString(sdsempty(),c);
-        redisLog(REDIS_VERBOSE,
+        serverLog(LL_VERBOSE,
             "Protocol error from client: %s", client);
         sdsfree(client);
     }
-    c->flags |= REDIS_CLOSE_AFTER_REPLY;
+    c->flags |= CLIENT_CLOSE_AFTER_REPLY;
     sdsrange(c->querybuf,pos,-1);
 }
 
-int processMultibulkBuffer(redisClient *c) {
+int processMultibulkBuffer(client *c) {
     char *newline = NULL;
     int pos = 0, ok;
     long long ll;
 
     if (c->multibulklen == 0) {
         /* The client should have been reset */
-        redisAssertWithInfo(c,NULL,c->argc == 0);
+        serverAssertWithInfo(c,NULL,c->argc == 0);
 
         /* Multi bulk length cannot be read without a \r\n */
         newline = strchr(c->querybuf,'\r');
         if (newline == NULL) {
-            if (sdslen(c->querybuf) > REDIS_INLINE_MAX_SIZE) {
+            if (sdslen(c->querybuf) > PROTO_INLINE_MAX_SIZE) {
                 addReplyError(c,"Protocol error: too big mbulk count string");
                 setProtocolError(c,0);
             }
-            return REDIS_ERR;
+            return C_ERR;
         }
 
         /* Buffer should also contain \n */
         if (newline-(c->querybuf) > ((signed)sdslen(c->querybuf)-2))
-            return REDIS_ERR;
+            return C_ERR;
 
         /* We know for sure there is a whole line since newline != NULL,
          * so go ahead and find out the multi bulk length. */
-        redisAssertWithInfo(c,NULL,c->querybuf[0] == '*');
+        serverAssertWithInfo(c,NULL,c->querybuf[0] == '*');
         ok = string2ll(c->querybuf+1,newline-(c->querybuf+1),&ll);
         if (!ok || ll > 1024*1024) {
             addReplyError(c,"Protocol error: invalid multibulk length");
             setProtocolError(c,pos);
-            return REDIS_ERR;
+            return C_ERR;
         }
 
         pos = (newline-c->querybuf)+2;
         if (ll <= 0) {
             sdsrange(c->querybuf,pos,-1);
-            return REDIS_OK;
+            return C_OK;
         }
 
         c->multibulklen = ll;
 
         /* Setup argv array on client structure */
         if (c->argv) zfree(c->argv);
         c->argv = zmalloc(sizeof(robj*)*c->multibulklen);
     }
 
-    redisAssertWithInfo(c,NULL,c->multibulklen > 0);
+    serverAssertWithInfo(c,NULL,c->multibulklen > 0);
     while(c->multibulklen) {
         /* Read bulk length if unknown */
         if (c->bulklen == -1) {
             newline = strchr(c->querybuf+pos,'\r');
             if (newline == NULL) {
-                if (sdslen(c->querybuf) > REDIS_INLINE_MAX_SIZE) {
+                if (sdslen(c->querybuf) > PROTO_INLINE_MAX_SIZE) {
                     addReplyError(c,
                         "Protocol error: too big bulk count string");
                     setProtocolError(c,0);
-                    return REDIS_ERR;
+                    return C_ERR;
                 }
                 break;
             }
 
             /* Buffer should also contain \n */
             if (newline-(c->querybuf) > ((signed)sdslen(c->querybuf)-2))
@@ -1038,24 +1185,24 @@
 
             if (c->querybuf[pos] != '$') {
                 addReplyErrorFormat(c,
                     "Protocol error: expected '$', got '%c'",
                     c->querybuf[pos]);
                 setProtocolError(c,pos);
-                return REDIS_ERR;
+                return C_ERR;
             }
 
             ok = string2ll(c->querybuf+pos+1,newline-(c->querybuf+pos+1),&ll);
             if (!ok || ll < 0 || ll > 512*1024*1024) {
                 addReplyError(c,"Protocol error: invalid bulk length");
                 setProtocolError(c,pos);
-                return REDIS_ERR;
+                return C_ERR;
             }
 
             pos += newline-(c->querybuf+pos)+2;
-            if (ll >= REDIS_MBULK_BIG_ARG) {
+            if (ll >= PROTO_MBULK_BIG_ARG) {
                 size_t qblen;
 
                 /* If we are going to read a large object from network
                  * try to make it likely that it will start at c->querybuf
                  * boundary so that we can optimize object creation
                  * avoiding a large copy of data. */
@@ -1076,21 +1223,21 @@
             break;
         } else {
             /* Optimization: if the buffer contains JUST our bulk element
              * instead of creating a new object by *copying* the sds we
              * just use the current sds string. */
             if (pos == 0 &&
-                c->bulklen >= REDIS_MBULK_BIG_ARG &&
+                c->bulklen >= PROTO_MBULK_BIG_ARG &&
                 (signed) sdslen(c->querybuf) == c->bulklen+2)
             {
-                c->argv[c->argc++] = createObject(REDIS_STRING,c->querybuf);
+                c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);
                 sdsIncrLen(c->querybuf,-2); /* remove CRLF */
-                c->querybuf = sdsempty();
                 /* Assume that if we saw a fat argument we'll see another one
                  * likely... */
-                c->querybuf = sdsMakeRoomFor(c->querybuf,c->bulklen+2);
+                c->querybuf = sdsnewlen(NULL,c->bulklen+2);
+                sdsclear(c->querybuf);
                 pos = 0;
             } else {
                 c->argv[c->argc++] =
                     createStringObject(c->querybuf+pos,c->bulklen);
                 pos += c->bulklen+2;
             }
@@ -1100,126 +1247,125 @@
     }
 
     /* Trim to pos */
     if (pos) sdsrange(c->querybuf,pos,-1);
 
     /* We're done when c->multibulk == 0 */
-    if (c->multibulklen == 0) return REDIS_OK;
+    if (c->multibulklen == 0) return C_OK;
 
     /* Still not read to process the command */
-    return REDIS_ERR;
+    return C_ERR;
 }
 
-void processInputBuffer(redisClient *c) {
+void processInputBuffer(client *c) {
+    server.current_client = c;
     /* Keep processing while there is something in the input buffer */
     while(sdslen(c->querybuf)) {
         /* Return if clients are paused. */
-        if (!(c->flags & REDIS_SLAVE) && clientsArePaused()) return;
+        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;
 
         /* Immediately abort if the client is in the middle of something. */
-        if (c->flags & REDIS_BLOCKED) return;
+        if (c->flags & CLIENT_BLOCKED) break;
 
-        /* REDIS_CLOSE_AFTER_REPLY closes the connection once the reply is
+        /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
          * this flag has been set (i.e. don't process more commands). */
-        if (c->flags & REDIS_CLOSE_AFTER_REPLY) return;
+        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
             if (c->querybuf[0] == '*') {
-                c->reqtype = REDIS_REQ_MULTIBULK;
+                c->reqtype = PROTO_REQ_MULTIBULK;
             } else {
-                c->reqtype = REDIS_REQ_INLINE;
+                c->reqtype = PROTO_REQ_INLINE;
             }
         }
 
-        if (c->reqtype == REDIS_REQ_INLINE) {
-            if (processInlineBuffer(c) != REDIS_OK) break;
-        } else if (c->reqtype == REDIS_REQ_MULTIBULK) {
-            if (processMultibulkBuffer(c) != REDIS_OK) break;
+        if (c->reqtype == PROTO_REQ_INLINE) {
+            if (processInlineBuffer(c) != C_OK) break;
+        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
+            if (processMultibulkBuffer(c) != C_OK) break;
         } else {
-            redisPanic("Unknown request type");
+            serverPanic("Unknown request type");
         }
 
         /* Multibulk processing could see a <= 0 length. */
         if (c->argc == 0) {
             resetClient(c);
         } else {
             /* Only reset the client when the command was executed. */
-            if (processCommand(c) == REDIS_OK)
+            if (processCommand(c) == C_OK)
                 resetClient(c);
+            /* freeMemoryIfNeeded may flush slave output buffers. This may result
+             * into a slave, that may be the active client, to be freed. */
+            if (server.current_client == NULL) break;
         }
     }
+    server.current_client = NULL;
 }
 
 void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
-    redisClient *c = (redisClient*) privdata;
+    client *c = (client*) privdata;
     int nread, readlen;
     size_t qblen;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(mask);
+    UNUSED(el);
+    UNUSED(mask);
 
-    server.current_client = c;
-    readlen = REDIS_IOBUF_LEN;
+    readlen = PROTO_IOBUF_LEN;
     /* If this is a multi bulk request, and we are processing a bulk reply
      * that is large enough, try to maximize the probability that the query
      * buffer contains exactly the SDS string representing the object, even
      * at the risk of requiring more read(2) calls. This way the function
      * processMultiBulkBuffer() can avoid copying buffers to create the
      * Redis Object representing the argument. */
-    if (c->reqtype == REDIS_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1
-        && c->bulklen >= REDIS_MBULK_BIG_ARG)
+    if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1
+        && c->bulklen >= PROTO_MBULK_BIG_ARG)
     {
         int remaining = (unsigned)(c->bulklen+2)-sdslen(c->querybuf);
 
         if (remaining < readlen) readlen = remaining;
     }
 
     qblen = sdslen(c->querybuf);
     if (c->querybuf_peak < qblen) c->querybuf_peak = qblen;
     c->querybuf = sdsMakeRoomFor(c->querybuf, readlen);
     nread = read(fd, c->querybuf+qblen, readlen);
     if (nread == -1) {
         if (errno == EAGAIN) {
-            nread = 0;
+            return;
         } else {
-            redisLog(REDIS_VERBOSE, "Reading from client: %s",strerror(errno));
+            serverLog(LL_VERBOSE, "Reading from client: %s",strerror(errno));
             freeClient(c);
             return;
         }
     } else if (nread == 0) {
-        redisLog(REDIS_VERBOSE, "Client closed connection");
+        serverLog(LL_VERBOSE, "Client closed connection");
         freeClient(c);
         return;
     }
-    if (nread) {
-        sdsIncrLen(c->querybuf,nread);
-        c->lastinteraction = server.unixtime;
-        if (c->flags & REDIS_MASTER) c->reploff += nread;
-        server.stat_net_input_bytes += nread;
-    } else {
-        server.current_client = NULL;
-        return;
-    }
+
+    sdsIncrLen(c->querybuf,nread);
+    c->lastinteraction = server.unixtime;
+    if (c->flags & CLIENT_MASTER) c->reploff += nread;
+    server.stat_net_input_bytes += nread;
     if (sdslen(c->querybuf) > server.client_max_querybuf_len) {
         sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();
 
         bytes = sdscatrepr(bytes,c->querybuf,64);
-        redisLog(REDIS_WARNING,"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)", ci, bytes);
+        serverLog(LL_WARNING,"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)", ci, bytes);
         sdsfree(ci);
         sdsfree(bytes);
         freeClient(c);
         return;
     }
     processInputBuffer(c);
-    server.current_client = NULL;
 }
 
 void getClientsMaxBuffers(unsigned long *longest_output_list,
                           unsigned long *biggest_input_buffer) {
-    redisClient *c;
+    client *c;
     listNode *ln;
     listIter li;
     unsigned long lol = 0, bib = 0;
 
     listRewind(server.clients,&li);
     while ((ln = listNext(&li)) != NULL) {
@@ -1229,88 +1375,70 @@
         if (sdslen(c->querybuf) > bib) bib = sdslen(c->querybuf);
     }
     *longest_output_list = lol;
     *biggest_input_buffer = bib;
 }
 
-/* This is a helper function for genClientPeerId().
- * It writes the specified ip/port to "peerid" as a null termiated string
- * in the form ip:port if ip does not contain ":" itself, otherwise
- * [ip]:port format is used (for IPv6 addresses basically). */
-void formatPeerId(char *peerid, size_t peerid_len, char *ip, int port) {
-    if (strchr(ip,':'))
-        snprintf(peerid,peerid_len,"[%s]:%d",ip,port);
-    else
-        snprintf(peerid,peerid_len,"%s:%d",ip,port);
-}
-
 /* A Redis "Peer ID" is a colon separated ip:port pair.
  * For IPv4 it's in the form x.y.z.k:port, example: "127.0.0.1:1234".
  * For IPv6 addresses we use [] around the IP part, like in "[::1]:1234".
  * For Unix sockets we use path:0, like in "/tmp/redis:0".
  *
- * A Peer ID always fits inside a buffer of REDIS_PEER_ID_LEN bytes, including
+ * A Peer ID always fits inside a buffer of NET_PEER_ID_LEN bytes, including
  * the null term.
  *
- * The function returns REDIS_OK on succcess, and REDIS_ERR on failure.
- *
  * On failure the function still populates 'peerid' with the "?:0" string
  * in case you want to relax error checking or need to display something
  * anyway (see anetPeerToString implementation for more info). */
-int genClientPeerId(redisClient *client, char *peerid, size_t peerid_len) {
-    char ip[REDIS_IP_STR_LEN];
-    int port;
-
-    if (client->flags & REDIS_UNIX_SOCKET) {
+void genClientPeerId(client *client, char *peerid,
+                            size_t peerid_len) {
+    if (client->flags & CLIENT_UNIX_SOCKET) {
         /* Unix socket client. */
         snprintf(peerid,peerid_len,"%s:0",server.unixsocket);
-        return REDIS_OK;
     } else {
         /* TCP client. */
-        int retval = anetPeerToString(client->fd,ip,sizeof(ip),&port);
-        formatPeerId(peerid,peerid_len,ip,port);
-        return (retval == -1) ? REDIS_ERR : REDIS_OK;
+        anetFormatPeer(client->fd,peerid,peerid_len);
     }
 }
 
 /* This function returns the client peer id, by creating and caching it
  * if client->peerid is NULL, otherwise returning the cached value.
  * The Peer ID never changes during the life of the client, however it
  * is expensive to compute. */
-char *getClientPeerId(redisClient *c) {
-    char peerid[REDIS_PEER_ID_LEN];
+char *getClientPeerId(client *c) {
+    char peerid[NET_PEER_ID_LEN];
 
     if (c->peerid == NULL) {
         genClientPeerId(c,peerid,sizeof(peerid));
         c->peerid = sdsnew(peerid);
     }
     return c->peerid;
 }
 
 /* Concatenate a string representing the state of a client in an human
  * readable format, into the sds string 's'. */
-sds catClientInfoString(sds s, redisClient *client) {
+sds catClientInfoString(sds s, client *client) {
     char flags[16], events[3], *p;
     int emask;
 
     p = flags;
-    if (client->flags & REDIS_SLAVE) {
-        if (client->flags & REDIS_MONITOR)
+    if (client->flags & CLIENT_SLAVE) {
+        if (client->flags & CLIENT_MONITOR)
             *p++ = 'O';
         else
             *p++ = 'S';
     }
-    if (client->flags & REDIS_MASTER) *p++ = 'M';
-    if (client->flags & REDIS_MULTI) *p++ = 'x';
-    if (client->flags & REDIS_BLOCKED) *p++ = 'b';
-    if (client->flags & REDIS_DIRTY_CAS) *p++ = 'd';
-    if (client->flags & REDIS_CLOSE_AFTER_REPLY) *p++ = 'c';
-    if (client->flags & REDIS_UNBLOCKED) *p++ = 'u';
-    if (client->flags & REDIS_CLOSE_ASAP) *p++ = 'A';
-    if (client->flags & REDIS_UNIX_SOCKET) *p++ = 'U';
-    if (client->flags & REDIS_READONLY) *p++ = 'r';
+    if (client->flags & CLIENT_MASTER) *p++ = 'M';
+    if (client->flags & CLIENT_MULTI) *p++ = 'x';
+    if (client->flags & CLIENT_BLOCKED) *p++ = 'b';
+    if (client->flags & CLIENT_DIRTY_CAS) *p++ = 'd';
+    if (client->flags & CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';
+    if (client->flags & CLIENT_UNBLOCKED) *p++ = 'u';
+    if (client->flags & CLIENT_CLOSE_ASAP) *p++ = 'A';
+    if (client->flags & CLIENT_UNIX_SOCKET) *p++ = 'U';
+    if (client->flags & CLIENT_READONLY) *p++ = 'r';
     if (p == flags) *p++ = 'N';
     *p++ = '\0';
 
     emask = client->fd == -1 ? 0 : aeGetFileEvents(server.el,client->fd);
     p = events;
     if (emask & AE_READABLE) *p++ = 'r';
@@ -1325,48 +1453,61 @@
         (long long)(server.unixtime - client->ctime),
         (long long)(server.unixtime - client->lastinteraction),
         flags,
         client->db->id,
         (int) dictSize(client->pubsub_channels),
         (int) listLength(client->pubsub_patterns),
-        (client->flags & REDIS_MULTI) ? client->mstate.count : -1,
+        (client->flags & CLIENT_MULTI) ? client->mstate.count : -1,
         (unsigned long long) sdslen(client->querybuf),
         (unsigned long long) sdsavail(client->querybuf),
         (unsigned long long) client->bufpos,
         (unsigned long long) listLength(client->reply),
         (unsigned long long) getClientOutputBufferMemoryUsage(client),
         events,
         client->lastcmd ? client->lastcmd->name : "NULL");
 }
 
 sds getAllClientsInfoString(void) {
     listNode *ln;
     listIter li;
-    redisClient *client;
-    sds o = sdsempty();
-
-    o = sdsMakeRoomFor(o,200*listLength(server.clients));
+    client *client;
+    sds o = sdsnewlen(NULL,200*listLength(server.clients));
+    sdsclear(o);
     listRewind(server.clients,&li);
     while ((ln = listNext(&li)) != NULL) {
         client = listNodeValue(ln);
         o = catClientInfoString(o,client);
         o = sdscatlen(o,"\n",1);
     }
     return o;
 }
 
-void clientCommand(redisClient *c) {
+void clientCommand(client *c) {
     listNode *ln;
     listIter li;
-    redisClient *client;
+    client *client;
 
     if (!strcasecmp(c->argv[1]->ptr,"list") && c->argc == 2) {
         /* CLIENT LIST */
         sds o = getAllClientsInfoString();
         addReplyBulkCBuffer(c,o,sdslen(o));
         sdsfree(o);
+    } else if (!strcasecmp(c->argv[1]->ptr,"reply") && c->argc == 3) {
+        /* CLIENT REPLY ON|OFF|SKIP */
+        if (!strcasecmp(c->argv[2]->ptr,"on")) {
+            c->flags &= ~(CLIENT_REPLY_SKIP|CLIENT_REPLY_OFF);
+            addReply(c,shared.ok);
+        } else if (!strcasecmp(c->argv[2]->ptr,"off")) {
+            c->flags |= CLIENT_REPLY_OFF;
+        } else if (!strcasecmp(c->argv[2]->ptr,"skip")) {
+            if (!(c->flags & CLIENT_REPLY_OFF))
+                c->flags |= CLIENT_REPLY_SKIP_NEXT;
+        } else {
+            addReply(c,shared.syntaxerr);
+            return;
+        }
     } else if (!strcasecmp(c->argv[1]->ptr,"kill")) {
         /* CLIENT KILL <ip:port>
          * CLIENT KILL <option> [value] ... <option> [value] */
         char *addr = NULL;
         int type = -1;
         uint64_t id = 0;
@@ -1385,13 +1526,13 @@
                 int moreargs = c->argc > i+1;
 
                 if (!strcasecmp(c->argv[i]->ptr,"id") && moreargs) {
                     long long tmp;
 
                     if (getLongLongFromObjectOrReply(c,c->argv[i+1],&tmp,NULL)
-                        != REDIS_OK) return;
+                        != C_OK) return;
                     id = tmp;
                 } else if (!strcasecmp(c->argv[i]->ptr,"type") && moreargs) {
                     type = getClientTypeByName(c->argv[i+1]->ptr);
                     if (type == -1) {
                         addReplyErrorFormat(c,"Unknown client type '%s'",
                             (char*) c->argv[i+1]->ptr);
@@ -1421,15 +1562,13 @@
 
         /* Iterate clients killing all the matching clients. */
         listRewind(server.clients,&li);
         while ((ln = listNext(&li)) != NULL) {
             client = listNodeValue(ln);
             if (addr && strcmp(getClientPeerId(client),addr) != 0) continue;
-            if (type != -1 &&
-                (client->flags & REDIS_MASTER ||
-                 getClientType(client) != type)) continue;
+            if (type != -1 && getClientType(client) != type) continue;
             if (id != 0 && client->id != id) continue;
             if (c == client && skipme) continue;
 
             /* Kill it. */
             if (c == client) {
                 close_this_client = 1;
@@ -1448,13 +1587,13 @@
         } else {
             addReplyLongLong(c,killed);
         }
 
         /* If this client has to be closed, flag it as CLOSE_AFTER_REPLY
          * only after we queued the reply to its output buffers. */
-        if (close_this_client) c->flags |= REDIS_CLOSE_AFTER_REPLY;
+        if (close_this_client) c->flags |= CLIENT_CLOSE_AFTER_REPLY;
     } else if (!strcasecmp(c->argv[1]->ptr,"setname") && c->argc == 3) {
         int j, len = sdslen(c->argv[2]->ptr);
         char *p = c->argv[2]->ptr;
 
         /* Setting the client name to an empty string actually removes
          * the current name. */
@@ -1486,24 +1625,24 @@
         else
             addReply(c,shared.nullbulk);
     } else if (!strcasecmp(c->argv[1]->ptr,"pause") && c->argc == 3) {
         long long duration;
 
         if (getTimeoutFromObjectOrReply(c,c->argv[2],&duration,UNIT_MILLISECONDS)
-                                        != REDIS_OK) return;
+                                        != C_OK) return;
         pauseClients(duration);
         addReply(c,shared.ok);
     } else {
         addReplyError(c, "Syntax error, try CLIENT (LIST | KILL ip:port | GETNAME | SETNAME connection-name)");
     }
 }
 
 /* Rewrite the command vector of the client. All the new objects ref count
  * is incremented. The old command vector is freed, and the old objects
  * ref count is decremented. */
-void rewriteClientCommandVector(redisClient *c, int argc, ...) {
+void rewriteClientCommandVector(client *c, int argc, ...) {
     va_list ap;
     int j;
     robj **argv; /* The new argument vector */
 
     argv = zmalloc(sizeof(robj*)*argc);
     va_start(ap,argc);
@@ -1520,24 +1659,24 @@
     for (j = 0; j < c->argc; j++) decrRefCount(c->argv[j]);
     zfree(c->argv);
     /* Replace argv and argc with our new versions. */
     c->argv = argv;
     c->argc = argc;
     c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
-    redisAssertWithInfo(c,NULL,c->cmd != NULL);
+    serverAssertWithInfo(c,NULL,c->cmd != NULL);
     va_end(ap);
 }
 
 /* Completely replace the client command vector with the provided one. */
-void replaceClientCommandVector(redisClient *c, int argc, robj **argv) {
+void replaceClientCommandVector(client *c, int argc, robj **argv) {
     freeClientArgv(c);
     zfree(c->argv);
     c->argv = argv;
     c->argc = argc;
     c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
-    redisAssertWithInfo(c,NULL,c->cmd != NULL);
+    serverAssertWithInfo(c,NULL,c->cmd != NULL);
 }
 
 /* Rewrite a single item in the command vector.
  * The new val ref count is incremented, and the old decremented.
  *
  * It is possible to specify an argument over the current size of the
@@ -1545,13 +1684,13 @@
  * and c->argc set to the max value. However it's up to the caller to
  *
  * 1. Make sure there are no "holes" and all the arguments are set.
  * 2. If the original argument vector was longer than the one we
  *    want to end with, it's up to the caller to set c->argc and
  *    free the no longer used objects on c->argv. */
-void rewriteClientCommandArgument(redisClient *c, int i, robj *newval) {
+void rewriteClientCommandArgument(client *c, int i, robj *newval) {
     robj *oldval;
 
     if (i >= c->argc) {
         c->argv = zrealloc(c->argv,sizeof(robj*)*(i+1));
         c->argc = i+1;
         c->argv[i] = NULL;
@@ -1561,13 +1700,13 @@
     incrRefCount(newval);
     if (oldval) decrRefCount(oldval);
 
     /* If this is the command name make sure to fix c->cmd. */
     if (i == 0) {
         c->cmd = lookupCommandOrOriginal(c->argv[0]->ptr);
-        redisAssertWithInfo(c,NULL,c->cmd != NULL);
+        serverAssertWithInfo(c,NULL,c->cmd != NULL);
     }
 }
 
 /* This function returns the number of bytes that Redis is virtually
  * using to store the reply still not read by the client.
  * It is "virtual" since the reply output list may contain objects that
@@ -1578,61 +1717,68 @@
  * list node. The static reply buffer is not taken into account since it
  * is allocated anyway.
  *
  * Note: this function is very fast so can be called as many time as
  * the caller wishes. The main usage of this function currently is
  * enforcing the client output length limits. */
-unsigned long getClientOutputBufferMemoryUsage(redisClient *c) {
+unsigned long getClientOutputBufferMemoryUsage(client *c) {
     unsigned long list_item_size = sizeof(listNode)+sizeof(robj);
 
     return c->reply_bytes + (list_item_size*listLength(c->reply));
 }
 
 /* Get the class of a client, used in order to enforce limits to different
  * classes of clients.
  *
  * The function will return one of the following:
- * REDIS_CLIENT_TYPE_NORMAL -> Normal client
- * REDIS_CLIENT_TYPE_SLAVE  -> Slave or client executing MONITOR command
- * REDIS_CLIENT_TYPE_PUBSUB -> Client subscribed to Pub/Sub channels
+ * CLIENT_TYPE_NORMAL -> Normal client
+ * CLIENT_TYPE_SLAVE  -> Slave or client executing MONITOR command
+ * CLIENT_TYPE_PUBSUB -> Client subscribed to Pub/Sub channels
+ * CLIENT_TYPE_MASTER -> The client representing our replication master.
  */
-int getClientType(redisClient *c) {
-    if ((c->flags & REDIS_SLAVE) && !(c->flags & REDIS_MONITOR))
-        return REDIS_CLIENT_TYPE_SLAVE;
-    if (c->flags & REDIS_PUBSUB)
-        return REDIS_CLIENT_TYPE_PUBSUB;
-    return REDIS_CLIENT_TYPE_NORMAL;
+int getClientType(client *c) {
+    if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;
+    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))
+        return CLIENT_TYPE_SLAVE;
+    if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;
+    return CLIENT_TYPE_NORMAL;
 }
 
 int getClientTypeByName(char *name) {
-    if (!strcasecmp(name,"normal")) return REDIS_CLIENT_TYPE_NORMAL;
-    else if (!strcasecmp(name,"slave")) return REDIS_CLIENT_TYPE_SLAVE;
-    else if (!strcasecmp(name,"pubsub")) return REDIS_CLIENT_TYPE_PUBSUB;
+    if (!strcasecmp(name,"normal")) return CLIENT_TYPE_NORMAL;
+    else if (!strcasecmp(name,"slave")) return CLIENT_TYPE_SLAVE;
+    else if (!strcasecmp(name,"pubsub")) return CLIENT_TYPE_PUBSUB;
+    else if (!strcasecmp(name,"master")) return CLIENT_TYPE_MASTER;
     else return -1;
 }
 
 char *getClientTypeName(int class) {
     switch(class) {
-    case REDIS_CLIENT_TYPE_NORMAL: return "normal";
-    case REDIS_CLIENT_TYPE_SLAVE:  return "slave";
-    case REDIS_CLIENT_TYPE_PUBSUB: return "pubsub";
+    case CLIENT_TYPE_NORMAL: return "normal";
+    case CLIENT_TYPE_SLAVE:  return "slave";
+    case CLIENT_TYPE_PUBSUB: return "pubsub";
+    case CLIENT_TYPE_MASTER: return "master";
     default:                       return NULL;
     }
 }
 
 /* The function checks if the client reached output buffer soft or hard
  * limit, and also update the state needed to check the soft limit as
  * a side effect.
  *
  * Return value: non-zero if the client reached the soft or the hard limit.
  *               Otherwise zero is returned. */
-int checkClientOutputBufferLimits(redisClient *c) {
+int checkClientOutputBufferLimits(client *c) {
     int soft = 0, hard = 0, class;
     unsigned long used_mem = getClientOutputBufferMemoryUsage(c);
 
     class = getClientType(c);
+    /* For the purpose of output buffer limiting, masters are handled
+     * like normal clients. */
+    if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;
+
     if (server.client_obuf_limits[class].hard_limit_bytes &&
         used_mem >= server.client_obuf_limits[class].hard_limit_bytes)
         hard = 1;
     if (server.client_obuf_limits[class].soft_limit_bytes &&
         used_mem >= server.client_obuf_limits[class].soft_limit_bytes)
         soft = 1;
@@ -1658,52 +1804,54 @@
     }
     return soft || hard;
 }
 
 /* Asynchronously close a client if soft or hard limit is reached on the
  * output buffer size. The caller can check if the client will be closed
- * checking if the client REDIS_CLOSE_ASAP flag is set.
+ * checking if the client CLIENT_CLOSE_ASAP flag is set.
  *
  * Note: we need to close the client asynchronously because this function is
  * called from contexts where the client can't be freed safely, i.e. from the
  * lower level functions pushing data inside the client output buffers. */
-void asyncCloseClientOnOutputBufferLimitReached(redisClient *c) {
-    redisAssert(c->reply_bytes < ULONG_MAX-(1024*64));
-    if (c->reply_bytes == 0 || c->flags & REDIS_CLOSE_ASAP) return;
+void asyncCloseClientOnOutputBufferLimitReached(client *c) {
+    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
+    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
     if (checkClientOutputBufferLimits(c)) {
         sds client = catClientInfoString(sdsempty(),c);
 
         freeClientAsync(c);
-        redisLog(REDIS_WARNING,"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.", client);
+        serverLog(LL_WARNING,"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.", client);
         sdsfree(client);
     }
 }
 
 /* Helper function used by freeMemoryIfNeeded() in order to flush slaves
- * output buffers without returning control to the event loop. */
+ * output buffers without returning control to the event loop.
+ * This is also called by SHUTDOWN for a best-effort attempt to send
+ * slaves the latest writes. */
 void flushSlavesOutputBuffers(void) {
     listIter li;
     listNode *ln;
 
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
-        redisClient *slave = listNodeValue(ln);
+        client *slave = listNodeValue(ln);
         int events;
 
         /* Note that the following will not flush output buffers of slaves
          * in STATE_ONLINE but having put_online_on_ack set to true: in this
          * case the writable event is never installed, since the purpose
          * of put_online_on_ack is to postpone the moment it is installed.
          * This is what we want since slaves in this state should not receive
          * writes before the first ACK. */
         events = aeGetFileEvents(server.el,slave->fd);
         if (events & AE_WRITABLE &&
-            slave->replstate == REDIS_REPL_ONLINE &&
-            listLength(slave->reply))
+            slave->replstate == SLAVE_STATE_ONLINE &&
+            clientHasPendingReplies(slave))
         {
-            sendReplyToClient(server.el,slave->fd,slave,0);
+            writeToClient(slave->fd,slave,0);
         }
     }
 }
 
 /* Pause clients up to the specified unixtime (in ms). While clients
  * are paused no command is processed from clients, so the data set can't
@@ -1733,26 +1881,26 @@
 int clientsArePaused(void) {
     if (server.clients_paused &&
         server.clients_pause_end_time < server.mstime)
     {
         listNode *ln;
         listIter li;
-        redisClient *c;
+        client *c;
 
         server.clients_paused = 0;
 
         /* Put all the clients in the unblocked clients queue in order to
          * force the re-processing of the input buffer if any. */
         listRewind(server.clients,&li);
         while ((ln = listNext(&li)) != NULL) {
             c = listNodeValue(ln);
 
             /* Don't touch slaves and blocked clients. The latter pending
              * requests be processed when unblocked. */
-            if (c->flags & (REDIS_SLAVE|REDIS_BLOCKED)) continue;
-            c->flags |= REDIS_UNBLOCKED;
+            if (c->flags & (CLIENT_SLAVE|CLIENT_BLOCKED)) continue;
+            c->flags |= CLIENT_UNBLOCKED;
             listAddNodeTail(server.unblocked_clients,c);
         }
     }
     return server.clients_paused;
 }
 
@@ -1760,21 +1908,23 @@
  * time to time while blocked into some not interruptible operation.
  * This allows to reply to clients with the -LOADING error while loading the
  * data set at startup or after a full resynchronization with the master
  * and so forth.
  *
  * It calls the event loop in order to process a few events. Specifically we
- * try to call the event loop for times as long as we receive acknowledge that
+ * try to call the event loop 4 times as long as we receive acknowledge that
  * some event was processed, in order to go forward with the accept, read,
  * write, close sequence needed to serve a client.
  *
  * The function returns the total number of events processed. */
 int processEventsWhileBlocked(void) {
     int iterations = 4; /* See the function top-comment. */
     int count = 0;
     while (iterations--) {
-        int events = aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);
+        int events = 0;
+        events += aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);
+        events += handleClientsWithPendingWrites();
         if (!events) break;
         count += events;
     }
     return count;
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/networking.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/networking.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/networking.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/networking.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/notify.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/notify.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/notify.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/notify.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,13 +24,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 /* This file implements keyspace events notification via Pub/Sub ad
  * described at http://redis.io/topics/keyspace-events. */
 
 /* Turn a string representing notification classes into an integer
  * representing notification classes flags xored.
@@ -40,23 +40,23 @@
 int keyspaceEventsStringToFlags(char *classes) {
     char *p = classes;
     int c, flags = 0;
 
     while((c = *p++) != '\0') {
         switch(c) {
-        case 'A': flags |= REDIS_NOTIFY_ALL; break;
-        case 'g': flags |= REDIS_NOTIFY_GENERIC; break;
-        case '$': flags |= REDIS_NOTIFY_STRING; break;
-        case 'l': flags |= REDIS_NOTIFY_LIST; break;
-        case 's': flags |= REDIS_NOTIFY_SET; break;
-        case 'h': flags |= REDIS_NOTIFY_HASH; break;
-        case 'z': flags |= REDIS_NOTIFY_ZSET; break;
-        case 'x': flags |= REDIS_NOTIFY_EXPIRED; break;
-        case 'e': flags |= REDIS_NOTIFY_EVICTED; break;
-        case 'K': flags |= REDIS_NOTIFY_KEYSPACE; break;
-        case 'E': flags |= REDIS_NOTIFY_KEYEVENT; break;
+        case 'A': flags |= NOTIFY_ALL; break;
+        case 'g': flags |= NOTIFY_GENERIC; break;
+        case '$': flags |= NOTIFY_STRING; break;
+        case 'l': flags |= NOTIFY_LIST; break;
+        case 's': flags |= NOTIFY_SET; break;
+        case 'h': flags |= NOTIFY_HASH; break;
+        case 'z': flags |= NOTIFY_ZSET; break;
+        case 'x': flags |= NOTIFY_EXPIRED; break;
+        case 'e': flags |= NOTIFY_EVICTED; break;
+        case 'K': flags |= NOTIFY_KEYSPACE; break;
+        case 'E': flags |= NOTIFY_KEYEVENT; break;
         default: return -1;
         }
     }
     return flags;
 }
 
@@ -65,26 +65,26 @@
  * the selected classes. The string returned is an sds string that needs to
  * be released with sdsfree(). */
 sds keyspaceEventsFlagsToString(int flags) {
     sds res;
 
     res = sdsempty();
-    if ((flags & REDIS_NOTIFY_ALL) == REDIS_NOTIFY_ALL) {
+    if ((flags & NOTIFY_ALL) == NOTIFY_ALL) {
         res = sdscatlen(res,"A",1);
     } else {
-        if (flags & REDIS_NOTIFY_GENERIC) res = sdscatlen(res,"g",1);
-        if (flags & REDIS_NOTIFY_STRING) res = sdscatlen(res,"$",1);
-        if (flags & REDIS_NOTIFY_LIST) res = sdscatlen(res,"l",1);
-        if (flags & REDIS_NOTIFY_SET) res = sdscatlen(res,"s",1);
-        if (flags & REDIS_NOTIFY_HASH) res = sdscatlen(res,"h",1);
-        if (flags & REDIS_NOTIFY_ZSET) res = sdscatlen(res,"z",1);
-        if (flags & REDIS_NOTIFY_EXPIRED) res = sdscatlen(res,"x",1);
-        if (flags & REDIS_NOTIFY_EVICTED) res = sdscatlen(res,"e",1);
+        if (flags & NOTIFY_GENERIC) res = sdscatlen(res,"g",1);
+        if (flags & NOTIFY_STRING) res = sdscatlen(res,"$",1);
+        if (flags & NOTIFY_LIST) res = sdscatlen(res,"l",1);
+        if (flags & NOTIFY_SET) res = sdscatlen(res,"s",1);
+        if (flags & NOTIFY_HASH) res = sdscatlen(res,"h",1);
+        if (flags & NOTIFY_ZSET) res = sdscatlen(res,"z",1);
+        if (flags & NOTIFY_EXPIRED) res = sdscatlen(res,"x",1);
+        if (flags & NOTIFY_EVICTED) res = sdscatlen(res,"e",1);
     }
-    if (flags & REDIS_NOTIFY_KEYSPACE) res = sdscatlen(res,"K",1);
-    if (flags & REDIS_NOTIFY_KEYEVENT) res = sdscatlen(res,"E",1);
+    if (flags & NOTIFY_KEYSPACE) res = sdscatlen(res,"K",1);
+    if (flags & NOTIFY_KEYEVENT) res = sdscatlen(res,"E",1);
     return res;
 }
 
 /* The API provided to the rest of the Redis core is a simple function:
  *
  * notifyKeyspaceEvent(char *event, robj *key, int dbid);
@@ -101,30 +101,30 @@
     /* If notifications for this class of events are off, return ASAP. */
     if (!(server.notify_keyspace_events & type)) return;
 
     eventobj = createStringObject(event,strlen(event));
 
     /* __keyspace@<db>__:<key> <event> notifications. */
-    if (server.notify_keyspace_events & REDIS_NOTIFY_KEYSPACE) {
+    if (server.notify_keyspace_events & NOTIFY_KEYSPACE) {
         chan = sdsnewlen("__keyspace@",11);
         len = ll2string(buf,sizeof(buf),dbid);
         chan = sdscatlen(chan, buf, len);
         chan = sdscatlen(chan, "__:", 3);
         chan = sdscatsds(chan, key->ptr);
-        chanobj = createObject(REDIS_STRING, chan);
+        chanobj = createObject(OBJ_STRING, chan);
         pubsubPublishMessage(chanobj, eventobj);
         decrRefCount(chanobj);
     }
 
     /* __keyevente@<db>__:<event> <key> notifications. */
-    if (server.notify_keyspace_events & REDIS_NOTIFY_KEYEVENT) {
+    if (server.notify_keyspace_events & NOTIFY_KEYEVENT) {
         chan = sdsnewlen("__keyevent@",11);
         if (len == -1) len = ll2string(buf,sizeof(buf),dbid);
         chan = sdscatlen(chan, buf, len);
         chan = sdscatlen(chan, "__:", 3);
         chan = sdscatsds(chan, eventobj->ptr);
-        chanobj = createObject(REDIS_STRING, chan);
+        chanobj = createObject(OBJ_STRING, chan);
         pubsubPublishMessage(chanobj, key);
         decrRefCount(chanobj);
     }
     decrRefCount(eventobj);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/notify.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/notify.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/notify.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/notify.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/object.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/object.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/object.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/object.c	2016-05-06 15:11:36.000000000 +0800
@@ -25,53 +25,54 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include <math.h>
 #include <ctype.h>
 
 #ifdef __CYGWIN__
 #define strtold(a,b) ((long double)strtod((a),(b)))
 #endif
 
 robj *createObject(int type, void *ptr) {
     robj *o = zmalloc(sizeof(*o));
     o->type = type;
-    o->encoding = REDIS_ENCODING_RAW;
+    o->encoding = OBJ_ENCODING_RAW;
     o->ptr = ptr;
     o->refcount = 1;
 
     /* Set the LRU to the current lruclock (minutes resolution). */
     o->lru = LRU_CLOCK();
     return o;
 }
 
-/* Create a string object with encoding REDIS_ENCODING_RAW, that is a plain
+/* Create a string object with encoding OBJ_ENCODING_RAW, that is a plain
  * string object where o->ptr points to a proper sds string. */
-robj *createRawStringObject(char *ptr, size_t len) {
-    return createObject(REDIS_STRING,sdsnewlen(ptr,len));
+robj *createRawStringObject(const char *ptr, size_t len) {
+    return createObject(OBJ_STRING,sdsnewlen(ptr,len));
 }
 
-/* Create a string object with encoding REDIS_ENCODING_EMBSTR, that is
+/* Create a string object with encoding OBJ_ENCODING_EMBSTR, that is
  * an object where the sds string is actually an unmodifiable string
  * allocated in the same chunk as the object itself. */
-robj *createEmbeddedStringObject(char *ptr, size_t len) {
-    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr)+len+1);
-    struct sdshdr *sh = (void*)(o+1);
+robj *createEmbeddedStringObject(const char *ptr, size_t len) {
+    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);
+    struct sdshdr8 *sh = (void*)(o+1);
 
-    o->type = REDIS_STRING;
-    o->encoding = REDIS_ENCODING_EMBSTR;
+    o->type = OBJ_STRING;
+    o->encoding = OBJ_ENCODING_EMBSTR;
     o->ptr = sh+1;
     o->refcount = 1;
     o->lru = LRU_CLOCK();
 
     sh->len = len;
-    sh->free = 0;
+    sh->alloc = len;
+    sh->flags = SDS_TYPE_8;
     if (ptr) {
         memcpy(sh->buf,ptr,len);
         sh->buf[len] = '\0';
     } else {
         memset(sh->buf,0,len+1);
     }
@@ -81,32 +82,32 @@
 /* Create a string object with EMBSTR encoding if it is smaller than
  * REIDS_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is
  * used.
  *
  * The current limit of 39 is chosen so that the biggest string object
  * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */
-#define REDIS_ENCODING_EMBSTR_SIZE_LIMIT 39
-robj *createStringObject(char *ptr, size_t len) {
-    if (len <= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)
+#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
+robj *createStringObject(const char *ptr, size_t len) {
+    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
         return createEmbeddedStringObject(ptr,len);
     else
         return createRawStringObject(ptr,len);
 }
 
 robj *createStringObjectFromLongLong(long long value) {
     robj *o;
-    if (value >= 0 && value < REDIS_SHARED_INTEGERS) {
+    if (value >= 0 && value < OBJ_SHARED_INTEGERS) {
         incrRefCount(shared.integers[value]);
         o = shared.integers[value];
     } else {
         if (value >= LONG_MIN && value <= LONG_MAX) {
-            o = createObject(REDIS_STRING, NULL);
-            o->encoding = REDIS_ENCODING_INT;
+            o = createObject(OBJ_STRING, NULL);
+            o->encoding = OBJ_ENCODING_INT;
             o->ptr = (void*)((long)value);
         } else {
-            o = createObject(REDIS_STRING,sdsfromlonglong(value));
+            o = createObject(OBJ_STRING,sdsfromlonglong(value));
         }
     }
     return o;
 }
 
 /* Create a string object from a long double. If humanfriendly is non-zero
@@ -159,161 +160,157 @@
  * will always result in a fresh object that is unshared (refcount == 1).
  *
  * The resulting object always has refcount set to 1. */
 robj *dupStringObject(robj *o) {
     robj *d;
 
-    redisAssert(o->type == REDIS_STRING);
+    serverAssert(o->type == OBJ_STRING);
 
     switch(o->encoding) {
-    case REDIS_ENCODING_RAW:
+    case OBJ_ENCODING_RAW:
         return createRawStringObject(o->ptr,sdslen(o->ptr));
-    case REDIS_ENCODING_EMBSTR:
+    case OBJ_ENCODING_EMBSTR:
         return createEmbeddedStringObject(o->ptr,sdslen(o->ptr));
-    case REDIS_ENCODING_INT:
-        d = createObject(REDIS_STRING, NULL);
-        d->encoding = REDIS_ENCODING_INT;
+    case OBJ_ENCODING_INT:
+        d = createObject(OBJ_STRING, NULL);
+        d->encoding = OBJ_ENCODING_INT;
         d->ptr = o->ptr;
         return d;
     default:
-        redisPanic("Wrong encoding.");
+        serverPanic("Wrong encoding.");
         break;
     }
 }
 
-robj *createListObject(void) {
-    list *l = listCreate();
-    robj *o = createObject(REDIS_LIST,l);
-    listSetFreeMethod(l,decrRefCountVoid);
-    o->encoding = REDIS_ENCODING_LINKEDLIST;
+robj *createQuicklistObject(void) {
+    quicklist *l = quicklistCreate();
+    robj *o = createObject(OBJ_LIST,l);
+    o->encoding = OBJ_ENCODING_QUICKLIST;
     return o;
 }
 
 robj *createZiplistObject(void) {
     unsigned char *zl = ziplistNew();
-    robj *o = createObject(REDIS_LIST,zl);
-    o->encoding = REDIS_ENCODING_ZIPLIST;
+    robj *o = createObject(OBJ_LIST,zl);
+    o->encoding = OBJ_ENCODING_ZIPLIST;
     return o;
 }
 
 robj *createSetObject(void) {
     dict *d = dictCreate(&setDictType,NULL);
-    robj *o = createObject(REDIS_SET,d);
-    o->encoding = REDIS_ENCODING_HT;
+    robj *o = createObject(OBJ_SET,d);
+    o->encoding = OBJ_ENCODING_HT;
     return o;
 }
 
 robj *createIntsetObject(void) {
     intset *is = intsetNew();
-    robj *o = createObject(REDIS_SET,is);
-    o->encoding = REDIS_ENCODING_INTSET;
+    robj *o = createObject(OBJ_SET,is);
+    o->encoding = OBJ_ENCODING_INTSET;
     return o;
 }
 
 robj *createHashObject(void) {
     unsigned char *zl = ziplistNew();
-    robj *o = createObject(REDIS_HASH, zl);
-    o->encoding = REDIS_ENCODING_ZIPLIST;
+    robj *o = createObject(OBJ_HASH, zl);
+    o->encoding = OBJ_ENCODING_ZIPLIST;
     return o;
 }
 
 robj *createZsetObject(void) {
     zset *zs = zmalloc(sizeof(*zs));
     robj *o;
 
     zs->dict = dictCreate(&zsetDictType,NULL);
     zs->zsl = zslCreate();
-    o = createObject(REDIS_ZSET,zs);
-    o->encoding = REDIS_ENCODING_SKIPLIST;
+    o = createObject(OBJ_ZSET,zs);
+    o->encoding = OBJ_ENCODING_SKIPLIST;
     return o;
 }
 
 robj *createZsetZiplistObject(void) {
     unsigned char *zl = ziplistNew();
-    robj *o = createObject(REDIS_ZSET,zl);
-    o->encoding = REDIS_ENCODING_ZIPLIST;
+    robj *o = createObject(OBJ_ZSET,zl);
+    o->encoding = OBJ_ENCODING_ZIPLIST;
     return o;
 }
 
 void freeStringObject(robj *o) {
-    if (o->encoding == REDIS_ENCODING_RAW) {
+    if (o->encoding == OBJ_ENCODING_RAW) {
         sdsfree(o->ptr);
     }
 }
 
 void freeListObject(robj *o) {
     switch (o->encoding) {
-    case REDIS_ENCODING_LINKEDLIST:
-        listRelease((list*) o->ptr);
-        break;
-    case REDIS_ENCODING_ZIPLIST:
-        zfree(o->ptr);
+    case OBJ_ENCODING_QUICKLIST:
+        quicklistRelease(o->ptr);
         break;
     default:
-        redisPanic("Unknown list encoding type");
+        serverPanic("Unknown list encoding type");
     }
 }
 
 void freeSetObject(robj *o) {
     switch (o->encoding) {
-    case REDIS_ENCODING_HT:
+    case OBJ_ENCODING_HT:
         dictRelease((dict*) o->ptr);
         break;
-    case REDIS_ENCODING_INTSET:
+    case OBJ_ENCODING_INTSET:
         zfree(o->ptr);
         break;
     default:
-        redisPanic("Unknown set encoding type");
+        serverPanic("Unknown set encoding type");
     }
 }
 
 void freeZsetObject(robj *o) {
     zset *zs;
     switch (o->encoding) {
-    case REDIS_ENCODING_SKIPLIST:
+    case OBJ_ENCODING_SKIPLIST:
         zs = o->ptr;
         dictRelease(zs->dict);
         zslFree(zs->zsl);
         zfree(zs);
         break;
-    case REDIS_ENCODING_ZIPLIST:
+    case OBJ_ENCODING_ZIPLIST:
         zfree(o->ptr);
         break;
     default:
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 }
 
 void freeHashObject(robj *o) {
     switch (o->encoding) {
-    case REDIS_ENCODING_HT:
+    case OBJ_ENCODING_HT:
         dictRelease((dict*) o->ptr);
         break;
-    case REDIS_ENCODING_ZIPLIST:
+    case OBJ_ENCODING_ZIPLIST:
         zfree(o->ptr);
         break;
     default:
-        redisPanic("Unknown hash encoding type");
+        serverPanic("Unknown hash encoding type");
         break;
     }
 }
 
 void incrRefCount(robj *o) {
     o->refcount++;
 }
 
 void decrRefCount(robj *o) {
-    if (o->refcount <= 0) redisPanic("decrRefCount against refcount <= 0");
+    if (o->refcount <= 0) serverPanic("decrRefCount against refcount <= 0");
     if (o->refcount == 1) {
         switch(o->type) {
-        case REDIS_STRING: freeStringObject(o); break;
-        case REDIS_LIST: freeListObject(o); break;
-        case REDIS_SET: freeSetObject(o); break;
-        case REDIS_ZSET: freeZsetObject(o); break;
-        case REDIS_HASH: freeHashObject(o); break;
-        default: redisPanic("Unknown object type"); break;
+        case OBJ_STRING: freeStringObject(o); break;
+        case OBJ_LIST: freeListObject(o); break;
+        case OBJ_SET: freeSetObject(o); break;
+        case OBJ_ZSET: freeZsetObject(o); break;
+        case OBJ_HASH: freeHashObject(o); break;
+        default: serverPanic("Unknown object type"); break;
         }
         zfree(o);
     } else {
         o->refcount--;
     }
 }
@@ -339,27 +336,27 @@
  */
 robj *resetRefCount(robj *obj) {
     obj->refcount = 0;
     return obj;
 }
 
-int checkType(redisClient *c, robj *o, int type) {
+int checkType(client *c, robj *o, int type) {
     if (o->type != type) {
         addReply(c,shared.wrongtypeerr);
         return 1;
     }
     return 0;
 }
 
 int isObjectRepresentableAsLongLong(robj *o, long long *llval) {
-    redisAssertWithInfo(NULL,o,o->type == REDIS_STRING);
-    if (o->encoding == REDIS_ENCODING_INT) {
+    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
+    if (o->encoding == OBJ_ENCODING_INT) {
         if (llval) *llval = (long) o->ptr;
-        return REDIS_OK;
+        return C_OK;
     } else {
-        return string2ll(o->ptr,sdslen(o->ptr),llval) ? REDIS_OK : REDIS_ERR;
+        return string2ll(o->ptr,sdslen(o->ptr),llval) ? C_OK : C_ERR;
     }
 }
 
 /* Try to encode a string object in order to save space */
 robj *tryObjectEncoding(robj *o) {
     long value;
@@ -367,13 +364,13 @@
     size_t len;
 
     /* Make sure this is a string object, the only type we encode
      * in this function. Other types use encoded memory efficient
      * representations but are handled by the commands implementing
      * the type. */
-    redisAssertWithInfo(NULL,o,o->type == REDIS_STRING);
+    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
 
     /* We try some specialized encoding only for objects that are
      * RAW or EMBSTR encoded, in other words objects that are still
      * in represented by an actually array of chars. */
     if (!sdsEncodedObject(o)) return o;
 
@@ -389,36 +386,36 @@
     if (len <= 21 && string2l(s,len,&value)) {
         /* This object is encodable as a long. Try to use a shared object.
          * Note that we avoid using shared integers when maxmemory is used
          * because every object needs to have a private LRU field for the LRU
          * algorithm to work well. */
         if ((server.maxmemory == 0 ||
-             (server.maxmemory_policy != REDIS_MAXMEMORY_VOLATILE_LRU &&
-              server.maxmemory_policy != REDIS_MAXMEMORY_ALLKEYS_LRU)) &&
+             (server.maxmemory_policy != MAXMEMORY_VOLATILE_LRU &&
+              server.maxmemory_policy != MAXMEMORY_ALLKEYS_LRU)) &&
             value >= 0 &&
-            value < REDIS_SHARED_INTEGERS)
+            value < OBJ_SHARED_INTEGERS)
         {
             decrRefCount(o);
             incrRefCount(shared.integers[value]);
             return shared.integers[value];
         } else {
-            if (o->encoding == REDIS_ENCODING_RAW) sdsfree(o->ptr);
-            o->encoding = REDIS_ENCODING_INT;
+            if (o->encoding == OBJ_ENCODING_RAW) sdsfree(o->ptr);
+            o->encoding = OBJ_ENCODING_INT;
             o->ptr = (void*) value;
             return o;
         }
     }
 
     /* If the string is small and is still RAW encoded,
      * try the EMBSTR encoding which is more efficient.
      * In this representation the object and the SDS string are allocated
      * in the same chunk of memory to save space and cache misses. */
-    if (len <= REDIS_ENCODING_EMBSTR_SIZE_LIMIT) {
+    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) {
         robj *emb;
 
-        if (o->encoding == REDIS_ENCODING_EMBSTR) return o;
+        if (o->encoding == OBJ_ENCODING_EMBSTR) return o;
         emb = createEmbeddedStringObject(s,sdslen(s));
         decrRefCount(o);
         return emb;
     }
 
     /* We can't encode the object...
@@ -426,14 +423,14 @@
      * Do the last try, and at least optimize the SDS string inside
      * the string object to require little space, in case there
      * is more than 10% of free space at the end of the SDS string.
      *
      * We do that only for relatively large strings as this branch
      * is only entered if the length of the string is greater than
-     * REDIS_ENCODING_EMBSTR_SIZE_LIMIT. */
-    if (o->encoding == REDIS_ENCODING_RAW &&
+     * OBJ_ENCODING_EMBSTR_SIZE_LIMIT. */
+    if (o->encoding == OBJ_ENCODING_RAW &&
         sdsavail(s) > len/10)
     {
         o->ptr = sdsRemoveFreeSpace(o->ptr);
     }
 
     /* Return the original object. */
@@ -446,20 +443,20 @@
     robj *dec;
 
     if (sdsEncodedObject(o)) {
         incrRefCount(o);
         return o;
     }
-    if (o->type == REDIS_STRING && o->encoding == REDIS_ENCODING_INT) {
+    if (o->type == OBJ_STRING && o->encoding == OBJ_ENCODING_INT) {
         char buf[32];
 
         ll2string(buf,32,(long)o->ptr);
         dec = createStringObject(buf,strlen(buf));
         return dec;
     } else {
-        redisPanic("Unknown encoding type");
+        serverPanic("Unknown encoding type");
     }
 }
 
 /* Compare two string objects via strcmp() or strcoll() depending on flags.
  * Note that the objects may be integer-encoded. In such a case we
  * use ll2string() to get a string representation of the numbers on the stack
@@ -469,13 +466,13 @@
  * is used. */
 
 #define REDIS_COMPARE_BINARY (1<<0)
 #define REDIS_COMPARE_COLL (1<<1)
 
 int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {
-    redisAssertWithInfo(NULL,a,a->type == REDIS_STRING && b->type == REDIS_STRING);
+    serverAssertWithInfo(NULL,a,a->type == OBJ_STRING && b->type == OBJ_STRING);
     char bufa[128], bufb[128], *astr, *bstr;
     size_t alen, blen, minlen;
 
     if (a == b) return 0;
     if (sdsEncodedObject(a)) {
         astr = a->ptr;
@@ -515,212 +512,210 @@
 
 /* Equal string objects return 1 if the two objects are the same from the
  * point of view of a string comparison, otherwise 0 is returned. Note that
  * this function is faster then checking for (compareStringObject(a,b) == 0)
  * because it can perform some more optimization. */
 int equalStringObjects(robj *a, robj *b) {
-    if (a->encoding == REDIS_ENCODING_INT &&
-        b->encoding == REDIS_ENCODING_INT){
+    if (a->encoding == OBJ_ENCODING_INT &&
+        b->encoding == OBJ_ENCODING_INT){
         /* If both strings are integer encoded just check if the stored
          * long is the same. */
         return a->ptr == b->ptr;
     } else {
         return compareStringObjects(a,b) == 0;
     }
 }
 
 size_t stringObjectLen(robj *o) {
-    redisAssertWithInfo(NULL,o,o->type == REDIS_STRING);
+    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
     if (sdsEncodedObject(o)) {
         return sdslen(o->ptr);
     } else {
-        char buf[32];
-
-        return ll2string(buf,32,(long)o->ptr);
+        return sdigits10((long)o->ptr);
     }
 }
 
 int getDoubleFromObject(robj *o, double *target) {
     double value;
     char *eptr;
 
     if (o == NULL) {
         value = 0;
     } else {
-        redisAssertWithInfo(NULL,o,o->type == REDIS_STRING);
+        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
         if (sdsEncodedObject(o)) {
             errno = 0;
             value = strtod(o->ptr, &eptr);
             if (isspace(((char*)o->ptr)[0]) ||
                 eptr[0] != '\0' ||
                 (errno == ERANGE &&
                     (value == HUGE_VAL || value == -HUGE_VAL || value == 0)) ||
                 errno == EINVAL ||
                 isnan(value))
-                return REDIS_ERR;
-        } else if (o->encoding == REDIS_ENCODING_INT) {
+                return C_ERR;
+        } else if (o->encoding == OBJ_ENCODING_INT) {
             value = (long)o->ptr;
         } else {
-            redisPanic("Unknown string encoding");
+            serverPanic("Unknown string encoding");
         }
     }
     *target = value;
-    return REDIS_OK;
+    return C_OK;
 }
 
-int getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg) {
+int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg) {
     double value;
-    if (getDoubleFromObject(o, &value) != REDIS_OK) {
+    if (getDoubleFromObject(o, &value) != C_OK) {
         if (msg != NULL) {
             addReplyError(c,(char*)msg);
         } else {
             addReplyError(c,"value is not a valid float");
         }
-        return REDIS_ERR;
+        return C_ERR;
     }
     *target = value;
-    return REDIS_OK;
+    return C_OK;
 }
 
 int getLongDoubleFromObject(robj *o, long double *target) {
     long double value;
     char *eptr;
 
     if (o == NULL) {
         value = 0;
     } else {
-        redisAssertWithInfo(NULL,o,o->type == REDIS_STRING);
+        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
         if (sdsEncodedObject(o)) {
             errno = 0;
             value = strtold(o->ptr, &eptr);
             if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' ||
                 errno == ERANGE || isnan(value))
-                return REDIS_ERR;
-        } else if (o->encoding == REDIS_ENCODING_INT) {
+                return C_ERR;
+        } else if (o->encoding == OBJ_ENCODING_INT) {
             value = (long)o->ptr;
         } else {
-            redisPanic("Unknown string encoding");
+            serverPanic("Unknown string encoding");
         }
     }
     *target = value;
-    return REDIS_OK;
+    return C_OK;
 }
 
-int getLongDoubleFromObjectOrReply(redisClient *c, robj *o, long double *target, const char *msg) {
+int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg) {
     long double value;
-    if (getLongDoubleFromObject(o, &value) != REDIS_OK) {
+    if (getLongDoubleFromObject(o, &value) != C_OK) {
         if (msg != NULL) {
             addReplyError(c,(char*)msg);
         } else {
             addReplyError(c,"value is not a valid float");
         }
-        return REDIS_ERR;
+        return C_ERR;
     }
     *target = value;
-    return REDIS_OK;
+    return C_OK;
 }
 
 int getLongLongFromObject(robj *o, long long *target) {
     long long value;
     char *eptr;
 
     if (o == NULL) {
         value = 0;
     } else {
-        redisAssertWithInfo(NULL,o,o->type == REDIS_STRING);
+        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
         if (sdsEncodedObject(o)) {
             errno = 0;
             value = strtoll(o->ptr, &eptr, 10);
             if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' ||
                 errno == ERANGE)
-                return REDIS_ERR;
-        } else if (o->encoding == REDIS_ENCODING_INT) {
+                return C_ERR;
+        } else if (o->encoding == OBJ_ENCODING_INT) {
             value = (long)o->ptr;
         } else {
-            redisPanic("Unknown string encoding");
+            serverPanic("Unknown string encoding");
         }
     }
     if (target) *target = value;
-    return REDIS_OK;
+    return C_OK;
 }
 
-int getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg) {
+int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg) {
     long long value;
-    if (getLongLongFromObject(o, &value) != REDIS_OK) {
+    if (getLongLongFromObject(o, &value) != C_OK) {
         if (msg != NULL) {
             addReplyError(c,(char*)msg);
         } else {
             addReplyError(c,"value is not an integer or out of range");
         }
-        return REDIS_ERR;
+        return C_ERR;
     }
     *target = value;
-    return REDIS_OK;
+    return C_OK;
 }
 
-int getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg) {
+int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {
     long long value;
 
-    if (getLongLongFromObjectOrReply(c, o, &value, msg) != REDIS_OK) return REDIS_ERR;
+    if (getLongLongFromObjectOrReply(c, o, &value, msg) != C_OK) return C_ERR;
     if (value < LONG_MIN || value > LONG_MAX) {
         if (msg != NULL) {
             addReplyError(c,(char*)msg);
         } else {
             addReplyError(c,"value is out of range");
         }
-        return REDIS_ERR;
+        return C_ERR;
     }
     *target = value;
-    return REDIS_OK;
+    return C_OK;
 }
 
 char *strEncoding(int encoding) {
     switch(encoding) {
-    case REDIS_ENCODING_RAW: return "raw";
-    case REDIS_ENCODING_INT: return "int";
-    case REDIS_ENCODING_HT: return "hashtable";
-    case REDIS_ENCODING_LINKEDLIST: return "linkedlist";
-    case REDIS_ENCODING_ZIPLIST: return "ziplist";
-    case REDIS_ENCODING_INTSET: return "intset";
-    case REDIS_ENCODING_SKIPLIST: return "skiplist";
-    case REDIS_ENCODING_EMBSTR: return "embstr";
+    case OBJ_ENCODING_RAW: return "raw";
+    case OBJ_ENCODING_INT: return "int";
+    case OBJ_ENCODING_HT: return "hashtable";
+    case OBJ_ENCODING_QUICKLIST: return "quicklist";
+    case OBJ_ENCODING_ZIPLIST: return "ziplist";
+    case OBJ_ENCODING_INTSET: return "intset";
+    case OBJ_ENCODING_SKIPLIST: return "skiplist";
+    case OBJ_ENCODING_EMBSTR: return "embstr";
     default: return "unknown";
     }
 }
 
 /* Given an object returns the min number of milliseconds the object was never
  * requested, using an approximated LRU algorithm. */
 unsigned long long estimateObjectIdleTime(robj *o) {
     unsigned long long lruclock = LRU_CLOCK();
     if (lruclock >= o->lru) {
-        return (lruclock - o->lru) * REDIS_LRU_CLOCK_RESOLUTION;
+        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION;
     } else {
-        return (lruclock + (REDIS_LRU_CLOCK_MAX - o->lru)) *
-                    REDIS_LRU_CLOCK_RESOLUTION;
+        return (lruclock + (LRU_CLOCK_MAX - o->lru)) *
+                    LRU_CLOCK_RESOLUTION;
     }
 }
 
 /* This is a helper function for the OBJECT command. We need to lookup keys
  * without any modification of LRU or other parameters. */
-robj *objectCommandLookup(redisClient *c, robj *key) {
+robj *objectCommandLookup(client *c, robj *key) {
     dictEntry *de;
 
     if ((de = dictFind(c->db->dict,key->ptr)) == NULL) return NULL;
     return (robj*) dictGetVal(de);
 }
 
-robj *objectCommandLookupOrReply(redisClient *c, robj *key, robj *reply) {
+robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {
     robj *o = objectCommandLookup(c,key);
 
     if (!o) addReply(c, reply);
     return o;
 }
 
 /* Object command allows to inspect the internals of an Redis Object.
  * Usage: OBJECT <refcount|encoding|idletime> <key> */
-void objectCommand(redisClient *c) {
+void objectCommand(client *c) {
     robj *o;
 
     if (!strcasecmp(c->argv[1]->ptr,"refcount") && c->argc == 3) {
         if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))
                 == NULL) return;
         addReplyLongLong(c,o->refcount);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/object.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/object.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/object.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/object.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pqsort.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pqsort.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pqsort.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pqsort.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pubsub.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pubsub.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pubsub.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pubsub.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,13 +24,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 /*-----------------------------------------------------------------------------
  * Pubsub low level API
  *----------------------------------------------------------------------------*/
 
 void freePubsubPattern(void *p) {
@@ -45,20 +45,20 @@
 
     return (pa->client == pb->client) &&
            (equalStringObjects(pa->pattern,pb->pattern));
 }
 
 /* Return the number of channels + patterns a client is subscribed to. */
-int clientSubscriptionsCount(redisClient *c) {
+int clientSubscriptionsCount(client *c) {
     return dictSize(c->pubsub_channels)+
            listLength(c->pubsub_patterns);
 }
 
 /* Subscribe a client to a channel. Returns 1 if the operation succeeded, or
  * 0 if the client was already subscribed to that channel. */
-int pubsubSubscribeChannel(redisClient *c, robj *channel) {
+int pubsubSubscribeChannel(client *c, robj *channel) {
     dictEntry *de;
     list *clients = NULL;
     int retval = 0;
 
     /* Add the channel to the client -> channels hash table */
     if (dictAdd(c->pubsub_channels,channel,NULL) == DICT_OK) {
@@ -82,29 +82,29 @@
     addReplyLongLong(c,clientSubscriptionsCount(c));
     return retval;
 }
 
 /* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or
  * 0 if the client was not subscribed to the specified channel. */
-int pubsubUnsubscribeChannel(redisClient *c, robj *channel, int notify) {
+int pubsubUnsubscribeChannel(client *c, robj *channel, int notify) {
     dictEntry *de;
     list *clients;
     listNode *ln;
     int retval = 0;
 
     /* Remove the channel from the client -> channels hash table */
     incrRefCount(channel); /* channel may be just a pointer to the same object
                             we have in the hash tables. Protect it... */
     if (dictDelete(c->pubsub_channels,channel) == DICT_OK) {
         retval = 1;
         /* Remove the client from the channel -> clients list hash table */
         de = dictFind(server.pubsub_channels,channel);
-        redisAssertWithInfo(c,NULL,de != NULL);
+        serverAssertWithInfo(c,NULL,de != NULL);
         clients = dictGetVal(de);
         ln = listSearchKey(clients,c);
-        redisAssertWithInfo(c,NULL,ln != NULL);
+        serverAssertWithInfo(c,NULL,ln != NULL);
         listDelNode(clients,ln);
         if (listLength(clients) == 0) {
             /* Free the list and associated hash entry at all if this was
              * the latest client, so that it will be possible to abuse
              * Redis PUBSUB creating millions of channels. */
             dictDelete(server.pubsub_channels,channel);
@@ -121,13 +121,13 @@
     }
     decrRefCount(channel); /* it is finally safe to release it */
     return retval;
 }
 
 /* Subscribe a client to a pattern. Returns 1 if the operation succeeded, or 0 if the client was already subscribed to that pattern. */
-int pubsubSubscribePattern(redisClient *c, robj *pattern) {
+int pubsubSubscribePattern(client *c, robj *pattern) {
     int retval = 0;
 
     if (listSearchKey(c->pubsub_patterns,pattern) == NULL) {
         retval = 1;
         pubsubPattern *pat;
         listAddNodeTail(c->pubsub_patterns,pattern);
@@ -144,13 +144,13 @@
     addReplyLongLong(c,clientSubscriptionsCount(c));
     return retval;
 }
 
 /* Unsubscribe a client from a channel. Returns 1 if the operation succeeded, or
  * 0 if the client was not subscribed to the specified channel. */
-int pubsubUnsubscribePattern(redisClient *c, robj *pattern, int notify) {
+int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {
     listNode *ln;
     pubsubPattern pat;
     int retval = 0;
 
     incrRefCount(pattern); /* Protect the object. May be the same we remove */
     if ((ln = listSearchKey(c->pubsub_patterns,pattern)) != NULL) {
@@ -172,13 +172,13 @@
     decrRefCount(pattern);
     return retval;
 }
 
 /* Unsubscribe from all the channels. Return the number of channels the
  * client was subscribed to. */
-int pubsubUnsubscribeAllChannels(redisClient *c, int notify) {
+int pubsubUnsubscribeAllChannels(client *c, int notify) {
     dictIterator *di = dictGetSafeIterator(c->pubsub_channels);
     dictEntry *de;
     int count = 0;
 
     while((de = dictNext(di)) != NULL) {
         robj *channel = dictGetKey(de);
@@ -196,13 +196,13 @@
     dictReleaseIterator(di);
     return count;
 }
 
 /* Unsubscribe from all the patterns. Return the number of patterns the
  * client was subscribed from. */
-int pubsubUnsubscribeAllPatterns(redisClient *c, int notify) {
+int pubsubUnsubscribeAllPatterns(client *c, int notify) {
     listNode *ln;
     listIter li;
     int count = 0;
 
     listRewind(c->pubsub_patterns,&li);
     while ((ln = listNext(&li)) != NULL) {
@@ -234,13 +234,13 @@
         list *list = dictGetVal(de);
         listNode *ln;
         listIter li;
 
         listRewind(list,&li);
         while ((ln = listNext(&li)) != NULL) {
-            redisClient *c = ln->value;
+            client *c = ln->value;
 
             addReply(c,shared.mbulkhdr[3]);
             addReply(c,shared.messagebulk);
             addReplyBulk(c,channel);
             addReplyBulk(c,message);
             receivers++;
@@ -271,63 +271,63 @@
 }
 
 /*-----------------------------------------------------------------------------
  * Pubsub commands implementation
  *----------------------------------------------------------------------------*/
 
-void subscribeCommand(redisClient *c) {
+void subscribeCommand(client *c) {
     int j;
 
     for (j = 1; j < c->argc; j++)
         pubsubSubscribeChannel(c,c->argv[j]);
-    c->flags |= REDIS_PUBSUB;
+    c->flags |= CLIENT_PUBSUB;
 }
 
-void unsubscribeCommand(redisClient *c) {
+void unsubscribeCommand(client *c) {
     if (c->argc == 1) {
         pubsubUnsubscribeAllChannels(c,1);
     } else {
         int j;
 
         for (j = 1; j < c->argc; j++)
             pubsubUnsubscribeChannel(c,c->argv[j],1);
     }
-    if (clientSubscriptionsCount(c) == 0) c->flags &= ~REDIS_PUBSUB;
+    if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
 }
 
-void psubscribeCommand(redisClient *c) {
+void psubscribeCommand(client *c) {
     int j;
 
     for (j = 1; j < c->argc; j++)
         pubsubSubscribePattern(c,c->argv[j]);
-    c->flags |= REDIS_PUBSUB;
+    c->flags |= CLIENT_PUBSUB;
 }
 
-void punsubscribeCommand(redisClient *c) {
+void punsubscribeCommand(client *c) {
     if (c->argc == 1) {
         pubsubUnsubscribeAllPatterns(c,1);
     } else {
         int j;
 
         for (j = 1; j < c->argc; j++)
             pubsubUnsubscribePattern(c,c->argv[j],1);
     }
-    if (clientSubscriptionsCount(c) == 0) c->flags &= ~REDIS_PUBSUB;
+    if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
 }
 
-void publishCommand(redisClient *c) {
+void publishCommand(client *c) {
     int receivers = pubsubPublishMessage(c->argv[1],c->argv[2]);
     if (server.cluster_enabled)
         clusterPropagatePublish(c->argv[1],c->argv[2]);
     else
-        forceCommandPropagation(c,REDIS_PROPAGATE_REPL);
+        forceCommandPropagation(c,PROPAGATE_REPL);
     addReplyLongLong(c,receivers);
 }
 
 /* PUBSUB command for Pub/Sub introspection. */
-void pubsubCommand(redisClient *c) {
+void pubsubCommand(client *c) {
     if (!strcasecmp(c->argv[1]->ptr,"channels") &&
         (c->argc == 2 || c->argc ==3))
     {
         /* PUBSUB CHANNELS [<pattern>] */
         sds pat = (c->argc == 2) ? NULL : c->argv[2]->ptr;
         dictIterator *di = dictGetIterator(server.pubsub_channels);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pubsub.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pubsub.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/pubsub.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/pubsub.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: quicklist.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: quicklist.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: quicklist.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: quicklist.o
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rand.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rand.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rand.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rand.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,24 +24,39 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include "lzf.h"    /* LZF compression library */
 #include "zipmap.h"
 #include "endianconv.h"
 
 #include <math.h>
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <sys/wait.h>
 #include <arpa/inet.h>
 #include <sys/stat.h>
+#include <sys/param.h>
+
+#define RDB_LOAD_NONE   0
+#define RDB_LOAD_ENC    (1<<0)
+#define RDB_LOAD_PLAIN  (1<<1)
+
+#define rdbExitReportCorruptRDB(reason) rdbCheckThenExit(reason, __LINE__);
+
+void rdbCheckThenExit(char *reason, int where) {
+    serverLog(LL_WARNING, "Corrupt RDB detected at rdb.c:%d (%s). "
+        "Running 'redis-check-rdb %s'",
+        where, reason, server.rdb_filename);
+    redis_check_rdb(server.rdb_filename);
+    exit(1);
+}
 
 static int rdbWriteRaw(rio *rdb, void *p, size_t len) {
     if (rdb && rioWrite(rdb,p,len) == 0)
         return -1;
     return len;
 }
@@ -74,123 +89,132 @@
     int64_t t64;
     if (rioRead(rdb,&t64,8) == 0) return -1;
     return (long long)t64;
 }
 
 /* Saves an encoded length. The first two bits in the first byte are used to
- * hold the encoding type. See the REDIS_RDB_* definitions for more information
+ * hold the encoding type. See the RDB_* definitions for more information
  * on the types of encoding. */
 int rdbSaveLen(rio *rdb, uint32_t len) {
     unsigned char buf[2];
     size_t nwritten;
 
     if (len < (1<<6)) {
         /* Save a 6 bit len */
-        buf[0] = (len&0xFF)|(REDIS_RDB_6BITLEN<<6);
+        buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);
         if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
         nwritten = 1;
     } else if (len < (1<<14)) {
         /* Save a 14 bit len */
-        buf[0] = ((len>>8)&0xFF)|(REDIS_RDB_14BITLEN<<6);
+        buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);
         buf[1] = len&0xFF;
         if (rdbWriteRaw(rdb,buf,2) == -1) return -1;
         nwritten = 2;
     } else {
         /* Save a 32 bit len */
-        buf[0] = (REDIS_RDB_32BITLEN<<6);
+        buf[0] = (RDB_32BITLEN<<6);
         if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
         len = htonl(len);
         if (rdbWriteRaw(rdb,&len,4) == -1) return -1;
         nwritten = 1+4;
     }
     return nwritten;
 }
 
 /* Load an encoded length. The "isencoded" argument is set to 1 if the length
- * is not actually a length but an "encoding type". See the REDIS_RDB_ENC_*
+ * is not actually a length but an "encoding type". See the RDB_ENC_*
  * definitions in rdb.h for more information. */
 uint32_t rdbLoadLen(rio *rdb, int *isencoded) {
     unsigned char buf[2];
     uint32_t len;
     int type;
 
     if (isencoded) *isencoded = 0;
-    if (rioRead(rdb,buf,1) == 0) return REDIS_RDB_LENERR;
+    if (rioRead(rdb,buf,1) == 0) return RDB_LENERR;
     type = (buf[0]&0xC0)>>6;
-    if (type == REDIS_RDB_ENCVAL) {
+    if (type == RDB_ENCVAL) {
         /* Read a 6 bit encoding type. */
         if (isencoded) *isencoded = 1;
         return buf[0]&0x3F;
-    } else if (type == REDIS_RDB_6BITLEN) {
+    } else if (type == RDB_6BITLEN) {
         /* Read a 6 bit len. */
         return buf[0]&0x3F;
-    } else if (type == REDIS_RDB_14BITLEN) {
+    } else if (type == RDB_14BITLEN) {
         /* Read a 14 bit len. */
-        if (rioRead(rdb,buf+1,1) == 0) return REDIS_RDB_LENERR;
+        if (rioRead(rdb,buf+1,1) == 0) return RDB_LENERR;
         return ((buf[0]&0x3F)<<8)|buf[1];
     } else {
         /* Read a 32 bit len. */
-        if (rioRead(rdb,&len,4) == 0) return REDIS_RDB_LENERR;
+        if (rioRead(rdb,&len,4) == 0) return RDB_LENERR;
         return ntohl(len);
     }
 }
 
 /* Encodes the "value" argument as integer when it fits in the supported ranges
  * for encoded types. If the function successfully encodes the integer, the
  * representation is stored in the buffer pointer to by "enc" and the string
  * length is returned. Otherwise 0 is returned. */
 int rdbEncodeInteger(long long value, unsigned char *enc) {
     if (value >= -(1<<7) && value <= (1<<7)-1) {
-        enc[0] = (REDIS_RDB_ENCVAL<<6)|REDIS_RDB_ENC_INT8;
+        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT8;
         enc[1] = value&0xFF;
         return 2;
     } else if (value >= -(1<<15) && value <= (1<<15)-1) {
-        enc[0] = (REDIS_RDB_ENCVAL<<6)|REDIS_RDB_ENC_INT16;
+        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;
         enc[1] = value&0xFF;
         enc[2] = (value>>8)&0xFF;
         return 3;
     } else if (value >= -((long long)1<<31) && value <= ((long long)1<<31)-1) {
-        enc[0] = (REDIS_RDB_ENCVAL<<6)|REDIS_RDB_ENC_INT32;
+        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT32;
         enc[1] = value&0xFF;
         enc[2] = (value>>8)&0xFF;
         enc[3] = (value>>16)&0xFF;
         enc[4] = (value>>24)&0xFF;
         return 5;
     } else {
         return 0;
     }
 }
 
 /* Loads an integer-encoded object with the specified encoding type "enctype".
- * If the "encode" argument is set the function may return an integer-encoded
- * string object, otherwise it always returns a raw string object. */
-robj *rdbLoadIntegerObject(rio *rdb, int enctype, int encode) {
+ * The returned value changes according to the flags, see
+ * rdbGenerincLoadStringObject() for more info. */
+void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags) {
+    int plain = flags & RDB_LOAD_PLAIN;
+    int encode = flags & RDB_LOAD_ENC;
     unsigned char enc[4];
     long long val;
 
-    if (enctype == REDIS_RDB_ENC_INT8) {
+    if (enctype == RDB_ENC_INT8) {
         if (rioRead(rdb,enc,1) == 0) return NULL;
         val = (signed char)enc[0];
-    } else if (enctype == REDIS_RDB_ENC_INT16) {
+    } else if (enctype == RDB_ENC_INT16) {
         uint16_t v;
         if (rioRead(rdb,enc,2) == 0) return NULL;
         v = enc[0]|(enc[1]<<8);
         val = (int16_t)v;
-    } else if (enctype == REDIS_RDB_ENC_INT32) {
+    } else if (enctype == RDB_ENC_INT32) {
         uint32_t v;
         if (rioRead(rdb,enc,4) == 0) return NULL;
         v = enc[0]|(enc[1]<<8)|(enc[2]<<16)|(enc[3]<<24);
         val = (int32_t)v;
     } else {
         val = 0; /* anti-warning */
-        redisPanic("Unknown RDB integer encoding type");
+        rdbExitReportCorruptRDB("Unknown RDB integer encoding type");
     }
-    if (encode)
+    if (plain) {
+        char buf[LONG_STR_SIZE], *p;
+        int len = ll2string(buf,sizeof(buf),val);
+        p = zmalloc(len);
+        memcpy(p,buf,len);
+        return p;
+    } else if (encode) {
         return createStringObjectFromLongLong(val);
-    else
-        return createObject(REDIS_STRING,sdsfromlonglong(val));
+    } else {
+        return createObject(OBJ_STRING,sdsfromlonglong(val));
+    }
 }
 
 /* String objects in the form "2391" "-100" without any space and with a
  * range of values that can fit in an 8, 16 or 32 bit signed value can be
  * encoded as integers to save space */
 int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {
@@ -206,73 +230,98 @@
      * then it's not possible to encode the string as integer */
     if (strlen(buf) != len || memcmp(buf,s,len)) return 0;
 
     return rdbEncodeInteger(value,enc);
 }
 
-int rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
-    size_t comprlen, outlen;
+ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
+                       size_t original_len) {
     unsigned char byte;
-    int n, nwritten = 0;
-    void *out;
+    ssize_t n, nwritten = 0;
 
-    /* We require at least four bytes compression for this to be worth it */
-    if (len <= 4) return 0;
-    outlen = len-4;
-    if ((out = zmalloc(outlen+1)) == NULL) return 0;
-    comprlen = lzf_compress(s, len, out, outlen);
-    if (comprlen == 0) {
-        zfree(out);
-        return 0;
-    }
     /* Data compressed! Let's save it on disk */
-    byte = (REDIS_RDB_ENCVAL<<6)|REDIS_RDB_ENC_LZF;
+    byte = (RDB_ENCVAL<<6)|RDB_ENC_LZF;
     if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;
     nwritten += n;
 
-    if ((n = rdbSaveLen(rdb,comprlen)) == -1) goto writeerr;
+    if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;
     nwritten += n;
 
-    if ((n = rdbSaveLen(rdb,len)) == -1) goto writeerr;
+    if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;
     nwritten += n;
 
-    if ((n = rdbWriteRaw(rdb,out,comprlen)) == -1) goto writeerr;
+    if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
     nwritten += n;
 
-    zfree(out);
     return nwritten;
 
 writeerr:
-    zfree(out);
     return -1;
 }
 
-robj *rdbLoadLzfStringObject(rio *rdb) {
+ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
+    size_t comprlen, outlen;
+    void *out;
+
+    /* We require at least four bytes compression for this to be worth it */
+    if (len <= 4) return 0;
+    outlen = len-4;
+    if ((out = zmalloc(outlen+1)) == NULL) return 0;
+    comprlen = lzf_compress(s, len, out, outlen);
+    if (comprlen == 0) {
+        zfree(out);
+        return 0;
+    }
+    ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
+    zfree(out);
+    return nwritten;
+}
+
+/* Load an LZF compressed string in RDB format. The returned value
+ * changes according to 'flags'. For more info check the
+ * rdbGenericLoadStringObject() function. */
+void *rdbLoadLzfStringObject(rio *rdb, int flags) {
+    int plain = flags & RDB_LOAD_PLAIN;
     unsigned int len, clen;
     unsigned char *c = NULL;
     sds val = NULL;
 
-    if ((clen = rdbLoadLen(rdb,NULL)) == REDIS_RDB_LENERR) return NULL;
-    if ((len = rdbLoadLen(rdb,NULL)) == REDIS_RDB_LENERR) return NULL;
+    if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
+    if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
     if ((c = zmalloc(clen)) == NULL) goto err;
-    if ((val = sdsnewlen(NULL,len)) == NULL) goto err;
+
+    /* Allocate our target according to the uncompressed size. */
+    if (plain) {
+        val = zmalloc(len);
+    } else {
+        if ((val = sdsnewlen(NULL,len)) == NULL) goto err;
+    }
+
+    /* Load the compressed representation and uncompress it to target. */
     if (rioRead(rdb,c,clen) == 0) goto err;
     if (lzf_decompress(c,clen,val,len) == 0) goto err;
     zfree(c);
-    return createObject(REDIS_STRING,val);
+
+    if (plain)
+        return val;
+    else
+        return createObject(OBJ_STRING,val);
 err:
     zfree(c);
-    sdsfree(val);
+    if (plain)
+        zfree(val);
+    else
+        sdsfree(val);
     return NULL;
 }
 
 /* Save a string object as [len][data] on disk. If the object is a string
  * representation of an integer value we try to save it in a special form */
-int rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
+ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
     int enclen;
-    int n, nwritten = 0;
+    ssize_t n, nwritten = 0;
 
     /* Try integer encoding */
     if (len <= 11) {
         unsigned char buf[5];
         if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {
             if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
@@ -297,77 +346,98 @@
         nwritten += len;
     }
     return nwritten;
 }
 
 /* Save a long long value as either an encoded string or a string. */
-int rdbSaveLongLongAsStringObject(rio *rdb, long long value) {
+ssize_t rdbSaveLongLongAsStringObject(rio *rdb, long long value) {
     unsigned char buf[32];
-    int n, nwritten = 0;
+    ssize_t n, nwritten = 0;
     int enclen = rdbEncodeInteger(value,buf);
     if (enclen > 0) {
         return rdbWriteRaw(rdb,buf,enclen);
     } else {
         /* Encode as string */
         enclen = ll2string((char*)buf,32,value);
-        redisAssert(enclen < 32);
+        serverAssert(enclen < 32);
         if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;
         nwritten += n;
         if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;
         nwritten += n;
     }
     return nwritten;
 }
 
 /* Like rdbSaveStringObjectRaw() but handle encoded objects */
 int rdbSaveStringObject(rio *rdb, robj *obj) {
     /* Avoid to decode the object, then encode it again, if the
      * object is already integer encoded. */
-    if (obj->encoding == REDIS_ENCODING_INT) {
+    if (obj->encoding == OBJ_ENCODING_INT) {
         return rdbSaveLongLongAsStringObject(rdb,(long)obj->ptr);
     } else {
-        redisAssertWithInfo(NULL,obj,sdsEncodedObject(obj));
+        serverAssertWithInfo(NULL,obj,sdsEncodedObject(obj));
         return rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));
     }
 }
 
-robj *rdbGenericLoadStringObject(rio *rdb, int encode) {
+/* Load a string object from an RDB file according to flags:
+ *
+ * RDB_LOAD_NONE (no flags): load an RDB object, unencoded.
+ * RDB_LOAD_ENC: If the returned type is a Redis object, try to
+ *               encode it in a special way to be more memory
+ *               efficient. When this flag is passed the function
+ *               no longer guarantees that obj->ptr is an SDS string.
+ * RDB_LOAD_PLAIN: Return a plain string allocated with zmalloc()
+ *                 instead of a Redis object with an sds in it.
+ * RDB_LOAD_SDS: Return an SDS string instead of a Redis object.
+ */
+void *rdbGenericLoadStringObject(rio *rdb, int flags) {
+    int encode = flags & RDB_LOAD_ENC;
+    int plain = flags & RDB_LOAD_PLAIN;
     int isencoded;
     uint32_t len;
-    robj *o;
 
     len = rdbLoadLen(rdb,&isencoded);
     if (isencoded) {
         switch(len) {
-        case REDIS_RDB_ENC_INT8:
-        case REDIS_RDB_ENC_INT16:
-        case REDIS_RDB_ENC_INT32:
-            return rdbLoadIntegerObject(rdb,len,encode);
-        case REDIS_RDB_ENC_LZF:
-            return rdbLoadLzfStringObject(rdb);
+        case RDB_ENC_INT8:
+        case RDB_ENC_INT16:
+        case RDB_ENC_INT32:
+            return rdbLoadIntegerObject(rdb,len,flags);
+        case RDB_ENC_LZF:
+            return rdbLoadLzfStringObject(rdb,flags);
         default:
-            redisPanic("Unknown RDB encoding type");
+            rdbExitReportCorruptRDB("Unknown RDB encoding type");
         }
     }
 
-    if (len == REDIS_RDB_LENERR) return NULL;
-    o = encode ? createStringObject(NULL,len) :
-                 createRawStringObject(NULL,len);
-    if (len && rioRead(rdb,o->ptr,len) == 0) {
-        decrRefCount(o);
-        return NULL;
+    if (len == RDB_LENERR) return NULL;
+    if (!plain) {
+        robj *o = encode ? createStringObject(NULL,len) :
+                           createRawStringObject(NULL,len);
+        if (len && rioRead(rdb,o->ptr,len) == 0) {
+            decrRefCount(o);
+            return NULL;
+        }
+        return o;
+    } else {
+        void *buf = zmalloc(len);
+        if (len && rioRead(rdb,buf,len) == 0) {
+            zfree(buf);
+            return NULL;
+        }
+        return buf;
     }
-    return o;
 }
 
 robj *rdbLoadStringObject(rio *rdb) {
-    return rdbGenericLoadStringObject(rdb,0);
+    return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE);
 }
 
 robj *rdbLoadEncodedStringObject(rio *rdb) {
-    return rdbGenericLoadStringObject(rdb,1);
+    return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC);
 }
 
 /* Save a double value. Doubles are saved as strings prefixed by an unsigned
  * 8 bit integer specifying the length of the representation.
  * This 8 bit integer has special values in order to specify the following
  * conditions:
@@ -427,44 +497,42 @@
     }
 }
 
 /* Save the object type of object "o". */
 int rdbSaveObjectType(rio *rdb, robj *o) {
     switch (o->type) {
-    case REDIS_STRING:
-        return rdbSaveType(rdb,REDIS_RDB_TYPE_STRING);
-    case REDIS_LIST:
-        if (o->encoding == REDIS_ENCODING_ZIPLIST)
-            return rdbSaveType(rdb,REDIS_RDB_TYPE_LIST_ZIPLIST);
-        else if (o->encoding == REDIS_ENCODING_LINKEDLIST)
-            return rdbSaveType(rdb,REDIS_RDB_TYPE_LIST);
+    case OBJ_STRING:
+        return rdbSaveType(rdb,RDB_TYPE_STRING);
+    case OBJ_LIST:
+        if (o->encoding == OBJ_ENCODING_QUICKLIST)
+            return rdbSaveType(rdb,RDB_TYPE_LIST_QUICKLIST);
         else
-            redisPanic("Unknown list encoding");
-    case REDIS_SET:
-        if (o->encoding == REDIS_ENCODING_INTSET)
-            return rdbSaveType(rdb,REDIS_RDB_TYPE_SET_INTSET);
-        else if (o->encoding == REDIS_ENCODING_HT)
-            return rdbSaveType(rdb,REDIS_RDB_TYPE_SET);
+            serverPanic("Unknown list encoding");
+    case OBJ_SET:
+        if (o->encoding == OBJ_ENCODING_INTSET)
+            return rdbSaveType(rdb,RDB_TYPE_SET_INTSET);
+        else if (o->encoding == OBJ_ENCODING_HT)
+            return rdbSaveType(rdb,RDB_TYPE_SET);
         else
-            redisPanic("Unknown set encoding");
-    case REDIS_ZSET:
-        if (o->encoding == REDIS_ENCODING_ZIPLIST)
-            return rdbSaveType(rdb,REDIS_RDB_TYPE_ZSET_ZIPLIST);
-        else if (o->encoding == REDIS_ENCODING_SKIPLIST)
-            return rdbSaveType(rdb,REDIS_RDB_TYPE_ZSET);
+            serverPanic("Unknown set encoding");
+    case OBJ_ZSET:
+        if (o->encoding == OBJ_ENCODING_ZIPLIST)
+            return rdbSaveType(rdb,RDB_TYPE_ZSET_ZIPLIST);
+        else if (o->encoding == OBJ_ENCODING_SKIPLIST)
+            return rdbSaveType(rdb,RDB_TYPE_ZSET);
         else
-            redisPanic("Unknown sorted set encoding");
-    case REDIS_HASH:
-        if (o->encoding == REDIS_ENCODING_ZIPLIST)
-            return rdbSaveType(rdb,REDIS_RDB_TYPE_HASH_ZIPLIST);
-        else if (o->encoding == REDIS_ENCODING_HT)
-            return rdbSaveType(rdb,REDIS_RDB_TYPE_HASH);
+            serverPanic("Unknown sorted set encoding");
+    case OBJ_HASH:
+        if (o->encoding == OBJ_ENCODING_ZIPLIST)
+            return rdbSaveType(rdb,RDB_TYPE_HASH_ZIPLIST);
+        else if (o->encoding == OBJ_ENCODING_HT)
+            return rdbSaveType(rdb,RDB_TYPE_HASH);
         else
-            redisPanic("Unknown hash encoding");
+            serverPanic("Unknown hash encoding");
     default:
-        redisPanic("Unknown object type");
+        serverPanic("Unknown object type");
     }
     return -1; /* avoid warning */
 }
 
 /* Use rdbLoadType() to load a TYPE in RDB format, but returns -1 if the
  * type is not specifically a valid Object Type. */
@@ -473,46 +541,45 @@
     if ((type = rdbLoadType(rdb)) == -1) return -1;
     if (!rdbIsObjectType(type)) return -1;
     return type;
 }
 
 /* Save a Redis object. Returns -1 on error, number of bytes written on success. */
-int rdbSaveObject(rio *rdb, robj *o) {
-    int n, nwritten = 0;
+ssize_t rdbSaveObject(rio *rdb, robj *o) {
+    ssize_t n = 0, nwritten = 0;
 
-    if (o->type == REDIS_STRING) {
+    if (o->type == OBJ_STRING) {
         /* Save a string value */
         if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;
         nwritten += n;
-    } else if (o->type == REDIS_LIST) {
+    } else if (o->type == OBJ_LIST) {
         /* Save a list value */
-        if (o->encoding == REDIS_ENCODING_ZIPLIST) {
-            size_t l = ziplistBlobLen((unsigned char*)o->ptr);
+        if (o->encoding == OBJ_ENCODING_QUICKLIST) {
+            quicklist *ql = o->ptr;
+            quicklistNode *node = ql->head;
 
-            if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
+            if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;
             nwritten += n;
-        } else if (o->encoding == REDIS_ENCODING_LINKEDLIST) {
-            list *list = o->ptr;
-            listIter li;
-            listNode *ln;
 
-            if ((n = rdbSaveLen(rdb,listLength(list))) == -1) return -1;
-            nwritten += n;
-
-            listRewind(list,&li);
-            while((ln = listNext(&li))) {
-                robj *eleobj = listNodeValue(ln);
-                if ((n = rdbSaveStringObject(rdb,eleobj)) == -1) return -1;
-                nwritten += n;
-            }
+            do {
+                if (quicklistNodeIsCompressed(node)) {
+                    void *data;
+                    size_t compress_len = quicklistGetLzf(node, &data);
+                    if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;
+                    nwritten += n;
+                } else {
+                    if ((n = rdbSaveRawString(rdb,node->zl,node->sz)) == -1) return -1;
+                    nwritten += n;
+                }
+            } while ((node = node->next));
         } else {
-            redisPanic("Unknown list encoding");
+            serverPanic("Unknown list encoding");
         }
-    } else if (o->type == REDIS_SET) {
+    } else if (o->type == OBJ_SET) {
         /* Save a set value */
-        if (o->encoding == REDIS_ENCODING_HT) {
+        if (o->encoding == OBJ_ENCODING_HT) {
             dict *set = o->ptr;
             dictIterator *di = dictGetIterator(set);
             dictEntry *de;
 
             if ((n = rdbSaveLen(rdb,dictSize(set))) == -1) return -1;
             nwritten += n;
@@ -520,28 +587,28 @@
             while((de = dictNext(di)) != NULL) {
                 robj *eleobj = dictGetKey(de);
                 if ((n = rdbSaveStringObject(rdb,eleobj)) == -1) return -1;
                 nwritten += n;
             }
             dictReleaseIterator(di);
-        } else if (o->encoding == REDIS_ENCODING_INTSET) {
+        } else if (o->encoding == OBJ_ENCODING_INTSET) {
             size_t l = intsetBlobLen((intset*)o->ptr);
 
             if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
             nwritten += n;
         } else {
-            redisPanic("Unknown set encoding");
+            serverPanic("Unknown set encoding");
         }
-    } else if (o->type == REDIS_ZSET) {
+    } else if (o->type == OBJ_ZSET) {
         /* Save a sorted set value */
-        if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+        if (o->encoding == OBJ_ENCODING_ZIPLIST) {
             size_t l = ziplistBlobLen((unsigned char*)o->ptr);
 
             if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
             nwritten += n;
-        } else if (o->encoding == REDIS_ENCODING_SKIPLIST) {
+        } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
             zset *zs = o->ptr;
             dictIterator *di = dictGetIterator(zs->dict);
             dictEntry *de;
 
             if ((n = rdbSaveLen(rdb,dictSize(zs->dict))) == -1) return -1;
             nwritten += n;
@@ -554,23 +621,23 @@
                 nwritten += n;
                 if ((n = rdbSaveDoubleValue(rdb,*score)) == -1) return -1;
                 nwritten += n;
             }
             dictReleaseIterator(di);
         } else {
-            redisPanic("Unknown sorted set encoding");
+            serverPanic("Unknown sorted set encoding");
         }
-    } else if (o->type == REDIS_HASH) {
+    } else if (o->type == OBJ_HASH) {
         /* Save a hash value */
-        if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+        if (o->encoding == OBJ_ENCODING_ZIPLIST) {
             size_t l = ziplistBlobLen((unsigned char*)o->ptr);
 
             if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
             nwritten += n;
 
-        } else if (o->encoding == REDIS_ENCODING_HT) {
+        } else if (o->encoding == OBJ_ENCODING_HT) {
             dictIterator *di = dictGetIterator(o->ptr);
             dictEntry *de;
 
             if ((n = rdbSaveLen(rdb,dictSize((dict*)o->ptr))) == -1) return -1;
             nwritten += n;
 
@@ -583,28 +650,28 @@
                 if ((n = rdbSaveStringObject(rdb,val)) == -1) return -1;
                 nwritten += n;
             }
             dictReleaseIterator(di);
 
         } else {
-            redisPanic("Unknown hash encoding");
+            serverPanic("Unknown hash encoding");
         }
 
     } else {
-        redisPanic("Unknown object type");
+        serverPanic("Unknown object type");
     }
     return nwritten;
 }
 
 /* Return the length the object will have on disk if saved with
  * the rdbSaveObject() function. Currently we use a trick to get
  * this length with very little changes to the code. In the future
  * we could switch to a faster solution. */
-off_t rdbSavedObjectLen(robj *o) {
-    int len = rdbSaveObject(NULL,o);
-    redisAssertWithInfo(NULL,o,len != -1);
+size_t rdbSavedObjectLen(robj *o) {
+    ssize_t len = rdbSaveObject(NULL,o);
+    serverAssertWithInfo(NULL,o,len != -1);
     return len;
 }
 
 /* Save a key-value pair, with expire time, type, key, value.
  * On error -1 is returned.
  * On success if the key was actually saved 1 is returned, otherwise 0
@@ -613,55 +680,104 @@
                         long long expiretime, long long now)
 {
     /* Save the expire time */
     if (expiretime != -1) {
         /* If this key is already expired skip it */
         if (expiretime < now) return 0;
-        if (rdbSaveType(rdb,REDIS_RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
+        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
         if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
     }
 
     /* Save type, key, value */
     if (rdbSaveObjectType(rdb,val) == -1) return -1;
     if (rdbSaveStringObject(rdb,key) == -1) return -1;
     if (rdbSaveObject(rdb,val) == -1) return -1;
     return 1;
 }
 
+/* Save an AUX field. */
+int rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {
+    if (rdbSaveType(rdb,RDB_OPCODE_AUX) == -1) return -1;
+    if (rdbSaveRawString(rdb,key,keylen) == -1) return -1;
+    if (rdbSaveRawString(rdb,val,vallen) == -1) return -1;
+    return 1;
+}
+
+/* Wrapper for rdbSaveAuxField() used when key/val length can be obtained
+ * with strlen(). */
+int rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
+    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
+}
+
+/* Wrapper for strlen(key) + integer type (up to long long range). */
+int rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {
+    char buf[LONG_STR_SIZE];
+    int vlen = ll2string(buf,sizeof(buf),val);
+    return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
+}
+
+/* Save a few default AUX fields with information about the RDB generated. */
+int rdbSaveInfoAuxFields(rio *rdb) {
+    int redis_bits = (sizeof(void*) == 8) ? 64 : 32;
+
+    /* Add a few fields about the state when the RDB was created. */
+    if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) return -1;
+    if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) return -1;
+    if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) return -1;
+    if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) return -1;
+    return 1;
+}
+
 /* Produces a dump of the database in RDB format sending it to the specified
- * Redis I/O channel. On success REDIS_OK is returned, otherwise REDIS_ERR
+ * Redis I/O channel. On success C_OK is returned, otherwise C_ERR
  * is returned and part of the output, or all the output, can be
  * missing because of I/O errors.
  *
- * When the function returns REDIS_ERR and if 'error' is not NULL, the
+ * When the function returns C_ERR and if 'error' is not NULL, the
  * integer pointed by 'error' is set to the value of errno just after the I/O
  * error. */
 int rdbSaveRio(rio *rdb, int *error) {
     dictIterator *di = NULL;
     dictEntry *de;
     char magic[10];
     int j;
     long long now = mstime();
     uint64_t cksum;
 
     if (server.rdb_checksum)
         rdb->update_cksum = rioGenericUpdateChecksum;
-    snprintf(magic,sizeof(magic),"REDIS%04d",REDIS_RDB_VERSION);
+    snprintf(magic,sizeof(magic),"REDIS%04d",RDB_VERSION);
     if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
+    if (rdbSaveInfoAuxFields(rdb) == -1) goto werr;
 
     for (j = 0; j < server.dbnum; j++) {
         redisDb *db = server.db+j;
         dict *d = db->dict;
         if (dictSize(d) == 0) continue;
         di = dictGetSafeIterator(d);
-        if (!di) return REDIS_ERR;
+        if (!di) return C_ERR;
 
         /* Write the SELECT DB opcode */
-        if (rdbSaveType(rdb,REDIS_RDB_OPCODE_SELECTDB) == -1) goto werr;
+        if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;
         if (rdbSaveLen(rdb,j) == -1) goto werr;
 
+        /* Write the RESIZE DB opcode. We trim the size to UINT32_MAX, which
+         * is currently the largest type we are able to represent in RDB sizes.
+         * However this does not limit the actual size of the DB to load since
+         * these sizes are just hints to resize the hash tables. */
+        uint32_t db_size, expires_size;
+        db_size = (dictSize(db->dict) <= UINT32_MAX) ?
+                                dictSize(db->dict) :
+                                UINT32_MAX;
+        expires_size = (dictSize(db->expires) <= UINT32_MAX) ?
+                                dictSize(db->expires) :
+                                UINT32_MAX;
+        if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;
+        if (rdbSaveLen(rdb,db_size) == -1) goto werr;
+        if (rdbSaveLen(rdb,expires_size) == -1) goto werr;
+
         /* Iterate this DB writing every entry */
         while((de = dictNext(di)) != NULL) {
             sds keystr = dictGetKey(de);
             robj key, *o = dictGetVal(de);
             long long expire;
 
@@ -671,200 +787,199 @@
         }
         dictReleaseIterator(di);
     }
     di = NULL; /* So that we don't release it again on error. */
 
     /* EOF opcode */
-    if (rdbSaveType(rdb,REDIS_RDB_OPCODE_EOF) == -1) goto werr;
+    if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;
 
     /* CRC64 checksum. It will be zero if checksum computation is disabled, the
      * loading code skips the check in this case. */
     cksum = rdb->cksum;
     memrev64ifbe(&cksum);
     if (rioWrite(rdb,&cksum,8) == 0) goto werr;
-    return REDIS_OK;
+    return C_OK;
 
 werr:
     if (error) *error = errno;
     if (di) dictReleaseIterator(di);
-    return REDIS_ERR;
+    return C_ERR;
 }
 
 /* This is just a wrapper to rdbSaveRio() that additionally adds a prefix
  * and a suffix to the generated RDB dump. The prefix is:
  *
  * $EOF:<40 bytes unguessable hex string>\r\n
  *
  * While the suffix is the 40 bytes hex string we announced in the prefix.
  * This way processes receiving the payload can understand when it ends
  * without doing any processing of the content. */
 int rdbSaveRioWithEOFMark(rio *rdb, int *error) {
-    char eofmark[REDIS_EOF_MARK_SIZE];
+    char eofmark[RDB_EOF_MARK_SIZE];
 
-    getRandomHexChars(eofmark,REDIS_EOF_MARK_SIZE);
+    getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);
     if (error) *error = 0;
     if (rioWrite(rdb,"$EOF:",5) == 0) goto werr;
-    if (rioWrite(rdb,eofmark,REDIS_EOF_MARK_SIZE) == 0) goto werr;
+    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
     if (rioWrite(rdb,"\r\n",2) == 0) goto werr;
-    if (rdbSaveRio(rdb,error) == REDIS_ERR) goto werr;
-    if (rioWrite(rdb,eofmark,REDIS_EOF_MARK_SIZE) == 0) goto werr;
-    return REDIS_OK;
+    if (rdbSaveRio(rdb,error) == C_ERR) goto werr;
+    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
+    return C_OK;
 
 werr: /* Write error. */
     /* Set 'error' only if not already set by rdbSaveRio() call. */
     if (error && *error == 0) *error = errno;
-    return REDIS_ERR;
+    return C_ERR;
 }
 
-/* Save the DB on disk. Return REDIS_ERR on error, REDIS_OK on success. */
+/* Save the DB on disk. Return C_ERR on error, C_OK on success. */
 int rdbSave(char *filename) {
     char tmpfile[256];
+    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */
     FILE *fp;
     rio rdb;
-    int error;
+    int error = 0;
 
     snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid());
     fp = fopen(tmpfile,"w");
     if (!fp) {
-        redisLog(REDIS_WARNING, "Failed opening .rdb for saving: %s",
+        char *cwdp = getcwd(cwd,MAXPATHLEN);
+        serverLog(LL_WARNING,
+            "Failed opening the RDB file %s (in server root dir %s) "
+            "for saving: %s",
+            filename,
+            cwdp ? cwdp : "unknown",
             strerror(errno));
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     rioInitWithFile(&rdb,fp);
-    if (rdbSaveRio(&rdb,&error) == REDIS_ERR) {
+    if (rdbSaveRio(&rdb,&error) == C_ERR) {
         errno = error;
         goto werr;
     }
 
     /* Make sure data will not remain on the OS's output buffers */
     if (fflush(fp) == EOF) goto werr;
     if (fsync(fileno(fp)) == -1) goto werr;
     if (fclose(fp) == EOF) goto werr;
 
     /* Use RENAME to make sure the DB file is changed atomically only
      * if the generate DB file is ok. */
     if (rename(tmpfile,filename) == -1) {
-        redisLog(REDIS_WARNING,"Error moving temp DB file on the final destination: %s", strerror(errno));
+        char *cwdp = getcwd(cwd,MAXPATHLEN);
+        serverLog(LL_WARNING,
+            "Error moving temp DB file %s on the final "
+            "destination %s (in server root dir %s): %s",
+            tmpfile,
+            filename,
+            cwdp ? cwdp : "unknown",
+            strerror(errno));
         unlink(tmpfile);
-        return REDIS_ERR;
+        return C_ERR;
     }
-    redisLog(REDIS_NOTICE,"DB saved on disk");
+
+    serverLog(LL_NOTICE,"DB saved on disk");
     server.dirty = 0;
     server.lastsave = time(NULL);
-    server.lastbgsave_status = REDIS_OK;
-    return REDIS_OK;
+    server.lastbgsave_status = C_OK;
+    return C_OK;
 
 werr:
-    redisLog(REDIS_WARNING,"Write error saving DB on disk: %s", strerror(errno));
+    serverLog(LL_WARNING,"Write error saving DB on disk: %s", strerror(errno));
     fclose(fp);
     unlink(tmpfile);
-    return REDIS_ERR;
+    return C_ERR;
 }
 
 int rdbSaveBackground(char *filename) {
     pid_t childpid;
     long long start;
 
-    if (server.rdb_child_pid != -1) return REDIS_ERR;
+    if (server.rdb_child_pid != -1) return C_ERR;
 
     server.dirty_before_bgsave = server.dirty;
     server.lastbgsave_try = time(NULL);
 
     start = ustime();
     if ((childpid = fork()) == 0) {
         int retval;
 
         /* Child */
         closeListeningSockets(0);
         redisSetProcTitle("redis-rdb-bgsave");
         retval = rdbSave(filename);
-        if (retval == REDIS_OK) {
+        if (retval == C_OK) {
             size_t private_dirty = zmalloc_get_private_dirty();
 
             if (private_dirty) {
-                redisLog(REDIS_NOTICE,
+                serverLog(LL_NOTICE,
                     "RDB: %zu MB of memory used by copy-on-write",
                     private_dirty/(1024*1024));
             }
         }
-        exitFromChild((retval == REDIS_OK) ? 0 : 1);
+        exitFromChild((retval == C_OK) ? 0 : 1);
     } else {
         /* Parent */
         server.stat_fork_time = ustime()-start;
         server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */
         latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
         if (childpid == -1) {
-            server.lastbgsave_status = REDIS_ERR;
-            redisLog(REDIS_WARNING,"Can't save in background: fork: %s",
+            server.lastbgsave_status = C_ERR;
+            serverLog(LL_WARNING,"Can't save in background: fork: %s",
                 strerror(errno));
-            return REDIS_ERR;
+            return C_ERR;
         }
-        redisLog(REDIS_NOTICE,"Background saving started by pid %d",childpid);
+        serverLog(LL_NOTICE,"Background saving started by pid %d",childpid);
         server.rdb_save_time_start = time(NULL);
         server.rdb_child_pid = childpid;
-        server.rdb_child_type = REDIS_RDB_CHILD_TYPE_DISK;
+        server.rdb_child_type = RDB_CHILD_TYPE_DISK;
         updateDictResizePolicy();
-        return REDIS_OK;
+        return C_OK;
     }
-    return REDIS_OK; /* unreached */
+    return C_OK; /* unreached */
 }
 
 void rdbRemoveTempFile(pid_t childpid) {
     char tmpfile[256];
 
     snprintf(tmpfile,sizeof(tmpfile),"temp-%d.rdb", (int) childpid);
     unlink(tmpfile);
 }
 
 /* Load a Redis object of the specified type from the specified file.
  * On success a newly allocated object is returned, otherwise NULL. */
 robj *rdbLoadObject(int rdbtype, rio *rdb) {
-    robj *o, *ele, *dec;
+    robj *o = NULL, *ele, *dec;
     size_t len;
     unsigned int i;
 
-    if (rdbtype == REDIS_RDB_TYPE_STRING) {
+    if (rdbtype == RDB_TYPE_STRING) {
         /* Read string value */
         if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
         o = tryObjectEncoding(o);
-    } else if (rdbtype == REDIS_RDB_TYPE_LIST) {
+    } else if (rdbtype == RDB_TYPE_LIST) {
         /* Read list value */
-        if ((len = rdbLoadLen(rdb,NULL)) == REDIS_RDB_LENERR) return NULL;
+        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
 
-        /* Use a real list when there are too many entries */
-        if (len > server.list_max_ziplist_entries) {
-            o = createListObject();
-        } else {
-            o = createZiplistObject();
-        }
+        o = createQuicklistObject();
+        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,
+                            server.list_compress_depth);
 
         /* Load every single element of the list */
         while(len--) {
             if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
-
-            /* If we are using a ziplist and the value is too big, convert
-             * the object to a real list. */
-            if (o->encoding == REDIS_ENCODING_ZIPLIST &&
-                sdsEncodedObject(ele) &&
-                sdslen(ele->ptr) > server.list_max_ziplist_value)
-                    listTypeConvert(o,REDIS_ENCODING_LINKEDLIST);
-
-            if (o->encoding == REDIS_ENCODING_ZIPLIST) {
-                dec = getDecodedObject(ele);
-                o->ptr = ziplistPush(o->ptr,dec->ptr,sdslen(dec->ptr),REDIS_TAIL);
-                decrRefCount(dec);
-                decrRefCount(ele);
-            } else {
-                ele = tryObjectEncoding(ele);
-                listAddNodeTail(o->ptr,ele);
-            }
+            dec = getDecodedObject(ele);
+            size_t len = sdslen(dec->ptr);
+            quicklistPushTail(o->ptr, dec->ptr, len);
+            decrRefCount(dec);
+            decrRefCount(ele);
         }
-    } else if (rdbtype == REDIS_RDB_TYPE_SET) {
+    } else if (rdbtype == RDB_TYPE_SET) {
         /* Read list/set value */
-        if ((len = rdbLoadLen(rdb,NULL)) == REDIS_RDB_LENERR) return NULL;
+        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
 
         /* Use a regular set when there are too many entries. */
         if (len > server.set_max_intset_entries) {
             o = createSetObject();
             /* It's faster to expand the dict to the right size asap in order
              * to avoid rehashing */
@@ -877,37 +992,37 @@
         /* Load every single element of the list/set */
         for (i = 0; i < len; i++) {
             long long llval;
             if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
             ele = tryObjectEncoding(ele);
 
-            if (o->encoding == REDIS_ENCODING_INTSET) {
+            if (o->encoding == OBJ_ENCODING_INTSET) {
                 /* Fetch integer value from element */
-                if (isObjectRepresentableAsLongLong(ele,&llval) == REDIS_OK) {
+                if (isObjectRepresentableAsLongLong(ele,&llval) == C_OK) {
                     o->ptr = intsetAdd(o->ptr,llval,NULL);
                 } else {
-                    setTypeConvert(o,REDIS_ENCODING_HT);
+                    setTypeConvert(o,OBJ_ENCODING_HT);
                     dictExpand(o->ptr,len);
                 }
             }
 
             /* This will also be called when the set was just converted
              * to a regular hash table encoded set */
-            if (o->encoding == REDIS_ENCODING_HT) {
+            if (o->encoding == OBJ_ENCODING_HT) {
                 dictAdd((dict*)o->ptr,ele,NULL);
             } else {
                 decrRefCount(ele);
             }
         }
-    } else if (rdbtype == REDIS_RDB_TYPE_ZSET) {
+    } else if (rdbtype == RDB_TYPE_ZSET) {
         /* Read list/set value */
         size_t zsetlen;
         size_t maxelelen = 0;
         zset *zs;
 
-        if ((zsetlen = rdbLoadLen(rdb,NULL)) == REDIS_RDB_LENERR) return NULL;
+        if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
         o = createZsetObject();
         zs = o->ptr;
 
         /* Load every single element of the list/set */
         while(zsetlen--) {
             robj *ele;
@@ -927,57 +1042,57 @@
             incrRefCount(ele); /* added to skiplist */
         }
 
         /* Convert *after* loading, since sorted sets are not stored ordered. */
         if (zsetLength(o) <= server.zset_max_ziplist_entries &&
             maxelelen <= server.zset_max_ziplist_value)
-                zsetConvert(o,REDIS_ENCODING_ZIPLIST);
-    } else if (rdbtype == REDIS_RDB_TYPE_HASH) {
+                zsetConvert(o,OBJ_ENCODING_ZIPLIST);
+    } else if (rdbtype == RDB_TYPE_HASH) {
         size_t len;
         int ret;
 
         len = rdbLoadLen(rdb, NULL);
-        if (len == REDIS_RDB_LENERR) return NULL;
+        if (len == RDB_LENERR) return NULL;
 
         o = createHashObject();
 
         /* Too many entries? Use a hash table. */
         if (len > server.hash_max_ziplist_entries)
-            hashTypeConvert(o, REDIS_ENCODING_HT);
+            hashTypeConvert(o, OBJ_ENCODING_HT);
 
         /* Load every field and value into the ziplist */
-        while (o->encoding == REDIS_ENCODING_ZIPLIST && len > 0) {
+        while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {
             robj *field, *value;
 
             len--;
             /* Load raw strings */
             field = rdbLoadStringObject(rdb);
             if (field == NULL) return NULL;
-            redisAssert(sdsEncodedObject(field));
+            serverAssert(sdsEncodedObject(field));
             value = rdbLoadStringObject(rdb);
             if (value == NULL) return NULL;
-            redisAssert(sdsEncodedObject(value));
+            serverAssert(sdsEncodedObject(value));
 
             /* Add pair to ziplist */
             o->ptr = ziplistPush(o->ptr, field->ptr, sdslen(field->ptr), ZIPLIST_TAIL);
             o->ptr = ziplistPush(o->ptr, value->ptr, sdslen(value->ptr), ZIPLIST_TAIL);
             /* Convert to hash table if size threshold is exceeded */
             if (sdslen(field->ptr) > server.hash_max_ziplist_value ||
                 sdslen(value->ptr) > server.hash_max_ziplist_value)
             {
                 decrRefCount(field);
                 decrRefCount(value);
-                hashTypeConvert(o, REDIS_ENCODING_HT);
+                hashTypeConvert(o, OBJ_ENCODING_HT);
                 break;
             }
             decrRefCount(field);
             decrRefCount(value);
         }
 
         /* Load remaining fields and values into the hash table */
-        while (o->encoding == REDIS_ENCODING_HT && len > 0) {
+        while (o->encoding == OBJ_ENCODING_HT && len > 0) {
             robj *field, *value;
 
             len--;
             /* Load encoded strings */
             field = rdbLoadEncodedStringObject(rdb);
             if (field == NULL) return NULL;
@@ -986,40 +1101,48 @@
 
             field = tryObjectEncoding(field);
             value = tryObjectEncoding(value);
 
             /* Add pair to hash table */
             ret = dictAdd((dict*)o->ptr, field, value);
-            redisAssert(ret == DICT_OK);
+            if (ret == DICT_ERR) {
+                rdbExitReportCorruptRDB("Duplicate keys detected");
+            }
         }
 
         /* All pairs should be read by now */
-        redisAssert(len == 0);
-
-    } else if (rdbtype == REDIS_RDB_TYPE_HASH_ZIPMAP  ||
-               rdbtype == REDIS_RDB_TYPE_LIST_ZIPLIST ||
-               rdbtype == REDIS_RDB_TYPE_SET_INTSET   ||
-               rdbtype == REDIS_RDB_TYPE_ZSET_ZIPLIST ||
-               rdbtype == REDIS_RDB_TYPE_HASH_ZIPLIST)
+        serverAssert(len == 0);
+    } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {
+        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
+        o = createQuicklistObject();
+        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,
+                            server.list_compress_depth);
+
+        while (len--) {
+            unsigned char *zl = rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN);
+            if (zl == NULL) return NULL;
+            quicklistAppendZiplist(o->ptr, zl);
+        }
+    } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||
+               rdbtype == RDB_TYPE_LIST_ZIPLIST ||
+               rdbtype == RDB_TYPE_SET_INTSET   ||
+               rdbtype == RDB_TYPE_ZSET_ZIPLIST ||
+               rdbtype == RDB_TYPE_HASH_ZIPLIST)
     {
-        robj *aux = rdbLoadStringObject(rdb);
-
-        if (aux == NULL) return NULL;
-        o = createObject(REDIS_STRING,NULL); /* string is just placeholder */
-        o->ptr = zmalloc(sdslen(aux->ptr));
-        memcpy(o->ptr,aux->ptr,sdslen(aux->ptr));
-        decrRefCount(aux);
+        unsigned char *encoded = rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN);
+        if (encoded == NULL) return NULL;
+        o = createObject(OBJ_STRING,encoded); /* Obj type fixed below. */
 
         /* Fix the object encoding, and make sure to convert the encoded
          * data type into the base type if accordingly to the current
          * configuration there are too many elements in the encoded data
          * type. Note that we only check the length and not max element
          * size as this is an O(N) scan. Eventually everything will get
          * converted. */
         switch(rdbtype) {
-            case REDIS_RDB_TYPE_HASH_ZIPMAP:
+            case RDB_TYPE_HASH_ZIPMAP:
                 /* Convert to ziplist encoded hash. This must be deprecated
                  * when loading dumps created by Redis 2.4 gets deprecated. */
                 {
                     unsigned char *zl = ziplistNew();
                     unsigned char *zi = zipmapRewind(o->ptr);
                     unsigned char *fstr, *vstr;
@@ -1032,52 +1155,51 @@
                         zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);
                         zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);
                     }
 
                     zfree(o->ptr);
                     o->ptr = zl;
-                    o->type = REDIS_HASH;
-                    o->encoding = REDIS_ENCODING_ZIPLIST;
+                    o->type = OBJ_HASH;
+                    o->encoding = OBJ_ENCODING_ZIPLIST;
 
                     if (hashTypeLength(o) > server.hash_max_ziplist_entries ||
                         maxlen > server.hash_max_ziplist_value)
                     {
-                        hashTypeConvert(o, REDIS_ENCODING_HT);
+                        hashTypeConvert(o, OBJ_ENCODING_HT);
                     }
                 }
                 break;
-            case REDIS_RDB_TYPE_LIST_ZIPLIST:
-                o->type = REDIS_LIST;
-                o->encoding = REDIS_ENCODING_ZIPLIST;
-                if (ziplistLen(o->ptr) > server.list_max_ziplist_entries)
-                    listTypeConvert(o,REDIS_ENCODING_LINKEDLIST);
+            case RDB_TYPE_LIST_ZIPLIST:
+                o->type = OBJ_LIST;
+                o->encoding = OBJ_ENCODING_ZIPLIST;
+                listTypeConvert(o,OBJ_ENCODING_QUICKLIST);
                 break;
-            case REDIS_RDB_TYPE_SET_INTSET:
-                o->type = REDIS_SET;
-                o->encoding = REDIS_ENCODING_INTSET;
+            case RDB_TYPE_SET_INTSET:
+                o->type = OBJ_SET;
+                o->encoding = OBJ_ENCODING_INTSET;
                 if (intsetLen(o->ptr) > server.set_max_intset_entries)
-                    setTypeConvert(o,REDIS_ENCODING_HT);
+                    setTypeConvert(o,OBJ_ENCODING_HT);
                 break;
-            case REDIS_RDB_TYPE_ZSET_ZIPLIST:
-                o->type = REDIS_ZSET;
-                o->encoding = REDIS_ENCODING_ZIPLIST;
+            case RDB_TYPE_ZSET_ZIPLIST:
+                o->type = OBJ_ZSET;
+                o->encoding = OBJ_ENCODING_ZIPLIST;
                 if (zsetLength(o) > server.zset_max_ziplist_entries)
-                    zsetConvert(o,REDIS_ENCODING_SKIPLIST);
+                    zsetConvert(o,OBJ_ENCODING_SKIPLIST);
                 break;
-            case REDIS_RDB_TYPE_HASH_ZIPLIST:
-                o->type = REDIS_HASH;
-                o->encoding = REDIS_ENCODING_ZIPLIST;
+            case RDB_TYPE_HASH_ZIPLIST:
+                o->type = OBJ_HASH;
+                o->encoding = OBJ_ENCODING_ZIPLIST;
                 if (hashTypeLength(o) > server.hash_max_ziplist_entries)
-                    hashTypeConvert(o, REDIS_ENCODING_HT);
+                    hashTypeConvert(o, OBJ_ENCODING_HT);
                 break;
             default:
-                redisPanic("Unknown encoding");
+                rdbExitReportCorruptRDB("Unknown encoding");
                 break;
         }
     } else {
-        redisPanic("Unknown object type");
+        rdbExitReportCorruptRDB("Unknown object type");
     }
     return o;
 }
 
 /* Mark that we are loading in the global state and setup the fields
  * needed to provide loading stats. */
@@ -1116,13 +1238,13 @@
         (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes)
     {
         /* The DB can take some non trivial amount of time to load. Update
          * our cached time since it is used to create and update the last
          * interaction time with clients and for other important things. */
         updateCachedTime();
-        if (server.masterhost && server.repl_state == REDIS_REPL_TRANSFER)
+        if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER)
             replicationSendNewlineToMaster();
         loadingProgress(r->processed_bytes);
         processEventsWhileBlocked();
     }
 }
 
@@ -1132,69 +1254,114 @@
     redisDb *db = server.db+0;
     char buf[1024];
     long long expiretime, now = mstime();
     FILE *fp;
     rio rdb;
 
-    if ((fp = fopen(filename,"r")) == NULL) return REDIS_ERR;
+    if ((fp = fopen(filename,"r")) == NULL) return C_ERR;
 
     rioInitWithFile(&rdb,fp);
     rdb.update_cksum = rdbLoadProgressCallback;
     rdb.max_processing_chunk = server.loading_process_events_interval_bytes;
     if (rioRead(&rdb,buf,9) == 0) goto eoferr;
     buf[9] = '\0';
     if (memcmp(buf,"REDIS",5) != 0) {
         fclose(fp);
-        redisLog(REDIS_WARNING,"Wrong signature trying to load DB from file");
+        serverLog(LL_WARNING,"Wrong signature trying to load DB from file");
         errno = EINVAL;
-        return REDIS_ERR;
+        return C_ERR;
     }
     rdbver = atoi(buf+5);
-    if (rdbver < 1 || rdbver > REDIS_RDB_VERSION) {
+    if (rdbver < 1 || rdbver > RDB_VERSION) {
         fclose(fp);
-        redisLog(REDIS_WARNING,"Can't handle RDB format version %d",rdbver);
+        serverLog(LL_WARNING,"Can't handle RDB format version %d",rdbver);
         errno = EINVAL;
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     startLoading(fp);
     while(1) {
         robj *key, *val;
         expiretime = -1;
 
         /* Read type. */
         if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
-        if (type == REDIS_RDB_OPCODE_EXPIRETIME) {
+
+        /* Handle special types. */
+        if (type == RDB_OPCODE_EXPIRETIME) {
+            /* EXPIRETIME: load an expire associated with the next key
+             * to load. Note that after loading an expire we need to
+             * load the actual type, and continue. */
             if ((expiretime = rdbLoadTime(&rdb)) == -1) goto eoferr;
             /* We read the time so we need to read the object type again. */
             if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
             /* the EXPIRETIME opcode specifies time in seconds, so convert
              * into milliseconds. */
             expiretime *= 1000;
-        } else if (type == REDIS_RDB_OPCODE_EXPIRETIME_MS) {
-            /* Milliseconds precision expire times introduced with RDB
-             * version 3. */
+        } else if (type == RDB_OPCODE_EXPIRETIME_MS) {
+            /* EXPIRETIME_MS: milliseconds precision expire times introduced
+             * with RDB v3. Like EXPIRETIME but no with more precision. */
             if ((expiretime = rdbLoadMillisecondTime(&rdb)) == -1) goto eoferr;
             /* We read the time so we need to read the object type again. */
             if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
-        }
-
-        if (type == REDIS_RDB_OPCODE_EOF)
+        } else if (type == RDB_OPCODE_EOF) {
+            /* EOF: End of file, exit the main loop. */
             break;
-
-        /* Handle SELECT DB opcode as a special case */
-        if (type == REDIS_RDB_OPCODE_SELECTDB) {
-            if ((dbid = rdbLoadLen(&rdb,NULL)) == REDIS_RDB_LENERR)
+        } else if (type == RDB_OPCODE_SELECTDB) {
+            /* SELECTDB: Select the specified database. */
+            if ((dbid = rdbLoadLen(&rdb,NULL)) == RDB_LENERR)
                 goto eoferr;
             if (dbid >= (unsigned)server.dbnum) {
-                redisLog(REDIS_WARNING,"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\n", server.dbnum);
+                serverLog(LL_WARNING,
+                    "FATAL: Data file was created with a Redis "
+                    "server configured to handle more than %d "
+                    "databases. Exiting\n", server.dbnum);
                 exit(1);
             }
             db = server.db+dbid;
-            continue;
+            continue; /* Read type again. */
+        } else if (type == RDB_OPCODE_RESIZEDB) {
+            /* RESIZEDB: Hint about the size of the keys in the currently
+             * selected data base, in order to avoid useless rehashing. */
+            uint32_t db_size, expires_size;
+            if ((db_size = rdbLoadLen(&rdb,NULL)) == RDB_LENERR)
+                goto eoferr;
+            if ((expires_size = rdbLoadLen(&rdb,NULL)) == RDB_LENERR)
+                goto eoferr;
+            dictExpand(db->dict,db_size);
+            dictExpand(db->expires,expires_size);
+            continue; /* Read type again. */
+        } else if (type == RDB_OPCODE_AUX) {
+            /* AUX: generic string-string fields. Use to add state to RDB
+             * which is backward compatible. Implementations of RDB loading
+             * are requierd to skip AUX fields they don't understand.
+             *
+             * An AUX field is composed of two strings: key and value. */
+            robj *auxkey, *auxval;
+            if ((auxkey = rdbLoadStringObject(&rdb)) == NULL) goto eoferr;
+            if ((auxval = rdbLoadStringObject(&rdb)) == NULL) goto eoferr;
+
+            if (((char*)auxkey->ptr)[0] == '%') {
+                /* All the fields with a name staring with '%' are considered
+                 * information fields and are logged at startup with a log
+                 * level of NOTICE. */
+                serverLog(LL_NOTICE,"RDB '%s': %s",
+                    (char*)auxkey->ptr,
+                    (char*)auxval->ptr);
+            } else {
+                /* We ignore fields we don't understand, as by AUX field
+                 * contract. */
+                serverLog(LL_DEBUG,"Unrecognized RDB AUX field: '%s'",
+                    (char*)auxkey->ptr);
+            }
+
+            decrRefCount(auxkey);
+            decrRefCount(auxval);
+            continue; /* Read type again. */
         }
+
         /* Read key */
         if ((key = rdbLoadStringObject(&rdb)) == NULL) goto eoferr;
         /* Read value */
         if ((val = rdbLoadObject(type,&rdb)) == NULL) goto eoferr;
         /* Check if the key already expired. This function is used when loading
          * an RDB file from disk, either at startup, or when an RDB was
@@ -1218,81 +1385,81 @@
     if (rdbver >= 5 && server.rdb_checksum) {
         uint64_t cksum, expected = rdb.cksum;
 
         if (rioRead(&rdb,&cksum,8) == 0) goto eoferr;
         memrev64ifbe(&cksum);
         if (cksum == 0) {
-            redisLog(REDIS_WARNING,"RDB file was saved with checksum disabled: no check performed.");
+            serverLog(LL_WARNING,"RDB file was saved with checksum disabled: no check performed.");
         } else if (cksum != expected) {
-            redisLog(REDIS_WARNING,"Wrong RDB checksum. Aborting now.");
-            exit(1);
+            serverLog(LL_WARNING,"Wrong RDB checksum. Aborting now.");
+            rdbExitReportCorruptRDB("RDB CRC error");
         }
     }
 
     fclose(fp);
     stopLoading();
-    return REDIS_OK;
+    return C_OK;
 
 eoferr: /* unexpected end of file is handled here with a fatal exit */
-    redisLog(REDIS_WARNING,"Short read or OOM loading DB. Unrecoverable error, aborting now.");
-    exit(1);
-    return REDIS_ERR; /* Just to avoid warning */
+    serverLog(LL_WARNING,"Short read or OOM loading DB. Unrecoverable error, aborting now.");
+    rdbExitReportCorruptRDB("Unexpected EOF reading RDB file");
+    return C_ERR; /* Just to avoid warning */
 }
 
 /* A background saving child (BGSAVE) terminated its work. Handle this.
  * This function covers the case of actual BGSAVEs. */
 void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
     if (!bysignal && exitcode == 0) {
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Background saving terminated with success");
         server.dirty = server.dirty - server.dirty_before_bgsave;
         server.lastsave = time(NULL);
-        server.lastbgsave_status = REDIS_OK;
+        server.lastbgsave_status = C_OK;
     } else if (!bysignal && exitcode != 0) {
-        redisLog(REDIS_WARNING, "Background saving error");
-        server.lastbgsave_status = REDIS_ERR;
+        serverLog(LL_WARNING, "Background saving error");
+        server.lastbgsave_status = C_ERR;
     } else {
         mstime_t latency;
 
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Background saving terminated by signal %d", bysignal);
         latencyStartMonitor(latency);
         rdbRemoveTempFile(server.rdb_child_pid);
         latencyEndMonitor(latency);
         latencyAddSampleIfNeeded("rdb-unlink-temp-file",latency);
         /* SIGUSR1 is whitelisted, so we have a way to kill a child without
          * tirggering an error conditon. */
         if (bysignal != SIGUSR1)
-            server.lastbgsave_status = REDIS_ERR;
+            server.lastbgsave_status = C_ERR;
     }
     server.rdb_child_pid = -1;
-    server.rdb_child_type = REDIS_RDB_CHILD_TYPE_NONE;
+    server.rdb_child_type = RDB_CHILD_TYPE_NONE;
     server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;
     server.rdb_save_time_start = -1;
     /* Possibly there are slaves waiting for a BGSAVE in order to be served
      * (the first stage of SYNC is a bulk transfer of dump.rdb) */
-    updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? REDIS_OK : REDIS_ERR, REDIS_RDB_CHILD_TYPE_DISK);
+    updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_DISK);
 }
 
 /* A background saving child (BGSAVE) terminated its work. Handle this.
  * This function covers the case of RDB -> Salves socket transfers for
  * diskless replication. */
 void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
     uint64_t *ok_slaves;
 
     if (!bysignal && exitcode == 0) {
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Background RDB transfer terminated with success");
     } else if (!bysignal && exitcode != 0) {
-        redisLog(REDIS_WARNING, "Background transfer error");
+        serverLog(LL_WARNING, "Background transfer error");
     } else {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Background transfer terminated by signal %d", bysignal);
     }
     server.rdb_child_pid = -1;
-    server.rdb_child_type = REDIS_RDB_CHILD_TYPE_NONE;
+    server.rdb_child_type = RDB_CHILD_TYPE_NONE;
     server.rdb_save_time_start = -1;
 
     /* If the child returns an OK exit code, read the set of slave client
      * IDs and the associated status code. We'll terminate all the slaves
      * in error state.
      *
@@ -1328,15 +1495,15 @@
      * correctly received the full payload. Others are terminated. */
     listNode *ln;
     listIter li;
 
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
-        redisClient *slave = ln->value;
+        client *slave = ln->value;
 
-        if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_END) {
+        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
             uint64_t j;
             int errorcode = 0;
 
             /* Search for the slave ID in the reply. In order for a slave to
              * continue the replication process, we need to find it in the list,
              * and it must have an error code set to 0 (which means success). */
@@ -1344,66 +1511,66 @@
                 if (slave->id == ok_slaves[2*j+1]) {
                     errorcode = ok_slaves[2*j+2];
                     break; /* Found in slaves list. */
                 }
             }
             if (j == ok_slaves[0] || errorcode != 0) {
-                redisLog(REDIS_WARNING,
+                serverLog(LL_WARNING,
                 "Closing slave %s: child->slave RDB transfer failed: %s",
                     replicationGetSlaveName(slave),
                     (errorcode == 0) ? "RDB transfer child aborted"
                                      : strerror(errorcode));
                 freeClient(slave);
             } else {
-                redisLog(REDIS_WARNING,
+                serverLog(LL_WARNING,
                 "Slave %s correctly received the streamed RDB file.",
                     replicationGetSlaveName(slave));
                 /* Restore the socket as non-blocking. */
                 anetNonBlock(NULL,slave->fd);
                 anetSendTimeout(NULL,slave->fd,0);
             }
         }
     }
     zfree(ok_slaves);
 
-    updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? REDIS_OK : REDIS_ERR, REDIS_RDB_CHILD_TYPE_SOCKET);
+    updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_SOCKET);
 }
 
 /* When a background RDB saving/transfer terminates, call the right handler. */
 void backgroundSaveDoneHandler(int exitcode, int bysignal) {
     switch(server.rdb_child_type) {
-    case REDIS_RDB_CHILD_TYPE_DISK:
+    case RDB_CHILD_TYPE_DISK:
         backgroundSaveDoneHandlerDisk(exitcode,bysignal);
         break;
-    case REDIS_RDB_CHILD_TYPE_SOCKET:
+    case RDB_CHILD_TYPE_SOCKET:
         backgroundSaveDoneHandlerSocket(exitcode,bysignal);
         break;
     default:
-        redisPanic("Unknown RDB child type.");
+        serverPanic("Unknown RDB child type.");
         break;
     }
 }
 
 /* Spawn an RDB child that writes the RDB to the sockets of the slaves
- * that are currently in REDIS_REPL_WAIT_BGSAVE_START state. */
+ * that are currently in SLAVE_STATE_WAIT_BGSAVE_START state. */
 int rdbSaveToSlavesSockets(void) {
     int *fds;
     uint64_t *clientids;
     int numfds;
     listNode *ln;
     listIter li;
     pid_t childpid;
     long long start;
     int pipefds[2];
 
-    if (server.rdb_child_pid != -1) return REDIS_ERR;
+    if (server.rdb_child_pid != -1) return C_ERR;
 
     /* Before to fork, create a pipe that will be used in order to
      * send back to the parent the IDs of the slaves that successfully
      * received all the writes. */
-    if (pipe(pipefds) == -1) return REDIS_ERR;
+    if (pipe(pipefds) == -1) return C_ERR;
     server.rdb_pipe_read_result_from_child = pipefds[0];
     server.rdb_pipe_write_result_to_parent = pipefds[1];
 
     /* Collect the file descriptors of the slaves we want to transfer
      * the RDB to, which are i WAIT_BGSAVE_START state. */
     fds = zmalloc(sizeof(int)*listLength(server.slaves));
@@ -1412,19 +1579,19 @@
      * (sent via unix pipe) that will be sent to the parent. */
     clientids = zmalloc(sizeof(uint64_t)*listLength(server.slaves));
     numfds = 0;
 
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
-        redisClient *slave = ln->value;
+        client *slave = ln->value;
 
-        if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START) {
+        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
             clientids[numfds] = slave->id;
             fds[numfds++] = slave->fd;
             replicationSetupSlaveForFullResync(slave,getPsyncInitialOffset());
-            /* Put the socket in non-blocking mode to simplify RDB transfer.
+            /* Put the socket in blocking mode to simplify RDB transfer.
              * We'll restore it when the children returns (since duped socket
              * will share the O_NONBLOCK attribute with the parent). */
             anetBlock(NULL,slave->fd);
             anetSendTimeout(NULL,slave->fd,server.repl_timeout*1000);
         }
     }
@@ -1440,20 +1607,20 @@
         zfree(fds);
 
         closeListeningSockets(0);
         redisSetProcTitle("redis-rdb-to-slaves");
 
         retval = rdbSaveRioWithEOFMark(&slave_sockets,NULL);
-        if (retval == REDIS_OK && rioFlush(&slave_sockets) == 0)
-            retval = REDIS_ERR;
+        if (retval == C_OK && rioFlush(&slave_sockets) == 0)
+            retval = C_ERR;
 
-        if (retval == REDIS_OK) {
+        if (retval == C_OK) {
             size_t private_dirty = zmalloc_get_private_dirty();
 
             if (private_dirty) {
-                redisLog(REDIS_NOTICE,
+                serverLog(LL_NOTICE,
                     "RDB: %zu MB of memory used by copy-on-write",
                     private_dirty/(1024*1024));
             }
 
             /* If we are returning OK, at least one slave was served
              * with the RDB file as expected, so we need to send a report
@@ -1487,76 +1654,77 @@
              * process with all the childre that were waiting. */
             msglen = sizeof(uint64_t)*(1+2*numfds);
             if (*len == 0 ||
                 write(server.rdb_pipe_write_result_to_parent,msg,msglen)
                 != msglen)
             {
-                retval = REDIS_ERR;
+                retval = C_ERR;
             }
             zfree(msg);
         }
         zfree(clientids);
-        exitFromChild((retval == REDIS_OK) ? 0 : 1);
+        rioFreeFdset(&slave_sockets);
+        exitFromChild((retval == C_OK) ? 0 : 1);
     } else {
         /* Parent */
         server.stat_fork_time = ustime()-start;
         server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */
         latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
         if (childpid == -1) {
-            redisLog(REDIS_WARNING,"Can't save in background: fork: %s",
+            serverLog(LL_WARNING,"Can't save in background: fork: %s",
                 strerror(errno));
 
             /* Undo the state change. The caller will perform cleanup on
              * all the slaves in BGSAVE_START state, but an early call to
              * replicationSetupSlaveForFullResync() turned it into BGSAVE_END */
             listRewind(server.slaves,&li);
             while((ln = listNext(&li))) {
-                redisClient *slave = ln->value;
+                client *slave = ln->value;
                 int j;
 
                 for (j = 0; j < numfds; j++) {
                     if (slave->id == clientids[j]) {
-                        slave->replstate = REDIS_REPL_WAIT_BGSAVE_START;
+                        slave->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
                         break;
                     }
                 }
             }
             close(pipefds[0]);
             close(pipefds[1]);
         } else {
-            redisLog(REDIS_NOTICE,"Background RDB transfer started by pid %d",
+            serverLog(LL_NOTICE,"Background RDB transfer started by pid %d",
                 childpid);
             server.rdb_save_time_start = time(NULL);
             server.rdb_child_pid = childpid;
-            server.rdb_child_type = REDIS_RDB_CHILD_TYPE_SOCKET;
+            server.rdb_child_type = RDB_CHILD_TYPE_SOCKET;
             updateDictResizePolicy();
         }
         zfree(clientids);
         zfree(fds);
-        return (childpid == -1) ? REDIS_ERR : REDIS_OK;
+        return (childpid == -1) ? C_ERR : C_OK;
     }
-    return REDIS_OK; /* Unreached. */
+    return C_OK; /* Unreached. */
 }
 
-void saveCommand(redisClient *c) {
+void saveCommand(client *c) {
     if (server.rdb_child_pid != -1) {
         addReplyError(c,"Background save already in progress");
         return;
     }
-    if (rdbSave(server.rdb_filename) == REDIS_OK) {
+    if (rdbSave(server.rdb_filename) == C_OK) {
         addReply(c,shared.ok);
     } else {
         addReply(c,shared.err);
     }
 }
 
-void bgsaveCommand(redisClient *c) {
+void bgsaveCommand(client *c) {
     if (server.rdb_child_pid != -1) {
         addReplyError(c,"Background save already in progress");
     } else if (server.aof_child_pid != -1) {
         addReplyError(c,"Can't BGSAVE while AOF log rewriting is in progress");
-    } else if (rdbSaveBackground(server.rdb_filename) == REDIS_OK) {
+    } else if (rdbSaveBackground(server.rdb_filename) == C_OK) {
         addReplyStatus(c,"Background saving started");
     } else {
         addReply(c,shared.err);
     }
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.h	2016-05-06 15:11:36.000000000 +0800
@@ -24,75 +24,80 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef __REDIS_RDB_H
-#define __REDIS_RDB_H
+#ifndef __RDB_H
+#define __RDB_H
 
 #include <stdio.h>
 #include "rio.h"
 
 /* TBD: include only necessary headers. */
-#include "redis.h"
+#include "server.h"
 
 /* The current RDB version. When the format changes in a way that is no longer
  * backward compatible this number gets incremented. */
-#define REDIS_RDB_VERSION 6
+#define RDB_VERSION 7
 
 /* Defines related to the dump file format. To store 32 bits lengths for short
  * keys requires a lot of space, so we check the most significant 2 bits of
  * the first byte to interpreter the length:
  *
  * 00|000000 => if the two MSB are 00 the len is the 6 bits of this byte
  * 01|000000 00000000 =>  01, the len is 14 byes, 6 bits + 8 bits of next byte
  * 10|000000 [32 bit integer] => if it's 01, a full 32 bit len will follow
  * 11|000000 this means: specially encoded object will follow. The six bits
  *           number specify the kind of object that follows.
- *           See the REDIS_RDB_ENC_* defines.
+ *           See the RDB_ENC_* defines.
  *
  * Lengths up to 63 are stored using a single byte, most DB keys, and may
  * values, will fit inside. */
-#define REDIS_RDB_6BITLEN 0
-#define REDIS_RDB_14BITLEN 1
-#define REDIS_RDB_32BITLEN 2
-#define REDIS_RDB_ENCVAL 3
-#define REDIS_RDB_LENERR UINT_MAX
+#define RDB_6BITLEN 0
+#define RDB_14BITLEN 1
+#define RDB_32BITLEN 2
+#define RDB_ENCVAL 3
+#define RDB_LENERR UINT_MAX
 
 /* When a length of a string object stored on disk has the first two bits
  * set, the remaining two bits specify a special encoding for the object
  * accordingly to the following defines: */
-#define REDIS_RDB_ENC_INT8 0        /* 8 bit signed integer */
-#define REDIS_RDB_ENC_INT16 1       /* 16 bit signed integer */
-#define REDIS_RDB_ENC_INT32 2       /* 32 bit signed integer */
-#define REDIS_RDB_ENC_LZF 3         /* string compressed with FASTLZ */
+#define RDB_ENC_INT8 0        /* 8 bit signed integer */
+#define RDB_ENC_INT16 1       /* 16 bit signed integer */
+#define RDB_ENC_INT32 2       /* 32 bit signed integer */
+#define RDB_ENC_LZF 3         /* string compressed with FASTLZ */
 
 /* Dup object types to RDB object types. Only reason is readability (are we
  * dealing with RDB types or with in-memory object types?). */
-#define REDIS_RDB_TYPE_STRING 0
-#define REDIS_RDB_TYPE_LIST   1
-#define REDIS_RDB_TYPE_SET    2
-#define REDIS_RDB_TYPE_ZSET   3
-#define REDIS_RDB_TYPE_HASH   4
+#define RDB_TYPE_STRING 0
+#define RDB_TYPE_LIST   1
+#define RDB_TYPE_SET    2
+#define RDB_TYPE_ZSET   3
+#define RDB_TYPE_HASH   4
+/* NOTE: WHEN ADDING NEW RDB TYPE, UPDATE rdbIsObjectType() BELOW */
 
 /* Object types for encoded objects. */
-#define REDIS_RDB_TYPE_HASH_ZIPMAP    9
-#define REDIS_RDB_TYPE_LIST_ZIPLIST  10
-#define REDIS_RDB_TYPE_SET_INTSET    11
-#define REDIS_RDB_TYPE_ZSET_ZIPLIST  12
-#define REDIS_RDB_TYPE_HASH_ZIPLIST  13
+#define RDB_TYPE_HASH_ZIPMAP    9
+#define RDB_TYPE_LIST_ZIPLIST  10
+#define RDB_TYPE_SET_INTSET    11
+#define RDB_TYPE_ZSET_ZIPLIST  12
+#define RDB_TYPE_HASH_ZIPLIST  13
+#define RDB_TYPE_LIST_QUICKLIST 14
+/* NOTE: WHEN ADDING NEW RDB TYPE, UPDATE rdbIsObjectType() BELOW */
 
 /* Test if a type is an object type. */
-#define rdbIsObjectType(t) ((t >= 0 && t <= 4) || (t >= 9 && t <= 13))
+#define rdbIsObjectType(t) ((t >= 0 && t <= 4) || (t >= 9 && t <= 14))
 
 /* Special RDB opcodes (saved/loaded with rdbSaveType/rdbLoadType). */
-#define REDIS_RDB_OPCODE_EXPIRETIME_MS 252
-#define REDIS_RDB_OPCODE_EXPIRETIME 253
-#define REDIS_RDB_OPCODE_SELECTDB   254
-#define REDIS_RDB_OPCODE_EOF        255
+#define RDB_OPCODE_AUX        250
+#define RDB_OPCODE_RESIZEDB   251
+#define RDB_OPCODE_EXPIRETIME_MS 252
+#define RDB_OPCODE_EXPIRETIME 253
+#define RDB_OPCODE_SELECTDB   254
+#define RDB_OPCODE_EOF        255
 
 int rdbSaveType(rio *rdb, unsigned char type);
 int rdbLoadType(rio *rdb);
 int rdbSaveTime(rio *rdb, time_t t);
 time_t rdbLoadTime(rio *rdb);
 int rdbSaveLen(rio *rdb, uint32_t len);
@@ -101,15 +106,14 @@
 int rdbLoadObjectType(rio *rdb);
 int rdbLoad(char *filename);
 int rdbSaveBackground(char *filename);
 int rdbSaveToSlavesSockets(void);
 void rdbRemoveTempFile(pid_t childpid);
 int rdbSave(char *filename);
-int rdbSaveObject(rio *rdb, robj *o);
-off_t rdbSavedObjectLen(robj *o);
-off_t rdbSavedObjectPages(robj *o);
+ssize_t rdbSaveObject(rio *rdb, robj *o);
+size_t rdbSavedObjectLen(robj *o);
 robj *rdbLoadObject(int type, rio *rdb);
 void backgroundSaveDoneHandler(int exitcode, int bysignal);
 int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime, long long now);
 robj *rdbLoadStringObject(rio *rdb);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rdb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rdb.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redisassert.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redisassert.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redisassert.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redisassert.h	2016-05-06 15:11:36.000000000 +0800
@@ -37,11 +37,11 @@
 
 #ifndef __REDIS_ASSERT_H__
 #define __REDIS_ASSERT_H__
 
 #include <unistd.h> /* for _exit() */
 
-#define assert(_e) ((_e)?(void)0 : (_redisAssert(#_e,__FILE__,__LINE__),_exit(1)))
+#define assert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))
 
-void _redisAssert(char *estr, char *file, int line);
+void _serverAssert(char *estr, char *file, int line);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark.c	2016-05-06 15:11:36.000000000 +0800
@@ -37,19 +37,19 @@
 #include <errno.h>
 #include <time.h>
 #include <sys/time.h>
 #include <signal.h>
 #include <assert.h>
 
+#include <sds.h> /* Use hiredis sds. */
 #include "ae.h"
 #include "hiredis.h"
-#include "sds.h"
 #include "adlist.h"
 #include "zmalloc.h"
 
-#define REDIS_NOTUSED(V) ((void) V)
+#define UNUSED(V) ((void) V)
 #define RANDPTR_INITIAL_SIZE 8
 
 static struct config {
     aeEventLoop *el;
     const char *hostip;
     int hostport;
@@ -83,13 +83,13 @@
 typedef struct _client {
     redisContext *context;
     sds obuf;
     char **randptr;         /* Pointers to :rand: strings inside the command buf */
     size_t randlen;         /* Number of pointers in client->randptr */
     size_t randfree;        /* Number of unused pointers in client->randptr */
-    unsigned int written;   /* Bytes of 'obuf' already written */
+    size_t written;         /* Bytes of 'obuf' already written */
     long long start;        /* Start time of a request */
     long long latency;      /* Request latency */
     int pending;            /* Number of pending requests (replies to consume) */
     int prefix_pending;     /* If non-zero, number of pending prefix commands. Commands
                                such as auth and select are prefixed to the pipeline of
                                benchmark commands and discarded after the first send. */
@@ -185,15 +185,15 @@
     }
 }
 
 static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     client c = privdata;
     void *reply = NULL;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(fd);
-    REDIS_NOTUSED(mask);
+    UNUSED(el);
+    UNUSED(fd);
+    UNUSED(mask);
 
     /* Calculate latency only for the first read event. This means that the
      * server already sent the reply and we need to parse it. Parsing overhead
      * is not part of the latency, so calculate it only once, here. */
     if (c->latency < 0) c->latency = ustime()-(c->start);
 
@@ -243,15 +243,15 @@
         }
     }
 }
 
 static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     client c = privdata;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(fd);
-    REDIS_NOTUSED(mask);
+    UNUSED(el);
+    UNUSED(fd);
+    UNUSED(mask);
 
     /* Initialize request when nothing was written. */
     if (c->written == 0) {
         /* Enforce upper bound to number of requests. */
         if (config.requests_issued++ >= config.requests) {
             freeClient(c);
@@ -263,13 +263,13 @@
         c->start = ustime();
         c->latency = -1;
     }
 
     if (sdslen(c->obuf) > c->written) {
         void *ptr = c->obuf+c->written;
-        int nwritten = write(c->context->fd,ptr,sdslen(c->obuf)-c->written);
+        ssize_t nwritten = write(c->context->fd,ptr,sdslen(c->obuf)-c->written);
         if (nwritten == -1) {
             if (errno != EPIPE)
                 fprintf(stderr, "Writing to socket: %s\n", strerror(errno));
             freeClient(c);
             return;
         }
@@ -592,20 +592,20 @@
 " with a range of values selected by the -r option.\n"
     );
     exit(exit_status);
 }
 
 int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData) {
-    REDIS_NOTUSED(eventLoop);
-    REDIS_NOTUSED(id);
-    REDIS_NOTUSED(clientData);
+    UNUSED(eventLoop);
+    UNUSED(id);
+    UNUSED(clientData);
 
     if (config.liveclients == 0) {
         fprintf(stderr,"All clients disconnected... aborting.\n");
         exit(1);
-    } 
+    }
     if (config.csv) return 250;
     if (config.idlemode == 1) {
         printf("clients: %d\r", config.liveclients);
         fflush(stdout);
 	return 250;
     }
@@ -735,18 +735,30 @@
         if (test_is_selected("lpush")) {
             len = redisFormatCommand(&cmd,"LPUSH mylist %s",data);
             benchmark("LPUSH",cmd,len);
             free(cmd);
         }
 
+        if (test_is_selected("rpush")) {
+            len = redisFormatCommand(&cmd,"RPUSH mylist %s",data);
+            benchmark("RPUSH",cmd,len);
+            free(cmd);
+        }
+
         if (test_is_selected("lpop")) {
             len = redisFormatCommand(&cmd,"LPOP mylist");
             benchmark("LPOP",cmd,len);
             free(cmd);
         }
 
+        if (test_is_selected("rpop")) {
+            len = redisFormatCommand(&cmd,"RPOP mylist");
+            benchmark("RPOP",cmd,len);
+            free(cmd);
+        }
+
         if (test_is_selected("sadd")) {
             len = redisFormatCommand(&cmd,
                 "SADD myset element:__rand_int__");
             benchmark("SADD",cmd,len);
             free(cmd);
         }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-benchmark.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-benchmark.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src: redis.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src: redis.c.bc
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-aof and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-aof differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-aof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-aof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-check-aof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-check-aof.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src: redis-check-dump
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src: redis-check-dump.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src: redis-check-dump.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src: redis-check-dump.o
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: redis-check-rdb
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: redis-check-rdb.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: redis-check-rdb.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: redis-check-rdb.o
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli.c	2016-05-06 15:11:36.000000000 +0800
@@ -43,29 +43,31 @@
 #include <sys/time.h>
 #include <assert.h>
 #include <fcntl.h>
 #include <limits.h>
 #include <math.h>
 
-#include "hiredis.h"
-#include "sds.h"
+#include <hiredis.h>
+#include <sds.h> /* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */
 #include "zmalloc.h"
 #include "linenoise.h"
 #include "help.h"
 #include "anet.h"
 #include "ae.h"
 
-#define REDIS_NOTUSED(V) ((void) V)
+#define UNUSED(V) ((void) V)
 
 #define OUTPUT_STANDARD 0
 #define OUTPUT_RAW 1
 #define OUTPUT_CSV 2
 #define REDIS_CLI_KEEPALIVE_INTERVAL 15 /* seconds */
 #define REDIS_CLI_DEFAULT_PIPE_TIMEOUT 30 /* seconds */
 #define REDIS_CLI_HISTFILE_ENV "REDISCLI_HISTFILE"
 #define REDIS_CLI_HISTFILE_DEFAULT ".rediscli_history"
+#define REDIS_CLI_RCFILE_ENV "REDISCLI_RCFILE"
+#define REDIS_CLI_RCFILE_DEFAULT ".redisclirc"
 
 /* --latency-dist palettes. */
 int spectrum_palette_color_size = 19;
 int spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};
 
 int spectrum_palette_mono_size = 13;
@@ -108,15 +110,24 @@
     int stdinarg; /* get last arg from stdin. (-x option) */
     char *auth;
     int output; /* output mode, see OUTPUT_* defines */
     sds mb_delim;
     char prompt[128];
     char *eval;
+    int eval_ldb;
+    int eval_ldb_sync;  /* Ask for synchronous mode of the Lua debugger. */
+    int eval_ldb_end;   /* Lua debugging session ended. */
+    int enable_ldb_on_eval; /* Handle manual SCRIPT DEBUG + EVAL commands. */
     int last_cmd_type;
 } config;
 
+/* User preferences. */
+static struct pref {
+    int hints;
+} pref;
+
 static volatile sig_atomic_t force_cancel_loop = 0;
 static void usage(void);
 static void slaveMode(void);
 char *redisGitSHA1(void);
 char *redisGitDirty(void);
 
@@ -138,48 +149,55 @@
     return ustime()/1000;
 }
 
 static void cliRefreshPrompt(void) {
     int len;
 
+    if (config.eval_ldb) return;
     if (config.hostsocket != NULL)
         len = snprintf(config.prompt,sizeof(config.prompt),"redis %s",
                        config.hostsocket);
     else
-        len = snprintf(config.prompt,sizeof(config.prompt),
-                       strchr(config.hostip,':') ? "[%s]:%d" : "%s:%d",
-                       config.hostip, config.hostport);
+        len = anetFormatAddr(config.prompt, sizeof(config.prompt),
+                           config.hostip, config.hostport);
     /* Add [dbnum] if needed */
     if (config.dbnum != 0 && config.last_cmd_type != REDIS_REPLY_ERROR)
         len += snprintf(config.prompt+len,sizeof(config.prompt)-len,"[%d]",
             config.dbnum);
     snprintf(config.prompt+len,sizeof(config.prompt)-len,"> ");
 }
 
-static sds getHistoryPath() {
+/* Return the name of the dotfile for the specified 'dotfilename'.
+ * Normally it just concatenates user $HOME to the file specified
+ * in 'dotfilename'. However if the environment varialbe 'envoverride'
+ * is set, its value is taken as the path.
+ *
+ * The function returns NULL (if the file is /dev/null or cannot be
+ * obtained for some error), or an SDS string that must be freed by
+ * the user. */
+static sds getDotfilePath(char *envoverride, char *dotfilename) {
     char *path = NULL;
-    sds historyPath = NULL;
+    sds dotPath = NULL;
 
-    /* check the env for a histfile override */
-    path = getenv(REDIS_CLI_HISTFILE_ENV);
+    /* Check the env for a dotfile override. */
+    path = getenv(envoverride);
     if (path != NULL && *path != '\0') {
         if (!strcmp("/dev/null", path)) {
             return NULL;
         }
 
-        /* if the env is set, return it */
-        historyPath = sdscatprintf(sdsempty(), "%s", path);
+        /* If the env is set, return it. */
+        dotPath = sdsnew(path);
     } else {
         char *home = getenv("HOME");
         if (home != NULL && *home != '\0') {
-            /* otherwise, return the default */
-            historyPath = sdscatprintf(sdsempty(), "%s/%s", home, REDIS_CLI_HISTFILE_DEFAULT);
+            /* If no override is set use $HOME/<dotfilename>. */
+            dotPath = sdscatprintf(sdsempty(), "%s/%s", home, dotfilename);
         }
     }
-
-    return historyPath;
+    return dotPath;
 }
 
 /*------------------------------------------------------------------------------
  * Help functions
  *--------------------------------------------------------------------------- */
 
@@ -252,17 +270,23 @@
 }
 
 /* Print generic help. */
 static void cliOutputGenericHelp(void) {
     sds version = cliVersion();
     printf(
-        "redis-cli %s\r\n"
-        "Type: \"help @<group>\" to get a list of commands in <group>\r\n"
-        "      \"help <command>\" for help on <command>\r\n"
-        "      \"help <tab>\" to get a list of possible help topics\r\n"
-        "      \"quit\" to exit\r\n",
+        "redis-cli %s\n"
+        "To get help about Redis commands type:\n"
+        "      \"help @<group>\" to get a list of commands in <group>\n"
+        "      \"help <command>\" for help on <command>\n"
+        "      \"help <tab>\" to get a list of possible help topics\n"
+        "      \"quit\" to exit\n"
+        "\n"
+        "To set redis-cli perferences:\n"
+        "      \":set hints\" enable online hints\n"
+        "      \":set nohints\" disable online hints\n"
+        "Set your preferences in ~/.redisclirc\n",
         version
     );
     sdsfree(version);
 }
 
 /* Output all command help, filtering by group or command name. */
@@ -307,12 +331,13 @@
             }
         }
     }
     printf("\r\n");
 }
 
+/* Linenoise completion callback. */
 static void completionCallback(const char *buf, linenoiseCompletions *lc) {
     size_t startpos = 0;
     int mask;
     int i;
     size_t matchlen;
     sds tmp;
@@ -335,12 +360,64 @@
             linenoiseAddCompletion(lc,tmp);
             sdsfree(tmp);
         }
     }
 }
 
+/* Linenoise hints callback. */
+static char *hintsCallback(const char *buf, int *color, int *bold) {
+    if (!pref.hints) return NULL;
+
+    int i, argc, buflen = strlen(buf);
+    sds *argv = sdssplitargs(buf,&argc);
+    int endspace = buflen && isspace(buf[buflen-1]);
+
+    /* Check if the argument list is empty and return ASAP. */
+    if (argc == 0) {
+        sdsfreesplitres(argv,argc);
+        return NULL;
+    }
+
+    for (i = 0; i < helpEntriesLen; i++) {
+        if (!(helpEntries[i].type & CLI_HELP_COMMAND)) continue;
+
+        if (strcasecmp(argv[0],helpEntries[i].full) == 0)
+        {
+            *color = 90;
+            *bold = 0;
+            sds hint = sdsnew(helpEntries[i].org->params);
+
+            /* Remove arguments from the returned hint to show only the
+             * ones the user did not yet typed. */
+            int toremove = argc-1;
+            while(toremove > 0 && sdslen(hint)) {
+                if (hint[0] == '[') break;
+                if (hint[0] == ' ') toremove--;
+                sdsrange(hint,1,-1);
+            }
+
+            /* Add an initial space if needed. */
+            if (!endspace) {
+                sds newhint = sdsnewlen(" ",1);
+                newhint = sdscatsds(newhint,hint);
+                sdsfree(hint);
+                hint = newhint;
+            }
+
+            sdsfreesplitres(argv,argc);
+            return hint;
+        }
+    }
+    sdsfreesplitres(argv,argc);
+    return NULL;
+}
+
+static void freeHintsCallback(void *ptr) {
+    sdsfree(ptr);
+}
+
 /*------------------------------------------------------------------------------
  * Networking / parsing
  *--------------------------------------------------------------------------- */
 
 /* Send AUTH command to the server */
 static int cliAuth(void) {
@@ -371,14 +448,15 @@
 }
 
 /* Connect to the server. If force is not zero the connection is performed
  * even if there is already a connected socket. */
 static int cliConnect(int force) {
     if (context == NULL || force) {
-        if (context != NULL)
+        if (context != NULL) {
             redisFree(context);
+        }
 
         if (config.hostsocket == NULL) {
             context = redisConnect(config.hostip,config.hostport);
         } else {
             context = redisConnectUnix(config.hostsocket);
         }
@@ -478,12 +556,57 @@
         fprintf(stderr,"Unknown reply type: %d\n", r->type);
         exit(1);
     }
     return out;
 }
 
+int isColorTerm(void) {
+    char *t = getenv("TERM");
+    return t != NULL && strstr(t,"xterm") != NULL;
+}
+
+/* Helpe  function for sdsCatColorizedLdbReply() appending colorize strings
+ * to an SDS string. */
+sds sdscatcolor(sds o, char *s, size_t len, char *color) {
+    if (!isColorTerm()) return sdscatlen(o,s,len);
+
+    int bold = strstr(color,"bold") != NULL;
+    int ccode = 37; /* Defaults to white. */
+    if (strstr(color,"red")) ccode = 31;
+    else if (strstr(color,"red")) ccode = 31;
+    else if (strstr(color,"green")) ccode = 32;
+    else if (strstr(color,"yellow")) ccode = 33;
+    else if (strstr(color,"blue")) ccode = 34;
+    else if (strstr(color,"magenta")) ccode = 35;
+    else if (strstr(color,"cyan")) ccode = 36;
+    else if (strstr(color,"white")) ccode = 37;
+
+    o = sdscatfmt(o,"\033[%i;%i;49m",bold,ccode);
+    o = sdscatlen(o,s,len);
+    o = sdscat(o,"\033[0m");
+    return o;
+}
+
+/* Colorize Lua debugger status replies according to the prefix they
+ * have. */
+sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
+    char *color = "white";
+
+    if (strstr(s,"<debug>")) color = "bold";
+    if (strstr(s,"<redis>")) color = "green";
+    if (strstr(s,"<reply>")) color = "cyan";
+    if (strstr(s,"<error>")) color = "red";
+    if (strstr(s,"<hint>")) color = "bold";
+    if (strstr(s,"<value>") || strstr(s,"<retval>")) color = "magenta";
+    if (len > 4 && isdigit(s[3])) {
+        if (s[1] == '>') color = "yellow"; /* Current line. */
+        else if (s[2] == '#') color = "bold"; /* Break point. */
+    }
+    return sdscatcolor(o,s,len,color);
+}
+
 static sds cliFormatReplyRaw(redisReply *r) {
     sds out = sdsempty(), tmp;
     size_t i;
 
     switch (r->type) {
     case REDIS_REPLY_NIL:
@@ -492,13 +615,30 @@
     case REDIS_REPLY_ERROR:
         out = sdscatlen(out,r->str,r->len);
         out = sdscatlen(out,"\n",1);
         break;
     case REDIS_REPLY_STATUS:
     case REDIS_REPLY_STRING:
-        out = sdscatlen(out,r->str,r->len);
+        if (r->type == REDIS_REPLY_STATUS && config.eval_ldb) {
+            /* The Lua debugger replies with arrays of simple (status)
+             * strings. We colorize the output for more fun if this
+             * is a debugging session. */
+
+            /* Detect the end of a debugging session. */
+            if (strstr(r->str,"<endsession>") == r->str) {
+                config.enable_ldb_on_eval = 0;
+                config.eval_ldb = 0;
+                config.eval_ldb_end = 1; /* Signal the caller session ended. */
+                config.output = OUTPUT_STANDARD;
+                cliRefreshPrompt();
+            } else {
+                out = sdsCatColorizedLdbReply(out,r->str,r->len);
+            }
+        } else {
+            out = sdscatlen(out,r->str,r->len);
+        }
         break;
     case REDIS_REPLY_INTEGER:
         out = sdscatprintf(out,"%lld",r->integer);
         break;
     case REDIS_REPLY_ARRAY:
         for (i = 0; i < r->elements; i++) {
@@ -595,13 +735,13 @@
          * [P] for pointer 'p'
          */
         s = strchr(p,' ');      /* MOVED[S]3999 127.0.0.1:6381 */
         p = strchr(s+1,' ');    /* MOVED[S]3999[P]127.0.0.1:6381 */
         *p = '\0';
         slot = atoi(s+1);
-        s = strchr(p+1,':');    /* MOVED 3999[P]127.0.0.1[S]6381 */
+        s = strrchr(p+1,':');    /* MOVED 3999[P]127.0.0.1[S]6381 */
         *s = '\0';
         sdsfree(config.hostip);
         config.hostip = sdsnew(p+1);
         config.hostport = atoi(s+1);
         if (config.interactive)
             printf("-> Redirected to slot [%d] located at %s:%d\n",
@@ -633,21 +773,25 @@
 
 static int cliSendCommand(int argc, char **argv, int repeat) {
     char *command = argv[0];
     size_t *argvlen;
     int j, output_raw;
 
-    if (!strcasecmp(command,"help") || !strcasecmp(command,"?")) {
+    if (!config.eval_ldb && /* In debugging mode, let's pass "help" to Redis. */
+        (!strcasecmp(command,"help") || !strcasecmp(command,"?"))) {
         cliOutputHelp(--argc, ++argv);
         return REDIS_OK;
     }
 
     if (context == NULL) return REDIS_ERR;
 
     output_raw = 0;
     if (!strcasecmp(command,"info") ||
+        (argc >= 2 && !strcasecmp(command,"debug") &&
+                      ((!strcasecmp(argv[1],"jemalloc") && !strcasecmp(argv[2],"info")) ||
+                       !strcasecmp(argv[1],"htstats"))) ||
         (argc == 2 && !strcasecmp(command,"cluster") &&
                       (!strcasecmp(argv[1],"nodes") ||
                        !strcasecmp(argv[1],"info"))) ||
         (argc == 2 && !strcasecmp(command,"client") &&
                        !strcasecmp(argv[1],"list")) ||
         (argc == 3 && !strcasecmp(command,"latency") &&
@@ -662,12 +806,30 @@
     if (!strcasecmp(command,"monitor")) config.monitor_mode = 1;
     if (!strcasecmp(command,"subscribe") ||
         !strcasecmp(command,"psubscribe")) config.pubsub_mode = 1;
     if (!strcasecmp(command,"sync") ||
         !strcasecmp(command,"psync")) config.slave_mode = 1;
 
+    /* When the user manually calls SCRIPT DEBUG, setup the activation of
+     * debugging mode on the next eval if needed. */
+    if (argc == 3 && !strcasecmp(argv[0],"script") &&
+                     !strcasecmp(argv[1],"debug"))
+    {
+        if (!strcasecmp(argv[2],"yes") || !strcasecmp(argv[2],"sync")) {
+            config.enable_ldb_on_eval = 1;
+        } else {
+            config.enable_ldb_on_eval = 0;
+        }
+    }
+
+    /* Actually activate LDB on EVAL if needed. */
+    if (!strcasecmp(command,"eval") && config.enable_ldb_on_eval) {
+        config.eval_ldb = 1;
+        config.output = OUTPUT_RAW;
+    }
+
     /* Setup argument length */
     argvlen = malloc(argc*sizeof(size_t));
     for (j = 0; j < argc; j++)
         argvlen[j] = sdslen(argv[j]);
 
     while(repeat--) {
@@ -817,12 +979,19 @@
         } else if (!strcmp(argv[i],"--pipe-timeout") && !lastarg) {
             config.pipe_timeout = atoi(argv[++i]);
         } else if (!strcmp(argv[i],"--bigkeys")) {
             config.bigkeys = 1;
         } else if (!strcmp(argv[i],"--eval") && !lastarg) {
             config.eval = argv[++i];
+        } else if (!strcmp(argv[i],"--ldb")) {
+            config.eval_ldb = 1;
+            config.output = OUTPUT_RAW;
+        } else if (!strcmp(argv[i],"--ldb-sync-mode")) {
+            config.eval_ldb = 1;
+            config.eval_ldb_sync = 1;
+            config.output = OUTPUT_RAW;
         } else if (!strcmp(argv[i],"-c")) {
             config.cluster_mode = 1;
         } else if (!strcmp(argv[i],"-d") && !lastarg) {
             sdsfree(config.mb_delim);
             config.mb_delim = sdsnew(argv[++i]);
         } else if (!strcmp(argv[i],"-v") || !strcmp(argv[i], "--version")) {
@@ -839,12 +1008,19 @@
             } else {
                 /* Likely the command name, stop here. */
                 break;
             }
         }
     }
+
+    /* --ldb requires --eval. */
+    if (config.eval_ldb && config.eval == NULL) {
+        fprintf(stderr,"Options --ldb and --ldb-sync-mode require --eval.\n");
+        fprintf(stderr,"Try %s --help for more information.\n", argv[0]);
+        exit(1);
+    }
     return i;
 }
 
 static sds readArgFromStdin(void) {
     char buf[1024];
     sds arg = sdsempty();
@@ -899,12 +1075,16 @@
 "  --bigkeys          Sample Redis keys looking for big keys.\n"
 "  --scan             List all keys using the SCAN command.\n"
 "  --pattern <pat>    Useful with --scan to specify a SCAN pattern.\n"
 "  --intrinsic-latency <sec> Run a test to measure intrinsic system latency.\n"
 "                     The test will run for the specified amount of seconds.\n"
 "  --eval <file>      Send an EVAL command using the Lua script at <file>.\n"
+"  --ldb              Used with --eval enable the Redis Lua debugger.\n"
+"  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in\n"
+"                     this mode the server is blocked and script changes are\n"
+"                     are not rolled back from the server memory.\n"
 "  --help             Output this help and exit.\n"
 "  --version          Output version and exit.\n"
 "\n"
 "Examples:\n"
 "  cat /etc/passwd | redis-cli -x set mypasswd\n"
 "  redis-cli get mypasswd\n"
@@ -913,13 +1093,14 @@
 "  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\n"
 "  redis-cli --scan --pattern '*:12345*'\n"
 "\n"
 "  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\n"
 "\n"
 "When no command is given, redis-cli starts in interactive mode.\n"
-"Type \"help\" in interactive mode for information on available commands.\n"
+"Type \"help\" in interactive mode for information on available commands\n"
+"and settings.\n"
 "\n",
         version, REDIS_CLI_DEFAULT_PIPE_TIMEOUT);
     sdsfree(version);
     exit(1);
 }
 
@@ -958,48 +1139,123 @@
 }
 
 static int issueCommand(int argc, char **argv) {
     return issueCommandRepeat(argc, argv, config.repeat);
 }
 
+/* Split the user provided command into multiple SDS arguments.
+ * This function normally uses sdssplitargs() from sds.c which is able
+ * to understand "quoted strings", escapes and so forth. However when
+ * we are in Lua debugging mode and the "eval" command is used, we want
+ * the remaining Lua script (after "e " or "eval ") to be passed verbatim
+ * as a single big argument. */
+static sds *cliSplitArgs(char *line, int *argc) {
+    if (config.eval_ldb && (strstr(line,"eval ") == line ||
+                            strstr(line,"e ") == line))
+    {
+        sds *argv = sds_malloc(sizeof(sds)*2);
+        *argc = 2;
+        int len = strlen(line);
+        int elen = line[1] == ' ' ? 2 : 5; /* "e " or "eval "? */
+        argv[0] = sdsnewlen(line,elen-1);
+        argv[1] = sdsnewlen(line+elen,len-elen);
+        return argv;
+    } else {
+        return sdssplitargs(line,argc);
+    }
+}
+
+/* Set the CLI perferences. This function is invoked when an interactive
+ * ":command" is called, or when reading ~/.redisclirc file, in order to
+ * set user preferences. */
+void cliSetPreferences(char **argv, int argc, int interactive) {
+    if (!strcasecmp(argv[0],":set") && argc >= 2) {
+        if (!strcasecmp(argv[1],"hints")) pref.hints = 1;
+        else if (!strcasecmp(argv[1],"nohints")) pref.hints = 0;
+        else {
+            printf("%sunknown redis-cli preference '%s'\n",
+                interactive ? "" : ".redisclirc: ",
+                argv[1]);
+        }
+    } else {
+        printf("%sunknown redis-cli internal command '%s'\n",
+            interactive ? "" : ".redisclirc: ",
+            argv[0]);
+    }
+}
+
+/* Load the ~/.redisclirc file if any. */
+void cliLoadPreferences(void) {
+    sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
+    if (rcfile == NULL) return;
+    FILE *fp = fopen(rcfile,"r");
+    char buf[1024];
+
+    if (fp) {
+        while(fgets(buf,sizeof(buf),fp) != NULL) {
+            sds *argv;
+            int argc;
+
+            argv = sdssplitargs(buf,&argc);
+            if (argc > 0) cliSetPreferences(argv,argc,0);
+            sdsfreesplitres(argv,argc);
+        }
+    }
+    sdsfree(rcfile);
+}
+
 static void repl(void) {
     sds historyfile = NULL;
     int history = 0;
     char *line;
     int argc;
     sds *argv;
 
     config.interactive = 1;
     linenoiseSetMultiLine(1);
     linenoiseSetCompletionCallback(completionCallback);
+    linenoiseSetHintsCallback(hintsCallback);
+    linenoiseSetFreeHintsCallback(freeHintsCallback);
 
-    /* Only use history when stdin is a tty. */
+    /* Only use history and load the rc file when stdin is a tty. */
     if (isatty(fileno(stdin))) {
-        historyfile = getHistoryPath();
+        historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);
         if (historyfile != NULL) {
             history = 1;
             linenoiseHistoryLoad(historyfile);
         }
+        cliLoadPreferences();
     }
 
     cliRefreshPrompt();
     while((line = linenoise(context ? config.prompt : "not connected> ")) != NULL) {
         if (line[0] != '\0') {
-            argv = sdssplitargs(line,&argc);
+            argv = cliSplitArgs(line,&argc);
             if (history) linenoiseHistoryAdd(line);
             if (historyfile) linenoiseHistorySave(historyfile);
 
             if (argv == NULL) {
                 printf("Invalid argument(s)\n");
                 free(line);
                 continue;
             } else if (argc > 0) {
                 if (strcasecmp(argv[0],"quit") == 0 ||
                     strcasecmp(argv[0],"exit") == 0)
                 {
                     exit(0);
+                } else if (argv[0][0] == ':') {
+                    cliSetPreferences(argv,argc,1);
+                    continue;
+                } else if (strcasecmp(argv[0],"restart") == 0) {
+                    if (config.eval) {
+                        config.eval_ldb = 1;
+                        config.output = OUTPUT_RAW;
+                        return; /* Return to evalMode to restart the session. */
+                    } else {
+                        printf("Use 'restart' only in Lua debugging mode.");
+                    }
                 } else if (argc == 3 && !strcasecmp(argv[0],"connect")) {
                     sdsfree(config.hostip);
                     config.hostip = sdsnew(argv[1]);
                     config.hostport = atoi(argv[2]);
                     cliRefreshPrompt();
                     cliConnect(1);
@@ -1015,12 +1271,22 @@
                     } else {
                         repeat = 1;
                     }
 
                     issueCommandRepeat(argc-skipargs, argv+skipargs, repeat);
 
+                    /* If our debugging session ended, show the EVAL final
+                     * reply. */
+                    if (config.eval_ldb_end) {
+                        config.eval_ldb_end = 0;
+                        cliReadReply(0);
+                        printf("\n(Lua debugging session ended%s)\n\n",
+                            config.eval_ldb_sync ? "" :
+                            " -- dataset changes rolled back");
+                    }
+
                     elapsed = mstime()-start_time;
                     if (elapsed >= 500) {
                         printf("(%.2fs)\n",(double)elapsed/1000);
                     }
                 }
             }
@@ -1047,47 +1313,92 @@
 
 /*------------------------------------------------------------------------------
  * Eval mode
  *--------------------------------------------------------------------------- */
 
 static int evalMode(int argc, char **argv) {
-    sds script = sdsempty();
+    sds script = NULL;
     FILE *fp;
     char buf[1024];
     size_t nread;
     char **argv2;
-    int j, got_comma = 0, keys = 0;
+    int j, got_comma, keys;
+    int retval = REDIS_OK;
 
-    /* Load the script from the file, as an sds string. */
-    fp = fopen(config.eval,"r");
-    if (!fp) {
-        fprintf(stderr,
-            "Can't open file '%s': %s\n", config.eval, strerror(errno));
-        exit(1);
-    }
-    while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
-        script = sdscatlen(script,buf,nread);
-    }
-    fclose(fp);
+    while(1) {
+        if (config.eval_ldb) {
+            printf(
+            "Lua debugging session started, please use:\n"
+            "quit    -- End the session.\n"
+            "restart -- Restart the script in debug mode again.\n"
+            "help    -- Show Lua script debugging commands.\n\n"
+            );
+        }
 
-    /* Create our argument vector */
-    argv2 = zmalloc(sizeof(sds)*(argc+3));
-    argv2[0] = sdsnew("EVAL");
-    argv2[1] = script;
-    for (j = 0; j < argc; j++) {
-        if (!got_comma && argv[j][0] == ',' && argv[j][1] == 0) {
-            got_comma = 1;
-            continue;
+        sdsfree(script);
+        script = sdsempty();
+        got_comma = 0;
+        keys = 0;
+
+        /* Load the script from the file, as an sds string. */
+        fp = fopen(config.eval,"r");
+        if (!fp) {
+            fprintf(stderr,
+                "Can't open file '%s': %s\n", config.eval, strerror(errno));
+            exit(1);
         }
-        argv2[j+3-got_comma] = sdsnew(argv[j]);
-        if (!got_comma) keys++;
-    }
-    argv2[2] = sdscatprintf(sdsempty(),"%d",keys);
+        while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
+            script = sdscatlen(script,buf,nread);
+        }
+        fclose(fp);
 
-    /* Call it */
-    return issueCommand(argc+3-got_comma, argv2);
+        /* If we are debugging a script, enable the Lua debugger. */
+        if (config.eval_ldb) {
+            redisReply *reply = redisCommand(context,
+                    config.eval_ldb_sync ?
+                    "SCRIPT DEBUG sync": "SCRIPT DEBUG yes");
+            if (reply) freeReplyObject(reply);
+        }
+
+        /* Create our argument vector */
+        argv2 = zmalloc(sizeof(sds)*(argc+3));
+        argv2[0] = sdsnew("EVAL");
+        argv2[1] = script;
+        for (j = 0; j < argc; j++) {
+            if (!got_comma && argv[j][0] == ',' && argv[j][1] == 0) {
+                got_comma = 1;
+                continue;
+            }
+            argv2[j+3-got_comma] = sdsnew(argv[j]);
+            if (!got_comma) keys++;
+        }
+        argv2[2] = sdscatprintf(sdsempty(),"%d",keys);
+
+        /* Call it */
+        int eval_ldb = config.eval_ldb; /* Save it, may be reverteed. */
+        retval = issueCommand(argc+3-got_comma, argv2);
+        if (eval_ldb) {
+            if (!config.eval_ldb) {
+                /* If the debugging session ended immediately, there was an
+                 * error compiling the script. Show it and don't enter
+                 * the REPL at all. */
+                printf("Eval debugging session can't start:\n");
+                cliReadReply(0);
+                break; /* Return to the caller. */
+            } else {
+                strncpy(config.prompt,"lua debugger> ",sizeof(config.prompt));
+                repl();
+                /* Restart the session if repl() returned. */
+                cliConnect(1);
+                printf("\n");
+            }
+        } else {
+            break; /* Return to the caller. */
+        }
+    }
+    return retval;
 }
 
 /*------------------------------------------------------------------------------
  * Latency and latency history modes
  *--------------------------------------------------------------------------- */
 
@@ -2128,13 +2439,13 @@
         output += s[(s[i]+s[j])&255];
     }
     return output;
 }
 
 static void intrinsicLatencyModeStop(int s) {
-    REDIS_NOTUSED(s);
+    UNUSED(s);
     force_cancel_loop = 1;
 }
 
 static void intrinsicLatencyMode(void) {
     long long test_end, run_time, max_latency = 0, runs = 0;
 
@@ -2156,13 +2467,13 @@
         if (latency > max_latency) {
             max_latency = latency;
             printf("Max latency so far: %lld microseconds.\n", max_latency);
         }
 
         double avg_us = (double)run_time/runs;
-        double avg_ns = avg_us * 10e3;
+        double avg_ns = avg_us * 1e3;
         if (force_cancel_loop || end > test_end) {
             printf("\n%lld total runs "
                 "(avg latency: "
                 "%.4f microseconds / %.2f nanoseconds per run).\n",
                 runs, avg_us, avg_ns);
             printf("Worst run took %.0fx longer than the average latency.\n",
@@ -2205,14 +2516,20 @@
     config.pipe_mode = 0;
     config.pipe_timeout = REDIS_CLI_DEFAULT_PIPE_TIMEOUT;
     config.bigkeys = 0;
     config.stdinarg = 0;
     config.auth = NULL;
     config.eval = NULL;
+    config.eval_ldb = 0;
+    config.eval_ldb_end = 0;
+    config.eval_ldb_sync = 0;
+    config.enable_ldb_on_eval = 0;
     config.last_cmd_type = -1;
 
+    pref.hints = 1;
+
     spectrum_palette = spectrum_palette_color;
     spectrum_palette_size = spectrum_palette_color_size;
 
     if (!isatty(fileno(stdout)) && (getenv("FAKETTY") == NULL))
         config.output = OUTPUT_RAW;
     else
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-cli.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-cli.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src: redis.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src: redis.o
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-sentinel and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-sentinel differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-server and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-server differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-trib.rb /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-trib.rb
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/redis-trib.rb	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/redis-trib.rb	2016-05-06 15:11:36.000000000 +0800
@@ -404,13 +404,14 @@
         open_slots = []
         @nodes.each{|n|
             if n.info[:migrating].size > 0
                 cluster_error \
                     "[WARNING] Node #{n} has slots in migrating state (#{n.info[:migrating].keys.join(",")})."
                 open_slots += n.info[:migrating].keys
-            elsif n.info[:importing].size > 0
+            end
+            if n.info[:importing].size > 0
                 cluster_error \
                     "[WARNING] Node #{n} has slots in importing state (#{n.info[:importing].keys.join(",")})."
                 open_slots += n.info[:importing].keys
             end
         }
         open_slots.uniq!
@@ -564,23 +565,23 @@
                 xputs "[ERR] Can't select a slot owner. Impossible to fix."
                 exit 1
             end
 
             # Use ADDSLOTS to assign the slot.
             puts "*** Configuring #{owner} as the slot owner"
-            n.r.cluster("setslot",slot,"stable")
-            n.r.cluster("addslot",slot)
+            owner.r.cluster("setslot",slot,"stable")
+            owner.r.cluster("addslots",slot)
             # Make sure this information will propagate. Not strictly needed
             # since there is no past owner, so all the other nodes will accept
             # whatever epoch this node will claim the slot with.
-            n.r.cluster("bumpepoch")
+            owner.r.cluster("bumpepoch")
 
             # Remove the owner from the list of migrating/importing
             # nodes.
-            migrating.delete(n)
-            importing.delete(n)
+            migrating.delete(owner)
+            importing.delete(owner)
         end
 
         # If there are multiple owners of the slot, we need to fix it
         # so that a single node is the owner and all the other nodes
         # are in importing state. Later the fix can be handled by one
         # of the base cases above.
@@ -938,13 +939,13 @@
             rescue => e
                 if o[:fix] && e.to_s =~ /BUSYKEY/
                     xputs "*** Target key exists. Replacing it for FIX."
                     source.r.client.call(["migrate",target.info[:host],target.info[:port],"",0,@timeout,:replace,:keys,*keys])
                 else
                     puts ""
-                    xputs "[ERR] #{e}"
+                    xputs "[ERR] Calling MIGRATE: #{e}"
                     exit 1
                 end
             end
             print "."*keys.length if o[:dots]
             STDOUT.flush
         end
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/release.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/release.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/release.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/release.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/release.h	2017-09-27 22:47:46.978963703 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/release.h	2017-09-27 22:49:08.166960727 +0800
@@ -1,3 +1,3 @@
 #define REDIS_GIT_SHA1 "00000000"
 #define REDIS_GIT_DIRTY "0"
-#define REDIS_BUILD_ID "sarah-Erazer-X310-1506523666"
+#define REDIS_BUILD_ID "sarah-Erazer-X310-1506523748"
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/release.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/release.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/replication.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/replication.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/replication.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/replication.c	2016-05-06 15:11:36.000000000 +0800
@@ -26,53 +26,54 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 
-#include "redis.h"
+#include "server.h"
 
 #include <sys/time.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 
 void replicationDiscardCachedMaster(void);
 void replicationResurrectCachedMaster(int newfd);
 void replicationSendAck(void);
-void putSlaveOnline(redisClient *slave);
+void putSlaveOnline(client *slave);
+int cancelReplicationHandshake(void);
 
 /* --------------------------- Utility functions ---------------------------- */
 
 /* Return the pointer to a string representing the slave ip:listening_port
  * pair. Mostly useful for logging, since we want to log a slave using its
  * IP address and it's listening port which is more clear for the user, for
  * example: "Closing connection with slave 10.1.2.3:6380". */
-char *replicationGetSlaveName(redisClient *c) {
-    static char buf[REDIS_PEER_ID_LEN];
-    char ip[REDIS_IP_STR_LEN];
+char *replicationGetSlaveName(client *c) {
+    static char buf[NET_PEER_ID_LEN];
+    char ip[NET_IP_STR_LEN];
 
     ip[0] = '\0';
     buf[0] = '\0';
     if (anetPeerToString(c->fd,ip,sizeof(ip),NULL) != -1) {
         if (c->slave_listening_port)
-            snprintf(buf,sizeof(buf),"%s:%d",ip,c->slave_listening_port);
+            anetFormatAddr(buf,sizeof(buf),ip,c->slave_listening_port);
         else
             snprintf(buf,sizeof(buf),"%s:<unknown-slave-port>",ip);
     } else {
         snprintf(buf,sizeof(buf),"client id #%llu",
             (unsigned long long) c->id);
     }
     return buf;
 }
 
 /* ---------------------------------- MASTER -------------------------------- */
 
 void createReplicationBacklog(void) {
-    redisAssert(server.repl_backlog == NULL);
+    serverAssert(server.repl_backlog == NULL);
     server.repl_backlog = zmalloc(server.repl_backlog_size);
     server.repl_backlog_histlen = 0;
     server.repl_backlog_idx = 0;
     /* When a new backlog buffer is created, we increment the replication
      * offset by one to make sure we'll not be able to PSYNC with any
      * previous slave. This is needed because we avoid incrementing the
@@ -89,14 +90,14 @@
  * size at runtime. It is up to the function to both update the
  * server.repl_backlog_size and to resize the buffer and setup it so that
  * it contains the same data as the previous one (possibly less data, but
  * the most recent bytes, or the same data and more free space in case the
  * buffer is enlarged). */
 void resizeReplicationBacklog(long long newsize) {
-    if (newsize < REDIS_REPL_BACKLOG_MIN_SIZE)
-        newsize = REDIS_REPL_BACKLOG_MIN_SIZE;
+    if (newsize < CONFIG_REPL_BACKLOG_MIN_SIZE)
+        newsize = CONFIG_REPL_BACKLOG_MIN_SIZE;
     if (server.repl_backlog_size == newsize) return;
 
     server.repl_backlog_size = newsize;
     if (server.repl_backlog != NULL) {
         /* What we actually do is to flush the old buffer and realloc a new
          * empty one. It will refill with new data incrementally.
@@ -110,13 +111,13 @@
         /* Next byte we have is... the next since the buffer is empty. */
         server.repl_backlog_off = server.master_repl_offset+1;
     }
 }
 
 void freeReplicationBacklog(void) {
-    redisAssert(listLength(server.slaves) == 0);
+    serverAssert(listLength(server.slaves) == 0);
     zfree(server.repl_backlog);
     server.repl_backlog = NULL;
 }
 
 /* Add data to the replication backlog.
  * This function also increments the global replication offset stored at
@@ -147,17 +148,17 @@
                               server.repl_backlog_histlen + 1;
 }
 
 /* Wrapper for feedReplicationBacklog() that takes Redis string objects
  * as input. */
 void feedReplicationBacklogWithObject(robj *o) {
-    char llstr[REDIS_LONGSTR_SIZE];
+    char llstr[LONG_STR_SIZE];
     void *p;
     size_t len;
 
-    if (o->encoding == REDIS_ENCODING_INT) {
+    if (o->encoding == OBJ_ENCODING_INT) {
         len = ll2string(llstr,sizeof(llstr),(long)o->ptr);
         p = llstr;
     } else {
         len = sdslen(o->ptr);
         p = o->ptr;
     }
@@ -165,57 +166,57 @@
 }
 
 void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
     listNode *ln;
     listIter li;
     int j, len;
-    char llstr[REDIS_LONGSTR_SIZE];
+    char llstr[LONG_STR_SIZE];
 
     /* If there aren't slaves, and there is no backlog buffer to populate,
      * we can return ASAP. */
     if (server.repl_backlog == NULL && listLength(slaves) == 0) return;
 
     /* We can't have slaves attached and no backlog. */
-    redisAssert(!(listLength(slaves) != 0 && server.repl_backlog == NULL));
+    serverAssert(!(listLength(slaves) != 0 && server.repl_backlog == NULL));
 
     /* Send SELECT command to every slave if needed. */
     if (server.slaveseldb != dictid) {
         robj *selectcmd;
 
         /* For a few DBs we have pre-computed SELECT command. */
-        if (dictid >= 0 && dictid < REDIS_SHARED_SELECT_CMDS) {
+        if (dictid >= 0 && dictid < PROTO_SHARED_SELECT_CMDS) {
             selectcmd = shared.select[dictid];
         } else {
             int dictid_len;
 
             dictid_len = ll2string(llstr,sizeof(llstr),dictid);
-            selectcmd = createObject(REDIS_STRING,
+            selectcmd = createObject(OBJ_STRING,
                 sdscatprintf(sdsempty(),
                 "*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n",
                 dictid_len, llstr));
         }
 
         /* Add the SELECT command into the backlog. */
         if (server.repl_backlog) feedReplicationBacklogWithObject(selectcmd);
 
         /* Send it to slaves. */
         listRewind(slaves,&li);
         while((ln = listNext(&li))) {
-            redisClient *slave = ln->value;
-            if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START) continue;
+            client *slave = ln->value;
+            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
             addReply(slave,selectcmd);
         }
 
-        if (dictid < 0 || dictid >= REDIS_SHARED_SELECT_CMDS)
+        if (dictid < 0 || dictid >= PROTO_SHARED_SELECT_CMDS)
             decrRefCount(selectcmd);
     }
     server.slaveseldb = dictid;
 
     /* Write the command to the replication backlog if any. */
     if (server.repl_backlog) {
-        char aux[REDIS_LONGSTR_SIZE+3];
+        char aux[LONG_STR_SIZE+3];
 
         /* Add the multi bulk reply length. */
         aux[0] = '*';
         len = ll2string(aux+1,sizeof(aux)-1,argc);
         aux[len+1] = '\r';
         aux[len+2] = '\n';
@@ -237,16 +238,16 @@
         }
     }
 
     /* Write the command to every slave. */
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
-        redisClient *slave = ln->value;
+        client *slave = ln->value;
 
         /* Don't feed slaves that are still waiting for BGSAVE to start */
-        if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START) continue;
+        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
 
         /* Feed slaves that are waiting for the initial SYNC (so these commands
          * are queued in the output buffer until the initial SYNC completes),
          * or are already in sync with the master. */
 
         /* Add the multi bulk length. */
@@ -256,96 +257,96 @@
          * static buffer if any (from j to argc). */
         for (j = 0; j < argc; j++)
             addReplyBulk(slave,argv[j]);
     }
 }
 
-void replicationFeedMonitors(redisClient *c, list *monitors, int dictid, robj **argv, int argc) {
+void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
     listNode *ln;
     listIter li;
     int j;
     sds cmdrepr = sdsnew("+");
     robj *cmdobj;
     struct timeval tv;
 
     gettimeofday(&tv,NULL);
     cmdrepr = sdscatprintf(cmdrepr,"%ld.%06ld ",(long)tv.tv_sec,(long)tv.tv_usec);
-    if (c->flags & REDIS_LUA_CLIENT) {
+    if (c->flags & CLIENT_LUA) {
         cmdrepr = sdscatprintf(cmdrepr,"[%d lua] ",dictid);
-    } else if (c->flags & REDIS_UNIX_SOCKET) {
+    } else if (c->flags & CLIENT_UNIX_SOCKET) {
         cmdrepr = sdscatprintf(cmdrepr,"[%d unix:%s] ",dictid,server.unixsocket);
     } else {
         cmdrepr = sdscatprintf(cmdrepr,"[%d %s] ",dictid,getClientPeerId(c));
     }
 
     for (j = 0; j < argc; j++) {
-        if (argv[j]->encoding == REDIS_ENCODING_INT) {
+        if (argv[j]->encoding == OBJ_ENCODING_INT) {
             cmdrepr = sdscatprintf(cmdrepr, "\"%ld\"", (long)argv[j]->ptr);
         } else {
             cmdrepr = sdscatrepr(cmdrepr,(char*)argv[j]->ptr,
                         sdslen(argv[j]->ptr));
         }
         if (j != argc-1)
             cmdrepr = sdscatlen(cmdrepr," ",1);
     }
     cmdrepr = sdscatlen(cmdrepr,"\r\n",2);
-    cmdobj = createObject(REDIS_STRING,cmdrepr);
+    cmdobj = createObject(OBJ_STRING,cmdrepr);
 
     listRewind(monitors,&li);
     while((ln = listNext(&li))) {
-        redisClient *monitor = ln->value;
+        client *monitor = ln->value;
         addReply(monitor,cmdobj);
     }
     decrRefCount(cmdobj);
 }
 
 /* Feed the slave 'c' with the replication backlog starting from the
  * specified 'offset' up to the end of the backlog. */
-long long addReplyReplicationBacklog(redisClient *c, long long offset) {
+long long addReplyReplicationBacklog(client *c, long long offset) {
     long long j, skip, len;
 
-    redisLog(REDIS_DEBUG, "[PSYNC] Slave request offset: %lld", offset);
+    serverLog(LL_DEBUG, "[PSYNC] Slave request offset: %lld", offset);
 
     if (server.repl_backlog_histlen == 0) {
-        redisLog(REDIS_DEBUG, "[PSYNC] Backlog history len is zero");
+        serverLog(LL_DEBUG, "[PSYNC] Backlog history len is zero");
         return 0;
     }
 
-    redisLog(REDIS_DEBUG, "[PSYNC] Backlog size: %lld",
+    serverLog(LL_DEBUG, "[PSYNC] Backlog size: %lld",
              server.repl_backlog_size);
-    redisLog(REDIS_DEBUG, "[PSYNC] First byte: %lld",
+    serverLog(LL_DEBUG, "[PSYNC] First byte: %lld",
              server.repl_backlog_off);
-    redisLog(REDIS_DEBUG, "[PSYNC] History len: %lld",
+    serverLog(LL_DEBUG, "[PSYNC] History len: %lld",
              server.repl_backlog_histlen);
-    redisLog(REDIS_DEBUG, "[PSYNC] Current index: %lld",
+    serverLog(LL_DEBUG, "[PSYNC] Current index: %lld",
              server.repl_backlog_idx);
 
     /* Compute the amount of bytes we need to discard. */
     skip = offset - server.repl_backlog_off;
-    redisLog(REDIS_DEBUG, "[PSYNC] Skipping: %lld", skip);
+    serverLog(LL_DEBUG, "[PSYNC] Skipping: %lld", skip);
 
     /* Point j to the oldest byte, that is actaully our
      * server.repl_backlog_off byte. */
     j = (server.repl_backlog_idx +
         (server.repl_backlog_size-server.repl_backlog_histlen)) %
         server.repl_backlog_size;
-    redisLog(REDIS_DEBUG, "[PSYNC] Index of first byte: %lld", j);
+    serverLog(LL_DEBUG, "[PSYNC] Index of first byte: %lld", j);
 
     /* Discard the amount of data to seek to the specified 'offset'. */
     j = (j + skip) % server.repl_backlog_size;
 
     /* Feed slave with data. Since it is a circular buffer we have to
      * split the reply in two parts if we are cross-boundary. */
     len = server.repl_backlog_histlen - skip;
-    redisLog(REDIS_DEBUG, "[PSYNC] Reply total length: %lld", len);
+    serverLog(LL_DEBUG, "[PSYNC] Reply total length: %lld", len);
     while(len) {
         long long thislen =
             ((server.repl_backlog_size - j) < len) ?
             (server.repl_backlog_size - j) : len;
 
-        redisLog(REDIS_DEBUG, "[PSYNC] addReply() length: %lld", thislen);
+        serverLog(LL_DEBUG, "[PSYNC] addReply() length: %lld", thislen);
         addReplySds(c,sdsnewlen(server.repl_backlog + j, thislen));
         len -= thislen;
         j = 0;
     }
     return server.repl_backlog_histlen - skip;
 }
@@ -375,114 +376,114 @@
  *    the new slave incremental differences will start selecting the
  *    right database number.
  *
  * Normally this function should be called immediately after a successful
  * BGSAVE for replication was started, or when there is one already in
  * progress that we attached our slave to. */
-int replicationSetupSlaveForFullResync(redisClient *slave, long long offset) {
+int replicationSetupSlaveForFullResync(client *slave, long long offset) {
     char buf[128];
     int buflen;
 
     slave->psync_initial_offset = offset;
-    slave->replstate = REDIS_REPL_WAIT_BGSAVE_END;
+    slave->replstate = SLAVE_STATE_WAIT_BGSAVE_END;
     /* We are going to accumulate the incremental changes for this
      * slave as well. Set slaveseldb to -1 in order to force to re-emit
      * a SLEECT statement in the replication stream. */
     server.slaveseldb = -1;
 
     /* Don't send this reply to slaves that approached us with
      * the old SYNC command. */
-    if (!(slave->flags & REDIS_PRE_PSYNC)) {
+    if (!(slave->flags & CLIENT_PRE_PSYNC)) {
         buflen = snprintf(buf,sizeof(buf),"+FULLRESYNC %s %lld\r\n",
                           server.runid,offset);
         if (write(slave->fd,buf,buflen) != buflen) {
             freeClientAsync(slave);
-            return REDIS_ERR;
+            return C_ERR;
         }
     }
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* This function handles the PSYNC command from the point of view of a
  * master receiving a request for partial resynchronization.
  *
- * On success return REDIS_OK, otherwise REDIS_ERR is returned and we proceed
+ * On success return C_OK, otherwise C_ERR is returned and we proceed
  * with the usual full resync. */
-int masterTryPartialResynchronization(redisClient *c) {
+int masterTryPartialResynchronization(client *c) {
     long long psync_offset, psync_len;
     char *master_runid = c->argv[1]->ptr;
     char buf[128];
     int buflen;
 
     /* Is the runid of this master the same advertised by the wannabe slave
      * via PSYNC? If runid changed this master is a different instance and
      * there is no way to continue. */
     if (strcasecmp(master_runid, server.runid)) {
         /* Run id "?" is used by slaves that want to force a full resync. */
         if (master_runid[0] != '?') {
-            redisLog(REDIS_NOTICE,"Partial resynchronization not accepted: "
+            serverLog(LL_NOTICE,"Partial resynchronization not accepted: "
                 "Runid mismatch (Client asked for runid '%s', my runid is '%s')",
                 master_runid, server.runid);
         } else {
-            redisLog(REDIS_NOTICE,"Full resync requested by slave %s",
+            serverLog(LL_NOTICE,"Full resync requested by slave %s",
                 replicationGetSlaveName(c));
         }
         goto need_full_resync;
     }
 
     /* We still have the data our slave is asking for? */
     if (getLongLongFromObjectOrReply(c,c->argv[2],&psync_offset,NULL) !=
-       REDIS_OK) goto need_full_resync;
+       C_OK) goto need_full_resync;
     if (!server.repl_backlog ||
         psync_offset < server.repl_backlog_off ||
         psync_offset > (server.repl_backlog_off + server.repl_backlog_histlen))
     {
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Unable to partial resync with slave %s for lack of backlog (Slave request was: %lld).", replicationGetSlaveName(c), psync_offset);
         if (psync_offset > server.master_repl_offset) {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "Warning: slave %s tried to PSYNC with an offset that is greater than the master replication offset.", replicationGetSlaveName(c));
         }
         goto need_full_resync;
     }
 
     /* If we reached this point, we are able to perform a partial resync:
      * 1) Set client state to make it a slave.
      * 2) Inform the client we can continue with +CONTINUE
      * 3) Send the backlog data (from the offset to the end) to the slave. */
-    c->flags |= REDIS_SLAVE;
-    c->replstate = REDIS_REPL_ONLINE;
+    c->flags |= CLIENT_SLAVE;
+    c->replstate = SLAVE_STATE_ONLINE;
     c->repl_ack_time = server.unixtime;
     c->repl_put_online_on_ack = 0;
     listAddNodeTail(server.slaves,c);
     /* We can't use the connection buffers since they are used to accumulate
      * new commands at this stage. But we are sure the socket send buffer is
      * empty so this write will never fail actually. */
     buflen = snprintf(buf,sizeof(buf),"+CONTINUE\r\n");
     if (write(c->fd,buf,buflen) != buflen) {
         freeClientAsync(c);
-        return REDIS_OK;
+        return C_OK;
     }
     psync_len = addReplyReplicationBacklog(c,psync_offset);
-    redisLog(REDIS_NOTICE,
+    serverLog(LL_NOTICE,
         "Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.",
             replicationGetSlaveName(c),
             psync_len, psync_offset);
     /* Note that we don't need to set the selected DB at server.slaveseldb
      * to -1 to force the master to emit SELECT, since the slave already
      * has this state from the previous connection with the master. */
 
     refreshGoodSlavesCount();
-    return REDIS_OK; /* The caller can return, no full resync needed. */
+    return C_OK; /* The caller can return, no full resync needed. */
 
 need_full_resync:
     /* We need a full resync for some reason... Note that we can't
      * reply to PSYNC right now if a full SYNC is needed. The reply
      * must include the master offset at the time the RDB file we transfer
      * is generated, so we need to delay the reply to that moment. */
-    return REDIS_ERR;
+    return C_ERR;
 }
 
 /* Start a BGSAVE for replication goals, which is, selecting the disk or
  * socket target depending on the configuration, and making sure that
  * the script cache is flushed before to start.
  *
@@ -496,102 +497,102 @@
  *    sync if the BGSAVE was succesfully started, or sending them an error
  *    and dropping them from the list of slaves.
  *
  * 2) Flush the Lua scripting script cache if the BGSAVE was actually
  *    started.
  *
- * Returns REDIS_OK on success or REDIS_ERR otherwise. */
+ * Returns C_OK on success or C_ERR otherwise. */
 int startBgsaveForReplication(int mincapa) {
     int retval;
     int socket_target = server.repl_diskless_sync && (mincapa & SLAVE_CAPA_EOF);
     listIter li;
     listNode *ln;
 
-    redisLog(REDIS_NOTICE,"Starting BGSAVE for SYNC with target: %s",
+    serverLog(LL_NOTICE,"Starting BGSAVE for SYNC with target: %s",
         socket_target ? "slaves sockets" : "disk");
 
     if (socket_target)
         retval = rdbSaveToSlavesSockets();
     else
         retval = rdbSaveBackground(server.rdb_filename);
 
     /* If we failed to BGSAVE, remove the slaves waiting for a full
      * resynchorinization from the list of salves, inform them with
      * an error about what happened, close the connection ASAP. */
-    if (retval == REDIS_ERR) {
-        redisLog(REDIS_WARNING,"BGSAVE for replication failed");
+    if (retval == C_ERR) {
+        serverLog(LL_WARNING,"BGSAVE for replication failed");
         listRewind(server.slaves,&li);
         while((ln = listNext(&li))) {
-            redisClient *slave = ln->value;
+            client *slave = ln->value;
 
-            if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START) {
-                slave->flags &= ~REDIS_SLAVE;
+            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
+                slave->flags &= ~CLIENT_SLAVE;
                 listDelNode(server.slaves,ln);
                 addReplyError(slave,
                     "BGSAVE failed, replication can't continue");
-                slave->flags |= REDIS_CLOSE_AFTER_REPLY;
+                slave->flags |= CLIENT_CLOSE_AFTER_REPLY;
             }
         }
         return retval;
     }
 
     /* If the target is socket, rdbSaveToSlavesSockets() already setup
      * the salves for a full resync. Otherwise for disk target do it now.*/
     if (!socket_target) {
         listRewind(server.slaves,&li);
         while((ln = listNext(&li))) {
-            redisClient *slave = ln->value;
+            client *slave = ln->value;
 
-            if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START) {
+            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
                     replicationSetupSlaveForFullResync(slave,
                             getPsyncInitialOffset());
             }
         }
     }
 
     /* Flush the script cache, since we need that slave differences are
      * accumulated without requiring slaves to match our cached scripts. */
-    if (retval == REDIS_OK) replicationScriptCacheFlush();
+    if (retval == C_OK) replicationScriptCacheFlush();
     return retval;
 }
 
 /* SYNC and PSYNC command implemenation. */
-void syncCommand(redisClient *c) {
+void syncCommand(client *c) {
     /* ignore SYNC if already slave or in monitor mode */
-    if (c->flags & REDIS_SLAVE) return;
+    if (c->flags & CLIENT_SLAVE) return;
 
     /* Refuse SYNC requests if we are a slave but the link with our master
      * is not ok... */
-    if (server.masterhost && server.repl_state != REDIS_REPL_CONNECTED) {
+    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED) {
         addReplyError(c,"Can't SYNC while not connected with my master");
         return;
     }
 
     /* SYNC can't be issued when the server has pending data to send to
      * the client about already issued commands. We need a fresh reply
      * buffer registering the differences between the BGSAVE and the current
      * dataset, so that we can copy to other slaves if needed. */
-    if (listLength(c->reply) != 0 || c->bufpos != 0) {
+    if (clientHasPendingReplies(c)) {
         addReplyError(c,"SYNC and PSYNC are invalid with pending output");
         return;
     }
 
-    redisLog(REDIS_NOTICE,"Slave %s asks for synchronization",
+    serverLog(LL_NOTICE,"Slave %s asks for synchronization",
         replicationGetSlaveName(c));
 
     /* Try a partial resynchronization if this is a PSYNC command.
      * If it fails, we continue with usual full resynchronization, however
      * when this happens masterTryPartialResynchronization() already
      * replied with:
      *
      * +FULLRESYNC <runid> <offset>
      *
      * So the slave knows the new runid and offset to try a PSYNC later
      * if the connection with the master is lost. */
     if (!strcasecmp(c->argv[0]->ptr,"psync")) {
-        if (masterTryPartialResynchronization(c) == REDIS_OK) {
+        if (masterTryPartialResynchronization(c) == C_OK) {
             server.stat_sync_partial_ok++;
             return; /* No full resync needed, return. */
         } else {
             char *master_runid = c->argv[1]->ptr;
 
             /* Increment stats for failed PSYNCs, but only if the
@@ -601,79 +602,79 @@
             if (master_runid[0] != '?') server.stat_sync_partial_err++;
         }
     } else {
         /* If a slave uses SYNC, we are dealing with an old implementation
          * of the replication protocol (like redis-cli --slave). Flag the client
          * so that we don't expect to receive REPLCONF ACK feedbacks. */
-        c->flags |= REDIS_PRE_PSYNC;
+        c->flags |= CLIENT_PRE_PSYNC;
     }
 
     /* Full resynchronization. */
     server.stat_sync_full++;
 
     /* Setup the slave as one waiting for BGSAVE to start. The following code
      * paths will change the state if we handle the slave differently. */
-    c->replstate = REDIS_REPL_WAIT_BGSAVE_START;
+    c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
     if (server.repl_disable_tcp_nodelay)
         anetDisableTcpNoDelay(NULL, c->fd); /* Non critical if it fails. */
     c->repldbfd = -1;
-    c->flags |= REDIS_SLAVE;
+    c->flags |= CLIENT_SLAVE;
     listAddNodeTail(server.slaves,c);
 
     /* CASE 1: BGSAVE is in progress, with disk target. */
     if (server.rdb_child_pid != -1 &&
-        server.rdb_child_type == REDIS_RDB_CHILD_TYPE_DISK)
+        server.rdb_child_type == RDB_CHILD_TYPE_DISK)
     {
         /* Ok a background save is in progress. Let's check if it is a good
          * one for replication, i.e. if there is another slave that is
          * registering differences since the server forked to save. */
-        redisClient *slave;
+        client *slave;
         listNode *ln;
         listIter li;
 
         listRewind(server.slaves,&li);
         while((ln = listNext(&li))) {
             slave = ln->value;
-            if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_END) break;
+            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) break;
         }
         /* To attach this slave, we check that it has at least all the
          * capabilities of the slave that triggered the current BGSAVE. */
         if (ln && ((c->slave_capa & slave->slave_capa) == slave->slave_capa)) {
             /* Perfect, the server is already registering differences for
              * another slave. Set the right state, and copy the buffer. */
             copyClientOutputBuffer(c,slave);
             replicationSetupSlaveForFullResync(c,slave->psync_initial_offset);
-            redisLog(REDIS_NOTICE,"Waiting for end of BGSAVE for SYNC");
+            serverLog(LL_NOTICE,"Waiting for end of BGSAVE for SYNC");
         } else {
             /* No way, we need to wait for the next BGSAVE in order to
              * register differences. */
-            redisLog(REDIS_NOTICE,"Waiting for next BGSAVE for SYNC");
+            serverLog(LL_NOTICE,"Waiting for next BGSAVE for SYNC");
         }
 
     /* CASE 2: BGSAVE is in progress, with socket target. */
     } else if (server.rdb_child_pid != -1 &&
-               server.rdb_child_type == REDIS_RDB_CHILD_TYPE_SOCKET)
+               server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)
     {
         /* There is an RDB child process but it is writing directly to
          * children sockets. We need to wait for the next BGSAVE
          * in order to synchronize. */
-        redisLog(REDIS_NOTICE,"Waiting for next BGSAVE for SYNC");
+        serverLog(LL_NOTICE,"Waiting for next BGSAVE for SYNC");
 
     /* CASE 3: There is no BGSAVE is progress. */
     } else {
         if (server.repl_diskless_sync && (c->slave_capa & SLAVE_CAPA_EOF)) {
             /* Diskless replication RDB child is created inside
              * replicationCron() since we want to delay its start a
              * few seconds to wait for more slaves to arrive. */
             if (server.repl_diskless_sync_delay)
-                redisLog(REDIS_NOTICE,"Delay next BGSAVE for SYNC");
+                serverLog(LL_NOTICE,"Delay next BGSAVE for SYNC");
         } else {
             /* Target is disk (or the slave is not capable of supporting
              * diskless replication) and we don't have a BGSAVE in progress,
              * let's start one. */
-            if (startBgsaveForReplication(c->slave_capa) != REDIS_OK) return;
+            if (startBgsaveForReplication(c->slave_capa) != C_OK) return;
         }
     }
 
     if (listLength(server.slaves) == 1 && server.repl_backlog == NULL)
         createReplicationBacklog();
     return;
@@ -688,13 +689,13 @@
  * master can accurately list slaves and their listening ports in
  * the INFO output.
  *
  * In the future the same command can be used in order to configure
  * the replication to initiate an incremental replication instead of a
  * full resync. */
-void replconfCommand(redisClient *c) {
+void replconfCommand(client *c) {
     int j;
 
     if ((c->argc % 2) == 0) {
         /* Number of arguments must be odd to make sure that every
          * option has a corresponding value. */
         addReply(c,shared.syntaxerr);
@@ -704,35 +705,35 @@
     /* Process every option-value pair. */
     for (j = 1; j < c->argc; j+=2) {
         if (!strcasecmp(c->argv[j]->ptr,"listening-port")) {
             long port;
 
             if ((getLongFromObjectOrReply(c,c->argv[j+1],
-                    &port,NULL) != REDIS_OK))
+                    &port,NULL) != C_OK))
                 return;
             c->slave_listening_port = port;
         } else if (!strcasecmp(c->argv[j]->ptr,"capa")) {
             /* Ignore capabilities not understood by this master. */
             if (!strcasecmp(c->argv[j+1]->ptr,"eof"))
                 c->slave_capa |= SLAVE_CAPA_EOF;
         } else if (!strcasecmp(c->argv[j]->ptr,"ack")) {
             /* REPLCONF ACK is used by slave to inform the master the amount
              * of replication stream that it processed so far. It is an
              * internal only command that normal clients should never use. */
             long long offset;
 
-            if (!(c->flags & REDIS_SLAVE)) return;
-            if ((getLongLongFromObject(c->argv[j+1], &offset) != REDIS_OK))
+            if (!(c->flags & CLIENT_SLAVE)) return;
+            if ((getLongLongFromObject(c->argv[j+1], &offset) != C_OK))
                 return;
             if (offset > c->repl_ack_off)
                 c->repl_ack_off = offset;
             c->repl_ack_time = server.unixtime;
             /* If this was a diskless replication, we need to really put
              * the slave online when the first ACK is received (which
              * confirms slave is online and ready to get more data). */
-            if (c->repl_put_online_on_ack && c->replstate == REDIS_REPL_ONLINE)
+            if (c->repl_put_online_on_ack && c->replstate == SLAVE_STATE_ONLINE)
                 putSlaveOnline(c);
             /* Note: this command does not reply anything! */
             return;
         } else if (!strcasecmp(c->argv[j]->ptr,"getack")) {
             /* REPLCONF GETACK is used in order to request an ACK ASAP
              * to the slave. */
@@ -756,41 +757,41 @@
  * 1) Put the slave in ONLINE state (useless when the function is called
  *    because state is already ONLINE but repl_put_online_on_ack is true).
  * 2) Make sure the writable event is re-installed, since calling the SYNC
  *    command disables it, so that we can accumulate output buffer without
  *    sending it to the slave.
  * 3) Update the count of good slaves. */
-void putSlaveOnline(redisClient *slave) {
-    slave->replstate = REDIS_REPL_ONLINE;
+void putSlaveOnline(client *slave) {
+    slave->replstate = SLAVE_STATE_ONLINE;
     slave->repl_put_online_on_ack = 0;
     slave->repl_ack_time = server.unixtime; /* Prevent false timeout. */
     if (aeCreateFileEvent(server.el, slave->fd, AE_WRITABLE,
         sendReplyToClient, slave) == AE_ERR) {
-        redisLog(REDIS_WARNING,"Unable to register writable event for slave bulk transfer: %s", strerror(errno));
+        serverLog(LL_WARNING,"Unable to register writable event for slave bulk transfer: %s", strerror(errno));
         freeClient(slave);
         return;
     }
     refreshGoodSlavesCount();
-    redisLog(REDIS_NOTICE,"Synchronization with slave %s succeeded",
+    serverLog(LL_NOTICE,"Synchronization with slave %s succeeded",
         replicationGetSlaveName(slave));
 }
 
 void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
-    redisClient *slave = privdata;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(mask);
-    char buf[REDIS_IOBUF_LEN];
+    client *slave = privdata;
+    UNUSED(el);
+    UNUSED(mask);
+    char buf[PROTO_IOBUF_LEN];
     ssize_t nwritten, buflen;
 
     /* Before sending the RDB file, we send the preamble as configured by the
      * replication process. Currently the preamble is just the bulk count of
      * the file in the form "$<length>\r\n". */
     if (slave->replpreamble) {
         nwritten = write(fd,slave->replpreamble,sdslen(slave->replpreamble));
         if (nwritten == -1) {
-            redisLog(REDIS_VERBOSE,"Write error sending RDB preamble to slave: %s",
+            serverLog(LL_VERBOSE,"Write error sending RDB preamble to slave: %s",
                 strerror(errno));
             freeClient(slave);
             return;
         }
         server.stat_net_output_bytes += nwritten;
         sdsrange(slave->replpreamble,nwritten,-1);
@@ -802,22 +803,22 @@
             return;
         }
     }
 
     /* If the preamble was already transfered, send the RDB bulk data. */
     lseek(slave->repldbfd,slave->repldboff,SEEK_SET);
-    buflen = read(slave->repldbfd,buf,REDIS_IOBUF_LEN);
+    buflen = read(slave->repldbfd,buf,PROTO_IOBUF_LEN);
     if (buflen <= 0) {
-        redisLog(REDIS_WARNING,"Read error sending DB to slave: %s",
+        serverLog(LL_WARNING,"Read error sending DB to slave: %s",
             (buflen == 0) ? "premature EOF" : strerror(errno));
         freeClient(slave);
         return;
     }
     if ((nwritten = write(fd,buf,buflen)) == -1) {
         if (errno != EAGAIN) {
-            redisLog(REDIS_WARNING,"Write error sending DB to slave: %s",
+            serverLog(LL_WARNING,"Write error sending DB to slave: %s",
                 strerror(errno));
             freeClient(slave);
         }
         return;
     }
     slave->repldboff += nwritten;
@@ -837,65 +838,65 @@
  * The goal of this function is to handle slaves waiting for a successful
  * background saving in order to perform non-blocking synchronization, and
  * to schedule a new BGSAVE if there are slaves that attached while a
  * BGSAVE was in progress, but it was not a good one for replication (no
  * other slave was accumulating differences).
  *
- * The argument bgsaveerr is REDIS_OK if the background saving succeeded
- * otherwise REDIS_ERR is passed to the function.
+ * The argument bgsaveerr is C_OK if the background saving succeeded
+ * otherwise C_ERR is passed to the function.
  * The 'type' argument is the type of the child that terminated
  * (if it had a disk or socket target). */
 void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
     listNode *ln;
     int startbgsave = 0;
     int mincapa = -1;
     listIter li;
 
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
-        redisClient *slave = ln->value;
+        client *slave = ln->value;
 
-        if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START) {
+        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
             startbgsave = 1;
             mincapa = (mincapa == -1) ? slave->slave_capa :
                                         (mincapa & slave->slave_capa);
-        } else if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_END) {
+        } else if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
             struct redis_stat buf;
 
             /* If this was an RDB on disk save, we have to prepare to send
              * the RDB from disk to the slave socket. Otherwise if this was
              * already an RDB -> Slaves socket transfer, used in the case of
              * diskless replication, our work is trivial, we can just put
              * the slave online. */
-            if (type == REDIS_RDB_CHILD_TYPE_SOCKET) {
-                redisLog(REDIS_NOTICE,
+            if (type == RDB_CHILD_TYPE_SOCKET) {
+                serverLog(LL_NOTICE,
                     "Streamed RDB transfer with slave %s succeeded (socket). Waiting for REPLCONF ACK from slave to enable streaming",
                         replicationGetSlaveName(slave));
                 /* Note: we wait for a REPLCONF ACK message from slave in
                  * order to really put it online (install the write handler
                  * so that the accumulated data can be transfered). However
                  * we change the replication state ASAP, since our slave
                  * is technically online now. */
-                slave->replstate = REDIS_REPL_ONLINE;
+                slave->replstate = SLAVE_STATE_ONLINE;
                 slave->repl_put_online_on_ack = 1;
                 slave->repl_ack_time = server.unixtime; /* Timeout otherwise. */
             } else {
-                if (bgsaveerr != REDIS_OK) {
+                if (bgsaveerr != C_OK) {
                     freeClient(slave);
-                    redisLog(REDIS_WARNING,"SYNC failed. BGSAVE child returned an error");
+                    serverLog(LL_WARNING,"SYNC failed. BGSAVE child returned an error");
                     continue;
                 }
                 if ((slave->repldbfd = open(server.rdb_filename,O_RDONLY)) == -1 ||
                     redis_fstat(slave->repldbfd,&buf) == -1) {
                     freeClient(slave);
-                    redisLog(REDIS_WARNING,"SYNC failed. Can't open/stat DB after BGSAVE: %s", strerror(errno));
+                    serverLog(LL_WARNING,"SYNC failed. Can't open/stat DB after BGSAVE: %s", strerror(errno));
                     continue;
                 }
                 slave->repldboff = 0;
                 slave->repldbsize = buf.st_size;
-                slave->replstate = REDIS_REPL_SEND_BULK;
+                slave->replstate = SLAVE_STATE_SEND_BULK;
                 slave->replpreamble = sdscatprintf(sdsempty(),"$%lld\r\n",
                     (unsigned long long) slave->repldbsize);
 
                 aeDeleteFileEvent(server.el,slave->fd,AE_WRITABLE);
                 if (aeCreateFileEvent(server.el, slave->fd, AE_WRITABLE, sendBulkToSlave, slave) == AE_ERR) {
                     freeClient(slave);
@@ -909,26 +910,14 @@
 
 /* ----------------------------------- SLAVE -------------------------------- */
 
 /* Returns 1 if the given replication state is a handshake state,
  * 0 otherwise. */
 int slaveIsInHandshakeState(void) {
-    return server.repl_state >= REDIS_REPL_RECEIVE_PONG &&
-           server.repl_state <= REDIS_REPL_RECEIVE_PSYNC;
-}
-
-/* Abort the async download of the bulk dataset while SYNC-ing with master */
-void replicationAbortSyncTransfer(void) {
-    redisAssert(server.repl_state == REDIS_REPL_TRANSFER);
-
-    aeDeleteFileEvent(server.el,server.repl_transfer_s,AE_READABLE);
-    close(server.repl_transfer_s);
-    close(server.repl_transfer_fd);
-    unlink(server.repl_transfer_tmpfile);
-    zfree(server.repl_transfer_tmpfile);
-    server.repl_state = REDIS_REPL_CONNECT;
+    return server.repl_state >= REPL_STATE_RECEIVE_PONG &&
+           server.repl_state <= REPL_STATE_RECEIVE_PSYNC;
 }
 
 /* Avoid the master to detect the slave is timing out while loading the
  * RDB file in initial synchronization. We send a single newline character
  * that is valid protocol but is guaranteed to either be sent entierly or
  * not, since the byte is indivisible.
@@ -946,55 +935,72 @@
     }
 }
 
 /* Callback used by emptyDb() while flushing away old data to load
  * the new dataset received by the master. */
 void replicationEmptyDbCallback(void *privdata) {
-    REDIS_NOTUSED(privdata);
+    UNUSED(privdata);
     replicationSendNewlineToMaster();
 }
 
+/* Once we have a link with the master and the synchroniziation was
+ * performed, this function materializes the master client we store
+ * at server.master, starting from the specified file descriptor. */
+void replicationCreateMasterClient(int fd) {
+    server.master = createClient(fd);
+    server.master->flags |= CLIENT_MASTER;
+    server.master->authenticated = 1;
+    server.repl_state = REPL_STATE_CONNECTED;
+    server.master->reploff = server.repl_master_initial_offset;
+    memcpy(server.master->replrunid, server.repl_master_runid,
+        sizeof(server.repl_master_runid));
+    /* If master offset is set to -1, this master is old and is not
+     * PSYNC capable, so we flag it accordingly. */
+    if (server.master->reploff == -1)
+        server.master->flags |= CLIENT_PRE_PSYNC;
+}
+
 /* Asynchronously read the SYNC payload we receive from a master */
 #define REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) /* 8 MB */
 void readSyncBulkPayload(aeEventLoop *el, int fd, void *privdata, int mask) {
     char buf[4096];
     ssize_t nread, readlen;
     off_t left;
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(privdata);
-    REDIS_NOTUSED(mask);
+    UNUSED(el);
+    UNUSED(privdata);
+    UNUSED(mask);
 
     /* Static vars used to hold the EOF mark, and the last bytes received
      * form the server: when they match, we reached the end of the transfer. */
-    static char eofmark[REDIS_RUN_ID_SIZE];
-    static char lastbytes[REDIS_RUN_ID_SIZE];
+    static char eofmark[CONFIG_RUN_ID_SIZE];
+    static char lastbytes[CONFIG_RUN_ID_SIZE];
     static int usemark = 0;
 
     /* If repl_transfer_size == -1 we still have to read the bulk length
      * from the master reply. */
     if (server.repl_transfer_size == -1) {
         if (syncReadLine(fd,buf,1024,server.repl_syncio_timeout*1000) == -1) {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "I/O error reading bulk count from MASTER: %s",
                 strerror(errno));
             goto error;
         }
 
         if (buf[0] == '-') {
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "MASTER aborted replication with an error: %s",
                 buf+1);
             goto error;
         } else if (buf[0] == '\0') {
             /* At this stage just a newline works as a PING in order to take
              * the connection live. So we refresh our last interaction
              * timestamp. */
             server.repl_transfer_lastio = server.unixtime;
             return;
         } else if (buf[0] != '$') {
-            redisLog(REDIS_WARNING,"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?", buf);
+            serverLog(LL_WARNING,"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?", buf);
             goto error;
         }
 
         /* There are two possible forms for the bulk payload. One is the
          * usual $<count> bulk format. The other is used for diskless transfers
          * when the master does not know beforehand the size of the file to
@@ -1002,25 +1008,25 @@
          *
          * $EOF:<40 bytes delimiter>
          *
          * At the end of the file the announced delimiter is transmitted. The
          * delimiter is long and random enough that the probability of a
          * collision with the actual file content can be ignored. */
-        if (strncmp(buf+1,"EOF:",4) == 0 && strlen(buf+5) >= REDIS_RUN_ID_SIZE) {
+        if (strncmp(buf+1,"EOF:",4) == 0 && strlen(buf+5) >= CONFIG_RUN_ID_SIZE) {
             usemark = 1;
-            memcpy(eofmark,buf+5,REDIS_RUN_ID_SIZE);
-            memset(lastbytes,0,REDIS_RUN_ID_SIZE);
+            memcpy(eofmark,buf+5,CONFIG_RUN_ID_SIZE);
+            memset(lastbytes,0,CONFIG_RUN_ID_SIZE);
             /* Set any repl_transfer_size to avoid entering this code path
              * at the next call. */
             server.repl_transfer_size = 0;
-            redisLog(REDIS_NOTICE,
+            serverLog(LL_NOTICE,
                 "MASTER <-> SLAVE sync: receiving streamed RDB from master");
         } else {
             usemark = 0;
             server.repl_transfer_size = strtol(buf+1,NULL,10);
-            redisLog(REDIS_NOTICE,
+            serverLog(LL_NOTICE,
                 "MASTER <-> SLAVE sync: receiving %lld bytes from master",
                 (long long) server.repl_transfer_size);
         }
         return;
     }
 
@@ -1031,48 +1037,48 @@
         left = server.repl_transfer_size - server.repl_transfer_read;
         readlen = (left < (signed)sizeof(buf)) ? left : (signed)sizeof(buf);
     }
 
     nread = read(fd,buf,readlen);
     if (nread <= 0) {
-        redisLog(REDIS_WARNING,"I/O error trying to sync with MASTER: %s",
+        serverLog(LL_WARNING,"I/O error trying to sync with MASTER: %s",
             (nread == -1) ? strerror(errno) : "connection lost");
-        replicationAbortSyncTransfer();
+        cancelReplicationHandshake();
         return;
     }
     server.stat_net_input_bytes += nread;
 
     /* When a mark is used, we want to detect EOF asap in order to avoid
      * writing the EOF mark into the file... */
     int eof_reached = 0;
 
     if (usemark) {
         /* Update the last bytes array, and check if it matches our delimiter.*/
-        if (nread >= REDIS_RUN_ID_SIZE) {
-            memcpy(lastbytes,buf+nread-REDIS_RUN_ID_SIZE,REDIS_RUN_ID_SIZE);
+        if (nread >= CONFIG_RUN_ID_SIZE) {
+            memcpy(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,CONFIG_RUN_ID_SIZE);
         } else {
-            int rem = REDIS_RUN_ID_SIZE-nread;
+            int rem = CONFIG_RUN_ID_SIZE-nread;
             memmove(lastbytes,lastbytes+nread,rem);
             memcpy(lastbytes+rem,buf,nread);
         }
-        if (memcmp(lastbytes,eofmark,REDIS_RUN_ID_SIZE) == 0) eof_reached = 1;
+        if (memcmp(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == 0) eof_reached = 1;
     }
 
     server.repl_transfer_lastio = server.unixtime;
     if (write(server.repl_transfer_fd,buf,nread) != nread) {
-        redisLog(REDIS_WARNING,"Write error or short write writing to the DB dump file needed for MASTER <-> SLAVE synchronization: %s", strerror(errno));
+        serverLog(LL_WARNING,"Write error or short write writing to the DB dump file needed for MASTER <-> SLAVE synchronization: %s", strerror(errno));
         goto error;
     }
     server.repl_transfer_read += nread;
 
     /* Delete the last 40 bytes from the file if we reached EOF. */
     if (usemark && eof_reached) {
         if (ftruncate(server.repl_transfer_fd,
-            server.repl_transfer_read - REDIS_RUN_ID_SIZE) == -1)
+            server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == -1)
         {
-            redisLog(REDIS_WARNING,"Error truncating the RDB file received from the master for SYNC: %s", strerror(errno));
+            serverLog(LL_WARNING,"Error truncating the RDB file received from the master for SYNC: %s", strerror(errno));
             goto error;
         }
     }
 
     /* Sync data on disk from time to time, otherwise at the end of the transfer
      * we may suffer a big delay as the memory buffers are copied into the
@@ -1092,67 +1098,57 @@
         if (server.repl_transfer_read == server.repl_transfer_size)
             eof_reached = 1;
     }
 
     if (eof_reached) {
         if (rename(server.repl_transfer_tmpfile,server.rdb_filename) == -1) {
-            redisLog(REDIS_WARNING,"Failed trying to rename the temp DB into dump.rdb in MASTER <-> SLAVE synchronization: %s", strerror(errno));
-            replicationAbortSyncTransfer();
+            serverLog(LL_WARNING,"Failed trying to rename the temp DB into dump.rdb in MASTER <-> SLAVE synchronization: %s", strerror(errno));
+            cancelReplicationHandshake();
             return;
         }
-        redisLog(REDIS_NOTICE, "MASTER <-> SLAVE sync: Flushing old data");
+        serverLog(LL_NOTICE, "MASTER <-> SLAVE sync: Flushing old data");
         signalFlushedDb(-1);
         emptyDb(replicationEmptyDbCallback);
         /* Before loading the DB into memory we need to delete the readable
          * handler, otherwise it will get called recursively since
          * rdbLoad() will call the event loop to process events from time to
          * time for non blocking loading. */
         aeDeleteFileEvent(server.el,server.repl_transfer_s,AE_READABLE);
-        redisLog(REDIS_NOTICE, "MASTER <-> SLAVE sync: Loading DB in memory");
-        if (rdbLoad(server.rdb_filename) != REDIS_OK) {
-            redisLog(REDIS_WARNING,"Failed trying to load the MASTER synchronization DB from disk");
-            replicationAbortSyncTransfer();
+        serverLog(LL_NOTICE, "MASTER <-> SLAVE sync: Loading DB in memory");
+        if (rdbLoad(server.rdb_filename) != C_OK) {
+            serverLog(LL_WARNING,"Failed trying to load the MASTER synchronization DB from disk");
+            cancelReplicationHandshake();
             return;
         }
         /* Final setup of the connected slave <- master link */
         zfree(server.repl_transfer_tmpfile);
         close(server.repl_transfer_fd);
-        server.master = createClient(server.repl_transfer_s);
-        server.master->flags |= REDIS_MASTER;
-        server.master->authenticated = 1;
-        server.repl_state = REDIS_REPL_CONNECTED;
-        server.master->reploff = server.repl_master_initial_offset;
-        memcpy(server.master->replrunid, server.repl_master_runid,
-            sizeof(server.repl_master_runid));
-        /* If master offset is set to -1, this master is old and is not
-         * PSYNC capable, so we flag it accordingly. */
-        if (server.master->reploff == -1)
-            server.master->flags |= REDIS_PRE_PSYNC;
-        redisLog(REDIS_NOTICE, "MASTER <-> SLAVE sync: Finished with success");
+        replicationCreateMasterClient(server.repl_transfer_s);
+        serverLog(LL_NOTICE, "MASTER <-> SLAVE sync: Finished with success");
         /* Restart the AOF subsystem now that we finished the sync. This
          * will trigger an AOF rewrite, and when done will start appending
          * to the new file. */
-        if (server.aof_state != REDIS_AOF_OFF) {
+        if (server.aof_state != AOF_OFF) {
             int retry = 10;
 
             stopAppendOnly();
-            while (retry-- && startAppendOnly() == REDIS_ERR) {
-                redisLog(REDIS_WARNING,"Failed enabling the AOF after successful master synchronization! Trying it again in one second.");
+            while (retry-- && startAppendOnly() == C_ERR) {
+                serverLog(LL_WARNING,"Failed enabling the AOF after successful master synchronization! Trying it again in one second.");
                 sleep(1);
             }
             if (!retry) {
-                redisLog(REDIS_WARNING,"FATAL: this slave instance finished the synchronization with its master, but the AOF can't be turned on. Exiting now.");
+                serverLog(LL_WARNING,"FATAL: this slave instance finished the synchronization with its master, but the AOF can't be turned on. Exiting now.");
                 exit(1);
             }
         }
     }
 
     return;
 
 error:
-    replicationAbortSyncTransfer();
+    cancelReplicationHandshake();
     return;
 }
 
 /* Send a synchronous command to the master. Used to send AUTH and
  * REPLCONF commands before starting the replication with SYNC.
  *
@@ -1275,23 +1271,23 @@
          * client structure representing the master into server.master. */
         server.repl_master_initial_offset = -1;
 
         if (server.cached_master) {
             psync_runid = server.cached_master->replrunid;
             snprintf(psync_offset,sizeof(psync_offset),"%lld", server.cached_master->reploff+1);
-            redisLog(REDIS_NOTICE,"Trying a partial resynchronization (request %s:%s).", psync_runid, psync_offset);
+            serverLog(LL_NOTICE,"Trying a partial resynchronization (request %s:%s).", psync_runid, psync_offset);
         } else {
-            redisLog(REDIS_NOTICE,"Partial resynchronization not possible (no cached master)");
+            serverLog(LL_NOTICE,"Partial resynchronization not possible (no cached master)");
             psync_runid = "?";
             memcpy(psync_offset,"-1",3);
         }
 
         /* Issue the PSYNC command */
         reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"PSYNC",psync_runid,psync_offset,NULL);
         if (reply != NULL) {
-            redisLog(REDIS_WARNING,"Unable to send PSYNC to master: %s",reply);
+            serverLog(LL_WARNING,"Unable to send PSYNC to master: %s",reply);
             sdsfree(reply);
             aeDeleteFileEvent(server.el,fd,AE_READABLE);
             return PSYNC_WRITE_ERROR;
         }
         return PSYNC_WAIT_REPLY;
     }
@@ -1315,53 +1311,53 @@
         runid = strchr(reply,' ');
         if (runid) {
             runid++;
             offset = strchr(runid,' ');
             if (offset) offset++;
         }
-        if (!runid || !offset || (offset-runid-1) != REDIS_RUN_ID_SIZE) {
-            redisLog(REDIS_WARNING,
+        if (!runid || !offset || (offset-runid-1) != CONFIG_RUN_ID_SIZE) {
+            serverLog(LL_WARNING,
                 "Master replied with wrong +FULLRESYNC syntax.");
             /* This is an unexpected condition, actually the +FULLRESYNC
              * reply means that the master supports PSYNC, but the reply
              * format seems wrong. To stay safe we blank the master
              * runid to make sure next PSYNCs will fail. */
-            memset(server.repl_master_runid,0,REDIS_RUN_ID_SIZE+1);
+            memset(server.repl_master_runid,0,CONFIG_RUN_ID_SIZE+1);
         } else {
             memcpy(server.repl_master_runid, runid, offset-runid-1);
-            server.repl_master_runid[REDIS_RUN_ID_SIZE] = '\0';
+            server.repl_master_runid[CONFIG_RUN_ID_SIZE] = '\0';
             server.repl_master_initial_offset = strtoll(offset,NULL,10);
-            redisLog(REDIS_NOTICE,"Full resync from master: %s:%lld",
+            serverLog(LL_NOTICE,"Full resync from master: %s:%lld",
                 server.repl_master_runid,
                 server.repl_master_initial_offset);
         }
         /* We are going to full resync, discard the cached master structure. */
         replicationDiscardCachedMaster();
         sdsfree(reply);
         return PSYNC_FULLRESYNC;
     }
 
     if (!strncmp(reply,"+CONTINUE",9)) {
         /* Partial resync was accepted, set the replication state accordingly */
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Successful partial resynchronization with master.");
         sdsfree(reply);
         replicationResurrectCachedMaster(fd);
         return PSYNC_CONTINUE;
     }
 
     /* If we reach this point we received either an error since the master does
      * not understand PSYNC, or an unexpected reply from the master.
      * Return PSYNC_NOT_SUPPORTED to the caller in both cases. */
 
     if (strncmp(reply,"-ERR",4)) {
         /* If it's not an error, log the unexpected event. */
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Unexpected reply to PSYNC from master: %s", reply);
     } else {
-        redisLog(REDIS_NOTICE,
+        serverLog(LL_NOTICE,
             "Master does not support PSYNC or is in "
             "error state (reply: %s)", reply);
     }
     sdsfree(reply);
     replicationDiscardCachedMaster();
     return PSYNC_NOT_SUPPORTED;
@@ -1369,176 +1365,176 @@
 
 void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {
     char tmpfile[256], *err = NULL;
     int dfd, maxtries = 5;
     int sockerr = 0, psync_result;
     socklen_t errlen = sizeof(sockerr);
-    REDIS_NOTUSED(el);
-    REDIS_NOTUSED(privdata);
-    REDIS_NOTUSED(mask);
+    UNUSED(el);
+    UNUSED(privdata);
+    UNUSED(mask);
 
     /* If this event fired after the user turned the instance into a master
      * with SLAVEOF NO ONE we must just return ASAP. */
-    if (server.repl_state == REDIS_REPL_NONE) {
+    if (server.repl_state == REPL_STATE_NONE) {
         close(fd);
         return;
     }
 
     /* Check for errors in the socket. */
     if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)
         sockerr = errno;
     if (sockerr) {
-        redisLog(REDIS_WARNING,"Error condition on socket for SYNC: %s",
+        serverLog(LL_WARNING,"Error condition on socket for SYNC: %s",
             strerror(sockerr));
         goto error;
     }
 
     /* Send a PING to check the master is able to reply without errors. */
-    if (server.repl_state == REDIS_REPL_CONNECTING) {
-        redisLog(REDIS_NOTICE,"Non blocking connect for SYNC fired the event.");
+    if (server.repl_state == REPL_STATE_CONNECTING) {
+        serverLog(LL_NOTICE,"Non blocking connect for SYNC fired the event.");
         /* Delete the writable event so that the readable event remains
          * registered and we can wait for the PONG reply. */
         aeDeleteFileEvent(server.el,fd,AE_WRITABLE);
-        server.repl_state = REDIS_REPL_RECEIVE_PONG;
+        server.repl_state = REPL_STATE_RECEIVE_PONG;
         /* Send the PING, don't check for errors at all, we have the timeout
          * that will take care about this. */
         err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"PING",NULL);
         if (err) goto write_error;
         return;
     }
 
     /* Receive the PONG command. */
-    if (server.repl_state == REDIS_REPL_RECEIVE_PONG) {
+    if (server.repl_state == REPL_STATE_RECEIVE_PONG) {
         err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
 
         /* We accept only two replies as valid, a positive +PONG reply
          * (we just check for "+") or an authentication error.
          * Note that older versions of Redis replied with "operation not
          * permitted" instead of using a proper error code, so we test
          * both. */
         if (err[0] != '+' &&
             strncmp(err,"-NOAUTH",7) != 0 &&
             strncmp(err,"-ERR operation not permitted",28) != 0)
         {
-            redisLog(REDIS_WARNING,"Error reply to PING from master: '%s'",err);
+            serverLog(LL_WARNING,"Error reply to PING from master: '%s'",err);
             sdsfree(err);
             goto error;
         } else {
-            redisLog(REDIS_NOTICE,
+            serverLog(LL_NOTICE,
                 "Master replied to PING, replication can continue...");
         }
         sdsfree(err);
-        server.repl_state = REDIS_REPL_SEND_AUTH;
+        server.repl_state = REPL_STATE_SEND_AUTH;
     }
 
     /* AUTH with the master if required. */
-    if (server.repl_state == REDIS_REPL_SEND_AUTH) {
+    if (server.repl_state == REPL_STATE_SEND_AUTH) {
         if (server.masterauth) {
             err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"AUTH",server.masterauth,NULL);
             if (err) goto write_error;
-            server.repl_state = REDIS_REPL_RECEIVE_AUTH;
+            server.repl_state = REPL_STATE_RECEIVE_AUTH;
             return;
         } else {
-            server.repl_state = REDIS_REPL_SEND_PORT;
+            server.repl_state = REPL_STATE_SEND_PORT;
         }
     }
 
     /* Receive AUTH reply. */
-    if (server.repl_state == REDIS_REPL_RECEIVE_AUTH) {
+    if (server.repl_state == REPL_STATE_RECEIVE_AUTH) {
         err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
         if (err[0] == '-') {
-            redisLog(REDIS_WARNING,"Unable to AUTH to MASTER: %s",err);
+            serverLog(LL_WARNING,"Unable to AUTH to MASTER: %s",err);
             sdsfree(err);
             goto error;
         }
         sdsfree(err);
-        server.repl_state = REDIS_REPL_SEND_PORT;
+        server.repl_state = REPL_STATE_SEND_PORT;
     }
 
     /* Set the slave port, so that Master's INFO command can list the
      * slave listening port correctly. */
-    if (server.repl_state == REDIS_REPL_SEND_PORT) {
+    if (server.repl_state == REPL_STATE_SEND_PORT) {
         sds port = sdsfromlonglong(server.port);
         err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"REPLCONF",
                 "listening-port",port, NULL);
         sdsfree(port);
         if (err) goto write_error;
         sdsfree(err);
-        server.repl_state = REDIS_REPL_RECEIVE_PORT;
+        server.repl_state = REPL_STATE_RECEIVE_PORT;
         return;
     }
 
     /* Receive REPLCONF listening-port reply. */
-    if (server.repl_state == REDIS_REPL_RECEIVE_PORT) {
+    if (server.repl_state == REPL_STATE_RECEIVE_PORT) {
         err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
         /* Ignore the error if any, not all the Redis versions support
          * REPLCONF listening-port. */
         if (err[0] == '-') {
-            redisLog(REDIS_NOTICE,"(Non critical) Master does not understand "
-                                  "REPLCONF listening-port: %s", err);
+            serverLog(LL_NOTICE,"(Non critical) Master does not understand "
+                                "REPLCONF listening-port: %s", err);
         }
         sdsfree(err);
-        server.repl_state = REDIS_REPL_SEND_CAPA;
+        server.repl_state = REPL_STATE_SEND_CAPA;
     }
 
     /* Inform the master of our capabilities. While we currently send
      * just one capability, it is possible to chain new capabilities here
      * in the form of REPLCONF capa X capa Y capa Z ...
      * The master will ignore capabilities it does not understand. */
-    if (server.repl_state == REDIS_REPL_SEND_CAPA) {
+    if (server.repl_state == REPL_STATE_SEND_CAPA) {
         err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"REPLCONF",
                 "capa","eof",NULL);
         if (err) goto write_error;
         sdsfree(err);
-        server.repl_state = REDIS_REPL_RECEIVE_CAPA;
+        server.repl_state = REPL_STATE_RECEIVE_CAPA;
         return;
     }
 
     /* Receive CAPA reply. */
-    if (server.repl_state == REDIS_REPL_RECEIVE_CAPA) {
+    if (server.repl_state == REPL_STATE_RECEIVE_CAPA) {
         err = sendSynchronousCommand(SYNC_CMD_READ,fd,NULL);
         /* Ignore the error if any, not all the Redis versions support
          * REPLCONF capa. */
         if (err[0] == '-') {
-            redisLog(REDIS_NOTICE,"(Non critical) Master does not understand "
+            serverLog(LL_NOTICE,"(Non critical) Master does not understand "
                                   "REPLCONF capa: %s", err);
         }
         sdsfree(err);
-        server.repl_state = REDIS_REPL_SEND_PSYNC;
+        server.repl_state = REPL_STATE_SEND_PSYNC;
     }
 
     /* Try a partial resynchonization. If we don't have a cached master
      * slaveTryPartialResynchronization() will at least try to use PSYNC
      * to start a full resynchronization so that we get the master run id
      * and the global offset, to try a partial resync at the next
      * reconnection attempt. */
-    if (server.repl_state == REDIS_REPL_SEND_PSYNC) {
+    if (server.repl_state == REPL_STATE_SEND_PSYNC) {
         if (slaveTryPartialResynchronization(fd,0) == PSYNC_WRITE_ERROR) {
             err = sdsnew("Write error sending the PSYNC command.");
             goto write_error;
         }
-        server.repl_state = REDIS_REPL_RECEIVE_PSYNC;
+        server.repl_state = REPL_STATE_RECEIVE_PSYNC;
         return;
     }
 
-    /* If reached this point, we should be in REDIS_REPL_RECEIVE_PSYNC. */
-    if (server.repl_state != REDIS_REPL_RECEIVE_PSYNC) {
-        redisLog(REDIS_WARNING,"syncWithMaster(): state machine error, "
+    /* If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC. */
+    if (server.repl_state != REPL_STATE_RECEIVE_PSYNC) {
+        serverLog(LL_WARNING,"syncWithMaster(): state machine error, "
                              "state should be RECEIVE_PSYNC but is %d",
                              server.repl_state);
         goto error;
     }
 
     psync_result = slaveTryPartialResynchronization(fd,1);
     if (psync_result == PSYNC_WAIT_REPLY) return; /* Try again later... */
 
     /* Note: if PSYNC does not return WAIT_REPLY, it will take care of
      * uninstalling the read handler from the file descriptor. */
 
     if (psync_result == PSYNC_CONTINUE) {
-        redisLog(REDIS_NOTICE, "MASTER <-> SLAVE sync: Master accepted a Partial Resynchronization.");
+        serverLog(LL_NOTICE, "MASTER <-> SLAVE sync: Master accepted a Partial Resynchronization.");
         return;
     }
 
     /* PSYNC failed or is not supported: we want our slaves to resync with us
      * as well, if we have any (chained replication case). The mater may
      * transfer us an entirely different data set and we have no way to
@@ -1547,15 +1543,15 @@
     freeReplicationBacklog(); /* Don't allow our chained slaves to PSYNC. */
 
     /* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC
      * and the server.repl_master_runid and repl_master_initial_offset are
      * already populated. */
     if (psync_result == PSYNC_NOT_SUPPORTED) {
-        redisLog(REDIS_NOTICE,"Retrying with SYNC...");
+        serverLog(LL_NOTICE,"Retrying with SYNC...");
         if (syncWrite(fd,"SYNC\r\n",6,server.repl_syncio_timeout*1000) == -1) {
-            redisLog(REDIS_WARNING,"I/O error writing to MASTER: %s",
+            serverLog(LL_WARNING,"I/O error writing to MASTER: %s",
                 strerror(errno));
             goto error;
         }
     }
 
     /* Prepare a suitable temp file for bulk transfer */
@@ -1564,101 +1560,113 @@
             "temp-%d.%ld.rdb",(int)server.unixtime,(long int)getpid());
         dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);
         if (dfd != -1) break;
         sleep(1);
     }
     if (dfd == -1) {
-        redisLog(REDIS_WARNING,"Opening the temp file needed for MASTER <-> SLAVE synchronization: %s",strerror(errno));
+        serverLog(LL_WARNING,"Opening the temp file needed for MASTER <-> SLAVE synchronization: %s",strerror(errno));
         goto error;
     }
 
     /* Setup the non blocking download of the bulk file. */
     if (aeCreateFileEvent(server.el,fd, AE_READABLE,readSyncBulkPayload,NULL)
             == AE_ERR)
     {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Can't create readable event for SYNC: %s (fd=%d)",
             strerror(errno),fd);
         goto error;
     }
 
-    server.repl_state = REDIS_REPL_TRANSFER;
+    server.repl_state = REPL_STATE_TRANSFER;
     server.repl_transfer_size = -1;
     server.repl_transfer_read = 0;
     server.repl_transfer_last_fsync_off = 0;
     server.repl_transfer_fd = dfd;
     server.repl_transfer_lastio = server.unixtime;
     server.repl_transfer_tmpfile = zstrdup(tmpfile);
     return;
 
 error:
     aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
     close(fd);
     server.repl_transfer_s = -1;
-    server.repl_state = REDIS_REPL_CONNECT;
+    server.repl_state = REPL_STATE_CONNECT;
     return;
 
 write_error: /* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */
-    redisLog(REDIS_WARNING,"Sending command to master in replication handshake: %s", err);
+    serverLog(LL_WARNING,"Sending command to master in replication handshake: %s", err);
     sdsfree(err);
     goto error;
 }
 
 int connectWithMaster(void) {
     int fd;
 
     fd = anetTcpNonBlockBestEffortBindConnect(NULL,
-        server.masterhost,server.masterport,REDIS_BIND_ADDR);
+        server.masterhost,server.masterport,NET_FIRST_BIND_ADDR);
     if (fd == -1) {
-        redisLog(REDIS_WARNING,"Unable to connect to MASTER: %s",
+        serverLog(LL_WARNING,"Unable to connect to MASTER: %s",
             strerror(errno));
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     if (aeCreateFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE,syncWithMaster,NULL) ==
             AE_ERR)
     {
         close(fd);
-        redisLog(REDIS_WARNING,"Can't create readable event for SYNC");
-        return REDIS_ERR;
+        serverLog(LL_WARNING,"Can't create readable event for SYNC");
+        return C_ERR;
     }
 
     server.repl_transfer_lastio = server.unixtime;
     server.repl_transfer_s = fd;
-    server.repl_state = REDIS_REPL_CONNECTING;
-    return REDIS_OK;
+    server.repl_state = REPL_STATE_CONNECTING;
+    return C_OK;
 }
 
 /* This function can be called when a non blocking connection is currently
- * in progress to undo it. */
+ * in progress to undo it.
+ * Never call this function directly, use cancelReplicationHandshake() instead.
+ */
 void undoConnectWithMaster(void) {
     int fd = server.repl_transfer_s;
 
-    redisAssert(server.repl_state == REDIS_REPL_CONNECTING ||
-                slaveIsInHandshakeState());
     aeDeleteFileEvent(server.el,fd,AE_READABLE|AE_WRITABLE);
     close(fd);
     server.repl_transfer_s = -1;
-    server.repl_state = REDIS_REPL_CONNECT;
+}
+
+/* Abort the async download of the bulk dataset while SYNC-ing with master.
+ * Never call this function directly, use cancelReplicationHandshake() instead.
+ */
+void replicationAbortSyncTransfer(void) {
+    serverAssert(server.repl_state == REPL_STATE_TRANSFER);
+    undoConnectWithMaster();
+    close(server.repl_transfer_fd);
+    unlink(server.repl_transfer_tmpfile);
+    zfree(server.repl_transfer_tmpfile);
 }
 
 /* This function aborts a non blocking replication attempt if there is one
  * in progress, by canceling the non-blocking connect attempt or
  * the initial bulk transfer.
  *
  * If there was a replication handshake in progress 1 is returned and
- * the replication state (server.repl_state) set to REDIS_REPL_CONNECT.
+ * the replication state (server.repl_state) set to REPL_STATE_CONNECT.
  *
  * Otherwise zero is returned and no operation is perforemd at all. */
 int cancelReplicationHandshake(void) {
-    if (server.repl_state == REDIS_REPL_TRANSFER) {
+    if (server.repl_state == REPL_STATE_TRANSFER) {
         replicationAbortSyncTransfer();
-    } else if (server.repl_state == REDIS_REPL_CONNECTING ||
+        server.repl_state = REPL_STATE_CONNECT;
+    } else if (server.repl_state == REPL_STATE_CONNECTING ||
                slaveIsInHandshakeState())
     {
         undoConnectWithMaster();
+        server.repl_state = REPL_STATE_CONNECT;
     } else {
         return 0;
     }
     return 1;
 }
 
@@ -1670,13 +1678,13 @@
     if (server.master) freeClient(server.master);
     disconnectAllBlockedClients(); /* Clients blocked in master, now slave. */
     disconnectSlaves(); /* Force our slaves to resync with us as well. */
     replicationDiscardCachedMaster(); /* Don't try a PSYNC. */
     freeReplicationBacklog(); /* Don't allow our chained slaves to PSYNC. */
     cancelReplicationHandshake();
-    server.repl_state = REDIS_REPL_CONNECT;
+    server.repl_state = REPL_STATE_CONNECT;
     server.master_repl_offset = 0;
     server.repl_down_since = 0;
 }
 
 /* Cancel replication, setting the instance as a master itself. */
 void replicationUnsetMaster(void) {
@@ -1693,27 +1701,27 @@
             freeReplicationBacklog();
         }
         freeClient(server.master);
     }
     replicationDiscardCachedMaster();
     cancelReplicationHandshake();
-    server.repl_state = REDIS_REPL_NONE;
+    server.repl_state = REPL_STATE_NONE;
 }
 
 /* This function is called when the slave lose the connection with the
  * master into an unexpected way. */
 void replicationHandleMasterDisconnection(void) {
     server.master = NULL;
-    server.repl_state = REDIS_REPL_CONNECT;
+    server.repl_state = REPL_STATE_CONNECT;
     server.repl_down_since = server.unixtime;
     /* We lost connection with our master, don't disconnect slaves yet,
      * maybe we'll be able to PSYNC with our master later. We'll disconnect
      * the slaves only if we'll have to do a full resync with our master. */
 }
 
-void slaveofCommand(redisClient *c) {
+void slaveofCommand(client *c) {
     /* SLAVEOF is not allowed in cluster mode as replication is automatically
      * configured using the current address of the master node. */
     if (server.cluster_enabled) {
         addReplyError(c,"SLAVEOF not allowed in cluster mode.");
         return;
     }
@@ -1722,61 +1730,61 @@
      * into a master. Otherwise the new master address is set. */
     if (!strcasecmp(c->argv[1]->ptr,"no") &&
         !strcasecmp(c->argv[2]->ptr,"one")) {
         if (server.masterhost) {
             replicationUnsetMaster();
             sds client = catClientInfoString(sdsempty(),c);
-            redisLog(REDIS_NOTICE,
-                "MASTER MODE enabled (user request from '%s')",client);
+            serverLog(LL_NOTICE,"MASTER MODE enabled (user request from '%s')",
+                client);
             sdsfree(client);
         }
     } else {
         long port;
 
-        if ((getLongFromObjectOrReply(c, c->argv[2], &port, NULL) != REDIS_OK))
+        if ((getLongFromObjectOrReply(c, c->argv[2], &port, NULL) != C_OK))
             return;
 
         /* Check if we are already attached to the specified slave */
         if (server.masterhost && !strcasecmp(server.masterhost,c->argv[1]->ptr)
             && server.masterport == port) {
-            redisLog(REDIS_NOTICE,"SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.");
+            serverLog(LL_NOTICE,"SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.");
             addReplySds(c,sdsnew("+OK Already connected to specified master\r\n"));
             return;
         }
         /* There was no previous master or the user specified a different one,
          * we can continue. */
         replicationSetMaster(c->argv[1]->ptr, port);
         sds client = catClientInfoString(sdsempty(),c);
-        redisLog(REDIS_NOTICE,"SLAVE OF %s:%d enabled (user request from '%s')",
+        serverLog(LL_NOTICE,"SLAVE OF %s:%d enabled (user request from '%s')",
             server.masterhost, server.masterport, client);
         sdsfree(client);
     }
     addReply(c,shared.ok);
 }
 
 /* ROLE command: provide information about the role of the instance
  * (master or slave) and additional information related to replication
  * in an easy to process format. */
-void roleCommand(redisClient *c) {
+void roleCommand(client *c) {
     if (server.masterhost == NULL) {
         listIter li;
         listNode *ln;
         void *mbcount;
         int slaves = 0;
 
         addReplyMultiBulkLen(c,3);
         addReplyBulkCBuffer(c,"master",6);
         addReplyLongLong(c,server.master_repl_offset);
         mbcount = addDeferredMultiBulkLength(c);
         listRewind(server.slaves,&li);
         while((ln = listNext(&li))) {
-            redisClient *slave = ln->value;
-            char ip[REDIS_IP_STR_LEN];
+            client *slave = ln->value;
+            char ip[NET_IP_STR_LEN];
 
             if (anetPeerToString(slave->fd,ip,sizeof(ip),NULL) == -1) continue;
-            if (slave->replstate != REDIS_REPL_ONLINE) continue;
+            if (slave->replstate != SLAVE_STATE_ONLINE) continue;
             addReplyMultiBulkLen(c,3);
             addReplyBulkCString(c,ip);
             addReplyBulkLongLong(c,slave->slave_listening_port);
             addReplyBulkLongLong(c,slave->repl_ack_off);
             slaves++;
         }
@@ -1789,38 +1797,38 @@
         addReplyBulkCString(c,server.masterhost);
         addReplyLongLong(c,server.masterport);
         if (slaveIsInHandshakeState()) {
             slavestate = "handshake";
         } else {
             switch(server.repl_state) {
-            case REDIS_REPL_NONE: slavestate = "none"; break;
-            case REDIS_REPL_CONNECT: slavestate = "connect"; break;
-            case REDIS_REPL_CONNECTING: slavestate = "connecting"; break;
-            case REDIS_REPL_TRANSFER: slavestate = "sync"; break;
-            case REDIS_REPL_CONNECTED: slavestate = "connected"; break;
+            case REPL_STATE_NONE: slavestate = "none"; break;
+            case REPL_STATE_CONNECT: slavestate = "connect"; break;
+            case REPL_STATE_CONNECTING: slavestate = "connecting"; break;
+            case REPL_STATE_TRANSFER: slavestate = "sync"; break;
+            case REPL_STATE_CONNECTED: slavestate = "connected"; break;
             default: slavestate = "unknown"; break;
             }
         }
         addReplyBulkCString(c,slavestate);
         addReplyLongLong(c,server.master ? server.master->reploff : -1);
     }
 }
 
 /* Send a REPLCONF ACK command to the master to inform it about the current
  * processed offset. If we are not connected with a master, the command has
  * no effects. */
 void replicationSendAck(void) {
-    redisClient *c = server.master;
+    client *c = server.master;
 
     if (c != NULL) {
-        c->flags |= REDIS_MASTER_FORCE_REPLY;
+        c->flags |= CLIENT_MASTER_FORCE_REPLY;
         addReplyMultiBulkLen(c,3);
         addReplyBulkCString(c,"REPLCONF");
         addReplyBulkCString(c,"ACK");
         addReplyBulkLongLong(c,c->reploff);
-        c->flags &= ~REDIS_MASTER_FORCE_REPLY;
+        c->flags &= ~CLIENT_MASTER_FORCE_REPLY;
     }
 }
 
 /* ---------------------- MASTER CACHING FOR PSYNC -------------------------- */
 
 /* In order to implement partial synchronization we need to be able to cache
@@ -1838,37 +1846,23 @@
  * replicationDiscardCachedMaster() that will make sure to kill the client
  * as for some reason we don't want to use it in the future.
  *
  * replicationResurrectCachedMaster() that is used after a successful PSYNC
  * handshake in order to reactivate the cached master.
  */
-void replicationCacheMaster(redisClient *c) {
-    listNode *ln;
-
-    redisAssert(server.master != NULL && server.cached_master == NULL);
-    redisLog(REDIS_NOTICE,"Caching the disconnected master state.");
+void replicationCacheMaster(client *c) {
+    serverAssert(server.master != NULL && server.cached_master == NULL);
+    serverLog(LL_NOTICE,"Caching the disconnected master state.");
 
-    /* Remove from the list of clients, we don't want this client to be
-     * listed by CLIENT LIST or processed in any way by batch operations. */
-    ln = listSearchKey(server.clients,c);
-    redisAssert(ln != NULL);
-    listDelNode(server.clients,ln);
+    /* Unlink the client from the server structures. */
+    unlinkClient(c);
 
     /* Save the master. Server.master will be set to null later by
      * replicationHandleMasterDisconnection(). */
     server.cached_master = server.master;
 
-    /* Remove the event handlers and close the socket. We'll later reuse
-     * the socket of the new connection with the master during PSYNC. */
-    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
-    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
-    close(c->fd);
-
-    /* Set fd to -1 so that we can safely call freeClient(c) later. */
-    c->fd = -1;
-
     /* Invalidate the Peer ID cache. */
     if (c->peerid) {
         sdsfree(c->peerid);
         c->peerid = NULL;
     }
 
@@ -1880,14 +1874,14 @@
 
 /* Free a cached master, called when there are no longer the conditions for
  * a partial resync on reconnection. */
 void replicationDiscardCachedMaster(void) {
     if (server.cached_master == NULL) return;
 
-    redisLog(REDIS_NOTICE,"Discarding previously cached master state.");
-    server.cached_master->flags &= ~REDIS_MASTER;
+    serverLog(LL_NOTICE,"Discarding previously cached master state.");
+    server.cached_master->flags &= ~CLIENT_MASTER;
     freeClient(server.cached_master);
     server.cached_master = NULL;
 }
 
 /* Turn the cached master into the current master, using the file descriptor
  * passed as argument as the socket for the new master.
@@ -1896,31 +1890,31 @@
  * so the stream of data that we'll receive will start from were this
  * master left. */
 void replicationResurrectCachedMaster(int newfd) {
     server.master = server.cached_master;
     server.cached_master = NULL;
     server.master->fd = newfd;
-    server.master->flags &= ~(REDIS_CLOSE_AFTER_REPLY|REDIS_CLOSE_ASAP);
+    server.master->flags &= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
     server.master->authenticated = 1;
     server.master->lastinteraction = server.unixtime;
-    server.repl_state = REDIS_REPL_CONNECTED;
+    server.repl_state = REPL_STATE_CONNECTED;
 
     /* Re-add to the list of clients. */
     listAddNodeTail(server.clients,server.master);
     if (aeCreateFileEvent(server.el, newfd, AE_READABLE,
                           readQueryFromClient, server.master)) {
-        redisLog(REDIS_WARNING,"Error resurrecting the cached master, impossible to add the readable handler: %s", strerror(errno));
+        serverLog(LL_WARNING,"Error resurrecting the cached master, impossible to add the readable handler: %s", strerror(errno));
         freeClientAsync(server.master); /* Close ASAP. */
     }
 
     /* We may also need to install the write handler as well if there is
      * pending data in the write buffers. */
-    if (server.master->bufpos || listLength(server.master->reply)) {
+    if (clientHasPendingReplies(server.master)) {
         if (aeCreateFileEvent(server.el, newfd, AE_WRITABLE,
                           sendReplyToClient, server.master)) {
-            redisLog(REDIS_WARNING,"Error resurrecting the cached master, impossible to add the writable handler: %s", strerror(errno));
+            serverLog(LL_WARNING,"Error resurrecting the cached master, impossible to add the writable handler: %s", strerror(errno));
             freeClientAsync(server.master); /* Close ASAP. */
         }
     }
 }
 
 /* ------------------------- MIN-SLAVES-TO-WRITE  --------------------------- */
@@ -1935,16 +1929,16 @@
 
     if (!server.repl_min_slaves_to_write ||
         !server.repl_min_slaves_max_lag) return;
 
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
-        redisClient *slave = ln->value;
+        client *slave = ln->value;
         time_t lag = server.unixtime - slave->repl_ack_time;
 
-        if (slave->replstate == REDIS_REPL_ONLINE &&
+        if (slave->replstate == SLAVE_STATE_ONLINE &&
             lag <= server.repl_min_slaves_max_lag) good++;
     }
     server.repl_good_slaves_count = good;
 }
 
 /* ----------------------- REPLICATION SCRIPT CACHE --------------------------
@@ -2012,20 +2006,20 @@
     if (listLength(server.repl_scriptcache_fifo) == server.repl_scriptcache_size)
     {
         listNode *ln = listLast(server.repl_scriptcache_fifo);
         sds oldest = listNodeValue(ln);
 
         retval = dictDelete(server.repl_scriptcache_dict,oldest);
-        redisAssert(retval == DICT_OK);
+        serverAssert(retval == DICT_OK);
         listDelNode(server.repl_scriptcache_fifo,ln);
     }
 
     /* Add current. */
     retval = dictAdd(server.repl_scriptcache_dict,key,NULL);
     listAddNodeHead(server.repl_scriptcache_fifo,key);
-    redisAssert(retval == DICT_OK);
+    serverAssert(retval == DICT_OK);
 }
 
 /* Returns non-zero if the specified entry exists inside the cache, that is,
  * if all the slaves are aware of this script SHA1. */
 int replicationScriptCacheExists(sds sha1) {
     return dictFind(server.repl_scriptcache_dict,sha1) != NULL;
@@ -2071,60 +2065,60 @@
     listIter li;
     listNode *ln;
     int count = 0;
 
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
-        redisClient *slave = ln->value;
+        client *slave = ln->value;
 
-        if (slave->replstate != REDIS_REPL_ONLINE) continue;
+        if (slave->replstate != SLAVE_STATE_ONLINE) continue;
         if (slave->repl_ack_off >= offset) count++;
     }
     return count;
 }
 
 /* WAIT for N replicas to acknowledge the processing of our latest
  * write command (and all the previous commands). */
-void waitCommand(redisClient *c) {
+void waitCommand(client *c) {
     mstime_t timeout;
     long numreplicas, ackreplicas;
     long long offset = c->woff;
 
     /* Argument parsing. */
-    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != REDIS_OK)
+    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK)
         return;
     if (getTimeoutFromObjectOrReply(c,c->argv[2],&timeout,UNIT_MILLISECONDS)
-        != REDIS_OK) return;
+        != C_OK) return;
 
     /* First try without blocking at all. */
     ackreplicas = replicationCountAcksByOffset(c->woff);
-    if (ackreplicas >= numreplicas || c->flags & REDIS_MULTI) {
+    if (ackreplicas >= numreplicas || c->flags & CLIENT_MULTI) {
         addReplyLongLong(c,ackreplicas);
         return;
     }
 
     /* Otherwise block the client and put it into our list of clients
      * waiting for ack from slaves. */
     c->bpop.timeout = timeout;
     c->bpop.reploffset = offset;
     c->bpop.numreplicas = numreplicas;
     listAddNodeTail(server.clients_waiting_acks,c);
-    blockClient(c,REDIS_BLOCKED_WAIT);
+    blockClient(c,BLOCKED_WAIT);
 
     /* Make sure that the server will send an ACK request to all the slaves
      * before returning to the event loop. */
     replicationRequestAckFromSlaves();
 }
 
 /* This is called by unblockClient() to perform the blocking op type
  * specific cleanup. We just remove the client from the list of clients
  * waiting for replica acks. Never call it directly, call unblockClient()
  * instead. */
-void unblockClientWaitingReplicas(redisClient *c) {
+void unblockClientWaitingReplicas(client *c) {
     listNode *ln = listSearchKey(server.clients_waiting_acks,c);
-    redisAssert(ln != NULL);
+    serverAssert(ln != NULL);
     listDelNode(server.clients_waiting_acks,ln);
 }
 
 /* Check if there are clients blocked in WAIT that can be unblocked since
  * we received enough ACKs from slaves. */
 void processClientsWaitingReplicas(void) {
@@ -2133,13 +2127,13 @@
 
     listIter li;
     listNode *ln;
 
     listRewind(server.clients_waiting_acks,&li);
     while((ln = listNext(&li))) {
-        redisClient *c = ln->value;
+        client *c = ln->value;
 
         /* Every time we find a client that is satisfied for a given
          * offset and number of replicas, we remember it so the next client
          * may be unblocked without calling replicationCountAcksByOffset()
          * if the requested offset / replicas were equal or less. */
         if (last_offset && last_offset > c->bpop.reploffset &&
@@ -2185,50 +2179,50 @@
 /* Replication cron function, called 1 time per second. */
 void replicationCron(void) {
     static long long replication_cron_loops = 0;
 
     /* Non blocking connection timeout? */
     if (server.masterhost &&
-        (server.repl_state == REDIS_REPL_CONNECTING ||
+        (server.repl_state == REPL_STATE_CONNECTING ||
          slaveIsInHandshakeState()) &&
          (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
     {
-        redisLog(REDIS_WARNING,"Timeout connecting to the MASTER...");
-        undoConnectWithMaster();
+        serverLog(LL_WARNING,"Timeout connecting to the MASTER...");
+        cancelReplicationHandshake();
     }
 
     /* Bulk transfer I/O timeout? */
-    if (server.masterhost && server.repl_state == REDIS_REPL_TRANSFER &&
+    if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER &&
         (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
     {
-        redisLog(REDIS_WARNING,"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value.");
-        replicationAbortSyncTransfer();
+        serverLog(LL_WARNING,"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value.");
+        cancelReplicationHandshake();
     }
 
     /* Timed out master when we are an already connected slave? */
-    if (server.masterhost && server.repl_state == REDIS_REPL_CONNECTED &&
+    if (server.masterhost && server.repl_state == REPL_STATE_CONNECTED &&
         (time(NULL)-server.master->lastinteraction) > server.repl_timeout)
     {
-        redisLog(REDIS_WARNING,"MASTER timeout: no data nor PING received...");
+        serverLog(LL_WARNING,"MASTER timeout: no data nor PING received...");
         freeClient(server.master);
     }
 
     /* Check if we should connect to a MASTER */
-    if (server.repl_state == REDIS_REPL_CONNECT) {
-        redisLog(REDIS_NOTICE,"Connecting to MASTER %s:%d",
+    if (server.repl_state == REPL_STATE_CONNECT) {
+        serverLog(LL_NOTICE,"Connecting to MASTER %s:%d",
             server.masterhost, server.masterport);
-        if (connectWithMaster() == REDIS_OK) {
-            redisLog(REDIS_NOTICE,"MASTER <-> SLAVE sync started");
+        if (connectWithMaster() == C_OK) {
+            serverLog(LL_NOTICE,"MASTER <-> SLAVE sync started");
         }
     }
 
     /* Send ACK to master from time to time.
      * Note that we do not send periodic acks to masters that don't
      * support PSYNC and replication offsets. */
     if (server.masterhost && server.master &&
-        !(server.master->flags & REDIS_PRE_PSYNC))
+        !(server.master->flags & CLIENT_PRE_PSYNC))
         replicationSendAck();
 
     /* If we have attached slaves, PING them from time to time.
      * So slaves can implement an explicit timeout to masters, and will
      * be able to detect a link disconnection even if the TCP connection
      * will not actually go down. */
@@ -2249,17 +2243,17 @@
      * The newline will be ignored by the slave but will refresh the
      * last-io timer preventing a timeout. In this case we ignore the
      * ping period and refresh the connection once per second since certain
      * timeouts are set at a few seconds (example: PSYNC response). */
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
-        redisClient *slave = ln->value;
+        client *slave = ln->value;
 
-        if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START ||
-            (slave->replstate == REDIS_REPL_WAIT_BGSAVE_END &&
-             server.rdb_child_type != REDIS_RDB_CHILD_TYPE_SOCKET))
+        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
+            (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END &&
+             server.rdb_child_type != RDB_CHILD_TYPE_SOCKET))
         {
             if (write(slave->fd, "\n", 1) == -1) {
                 /* Don't worry, it's just a ping. */
             }
         }
     }
@@ -2268,19 +2262,19 @@
     if (listLength(server.slaves)) {
         listIter li;
         listNode *ln;
 
         listRewind(server.slaves,&li);
         while((ln = listNext(&li))) {
-            redisClient *slave = ln->value;
+            client *slave = ln->value;
 
-            if (slave->replstate != REDIS_REPL_ONLINE) continue;
-            if (slave->flags & REDIS_PRE_PSYNC) continue;
+            if (slave->replstate != SLAVE_STATE_ONLINE) continue;
+            if (slave->flags & CLIENT_PRE_PSYNC) continue;
             if ((server.unixtime - slave->repl_ack_time) > server.repl_timeout)
             {
-                redisLog(REDIS_WARNING, "Disconnecting timedout slave: %s",
+                serverLog(LL_WARNING, "Disconnecting timedout slave: %s",
                     replicationGetSlaveName(slave));
                 freeClient(slave);
             }
         }
     }
 
@@ -2290,24 +2284,24 @@
         server.repl_backlog)
     {
         time_t idle = server.unixtime - server.repl_no_slaves_since;
 
         if (idle > server.repl_backlog_time_limit) {
             freeReplicationBacklog();
-            redisLog(REDIS_NOTICE,
+            serverLog(LL_NOTICE,
                 "Replication backlog freed after %d seconds "
                 "without connected slaves.",
                 (int) server.repl_backlog_time_limit);
         }
     }
 
     /* If AOF is disabled and we no longer have attached slaves, we can
      * free our Replication Script Cache as there is no need to propagate
      * EVALSHA at all. */
     if (listLength(server.slaves) == 0 &&
-        server.aof_state == REDIS_AOF_OFF &&
+        server.aof_state == AOF_OFF &&
         listLength(server.repl_scriptcache_fifo) != 0)
     {
         replicationScriptCacheFlush();
     }
 
     /* If we are using diskless replication and there are slaves waiting
@@ -2323,14 +2317,14 @@
         int mincapa = -1;
         listNode *ln;
         listIter li;
 
         listRewind(server.slaves,&li);
         while((ln = listNext(&li))) {
-            redisClient *slave = ln->value;
-            if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START) {
+            client *slave = ln->value;
+            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
                 idle = server.unixtime - slave->lastinteraction;
                 if (idle > max_idle) max_idle = idle;
                 slaves_waiting++;
                 mincapa = (mincapa == -1) ? slave->slave_capa :
                                             (mincapa & slave->slave_capa);
             }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/replication.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/replication.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/replication.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/replication.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.c	2016-05-06 15:11:36.000000000 +0800
@@ -50,13 +50,13 @@
 #include <stdio.h>
 #include <unistd.h>
 #include "rio.h"
 #include "util.h"
 #include "crc64.h"
 #include "config.h"
-#include "redis.h"
+#include "server.h"
 
 /* ------------------------- Buffer I/O implementation ----------------------- */
 
 /* Returns 1 or 0 for success/failure. */
 static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {
     r->io.buffer.ptr = sdscatlen(r->io.buffer.ptr,(char*)buf,len);
@@ -78,13 +78,13 @@
     return r->io.buffer.pos;
 }
 
 /* Flushes any buffer to target device if applicable. Returns 1 on success
  * and 0 on failures. */
 static int rioBufferFlush(rio *r) {
-    REDIS_NOTUSED(r);
+    UNUSED(r);
     return 1; /* Nothing to do, our write just appends to the buffer. */
 }
 
 static const rio rioBufferIO = {
     rioBufferRead,
     rioBufferWrite,
@@ -160,27 +160,27 @@
 /* ------------------- File descriptors set implementation ------------------- */
 
 /* Returns 1 or 0 for success/failure.
  * The function returns success as long as we are able to correctly write
  * to at least one file descriptor.
  *
- * When buf is NULL adn len is 0, the function performs a flush operation
+ * When buf is NULL and len is 0, the function performs a flush operation
  * if there is some pending buffer, so this function is also used in order
  * to implement rioFdsetFlush(). */
 static size_t rioFdsetWrite(rio *r, const void *buf, size_t len) {
     ssize_t retval;
     int j;
     unsigned char *p = (unsigned char*) buf;
     int doflush = (buf == NULL && len == 0);
 
     /* To start we always append to our buffer. If it gets larger than
      * a given size, we actually write to the sockets. */
     if (len) {
         r->io.fdset.buf = sdscatlen(r->io.fdset.buf,buf,len);
-        len = 0; /* Prevent entering the while belove if we don't flush. */
-        if (sdslen(r->io.fdset.buf) > REDIS_IOBUF_LEN) doflush = 1;
+        len = 0; /* Prevent entering the while below if we don't flush. */
+        if (sdslen(r->io.fdset.buf) > PROTO_IOBUF_LEN) doflush = 1;
     }
 
     if (doflush) {
         p = (unsigned char*) r->io.fdset.buf;
         len = sdslen(r->io.fdset.buf);
     }
@@ -229,15 +229,15 @@
     if (doflush) sdsclear(r->io.fdset.buf);
     return 1;
 }
 
 /* Returns 1 or 0 for success/failure. */
 static size_t rioFdsetRead(rio *r, void *buf, size_t len) {
-    REDIS_NOTUSED(r);
-    REDIS_NOTUSED(buf);
-    REDIS_NOTUSED(len);
+    UNUSED(r);
+    UNUSED(buf);
+    UNUSED(len);
     return 0; /* Error, this target does not support reading. */
 }
 
 /* Returns read/write position in file. */
 static off_t rioFdsetTell(rio *r) {
     return r->io.fdset.pos;
@@ -273,12 +273,13 @@
     for (j = 0; j < numfds; j++) r->io.fdset.state[j] = 0;
     r->io.fdset.numfds = numfds;
     r->io.fdset.pos = 0;
     r->io.fdset.buf = sdsempty();
 }
 
+/* release the rio stream. */
 void rioFreeFdset(rio *r) {
     zfree(r->io.fdset.fds);
     zfree(r->io.fdset.state);
     sdsfree(r->io.fdset.buf);
 }
 
@@ -296,13 +297,13 @@
  *
  * This feature is useful in a few contexts since when we rely on OS write
  * buffers sometimes the OS buffers way too much, resulting in too many
  * disk I/O concentrated in very little time. When we fsync in an explicit
  * way instead the I/O pressure is more distributed across time. */
 void rioSetAutoSync(rio *r, off_t bytes) {
-    redisAssert(r->read == rioFileIO.read);
+    serverAssert(r->read == rioFileIO.read);
     r->io.file.autosync = bytes;
 }
 
 /* --------------------------- Higher level interface --------------------------
  *
  * The following higher level functions use lower level rio.c functions to help
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.h	2016-05-06 15:11:36.000000000 +0800
@@ -125,12 +125,14 @@
 }
 
 void rioInitWithFile(rio *r, FILE *fp);
 void rioInitWithBuffer(rio *r, sds s);
 void rioInitWithFdset(rio *r, int *fds, int numfds);
 
+void rioFreeFdset(rio *r);
+
 size_t rioWriteBulkCount(rio *r, char prefix, int count);
 size_t rioWriteBulkString(rio *r, const char *buf, size_t len);
 size_t rioWriteBulkLongLong(rio *r, long long l);
 size_t rioWriteBulkDouble(rio *r, double d);
 
 void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/rio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/rio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/scripting.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/scripting.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/scripting.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/scripting.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,13 +24,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include "sha1.h"
 #include "rand.h"
 #include "cluster.h"
 
 #include <lua.h>
 #include <lauxlib.h>
@@ -42,52 +42,100 @@
 char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply);
 char *redisProtocolToLuaType_Status(lua_State *lua, char *reply);
 char *redisProtocolToLuaType_Error(lua_State *lua, char *reply);
 char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply);
 int redis_math_random (lua_State *L);
 int redis_math_randomseed (lua_State *L);
-void sha1hex(char *digest, char *script, size_t len);
+void ldbInit(void);
+void ldbDisable(client *c);
+void ldbEnable(client *c);
+void evalGenericCommandWithDebugging(client *c, int evalsha);
+void luaLdbLineHook(lua_State *lua, lua_Debug *ar);
+void ldbLog(sds entry);
+void ldbLogRedisReply(char *reply);
+sds ldbCatStackValue(sds s, lua_State *lua, int idx);
+
+/* Debugger shared state is stored inside this global structure. */
+#define LDB_BREAKPOINTS_MAX 64  /* Max number of breakpoints. */
+#define LDB_MAX_LEN_DEFAULT 256 /* Default len limit for replies / var dumps. */
+struct ldbState {
+    int fd;     /* Socket of the debugging client. */
+    int active; /* Are we debugging EVAL right now? */
+    int forked; /* Is this a fork()ed debugging session? */
+    list *logs; /* List of messages to send to the client. */
+    list *traces; /* Messages about Redis commands executed since last stop.*/
+    list *children; /* All forked debugging sessions pids. */
+    int bp[LDB_BREAKPOINTS_MAX]; /* An array of breakpoints line numbers. */
+    int bpcount; /* Number of valid entries inside bp. */
+    int step;   /* Stop at next line ragardless of breakpoints. */
+    int luabp;  /* Stop at next line because redis.breakpoint() was called. */
+    sds *src;   /* Lua script source code split by line. */
+    int lines;  /* Number of lines in 'src'. */
+    int currentline;    /* Current line number. */
+    sds cbuf;   /* Debugger client command buffer. */
+    size_t maxlen;  /* Max var dump / reply length. */
+    int maxlen_hint_sent; /* Did we already hint about "set maxlen"? */
+} ldb;
+
+/* ---------------------------------------------------------------------------
+ * Utility functions.
+ * ------------------------------------------------------------------------- */
+
+/* Perform the SHA1 of the input string. We use this both for hashing script
+ * bodies in order to obtain the Lua function name, and in the implementation
+ * of redis.sha1().
+ *
+ * 'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an
+ * hexadecimal number, plus 1 byte for null term. */
+void sha1hex(char *digest, char *script, size_t len) {
+    SHA1_CTX ctx;
+    unsigned char hash[20];
+    char *cset = "0123456789abcdef";
+    int j;
+
+    SHA1Init(&ctx);
+    SHA1Update(&ctx,(unsigned char*)script,len);
+    SHA1Final(hash,&ctx);
+
+    for (j = 0; j < 20; j++) {
+        digest[j*2] = cset[((hash[j]&0xF0)>>4)];
+        digest[j*2+1] = cset[(hash[j]&0xF)];
+    }
+    digest[40] = '\0';
+}
+
+/* ---------------------------------------------------------------------------
+ * Redis reply to Lua type conversion functions.
+ * ------------------------------------------------------------------------- */
 
 /* Take a Redis reply in the Redis protocol format and convert it into a
  * Lua type. Thanks to this function, and the introduction of not connected
  * clients, it is trivial to implement the redis() lua function.
  *
  * Basically we take the arguments, execute the Redis command in the context
  * of a non connected client, then take the generated reply and convert it
  * into a suitable Lua type. With this trick the scripting feature does not
- * need the introduction of a full Redis internals API. Basically the script
+ * need the introduction of a full Redis internals API. The script
  * is like a normal client that bypasses all the slow I/O paths.
  *
  * Note: in this function we do not do any sanity check as the reply is
  * generated by Redis directly. This allows us to go faster.
- * The reply string can be altered during the parsing as it is discarded
- * after the conversion is completed.
  *
  * Errors are returned as a table with a single 'err' field set to the
  * error string.
  */
 
 char *redisProtocolToLuaType(lua_State *lua, char* reply) {
     char *p = reply;
 
     switch(*p) {
-    case ':':
-        p = redisProtocolToLuaType_Int(lua,reply);
-        break;
-    case '$':
-        p = redisProtocolToLuaType_Bulk(lua,reply);
-        break;
-    case '+':
-        p = redisProtocolToLuaType_Status(lua,reply);
-        break;
-    case '-':
-        p = redisProtocolToLuaType_Error(lua,reply);
-        break;
-    case '*':
-        p = redisProtocolToLuaType_MultiBulk(lua,reply);
-        break;
+    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;
+    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;
+    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;
+    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;
+    case '*': p = redisProtocolToLuaType_MultiBulk(lua,reply); break;
     }
     return p;
 }
 
 char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {
     char *p = strchr(reply+1,'\r');
@@ -149,15 +197,26 @@
         p = redisProtocolToLuaType(lua,p);
         lua_settable(lua,-3);
     }
     return p;
 }
 
+/* This function is used in order to push an error on the Lua stack in the
+ * format used by redis.pcall to return errors, which is a lua table
+ * with a single "err" field set to the error string. Note that this
+ * table is never a valid reply by proper commands, since the returned
+ * tables are otherwise always indexed by integers, never by strings. */
 void luaPushError(lua_State *lua, char *error) {
     lua_Debug dbg;
 
+    /* If debugging is active and in step mode, log errors resulting from
+     * Redis commands. */
+    if (ldb.active && ldb.step) {
+        ldbLog(sdscatprintf(sdsempty(),"<error> %s",error));
+    }
+
     lua_newtable(lua);
     lua_pushstring(lua,"err");
 
     /* Attempt to figure out where this function was called, if possible */
     if(lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, "nSl", &dbg)) {
         sds msg = sdscatprintf(sdsempty(), "%s: %d: %s",
@@ -167,12 +226,22 @@
     } else {
         lua_pushstring(lua, error);
     }
     lua_settable(lua,-3);
 }
 
+/* In case the error set into the Lua stack by luaPushError() was generated
+ * by the non-error-trapping version of redis.pcall(), which is redis.call(),
+ * this function will raise the Lua error so that the execution of the
+ * script will be halted. */
+int luaRaiseError(lua_State *lua) {
+    lua_pushstring(lua,"err");
+    lua_gettable(lua,-2);
+    return lua_error(lua);
+}
+
 /* Sort the array currently in the stack. We do this to make the output
  * of commands like KEYS or SMEMBERS something deterministic when called
  * from Lua (to play well with AOf/replication).
  *
  * The array is sorted using table.sort itself, and assuming all the
  * list elements are strings. */
@@ -198,18 +267,91 @@
         lua_call(lua,2,0);
     }
     /* Stack: array (sorted), table */
     lua_pop(lua,1);             /* Stack: array (sorted) */
 }
 
+/* ---------------------------------------------------------------------------
+ * Lua reply to Redis reply conversion functions.
+ * ------------------------------------------------------------------------- */
+
+void luaReplyToRedisReply(client *c, lua_State *lua) {
+    int t = lua_type(lua,-1);
+
+    switch(t) {
+    case LUA_TSTRING:
+        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));
+        break;
+    case LUA_TBOOLEAN:
+        addReply(c,lua_toboolean(lua,-1) ? shared.cone : shared.nullbulk);
+        break;
+    case LUA_TNUMBER:
+        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));
+        break;
+    case LUA_TTABLE:
+        /* We need to check if it is an array, an error, or a status reply.
+         * Error are returned as a single element table with 'err' field.
+         * Status replies are returned as single element table with 'ok'
+         * field. */
+        lua_pushstring(lua,"err");
+        lua_gettable(lua,-2);
+        t = lua_type(lua,-1);
+        if (t == LUA_TSTRING) {
+            sds err = sdsnew(lua_tostring(lua,-1));
+            sdsmapchars(err,"\r\n","  ",2);
+            addReplySds(c,sdscatprintf(sdsempty(),"-%s\r\n",err));
+            sdsfree(err);
+            lua_pop(lua,2);
+            return;
+        }
+
+        lua_pop(lua,1);
+        lua_pushstring(lua,"ok");
+        lua_gettable(lua,-2);
+        t = lua_type(lua,-1);
+        if (t == LUA_TSTRING) {
+            sds ok = sdsnew(lua_tostring(lua,-1));
+            sdsmapchars(ok,"\r\n","  ",2);
+            addReplySds(c,sdscatprintf(sdsempty(),"+%s\r\n",ok));
+            sdsfree(ok);
+            lua_pop(lua,1);
+        } else {
+            void *replylen = addDeferredMultiBulkLength(c);
+            int j = 1, mbulklen = 0;
+
+            lua_pop(lua,1); /* Discard the 'ok' field value we popped */
+            while(1) {
+                lua_pushnumber(lua,j++);
+                lua_gettable(lua,-2);
+                t = lua_type(lua,-1);
+                if (t == LUA_TNIL) {
+                    lua_pop(lua,1);
+                    break;
+                }
+                luaReplyToRedisReply(c, lua);
+                mbulklen++;
+            }
+            setDeferredMultiBulkLength(c,replylen,mbulklen);
+        }
+        break;
+    default:
+        addReply(c,shared.nullbulk);
+    }
+    lua_pop(lua,1);
+}
+
+/* ---------------------------------------------------------------------------
+ * Lua redis.* functions implementations.
+ * ------------------------------------------------------------------------- */
+
 #define LUA_CMD_OBJCACHE_SIZE 32
 #define LUA_CMD_OBJCACHE_MAX_LEN 64
 int luaRedisGenericCommand(lua_State *lua, int raise_error) {
     int j, argc = lua_gettop(lua);
     struct redisCommand *cmd;
-    redisClient *c = server.lua_client;
+    client *c = server.lua_client;
     sds reply;
 
     /* Cached across calls. */
     static robj **argv = NULL;
     static int argv_size = 0;
     static robj *cached_objects[LUA_CMD_OBJCACHE_SIZE];
@@ -221,24 +363,24 @@
      * To make this function reentrant is futile and makes it slower, but
      * we should at least detect such a misuse, and abort. */
     if (inuse) {
         char *recursion_warning =
             "luaRedisGenericCommand() recursive call detected. "
             "Are you doing funny stuff with Lua debug hooks?";
-        redisLog(REDIS_WARNING,"%s",recursion_warning);
+        serverLog(LL_WARNING,"%s",recursion_warning);
         luaPushError(lua,recursion_warning);
         return 1;
     }
     inuse++;
 
     /* Require at least one argument */
     if (argc == 0) {
         luaPushError(lua,
             "Please specify at least one argument for redis.call()");
         inuse--;
-        return 1;
+        return raise_error ? luaRaiseError(lua) : 1;
     }
 
     /* Build the arguments vector */
     if (argv_size < argc) {
         argv = zrealloc(argv,sizeof(robj*)*argc);
         argv_size = argc;
@@ -262,20 +404,17 @@
         }
 
         /* Try to use a cached object. */
         if (j < LUA_CMD_OBJCACHE_SIZE && cached_objects[j] &&
             cached_objects_len[j] >= obj_len)
         {
-            char *s = cached_objects[j]->ptr;
-            struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
-
+            sds s = cached_objects[j]->ptr;
             argv[j] = cached_objects[j];
             cached_objects[j] = NULL;
             memcpy(s,obj_s,obj_len+1);
-            sh->free += sh->len - obj_len;
-            sh->len = obj_len;
+            sdssetlen(s, obj_len);
         } else {
             argv[j] = createStringObject(obj_s, obj_len);
         }
     }
 
     /* Check if one of the arguments passed by the Lua script
@@ -287,102 +426,139 @@
             decrRefCount(argv[j]);
             j--;
         }
         luaPushError(lua,
             "Lua redis() command arguments must be strings or integers");
         inuse--;
-        return 1;
+        return raise_error ? luaRaiseError(lua) : 1;
     }
 
     /* Setup our fake client for command execution */
     c->argv = argv;
     c->argc = argc;
 
+    /* Log the command if debugging is active. */
+    if (ldb.active && ldb.step) {
+        sds cmdlog = sdsnew("<redis>");
+        for (j = 0; j < c->argc; j++) {
+            if (j == 10) {
+                cmdlog = sdscatprintf(cmdlog," ... (%d more)",
+                    c->argc-j-1);
+            } else {
+                cmdlog = sdscatlen(cmdlog," ",1);
+                cmdlog = sdscatsds(cmdlog,c->argv[j]->ptr);
+            }
+        }
+        ldbLog(cmdlog);
+    }
+
     /* Command lookup */
     cmd = lookupCommand(argv[0]->ptr);
     if (!cmd || ((cmd->arity > 0 && cmd->arity != argc) ||
                    (argc < -cmd->arity)))
     {
         if (cmd)
             luaPushError(lua,
                 "Wrong number of args calling Redis command From Lua script");
         else
             luaPushError(lua,"Unknown Redis command called from Lua script");
         goto cleanup;
     }
-    c->cmd = cmd;
+    c->cmd = c->lastcmd = cmd;
 
     /* There are commands that are not allowed inside scripts. */
-    if (cmd->flags & REDIS_CMD_NOSCRIPT) {
+    if (cmd->flags & CMD_NOSCRIPT) {
         luaPushError(lua, "This Redis command is not allowed from scripts");
         goto cleanup;
     }
 
     /* Write commands are forbidden against read-only slaves, or if a
      * command marked as non-deterministic was already called in the context
      * of this script. */
-    if (cmd->flags & REDIS_CMD_WRITE) {
-        if (server.lua_random_dirty) {
+    if (cmd->flags & CMD_WRITE) {
+        if (server.lua_random_dirty && !server.lua_replicate_commands) {
             luaPushError(lua,
-                "Write commands not allowed after non deterministic commands");
+                "Write commands not allowed after non deterministic commands. Call redis.replicate_commands() at the start of your script in order to switch to single commands replication mode.");
             goto cleanup;
         } else if (server.masterhost && server.repl_slave_ro &&
                    !server.loading &&
-                   !(server.lua_caller->flags & REDIS_MASTER))
+                   !(server.lua_caller->flags & CLIENT_MASTER))
         {
             luaPushError(lua, shared.roslaveerr->ptr);
             goto cleanup;
         } else if (server.stop_writes_on_bgsave_err &&
                    server.saveparamslen > 0 &&
-                   server.lastbgsave_status == REDIS_ERR)
+                   server.lastbgsave_status == C_ERR)
         {
             luaPushError(lua, shared.bgsaveerr->ptr);
             goto cleanup;
         }
     }
 
     /* If we reached the memory limit configured via maxmemory, commands that
      * could enlarge the memory usage are not allowed, but only if this is the
      * first write in the context of this script, otherwise we can't stop
      * in the middle. */
     if (server.maxmemory && server.lua_write_dirty == 0 &&
-        (cmd->flags & REDIS_CMD_DENYOOM))
+        (cmd->flags & CMD_DENYOOM))
     {
-        if (freeMemoryIfNeeded() == REDIS_ERR) {
+        if (freeMemoryIfNeeded() == C_ERR) {
             luaPushError(lua, shared.oomerr->ptr);
             goto cleanup;
         }
     }
 
-    if (cmd->flags & REDIS_CMD_RANDOM) server.lua_random_dirty = 1;
-    if (cmd->flags & REDIS_CMD_WRITE) server.lua_write_dirty = 1;
+    if (cmd->flags & CMD_RANDOM) server.lua_random_dirty = 1;
+    if (cmd->flags & CMD_WRITE) server.lua_write_dirty = 1;
 
     /* If this is a Redis Cluster node, we need to make sure Lua is not
      * trying to access non-local keys, with the exception of commands
-     * received from our master. */
-    if (server.cluster_enabled && !(server.lua_caller->flags & REDIS_MASTER)) {
+     * received from our master or when loading the AOF back in memory. */
+    if (server.cluster_enabled && !server.loading &&
+        !(server.lua_caller->flags & CLIENT_MASTER))
+    {
         /* Duplicate relevant flags in the lua client. */
-        c->flags &= ~(REDIS_READONLY|REDIS_ASKING);
-        c->flags |= server.lua_caller->flags & (REDIS_READONLY|REDIS_ASKING);
+        c->flags &= ~(CLIENT_READONLY|CLIENT_ASKING);
+        c->flags |= server.lua_caller->flags & (CLIENT_READONLY|CLIENT_ASKING);
         if (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,NULL) !=
                            server.cluster->myself)
         {
             luaPushError(lua,
                 "Lua script attempted to access a non local key in a "
                 "cluster node");
             goto cleanup;
         }
     }
 
+    /* If we are using single commands replication, we need to wrap what
+     * we propagate into a MULTI/EXEC block, so that it will be atomic like
+     * a Lua script in the context of AOF and slaves. */
+    if (server.lua_replicate_commands &&
+        !server.lua_multi_emitted &&
+        server.lua_write_dirty &&
+        server.lua_repl != PROPAGATE_NONE)
+    {
+        execCommandPropagateMulti(server.lua_caller);
+        server.lua_multi_emitted = 1;
+    }
+
     /* Run the command */
-    call(c,REDIS_CALL_SLOWLOG | REDIS_CALL_STATS);
+    int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;
+    if (server.lua_replicate_commands) {
+        /* Set flags according to redis.set_repl() settings. */
+        if (server.lua_repl & PROPAGATE_AOF)
+            call_flags |= CMD_CALL_PROPAGATE_AOF;
+        if (server.lua_repl & PROPAGATE_REPL)
+            call_flags |= CMD_CALL_PROPAGATE_REPL;
+    }
+    call(c,call_flags);
 
     /* Convert the result of the Redis command into a suitable Lua type.
      * The first thing we need is to create a single string from the client
      * output buffers. */
-    if (listLength(c->reply) == 0 && c->bufpos < REDIS_REPLY_CHUNK_BYTES) {
+    if (listLength(c->reply) == 0 && c->bufpos < PROTO_REPLY_CHUNK_BYTES) {
         /* This is a fast path for the common case of a reply inside the
          * client static buffer. Don't create an SDS string but just use
          * the client buffer directly. */
         c->buf[c->bufpos] = '\0';
         reply = c->buf;
         c->bufpos = 0;
@@ -395,15 +571,21 @@
             reply = sdscatlen(reply,o->ptr,sdslen(o->ptr));
             listDelNode(c->reply,listFirst(c->reply));
         }
     }
     if (raise_error && reply[0] != '-') raise_error = 0;
     redisProtocolToLuaType(lua,reply);
+
+    /* If the debugger is active, log the reply from Redis. */
+    if (ldb.active && ldb.step)
+        ldbLogRedisReply(reply);
+
     /* Sort the output array if needed, assuming it is a non-null multi bulk
      * reply as expected. */
-    if ((cmd->flags & REDIS_CMD_SORT_FOR_SCRIPT) &&
+    if ((cmd->flags & CMD_SORT_FOR_SCRIPT) &&
+        (server.lua_replicate_commands == 0) &&
         (reply[0] == '*' && reply[1] != '-')) {
             luaSortArray(lua);
     }
     if (reply != c->buf) sdsfree(reply);
     c->reply_bytes = 0;
 
@@ -415,21 +597,20 @@
 
         /* Try to cache the object in the cached_objects array.
          * The object must be small, SDS-encoded, and with refcount = 1
          * (we must be the only owner) for us to cache it. */
         if (j < LUA_CMD_OBJCACHE_SIZE &&
             o->refcount == 1 &&
-            (o->encoding == REDIS_ENCODING_RAW ||
-             o->encoding == REDIS_ENCODING_EMBSTR) &&
+            (o->encoding == OBJ_ENCODING_RAW ||
+             o->encoding == OBJ_ENCODING_EMBSTR) &&
             sdslen(o->ptr) <= LUA_CMD_OBJCACHE_MAX_LEN)
         {
-            struct sdshdr *sh = (void*)(((char*)(o->ptr))-(sizeof(struct sdshdr)));
-
+            sds s = o->ptr;
             if (cached_objects[j]) decrRefCount(cached_objects[j]);
             cached_objects[j] = o;
-            cached_objects_len[j] = sh->free + sh->len;
+            cached_objects_len[j] = sdsalloc(s);
         } else {
             decrRefCount(o);
         }
     }
 
     if (c->argv != argv) {
@@ -439,25 +620,25 @@
     }
 
     if (raise_error) {
         /* If we are here we should have an error in the stack, in the
          * form of a table with an "err" field. Extract the string to
          * return the plain error. */
-        lua_pushstring(lua,"err");
-        lua_gettable(lua,-2);
         inuse--;
-        return lua_error(lua);
+        return luaRaiseError(lua);
     }
     inuse--;
     return 1;
 }
 
+/* redis.call() */
 int luaRedisCallCommand(lua_State *lua) {
     return luaRedisGenericCommand(lua,1);
 }
 
+/* redis.pcall() */
 int luaRedisPCallCommand(lua_State *lua) {
     return luaRedisGenericCommand(lua,0);
 }
 
 /* This adds redis.sha1hex(string) to Lua scripts using the same hashing
  * function used for sha1ing lua scripts. */
@@ -465,14 +646,14 @@
     int argc = lua_gettop(lua);
     char digest[41];
     size_t len;
     char *s;
 
     if (argc != 1) {
-        luaPushError(lua, "wrong number of arguments");
-        return 1;
+        lua_pushstring(lua, "wrong number of arguments");
+        return lua_error(lua);
     }
 
     s = (char*)lua_tolstring(lua,1,&len);
     sha1hex(digest,s,len);
     lua_pushstring(lua,digest);
     return 1;
@@ -495,36 +676,116 @@
     lua_pushstring(lua, field);
     lua_pushvalue(lua, -3);
     lua_settable(lua, -3);
     return 1;
 }
 
+/* redis.error_reply() */
 int luaRedisErrorReplyCommand(lua_State *lua) {
     return luaRedisReturnSingleFieldTable(lua,"err");
 }
 
+/* redis.status_reply() */
 int luaRedisStatusReplyCommand(lua_State *lua) {
     return luaRedisReturnSingleFieldTable(lua,"ok");
 }
 
+/* redis.replicate_commands()
+ *
+ * Turn on single commands replication if the script never called
+ * a write command so far, and returns true. Otherwise if the script
+ * already started to write, returns false and stick to whole scripts
+ * replication, which is our default. */
+int luaRedisReplicateCommandsCommand(lua_State *lua) {
+    if (server.lua_write_dirty) {
+        lua_pushboolean(lua,0);
+    } else {
+        server.lua_replicate_commands = 1;
+        /* When we switch to single commands replication, we can provide
+         * different math.random() sequences at every call, which is what
+         * the user normally expects. */
+        redisSrand48(rand());
+        lua_pushboolean(lua,1);
+    }
+    return 1;
+}
+
+/* redis.breakpoint()
+ *
+ * Allows to stop execution during a debuggign session from within
+ * the Lua code implementation, like if a breakpoint was set in the code
+ * immediately after the function. */
+int luaRedisBreakpointCommand(lua_State *lua) {
+    if (ldb.active) {
+        ldb.luabp = 1;
+        lua_pushboolean(lua,1);
+    } else {
+        lua_pushboolean(lua,0);
+    }
+    return 1;
+}
+
+/* redis.debug()
+ *
+ * Log a string message into the output console.
+ * Can take multiple arguments that will be separated by commas.
+ * Nothing is returned to the caller. */
+int luaRedisDebugCommand(lua_State *lua) {
+    if (!ldb.active) return 0;
+    int argc = lua_gettop(lua);
+    sds log = sdscatprintf(sdsempty(),"<debug> line %d: ", ldb.currentline);
+    while(argc--) {
+        log = ldbCatStackValue(log,lua,-1 - argc);
+        if (argc != 0) log = sdscatlen(log,", ",2);
+    }
+    ldbLog(log);
+    return 0;
+}
+
+/* redis.set_repl()
+ *
+ * Set the propagation of write commands executed in the context of the
+ * script to on/off for AOF and slaves. */
+int luaRedisSetReplCommand(lua_State *lua) {
+    int argc = lua_gettop(lua);
+    int flags;
+
+    if (server.lua_replicate_commands == 0) {
+        lua_pushstring(lua, "You can set the replication behavior only after turning on single commands replication with redis.replicate_commands().");
+        return lua_error(lua);
+    } else if (argc != 1) {
+        lua_pushstring(lua, "redis.set_repl() requires two arguments.");
+        return lua_error(lua);
+    }
+
+    flags = lua_tonumber(lua,-1);
+    if ((flags & ~(PROPAGATE_AOF|PROPAGATE_REPL)) != 0) {
+        lua_pushstring(lua, "Invalid replication flags. Use REPL_AOF, REPL_SLAVE, REPL_ALL or REPL_NONE.");
+        return lua_error(lua);
+    }
+    server.lua_repl = flags;
+    return 0;
+}
+
+/* redis.log() */
 int luaLogCommand(lua_State *lua) {
     int j, argc = lua_gettop(lua);
     int level;
     sds log;
 
     if (argc < 2) {
-        luaPushError(lua, "redis.log() requires two arguments or more.");
-        return 1;
+        lua_pushstring(lua, "redis.log() requires two arguments or more.");
+        return lua_error(lua);
     } else if (!lua_isnumber(lua,-argc)) {
-        luaPushError(lua, "First argument must be a number (log level).");
-        return 1;
+        lua_pushstring(lua, "First argument must be a number (log level).");
+        return lua_error(lua);
     }
     level = lua_tonumber(lua,-argc);
-    if (level < REDIS_DEBUG || level > REDIS_WARNING) {
-        luaPushError(lua, "Invalid debug level.");
-        return 1;
+    if (level < LL_DEBUG || level > LL_WARNING) {
+        lua_pushstring(lua, "Invalid debug level.");
+        return lua_error(lua);
     }
 
     /* Glue together all the arguments */
     log = sdsempty();
     for (j = 1; j < argc; j++) {
         size_t len;
@@ -533,40 +794,20 @@
         s = (char*)lua_tolstring(lua,(-argc)+j,&len);
         if (s) {
             if (j != 1) log = sdscatlen(log," ",1);
             log = sdscatlen(log,s,len);
         }
     }
-    redisLogRaw(level,log);
+    serverLogRaw(level,log);
     sdsfree(log);
     return 0;
 }
 
-void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
-    long long elapsed;
-    REDIS_NOTUSED(ar);
-    REDIS_NOTUSED(lua);
-
-    elapsed = mstime() - server.lua_time_start;
-    if (elapsed >= server.lua_time_limit && server.lua_timedout == 0) {
-        redisLog(REDIS_WARNING,"Lua slow script detected: still in execution after %lld milliseconds. You can try killing the script using the SCRIPT KILL command.",elapsed);
-        server.lua_timedout = 1;
-        /* Once the script timeouts we reenter the event loop to permit others
-         * to call SCRIPT KILL or SHUTDOWN NOSAVE if needed. For this reason
-         * we need to mask the client executing the script from the event loop.
-         * If we don't do that the client may disconnect and could no longer be
-         * here when the EVAL command will return. */
-         aeDeleteFileEvent(server.el, server.lua_caller->fd, AE_READABLE);
-    }
-    if (server.lua_timedout) processEventsWhileBlocked();
-    if (server.lua_kill) {
-        redisLog(REDIS_WARNING,"Lua script killed by user with SCRIPT KILL.");
-        lua_pushstring(lua,"Script killed by user with SCRIPT KILL...");
-        lua_error(lua);
-    }
-}
+/* ---------------------------------------------------------------------------
+ * Lua engine initialization and reset.
+ * ------------------------------------------------------------------------- */
 
 void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {
   lua_pushcfunction(lua, luafunc);
   lua_pushstring(lua, libname);
   lua_call(lua, 1, 0);
 }
@@ -637,18 +878,33 @@
     luaL_loadbuffer(lua,code,sdslen(code),"@enable_strict_lua");
     lua_pcall(lua,0,0,0);
     sdsfree(code);
 }
 
 /* Initialize the scripting environment.
- * It is possible to call this function to reset the scripting environment
- * assuming that we call scriptingRelease() before.
- * See scriptingReset() for more information. */
-void scriptingInit(void) {
+ *
+ * This function is called the first time at server startup with
+ * the 'setup' argument set to 1.
+ *
+ * It can be called again multiple times during the lifetime of the Redis
+ * process, with 'setup' set to 0, and following a scriptingRelease() call,
+ * in order to reset the Lua scripting environment.
+ *
+ * However it is simpler to just call scriptingReset() that does just that. */
+void scriptingInit(int setup) {
     lua_State *lua = lua_open();
 
+    if (setup) {
+        server.lua_client = NULL;
+        server.lua_caller = NULL;
+        server.lua_timedout = 0;
+        server.lua_always_replicate_commands = 0; /* Only DEBUG can change it.*/
+        server.lua_time_limit = LUA_SCRIPT_TIME_LIMIT;
+        ldbInit();
+    }
+
     luaLoadLibraries(lua);
     luaRemoveUnsupportedFunctions(lua);
 
     /* Initialize a dictionary we use to map SHAs to scripts.
      * This is useful for replication, as we need to replicate EVALSHA
      * as EVAL, so we need to remember the associated script. */
@@ -670,25 +926,25 @@
     /* redis.log and log levels. */
     lua_pushstring(lua,"log");
     lua_pushcfunction(lua,luaLogCommand);
     lua_settable(lua,-3);
 
     lua_pushstring(lua,"LOG_DEBUG");
-    lua_pushnumber(lua,REDIS_DEBUG);
+    lua_pushnumber(lua,LL_DEBUG);
     lua_settable(lua,-3);
 
     lua_pushstring(lua,"LOG_VERBOSE");
-    lua_pushnumber(lua,REDIS_VERBOSE);
+    lua_pushnumber(lua,LL_VERBOSE);
     lua_settable(lua,-3);
 
     lua_pushstring(lua,"LOG_NOTICE");
-    lua_pushnumber(lua,REDIS_NOTICE);
+    lua_pushnumber(lua,LL_NOTICE);
     lua_settable(lua,-3);
 
     lua_pushstring(lua,"LOG_WARNING");
-    lua_pushnumber(lua,REDIS_WARNING);
+    lua_pushnumber(lua,LL_WARNING);
     lua_settable(lua,-3);
 
     /* redis.sha1hex */
     lua_pushstring(lua, "sha1hex");
     lua_pushcfunction(lua, luaRedisSha1hexCommand);
     lua_settable(lua, -3);
@@ -698,12 +954,48 @@
     lua_pushcfunction(lua, luaRedisErrorReplyCommand);
     lua_settable(lua, -3);
     lua_pushstring(lua, "status_reply");
     lua_pushcfunction(lua, luaRedisStatusReplyCommand);
     lua_settable(lua, -3);
 
+    /* redis.replicate_commands */
+    lua_pushstring(lua, "replicate_commands");
+    lua_pushcfunction(lua, luaRedisReplicateCommandsCommand);
+    lua_settable(lua, -3);
+
+    /* redis.set_repl and associated flags. */
+    lua_pushstring(lua,"set_repl");
+    lua_pushcfunction(lua,luaRedisSetReplCommand);
+    lua_settable(lua,-3);
+
+    lua_pushstring(lua,"REPL_NONE");
+    lua_pushnumber(lua,PROPAGATE_NONE);
+    lua_settable(lua,-3);
+
+    lua_pushstring(lua,"REPL_AOF");
+    lua_pushnumber(lua,PROPAGATE_AOF);
+    lua_settable(lua,-3);
+
+    lua_pushstring(lua,"REPL_SLAVE");
+    lua_pushnumber(lua,PROPAGATE_REPL);
+    lua_settable(lua,-3);
+
+    lua_pushstring(lua,"REPL_ALL");
+    lua_pushnumber(lua,PROPAGATE_AOF|PROPAGATE_REPL);
+    lua_settable(lua,-3);
+
+    /* redis.breakpoint */
+    lua_pushstring(lua,"breakpoint");
+    lua_pushcfunction(lua,luaRedisBreakpointCommand);
+    lua_settable(lua,-3);
+
+    /* redis.debug */
+    lua_pushstring(lua,"debug");
+    lua_pushcfunction(lua,luaRedisDebugCommand);
+    lua_settable(lua,-3);
+
     /* Finally set the table as 'redis' global var. */
     lua_setglobal(lua,"redis");
 
     /* Replace math.random and math.randomseed with our implementations. */
     lua_getglobal(lua,"math");
 
@@ -753,13 +1045,13 @@
     /* Create the (non connected) client that we use to execute Redis commands
      * inside the Lua interpreter.
      * Note: there is no need to create it again when this function is called
      * by scriptingReset(). */
     if (server.lua_client == NULL) {
         server.lua_client = createClient(-1);
-        server.lua_client->flags |= REDIS_LUA_CLIENT;
+        server.lua_client->flags |= CLIENT_LUA;
     }
 
     /* Lua beginners often don't use "local", this is likely to introduce
      * subtle bugs in their code. To prevent problems we protect accesses
      * to global variables. */
     scriptingEnableGlobalsProtection(lua);
@@ -773,125 +1065,85 @@
     dictRelease(server.lua_scripts);
     lua_close(server.lua);
 }
 
 void scriptingReset(void) {
     scriptingRelease();
-    scriptingInit();
+    scriptingInit(0);
 }
 
-/* Perform the SHA1 of the input string. We use this both for hashing script
- * bodies in order to obtain the Lua function name, and in the implementation
- * of redis.sha1().
- *
- * 'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an
- * hexadecimal number, plus 1 byte for null term. */
-void sha1hex(char *digest, char *script, size_t len) {
-    SHA1_CTX ctx;
-    unsigned char hash[20];
-    char *cset = "0123456789abcdef";
+/* Set an array of Redis String Objects as a Lua array (table) stored into a
+ * global variable. */
+void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {
     int j;
 
-    SHA1Init(&ctx);
-    SHA1Update(&ctx,(unsigned char*)script,len);
-    SHA1Final(hash,&ctx);
-
-    for (j = 0; j < 20; j++) {
-        digest[j*2] = cset[((hash[j]&0xF0)>>4)];
-        digest[j*2+1] = cset[(hash[j]&0xF)];
+    lua_newtable(lua);
+    for (j = 0; j < elec; j++) {
+        lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));
+        lua_rawseti(lua,-2,j+1);
     }
-    digest[40] = '\0';
+    lua_setglobal(lua,var);
 }
 
-void luaReplyToRedisReply(redisClient *c, lua_State *lua) {
-    int t = lua_type(lua,-1);
+/* ---------------------------------------------------------------------------
+ * Redis provided math.random
+ * ------------------------------------------------------------------------- */
 
-    switch(t) {
-    case LUA_TSTRING:
-        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));
-        break;
-    case LUA_TBOOLEAN:
-        addReply(c,lua_toboolean(lua,-1) ? shared.cone : shared.nullbulk);
-        break;
-    case LUA_TNUMBER:
-        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));
-        break;
-    case LUA_TTABLE:
-        /* We need to check if it is an array, an error, or a status reply.
-         * Error are returned as a single element table with 'err' field.
-         * Status replies are returned as single element table with 'ok' field */
-        lua_pushstring(lua,"err");
-        lua_gettable(lua,-2);
-        t = lua_type(lua,-1);
-        if (t == LUA_TSTRING) {
-            sds err = sdsnew(lua_tostring(lua,-1));
-            sdsmapchars(err,"\r\n","  ",2);
-            addReplySds(c,sdscatprintf(sdsempty(),"-%s\r\n",err));
-            sdsfree(err);
-            lua_pop(lua,2);
-            return;
-        }
-
-        lua_pop(lua,1);
-        lua_pushstring(lua,"ok");
-        lua_gettable(lua,-2);
-        t = lua_type(lua,-1);
-        if (t == LUA_TSTRING) {
-            sds ok = sdsnew(lua_tostring(lua,-1));
-            sdsmapchars(ok,"\r\n","  ",2);
-            addReplySds(c,sdscatprintf(sdsempty(),"+%s\r\n",ok));
-            sdsfree(ok);
-            lua_pop(lua,1);
-        } else {
-            void *replylen = addDeferredMultiBulkLength(c);
-            int j = 1, mbulklen = 0;
+/* We replace math.random() with our implementation that is not affected
+ * by specific libc random() implementations and will output the same sequence
+ * (for the same seed) in every arch. */
 
-            lua_pop(lua,1); /* Discard the 'ok' field value we popped */
-            while(1) {
-                lua_pushnumber(lua,j++);
-                lua_gettable(lua,-2);
-                t = lua_type(lua,-1);
-                if (t == LUA_TNIL) {
-                    lua_pop(lua,1);
-                    break;
-                }
-                luaReplyToRedisReply(c, lua);
-                mbulklen++;
-            }
-            setDeferredMultiBulkLength(c,replylen,mbulklen);
-        }
-        break;
-    default:
-        addReply(c,shared.nullbulk);
+/* The following implementation is the one shipped with Lua itself but with
+ * rand() replaced by redisLrand48(). */
+int redis_math_random (lua_State *L) {
+  /* the `%' avoids the (rare) case of r==1, and is needed also because on
+     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
+  lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /
+                                (lua_Number)REDIS_LRAND48_MAX;
+  switch (lua_gettop(L)) {  /* check number of arguments */
+    case 0: {  /* no arguments */
+      lua_pushnumber(L, r);  /* Number between 0 and 1 */
+      break;
     }
-    lua_pop(lua,1);
+    case 1: {  /* only upper limit */
+      int u = luaL_checkint(L, 1);
+      luaL_argcheck(L, 1<=u, 1, "interval is empty");
+      lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */
+      break;
+    }
+    case 2: {  /* lower and upper limits */
+      int l = luaL_checkint(L, 1);
+      int u = luaL_checkint(L, 2);
+      luaL_argcheck(L, l<=u, 2, "interval is empty");
+      lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
+      break;
+    }
+    default: return luaL_error(L, "wrong number of arguments");
+  }
+  return 1;
 }
 
-/* Set an array of Redis String Objects as a Lua array (table) stored into a
- * global variable. */
-void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {
-    int j;
-
-    lua_newtable(lua);
-    for (j = 0; j < elec; j++) {
-        lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));
-        lua_rawseti(lua,-2,j+1);
-    }
-    lua_setglobal(lua,var);
+int redis_math_randomseed (lua_State *L) {
+  redisSrand48(luaL_checkint(L, 1));
+  return 0;
 }
 
+/* ---------------------------------------------------------------------------
+ * EVAL and SCRIPT commands implementation
+ * ------------------------------------------------------------------------- */
+
 /* Define a lua function with the specified function name and body.
- * The function name musts be a 2 characters long string, since all the
+ * The function name musts be a 42 characters long string, since all the
  * functions we defined in the Lua context are in the form:
  *
  *   f_<hex sha1 sum>
  *
- * On success REDIS_OK is returned, and nothing is left on the Lua stack.
- * On error REDIS_ERR is returned and an appropriate error is set in the
+ * On success C_OK is returned, and nothing is left on the Lua stack.
+ * On error C_ERR is returned and an appropriate error is set in the
  * client context. */
-int luaCreateFunction(redisClient *c, lua_State *lua, char *funcname, robj *body) {
+int luaCreateFunction(client *c, lua_State *lua, char *funcname, robj *body) {
     sds funcdef = sdsempty();
 
     funcdef = sdscat(funcdef,"function ");
     funcdef = sdscatlen(funcdef,funcname,42);
     funcdef = sdscatlen(funcdef,"() ",3);
     funcdef = sdscatlen(funcdef,body->ptr,sdslen(body->ptr));
@@ -899,57 +1151,85 @@
 
     if (luaL_loadbuffer(lua,funcdef,sdslen(funcdef),"@user_script")) {
         addReplyErrorFormat(c,"Error compiling script (new function): %s\n",
             lua_tostring(lua,-1));
         lua_pop(lua,1);
         sdsfree(funcdef);
-        return REDIS_ERR;
+        return C_ERR;
     }
     sdsfree(funcdef);
     if (lua_pcall(lua,0,0,0)) {
         addReplyErrorFormat(c,"Error running script (new function): %s\n",
             lua_tostring(lua,-1));
         lua_pop(lua,1);
-        return REDIS_ERR;
+        return C_ERR;
     }
 
     /* We also save a SHA1 -> Original script map in a dictionary
      * so that we can replicate / write in the AOF all the
      * EVALSHA commands as EVAL using the original script. */
     {
         int retval = dictAdd(server.lua_scripts,
                              sdsnewlen(funcname+2,40),body);
-        redisAssertWithInfo(c,NULL,retval == DICT_OK);
+        serverAssertWithInfo(c,NULL,retval == DICT_OK);
         incrRefCount(body);
     }
-    return REDIS_OK;
+    return C_OK;
 }
 
-void evalGenericCommand(redisClient *c, int evalsha) {
+/* This is the Lua script "count" hook that we use to detect scripts timeout. */
+void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
+    long long elapsed;
+    UNUSED(ar);
+    UNUSED(lua);
+
+    elapsed = mstime() - server.lua_time_start;
+    if (elapsed >= server.lua_time_limit && server.lua_timedout == 0) {
+        serverLog(LL_WARNING,"Lua slow script detected: still in execution after %lld milliseconds. You can try killing the script using the SCRIPT KILL command.",elapsed);
+        server.lua_timedout = 1;
+        /* Once the script timeouts we reenter the event loop to permit others
+         * to call SCRIPT KILL or SHUTDOWN NOSAVE if needed. For this reason
+         * we need to mask the client executing the script from the event loop.
+         * If we don't do that the client may disconnect and could no longer be
+         * here when the EVAL command will return. */
+         aeDeleteFileEvent(server.el, server.lua_caller->fd, AE_READABLE);
+    }
+    if (server.lua_timedout) processEventsWhileBlocked();
+    if (server.lua_kill) {
+        serverLog(LL_WARNING,"Lua script killed by user with SCRIPT KILL.");
+        lua_pushstring(lua,"Script killed by user with SCRIPT KILL...");
+        lua_error(lua);
+    }
+}
+
+void evalGenericCommand(client *c, int evalsha) {
     lua_State *lua = server.lua;
     char funcname[43];
     long long numkeys;
     int delhook = 0, err;
 
-    /* We want the same PRNG sequence at every call so that our PRNG is
-     * not affected by external state. */
+    /* When we replicate whole scripts, we want the same PRNG sequence at
+     * every call so that our PRNG is not affected by external state. */
     redisSrand48(0);
 
     /* We set this flag to zero to remember that so far no random command
      * was called. This way we can allow the user to call commands like
      * SRANDMEMBER or RANDOMKEY from Lua scripts as far as no write command
      * is called (otherwise the replication and AOF would end with non
      * deterministic sequences).
      *
      * Thanks to this flag we'll raise an error every time a write command
      * is called after a random command was used. */
     server.lua_random_dirty = 0;
     server.lua_write_dirty = 0;
+    server.lua_replicate_commands = server.lua_always_replicate_commands;
+    server.lua_multi_emitted = 0;
+    server.lua_repl = PROPAGATE_AOF|PROPAGATE_REPL;
 
     /* Get the number of arguments that are keys */
-    if (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != REDIS_OK)
+    if (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != C_OK)
         return;
     if (numkeys > (c->argc - 3)) {
         addReplyError(c,"Number of keys can't be greater than number of args");
         return;
     } else if (numkeys < 0) {
         addReplyError(c,"Number of keys can't be negative");
@@ -989,21 +1269,21 @@
          * return an error. */
         if (evalsha) {
             lua_pop(lua,1); /* remove the error handler from the stack. */
             addReply(c, shared.noscripterr);
             return;
         }
-        if (luaCreateFunction(c,lua,funcname,c->argv[1]) == REDIS_ERR) {
+        if (luaCreateFunction(c,lua,funcname,c->argv[1]) == C_ERR) {
             lua_pop(lua,1); /* remove the error handler from the stack. */
             /* The error is sent to the client by luaCreateFunction()
-             * itself when it returns REDIS_ERR. */
+             * itself when it returns C_ERR. */
             return;
         }
         /* Now the following is guaranteed to return non nil */
         lua_getglobal(lua, funcname);
-        redisAssert(!lua_isnil(lua,-1));
+        serverAssert(!lua_isnil(lua,-1));
     }
 
     /* Populate the argv and keys table accordingly to the arguments that
      * EVAL received. */
     luaSetGlobalArray(lua,"KEYS",c->argv+3,numkeys);
     luaSetGlobalArray(lua,"ARGV",c->argv+3+numkeys,c->argc-3-numkeys);
@@ -1011,28 +1291,36 @@
     /* Select the right DB in the context of the Lua client */
     selectDb(server.lua_client,c->db->id);
 
     /* Set a hook in order to be able to stop the script execution if it
      * is running for too much time.
      * We set the hook only if the time limit is enabled as the hook will
-     * make the Lua script execution slower. */
+     * make the Lua script execution slower.
+     *
+     * If we are debugging, we set instead a "line" hook so that the
+     * debugger is call-back at every line executed by the script. */
     server.lua_caller = c;
     server.lua_time_start = mstime();
     server.lua_kill = 0;
-    if (server.lua_time_limit > 0 && server.masterhost == NULL) {
+    if (server.lua_time_limit > 0 && server.masterhost == NULL &&
+        ldb.active == 0)
+    {
         lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);
         delhook = 1;
+    } else if (ldb.active) {
+        lua_sethook(server.lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);
+        delhook = 1;
     }
 
     /* At this point whether this script was never seen before or if it was
      * already defined, we can call it. We have zero arguments and expect
      * a single return value. */
     err = lua_pcall(lua,0,1,-2);
 
     /* Perform some cleanup that we need to do both on error and success. */
-    if (delhook) lua_sethook(lua,luaMaskCountHook,0,0); /* Disable hook */
+    if (delhook) lua_sethook(lua,NULL,0,0); /* Disable hook */
     if (server.lua_timedout) {
         server.lua_timedout = 0;
         /* Restore the readable handler that was unregistered when the
          * script timeout was detected. */
         aeCreateFileEvent(server.el,c->fd,AE_READABLE,
                           readQueryFromClient,c);
@@ -1064,99 +1352,77 @@
         /* On success convert the Lua return value into Redis protocol, and
          * send it to * the client. */
         luaReplyToRedisReply(c,lua); /* Convert and consume the reply. */
         lua_pop(lua,1); /* Remove the error handler. */
     }
 
+    /* If we are using single commands replication, emit EXEC if there
+     * was at least a write. */
+    if (server.lua_replicate_commands) {
+        preventCommandPropagation(c);
+        if (server.lua_multi_emitted) {
+            robj *propargv[1];
+            propargv[0] = createStringObject("EXEC",4);
+            alsoPropagate(server.execCommand,c->db->id,propargv,1,
+                PROPAGATE_AOF|PROPAGATE_REPL);
+            decrRefCount(propargv[0]);
+        }
+    }
+
     /* EVALSHA should be propagated to Slave and AOF file as full EVAL, unless
      * we are sure that the script was already in the context of all the
      * attached slaves *and* the current AOF file if enabled.
      *
      * To do so we use a cache of SHA1s of scripts that we already propagated
      * as full EVAL, that's called the Replication Script Cache.
      *
      * For repliation, everytime a new slave attaches to the master, we need to
      * flush our cache of scripts that can be replicated as EVALSHA, while
      * for AOF we need to do so every time we rewrite the AOF file. */
-    if (evalsha) {
+    if (evalsha && !server.lua_replicate_commands) {
         if (!replicationScriptCacheExists(c->argv[1]->ptr)) {
             /* This script is not in our script cache, replicate it as
              * EVAL, then add it into the script cache, as from now on
              * slaves and AOF know about it. */
             robj *script = dictFetchValue(server.lua_scripts,c->argv[1]->ptr);
 
             replicationScriptCacheAdd(c->argv[1]->ptr);
-            redisAssertWithInfo(c,NULL,script != NULL);
+            serverAssertWithInfo(c,NULL,script != NULL);
             rewriteClientCommandArgument(c,0,
                 resetRefCount(createStringObject("EVAL",4)));
             rewriteClientCommandArgument(c,1,script);
-            forceCommandPropagation(c,REDIS_PROPAGATE_REPL|REDIS_PROPAGATE_AOF);
+            forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);
         }
     }
 }
 
-void evalCommand(redisClient *c) {
-    evalGenericCommand(c,0);
+void evalCommand(client *c) {
+    if (!(c->flags & CLIENT_LUA_DEBUG))
+        evalGenericCommand(c,0);
+    else
+        evalGenericCommandWithDebugging(c,0);
 }
 
-void evalShaCommand(redisClient *c) {
+void evalShaCommand(client *c) {
     if (sdslen(c->argv[1]->ptr) != 40) {
         /* We know that a match is not possible if the provided SHA is
          * not the right length. So we return an error ASAP, this way
          * evalGenericCommand() can be implemented without string length
          * sanity check */
         addReply(c, shared.noscripterr);
         return;
     }
-    evalGenericCommand(c,1);
-}
-
-/* We replace math.random() with our implementation that is not affected
- * by specific libc random() implementations and will output the same sequence
- * (for the same seed) in every arch. */
-
-/* The following implementation is the one shipped with Lua itself but with
- * rand() replaced by redisLrand48(). */
-int redis_math_random (lua_State *L) {
-  /* the `%' avoids the (rare) case of r==1, and is needed also because on
-     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
-  lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /
-                                (lua_Number)REDIS_LRAND48_MAX;
-  switch (lua_gettop(L)) {  /* check number of arguments */
-    case 0: {  /* no arguments */
-      lua_pushnumber(L, r);  /* Number between 0 and 1 */
-      break;
-    }
-    case 1: {  /* only upper limit */
-      int u = luaL_checkint(L, 1);
-      luaL_argcheck(L, 1<=u, 1, "interval is empty");
-      lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */
-      break;
-    }
-    case 2: {  /* lower and upper limits */
-      int l = luaL_checkint(L, 1);
-      int u = luaL_checkint(L, 2);
-      luaL_argcheck(L, l<=u, 2, "interval is empty");
-      lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
-      break;
+    if (!(c->flags & CLIENT_LUA_DEBUG))
+        evalGenericCommand(c,1);
+    else {
+        addReplyError(c,"Please use EVAL instead of EVALSHA for debugging");
+        return;
     }
-    default: return luaL_error(L, "wrong number of arguments");
-  }
-  return 1;
-}
-
-int redis_math_randomseed (lua_State *L) {
-  redisSrand48(luaL_checkint(L, 1));
-  return 0;
 }
 
-/* ---------------------------------------------------------------------------
- * SCRIPT command for script environment introspection and control
- * ------------------------------------------------------------------------- */
-
-void scriptCommand(redisClient *c) {
+void scriptCommand(client *c) {
     if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"flush")) {
         scriptingReset();
         addReply(c,shared.ok);
         replicationScriptCacheFlush();
         server.dirty++; /* Propagating this command is a good idea. */
     } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,"exists")) {
@@ -1176,27 +1442,946 @@
         funcname[0] = 'f';
         funcname[1] = '_';
         sha1hex(funcname+2,c->argv[2]->ptr,sdslen(c->argv[2]->ptr));
         sha = sdsnewlen(funcname+2,40);
         if (dictFind(server.lua_scripts,sha) == NULL) {
             if (luaCreateFunction(c,server.lua,funcname,c->argv[2])
-                    == REDIS_ERR) {
+                    == C_ERR) {
                 sdsfree(sha);
                 return;
             }
         }
         addReplyBulkCBuffer(c,funcname+2,40);
         sdsfree(sha);
-        forceCommandPropagation(c,REDIS_PROPAGATE_REPL|REDIS_PROPAGATE_AOF);
+        forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);
     } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"kill")) {
         if (server.lua_caller == NULL) {
             addReplySds(c,sdsnew("-NOTBUSY No scripts in execution right now.\r\n"));
         } else if (server.lua_write_dirty) {
             addReplySds(c,sdsnew("-UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN NOSAVE command.\r\n"));
         } else {
             server.lua_kill = 1;
             addReply(c,shared.ok);
         }
+    } else if (c->argc == 3 && !strcasecmp(c->argv[1]->ptr,"debug")) {
+        if (clientHasPendingReplies(c)) {
+            addReplyError(c,"SCRIPT DEBUG must be called outside a pipeline");
+            return;
+        }
+        if (!strcasecmp(c->argv[2]->ptr,"no")) {
+            ldbDisable(c);
+            addReply(c,shared.ok);
+        } else if (!strcasecmp(c->argv[2]->ptr,"yes")) {
+            ldbEnable(c);
+            addReply(c,shared.ok);
+        } else if (!strcasecmp(c->argv[2]->ptr,"sync")) {
+            ldbEnable(c);
+            addReply(c,shared.ok);
+            c->flags |= CLIENT_LUA_DEBUG_SYNC;
+        } else {
+            addReplyError(c,"Use SCRIPT DEBUG yes/sync/no");
+        }
     } else {
         addReplyError(c, "Unknown SCRIPT subcommand or wrong # of args.");
     }
 }
+
+/* ---------------------------------------------------------------------------
+ * LDB: Redis Lua debugging facilities
+ * ------------------------------------------------------------------------- */
+
+/* Initialize Lua debugger data structures. */
+void ldbInit(void) {
+    ldb.fd = -1;
+    ldb.active = 0;
+    ldb.logs = listCreate();
+    listSetFreeMethod(ldb.logs,(void (*)(void*))sdsfree);
+    ldb.children = listCreate();
+    ldb.src = NULL;
+    ldb.lines = 0;
+    ldb.cbuf = sdsempty();
+}
+
+/* Remove all the pending messages in the specified list. */
+void ldbFlushLog(list *log) {
+    listNode *ln;
+
+    while((ln = listFirst(log)) != NULL)
+        listDelNode(log,ln);
+}
+
+/* Enable debug mode of Lua scripts for this client. */
+void ldbEnable(client *c) {
+    c->flags |= CLIENT_LUA_DEBUG;
+    ldbFlushLog(ldb.logs);
+    ldb.fd = c->fd;
+    ldb.step = 1;
+    ldb.bpcount = 0;
+    ldb.luabp = 0;
+    sdsfree(ldb.cbuf);
+    ldb.cbuf = sdsempty();
+    ldb.maxlen = LDB_MAX_LEN_DEFAULT;
+    ldb.maxlen_hint_sent = 0;
+}
+
+/* Exit debugging mode from the POV of client. This function is not enough
+ * to properly shut down a client debugging session, see ldbEndSession()
+ * for more information. */
+void ldbDisable(client *c) {
+    c->flags &= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);
+}
+
+/* Append a log entry to the specified LDB log. */
+void ldbLog(sds entry) {
+    listAddNodeTail(ldb.logs,entry);
+}
+
+/* A version of ldbLog() which prevents producing logs greater than
+ * ldb.maxlen. The first time the limit is reached an hint is generated
+ * to inform the user that reply trimming can be disabled using the
+ * debugger "maxlen" command. */
+void ldbLogWithMaxLen(sds entry) {
+    int trimmed = 0;
+    if (ldb.maxlen && sdslen(entry) > ldb.maxlen) {
+        sdsrange(entry,0,ldb.maxlen-1);
+        entry = sdscatlen(entry," ...",4);
+        trimmed = 1;
+    }
+    ldbLog(entry);
+    if (trimmed && ldb.maxlen_hint_sent == 0) {
+        ldb.maxlen_hint_sent = 1;
+        ldbLog(sdsnew(
+        "<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming."));
+    }
+}
+
+/* Send ldb.logs to the debugging client as a multi-bulk reply
+ * consisting of simple strings. Log entries which include newlines have them
+ * replaced with spaces. The entries sent are also consumed. */
+void ldbSendLogs(void) {
+    sds proto = sdsempty();
+    proto = sdscatfmt(proto,"*%i\r\n", (int)listLength(ldb.logs));
+    while(listLength(ldb.logs)) {
+        listNode *ln = listFirst(ldb.logs);
+        proto = sdscatlen(proto,"+",1);
+        sdsmapchars(ln->value,"\r\n","  ",2);
+        proto = sdscatsds(proto,ln->value);
+        proto = sdscatlen(proto,"\r\n",2);
+        listDelNode(ldb.logs,ln);
+    }
+    if (write(ldb.fd,proto,sdslen(proto)) == -1) {
+        /* Avoid warning. We don't check the return value of write()
+         * since the next read() will catch the I/O error and will
+         * close the debugging session. */
+    }
+    sdsfree(proto);
+}
+
+/* Start a debugging session before calling EVAL implementation.
+ * The techique we use is to capture the client socket file descriptor,
+ * in order to perform direct I/O with it from within Lua hooks. This
+ * way we don't have to re-enter Redis in order to handle I/O.
+ *
+ * The function returns 1 if the caller should proceed to call EVAL,
+ * and 0 if instead the caller should abort the operation (this happens
+ * for the parent in a forked session, since it's up to the children
+ * to continue, or when fork returned an error).
+ *
+ * The caller should call ldbEndSession() only if ldbStartSession()
+ * returned 1. */
+int ldbStartSession(client *c) {
+    ldb.forked = (c->flags & CLIENT_LUA_DEBUG_SYNC) == 0;
+    if (ldb.forked) {
+        pid_t cp = fork();
+        if (cp == -1) {
+            addReplyError(c,"Fork() failed: can't run EVAL in debugging mode.");
+            return 0;
+        } else if (cp == 0) {
+            /* Child. Let's ignore important signals handled by the parent. */
+            struct sigaction act;
+            sigemptyset(&act.sa_mask);
+            act.sa_flags = 0;
+            act.sa_handler = SIG_IGN;
+            sigaction(SIGTERM, &act, NULL);
+            sigaction(SIGINT, &act, NULL);
+
+            /* Log the creation of the child and close the listening
+             * socket to make sure if the parent crashes a reset is sent
+             * to the clients. */
+            serverLog(LL_WARNING,"Redis forked for debugging eval");
+            closeListeningSockets(0);
+        } else {
+            /* Parent */
+            listAddNodeTail(ldb.children,(void*)(unsigned long)cp);
+            freeClientAsync(c); /* Close the client in the parent side. */
+            return 0;
+        }
+    } else {
+        serverLog(LL_WARNING,
+            "Redis synchronous debugging eval session started");
+    }
+
+    /* Setup our debugging session. */
+    anetBlock(NULL,ldb.fd);
+    anetSendTimeout(NULL,ldb.fd,5000);
+    ldb.active = 1;
+
+    /* First argument of EVAL is the script itself. We split it into different
+     * lines since this is the way the debugger accesses the source code. */
+    sds srcstring = sdsdup(c->argv[1]->ptr);
+    size_t srclen = sdslen(srcstring);
+    while(srclen && (srcstring[srclen-1] == '\n' ||
+                     srcstring[srclen-1] == '\r'))
+    {
+        srcstring[--srclen] = '\0';
+    }
+    sdssetlen(srcstring,srclen);
+    ldb.src = sdssplitlen(srcstring,sdslen(srcstring),"\n",1,&ldb.lines);
+    sdsfree(srcstring);
+    return 1;
+}
+
+/* End a debugging session after the EVAL call with debugging enabled
+ * returned. */
+void ldbEndSession(client *c) {
+    /* Emit the remaining logs and an <endsession> mark. */
+    ldbLog(sdsnew("<endsession>"));
+    ldbSendLogs();
+
+    /* If it's a fork()ed session, we just exit. */
+    if (ldb.forked) {
+        writeToClient(c->fd, c, 0);
+        serverLog(LL_WARNING,"Lua debugging session child exiting");
+        exitFromChild(0);
+    } else {
+        serverLog(LL_WARNING,
+            "Redis synchronous debugging eval session ended");
+    }
+
+    /* Otherwise let's restore client's state. */
+    anetNonBlock(NULL,ldb.fd);
+    anetSendTimeout(NULL,ldb.fd,0);
+
+    /* Close the client connectin after sending the final EVAL reply
+     * in order to signal the end of the debugging session. */
+    c->flags |= CLIENT_CLOSE_AFTER_REPLY;
+
+    /* Cleanup. */
+    sdsfreesplitres(ldb.src,ldb.lines);
+    ldb.lines = 0;
+    ldb.active = 0;
+}
+
+/* If the specified pid is among the list of children spawned for
+ * forked debugging sessions, it is removed from the children list.
+ * If the pid was found non-zero is returned. */
+int ldbRemoveChild(pid_t pid) {
+    listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);
+    if (ln) {
+        listDelNode(ldb.children,ln);
+        return 1;
+    }
+    return 0;
+}
+
+/* Return the number of children we still did not received termination
+ * acknowledge via wait() in the parent process. */
+int ldbPendingChildren(void) {
+    return listLength(ldb.children);
+}
+
+/* Kill all the forked sessions. */
+void ldbKillForkedSessions(void) {
+    listIter li;
+    listNode *ln;
+
+    listRewind(ldb.children,&li);
+    while((ln = listNext(&li))) {
+        pid_t pid = (unsigned long) ln->value;
+        serverLog(LL_WARNING,"Killing debugging session %ld",(long)pid);
+        kill(pid,SIGKILL);
+    }
+    listRelease(ldb.children);
+    ldb.children = listCreate();
+}
+
+/* Wrapper for EVAL / EVALSHA that enables debugging, and makes sure
+ * that when EVAL returns, whatever happened, the session is ended. */
+void evalGenericCommandWithDebugging(client *c, int evalsha) {
+    if (ldbStartSession(c)) {
+        evalGenericCommand(c,evalsha);
+        ldbEndSession(c);
+    } else {
+        ldbDisable(c);
+    }
+}
+
+/* Return a pointer to ldb.src source code line, considering line to be
+ * one-based, and returning a special string for out of range lines. */
+char *ldbGetSourceLine(int line) {
+    int idx = line-1;
+    if (idx < 0 || idx >= ldb.lines) return "<out of range source code line>";
+    return ldb.src[idx];
+}
+
+/* Return true if there is a breakpoint in the specified line. */
+int ldbIsBreakpoint(int line) {
+    int j;
+
+    for (j = 0; j < ldb.bpcount; j++)
+        if (ldb.bp[j] == line) return 1;
+    return 0;
+}
+
+/* Add the specified breakpoint. Ignore it if we already reached the max.
+ * Returns 1 if the breakpoint was added (or was already set). 0 if there is
+ * no space for the breakpoint or if the line is invalid. */
+int ldbAddBreakpoint(int line) {
+    if (line <= 0 || line > ldb.lines) return 0;
+    if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {
+        ldb.bp[ldb.bpcount++] = line;
+        return 1;
+    }
+    return 0;
+}
+
+/* Remove the specified breakpoint, returning 1 if the operation was
+ * performed or 0 if there was no such breakpoint. */
+int ldbDelBreakpoint(int line) {
+    int j;
+
+    for (j = 0; j < ldb.bpcount; j++) {
+        if (ldb.bp[j] == line) {
+            ldb.bpcount--;
+            memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
+            return 1;
+        }
+    }
+    return 0;
+}
+
+/* Expect a valid multi-bulk command in the debugging client query buffer.
+ * On success the command is parsed and returned as an array of SDS strings,
+ * otherwise NULL is returned and there is to read more buffer. */
+sds *ldbReplParseCommand(int *argcp) {
+    sds *argv = NULL;
+    int argc = 0;
+    if (sdslen(ldb.cbuf) == 0) return NULL;
+
+    /* Working on a copy is simpler in this case. We can modify it freely
+     * for the sake of simpler parsing. */
+    sds copy = sdsdup(ldb.cbuf);
+    char *p = copy;
+
+    /* This Redis protocol parser is a joke... just the simplest thing that
+     * works in this context. It is also very forgiving regarding broken
+     * protocol. */
+
+    /* Seek and parse *<count>\r\n. */
+    p = strchr(p,'*'); if (!p) goto protoerr;
+    char *plen = p+1; /* Multi bulk len pointer. */
+    p = strstr(p,"\r\n"); if (!p) goto protoerr;
+    *p = '\0'; p += 2;
+    *argcp = atoi(plen);
+    if (*argcp <= 0 || *argcp > 1024) goto protoerr;
+
+    /* Parse each argument. */
+    argv = zmalloc(sizeof(sds)*(*argcp));
+    argc = 0;
+    while(argc < *argcp) {
+        if (*p != '$') goto protoerr;
+        plen = p+1; /* Bulk string len pointer. */
+        p = strstr(p,"\r\n"); if (!p) goto protoerr;
+        *p = '\0'; p += 2;
+        int slen = atoi(plen); /* Length of this arg. */
+        if (slen <= 0 || slen > 1024) goto protoerr;
+        argv[argc++] = sdsnewlen(p,slen);
+        p += slen; /* Skip the already parsed argument. */
+        if (p[0] != '\r' || p[1] != '\n') goto protoerr;
+        p += 2; /* Skip \r\n. */
+    }
+    sdsfree(copy);
+    return argv;
+
+protoerr:
+    sdsfreesplitres(argv,argc);
+    sdsfree(copy);
+    return NULL;
+}
+
+/* Log the specified line in the Lua debugger output. */
+void ldbLogSourceLine(int lnum) {
+    char *line = ldbGetSourceLine(lnum);
+    char *prefix;
+    int bp = ldbIsBreakpoint(lnum);
+    int current = ldb.currentline == lnum;
+
+    if (current && bp)
+        prefix = "->#";
+    else if (current)
+        prefix = "-> ";
+    else if (bp)
+        prefix = "  #";
+    else
+        prefix = "   ";
+    sds thisline = sdscatprintf(sdsempty(),"%s%-3d %s", prefix, lnum, line);
+    ldbLog(thisline);
+}
+
+/* Implement the "list" command of the Lua debugger. If around is 0
+ * the whole file is listed, otherwise only a small portion of the file
+ * around the specified line is shown. When a line number is specified
+ * the amonut of context (lines before/after) is specified via the
+ * 'context' argument. */
+void ldbList(int around, int context) {
+    int j;
+
+    for (j = 1; j <= ldb.lines; j++) {
+        if (around != 0 && abs(around-j) > context) continue;
+        ldbLogSourceLine(j);
+    }
+}
+
+/* Append an human readable representation of the Lua value at position 'idx'
+ * on the stack of the 'lua' state, to the SDS string passed as argument.
+ * The new SDS string with the represented value attached is returned.
+ * Used in order to implement ldbLogStackValue().
+ *
+ * The element is not automatically removed from the stack, nor it is
+ * converted to a different type. */
+#define LDB_MAX_VALUES_DEPTH (LUA_MINSTACK/2)
+sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
+    int t = lua_type(lua,idx);
+
+    if (level++ == LDB_MAX_VALUES_DEPTH)
+        return sdscat(s,"<max recursion level reached! Nested table?>");
+
+    switch(t) {
+    case LUA_TSTRING:
+        {
+        size_t strl;
+        char *strp = (char*)lua_tolstring(lua,idx,&strl);
+        s = sdscatrepr(s,strp,strl);
+        }
+        break;
+    case LUA_TBOOLEAN:
+        s = sdscat(s,lua_toboolean(lua,idx) ? "true" : "false");
+        break;
+    case LUA_TNUMBER:
+        s = sdscatprintf(s,"%g",(double)lua_tonumber(lua,idx));
+        break;
+    case LUA_TNIL:
+        s = sdscatlen(s,"nil",3);
+        break;
+    case LUA_TTABLE:
+        {
+        int expected_index = 1; /* First index we expect in an array. */
+        int is_array = 1; /* Will be set to null if check fails. */
+        /* Note: we create two representations at the same time, one
+         * assuming the table is an array, one assuming it is not. At the
+         * end we know what is true and select the right one. */
+        sds repr1 = sdsempty();
+        sds repr2 = sdsempty();
+        lua_pushnil(lua); /* The first key to start the iteration is nil. */
+        while (lua_next(lua,idx-1)) {
+            /* Test if so far the table looks like an array. */
+            if (is_array &&
+                (lua_type(lua,-2) != LUA_TNUMBER ||
+                 lua_tonumber(lua,-2) != expected_index)) is_array = 0;
+            /* Stack now: table, key, value */
+            /* Array repr. */
+            repr1 = ldbCatStackValueRec(repr1,lua,-1,level);
+            repr1 = sdscatlen(repr1,"; ",2);
+            /* Full repr. */
+            repr2 = sdscatlen(repr2,"[",1);
+            repr2 = ldbCatStackValueRec(repr2,lua,-2,level);
+            repr2 = sdscatlen(repr2,"]=",2);
+            repr2 = ldbCatStackValueRec(repr2,lua,-1,level);
+            repr2 = sdscatlen(repr2,"; ",2);
+            lua_pop(lua,1); /* Stack: table, key. Ready for next iteration. */
+            expected_index++;
+        }
+        /* Strip the last " ;" from both the representations. */
+        if (sdslen(repr1)) sdsrange(repr1,0,-3);
+        if (sdslen(repr2)) sdsrange(repr2,0,-3);
+        /* Select the right one and discard the other. */
+        s = sdscatlen(s,"{",1);
+        s = sdscatsds(s,is_array ? repr1 : repr2);
+        s = sdscatlen(s,"}",1);
+        sdsfree(repr1);
+        sdsfree(repr2);
+        }
+        break;
+    case LUA_TFUNCTION:
+    case LUA_TUSERDATA:
+    case LUA_TTHREAD:
+    case LUA_TLIGHTUSERDATA:
+        {
+        const void *p = lua_topointer(lua,idx);
+        char *typename = "unknown";
+        if (t == LUA_TFUNCTION) typename = "function";
+        else if (t == LUA_TUSERDATA) typename = "userdata";
+        else if (t == LUA_TTHREAD) typename = "thread";
+        else if (t == LUA_TLIGHTUSERDATA) typename = "light-userdata";
+        s = sdscatprintf(s,"\"%s@%p\"",typename,p);
+        }
+        break;
+    default:
+        s = sdscat(s,"\"<unknown-lua-type>\"");
+        break;
+    }
+    return s;
+}
+
+/* Higher level wrapper for ldbCatStackValueRec() that just uses an initial
+ * recursion level of '0'. */
+sds ldbCatStackValue(sds s, lua_State *lua, int idx) {
+    return ldbCatStackValueRec(s,lua,idx,0);
+}
+
+/* Produce a debugger log entry representing the value of the Lua object
+ * currently on the top of the stack. The element is ot popped nor modified.
+ * Check ldbCatStackValue() for the actual implementation. */
+void ldbLogStackValue(lua_State *lua, char *prefix) {
+    sds s = sdsnew(prefix);
+    s = ldbCatStackValue(s,lua,-1);
+    ldbLogWithMaxLen(s);
+}
+
+char *ldbRedisProtocolToHuman_Int(sds *o, char *reply);
+char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply);
+char *ldbRedisProtocolToHuman_Status(sds *o, char *reply);
+char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply);
+
+/* Get Redis protocol from 'reply' and appends it in human readable form to
+ * the passed SDS string 'o'.
+ *
+ * Note that the SDS string is passed by reference (pointer of pointer to
+ * char*) so that we can return a modified pointer, as for SDS semantics. */
+char *ldbRedisProtocolToHuman(sds *o, char *reply) {
+    char *p = reply;
+    switch(*p) {
+    case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;
+    case '$': p = ldbRedisProtocolToHuman_Bulk(o,reply); break;
+    case '+': p = ldbRedisProtocolToHuman_Status(o,reply); break;
+    case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;
+    case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;
+    }
+    return p;
+}
+
+/* The following functions are helpers for ldbRedisProtocolToHuman(), each
+ * take care of a given Redis return type. */
+
+char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {
+    char *p = strchr(reply+1,'\r');
+    *o = sdscatlen(*o,reply+1,p-reply-1);
+    return p+2;
+}
+
+char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {
+    char *p = strchr(reply+1,'\r');
+    long long bulklen;
+
+    string2ll(reply+1,p-reply-1,&bulklen);
+    if (bulklen == -1) {
+        *o = sdscatlen(*o,"NULL",4);
+        return p+2;
+    } else {
+        *o = sdscatrepr(*o,p+2,bulklen);
+        return p+2+bulklen+2;
+    }
+}
+
+char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {
+    char *p = strchr(reply+1,'\r');
+
+    *o = sdscatrepr(*o,reply,p-reply);
+    return p+2;
+}
+
+char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
+    char *p = strchr(reply+1,'\r');
+    long long mbulklen;
+    int j = 0;
+
+    string2ll(reply+1,p-reply-1,&mbulklen);
+    p += 2;
+    if (mbulklen == -1) {
+        *o = sdscatlen(*o,"NULL",4);
+        return p;
+    }
+    *o = sdscatlen(*o,"[",1);
+    for (j = 0; j < mbulklen; j++) {
+        p = ldbRedisProtocolToHuman(o,p);
+        if (j != mbulklen-1) *o = sdscatlen(*o,",",1);
+    }
+    *o = sdscatlen(*o,"]",1);
+    return p;
+}
+
+/* Log a Redis reply as debugger output, in an human readable format.
+ * If the resulting string is longer than 'len' plus a few more chars
+ * used as prefix, it gets truncated. */
+void ldbLogRedisReply(char *reply) {
+    sds log = sdsnew("<reply> ");
+    ldbRedisProtocolToHuman(&log,reply);
+    ldbLogWithMaxLen(log);
+}
+
+/* Implements the "print <var>" command of the Lua debugger. It scans for Lua
+ * var "varname" starting from the current stack frame up to the top stack
+ * frame. The first matching variable is printed. */
+void ldbPrint(lua_State *lua, char *varname) {
+    lua_Debug ar;
+
+    int l = 0; /* Stack level. */
+    while (lua_getstack(lua,l,&ar) != 0) {
+        l++;
+        const char *name;
+        int i = 1; /* Variable index. */
+        while((name = lua_getlocal(lua,&ar,i)) != NULL) {
+            i++;
+            if (strcmp(varname,name) == 0) {
+                ldbLogStackValue(lua,"<value> ");
+                lua_pop(lua,1);
+                return;
+            } else {
+                lua_pop(lua,1); /* Discard the var name on the stack. */
+            }
+        }
+    }
+
+    /* Let's try with global vars in two selected cases */
+    if (!strcmp(varname,"ARGV") || !strcmp(varname,"KEYS")) {
+        lua_getglobal(lua, varname);
+        ldbLogStackValue(lua,"<value> ");
+        lua_pop(lua,1);
+    } else {
+        ldbLog(sdsnew("No such variable."));
+    }
+}
+
+/* Implements the "print" command (without arguments) of the Lua debugger.
+ * Prints all the variables in the current stack frame. */
+void ldbPrintAll(lua_State *lua) {
+    lua_Debug ar;
+    int vars = 0;
+
+    if (lua_getstack(lua,0,&ar) != 0) {
+        const char *name;
+        int i = 1; /* Variable index. */
+        while((name = lua_getlocal(lua,&ar,i)) != NULL) {
+            i++;
+            if (!strstr(name,"(*temporary)")) {
+                sds prefix = sdscatprintf(sdsempty(),"<value> %s = ",name);
+                ldbLogStackValue(lua,prefix);
+                sdsfree(prefix);
+                vars++;
+            }
+            lua_pop(lua,1);
+        }
+    }
+
+    if (vars == 0) {
+        ldbLog(sdsnew("No local variables in the current context."));
+    }
+}
+
+/* Implements the break command to list, add and remove breakpoints. */
+void ldbBreak(sds *argv, int argc) {
+    if (argc == 1) {
+        if (ldb.bpcount == 0) {
+            ldbLog(sdsnew("No breakpoints set. Use 'b <line>' to add one."));
+            return;
+        } else {
+            ldbLog(sdscatfmt(sdsempty(),"%i breakpoints set:",ldb.bpcount));
+            int j;
+            for (j = 0; j < ldb.bpcount; j++)
+                ldbLogSourceLine(ldb.bp[j]);
+        }
+    } else {
+        int j;
+        for (j = 1; j < argc; j++) {
+            char *arg = argv[j];
+            long line;
+            if (!string2l(arg,sdslen(arg),&line)) {
+                ldbLog(sdscatfmt(sdsempty(),"Invalid argument:'%s'",arg));
+            } else {
+                if (line == 0) {
+                    ldb.bpcount = 0;
+                    ldbLog(sdsnew("All breakpoints removed."));
+                } else if (line > 0) {
+                    if (ldb.bpcount == LDB_BREAKPOINTS_MAX) {
+                        ldbLog(sdsnew("Too many breakpoints set."));
+                    } else if (ldbAddBreakpoint(line)) {
+                        ldbList(line,1);
+                    } else {
+                        ldbLog(sdsnew("Wrong line number."));
+                    }
+                } else if (line < 0) {
+                    if (ldbDelBreakpoint(-line))
+                        ldbLog(sdsnew("Breakpoint removed."));
+                    else
+                        ldbLog(sdsnew("No breakpoint in the specified line."));
+                }
+            }
+        }
+    }
+}
+
+/* Implements the Lua debugger "eval" command. It just compiles the user
+ * passed fragment of code and executes it, showing the result left on
+ * the stack. */
+void ldbEval(lua_State *lua, sds *argv, int argc) {
+    /* Glue the script together if it is composed of multiple arguments. */
+    sds code = sdsjoinsds(argv+1,argc-1," ",1);
+    sds expr = sdscatsds(sdsnew("return "),code);
+
+    /* Try to compile it as an expression, prepending "return ". */
+    if (luaL_loadbuffer(lua,expr,sdslen(expr),"@ldb_eval")) {
+        lua_pop(lua,1);
+        /* Failed? Try as a statement. */
+        if (luaL_loadbuffer(lua,code,sdslen(code),"@ldb_eval")) {
+            ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
+            lua_pop(lua,1);
+            sdsfree(code);
+            return;
+        }
+    }
+
+    /* Call it. */
+    sdsfree(code);
+    sdsfree(expr);
+    if (lua_pcall(lua,0,1,0)) {
+        ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
+        lua_pop(lua,1);
+        return;
+    }
+    ldbLogStackValue(lua,"<retval> ");
+    lua_pop(lua,1);
+}
+
+/* Implement the debugger "redis" command. We use a trick in order to make
+ * the implementation very simple: we just call the Lua redis.call() command
+ * implementation, with ldb.step enabled, so as a side effect the Redis command
+ * and its reply are logged. */
+void ldbRedis(lua_State *lua, sds *argv, int argc) {
+    int j, saved_rc = server.lua_replicate_commands;
+
+    lua_getglobal(lua,"redis");
+    lua_pushstring(lua,"call");
+    lua_gettable(lua,-2);       /* Stack: redis, redis.call */
+    for (j = 1; j < argc; j++)
+        lua_pushlstring(lua,argv[j],sdslen(argv[j]));
+    ldb.step = 1;               /* Force redis.call() to log. */
+    server.lua_replicate_commands = 1;
+    lua_pcall(lua,argc-1,1,0);  /* Stack: redis, result */
+    ldb.step = 0;               /* Disable logging. */
+    server.lua_replicate_commands = saved_rc;
+    lua_pop(lua,2);             /* Discard the result and clean the stack. */
+}
+
+/* Implements "trace" command of the Lua debugger. It just prints a backtrace
+ * querying Lua starting from the current callframe back to the outer one. */
+void ldbTrace(lua_State *lua) {
+    lua_Debug ar;
+    int level = 0;
+
+    while(lua_getstack(lua,level,&ar)) {
+        lua_getinfo(lua,"Snl",&ar);
+        if(strstr(ar.short_src,"user_script") != NULL) {
+            ldbLog(sdscatprintf(sdsempty(),"%s %s:",
+                (level == 0) ? "In" : "From",
+                ar.name ? ar.name : "top level"));
+            ldbLogSourceLine(ar.currentline);
+        }
+        level++;
+    }
+    if (level == 0) {
+        ldbLog(sdsnew("<error> Can't retrieve Lua stack."));
+    }
+}
+
+/* Impleemnts the debugger "maxlen" command. It just queries or sets the
+ * ldb.maxlen variable. */
+void ldbMaxlen(sds *argv, int argc) {
+    if (argc == 2) {
+        int newval = atoi(argv[1]);
+        ldb.maxlen_hint_sent = 1; /* User knows about this command. */
+        if (newval != 0 && newval <= 60) newval = 60;
+        ldb.maxlen = newval;
+    }
+    if (ldb.maxlen) {
+        ldbLog(sdscatprintf(sdsempty(),"<value> replies are truncated at %d bytes.",(int)ldb.maxlen));
+    } else {
+        ldbLog(sdscatprintf(sdsempty(),"<value> replies are unlimited."));
+    }
+}
+
+/* Read debugging commands from client.
+ * Return C_OK if the debugging session is continuing, otherwise
+ * C_ERR if the client closed the connection or is timing out. */
+int ldbRepl(lua_State *lua) {
+    sds *argv;
+    int argc;
+
+    /* We continue processing commands until a command that should return
+     * to the Lua interpreter is found. */
+    while(1) {
+        while((argv = ldbReplParseCommand(&argc)) == NULL) {
+            char buf[1024];
+            int nread = read(ldb.fd,buf,sizeof(buf));
+            if (nread <= 0) {
+                /* Make sure the script runs without user input since the
+                 * client is no longer connected. */
+                ldb.step = 0;
+                ldb.bpcount = 0;
+                return C_ERR;
+            }
+            ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
+        }
+
+        /* Flush the old buffer. */
+        sdsfree(ldb.cbuf);
+        ldb.cbuf = sdsempty();
+
+        /* Execute the command. */
+        if (!strcasecmp(argv[0],"h") || !strcasecmp(argv[0],"help")) {
+ldbLog(sdsnew("Redis Lua debugger help:"));
+ldbLog(sdsnew("[h]elp               Show this help."));
+ldbLog(sdsnew("[s]tep               Run current line and stop again."));
+ldbLog(sdsnew("[n]ext               Alias for step."));
+ldbLog(sdsnew("[c]continue          Run till next breakpoint."));
+ldbLog(sdsnew("[l]list              List source code around current line."));
+ldbLog(sdsnew("[l]list [line]       List source code around [line]."));
+ldbLog(sdsnew("                     line = 0 means: current position."));
+ldbLog(sdsnew("[l]list [line] [ctx] In this form [ctx] specifies how many lines"));
+ldbLog(sdsnew("                     to show before/after [line]."));
+ldbLog(sdsnew("[w]hole              List all source code. Alias for 'list 1 1000000'."));
+ldbLog(sdsnew("[p]rint              Show all the local variables."));
+ldbLog(sdsnew("[p]rint <var>        Show the value of the specified variable."));
+ldbLog(sdsnew("                     Can also show global vars KEYS and ARGV."));
+ldbLog(sdsnew("[b]reak              Show all breakpoints."));
+ldbLog(sdsnew("[b]reak <line>       Add a breakpoint to the specified line."));
+ldbLog(sdsnew("[b]reak -<line>      Remove breakpoint from the specified line."));
+ldbLog(sdsnew("[b]reak 0            Remove all breakpoints."));
+ldbLog(sdsnew("[t]race              Show a backtrace."));
+ldbLog(sdsnew("[e]eval <code>       Execute some Lua code (in a different callframe)."));
+ldbLog(sdsnew("[r]edis <cmd>        Execute a Redis command."));
+ldbLog(sdsnew("[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len."));
+ldbLog(sdsnew("                     Specifying zero as <len> means unlimited."));
+ldbLog(sdsnew("[a]abort             Stop the execution of the script. In sync"));
+ldbLog(sdsnew("                     mode dataset changes will be retained."));
+ldbLog(sdsnew(""));
+ldbLog(sdsnew("Debugger functions you can call from Lua scripts:"));
+ldbLog(sdsnew("redis.debug()        Produce logs in the debugger console."));
+ldbLog(sdsnew("redis.breakpoint()   Stop execution like if there was a breakpoing."));
+ldbLog(sdsnew("                     in the next line of code."));
+            ldbSendLogs();
+        } else if (!strcasecmp(argv[0],"s") || !strcasecmp(argv[0],"step") ||
+                   !strcasecmp(argv[0],"n") || !strcasecmp(argv[0],"next")) {
+            ldb.step = 1;
+            break;
+        } else if (!strcasecmp(argv[0],"c") || !strcasecmp(argv[0],"continue")){
+            break;
+        } else if (!strcasecmp(argv[0],"t") || !strcasecmp(argv[0],"trace")) {
+            ldbTrace(lua);
+            ldbSendLogs();
+        } else if (!strcasecmp(argv[0],"m") || !strcasecmp(argv[0],"maxlen")) {
+            ldbMaxlen(argv,argc);
+            ldbSendLogs();
+        } else if (!strcasecmp(argv[0],"b") || !strcasecmp(argv[0],"break")) {
+            ldbBreak(argv,argc);
+            ldbSendLogs();
+        } else if (!strcasecmp(argv[0],"e") || !strcasecmp(argv[0],"eval")) {
+            ldbEval(lua,argv,argc);
+            ldbSendLogs();
+        } else if (!strcasecmp(argv[0],"a") || !strcasecmp(argv[0],"abort")) {
+            lua_pushstring(lua, "script aborted for user request");
+            lua_error(lua);
+        } else if (argc > 1 &&
+                   (!strcasecmp(argv[0],"r") || !strcasecmp(argv[0],"redis"))) {
+            ldbRedis(lua,argv,argc);
+            ldbSendLogs();
+        } else if ((!strcasecmp(argv[0],"p") || !strcasecmp(argv[0],"print"))) {
+            if (argc == 2)
+                ldbPrint(lua,argv[1]);
+            else
+                ldbPrintAll(lua);
+            ldbSendLogs();
+        } else if (!strcasecmp(argv[0],"l") || !strcasecmp(argv[0],"list")){
+            int around = ldb.currentline, ctx = 5;
+            if (argc > 1) {
+                int num = atoi(argv[1]);
+                if (num > 0) around = num;
+            }
+            if (argc > 2) ctx = atoi(argv[2]);
+            ldbList(around,ctx);
+            ldbSendLogs();
+        } else if (!strcasecmp(argv[0],"w") || !strcasecmp(argv[0],"whole")){
+            ldbList(1,1000000);
+            ldbSendLogs();
+        } else {
+            ldbLog(sdsnew("<error> Unknown Redis Lua debugger command or "
+                          "wrong number of arguments."));
+            ldbSendLogs();
+        }
+
+        /* Free the command vector. */
+        sdsfreesplitres(argv,argc);
+    }
+
+    /* Free the current command argv if we break inside the while loop. */
+    sdsfreesplitres(argv,argc);
+    return C_OK;
+}
+
+/* This is the core of our Lua debugger, called each time Lua is about
+ * to start executing a new line. */
+void luaLdbLineHook(lua_State *lua, lua_Debug *ar) {
+    lua_getstack(lua,0,ar);
+    lua_getinfo(lua,"Sl",ar);
+    ldb.currentline = ar->currentline;
+
+    int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;
+    int timeout = 0;
+
+    /* Events outside our script are not interesting. */
+    if(strstr(ar->short_src,"user_script") == NULL) return;
+
+    /* Check if a timeout occurred. */
+    if (ar->event == LUA_HOOKCOUNT && ldb.step == 0 && bp == 0) {
+        mstime_t elapsed = mstime() - server.lua_time_start;
+        mstime_t timelimit = server.lua_time_limit ?
+                             server.lua_time_limit : 5000;
+        if (elapsed >= timelimit) {
+            timeout = 1;
+            ldb.step = 1;
+        } else {
+            return; /* No timeout, ignore the COUNT event. */
+        }
+    }
+
+    if (ldb.step || bp) {
+        char *reason = "step over";
+        if (bp) reason = ldb.luabp ? "redis.breakpoint() called" :
+                                     "break point";
+        else if (timeout) reason = "timeout reached, infinite loop?";
+        ldb.step = 0;
+        ldb.luabp = 0;
+        ldbLog(sdscatprintf(sdsempty(),
+            "* Stopped at %d, stop reason = %s",
+            ldb.currentline, reason));
+        ldbLogSourceLine(ldb.currentline);
+        ldbSendLogs();
+        if (ldbRepl(lua) == C_ERR && timeout) {
+            /* If the client closed the connection and we have a timeout
+             * connection, let's kill the script otherwise the process
+             * will remain blocked indefinitely. */
+            lua_pushstring(lua, "timeout during Lua debugging with client closing connection");
+            lua_error(lua);
+        }
+        server.lua_time_start = mstime();
+    }
+}
+
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/scripting.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/scripting.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/scripting.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/scripting.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: sdsalloc.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.c	2016-05-06 15:11:36.000000000 +0800
@@ -1,9 +1,11 @@
-/* SDSLib, A C dynamic strings library
+/* SDSLib 2.0 -- A C dynamic strings library
  *
- * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2015, Oran Agra
+ * Copyright (c) 2015, Redis Labs, Inc
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  *   * Redistributions of source code must retain the above copyright notice,
@@ -31,13 +33,41 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <assert.h>
 #include "sds.h"
-#include "zmalloc.h"
+#include "sdsalloc.h"
+
+static inline int sdsHdrSize(char type) {
+    switch(type&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            return sizeof(struct sdshdr5);
+        case SDS_TYPE_8:
+            return sizeof(struct sdshdr8);
+        case SDS_TYPE_16:
+            return sizeof(struct sdshdr16);
+        case SDS_TYPE_32:
+            return sizeof(struct sdshdr32);
+        case SDS_TYPE_64:
+            return sizeof(struct sdshdr64);
+    }
+    return 0;
+}
+
+static inline char sdsReqType(size_t string_size) {
+    if (string_size < 32)
+        return SDS_TYPE_5;
+    if (string_size < 0xff)
+        return SDS_TYPE_8;
+    if (string_size < 0xffff)
+        return SDS_TYPE_16;
+    if (string_size < 0xffffffff)
+        return SDS_TYPE_32;
+    return SDS_TYPE_64;
+}
 
 /* Create a new sds string with the content specified by the 'init' pointer
  * and 'initlen'.
  * If NULL is used for 'init' the string is initialized with zero bytes.
  *
  * The string is always null-termined (all the sds strings are, always) so
@@ -46,26 +76,65 @@
  * mystring = sdsnewlen("abc",3);
  *
  * You can print the string with printf() as there is an implicit \0 at the
  * end of the string. However the string is binary safe and can contain
  * \0 characters in the middle, as the length is stored in the sds header. */
 sds sdsnewlen(const void *init, size_t initlen) {
-    struct sdshdr *sh;
-
-    if (init) {
-        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
-    } else {
-        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);
-    }
+    void *sh;
+    sds s;
+    char type = sdsReqType(initlen);
+    /* Empty strings are usually created in order to append. Use type 8
+     * since type 5 is not good at this. */
+    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
+    int hdrlen = sdsHdrSize(type);
+    unsigned char *fp; /* flags pointer. */
+
+    sh = s_malloc(hdrlen+initlen+1);
+    if (!init)
+        memset(sh, 0, hdrlen+initlen+1);
     if (sh == NULL) return NULL;
-    sh->len = initlen;
-    sh->free = 0;
+    s = (char*)sh+hdrlen;
+    fp = ((unsigned char*)s)-1;
+    switch(type) {
+        case SDS_TYPE_5: {
+            *fp = type | (initlen << SDS_TYPE_BITS);
+            break;
+        }
+        case SDS_TYPE_8: {
+            SDS_HDR_VAR(8,s);
+            sh->len = initlen;
+            sh->alloc = initlen;
+            *fp = type;
+            break;
+        }
+        case SDS_TYPE_16: {
+            SDS_HDR_VAR(16,s);
+            sh->len = initlen;
+            sh->alloc = initlen;
+            *fp = type;
+            break;
+        }
+        case SDS_TYPE_32: {
+            SDS_HDR_VAR(32,s);
+            sh->len = initlen;
+            sh->alloc = initlen;
+            *fp = type;
+            break;
+        }
+        case SDS_TYPE_64: {
+            SDS_HDR_VAR(64,s);
+            sh->len = initlen;
+            sh->alloc = initlen;
+            *fp = type;
+            break;
+        }
+    }
     if (initlen && init)
-        memcpy(sh->buf, init, initlen);
-    sh->buf[initlen] = '\0';
-    return (char*)sh->buf;
+        memcpy(s, init, initlen);
+    s[initlen] = '\0';
+    return s;
 }
 
 /* Create an empty (zero length) sds string. Even in this case the string
  * always has an implicit null term. */
 sds sdsempty(void) {
     return sdsnewlen("",0);
@@ -82,13 +151,13 @@
     return sdsnewlen(s, sdslen(s));
 }
 
 /* Free an sds string. No operation is performed if 's' is NULL. */
 void sdsfree(sds s) {
     if (s == NULL) return;
-    zfree(s-sizeof(struct sdshdr));
+    s_free((char*)s-sdsHdrSize(s[-1]));
 }
 
 /* Set the sds string length to the length as obtained with strlen(), so
  * considering as content only up to the first null term character.
  *
  * This function is useful when the sds string is hacked manually in some
@@ -100,81 +169,124 @@
  * printf("%d\n", sdslen(s));
  *
  * The output will be "2", but if we comment out the call to sdsupdatelen()
  * the output will be "6" as the string was modified but the logical length
  * remains 6 bytes. */
 void sdsupdatelen(sds s) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     int reallen = strlen(s);
-    sh->free += (sh->len-reallen);
-    sh->len = reallen;
+    sdssetlen(s, reallen);
 }
 
 /* Modify an sds string in-place to make it empty (zero length).
  * However all the existing buffer is not discarded but set as free space
  * so that next append operations will not require allocations up to the
  * number of bytes previously available. */
 void sdsclear(sds s) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
-    sh->free += sh->len;
-    sh->len = 0;
-    sh->buf[0] = '\0';
+    sdssetlen(s, 0);
+    s[0] = '\0';
 }
 
 /* Enlarge the free space at the end of the sds string so that the caller
  * is sure that after calling this function can overwrite up to addlen
  * bytes after the end of the string, plus one more byte for nul term.
  *
  * Note: this does not change the *length* of the sds string as returned
  * by sdslen(), but only the free buffer space we have. */
 sds sdsMakeRoomFor(sds s, size_t addlen) {
-    struct sdshdr *sh, *newsh;
-    size_t free = sdsavail(s);
+    void *sh, *newsh;
+    size_t avail = sdsavail(s);
     size_t len, newlen;
+    char type, oldtype = s[-1] & SDS_TYPE_MASK;
+    int hdrlen;
+
+    /* Return ASAP if there is enough space left. */
+    if (avail >= addlen) return s;
 
-    if (free >= addlen) return s;
     len = sdslen(s);
-    sh = (void*) (s-(sizeof(struct sdshdr)));
+    sh = (char*)s-sdsHdrSize(oldtype);
     newlen = (len+addlen);
     if (newlen < SDS_MAX_PREALLOC)
         newlen *= 2;
     else
         newlen += SDS_MAX_PREALLOC;
-    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);
-    if (newsh == NULL) return NULL;
 
-    newsh->free = newlen - len;
-    return newsh->buf;
+    type = sdsReqType(newlen);
+
+    /* Don't use type 5: the user is appending to the string and type 5 is
+     * not able to remember empty space, so sdsMakeRoomFor() must be called
+     * at every appending operation. */
+    if (type == SDS_TYPE_5) type = SDS_TYPE_8;
+
+    hdrlen = sdsHdrSize(type);
+    if (oldtype==type) {
+        newsh = s_realloc(sh, hdrlen+newlen+1);
+        if (newsh == NULL) return NULL;
+        s = (char*)newsh+hdrlen;
+    } else {
+        /* Since the header size changes, need to move the string forward,
+         * and can't use realloc */
+        newsh = s_malloc(hdrlen+newlen+1);
+        if (newsh == NULL) return NULL;
+        memcpy((char*)newsh+hdrlen, s, len+1);
+        s_free(sh);
+        s = (char*)newsh+hdrlen;
+        s[-1] = type;
+        sdssetlen(s, len);
+    }
+    sdssetalloc(s, newlen);
+    return s;
 }
 
 /* Reallocate the sds string so that it has no free space at the end. The
  * contained string remains not altered, but next concatenation operations
  * will require a reallocation.
  *
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdsRemoveFreeSpace(sds s) {
-    struct sdshdr *sh;
-
-    sh = (void*) (s-(sizeof(struct sdshdr)));
-    sh = zrealloc(sh, sizeof(struct sdshdr)+sh->len+1);
-    sh->free = 0;
-    return sh->buf;
+    void *sh, *newsh;
+    char type, oldtype = s[-1] & SDS_TYPE_MASK;
+    int hdrlen;
+    size_t len = sdslen(s);
+    sh = (char*)s-sdsHdrSize(oldtype);
+
+    type = sdsReqType(len);
+    hdrlen = sdsHdrSize(type);
+    if (oldtype==type) {
+        newsh = s_realloc(sh, hdrlen+len+1);
+        if (newsh == NULL) return NULL;
+        s = (char*)newsh+hdrlen;
+    } else {
+        newsh = s_malloc(hdrlen+len+1);
+        if (newsh == NULL) return NULL;
+        memcpy((char*)newsh+hdrlen, s, len+1);
+        s_free(sh);
+        s = (char*)newsh+hdrlen;
+        s[-1] = type;
+        sdssetlen(s, len);
+    }
+    sdssetalloc(s, len);
+    return s;
 }
 
 /* Return the total size of the allocation of the specifed sds string,
  * including:
  * 1) The sds header before the pointer.
  * 2) The string.
  * 3) The free buffer at the end if any.
  * 4) The implicit null term.
  */
 size_t sdsAllocSize(sds s) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    size_t alloc = sdsalloc(s);
+    return sdsHdrSize(s[-1])+alloc+1;
+}
 
-    return sizeof(*sh)+sh->len+sh->free+1;
+/* Return the pointer of the actual SDS allocation (normally SDS strings
+ * are referenced by the start of the string buffer). */
+void *sdsAllocPtr(sds s) {
+    return (void*) (s-sdsHdrSize(s[-1]));
 }
 
 /* Increment the sds length and decrements the left free space at the
  * end of the string according to 'incr'. Also set the null term
  * in the new end of the string.
  *
@@ -195,60 +307,82 @@
  * s = sdsMakeRoomFor(s, BUFFER_SIZE);
  * nread = read(fd, s+oldlen, BUFFER_SIZE);
  * ... check for nread <= 0 and handle it ...
  * sdsIncrLen(s, nread);
  */
 void sdsIncrLen(sds s, int incr) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
-
-    if (incr >= 0)
-        assert(sh->free >= (unsigned int)incr);
-    else
-        assert(sh->len >= (unsigned int)(-incr));
-    sh->len += incr;
-    sh->free -= incr;
-    s[sh->len] = '\0';
+    unsigned char flags = s[-1];
+    size_t len;
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5: {
+            unsigned char *fp = ((unsigned char*)s)-1;
+            unsigned char oldlen = SDS_TYPE_5_LEN(flags);
+            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));
+            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);
+            len = oldlen+incr;
+            break;
+        }
+        case SDS_TYPE_8: {
+            SDS_HDR_VAR(8,s);
+            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
+            len = (sh->len += incr);
+            break;
+        }
+        case SDS_TYPE_16: {
+            SDS_HDR_VAR(16,s);
+            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
+            len = (sh->len += incr);
+            break;
+        }
+        case SDS_TYPE_32: {
+            SDS_HDR_VAR(32,s);
+            assert((incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
+            len = (sh->len += incr);
+            break;
+        }
+        case SDS_TYPE_64: {
+            SDS_HDR_VAR(64,s);
+            assert((incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));
+            len = (sh->len += incr);
+            break;
+        }
+        default: len = 0; /* Just to avoid compilation warnings. */
+    }
+    s[len] = '\0';
 }
 
 /* Grow the sds to have the specified length. Bytes that were not part of
  * the original length of the sds will be set to zero.
  *
  * if the specified length is smaller than the current length, no operation
  * is performed. */
 sds sdsgrowzero(sds s, size_t len) {
-    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
-    size_t totlen, curlen = sh->len;
+    size_t curlen = sdslen(s);
 
     if (len <= curlen) return s;
     s = sdsMakeRoomFor(s,len-curlen);
     if (s == NULL) return NULL;
 
     /* Make sure added region doesn't contain garbage */
-    sh = (void*)(s-(sizeof(struct sdshdr)));
     memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
-    totlen = sh->len+sh->free;
-    sh->len = len;
-    sh->free = totlen-sh->len;
+    sdssetlen(s, len);
     return s;
 }
 
 /* Append the specified binary-safe string pointed by 't' of 'len' bytes to the
  * end of the specified sds string 's'.
  *
  * After the call, the passed sds string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call. */
 sds sdscatlen(sds s, const void *t, size_t len) {
-    struct sdshdr *sh;
     size_t curlen = sdslen(s);
 
     s = sdsMakeRoomFor(s,len);
     if (s == NULL) return NULL;
-    sh = (void*) (s-(sizeof(struct sdshdr)));
     memcpy(s+curlen, t, len);
-    sh->len = curlen+len;
-    sh->free = sh->free-len;
+    sdssetlen(s, curlen+len);
     s[curlen+len] = '\0';
     return s;
 }
 
 /* Append the specified null termianted C string to the sds string 's'.
  *
@@ -266,25 +400,19 @@
     return sdscatlen(s, t, sdslen(t));
 }
 
 /* Destructively modify the sds string 's' to hold the specified binary
  * safe string pointed by 't' of length 'len' bytes. */
 sds sdscpylen(sds s, const char *t, size_t len) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
-    size_t totlen = sh->free+sh->len;
-
-    if (totlen < len) {
-        s = sdsMakeRoomFor(s,len-sh->len);
+    if (sdsalloc(s) < len) {
+        s = sdsMakeRoomFor(s,len-sdslen(s));
         if (s == NULL) return NULL;
-        sh = (void*) (s-(sizeof(struct sdshdr)));
-        totlen = sh->free+sh->len;
     }
     memcpy(s, t, len);
     s[len] = '\0';
-    sh->len = len;
-    sh->free = totlen-len;
+    sdssetlen(s, len);
     return s;
 }
 
 /* Like sdscpylen() but 't' must be a null-termined string so that the length
  * of the string is obtained with strlen(). */
 sds sdscpy(sds s, const char *t) {
@@ -375,13 +503,13 @@
     char staticbuf[1024], *buf = staticbuf, *t;
     size_t buflen = strlen(fmt)*2;
 
     /* We try to start using a static buffer for speed.
      * If not possible we revert to heap allocation. */
     if (buflen > sizeof(staticbuf)) {
-        buf = zmalloc(buflen);
+        buf = s_malloc(buflen);
         if (buf == NULL) return NULL;
     } else {
         buflen = sizeof(staticbuf);
     }
 
     /* Try with buffers two times bigger every time we fail to
@@ -389,24 +517,24 @@
     while(1) {
         buf[buflen-2] = '\0';
         va_copy(cpy,ap);
         vsnprintf(buf, buflen, fmt, cpy);
         va_end(cpy);
         if (buf[buflen-2] != '\0') {
-            if (buf != staticbuf) zfree(buf);
+            if (buf != staticbuf) s_free(buf);
             buflen *= 2;
-            buf = zmalloc(buflen);
+            buf = s_malloc(buflen);
             if (buf == NULL) return NULL;
             continue;
         }
         break;
     }
 
     /* Finally concat the obtained string to the SDS string and return it. */
     t = sdscat(s, buf);
-    if (buf != staticbuf) zfree(buf);
+    if (buf != staticbuf) s_free(buf);
     return t;
 }
 
 /* Append to the sds string 's' a string obtained using printf-alike format
  * specifier.
  *
@@ -446,100 +574,90 @@
  * %I - 64 bit signed integer (long long, int64_t)
  * %u - unsigned int
  * %U - 64 bit unsigned integer (unsigned long long, uint64_t)
  * %% - Verbatim "%" character.
  */
 sds sdscatfmt(sds s, char const *fmt, ...) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     size_t initlen = sdslen(s);
     const char *f = fmt;
     int i;
     va_list ap;
 
     va_start(ap,fmt);
     f = fmt;    /* Next format specifier byte to process. */
     i = initlen; /* Position of the next byte to write to dest str. */
     while(*f) {
         char next, *str;
-        unsigned int l;
+        size_t l;
         long long num;
         unsigned long long unum;
 
         /* Make sure there is always space for at least 1 char. */
-        if (sh->free == 0) {
+        if (sdsavail(s)==0) {
             s = sdsMakeRoomFor(s,1);
-            sh = (void*) (s-(sizeof(struct sdshdr)));
         }
 
         switch(*f) {
         case '%':
             next = *(f+1);
             f++;
             switch(next) {
             case 's':
             case 'S':
                 str = va_arg(ap,char*);
                 l = (next == 's') ? strlen(str) : sdslen(str);
-                if (sh->free < l) {
+                if (sdsavail(s) < l) {
                     s = sdsMakeRoomFor(s,l);
-                    sh = (void*) (s-(sizeof(struct sdshdr)));
                 }
                 memcpy(s+i,str,l);
-                sh->len += l;
-                sh->free -= l;
+                sdsinclen(s,l);
                 i += l;
                 break;
             case 'i':
             case 'I':
                 if (next == 'i')
                     num = va_arg(ap,int);
                 else
                     num = va_arg(ap,long long);
                 {
                     char buf[SDS_LLSTR_SIZE];
                     l = sdsll2str(buf,num);
-                    if (sh->free < l) {
+                    if (sdsavail(s) < l) {
                         s = sdsMakeRoomFor(s,l);
-                        sh = (void*) (s-(sizeof(struct sdshdr)));
                     }
                     memcpy(s+i,buf,l);
-                    sh->len += l;
-                    sh->free -= l;
+                    sdsinclen(s,l);
                     i += l;
                 }
                 break;
             case 'u':
             case 'U':
                 if (next == 'u')
                     unum = va_arg(ap,unsigned int);
                 else
                     unum = va_arg(ap,unsigned long long);
                 {
                     char buf[SDS_LLSTR_SIZE];
                     l = sdsull2str(buf,unum);
-                    if (sh->free < l) {
+                    if (sdsavail(s) < l) {
                         s = sdsMakeRoomFor(s,l);
-                        sh = (void*) (s-(sizeof(struct sdshdr)));
                     }
                     memcpy(s+i,buf,l);
-                    sh->len += l;
-                    sh->free -= l;
+                    sdsinclen(s,l);
                     i += l;
                 }
                 break;
             default: /* Handle %% and generally %<unknown>. */
                 s[i++] = next;
-                sh->len += 1;
-                sh->free -= 1;
+                sdsinclen(s,1);
                 break;
             }
             break;
         default:
             s[i++] = *f;
-            sh->len += 1;
-            sh->free -= 1;
+            sdsinclen(s,1);
             break;
         }
         f++;
     }
     va_end(ap);
 
@@ -560,25 +678,23 @@
  * s = sdstrim(s,"Aa. :");
  * printf("%s\n", s);
  *
  * Output will be just "Hello World".
  */
 sds sdstrim(sds s, const char *cset) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     char *start, *end, *sp, *ep;
     size_t len;
 
     sp = start = s;
     ep = end = s+sdslen(s)-1;
     while(sp <= end && strchr(cset, *sp)) sp++;
-    while(ep > start && strchr(cset, *ep)) ep--;
+    while(ep > sp && strchr(cset, *ep)) ep--;
     len = (sp > ep) ? 0 : ((ep-sp)+1);
-    if (sh->buf != sp) memmove(sh->buf, sp, len);
-    sh->buf[len] = '\0';
-    sh->free = sh->free+(sh->len-len);
-    sh->len = len;
+    if (s != sp) memmove(s, sp, len);
+    s[len] = '\0';
+    sdssetlen(s,len);
     return s;
 }
 
 /* Turn the string into a smaller (or equal) string containing only the
  * substring specified by the 'start' and 'end' indexes.
  *
@@ -593,13 +709,12 @@
  * Example:
  *
  * s = sdsnew("Hello World");
  * sdsrange(s,1,-1); => "ello World"
  */
 void sdsrange(sds s, int start, int end) {
-    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     size_t newlen, len = sdslen(s);
 
     if (len == 0) return;
     if (start < 0) {
         start = len+start;
         if (start < 0) start = 0;
@@ -616,16 +731,15 @@
             end = len-1;
             newlen = (start > end) ? 0 : (end-start)+1;
         }
     } else {
         start = 0;
     }
-    if (start && newlen) memmove(sh->buf, sh->buf+start, newlen);
-    sh->buf[newlen] = 0;
-    sh->free = sh->free+(sh->len-newlen);
-    sh->len = newlen;
+    if (start && newlen) memmove(s, s+start, newlen);
+    s[newlen] = 0;
+    sdssetlen(s,newlen);
 }
 
 /* Apply tolower() to every character of the sds string 's'. */
 void sdstolower(sds s) {
     int len = sdslen(s), j;
 
@@ -681,26 +795,26 @@
 sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {
     int elements = 0, slots = 5, start = 0, j;
     sds *tokens;
 
     if (seplen < 1 || len < 0) return NULL;
 
-    tokens = zmalloc(sizeof(sds)*slots);
+    tokens = s_malloc(sizeof(sds)*slots);
     if (tokens == NULL) return NULL;
 
     if (len == 0) {
         *count = 0;
         return tokens;
     }
     for (j = 0; j < (len-(seplen-1)); j++) {
         /* make sure there is room for the next element and the final one */
         if (slots < elements+2) {
             sds *newtokens;
 
             slots *= 2;
-            newtokens = zrealloc(tokens,sizeof(sds)*slots);
+            newtokens = s_realloc(tokens,sizeof(sds)*slots);
             if (newtokens == NULL) goto cleanup;
             tokens = newtokens;
         }
         /* search the separator */
         if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
             tokens[elements] = sdsnewlen(s+start,j-start);
@@ -718,24 +832,24 @@
     return tokens;
 
 cleanup:
     {
         int i;
         for (i = 0; i < elements; i++) sdsfree(tokens[i]);
-        zfree(tokens);
+        s_free(tokens);
         *count = 0;
         return NULL;
     }
 }
 
 /* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */
 void sdsfreesplitres(sds *tokens, int count) {
     if (!tokens) return;
     while(count--)
         sdsfree(tokens[count]);
-    zfree(tokens);
+    s_free(tokens);
 }
 
 /* Append to the sds string "s" an escaped string representation where
  * all the non-printable characters (tested with isprint()) are turned into
  * escapes in the form "\n\r\a...." or "\x<hex-number>".
  *
@@ -903,27 +1017,27 @@
                         break;
                     }
                 }
                 if (*p) p++;
             }
             /* add the token to the vector */
-            vector = zrealloc(vector,((*argc)+1)*sizeof(char*));
+            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));
             vector[*argc] = current;
             (*argc)++;
             current = NULL;
         } else {
             /* Even on empty input string return something not NULL. */
-            if (vector == NULL) vector = zmalloc(sizeof(void*));
+            if (vector == NULL) vector = s_malloc(sizeof(void*));
             return vector;
         }
     }
 
 err:
     while((*argc)--)
         sdsfree(vector[*argc]);
-    zfree(vector);
+    s_free(vector);
     if (current) sdsfree(current);
     *argc = 0;
     return NULL;
 }
 
 /* Modify the string substituting all the occurrences of the set of
@@ -959,20 +1073,41 @@
         join = sdscat(join, argv[j]);
         if (j != argc-1) join = sdscat(join,sep);
     }
     return join;
 }
 
-#ifdef SDS_TEST_MAIN
+/* Like sdsjoin, but joins an array of SDS strings. */
+sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
+    sds join = sdsempty();
+    int j;
+
+    for (j = 0; j < argc; j++) {
+        join = sdscatsds(join, argv[j]);
+        if (j != argc-1) join = sdscatlen(join,sep,seplen);
+    }
+    return join;
+}
+
+/* Wrappers to the allocators used by SDS. Note that SDS will actually
+ * just use the macros defined into sdsalloc.h in order to avoid to pay
+ * the overhead of function calls. Here we define these wrappers only for
+ * the programs SDS is linked to, if they want to touch the SDS internals
+ * even if they use a different allocator. */
+void *sds_malloc(size_t size) { return s_malloc(size); }
+void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }
+void sds_free(void *ptr) { s_free(ptr); }
+
+#if defined(SDS_TEST_MAIN)
 #include <stdio.h>
 #include "testhelp.h"
 #include "limits.h"
 
-int main(void) {
+#define UNUSED(x) (void)(x)
+int sdsTest(void) {
     {
-        struct sdshdr *sh;
         sds x = sdsnew("foo"), y;
 
         test_cond("Create a string and obtain the length",
             sdslen(x) == 3 && memcmp(x,"foo\0",4) == 0)
 
         sdsfree(x);
@@ -1002,21 +1137,34 @@
         x = sdsnew("--");
         x = sdscatfmt(x, "Hello %s World %I,%I--", "Hi!", LLONG_MIN,LLONG_MAX);
         test_cond("sdscatfmt() seems working in the base case",
             sdslen(x) == 60 &&
             memcmp(x,"--Hello Hi! World -9223372036854775808,"
                      "9223372036854775807--",60) == 0)
+        printf("[%s]\n",x);
 
         sdsfree(x);
         x = sdsnew("--");
         x = sdscatfmt(x, "%u,%U--", UINT_MAX, ULLONG_MAX);
         test_cond("sdscatfmt() seems working with unsigned numbers",
             sdslen(x) == 35 &&
             memcmp(x,"--4294967295,18446744073709551615--",35) == 0)
 
         sdsfree(x);
+        x = sdsnew(" x ");
+        sdstrim(x," x");
+        test_cond("sdstrim() works when all chars match",
+            sdslen(x) == 0)
+
+        sdsfree(x);
+        x = sdsnew(" x ");
+        sdstrim(x," ");
+        test_cond("sdstrim() works when a single char remains",
+            sdslen(x) == 1 && x[0] == 'x')
+
+        sdsfree(x);
         x = sdsnew("xxciaoyyy");
         sdstrim(x,"xy");
         test_cond("sdstrim() correctly trims characters",
             sdslen(x) == 4 && memcmp(x,"ciao\0",5) == 0)
 
         y = sdsdup(x);
@@ -1077,30 +1225,50 @@
         x = sdsnewlen("\a\n\0foo\r",7);
         y = sdscatrepr(sdsempty(),x,sdslen(x));
         test_cond("sdscatrepr(...data...)",
             memcmp(y,"\"\\a\\n\\x00foo\\r\"",15) == 0)
 
         {
-            int oldfree;
+            unsigned int oldfree;
+            char *p;
+            int step = 10, j, i;
 
             sdsfree(x);
             sdsfree(y);
             x = sdsnew("0");
-            sh = (void*) (x-(sizeof(struct sdshdr)));
-            test_cond("sdsnew() free/len buffers", sh->len == 1 && sh->free == 0);
-            x = sdsMakeRoomFor(x,1);
-            sh = (void*) (x-(sizeof(struct sdshdr)));
-            test_cond("sdsMakeRoomFor()", sh->len == 1 && sh->free > 0);
-            oldfree = sh->free;
-            x[1] = '1';
-            sdsIncrLen(x,1);
-            test_cond("sdsIncrLen() -- content", x[0] == '0' && x[1] == '1');
-            test_cond("sdsIncrLen() -- len", sh->len == 2);
-            test_cond("sdsIncrLen() -- free", sh->free == oldfree-1);
+            test_cond("sdsnew() free/len buffers", sdslen(x) == 1 && sdsavail(x) == 0);
+
+            /* Run the test a few times in order to hit the first two
+             * SDS header types. */
+            for (i = 0; i < 10; i++) {
+                int oldlen = sdslen(x);
+                x = sdsMakeRoomFor(x,step);
+                int type = x[-1]&SDS_TYPE_MASK;
+
+                test_cond("sdsMakeRoomFor() len", sdslen(x) == oldlen);
+                if (type != SDS_TYPE_5) {
+                    test_cond("sdsMakeRoomFor() free", sdsavail(x) >= step);
+                    oldfree = sdsavail(x);
+                }
+                p = x+oldlen;
+                for (j = 0; j < step; j++) {
+                    p[j] = 'A'+j;
+                }
+                sdsIncrLen(x,step);
+            }
+            test_cond("sdsMakeRoomFor() content",
+                memcmp("0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ",x,101) == 0);
+            test_cond("sdsMakeRoomFor() final length",sdslen(x)==101);
 
             sdsfree(x);
         }
     }
     test_report()
     return 0;
 }
 #endif
+
+#ifdef SDS_TEST_MAIN
+int main(void) {
+    return sdsTest();
+}
+#endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,9 +1,11 @@
-/* SDSLib, A C dynamic strings library
+/* SDSLib 2.0 -- A C dynamic strings library
  *
- * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2015, Oran Agra
+ * Copyright (c) 2015, Redis Labs, Inc
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  *   * Redistributions of source code must retain the above copyright notice,
@@ -32,38 +34,194 @@
 #define __SDS_H
 
 #define SDS_MAX_PREALLOC (1024*1024)
 
 #include <sys/types.h>
 #include <stdarg.h>
+#include <stdint.h>
 
 typedef char *sds;
 
-struct sdshdr {
-    unsigned int len;
-    unsigned int free;
+/* Note: sdshdr5 is never used, we just access the flags byte directly.
+ * However is here to document the layout of type 5 SDS strings. */
+struct __attribute__ ((__packed__)) sdshdr5 {
+    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
+    char buf[];
+};
+struct __attribute__ ((__packed__)) sdshdr8 {
+    uint8_t len; /* used */
+    uint8_t alloc; /* excluding the header and null terminator */
+    unsigned char flags; /* 3 lsb of type, 5 unused bits */
+    char buf[];
+};
+struct __attribute__ ((__packed__)) sdshdr16 {
+    uint16_t len; /* used */
+    uint16_t alloc; /* excluding the header and null terminator */
+    unsigned char flags; /* 3 lsb of type, 5 unused bits */
+    char buf[];
+};
+struct __attribute__ ((__packed__)) sdshdr32 {
+    uint32_t len; /* used */
+    uint32_t alloc; /* excluding the header and null terminator */
+    unsigned char flags; /* 3 lsb of type, 5 unused bits */
+    char buf[];
+};
+struct __attribute__ ((__packed__)) sdshdr64 {
+    uint64_t len; /* used */
+    uint64_t alloc; /* excluding the header and null terminator */
+    unsigned char flags; /* 3 lsb of type, 5 unused bits */
     char buf[];
 };
 
+#define SDS_TYPE_5  0
+#define SDS_TYPE_8  1
+#define SDS_TYPE_16 2
+#define SDS_TYPE_32 3
+#define SDS_TYPE_64 4
+#define SDS_TYPE_MASK 7
+#define SDS_TYPE_BITS 3
+#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));
+#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
+#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)
+
 static inline size_t sdslen(const sds s) {
-    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
-    return sh->len;
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            return SDS_TYPE_5_LEN(flags);
+        case SDS_TYPE_8:
+            return SDS_HDR(8,s)->len;
+        case SDS_TYPE_16:
+            return SDS_HDR(16,s)->len;
+        case SDS_TYPE_32:
+            return SDS_HDR(32,s)->len;
+        case SDS_TYPE_64:
+            return SDS_HDR(64,s)->len;
+    }
+    return 0;
 }
 
 static inline size_t sdsavail(const sds s) {
-    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
-    return sh->free;
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5: {
+            return 0;
+        }
+        case SDS_TYPE_8: {
+            SDS_HDR_VAR(8,s);
+            return sh->alloc - sh->len;
+        }
+        case SDS_TYPE_16: {
+            SDS_HDR_VAR(16,s);
+            return sh->alloc - sh->len;
+        }
+        case SDS_TYPE_32: {
+            SDS_HDR_VAR(32,s);
+            return sh->alloc - sh->len;
+        }
+        case SDS_TYPE_64: {
+            SDS_HDR_VAR(64,s);
+            return sh->alloc - sh->len;
+        }
+    }
+    return 0;
+}
+
+static inline void sdssetlen(sds s, size_t newlen) {
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            {
+                unsigned char *fp = ((unsigned char*)s)-1;
+                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
+            }
+            break;
+        case SDS_TYPE_8:
+            SDS_HDR(8,s)->len = newlen;
+            break;
+        case SDS_TYPE_16:
+            SDS_HDR(16,s)->len = newlen;
+            break;
+        case SDS_TYPE_32:
+            SDS_HDR(32,s)->len = newlen;
+            break;
+        case SDS_TYPE_64:
+            SDS_HDR(64,s)->len = newlen;
+            break;
+    }
+}
+
+static inline void sdsinclen(sds s, size_t inc) {
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            {
+                unsigned char *fp = ((unsigned char*)s)-1;
+                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;
+                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
+            }
+            break;
+        case SDS_TYPE_8:
+            SDS_HDR(8,s)->len += inc;
+            break;
+        case SDS_TYPE_16:
+            SDS_HDR(16,s)->len += inc;
+            break;
+        case SDS_TYPE_32:
+            SDS_HDR(32,s)->len += inc;
+            break;
+        case SDS_TYPE_64:
+            SDS_HDR(64,s)->len += inc;
+            break;
+    }
+}
+
+/* sdsalloc() = sdsavail() + sdslen() */
+static inline size_t sdsalloc(const sds s) {
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            return SDS_TYPE_5_LEN(flags);
+        case SDS_TYPE_8:
+            return SDS_HDR(8,s)->alloc;
+        case SDS_TYPE_16:
+            return SDS_HDR(16,s)->alloc;
+        case SDS_TYPE_32:
+            return SDS_HDR(32,s)->alloc;
+        case SDS_TYPE_64:
+            return SDS_HDR(64,s)->alloc;
+    }
+    return 0;
+}
+
+static inline void sdssetalloc(sds s, size_t newlen) {
+    unsigned char flags = s[-1];
+    switch(flags&SDS_TYPE_MASK) {
+        case SDS_TYPE_5:
+            /* Nothing to do, this type has no total allocation info. */
+            break;
+        case SDS_TYPE_8:
+            SDS_HDR(8,s)->alloc = newlen;
+            break;
+        case SDS_TYPE_16:
+            SDS_HDR(16,s)->alloc = newlen;
+            break;
+        case SDS_TYPE_32:
+            SDS_HDR(32,s)->alloc = newlen;
+            break;
+        case SDS_TYPE_64:
+            SDS_HDR(64,s)->alloc = newlen;
+            break;
+    }
 }
 
 sds sdsnewlen(const void *init, size_t initlen);
 sds sdsnew(const char *init);
 sds sdsempty(void);
-size_t sdslen(const sds s);
 sds sdsdup(const sds s);
 void sdsfree(sds s);
-size_t sdsavail(const sds s);
 sds sdsgrowzero(sds s, size_t len);
 sds sdscatlen(sds s, const void *t, size_t len);
 sds sdscat(sds s, const char *t);
 sds sdscatsds(sds s, const sds t);
 sds sdscpylen(sds s, const char *t, size_t len);
 sds sdscpy(sds s, const char *t);
@@ -88,14 +246,28 @@
 void sdstoupper(sds s);
 sds sdsfromlonglong(long long value);
 sds sdscatrepr(sds s, const char *p, size_t len);
 sds *sdssplitargs(const char *line, int *argc);
 sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);
 sds sdsjoin(char **argv, int argc, char *sep);
+sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);
 
 /* Low level functions exposed to the user API */
 sds sdsMakeRoomFor(sds s, size_t addlen);
 void sdsIncrLen(sds s, int incr);
 sds sdsRemoveFreeSpace(sds s);
 size_t sdsAllocSize(sds s);
+void *sdsAllocPtr(sds s);
+
+/* Export the allocator used by SDS to the program using SDS.
+ * Sometimes the program SDS is linked to, may use a different set of
+ * allocators, but may want to allocate or free things that SDS will
+ * respectively free or allocate. */
+void *sds_malloc(size_t size);
+void *sds_realloc(void *ptr, size_t size);
+void sds_free(void *ptr);
+
+#ifdef REDIS_TEST
+int sdsTest(int argc, char *argv[]);
+#endif
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sds.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sds.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sentinel.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sentinel.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sentinel.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sentinel.c	2016-05-06 15:11:36.000000000 +0800
@@ -25,13 +25,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include "hiredis.h"
 #include "async.h"
 
 #include <ctype.h>
 #include <arpa/inet.h>
 #include <sys/socket.h>
@@ -51,25 +51,24 @@
 } sentinelAddr;
 
 /* A Sentinel Redis Instance object is monitoring. */
 #define SRI_MASTER  (1<<0)
 #define SRI_SLAVE   (1<<1)
 #define SRI_SENTINEL (1<<2)
-#define SRI_DISCONNECTED (1<<3)
-#define SRI_S_DOWN (1<<4)   /* Subjectively down (no quorum). */
-#define SRI_O_DOWN (1<<5)   /* Objectively down (confirmed by others). */
-#define SRI_MASTER_DOWN (1<<6) /* A Sentinel with this flag set thinks that
+#define SRI_S_DOWN (1<<3)   /* Subjectively down (no quorum). */
+#define SRI_O_DOWN (1<<4)   /* Objectively down (confirmed by others). */
+#define SRI_MASTER_DOWN (1<<5) /* A Sentinel with this flag set thinks that
                                    its master is down. */
-#define SRI_FAILOVER_IN_PROGRESS (1<<7) /* Failover is in progress for
+#define SRI_FAILOVER_IN_PROGRESS (1<<6) /* Failover is in progress for
                                            this master. */
-#define SRI_PROMOTED (1<<8)            /* Slave selected for promotion. */
-#define SRI_RECONF_SENT (1<<9)     /* SLAVEOF <newmaster> sent. */
-#define SRI_RECONF_INPROG (1<<10)   /* Slave synchronization in progress. */
-#define SRI_RECONF_DONE (1<<11)     /* Slave synchronized with new master. */
-#define SRI_FORCE_FAILOVER (1<<12)  /* Force failover with master up. */
-#define SRI_SCRIPT_KILL_SENT (1<<13) /* SCRIPT KILL already sent on -BUSY */
+#define SRI_PROMOTED (1<<7)            /* Slave selected for promotion. */
+#define SRI_RECONF_SENT (1<<8)     /* SLAVEOF <newmaster> sent. */
+#define SRI_RECONF_INPROG (1<<9)   /* Slave synchronization in progress. */
+#define SRI_RECONF_DONE (1<<10)     /* Slave synchronized with new master. */
+#define SRI_FORCE_FAILOVER (1<<11)  /* Force failover with master up. */
+#define SRI_SCRIPT_KILL_SENT (1<<12) /* SCRIPT KILL already sent on -BUSY */
 
 /* Note: times are in milliseconds. */
 #define SENTINEL_INFO_PERIOD 10000
 #define SENTINEL_PING_PERIOD 1000
 #define SENTINEL_ASK_PERIOD 1000
 #define SENTINEL_PUBLISH_PERIOD 2000
@@ -112,33 +111,65 @@
 #define SENTINEL_SCRIPT_MAX_QUEUE 256
 #define SENTINEL_SCRIPT_MAX_RUNNING 16
 #define SENTINEL_SCRIPT_MAX_RUNTIME 60000 /* 60 seconds max exec time. */
 #define SENTINEL_SCRIPT_MAX_RETRY 10
 #define SENTINEL_SCRIPT_RETRY_DELAY 30000 /* 30 seconds between retries. */
 
-typedef struct sentinelRedisInstance {
-    int flags;      /* See SRI_... defines */
-    char *name;     /* Master name from the point of view of this sentinel. */
-    char *runid;    /* run ID of this instance. */
-    uint64_t config_epoch;  /* Configuration epoch. */
-    sentinelAddr *addr; /* Master host. */
+/* SENTINEL SIMULATE-FAILURE command flags. */
+#define SENTINEL_SIMFAILURE_NONE 0
+#define SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION (1<<0)
+#define SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION (1<<1)
+
+/* The link to a sentinelRedisInstance. When we have the same set of Sentinels
+ * monitoring many masters, we have different instances representing the
+ * same Sentinels, one per master, and we need to share the hiredis connections
+ * among them. Oherwise if 5 Sentinels are monitoring 100 masters we create
+ * 500 outgoing connections instead of 5.
+ *
+ * So this structure represents a reference counted link in terms of the two
+ * hiredis connections for commands and Pub/Sub, and the fields needed for
+ * failure detection, since the ping/pong time are now local to the link: if
+ * the link is available, the instance is avaialbe. This way we don't just
+ * have 5 connections instead of 500, we also send 5 pings instead of 500.
+ *
+ * Links are shared only for Sentinels: master and slave instances have
+ * a link with refcount = 1, always. */
+typedef struct instanceLink {
+    int refcount;          /* Number of sentinelRedisInstance owners. */
+    int disconnected;      /* Non-zero if we need to reconnect cc or pc. */
+    int pending_commands;  /* Number of commands sent waiting for a reply. */
     redisAsyncContext *cc; /* Hiredis context for commands. */
     redisAsyncContext *pc; /* Hiredis context for Pub / Sub. */
-    int pending_commands;   /* Number of commands sent waiting for a reply. */
     mstime_t cc_conn_time; /* cc connection time. */
     mstime_t pc_conn_time; /* pc connection time. */
     mstime_t pc_last_activity; /* Last time we received any message. */
     mstime_t last_avail_time; /* Last time the instance replied to ping with
                                  a reply we consider valid. */
-    mstime_t last_ping_time;  /* Last time a pending ping was sent in the
-                                 context of the current command connection
-                                 with the instance. 0 if still not sent or
-                                 if pong already received. */
+    mstime_t act_ping_time;   /* Time at which the last pending ping (no pong
+                                 received after it) was sent. This field is
+                                 set to 0 when a pong is received, and set again
+                                 to the current time if the value is 0 and a new
+                                 ping is sent. */
+    mstime_t last_ping_time;  /* Time at which we sent the last ping. This is
+                                 only used to avoid sending too many pings
+                                 during failure. Idle time is computed using
+                                 the act_ping_time field. */
     mstime_t last_pong_time;  /* Last time the instance replied to ping,
                                  whatever the reply was. That's used to check
                                  if the link is idle and must be reconnected. */
+    mstime_t last_reconn_time;  /* Last reconnection attempt performed when
+                                   the link was down. */
+} instanceLink;
+
+typedef struct sentinelRedisInstance {
+    int flags;      /* See SRI_... defines */
+    char *name;     /* Master name from the point of view of this sentinel. */
+    char *runid;    /* Run ID of this instance, or unique ID if is a Sentinel.*/
+    uint64_t config_epoch;  /* Configuration epoch. */
+    sentinelAddr *addr; /* Master host. */
+    instanceLink *link; /* Link to the instance, may be shared for Sentinels. */
     mstime_t last_pub_time;   /* Last time we sent hello via Pub/Sub. */
     mstime_t last_hello_time; /* Only used if SRI_SENTINEL is set. Last time
                                  we received a hello from this Sentinel
                                  via Pub/Sub. */
     mstime_t last_master_down_reply_time; /* Time of last reply to
                                              SENTINEL is-master-down command. */
@@ -187,29 +218,32 @@
                                        logged the failover delay. */
     struct sentinelRedisInstance *promoted_slave; /* Promoted slave instance. */
     /* Scripts executed to notify admin or reconfigure clients: when they
      * are set to NULL no script is executed. */
     char *notification_script;
     char *client_reconfig_script;
+    sds info; /* cached INFO output */
 } sentinelRedisInstance;
 
 /* Main state. */
 struct sentinelState {
-    uint64_t current_epoch;     /* Current epoch. */
+    char myid[CONFIG_RUN_ID_SIZE+1]; /* This sentinel ID. */
+    uint64_t current_epoch;         /* Current epoch. */
     dict *masters;      /* Dictionary of master sentinelRedisInstances.
                            Key is the instance name, value is the
                            sentinelRedisInstance structure pointer. */
     int tilt;           /* Are we in TILT mode? */
     int running_scripts;    /* Number of scripts in execution right now. */
-    mstime_t tilt_start_time;   /* When TITL started. */
-    mstime_t previous_time;     /* Last time we ran the time handler. */
-    list *scripts_queue;    /* Queue of user scripts to execute. */
-    char *announce_ip;      /* IP addr that is gossiped to other sentinels if
-                               not NULL. */
-    int announce_port;      /* Port that is gossiped to other sentinels if
-                               non zero. */
+    mstime_t tilt_start_time;       /* When TITL started. */
+    mstime_t previous_time;         /* Last time we ran the time handler. */
+    list *scripts_queue;            /* Queue of user scripts to execute. */
+    char *announce_ip;  /* IP addr that is gossiped to other sentinels if
+                           not NULL. */
+    int announce_port;  /* Port that is gossiped to other sentinels if
+                           non zero. */
+    unsigned long simfailure_flags; /* Failures simulation. */
 } sentinel;
 
 /* A script execution job. */
 typedef struct sentinelScriptJob {
     int flags;              /* Script job flags: SENTINEL_SCRIPT_* */
     int retry_num;          /* Number of times we tried to execute it. */
@@ -294,13 +328,13 @@
 static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
     redisContext *c = &(ac->c);
     redisAeEvents *e;
 
     /* Nothing should be attached when something is already attached */
     if (ac->ev.data != NULL)
-        return REDIS_ERR;
+        return C_ERR;
 
     /* Create container for context and r/w events */
     e = (redisAeEvents*)zmalloc(sizeof(*e));
     e->context = ac;
     e->loop = loop;
     e->fd = c->fd;
@@ -311,26 +345,25 @@
     ac->ev.delRead = redisAeDelRead;
     ac->ev.addWrite = redisAeAddWrite;
     ac->ev.delWrite = redisAeDelWrite;
     ac->ev.cleanup = redisAeCleanup;
     ac->ev.data = e;
 
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* ============================= Prototypes ================================= */
 
 void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status);
 void sentinelDisconnectCallback(const redisAsyncContext *c, int status);
 void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata);
 sentinelRedisInstance *sentinelGetMasterByName(char *name);
 char *sentinelGetSubjectiveLeader(sentinelRedisInstance *master);
 char *sentinelGetObjectiveLeader(sentinelRedisInstance *master);
 int yesnotoi(char *s);
-void sentinelDisconnectInstanceFromContext(const redisAsyncContext *c);
-void sentinelKillLink(sentinelRedisInstance *ri, redisAsyncContext *c);
+void instanceLinkConnectionError(const redisAsyncContext *c);
 const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri);
 void sentinelAbortFailover(sentinelRedisInstance *ri);
 void sentinelEvent(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...);
 sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master);
 void sentinelScheduleScriptExecution(char *path, ...);
 void sentinelStartFailover(sentinelRedisInstance *master);
@@ -338,21 +371,23 @@
 int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port);
 char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch);
 void sentinelFlushConfig(void);
 void sentinelGenerateInitialMonitorEvents(void);
 int sentinelSendPing(sentinelRedisInstance *ri);
 int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master);
+sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid);
+void sentinelSimFailureCrash(void);
 
 /* ========================= Dictionary types =============================== */
 
 unsigned int dictSdsHash(const void *key);
 int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
 void releaseSentinelRedisInstance(sentinelRedisInstance *ri);
 
 void dictInstancesValDestructor (void *privdata, void *obj) {
-    REDIS_NOTUSED(privdata);
+    UNUSED(privdata);
     releaseSentinelRedisInstance(obj);
 }
 
 /* Instance name (sds) -> instance (sentinelRedisInstance pointer)
  *
  * also used for: sentinelRedisInstance->sentinels dictionary that maps
@@ -378,17 +413,17 @@
     NULL,                      /* key destructor */
     NULL                       /* val destructor */
 };
 
 /* =========================== Initialization =============================== */
 
-void sentinelCommand(redisClient *c);
-void sentinelInfoCommand(redisClient *c);
-void sentinelSetCommand(redisClient *c);
-void sentinelPublishCommand(redisClient *c);
-void sentinelRoleCommand(redisClient *c);
+void sentinelCommand(client *c);
+void sentinelInfoCommand(client *c);
+void sentinelSetCommand(client *c);
+void sentinelPublishCommand(client *c);
+void sentinelRoleCommand(client *c);
 
 struct redisCommand sentinelcmds[] = {
     {"ping",pingCommand,1,"",0,NULL,0,0,0,0,0},
     {"sentinel",sentinelCommand,-2,"",0,NULL,0,0,0,0,0},
     {"subscribe",subscribeCommand,-2,"",0,NULL,0,0,0,0,0},
     {"unsubscribe",unsubscribeCommand,-1,"",0,NULL,0,0,0,0,0},
@@ -416,43 +451,60 @@
     dictEmpty(server.commands,NULL);
     for (j = 0; j < sizeof(sentinelcmds)/sizeof(sentinelcmds[0]); j++) {
         int retval;
         struct redisCommand *cmd = sentinelcmds+j;
 
         retval = dictAdd(server.commands, sdsnew(cmd->name), cmd);
-        redisAssert(retval == DICT_OK);
+        serverAssert(retval == DICT_OK);
     }
 
     /* Initialize various data structures. */
     sentinel.current_epoch = 0;
     sentinel.masters = dictCreate(&instancesDictType,NULL);
     sentinel.tilt = 0;
     sentinel.tilt_start_time = 0;
     sentinel.previous_time = mstime();
     sentinel.running_scripts = 0;
     sentinel.scripts_queue = listCreate();
     sentinel.announce_ip = NULL;
     sentinel.announce_port = 0;
+    sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
+    memset(sentinel.myid,0,sizeof(sentinel.myid));
 }
 
 /* This function gets called when the server is in Sentinel mode, started,
  * loaded the configuration, and is ready for normal operations. */
 void sentinelIsRunning(void) {
-    redisLog(REDIS_WARNING,"Sentinel runid is %s", server.runid);
+    int j;
 
     if (server.configfile == NULL) {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Sentinel started without a config file. Exiting...");
         exit(1);
     } else if (access(server.configfile,W_OK) == -1) {
-        redisLog(REDIS_WARNING,
+        serverLog(LL_WARNING,
             "Sentinel config file %s is not writable: %s. Exiting...",
             server.configfile,strerror(errno));
         exit(1);
     }
 
+    /* If this Sentinel has yet no ID set in the configuration file, we
+     * pick a random one and persist the config on disk. From now on this
+     * will be this Sentinel ID across restarts. */
+    for (j = 0; j < CONFIG_RUN_ID_SIZE; j++)
+        if (sentinel.myid[j] != 0) break;
+
+    if (j == CONFIG_RUN_ID_SIZE) {
+        /* Pick ID and presist the config. */
+        getRandomHexChars(sentinel.myid,CONFIG_RUN_ID_SIZE);
+        sentinelFlushConfig();
+    }
+
+    /* Log its ID to make debugging of issues simpler. */
+    serverLog(LL_WARNING,"Sentinel ID is %s", sentinel.myid);
+
     /* We want to generate a +monitor event for every configured master
      * at startup. */
     sentinelGenerateInitialMonitorEvents();
 }
 
 /* ============================== sentinelAddr ============================== */
@@ -460,16 +512,16 @@
 /* Create a sentinelAddr object and return it on success.
  * On error NULL is returned and errno is set to:
  *  ENOENT: Can't resolve the hostname.
  *  EINVAL: Invalid port number.
  */
 sentinelAddr *createSentinelAddr(char *hostname, int port) {
-    char ip[REDIS_IP_STR_LEN];
+    char ip[NET_IP_STR_LEN];
     sentinelAddr *sa;
 
-    if (port <= 0 || port > 65535) {
+    if (port < 0 || port > 65535) {
         errno = EINVAL;
         return NULL;
     }
     if (anetResolve(NULL,hostname,ip,sizeof(ip)) == ANET_ERR) {
         errno = ENOENT;
         return NULL;
@@ -502,13 +554,13 @@
 }
 
 /* =========================== Events notification ========================== */
 
 /* Send an event to log, pub/sub, user notification script.
  *
- * 'level' is the log level for logging. Only REDIS_WARNING events will trigger
+ * 'level' is the log level for logging. Only LL_WARNING events will trigger
  * the execution of the user notification script.
  *
  * 'type' is the message type, also used as a pub/sub channel name.
  *
  * 'ri', is the redis instance target of this event if applicable, and is
  * used to obtain the path of the notification script to execute.
@@ -527,13 +579,13 @@
  *
  *  Any other specifier after "%@" is processed by printf itself.
  */
 void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
                    const char *fmt, ...) {
     va_list ap;
-    char msg[REDIS_MAX_LOGMSG_LEN];
+    char msg[LOG_MAX_LEN];
     robj *channel, *payload;
 
     /* Handle %@ */
     if (fmt[0] == '%' && fmt[1] == '@') {
         sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ?
                                          NULL : ri->master;
@@ -559,28 +611,28 @@
         vsnprintf(msg+strlen(msg), sizeof(msg)-strlen(msg), fmt, ap);
         va_end(ap);
     }
 
     /* Log the message if the log level allows it to be logged. */
     if (level >= server.verbosity)
-        redisLog(level,"%s %s",type,msg);
+        serverLog(level,"%s %s",type,msg);
 
     /* Publish the message via Pub/Sub if it's not a debugging one. */
-    if (level != REDIS_DEBUG) {
+    if (level != LL_DEBUG) {
         channel = createStringObject(type,strlen(type));
         payload = createStringObject(msg,strlen(msg));
         pubsubPublishMessage(channel,payload);
         decrRefCount(channel);
         decrRefCount(payload);
     }
 
     /* Call the notification script if applicable. */
-    if (level == REDIS_WARNING && ri != NULL) {
+    if (level == LL_WARNING && ri != NULL) {
         sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ?
                                          ri : ri->master;
-        if (master->notification_script) {
+        if (master && master->notification_script) {
             sentinelScheduleScriptExecution(master->notification_script,
                 type,msg,NULL);
         }
     }
 }
 
@@ -592,13 +644,13 @@
     dictIterator *di;
     dictEntry *de;
 
     di = dictGetIterator(sentinel.masters);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *ri = dictGetVal(de);
-        sentinelEvent(REDIS_WARNING,"+monitor",ri,"%@ quorum %d",ri->quorum);
+        sentinelEvent(LL_WARNING,"+monitor",ri,"%@ quorum %d",ri->quorum);
     }
     dictReleaseIterator(di);
 }
 
 /* ============================ script execution ============================ */
 
@@ -650,13 +702,13 @@
             if (sj->flags & SENTINEL_SCRIPT_RUNNING) continue;
             /* The first node is the oldest as we add on tail. */
             listDelNode(sentinel.scripts_queue,ln);
             sentinelReleaseScriptJob(sj);
             break;
         }
-        redisAssert(listLength(sentinel.scripts_queue) <=
+        serverAssert(listLength(sentinel.scripts_queue) <=
                     SENTINEL_SCRIPT_MAX_QUEUE);
     }
 }
 
 /* Lookup a script in the scripts queue via pid, and returns the list node
  * (so that we can easily remove it from the queue if needed). */
@@ -702,25 +754,25 @@
         pid = fork();
 
         if (pid == -1) {
             /* Parent (fork error).
              * We report fork errors as signal 99, in order to unify the
              * reporting with other kind of errors. */
-            sentinelEvent(REDIS_WARNING,"-script-error",NULL,
+            sentinelEvent(LL_WARNING,"-script-error",NULL,
                           "%s %d %d", sj->argv[0], 99, 0);
             sj->flags &= ~SENTINEL_SCRIPT_RUNNING;
             sj->pid = 0;
         } else if (pid == 0) {
             /* Child */
             execve(sj->argv[0],sj->argv,environ);
             /* If we are here an error occurred. */
             _exit(2); /* Don't retry execution. */
         } else {
             sentinel.running_scripts++;
             sj->pid = pid;
-            sentinelEvent(REDIS_DEBUG,"+script-child",NULL,"%ld",(long)pid);
+            sentinelEvent(LL_DEBUG,"+script-child",NULL,"%ld",(long)pid);
         }
     }
 }
 
 /* How much to delay the execution of a script that we need to retry after
  * an error?
@@ -748,18 +800,18 @@
         int exitcode = WEXITSTATUS(statloc);
         int bysignal = 0;
         listNode *ln;
         sentinelScriptJob *sj;
 
         if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
-        sentinelEvent(REDIS_DEBUG,"-script-child",NULL,"%ld %d %d",
+        sentinelEvent(LL_DEBUG,"-script-child",NULL,"%ld %d %d",
             (long)pid, exitcode, bysignal);
 
         ln = sentinelGetScriptListNodeByPid(pid);
         if (ln == NULL) {
-            redisLog(REDIS_WARNING,"wait3() returned a pid (%ld) we can't find in our scripts execution queue!", (long)pid);
+            serverLog(LL_WARNING,"wait3() returned a pid (%ld) we can't find in our scripts execution queue!", (long)pid);
             continue;
         }
         sj = ln->value;
 
         /* If the script was terminated by a signal or returns an
          * exit code of "1" (that means: please retry), we reschedule it
@@ -772,13 +824,13 @@
             sj->start_time = mstime() +
                              sentinelScriptRetryDelay(sj->retry_num);
         } else {
             /* Otherwise let's remove the script, but log the event if the
              * execution did not terminated in the best of the ways. */
             if (bysignal || exitcode != 0) {
-                sentinelEvent(REDIS_WARNING,"-script-error",NULL,
+                sentinelEvent(LL_WARNING,"-script-error",NULL,
                               "%s %d %d", sj->argv[0], bysignal, exitcode);
             }
             listDelNode(sentinel.scripts_queue,ln);
             sentinelReleaseScriptJob(sj);
             sentinel.running_scripts--;
         }
@@ -796,21 +848,21 @@
     while ((ln = listNext(&li)) != NULL) {
         sentinelScriptJob *sj = ln->value;
 
         if (sj->flags & SENTINEL_SCRIPT_RUNNING &&
             (now - sj->start_time) > SENTINEL_SCRIPT_MAX_RUNTIME)
         {
-            sentinelEvent(REDIS_WARNING,"-script-timeout",NULL,"%s %ld",
+            sentinelEvent(LL_WARNING,"-script-timeout",NULL,"%s %ld",
                 sj->argv[0], (long)sj->pid);
             kill(sj->pid,SIGKILL);
         }
     }
 }
 
 /* Implements SENTINEL PENDING-SCRIPTS command. */
-void sentinelPendingScriptsCommand(redisClient *c) {
+void sentinelPendingScriptsCommand(client *c) {
     listNode *ln;
     listIter li;
 
     addReplyMultiBulkLen(c,listLength(sentinel.scripts_queue));
     listRewind(sentinel.scripts_queue,&li);
     while ((ln = listNext(&li)) != NULL) {
@@ -868,12 +920,200 @@
     sentinelScheduleScriptExecution(master->client_reconfig_script,
         master->name,
         (role == SENTINEL_LEADER) ? "leader" : "observer",
         state, from->ip, fromport, to->ip, toport, NULL);
 }
 
+/* =============================== instanceLink ============================= */
+
+/* Create a not yet connected link object. */
+instanceLink *createInstanceLink(void) {
+    instanceLink *link = zmalloc(sizeof(*link));
+
+    link->refcount = 1;
+    link->disconnected = 1;
+    link->pending_commands = 0;
+    link->cc = NULL;
+    link->pc = NULL;
+    link->cc_conn_time = 0;
+    link->pc_conn_time = 0;
+    link->last_reconn_time = 0;
+    link->pc_last_activity = 0;
+    /* We set the act_ping_time to "now" even if we actually don't have yet
+     * a connection with the node, nor we sent a ping.
+     * This is useful to detect a timeout in case we'll not be able to connect
+     * with the node at all. */
+    link->act_ping_time = mstime();
+    link->last_ping_time = 0;
+    link->last_avail_time = mstime();
+    link->last_pong_time = mstime();
+    return link;
+}
+
+/* Disconnect an hiredis connection in the context of an instance link. */
+void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
+    if (c == NULL) return;
+
+    if (link->cc == c) {
+        link->cc = NULL;
+        link->pending_commands = 0;
+    }
+    if (link->pc == c) link->pc = NULL;
+    c->data = NULL;
+    link->disconnected = 1;
+    redisAsyncFree(c);
+}
+
+/* Decrement the refcount of a link object, if it drops to zero, actually
+ * free it and return NULL. Otherwise don't do anything and return the pointer
+ * to the object.
+ *
+ * If we are not going to free the link and ri is not NULL, we rebind all the
+ * pending requests in link->cc (hiredis connection for commands) to a
+ * callback that will just ignore them. This is useful to avoid processing
+ * replies for an instance that no longer exists. */
+instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
+{
+    serverAssert(link->refcount > 0);
+    link->refcount--;
+    if (link->refcount != 0) {
+        if (ri && ri->link->cc) {
+            /* This instance may have pending callbacks in the hiredis async
+             * context, having as 'privdata' the instance that we are going to
+             * free. Let's rewrite the callback list, directly exploiting
+             * hiredis internal data structures, in order to bind them with
+             * a callback that will ignore the reply at all. */
+            redisCallback *cb;
+            redisCallbackList *callbacks = &link->cc->replies;
+
+            cb = callbacks->head;
+            while(cb) {
+                if (cb->privdata == ri) {
+                    cb->fn = sentinelDiscardReplyCallback;
+                    cb->privdata = NULL; /* Not strictly needed. */
+                }
+                cb = cb->next;
+            }
+        }
+        return link; /* Other active users. */
+    }
+
+    instanceLinkCloseConnection(link,link->cc);
+    instanceLinkCloseConnection(link,link->pc);
+    zfree(link);
+    return NULL;
+}
+
+/* This function will attempt to share the instance link we already have
+ * for the same Sentinel in the context of a different master, with the
+ * instance we are passing as argument.
+ *
+ * This way multiple Sentinel objects that refer all to the same physical
+ * Sentinel instance but in the context of different masters will use
+ * a single connection, will send a single PING per second for failure
+ * detection and so forth.
+ *
+ * Return C_OK if a matching Sentinel was found in the context of a
+ * different master and sharing was performed. Otherwise C_ERR
+ * is returned. */
+int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
+    serverAssert(ri->flags & SRI_SENTINEL);
+    dictIterator *di;
+    dictEntry *de;
+
+    if (ri->runid == NULL) return C_ERR; /* No way to identify it. */
+    if (ri->link->refcount > 1) return C_ERR; /* Already shared. */
+
+    di = dictGetIterator(sentinel.masters);
+    while((de = dictNext(di)) != NULL) {
+        sentinelRedisInstance *master = dictGetVal(de), *match;
+        /* We want to share with the same physical Sentinel referenced
+         * in other masters, so skip our master. */
+        if (master == ri->master) continue;
+        match = getSentinelRedisInstanceByAddrAndRunID(master->sentinels,
+                                                       NULL,0,ri->runid);
+        if (match == NULL) continue; /* No match. */
+        if (match == ri) continue; /* Should never happen but... safer. */
+
+        /* We identified a matching Sentinel, great! Let's free our link
+         * and use the one of the matching Sentinel. */
+        releaseInstanceLink(ri->link,NULL);
+        ri->link = match->link;
+        match->link->refcount++;
+        return C_OK;
+    }
+    dictReleaseIterator(di);
+    return C_ERR;
+}
+
+/* When we detect a Sentinel to switch address (reporting a different IP/port
+ * pair in Hello messages), let's update all the matching Sentinels in the
+ * context of other masters as well and disconnect the links, so that everybody
+ * will be updated.
+ *
+ * Return the number of updated Sentinel addresses. */
+int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
+    serverAssert(ri->flags & SRI_SENTINEL);
+    dictIterator *di;
+    dictEntry *de;
+    int reconfigured = 0;
+
+    di = dictGetIterator(sentinel.masters);
+    while((de = dictNext(di)) != NULL) {
+        sentinelRedisInstance *master = dictGetVal(de), *match;
+        match = getSentinelRedisInstanceByAddrAndRunID(master->sentinels,
+                                                       NULL,0,ri->runid);
+        if (match->link->disconnected == 0) {
+            instanceLinkCloseConnection(match->link,match->link->cc);
+            instanceLinkCloseConnection(match->link,match->link->pc);
+        }
+        if (match == ri) continue; /* Address already updated for it. */
+        /* Update the address of the matching Sentinel by copying the address
+         * of the Sentinel object that received the address update. */
+        releaseSentinelAddr(match->addr);
+        match->addr = dupSentinelAddr(ri->addr);
+        reconfigured++;
+    }
+    dictReleaseIterator(di);
+    if (reconfigured)
+        sentinelEvent(LL_NOTICE,"+sentinel-address-update", ri,
+                    "%@ %d additional matching instances", reconfigured);
+    return reconfigured;
+}
+
+/* This function is called when an hiredis connection reported an error.
+ * We set it to NULL and mark the link as disconnected so that it will be
+ * reconnected again.
+ *
+ * Note: we don't free the hiredis context as hiredis will do it for us
+ * for async connections. */
+void instanceLinkConnectionError(const redisAsyncContext *c) {
+    instanceLink *link = c->data;
+    int pubsub;
+
+    if (!link) return;
+
+    pubsub = (link->pc == c);
+    if (pubsub)
+        link->pc = NULL;
+    else
+        link->cc = NULL;
+    link->disconnected = 1;
+}
+
+/* Hiredis connection established / disconnected callbacks. We need them
+ * just to cleanup our link state. */
+void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {
+    if (status != C_OK) instanceLinkConnectionError(c);
+}
+
+void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
+    UNUSED(status);
+    instanceLinkConnectionError(c);
+}
+
 /* ========================== sentinelRedisInstance ========================= */
 
 /* Create a redis instance, the following fields must be populated by the
  * caller if needed:
  * runid: set to NULL but will be populated once INFO output is received.
  * info_refresh: is set to 0 to mean that we never received INFO so far.
@@ -889,31 +1129,31 @@
  *
  * The function fails if hostname can't be resolved or port is out of range.
  * When this happens NULL is returned and errno is set accordingly to the
  * createSentinelAddr() function.
  *
  * The function may also fail and return NULL with errno set to EBUSY if
- * a master or slave with the same name already exists. */
+ * a master with the same name, a slave with the same address, or a sentinel
+ * with the same ID already exists. */
+
 sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {
     sentinelRedisInstance *ri;
     sentinelAddr *addr;
     dict *table = NULL;
-    char slavename[128], *sdsname;
+    char slavename[NET_PEER_ID_LEN], *sdsname;
 
-    redisAssert(flags & (SRI_MASTER|SRI_SLAVE|SRI_SENTINEL));
-    redisAssert((flags & SRI_MASTER) || master != NULL);
+    serverAssert(flags & (SRI_MASTER|SRI_SLAVE|SRI_SENTINEL));
+    serverAssert((flags & SRI_MASTER) || master != NULL);
 
     /* Check address validity. */
     addr = createSentinelAddr(hostname,port);
     if (addr == NULL) return NULL;
 
-    /* For slaves and sentinel we use ip:port as name. */
-    if (flags & (SRI_SLAVE|SRI_SENTINEL)) {
-        snprintf(slavename,sizeof(slavename),
-            strchr(hostname,':') ? "[%s]:%d" : "%s:%d",
-            hostname,port);
+    /* For slaves use ip:port as name. */
+    if (flags & SRI_SLAVE) {
+        anetFormatAddr(slavename, sizeof(slavename), hostname, port);
         name = slavename;
     }
 
     /* Make sure the entry is not duplicated. This may happen when the same
      * name for a master is used multiple times inside the configuration or
      * if we try to add multiple times a slave or sentinel with same ip/port
@@ -930,30 +1170,18 @@
     }
 
     /* Create the instance object. */
     ri = zmalloc(sizeof(*ri));
     /* Note that all the instances are started in the disconnected state,
      * the event loop will take care of connecting them. */
-    ri->flags = flags | SRI_DISCONNECTED;
+    ri->flags = flags;
     ri->name = sdsname;
     ri->runid = NULL;
     ri->config_epoch = 0;
     ri->addr = addr;
-    ri->cc = NULL;
-    ri->pc = NULL;
-    ri->pending_commands = 0;
-    ri->cc_conn_time = 0;
-    ri->pc_conn_time = 0;
-    ri->pc_last_activity = 0;
-    /* We set the last_ping_time to "now" even if we actually don't have yet
-     * a connection with the node, nor we sent a ping.
-     * This is useful to detect a timeout in case we'll not be able to connect
-     * with the node at all. */
-    ri->last_ping_time = mstime();
-    ri->last_avail_time = mstime();
-    ri->last_pong_time = mstime();
+    ri->link = createInstanceLink();
     ri->last_pub_time = mstime();
     ri->last_hello_time = mstime();
     ri->last_master_down_reply_time = mstime();
     ri->s_down_since_time = 0;
     ri->o_down_since_time = 0;
     ri->down_after_period = master ? master->down_after_period :
@@ -982,12 +1210,13 @@
     ri->failover_start_time = 0;
     ri->failover_timeout = SENTINEL_DEFAULT_FAILOVER_TIMEOUT;
     ri->failover_delay_logged = 0;
     ri->promoted_slave = NULL;
     ri->notification_script = NULL;
     ri->client_reconfig_script = NULL;
+    ri->info = NULL;
 
     /* Role */
     ri->role_reported = ri->flags & (SRI_MASTER|SRI_SLAVE);
     ri->role_reported_time = mstime();
     ri->slave_conf_change_time = mstime();
 
@@ -1002,24 +1231,24 @@
  * if it is a slave or sentinel. */
 void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {
     /* Release all its slaves or sentinels if any. */
     dictRelease(ri->sentinels);
     dictRelease(ri->slaves);
 
-    /* Release hiredis connections. */
-    if (ri->cc) sentinelKillLink(ri,ri->cc);
-    if (ri->pc) sentinelKillLink(ri,ri->pc);
+    /* Disconnect the instance. */
+    releaseInstanceLink(ri->link,ri);
 
     /* Free other resources. */
     sdsfree(ri->name);
     sdsfree(ri->runid);
     sdsfree(ri->notification_script);
     sdsfree(ri->client_reconfig_script);
     sdsfree(ri->slave_master_host);
     sdsfree(ri->leader);
     sdsfree(ri->auth_pass);
+    sdsfree(ri->info);
     releaseSentinelAddr(ri->addr);
 
     /* Clear state into the master if needed. */
     if ((ri->flags & SRI_SLAVE) && (ri->flags & SRI_PROMOTED) && ri->master)
         ri->master->promoted_slave = NULL;
 
@@ -1029,17 +1258,17 @@
 /* Lookup a slave in a master Redis instance, by ip and port. */
 sentinelRedisInstance *sentinelRedisInstanceLookupSlave(
                 sentinelRedisInstance *ri, char *ip, int port)
 {
     sds key;
     sentinelRedisInstance *slave;
+    char buf[NET_PEER_ID_LEN];
 
-    redisAssert(ri->flags & SRI_MASTER);
-    key = sdscatprintf(sdsempty(),
-        strchr(ip,':') ? "[%s]:%d" : "%s:%d",
-        ip,port);
+    serverAssert(ri->flags & SRI_MASTER);
+    anetFormatAddr(buf,sizeof(buf),ip,port);
+    key = sdsnew(buf);
     slave = dictFetchValue(ri->slaves,key);
     sdsfree(key);
     return slave;
 }
 
 /* Return the name of the type of the instance as a string. */
@@ -1047,41 +1276,35 @@
     if (ri->flags & SRI_MASTER) return "master";
     else if (ri->flags & SRI_SLAVE) return "slave";
     else if (ri->flags & SRI_SENTINEL) return "sentinel";
     else return "unknown";
 }
 
-/* This function removes all the instances found in the dictionary of
- * sentinels in the specified 'master', having either:
- *
- * 1) The same ip/port as specified.
- * 2) The same runid.
+/* This function remove the Sentinel with the specified ID from the
+ * specified master.
  *
- * "1" and "2" don't need to verify at the same time, just one is enough.
- * If "runid" is NULL it is not checked.
- * Similarly if "ip" is NULL it is not checked.
- *
- * This function is useful because every time we add a new Sentinel into
- * a master's Sentinels dictionary, we want to be very sure about not
- * having duplicated instances for any reason. This is important because
- * other sentinels are needed to reach ODOWN quorum, and later to get
- * voted for a given configuration epoch in order to perform the failover.
+ * If "runid" is NULL the function returns ASAP.
  *
- * The function returns the number of Sentinels removed. */
-int removeMatchingSentinelsFromMaster(sentinelRedisInstance *master, char *ip, int port, char *runid) {
+ * This function is useful because on Sentinels address switch, we want to
+ * remove our old entry and add a new one for the same ID but with the new
+ * address.
+ *
+ * The function returns 1 if the matching Sentinel was removed, otherwise
+ * 0 if there was no Sentinel with this ID. */
+int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid) {
     dictIterator *di;
     dictEntry *de;
     int removed = 0;
 
+    if (runid == NULL) return 0;
+
     di = dictGetSafeIterator(master->sentinels);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *ri = dictGetVal(de);
 
-        if ((ri->runid && runid && strcmp(ri->runid,runid) == 0) ||
-            (ip && strcmp(ri->addr->ip,ip) == 0 && port == ri->addr->port))
-        {
+        if (ri->runid && strcmp(ri->runid,runid) == 0) {
             dictDelete(master->sentinels,ri->name);
             removed++;
         }
     }
     dictReleaseIterator(di);
     return removed;
@@ -1095,13 +1318,13 @@
  * by the non-NULL field. */
 sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid) {
     dictIterator *di;
     dictEntry *de;
     sentinelRedisInstance *instance = NULL;
 
-    redisAssert(ip || runid);   /* User must pass at least one search param. */
+    serverAssert(ip || runid);   /* User must pass at least one search param. */
     di = dictGetIterator(instances);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *ri = dictGetVal(de);
 
         if (runid && !ri->runid) continue;
         if ((runid == NULL || strcmp(ri->runid, runid) == 0) &&
@@ -1163,41 +1386,42 @@
  * 5) In the process of doing this undo the failover if in progress.
  * 6) Disconnect the connections with the master (will reconnect automatically).
  */
 
 #define SENTINEL_RESET_NO_SENTINELS (1<<0)
 void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
-    redisAssert(ri->flags & SRI_MASTER);
+    serverAssert(ri->flags & SRI_MASTER);
     dictRelease(ri->slaves);
     ri->slaves = dictCreate(&instancesDictType,NULL);
     if (!(flags & SENTINEL_RESET_NO_SENTINELS)) {
         dictRelease(ri->sentinels);
         ri->sentinels = dictCreate(&instancesDictType,NULL);
     }
-    if (ri->cc) sentinelKillLink(ri,ri->cc);
-    if (ri->pc) sentinelKillLink(ri,ri->pc);
-    ri->flags &= SRI_MASTER|SRI_DISCONNECTED;
+    instanceLinkCloseConnection(ri->link,ri->link->cc);
+    instanceLinkCloseConnection(ri->link,ri->link->pc);
+    ri->flags &= SRI_MASTER;
     if (ri->leader) {
         sdsfree(ri->leader);
         ri->leader = NULL;
     }
     ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
     ri->failover_state_change_time = 0;
     ri->failover_start_time = 0; /* We can failover again ASAP. */
     ri->promoted_slave = NULL;
     sdsfree(ri->runid);
     sdsfree(ri->slave_master_host);
     ri->runid = NULL;
     ri->slave_master_host = NULL;
-    ri->last_ping_time = mstime();
-    ri->last_avail_time = mstime();
-    ri->last_pong_time = mstime();
+    ri->link->act_ping_time = mstime();
+    ri->link->last_ping_time = 0;
+    ri->link->last_avail_time = mstime();
+    ri->link->last_pong_time = mstime();
     ri->role_reported_time = mstime();
     ri->role_reported = SRI_MASTER;
     if (flags & SENTINEL_GENERATE_EVENT)
-        sentinelEvent(REDIS_WARNING,"+reset-master",ri,"%@");
+        sentinelEvent(LL_WARNING,"+reset-master",ri,"%@");
 }
 
 /* Call sentinelResetMaster() on every master with a name matching the specified
  * pattern. */
 int sentinelResetMastersByPattern(char *pattern, int flags) {
     dictIterator *di;
@@ -1221,23 +1445,23 @@
 
 /* Reset the specified master with sentinelResetMaster(), and also change
  * the ip:port address, but take the name of the instance unmodified.
  *
  * This is used to handle the +switch-master event.
  *
- * The function returns REDIS_ERR if the address can't be resolved for some
- * reason. Otherwise REDIS_OK is returned.  */
+ * The function returns C_ERR if the address can't be resolved for some
+ * reason. Otherwise C_OK is returned.  */
 int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip, int port) {
     sentinelAddr *oldaddr, *newaddr;
     sentinelAddr **slaves = NULL;
     int numslaves = 0, j;
     dictIterator *di;
     dictEntry *de;
 
     newaddr = createSentinelAddr(ip,port);
-    if (newaddr == NULL) return REDIS_ERR;
+    if (newaddr == NULL) return C_ERR;
 
     /* Make a list of slaves to add back after the reset.
      * Don't include the one having the address we are switching to. */
     di = dictGetIterator(master->slaves);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *slave = dictGetVal(de);
@@ -1269,21 +1493,21 @@
     for (j = 0; j < numslaves; j++) {
         sentinelRedisInstance *slave;
 
         slave = createSentinelRedisInstance(NULL,SRI_SLAVE,slaves[j]->ip,
                     slaves[j]->port, master->quorum, master);
         releaseSentinelAddr(slaves[j]);
-        if (slave) sentinelEvent(REDIS_NOTICE,"+slave",slave,"%@");
+        if (slave) sentinelEvent(LL_NOTICE,"+slave",slave,"%@");
     }
     zfree(slaves);
 
     /* Release the old address at the end so we are safe even if the function
      * gets the master->addr->ip and master->addr->port as arguments. */
     releaseSentinelAddr(oldaddr);
     sentinelFlushConfig();
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* Return non-zero if there was no SDOWN or ODOWN error associated to this
  * instance in the latest 'ms' milliseconds. */
 int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {
     mstime_t most_recent;
@@ -1327,12 +1551,19 @@
             ri->down_after_period = master->down_after_period;
         }
         dictReleaseIterator(di);
     }
 }
 
+char *sentinelGetInstanceTypeString(sentinelRedisInstance *ri) {
+    if (ri->flags & SRI_MASTER) return "master";
+    else if (ri->flags & SRI_SLAVE) return "slave";
+    else if (ri->flags & SRI_SENTINEL) return "sentinel";
+    else return "unknown";
+}
+
 /* ============================ Config handling ============================= */
 char *sentinelHandleConfiguration(char **argv, int argc) {
     sentinelRedisInstance *ri;
 
     if (!strcasecmp(argv[0],"monitor") && argc == 5) {
         /* monitor <name> <host> <port> <quorum> */
@@ -1390,12 +1621,16 @@
         ri->auth_pass = sdsnew(argv[2]);
     } else if (!strcasecmp(argv[0],"current-epoch") && argc == 2) {
         /* current-epoch <epoch> */
         unsigned long long current_epoch = strtoull(argv[1],NULL,10);
         if (current_epoch > sentinel.current_epoch)
             sentinel.current_epoch = current_epoch;
+    } else if (!strcasecmp(argv[0],"myid") && argc == 2) {
+        if (strlen(argv[1]) != CONFIG_RUN_ID_SIZE)
+            return "Malformed Sentinel id in myid option.";
+        memcpy(sentinel.myid,argv[1],CONFIG_RUN_ID_SIZE);
     } else if (!strcasecmp(argv[0],"config-epoch") && argc == 3) {
         /* config-epoch <name> <epoch> */
         ri = sentinelGetMasterByName(argv[1]);
         if (!ri) return "No such master with specified name.";
         ri->config_epoch = strtoull(argv[2],NULL,10);
         /* The following update of current_epoch is not really useful as
@@ -1420,21 +1655,24 @@
             return "Wrong hostname or port for slave.";
         }
     } else if (!strcasecmp(argv[0],"known-sentinel") &&
                (argc == 4 || argc == 5)) {
         sentinelRedisInstance *si;
 
-        /* known-sentinel <name> <ip> <port> [runid] */
-        ri = sentinelGetMasterByName(argv[1]);
-        if (!ri) return "No such master with specified name.";
-        if ((si = createSentinelRedisInstance(NULL,SRI_SENTINEL,argv[2],
-                    atoi(argv[3]), ri->quorum, ri)) == NULL)
-        {
-            return "Wrong hostname or port for sentinel.";
+        if (argc == 5) { /* Ignore the old form without runid. */
+            /* known-sentinel <name> <ip> <port> [runid] */
+            ri = sentinelGetMasterByName(argv[1]);
+            if (!ri) return "No such master with specified name.";
+            if ((si = createSentinelRedisInstance(argv[4],SRI_SENTINEL,argv[2],
+                        atoi(argv[3]), ri->quorum, ri)) == NULL)
+            {
+                return "Wrong hostname or port for sentinel.";
+            }
+            si->runid = sdsnew(argv[4]);
+            sentinelTryConnectionSharing(si);
         }
-        if (argc == 5) si->runid = sdsnew(argv[4]);
     } else if (!strcasecmp(argv[0],"announce-ip") && argc == 2) {
         /* announce-ip <ip-address> */
         if (strlen(argv[1]))
             sentinel.announce_ip = sdsnew(argv[1]);
     } else if (!strcasecmp(argv[0],"announce-port") && argc == 2) {
         /* announce-port <port> */
@@ -1452,12 +1690,16 @@
  * and sentinel instances, and so forth. */
 void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
     dictIterator *di, *di2;
     dictEntry *de;
     sds line;
 
+    /* sentinel unique ID. */
+    line = sdscatprintf(sdsempty(), "sentinel myid %s", sentinel.myid);
+    rewriteConfigRewriteLine(state,"sentinel",line,1);
+
     /* For every master emit a "sentinel monitor" config entry. */
     di = dictGetIterator(sentinel.masters);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *master, *ri;
         sentinelAddr *master_addr;
 
@@ -1552,17 +1794,16 @@
         dictReleaseIterator(di2);
 
         /* sentinel known-sentinel */
         di2 = dictGetIterator(master->sentinels);
         while((de = dictNext(di2)) != NULL) {
             ri = dictGetVal(de);
+            if (ri->runid == NULL) continue;
             line = sdscatprintf(sdsempty(),
-                "sentinel known-sentinel %s %s %d%s%s",
-                master->name, ri->addr->ip, ri->addr->port,
-                ri->runid ? " " : "",
-                ri->runid ? ri->runid : "");
+                "sentinel known-sentinel %s %s %d %s",
+                master->name, ri->addr->ip, ri->addr->port, ri->runid);
             rewriteConfigRewriteLine(state,"sentinel",line,1);
         }
         dictReleaseIterator(di2);
     }
 
     /* sentinel current-epoch is a global state valid for all the masters. */
@@ -1596,176 +1837,131 @@
  * On failure the function logs a warning on the Redis log. */
 void sentinelFlushConfig(void) {
     int fd = -1;
     int saved_hz = server.hz;
     int rewrite_status;
 
-    server.hz = REDIS_DEFAULT_HZ;
+    server.hz = CONFIG_DEFAULT_HZ;
     rewrite_status = rewriteConfig(server.configfile);
     server.hz = saved_hz;
 
     if (rewrite_status == -1) goto werr;
     if ((fd = open(server.configfile,O_RDONLY)) == -1) goto werr;
     if (fsync(fd) == -1) goto werr;
     if (close(fd) == EOF) goto werr;
     return;
 
 werr:
     if (fd != -1) close(fd);
-    redisLog(REDIS_WARNING,"WARNING: Sentinel was not able to save the new configuration on disk!!!: %s", strerror(errno));
+    serverLog(LL_WARNING,"WARNING: Sentinel was not able to save the new configuration on disk!!!: %s", strerror(errno));
 }
 
 /* ====================== hiredis connection handling ======================= */
 
-/* Completely disconnect a hiredis link from an instance. */
-void sentinelKillLink(sentinelRedisInstance *ri, redisAsyncContext *c) {
-    if (ri->cc == c) {
-        ri->cc = NULL;
-        ri->pending_commands = 0;
-    }
-    if (ri->pc == c) ri->pc = NULL;
-    c->data = NULL;
-    ri->flags |= SRI_DISCONNECTED;
-    redisAsyncFree(c);
-}
-
-/* This function takes a hiredis context that is in an error condition
- * and make sure to mark the instance as disconnected performing the
- * cleanup needed.
- *
- * Note: we don't free the hiredis context as hiredis will do it for us
- * for async connections. */
-void sentinelDisconnectInstanceFromContext(const redisAsyncContext *c) {
-    sentinelRedisInstance *ri = c->data;
-    int pubsub;
-
-    if (ri == NULL) return; /* The instance no longer exists. */
-
-    pubsub = (ri->pc == c);
-    sentinelEvent(REDIS_DEBUG, pubsub ? "-pubsub-link" : "-cmd-link", ri,
-        "%@ #%s", c->errstr);
-    if (pubsub)
-        ri->pc = NULL;
-    else
-        ri->cc = NULL;
-    ri->flags |= SRI_DISCONNECTED;
-}
-
-void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {
-    if (status != REDIS_OK) {
-        sentinelDisconnectInstanceFromContext(c);
-    } else {
-        sentinelRedisInstance *ri = c->data;
-        int pubsub = (ri->pc == c);
-
-        sentinelEvent(REDIS_DEBUG, pubsub ? "+pubsub-link" : "+cmd-link", ri,
-            "%@");
-    }
-}
-
-void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
-    REDIS_NOTUSED(status);
-    sentinelDisconnectInstanceFromContext(c);
-}
-
 /* Send the AUTH command with the specified master password if needed.
  * Note that for slaves the password set for the master is used.
  *
  * We don't check at all if the command was successfully transmitted
  * to the instance as if it fails Sentinel will detect the instance down,
  * will disconnect and reconnect the link and so forth. */
 void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
     char *auth_pass = (ri->flags & SRI_MASTER) ? ri->auth_pass :
                                                  ri->master->auth_pass;
 
     if (auth_pass) {
-        if (redisAsyncCommand(c, sentinelDiscardReplyCallback, NULL, "AUTH %s",
-            auth_pass) == REDIS_OK) ri->pending_commands++;
+        if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri, "AUTH %s",
+            auth_pass) == C_OK) ri->link->pending_commands++;
     }
 }
 
 /* Use CLIENT SETNAME to name the connection in the Redis instance as
  * sentinel-<first_8_chars_of_runid>-<connection_type>
  * The connection type is "cmd" or "pubsub" as specified by 'type'.
  *
  * This makes it possible to list all the sentinel instances connected
  * to a Redis servewr with CLIENT LIST, grepping for a specific name format. */
 void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {
     char name[64];
 
-    snprintf(name,sizeof(name),"sentinel-%.8s-%s",server.runid,type);
-    if (redisAsyncCommand(c, sentinelDiscardReplyCallback, NULL,
-        "CLIENT SETNAME %s", name) == REDIS_OK)
+    snprintf(name,sizeof(name),"sentinel-%.8s-%s",sentinel.myid,type);
+    if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri,
+        "CLIENT SETNAME %s", name) == C_OK)
     {
-        ri->pending_commands++;
+        ri->link->pending_commands++;
     }
 }
 
-/* Create the async connections for the specified instance if the instance
- * is disconnected. Note that the SRI_DISCONNECTED flag is set even if just
+/* Create the async connections for the instance link if the link
+ * is disconnected. Note that link->disconnected is true even if just
  * one of the two links (commands and pub/sub) is missing. */
 void sentinelReconnectInstance(sentinelRedisInstance *ri) {
-    if (!(ri->flags & SRI_DISCONNECTED)) return;
+    if (ri->link->disconnected == 0) return;
+    if (ri->addr->port == 0) return; /* port == 0 means invalid address. */
+    instanceLink *link = ri->link;
+    mstime_t now = mstime();
+
+    if (now - ri->link->last_reconn_time < SENTINEL_PING_PERIOD) return;
+    ri->link->last_reconn_time = now;
 
     /* Commands connection. */
-    if (ri->cc == NULL) {
-        ri->cc = redisAsyncConnectBind(ri->addr->ip,ri->addr->port,REDIS_BIND_ADDR);
-        if (ri->cc->err) {
-            sentinelEvent(REDIS_DEBUG,"-cmd-link-reconnection",ri,"%@ #%s",
-                ri->cc->errstr);
-            sentinelKillLink(ri,ri->cc);
+    if (link->cc == NULL) {
+        link->cc = redisAsyncConnectBind(ri->addr->ip,ri->addr->port,NET_FIRST_BIND_ADDR);
+        if (link->cc->err) {
+            sentinelEvent(LL_DEBUG,"-cmd-link-reconnection",ri,"%@ #%s",
+                link->cc->errstr);
+            instanceLinkCloseConnection(link,link->cc);
         } else {
-            ri->cc_conn_time = mstime();
-            ri->cc->data = ri;
-            redisAeAttach(server.el,ri->cc);
-            redisAsyncSetConnectCallback(ri->cc,
-                                            sentinelLinkEstablishedCallback);
-            redisAsyncSetDisconnectCallback(ri->cc,
-                                            sentinelDisconnectCallback);
-            sentinelSendAuthIfNeeded(ri,ri->cc);
-            sentinelSetClientName(ri,ri->cc,"cmd");
+            link->cc_conn_time = mstime();
+            link->cc->data = link;
+            redisAeAttach(server.el,link->cc);
+            redisAsyncSetConnectCallback(link->cc,
+                    sentinelLinkEstablishedCallback);
+            redisAsyncSetDisconnectCallback(link->cc,
+                    sentinelDisconnectCallback);
+            sentinelSendAuthIfNeeded(ri,link->cc);
+            sentinelSetClientName(ri,link->cc,"cmd");
 
             /* Send a PING ASAP when reconnecting. */
             sentinelSendPing(ri);
         }
     }
     /* Pub / Sub */
-    if ((ri->flags & (SRI_MASTER|SRI_SLAVE)) && ri->pc == NULL) {
-        ri->pc = redisAsyncConnectBind(ri->addr->ip,ri->addr->port,REDIS_BIND_ADDR);
-        if (ri->pc->err) {
-            sentinelEvent(REDIS_DEBUG,"-pubsub-link-reconnection",ri,"%@ #%s",
-                ri->pc->errstr);
-            sentinelKillLink(ri,ri->pc);
+    if ((ri->flags & (SRI_MASTER|SRI_SLAVE)) && link->pc == NULL) {
+        link->pc = redisAsyncConnectBind(ri->addr->ip,ri->addr->port,NET_FIRST_BIND_ADDR);
+        if (link->pc->err) {
+            sentinelEvent(LL_DEBUG,"-pubsub-link-reconnection",ri,"%@ #%s",
+                link->pc->errstr);
+            instanceLinkCloseConnection(link,link->pc);
         } else {
             int retval;
 
-            ri->pc_conn_time = mstime();
-            ri->pc->data = ri;
-            redisAeAttach(server.el,ri->pc);
-            redisAsyncSetConnectCallback(ri->pc,
-                                            sentinelLinkEstablishedCallback);
-            redisAsyncSetDisconnectCallback(ri->pc,
-                                            sentinelDisconnectCallback);
-            sentinelSendAuthIfNeeded(ri,ri->pc);
-            sentinelSetClientName(ri,ri->pc,"pubsub");
+            link->pc_conn_time = mstime();
+            link->pc->data = link;
+            redisAeAttach(server.el,link->pc);
+            redisAsyncSetConnectCallback(link->pc,
+                    sentinelLinkEstablishedCallback);
+            redisAsyncSetDisconnectCallback(link->pc,
+                    sentinelDisconnectCallback);
+            sentinelSendAuthIfNeeded(ri,link->pc);
+            sentinelSetClientName(ri,link->pc,"pubsub");
             /* Now we subscribe to the Sentinels "Hello" channel. */
-            retval = redisAsyncCommand(ri->pc,
-                sentinelReceiveHelloMessages, NULL, "SUBSCRIBE %s",
+            retval = redisAsyncCommand(link->pc,
+                sentinelReceiveHelloMessages, ri, "SUBSCRIBE %s",
                     SENTINEL_HELLO_CHANNEL);
-            if (retval != REDIS_OK) {
+            if (retval != C_OK) {
                 /* If we can't subscribe, the Pub/Sub connection is useless
                  * and we can simply disconnect it and try again. */
-                sentinelKillLink(ri,ri->pc);
+                instanceLinkCloseConnection(link,link->pc);
                 return;
             }
         }
     }
-    /* Clear the DISCONNECTED flags only if we have both the connections
+    /* Clear the disconnected status only if we have both the connections
      * (or just the commands connection if this is a sentinel instance). */
-    if (ri->cc && (ri->flags & SRI_SENTINEL || ri->pc))
-        ri->flags &= ~SRI_DISCONNECTED;
+    if (link->cc && (ri->flags & SRI_SENTINEL || link->pc))
+        link->disconnected = 0;
 }
 
 /* ======================== Redis instances pinging  ======================== */
 
 /* Return true if master looks "sane", that is:
  * 1) It is actually a master in the current configuration.
@@ -1783,12 +1979,16 @@
 /* Process the INFO output from masters. */
 void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
     sds *lines;
     int numlines, j;
     int role = 0;
 
+    /* cache full INFO output for instance */
+    sdsfree(ri->info);
+    ri->info = sdsnew(info);
+
     /* The following fields must be reset to a given value in the case they
      * are not found at all in the INFO output. */
     ri->master_link_down_time = 0;
 
     /* Process line by line. */
     lines = sdssplitlen(info,strlen(info),"\r\n",2,&numlines);
@@ -1799,13 +1999,13 @@
         /* run_id:<40 hex chars>*/
         if (sdslen(l) >= 47 && !memcmp(l,"run_id:",7)) {
             if (ri->runid == NULL) {
                 ri->runid = sdsnewlen(l+7,40);
             } else {
                 if (strncmp(ri->runid,l+7,40) != 0) {
-                    sentinelEvent(REDIS_NOTICE,"+reboot",ri,"%@");
+                    sentinelEvent(LL_NOTICE,"+reboot",ri,"%@");
                     sdsfree(ri->runid);
                     ri->runid = sdsnewlen(l+7,40);
                 }
             }
         }
 
@@ -1840,13 +2040,13 @@
             /* Check if we already have this slave into our table,
              * otherwise add it. */
             if (sentinelRedisInstanceLookupSlave(ri,ip,atoi(port)) == NULL) {
                 if ((slave = createSentinelRedisInstance(NULL,SRI_SLAVE,ip,
                             atoi(port), ri->quorum, ri)) != NULL)
                 {
-                    sentinelEvent(REDIS_NOTICE,"+slave",slave,"%@");
+                    sentinelEvent(LL_NOTICE,"+slave",slave,"%@");
                     sentinelFlushConfig();
                 }
             }
         }
 
         /* master_link_down_since_seconds:<seconds> */
@@ -1910,13 +2110,13 @@
     if (role != ri->role_reported) {
         ri->role_reported_time = mstime();
         ri->role_reported = role;
         if (role == SRI_SLAVE) ri->slave_conf_change_time = mstime();
         /* Log the event with +role-change if the new role is coherent or
          * with -role-change if there is a mismatch with the current config. */
-        sentinelEvent(REDIS_VERBOSE,
+        sentinelEvent(LL_VERBOSE,
             ((ri->flags & (SRI_MASTER|SRI_SLAVE)) == role) ?
             "+role-change" : "-role-change",
             ri, "%@ new reported role is %s",
             role == SRI_MASTER ? "master" : "slave",
             ri->flags & SRI_MASTER ? "master" : "slave");
     }
@@ -1947,14 +2147,17 @@
              * Sentinels to update their config (assuming there is not
              * a newer one already available). */
             ri->master->config_epoch = ri->master->failover_epoch;
             ri->master->failover_state = SENTINEL_FAILOVER_STATE_RECONF_SLAVES;
             ri->master->failover_state_change_time = mstime();
             sentinelFlushConfig();
-            sentinelEvent(REDIS_WARNING,"+promoted-slave",ri,"%@");
-            sentinelEvent(REDIS_WARNING,"+failover-state-reconf-slaves",
+            sentinelEvent(LL_WARNING,"+promoted-slave",ri,"%@");
+            if (sentinel.simfailure_flags &
+                SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION)
+                sentinelSimFailureCrash();
+            sentinelEvent(LL_WARNING,"+failover-state-reconf-slaves",
                 ri->master,"%@");
             sentinelCallClientReconfScript(ri->master,SENTINEL_LEADER,
                 "start",ri->master->addr,ri->addr);
             sentinelForceHelloUpdateForMaster(ri->master);
         } else {
             /* A slave turned into a master. We want to force our view and
@@ -1967,14 +2170,14 @@
                  sentinelRedisInstanceNoDownFor(ri,wait_time) &&
                  mstime() - ri->role_reported_time > wait_time)
             {
                 int retval = sentinelSendSlaveOf(ri,
                         ri->master->addr->ip,
                         ri->master->addr->port);
-                if (retval == REDIS_OK)
-                    sentinelEvent(REDIS_NOTICE,"+convert-to-slave",ri,"%@");
+                if (retval == C_OK)
+                    sentinelEvent(LL_NOTICE,"+convert-to-slave",ri,"%@");
             }
         }
     }
 
     /* Handle slaves replicating to a different master address. */
     if ((ri->flags & SRI_SLAVE) &&
@@ -1990,14 +2193,14 @@
             sentinelRedisInstanceNoDownFor(ri,wait_time) &&
             mstime() - ri->slave_conf_change_time > wait_time)
         {
             int retval = sentinelSendSlaveOf(ri,
                     ri->master->addr->ip,
                     ri->master->addr->port);
-            if (retval == REDIS_OK)
-                sentinelEvent(REDIS_NOTICE,"+fix-slave-config",ri,"%@");
+            if (retval == C_OK)
+                sentinelEvent(LL_NOTICE,"+fix-slave-config",ri,"%@");
         }
     }
 
     /* Detect if the slave that is in the process of being reconfigured
      * changed state. */
     if ((ri->flags & SRI_SLAVE) && role == SRI_SLAVE &&
@@ -2009,96 +2212,95 @@
             strcmp(ri->slave_master_host,
                     ri->master->promoted_slave->addr->ip) == 0 &&
             ri->slave_master_port == ri->master->promoted_slave->addr->port)
         {
             ri->flags &= ~SRI_RECONF_SENT;
             ri->flags |= SRI_RECONF_INPROG;
-            sentinelEvent(REDIS_NOTICE,"+slave-reconf-inprog",ri,"%@");
+            sentinelEvent(LL_NOTICE,"+slave-reconf-inprog",ri,"%@");
         }
 
         /* SRI_RECONF_INPROG -> SRI_RECONF_DONE */
         if ((ri->flags & SRI_RECONF_INPROG) &&
             ri->slave_master_link_status == SENTINEL_MASTER_LINK_STATUS_UP)
         {
             ri->flags &= ~SRI_RECONF_INPROG;
             ri->flags |= SRI_RECONF_DONE;
-            sentinelEvent(REDIS_NOTICE,"+slave-reconf-done",ri,"%@");
+            sentinelEvent(LL_NOTICE,"+slave-reconf-done",ri,"%@");
         }
     }
 }
 
 void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
-    sentinelRedisInstance *ri = c->data;
+    sentinelRedisInstance *ri = privdata;
+    instanceLink *link = c->data;
     redisReply *r;
-    REDIS_NOTUSED(privdata);
 
-    if (ri) ri->pending_commands--;
-    if (!reply || !ri) return;
+    if (!reply || !link) return;
+    link->pending_commands--;
     r = reply;
 
-    if (r->type == REDIS_REPLY_STRING) {
+    if (r->type == REDIS_REPLY_STRING)
         sentinelRefreshInstanceInfo(ri,r->str);
-    }
 }
 
 /* Just discard the reply. We use this when we are not monitoring the return
  * value of the command but its effects directly. */
 void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
-    sentinelRedisInstance *ri = c->data;
-    REDIS_NOTUSED(reply);
-    REDIS_NOTUSED(privdata);
+    instanceLink *link = c->data;
+    UNUSED(reply);
+    UNUSED(privdata);
 
-    if (ri) ri->pending_commands--;
+    if (link) link->pending_commands--;
 }
 
 void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
-    sentinelRedisInstance *ri = c->data;
+    sentinelRedisInstance *ri = privdata;
+    instanceLink *link = c->data;
     redisReply *r;
-    REDIS_NOTUSED(privdata);
 
-    if (ri) ri->pending_commands--;
-    if (!reply || !ri) return;
+    if (!reply || !link) return;
+    link->pending_commands--;
     r = reply;
 
     if (r->type == REDIS_REPLY_STATUS ||
         r->type == REDIS_REPLY_ERROR) {
         /* Update the "instance available" field only if this is an
          * acceptable reply. */
         if (strncmp(r->str,"PONG",4) == 0 ||
             strncmp(r->str,"LOADING",7) == 0 ||
             strncmp(r->str,"MASTERDOWN",10) == 0)
         {
-            ri->last_avail_time = mstime();
-            ri->last_ping_time = 0; /* Flag the pong as received. */
+            link->last_avail_time = mstime();
+            link->act_ping_time = 0; /* Flag the pong as received. */
         } else {
             /* Send a SCRIPT KILL command if the instance appears to be
              * down because of a busy script. */
             if (strncmp(r->str,"BUSY",4) == 0 &&
                 (ri->flags & SRI_S_DOWN) &&
                 !(ri->flags & SRI_SCRIPT_KILL_SENT))
             {
-                if (redisAsyncCommand(ri->cc,
-                        sentinelDiscardReplyCallback, NULL,
-                        "SCRIPT KILL") == REDIS_OK)
-                    ri->pending_commands++;
+                if (redisAsyncCommand(ri->link->cc,
+                        sentinelDiscardReplyCallback, ri,
+                        "SCRIPT KILL") == C_OK)
+                    ri->link->pending_commands++;
                 ri->flags |= SRI_SCRIPT_KILL_SENT;
             }
         }
     }
-    ri->last_pong_time = mstime();
+    link->last_pong_time = mstime();
 }
 
 /* This is called when we get the reply about the PUBLISH command we send
  * to the master to advertise this sentinel. */
 void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
-    sentinelRedisInstance *ri = c->data;
+    sentinelRedisInstance *ri = privdata;
+    instanceLink *link = c->data;
     redisReply *r;
-    REDIS_NOTUSED(privdata);
 
-    if (ri) ri->pending_commands--;
-    if (!reply || !ri) return;
+    if (!reply || !link) return;
+    link->pending_commands--;
     r = reply;
 
     /* Only update pub_time if we actually published our message. Otherwise
      * we'll retry again in 100 milliseconds. */
     if (r->type != REDIS_REPLY_ERROR)
         ri->last_pub_time = mstime();
@@ -2130,53 +2332,67 @@
                         master->sentinels,token[0],port,token[2]);
         current_epoch = strtoull(token[3],NULL,10);
         master_config_epoch = strtoull(token[7],NULL,10);
 
         if (!si) {
             /* If not, remove all the sentinels that have the same runid
-             * OR the same ip/port, because it's either a restart or a
-             * network topology change. */
-            removed = removeMatchingSentinelsFromMaster(master,token[0],port,
-                            token[2]);
+             * because there was an address change, and add the same Sentinel
+             * with the new address back. */
+            removed = removeMatchingSentinelFromMaster(master,token[2]);
             if (removed) {
-                sentinelEvent(REDIS_NOTICE,"-dup-sentinel",master,
-                    "%@ #duplicate of %s:%d or %s",
-                    token[0],port,token[2]);
+                sentinelEvent(LL_NOTICE,"+sentinel-address-switch",master,
+                    "%@ ip %s port %d for %s", token[0],port,token[2]);
+            } else {
+                /* Check if there is another Sentinel with the same address this
+                 * new one is reporting. What we do if this happens is to set its
+                 * port to 0, to signal the address is invalid. We'll update it
+                 * later if we get an HELLO message. */
+                sentinelRedisInstance *other =
+                    getSentinelRedisInstanceByAddrAndRunID(
+                        master->sentinels, token[0],port,NULL);
+                if (other) {
+                    sentinelEvent(LL_NOTICE,"+sentinel-invalid-addr",other,"%@");
+                    other->addr->port = 0; /* It means: invalid address. */
+                    sentinelUpdateSentinelAddressInAllMasters(other);
+                }
             }
 
             /* Add the new sentinel. */
-            si = createSentinelRedisInstance(NULL,SRI_SENTINEL,
+            si = createSentinelRedisInstance(token[2],SRI_SENTINEL,
                             token[0],port,master->quorum,master);
+
             if (si) {
-                sentinelEvent(REDIS_NOTICE,"+sentinel",si,"%@");
+                if (!removed) sentinelEvent(LL_NOTICE,"+sentinel",si,"%@");
                 /* The runid is NULL after a new instance creation and
                  * for Sentinels we don't have a later chance to fill it,
                  * so do it now. */
                 si->runid = sdsnew(token[2]);
+                sentinelTryConnectionSharing(si);
+                if (removed) sentinelUpdateSentinelAddressInAllMasters(si);
                 sentinelFlushConfig();
             }
         }
 
         /* Update local current_epoch if received current_epoch is greater.*/
         if (current_epoch > sentinel.current_epoch) {
             sentinel.current_epoch = current_epoch;
             sentinelFlushConfig();
-            sentinelEvent(REDIS_WARNING,"+new-epoch",master,"%llu",
+            sentinelEvent(LL_WARNING,"+new-epoch",master,"%llu",
                 (unsigned long long) sentinel.current_epoch);
         }
 
         /* Update master info if received configuration is newer. */
-        if (master->config_epoch < master_config_epoch) {
+        if (si && master->config_epoch < master_config_epoch) {
             master->config_epoch = master_config_epoch;
             if (master_port != master->addr->port ||
                 strcmp(master->addr->ip, token[5]))
             {
                 sentinelAddr *old_addr;
 
-                sentinelEvent(REDIS_WARNING,"+config-update-from",si,"%@");
-                sentinelEvent(REDIS_WARNING,"+switch-master",
+                sentinelEvent(LL_WARNING,"+config-update-from",si,"%@");
+                sentinelEvent(LL_WARNING,"+switch-master",
                     master,"%s %s %d %s %d",
                     master->name,
                     master->addr->ip, master->addr->port,
                     token[5], master_port);
 
                 old_addr = dupSentinelAddr(master->addr);
@@ -2197,35 +2413,35 @@
 }
 
 
 /* This is our Pub/Sub callback for the Hello channel. It's useful in order
  * to discover other sentinels attached at the same master. */
 void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {
-    sentinelRedisInstance *ri = c->data;
+    sentinelRedisInstance *ri = privdata;
     redisReply *r;
-    REDIS_NOTUSED(privdata);
+    UNUSED(c);
 
     if (!reply || !ri) return;
     r = reply;
 
     /* Update the last activity in the pubsub channel. Note that since we
      * receive our messages as well this timestamp can be used to detect
      * if the link is probably disconnected even if it seems otherwise. */
-    ri->pc_last_activity = mstime();
+    ri->link->pc_last_activity = mstime();
 
     /* Sanity check in the reply we expect, so that the code that follows
      * can avoid to check for details. */
     if (r->type != REDIS_REPLY_ARRAY ||
         r->elements != 3 ||
         r->element[0]->type != REDIS_REPLY_STRING ||
         r->element[1]->type != REDIS_REPLY_STRING ||
         r->element[2]->type != REDIS_REPLY_STRING ||
         strcmp(r->element[0]->str,"message") != 0) return;
 
     /* We are not interested in meeting ourselves */
-    if (strstr(r->element[2]->str,server.runid) != NULL) return;
+    if (strstr(r->element[2]->str,sentinel.myid) != NULL) return;
 
     sentinelProcessHelloMessage(r->element[2]->str, r->element[2]->len);
 }
 
 /* Send an "Hello" message via Pub/Sub to the specified 'ri' Redis
  * instance in order to broadcast the current configuraiton for this
@@ -2233,52 +2449,52 @@
  *
  * The message has the following format:
  *
  * sentinel_ip,sentinel_port,sentinel_runid,current_epoch,
  * master_name,master_ip,master_port,master_config_epoch.
  *
- * Returns REDIS_OK if the PUBLISH was queued correctly, otherwise
- * REDIS_ERR is returned. */
+ * Returns C_OK if the PUBLISH was queued correctly, otherwise
+ * C_ERR is returned. */
 int sentinelSendHello(sentinelRedisInstance *ri) {
-    char ip[REDIS_IP_STR_LEN];
-    char payload[REDIS_IP_STR_LEN+1024];
+    char ip[NET_IP_STR_LEN];
+    char payload[NET_IP_STR_LEN+1024];
     int retval;
     char *announce_ip;
     int announce_port;
     sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ? ri : ri->master;
     sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);
 
-    if (ri->flags & SRI_DISCONNECTED) return REDIS_ERR;
+    if (ri->link->disconnected) return C_ERR;
 
     /* Use the specified announce address if specified, otherwise try to
      * obtain our own IP address. */
     if (sentinel.announce_ip) {
         announce_ip = sentinel.announce_ip;
     } else {
-        if (anetSockName(ri->cc->c.fd,ip,sizeof(ip),NULL) == -1)
-            return REDIS_ERR;
+        if (anetSockName(ri->link->cc->c.fd,ip,sizeof(ip),NULL) == -1)
+            return C_ERR;
         announce_ip = ip;
     }
     announce_port = sentinel.announce_port ?
                     sentinel.announce_port : server.port;
 
     /* Format and send the Hello message. */
     snprintf(payload,sizeof(payload),
         "%s,%d,%s,%llu," /* Info about this sentinel. */
         "%s,%s,%d,%llu", /* Info about current master. */
-        announce_ip, announce_port, server.runid,
+        announce_ip, announce_port, sentinel.myid,
         (unsigned long long) sentinel.current_epoch,
         /* --- */
         master->name,master_addr->ip,master_addr->port,
         (unsigned long long) master->config_epoch);
-    retval = redisAsyncCommand(ri->cc,
-        sentinelPublishReplyCallback, NULL, "PUBLISH %s %s",
+    retval = redisAsyncCommand(ri->link->cc,
+        sentinelPublishReplyCallback, ri, "PUBLISH %s %s",
             SENTINEL_HELLO_CHANNEL,payload);
-    if (retval != REDIS_OK) return REDIS_ERR;
-    ri->pending_commands++;
-    return REDIS_OK;
+    if (retval != C_OK) return C_ERR;
+    ri->link->pending_commands++;
+    return C_OK;
 }
 
 /* Reset last_pub_time in all the instances in the specified dictionary
  * in order to force the delivery of an Hello update ASAP. */
 void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
     dictIterator *di;
@@ -2299,34 +2515,36 @@
  *
  * It is technically not needed since we send an update to every instance
  * with a period of SENTINEL_PUBLISH_PERIOD milliseconds, however when a
  * Sentinel upgrades a configuration it is a good idea to deliever an update
  * to the other Sentinels ASAP. */
 int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {
-    if (!(master->flags & SRI_MASTER)) return REDIS_ERR;
+    if (!(master->flags & SRI_MASTER)) return C_ERR;
     if (master->last_pub_time >= (SENTINEL_PUBLISH_PERIOD+1))
         master->last_pub_time -= (SENTINEL_PUBLISH_PERIOD+1);
     sentinelForceHelloUpdateDictOfRedisInstances(master->sentinels);
     sentinelForceHelloUpdateDictOfRedisInstances(master->slaves);
-    return REDIS_OK;
+    return C_OK;
 }
 
-/* Send a PING to the specified instance and refresh the last_ping_time
+/* Send a PING to the specified instance and refresh the act_ping_time
  * if it is zero (that is, if we received a pong for the previous ping).
  *
  * On error zero is returned, and we can't consider the PING command
  * queued in the connection. */
 int sentinelSendPing(sentinelRedisInstance *ri) {
-    int retval = redisAsyncCommand(ri->cc,
-        sentinelPingReplyCallback, NULL, "PING");
-    if (retval == REDIS_OK) {
-        ri->pending_commands++;
-        /* We update the ping time only if we received the pong for
-         * the previous ping, otherwise we are technically waiting
-         * since the first ping that did not received a reply. */
-        if (ri->last_ping_time == 0) ri->last_ping_time = mstime();
+    int retval = redisAsyncCommand(ri->link->cc,
+        sentinelPingReplyCallback, ri, "PING");
+    if (retval == C_OK) {
+        ri->link->pending_commands++;
+        ri->link->last_ping_time = mstime();
+        /* We update the active ping time only if we received the pong for
+         * the previous ping, otherwise we are technically waiting since the
+         * first ping that did not received a reply. */
+        if (ri->link->act_ping_time == 0)
+            ri->link->act_ping_time = ri->link->last_ping_time;
         return 1;
     } else {
         return 0;
     }
 }
 
@@ -2336,21 +2554,22 @@
     mstime_t now = mstime();
     mstime_t info_period, ping_period;
     int retval;
 
     /* Return ASAP if we have already a PING or INFO already pending, or
      * in the case the instance is not properly connected. */
-    if (ri->flags & SRI_DISCONNECTED) return;
+    if (ri->link->disconnected) return;
 
     /* For INFO, PING, PUBLISH that are not critical commands to send we
      * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don't
      * want to use a lot of memory just because a link is not working
      * properly (note that anyway there is a redundant protection about this,
      * that is, the link will be disconnected and reconnected if a long
      * timeout condition is detected. */
-    if (ri->pending_commands >= SENTINEL_MAX_PENDING_COMMANDS) return;
+    if (ri->link->pending_commands >=
+        SENTINEL_MAX_PENDING_COMMANDS * ri->link->refcount) return;
 
     /* If this is a slave of a master in O_DOWN condition we start sending
      * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD
      * period. In this state we want to closely monitor slaves in case they
      * are turned into masters by another Sentinel, or by the sysadmin. */
     if ((ri->flags & SRI_SLAVE) &&
@@ -2368,16 +2587,17 @@
 
     if ((ri->flags & SRI_SENTINEL) == 0 &&
         (ri->info_refresh == 0 ||
         (now - ri->info_refresh) > info_period))
     {
         /* Send INFO to masters and slaves, not sentinels. */
-        retval = redisAsyncCommand(ri->cc,
-            sentinelInfoReplyCallback, NULL, "INFO");
-        if (retval == REDIS_OK) ri->pending_commands++;
-    } else if ((now - ri->last_pong_time) > ping_period) {
+        retval = redisAsyncCommand(ri->link->cc,
+            sentinelInfoReplyCallback, ri, "INFO");
+        if (retval == C_OK) ri->link->pending_commands++;
+    } else if ((now - ri->link->last_pong_time) > ping_period &&
+               (now - ri->link->last_ping_time) > ping_period/2) {
         /* Send PING to all the three kinds of instances. */
         sentinelSendPing(ri);
     } else if ((now - ri->last_pub_time) > SENTINEL_PUBLISH_PERIOD) {
         /* PUBLISH hello messages to all the three kinds of instances. */
         sentinelSendHello(ri);
     }
@@ -2396,13 +2616,13 @@
     case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return "update_config";
     default: return "unknown";
     }
 }
 
 /* Redis instance to Redis protocol representation. */
-void addReplySentinelRedisInstance(redisClient *c, sentinelRedisInstance *ri) {
+void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {
     char *flags = sdsempty();
     void *mbl;
     int fields = 0;
 
     mbl = addDeferredMultiBulkLength(c);
 
@@ -2425,13 +2645,13 @@
     addReplyBulkCString(c,"flags");
     if (ri->flags & SRI_S_DOWN) flags = sdscat(flags,"s_down,");
     if (ri->flags & SRI_O_DOWN) flags = sdscat(flags,"o_down,");
     if (ri->flags & SRI_MASTER) flags = sdscat(flags,"master,");
     if (ri->flags & SRI_SLAVE) flags = sdscat(flags,"slave,");
     if (ri->flags & SRI_SENTINEL) flags = sdscat(flags,"sentinel,");
-    if (ri->flags & SRI_DISCONNECTED) flags = sdscat(flags,"disconnected,");
+    if (ri->link->disconnected) flags = sdscat(flags,"disconnected,");
     if (ri->flags & SRI_MASTER_DOWN) flags = sdscat(flags,"master_down,");
     if (ri->flags & SRI_FAILOVER_IN_PROGRESS)
         flags = sdscat(flags,"failover_in_progress,");
     if (ri->flags & SRI_PROMOTED) flags = sdscat(flags,"promoted,");
     if (ri->flags & SRI_RECONF_SENT) flags = sdscat(flags,"reconf_sent,");
     if (ri->flags & SRI_RECONF_INPROG) flags = sdscat(flags,"reconf_inprog,");
@@ -2439,33 +2659,37 @@
 
     if (sdslen(flags) != 0) sdsrange(flags,0,-2); /* remove last "," */
     addReplyBulkCString(c,flags);
     sdsfree(flags);
     fields++;
 
-    addReplyBulkCString(c,"pending-commands");
-    addReplyBulkLongLong(c,ri->pending_commands);
+    addReplyBulkCString(c,"link-pending-commands");
+    addReplyBulkLongLong(c,ri->link->pending_commands);
+    fields++;
+
+    addReplyBulkCString(c,"link-refcount");
+    addReplyBulkLongLong(c,ri->link->refcount);
     fields++;
 
     if (ri->flags & SRI_FAILOVER_IN_PROGRESS) {
         addReplyBulkCString(c,"failover-state");
         addReplyBulkCString(c,(char*)sentinelFailoverStateStr(ri->failover_state));
         fields++;
     }
 
     addReplyBulkCString(c,"last-ping-sent");
     addReplyBulkLongLong(c,
-        ri->last_ping_time ? (mstime() - ri->last_ping_time) : 0);
+        ri->link->act_ping_time ? (mstime() - ri->link->act_ping_time) : 0);
     fields++;
 
     addReplyBulkCString(c,"last-ok-ping-reply");
-    addReplyBulkLongLong(c,mstime() - ri->last_avail_time);
+    addReplyBulkLongLong(c,mstime() - ri->link->last_avail_time);
     fields++;
 
     addReplyBulkCString(c,"last-ping-reply");
-    addReplyBulkLongLong(c,mstime() - ri->last_pong_time);
+    addReplyBulkLongLong(c,mstime() - ri->link->last_pong_time);
     fields++;
 
     if (ri->flags & SRI_S_DOWN) {
         addReplyBulkCString(c,"s-down-time");
         addReplyBulkLongLong(c,mstime()-ri->s_down_since_time);
         fields++;
@@ -2583,13 +2807,13 @@
 
     setDeferredMultiBulkLength(c,mbl,fields*2);
 }
 
 /* Output a number of instances contained inside a dictionary as
  * Redis protocol. */
-void addReplyDictOfRedisInstances(redisClient *c, dict *instances) {
+void addReplyDictOfRedisInstances(client *c, dict *instances) {
     dictIterator *di;
     dictEntry *de;
 
     di = dictGetIterator(instances);
     addReplyMultiBulkLen(c,dictSize(instances));
     while((de = dictNext(di)) != NULL) {
@@ -2600,13 +2824,13 @@
     dictReleaseIterator(di);
 }
 
 /* Lookup the named master into sentinel.masters.
  * If the master is not found reply to the client with an error and returns
  * NULL. */
-sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(redisClient *c,
+sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,
                         robj *name)
 {
     sentinelRedisInstance *ri;
 
     ri = dictFetchValue(sentinel.masters,name->ptr);
     if (!ri) {
@@ -2638,13 +2862,13 @@
     if (usable < (int)master->quorum) result |= SENTINEL_ISQR_NOQUORUM;
     if (usable < voters/2+1) result |= SENTINEL_ISQR_NOAUTH;
     if (usableptr) *usableptr = usable;
     return result;
 }
 
-void sentinelCommand(redisClient *c) {
+void sentinelCommand(client *c) {
     if (!strcasecmp(c->argv[1]->ptr,"masters")) {
         /* SENTINEL MASTERS */
         if (c->argc != 2) goto numargserr;
         addReplyDictOfRedisInstances(c,sentinel.masters);
     } else if (!strcasecmp(c->argv[1]->ptr,"master")) {
         /* SENTINEL MASTER <name> */
@@ -2668,24 +2892,40 @@
 
         if (c->argc != 3) goto numargserr;
         if ((ri = sentinelGetMasterByNameOrReplyError(c,c->argv[2])) == NULL)
             return;
         addReplyDictOfRedisInstances(c,ri->sentinels);
     } else if (!strcasecmp(c->argv[1]->ptr,"is-master-down-by-addr")) {
-        /* SENTINEL IS-MASTER-DOWN-BY-ADDR <ip> <port> <current-epoch> <runid>*/
+        /* SENTINEL IS-MASTER-DOWN-BY-ADDR <ip> <port> <current-epoch> <runid>
+         *
+         * Arguments:
+         *
+         * ip and port are the ip and port of the master we want to be
+         * checked by Sentinel. Note that the command will not check by
+         * name but just by master, in theory different Sentinels may monitor
+         * differnet masters with the same name.
+         *
+         * current-epoch is needed in order to understand if we are allowed
+         * to vote for a failover leader or not. Each Sentinel can vote just
+         * one time per epoch.
+         *
+         * runid is "*" if we are not seeking for a vote from the Sentinel
+         * in order to elect the failover leader. Otherwise it is set to the
+         * runid we want the Sentinel to vote if it did not already voted.
+         */
         sentinelRedisInstance *ri;
         long long req_epoch;
         uint64_t leader_epoch = 0;
         char *leader = NULL;
         long port;
         int isdown = 0;
 
         if (c->argc != 6) goto numargserr;
-        if (getLongFromObjectOrReply(c,c->argv[3],&port,NULL) != REDIS_OK ||
+        if (getLongFromObjectOrReply(c,c->argv[3],&port,NULL) != C_OK ||
             getLongLongFromObjectOrReply(c,c->argv[4],&req_epoch,NULL)
-                                                              != REDIS_OK)
+                                                              != C_OK)
             return;
         ri = getSentinelRedisInstanceByAddrAndRunID(sentinel.masters,
             c->argv[2]->ptr,port,NULL);
 
         /* It exists? Is actually a master? Is subjectively down? It's down.
          * Note: if we are in tilt mode we always reply with "0". */
@@ -2739,13 +2979,13 @@
             return;
         }
         if (sentinelSelectSlave(ri) == NULL) {
             addReplySds(c,sdsnew("-NOGOODSLAVE No suitable slave to promote\r\n"));
             return;
         }
-        redisLog(REDIS_WARNING,"Executing user requested FAILOVER of '%s'",
+        serverLog(LL_WARNING,"Executing user requested FAILOVER of '%s'",
             ri->name);
         sentinelStartFailover(ri);
         ri->flags |= SRI_FORCE_FAILOVER;
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"pending-scripts")) {
         /* SENTINEL PENDING-SCRIPTS */
@@ -2753,19 +2993,25 @@
         if (c->argc != 2) goto numargserr;
         sentinelPendingScriptsCommand(c);
     } else if (!strcasecmp(c->argv[1]->ptr,"monitor")) {
         /* SENTINEL MONITOR <name> <ip> <port> <quorum> */
         sentinelRedisInstance *ri;
         long quorum, port;
-        char ip[REDIS_IP_STR_LEN];
+        char ip[NET_IP_STR_LEN];
 
         if (c->argc != 6) goto numargserr;
         if (getLongFromObjectOrReply(c,c->argv[5],&quorum,"Invalid quorum")
-            != REDIS_OK) return;
+            != C_OK) return;
         if (getLongFromObjectOrReply(c,c->argv[4],&port,"Invalid port")
-            != REDIS_OK) return;
+            != C_OK) return;
+
+        if (quorum <= 0) {
+            addReplyError(c, "Quorum must be 1 or greater.");
+            return;
+        }
+
         /* Make sure the IP field is actually a valid IP before passing it
          * to createSentinelRedisInstance(), otherwise we may trigger a
          * DNS lookup at runtime. */
         if (anetResolveIP(NULL,c->argv[3]->ptr,ip,sizeof(ip)) == ANET_ERR) {
             addReplyError(c,"Invalid IP address specified");
             return;
@@ -2785,13 +3031,13 @@
             default:
                 addReplyError(c,"Unspecified error adding the instance");
                 break;
             }
         } else {
             sentinelFlushConfig();
-            sentinelEvent(REDIS_WARNING,"+monitor",ri,"%@ quorum %d",ri->quorum);
+            sentinelEvent(LL_WARNING,"+monitor",ri,"%@ quorum %d",ri->quorum);
             addReply(c,shared.ok);
         }
     } else if (!strcasecmp(c->argv[1]->ptr,"flushconfig")) {
         if (c->argc != 2) goto numargserr;
         sentinelFlushConfig();
         addReply(c,shared.ok);
@@ -2800,13 +3046,13 @@
         /* SENTINEL REMOVE <name> */
         sentinelRedisInstance *ri;
 
         if (c->argc != 3) goto numargserr;
         if ((ri = sentinelGetMasterByNameOrReplyError(c,c->argv[2]))
             == NULL) return;
-        sentinelEvent(REDIS_WARNING,"-monitor",ri,"%@");
+        sentinelEvent(LL_WARNING,"-monitor",ri,"%@");
         dictDelete(sentinel.masters,c->argv[2]->ptr);
         sentinelFlushConfig();
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"ckquorum")) {
         /* SENTINEL CKQUORUM <name> */
         sentinelRedisInstance *ri;
@@ -2834,58 +3080,164 @@
             e = sdscat(e,"\r\n");
             addReplySds(c,e);
         }
     } else if (!strcasecmp(c->argv[1]->ptr,"set")) {
         if (c->argc < 3 || c->argc % 2 == 0) goto numargserr;
         sentinelSetCommand(c);
+    } else if (!strcasecmp(c->argv[1]->ptr,"info-cache")) {
+        /* SENTINEL INFO-CACHE <name> */
+        if (c->argc < 2) goto numargserr;
+        mstime_t now = mstime();
+
+        /* Create an ad-hoc dictionary type so that we can iterate
+         * a dictionary composed of just the master groups the user
+         * requested. */
+        dictType copy_keeper = instancesDictType;
+        copy_keeper.valDestructor = NULL;
+        dict *masters_local = sentinel.masters;
+        if (c->argc > 2) {
+            masters_local = dictCreate(&copy_keeper, NULL);
+
+            for (int i = 2; i < c->argc; i++) {
+                sentinelRedisInstance *ri;
+                ri = sentinelGetMasterByName(c->argv[i]->ptr);
+                if (!ri) continue; /* ignore non-existing names */
+                dictAdd(masters_local, ri->name, ri);
+            }
+        }
+
+        /* Reply format:
+         *   1.) master name
+         *   2.) 1.) info from master
+         *       2.) info from replica
+         *       ...
+         *   3.) other master name
+         *   ...
+         */
+        addReplyMultiBulkLen(c,dictSize(masters_local) * 2);
+
+        dictIterator  *di;
+        dictEntry *de;
+        di = dictGetIterator(masters_local);
+        while ((de = dictNext(di)) != NULL) {
+            sentinelRedisInstance *ri = dictGetVal(de);
+            addReplyBulkCBuffer(c,ri->name,strlen(ri->name));
+            addReplyMultiBulkLen(c,dictSize(ri->slaves) + 1); /* +1 for self */
+            addReplyMultiBulkLen(c,2);
+            addReplyLongLong(c, now - ri->info_refresh);
+            if (ri->info)
+                addReplyBulkCBuffer(c,ri->info,sdslen(ri->info));
+            else
+                addReply(c,shared.nullbulk);
+
+            dictIterator *sdi;
+            dictEntry *sde;
+            sdi = dictGetIterator(ri->slaves);
+            while ((sde = dictNext(sdi)) != NULL) {
+                sentinelRedisInstance *sri = dictGetVal(sde);
+                addReplyMultiBulkLen(c,2);
+                addReplyLongLong(c, now - sri->info_refresh);
+                if (sri->info)
+                    addReplyBulkCBuffer(c,sri->info,sdslen(sri->info));
+                else
+                    addReply(c,shared.nullbulk);
+            }
+            dictReleaseIterator(sdi);
+        }
+        dictReleaseIterator(di);
+        if (masters_local != sentinel.masters) dictRelease(masters_local);
+    } else if (!strcasecmp(c->argv[1]->ptr,"simulate-failure")) {
+        /* SENTINEL SIMULATE-FAILURE <flag> <flag> ... <flag> */
+        int j;
+
+        sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
+        for (j = 2; j < c->argc; j++) {
+            if (!strcasecmp(c->argv[j]->ptr,"crash-after-election")) {
+                sentinel.simfailure_flags |=
+                    SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION;
+                serverLog(LL_WARNING,"Failure simulation: this Sentinel "
+                    "will crash after being successfully elected as failover "
+                    "leader");
+            } else if (!strcasecmp(c->argv[j]->ptr,"crash-after-promotion")) {
+                sentinel.simfailure_flags |=
+                    SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION;
+                serverLog(LL_WARNING,"Failure simulation: this Sentinel "
+                    "will crash after promoting the selected slave to master");
+            } else if (!strcasecmp(c->argv[j]->ptr,"help")) {
+                addReplyMultiBulkLen(c,2);
+                addReplyBulkCString(c,"crash-after-election");
+                addReplyBulkCString(c,"crash-after-promotion");
+            } else {
+                addReplyError(c,"Unknown failure simulation specified");
+                return;
+            }
+        }
+        addReply(c,shared.ok);
     } else {
         addReplyErrorFormat(c,"Unknown sentinel subcommand '%s'",
                                (char*)c->argv[1]->ptr);
     }
     return;
 
 numargserr:
     addReplyErrorFormat(c,"Wrong number of arguments for 'sentinel %s'",
                           (char*)c->argv[1]->ptr);
 }
 
-/* SENTINEL INFO [section] */
-void sentinelInfoCommand(redisClient *c) {
-    char *section = c->argc == 2 ? c->argv[1]->ptr : "default";
-    sds info = sdsempty();
-    int defsections = !strcasecmp(section,"default");
-    int sections = 0;
+#define info_section_from_redis(section_name) do { \
+    if (defsections || allsections || !strcasecmp(section,section_name)) { \
+        sds redissection; \
+        if (sections++) info = sdscat(info,"\r\n"); \
+        redissection = genRedisInfoString(section_name); \
+        info = sdscatlen(info,redissection,sdslen(redissection)); \
+        sdsfree(redissection); \
+    } \
+} while(0)
 
+/* SENTINEL INFO [section] */
+void sentinelInfoCommand(client *c) {
     if (c->argc > 2) {
         addReply(c,shared.syntaxerr);
         return;
     }
 
-    if (!strcasecmp(section,"server") || defsections) {
-        if (sections++) info = sdscat(info,"\r\n");
-        sds serversection = genRedisInfoString("server");
-        info = sdscatlen(info,serversection,sdslen(serversection));
-        sdsfree(serversection);
+    int defsections = 0, allsections = 0;
+    char *section = c->argc == 2 ? c->argv[1]->ptr : NULL;
+    if (section) {
+        allsections = !strcasecmp(section,"all");
+        defsections = !strcasecmp(section,"default");
+    } else {
+        defsections = 1;
     }
 
-    if (!strcasecmp(section,"sentinel") || defsections) {
+    int sections = 0;
+    sds info = sdsempty();
+
+    info_section_from_redis("server");
+    info_section_from_redis("clients");
+    info_section_from_redis("cpu");
+    info_section_from_redis("stats");
+
+    if (defsections || allsections || !strcasecmp(section,"sentinel")) {
         dictIterator *di;
         dictEntry *de;
         int master_id = 0;
 
         if (sections++) info = sdscat(info,"\r\n");
         info = sdscatprintf(info,
             "# Sentinel\r\n"
             "sentinel_masters:%lu\r\n"
             "sentinel_tilt:%d\r\n"
             "sentinel_running_scripts:%d\r\n"
-            "sentinel_scripts_queue_length:%ld\r\n",
+            "sentinel_scripts_queue_length:%ld\r\n"
+            "sentinel_simulate_failure_flags:%lu\r\n",
             dictSize(sentinel.masters),
             sentinel.tilt,
             sentinel.running_scripts,
-            listLength(sentinel.scripts_queue));
+            listLength(sentinel.scripts_queue),
+            sentinel.simfailure_flags);
 
         di = dictGetIterator(sentinel.masters);
         while((de = dictNext(di)) != NULL) {
             sentinelRedisInstance *ri = dictGetVal(de);
             char *status = "ok";
 
@@ -2899,21 +3251,18 @@
                 dictSize(ri->slaves),
                 dictSize(ri->sentinels)+1);
         }
         dictReleaseIterator(di);
     }
 
-    addReplySds(c,sdscatprintf(sdsempty(),"$%lu\r\n",
-        (unsigned long)sdslen(info)));
-    addReplySds(c,info);
-    addReply(c,shared.crlf);
+    addReplyBulkSds(c, info);
 }
 
 /* Implements Sentinel verison of the ROLE command. The output is
  * "sentinel" and the list of currently monitored master names. */
-void sentinelRoleCommand(redisClient *c) {
+void sentinelRoleCommand(client *c) {
     dictIterator *di;
     dictEntry *de;
 
     addReplyMultiBulkLen(c,2);
     addReplyBulkCBuffer(c,"sentinel",8);
     addReplyMultiBulkLen(c,dictSize(sentinel.masters));
@@ -2925,13 +3274,13 @@
         addReplyBulkCString(c,ri->name);
     }
     dictReleaseIterator(di);
 }
 
 /* SENTINEL SET <mastername> [<option> <value> ...] */
-void sentinelSetCommand(redisClient *c) {
+void sentinelSetCommand(client *c) {
     sentinelRedisInstance *ri;
     int j, changes = 0;
     char *option, *value;
 
     if ((ri = sentinelGetMasterByNameOrReplyError(c,c->argv[2]))
         == NULL) return;
@@ -2942,26 +3291,26 @@
         value = c->argv[j+1]->ptr;
         robj *o = c->argv[j+1];
         long long ll;
 
         if (!strcasecmp(option,"down-after-milliseconds")) {
             /* down-after-millisecodns <milliseconds> */
-            if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll <= 0)
+            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0)
                 goto badfmt;
             ri->down_after_period = ll;
             sentinelPropagateDownAfterPeriod(ri);
             changes++;
         } else if (!strcasecmp(option,"failover-timeout")) {
             /* failover-timeout <milliseconds> */
-            if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll <= 0)
+            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0)
                 goto badfmt;
             ri->failover_timeout = ll;
             changes++;
        } else if (!strcasecmp(option,"parallel-syncs")) {
             /* parallel-syncs <milliseconds> */
-            if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll <= 0)
+            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0)
                 goto badfmt;
             ri->parallel_syncs = ll;
             changes++;
        } else if (!strcasecmp(option,"notification-script")) {
             /* notification-script <path> */
             if (strlen(value) && access(value,X_OK) == -1) {
@@ -2989,23 +3338,23 @@
             /* auth-pass <password> */
             sdsfree(ri->auth_pass);
             ri->auth_pass = strlen(value) ? sdsnew(value) : NULL;
             changes++;
        } else if (!strcasecmp(option,"quorum")) {
             /* quorum <count> */
-            if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll <= 0)
+            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0)
                 goto badfmt;
             ri->quorum = ll;
             changes++;
         } else {
             addReplyErrorFormat(c,"Unknown option '%s' for SENTINEL SET",
                 option);
             if (changes) sentinelFlushConfig();
             return;
         }
-        sentinelEvent(REDIS_WARNING,"+set",ri,"%@ %s %s",option,value);
+        sentinelEvent(LL_WARNING,"+set",ri,"%@ %s %s",option,value);
     }
 
     if (changes) sentinelFlushConfig();
     addReply(c,shared.ok);
     return;
 
@@ -3018,13 +3367,13 @@
 /* Our fake PUBLISH command: it is actually useful only to receive hello messages
  * from the other sentinel instances, and publishing to a channel other than
  * SENTINEL_HELLO_CHANNEL is forbidden.
  *
  * Because we have a Sentinel PUBLISH, the code to send hello messages is the same
  * for all the three kind of instances: masters, slaves, sentinels. */
-void sentinelPublishCommand(redisClient *c) {
+void sentinelPublishCommand(client *c) {
     if (strcmp(c->argv[1]->ptr,SENTINEL_HELLO_CHANNEL)) {
         addReplyError(c, "Only HELLO messages are accepted by Sentinel instances.");
         return;
     }
     sentinelProcessHelloMessage(c->argv[2]->ptr,sdslen(c->argv[2]->ptr));
     addReplyLongLong(c,1);
@@ -3033,42 +3382,46 @@
 /* ===================== SENTINEL availability checks ======================= */
 
 /* Is this instance down from our point of view? */
 void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
     mstime_t elapsed = 0;
 
-    if (ri->last_ping_time)
-        elapsed = mstime() - ri->last_ping_time;
+    if (ri->link->act_ping_time)
+        elapsed = mstime() - ri->link->act_ping_time;
+    else if (ri->link->disconnected)
+        elapsed = mstime() - ri->link->last_avail_time;
 
     /* Check if we are in need for a reconnection of one of the
      * links, because we are detecting low activity.
      *
      * 1) Check if the command link seems connected, was connected not less
      *    than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have a
      *    pending ping for more than half the timeout. */
-    if (ri->cc &&
-        (mstime() - ri->cc_conn_time) > SENTINEL_MIN_LINK_RECONNECT_PERIOD &&
-        ri->last_ping_time != 0 && /* Ther is a pending ping... */
+    if (ri->link->cc &&
+        (mstime() - ri->link->cc_conn_time) >
+        SENTINEL_MIN_LINK_RECONNECT_PERIOD &&
+        ri->link->act_ping_time != 0 && /* Ther is a pending ping... */
         /* The pending ping is delayed, and we did not received
          * error replies as well. */
-        (mstime() - ri->last_ping_time) > (ri->down_after_period/2) &&
-        (mstime() - ri->last_pong_time) > (ri->down_after_period/2))
+        (mstime() - ri->link->act_ping_time) > (ri->down_after_period/2) &&
+        (mstime() - ri->link->last_pong_time) > (ri->down_after_period/2))
     {
-        sentinelKillLink(ri,ri->cc);
+        instanceLinkCloseConnection(ri->link,ri->link->cc);
     }
 
     /* 2) Check if the pubsub link seems connected, was connected not less
      *    than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have no
      *    activity in the Pub/Sub channel for more than
      *    SENTINEL_PUBLISH_PERIOD * 3.
      */
-    if (ri->pc &&
-        (mstime() - ri->pc_conn_time) > SENTINEL_MIN_LINK_RECONNECT_PERIOD &&
-        (mstime() - ri->pc_last_activity) > (SENTINEL_PUBLISH_PERIOD*3))
+    if (ri->link->pc &&
+        (mstime() - ri->link->pc_conn_time) >
+         SENTINEL_MIN_LINK_RECONNECT_PERIOD &&
+        (mstime() - ri->link->pc_last_activity) > (SENTINEL_PUBLISH_PERIOD*3))
     {
-        sentinelKillLink(ri,ri->pc);
+        instanceLinkCloseConnection(ri->link,ri->link->pc);
     }
 
     /* Update the SDOWN flag. We believe the instance is SDOWN if:
      *
      * 1) It is not replying.
      * 2) We believe it is a master, it reports to be a slave for enough time
@@ -3079,20 +3432,20 @@
          ri->role_reported == SRI_SLAVE &&
          mstime() - ri->role_reported_time >
           (ri->down_after_period+SENTINEL_INFO_PERIOD*2)))
     {
         /* Is subjectively down */
         if ((ri->flags & SRI_S_DOWN) == 0) {
-            sentinelEvent(REDIS_WARNING,"+sdown",ri,"%@");
+            sentinelEvent(LL_WARNING,"+sdown",ri,"%@");
             ri->s_down_since_time = mstime();
             ri->flags |= SRI_S_DOWN;
         }
     } else {
         /* Is subjectively up */
         if (ri->flags & SRI_S_DOWN) {
-            sentinelEvent(REDIS_WARNING,"-sdown",ri,"%@");
+            sentinelEvent(LL_WARNING,"-sdown",ri,"%@");
             ri->flags &= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);
         }
     }
 }
 
 /* Is this instance down according to the configured quorum?
@@ -3120,34 +3473,34 @@
         if (quorum >= master->quorum) odown = 1;
     }
 
     /* Set the flag accordingly to the outcome. */
     if (odown) {
         if ((master->flags & SRI_O_DOWN) == 0) {
-            sentinelEvent(REDIS_WARNING,"+odown",master,"%@ #quorum %d/%d",
+            sentinelEvent(LL_WARNING,"+odown",master,"%@ #quorum %d/%d",
                 quorum, master->quorum);
             master->flags |= SRI_O_DOWN;
             master->o_down_since_time = mstime();
         }
     } else {
         if (master->flags & SRI_O_DOWN) {
-            sentinelEvent(REDIS_WARNING,"-odown",master,"%@");
+            sentinelEvent(LL_WARNING,"-odown",master,"%@");
             master->flags &= ~SRI_O_DOWN;
         }
     }
 }
 
 /* Receive the SENTINEL is-master-down-by-addr reply, see the
  * sentinelAskMasterStateToOtherSentinels() function for more information. */
 void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {
-    sentinelRedisInstance *ri = c->data;
+    sentinelRedisInstance *ri = privdata;
+    instanceLink *link = c->data;
     redisReply *r;
-    REDIS_NOTUSED(privdata);
 
-    if (ri) ri->pending_commands--;
-    if (!reply || !ri) return;
+    if (!reply || !link) return;
+    link->pending_commands--;
     r = reply;
 
     /* Ignore every error or unexpected reply.
      * Note that if the command returns an error for any reason we'll
      * end clearing the SRI_MASTER_DOWN flag for timeout anyway. */
     if (r->type == REDIS_REPLY_ARRAY && r->elements == 3 &&
@@ -3163,13 +3516,13 @@
         }
         if (strcmp(r->element[1]->str,"*")) {
             /* If the runid in the reply is not "*" the Sentinel actually
              * replied with a vote. */
             sdsfree(ri->leader);
             if ((long long)ri->leader_epoch != r->element[2]->integer)
-                redisLog(REDIS_WARNING,
+                serverLog(LL_WARNING,
                     "%s voted for %s %llu", ri->name,
                     r->element[1]->str,
                     (unsigned long long) r->element[2]->integer);
             ri->leader = sdsnew(r->element[1]->str);
             ri->leader_epoch = r->element[2]->integer;
         }
@@ -3202,58 +3555,65 @@
         /* Only ask if master is down to other sentinels if:
          *
          * 1) We believe it is down, or there is a failover in progress.
          * 2) Sentinel is connected.
          * 3) We did not received the info within SENTINEL_ASK_PERIOD ms. */
         if ((master->flags & SRI_S_DOWN) == 0) continue;
-        if (ri->flags & SRI_DISCONNECTED) continue;
+        if (ri->link->disconnected) continue;
         if (!(flags & SENTINEL_ASK_FORCED) &&
             mstime() - ri->last_master_down_reply_time < SENTINEL_ASK_PERIOD)
             continue;
 
         /* Ask */
         ll2string(port,sizeof(port),master->addr->port);
-        retval = redisAsyncCommand(ri->cc,
-                    sentinelReceiveIsMasterDownReply, NULL,
+        retval = redisAsyncCommand(ri->link->cc,
+                    sentinelReceiveIsMasterDownReply, ri,
                     "SENTINEL is-master-down-by-addr %s %s %llu %s",
                     master->addr->ip, port,
                     sentinel.current_epoch,
                     (master->failover_state > SENTINEL_FAILOVER_STATE_NONE) ?
-                    server.runid : "*");
-        if (retval == REDIS_OK) ri->pending_commands++;
+                    sentinel.myid : "*");
+        if (retval == C_OK) ri->link->pending_commands++;
     }
     dictReleaseIterator(di);
 }
 
 /* =============================== FAILOVER ================================= */
 
+/* Crash because of user request via SENTINEL simulate-failure command. */
+void sentinelSimFailureCrash(void) {
+    serverLog(LL_WARNING,
+        "Sentinel CRASH because of SENTINEL simulate-failure");
+    exit(99);
+}
+
 /* Vote for the sentinel with 'req_runid' or return the old vote if already
  * voted for the specifed 'req_epoch' or one greater.
  *
  * If a vote is not available returns NULL, otherwise return the Sentinel
  * runid and populate the leader_epoch with the epoch of the vote. */
 char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {
     if (req_epoch > sentinel.current_epoch) {
         sentinel.current_epoch = req_epoch;
         sentinelFlushConfig();
-        sentinelEvent(REDIS_WARNING,"+new-epoch",master,"%llu",
+        sentinelEvent(LL_WARNING,"+new-epoch",master,"%llu",
             (unsigned long long) sentinel.current_epoch);
     }
 
     if (master->leader_epoch < req_epoch && sentinel.current_epoch <= req_epoch)
     {
         sdsfree(master->leader);
         master->leader = sdsnew(req_runid);
         master->leader_epoch = sentinel.current_epoch;
         sentinelFlushConfig();
-        sentinelEvent(REDIS_WARNING,"+vote-for-leader",master,"%s %llu",
+        sentinelEvent(LL_WARNING,"+vote-for-leader",master,"%s %llu",
             master->leader, (unsigned long long) master->leader_epoch);
         /* If we did not voted for ourselves, set the master failover start
          * time to now, in order to force a delay before we can start a
          * failover for the same master. */
-        if (strcasecmp(master->leader,server.runid))
+        if (strcasecmp(master->leader,sentinel.myid))
             master->failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
     }
 
     *leader_epoch = master->leader_epoch;
     return master->leader ? sdsnew(master->leader) : NULL;
 }
@@ -3272,13 +3632,13 @@
     if (de) {
         oldval = dictGetUnsignedIntegerVal(de);
         dictSetUnsignedIntegerVal(de,oldval+1);
         return oldval+1;
     } else {
         de = dictAddRaw(counters,runid);
-        redisAssert(de != NULL);
+        serverAssert(de != NULL);
         dictSetUnsignedIntegerVal(de,1);
         return 1;
     }
 }
 
 /* Scan all the Sentinels attached to this master to check if there
@@ -3294,13 +3654,13 @@
     unsigned int voters = 0, voters_quorum;
     char *myvote;
     char *winner = NULL;
     uint64_t leader_epoch;
     uint64_t max_votes = 0;
 
-    redisAssert(master->flags & (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));
+    serverAssert(master->flags & (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));
     counters = dictCreate(&leaderVotesDictType,NULL);
 
     voters = dictSize(master->sentinels)+1; /* All the other sentinels and me. */
 
     /* Count other sentinels votes */
     di = dictGetIterator(master->sentinels);
@@ -3328,13 +3688,13 @@
     /* Count this Sentinel vote:
      * if this Sentinel did not voted yet, either vote for the most
      * common voted sentinel, or for itself if no vote exists at all. */
     if (winner)
         myvote = sentinelVoteLeader(master,epoch,winner,&leader_epoch);
     else
-        myvote = sentinelVoteLeader(master,epoch,server.runid,&leader_epoch);
+        myvote = sentinelVoteLeader(master,epoch,sentinel.myid,&leader_epoch);
 
     if (myvote && leader_epoch == epoch) {
         uint64_t votes = sentinelLeaderIncr(counters,myvote);
 
         if (votes > max_votes) {
             max_votes = votes;
@@ -3356,14 +3716,14 @@
  * CONFIG REWRITE command in order to store the new configuration on disk
  * when possible (that is, if the Redis instance is recent enough to support
  * config rewriting, and if the server was started with a configuration file).
  *
  * If Host is NULL the function sends "SLAVEOF NO ONE".
  *
- * The command returns REDIS_OK if the SLAVEOF command was accepted for
- * (later) delivery otherwise REDIS_ERR. The command replies are just
+ * The command returns C_OK if the SLAVEOF command was accepted for
+ * (later) delivery otherwise C_ERR. The command replies are just
  * discarded. */
 int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {
     char portstr[32];
     int retval;
 
     ll2string(portstr,sizeof(portstr),port);
@@ -3382,55 +3742,55 @@
      * 3) Disconnect all clients (but this one sending the commnad) in order
      *    to trigger the ask-master-on-reconnection protocol for connected
      *    clients.
      *
      * Note that we don't check the replies returned by commands, since we
      * will observe instead the effects in the next INFO output. */
-    retval = redisAsyncCommand(ri->cc,
-        sentinelDiscardReplyCallback, NULL, "MULTI");
-    if (retval == REDIS_ERR) return retval;
-    ri->pending_commands++;
-
-    retval = redisAsyncCommand(ri->cc,
-        sentinelDiscardReplyCallback, NULL, "SLAVEOF %s %s", host, portstr);
-    if (retval == REDIS_ERR) return retval;
-    ri->pending_commands++;
-
-    retval = redisAsyncCommand(ri->cc,
-        sentinelDiscardReplyCallback, NULL, "CONFIG REWRITE");
-    if (retval == REDIS_ERR) return retval;
-    ri->pending_commands++;
+    retval = redisAsyncCommand(ri->link->cc,
+        sentinelDiscardReplyCallback, ri, "MULTI");
+    if (retval == C_ERR) return retval;
+    ri->link->pending_commands++;
+
+    retval = redisAsyncCommand(ri->link->cc,
+        sentinelDiscardReplyCallback, ri, "SLAVEOF %s %s", host, portstr);
+    if (retval == C_ERR) return retval;
+    ri->link->pending_commands++;
+
+    retval = redisAsyncCommand(ri->link->cc,
+        sentinelDiscardReplyCallback, ri, "CONFIG REWRITE");
+    if (retval == C_ERR) return retval;
+    ri->link->pending_commands++;
 
     /* CLIENT KILL TYPE <type> is only supported starting from Redis 2.8.12,
      * however sending it to an instance not understanding this command is not
      * an issue because CLIENT is variadic command, so Redis will not
      * recognized as a syntax error, and the transaction will not fail (but
      * only the unsupported command will fail). */
-    retval = redisAsyncCommand(ri->cc,
-        sentinelDiscardReplyCallback, NULL, "CLIENT KILL TYPE normal");
-    if (retval == REDIS_ERR) return retval;
-    ri->pending_commands++;
-
-    retval = redisAsyncCommand(ri->cc,
-        sentinelDiscardReplyCallback, NULL, "EXEC");
-    if (retval == REDIS_ERR) return retval;
-    ri->pending_commands++;
+    retval = redisAsyncCommand(ri->link->cc,
+        sentinelDiscardReplyCallback, ri, "CLIENT KILL TYPE normal");
+    if (retval == C_ERR) return retval;
+    ri->link->pending_commands++;
+
+    retval = redisAsyncCommand(ri->link->cc,
+        sentinelDiscardReplyCallback, ri, "EXEC");
+    if (retval == C_ERR) return retval;
+    ri->link->pending_commands++;
 
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* Setup the master state to start a failover. */
 void sentinelStartFailover(sentinelRedisInstance *master) {
-    redisAssert(master->flags & SRI_MASTER);
+    serverAssert(master->flags & SRI_MASTER);
 
     master->failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
     master->flags |= SRI_FAILOVER_IN_PROGRESS;
     master->failover_epoch = ++sentinel.current_epoch;
-    sentinelEvent(REDIS_WARNING,"+new-epoch",master,"%llu",
+    sentinelEvent(LL_WARNING,"+new-epoch",master,"%llu",
         (unsigned long long) sentinel.current_epoch);
-    sentinelEvent(REDIS_WARNING,"+try-failover",master,"%@");
+    sentinelEvent(LL_WARNING,"+try-failover",master,"%@");
     master->failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
     master->failover_state_change_time = mstime();
 }
 
 /* This function checks if there are the conditions to start the failover,
  * that is:
@@ -3459,13 +3819,13 @@
                             master->failover_timeout*2) / 1000;
             char ctimebuf[26];
 
             ctime_r(&clock,ctimebuf);
             ctimebuf[24] = '\0'; /* Remove newline. */
             master->failover_delay_logged = master->failover_start_time;
-            redisLog(REDIS_WARNING,
+            serverLog(LL_WARNING,
                 "Next failover delay: I will not start a failover before %s",
                 ctimebuf);
         }
         return 0;
     }
 
@@ -3548,14 +3908,15 @@
 
     di = dictGetIterator(master->slaves);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *slave = dictGetVal(de);
         mstime_t info_validity_time;
 
-        if (slave->flags & (SRI_S_DOWN|SRI_O_DOWN|SRI_DISCONNECTED)) continue;
-        if (mstime() - slave->last_avail_time > SENTINEL_PING_PERIOD*5) continue;
+        if (slave->flags & (SRI_S_DOWN|SRI_O_DOWN)) continue;
+        if (slave->link->disconnected) continue;
+        if (mstime() - slave->link->last_avail_time > SENTINEL_PING_PERIOD*5) continue;
         if (slave->slave_priority == 0) continue;
 
         /* If the master is in SDOWN state we get INFO for slaves every second.
          * Otherwise we get it with the usual period so we need to account for
          * a larger delay. */
         if (master->flags & SRI_S_DOWN)
@@ -3580,13 +3941,13 @@
 void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
     char *leader;
     int isleader;
 
     /* Check if we are the leader for the failover epoch. */
     leader = sentinelGetLeader(ri, ri->failover_epoch);
-    isleader = leader && strcasecmp(leader,server.runid) == 0;
+    isleader = leader && strcasecmp(leader,sentinel.myid) == 0;
     sdsfree(leader);
 
     /* If I'm not the leader, and it is not a forced failover via
      * SENTINEL FAILOVER, then I can't continue with the failover. */
     if (!isleader && !(ri->flags & SRI_FORCE_FAILOVER)) {
         int election_timeout = SENTINEL_ELECTION_TIMEOUT;
@@ -3594,75 +3955,77 @@
         /* The election timeout is the MIN between SENTINEL_ELECTION_TIMEOUT
          * and the configured failover timeout. */
         if (election_timeout > ri->failover_timeout)
             election_timeout = ri->failover_timeout;
         /* Abort the failover if I'm not the leader after some time. */
         if (mstime() - ri->failover_start_time > election_timeout) {
-            sentinelEvent(REDIS_WARNING,"-failover-abort-not-elected",ri,"%@");
+            sentinelEvent(LL_WARNING,"-failover-abort-not-elected",ri,"%@");
             sentinelAbortFailover(ri);
         }
         return;
     }
-    sentinelEvent(REDIS_WARNING,"+elected-leader",ri,"%@");
+    sentinelEvent(LL_WARNING,"+elected-leader",ri,"%@");
+    if (sentinel.simfailure_flags & SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION)
+        sentinelSimFailureCrash();
     ri->failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;
     ri->failover_state_change_time = mstime();
-    sentinelEvent(REDIS_WARNING,"+failover-state-select-slave",ri,"%@");
+    sentinelEvent(LL_WARNING,"+failover-state-select-slave",ri,"%@");
 }
 
 void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
     sentinelRedisInstance *slave = sentinelSelectSlave(ri);
 
     /* We don't handle the timeout in this state as the function aborts
      * the failover or go forward in the next state. */
     if (slave == NULL) {
-        sentinelEvent(REDIS_WARNING,"-failover-abort-no-good-slave",ri,"%@");
+        sentinelEvent(LL_WARNING,"-failover-abort-no-good-slave",ri,"%@");
         sentinelAbortFailover(ri);
     } else {
-        sentinelEvent(REDIS_WARNING,"+selected-slave",slave,"%@");
+        sentinelEvent(LL_WARNING,"+selected-slave",slave,"%@");
         slave->flags |= SRI_PROMOTED;
         ri->promoted_slave = slave;
         ri->failover_state = SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE;
         ri->failover_state_change_time = mstime();
-        sentinelEvent(REDIS_NOTICE,"+failover-state-send-slaveof-noone",
+        sentinelEvent(LL_NOTICE,"+failover-state-send-slaveof-noone",
             slave, "%@");
     }
 }
 
 void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
     int retval;
 
     /* We can't send the command to the promoted slave if it is now
      * disconnected. Retry again and again with this state until the timeout
      * is reached, then abort the failover. */
-    if (ri->promoted_slave->flags & SRI_DISCONNECTED) {
+    if (ri->link->disconnected) {
         if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
-            sentinelEvent(REDIS_WARNING,"-failover-abort-slave-timeout",ri,"%@");
+            sentinelEvent(LL_WARNING,"-failover-abort-slave-timeout",ri,"%@");
             sentinelAbortFailover(ri);
         }
         return;
     }
 
     /* Send SLAVEOF NO ONE command to turn the slave into a master.
      * We actually register a generic callback for this command as we don't
      * really care about the reply. We check if it worked indirectly observing
      * if INFO returns a different role (master instead of slave). */
     retval = sentinelSendSlaveOf(ri->promoted_slave,NULL,0);
-    if (retval != REDIS_OK) return;
-    sentinelEvent(REDIS_NOTICE, "+failover-state-wait-promotion",
+    if (retval != C_OK) return;
+    sentinelEvent(LL_NOTICE, "+failover-state-wait-promotion",
         ri->promoted_slave,"%@");
     ri->failover_state = SENTINEL_FAILOVER_STATE_WAIT_PROMOTION;
     ri->failover_state_change_time = mstime();
 }
 
 /* We actually wait for promotion indirectly checking with INFO when the
  * slave turns into a master. */
 void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
     /* Just handle the timeout. Switching to the next state is handled
      * by the function parsing the INFO command of the promoted slave. */
     if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
-        sentinelEvent(REDIS_WARNING,"-failover-abort-slave-timeout",ri,"%@");
+        sentinelEvent(LL_WARNING,"-failover-abort-slave-timeout",ri,"%@");
         sentinelAbortFailover(ri);
     }
 }
 
 void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
     int not_reconfigured = 0, timeout = 0;
@@ -3688,17 +4051,17 @@
     dictReleaseIterator(di);
 
     /* Force end of failover on timeout. */
     if (elapsed > master->failover_timeout) {
         not_reconfigured = 0;
         timeout = 1;
-        sentinelEvent(REDIS_WARNING,"+failover-end-for-timeout",master,"%@");
+        sentinelEvent(LL_WARNING,"+failover-end-for-timeout",master,"%@");
     }
 
     if (not_reconfigured == 0) {
-        sentinelEvent(REDIS_WARNING,"+failover-end",master,"%@");
+        sentinelEvent(LL_WARNING,"+failover-end",master,"%@");
         master->failover_state = SENTINEL_FAILOVER_STATE_UPDATE_CONFIG;
         master->failover_state_change_time = mstime();
     }
 
     /* If I'm the leader it is a good idea to send a best effort SLAVEOF
      * command to all the slaves still not reconfigured to replicate with
@@ -3709,20 +4072,20 @@
 
         di = dictGetIterator(master->slaves);
         while((de = dictNext(di)) != NULL) {
             sentinelRedisInstance *slave = dictGetVal(de);
             int retval;
 
-            if (slave->flags &
-                (SRI_RECONF_DONE|SRI_RECONF_SENT|SRI_DISCONNECTED)) continue;
+            if (slave->flags & (SRI_RECONF_DONE|SRI_RECONF_SENT)) continue;
+            if (slave->link->disconnected) continue;
 
             retval = sentinelSendSlaveOf(slave,
                     master->promoted_slave->addr->ip,
                     master->promoted_slave->addr->port);
-            if (retval == REDIS_OK) {
-                sentinelEvent(REDIS_NOTICE,"+slave-reconf-sent-be",slave,"%@");
+            if (retval == C_OK) {
+                sentinelEvent(LL_NOTICE,"+slave-reconf-sent-be",slave,"%@");
                 slave->flags |= SRI_RECONF_SENT;
             }
         }
         dictReleaseIterator(di);
     }
 }
@@ -3758,30 +4121,30 @@
          * Sentinels will detect the slave as misconfigured and fix its
          * configuration later. */
         if ((slave->flags & SRI_RECONF_SENT) &&
             (mstime() - slave->slave_reconf_sent_time) >
             SENTINEL_SLAVE_RECONF_TIMEOUT)
         {
-            sentinelEvent(REDIS_NOTICE,"-slave-reconf-sent-timeout",slave,"%@");
+            sentinelEvent(LL_NOTICE,"-slave-reconf-sent-timeout",slave,"%@");
             slave->flags &= ~SRI_RECONF_SENT;
             slave->flags |= SRI_RECONF_DONE;
         }
 
         /* Nothing to do for instances that are disconnected or already
          * in RECONF_SENT state. */
-        if (slave->flags & (SRI_DISCONNECTED|SRI_RECONF_SENT|SRI_RECONF_INPROG))
-            continue;
+        if (slave->flags & (SRI_RECONF_SENT|SRI_RECONF_INPROG)) continue;
+        if (slave->link->disconnected) continue;
 
         /* Send SLAVEOF <new master>. */
         retval = sentinelSendSlaveOf(slave,
                 master->promoted_slave->addr->ip,
                 master->promoted_slave->addr->port);
-        if (retval == REDIS_OK) {
+        if (retval == C_OK) {
             slave->flags |= SRI_RECONF_SENT;
             slave->slave_reconf_sent_time = mstime();
-            sentinelEvent(REDIS_NOTICE,"+slave-reconf-sent",slave,"%@");
+            sentinelEvent(LL_NOTICE,"+slave-reconf-sent",slave,"%@");
             in_progress++;
         }
     }
     dictReleaseIterator(di);
 
     /* Check if all the slaves are reconfigured and handle timeout. */
@@ -3792,21 +4155,21 @@
  * SENTINEL_FAILOVER_STATE_UPDATE_CONFIG state. In this state we need
  * to remove it from the master table and add the promoted slave instead. */
 void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
     sentinelRedisInstance *ref = master->promoted_slave ?
                                  master->promoted_slave : master;
 
-    sentinelEvent(REDIS_WARNING,"+switch-master",master,"%s %s %d %s %d",
+    sentinelEvent(LL_WARNING,"+switch-master",master,"%s %s %d %s %d",
         master->name, master->addr->ip, master->addr->port,
         ref->addr->ip, ref->addr->port);
 
     sentinelResetMasterAndChangeAddress(master,ref->addr->ip,ref->addr->port);
 }
 
 void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
-    redisAssert(ri->flags & SRI_MASTER);
+    serverAssert(ri->flags & SRI_MASTER);
 
     if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) return;
 
     switch(ri->failover_state) {
         case SENTINEL_FAILOVER_STATE_WAIT_START:
             sentinelFailoverWaitStart(ri);
@@ -3829,14 +4192,14 @@
 /* Abort a failover in progress:
  *
  * This function can only be called before the promoted slave acknowledged
  * the slave -> master switch. Otherwise the failover can't be aborted and
  * will reach its end (possibly by timeout). */
 void sentinelAbortFailover(sentinelRedisInstance *ri) {
-    redisAssert(ri->flags & SRI_FAILOVER_IN_PROGRESS);
-    redisAssert(ri->failover_state <= SENTINEL_FAILOVER_STATE_WAIT_PROMOTION);
+    serverAssert(ri->flags & SRI_FAILOVER_IN_PROGRESS);
+    serverAssert(ri->failover_state <= SENTINEL_FAILOVER_STATE_WAIT_PROMOTION);
 
     ri->flags &= ~(SRI_FAILOVER_IN_PROGRESS|SRI_FORCE_FAILOVER);
     ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
     ri->failover_state_change_time = mstime();
     if (ri->promoted_slave) {
         ri->promoted_slave->flags &= ~SRI_PROMOTED;
@@ -3860,13 +4223,13 @@
     /* We don't proceed with the acting half if we are in TILT mode.
      * TILT happens when we find something odd with the time, like a
      * sudden change in the clock. */
     if (sentinel.tilt) {
         if (mstime()-sentinel.tilt_start_time < SENTINEL_TILT_PERIOD) return;
         sentinel.tilt = 0;
-        sentinelEvent(REDIS_WARNING,"-tilt",NULL,"#tilt mode exited");
+        sentinelEvent(LL_WARNING,"-tilt",NULL,"#tilt mode exited");
     }
 
     /* Every kind of instance */
     sentinelCheckSubjectivelyDown(ri);
 
     /* Masters and slaves */
@@ -3933,13 +4296,13 @@
     mstime_t now = mstime();
     mstime_t delta = now - sentinel.previous_time;
 
     if (delta < 0 || delta > SENTINEL_TILT_TRIGGER) {
         sentinel.tilt = 1;
         sentinel.tilt_start_time = mstime();
-        sentinelEvent(REDIS_WARNING,"+tilt",NULL,"#tilt mode entered");
+        sentinelEvent(LL_WARNING,"+tilt",NULL,"#tilt mode entered");
     }
     sentinel.previous_time = mstime();
 }
 
 void sentinelTimer(void) {
     sentinelCheckTiltCondition();
@@ -3951,9 +4314,9 @@
     /* We continuously change the frequency of the Redis "timer interrupt"
      * in order to desynchronize every Sentinel from every other.
      * This non-determinism avoids that Sentinels started at the same time
      * exactly continue to stay synchronized asking to be voted at the
      * same time again and again (resulting in nobody likely winning the
      * election because of split brain voting). */
-    server.hz = REDIS_DEFAULT_HZ + rand() % REDIS_DEFAULT_HZ;
+    server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;
 }
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sentinel.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sentinel.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sentinel.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sentinel.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: server.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: server.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: server.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src: server.o
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/setproctitle.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/setproctitle.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/setproctitle.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/setproctitle.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.c	2016-05-06 15:11:36.000000000 +0800
@@ -194,22 +194,25 @@
     /* Wipe variables */
     memset(context, '\0', sizeof(*context));
     memset(&finalcount, '\0', sizeof(finalcount));
 }
 /* ================ end of sha1.c ================ */
 
-#if 0
+#ifdef REDIS_TEST
 #define BUFSIZE 4096
 
-int
-main(int argc, char **argv)
+#define UNUSED(x) (void)(x)
+int sha1Test(int argc, char **argv)
 {
     SHA1_CTX ctx;
     unsigned char hash[20], buf[BUFSIZE];
     int i;
 
+    UNUSED(argc);
+    UNUSED(argv);
+
     for(i=0;i<BUFSIZE;i++)
         buf[i] = i;
 
     SHA1Init(&ctx);
     for(i=0;i<1000;i++)
         SHA1Update(&ctx, buf, BUFSIZE);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.h	2016-05-06 15:11:36.000000000 +0800
@@ -1,6 +1,8 @@
+#ifndef SHA1_H
+#define SHA1_H
 /* ================ sha1.h ================ */
 /*
 SHA-1 in C
 By Steve Reid <steve@edmweb.com>
 100% Public Domain
 */
@@ -12,6 +14,11 @@
 } SHA1_CTX;
 
 void SHA1Transform(uint32_t state[5], const unsigned char buffer[64]);
 void SHA1Init(SHA1_CTX* context);
 void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len);
 void SHA1Final(unsigned char digest[20], SHA1_CTX* context);
+
+#ifdef REDIS_TEST
+int sha1Test(int argc, char **argv);
+#endif
+#endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sha1.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sha1.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.c	2016-05-06 15:11:36.000000000 +0800
@@ -36,13 +36,13 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 
-#include "redis.h"
+#include "server.h"
 #include "slowlog.h"
 
 /* Create a new slowlog entry.
  * Incrementing the ref count of all the objects retained is up to
  * this function. */
 slowlogEntry *slowlogCreateEntry(robj **argv, int argc, long long duration) {
@@ -54,27 +54,27 @@
     se->argv = zmalloc(sizeof(robj*)*slargc);
     for (j = 0; j < slargc; j++) {
         /* Logging too many arguments is a useless memory waste, so we stop
          * at SLOWLOG_ENTRY_MAX_ARGC, but use the last argument to specify
          * how many remaining arguments there were in the original command. */
         if (slargc != argc && j == slargc-1) {
-            se->argv[j] = createObject(REDIS_STRING,
+            se->argv[j] = createObject(OBJ_STRING,
                 sdscatprintf(sdsempty(),"... (%d more arguments)",
                 argc-slargc+1));
         } else {
             /* Trim too long strings as well... */
-            if (argv[j]->type == REDIS_STRING &&
+            if (argv[j]->type == OBJ_STRING &&
                 sdsEncodedObject(argv[j]) &&
                 sdslen(argv[j]->ptr) > SLOWLOG_ENTRY_MAX_STRING)
             {
                 sds s = sdsnewlen(argv[j]->ptr, SLOWLOG_ENTRY_MAX_STRING);
 
                 s = sdscatprintf(s,"... (%lu more bytes)",
                     (unsigned long)
                     sdslen(argv[j]->ptr) - SLOWLOG_ENTRY_MAX_STRING);
-                se->argv[j] = createObject(REDIS_STRING,s);
+                se->argv[j] = createObject(OBJ_STRING,s);
             } else {
                 se->argv[j] = argv[j];
                 incrRefCount(argv[j]);
             }
         }
     }
@@ -124,13 +124,13 @@
     while (listLength(server.slowlog) > 0)
         listDelNode(server.slowlog,listLast(server.slowlog));
 }
 
 /* The SLOWLOG command. Implements all the subcommands needed to handle the
  * Redis slow log. */
-void slowlogCommand(redisClient *c) {
+void slowlogCommand(client *c) {
     if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"reset")) {
         slowlogReset();
         addReply(c,shared.ok);
     } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"len")) {
         addReplyLongLong(c,listLength(server.slowlog));
     } else if ((c->argc == 2 || c->argc == 3) &&
@@ -140,13 +140,13 @@
         listIter li;
         void *totentries;
         listNode *ln;
         slowlogEntry *se;
 
         if (c->argc == 3 &&
-            getLongFromObjectOrReply(c,c->argv[2],&count,NULL) != REDIS_OK)
+            getLongFromObjectOrReply(c,c->argv[2],&count,NULL) != C_OK)
             return;
 
         listRewind(server.slowlog,&li);
         totentries = addDeferredMultiBulkLength(c);
         while(count-- && (ln = listNext(&li))) {
             int j;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.h	2016-05-06 15:11:36.000000000 +0800
@@ -41,7 +41,7 @@
 
 /* Exported API */
 void slowlogInit(void);
 void slowlogPushEntryIfNeeded(robj **argv, int argc, long long duration);
 
 /* Exported commands */
-void slowlogCommand(redisClient *c);
+void slowlogCommand(client *c);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/slowlog.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/slowlog.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sort.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sort.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sort.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sort.c	2016-05-06 15:11:36.000000000 +0800
@@ -26,13 +26,13 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 
-#include "redis.h"
+#include "server.h"
 #include "pqsort.h" /* Partial qsort for SORT+LIMIT */
 #include <math.h> /* isnan() */
 
 zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);
 
 redisSortOperation *createSortOperation(int type, robj *pattern) {
@@ -107,19 +107,19 @@
 
     /* Lookup substituted key */
     o = lookupKeyRead(db,keyobj);
     if (o == NULL) goto noobj;
 
     if (fieldobj) {
-        if (o->type != REDIS_HASH) goto noobj;
+        if (o->type != OBJ_HASH) goto noobj;
 
         /* Retrieve value from hash by the field name. This operation
          * already increases the refcount of the returned object. */
         o = hashTypeGetObject(o, fieldobj);
     } else {
-        if (o->type != REDIS_STRING) goto noobj;
+        if (o->type != OBJ_STRING) goto noobj;
 
         /* Every object that this function returns needs to have its refcount
          * increased. sortCommand decreases it again. */
         incrRefCount(o);
     }
     decrRefCount(keyobj);
@@ -183,13 +183,13 @@
     }
     return server.sort_desc ? -cmp : cmp;
 }
 
 /* The SORT command is the most complex command in Redis. Warning: this code
  * is optimized for speed and a bit less for readability */
-void sortCommand(redisClient *c) {
+void sortCommand(client *c) {
     list *operations;
     unsigned int outputlen = 0;
     int desc = 0, alpha = 0;
     long limit_start = 0, limit_count = -1, start, end;
     int j, dontsort = 0, vectorlen;
     int getop = 0; /* GET operation counter */
@@ -197,15 +197,15 @@
     int syntax_error = 0;
     robj *sortval, *sortby = NULL, *storekey = NULL;
     redisSortObject *vector; /* Resulting vector to sort */
 
     /* Lookup the key to sort. It must be of the right types */
     sortval = lookupKeyRead(c->db,c->argv[1]);
-    if (sortval && sortval->type != REDIS_SET &&
-                   sortval->type != REDIS_LIST &&
-                   sortval->type != REDIS_ZSET)
+    if (sortval && sortval->type != OBJ_SET &&
+                   sortval->type != OBJ_LIST &&
+                   sortval->type != OBJ_ZSET)
     {
         addReply(c,shared.wrongtypeerr);
         return;
     }
 
     /* Create a list of operations to perform for every sorted element.
@@ -217,28 +217,28 @@
     /* Now we need to protect sortval incrementing its count, in the future
      * SORT may have options able to overwrite/delete keys during the sorting
      * and the sorted key itself may get destroyed */
     if (sortval)
         incrRefCount(sortval);
     else
-        sortval = createListObject();
+        sortval = createQuicklistObject();
 
     /* The SORT command has an SQL-alike syntax, parse it */
     while(j < c->argc) {
         int leftargs = c->argc-j-1;
         if (!strcasecmp(c->argv[j]->ptr,"asc")) {
             desc = 0;
         } else if (!strcasecmp(c->argv[j]->ptr,"desc")) {
             desc = 1;
         } else if (!strcasecmp(c->argv[j]->ptr,"alpha")) {
             alpha = 1;
         } else if (!strcasecmp(c->argv[j]->ptr,"limit") && leftargs >= 2) {
             if ((getLongFromObjectOrReply(c, c->argv[j+1], &limit_start, NULL)
-                 != REDIS_OK) ||
+                 != C_OK) ||
                 (getLongFromObjectOrReply(c, c->argv[j+2], &limit_count, NULL)
-                 != REDIS_OK))
+                 != C_OK))
             {
                 syntax_error++;
                 break;
             }
             j+=2;
         } else if (!strcasecmp(c->argv[j]->ptr,"store") && leftargs >= 1) {
@@ -264,13 +264,13 @@
             if (server.cluster_enabled) {
                 addReplyError(c,"GET option of SORT denied in Cluster mode.");
                 syntax_error++;
                 break;
             }
             listAddNodeTail(operations,createSortOperation(
-                REDIS_SORT_GET,c->argv[j+1]));
+                SORT_OP_GET,c->argv[j+1]));
             getop++;
             j++;
         } else {
             addReply(c,shared.syntaxerr);
             syntax_error++;
             break;
@@ -289,84 +289,109 @@
      * so the result is consistent across scripting and replication.
      *
      * The other types (list, sorted set) will retain their native order
      * even if no sort order is requested, so they remain stable across
      * scripting and replication. */
     if (dontsort &&
-        sortval->type == REDIS_SET &&
-        (storekey || c->flags & REDIS_LUA_CLIENT))
+        sortval->type == OBJ_SET &&
+        (storekey || c->flags & CLIENT_LUA))
     {
         /* Force ALPHA sorting */
         dontsort = 0;
         alpha = 1;
         sortby = NULL;
     }
 
     /* Destructively convert encoded sorted sets for SORT. */
-    if (sortval->type == REDIS_ZSET)
-        zsetConvert(sortval, REDIS_ENCODING_SKIPLIST);
+    if (sortval->type == OBJ_ZSET)
+        zsetConvert(sortval, OBJ_ENCODING_SKIPLIST);
 
     /* Objtain the length of the object to sort. */
     switch(sortval->type) {
-    case REDIS_LIST: vectorlen = listTypeLength(sortval); break;
-    case REDIS_SET: vectorlen =  setTypeSize(sortval); break;
-    case REDIS_ZSET: vectorlen = dictSize(((zset*)sortval->ptr)->dict); break;
-    default: vectorlen = 0; redisPanic("Bad SORT type"); /* Avoid GCC warning */
+    case OBJ_LIST: vectorlen = listTypeLength(sortval); break;
+    case OBJ_SET: vectorlen =  setTypeSize(sortval); break;
+    case OBJ_ZSET: vectorlen = dictSize(((zset*)sortval->ptr)->dict); break;
+    default: vectorlen = 0; serverPanic("Bad SORT type"); /* Avoid GCC warning */
     }
 
     /* Perform LIMIT start,count sanity checking. */
     start = (limit_start < 0) ? 0 : limit_start;
     end = (limit_count < 0) ? vectorlen-1 : start+limit_count-1;
     if (start >= vectorlen) {
         start = vectorlen-1;
         end = vectorlen-2;
     }
     if (end >= vectorlen) end = vectorlen-1;
 
-    /* Optimization:
+    /* Whenever possible, we load elements into the output array in a more
+     * direct way. This is possible if:
      *
-     * 1) if the object to sort is a sorted set.
+     * 1) The object to sort is a sorted set or a list (internally sorted).
      * 2) There is nothing to sort as dontsort is true (BY <constant string>).
-     * 3) We have a LIMIT option that actually reduces the number of elements
-     *    to fetch.
      *
-     * In this case to load all the objects in the vector is a huge waste of
-     * resources. We just allocate a vector that is big enough for the selected
-     * range length, and make sure to load just this part in the vector. */
-    if (sortval->type == REDIS_ZSET &&
+     * In this special case, if we have a LIMIT option that actually reduces
+     * the number of elements to fetch, we also optimize to just load the
+     * range we are interested in and allocating a vector that is big enough
+     * for the selected range length. */
+    if ((sortval->type == OBJ_ZSET || sortval->type == OBJ_LIST) &&
         dontsort &&
         (start != 0 || end != vectorlen-1))
     {
         vectorlen = end-start+1;
     }
 
     /* Load the sorting vector with all the objects to sort */
     vector = zmalloc(sizeof(redisSortObject)*vectorlen);
     j = 0;
 
-    if (sortval->type == REDIS_LIST) {
-        listTypeIterator *li = listTypeInitIterator(sortval,0,REDIS_TAIL);
+    if (sortval->type == OBJ_LIST && dontsort) {
+        /* Special handling for a list, if 'dontsort' is true.
+         * This makes sure we return elements in the list original
+         * ordering, accordingly to DESC / ASC options.
+         *
+         * Note that in this case we also handle LIMIT here in a direct
+         * way, just getting the required range, as an optimization. */
+        if (end >= start) {
+            listTypeIterator *li;
+            listTypeEntry entry;
+            li = listTypeInitIterator(sortval,
+                    desc ? (long)(listTypeLength(sortval) - start - 1) : start,
+                    desc ? LIST_HEAD : LIST_TAIL);
+
+            while(j < vectorlen && listTypeNext(li,&entry)) {
+                vector[j].obj = listTypeGet(&entry);
+                vector[j].u.score = 0;
+                vector[j].u.cmpobj = NULL;
+                j++;
+            }
+            listTypeReleaseIterator(li);
+            /* Fix start/end: output code is not aware of this optimization. */
+            end -= start;
+            start = 0;
+        }
+    } else if (sortval->type == OBJ_LIST) {
+        listTypeIterator *li = listTypeInitIterator(sortval,0,LIST_TAIL);
         listTypeEntry entry;
         while(listTypeNext(li,&entry)) {
             vector[j].obj = listTypeGet(&entry);
             vector[j].u.score = 0;
             vector[j].u.cmpobj = NULL;
             j++;
         }
         listTypeReleaseIterator(li);
-    } else if (sortval->type == REDIS_SET) {
+    } else if (sortval->type == OBJ_SET) {
         setTypeIterator *si = setTypeInitIterator(sortval);
         robj *ele;
         while((ele = setTypeNextObject(si)) != NULL) {
             vector[j].obj = ele;
             vector[j].u.score = 0;
             vector[j].u.cmpobj = NULL;
             j++;
         }
         setTypeReleaseIterator(si);
-    } else if (sortval->type == REDIS_ZSET && dontsort) {
+    } else if (sortval->type == OBJ_ZSET && dontsort) {
         /* Special handling for a sorted set, if 'dontsort' is true.
          * This makes sure we return elements in the sorted set original
          * ordering, accordingly to DESC / ASC options.
          *
          * Note that in this case we also handle LIMIT here in a direct
          * way, just getting the required range, as an optimization. */
@@ -388,42 +413,39 @@
             ln = zsl->header->level[0].forward;
             if (start > 0)
                 ln = zslGetElementByRank(zsl,start+1);
         }
 
         while(rangelen--) {
-            redisAssertWithInfo(c,sortval,ln != NULL);
+            serverAssertWithInfo(c,sortval,ln != NULL);
             ele = ln->obj;
             vector[j].obj = ele;
             vector[j].u.score = 0;
             vector[j].u.cmpobj = NULL;
             j++;
             ln = desc ? ln->backward : ln->level[0].forward;
         }
-        /* The code producing the output does not know that in the case of
-         * sorted set, 'dontsort', and LIMIT, we are able to get just the
-         * range, already sorted, so we need to adjust "start" and "end"
-         * to make sure start is set to 0. */
+        /* Fix start/end: output code is not aware of this optimization. */
         end -= start;
         start = 0;
-    } else if (sortval->type == REDIS_ZSET) {
+    } else if (sortval->type == OBJ_ZSET) {
         dict *set = ((zset*)sortval->ptr)->dict;
         dictIterator *di;
         dictEntry *setele;
         di = dictGetIterator(set);
         while((setele = dictNext(di)) != NULL) {
             vector[j].obj = dictGetKey(setele);
             vector[j].u.score = 0;
             vector[j].u.cmpobj = NULL;
             j++;
         }
         dictReleaseIterator(di);
     } else {
-        redisPanic("Unknown type");
+        serverPanic("Unknown type");
     }
-    redisAssertWithInfo(c,sortval,j == vectorlen);
+    serverAssertWithInfo(c,sortval,j == vectorlen);
 
     /* Now it's time to load the right scores in the sorting vector */
     if (dontsort == 0) {
         for (j = 0; j < vectorlen; j++) {
             robj *byval;
             if (sortby) {
@@ -444,19 +466,19 @@
                     vector[j].u.score = strtod(byval->ptr,&eptr);
                     if (eptr[0] != '\0' || errno == ERANGE ||
                         isnan(vector[j].u.score))
                     {
                         int_convertion_error = 1;
                     }
-                } else if (byval->encoding == REDIS_ENCODING_INT) {
+                } else if (byval->encoding == OBJ_ENCODING_INT) {
                     /* Don't need to decode the object if it's
                      * integer-encoded (the only encoding supported) so
                      * far. We can just cast it */
                     vector[j].u.score = (long)byval->ptr;
                 } else {
-                    redisAssertWithInfo(c,sortval,1 != 1);
+                    serverAssertWithInfo(c,sortval,1 != 1);
                 }
             }
 
             /* when the object was retrieved using lookupKeyByPattern,
              * its refcount needs to be decreased. */
             if (sortby) {
@@ -492,73 +514,73 @@
             listRewind(operations,&li);
             while((ln = listNext(&li))) {
                 redisSortOperation *sop = ln->value;
                 robj *val = lookupKeyByPattern(c->db,sop->pattern,
                     vector[j].obj);
 
-                if (sop->type == REDIS_SORT_GET) {
+                if (sop->type == SORT_OP_GET) {
                     if (!val) {
                         addReply(c,shared.nullbulk);
                     } else {
                         addReplyBulk(c,val);
                         decrRefCount(val);
                     }
                 } else {
                     /* Always fails */
-                    redisAssertWithInfo(c,sortval,sop->type == REDIS_SORT_GET);
+                    serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);
                 }
             }
         }
     } else {
-        robj *sobj = createZiplistObject();
+        robj *sobj = createQuicklistObject();
 
         /* STORE option specified, set the sorting result as a List object */
         for (j = start; j <= end; j++) {
             listNode *ln;
             listIter li;
 
             if (!getop) {
-                listTypePush(sobj,vector[j].obj,REDIS_TAIL);
+                listTypePush(sobj,vector[j].obj,LIST_TAIL);
             } else {
                 listRewind(operations,&li);
                 while((ln = listNext(&li))) {
                     redisSortOperation *sop = ln->value;
                     robj *val = lookupKeyByPattern(c->db,sop->pattern,
                         vector[j].obj);
 
-                    if (sop->type == REDIS_SORT_GET) {
+                    if (sop->type == SORT_OP_GET) {
                         if (!val) val = createStringObject("",0);
 
                         /* listTypePush does an incrRefCount, so we should take care
                          * care of the incremented refcount caused by either
                          * lookupKeyByPattern or createStringObject("",0) */
-                        listTypePush(sobj,val,REDIS_TAIL);
+                        listTypePush(sobj,val,LIST_TAIL);
                         decrRefCount(val);
                     } else {
                         /* Always fails */
-                        redisAssertWithInfo(c,sortval,sop->type == REDIS_SORT_GET);
+                        serverAssertWithInfo(c,sortval,sop->type == SORT_OP_GET);
                     }
                 }
             }
         }
         if (outputlen) {
             setKey(c->db,storekey,sobj);
-            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"sortstore",storekey,
+            notifyKeyspaceEvent(NOTIFY_LIST,"sortstore",storekey,
                                 c->db->id);
             server.dirty += outputlen;
         } else if (dbDelete(c->db,storekey)) {
             signalModifiedKey(c->db,storekey);
-            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",storekey,c->db->id);
+            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",storekey,c->db->id);
             server.dirty++;
         }
         decrRefCount(sobj);
         addReplyLongLong(c,outputlen);
     }
 
     /* Cleanup */
-    if (sortval->type == REDIS_LIST || sortval->type == REDIS_SET)
+    if (sortval->type == OBJ_LIST || sortval->type == OBJ_SET)
         for (j = 0; j < vectorlen; j++)
             decrRefCount(vector[j].obj);
     decrRefCount(sortval);
     listRelease(operations);
     for (j = 0; j < vectorlen; j++) {
         if (alpha && vector[j].u.cmpobj)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sort.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sort.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sort.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sort.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sparkline.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sparkline.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sparkline.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sparkline.c	2016-05-06 15:11:36.000000000 +0800
@@ -27,13 +27,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 #include <math.h>
 
 /* This is the charset used to display the graphs, but multiple rows are used
  * to increase the resolution. */
 static char charset[] = "_-`";
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sparkline.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sparkline.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/sparkline.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/sparkline.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/syncio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/syncio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/syncio.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/syncio.c	2016-05-06 15:11:36.000000000 +0800
@@ -25,38 +25,38 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 /* ----------------- Blocking sockets I/O with timeouts --------------------- */
 
 /* Redis performs most of the I/O in a nonblocking way, with the exception
  * of the SYNC command where the slave does it in a blocking way, and
  * the MIGRATE command that must be blocking in order to be atomic from the
  * point of view of the two instances (one migrating the key and one receiving
  * the key). This is why need the following blocking I/O functions.
  *
  * All the functions take the timeout in milliseconds. */
 
-#define REDIS_SYNCIO_RESOLUTION 10 /* Resolution in milliseconds */
+#define SYNCIO__RESOLUTION 10 /* Resolution in milliseconds */
 
 /* Write the specified payload to 'fd'. If writing the whole payload will be
  * done within 'timeout' milliseconds the operation succeeds and 'size' is
  * returned. Otherwise the operation fails, -1 is returned, and an unspecified
  * partial write could be performed against the file descriptor. */
 ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout) {
     ssize_t nwritten, ret = size;
     long long start = mstime();
     long long remaining = timeout;
 
     while(1) {
-        long long wait = (remaining > REDIS_SYNCIO_RESOLUTION) ?
-                          remaining : REDIS_SYNCIO_RESOLUTION;
+        long long wait = (remaining > SYNCIO__RESOLUTION) ?
+                          remaining : SYNCIO__RESOLUTION;
         long long elapsed;
 
         /* Optimistically try to write before checking if the file descriptor
          * is actually writable. At worst we get EAGAIN. */
         nwritten = write(fd,ptr,size);
         if (nwritten == -1) {
@@ -86,14 +86,14 @@
     ssize_t nread, totread = 0;
     long long start = mstime();
     long long remaining = timeout;
 
     if (size == 0) return 0;
     while(1) {
-        long long wait = (remaining > REDIS_SYNCIO_RESOLUTION) ?
-                          remaining : REDIS_SYNCIO_RESOLUTION;
+        long long wait = (remaining > SYNCIO__RESOLUTION) ?
+                          remaining : SYNCIO__RESOLUTION;
         long long elapsed;
 
         /* Optimistically try to read before checking if the file descriptor
          * is actually readable. At worst we get EAGAIN. */
         nread = read(fd,ptr,size);
         if (nread == 0) return -1; /* short read. */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/syncio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/syncio.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/syncio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/syncio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_hash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_hash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_hash.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_hash.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,40 +24,40 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include <math.h>
 
 /*-----------------------------------------------------------------------------
  * Hash type API
  *----------------------------------------------------------------------------*/
 
 /* Check the length of a number of objects to see if we need to convert a
  * ziplist to a real hash. Note that we only check string encoded objects
  * as their string length can be queried in constant time. */
 void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
     int i;
 
-    if (o->encoding != REDIS_ENCODING_ZIPLIST) return;
+    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;
 
     for (i = start; i <= end; i++) {
         if (sdsEncodedObject(argv[i]) &&
             sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)
         {
-            hashTypeConvert(o, REDIS_ENCODING_HT);
+            hashTypeConvert(o, OBJ_ENCODING_HT);
             break;
         }
     }
 }
 
 /* Encode given objects in-place when the hash uses a dict. */
 void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2) {
-    if (subject->encoding == REDIS_ENCODING_HT) {
+    if (subject->encoding == OBJ_ENCODING_HT) {
         if (o1) *o1 = tryObjectEncoding(*o1);
         if (o2) *o2 = tryObjectEncoding(*o2);
     }
 }
 
 /* Get the value from a ziplist encoded hash, identified by field.
@@ -67,44 +67,44 @@
                            unsigned int *vlen,
                            long long *vll)
 {
     unsigned char *zl, *fptr = NULL, *vptr = NULL;
     int ret;
 
-    redisAssert(o->encoding == REDIS_ENCODING_ZIPLIST);
+    serverAssert(o->encoding == OBJ_ENCODING_ZIPLIST);
 
     field = getDecodedObject(field);
 
     zl = o->ptr;
     fptr = ziplistIndex(zl, ZIPLIST_HEAD);
     if (fptr != NULL) {
         fptr = ziplistFind(fptr, field->ptr, sdslen(field->ptr), 1);
         if (fptr != NULL) {
             /* Grab pointer to the value (fptr points to the field) */
             vptr = ziplistNext(zl, fptr);
-            redisAssert(vptr != NULL);
+            serverAssert(vptr != NULL);
         }
     }
 
     decrRefCount(field);
 
     if (vptr != NULL) {
         ret = ziplistGet(vptr, vstr, vlen, vll);
-        redisAssert(ret);
+        serverAssert(ret);
         return 0;
     }
 
     return -1;
 }
 
 /* Get the value from a hash table encoded hash, identified by field.
  * Returns -1 when the field cannot be found. */
 int hashTypeGetFromHashTable(robj *o, robj *field, robj **value) {
     dictEntry *de;
 
-    redisAssert(o->encoding == REDIS_ENCODING_HT);
+    serverAssert(o->encoding == OBJ_ENCODING_HT);
 
     de = dictFind(o->ptr, field);
     if (de == NULL) return -1;
     *value = dictGetVal(de);
     return 0;
 }
@@ -115,78 +115,100 @@
  *
  * The lower level function can prevent copy on write so it is
  * the preferred way of doing read operations. */
 robj *hashTypeGetObject(robj *o, robj *field) {
     robj *value = NULL;
 
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         if (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0) {
             if (vstr) {
                 value = createStringObject((char*)vstr, vlen);
             } else {
                 value = createStringObjectFromLongLong(vll);
             }
         }
-
-    } else if (o->encoding == REDIS_ENCODING_HT) {
+    } else if (o->encoding == OBJ_ENCODING_HT) {
         robj *aux;
 
         if (hashTypeGetFromHashTable(o, field, &aux) == 0) {
             incrRefCount(aux);
             value = aux;
         }
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
     return value;
 }
 
+/* Higher level function using hashTypeGet*() to return the length of the
+ * object associated with the requested field, or 0 if the field does not
+ * exist. */
+size_t hashTypeGetValueLength(robj *o, robj *field) {
+    size_t len = 0;
+    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
+        unsigned char *vstr = NULL;
+        unsigned int vlen = UINT_MAX;
+        long long vll = LLONG_MAX;
+
+        if (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0)
+            len = vstr ? vlen : sdigits10(vll);
+    } else if (o->encoding == OBJ_ENCODING_HT) {
+        robj *aux;
+
+        if (hashTypeGetFromHashTable(o, field, &aux) == 0)
+            len = stringObjectLen(aux);
+    } else {
+        serverPanic("Unknown hash encoding");
+    }
+    return len;
+}
+
 /* Test if the specified field exists in the given hash. Returns 1 if the field
  * exists, and 0 when it doesn't. */
 int hashTypeExists(robj *o, robj *field) {
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         if (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0) return 1;
-    } else if (o->encoding == REDIS_ENCODING_HT) {
+    } else if (o->encoding == OBJ_ENCODING_HT) {
         robj *aux;
 
         if (hashTypeGetFromHashTable(o, field, &aux) == 0) return 1;
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
     return 0;
 }
 
 /* Add an element, discard the old if the key already exists.
  * Return 0 on insert and 1 on update.
  * This function will take care of incrementing the reference count of the
  * retained fields and value objects. */
 int hashTypeSet(robj *o, robj *field, robj *value) {
     int update = 0;
 
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl, *fptr, *vptr;
 
         field = getDecodedObject(field);
         value = getDecodedObject(value);
 
         zl = o->ptr;
         fptr = ziplistIndex(zl, ZIPLIST_HEAD);
         if (fptr != NULL) {
             fptr = ziplistFind(fptr, field->ptr, sdslen(field->ptr), 1);
             if (fptr != NULL) {
                 /* Grab pointer to the value (fptr points to the field) */
                 vptr = ziplistNext(zl, fptr);
-                redisAssert(vptr != NULL);
+                serverAssert(vptr != NULL);
                 update = 1;
 
                 /* Delete value */
                 zl = ziplistDelete(zl, &vptr);
 
                 /* Insert new value */
@@ -202,32 +224,32 @@
         o->ptr = zl;
         decrRefCount(field);
         decrRefCount(value);
 
         /* Check if the ziplist needs to be converted to a hash table */
         if (hashTypeLength(o) > server.hash_max_ziplist_entries)
-            hashTypeConvert(o, REDIS_ENCODING_HT);
-    } else if (o->encoding == REDIS_ENCODING_HT) {
+            hashTypeConvert(o, OBJ_ENCODING_HT);
+    } else if (o->encoding == OBJ_ENCODING_HT) {
         if (dictReplace(o->ptr, field, value)) { /* Insert */
             incrRefCount(field);
         } else { /* Update */
             update = 1;
         }
         incrRefCount(value);
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
     return update;
 }
 
 /* Delete an element from a hash.
  * Return 1 on deleted and 0 on not found. */
 int hashTypeDelete(robj *o, robj *field) {
     int deleted = 0;
 
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl, *fptr;
 
         field = getDecodedObject(field);
 
         zl = o->ptr;
         fptr = ziplistIndex(zl, ZIPLIST_HEAD);
@@ -240,262 +262,262 @@
                 deleted = 1;
             }
         }
 
         decrRefCount(field);
 
-    } else if (o->encoding == REDIS_ENCODING_HT) {
-        if (dictDelete((dict*)o->ptr, field) == REDIS_OK) {
+    } else if (o->encoding == OBJ_ENCODING_HT) {
+        if (dictDelete((dict*)o->ptr, field) == C_OK) {
             deleted = 1;
 
             /* Always check if the dictionary needs a resize after a delete. */
             if (htNeedsResize(o->ptr)) dictResize(o->ptr);
         }
 
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
 
     return deleted;
 }
 
 /* Return the number of elements in a hash. */
 unsigned long hashTypeLength(robj *o) {
     unsigned long length = ULONG_MAX;
 
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         length = ziplistLen(o->ptr) / 2;
-    } else if (o->encoding == REDIS_ENCODING_HT) {
+    } else if (o->encoding == OBJ_ENCODING_HT) {
         length = dictSize((dict*)o->ptr);
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
 
     return length;
 }
 
 hashTypeIterator *hashTypeInitIterator(robj *subject) {
     hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));
     hi->subject = subject;
     hi->encoding = subject->encoding;
 
-    if (hi->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
         hi->fptr = NULL;
         hi->vptr = NULL;
-    } else if (hi->encoding == REDIS_ENCODING_HT) {
+    } else if (hi->encoding == OBJ_ENCODING_HT) {
         hi->di = dictGetIterator(subject->ptr);
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
 
     return hi;
 }
 
 void hashTypeReleaseIterator(hashTypeIterator *hi) {
-    if (hi->encoding == REDIS_ENCODING_HT) {
+    if (hi->encoding == OBJ_ENCODING_HT) {
         dictReleaseIterator(hi->di);
     }
 
     zfree(hi);
 }
 
-/* Move to the next entry in the hash. Return REDIS_OK when the next entry
- * could be found and REDIS_ERR when the iterator reaches the end. */
+/* Move to the next entry in the hash. Return C_OK when the next entry
+ * could be found and C_ERR when the iterator reaches the end. */
 int hashTypeNext(hashTypeIterator *hi) {
-    if (hi->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl;
         unsigned char *fptr, *vptr;
 
         zl = hi->subject->ptr;
         fptr = hi->fptr;
         vptr = hi->vptr;
 
         if (fptr == NULL) {
             /* Initialize cursor */
-            redisAssert(vptr == NULL);
+            serverAssert(vptr == NULL);
             fptr = ziplistIndex(zl, 0);
         } else {
             /* Advance cursor */
-            redisAssert(vptr != NULL);
+            serverAssert(vptr != NULL);
             fptr = ziplistNext(zl, vptr);
         }
-        if (fptr == NULL) return REDIS_ERR;
+        if (fptr == NULL) return C_ERR;
 
         /* Grab pointer to the value (fptr points to the field) */
         vptr = ziplistNext(zl, fptr);
-        redisAssert(vptr != NULL);
+        serverAssert(vptr != NULL);
 
         /* fptr, vptr now point to the first or next pair */
         hi->fptr = fptr;
         hi->vptr = vptr;
-    } else if (hi->encoding == REDIS_ENCODING_HT) {
-        if ((hi->de = dictNext(hi->di)) == NULL) return REDIS_ERR;
+    } else if (hi->encoding == OBJ_ENCODING_HT) {
+        if ((hi->de = dictNext(hi->di)) == NULL) return C_ERR;
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* Get the field or value at iterator cursor, for an iterator on a hash value
  * encoded as a ziplist. Prototype is similar to `hashTypeGetFromZiplist`. */
 void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,
                                 unsigned char **vstr,
                                 unsigned int *vlen,
                                 long long *vll)
 {
     int ret;
 
-    redisAssert(hi->encoding == REDIS_ENCODING_ZIPLIST);
+    serverAssert(hi->encoding == OBJ_ENCODING_ZIPLIST);
 
-    if (what & REDIS_HASH_KEY) {
+    if (what & OBJ_HASH_KEY) {
         ret = ziplistGet(hi->fptr, vstr, vlen, vll);
-        redisAssert(ret);
+        serverAssert(ret);
     } else {
         ret = ziplistGet(hi->vptr, vstr, vlen, vll);
-        redisAssert(ret);
+        serverAssert(ret);
     }
 }
 
 /* Get the field or value at iterator cursor, for an iterator on a hash value
  * encoded as a ziplist. Prototype is similar to `hashTypeGetFromHashTable`. */
 void hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what, robj **dst) {
-    redisAssert(hi->encoding == REDIS_ENCODING_HT);
+    serverAssert(hi->encoding == OBJ_ENCODING_HT);
 
-    if (what & REDIS_HASH_KEY) {
+    if (what & OBJ_HASH_KEY) {
         *dst = dictGetKey(hi->de);
     } else {
         *dst = dictGetVal(hi->de);
     }
 }
 
 /* A non copy-on-write friendly but higher level version of hashTypeCurrent*()
  * that returns an object with incremented refcount (or a new object). It is up
  * to the caller to decrRefCount() the object if no reference is retained. */
 robj *hashTypeCurrentObject(hashTypeIterator *hi, int what) {
     robj *dst;
 
-    if (hi->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
         if (vstr) {
             dst = createStringObject((char*)vstr, vlen);
         } else {
             dst = createStringObjectFromLongLong(vll);
         }
-    } else if (hi->encoding == REDIS_ENCODING_HT) {
+    } else if (hi->encoding == OBJ_ENCODING_HT) {
         hashTypeCurrentFromHashTable(hi, what, &dst);
         incrRefCount(dst);
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
     return dst;
 }
 
-robj *hashTypeLookupWriteOrCreate(redisClient *c, robj *key) {
+robj *hashTypeLookupWriteOrCreate(client *c, robj *key) {
     robj *o = lookupKeyWrite(c->db,key);
     if (o == NULL) {
         o = createHashObject();
         dbAdd(c->db,key,o);
     } else {
-        if (o->type != REDIS_HASH) {
+        if (o->type != OBJ_HASH) {
             addReply(c,shared.wrongtypeerr);
             return NULL;
         }
     }
     return o;
 }
 
 void hashTypeConvertZiplist(robj *o, int enc) {
-    redisAssert(o->encoding == REDIS_ENCODING_ZIPLIST);
+    serverAssert(o->encoding == OBJ_ENCODING_ZIPLIST);
 
-    if (enc == REDIS_ENCODING_ZIPLIST) {
+    if (enc == OBJ_ENCODING_ZIPLIST) {
         /* Nothing to do... */
 
-    } else if (enc == REDIS_ENCODING_HT) {
+    } else if (enc == OBJ_ENCODING_HT) {
         hashTypeIterator *hi;
         dict *dict;
         int ret;
 
         hi = hashTypeInitIterator(o);
         dict = dictCreate(&hashDictType, NULL);
 
-        while (hashTypeNext(hi) != REDIS_ERR) {
+        while (hashTypeNext(hi) != C_ERR) {
             robj *field, *value;
 
-            field = hashTypeCurrentObject(hi, REDIS_HASH_KEY);
+            field = hashTypeCurrentObject(hi, OBJ_HASH_KEY);
             field = tryObjectEncoding(field);
-            value = hashTypeCurrentObject(hi, REDIS_HASH_VALUE);
+            value = hashTypeCurrentObject(hi, OBJ_HASH_VALUE);
             value = tryObjectEncoding(value);
             ret = dictAdd(dict, field, value);
             if (ret != DICT_OK) {
-                redisLogHexDump(REDIS_WARNING,"ziplist with dup elements dump",
+                serverLogHexDump(LL_WARNING,"ziplist with dup elements dump",
                     o->ptr,ziplistBlobLen(o->ptr));
-                redisAssert(ret == DICT_OK);
+                serverAssert(ret == DICT_OK);
             }
         }
 
         hashTypeReleaseIterator(hi);
         zfree(o->ptr);
 
-        o->encoding = REDIS_ENCODING_HT;
+        o->encoding = OBJ_ENCODING_HT;
         o->ptr = dict;
 
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
 }
 
 void hashTypeConvert(robj *o, int enc) {
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         hashTypeConvertZiplist(o, enc);
-    } else if (o->encoding == REDIS_ENCODING_HT) {
-        redisPanic("Not implemented");
+    } else if (o->encoding == OBJ_ENCODING_HT) {
+        serverPanic("Not implemented");
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
 }
 
 /*-----------------------------------------------------------------------------
  * Hash type commands
  *----------------------------------------------------------------------------*/
 
-void hsetCommand(redisClient *c) {
+void hsetCommand(client *c) {
     int update;
     robj *o;
 
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
     hashTypeTryConversion(o,c->argv,2,3);
     hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);
     update = hashTypeSet(o,c->argv[2],c->argv[3]);
     addReply(c, update ? shared.czero : shared.cone);
     signalModifiedKey(c->db,c->argv[1]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hset",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
     server.dirty++;
 }
 
-void hsetnxCommand(redisClient *c) {
+void hsetnxCommand(client *c) {
     robj *o;
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
     hashTypeTryConversion(o,c->argv,2,3);
 
     if (hashTypeExists(o, c->argv[2])) {
         addReply(c, shared.czero);
     } else {
         hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);
         hashTypeSet(o,c->argv[2],c->argv[3]);
         addReply(c, shared.cone);
         signalModifiedKey(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hset",c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
         server.dirty++;
     }
 }
 
-void hmsetCommand(redisClient *c) {
+void hmsetCommand(client *c) {
     int i;
     robj *o;
 
     if ((c->argc % 2) == 1) {
         addReplyError(c,"wrong number of arguments for HMSET");
         return;
@@ -506,25 +528,25 @@
     for (i = 2; i < c->argc; i += 2) {
         hashTypeTryObjectEncoding(o,&c->argv[i], &c->argv[i+1]);
         hashTypeSet(o,c->argv[i],c->argv[i+1]);
     }
     addReply(c, shared.ok);
     signalModifiedKey(c->db,c->argv[1]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hset",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
     server.dirty++;
 }
 
-void hincrbyCommand(redisClient *c) {
+void hincrbyCommand(client *c) {
     long long value, incr, oldvalue;
     robj *o, *current, *new;
 
-    if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != REDIS_OK) return;
+    if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
     if ((current = hashTypeGetObject(o,c->argv[2])) != NULL) {
         if (getLongLongFromObjectOrReply(c,current,&value,
-            "hash value is not an integer") != REDIS_OK) {
+            "hash value is not an integer") != C_OK) {
             decrRefCount(current);
             return;
         }
         decrRefCount(current);
     } else {
         value = 0;
@@ -540,25 +562,25 @@
     new = createStringObjectFromLongLong(value);
     hashTypeTryObjectEncoding(o,&c->argv[2],NULL);
     hashTypeSet(o,c->argv[2],new);
     decrRefCount(new);
     addReplyLongLong(c,value);
     signalModifiedKey(c->db,c->argv[1]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hincrby",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_HASH,"hincrby",c->argv[1],c->db->id);
     server.dirty++;
 }
 
-void hincrbyfloatCommand(redisClient *c) {
+void hincrbyfloatCommand(client *c) {
     double long value, incr;
     robj *o, *current, *new, *aux;
 
-    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != REDIS_OK) return;
+    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
     if ((current = hashTypeGetObject(o,c->argv[2])) != NULL) {
         if (getLongDoubleFromObjectOrReply(c,current,&value,
-            "hash value is not a valid float") != REDIS_OK) {
+            "hash value is not a valid float") != C_OK) {
             decrRefCount(current);
             return;
         }
         decrRefCount(current);
     } else {
         value = 0;
@@ -567,34 +589,34 @@
     value += incr;
     new = createStringObjectFromLongDouble(value,1);
     hashTypeTryObjectEncoding(o,&c->argv[2],NULL);
     hashTypeSet(o,c->argv[2],new);
     addReplyBulk(c,new);
     signalModifiedKey(c->db,c->argv[1]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hincrbyfloat",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_HASH,"hincrbyfloat",c->argv[1],c->db->id);
     server.dirty++;
 
     /* Always replicate HINCRBYFLOAT as an HSET command with the final value
      * in order to make sure that differences in float pricision or formatting
      * will not create differences in replicas or after an AOF restart. */
     aux = createStringObject("HSET",4);
     rewriteClientCommandArgument(c,0,aux);
     decrRefCount(aux);
     rewriteClientCommandArgument(c,3,new);
     decrRefCount(new);
 }
 
-static void addHashFieldToReply(redisClient *c, robj *o, robj *field) {
+static void addHashFieldToReply(client *c, robj *o, robj *field) {
     int ret;
 
     if (o == NULL) {
         addReply(c, shared.nullbulk);
         return;
     }
 
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         ret = hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll);
         if (ret < 0) {
@@ -604,60 +626,60 @@
                 addReplyBulkCBuffer(c, vstr, vlen);
             } else {
                 addReplyBulkLongLong(c, vll);
             }
         }
 
-    } else if (o->encoding == REDIS_ENCODING_HT) {
+    } else if (o->encoding == OBJ_ENCODING_HT) {
         robj *value;
 
         ret = hashTypeGetFromHashTable(o, field, &value);
         if (ret < 0) {
             addReply(c, shared.nullbulk);
         } else {
             addReplyBulk(c, value);
         }
 
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
 }
 
-void hgetCommand(redisClient *c) {
+void hgetCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
-        checkType(c,o,REDIS_HASH)) return;
+        checkType(c,o,OBJ_HASH)) return;
 
     addHashFieldToReply(c, o, c->argv[2]);
 }
 
-void hmgetCommand(redisClient *c) {
+void hmgetCommand(client *c) {
     robj *o;
     int i;
 
     /* Don't abort when the key cannot be found. Non-existing keys are empty
      * hashes, where HMGET should respond with a series of null bulks. */
     o = lookupKeyRead(c->db, c->argv[1]);
-    if (o != NULL && o->type != REDIS_HASH) {
+    if (o != NULL && o->type != OBJ_HASH) {
         addReply(c, shared.wrongtypeerr);
         return;
     }
 
     addReplyMultiBulkLen(c, c->argc-2);
     for (i = 2; i < c->argc; i++) {
         addHashFieldToReply(c, o, c->argv[i]);
     }
 }
 
-void hdelCommand(redisClient *c) {
+void hdelCommand(client *c) {
     robj *o;
     int j, deleted = 0, keyremoved = 0;
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,REDIS_HASH)) return;
+        checkType(c,o,OBJ_HASH)) return;
 
     for (j = 2; j < c->argc; j++) {
         if (hashTypeDelete(o,c->argv[j])) {
             deleted++;
             if (hashTypeLength(o) == 0) {
                 dbDelete(c->db,c->argv[1]);
@@ -665,107 +687,116 @@
                 break;
             }
         }
     }
     if (deleted) {
         signalModifiedKey(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hdel",c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_HASH,"hdel",c->argv[1],c->db->id);
         if (keyremoved)
-            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],
+            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],
                                 c->db->id);
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
 }
 
-void hlenCommand(redisClient *c) {
+void hlenCommand(client *c) {
     robj *o;
+
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,REDIS_HASH)) return;
+        checkType(c,o,OBJ_HASH)) return;
 
     addReplyLongLong(c,hashTypeLength(o));
 }
 
-static void addHashIteratorCursorToReply(redisClient *c, hashTypeIterator *hi, int what) {
-    if (hi->encoding == REDIS_ENCODING_ZIPLIST) {
+void hstrlenCommand(client *c) {
+    robj *o;
+
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,o,OBJ_HASH)) return;
+    addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]));
+}
+
+static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {
+    if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
         if (vstr) {
             addReplyBulkCBuffer(c, vstr, vlen);
         } else {
             addReplyBulkLongLong(c, vll);
         }
 
-    } else if (hi->encoding == REDIS_ENCODING_HT) {
+    } else if (hi->encoding == OBJ_ENCODING_HT) {
         robj *value;
 
         hashTypeCurrentFromHashTable(hi, what, &value);
         addReplyBulk(c, value);
 
     } else {
-        redisPanic("Unknown hash encoding");
+        serverPanic("Unknown hash encoding");
     }
 }
 
-void genericHgetallCommand(redisClient *c, int flags) {
+void genericHgetallCommand(client *c, int flags) {
     robj *o;
     hashTypeIterator *hi;
     int multiplier = 0;
     int length, count = 0;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
-        || checkType(c,o,REDIS_HASH)) return;
+        || checkType(c,o,OBJ_HASH)) return;
 
-    if (flags & REDIS_HASH_KEY) multiplier++;
-    if (flags & REDIS_HASH_VALUE) multiplier++;
+    if (flags & OBJ_HASH_KEY) multiplier++;
+    if (flags & OBJ_HASH_VALUE) multiplier++;
 
     length = hashTypeLength(o) * multiplier;
     addReplyMultiBulkLen(c, length);
 
     hi = hashTypeInitIterator(o);
-    while (hashTypeNext(hi) != REDIS_ERR) {
-        if (flags & REDIS_HASH_KEY) {
-            addHashIteratorCursorToReply(c, hi, REDIS_HASH_KEY);
+    while (hashTypeNext(hi) != C_ERR) {
+        if (flags & OBJ_HASH_KEY) {
+            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);
             count++;
         }
-        if (flags & REDIS_HASH_VALUE) {
-            addHashIteratorCursorToReply(c, hi, REDIS_HASH_VALUE);
+        if (flags & OBJ_HASH_VALUE) {
+            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);
             count++;
         }
     }
 
     hashTypeReleaseIterator(hi);
-    redisAssert(count == length);
+    serverAssert(count == length);
 }
 
-void hkeysCommand(redisClient *c) {
-    genericHgetallCommand(c,REDIS_HASH_KEY);
+void hkeysCommand(client *c) {
+    genericHgetallCommand(c,OBJ_HASH_KEY);
 }
 
-void hvalsCommand(redisClient *c) {
-    genericHgetallCommand(c,REDIS_HASH_VALUE);
+void hvalsCommand(client *c) {
+    genericHgetallCommand(c,OBJ_HASH_VALUE);
 }
 
-void hgetallCommand(redisClient *c) {
-    genericHgetallCommand(c,REDIS_HASH_KEY|REDIS_HASH_VALUE);
+void hgetallCommand(client *c) {
+    genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);
 }
 
-void hexistsCommand(redisClient *c) {
+void hexistsCommand(client *c) {
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,REDIS_HASH)) return;
+        checkType(c,o,OBJ_HASH)) return;
 
     addReply(c, hashTypeExists(o,c->argv[2]) ? shared.cone : shared.czero);
 }
 
-void hscanCommand(redisClient *c) {
+void hscanCommand(client *c) {
     robj *o;
     unsigned long cursor;
 
-    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == REDIS_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
-        checkType(c,o,REDIS_HASH)) return;
+        checkType(c,o,OBJ_HASH)) return;
     scanGenericCommand(c,o,cursor);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_hash.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_hash.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_hash.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_hash.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_list.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_list.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_list.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_list.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,516 +24,380 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 /*-----------------------------------------------------------------------------
  * List API
  *----------------------------------------------------------------------------*/
 
-/* Check the argument length to see if it requires us to convert the ziplist
- * to a real list. Only check raw-encoded objects because integer encoded
- * objects are never too long. */
-void listTypeTryConversion(robj *subject, robj *value) {
-    if (subject->encoding != REDIS_ENCODING_ZIPLIST) return;
-    if (sdsEncodedObject(value) &&
-        sdslen(value->ptr) > server.list_max_ziplist_value)
-            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);
-}
-
 /* The function pushes an element to the specified list object 'subject',
  * at head or tail position as specified by 'where'.
  *
  * There is no need for the caller to increment the refcount of 'value' as
  * the function takes care of it if needed. */
 void listTypePush(robj *subject, robj *value, int where) {
-    /* Check if we need to convert the ziplist */
-    listTypeTryConversion(subject,value);
-    if (subject->encoding == REDIS_ENCODING_ZIPLIST &&
-        ziplistLen(subject->ptr) >= server.list_max_ziplist_entries)
-            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);
-
-    if (subject->encoding == REDIS_ENCODING_ZIPLIST) {
-        int pos = (where == REDIS_HEAD) ? ZIPLIST_HEAD : ZIPLIST_TAIL;
+    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
+        int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;
         value = getDecodedObject(value);
-        subject->ptr = ziplistPush(subject->ptr,value->ptr,sdslen(value->ptr),pos);
+        size_t len = sdslen(value->ptr);
+        quicklistPush(subject->ptr, value->ptr, len, pos);
         decrRefCount(value);
-    } else if (subject->encoding == REDIS_ENCODING_LINKEDLIST) {
-        if (where == REDIS_HEAD) {
-            listAddNodeHead(subject->ptr,value);
-        } else {
-            listAddNodeTail(subject->ptr,value);
-        }
-        incrRefCount(value);
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
 }
 
+void *listPopSaver(unsigned char *data, unsigned int sz) {
+    return createStringObject((char*)data,sz);
+}
+
 robj *listTypePop(robj *subject, int where) {
+    long long vlong;
     robj *value = NULL;
-    if (subject->encoding == REDIS_ENCODING_ZIPLIST) {
-        unsigned char *p;
-        unsigned char *vstr;
-        unsigned int vlen;
-        long long vlong;
-        int pos = (where == REDIS_HEAD) ? 0 : -1;
-        p = ziplistIndex(subject->ptr,pos);
-        if (ziplistGet(p,&vstr,&vlen,&vlong)) {
-            if (vstr) {
-                value = createStringObject((char*)vstr,vlen);
-            } else {
+
+    int ql_where = where == LIST_HEAD ? QUICKLIST_HEAD : QUICKLIST_TAIL;
+    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
+        if (quicklistPopCustom(subject->ptr, ql_where, (unsigned char **)&value,
+                               NULL, &vlong, listPopSaver)) {
+            if (!value)
                 value = createStringObjectFromLongLong(vlong);
-            }
-            /* We only need to delete an element when it exists */
-            subject->ptr = ziplistDelete(subject->ptr,&p);
-        }
-    } else if (subject->encoding == REDIS_ENCODING_LINKEDLIST) {
-        list *list = subject->ptr;
-        listNode *ln;
-        if (where == REDIS_HEAD) {
-            ln = listFirst(list);
-        } else {
-            ln = listLast(list);
-        }
-        if (ln != NULL) {
-            value = listNodeValue(ln);
-            incrRefCount(value);
-            listDelNode(list,ln);
         }
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
     return value;
 }
 
 unsigned long listTypeLength(robj *subject) {
-    if (subject->encoding == REDIS_ENCODING_ZIPLIST) {
-        return ziplistLen(subject->ptr);
-    } else if (subject->encoding == REDIS_ENCODING_LINKEDLIST) {
-        return listLength((list*)subject->ptr);
+    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
+        return quicklistCount(subject->ptr);
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
 }
 
 /* Initialize an iterator at the specified index. */
-listTypeIterator *listTypeInitIterator(robj *subject, long index, unsigned char direction) {
+listTypeIterator *listTypeInitIterator(robj *subject, long index,
+                                       unsigned char direction) {
     listTypeIterator *li = zmalloc(sizeof(listTypeIterator));
     li->subject = subject;
     li->encoding = subject->encoding;
     li->direction = direction;
-    if (li->encoding == REDIS_ENCODING_ZIPLIST) {
-        li->zi = ziplistIndex(subject->ptr,index);
-    } else if (li->encoding == REDIS_ENCODING_LINKEDLIST) {
-        li->ln = listIndex(subject->ptr,index);
+    li->iter = NULL;
+    /* LIST_HEAD means start at TAIL and move *towards* head.
+     * LIST_TAIL means start at HEAD and move *towards tail. */
+    int iter_direction =
+        direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;
+    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
+        li->iter = quicklistGetIteratorAtIdx(li->subject->ptr,
+                                             iter_direction, index);
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
     return li;
 }
 
 /* Clean up the iterator. */
 void listTypeReleaseIterator(listTypeIterator *li) {
+    zfree(li->iter);
     zfree(li);
 }
 
 /* Stores pointer to current the entry in the provided entry structure
  * and advances the position of the iterator. Returns 1 when the current
  * entry is in fact an entry, 0 otherwise. */
 int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {
     /* Protect from converting when iterating */
-    redisAssert(li->subject->encoding == li->encoding);
+    serverAssert(li->subject->encoding == li->encoding);
 
     entry->li = li;
-    if (li->encoding == REDIS_ENCODING_ZIPLIST) {
-        entry->zi = li->zi;
-        if (entry->zi != NULL) {
-            if (li->direction == REDIS_TAIL)
-                li->zi = ziplistNext(li->subject->ptr,li->zi);
-            else
-                li->zi = ziplistPrev(li->subject->ptr,li->zi);
-            return 1;
-        }
-    } else if (li->encoding == REDIS_ENCODING_LINKEDLIST) {
-        entry->ln = li->ln;
-        if (entry->ln != NULL) {
-            if (li->direction == REDIS_TAIL)
-                li->ln = li->ln->next;
-            else
-                li->ln = li->ln->prev;
-            return 1;
-        }
+    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
+        return quicklistNext(li->iter, &entry->entry);
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
     return 0;
 }
 
 /* Return entry or NULL at the current position of the iterator. */
 robj *listTypeGet(listTypeEntry *entry) {
-    listTypeIterator *li = entry->li;
     robj *value = NULL;
-    if (li->encoding == REDIS_ENCODING_ZIPLIST) {
-        unsigned char *vstr;
-        unsigned int vlen;
-        long long vlong;
-        redisAssert(entry->zi != NULL);
-        if (ziplistGet(entry->zi,&vstr,&vlen,&vlong)) {
-            if (vstr) {
-                value = createStringObject((char*)vstr,vlen);
-            } else {
-                value = createStringObjectFromLongLong(vlong);
-            }
+    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
+        if (entry->entry.value) {
+            value = createStringObject((char *)entry->entry.value,
+                                       entry->entry.sz);
+        } else {
+            value = createStringObjectFromLongLong(entry->entry.longval);
         }
-    } else if (li->encoding == REDIS_ENCODING_LINKEDLIST) {
-        redisAssert(entry->ln != NULL);
-        value = listNodeValue(entry->ln);
-        incrRefCount(value);
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
     return value;
 }
 
 void listTypeInsert(listTypeEntry *entry, robj *value, int where) {
-    robj *subject = entry->li->subject;
-    if (entry->li->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
         value = getDecodedObject(value);
-        if (where == REDIS_TAIL) {
-            unsigned char *next = ziplistNext(subject->ptr,entry->zi);
-
-            /* When we insert after the current element, but the current element
-             * is the tail of the list, we need to do a push. */
-            if (next == NULL) {
-                subject->ptr = ziplistPush(subject->ptr,value->ptr,sdslen(value->ptr),REDIS_TAIL);
-            } else {
-                subject->ptr = ziplistInsert(subject->ptr,next,value->ptr,sdslen(value->ptr));
-            }
-        } else {
-            subject->ptr = ziplistInsert(subject->ptr,entry->zi,value->ptr,sdslen(value->ptr));
+        sds str = value->ptr;
+        size_t len = sdslen(str);
+        if (where == LIST_TAIL) {
+            quicklistInsertAfter((quicklist *)entry->entry.quicklist,
+                                 &entry->entry, str, len);
+        } else if (where == LIST_HEAD) {
+            quicklistInsertBefore((quicklist *)entry->entry.quicklist,
+                                  &entry->entry, str, len);
         }
         decrRefCount(value);
-    } else if (entry->li->encoding == REDIS_ENCODING_LINKEDLIST) {
-        if (where == REDIS_TAIL) {
-            listInsertNode(subject->ptr,entry->ln,value,AL_START_TAIL);
-        } else {
-            listInsertNode(subject->ptr,entry->ln,value,AL_START_HEAD);
-        }
-        incrRefCount(value);
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
 }
 
 /* Compare the given object with the entry at the current position. */
 int listTypeEqual(listTypeEntry *entry, robj *o) {
-    listTypeIterator *li = entry->li;
-    if (li->encoding == REDIS_ENCODING_ZIPLIST) {
-        redisAssertWithInfo(NULL,o,sdsEncodedObject(o));
-        return ziplistCompare(entry->zi,o->ptr,sdslen(o->ptr));
-    } else if (li->encoding == REDIS_ENCODING_LINKEDLIST) {
-        return equalStringObjects(o,listNodeValue(entry->ln));
+    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
+        serverAssertWithInfo(NULL,o,sdsEncodedObject(o));
+        return quicklistCompare(entry->entry.zi,o->ptr,sdslen(o->ptr));
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
 }
 
 /* Delete the element pointed to. */
-void listTypeDelete(listTypeEntry *entry) {
-    listTypeIterator *li = entry->li;
-    if (li->encoding == REDIS_ENCODING_ZIPLIST) {
-        unsigned char *p = entry->zi;
-        li->subject->ptr = ziplistDelete(li->subject->ptr,&p);
-
-        /* Update position of the iterator depending on the direction */
-        if (li->direction == REDIS_TAIL)
-            li->zi = p;
-        else
-            li->zi = ziplistPrev(li->subject->ptr,p);
-    } else if (entry->li->encoding == REDIS_ENCODING_LINKEDLIST) {
-        listNode *next;
-        if (li->direction == REDIS_TAIL)
-            next = entry->ln->next;
-        else
-            next = entry->ln->prev;
-        listDelNode(li->subject->ptr,entry->ln);
-        li->ln = next;
+void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {
+    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
+        quicklistDelEntry(iter->iter, &entry->entry);
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
 }
 
+/* Create a quicklist from a single ziplist */
 void listTypeConvert(robj *subject, int enc) {
-    listTypeIterator *li;
-    listTypeEntry entry;
-    redisAssertWithInfo(NULL,subject,subject->type == REDIS_LIST);
+    serverAssertWithInfo(NULL,subject,subject->type==OBJ_LIST);
+    serverAssertWithInfo(NULL,subject,subject->encoding==OBJ_ENCODING_ZIPLIST);
 
-    if (enc == REDIS_ENCODING_LINKEDLIST) {
-        list *l = listCreate();
-        listSetFreeMethod(l,decrRefCountVoid);
-
-        /* listTypeGet returns a robj with incremented refcount */
-        li = listTypeInitIterator(subject,0,REDIS_TAIL);
-        while (listTypeNext(li,&entry)) listAddNodeTail(l,listTypeGet(&entry));
-        listTypeReleaseIterator(li);
-
-        subject->encoding = REDIS_ENCODING_LINKEDLIST;
-        zfree(subject->ptr);
-        subject->ptr = l;
+    if (enc == OBJ_ENCODING_QUICKLIST) {
+        size_t zlen = server.list_max_ziplist_size;
+        int depth = server.list_compress_depth;
+        subject->ptr = quicklistCreateFromZiplist(zlen, depth, subject->ptr);
+        subject->encoding = OBJ_ENCODING_QUICKLIST;
     } else {
-        redisPanic("Unsupported list conversion");
+        serverPanic("Unsupported list conversion");
     }
 }
 
 /*-----------------------------------------------------------------------------
  * List Commands
  *----------------------------------------------------------------------------*/
 
-void pushGenericCommand(redisClient *c, int where) {
+void pushGenericCommand(client *c, int where) {
     int j, waiting = 0, pushed = 0;
     robj *lobj = lookupKeyWrite(c->db,c->argv[1]);
 
-    if (lobj && lobj->type != REDIS_LIST) {
+    if (lobj && lobj->type != OBJ_LIST) {
         addReply(c,shared.wrongtypeerr);
         return;
     }
 
     for (j = 2; j < c->argc; j++) {
         c->argv[j] = tryObjectEncoding(c->argv[j]);
         if (!lobj) {
-            lobj = createZiplistObject();
+            lobj = createQuicklistObject();
+            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,
+                                server.list_compress_depth);
             dbAdd(c->db,c->argv[1],lobj);
         }
         listTypePush(lobj,c->argv[j],where);
         pushed++;
     }
     addReplyLongLong(c, waiting + (lobj ? listTypeLength(lobj) : 0));
     if (pushed) {
-        char *event = (where == REDIS_HEAD) ? "lpush" : "rpush";
+        char *event = (where == LIST_HEAD) ? "lpush" : "rpush";
 
         signalModifiedKey(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
     }
     server.dirty += pushed;
 }
 
-void lpushCommand(redisClient *c) {
-    pushGenericCommand(c,REDIS_HEAD);
+void lpushCommand(client *c) {
+    pushGenericCommand(c,LIST_HEAD);
 }
 
-void rpushCommand(redisClient *c) {
-    pushGenericCommand(c,REDIS_TAIL);
+void rpushCommand(client *c) {
+    pushGenericCommand(c,LIST_TAIL);
 }
 
-void pushxGenericCommand(redisClient *c, robj *refval, robj *val, int where) {
+void pushxGenericCommand(client *c, robj *refval, robj *val, int where) {
     robj *subject;
     listTypeIterator *iter;
     listTypeEntry entry;
     int inserted = 0;
 
-    if ((subject = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,subject,REDIS_LIST)) return;
+    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,subject,OBJ_LIST)) return;
 
     if (refval != NULL) {
-        /* We're not sure if this value can be inserted yet, but we cannot
-         * convert the list inside the iterator. We don't want to loop over
-         * the list twice (once to see if the value can be inserted and once
-         * to do the actual insert), so we assume this value can be inserted
-         * and convert the ziplist to a regular list if necessary. */
-        listTypeTryConversion(subject,val);
-
         /* Seek refval from head to tail */
-        iter = listTypeInitIterator(subject,0,REDIS_TAIL);
+        iter = listTypeInitIterator(subject,0,LIST_TAIL);
         while (listTypeNext(iter,&entry)) {
             if (listTypeEqual(&entry,refval)) {
                 listTypeInsert(&entry,val,where);
                 inserted = 1;
                 break;
             }
         }
         listTypeReleaseIterator(iter);
 
         if (inserted) {
-            /* Check if the length exceeds the ziplist length threshold. */
-            if (subject->encoding == REDIS_ENCODING_ZIPLIST &&
-                ziplistLen(subject->ptr) > server.list_max_ziplist_entries)
-                    listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);
             signalModifiedKey(c->db,c->argv[1]);
-            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"linsert",
+            notifyKeyspaceEvent(NOTIFY_LIST,"linsert",
                                 c->argv[1],c->db->id);
             server.dirty++;
         } else {
             /* Notify client of a failed insert */
             addReply(c,shared.cnegone);
             return;
         }
     } else {
-        char *event = (where == REDIS_HEAD) ? "lpush" : "rpush";
+        char *event = (where == LIST_HEAD) ? "lpush" : "rpush";
 
         listTypePush(subject,val,where);
         signalModifiedKey(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
         server.dirty++;
     }
 
     addReplyLongLong(c,listTypeLength(subject));
 }
 
-void lpushxCommand(redisClient *c) {
+void lpushxCommand(client *c) {
     c->argv[2] = tryObjectEncoding(c->argv[2]);
-    pushxGenericCommand(c,NULL,c->argv[2],REDIS_HEAD);
+    pushxGenericCommand(c,NULL,c->argv[2],LIST_HEAD);
 }
 
-void rpushxCommand(redisClient *c) {
+void rpushxCommand(client *c) {
     c->argv[2] = tryObjectEncoding(c->argv[2]);
-    pushxGenericCommand(c,NULL,c->argv[2],REDIS_TAIL);
+    pushxGenericCommand(c,NULL,c->argv[2],LIST_TAIL);
 }
 
-void linsertCommand(redisClient *c) {
+void linsertCommand(client *c) {
     c->argv[4] = tryObjectEncoding(c->argv[4]);
     if (strcasecmp(c->argv[2]->ptr,"after") == 0) {
-        pushxGenericCommand(c,c->argv[3],c->argv[4],REDIS_TAIL);
+        pushxGenericCommand(c,c->argv[3],c->argv[4],LIST_TAIL);
     } else if (strcasecmp(c->argv[2]->ptr,"before") == 0) {
-        pushxGenericCommand(c,c->argv[3],c->argv[4],REDIS_HEAD);
+        pushxGenericCommand(c,c->argv[3],c->argv[4],LIST_HEAD);
     } else {
         addReply(c,shared.syntaxerr);
     }
 }
 
-void llenCommand(redisClient *c) {
+void llenCommand(client *c) {
     robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.czero);
-    if (o == NULL || checkType(c,o,REDIS_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
     addReplyLongLong(c,listTypeLength(o));
 }
 
-void lindexCommand(redisClient *c) {
+void lindexCommand(client *c) {
     robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk);
-    if (o == NULL || checkType(c,o,REDIS_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
     long index;
     robj *value = NULL;
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != REDIS_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
         return;
 
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
-        unsigned char *p;
-        unsigned char *vstr;
-        unsigned int vlen;
-        long long vlong;
-        p = ziplistIndex(o->ptr,index);
-        if (ziplistGet(p,&vstr,&vlen,&vlong)) {
-            if (vstr) {
-                value = createStringObject((char*)vstr,vlen);
+    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
+        quicklistEntry entry;
+        if (quicklistIndex(o->ptr, index, &entry)) {
+            if (entry.value) {
+                value = createStringObject((char*)entry.value,entry.sz);
             } else {
-                value = createStringObjectFromLongLong(vlong);
+                value = createStringObjectFromLongLong(entry.longval);
             }
             addReplyBulk(c,value);
             decrRefCount(value);
         } else {
             addReply(c,shared.nullbulk);
         }
-    } else if (o->encoding == REDIS_ENCODING_LINKEDLIST) {
-        listNode *ln = listIndex(o->ptr,index);
-        if (ln != NULL) {
-            value = listNodeValue(ln);
-            addReplyBulk(c,value);
-        } else {
-            addReply(c,shared.nullbulk);
-        }
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
 }
 
-void lsetCommand(redisClient *c) {
+void lsetCommand(client *c) {
     robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
-    if (o == NULL || checkType(c,o,REDIS_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
     long index;
-    robj *value = (c->argv[3] = tryObjectEncoding(c->argv[3]));
+    robj *value = c->argv[3];
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != REDIS_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
         return;
 
-    listTypeTryConversion(o,value);
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
-        unsigned char *p, *zl = o->ptr;
-        p = ziplistIndex(zl,index);
-        if (p == NULL) {
-            addReply(c,shared.outofrangeerr);
-        } else {
-            o->ptr = ziplistDelete(o->ptr,&p);
-            value = getDecodedObject(value);
-            o->ptr = ziplistInsert(o->ptr,p,value->ptr,sdslen(value->ptr));
-            decrRefCount(value);
-            addReply(c,shared.ok);
-            signalModifiedKey(c->db,c->argv[1]);
-            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"lset",c->argv[1],c->db->id);
-            server.dirty++;
-        }
-    } else if (o->encoding == REDIS_ENCODING_LINKEDLIST) {
-        listNode *ln = listIndex(o->ptr,index);
-        if (ln == NULL) {
+    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
+        quicklist *ql = o->ptr;
+        int replaced = quicklistReplaceAtIndex(ql, index,
+                                               value->ptr, sdslen(value->ptr));
+        if (!replaced) {
             addReply(c,shared.outofrangeerr);
         } else {
-            decrRefCount((robj*)listNodeValue(ln));
-            listNodeValue(ln) = value;
-            incrRefCount(value);
             addReply(c,shared.ok);
             signalModifiedKey(c->db,c->argv[1]);
-            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"lset",c->argv[1],c->db->id);
+            notifyKeyspaceEvent(NOTIFY_LIST,"lset",c->argv[1],c->db->id);
             server.dirty++;
         }
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
 }
 
-void popGenericCommand(redisClient *c, int where) {
+void popGenericCommand(client *c, int where) {
     robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk);
-    if (o == NULL || checkType(c,o,REDIS_LIST)) return;
+    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
 
     robj *value = listTypePop(o,where);
     if (value == NULL) {
         addReply(c,shared.nullbulk);
     } else {
-        char *event = (where == REDIS_HEAD) ? "lpop" : "rpop";
+        char *event = (where == LIST_HEAD) ? "lpop" : "rpop";
 
         addReplyBulk(c,value);
         decrRefCount(value);
-        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
         if (listTypeLength(o) == 0) {
-            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
                                 c->argv[1],c->db->id);
             dbDelete(c->db,c->argv[1]);
         }
         signalModifiedKey(c->db,c->argv[1]);
         server.dirty++;
     }
 }
 
-void lpopCommand(redisClient *c) {
-    popGenericCommand(c,REDIS_HEAD);
+void lpopCommand(client *c) {
+    popGenericCommand(c,LIST_HEAD);
 }
 
-void rpopCommand(redisClient *c) {
-    popGenericCommand(c,REDIS_TAIL);
+void rpopCommand(client *c) {
+    popGenericCommand(c,LIST_TAIL);
 }
 
-void lrangeCommand(redisClient *c) {
+void lrangeCommand(client *c) {
     robj *o;
     long start, end, llen, rangelen;
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != REDIS_OK) ||
-        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != REDIS_OK)) return;
+    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
+        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
-         || checkType(c,o,REDIS_LIST)) return;
+         || checkType(c,o,OBJ_LIST)) return;
     llen = listTypeLength(o);
 
     /* convert negative indexes */
     if (start < 0) start = llen+start;
     if (end < 0) end = llen+end;
     if (start < 0) start = 0;
@@ -546,55 +410,40 @@
     }
     if (end >= llen) end = llen-1;
     rangelen = (end-start)+1;
 
     /* Return the result in form of a multi-bulk reply */
     addReplyMultiBulkLen(c,rangelen);
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
-        unsigned char *p = ziplistIndex(o->ptr,start);
-        unsigned char *vstr;
-        unsigned int vlen;
-        long long vlong;
+    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
+        listTypeIterator *iter = listTypeInitIterator(o, start, LIST_TAIL);
 
         while(rangelen--) {
-            ziplistGet(p,&vstr,&vlen,&vlong);
-            if (vstr) {
-                addReplyBulkCBuffer(c,vstr,vlen);
+            listTypeEntry entry;
+            listTypeNext(iter, &entry);
+            quicklistEntry *qe = &entry.entry;
+            if (qe->value) {
+                addReplyBulkCBuffer(c,qe->value,qe->sz);
             } else {
-                addReplyBulkLongLong(c,vlong);
+                addReplyBulkLongLong(c,qe->longval);
             }
-            p = ziplistNext(o->ptr,p);
-        }
-    } else if (o->encoding == REDIS_ENCODING_LINKEDLIST) {
-        listNode *ln;
-
-        /* If we are nearest to the end of the list, reach the element
-         * starting from tail and going backward, as it is faster. */
-        if (start > llen/2) start -= llen;
-        ln = listIndex(o->ptr,start);
-
-        while(rangelen--) {
-            addReplyBulk(c,ln->value);
-            ln = ln->next;
         }
+        listTypeReleaseIterator(iter);
     } else {
-        redisPanic("List encoding is not LINKEDLIST nor ZIPLIST!");
+        serverPanic("List encoding is not QUICKLIST!");
     }
 }
 
-void ltrimCommand(redisClient *c) {
+void ltrimCommand(client *c) {
     robj *o;
-    long start, end, llen, j, ltrim, rtrim;
-    list *list;
-    listNode *ln;
+    long start, end, llen, ltrim, rtrim;
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != REDIS_OK) ||
-        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != REDIS_OK)) return;
+    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
+        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.ok)) == NULL ||
-        checkType(c,o,REDIS_LIST)) return;
+        checkType(c,o,OBJ_LIST)) return;
     llen = listTypeLength(o);
 
     /* convert negative indexes */
     if (start < 0) start = llen+start;
     if (end < 0) end = llen+end;
     if (start < 0) start = 0;
@@ -609,81 +458,71 @@
         if (end >= llen) end = llen-1;
         ltrim = start;
         rtrim = llen-end-1;
     }
 
     /* Remove list elements to perform the trim */
-    if (o->encoding == REDIS_ENCODING_ZIPLIST) {
-        o->ptr = ziplistDeleteRange(o->ptr,0,ltrim);
-        o->ptr = ziplistDeleteRange(o->ptr,-rtrim,rtrim);
-    } else if (o->encoding == REDIS_ENCODING_LINKEDLIST) {
-        list = o->ptr;
-        for (j = 0; j < ltrim; j++) {
-            ln = listFirst(list);
-            listDelNode(list,ln);
-        }
-        for (j = 0; j < rtrim; j++) {
-            ln = listLast(list);
-            listDelNode(list,ln);
-        }
+    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
+        quicklistDelRange(o->ptr,0,ltrim);
+        quicklistDelRange(o->ptr,-rtrim,rtrim);
     } else {
-        redisPanic("Unknown list encoding");
+        serverPanic("Unknown list encoding");
     }
 
-    notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"ltrim",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_LIST,"ltrim",c->argv[1],c->db->id);
     if (listTypeLength(o) == 0) {
         dbDelete(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
     }
     signalModifiedKey(c->db,c->argv[1]);
     server.dirty++;
     addReply(c,shared.ok);
 }
 
-void lremCommand(redisClient *c) {
+void lremCommand(client *c) {
     robj *subject, *obj;
-    obj = c->argv[3] = tryObjectEncoding(c->argv[3]);
+    obj = c->argv[3];
     long toremove;
     long removed = 0;
-    listTypeEntry entry;
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != REDIS_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))
         return;
 
     subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);
-    if (subject == NULL || checkType(c,subject,REDIS_LIST)) return;
-
-    /* Make sure obj is raw when we're dealing with a ziplist */
-    if (subject->encoding == REDIS_ENCODING_ZIPLIST)
-        obj = getDecodedObject(obj);
+    if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;
 
     listTypeIterator *li;
     if (toremove < 0) {
         toremove = -toremove;
-        li = listTypeInitIterator(subject,-1,REDIS_HEAD);
+        li = listTypeInitIterator(subject,-1,LIST_HEAD);
     } else {
-        li = listTypeInitIterator(subject,0,REDIS_TAIL);
+        li = listTypeInitIterator(subject,0,LIST_TAIL);
     }
 
+    listTypeEntry entry;
     while (listTypeNext(li,&entry)) {
         if (listTypeEqual(&entry,obj)) {
-            listTypeDelete(&entry);
+            listTypeDelete(li, &entry);
             server.dirty++;
             removed++;
             if (toremove && removed == toremove) break;
         }
     }
     listTypeReleaseIterator(li);
 
-    /* Clean up raw encoded object */
-    if (subject->encoding == REDIS_ENCODING_ZIPLIST)
-        decrRefCount(obj);
+    if (removed) {
+        signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(NOTIFY_GENERIC,"lrem",c->argv[1],c->db->id);
+    }
+
+    if (listTypeLength(subject) == 0) {
+        dbDelete(c->db,c->argv[1]);
+        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
+    }
 
-    if (listTypeLength(subject) == 0) dbDelete(c->db,c->argv[1]);
     addReplyLongLong(c,removed);
-    if (removed) signalModifiedKey(c->db,c->argv[1]);
 }
 
 /* This is the semantic of this command:
  *  RPOPLPUSH srclist dstlist:
  *    IF LLEN(srclist) > 0
  *      element = RPOP srclist
@@ -696,54 +535,56 @@
  *
  * The idea is to be able to get an element from a list in a reliable way
  * since the element is not just returned but pushed against another list
  * as well. This command was originally proposed by Ezra Zygmuntowicz.
  */
 
-void rpoplpushHandlePush(redisClient *c, robj *dstkey, robj *dstobj, robj *value) {
+void rpoplpushHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value) {
     /* Create the list if the key does not exist */
     if (!dstobj) {
-        dstobj = createZiplistObject();
+        dstobj = createQuicklistObject();
+        quicklistSetOptions(dstobj->ptr, server.list_max_ziplist_size,
+                            server.list_compress_depth);
         dbAdd(c->db,dstkey,dstobj);
     }
     signalModifiedKey(c->db,dstkey);
-    listTypePush(dstobj,value,REDIS_HEAD);
-    notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"lpush",dstkey,c->db->id);
+    listTypePush(dstobj,value,LIST_HEAD);
+    notifyKeyspaceEvent(NOTIFY_LIST,"lpush",dstkey,c->db->id);
     /* Always send the pushed value to the client. */
     addReplyBulk(c,value);
 }
 
-void rpoplpushCommand(redisClient *c) {
+void rpoplpushCommand(client *c) {
     robj *sobj, *value;
     if ((sobj = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
-        checkType(c,sobj,REDIS_LIST)) return;
+        checkType(c,sobj,OBJ_LIST)) return;
 
     if (listTypeLength(sobj) == 0) {
         /* This may only happen after loading very old RDB files. Recent
          * versions of Redis delete keys of empty lists. */
         addReply(c,shared.nullbulk);
     } else {
         robj *dobj = lookupKeyWrite(c->db,c->argv[2]);
         robj *touchedkey = c->argv[1];
 
-        if (dobj && checkType(c,dobj,REDIS_LIST)) return;
-        value = listTypePop(sobj,REDIS_TAIL);
+        if (dobj && checkType(c,dobj,OBJ_LIST)) return;
+        value = listTypePop(sobj,LIST_TAIL);
         /* We saved touched key, and protect it, since rpoplpushHandlePush
          * may change the client command argument vector (it does not
          * currently). */
         incrRefCount(touchedkey);
         rpoplpushHandlePush(c,c->argv[2],dobj,value);
 
         /* listTypePop returns an object with its refcount incremented */
         decrRefCount(value);
 
         /* Delete the source list when it is empty */
-        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"rpop",touchedkey,c->db->id);
+        notifyKeyspaceEvent(NOTIFY_LIST,"rpop",touchedkey,c->db->id);
         if (listTypeLength(sobj) == 0) {
             dbDelete(c->db,touchedkey);
-            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
                                 touchedkey,c->db->id);
         }
         signalModifiedKey(c->db,touchedkey);
         decrRefCount(touchedkey);
         server.dirty++;
     }
@@ -769,13 +610,13 @@
  *   for this list, from the one that blocked first, to the last, accordingly
  *   to the number of elements we have in the ready list.
  */
 
 /* Set a client in blocking mode for the specified key, with the specified
  * timeout */
-void blockForKeys(redisClient *c, robj **keys, int numkeys, mstime_t timeout, robj *target) {
+void blockForKeys(client *c, robj **keys, int numkeys, mstime_t timeout, robj *target) {
     dictEntry *de;
     list *l;
     int j;
 
     c->bpop.timeout = timeout;
     c->bpop.target = target;
@@ -793,37 +634,37 @@
             int retval;
 
             /* For every key we take a list of clients blocked for it */
             l = listCreate();
             retval = dictAdd(c->db->blocking_keys,keys[j],l);
             incrRefCount(keys[j]);
-            redisAssertWithInfo(c,keys[j],retval == DICT_OK);
+            serverAssertWithInfo(c,keys[j],retval == DICT_OK);
         } else {
             l = dictGetVal(de);
         }
         listAddNodeTail(l,c);
     }
-    blockClient(c,REDIS_BLOCKED_LIST);
+    blockClient(c,BLOCKED_LIST);
 }
 
 /* Unblock a client that's waiting in a blocking operation such as BLPOP.
  * You should never call this function directly, but unblockClient() instead. */
-void unblockClientWaitingData(redisClient *c) {
+void unblockClientWaitingData(client *c) {
     dictEntry *de;
     dictIterator *di;
     list *l;
 
-    redisAssertWithInfo(c,NULL,dictSize(c->bpop.keys) != 0);
+    serverAssertWithInfo(c,NULL,dictSize(c->bpop.keys) != 0);
     di = dictGetIterator(c->bpop.keys);
     /* The client may wait for multiple keys, so unblock it for every key. */
     while((de = dictNext(di)) != NULL) {
         robj *key = dictGetKey(de);
 
         /* Remove this client from the list of clients waiting for this key. */
         l = dictFetchValue(c->db->blocking_keys,key);
-        redisAssertWithInfo(c,key,l != NULL);
+        serverAssertWithInfo(c,key,l != NULL);
         listDelNode(l,listSearchKey(l,c));
         /* If the list is empty we need to remove it to avoid wasting memory */
         if (listLength(l) == 0)
             dictDelete(c->db->blocking_keys,key);
     }
     dictReleaseIterator(di);
@@ -860,82 +701,82 @@
     listAddNodeTail(server.ready_keys,rl);
 
     /* We also add the key in the db->ready_keys dictionary in order
      * to avoid adding it multiple times into a list with a simple O(1)
      * check. */
     incrRefCount(key);
-    redisAssert(dictAdd(db->ready_keys,key,NULL) == DICT_OK);
+    serverAssert(dictAdd(db->ready_keys,key,NULL) == DICT_OK);
 }
 
 /* This is a helper function for handleClientsBlockedOnLists(). It's work
  * is to serve a specific client (receiver) that is blocked on 'key'
  * in the context of the specified 'db', doing the following:
  *
  * 1) Provide the client with the 'value' element.
  * 2) If the dstkey is not NULL (we are serving a BRPOPLPUSH) also push the
  *    'value' element on the destination list (the LPUSH side of the command).
  * 3) Propagate the resulting BRPOP, BLPOP and additional LPUSH if any into
  *    the AOF and replication channel.
  *
- * The argument 'where' is REDIS_TAIL or REDIS_HEAD, and indicates if the
+ * The argument 'where' is LIST_TAIL or LIST_HEAD, and indicates if the
  * 'value' element was popped fron the head (BLPOP) or tail (BRPOP) so that
  * we can propagate the command properly.
  *
- * The function returns REDIS_OK if we are able to serve the client, otherwise
- * REDIS_ERR is returned to signal the caller that the list POP operation
+ * The function returns C_OK if we are able to serve the client, otherwise
+ * C_ERR is returned to signal the caller that the list POP operation
  * should be undone as the client was not served: This only happens for
  * BRPOPLPUSH that fails to push the value to the destination key as it is
  * of the wrong type. */
-int serveClientBlockedOnList(redisClient *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int where)
+int serveClientBlockedOnList(client *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int where)
 {
     robj *argv[3];
 
     if (dstkey == NULL) {
         /* Propagate the [LR]POP operation. */
-        argv[0] = (where == REDIS_HEAD) ? shared.lpop :
+        argv[0] = (where == LIST_HEAD) ? shared.lpop :
                                           shared.rpop;
         argv[1] = key;
-        propagate((where == REDIS_HEAD) ?
+        propagate((where == LIST_HEAD) ?
             server.lpopCommand : server.rpopCommand,
-            db->id,argv,2,REDIS_PROPAGATE_AOF|REDIS_PROPAGATE_REPL);
+            db->id,argv,2,PROPAGATE_AOF|PROPAGATE_REPL);
 
         /* BRPOP/BLPOP */
         addReplyMultiBulkLen(receiver,2);
         addReplyBulk(receiver,key);
         addReplyBulk(receiver,value);
     } else {
         /* BRPOPLPUSH */
         robj *dstobj =
             lookupKeyWrite(receiver->db,dstkey);
         if (!(dstobj &&
-             checkType(receiver,dstobj,REDIS_LIST)))
+             checkType(receiver,dstobj,OBJ_LIST)))
         {
             /* Propagate the RPOP operation. */
             argv[0] = shared.rpop;
             argv[1] = key;
             propagate(server.rpopCommand,
                 db->id,argv,2,
-                REDIS_PROPAGATE_AOF|
-                REDIS_PROPAGATE_REPL);
+                PROPAGATE_AOF|
+                PROPAGATE_REPL);
             rpoplpushHandlePush(receiver,dstkey,dstobj,
                 value);
             /* Propagate the LPUSH operation. */
             argv[0] = shared.lpush;
             argv[1] = dstkey;
             argv[2] = value;
             propagate(server.lpushCommand,
                 db->id,argv,3,
-                REDIS_PROPAGATE_AOF|
-                REDIS_PROPAGATE_REPL);
+                PROPAGATE_AOF|
+                PROPAGATE_REPL);
         } else {
             /* BRPOPLPUSH failed because of wrong
              * destination type. */
-            return REDIS_ERR;
+            return C_ERR;
         }
     }
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* This function should be called by Redis every time a single command,
  * a MULTI/EXEC block, or a Lua script, terminated its execution after
  * being called by a client.
  *
@@ -964,41 +805,41 @@
              * we can safely call signalListAsReady() against this key. */
             dictDelete(rl->db->ready_keys,rl->key);
 
             /* If the key exists and it's a list, serve blocked clients
              * with data. */
             robj *o = lookupKeyWrite(rl->db,rl->key);
-            if (o != NULL && o->type == REDIS_LIST) {
+            if (o != NULL && o->type == OBJ_LIST) {
                 dictEntry *de;
 
                 /* We serve clients in the same order they blocked for
                  * this key, from the first blocked to the last. */
                 de = dictFind(rl->db->blocking_keys,rl->key);
                 if (de) {
                     list *clients = dictGetVal(de);
                     int numclients = listLength(clients);
 
                     while(numclients--) {
                         listNode *clientnode = listFirst(clients);
-                        redisClient *receiver = clientnode->value;
+                        client *receiver = clientnode->value;
                         robj *dstkey = receiver->bpop.target;
                         int where = (receiver->lastcmd &&
                                      receiver->lastcmd->proc == blpopCommand) ?
-                                    REDIS_HEAD : REDIS_TAIL;
+                                    LIST_HEAD : LIST_TAIL;
                         robj *value = listTypePop(o,where);
 
                         if (value) {
                             /* Protect receiver->bpop.target, that will be
                              * freed by the next unblockClient()
                              * call. */
                             if (dstkey) incrRefCount(dstkey);
                             unblockClient(receiver);
 
                             if (serveClientBlockedOnList(receiver,
                                 rl->key,dstkey,rl->db,value,
-                                where) == REDIS_ERR)
+                                where) == C_ERR)
                             {
                                 /* If we failed serving the client we need
                                  * to also undo the POP operation. */
                                     listTypePush(o,value,where);
                             }
 
@@ -1007,13 +848,15 @@
                         } else {
                             break;
                         }
                     }
                 }
 
-                if (listTypeLength(o) == 0) dbDelete(rl->db,rl->key);
+                if (listTypeLength(o) == 0) {
+                    dbDelete(rl->db,rl->key);
+                }
                 /* We don't call signalModifiedKey() as it was already called
                  * when an element was pushed on the list. */
             }
 
             /* Free this item. */
             decrRefCount(rl->key);
@@ -1022,98 +865,98 @@
         }
         listRelease(l); /* We have the new list on place at this point. */
     }
 }
 
 /* Blocking RPOP/LPOP */
-void blockingPopGenericCommand(redisClient *c, int where) {
+void blockingPopGenericCommand(client *c, int where) {
     robj *o;
     mstime_t timeout;
     int j;
 
     if (getTimeoutFromObjectOrReply(c,c->argv[c->argc-1],&timeout,UNIT_SECONDS)
-        != REDIS_OK) return;
+        != C_OK) return;
 
     for (j = 1; j < c->argc-1; j++) {
         o = lookupKeyWrite(c->db,c->argv[j]);
         if (o != NULL) {
-            if (o->type != REDIS_LIST) {
+            if (o->type != OBJ_LIST) {
                 addReply(c,shared.wrongtypeerr);
                 return;
             } else {
                 if (listTypeLength(o) != 0) {
                     /* Non empty list, this is like a non normal [LR]POP. */
-                    char *event = (where == REDIS_HEAD) ? "lpop" : "rpop";
+                    char *event = (where == LIST_HEAD) ? "lpop" : "rpop";
                     robj *value = listTypePop(o,where);
-                    redisAssert(value != NULL);
+                    serverAssert(value != NULL);
 
                     addReplyMultiBulkLen(c,2);
                     addReplyBulk(c,c->argv[j]);
                     addReplyBulk(c,value);
                     decrRefCount(value);
-                    notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,
+                    notifyKeyspaceEvent(NOTIFY_LIST,event,
                                         c->argv[j],c->db->id);
                     if (listTypeLength(o) == 0) {
                         dbDelete(c->db,c->argv[j]);
-                        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+                        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
                                             c->argv[j],c->db->id);
                     }
                     signalModifiedKey(c->db,c->argv[j]);
                     server.dirty++;
 
                     /* Replicate it as an [LR]POP instead of B[LR]POP. */
                     rewriteClientCommandVector(c,2,
-                        (where == REDIS_HEAD) ? shared.lpop : shared.rpop,
+                        (where == LIST_HEAD) ? shared.lpop : shared.rpop,
                         c->argv[j]);
                     return;
                 }
             }
         }
     }
 
     /* If we are inside a MULTI/EXEC and the list is empty the only thing
      * we can do is treating it as a timeout (even with timeout 0). */
-    if (c->flags & REDIS_MULTI) {
+    if (c->flags & CLIENT_MULTI) {
         addReply(c,shared.nullmultibulk);
         return;
     }
 
     /* If the list is empty or the key does not exists we must block */
     blockForKeys(c, c->argv + 1, c->argc - 2, timeout, NULL);
 }
 
-void blpopCommand(redisClient *c) {
-    blockingPopGenericCommand(c,REDIS_HEAD);
+void blpopCommand(client *c) {
+    blockingPopGenericCommand(c,LIST_HEAD);
 }
 
-void brpopCommand(redisClient *c) {
-    blockingPopGenericCommand(c,REDIS_TAIL);
+void brpopCommand(client *c) {
+    blockingPopGenericCommand(c,LIST_TAIL);
 }
 
-void brpoplpushCommand(redisClient *c) {
+void brpoplpushCommand(client *c) {
     mstime_t timeout;
 
     if (getTimeoutFromObjectOrReply(c,c->argv[3],&timeout,UNIT_SECONDS)
-        != REDIS_OK) return;
+        != C_OK) return;
 
     robj *key = lookupKeyWrite(c->db, c->argv[1]);
 
     if (key == NULL) {
-        if (c->flags & REDIS_MULTI) {
+        if (c->flags & CLIENT_MULTI) {
             /* Blocking against an empty list in a multi state
              * returns immediately. */
             addReply(c, shared.nullbulk);
         } else {
             /* The list is empty and the client blocks. */
             blockForKeys(c, c->argv + 1, 1, timeout, c->argv[2]);
         }
     } else {
-        if (key->type != REDIS_LIST) {
+        if (key->type != OBJ_LIST) {
             addReply(c, shared.wrongtypeerr);
         } else {
             /* The list exists and has elements, so
              * the regular rpoplpushCommand is executed. */
-            redisAssertWithInfo(c,key,listTypeLength(key) > 0);
+            serverAssertWithInfo(c,key,listTypeLength(key) > 0);
             rpoplpushCommand(c);
         }
     }
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_list.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_list.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_list.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_list.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_set.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_set.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_set.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_set.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,135 +24,150 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 
 /*-----------------------------------------------------------------------------
  * Set Commands
  *----------------------------------------------------------------------------*/
 
-void sunionDiffGenericCommand(redisClient *c, robj **setkeys, int setnum, robj *dstkey, int op);
+void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
+                              robj *dstkey, int op);
 
 /* Factory method to return a set that *can* hold "value". When the object has
  * an integer-encodable value, an intset will be returned. Otherwise a regular
  * hash table. */
 robj *setTypeCreate(robj *value) {
-    if (isObjectRepresentableAsLongLong(value,NULL) == REDIS_OK)
+    if (isObjectRepresentableAsLongLong(value,NULL) == C_OK)
         return createIntsetObject();
     return createSetObject();
 }
 
+/* Add the specified value into a set. The function takes care of incrementing
+ * the reference count of the object if needed in order to retain a copy.
+ *
+ * If the value was already member of the set, nothing is done and 0 is
+ * returned, otherwise the new element is added and 1 is returned. */
 int setTypeAdd(robj *subject, robj *value) {
     long long llval;
-    if (subject->encoding == REDIS_ENCODING_HT) {
+    if (subject->encoding == OBJ_ENCODING_HT) {
         if (dictAdd(subject->ptr,value,NULL) == DICT_OK) {
             incrRefCount(value);
             return 1;
         }
-    } else if (subject->encoding == REDIS_ENCODING_INTSET) {
-        if (isObjectRepresentableAsLongLong(value,&llval) == REDIS_OK) {
+    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
+        if (isObjectRepresentableAsLongLong(value,&llval) == C_OK) {
             uint8_t success = 0;
             subject->ptr = intsetAdd(subject->ptr,llval,&success);
             if (success) {
                 /* Convert to regular set when the intset contains
                  * too many entries. */
                 if (intsetLen(subject->ptr) > server.set_max_intset_entries)
-                    setTypeConvert(subject,REDIS_ENCODING_HT);
+                    setTypeConvert(subject,OBJ_ENCODING_HT);
                 return 1;
             }
         } else {
             /* Failed to get integer from object, convert to regular set. */
-            setTypeConvert(subject,REDIS_ENCODING_HT);
+            setTypeConvert(subject,OBJ_ENCODING_HT);
 
             /* The set *was* an intset and this value is not integer
              * encodable, so dictAdd should always work. */
-            redisAssertWithInfo(NULL,value,dictAdd(subject->ptr,value,NULL) == DICT_OK);
+            serverAssertWithInfo(NULL,value,
+                                dictAdd(subject->ptr,value,NULL) == DICT_OK);
             incrRefCount(value);
             return 1;
         }
     } else {
-        redisPanic("Unknown set encoding");
+        serverPanic("Unknown set encoding");
     }
     return 0;
 }
 
 int setTypeRemove(robj *setobj, robj *value) {
     long long llval;
-    if (setobj->encoding == REDIS_ENCODING_HT) {
+    if (setobj->encoding == OBJ_ENCODING_HT) {
         if (dictDelete(setobj->ptr,value) == DICT_OK) {
             if (htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);
             return 1;
         }
-    } else if (setobj->encoding == REDIS_ENCODING_INTSET) {
-        if (isObjectRepresentableAsLongLong(value,&llval) == REDIS_OK) {
+    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
+        if (isObjectRepresentableAsLongLong(value,&llval) == C_OK) {
             int success;
             setobj->ptr = intsetRemove(setobj->ptr,llval,&success);
             if (success) return 1;
         }
     } else {
-        redisPanic("Unknown set encoding");
+        serverPanic("Unknown set encoding");
     }
     return 0;
 }
 
 int setTypeIsMember(robj *subject, robj *value) {
     long long llval;
-    if (subject->encoding == REDIS_ENCODING_HT) {
+    if (subject->encoding == OBJ_ENCODING_HT) {
         return dictFind((dict*)subject->ptr,value) != NULL;
-    } else if (subject->encoding == REDIS_ENCODING_INTSET) {
-        if (isObjectRepresentableAsLongLong(value,&llval) == REDIS_OK) {
+    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
+        if (isObjectRepresentableAsLongLong(value,&llval) == C_OK) {
             return intsetFind((intset*)subject->ptr,llval);
         }
     } else {
-        redisPanic("Unknown set encoding");
+        serverPanic("Unknown set encoding");
     }
     return 0;
 }
 
 setTypeIterator *setTypeInitIterator(robj *subject) {
     setTypeIterator *si = zmalloc(sizeof(setTypeIterator));
     si->subject = subject;
     si->encoding = subject->encoding;
-    if (si->encoding == REDIS_ENCODING_HT) {
+    if (si->encoding == OBJ_ENCODING_HT) {
         si->di = dictGetIterator(subject->ptr);
-    } else if (si->encoding == REDIS_ENCODING_INTSET) {
+    } else if (si->encoding == OBJ_ENCODING_INTSET) {
         si->ii = 0;
     } else {
-        redisPanic("Unknown set encoding");
+        serverPanic("Unknown set encoding");
     }
     return si;
 }
 
 void setTypeReleaseIterator(setTypeIterator *si) {
-    if (si->encoding == REDIS_ENCODING_HT)
+    if (si->encoding == OBJ_ENCODING_HT)
         dictReleaseIterator(si->di);
     zfree(si);
 }
 
 /* Move to the next entry in the set. Returns the object at the current
  * position.
  *
  * Since set elements can be internally be stored as redis objects or
  * simple arrays of integers, setTypeNext returns the encoding of the
  * set object you are iterating, and will populate the appropriate pointer
- * (eobj) or (llobj) accordingly.
+ * (objele) or (llele) accordingly.
+ *
+ * Note that both the objele and llele pointers should be passed and cannot
+ * be NULL since the function will try to defensively populate the non
+ * used field with values which are easy to trap if misused.
  *
  * When there are no longer elements -1 is returned.
  * Returned objects ref count is not incremented, so this function is
  * copy on write friendly. */
 int setTypeNext(setTypeIterator *si, robj **objele, int64_t *llele) {
-    if (si->encoding == REDIS_ENCODING_HT) {
+    if (si->encoding == OBJ_ENCODING_HT) {
         dictEntry *de = dictNext(si->di);
         if (de == NULL) return -1;
         *objele = dictGetKey(de);
-    } else if (si->encoding == REDIS_ENCODING_INTSET) {
+        *llele = -123456789; /* Not needed. Defensive. */
+    } else if (si->encoding == OBJ_ENCODING_INTSET) {
         if (!intsetGet(si->subject->ptr,si->ii++,llele))
             return -1;
+        *objele = NULL; /* Not needed. Defensive. */
+    } else {
+        serverPanic("Wrong set encoding in setTypeNext");
     }
     return si->encoding;
 }
 
 /* The not copy on write friendly version but easy to use version
  * of setTypeNext() is setTypeNextObject(), returning new objects
@@ -166,19 +181,19 @@
     robj *objele;
     int encoding;
 
     encoding = setTypeNext(si,&objele,&intele);
     switch(encoding) {
         case -1:    return NULL;
-        case REDIS_ENCODING_INTSET:
+        case OBJ_ENCODING_INTSET:
             return createStringObjectFromLongLong(intele);
-        case REDIS_ENCODING_HT:
+        case OBJ_ENCODING_HT:
             incrRefCount(objele);
             return objele;
         default:
-            redisPanic("Unsupported encoding");
+            serverPanic("Unsupported encoding");
     }
     return NULL; /* just to suppress warnings */
 }
 
 /* Return random element from a non empty set.
  * The returned element can be a int64_t value if the set is encoded
@@ -187,102 +202,109 @@
  *
  * The caller provides both pointers to be populated with the right
  * object. The return value of the function is the object->encoding
  * field of the object and is used by the caller to check if the
  * int64_t pointer or the redis object pointer was populated.
  *
+ * Note that both the objele and llele pointers should be passed and cannot
+ * be NULL since the function will try to defensively populate the non
+ * used field with values which are easy to trap if misused.
+ *
  * When an object is returned (the set was a real set) the ref count
  * of the object is not incremented so this function can be considered
  * copy on write friendly. */
 int setTypeRandomElement(robj *setobj, robj **objele, int64_t *llele) {
-    if (setobj->encoding == REDIS_ENCODING_HT) {
+    if (setobj->encoding == OBJ_ENCODING_HT) {
         dictEntry *de = dictGetRandomKey(setobj->ptr);
         *objele = dictGetKey(de);
-    } else if (setobj->encoding == REDIS_ENCODING_INTSET) {
+        *llele = -123456789; /* Not needed. Defensive. */
+    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
         *llele = intsetRandom(setobj->ptr);
+        *objele = NULL; /* Not needed. Defensive. */
     } else {
-        redisPanic("Unknown set encoding");
+        serverPanic("Unknown set encoding");
     }
     return setobj->encoding;
 }
 
 unsigned long setTypeSize(robj *subject) {
-    if (subject->encoding == REDIS_ENCODING_HT) {
+    if (subject->encoding == OBJ_ENCODING_HT) {
         return dictSize((dict*)subject->ptr);
-    } else if (subject->encoding == REDIS_ENCODING_INTSET) {
+    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
         return intsetLen((intset*)subject->ptr);
     } else {
-        redisPanic("Unknown set encoding");
+        serverPanic("Unknown set encoding");
     }
 }
 
 /* Convert the set to specified encoding. The resulting dict (when converting
  * to a hash table) is presized to hold the number of elements in the original
  * set. */
 void setTypeConvert(robj *setobj, int enc) {
     setTypeIterator *si;
-    redisAssertWithInfo(NULL,setobj,setobj->type == REDIS_SET &&
-                             setobj->encoding == REDIS_ENCODING_INTSET);
+    serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&
+                             setobj->encoding == OBJ_ENCODING_INTSET);
 
-    if (enc == REDIS_ENCODING_HT) {
+    if (enc == OBJ_ENCODING_HT) {
         int64_t intele;
         dict *d = dictCreate(&setDictType,NULL);
         robj *element;
 
         /* Presize the dict to avoid rehashing */
         dictExpand(d,intsetLen(setobj->ptr));
 
         /* To add the elements we extract integers and create redis objects */
         si = setTypeInitIterator(setobj);
-        while (setTypeNext(si,NULL,&intele) != -1) {
+        while (setTypeNext(si,&element,&intele) != -1) {
             element = createStringObjectFromLongLong(intele);
-            redisAssertWithInfo(NULL,element,dictAdd(d,element,NULL) == DICT_OK);
+            serverAssertWithInfo(NULL,element,
+                                dictAdd(d,element,NULL) == DICT_OK);
         }
         setTypeReleaseIterator(si);
 
-        setobj->encoding = REDIS_ENCODING_HT;
+        setobj->encoding = OBJ_ENCODING_HT;
         zfree(setobj->ptr);
         setobj->ptr = d;
     } else {
-        redisPanic("Unsupported set conversion");
+        serverPanic("Unsupported set conversion");
     }
 }
 
-void saddCommand(redisClient *c) {
+void saddCommand(client *c) {
     robj *set;
     int j, added = 0;
 
     set = lookupKeyWrite(c->db,c->argv[1]);
     if (set == NULL) {
         set = setTypeCreate(c->argv[2]);
         dbAdd(c->db,c->argv[1],set);
     } else {
-        if (set->type != REDIS_SET) {
+        if (set->type != OBJ_SET) {
             addReply(c,shared.wrongtypeerr);
             return;
         }
     }
 
     for (j = 2; j < c->argc; j++) {
         c->argv[j] = tryObjectEncoding(c->argv[j]);
         if (setTypeAdd(set,c->argv[j])) added++;
     }
     if (added) {
         signalModifiedKey(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_SET,"sadd",c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[1],c->db->id);
     }
     server.dirty += added;
     addReplyLongLong(c,added);
 }
 
-void sremCommand(redisClient *c) {
+void sremCommand(client *c) {
     robj *set;
     int j, deleted = 0, keyremoved = 0;
 
     if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,set,REDIS_SET)) return;
+        checkType(c,set,OBJ_SET)) return;
 
     for (j = 2; j < c->argc; j++) {
         if (setTypeRemove(set,c->argv[j])) {
             deleted++;
             if (setTypeSize(set) == 0) {
                 dbDelete(c->db,c->argv[1]);
@@ -290,22 +312,22 @@
                 break;
             }
         }
     }
     if (deleted) {
         signalModifiedKey(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_SET,"srem",c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
         if (keyremoved)
-            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],
+            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],
                                 c->db->id);
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
 }
 
-void smoveCommand(redisClient *c) {
+void smoveCommand(client *c) {
     robj *srcset, *dstset, *ele;
     srcset = lookupKeyWrite(c->db,c->argv[1]);
     dstset = lookupKeyWrite(c->db,c->argv[2]);
     ele = c->argv[3] = tryObjectEncoding(c->argv[3]);
 
     /* If the source key does not exist return 0 */
@@ -313,32 +335,32 @@
         addReply(c,shared.czero);
         return;
     }
 
     /* If the source key has the wrong type, or the destination key
      * is set and has the wrong type, return with an error. */
-    if (checkType(c,srcset,REDIS_SET) ||
-        (dstset && checkType(c,dstset,REDIS_SET))) return;
+    if (checkType(c,srcset,OBJ_SET) ||
+        (dstset && checkType(c,dstset,OBJ_SET))) return;
 
     /* If srcset and dstset are equal, SMOVE is a no-op */
     if (srcset == dstset) {
         addReply(c,setTypeIsMember(srcset,ele) ? shared.cone : shared.czero);
         return;
     }
 
     /* If the element cannot be removed from the src set, return 0. */
     if (!setTypeRemove(srcset,ele)) {
         addReply(c,shared.czero);
         return;
     }
-    notifyKeyspaceEvent(REDIS_NOTIFY_SET,"srem",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
 
     /* Remove the src set from the database when empty */
     if (setTypeSize(srcset) == 0) {
         dbDelete(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
     }
     signalModifiedKey(c->db,c->argv[1]);
     signalModifiedKey(c->db,c->argv[2]);
     server.dirty++;
 
     /* Create the destination set when it doesn't exist */
@@ -347,102 +369,278 @@
         dbAdd(c->db,c->argv[2],dstset);
     }
 
     /* An extra key has changed when ele was successfully added to dstset */
     if (setTypeAdd(dstset,ele)) {
         server.dirty++;
-        notifyKeyspaceEvent(REDIS_NOTIFY_SET,"sadd",c->argv[2],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[2],c->db->id);
     }
     addReply(c,shared.cone);
 }
 
-void sismemberCommand(redisClient *c) {
+void sismemberCommand(client *c) {
     robj *set;
 
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,set,REDIS_SET)) return;
+        checkType(c,set,OBJ_SET)) return;
 
     c->argv[2] = tryObjectEncoding(c->argv[2]);
     if (setTypeIsMember(set,c->argv[2]))
         addReply(c,shared.cone);
     else
         addReply(c,shared.czero);
 }
 
-void scardCommand(redisClient *c) {
+void scardCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,REDIS_SET)) return;
+        checkType(c,o,OBJ_SET)) return;
 
     addReplyLongLong(c,setTypeSize(o));
 }
 
-void spopCommand(redisClient *c) {
+/* Handle the "SPOP key <count>" variant. The normal version of the
+ * command is handled by the spopCommand() function itself. */
+
+/* How many times bigger should be the set compared to the remaining size
+ * for us to use the "create new set" strategy? Read later in the
+ * implementation for more info. */
+#define SPOP_MOVE_STRATEGY_MUL 5
+
+void spopWithCountCommand(client *c) {
+    long l;
+    unsigned long count, size;
+    robj *set;
+
+    /* Get the count argument */
+    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
+    if (l >= 0) {
+        count = (unsigned) l;
+    } else {
+        addReply(c,shared.outofrangeerr);
+        return;
+    }
+
+    /* Make sure a key with the name inputted exists, and that it's type is
+     * indeed a set. Otherwise, return nil */
+    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
+        == NULL || checkType(c,set,OBJ_SET)) return;
+
+    /* If count is zero, serve an empty multibulk ASAP to avoid special
+     * cases later. */
+    if (count == 0) {
+        addReply(c,shared.emptymultibulk);
+        return;
+    }
+
+    size = setTypeSize(set);
+
+    /* Generate an SPOP keyspace notification */
+    notifyKeyspaceEvent(NOTIFY_SET,"spop",c->argv[1],c->db->id);
+    server.dirty += count;
+
+    /* CASE 1:
+     * The number of requested elements is greater than or equal to
+     * the number of elements inside the set: simply return the whole set. */
+    if (count >= size) {
+        /* We just return the entire set */
+        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
+
+        /* Delete the set as it is now empty */
+        dbDelete(c->db,c->argv[1]);
+        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
+
+        /* Propagate this command as an DEL operation */
+        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);
+        signalModifiedKey(c->db,c->argv[1]);
+        server.dirty++;
+        return;
+    }
+
+    /* Case 2 and 3 require to replicate SPOP as a set of SERM commands.
+     * Prepare our replication argument vector. Also send the array length
+     * which is common to both the code paths. */
+    robj *propargv[3];
+    propargv[0] = createStringObject("SREM",4);
+    propargv[1] = c->argv[1];
+    addReplyMultiBulkLen(c,count);
+
+    /* Common iteration vars. */
+    robj *objele;
+    int encoding;
+    int64_t llele;
+    unsigned long remaining = size-count; /* Elements left after SPOP. */
+
+    /* If we are here, the number of requested elements is less than the
+     * number of elements inside the set. Also we are sure that count < size.
+     * Use two different strategies.
+     *
+     * CASE 2: The number of elements to return is small compared to the
+     * set size. We can just extract random elements and return them to
+     * the set. */
+    if (remaining*SPOP_MOVE_STRATEGY_MUL > count) {
+        while(count--) {
+            encoding = setTypeRandomElement(set,&objele,&llele);
+            if (encoding == OBJ_ENCODING_INTSET) {
+                objele = createStringObjectFromLongLong(llele);
+            } else {
+                incrRefCount(objele);
+            }
+
+            /* Return the element to the client and remove from the set. */
+            addReplyBulk(c,objele);
+            setTypeRemove(set,objele);
+
+            /* Replicate/AOF this command as an SREM operation */
+            propargv[2] = objele;
+            alsoPropagate(server.sremCommand,c->db->id,propargv,3,
+                PROPAGATE_AOF|PROPAGATE_REPL);
+            decrRefCount(objele);
+        }
+    } else {
+    /* CASE 3: The number of elements to return is very big, approaching
+     * the size of the set itself. After some time extracting random elements
+     * from such a set becomes computationally expensive, so we use
+     * a different strategy, we extract random elements that we don't
+     * want to return (the elements that will remain part of the set),
+     * creating a new set as we do this (that will be stored as the original
+     * set). Then we return the elements left in the original set and
+     * release it. */
+        robj *newset = NULL;
+
+        /* Create a new set with just the remaining elements. */
+        while(remaining--) {
+            encoding = setTypeRandomElement(set,&objele,&llele);
+            if (encoding == OBJ_ENCODING_INTSET) {
+                objele = createStringObjectFromLongLong(llele);
+            } else {
+                incrRefCount(objele);
+            }
+            if (!newset) newset = setTypeCreate(objele);
+            setTypeAdd(newset,objele);
+            setTypeRemove(set,objele);
+            decrRefCount(objele);
+        }
+
+        /* Assign the new set as the key value. */
+        incrRefCount(set); /* Protect the old set value. */
+        dbOverwrite(c->db,c->argv[1],newset);
+
+        /* Tranfer the old set to the client and release it. */
+        setTypeIterator *si;
+        si = setTypeInitIterator(set);
+        while((encoding = setTypeNext(si,&objele,&llele)) != -1) {
+            if (encoding == OBJ_ENCODING_INTSET) {
+                objele = createStringObjectFromLongLong(llele);
+            } else {
+                incrRefCount(objele);
+            }
+            addReplyBulk(c,objele);
+
+            /* Replicate/AOF this command as an SREM operation */
+            propargv[2] = objele;
+            alsoPropagate(server.sremCommand,c->db->id,propargv,3,
+                PROPAGATE_AOF|PROPAGATE_REPL);
+
+            decrRefCount(objele);
+        }
+        setTypeReleaseIterator(si);
+        decrRefCount(set);
+    }
+
+    /* Don't propagate the command itself even if we incremented the
+     * dirty counter. We don't want to propagate an SPOP command since
+     * we propagated the command as a set of SREMs operations using
+     * the alsoPropagate() API. */
+    decrRefCount(propargv[0]);
+    preventCommandPropagation(c);
+}
+
+void spopCommand(client *c) {
     robj *set, *ele, *aux;
     int64_t llele;
     int encoding;
 
+    if (c->argc == 3) {
+        spopWithCountCommand(c);
+        return;
+    } else if (c->argc > 3) {
+        addReply(c,shared.syntaxerr);
+        return;
+    }
+
+    /* Make sure a key with the name inputted exists, and that it's type is
+     * indeed a set */
     if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
-        checkType(c,set,REDIS_SET)) return;
+        checkType(c,set,OBJ_SET)) return;
 
+    /* Get a random element from the set */
     encoding = setTypeRandomElement(set,&ele,&llele);
-    if (encoding == REDIS_ENCODING_INTSET) {
+
+    /* Remove the element from the set */
+    if (encoding == OBJ_ENCODING_INTSET) {
         ele = createStringObjectFromLongLong(llele);
         set->ptr = intsetRemove(set->ptr,llele,NULL);
     } else {
         incrRefCount(ele);
         setTypeRemove(set,ele);
     }
-    notifyKeyspaceEvent(REDIS_NOTIFY_SET,"spop",c->argv[1],c->db->id);
+
+    notifyKeyspaceEvent(NOTIFY_SET,"spop",c->argv[1],c->db->id);
 
     /* Replicate/AOF this command as an SREM operation */
     aux = createStringObject("SREM",4);
     rewriteClientCommandVector(c,3,aux,c->argv[1],ele);
     decrRefCount(ele);
     decrRefCount(aux);
 
+    /* Add the element to the reply */
     addReplyBulk(c,ele);
+
+    /* Delete the set if it's empty */
     if (setTypeSize(set) == 0) {
         dbDelete(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
     }
+
+    /* Set has been modified */
     signalModifiedKey(c->db,c->argv[1]);
     server.dirty++;
 }
 
 /* handle the "SRANDMEMBER key <count>" variant. The normal version of the
  * command is handled by the srandmemberCommand() function itself. */
 
 /* How many times bigger should be the set compared to the requested size
  * for us to don't use the "remove elements" strategy? Read later in the
  * implementation for more info. */
 #define SRANDMEMBER_SUB_STRATEGY_MUL 3
 
-void srandmemberWithCountCommand(redisClient *c) {
+void srandmemberWithCountCommand(client *c) {
     long l;
     unsigned long count, size;
     int uniq = 1;
     robj *set, *ele;
     int64_t llele;
     int encoding;
 
     dict *d;
 
-    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != REDIS_OK) return;
+    if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
     if (l >= 0) {
         count = (unsigned) l;
     } else {
         /* A negative count means: return the same elements multiple times
          * (i.e. don't remove the extracted element after every extraction). */
         count = -l;
         uniq = 0;
     }
 
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
-        == NULL || checkType(c,set,REDIS_SET)) return;
+        == NULL || checkType(c,set,OBJ_SET)) return;
     size = setTypeSize(set);
 
     /* If count is zero, serve it ASAP to avoid special cases later. */
     if (count == 0) {
         addReply(c,shared.emptymultibulk);
         return;
@@ -453,26 +651,26 @@
      * This case is trivial and can be served without auxiliary data
      * structures. */
     if (!uniq) {
         addReplyMultiBulkLen(c,count);
         while(count--) {
             encoding = setTypeRandomElement(set,&ele,&llele);
-            if (encoding == REDIS_ENCODING_INTSET) {
+            if (encoding == OBJ_ENCODING_INTSET) {
                 addReplyBulkLongLong(c,llele);
             } else {
                 addReplyBulk(c,ele);
             }
         }
         return;
     }
 
     /* CASE 2:
      * The number of requested elements is greater than the number of
      * elements inside the set: simply return the whole set. */
     if (count >= size) {
-        sunionDiffGenericCommand(c,c->argv+1,1,NULL,REDIS_OP_UNION);
+        sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
         return;
     }
 
     /* For CASE 3 and CASE 4 we need an auxiliary dictionary. */
     d = dictCreate(&setDictType,NULL);
 
@@ -490,21 +688,21 @@
 
         /* Add all the elements into the temporary dictionary. */
         si = setTypeInitIterator(set);
         while((encoding = setTypeNext(si,&ele,&llele)) != -1) {
             int retval = DICT_ERR;
 
-            if (encoding == REDIS_ENCODING_INTSET) {
+            if (encoding == OBJ_ENCODING_INTSET) {
                 retval = dictAdd(d,createStringObjectFromLongLong(llele),NULL);
             } else {
                 retval = dictAdd(d,dupStringObject(ele),NULL);
             }
-            redisAssert(retval == DICT_OK);
+            serverAssert(retval == DICT_OK);
         }
         setTypeReleaseIterator(si);
-        redisAssert(dictSize(d) == size);
+        serverAssert(dictSize(d) == size);
 
         /* Remove random elements to reach the right count. */
         while(size > count) {
             dictEntry *de;
 
             de = dictGetRandomKey(d);
@@ -519,13 +717,13 @@
      * to reach the specified count. */
     else {
         unsigned long added = 0;
 
         while(added < count) {
             encoding = setTypeRandomElement(set,&ele,&llele);
-            if (encoding == REDIS_ENCODING_INTSET) {
+            if (encoding == OBJ_ENCODING_INTSET) {
                 ele = createStringObjectFromLongLong(llele);
             } else {
                 ele = dupStringObject(ele);
             }
             /* Try to add the object to the dictionary. If it already exists
              * free it, otherwise increment the number of objects we have
@@ -548,13 +746,13 @@
             addReplyBulk(c,dictGetKey(de));
         dictReleaseIterator(di);
         dictRelease(d);
     }
 }
 
-void srandmemberCommand(redisClient *c) {
+void srandmemberCommand(client *c) {
     robj *set, *ele;
     int64_t llele;
     int encoding;
 
     if (c->argc == 3) {
         srandmemberWithCountCommand(c);
@@ -562,16 +760,16 @@
     } else if (c->argc > 3) {
         addReply(c,shared.syntaxerr);
         return;
     }
 
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
-        checkType(c,set,REDIS_SET)) return;
+        checkType(c,set,OBJ_SET)) return;
 
     encoding = setTypeRandomElement(set,&ele,&llele);
-    if (encoding == REDIS_ENCODING_INTSET) {
+    if (encoding == OBJ_ENCODING_INTSET) {
         addReplyBulkLongLong(c,llele);
     } else {
         addReplyBulk(c,ele);
     }
 }
 
@@ -584,13 +782,14 @@
 int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
     robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
 
     return  (o2 ? setTypeSize(o2) : 0) - (o1 ? setTypeSize(o1) : 0);
 }
 
-void sinterGenericCommand(redisClient *c, robj **setkeys, unsigned long setnum, robj *dstkey) {
+void sinterGenericCommand(client *c, robj **setkeys,
+                          unsigned long setnum, robj *dstkey) {
     robj **sets = zmalloc(sizeof(robj*)*setnum);
     setTypeIterator *si;
     robj *eleobj, *dstset = NULL;
     int64_t intobj;
     void *replylen = NULL;
     unsigned long j, cardinality = 0;
@@ -610,13 +809,13 @@
                 addReply(c,shared.czero);
             } else {
                 addReply(c,shared.emptymultibulk);
             }
             return;
         }
-        if (checkType(c,setobj,REDIS_SET)) {
+        if (checkType(c,setobj,OBJ_SET)) {
             zfree(sets);
             return;
         }
         sets[j] = setobj;
     }
     /* Sort sets from the smallest to largest, this will improve our
@@ -640,35 +839,35 @@
      * the element against all the other sets, if at least one set does
      * not include the element it is discarded */
     si = setTypeInitIterator(sets[0]);
     while((encoding = setTypeNext(si,&eleobj,&intobj)) != -1) {
         for (j = 1; j < setnum; j++) {
             if (sets[j] == sets[0]) continue;
-            if (encoding == REDIS_ENCODING_INTSET) {
+            if (encoding == OBJ_ENCODING_INTSET) {
                 /* intset with intset is simple... and fast */
-                if (sets[j]->encoding == REDIS_ENCODING_INTSET &&
+                if (sets[j]->encoding == OBJ_ENCODING_INTSET &&
                     !intsetFind((intset*)sets[j]->ptr,intobj))
                 {
                     break;
                 /* in order to compare an integer with an object we
                  * have to use the generic function, creating an object
                  * for this */
-                } else if (sets[j]->encoding == REDIS_ENCODING_HT) {
+                } else if (sets[j]->encoding == OBJ_ENCODING_HT) {
                     eleobj = createStringObjectFromLongLong(intobj);
                     if (!setTypeIsMember(sets[j],eleobj)) {
                         decrRefCount(eleobj);
                         break;
                     }
                     decrRefCount(eleobj);
                 }
-            } else if (encoding == REDIS_ENCODING_HT) {
+            } else if (encoding == OBJ_ENCODING_HT) {
                 /* Optimization... if the source object is integer
                  * encoded AND the target set is an intset, we can get
                  * a much faster path. */
-                if (eleobj->encoding == REDIS_ENCODING_INT &&
-                    sets[j]->encoding == REDIS_ENCODING_INTSET &&
+                if (eleobj->encoding == OBJ_ENCODING_INT &&
+                    sets[j]->encoding == OBJ_ENCODING_INTSET &&
                     !intsetFind((intset*)sets[j]->ptr,(long)eleobj->ptr))
                 {
                     break;
                 /* else... object to object check is easy as we use the
                  * type agnostic API here. */
                 } else if (!setTypeIsMember(sets[j],eleobj)) {
@@ -677,19 +876,19 @@
             }
         }
 
         /* Only take action when all sets contain the member */
         if (j == setnum) {
             if (!dstkey) {
-                if (encoding == REDIS_ENCODING_HT)
+                if (encoding == OBJ_ENCODING_HT)
                     addReplyBulk(c,eleobj);
                 else
                     addReplyBulkLongLong(c,intobj);
                 cardinality++;
             } else {
-                if (encoding == REDIS_ENCODING_INTSET) {
+                if (encoding == OBJ_ENCODING_INTSET) {
                     eleobj = createStringObjectFromLongLong(intobj);
                     setTypeAdd(dstset,eleobj);
                     decrRefCount(eleobj);
                 } else {
                     setTypeAdd(dstset,eleobj);
                 }
@@ -702,42 +901,43 @@
         /* Store the resulting set into the target, if the intersection
          * is not an empty set. */
         int deleted = dbDelete(c->db,dstkey);
         if (setTypeSize(dstset) > 0) {
             dbAdd(c->db,dstkey,dstset);
             addReplyLongLong(c,setTypeSize(dstset));
-            notifyKeyspaceEvent(REDIS_NOTIFY_SET,"sinterstore",
+            notifyKeyspaceEvent(NOTIFY_SET,"sinterstore",
                 dstkey,c->db->id);
         } else {
             decrRefCount(dstset);
             addReply(c,shared.czero);
             if (deleted)
-                notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+                notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
                     dstkey,c->db->id);
         }
         signalModifiedKey(c->db,dstkey);
         server.dirty++;
     } else {
         setDeferredMultiBulkLength(c,replylen,cardinality);
     }
     zfree(sets);
 }
 
-void sinterCommand(redisClient *c) {
+void sinterCommand(client *c) {
     sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);
 }
 
-void sinterstoreCommand(redisClient *c) {
+void sinterstoreCommand(client *c) {
     sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);
 }
 
-#define REDIS_OP_UNION 0
-#define REDIS_OP_DIFF 1
-#define REDIS_OP_INTER 2
+#define SET_OP_UNION 0
+#define SET_OP_DIFF 1
+#define SET_OP_INTER 2
 
-void sunionDiffGenericCommand(redisClient *c, robj **setkeys, int setnum, robj *dstkey, int op) {
+void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
+                              robj *dstkey, int op) {
     robj **sets = zmalloc(sizeof(robj*)*setnum);
     setTypeIterator *si;
     robj *ele, *dstset = NULL;
     int j, cardinality = 0;
     int diff_algo = 1;
 
@@ -746,13 +946,13 @@
             lookupKeyWrite(c->db,setkeys[j]) :
             lookupKeyRead(c->db,setkeys[j]);
         if (!setobj) {
             sets[j] = NULL;
             continue;
         }
-        if (checkType(c,setobj,REDIS_SET)) {
+        if (checkType(c,setobj,OBJ_SET)) {
             zfree(sets);
             return;
         }
         sets[j] = setobj;
     }
 
@@ -762,13 +962,13 @@
      * and M the total number of sets.
      *
      * Algorithm 2 is O(N) where N is the total number of elements in all
      * the sets.
      *
      * We compute what is the best bet with the current input here. */
-    if (op == REDIS_OP_DIFF && sets[0]) {
+    if (op == SET_OP_DIFF && sets[0]) {
         long long algo_one_work = 0, algo_two_work = 0;
 
         for (j = 0; j < setnum; j++) {
             if (sets[j] == NULL) continue;
 
             algo_one_work += setTypeSize(sets[0]);
@@ -791,26 +991,26 @@
 
     /* We need a temp set object to store our union. If the dstkey
      * is not NULL (that is, we are inside an SUNIONSTORE operation) then
      * this set object will be the resulting object to set into the target key*/
     dstset = createIntsetObject();
 
-    if (op == REDIS_OP_UNION) {
+    if (op == SET_OP_UNION) {
         /* Union is trivial, just add every element of every set to the
          * temporary set. */
         for (j = 0; j < setnum; j++) {
             if (!sets[j]) continue; /* non existing keys are like empty sets */
 
             si = setTypeInitIterator(sets[j]);
             while((ele = setTypeNextObject(si)) != NULL) {
                 if (setTypeAdd(dstset,ele)) cardinality++;
                 decrRefCount(ele);
             }
             setTypeReleaseIterator(si);
         }
-    } else if (op == REDIS_OP_DIFF && sets[0] && diff_algo == 1) {
+    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 1) {
         /* DIFF Algorithm 1:
          *
          * We perform the diff by iterating all the elements of the first set,
          * and only adding it to the target set if the element does not exist
          * into all the other sets.
          *
@@ -828,13 +1028,13 @@
                 setTypeAdd(dstset,ele);
                 cardinality++;
             }
             decrRefCount(ele);
         }
         setTypeReleaseIterator(si);
-    } else if (op == REDIS_OP_DIFF && sets[0] && diff_algo == 2) {
+    } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 2) {
         /* DIFF Algorithm 2:
          *
          * Add all the elements of the first set to the auxiliary set.
          * Then remove all the elements of all the next sets from it.
          *
          * This is O(N) where N is the sum of all the elements in every
@@ -873,47 +1073,47 @@
         /* If we have a target key where to store the resulting set
          * create this key with the result set inside */
         int deleted = dbDelete(c->db,dstkey);
         if (setTypeSize(dstset) > 0) {
             dbAdd(c->db,dstkey,dstset);
             addReplyLongLong(c,setTypeSize(dstset));
-            notifyKeyspaceEvent(REDIS_NOTIFY_SET,
-                op == REDIS_OP_UNION ? "sunionstore" : "sdiffstore",
+            notifyKeyspaceEvent(NOTIFY_SET,
+                op == SET_OP_UNION ? "sunionstore" : "sdiffstore",
                 dstkey,c->db->id);
         } else {
             decrRefCount(dstset);
             addReply(c,shared.czero);
             if (deleted)
-                notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+                notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
                     dstkey,c->db->id);
         }
         signalModifiedKey(c->db,dstkey);
         server.dirty++;
     }
     zfree(sets);
 }
 
-void sunionCommand(redisClient *c) {
-    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,REDIS_OP_UNION);
+void sunionCommand(client *c) {
+    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);
 }
 
-void sunionstoreCommand(redisClient *c) {
-    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],REDIS_OP_UNION);
+void sunionstoreCommand(client *c) {
+    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);
 }
 
-void sdiffCommand(redisClient *c) {
-    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,REDIS_OP_DIFF);
+void sdiffCommand(client *c) {
+    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);
 }
 
-void sdiffstoreCommand(redisClient *c) {
-    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],REDIS_OP_DIFF);
+void sdiffstoreCommand(client *c) {
+    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);
 }
 
-void sscanCommand(redisClient *c) {
+void sscanCommand(client *c) {
     robj *set;
     unsigned long cursor;
 
-    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == REDIS_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
-        checkType(c,set,REDIS_SET)) return;
+        checkType(c,set,OBJ_SET)) return;
     scanGenericCommand(c,set,cursor);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_set.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_set.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_set.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_set.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_string.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_string.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_string.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_string.c	2016-05-06 15:11:36.000000000 +0800
@@ -24,25 +24,25 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "redis.h"
+#include "server.h"
 #include <math.h> /* isnan(), isinf() */
 
 /*-----------------------------------------------------------------------------
  * String Commands
  *----------------------------------------------------------------------------*/
 
-static int checkStringLength(redisClient *c, long long size) {
+static int checkStringLength(client *c, long long size) {
     if (size > 512*1024*1024) {
         addReplyError(c,"string exceeds maximum allowed size (512MB)");
-        return REDIS_ERR;
+        return C_ERR;
     }
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* The setGenericCommand() function implements the SET operation with different
  * options and variants. This function is called in order to implement the
  * following commands: SET, SETEX, PSETEX, SETNX.
  *
@@ -55,68 +55,80 @@
  * if the operation is performed, or when it is not because of NX or
  * XX flags.
  *
  * If ok_reply is NULL "+OK" is used.
  * If abort_reply is NULL, "$-1" is used. */
 
-#define REDIS_SET_NO_FLAGS 0
-#define REDIS_SET_NX (1<<0)     /* Set if key not exists. */
-#define REDIS_SET_XX (1<<1)     /* Set if key exists. */
+#define OBJ_SET_NO_FLAGS 0
+#define OBJ_SET_NX (1<<0)     /* Set if key not exists. */
+#define OBJ_SET_XX (1<<1)     /* Set if key exists. */
+#define OBJ_SET_EX (1<<2)     /* Set if time in seconds is given */
+#define OBJ_SET_PX (1<<3)     /* Set if time in ms in given */
 
-void setGenericCommand(redisClient *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
+void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
     long long milliseconds = 0; /* initialized to avoid any harmness warning */
 
     if (expire) {
-        if (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != REDIS_OK)
+        if (getLongLongFromObjectOrReply(c, expire, &milliseconds, NULL) != C_OK)
             return;
         if (milliseconds <= 0) {
             addReplyErrorFormat(c,"invalid expire time in %s",c->cmd->name);
             return;
         }
         if (unit == UNIT_SECONDS) milliseconds *= 1000;
     }
 
-    if ((flags & REDIS_SET_NX && lookupKeyWrite(c->db,key) != NULL) ||
-        (flags & REDIS_SET_XX && lookupKeyWrite(c->db,key) == NULL))
+    if ((flags & OBJ_SET_NX && lookupKeyWrite(c->db,key) != NULL) ||
+        (flags & OBJ_SET_XX && lookupKeyWrite(c->db,key) == NULL))
     {
         addReply(c, abort_reply ? abort_reply : shared.nullbulk);
         return;
     }
     setKey(c->db,key,val);
     server.dirty++;
     if (expire) setExpire(c->db,key,mstime()+milliseconds);
-    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"set",key,c->db->id);
-    if (expire) notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,
+    notifyKeyspaceEvent(NOTIFY_STRING,"set",key,c->db->id);
+    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,
         "expire",key,c->db->id);
     addReply(c, ok_reply ? ok_reply : shared.ok);
 }
 
 /* SET key value [NX] [XX] [EX <seconds>] [PX <milliseconds>] */
-void setCommand(redisClient *c) {
+void setCommand(client *c) {
     int j;
     robj *expire = NULL;
     int unit = UNIT_SECONDS;
-    int flags = REDIS_SET_NO_FLAGS;
+    int flags = OBJ_SET_NO_FLAGS;
 
     for (j = 3; j < c->argc; j++) {
         char *a = c->argv[j]->ptr;
         robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];
 
         if ((a[0] == 'n' || a[0] == 'N') &&
-            (a[1] == 'x' || a[1] == 'X') && a[2] == '\0') {
-            flags |= REDIS_SET_NX;
+            (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
+            !(flags & OBJ_SET_XX))
+        {
+            flags |= OBJ_SET_NX;
         } else if ((a[0] == 'x' || a[0] == 'X') &&
-                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\0') {
-            flags |= REDIS_SET_XX;
+                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
+                   !(flags & OBJ_SET_NX))
+        {
+            flags |= OBJ_SET_XX;
         } else if ((a[0] == 'e' || a[0] == 'E') &&
-                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' && next) {
+                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
+                   !(flags & OBJ_SET_PX) && next)
+        {
+            flags |= OBJ_SET_EX;
             unit = UNIT_SECONDS;
             expire = next;
             j++;
         } else if ((a[0] == 'p' || a[0] == 'P') &&
-                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' && next) {
+                   (a[1] == 'x' || a[1] == 'X') && a[2] == '\0' &&
+                   !(flags & OBJ_SET_EX) && next)
+        {
+            flags |= OBJ_SET_PX;
             unit = UNIT_MILLISECONDS;
             expire = next;
             j++;
         } else {
             addReply(c,shared.syntaxerr);
             return;
@@ -124,60 +136,60 @@
     }
 
     c->argv[2] = tryObjectEncoding(c->argv[2]);
     setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
 }
 
-void setnxCommand(redisClient *c) {
+void setnxCommand(client *c) {
     c->argv[2] = tryObjectEncoding(c->argv[2]);
-    setGenericCommand(c,REDIS_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
+    setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
 }
 
-void setexCommand(redisClient *c) {
+void setexCommand(client *c) {
     c->argv[3] = tryObjectEncoding(c->argv[3]);
-    setGenericCommand(c,REDIS_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);
+    setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);
 }
 
-void psetexCommand(redisClient *c) {
+void psetexCommand(client *c) {
     c->argv[3] = tryObjectEncoding(c->argv[3]);
-    setGenericCommand(c,REDIS_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);
+    setGenericCommand(c,OBJ_SET_NO_FLAGS,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);
 }
 
-int getGenericCommand(redisClient *c) {
+int getGenericCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL)
-        return REDIS_OK;
+        return C_OK;
 
-    if (o->type != REDIS_STRING) {
+    if (o->type != OBJ_STRING) {
         addReply(c,shared.wrongtypeerr);
-        return REDIS_ERR;
+        return C_ERR;
     } else {
         addReplyBulk(c,o);
-        return REDIS_OK;
+        return C_OK;
     }
 }
 
-void getCommand(redisClient *c) {
+void getCommand(client *c) {
     getGenericCommand(c);
 }
 
-void getsetCommand(redisClient *c) {
-    if (getGenericCommand(c) == REDIS_ERR) return;
+void getsetCommand(client *c) {
+    if (getGenericCommand(c) == C_ERR) return;
     c->argv[2] = tryObjectEncoding(c->argv[2]);
     setKey(c->db,c->argv[1],c->argv[2]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"set",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_STRING,"set",c->argv[1],c->db->id);
     server.dirty++;
 }
 
-void setrangeCommand(redisClient *c) {
+void setrangeCommand(client *c) {
     robj *o;
     long offset;
     sds value = c->argv[3]->ptr;
 
-    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != REDIS_OK)
+    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)
         return;
 
     if (offset < 0) {
         addReplyError(c,"offset is out of range");
         return;
     }
@@ -188,64 +200,64 @@
         if (sdslen(value) == 0) {
             addReply(c,shared.czero);
             return;
         }
 
         /* Return when the resulting string exceeds allowed size */
-        if (checkStringLength(c,offset+sdslen(value)) != REDIS_OK)
+        if (checkStringLength(c,offset+sdslen(value)) != C_OK)
             return;
 
-        o = createObject(REDIS_STRING,sdsempty());
+        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));
         dbAdd(c->db,c->argv[1],o);
     } else {
         size_t olen;
 
         /* Key exists, check type */
-        if (checkType(c,o,REDIS_STRING))
+        if (checkType(c,o,OBJ_STRING))
             return;
 
         /* Return existing string length when setting nothing */
         olen = stringObjectLen(o);
         if (sdslen(value) == 0) {
             addReplyLongLong(c,olen);
             return;
         }
 
         /* Return when the resulting string exceeds allowed size */
-        if (checkStringLength(c,offset+sdslen(value)) != REDIS_OK)
+        if (checkStringLength(c,offset+sdslen(value)) != C_OK)
             return;
 
         /* Create a copy when the object is shared or encoded. */
         o = dbUnshareStringValue(c->db,c->argv[1],o);
     }
 
     if (sdslen(value) > 0) {
         o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));
         memcpy((char*)o->ptr+offset,value,sdslen(value));
         signalModifiedKey(c->db,c->argv[1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_STRING,
+        notifyKeyspaceEvent(NOTIFY_STRING,
             "setrange",c->argv[1],c->db->id);
         server.dirty++;
     }
     addReplyLongLong(c,sdslen(o->ptr));
 }
 
-void getrangeCommand(redisClient *c) {
+void getrangeCommand(client *c) {
     robj *o;
     long long start, end;
     char *str, llbuf[32];
     size_t strlen;
 
-    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != REDIS_OK)
+    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
         return;
-    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != REDIS_OK)
+    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
         return;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||
-        checkType(c,o,REDIS_STRING)) return;
+        checkType(c,o,OBJ_STRING)) return;
 
-    if (o->encoding == REDIS_ENCODING_INT) {
+    if (o->encoding == OBJ_ENCODING_INT) {
         str = llbuf;
         strlen = ll2string(llbuf,sizeof(llbuf),(long)o->ptr);
     } else {
         str = o->ptr;
         strlen = sdslen(str);
     }
@@ -263,31 +275,31 @@
         addReply(c,shared.emptybulk);
     } else {
         addReplyBulkCBuffer(c,(char*)str+start,end-start+1);
     }
 }
 
-void mgetCommand(redisClient *c) {
+void mgetCommand(client *c) {
     int j;
 
     addReplyMultiBulkLen(c,c->argc-1);
     for (j = 1; j < c->argc; j++) {
         robj *o = lookupKeyRead(c->db,c->argv[j]);
         if (o == NULL) {
             addReply(c,shared.nullbulk);
         } else {
-            if (o->type != REDIS_STRING) {
+            if (o->type != OBJ_STRING) {
                 addReply(c,shared.nullbulk);
             } else {
                 addReplyBulk(c,o);
             }
         }
     }
 }
 
-void msetGenericCommand(redisClient *c, int nx) {
+void msetGenericCommand(client *c, int nx) {
     int j, busykeys = 0;
 
     if ((c->argc % 2) == 0) {
         addReplyError(c,"wrong number of arguments for MSET");
         return;
     }
@@ -305,44 +317,44 @@
         }
     }
 
     for (j = 1; j < c->argc; j += 2) {
         c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
         setKey(c->db,c->argv[j],c->argv[j+1]);
-        notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"set",c->argv[j],c->db->id);
+        notifyKeyspaceEvent(NOTIFY_STRING,"set",c->argv[j],c->db->id);
     }
     server.dirty += (c->argc-1)/2;
     addReply(c, nx ? shared.cone : shared.ok);
 }
 
-void msetCommand(redisClient *c) {
+void msetCommand(client *c) {
     msetGenericCommand(c,0);
 }
 
-void msetnxCommand(redisClient *c) {
+void msetnxCommand(client *c) {
     msetGenericCommand(c,1);
 }
 
-void incrDecrCommand(redisClient *c, long long incr) {
+void incrDecrCommand(client *c, long long incr) {
     long long value, oldvalue;
     robj *o, *new;
 
     o = lookupKeyWrite(c->db,c->argv[1]);
-    if (o != NULL && checkType(c,o,REDIS_STRING)) return;
-    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != REDIS_OK) return;
+    if (o != NULL && checkType(c,o,OBJ_STRING)) return;
+    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;
 
     oldvalue = value;
     if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
         (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
         addReplyError(c,"increment or decrement would overflow");
         return;
     }
     value += incr;
 
-    if (o && o->refcount == 1 && o->encoding == REDIS_ENCODING_INT &&
-        (value < 0 || value >= REDIS_SHARED_INTEGERS) &&
+    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&
+        (value < 0 || value >= OBJ_SHARED_INTEGERS) &&
         value >= LONG_MIN && value <= LONG_MAX)
     {
         new = o;
         o->ptr = (void*)((long)value);
     } else {
         new = createStringObjectFromLongLong(value);
@@ -350,49 +362,49 @@
             dbOverwrite(c->db,c->argv[1],new);
         } else {
             dbAdd(c->db,c->argv[1],new);
         }
     }
     signalModifiedKey(c->db,c->argv[1]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"incrby",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_STRING,"incrby",c->argv[1],c->db->id);
     server.dirty++;
     addReply(c,shared.colon);
     addReply(c,new);
     addReply(c,shared.crlf);
 }
 
-void incrCommand(redisClient *c) {
+void incrCommand(client *c) {
     incrDecrCommand(c,1);
 }
 
-void decrCommand(redisClient *c) {
+void decrCommand(client *c) {
     incrDecrCommand(c,-1);
 }
 
-void incrbyCommand(redisClient *c) {
+void incrbyCommand(client *c) {
     long long incr;
 
-    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != REDIS_OK) return;
+    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
     incrDecrCommand(c,incr);
 }
 
-void decrbyCommand(redisClient *c) {
+void decrbyCommand(client *c) {
     long long incr;
 
-    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != REDIS_OK) return;
+    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
     incrDecrCommand(c,-incr);
 }
 
-void incrbyfloatCommand(redisClient *c) {
+void incrbyfloatCommand(client *c) {
     long double incr, value;
     robj *o, *new, *aux;
 
     o = lookupKeyWrite(c->db,c->argv[1]);
-    if (o != NULL && checkType(c,o,REDIS_STRING)) return;
-    if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != REDIS_OK ||
-        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != REDIS_OK)
+    if (o != NULL && checkType(c,o,OBJ_STRING)) return;
+    if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||
+        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)
         return;
 
     value += incr;
     if (isnan(value) || isinf(value)) {
         addReplyError(c,"increment would produce NaN or Infinity");
         return;
@@ -400,58 +412,58 @@
     new = createStringObjectFromLongDouble(value,1);
     if (o)
         dbOverwrite(c->db,c->argv[1],new);
     else
         dbAdd(c->db,c->argv[1],new);
     signalModifiedKey(c->db,c->argv[1]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"incrbyfloat",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_STRING,"incrbyfloat",c->argv[1],c->db->id);
     server.dirty++;
     addReplyBulk(c,new);
 
     /* Always replicate INCRBYFLOAT as a SET command with the final value
      * in order to make sure that differences in float precision or formatting
      * will not create differences in replicas or after an AOF restart. */
     aux = createStringObject("SET",3);
     rewriteClientCommandArgument(c,0,aux);
     decrRefCount(aux);
     rewriteClientCommandArgument(c,2,new);
 }
 
-void appendCommand(redisClient *c) {
+void appendCommand(client *c) {
     size_t totlen;
     robj *o, *append;
 
     o = lookupKeyWrite(c->db,c->argv[1]);
     if (o == NULL) {
         /* Create the key */
         c->argv[2] = tryObjectEncoding(c->argv[2]);
         dbAdd(c->db,c->argv[1],c->argv[2]);
         incrRefCount(c->argv[2]);
         totlen = stringObjectLen(c->argv[2]);
     } else {
         /* Key exists, check type */
-        if (checkType(c,o,REDIS_STRING))
+        if (checkType(c,o,OBJ_STRING))
             return;
 
         /* "append" is an argument, so always an sds */
         append = c->argv[2];
         totlen = stringObjectLen(o)+sdslen(append->ptr);
-        if (checkStringLength(c,totlen) != REDIS_OK)
+        if (checkStringLength(c,totlen) != C_OK)
             return;
 
         /* Append the value */
         o = dbUnshareStringValue(c->db,c->argv[1],o);
         o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));
         totlen = sdslen(o->ptr);
     }
     signalModifiedKey(c->db,c->argv[1]);
-    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"append",c->argv[1],c->db->id);
+    notifyKeyspaceEvent(NOTIFY_STRING,"append",c->argv[1],c->db->id);
     server.dirty++;
     addReplyLongLong(c,totlen);
 }
 
-void strlenCommand(redisClient *c) {
+void strlenCommand(client *c) {
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
-        checkType(c,o,REDIS_STRING)) return;
+        checkType(c,o,OBJ_STRING)) return;
     addReplyLongLong(c,stringObjectLen(o));
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_string.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_string.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_string.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_string.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_zset.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_zset.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_zset.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_zset.c	2016-05-06 15:11:36.000000000 +0800
@@ -46,13 +46,13 @@
  * a) this implementation allows for repeated scores.
  * b) the comparison is not just by key (our 'score') but by satellite data.
  * c) there is a back pointer, so it's a doubly linked list with the back
  * pointers being only at "level 1". This allows to traverse the list
  * from tail to head, useful for ZREVRANGE. */
 
-#include "redis.h"
+#include "server.h"
 #include <math.h>
 
 static int zslLexValueGteMin(robj *value, zlexrangespec *spec);
 static int zslLexValueLteMax(robj *value, zlexrangespec *spec);
 
 zskiplistNode *zslCreateNode(int level, double score, robj *obj) {
@@ -109,13 +109,13 @@
 
 zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) {
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
     unsigned int rank[ZSKIPLIST_MAXLEVEL];
     int i, level;
 
-    redisAssert(!isnan(score));
+    serverAssert(!isnan(score));
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
         /* store rank that is crossed to reach the insert position */
         rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
         while (x->level[i].forward &&
             (x->level[i].forward->score < score ||
@@ -210,13 +210,13 @@
 }
 
 static int zslValueGteMin(double value, zrangespec *spec) {
     return spec->minex ? (value > spec->min) : (value >= spec->min);
 }
 
-static int zslValueLteMax(double value, zrangespec *spec) {
+int zslValueLteMax(double value, zrangespec *spec) {
     return spec->maxex ? (value < spec->max) : (value <= spec->max);
 }
 
 /* Returns if there is a part of the zset is in range. */
 int zslIsInRange(zskiplist *zsl, zrangespec *range) {
     zskiplistNode *x;
@@ -250,13 +250,13 @@
             !zslValueGteMin(x->level[i].forward->score,range))
                 x = x->level[i].forward;
     }
 
     /* This is an inner range, so the next node cannot be NULL. */
     x = x->level[0].forward;
-    redisAssert(x != NULL);
+    serverAssert(x != NULL);
 
     /* Check if score <= max. */
     if (!zslValueLteMax(x->score,range)) return NULL;
     return x;
 }
 
@@ -275,13 +275,13 @@
         while (x->level[i].forward &&
             zslValueLteMax(x->level[i].forward->score,range))
                 x = x->level[i].forward;
     }
 
     /* This is an inner range, so this node cannot be NULL. */
-    redisAssert(x != NULL);
+    serverAssert(x != NULL);
 
     /* Check if score >= min. */
     if (!zslValueGteMin(x->score,range)) return NULL;
     return x;
 }
 
@@ -432,108 +432,108 @@
     spec->minex = spec->maxex = 0;
 
     /* Parse the min-max interval. If one of the values is prefixed
      * by the "(" character, it's considered "open". For instance
      * ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max
      * ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */
-    if (min->encoding == REDIS_ENCODING_INT) {
+    if (min->encoding == OBJ_ENCODING_INT) {
         spec->min = (long)min->ptr;
     } else {
         if (((char*)min->ptr)[0] == '(') {
             spec->min = strtod((char*)min->ptr+1,&eptr);
-            if (eptr[0] != '\0' || isnan(spec->min)) return REDIS_ERR;
+            if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
             spec->minex = 1;
         } else {
             spec->min = strtod((char*)min->ptr,&eptr);
-            if (eptr[0] != '\0' || isnan(spec->min)) return REDIS_ERR;
+            if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
         }
     }
-    if (max->encoding == REDIS_ENCODING_INT) {
+    if (max->encoding == OBJ_ENCODING_INT) {
         spec->max = (long)max->ptr;
     } else {
         if (((char*)max->ptr)[0] == '(') {
             spec->max = strtod((char*)max->ptr+1,&eptr);
-            if (eptr[0] != '\0' || isnan(spec->max)) return REDIS_ERR;
+            if (eptr[0] != '\0' || isnan(spec->max)) return C_ERR;
             spec->maxex = 1;
         } else {
             spec->max = strtod((char*)max->ptr,&eptr);
-            if (eptr[0] != '\0' || isnan(spec->max)) return REDIS_ERR;
+            if (eptr[0] != '\0' || isnan(spec->max)) return C_ERR;
         }
     }
 
-    return REDIS_OK;
+    return C_OK;
 }
 
 /* ------------------------ Lexicographic ranges ---------------------------- */
 
 /* Parse max or min argument of ZRANGEBYLEX.
   * (foo means foo (open interval)
   * [foo means foo (closed interval)
   * - means the min string possible
   * + means the max string possible
   *
   * If the string is valid the *dest pointer is set to the redis object
   * that will be used for the comparision, and ex will be set to 0 or 1
-  * respectively if the item is exclusive or inclusive. REDIS_OK will be
+  * respectively if the item is exclusive or inclusive. C_OK will be
   * returned.
   *
-  * If the string is not a valid range REDIS_ERR is returned, and the value
+  * If the string is not a valid range C_ERR is returned, and the value
   * of *dest and *ex is undefined. */
 int zslParseLexRangeItem(robj *item, robj **dest, int *ex) {
     char *c = item->ptr;
 
     switch(c[0]) {
     case '+':
-        if (c[1] != '\0') return REDIS_ERR;
+        if (c[1] != '\0') return C_ERR;
         *ex = 0;
         *dest = shared.maxstring;
         incrRefCount(shared.maxstring);
-        return REDIS_OK;
+        return C_OK;
     case '-':
-        if (c[1] != '\0') return REDIS_ERR;
+        if (c[1] != '\0') return C_ERR;
         *ex = 0;
         *dest = shared.minstring;
         incrRefCount(shared.minstring);
-        return REDIS_OK;
+        return C_OK;
     case '(':
         *ex = 1;
         *dest = createStringObject(c+1,sdslen(c)-1);
-        return REDIS_OK;
+        return C_OK;
     case '[':
         *ex = 0;
         *dest = createStringObject(c+1,sdslen(c)-1);
-        return REDIS_OK;
+        return C_OK;
     default:
-        return REDIS_ERR;
+        return C_ERR;
     }
 }
 
 /* Populate the rangespec according to the objects min and max.
  *
- * Return REDIS_OK on success. On error REDIS_ERR is returned.
+ * Return C_OK on success. On error C_ERR is returned.
  * When OK is returned the structure must be freed with zslFreeLexRange(),
  * otherwise no release is needed. */
 static int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
     /* The range can't be valid if objects are integer encoded.
      * Every item must start with ( or [. */
-    if (min->encoding == REDIS_ENCODING_INT ||
-        max->encoding == REDIS_ENCODING_INT) return REDIS_ERR;
+    if (min->encoding == OBJ_ENCODING_INT ||
+        max->encoding == OBJ_ENCODING_INT) return C_ERR;
 
     spec->min = spec->max = NULL;
-    if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == REDIS_ERR ||
-        zslParseLexRangeItem(max, &spec->max, &spec->maxex) == REDIS_ERR) {
+    if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == C_ERR ||
+        zslParseLexRangeItem(max, &spec->max, &spec->maxex) == C_ERR) {
         if (spec->min) decrRefCount(spec->min);
         if (spec->max) decrRefCount(spec->max);
-        return REDIS_ERR;
+        return C_ERR;
     } else {
-        return REDIS_OK;
+        return C_OK;
     }
 }
 
 /* Free a lex range structure, must be called only after zelParseLexRange()
- * populated the structure with success (REDIS_OK returned). */
+ * populated the structure with success (C_OK returned). */
 void zslFreeLexRange(zlexrangespec *spec) {
     decrRefCount(spec->min);
     decrRefCount(spec->max);
 }
 
 /* This is just a wrapper to compareStringObjects() that is able to
@@ -593,13 +593,13 @@
             !zslLexValueGteMin(x->level[i].forward->obj,range))
                 x = x->level[i].forward;
     }
 
     /* This is an inner range, so the next node cannot be NULL. */
     x = x->level[0].forward;
-    redisAssert(x != NULL);
+    serverAssert(x != NULL);
 
     /* Check if score <= max. */
     if (!zslLexValueLteMax(x->obj,range)) return NULL;
     return x;
 }
 
@@ -618,13 +618,13 @@
         while (x->level[i].forward &&
             zslLexValueLteMax(x->level[i].forward->obj,range))
                 x = x->level[i].forward;
     }
 
     /* This is an inner range, so this node cannot be NULL. */
-    redisAssert(x != NULL);
+    serverAssert(x != NULL);
 
     /* Check if score >= min. */
     if (!zslLexValueGteMin(x->obj,range)) return NULL;
     return x;
 }
 
@@ -636,14 +636,14 @@
     unsigned char *vstr;
     unsigned int vlen;
     long long vlong;
     char buf[128];
     double score;
 
-    redisAssert(sptr != NULL);
-    redisAssert(ziplistGet(sptr,&vstr,&vlen,&vlong));
+    serverAssert(sptr != NULL);
+    serverAssert(ziplistGet(sptr,&vstr,&vlen,&vlong));
 
     if (vstr) {
         memcpy(buf,vstr,vlen);
         buf[vlen] = '\0';
         score = strtod(buf,NULL);
     } else {
@@ -658,14 +658,14 @@
  * cost of some performance. */
 robj *ziplistGetObject(unsigned char *sptr) {
     unsigned char *vstr;
     unsigned int vlen;
     long long vlong;
 
-    redisAssert(sptr != NULL);
-    redisAssert(ziplistGet(sptr,&vstr,&vlen,&vlong));
+    serverAssert(sptr != NULL);
+    serverAssert(ziplistGet(sptr,&vstr,&vlen,&vlong));
 
     if (vstr) {
         return createStringObject((char*)vstr,vlen);
     } else {
         return createStringObjectFromLongLong(vlong);
     }
@@ -676,13 +676,13 @@
     unsigned char *vstr;
     unsigned int vlen;
     long long vlong;
     unsigned char vbuf[32];
     int minlen, cmp;
 
-    redisAssert(ziplistGet(eptr,&vstr,&vlen,&vlong));
+    serverAssert(ziplistGet(eptr,&vstr,&vlen,&vlong));
     if (vstr == NULL) {
         /* Store string representation of long long in buf. */
         vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);
         vstr = vbuf;
     }
 
@@ -697,18 +697,18 @@
 }
 
 /* Move to next entry based on the values in eptr and sptr. Both are set to
  * NULL when there is no next entry. */
 void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
     unsigned char *_eptr, *_sptr;
-    redisAssert(*eptr != NULL && *sptr != NULL);
+    serverAssert(*eptr != NULL && *sptr != NULL);
 
     _eptr = ziplistNext(zl,*sptr);
     if (_eptr != NULL) {
         _sptr = ziplistNext(zl,_eptr);
-        redisAssert(_sptr != NULL);
+        serverAssert(_sptr != NULL);
     } else {
         /* No next entry. */
         _sptr = NULL;
     }
 
     *eptr = _eptr;
@@ -716,18 +716,18 @@
 }
 
 /* Move to the previous entry based on the values in eptr and sptr. Both are
  * set to NULL when there is no next entry. */
 void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
     unsigned char *_eptr, *_sptr;
-    redisAssert(*eptr != NULL && *sptr != NULL);
+    serverAssert(*eptr != NULL && *sptr != NULL);
 
     _sptr = ziplistPrev(zl,*eptr);
     if (_sptr != NULL) {
         _eptr = ziplistPrev(zl,_sptr);
-        redisAssert(_eptr != NULL);
+        serverAssert(_eptr != NULL);
     } else {
         /* No previous entry. */
         _eptr = NULL;
     }
 
     *eptr = _eptr;
@@ -749,13 +749,13 @@
     if (p == NULL) return 0; /* Empty sorted set */
     score = zzlGetScore(p);
     if (!zslValueGteMin(score,range))
         return 0;
 
     p = ziplistIndex(zl,1); /* First score. */
-    redisAssert(p != NULL);
+    serverAssert(p != NULL);
     score = zzlGetScore(p);
     if (!zslValueLteMax(score,range))
         return 0;
 
     return 1;
 }
@@ -768,13 +768,13 @@
 
     /* If everything is out of range, return early. */
     if (!zzlIsInRange(zl,range)) return NULL;
 
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
-        redisAssert(sptr != NULL);
+        serverAssert(sptr != NULL);
 
         score = zzlGetScore(sptr);
         if (zslValueGteMin(score,range)) {
             /* Check if score <= max. */
             if (zslValueLteMax(score,range))
                 return eptr;
@@ -796,13 +796,13 @@
 
     /* If everything is out of range, return early. */
     if (!zzlIsInRange(zl,range)) return NULL;
 
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
-        redisAssert(sptr != NULL);
+        serverAssert(sptr != NULL);
 
         score = zzlGetScore(sptr);
         if (zslValueLteMax(score,range)) {
             /* Check if score >= min. */
             if (zslValueGteMin(score,range))
                 return eptr;
@@ -810,13 +810,13 @@
         }
 
         /* Move to previous element by moving to the score of previous element.
          * When this returns NULL, we know there also is no element. */
         sptr = ziplistPrev(zl,eptr);
         if (sptr != NULL)
-            redisAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
+            serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
         else
             eptr = NULL;
     }
 
     return NULL;
 }
@@ -849,13 +849,13 @@
     p = ziplistIndex(zl,-2); /* Last element. */
     if (p == NULL) return 0;
     if (!zzlLexValueGteMin(p,range))
         return 0;
 
     p = ziplistIndex(zl,0); /* First element. */
-    redisAssert(p != NULL);
+    serverAssert(p != NULL);
     if (!zzlLexValueLteMax(p,range))
         return 0;
 
     return 1;
 }
 
@@ -874,13 +874,13 @@
                 return eptr;
             return NULL;
         }
 
         /* Move to next element. */
         sptr = ziplistNext(zl,eptr); /* This element score. Skip it. */
-        redisAssert(sptr != NULL);
+        serverAssert(sptr != NULL);
         eptr = ziplistNext(zl,sptr); /* Next element. */
     }
 
     return NULL;
 }
 
@@ -901,13 +901,13 @@
         }
 
         /* Move to previous element by moving to the score of previous element.
          * When this returns NULL, we know there also is no element. */
         sptr = ziplistPrev(zl,eptr);
         if (sptr != NULL)
-            redisAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
+            serverAssert((eptr = ziplistPrev(zl,sptr)) != NULL);
         else
             eptr = NULL;
     }
 
     return NULL;
 }
@@ -915,13 +915,13 @@
 unsigned char *zzlFind(unsigned char *zl, robj *ele, double *score) {
     unsigned char *eptr = ziplistIndex(zl,0), *sptr;
 
     ele = getDecodedObject(ele);
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
-        redisAssertWithInfo(NULL,ele,sptr != NULL);
+        serverAssertWithInfo(NULL,ele,sptr != NULL);
 
         if (ziplistCompare(eptr,ele->ptr,sdslen(ele->ptr))) {
             /* Matching element, pull out score. */
             if (score != NULL) *score = zzlGetScore(sptr);
             decrRefCount(ele);
             return eptr;
@@ -949,25 +949,25 @@
 unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, robj *ele, double score) {
     unsigned char *sptr;
     char scorebuf[128];
     int scorelen;
     size_t offset;
 
-    redisAssertWithInfo(NULL,ele,sdsEncodedObject(ele));
+    serverAssertWithInfo(NULL,ele,sdsEncodedObject(ele));
     scorelen = d2string(scorebuf,sizeof(scorebuf),score);
     if (eptr == NULL) {
         zl = ziplistPush(zl,ele->ptr,sdslen(ele->ptr),ZIPLIST_TAIL);
         zl = ziplistPush(zl,(unsigned char*)scorebuf,scorelen,ZIPLIST_TAIL);
     } else {
         /* Keep offset relative to zl, as it might be re-allocated. */
         offset = eptr-zl;
         zl = ziplistInsert(zl,eptr,ele->ptr,sdslen(ele->ptr));
         eptr = zl+offset;
 
         /* Insert score after the element. */
-        redisAssertWithInfo(NULL,ele,(sptr = ziplistNext(zl,eptr)) != NULL);
+        serverAssertWithInfo(NULL,ele,(sptr = ziplistNext(zl,eptr)) != NULL);
         zl = ziplistInsert(zl,sptr,(unsigned char*)scorebuf,scorelen);
     }
 
     return zl;
 }
 
@@ -977,13 +977,13 @@
     unsigned char *eptr = ziplistIndex(zl,0), *sptr;
     double s;
 
     ele = getDecodedObject(ele);
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
-        redisAssertWithInfo(NULL,ele,sptr != NULL);
+        serverAssertWithInfo(NULL,ele,sptr != NULL);
         s = zzlGetScore(sptr);
 
         if (s > score) {
             /* First element with score larger than score for element to be
              * inserted. This means we should take its spot in the list to
              * maintain ordering. */
@@ -1077,71 +1077,71 @@
 /*-----------------------------------------------------------------------------
  * Common sorted set API
  *----------------------------------------------------------------------------*/
 
 unsigned int zsetLength(robj *zobj) {
     int length = -1;
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         length = zzlLength(zobj->ptr);
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         length = ((zset*)zobj->ptr)->zsl->length;
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
     return length;
 }
 
 void zsetConvert(robj *zobj, int encoding) {
     zset *zs;
     zskiplistNode *node, *next;
     robj *ele;
     double score;
 
     if (zobj->encoding == encoding) return;
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
         unsigned char *vstr;
         unsigned int vlen;
         long long vlong;
 
-        if (encoding != REDIS_ENCODING_SKIPLIST)
-            redisPanic("Unknown target encoding");
+        if (encoding != OBJ_ENCODING_SKIPLIST)
+            serverPanic("Unknown target encoding");
 
         zs = zmalloc(sizeof(*zs));
         zs->dict = dictCreate(&zsetDictType,NULL);
         zs->zsl = zslCreate();
 
         eptr = ziplistIndex(zl,0);
-        redisAssertWithInfo(NULL,zobj,eptr != NULL);
+        serverAssertWithInfo(NULL,zobj,eptr != NULL);
         sptr = ziplistNext(zl,eptr);
-        redisAssertWithInfo(NULL,zobj,sptr != NULL);
+        serverAssertWithInfo(NULL,zobj,sptr != NULL);
 
         while (eptr != NULL) {
             score = zzlGetScore(sptr);
-            redisAssertWithInfo(NULL,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
+            serverAssertWithInfo(NULL,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
             if (vstr == NULL)
                 ele = createStringObjectFromLongLong(vlong);
             else
                 ele = createStringObject((char*)vstr,vlen);
 
             /* Has incremented refcount since it was just created. */
             node = zslInsert(zs->zsl,score,ele);
-            redisAssertWithInfo(NULL,zobj,dictAdd(zs->dict,ele,&node->score) == DICT_OK);
+            serverAssertWithInfo(NULL,zobj,dictAdd(zs->dict,ele,&node->score) == DICT_OK);
             incrRefCount(ele); /* Added to dictionary. */
             zzlNext(zl,&eptr,&sptr);
         }
 
         zfree(zobj->ptr);
         zobj->ptr = zs;
-        zobj->encoding = REDIS_ENCODING_SKIPLIST;
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+        zobj->encoding = OBJ_ENCODING_SKIPLIST;
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         unsigned char *zl = ziplistNew();
 
-        if (encoding != REDIS_ENCODING_ZIPLIST)
-            redisPanic("Unknown target encoding");
+        if (encoding != OBJ_ENCODING_ZIPLIST)
+            serverPanic("Unknown target encoding");
 
         /* Approach similar to zslFree(), since we want to free the skiplist at
          * the same time as creating the ziplist. */
         zs = zobj->ptr;
         dictRelease(zs->dict);
         node = zs->zsl->header->level[0].forward;
@@ -1157,29 +1157,61 @@
             zslFreeNode(node);
             node = next;
         }
 
         zfree(zs);
         zobj->ptr = zl;
-        zobj->encoding = REDIS_ENCODING_ZIPLIST;
+        zobj->encoding = OBJ_ENCODING_ZIPLIST;
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 }
 
+/* Convert the sorted set object into a ziplist if it is not already a ziplist
+ * and if the number of elements and the maximum element size is within the
+ * expected ranges. */
+void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;
+    zset *zset = zobj->ptr;
+
+    if (zset->zsl->length <= server.zset_max_ziplist_entries &&
+        maxelelen <= server.zset_max_ziplist_value)
+            zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);
+}
+
+/* Return (by reference) the score of the specified member of the sorted set
+ * storing it into *score. If the element does not exist C_ERR is returned
+ * otherwise C_OK is returned and *score is correctly populated.
+ * If 'zobj' or 'member' is NULL, C_ERR is returned. */
+int zsetScore(robj *zobj, robj *member, double *score) {
+    if (!zobj || !member) return C_ERR;
+
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
+        if (zzlFind(zobj->ptr, member, score) == NULL) return C_ERR;
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
+        zset *zs = zobj->ptr;
+        dictEntry *de = dictFind(zs->dict, member);
+        if (de == NULL) return C_ERR;
+        *score = *(double*)dictGetVal(de);
+    } else {
+        serverPanic("Unknown sorted set encoding");
+    }
+    return C_OK;
+}
+
 /*-----------------------------------------------------------------------------
  * Sorted set commands
  *----------------------------------------------------------------------------*/
 
 /* This generic command implements both ZADD and ZINCRBY. */
 #define ZADD_NONE 0
 #define ZADD_INCR (1<<0)    /* Increment the score instead of setting it. */
 #define ZADD_NX (1<<1)      /* Don't touch elements not already existing. */
 #define ZADD_XX (1<<2)      /* Only touch elements already exisitng. */
 #define ZADD_CH (1<<3)      /* Return num of elements added or updated. */
-void zaddGenericCommand(redisClient *c, int flags) {
+void zaddGenericCommand(client *c, int flags) {
     static char *nanerr = "resulting score is not a number (NaN)";
     robj *key = c->argv[1];
     robj *ele;
     robj *zobj;
     robj *curobj;
     double score = 0, *scores = NULL, curscore = 0.0;
@@ -1237,13 +1269,13 @@
     /* Start parsing all the scores, we need to emit any syntax error
      * before executing additions to the sorted set, as the command should
      * either execute fully or nothing at all. */
     scores = zmalloc(sizeof(double)*elements);
     for (j = 0; j < elements; j++) {
         if (getDoubleFromObjectOrReply(c,c->argv[scoreidx+j*2],&scores[j],NULL)
-            != REDIS_OK) goto cleanup;
+            != C_OK) goto cleanup;
     }
 
     /* Lookup the key and create the sorted set if does not exist. */
     zobj = lookupKeyWrite(c->db,key);
     if (zobj == NULL) {
         if (xx) goto reply_to_client; /* No key + XX option: nothing to do. */
@@ -1253,22 +1285,22 @@
             zobj = createZsetObject();
         } else {
             zobj = createZsetZiplistObject();
         }
         dbAdd(c->db,key,zobj);
     } else {
-        if (zobj->type != REDIS_ZSET) {
+        if (zobj->type != OBJ_ZSET) {
             addReply(c,shared.wrongtypeerr);
             goto cleanup;
         }
     }
 
     for (j = 0; j < elements; j++) {
         score = scores[j];
 
-        if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+        if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
             unsigned char *eptr;
 
             /* Prefer non-encoded element when dealing with ziplists. */
             ele = c->argv[scoreidx+1+j*2];
             if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {
                 if (nx) continue;
@@ -1290,20 +1322,20 @@
                 processed++;
             } else if (!xx) {
                 /* Optimize: check if the element is too large or the list
                  * becomes too long *before* executing zzlInsert. */
                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);
                 if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries)
-                    zsetConvert(zobj,REDIS_ENCODING_SKIPLIST);
+                    zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
                 if (sdslen(ele->ptr) > server.zset_max_ziplist_value)
-                    zsetConvert(zobj,REDIS_ENCODING_SKIPLIST);
+                    zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
                 server.dirty++;
                 added++;
                 processed++;
             }
-        } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+        } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
             zset *zs = zobj->ptr;
             zskiplistNode *znode;
             dictEntry *de;
 
             ele = c->argv[scoreidx+1+j*2] =
                 tryObjectEncoding(c->argv[scoreidx+1+j*2]);
@@ -1324,31 +1356,31 @@
                 }
 
                 /* Remove and re-insert when score changed. We can safely
                  * delete the key object from the skiplist, since the
                  * dictionary still has a reference to it. */
                 if (score != curscore) {
-                    redisAssertWithInfo(c,curobj,zslDelete(zs->zsl,curscore,curobj));
+                    serverAssertWithInfo(c,curobj,zslDelete(zs->zsl,curscore,curobj));
                     znode = zslInsert(zs->zsl,score,curobj);
                     incrRefCount(curobj); /* Re-inserted in skiplist. */
                     dictGetVal(de) = &znode->score; /* Update score ptr. */
                     server.dirty++;
                     updated++;
                 }
                 processed++;
             } else if (!xx) {
                 znode = zslInsert(zs->zsl,score,ele);
                 incrRefCount(ele); /* Inserted in skiplist. */
-                redisAssertWithInfo(c,NULL,dictAdd(zs->dict,ele,&znode->score) == DICT_OK);
+                serverAssertWithInfo(c,NULL,dictAdd(zs->dict,ele,&znode->score) == DICT_OK);
                 incrRefCount(ele); /* Added to dictionary. */
                 server.dirty++;
                 added++;
                 processed++;
             }
         } else {
-            redisPanic("Unknown sorted set encoding");
+            serverPanic("Unknown sorted set encoding");
         }
     }
 
 reply_to_client:
     if (incr) { /* ZINCRBY or INCR option. */
         if (processed)
@@ -1360,34 +1392,34 @@
     }
 
 cleanup:
     zfree(scores);
     if (added || updated) {
         signalModifiedKey(c->db,key);
-        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,
+        notifyKeyspaceEvent(NOTIFY_ZSET,
             incr ? "zincr" : "zadd", key, c->db->id);
     }
 }
 
-void zaddCommand(redisClient *c) {
+void zaddCommand(client *c) {
     zaddGenericCommand(c,ZADD_NONE);
 }
 
-void zincrbyCommand(redisClient *c) {
+void zincrbyCommand(client *c) {
     zaddGenericCommand(c,ZADD_INCR);
 }
 
-void zremCommand(redisClient *c) {
+void zremCommand(client *c) {
     robj *key = c->argv[1];
     robj *zobj;
     int deleted = 0, keyremoved = 0, j;
 
     if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
-        checkType(c,zobj,REDIS_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) return;
 
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *eptr;
 
         for (j = 2; j < c->argc; j++) {
             if ((eptr = zzlFind(zobj->ptr,c->argv[j],NULL)) != NULL) {
                 deleted++;
                 zobj->ptr = zzlDelete(zobj->ptr,eptr);
@@ -1395,83 +1427,83 @@
                     dbDelete(c->db,key);
                     keyremoved = 1;
                     break;
                 }
             }
         }
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         dictEntry *de;
         double score;
 
         for (j = 2; j < c->argc; j++) {
             de = dictFind(zs->dict,c->argv[j]);
             if (de != NULL) {
                 deleted++;
 
                 /* Delete from the skiplist */
                 score = *(double*)dictGetVal(de);
-                redisAssertWithInfo(c,c->argv[j],zslDelete(zs->zsl,score,c->argv[j]));
+                serverAssertWithInfo(c,c->argv[j],zslDelete(zs->zsl,score,c->argv[j]));
 
                 /* Delete from the hash table */
                 dictDelete(zs->dict,c->argv[j]);
                 if (htNeedsResize(zs->dict)) dictResize(zs->dict);
                 if (dictSize(zs->dict) == 0) {
                     dbDelete(c->db,key);
                     keyremoved = 1;
                     break;
                 }
             }
         }
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 
     if (deleted) {
-        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,"zrem",key,c->db->id);
+        notifyKeyspaceEvent(NOTIFY_ZSET,"zrem",key,c->db->id);
         if (keyremoved)
-            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",key,c->db->id);
+            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
         signalModifiedKey(c->db,key);
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
 }
 
 /* Implements ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREMRANGEBYLEX commands. */
 #define ZRANGE_RANK 0
 #define ZRANGE_SCORE 1
 #define ZRANGE_LEX 2
-void zremrangeGenericCommand(redisClient *c, int rangetype) {
+void zremrangeGenericCommand(client *c, int rangetype) {
     robj *key = c->argv[1];
     robj *zobj;
     int keyremoved = 0;
-    unsigned long deleted;
+    unsigned long deleted = 0;
     zrangespec range;
     zlexrangespec lexrange;
     long start, end, llen;
 
     /* Step 1: Parse the range. */
     if (rangetype == ZRANGE_RANK) {
-        if ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != REDIS_OK) ||
-            (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != REDIS_OK))
+        if ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) ||
+            (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK))
             return;
     } else if (rangetype == ZRANGE_SCORE) {
-        if (zslParseRange(c->argv[2],c->argv[3],&range) != REDIS_OK) {
+        if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
             addReplyError(c,"min or max is not a float");
             return;
         }
     } else if (rangetype == ZRANGE_LEX) {
-        if (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != REDIS_OK) {
+        if (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != C_OK) {
             addReplyError(c,"min or max not valid string range item");
             return;
         }
     }
 
     /* Step 2: Lookup & range sanity checks if needed. */
     if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
-        checkType(c,zobj,REDIS_ZSET)) goto cleanup;
+        checkType(c,zobj,OBJ_ZSET)) goto cleanup;
 
     if (rangetype == ZRANGE_RANK) {
         /* Sanitize indexes. */
         llen = zsetLength(zobj);
         if (start < 0) start = llen+start;
         if (end < 0) end = llen+end;
@@ -1484,13 +1516,13 @@
             goto cleanup;
         }
         if (end >= llen) end = llen-1;
     }
 
     /* Step 3: Perform the range deletion operation. */
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         switch(rangetype) {
         case ZRANGE_RANK:
             zobj->ptr = zzlDeleteRangeByRank(zobj->ptr,start+1,end+1,&deleted);
             break;
         case ZRANGE_SCORE:
             zobj->ptr = zzlDeleteRangeByScore(zobj->ptr,&range,&deleted);
@@ -1500,13 +1532,13 @@
             break;
         }
         if (zzlLength(zobj->ptr) == 0) {
             dbDelete(c->db,key);
             keyremoved = 1;
         }
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         switch(rangetype) {
         case ZRANGE_RANK:
             deleted = zslDeleteRangeByRank(zs->zsl,start+1,end+1,zs->dict);
             break;
         case ZRANGE_SCORE:
@@ -1519,39 +1551,39 @@
         if (htNeedsResize(zs->dict)) dictResize(zs->dict);
         if (dictSize(zs->dict) == 0) {
             dbDelete(c->db,key);
             keyremoved = 1;
         }
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 
     /* Step 4: Notifications and reply. */
     if (deleted) {
         char *event[3] = {"zremrangebyrank","zremrangebyscore","zremrangebylex"};
         signalModifiedKey(c->db,key);
-        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,event[rangetype],key,c->db->id);
+        notifyKeyspaceEvent(NOTIFY_ZSET,event[rangetype],key,c->db->id);
         if (keyremoved)
-            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",key,c->db->id);
+            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
     }
     server.dirty += deleted;
     addReplyLongLong(c,deleted);
 
 cleanup:
     if (rangetype == ZRANGE_LEX) zslFreeLexRange(&lexrange);
 }
 
-void zremrangebyrankCommand(redisClient *c) {
+void zremrangebyrankCommand(client *c) {
     zremrangeGenericCommand(c,ZRANGE_RANK);
 }
 
-void zremrangebyscoreCommand(redisClient *c) {
+void zremrangebyscoreCommand(client *c) {
     zremrangeGenericCommand(c,ZRANGE_SCORE);
 }
 
-void zremrangebylexCommand(redisClient *c) {
+void zremrangebylexCommand(client *c) {
     zremrangeGenericCommand(c,ZRANGE_LEX);
 }
 
 typedef struct {
     robj *subject;
     int type; /* Set, sorted set */
@@ -1612,95 +1644,95 @@
 typedef union _iterzset iterzset;
 
 void zuiInitIterator(zsetopsrc *op) {
     if (op->subject == NULL)
         return;
 
-    if (op->type == REDIS_SET) {
+    if (op->type == OBJ_SET) {
         iterset *it = &op->iter.set;
-        if (op->encoding == REDIS_ENCODING_INTSET) {
+        if (op->encoding == OBJ_ENCODING_INTSET) {
             it->is.is = op->subject->ptr;
             it->is.ii = 0;
-        } else if (op->encoding == REDIS_ENCODING_HT) {
+        } else if (op->encoding == OBJ_ENCODING_HT) {
             it->ht.dict = op->subject->ptr;
             it->ht.di = dictGetIterator(op->subject->ptr);
             it->ht.de = dictNext(it->ht.di);
         } else {
-            redisPanic("Unknown set encoding");
+            serverPanic("Unknown set encoding");
         }
-    } else if (op->type == REDIS_ZSET) {
+    } else if (op->type == OBJ_ZSET) {
         iterzset *it = &op->iter.zset;
-        if (op->encoding == REDIS_ENCODING_ZIPLIST) {
+        if (op->encoding == OBJ_ENCODING_ZIPLIST) {
             it->zl.zl = op->subject->ptr;
             it->zl.eptr = ziplistIndex(it->zl.zl,0);
             if (it->zl.eptr != NULL) {
                 it->zl.sptr = ziplistNext(it->zl.zl,it->zl.eptr);
-                redisAssert(it->zl.sptr != NULL);
+                serverAssert(it->zl.sptr != NULL);
             }
-        } else if (op->encoding == REDIS_ENCODING_SKIPLIST) {
+        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
             it->sl.zs = op->subject->ptr;
             it->sl.node = it->sl.zs->zsl->header->level[0].forward;
         } else {
-            redisPanic("Unknown sorted set encoding");
+            serverPanic("Unknown sorted set encoding");
         }
     } else {
-        redisPanic("Unsupported type");
+        serverPanic("Unsupported type");
     }
 }
 
 void zuiClearIterator(zsetopsrc *op) {
     if (op->subject == NULL)
         return;
 
-    if (op->type == REDIS_SET) {
+    if (op->type == OBJ_SET) {
         iterset *it = &op->iter.set;
-        if (op->encoding == REDIS_ENCODING_INTSET) {
-            REDIS_NOTUSED(it); /* skip */
-        } else if (op->encoding == REDIS_ENCODING_HT) {
+        if (op->encoding == OBJ_ENCODING_INTSET) {
+            UNUSED(it); /* skip */
+        } else if (op->encoding == OBJ_ENCODING_HT) {
             dictReleaseIterator(it->ht.di);
         } else {
-            redisPanic("Unknown set encoding");
+            serverPanic("Unknown set encoding");
         }
-    } else if (op->type == REDIS_ZSET) {
+    } else if (op->type == OBJ_ZSET) {
         iterzset *it = &op->iter.zset;
-        if (op->encoding == REDIS_ENCODING_ZIPLIST) {
-            REDIS_NOTUSED(it); /* skip */
-        } else if (op->encoding == REDIS_ENCODING_SKIPLIST) {
-            REDIS_NOTUSED(it); /* skip */
+        if (op->encoding == OBJ_ENCODING_ZIPLIST) {
+            UNUSED(it); /* skip */
+        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
+            UNUSED(it); /* skip */
         } else {
-            redisPanic("Unknown sorted set encoding");
+            serverPanic("Unknown sorted set encoding");
         }
     } else {
-        redisPanic("Unsupported type");
+        serverPanic("Unsupported type");
     }
 }
 
 int zuiLength(zsetopsrc *op) {
     if (op->subject == NULL)
         return 0;
 
-    if (op->type == REDIS_SET) {
-        if (op->encoding == REDIS_ENCODING_INTSET) {
+    if (op->type == OBJ_SET) {
+        if (op->encoding == OBJ_ENCODING_INTSET) {
             return intsetLen(op->subject->ptr);
-        } else if (op->encoding == REDIS_ENCODING_HT) {
+        } else if (op->encoding == OBJ_ENCODING_HT) {
             dict *ht = op->subject->ptr;
             return dictSize(ht);
         } else {
-            redisPanic("Unknown set encoding");
+            serverPanic("Unknown set encoding");
         }
-    } else if (op->type == REDIS_ZSET) {
-        if (op->encoding == REDIS_ENCODING_ZIPLIST) {
+    } else if (op->type == OBJ_ZSET) {
+        if (op->encoding == OBJ_ENCODING_ZIPLIST) {
             return zzlLength(op->subject->ptr);
-        } else if (op->encoding == REDIS_ENCODING_SKIPLIST) {
+        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
             zset *zs = op->subject->ptr;
             return zs->zsl->length;
         } else {
-            redisPanic("Unknown sorted set encoding");
+            serverPanic("Unknown sorted set encoding");
         }
     } else {
-        redisPanic("Unsupported type");
+        serverPanic("Unsupported type");
     }
 }
 
 /* Check if the current value is valid. If so, store it in the passed structure
  * and move to the next element. If not valid, this means we have reached the
  * end of the structure and can abort. */
@@ -1710,76 +1742,76 @@
 
     if (val->flags & OPVAL_DIRTY_ROBJ)
         decrRefCount(val->ele);
 
     memset(val,0,sizeof(zsetopval));
 
-    if (op->type == REDIS_SET) {
+    if (op->type == OBJ_SET) {
         iterset *it = &op->iter.set;
-        if (op->encoding == REDIS_ENCODING_INTSET) {
+        if (op->encoding == OBJ_ENCODING_INTSET) {
             int64_t ell;
 
             if (!intsetGet(it->is.is,it->is.ii,&ell))
                 return 0;
             val->ell = ell;
             val->score = 1.0;
 
             /* Move to next element. */
             it->is.ii++;
-        } else if (op->encoding == REDIS_ENCODING_HT) {
+        } else if (op->encoding == OBJ_ENCODING_HT) {
             if (it->ht.de == NULL)
                 return 0;
             val->ele = dictGetKey(it->ht.de);
             val->score = 1.0;
 
             /* Move to next element. */
             it->ht.de = dictNext(it->ht.di);
         } else {
-            redisPanic("Unknown set encoding");
+            serverPanic("Unknown set encoding");
         }
-    } else if (op->type == REDIS_ZSET) {
+    } else if (op->type == OBJ_ZSET) {
         iterzset *it = &op->iter.zset;
-        if (op->encoding == REDIS_ENCODING_ZIPLIST) {
+        if (op->encoding == OBJ_ENCODING_ZIPLIST) {
             /* No need to check both, but better be explicit. */
             if (it->zl.eptr == NULL || it->zl.sptr == NULL)
                 return 0;
-            redisAssert(ziplistGet(it->zl.eptr,&val->estr,&val->elen,&val->ell));
+            serverAssert(ziplistGet(it->zl.eptr,&val->estr,&val->elen,&val->ell));
             val->score = zzlGetScore(it->zl.sptr);
 
             /* Move to next element. */
             zzlNext(it->zl.zl,&it->zl.eptr,&it->zl.sptr);
-        } else if (op->encoding == REDIS_ENCODING_SKIPLIST) {
+        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
             if (it->sl.node == NULL)
                 return 0;
             val->ele = it->sl.node->obj;
             val->score = it->sl.node->score;
 
             /* Move to next element. */
             it->sl.node = it->sl.node->level[0].forward;
         } else {
-            redisPanic("Unknown sorted set encoding");
+            serverPanic("Unknown sorted set encoding");
         }
     } else {
-        redisPanic("Unsupported type");
+        serverPanic("Unsupported type");
     }
     return 1;
 }
 
 int zuiLongLongFromValue(zsetopval *val) {
     if (!(val->flags & OPVAL_DIRTY_LL)) {
         val->flags |= OPVAL_DIRTY_LL;
 
         if (val->ele != NULL) {
-            if (val->ele->encoding == REDIS_ENCODING_INT) {
+            if (val->ele->encoding == OBJ_ENCODING_INT) {
                 val->ell = (long)val->ele->ptr;
                 val->flags |= OPVAL_VALID_LL;
             } else if (sdsEncodedObject(val->ele)) {
                 if (string2ll(val->ele->ptr,sdslen(val->ele->ptr),&val->ell))
                     val->flags |= OPVAL_VALID_LL;
             } else {
-                redisPanic("Unsupported element encoding");
+                serverPanic("Unsupported element encoding");
             }
         } else if (val->estr != NULL) {
             if (string2ll((char*)val->estr,val->elen,&val->ell))
                 val->flags |= OPVAL_VALID_LL;
         } else {
             /* The long long was already set, flag as valid. */
@@ -1801,20 +1833,20 @@
     return val->ele;
 }
 
 int zuiBufferFromValue(zsetopval *val) {
     if (val->estr == NULL) {
         if (val->ele != NULL) {
-            if (val->ele->encoding == REDIS_ENCODING_INT) {
+            if (val->ele->encoding == OBJ_ENCODING_INT) {
                 val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),(long)val->ele->ptr);
                 val->estr = val->_buf;
             } else if (sdsEncodedObject(val->ele)) {
                 val->elen = sdslen(val->ele->ptr);
                 val->estr = val->ele->ptr;
             } else {
-                redisPanic("Unsupported element encoding");
+                serverPanic("Unsupported element encoding");
             }
         } else {
             val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),val->ell);
             val->estr = val->_buf;
         }
     }
@@ -1824,58 +1856,58 @@
 /* Find value pointed to by val in the source pointer to by op. When found,
  * return 1 and store its score in target. Return 0 otherwise. */
 int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
     if (op->subject == NULL)
         return 0;
 
-    if (op->type == REDIS_SET) {
-        if (op->encoding == REDIS_ENCODING_INTSET) {
+    if (op->type == OBJ_SET) {
+        if (op->encoding == OBJ_ENCODING_INTSET) {
             if (zuiLongLongFromValue(val) &&
                 intsetFind(op->subject->ptr,val->ell))
             {
                 *score = 1.0;
                 return 1;
             } else {
                 return 0;
             }
-        } else if (op->encoding == REDIS_ENCODING_HT) {
+        } else if (op->encoding == OBJ_ENCODING_HT) {
             dict *ht = op->subject->ptr;
             zuiObjectFromValue(val);
             if (dictFind(ht,val->ele) != NULL) {
                 *score = 1.0;
                 return 1;
             } else {
                 return 0;
             }
         } else {
-            redisPanic("Unknown set encoding");
+            serverPanic("Unknown set encoding");
         }
-    } else if (op->type == REDIS_ZSET) {
+    } else if (op->type == OBJ_ZSET) {
         zuiObjectFromValue(val);
 
-        if (op->encoding == REDIS_ENCODING_ZIPLIST) {
+        if (op->encoding == OBJ_ENCODING_ZIPLIST) {
             if (zzlFind(op->subject->ptr,val->ele,score) != NULL) {
                 /* Score is already set by zzlFind. */
                 return 1;
             } else {
                 return 0;
             }
-        } else if (op->encoding == REDIS_ENCODING_SKIPLIST) {
+        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
             zset *zs = op->subject->ptr;
             dictEntry *de;
             if ((de = dictFind(zs->dict,val->ele)) != NULL) {
                 *score = *(double*)dictGetVal(de);
                 return 1;
             } else {
                 return 0;
             }
         } else {
-            redisPanic("Unknown sorted set encoding");
+            serverPanic("Unknown sorted set encoding");
         }
     } else {
-        redisPanic("Unsupported type");
+        serverPanic("Unsupported type");
     }
 }
 
 int zuiCompareByCardinality(const void *s1, const void *s2) {
     return zuiLength((zsetopsrc*)s1) - zuiLength((zsetopsrc*)s2);
 }
@@ -1895,17 +1927,17 @@
     } else if (aggregate == REDIS_AGGR_MIN) {
         *target = val < *target ? val : *target;
     } else if (aggregate == REDIS_AGGR_MAX) {
         *target = val > *target ? val : *target;
     } else {
         /* safety net */
-        redisPanic("Unknown ZUNION/INTER aggregate type");
+        serverPanic("Unknown ZUNION/INTER aggregate type");
     }
 }
 
-void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {
+void zunionInterGenericCommand(client *c, robj *dstkey, int op) {
     int i, j;
     long setnum;
     int aggregate = REDIS_AGGR_SUM;
     zsetopsrc *src;
     zsetopval zval;
     robj *tmp;
@@ -1913,13 +1945,13 @@
     robj *dstobj;
     zset *dstzset;
     zskiplistNode *znode;
     int touched = 0;
 
     /* expect setnum input keys to be given */
-    if ((getLongFromObjectOrReply(c, c->argv[2], &setnum, NULL) != REDIS_OK))
+    if ((getLongFromObjectOrReply(c, c->argv[2], &setnum, NULL) != C_OK))
         return;
 
     if (setnum < 1) {
         addReplyError(c,
             "at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE");
         return;
@@ -1933,13 +1965,13 @@
 
     /* read keys to be used for input */
     src = zcalloc(sizeof(zsetopsrc) * setnum);
     for (i = 0, j = 3; i < setnum; i++, j++) {
         robj *obj = lookupKeyWrite(c->db,c->argv[j]);
         if (obj != NULL) {
-            if (obj->type != REDIS_ZSET && obj->type != REDIS_SET) {
+            if (obj->type != OBJ_ZSET && obj->type != OBJ_SET) {
                 zfree(src);
                 addReply(c,shared.wrongtypeerr);
                 return;
             }
 
             src[i].subject = obj;
@@ -1959,13 +1991,13 @@
 
         while (remaining) {
             if (remaining >= (setnum + 1) && !strcasecmp(c->argv[j]->ptr,"weights")) {
                 j++; remaining--;
                 for (i = 0; i < setnum; i++, j++, remaining--) {
                     if (getDoubleFromObjectOrReply(c,c->argv[j],&src[i].weight,
-                            "weight value is not a float") != REDIS_OK)
+                            "weight value is not a float") != C_OK)
                     {
                         zfree(src);
                         return;
                     }
                 }
             } else if (remaining >= 2 && !strcasecmp(c->argv[j]->ptr,"aggregate")) {
@@ -1995,13 +2027,13 @@
     qsort(src,setnum,sizeof(zsetopsrc),zuiCompareByCardinality);
 
     dstobj = createZsetObject();
     dstzset = dstobj->ptr;
     memset(&zval, 0, sizeof(zval));
 
-    if (op == REDIS_OP_INTER) {
+    if (op == SET_OP_INTER) {
         /* Skip everything if the smallest input is empty. */
         if (zuiLength(&src[0]) > 0) {
             /* Precondition: as src[0] is non-empty and the inputs are ordered
              * by size, all src[i > 0] are non-empty too. */
             zuiInitIterator(&src[0]);
             while (zuiNext(&src[0],&zval)) {
@@ -2037,13 +2069,13 @@
                             maxelelen = sdslen(tmp->ptr);
                     }
                 }
             }
             zuiClearIterator(&src[0]);
         }
-    } else if (op == REDIS_OP_UNION) {
+    } else if (op == SET_OP_UNION) {
         dict *accumulator = dictCreate(&setDictType,NULL);
         dictIterator *di;
         dictEntry *de;
         double score;
 
         if (setnum) {
@@ -2110,71 +2142,67 @@
         }
         dictReleaseIterator(di);
 
         /* We can free the accumulator dictionary now. */
         dictRelease(accumulator);
     } else {
-        redisPanic("Unknown operator");
+        serverPanic("Unknown operator");
     }
 
     if (dbDelete(c->db,dstkey)) {
         signalModifiedKey(c->db,dstkey);
         touched = 1;
         server.dirty++;
     }
     if (dstzset->zsl->length) {
-        /* Convert to ziplist when in limits. */
-        if (dstzset->zsl->length <= server.zset_max_ziplist_entries &&
-            maxelelen <= server.zset_max_ziplist_value)
-                zsetConvert(dstobj,REDIS_ENCODING_ZIPLIST);
-
+        zsetConvertToZiplistIfNeeded(dstobj,maxelelen);
         dbAdd(c->db,dstkey,dstobj);
         addReplyLongLong(c,zsetLength(dstobj));
         if (!touched) signalModifiedKey(c->db,dstkey);
-        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,
-            (op == REDIS_OP_UNION) ? "zunionstore" : "zinterstore",
+        notifyKeyspaceEvent(NOTIFY_ZSET,
+            (op == SET_OP_UNION) ? "zunionstore" : "zinterstore",
             dstkey,c->db->id);
         server.dirty++;
     } else {
         decrRefCount(dstobj);
         addReply(c,shared.czero);
         if (touched)
-            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",dstkey,c->db->id);
+            notifyKeyspaceEvent(NOTIFY_GENERIC,"del",dstkey,c->db->id);
     }
     zfree(src);
 }
 
-void zunionstoreCommand(redisClient *c) {
-    zunionInterGenericCommand(c,c->argv[1], REDIS_OP_UNION);
+void zunionstoreCommand(client *c) {
+    zunionInterGenericCommand(c,c->argv[1], SET_OP_UNION);
 }
 
-void zinterstoreCommand(redisClient *c) {
-    zunionInterGenericCommand(c,c->argv[1], REDIS_OP_INTER);
+void zinterstoreCommand(client *c) {
+    zunionInterGenericCommand(c,c->argv[1], SET_OP_INTER);
 }
 
-void zrangeGenericCommand(redisClient *c, int reverse) {
+void zrangeGenericCommand(client *c, int reverse) {
     robj *key = c->argv[1];
     robj *zobj;
     int withscores = 0;
     long start;
     long end;
     int llen;
     int rangelen;
 
-    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != REDIS_OK) ||
-        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != REDIS_OK)) return;
+    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
+        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;
 
     if (c->argc == 5 && !strcasecmp(c->argv[4]->ptr,"withscores")) {
         withscores = 1;
     } else if (c->argc >= 5) {
         addReply(c,shared.syntaxerr);
         return;
     }
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL
-         || checkType(c,zobj,REDIS_ZSET)) return;
+         || checkType(c,zobj,OBJ_ZSET)) return;
 
     /* Sanitize indexes. */
     llen = zsetLength(zobj);
     if (start < 0) start = llen+start;
     if (end < 0) end = llen+end;
     if (start < 0) start = 0;
@@ -2188,30 +2216,30 @@
     if (end >= llen) end = llen-1;
     rangelen = (end-start)+1;
 
     /* Return the result in form of a multi-bulk reply */
     addReplyMultiBulkLen(c, withscores ? (rangelen*2) : rangelen);
 
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
         unsigned char *vstr;
         unsigned int vlen;
         long long vlong;
 
         if (reverse)
             eptr = ziplistIndex(zl,-2-(2*start));
         else
             eptr = ziplistIndex(zl,2*start);
 
-        redisAssertWithInfo(c,zobj,eptr != NULL);
+        serverAssertWithInfo(c,zobj,eptr != NULL);
         sptr = ziplistNext(zl,eptr);
 
         while (rangelen--) {
-            redisAssertWithInfo(c,zobj,eptr != NULL && sptr != NULL);
-            redisAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
+            serverAssertWithInfo(c,zobj,eptr != NULL && sptr != NULL);
+            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
             if (vstr == NULL)
                 addReplyBulkLongLong(c,vlong);
             else
                 addReplyBulkCBuffer(c,vstr,vlen);
 
             if (withscores)
@@ -2220,13 +2248,13 @@
             if (reverse)
                 zzlPrev(zl,&eptr,&sptr);
             else
                 zzlNext(zl,&eptr,&sptr);
         }
 
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         zskiplist *zsl = zs->zsl;
         zskiplistNode *ln;
         robj *ele;
 
         /* Check if starting point is trivial, before doing log(N) lookup. */
@@ -2238,34 +2266,34 @@
             ln = zsl->header->level[0].forward;
             if (start > 0)
                 ln = zslGetElementByRank(zsl,start+1);
         }
 
         while(rangelen--) {
-            redisAssertWithInfo(c,zobj,ln != NULL);
+            serverAssertWithInfo(c,zobj,ln != NULL);
             ele = ln->obj;
             addReplyBulk(c,ele);
             if (withscores)
                 addReplyDouble(c,ln->score);
             ln = reverse ? ln->backward : ln->level[0].forward;
         }
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 }
 
-void zrangeCommand(redisClient *c) {
+void zrangeCommand(client *c) {
     zrangeGenericCommand(c,0);
 }
 
-void zrevrangeCommand(redisClient *c) {
+void zrevrangeCommand(client *c) {
     zrangeGenericCommand(c,1);
 }
 
 /* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */
-void genericZrangebyscoreCommand(redisClient *c, int reverse) {
+void genericZrangebyscoreCommand(client *c, int reverse) {
     zrangespec range;
     robj *key = c->argv[1];
     robj *zobj;
     long offset = 0, limit = -1;
     int withscores = 0;
     unsigned long rangelen = 0;
@@ -2278,13 +2306,13 @@
         maxidx = 2; minidx = 3;
     } else {
         /* Range is given as [min,max] */
         minidx = 2; maxidx = 3;
     }
 
-    if (zslParseRange(c->argv[minidx],c->argv[maxidx],&range) != REDIS_OK) {
+    if (zslParseRange(c->argv[minidx],c->argv[maxidx],&range) != C_OK) {
         addReplyError(c,"min or max is not a float");
         return;
     }
 
     /* Parse optional extra arguments. Note that ZCOUNT will exactly have
      * 4 arguments, so we'll never enter the following code path. */
@@ -2294,27 +2322,27 @@
 
         while (remaining) {
             if (remaining >= 1 && !strcasecmp(c->argv[pos]->ptr,"withscores")) {
                 pos++; remaining--;
                 withscores = 1;
             } else if (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,"limit")) {
-                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL) != REDIS_OK) ||
-                    (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL) != REDIS_OK)) return;
+                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL) != C_OK) ||
+                    (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL) != C_OK)) return;
                 pos += 3; remaining -= 3;
             } else {
                 addReply(c,shared.syntaxerr);
                 return;
             }
         }
     }
 
     /* Ok, lookup the key and get the range */
     if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
-        checkType(c,zobj,REDIS_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) return;
 
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
         unsigned char *vstr;
         unsigned int vlen;
         long long vlong;
         double score;
@@ -2330,13 +2358,13 @@
         if (eptr == NULL) {
             addReply(c, shared.emptymultibulk);
             return;
         }
 
         /* Get score pointer for the first element. */
-        redisAssertWithInfo(c,zobj,eptr != NULL);
+        serverAssertWithInfo(c,zobj,eptr != NULL);
         sptr = ziplistNext(zl,eptr);
 
         /* We don't know in advance how many matching elements there are in the
          * list, so we push this object that will represent the multi-bulk
          * length in the output buffer, and will "fix" it later */
         replylen = addDeferredMultiBulkLength(c);
@@ -2359,13 +2387,13 @@
                 if (!zslValueGteMin(score,&range)) break;
             } else {
                 if (!zslValueLteMax(score,&range)) break;
             }
 
             /* We know the element exists, so ziplistGet should always succeed */
-            redisAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
+            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
 
             rangelen++;
             if (vstr == NULL) {
                 addReplyBulkLongLong(c,vlong);
             } else {
                 addReplyBulkCBuffer(c,vstr,vlen);
@@ -2379,13 +2407,13 @@
             if (reverse) {
                 zzlPrev(zl,&eptr,&sptr);
             } else {
                 zzlNext(zl,&eptr,&sptr);
             }
         }
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         zskiplist *zsl = zs->zsl;
         zskiplistNode *ln;
 
         /* If reversed, get the last node in range as starting point. */
         if (reverse) {
@@ -2435,47 +2463,47 @@
                 ln = ln->backward;
             } else {
                 ln = ln->level[0].forward;
             }
         }
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 
     if (withscores) {
         rangelen *= 2;
     }
 
     setDeferredMultiBulkLength(c, replylen, rangelen);
 }
 
-void zrangebyscoreCommand(redisClient *c) {
+void zrangebyscoreCommand(client *c) {
     genericZrangebyscoreCommand(c,0);
 }
 
-void zrevrangebyscoreCommand(redisClient *c) {
+void zrevrangebyscoreCommand(client *c) {
     genericZrangebyscoreCommand(c,1);
 }
 
-void zcountCommand(redisClient *c) {
+void zcountCommand(client *c) {
     robj *key = c->argv[1];
     robj *zobj;
     zrangespec range;
     int count = 0;
 
     /* Parse the range arguments */
-    if (zslParseRange(c->argv[2],c->argv[3],&range) != REDIS_OK) {
+    if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
         addReplyError(c,"min or max is not a float");
         return;
     }
 
     /* Lookup the sorted set */
     if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
-        checkType(c, zobj, REDIS_ZSET)) return;
+        checkType(c, zobj, OBJ_ZSET)) return;
 
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
         double score;
 
         /* Use the first element in range as the starting point */
         eptr = zzlFirstInRange(zl,&range);
@@ -2486,13 +2514,13 @@
             return;
         }
 
         /* First element is in range */
         sptr = ziplistNext(zl,eptr);
         score = zzlGetScore(sptr);
-        redisAssertWithInfo(c,zobj,zslValueLteMax(score,&range));
+        serverAssertWithInfo(c,zobj,zslValueLteMax(score,&range));
 
         /* Iterate over elements in range */
         while (eptr) {
             score = zzlGetScore(sptr);
 
             /* Abort when the node is no longer in range. */
@@ -2500,13 +2528,13 @@
                 break;
             } else {
                 count++;
                 zzlNext(zl,&eptr,&sptr);
             }
         }
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         zskiplist *zsl = zs->zsl;
         zskiplistNode *zn;
         unsigned long rank;
 
         /* Find first element in range */
@@ -2524,39 +2552,39 @@
             if (zn != NULL) {
                 rank = zslGetRank(zsl, zn->score, zn->obj);
                 count -= (zsl->length - rank);
             }
         }
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 
     addReplyLongLong(c, count);
 }
 
-void zlexcountCommand(redisClient *c) {
+void zlexcountCommand(client *c) {
     robj *key = c->argv[1];
     robj *zobj;
     zlexrangespec range;
     int count = 0;
 
     /* Parse the range arguments */
-    if (zslParseLexRange(c->argv[2],c->argv[3],&range) != REDIS_OK) {
+    if (zslParseLexRange(c->argv[2],c->argv[3],&range) != C_OK) {
         addReplyError(c,"min or max not valid string range item");
         return;
     }
 
     /* Lookup the sorted set */
     if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
-        checkType(c, zobj, REDIS_ZSET))
+        checkType(c, zobj, OBJ_ZSET))
     {
         zslFreeLexRange(&range);
         return;
     }
 
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
 
         /* Use the first element in range as the starting point */
         eptr = zzlFirstInLexRange(zl,&range);
 
@@ -2566,25 +2594,25 @@
             addReply(c, shared.czero);
             return;
         }
 
         /* First element is in range */
         sptr = ziplistNext(zl,eptr);
-        redisAssertWithInfo(c,zobj,zzlLexValueLteMax(eptr,&range));
+        serverAssertWithInfo(c,zobj,zzlLexValueLteMax(eptr,&range));
 
         /* Iterate over elements in range */
         while (eptr) {
             /* Abort when the node is no longer in range. */
             if (!zzlLexValueLteMax(eptr,&range)) {
                 break;
             } else {
                 count++;
                 zzlNext(zl,&eptr,&sptr);
             }
         }
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         zskiplist *zsl = zs->zsl;
         zskiplistNode *zn;
         unsigned long rank;
 
         /* Find first element in range */
@@ -2602,21 +2630,21 @@
             if (zn != NULL) {
                 rank = zslGetRank(zsl, zn->score, zn->obj);
                 count -= (zsl->length - rank);
             }
         }
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 
     zslFreeLexRange(&range);
     addReplyLongLong(c, count);
 }
 
 /* This command implements ZRANGEBYLEX, ZREVRANGEBYLEX. */
-void genericZrangebylexCommand(redisClient *c, int reverse) {
+void genericZrangebylexCommand(client *c, int reverse) {
     zlexrangespec range;
     robj *key = c->argv[1];
     robj *zobj;
     long offset = 0, limit = -1;
     unsigned long rangelen = 0;
     void *replylen = NULL;
@@ -2628,45 +2656,45 @@
         maxidx = 2; minidx = 3;
     } else {
         /* Range is given as [min,max] */
         minidx = 2; maxidx = 3;
     }
 
-    if (zslParseLexRange(c->argv[minidx],c->argv[maxidx],&range) != REDIS_OK) {
+    if (zslParseLexRange(c->argv[minidx],c->argv[maxidx],&range) != C_OK) {
         addReplyError(c,"min or max not valid string range item");
         return;
     }
 
     /* Parse optional extra arguments. Note that ZCOUNT will exactly have
      * 4 arguments, so we'll never enter the following code path. */
     if (c->argc > 4) {
         int remaining = c->argc - 4;
         int pos = 4;
 
         while (remaining) {
             if (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,"limit")) {
-                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL) != REDIS_OK) ||
-                    (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL) != REDIS_OK)) return;
+                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL) != C_OK) ||
+                    (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL) != C_OK)) return;
                 pos += 3; remaining -= 3;
             } else {
                 zslFreeLexRange(&range);
                 addReply(c,shared.syntaxerr);
                 return;
             }
         }
     }
 
     /* Ok, lookup the key and get the range */
     if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||
-        checkType(c,zobj,REDIS_ZSET))
+        checkType(c,zobj,OBJ_ZSET))
     {
         zslFreeLexRange(&range);
         return;
     }
 
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
         unsigned char *vstr;
         unsigned int vlen;
         long long vlong;
 
@@ -2682,13 +2710,13 @@
             addReply(c, shared.emptymultibulk);
             zslFreeLexRange(&range);
             return;
         }
 
         /* Get score pointer for the first element. */
-        redisAssertWithInfo(c,zobj,eptr != NULL);
+        serverAssertWithInfo(c,zobj,eptr != NULL);
         sptr = ziplistNext(zl,eptr);
 
         /* We don't know in advance how many matching elements there are in the
          * list, so we push this object that will represent the multi-bulk
          * length in the output buffer, and will "fix" it later */
         replylen = addDeferredMultiBulkLength(c);
@@ -2710,13 +2738,13 @@
             } else {
                 if (!zzlLexValueLteMax(eptr,&range)) break;
             }
 
             /* We know the element exists, so ziplistGet should always
              * succeed. */
-            redisAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
+            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
 
             rangelen++;
             if (vstr == NULL) {
                 addReplyBulkLongLong(c,vlong);
             } else {
                 addReplyBulkCBuffer(c,vstr,vlen);
@@ -2726,13 +2754,13 @@
             if (reverse) {
                 zzlPrev(zl,&eptr,&sptr);
             } else {
                 zzlNext(zl,&eptr,&sptr);
             }
         }
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         zskiplist *zsl = zs->zsl;
         zskiplistNode *ln;
 
         /* If reversed, get the last node in range as starting point. */
         if (reverse) {
@@ -2779,88 +2807,73 @@
                 ln = ln->backward;
             } else {
                 ln = ln->level[0].forward;
             }
         }
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 
     zslFreeLexRange(&range);
     setDeferredMultiBulkLength(c, replylen, rangelen);
 }
 
-void zrangebylexCommand(redisClient *c) {
+void zrangebylexCommand(client *c) {
     genericZrangebylexCommand(c,0);
 }
 
-void zrevrangebylexCommand(redisClient *c) {
+void zrevrangebylexCommand(client *c) {
     genericZrangebylexCommand(c,1);
 }
 
-void zcardCommand(redisClient *c) {
+void zcardCommand(client *c) {
     robj *key = c->argv[1];
     robj *zobj;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
-        checkType(c,zobj,REDIS_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) return;
 
     addReplyLongLong(c,zsetLength(zobj));
 }
 
-void zscoreCommand(redisClient *c) {
+void zscoreCommand(client *c) {
     robj *key = c->argv[1];
     robj *zobj;
     double score;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
-        checkType(c,zobj,REDIS_ZSET)) return;
-
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
-        if (zzlFind(zobj->ptr,c->argv[2],&score) != NULL)
-            addReplyDouble(c,score);
-        else
-            addReply(c,shared.nullbulk);
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
-        zset *zs = zobj->ptr;
-        dictEntry *de;
+        checkType(c,zobj,OBJ_ZSET)) return;
 
-        c->argv[2] = tryObjectEncoding(c->argv[2]);
-        de = dictFind(zs->dict,c->argv[2]);
-        if (de != NULL) {
-            score = *(double*)dictGetVal(de);
-            addReplyDouble(c,score);
-        } else {
-            addReply(c,shared.nullbulk);
-        }
+    if (zsetScore(zobj,c->argv[2],&score) == C_ERR) {
+        addReply(c,shared.nullbulk);
     } else {
-        redisPanic("Unknown sorted set encoding");
+        addReplyDouble(c,score);
     }
 }
 
-void zrankGenericCommand(redisClient *c, int reverse) {
+void zrankGenericCommand(client *c, int reverse) {
     robj *key = c->argv[1];
     robj *ele = c->argv[2];
     robj *zobj;
     unsigned long llen;
     unsigned long rank;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
-        checkType(c,zobj,REDIS_ZSET)) return;
+        checkType(c,zobj,OBJ_ZSET)) return;
     llen = zsetLength(zobj);
 
-    redisAssertWithInfo(c,ele,sdsEncodedObject(ele));
+    serverAssertWithInfo(c,ele,sdsEncodedObject(ele));
 
-    if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
 
         eptr = ziplistIndex(zl,0);
-        redisAssertWithInfo(c,zobj,eptr != NULL);
+        serverAssertWithInfo(c,zobj,eptr != NULL);
         sptr = ziplistNext(zl,eptr);
-        redisAssertWithInfo(c,zobj,sptr != NULL);
+        serverAssertWithInfo(c,zobj,sptr != NULL);
 
         rank = 1;
         while(eptr != NULL) {
             if (ziplistCompare(eptr,ele->ptr,sdslen(ele->ptr)))
                 break;
             rank++;
@@ -2872,47 +2885,47 @@
                 addReplyLongLong(c,llen-rank);
             else
                 addReplyLongLong(c,rank-1);
         } else {
             addReply(c,shared.nullbulk);
         }
-    } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         zskiplist *zsl = zs->zsl;
         dictEntry *de;
         double score;
 
-        ele = c->argv[2] = tryObjectEncoding(c->argv[2]);
+        ele = c->argv[2];
         de = dictFind(zs->dict,ele);
         if (de != NULL) {
             score = *(double*)dictGetVal(de);
             rank = zslGetRank(zsl,score,ele);
-            redisAssertWithInfo(c,ele,rank); /* Existing elements always have a rank. */
+            serverAssertWithInfo(c,ele,rank); /* Existing elements always have a rank. */
             if (reverse)
                 addReplyLongLong(c,llen-rank);
             else
                 addReplyLongLong(c,rank-1);
         } else {
             addReply(c,shared.nullbulk);
         }
     } else {
-        redisPanic("Unknown sorted set encoding");
+        serverPanic("Unknown sorted set encoding");
     }
 }
 
-void zrankCommand(redisClient *c) {
+void zrankCommand(client *c) {
     zrankGenericCommand(c, 0);
 }
 
-void zrevrankCommand(redisClient *c) {
+void zrevrankCommand(client *c) {
     zrankGenericCommand(c, 1);
 }
 
-void zscanCommand(redisClient *c) {
+void zscanCommand(client *c) {
     robj *o;
     unsigned long cursor;
 
-    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == REDIS_ERR) return;
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
-        checkType(c,o,REDIS_ZSET)) return;
+        checkType(c,o,OBJ_ZSET)) return;
     scanGenericCommand(c,o,cursor);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_zset.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_zset.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/t_zset.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/t_zset.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.c	2016-05-06 15:11:36.000000000 +0800
@@ -248,12 +248,24 @@
         }
         return 11 + (v >= 100000000000UL);
     }
     return 12 + digits10(v / 1000000000000UL);
 }
 
+/* Like digits10() but for signed values. */
+uint32_t sdigits10(int64_t v) {
+    if (v < 0) {
+        /* Abs value of LLONG_MIN requires special handling. */
+        uint64_t uv = (v != LLONG_MIN) ?
+                      (uint64_t)-v : ((uint64_t) LLONG_MAX)+1;
+        return digits10(uv)+1; /* +1 for the minus. */
+    } else {
+        return digits10(v);
+    }
+}
+
 /* Convert a long long into a string. Returns the number of
  * characters needed to represent the number.
  * If the buffer is not big enough to store the string, 0 is returned.
  *
  * Based on the following article (that apparently does not provide a
  * novel approach but only publicizes an already used technique):
@@ -571,16 +583,16 @@
  * character exists inside the specified path, that's enough in the
  * environments where Redis runs. */
 int pathIsBaseName(char *path) {
     return strchr(path,'/') == NULL && strchr(path,'\\') == NULL;
 }
 
-#ifdef UTIL_TEST_MAIN
+#ifdef REDIS_TEST
 #include <assert.h>
 
-void test_string2ll(void) {
+static void test_string2ll(void) {
     char buf[32];
     long long v;
 
     /* May not start with +. */
     strcpy(buf,"+1");
     assert(string2ll(buf,strlen(buf),&v) == 0);
@@ -629,13 +641,13 @@
     assert(v == LLONG_MAX);
 
     strcpy(buf,"9223372036854775808"); /* overflow */
     assert(string2ll(buf,strlen(buf),&v) == 0);
 }
 
-void test_string2l(void) {
+static void test_string2l(void) {
     char buf[32];
     long v;
 
     /* May not start with +. */
     strcpy(buf,"+1");
     assert(string2l(buf,strlen(buf),&v) == 0);
@@ -678,12 +690,58 @@
 
     strcpy(buf,"2147483648"); /* overflow */
     assert(string2l(buf,strlen(buf),&v) == 0);
 #endif
 }
 
-int main(int argc, char **argv) {
+static void test_ll2string(void) {
+    char buf[32];
+    long long v;
+    int sz;
+
+    v = 0;
+    sz = ll2string(buf, sizeof buf, v);
+    assert(sz == 1);
+    assert(!strcmp(buf, "0"));
+
+    v = -1;
+    sz = ll2string(buf, sizeof buf, v);
+    assert(sz == 2);
+    assert(!strcmp(buf, "-1"));
+
+    v = 99;
+    sz = ll2string(buf, sizeof buf, v);
+    assert(sz == 2);
+    assert(!strcmp(buf, "99"));
+
+    v = -99;
+    sz = ll2string(buf, sizeof buf, v);
+    assert(sz == 3);
+    assert(!strcmp(buf, "-99"));
+
+    v = -2147483648;
+    sz = ll2string(buf, sizeof buf, v);
+    assert(sz == 11);
+    assert(!strcmp(buf, "-2147483648"));
+
+    v = LLONG_MIN;
+    sz = ll2string(buf, sizeof buf, v);
+    assert(sz == 20);
+    assert(!strcmp(buf, "-9223372036854775808"));
+
+    v = LLONG_MAX;
+    sz = ll2string(buf, sizeof buf, v);
+    assert(sz == 19);
+    assert(!strcmp(buf, "9223372036854775807"));
+}
+
+#define UNUSED(x) (void)(x)
+int utilTest(int argc, char **argv) {
+    UNUSED(argc);
+    UNUSED(argv);
+
     test_string2ll();
     test_string2l();
+    test_ll2string();
     return 0;
 }
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.h	2016-05-06 15:11:36.000000000 +0800
@@ -27,19 +27,26 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __REDIS_UTIL_H
 #define __REDIS_UTIL_H
 
+#include <stdint.h>
 #include "sds.h"
 
 int stringmatchlen(const char *p, int plen, const char *s, int slen, int nocase);
 int stringmatch(const char *p, const char *s, int nocase);
 long long memtoll(const char *p, int *err);
+uint32_t digits10(uint64_t v);
+uint32_t sdigits10(int64_t v);
 int ll2string(char *s, size_t len, long long value);
 int string2ll(const char *s, size_t slen, long long *value);
 int string2l(const char *s, size_t slen, long *value);
 int d2string(char *buf, size_t len, double value);
 sds getAbsolutePath(char *filename);
 int pathIsBaseName(char *path);
 
+#ifdef REDIS_TEST
+int utilTest(int argc, char **argv);
+#endif
+
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/util.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/util.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/version.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/version.h	2016-05-06 15:11:36.000000000 +0800
@@ -1 +1 @@
-#define REDIS_VERSION "3.0.7"
+#define REDIS_VERSION "3.2.0"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.c	2016-05-06 15:11:36.000000000 +0800
@@ -140,12 +140,13 @@
 
 /* Utility macros */
 #define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
 #define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
 #define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
 #define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
+#define ZIPLIST_END_SIZE        (sizeof(uint8_t))
 #define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)
 #define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
 #define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
 
 /* We know a positive increment can only be 1 because entries can only be
  * pushed one at a time. */
@@ -159,19 +160,28 @@
     unsigned int lensize, len;
     unsigned int headersize;
     unsigned char encoding;
     unsigned char *p;
 } zlentry;
 
+#define ZIPLIST_ENTRY_ZERO(zle) { \
+    (zle)->prevrawlensize = (zle)->prevrawlen = 0; \
+    (zle)->lensize = (zle)->len = (zle)->headersize = 0; \
+    (zle)->encoding = 0; \
+    (zle)->p = NULL; \
+}
+
 /* Extract the encoding from the byte pointed by 'ptr' and set it into
  * 'encoding'. */
 #define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
     (encoding) = (ptr[0]); \
     if ((encoding) < ZIP_STR_MASK) (encoding) &= ZIP_STR_MASK; \
 } while(0)
 
+void ziplistRepr(unsigned char *zl);
+
 /* Return bytes needed to store integer encoded by 'encoding' */
 static unsigned int zipIntSize(unsigned char encoding) {
     switch(encoding) {
     case ZIP_INT_8B:  return 1;
     case ZIP_INT_16B: return 2;
     case ZIP_INT_24B: return 3;
@@ -401,20 +411,18 @@
         assert(NULL);
     }
     return ret;
 }
 
 /* Return a struct with all information about an entry. */
-static zlentry zipEntry(unsigned char *p) {
-    zlentry e;
+static void zipEntry(unsigned char *p, zlentry *e) {
 
-    ZIP_DECODE_PREVLEN(p, e.prevrawlensize, e.prevrawlen);
-    ZIP_DECODE_LENGTH(p + e.prevrawlensize, e.encoding, e.lensize, e.len);
-    e.headersize = e.prevrawlensize + e.lensize;
-    e.p = p;
-    return e;
+    ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
+    ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
+    e->headersize = e->prevrawlensize + e->lensize;
+    e->p = p;
 }
 
 /* Create a new empty ziplist. */
 unsigned char *ziplistNew(void) {
     unsigned int bytes = ZIPLIST_HEADER_SIZE+1;
     unsigned char *zl = zmalloc(bytes);
@@ -457,19 +465,19 @@
     size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
     size_t offset, noffset, extra;
     unsigned char *np;
     zlentry cur, next;
 
     while (p[0] != ZIP_END) {
-        cur = zipEntry(p);
+        zipEntry(p, &cur);
         rawlen = cur.headersize + cur.len;
         rawlensize = zipPrevEncodeLength(NULL,rawlen);
 
         /* Abort if there is no next entry. */
         if (p[rawlen] == ZIP_END) break;
-        next = zipEntry(p+rawlen);
+        zipEntry(p+rawlen, &next);
 
         /* Abort when "prevlen" has not changed. */
         if (next.prevrawlen == rawlen) break;
 
         if (next.prevrawlensize < rawlensize) {
             /* The "prevlen" field of "next" needs more bytes to hold
@@ -518,13 +526,13 @@
 static unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
     unsigned int i, totlen, deleted = 0;
     size_t offset;
     int nextdiff = 0;
     zlentry first, tail;
 
-    first = zipEntry(p);
+    zipEntry(p, &first);
     for (i = 0; p[0] != ZIP_END && i < num; i++) {
         p += zipRawEntryLength(p);
         deleted++;
     }
 
     totlen = p-first.p;
@@ -542,13 +550,13 @@
             ZIPLIST_TAIL_OFFSET(zl) =
                 intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);
 
             /* When the tail contains more than one entry, we need to take
              * "nextdiff" in account as well. Otherwise, a change in the
              * size of prevlen doesn't have an effect on the *tail* offset. */
-            tail = zipEntry(p);
+            zipEntry(p, &tail);
             if (p[tail.headersize+tail.len] != ZIP_END) {
                 ZIPLIST_TAIL_OFFSET(zl) =
                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
             }
 
             /* Move tail to the front of the ziplist */
@@ -632,13 +640,13 @@
         ZIPLIST_TAIL_OFFSET(zl) =
             intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);
 
         /* When the tail contains more than one entry, we need to take
          * "nextdiff" in account as well. Otherwise, a change in the
          * size of prevlen doesn't have an effect on the *tail* offset. */
-        tail = zipEntry(p+reqlen);
+        zipEntry(p+reqlen, &tail);
         if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
             ZIPLIST_TAIL_OFFSET(zl) =
                 intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
         }
     } else {
         /* This element will be the new tail. */
@@ -662,12 +670,127 @@
         zipSaveInteger(p,value,encoding);
     }
     ZIPLIST_INCR_LENGTH(zl,1);
     return zl;
 }
 
+/* Merge ziplists 'first' and 'second' by appending 'second' to 'first'.
+ *
+ * NOTE: The larger ziplist is reallocated to contain the new merged ziplist.
+ * Either 'first' or 'second' can be used for the result.  The parameter not
+ * used will be free'd and set to NULL.
+ *
+ * After calling this function, the input parameters are no longer valid since
+ * they are changed and free'd in-place.
+ *
+ * The result ziplist is the contents of 'first' followed by 'second'.
+ *
+ * On failure: returns NULL if the merge is impossible.
+ * On success: returns the merged ziplist (which is expanded version of either
+ * 'first' or 'second', also frees the other unused input ziplist, and sets the
+ * input ziplist argument equal to newly reallocated ziplist return value. */
+unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {
+    /* If any params are null, we can't merge, so NULL. */
+    if (first == NULL || *first == NULL || second == NULL || *second == NULL)
+        return NULL;
+
+    /* Can't merge same list into itself. */
+    if (*first == *second)
+        return NULL;
+
+    size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
+    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));
+
+    size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
+    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));
+
+    int append;
+    unsigned char *source, *target;
+    size_t target_bytes, source_bytes;
+    /* Pick the largest ziplist so we can resize easily in-place.
+     * We must also track if we are now appending or prepending to
+     * the target ziplist. */
+    if (first_len >= second_len) {
+        /* retain first, append second to first. */
+        target = *first;
+        target_bytes = first_bytes;
+        source = *second;
+        source_bytes = second_bytes;
+        append = 1;
+    } else {
+        /* else, retain second, prepend first to second. */
+        target = *second;
+        target_bytes = second_bytes;
+        source = *first;
+        source_bytes = first_bytes;
+        append = 0;
+    }
+
+    /* Calculate final bytes (subtract one pair of metadata) */
+    size_t zlbytes = first_bytes + second_bytes -
+                     ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;
+    size_t zllength = first_len + second_len;
+
+    /* Combined zl length should be limited within UINT16_MAX */
+    zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;
+
+    /* Save offset positions before we start ripping memory apart. */
+    size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));
+    size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));
+
+    /* Extend target to new zlbytes then append or prepend source. */
+    target = zrealloc(target, zlbytes);
+    if (append) {
+        /* append == appending to target */
+        /* Copy source after target (copying over original [END]):
+         *   [TARGET - END, SOURCE - HEADER] */
+        memcpy(target + target_bytes - ZIPLIST_END_SIZE,
+               source + ZIPLIST_HEADER_SIZE,
+               source_bytes - ZIPLIST_HEADER_SIZE);
+    } else {
+        /* !append == prepending to target */
+        /* Move target *contents* exactly size of (source - [END]),
+         * then copy source into vacataed space (source - [END]):
+         *   [SOURCE - END, TARGET - HEADER] */
+        memmove(target + source_bytes - ZIPLIST_END_SIZE,
+                target + ZIPLIST_HEADER_SIZE,
+                target_bytes - ZIPLIST_HEADER_SIZE);
+        memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);
+    }
+
+    /* Update header metadata. */
+    ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);
+    ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);
+    /* New tail offset is:
+     *   + N bytes of first ziplist
+     *   - 1 byte for [END] of first ziplist
+     *   + M bytes for the offset of the original tail of the second ziplist
+     *   - J bytes for HEADER because second_offset keeps no header. */
+    ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(
+                                   (first_bytes - ZIPLIST_END_SIZE) +
+                                   (second_offset - ZIPLIST_HEADER_SIZE));
+
+    /* __ziplistCascadeUpdate just fixes the prev length values until it finds a
+     * correct prev length value (then it assumes the rest of the list is okay).
+     * We tell CascadeUpdate to start at the first ziplist's tail element to fix
+     * the merge seam. */
+    target = __ziplistCascadeUpdate(target, target+first_offset);
+
+    /* Now free and NULL out what we didn't realloc */
+    if (append) {
+        zfree(*second);
+        *second = NULL;
+        *first = target;
+    } else {
+        zfree(*first);
+        *first = NULL;
+        *second = target;
+    }
+    return target;
+}
+
 unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
     unsigned char *p;
     p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
     return __ziplistInsert(zl,p,s,slen);
 }
 
@@ -745,13 +868,13 @@
  * Return 0 if 'p' points to the end of the ziplist, 1 otherwise. */
 unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {
     zlentry entry;
     if (p == NULL || p[0] == ZIP_END) return 0;
     if (sstr) *sstr = NULL;
 
-    entry = zipEntry(p);
+    zipEntry(p, &entry);
     if (ZIP_IS_STR(entry.encoding)) {
         if (sstr) {
             *slen = entry.len;
             *sstr = p+entry.headersize;
         }
     } else {
@@ -780,26 +903,26 @@
      * entry and end up with "p" pointing to ZIP_END, so check this. */
     *p = zl+offset;
     return zl;
 }
 
 /* Delete a range of entries from the ziplist. */
-unsigned char *ziplistDeleteRange(unsigned char *zl, unsigned int index, unsigned int num) {
+unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {
     unsigned char *p = ziplistIndex(zl,index);
     return (p == NULL) ? zl : __ziplistDelete(zl,p,num);
 }
 
 /* Compare entry pointer to by 'p' with 'sstr' of length 'slen'. */
 /* Return 1 if equal. */
 unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {
     zlentry entry;
     unsigned char sencoding;
     long long zval, sval;
     if (p[0] == ZIP_END) return 0;
 
-    entry = zipEntry(p);
+    zipEntry(p, &entry);
     if (ZIP_IS_STR(entry.encoding)) {
         /* Raw compare */
         if (entry.len == slen) {
             return memcmp(p+entry.headersize,sstr,slen) == 0;
         } else {
             return 0;
@@ -910,13 +1033,13 @@
         "{tail offset %u}\n",
         intrev32ifbe(ZIPLIST_BYTES(zl)),
         intrev16ifbe(ZIPLIST_LENGTH(zl)),
         intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
     p = ZIPLIST_ENTRY_HEAD(zl);
     while(*p != ZIP_END) {
-        entry = zipEntry(p);
+        zipEntry(p, &entry);
         printf(
             "{"
                 "addr 0x%08lx, "
                 "index %2d, "
                 "offset %5ld, "
                 "rl: %5u, "
@@ -949,29 +1072,29 @@
         p += entry.len;
         index++;
     }
     printf("{end}\n\n");
 }
 
-#ifdef ZIPLIST_TEST_MAIN
+#ifdef REDIS_TEST
 #include <sys/time.h>
 #include "adlist.h"
 #include "sds.h"
 
 #define debug(f, ...) { if (DEBUG) printf(f, __VA_ARGS__); }
 
-unsigned char *createList() {
+static unsigned char *createList() {
     unsigned char *zl = ziplistNew();
     zl = ziplistPush(zl, (unsigned char*)"foo", 3, ZIPLIST_TAIL);
     zl = ziplistPush(zl, (unsigned char*)"quux", 4, ZIPLIST_TAIL);
     zl = ziplistPush(zl, (unsigned char*)"hello", 5, ZIPLIST_HEAD);
     zl = ziplistPush(zl, (unsigned char*)"1024", 4, ZIPLIST_TAIL);
     return zl;
 }
 
-unsigned char *createIntList() {
+static unsigned char *createIntList() {
     unsigned char *zl = ziplistNew();
     char buf[32];
 
     sprintf(buf, "100");
     zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
     sprintf(buf, "128000");
@@ -984,19 +1107,19 @@
     zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
     sprintf(buf, "much much longer non integer");
     zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
     return zl;
 }
 
-long long usec(void) {
+static long long usec(void) {
     struct timeval tv;
     gettimeofday(&tv,NULL);
     return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
 }
 
-void stress(int pos, int num, int maxsize, int dnum) {
+static void stress(int pos, int num, int maxsize, int dnum) {
     int i,j,k;
     unsigned char *zl;
     char posstr[2][5] = { "HEAD", "TAIL" };
     long long start;
     for (i = 0; i < maxsize; i+=dnum) {
         zl = ziplistNew();
@@ -1013,38 +1136,40 @@
         printf("List size: %8d, bytes: %8d, %dx push+pop (%s): %6lld usec\n",
             i,intrev32ifbe(ZIPLIST_BYTES(zl)),num,posstr[pos],usec()-start);
         zfree(zl);
     }
 }
 
-void pop(unsigned char *zl, int where) {
+static unsigned char *pop(unsigned char *zl, int where) {
     unsigned char *p, *vstr;
     unsigned int vlen;
     long long vlong;
 
     p = ziplistIndex(zl,where == ZIPLIST_HEAD ? 0 : -1);
     if (ziplistGet(p,&vstr,&vlen,&vlong)) {
         if (where == ZIPLIST_HEAD)
             printf("Pop head: ");
         else
             printf("Pop tail: ");
 
-        if (vstr)
+        if (vstr) {
             if (vlen && fwrite(vstr,vlen,1,stdout) == 0) perror("fwrite");
-        else
+        }
+        else {
             printf("%lld", vlong);
+        }
 
         printf("\n");
-        ziplistDeleteRange(zl,-1,1);
+        return ziplistDelete(zl,&p);
     } else {
         printf("ERROR: Could not pop\n");
         exit(1);
     }
 }
 
-int randstring(char *target, unsigned int min, unsigned int max) {
+static int randstring(char *target, unsigned int min, unsigned int max) {
     int p = 0;
     int len = min+rand()%(max-min+1);
     int minval, maxval;
     switch(rand() % 3) {
     case 0:
         minval = 0;
@@ -1064,56 +1189,61 @@
 
     while(p < len)
         target[p++] = minval+rand()%(maxval-minval+1);
     return len;
 }
 
-void verify(unsigned char *zl, zlentry *e) {
-    int i;
+static void verify(unsigned char *zl, zlentry *e) {
     int len = ziplistLen(zl);
     zlentry _e;
 
-    for (i = 0; i < len; i++) {
+    ZIPLIST_ENTRY_ZERO(&_e);
+
+    for (int i = 0; i < len; i++) {
         memset(&e[i], 0, sizeof(zlentry));
-        e[i] = zipEntry(ziplistIndex(zl, i));
+        zipEntry(ziplistIndex(zl, i), &e[i]);
 
         memset(&_e, 0, sizeof(zlentry));
-        _e = zipEntry(ziplistIndex(zl, -len+i));
+        zipEntry(ziplistIndex(zl, -len+i), &_e);
 
         assert(memcmp(&e[i], &_e, sizeof(zlentry)) == 0);
     }
 }
 
-int main(int argc, char **argv) {
+int ziplistTest(int argc, char **argv) {
     unsigned char *zl, *p;
     unsigned char *entry;
     unsigned int elen;
     long long value;
 
     /* If an argument is given, use it as the random seed. */
     if (argc == 2)
         srand(atoi(argv[1]));
 
     zl = createIntList();
     ziplistRepr(zl);
 
+    zfree(zl);
+
     zl = createList();
     ziplistRepr(zl);
 
-    pop(zl,ZIPLIST_TAIL);
+    zl = pop(zl,ZIPLIST_TAIL);
     ziplistRepr(zl);
 
-    pop(zl,ZIPLIST_HEAD);
+    zl = pop(zl,ZIPLIST_HEAD);
     ziplistRepr(zl);
 
-    pop(zl,ZIPLIST_TAIL);
+    zl = pop(zl,ZIPLIST_TAIL);
     ziplistRepr(zl);
 
-    pop(zl,ZIPLIST_TAIL);
+    zl = pop(zl,ZIPLIST_TAIL);
     ziplistRepr(zl);
 
+    zfree(zl);
+
     printf("Get element at index 3:\n");
     {
         zl = createList();
         p = ziplistIndex(zl, 3);
         if (!ziplistGet(p, &entry, &elen, &value)) {
             printf("ERROR: Could not access index 3\n");
@@ -1123,12 +1253,13 @@
             if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
             printf("\n");
         } else {
             printf("%lld\n", value);
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Get element at index 4 (out of range):\n");
     {
         zl = createList();
         p = ziplistIndex(zl, 4);
@@ -1136,12 +1267,13 @@
             printf("No entry\n");
         } else {
             printf("ERROR: Out of range index should return NULL, returned offset: %ld\n", p-zl);
             return 1;
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Get element at index -1 (last element):\n");
     {
         zl = createList();
         p = ziplistIndex(zl, -1);
@@ -1153,12 +1285,13 @@
             if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
             printf("\n");
         } else {
             printf("%lld\n", value);
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Get element at index -4 (first element):\n");
     {
         zl = createList();
         p = ziplistIndex(zl, -4);
@@ -1170,12 +1303,13 @@
             if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
             printf("\n");
         } else {
             printf("%lld\n", value);
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Get element at index -5 (reverse out of range):\n");
     {
         zl = createList();
         p = ziplistIndex(zl, -5);
@@ -1183,12 +1317,13 @@
             printf("No entry\n");
         } else {
             printf("ERROR: Out of range index should return NULL, returned offset: %ld\n", p-zl);
             return 1;
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Iterate list from 0 to end:\n");
     {
         zl = createList();
         p = ziplistIndex(zl, 0);
@@ -1200,12 +1335,13 @@
                 printf("%lld", value);
             }
             p = ziplistNext(zl,p);
             printf("\n");
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Iterate list from 1 to end:\n");
     {
         zl = createList();
         p = ziplistIndex(zl, 1);
@@ -1217,12 +1353,13 @@
                 printf("%lld", value);
             }
             p = ziplistNext(zl,p);
             printf("\n");
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Iterate list from 2 to end:\n");
     {
         zl = createList();
         p = ziplistIndex(zl, 2);
@@ -1234,24 +1371,26 @@
                 printf("%lld", value);
             }
             p = ziplistNext(zl,p);
             printf("\n");
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Iterate starting out of range:\n");
     {
         zl = createList();
         p = ziplistIndex(zl, 4);
         if (!ziplistGet(p, &entry, &elen, &value)) {
             printf("No entry\n");
         } else {
             printf("ERROR\n");
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Iterate from back to front:\n");
     {
         zl = createList();
         p = ziplistIndex(zl, -1);
@@ -1263,12 +1402,13 @@
                 printf("%lld", value);
             }
             p = ziplistPrev(zl,p);
             printf("\n");
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Iterate from back to front, deleting all items:\n");
     {
         zl = createList();
         p = ziplistIndex(zl, -1);
@@ -1281,47 +1421,53 @@
             }
             zl = ziplistDelete(zl,&p);
             p = ziplistPrev(zl,p);
             printf("\n");
         }
         printf("\n");
+        zfree(zl);
     }
 
     printf("Delete inclusive range 0,0:\n");
     {
         zl = createList();
         zl = ziplistDeleteRange(zl, 0, 1);
         ziplistRepr(zl);
+        zfree(zl);
     }
 
     printf("Delete inclusive range 0,1:\n");
     {
         zl = createList();
         zl = ziplistDeleteRange(zl, 0, 2);
         ziplistRepr(zl);
+        zfree(zl);
     }
 
     printf("Delete inclusive range 1,2:\n");
     {
         zl = createList();
         zl = ziplistDeleteRange(zl, 1, 2);
         ziplistRepr(zl);
+        zfree(zl);
     }
 
     printf("Delete with start index out of range:\n");
     {
         zl = createList();
         zl = ziplistDeleteRange(zl, 5, 1);
         ziplistRepr(zl);
+        zfree(zl);
     }
 
     printf("Delete with num overflow:\n");
     {
         zl = createList();
         zl = ziplistDeleteRange(zl, 1, 5);
         ziplistRepr(zl);
+        zfree(zl);
     }
 
     printf("Delete foo while iterating:\n");
     {
         zl = createList();
         p = ziplistIndex(zl,0);
@@ -1340,17 +1486,18 @@
                 p = ziplistNext(zl,p);
                 printf("\n");
             }
         }
         printf("\n");
         ziplistRepr(zl);
+        zfree(zl);
     }
 
     printf("Regression test for >255 byte strings:\n");
     {
-        char v1[257],v2[257];
+        char v1[257] = {0}, v2[257] = {0};
         memset(v1,'x',256);
         memset(v2,'y',256);
         zl = ziplistNew();
         zl = ziplistPush(zl,(unsigned char*)v1,strlen(v1),ZIPLIST_TAIL);
         zl = ziplistPush(zl,(unsigned char*)v2,strlen(v2),ZIPLIST_TAIL);
 
@@ -1359,19 +1506,21 @@
         assert(ziplistGet(p,&entry,&elen,&value));
         assert(strncmp(v1,(char*)entry,elen) == 0);
         p = ziplistIndex(zl,1);
         assert(ziplistGet(p,&entry,&elen,&value));
         assert(strncmp(v2,(char*)entry,elen) == 0);
         printf("SUCCESS\n\n");
+        zfree(zl);
     }
 
     printf("Regression test deleting next to last entries:\n");
     {
-        char v[3][257];
-        zlentry e[3];
-        int i;
+        char v[3][257] = {{0}};
+        zlentry e[3] = {{.prevrawlensize = 0, .prevrawlen = 0, .lensize = 0,
+                         .len = 0, .headersize = 0, .encoding = 0, .p = NULL}};
+        size_t i;
 
         for (i = 0; i < (sizeof(v)/sizeof(v[0])); i++) {
             memset(v[i], 'a' + i, sizeof(v[0]));
         }
 
         v[0][256] = '\0';
@@ -1396,12 +1545,13 @@
         verify(zl, e);
 
         assert(e[0].prevrawlensize == 1);
         assert(e[1].prevrawlensize == 5);
 
         printf("SUCCESS\n\n");
+        zfree(zl);
     }
 
     printf("Create long list and check indices:\n");
     {
         zl = ziplistNew();
         char buf[32];
@@ -1417,12 +1567,13 @@
 
             p = ziplistIndex(zl,-i-1);
             assert(ziplistGet(p,NULL,NULL,&value));
             assert(999-i == value);
         }
         printf("SUCCESS\n\n");
+        zfree(zl);
     }
 
     printf("Compare strings with ziplist entries:\n");
     {
         zl = createList();
         p = ziplistIndex(zl,0);
@@ -1442,12 +1593,88 @@
         }
         if (ziplistCompare(p,(unsigned char*)"1025",4)) {
             printf("ERROR: \"1025\"\n");
             return 1;
         }
         printf("SUCCESS\n\n");
+        zfree(zl);
+    }
+
+    printf("Merge test:\n");
+    {
+        /* create list gives us: [hello, foo, quux, 1024] */
+        zl = createList();
+        unsigned char *zl2 = createList();
+
+        unsigned char *zl3 = ziplistNew();
+        unsigned char *zl4 = ziplistNew();
+
+        if (ziplistMerge(&zl4, &zl4)) {
+            printf("ERROR: Allowed merging of one ziplist into itself.\n");
+            return 1;
+        }
+
+        /* Merge two empty ziplists, get empty result back. */
+        zl4 = ziplistMerge(&zl3, &zl4);
+        ziplistRepr(zl4);
+        if (ziplistLen(zl4)) {
+            printf("ERROR: Merging two empty ziplists created entries.\n");
+            return 1;
+        }
+        zfree(zl4);
+
+        zl2 = ziplistMerge(&zl, &zl2);
+        /* merge gives us: [hello, foo, quux, 1024, hello, foo, quux, 1024] */
+        ziplistRepr(zl2);
+
+        if (ziplistLen(zl2) != 8) {
+            printf("ERROR: Merged length not 8, but: %u\n", ziplistLen(zl2));
+            return 1;
+        }
+
+        p = ziplistIndex(zl2,0);
+        if (!ziplistCompare(p,(unsigned char*)"hello",5)) {
+            printf("ERROR: not \"hello\"\n");
+            return 1;
+        }
+        if (ziplistCompare(p,(unsigned char*)"hella",5)) {
+            printf("ERROR: \"hella\"\n");
+            return 1;
+        }
+
+        p = ziplistIndex(zl2,3);
+        if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
+            printf("ERROR: not \"1024\"\n");
+            return 1;
+        }
+        if (ziplistCompare(p,(unsigned char*)"1025",4)) {
+            printf("ERROR: \"1025\"\n");
+            return 1;
+        }
+
+        p = ziplistIndex(zl2,4);
+        if (!ziplistCompare(p,(unsigned char*)"hello",5)) {
+            printf("ERROR: not \"hello\"\n");
+            return 1;
+        }
+        if (ziplistCompare(p,(unsigned char*)"hella",5)) {
+            printf("ERROR: \"hella\"\n");
+            return 1;
+        }
+
+        p = ziplistIndex(zl2,7);
+        if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
+            printf("ERROR: not \"1024\"\n");
+            return 1;
+        }
+        if (ziplistCompare(p,(unsigned char*)"1025",4)) {
+            printf("ERROR: \"1025\"\n");
+            return 1;
+        }
+        printf("SUCCESS\n\n");
+        zfree(zl);
     }
 
     printf("Stress with random payloads of different encoding:\n");
     {
         int i,j,len,where;
         unsigned char *p;
@@ -1461,13 +1688,13 @@
         unsigned int slen;
         long long sval;
 
         for (i = 0; i < 20000; i++) {
             zl = ziplistNew();
             ref = listCreate();
-            listSetFreeMethod(ref,sdsfree);
+            listSetFreeMethod(ref,(void (*)(void*))sdsfree);
             len = rand() % 256;
 
             /* Create lists */
             for (j = 0; j < len; j++) {
                 where = (rand() & 1) ? ZIPLIST_HEAD : ZIPLIST_TAIL;
                 if (rand() % 2) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.h	2016-05-06 15:11:36.000000000 +0800
@@ -25,22 +25,32 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#ifndef _ZIPLIST_H
+#define _ZIPLIST_H
+
 #define ZIPLIST_HEAD 0
 #define ZIPLIST_TAIL 1
 
 unsigned char *ziplistNew(void);
+unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);
 unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);
 unsigned char *ziplistIndex(unsigned char *zl, int index);
 unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);
 unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);
 unsigned int ziplistGet(unsigned char *p, unsigned char **sval, unsigned int *slen, long long *lval);
 unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);
 unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);
-unsigned char *ziplistDeleteRange(unsigned char *zl, unsigned int index, unsigned int num);
+unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num);
 unsigned int ziplistCompare(unsigned char *p, unsigned char *s, unsigned int slen);
 unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);
 unsigned int ziplistLen(unsigned char *zl);
 size_t ziplistBlobLen(unsigned char *zl);
+
+#ifdef REDIS_TEST
+int ziplistTest(int argc, char *argv[]);
+#endif
+
+#endif /* _ZIPLIST_H */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/ziplist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/ziplist.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.c	2016-05-06 15:11:36.000000000 +0800
@@ -367,14 +367,14 @@
 size_t zipmapBlobLen(unsigned char *zm) {
     unsigned int totlen;
     zipmapLookupRaw(zm,NULL,0,&totlen);
     return totlen;
 }
 
-#ifdef ZIPMAP_TEST_MAIN
-void zipmapRepr(unsigned char *p) {
+#ifdef REDIS_TEST
+static void zipmapRepr(unsigned char *p) {
     unsigned int l;
 
     printf("{status %u}",*p++);
     while(1) {
         if (p[0] == ZIPMAP_END) {
             printf("{end}");
@@ -401,15 +401,19 @@
             }
         }
     }
     printf("\n");
 }
 
-int main(void) {
+#define UNUSED(x) (void)(x)
+int zipmapTest(int argc, char *argv[]) {
     unsigned char *zm;
 
+    UNUSED(argc);
+    UNUSED(argv);
+
     zm = zipmapNew();
 
     zm = zipmapSet(zm,(unsigned char*) "name",4, (unsigned char*) "foo",3,NULL);
     zm = zipmapSet(zm,(unsigned char*) "surname",7, (unsigned char*) "foo",3,NULL);
     zm = zipmapSet(zm,(unsigned char*) "age",3, (unsigned char*) "foo",3,NULL);
     zipmapRepr(zm);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.h	2016-05-06 15:11:36.000000000 +0800
@@ -43,7 +43,11 @@
 int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen);
 int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen);
 unsigned int zipmapLen(unsigned char *zm);
 size_t zipmapBlobLen(unsigned char *zm);
 void zipmapRepr(unsigned char *p);
 
+#ifdef REDIS_TEST
+int zipmapTest(int argc, char *argv[]);
+#endif
+
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zipmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zipmap.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.c	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.c	2016-05-06 15:11:36.000000000 +0800
@@ -361,6 +361,63 @@
 }
 #endif
 
 size_t zmalloc_get_private_dirty(void) {
     return zmalloc_get_smap_bytes_by_field("Private_Dirty:");
 }
+
+/* Returns the size of physical memory (RAM) in bytes.
+ * It looks ugly, but this is the cleanest way to achive cross platform results.
+ * Cleaned up from:
+ *
+ * http://nadeausoftware.com/articles/2012/09/c_c_tip_how_get_physical_memory_size_system
+ *
+ * Note that this function:
+ * 1) Was released under the following CC attribution license:
+ *    http://creativecommons.org/licenses/by/3.0/deed.en_US.
+ * 2) Was originally implemented by David Robert Nadeau.
+ * 3) Was modified for Redis by Matt Stancliff.
+ * 4) This note exists in order to comply with the original license.
+ */
+size_t zmalloc_get_memory_size(void) {
+#if defined(__unix__) || defined(__unix) || defined(unix) || \
+    (defined(__APPLE__) && defined(__MACH__))
+#if defined(CTL_HW) && (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))
+    int mib[2];
+    mib[0] = CTL_HW;
+#if defined(HW_MEMSIZE)
+    mib[1] = HW_MEMSIZE;            /* OSX. --------------------- */
+#elif defined(HW_PHYSMEM64)
+    mib[1] = HW_PHYSMEM64;          /* NetBSD, OpenBSD. --------- */
+#endif
+    int64_t size = 0;               /* 64-bit */
+    size_t len = sizeof(size);
+    if (sysctl( mib, 2, &size, &len, NULL, 0) == 0)
+        return (size_t)size;
+    return 0L;          /* Failed? */
+
+#elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)
+    /* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */
+    return (size_t)sysconf(_SC_PHYS_PAGES) * (size_t)sysconf(_SC_PAGESIZE);
+
+#elif defined(CTL_HW) && (defined(HW_PHYSMEM) || defined(HW_REALMEM))
+    /* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */
+    int mib[2];
+    mib[0] = CTL_HW;
+#if defined(HW_REALMEM)
+    mib[1] = HW_REALMEM;        /* FreeBSD. ----------------- */
+#elif defined(HW_PYSMEM)
+    mib[1] = HW_PHYSMEM;        /* Others. ------------------ */
+#endif
+    unsigned int size = 0;      /* 32-bit */
+    size_t len = sizeof(size);
+    if (sysctl(mib, 2, &size, &len, NULL, 0) == 0)
+        return (size_t)size;
+    return 0L;          /* Failed? */
+#endif /* sysctl and sysconf variants */
+
+#else
+    return 0L;          /* Unknown OS. */
+#endif
+}
+
+
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.h	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.h	2016-05-06 15:11:36.000000000 +0800
@@ -74,12 +74,13 @@
 void zmalloc_enable_thread_safeness(void);
 void zmalloc_set_oom_handler(void (*oom_handler)(size_t));
 float zmalloc_get_fragmentation_ratio(size_t rss);
 size_t zmalloc_get_rss(void);
 size_t zmalloc_get_private_dirty(void);
 size_t zmalloc_get_smap_bytes_by_field(char *field);
+size_t zmalloc_get_memory_size(void);
 void zlibc_free(void *ptr);
 
 #ifndef HAVE_MALLOC_SIZE
 size_t zmalloc_size(void *ptr);
 #endif
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/src/zmalloc.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/src/zmalloc.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/cluster/tests: 12-replica-migration-2.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/instances.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/instances.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/instances.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/instances.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -151,12 +151,13 @@
         } elseif {$opt eq "--help"} {
             puts "Hello, I'm sentinel.tcl and I run Sentinel unit tests."
             puts "\nOptions:"
             puts "--single <pattern>      Only runs tests specified by pattern."
             puts "--pause-on-error        Pause for manual inspection on error."
             puts "--fail                  Simulate a test failure."
+            puts "--valgrind              Run with valgrind."
             puts "--help                  Shows this help."
             exit 0
         } else {
             puts "Unknown option $opt"
             exit 1
         }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/integration/aof.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/integration/aof.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/integration/aof.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/integration/aof.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -201,12 +201,36 @@
                 fail "Loading DB is taking too much time."
             }
             assert_equal 1 [$client scard set]
         }
     }
 
+    ## Uses the alsoPropagate() API.
+    create_aof {
+        append_to_aof [formatCommand sadd set foo]
+        append_to_aof [formatCommand sadd set bar]
+        append_to_aof [formatCommand sadd set gah]
+        append_to_aof [formatCommand spop set 2]
+    }
+
+    start_server_aof [list dir $server_path] {
+        test "AOF+SPOP: Server should have been started" {
+            assert_equal 1 [is_alive $srv]
+        }
+
+        test "AOF+SPOP: Set should have 1 member" {
+            set client [redis [dict get $srv host] [dict get $srv port]]
+            wait_for_condition 50 100 {
+                [catch {$client ping} e] == 0
+            } else {
+                fail "Loading DB is taking too much time."
+            }
+            assert_equal 1 [$client scard set]
+        }
+    }
+
     ## Test that EXPIREAT is loaded correctly
     create_aof {
         append_to_aof [formatCommand rpush list foo]
         append_to_aof [formatCommand expireat list 1000]
         append_to_aof [formatCommand rpush list bar]
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/integration/rdb.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/integration/rdb.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/integration/rdb.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/integration/rdb.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -87,12 +87,12 @@
 
 # Now make sure the server aborted with an error
 start_server_and_kill_it [list "dir" $server_path] {
     test {Server should not start if RDB is corrupted} {
         wait_for_condition 50 100 {
             [string match {*RDB checksum*} \
-                [exec tail -n1 < [dict get $srv stdout]]]
+                [exec tail -n10 < [dict get $srv stdout]]]
         } else {
             fail "Server started even if RDB was corrupted!"
         }
     }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/integration/replication-4.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/integration/replication-4.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/integration/replication-4.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/integration/replication-4.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -129,8 +129,27 @@
             {
                 after 1000
                 incr retry -1
             }
             assert {[$master dbsize] > 0}
         }
+
+        test {Replication of SPOP command -- alsoPropagate() API} {
+            $master del myset
+            set size [expr 1+[randomInt 100]]
+            set content {}
+            for {set j 0} {$j < $size} {incr j} {
+                lappend content [randomValue]
+            }
+            $master sadd myset {*}$content
+
+            set count [randomInt 100]
+            set result [$master spop myset $count]
+
+            wait_for_condition 50 100 {
+                [$master debug digest] eq [$slave debug digest]
+            } else {
+                fail "SPOP replication inconsistency"
+            }
+        }
     }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/support/test.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/support/test.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/support/test.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/support/test.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -16,34 +16,31 @@
 proc assert_match {pattern value} {
     if {![string match $pattern $value]} {
         error "assertion:Expected '$value' to match '$pattern'"
     }
 }
 
-proc assert_equal {expected value} {
+proc assert_equal {expected value {detail ""}} {
     if {$expected ne $value} {
-        error "assertion:Expected '$value' to be equal to '$expected'"
+        if {$detail ne ""} {
+            set detail " (detail: $detail)"
+        }
+        error "assertion:Expected '$value' to be equal to '$expected'$detail"
     }
 }
 
 proc assert_error {pattern code} {
     if {[catch {uplevel 1 $code} error]} {
         assert_match $pattern $error
     } else {
         error "assertion:Expected an error but nothing was caught"
     }
 }
 
 proc assert_encoding {enc key} {
-    # Swapped out values don't have an encoding, so make sure that
-    # the value is swapped in before checking the encoding.
     set dbg [r debug object $key]
-    while {[string match "* swapped at:*" $dbg]} {
-        r debug swapin $key
-        set dbg [r debug object $key]
-    }
     assert_match "* encoding:$enc *" $dbg
 }
 
 proc assert_type {type key} {
     assert_equal $type [r type $key]
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/test_helper.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/test_helper.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/test_helper.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/test_helper.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -13,14 +13,16 @@
 
 set ::all_tests {
     unit/printver
     unit/dump
     unit/auth
     unit/protocol
-    unit/basic
+    unit/keyspace
     unit/scan
+    unit/type/string
+    unit/type/incr
     unit/type/list
     unit/type/list-2
     unit/type/list-3
     unit/type/set
     unit/type/zset
     unit/type/hash
@@ -44,12 +46,13 @@
     unit/scripting
     unit/maxmemory
     unit/introspection
     unit/limits
     unit/obuf-limits
     unit/bitops
+    unit/bitfield
     unit/memefficiency
     unit/hyperloglog
 }
 # Index to the next test to run in the ::all_tests list.
 set ::next_test 0
 
@@ -459,14 +462,17 @@
     set s [socket [srv 0 "host"] [srv 0 "port"]]
     fconfigure $s -translation binary
     puts -nonewline $s "SYNC\r\n"
     flush $s
 
     # Get the count
-    set count [gets $s]
-    set prefix [string range $count 0 0]
+    while 1 {
+        set count [gets $s]
+        set prefix [string range $count 0 0]
+        if {$prefix ne {}} break; # Newlines are allowed as PINGs.
+    }
     if {$prefix ne {$}} {
         error "attach_to_replication_stream error. Received '$count' as count."
     }
     set count [string range $count 1 end]
 
     # Consume the bulk payload
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/aofrw.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/aofrw.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/aofrw.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/aofrw.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -74,16 +74,16 @@
         } else {
             fail "Can't find 'Killing AOF child' into recent logs"
         }
     }
 
     foreach d {string int} {
-        foreach e {ziplist linkedlist} {
+        foreach e {quicklist} {
             test "AOF rewrite of list with $e encoding, $d data" {
                 r flushall
-                if {$e eq {ziplist}} {set len 10} else {set len 1000}
+                set len 1000
                 for {set j 0} {$j < $len} {incr j} {
                     if {$d eq {string}} {
                         set data [randstring 0 16 alpha]
                     } else {
                         set data [randomInt 4000000000]
                     }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit: basic.tcl
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit: bitfield.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/bitops.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/bitops.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/bitops.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/bitops.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -1,7 +1,7 @@
-# Compare Redis commadns against Tcl implementations of the same commands.
+# Compare Redis commands against Tcl implementations of the same commands.
 proc count_bits s {
     binary scan $s b* bits
     string length [regsub -all {0} $bits {}]
 }
 
 proc simulate_bit_op {op args} {
@@ -85,13 +85,13 @@
     test {BITCOUNT syntax error #1} {
         catch {r bitcount s 0} e
         set e
     } {ERR*syntax*}
 
     test {BITCOUNT regression test for github issue #582} {
-        r del str
+        r del foo
         r setbit foo 0 1
         if {[catch {r bitcount foo 0 4294967296} e]} {
             assert_match {*ERR*out of range*} $e
             set _ 1
         } else {
             set e
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/dump.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/dump.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/dump.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/dump.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -154,13 +154,13 @@
         }
     }
 
     test {MIGRATE can correctly transfer large values} {
         set first [srv 0 client]
         r del key
-        for {set j 0} {$j < 5000} {incr j} {
+        for {set j 0} {$j < 40000} {incr j} {
             r rpush key 1 2 3 4 5 6 7 8 9 10
             r rpush key "item 1" "item 2" "item 3" "item 4" "item 5" \
                         "item 6" "item 7" "item 8" "item 9" "item 10"
         }
         assert {[string length [r dump key]] > (1024*64)}
         start_server {tags {"repl"}} {
@@ -172,13 +172,13 @@
             assert {[$second exists key] == 0}
             set ret [r -1 migrate $second_host $second_port key 9 10000]
             assert {$ret eq {OK}}
             assert {[$first exists key] == 0}
             assert {[$second exists key] == 1}
             assert {[$second ttl key] == -1}
-            assert {[$second llen key] == 5000*20}
+            assert {[$second llen key] == 40000*20}
         }
     }
 
     test {MIGRATE can correctly transfer hashes} {
         set first [srv 0 client]
         r del key
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit: geo.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/hyperloglog.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/hyperloglog.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/hyperloglog.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/hyperloglog.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -133,27 +133,42 @@
         r pfadd hll2 b c d
         r pfadd hll3 c d e
         r pfmerge hll hll1 hll2 hll3
         r pfcount hll
     } {5}
 
-    test {PFCOUNT multiple-keys merge returns cardinality of union} {
+    test {PFCOUNT multiple-keys merge returns cardinality of union #1} {
         r del hll1 hll2 hll3
         for {set x 1} {$x < 10000} {incr x} {
-            # Force dense representation of hll2
             r pfadd hll1 "foo-$x"
             r pfadd hll2 "bar-$x"
             r pfadd hll3 "zap-$x"
 
             set card [r pfcount hll1 hll2 hll3]
             set realcard [expr {$x*3}]
             set err [expr {abs($card-$realcard)}]
             assert {$err < (double($card)/100)*5}
         }
     }
 
+    test {PFCOUNT multiple-keys merge returns cardinality of union #2} {
+        r del hll1 hll2 hll3
+        set elements {}
+        for {set x 1} {$x < 10000} {incr x} {
+            for {set j 1} {$j <= 3} {incr j} {
+                set rint [randomInt 20000]
+                r pfadd hll$j $rint
+                lappend elements $rint
+            }
+        }
+        set realcard [llength [lsort -unique $elements]]
+        set card [r pfcount hll1 hll2 hll3]
+        set err [expr {abs($card-$realcard)}]
+        assert {$err < (double($card)/100)*5}
+    }
+
     test {PFDEBUG GETREG returns the HyperLogLog raw registers} {
         r del hll
         r pfadd hll 1 2 3
         llength [r pfdebug getreg hll]
     } {16384}
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit: keyspace.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/other.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/other.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/other.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/other.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -191,12 +191,13 @@
             close $fd2
             set _ 1
         } {1}
     }
 
     test {APPEND basics} {
+        r del foo
         list [r append foo bar] [r get foo] \
              [r append foo 100] [r get foo]
     } {3 bar 6 bar100}
 
     test {APPEND basics, integer encoded values} {
         set res {}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/scripting.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/scripting.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/scripting.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/scripting.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -59,65 +59,66 @@
     test {EVALSHA - Do we get an error on non defined SHA1?} {
         catch {r evalsha ffd632c7d33e571e9f24556ebed26c3479a87130 0} e
         set _ $e
     } {NOSCRIPT*}
 
     test {EVAL - Redis integer -> Lua type conversion} {
+        r set x 0
         r eval {
-            local foo = redis.pcall('incr','x')
+            local foo = redis.pcall('incr',KEYS[1])
             return {type(foo),foo}
-        } 0
+        } 1 x
     } {number 1}
 
     test {EVAL - Redis bulk -> Lua type conversion} {
         r set mykey myval
         r eval {
-            local foo = redis.pcall('get','mykey')
+            local foo = redis.pcall('get',KEYS[1])
             return {type(foo),foo}
-        } 0
+        } 1 mykey
     } {string myval}
 
     test {EVAL - Redis multi bulk -> Lua type conversion} {
         r del mylist
         r rpush mylist a
         r rpush mylist b
         r rpush mylist c
         r eval {
-            local foo = redis.pcall('lrange','mylist',0,-1)
+            local foo = redis.pcall('lrange',KEYS[1],0,-1)
             return {type(foo),foo[1],foo[2],foo[3],# foo}
-        } 0
+        } 1 mylist
     } {table a b c 3}
 
     test {EVAL - Redis status reply -> Lua type conversion} {
         r eval {
-            local foo = redis.pcall('set','mykey','myval')
+            local foo = redis.pcall('set',KEYS[1],'myval')
             return {type(foo),foo['ok']}
-        } 0
+        } 1 mykey
     } {table OK}
 
     test {EVAL - Redis error reply -> Lua type conversion} {
         r set mykey myval
         r eval {
-            local foo = redis.pcall('incr','mykey')
+            local foo = redis.pcall('incr',KEYS[1])
             return {type(foo),foo['err']}
-        } 0
+        } 1 mykey
     } {table {ERR value is not an integer or out of range}}
 
     test {EVAL - Redis nil bulk reply -> Lua type conversion} {
         r del mykey
         r eval {
-            local foo = redis.pcall('get','mykey')
+            local foo = redis.pcall('get',KEYS[1])
             return {type(foo),foo == false}
-        } 0
+        } 1 mykey
     } {boolean 1}
 
     test {EVAL - Is the Lua client using the currently selected DB?} {
         r set mykey "this is DB 9"
         r select 10
         r set mykey "this is DB 10"
-        r eval {return redis.pcall('get','mykey')} 0
+        r eval {return redis.pcall('get',KEYS[1])} 1 mykey
     } {this is DB 10}
 
     test {EVAL - SELECT inside Lua should not affect the caller} {
         # here we DB 10 is selected
         r set mykey "original value"
         r eval {return redis.pcall('select','9')} 0
@@ -414,13 +415,13 @@
 
     test {We can call scripts rewriting client->argv from Lua} {
         r del myset
         r sadd myset a b c
         r mset a 1 b 2 c 3 d 4
         assert {[r spop myset] ne {}}
-        assert {[r spop myset] ne {}}
+        assert {[r spop myset 1] ne {}}
         assert {[r spop myset] ne {}}
         assert {[r mget a b c d] eq {1 2 3 4}}
         assert {[r spop myset] eq {}}
     }
 
     test {Call Redis command with many args from Lua (issue #1764)} {
@@ -464,12 +465,21 @@
                   redis.call('EXPIRE', 'a', 0)
                   redis.call('GET', 'a')
                   redis.call('MGET', 'a', 'b', 'c')
               end
         } 0
     }
+
+    test {Functions in the Redis namespace are able to report errors} {
+        catch {
+            r eval {
+                  redis.sha1hex()
+            } 0
+        } e
+        set e
+    } {*wrong number*}
 }
 
 # Start a new server since the last test in this stanza will kill the
 # instance at all.
 start_server {tags {"scripting"}} {
     test {Timedout read-only scripts can be killed by SCRIPT KILL} {
@@ -513,98 +523,213 @@
         # Make sure the server was killed
         catch {set rd [redis_deferring_client]} e
         assert_match {*connection refused*} $e
     }
 }
 
-start_server {tags {"scripting repl"}} {
-    start_server {} {
-        test {Before the slave connects we issue two EVAL commands} {
-            # One with an error, but still executing a command.
-            # SHA is: 67164fc43fa971f76fd1aaeeaf60c1c178d25876
-            catch {
-                r eval {redis.call('incr',KEYS[1]); redis.call('nonexisting')} 1 x
+foreach cmdrepl {0 1} {
+    start_server {tags {"scripting repl"}} {
+        start_server {} {
+            if {$cmdrepl == 1} {
+                set rt "(commmands replication)"
+            } else {
+                set rt "(scripts replication)"
+                r debug lua-always-replicate-commands 1
             }
-            # One command is correct:
-            # SHA is: 6f5ade10a69975e903c6d07b10ea44c6382381a5
-            r eval {return redis.call('incr',KEYS[1])} 1 x
-        } {2}
 
-        test {Connect a slave to the main instance} {
+            test "Before the slave connects we issue two EVAL commands $rt" {
+                # One with an error, but still executing a command.
+                # SHA is: 67164fc43fa971f76fd1aaeeaf60c1c178d25876
+                catch {
+                    r eval {redis.call('incr',KEYS[1]); redis.call('nonexisting')} 1 x
+                }
+                # One command is correct:
+                # SHA is: 6f5ade10a69975e903c6d07b10ea44c6382381a5
+                r eval {return redis.call('incr',KEYS[1])} 1 x
+            } {2}
+
+            test "Connect a slave to the master instance $rt" {
+                r -1 slaveof [srv 0 host] [srv 0 port]
+                wait_for_condition 50 100 {
+                    [s -1 role] eq {slave} &&
+                    [string match {*master_link_status:up*} [r -1 info replication]]
+                } else {
+                    fail "Can't turn the instance into a slave"
+                }
+            }
+
+            test "Now use EVALSHA against the master, with both SHAs $rt" {
+                # The server should replicate successful and unsuccessful
+                # commands as EVAL instead of EVALSHA.
+                catch {
+                    r evalsha 67164fc43fa971f76fd1aaeeaf60c1c178d25876 1 x
+                }
+                r evalsha 6f5ade10a69975e903c6d07b10ea44c6382381a5 1 x
+            } {4}
+
+            test "If EVALSHA was replicated as EVAL, 'x' should be '4' $rt" {
+                wait_for_condition 50 100 {
+                    [r -1 get x] eq {4}
+                } else {
+                    fail "Expected 4 in x, but value is '[r -1 get x]'"
+                }
+            }
+
+            test "Replication of script multiple pushes to list with BLPOP $rt" {
+                set rd [redis_deferring_client]
+                $rd brpop a 0
+                r eval {
+                    redis.call("lpush",KEYS[1],"1");
+                    redis.call("lpush",KEYS[1],"2");
+                } 1 a
+                set res [$rd read]
+                $rd close
+                wait_for_condition 50 100 {
+                    [r -1 lrange a 0 -1] eq [r lrange a 0 -1]
+                } else {
+                    fail "Expected list 'a' in slave and master to be the same, but they are respectively '[r -1 lrange a 0 -1]' and '[r lrange a 0 -1]'"
+                }
+                set res
+            } {a 1}
+
+            test "EVALSHA replication when first call is readonly $rt" {
+                r del x
+                r eval {if tonumber(ARGV[1]) > 0 then redis.call('incr', KEYS[1]) end} 1 x 0
+                r evalsha 6e0e2745aa546d0b50b801a20983b70710aef3ce 1 x 0
+                r evalsha 6e0e2745aa546d0b50b801a20983b70710aef3ce 1 x 1
+                wait_for_condition 50 100 {
+                    [r -1 get x] eq {1}
+                } else {
+                    fail "Expected 1 in x, but value is '[r -1 get x]'"
+                }
+            }
+
+            test "Lua scripts using SELECT are replicated correctly $rt" {
+                r eval {
+                    redis.call("set","foo1","bar1")
+                    redis.call("select","10")
+                    redis.call("incr","x")
+                    redis.call("select","11")
+                    redis.call("incr","z")
+                } 0
+                r eval {
+                    redis.call("set","foo1","bar1")
+                    redis.call("select","10")
+                    redis.call("incr","x")
+                    redis.call("select","11")
+                    redis.call("incr","z")
+                } 0
+                wait_for_condition 50 100 {
+                    [r -1 debug digest] eq [r debug digest]
+                } else {
+                    fail "Master-Slave desync after Lua script using SELECT."
+                }
+            }
+        }
+    }
+}
+
+start_server {tags {"scripting repl"}} {
+    start_server {overrides {appendonly yes}} {
+        test "Connect a slave to the master instance" {
             r -1 slaveof [srv 0 host] [srv 0 port]
             wait_for_condition 50 100 {
                 [s -1 role] eq {slave} &&
                 [string match {*master_link_status:up*} [r -1 info replication]]
             } else {
                 fail "Can't turn the instance into a slave"
             }
         }
 
-        test {Now use EVALSHA against the master, with both SHAs} {
-            # The server should replicate successful and unsuccessful
-            # commands as EVAL instead of EVALSHA.
+        test "Redis.replicate_commands() must be issued before any write" {
+            r eval {
+                redis.call('set','foo','bar');
+                return redis.replicate_commands();
+            } 0
+        } {}
+
+        test "Redis.replicate_commands() must be issued before any write (2)" {
+            r eval {
+                return redis.replicate_commands();
+            } 0
+        } {1}
+
+        test "Redis.set_repl() must be issued after replicate_commands()" {
             catch {
-                r evalsha 67164fc43fa971f76fd1aaeeaf60c1c178d25876 1 x
-            }
-            r evalsha 6f5ade10a69975e903c6d07b10ea44c6382381a5 1 x
-        } {4}
+                r eval {
+                    redis.set_repl(redis.REPL_ALL);
+                } 0
+            } e
+            set e
+        } {*only after turning on*}
 
-        test {If EVALSHA was replicated as EVAL, 'x' should be '4'} {
-            wait_for_condition 50 100 {
-                [r -1 get x] eq {4}
-            } else {
-                fail "Expected 4 in x, but value is '[r -1 get x]'"
-            }
-        }
+        test "Redis.set_repl() don't accept invalid values" {
+            catch {
+                r eval {
+                    redis.replicate_commands();
+                    redis.set_repl(12345);
+                } 0
+            } e
+            set e
+        } {*Invalid*flags*}
 
-        test {Replication of script multiple pushes to list with BLPOP} {
-            set rd [redis_deferring_client]
-            $rd brpop a 0
+        test "Test selective replication of certain Redis commands from Lua" {
+            r del a b c d
             r eval {
-                redis.call("lpush",KEYS[1],"1");
-                redis.call("lpush",KEYS[1],"2");
-            } 1 a
-            set res [$rd read]
-            $rd close
-            wait_for_condition 50 100 {
-                [r -1 lrange a 0 -1] eq [r lrange a 0 -1]
-            } else {
-                fail "Expected list 'a' in slave and master to be the same, but they are respectively '[r -1 lrange a 0 -1]' and '[r lrange a 0 -1]'"
-            }
-            set res
-        } {a 1}
+                redis.replicate_commands();
+                redis.call('set','a','1');
+                redis.set_repl(redis.REPL_NONE);
+                redis.call('set','b','2');
+                redis.set_repl(redis.REPL_AOF);
+                redis.call('set','c','3');
+                redis.set_repl(redis.REPL_ALL);
+                redis.call('set','d','4');
+            } 0
 
-        test {EVALSHA replication when first call is readonly} {
-            r del x
-            r eval {if tonumber(ARGV[1]) > 0 then redis.call('incr', KEYS[1]) end} 1 x 0
-            r evalsha 6e0e2745aa546d0b50b801a20983b70710aef3ce 1 x 0
-            r evalsha 6e0e2745aa546d0b50b801a20983b70710aef3ce 1 x 1
             wait_for_condition 50 100 {
-                [r -1 get x] eq {1}
+                [r -1 mget a b c d] eq {1 {} {} 4}
             } else {
-                fail "Expected 1 in x, but value is '[r -1 get x]'"
+                fail "Only a and c should be replicated to slave"
             }
+
+            # Master should have everything right now
+            assert {[r mget a b c d] eq {1 2 3 4}}
+
+            # After an AOF reload only a, c and d should exist
+            r debug loadaof
+
+            assert {[r mget a b c d] eq {1 {} 3 4}}
         }
 
-        test {Lua scripts using SELECT are replicated correctly} {
-            r eval {
-                redis.call("set","foo1","bar1")
-                redis.call("select","10")
-                redis.call("incr","x")
-                redis.call("select","11")
-                redis.call("incr","z")
-            } 0
+        test "PRNG is seeded randomly for command replication" {
+            set a [
+                r eval {
+                    redis.replicate_commands();
+                    return math.random()*100000;
+                } 0
+            ]
+            set b [
+                r eval {
+                    redis.replicate_commands();
+                    return math.random()*100000;
+                } 0
+            ]
+            assert {$a ne $b}
+        }
+
+        test "Using side effects is not a problem with command replication" {
             r eval {
-                redis.call("set","foo1","bar1")
-                redis.call("select","10")
-                redis.call("incr","x")
-                redis.call("select","11")
-                redis.call("incr","z")
+                redis.replicate_commands();
+                redis.call('set','time',redis.call('time')[1])
             } 0
+
+            assert {[r get time] ne {}}
+
             wait_for_condition 50 100 {
-                [r -1 debug digest] eq [r debug digest]
+                [r get time] eq [r -1 get time]
             } else {
-                fail "Master-Slave desync after Lua script using SELECT."
+                fail "Time key does not match between master and slave"
             }
         }
     }
 }
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/sort.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/sort.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/sort.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/sort.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -1,11 +1,10 @@
 start_server {
     tags {"sort"}
     overrides {
-        "list-max-ziplist-value" 16
-        "list-max-ziplist-entries" 32
+        "list-max-ziplist-size" 32
         "set-max-intset-entries" 32
     }
 } {
     proc create_random_dataset {num cmd} {
         set tosort {}
         set result {}
@@ -33,15 +32,15 @@
             lappend result [lindex $sorted $i 0]
         }
         set _ $result
     }
 
     foreach {num cmd enc title} {
-        16 lpush ziplist "Ziplist"
-        1000 lpush linkedlist "Linked list"
-        10000 lpush linkedlist "Big Linked list"
+        16 lpush quicklist "Old Ziplist"
+        1000 lpush quicklist "Old Linked list"
+        10000 lpush quicklist "Old Big Linked list"
         16 sadd intset "Intset"
         1000 sadd hashtable "Hash table"
         10000 sadd hashtable "Big Hash table"
     } {
         set result [create_random_dataset $num $cmd]
         assert_encoding $enc tosort
@@ -82,20 +81,20 @@
     }
 
     test "SORT BY key STORE" {
         r sort tosort BY weight_* store sort-res
         assert_equal $result [r lrange sort-res 0 -1]
         assert_equal 16 [r llen sort-res]
-        assert_encoding ziplist sort-res
+        assert_encoding quicklist sort-res
     }
 
     test "SORT BY hash field STORE" {
         r sort tosort BY wobj_*->weight store sort-res
         assert_equal $result [r lrange sort-res 0 -1]
         assert_equal 16 [r llen sort-res]
-        assert_encoding ziplist sort-res
+        assert_encoding quicklist sort-res
     }
 
     test "SORT extracts STORE correctly" {
         r command getkeys sort abc store def
     } {abc def}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/hash.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/hash.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/hash.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/hash.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -387,12 +387,60 @@
         catch {r hincrbyfloat smallhash str 1} bigerr
         set rv {}
         lappend rv [string match "ERR*not*float*" $smallerr]
         lappend rv [string match "ERR*not*float*" $bigerr]
     } {1 1}
 
+    test {HSTRLEN against the small hash} {
+        set err {}
+        foreach k [array names smallhash *] {
+            if {[string length $smallhash($k)] ne [r hstrlen smallhash $k]} {
+                set err "[string length $smallhash($k)] != [r hstrlen smallhash $k]"
+                break
+            }
+        }
+        set _ $err
+    } {}
+
+    test {HSTRLEN against the big hash} {
+        set err {}
+        foreach k [array names bighash *] {
+            if {[string length $bighash($k)] ne [r hstrlen bighash $k]} {
+                set err "[string length $bighash($k)] != [r hstrlen bighash $k]"
+                puts "HSTRLEN and logical length mismatch:"
+                puts "key: $k"
+                puts "Logical content: $bighash($k)"
+                puts "Server  content: [r hget bighash $k]"
+            }
+        }
+        set _ $err
+    } {}
+
+    test {HSTRLEN against non existing field} {
+        set rv {}
+        lappend rv [r hstrlen smallhash __123123123__]
+        lappend rv [r hstrlen bighash __123123123__]
+        set _ $rv
+    } {0 0}
+
+    test {HSTRLEN corner cases} {
+        set vals {
+            -9223372036854775808 9223372036854775807 9223372036854775808
+            {} 0 -1 x
+        }
+        foreach v $vals {
+            r hmset smallhash field $v
+            r hmset bighash field $v
+            set len1 [string length $v]
+            set len2 [r hstrlen smallhash field]
+            set len3 [r hstrlen bighash field]
+            assert {$len1 == $len2}
+            assert {$len2 == $len3}
+        }
+    }
+
     test {Hash ziplist regression test for large keys} {
         r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk a
         r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk b
         r hget hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk
     } {b}
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type: incr.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/list-2.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/list-2.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/list-2.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/list-2.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -1,11 +1,10 @@
 start_server {
     tags {"list"}
     overrides {
-        "list-max-ziplist-value" 16
-        "list-max-ziplist-entries" 256
+        "list-max-ziplist-size" 4
     }
 } {
     source "tests/unit/type/list-common.tcl"
 
     foreach {type large} [array get largevalue] {
         tags {"slow"} {
@@ -25,20 +24,24 @@
                     lappend mylist $str
                 }
 
                 for {set i 0} {$i < 1000} {incr i} {
                     set min [expr {int(rand()*$startlen)}]
                     set max [expr {$min+int(rand()*$startlen)}]
+                    set before_len [llength $mylist]
+                    set before_len_r [r llen mylist]
                     set mylist [lrange $mylist $min $max]
                     r ltrim mylist $min $max
-                    assert_equal $mylist [r lrange mylist 0 -1]
+                    assert_equal $mylist [r lrange mylist 0 -1] "failed trim"
 
+                    set starting [r llen mylist]
                     for {set j [r llen mylist]} {$j < $startlen} {incr j} {
                         set str [randomInt 9223372036854775807]
                         r rpush mylist $str
                         lappend mylist $str
+                        assert_equal $mylist [r lrange mylist 0 -1] "failed append match"
                     }
                 }
             }
         }
     }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/list-3.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/list-3.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/list-3.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/list-3.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -1,11 +1,10 @@
 start_server {
     tags {list ziplist}
     overrides {
-        "list-max-ziplist-value" 200000
-        "list-max-ziplist-entries" 256
+        "list-max-ziplist-size" 16
     }
 } {
     test {Explicit regression for a list bug} {
         set mylist {49376042582 {BkG2o\pIC]4YYJa9cJ4GWZalG[4tin;1D2whSkCOW`mX;SFXGyS8sedcff3fQI^tgPCC@^Nu1J6o]meM@Lko]t_jRyo<xSJ1oObDYd`ppZuW6P@fS278YaOx=s6lvdFlMbP0[SbkI^Kr\HBXtuFaA^mDx:yzS4a[skiiPWhT<nNfAf=aQVfclcuwDrfe;iVuKdNvB9kbfq>tK?tH[\EvWqS]b`o2OCtjg:?nUTwdjpcUm]y:pg5q24q7LlCOwQE^}}
         r del l
         r rpush l [lindex $mylist 0]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/list.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/list.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/list.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/list.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -1,60 +1,59 @@
 start_server {
     tags {"list"}
     overrides {
-        "list-max-ziplist-value" 16
-        "list-max-ziplist-entries" 256
+        "list-max-ziplist-size" 5
     }
 } {
     source "tests/unit/type/list-common.tcl"
 
     test {LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - ziplist} {
         # first lpush then rpush
-        assert_equal 1 [r lpush myziplist1 a]
-        assert_equal 2 [r rpush myziplist1 b]
-        assert_equal 3 [r rpush myziplist1 c]
+        assert_equal 1 [r lpush myziplist1 aa]
+        assert_equal 2 [r rpush myziplist1 bb]
+        assert_equal 3 [r rpush myziplist1 cc]
         assert_equal 3 [r llen myziplist1]
-        assert_equal a [r lindex myziplist1 0]
-        assert_equal b [r lindex myziplist1 1]
-        assert_equal c [r lindex myziplist1 2]
+        assert_equal aa [r lindex myziplist1 0]
+        assert_equal bb [r lindex myziplist1 1]
+        assert_equal cc [r lindex myziplist1 2]
         assert_equal {} [r lindex myziplist2 3]
-        assert_equal c [r rpop myziplist1]
-        assert_equal a [r lpop myziplist1]
-        assert_encoding ziplist myziplist1
+        assert_equal cc [r rpop myziplist1]
+        assert_equal aa [r lpop myziplist1]
+        assert_encoding quicklist myziplist1
 
         # first rpush then lpush
         assert_equal 1 [r rpush myziplist2 a]
         assert_equal 2 [r lpush myziplist2 b]
         assert_equal 3 [r lpush myziplist2 c]
         assert_equal 3 [r llen myziplist2]
         assert_equal c [r lindex myziplist2 0]
         assert_equal b [r lindex myziplist2 1]
         assert_equal a [r lindex myziplist2 2]
         assert_equal {} [r lindex myziplist2 3]
         assert_equal a [r rpop myziplist2]
         assert_equal c [r lpop myziplist2]
-        assert_encoding ziplist myziplist2
+        assert_encoding quicklist myziplist2
     }
 
     test {LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - regular list} {
         # first lpush then rpush
         assert_equal 1 [r lpush mylist1 $largevalue(linkedlist)]
-        assert_encoding linkedlist mylist1
+        assert_encoding quicklist mylist1
         assert_equal 2 [r rpush mylist1 b]
         assert_equal 3 [r rpush mylist1 c]
         assert_equal 3 [r llen mylist1]
         assert_equal $largevalue(linkedlist) [r lindex mylist1 0]
         assert_equal b [r lindex mylist1 1]
         assert_equal c [r lindex mylist1 2]
         assert_equal {} [r lindex mylist1 3]
         assert_equal c [r rpop mylist1]
         assert_equal $largevalue(linkedlist) [r lpop mylist1]
 
         # first rpush then lpush
         assert_equal 1 [r rpush mylist2 $largevalue(linkedlist)]
-        assert_encoding linkedlist mylist2
+        assert_encoding quicklist mylist2
         assert_equal 2 [r lpush mylist2 b]
         assert_equal 3 [r lpush mylist2 c]
         assert_equal 3 [r llen mylist2]
         assert_equal c [r lindex mylist2 0]
         assert_equal b [r lindex mylist2 1]
         assert_equal $largevalue(linkedlist) [r lindex mylist2 2]
@@ -71,40 +70,28 @@
         r del mylist
         assert_equal 4 [r lpush mylist a b c d]
         assert_equal 8 [r rpush mylist 0 1 2 3]
         assert_equal {d c b a 0 1 2 3} [r lrange mylist 0 -1]
     }
 
-    test {DEL a list - ziplist} {
-        assert_equal 1 [r del myziplist2]
-        assert_equal 0 [r exists myziplist2]
-        assert_equal 0 [r llen myziplist2]
-    }
-
-    test {DEL a list - regular list} {
+    test {DEL a list} {
         assert_equal 1 [r del mylist2]
         assert_equal 0 [r exists mylist2]
         assert_equal 0 [r llen mylist2]
     }
 
-    proc create_ziplist {key entries} {
+    proc create_list {key entries} {
         r del $key
         foreach entry $entries { r rpush $key $entry }
-        assert_encoding ziplist $key
-    }
-
-    proc create_linkedlist {key entries} {
-        r del $key
-        foreach entry $entries { r rpush $key $entry }
-        assert_encoding linkedlist $key
+        assert_encoding quicklist $key
     }
 
     foreach {type large} [array get largevalue] {
         test "BLPOP, BRPOP: single existing list - $type" {
             set rd [redis_deferring_client]
-            create_$type blist "a b $large c d"
+            create_list blist "a b $large c d"
 
             $rd blpop blist 1
             assert_equal {blist a} [$rd read]
             $rd brpop blist 1
             assert_equal {blist d} [$rd read]
 
@@ -113,14 +100,14 @@
             $rd brpop blist 1
             assert_equal {blist c} [$rd read]
         }
 
         test "BLPOP, BRPOP: multiple existing lists - $type" {
             set rd [redis_deferring_client]
-            create_$type blist1 "a $large c"
-            create_$type blist2 "d $large f"
+            create_list blist1 "a $large c"
+            create_list blist2 "d $large f"
 
             $rd blpop blist1 blist2 1
             assert_equal {blist1 a} [$rd read]
             $rd brpop blist1 blist2 1
             assert_equal {blist1 c} [$rd read]
             assert_equal 1 [r llen blist1]
@@ -134,13 +121,13 @@
             assert_equal 1 [r llen blist2]
         }
 
         test "BLPOP, BRPOP: second list has an entry - $type" {
             set rd [redis_deferring_client]
             r del blist1
-            create_$type blist2 "d $large f"
+            create_list blist2 "d $large f"
 
             $rd blpop blist1 blist2 1
             assert_equal {blist2 d} [$rd read]
             $rd brpop blist1 blist2 1
             assert_equal {blist2 f} [$rd read]
             assert_equal 0 [r llen blist1]
@@ -148,13 +135,13 @@
         }
 
         test "BRPOPLPUSH - $type" {
             r del target
 
             set rd [redis_deferring_client]
-            create_$type blist "a b $large c d"
+            create_list blist "a b $large c d"
 
             $rd brpoplpush blist target 1
             assert_equal d [$rd read]
 
             assert_equal d [r rpop target]
             assert_equal "a b $large c" [r lrange blist 0 -1]
@@ -514,91 +501,43 @@
         assert_equal 0 [r rpushx xlist a]
         assert_equal 0 [r llen xlist]
     }
 
     foreach {type large} [array get largevalue] {
         test "LPUSHX, RPUSHX - $type" {
-            create_$type xlist "$large c"
+            create_list xlist "$large c"
             assert_equal 3 [r rpushx xlist d]
             assert_equal 4 [r lpushx xlist a]
             assert_equal "a $large c d" [r lrange xlist 0 -1]
         }
 
         test "LINSERT - $type" {
-            create_$type xlist "a $large c d"
-            assert_equal 5 [r linsert xlist before c zz]
-            assert_equal "a $large zz c d" [r lrange xlist 0 10]
-            assert_equal 6 [r linsert xlist after c yy]
-            assert_equal "a $large zz c yy d" [r lrange xlist 0 10]
-            assert_equal 7 [r linsert xlist after d dd]
-            assert_equal -1 [r linsert xlist after bad ddd]
-            assert_equal "a $large zz c yy d dd" [r lrange xlist 0 10]
-            assert_equal 8 [r linsert xlist before a aa]
-            assert_equal -1 [r linsert xlist before bad aaa]
-            assert_equal "aa a $large zz c yy d dd" [r lrange xlist 0 10]
+            create_list xlist "a $large c d"
+            assert_equal 5 [r linsert xlist before c zz] "before c"
+            assert_equal "a $large zz c d" [r lrange xlist 0 10] "lrangeA"
+            assert_equal 6 [r linsert xlist after c yy] "after c"
+            assert_equal "a $large zz c yy d" [r lrange xlist 0 10] "lrangeB"
+            assert_equal 7 [r linsert xlist after d dd] "after d"
+            assert_equal -1 [r linsert xlist after bad ddd] "after bad"
+            assert_equal "a $large zz c yy d dd" [r lrange xlist 0 10] "lrangeC"
+            assert_equal 8 [r linsert xlist before a aa] "before a"
+            assert_equal -1 [r linsert xlist before bad aaa] "before bad"
+            assert_equal "aa a $large zz c yy d dd" [r lrange xlist 0 10] "lrangeD"
 
             # check inserting integer encoded value
-            assert_equal 9 [r linsert xlist before aa 42]
-            assert_equal 42 [r lrange xlist 0 0]
+            assert_equal 9 [r linsert xlist before aa 42] "before aa"
+            assert_equal 42 [r lrange xlist 0 0] "lrangeE"
         }
     }
 
     test {LINSERT raise error on bad syntax} {
         catch {[r linsert xlist aft3r aa 42]} e
         set e
     } {*ERR*syntax*error*}
 
-    test {LPUSHX, RPUSHX convert from ziplist to list} {
-        set large $largevalue(linkedlist)
-
-        # convert when a large value is pushed
-        create_ziplist xlist a
-        assert_equal 2 [r rpushx xlist $large]
-        assert_encoding linkedlist xlist
-        create_ziplist xlist a
-        assert_equal 2 [r lpushx xlist $large]
-        assert_encoding linkedlist xlist
-
-        # convert when the length threshold is exceeded
-        create_ziplist xlist [lrepeat 256 a]
-        assert_equal 257 [r rpushx xlist b]
-        assert_encoding linkedlist xlist
-        create_ziplist xlist [lrepeat 256 a]
-        assert_equal 257 [r lpushx xlist b]
-        assert_encoding linkedlist xlist
-    }
-
-    test {LINSERT convert from ziplist to list} {
-        set large $largevalue(linkedlist)
-
-        # convert when a large value is inserted
-        create_ziplist xlist a
-        assert_equal 2 [r linsert xlist before a $large]
-        assert_encoding linkedlist xlist
-        create_ziplist xlist a
-        assert_equal 2 [r linsert xlist after a $large]
-        assert_encoding linkedlist xlist
-
-        # convert when the length threshold is exceeded
-        create_ziplist xlist [lrepeat 256 a]
-        assert_equal 257 [r linsert xlist before a a]
-        assert_encoding linkedlist xlist
-        create_ziplist xlist [lrepeat 256 a]
-        assert_equal 257 [r linsert xlist after a a]
-        assert_encoding linkedlist xlist
-
-        # don't convert when the value could not be inserted
-        create_ziplist xlist [lrepeat 256 a]
-        assert_equal -1 [r linsert xlist before foo a]
-        assert_encoding ziplist xlist
-        create_ziplist xlist [lrepeat 256 a]
-        assert_equal -1 [r linsert xlist after foo a]
-        assert_encoding ziplist xlist
-    }
-
-    foreach {type num} {ziplist 250 linkedlist 500} {
+    foreach {type num} {quicklist 250 quicklist 500} {
         proc check_numbered_list_consistency {key} {
             set len [r llen $key]
             for {set i 0} {$i < $len} {incr i} {
                 assert_equal $i [r lindex $key $i]
                 assert_equal [expr $len-1-$i] [r lindex $key [expr (-$i)-1]]
             }
@@ -661,40 +600,40 @@
         assert_error WRONGTYPE* {r rpush mylist 0}
     }
 
     foreach {type large} [array get largevalue] {
         test "RPOPLPUSH base case - $type" {
             r del mylist1 mylist2
-            create_$type mylist1 "a $large c d"
+            create_list mylist1 "a $large c d"
             assert_equal d [r rpoplpush mylist1 mylist2]
             assert_equal c [r rpoplpush mylist1 mylist2]
             assert_equal "a $large" [r lrange mylist1 0 -1]
             assert_equal "c d" [r lrange mylist2 0 -1]
-            assert_encoding ziplist mylist2
+            assert_encoding quicklist mylist2
         }
 
         test "RPOPLPUSH with the same list as src and dst - $type" {
-            create_$type mylist "a $large c"
+            create_list mylist "a $large c"
             assert_equal "a $large c" [r lrange mylist 0 -1]
             assert_equal c [r rpoplpush mylist mylist]
             assert_equal "c a $large" [r lrange mylist 0 -1]
         }
 
         foreach {othertype otherlarge} [array get largevalue] {
             test "RPOPLPUSH with $type source and existing target $othertype" {
-                create_$type srclist "a b c $large"
-                create_$othertype dstlist "$otherlarge"
+                create_list srclist "a b c $large"
+                create_list dstlist "$otherlarge"
                 assert_equal $large [r rpoplpush srclist dstlist]
                 assert_equal c [r rpoplpush srclist dstlist]
                 assert_equal "a b" [r lrange srclist 0 -1]
                 assert_equal "c $large $otherlarge" [r lrange dstlist 0 -1]
 
                 # When we rpoplpush'ed a large value, dstlist should be
                 # converted to the same encoding as srclist.
                 if {$type eq "linkedlist"} {
-                    assert_encoding linkedlist dstlist
+                    assert_encoding quicklist dstlist
                 }
             }
         }
     }
 
     test {RPOPLPUSH against non existing key} {
@@ -710,13 +649,13 @@
         assert_error WRONGTYPE* {r rpoplpush srclist dstlist}
         assert_type string srclist
         assert_equal 0 [r exists newlist]
     }
 
     test {RPOPLPUSH against non list dst key} {
-        create_ziplist srclist {a b c d}
+        create_list srclist {a b c d}
         r set dstlist x
         assert_error WRONGTYPE* {r rpoplpush srclist dstlist}
         assert_type string dstlist
         assert_equal {a b c d} [r lrange srclist 0 -1]
     }
 
@@ -724,13 +663,13 @@
         r del srclist dstlist
         assert_equal {} [r rpoplpush srclist dstlist]
     } {}
 
     foreach {type large} [array get largevalue] {
         test "Basic LPOP/RPOP - $type" {
-            create_$type mylist "$large 1 2"
+            create_list mylist "$large 1 2"
             assert_equal $large [r lpop mylist]
             assert_equal 2 [r rpop mylist]
             assert_equal 1 [r lpop mylist]
             assert_equal 0 [r llen mylist]
 
             # pop on empty list
@@ -742,13 +681,13 @@
     test {LPOP/RPOP against non list value} {
         r set notalist foo
         assert_error WRONGTYPE* {r lpop notalist}
         assert_error WRONGTYPE* {r rpop notalist}
     }
 
-    foreach {type num} {ziplist 250 linkedlist 500} {
+    foreach {type num} {quicklist 250 quicklist 500} {
         test "Mass RPOP/LPOP - $type" {
             r del mylist
             set sum1 0
             for {set i 0} {$i < $num} {incr i} {
                 r lpush mylist $i
                 incr sum1 $i
@@ -762,30 +701,30 @@
             assert_equal $sum1 $sum2
         }
     }
 
     foreach {type large} [array get largevalue] {
         test "LRANGE basics - $type" {
-            create_$type mylist "$large 1 2 3 4 5 6 7 8 9"
+            create_list mylist "$large 1 2 3 4 5 6 7 8 9"
             assert_equal {1 2 3 4 5 6 7 8} [r lrange mylist 1 -2]
             assert_equal {7 8 9} [r lrange mylist -3 -1]
             assert_equal {4} [r lrange mylist 4 4]
         }
 
         test "LRANGE inverted indexes - $type" {
-            create_$type mylist "$large 1 2 3 4 5 6 7 8 9"
+            create_list mylist "$large 1 2 3 4 5 6 7 8 9"
             assert_equal {} [r lrange mylist 6 2]
         }
 
         test "LRANGE out of range indexes including the full list - $type" {
-            create_$type mylist "$large 1 2 3"
+            create_list mylist "$large 1 2 3"
             assert_equal "$large 1 2 3" [r lrange mylist -1000 1000]
         }
 
         test "LRANGE out of range negative end index - $type" {
-            create_$type mylist "$large 1 2 3"
+            create_list mylist "$large 1 2 3"
             assert_equal $large [r lrange mylist 0 -4]
             assert_equal {} [r lrange mylist 0 -5]
         }
     }
 
     test {LRANGE against non existing key} {
@@ -793,13 +732,13 @@
     }
 
     foreach {type large} [array get largevalue] {
         proc trim_list {type min max} {
             upvar 1 large large
             r del mylist
-            create_$type mylist "1 2 3 4 $large"
+            create_list mylist "1 2 3 4 $large"
             r ltrim mylist $min $max
             r lrange mylist 0 -1
         }
 
         test "LTRIM basics - $type" {
             assert_equal "1" [trim_list $type 0 0]
@@ -822,13 +761,13 @@
         }
 
     }
 
     foreach {type large} [array get largevalue] {
         test "LSET - $type" {
-            create_$type mylist "99 98 $large 96 95"
+            create_list mylist "99 98 $large 96 95"
             r lset mylist 1 foo
             r lset mylist -1 bar
             assert_equal "99 foo $large 96 bar" [r lrange mylist 0 -1]
         }
 
         test "LSET out of range index - $type" {
@@ -844,13 +783,13 @@
         r set nolist foobar
         assert_error WRONGTYPE* {r lset nolist 0 foo}
     }
 
     foreach {type e} [array get largevalue] {
         test "LREM remove all the occurrences - $type" {
-            create_$type mylist "$e foo bar foobar foobared zap bar test foo"
+            create_list mylist "$e foo bar foobar foobared zap bar test foo"
             assert_equal 2 [r lrem mylist 0 bar]
             assert_equal "$e foo foobar foobared zap test foo" [r lrange mylist 0 -1]
         }
 
         test "LREM remove the first occurrence - $type" {
             assert_equal 1 [r lrem mylist 1 foo]
@@ -860,24 +799,24 @@
         test "LREM remove non existing element - $type" {
             assert_equal 0 [r lrem mylist 1 nosuchelement]
             assert_equal "$e foobar foobared zap test foo" [r lrange mylist 0 -1]
         }
 
         test "LREM starting from tail with negative count - $type" {
-            create_$type mylist "$e foo bar foobar foobared zap bar test foo foo"
+            create_list mylist "$e foo bar foobar foobared zap bar test foo foo"
             assert_equal 1 [r lrem mylist -1 bar]
             assert_equal "$e foo bar foobar foobared zap test foo foo" [r lrange mylist 0 -1]
         }
 
         test "LREM starting from tail with negative count (2) - $type" {
             assert_equal 2 [r lrem mylist -2 foo]
             assert_equal "$e foo bar foobar foobared zap test" [r lrange mylist 0 -1]
         }
 
         test "LREM deleting objects that may be int encoded - $type" {
-            create_$type myotherlist "$e 1 2 3"
+            create_list myotherlist "$e 1 2 3"
             assert_equal 1 [r lrem myotherlist 1 2]
             assert_equal 3 [r llen myotherlist]
         }
     }
 
     test "Regression for bug 593 - chaining BRPOPLPUSH with other blocking cmds" {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/set.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/set.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/set.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/set.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -290,23 +290,92 @@
             create_set myset $contents
             assert_encoding $type myset
             assert_equal $contents [lsort [list [r spop myset] [r spop myset] [r spop myset]]]
             assert_equal 0 [r scard myset]
         }
 
+        test "SPOP with <count>=1 - $type" {
+            create_set myset $contents
+            assert_encoding $type myset
+            assert_equal $contents [lsort [list [r spop myset 1] [r spop myset 1] [r spop myset 1]]]
+            assert_equal 0 [r scard myset]
+        }
+
         test "SRANDMEMBER - $type" {
             create_set myset $contents
             unset -nocomplain myset
             array set myset {}
             for {set i 0} {$i < 100} {incr i} {
                 set myset([r srandmember myset]) 1
             }
             assert_equal $contents [lsort [array names myset]]
         }
     }
 
+    foreach {type contents} {
+        hashtable {a b c d e f g h i j k l m n o p q r s t u v w x y z} 
+        intset {1 10 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 26 3 4 5 6 7 8 9}
+    } {
+        test "SPOP with <count>" {
+            create_set myset $contents
+            assert_encoding $type myset
+            assert_equal $contents [lsort [concat [r spop myset 11] [r spop myset 9] [r spop myset 0] [r spop myset 4] [r spop myset 1] [r spop myset 0] [r spop myset 1] [r spop myset 0]]]
+            assert_equal 0 [r scard myset]
+        }
+    }
+
+    # As seen in intsetRandomMembers
+    test "SPOP using integers, testing Knuth's and Floyd's algorithm" {
+        create_set myset {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}
+        assert_encoding intset myset
+        assert_equal 20 [r scard myset]
+        r spop myset 1
+        assert_equal 19 [r scard myset]
+        r spop myset 2
+        assert_equal 17 [r scard myset]
+        r spop myset 3
+        assert_equal 14 [r scard myset]
+        r spop myset 10
+        assert_equal 4 [r scard myset]
+        r spop myset 10
+        assert_equal 0 [r scard myset]
+        r spop myset 1
+        assert_equal 0 [r scard myset]
+    } {}
+
+    test "SPOP using integers with Knuth's algorithm" {
+        r spop nonexisting_key 100
+    } {}
+
+    test "SPOP new implementation: code path #1" {
+        set content {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}
+        create_set myset $content
+        set res [r spop myset 30]
+        assert {[lsort $content] eq [lsort $res]}
+    }
+
+    test "SPOP new implementation: code path #2" {
+        set content {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}
+        create_set myset $content
+        set res [r spop myset 2]
+        assert {[llength $res] == 2}
+        assert {[r scard myset] == 18}
+        set union [concat [r smembers myset] $res]
+        assert {[lsort $union] eq [lsort $content]}
+    }
+
+    test "SPOP new implementation: code path #3" {
+        set content {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}
+        create_set myset $content
+        set res [r spop myset 18]
+        assert {[llength $res] == 18}
+        assert {[r scard myset] == 2}
+        set union [concat [r smembers myset] $res]
+        assert {[lsort $union] eq [lsort $content]}
+    }
+
     test "SRANDMEMBER with <count> against non existing key" {
         r srandmember nonexisting_key 100
     } {}
 
     foreach {type contents} {
         hashtable {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type: string.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/zset.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/zset.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/tests/unit/type/zset.tcl	2016-01-25 22:57:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/tests/unit/type/zset.tcl	2016-05-06 15:11:36.000000000 +0800
@@ -287,12 +287,18 @@
             assert_equal {foo bar} [r zrange zset 0 -1]
 
             assert_equal -2 [r zscore zset foo]
             assert_equal  6 [r zscore zset bar]
         }
 
+        test "ZINCRBY return value" {
+            r del ztmp
+            set retval [r zincrby ztmp 1.0 x]
+            assert {$retval == 1.0}
+        }
+
         proc create_default_zset {} {
             create_zset zset {-inf a 1 b 2 c 3 d 4 e 5 f +inf g}
         }
 
         test "ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics" {
             create_default_zset
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/utils: hashtable
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.0.7/utils: mkrelease.sh
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.0/utils: releasetools
