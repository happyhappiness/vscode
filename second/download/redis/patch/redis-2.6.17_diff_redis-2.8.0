diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/00-RELEASENOTES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/00-RELEASENOTES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/00-RELEASENOTES	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/00-RELEASENOTES	2013-11-22 17:25:29.000000000 +0800
@@ -1,458 +1,159 @@
-Redis 2.6 release notes
+Redis 2.8 release notes
 =======================
 
-** IMPORTANT ** Check the 'Migrating from 2.4 to 2.6' section at the end of
-                this file for information about what changed between 2.4 and
-                2.6 and how this may affect your application.
+** IMPORTANT ** Check the 'Migrating from 2.6 to 2.8' section at the end of
+                this file for information about what changed between 2.6 and
+                2.8 and how this may affect your application.
 
 --------------------------------------------------------------------------------
 Upgrade urgency levels:
 
 LOW:      No need to upgrade unless there are new features you want to use.
 MODERATE: Program an upgrade of the server, but it's not urgent.
 HIGH:     There is a critical bug that may affect a subset of users. Upgrade!
 CRITICAL: There is a critical bug affecting MOST USERS. Upgrade ASAP.
 --------------------------------------------------------------------------------
 
---[ Redis 2.6.17 ] Release date: 11 Dec 2013
+--[ Redis 2.8.0 ] Release date: 22 Nov 2013
 
-UPGRADE URGENCY: MODERATE.
+# UPGRADE URGENCY: LOW, unless you want to upgrade to new Sentinel code.
 
-* [FIX] redis-cli: fix big keys search when the key no longer exist.
-* [FIX] Allow AUTH / PING when disconnected from slave with serve-stale-data on.
-* [FIX] redis-benchmark: update help for new __rand_int__ form.
-* [FIX] Fix broken rdbWriteRaw() return value check in rdb.c (harmless).
-* [FIX] Log to what master a slave is going to connect to.
-* [FIX] Only run the fast active expire cycle if master & enabled.
-* [FIX] Fixed a replication bug involving 32 bit instances and big datasets
-        hard to compress that resulted into more than 2GB of RDB file sent.
-
---[ Redis 2.6.16 ] Release date: 28 Aug 2013
-
-UPGRADE URGENCY: MODERATE.
-
-* [FIX] Stop writes when fork() fails when trying to BGSAVE. BGSAVE errors
-        were trapped only in the case the saving child failed, so the fork()
-        error was no trapped as no child is created at all.
-* [FIX] Fix a serious memory efficiency regression, Redis 2.6.16 is
-        significantly better with large values (>= a few kbytes) and will
-        be able to store two times the amount of data compared to Redis 2.6.15
-        when values are in that range.
-* [FIX] Fixed an issue with Table conversion in the lua-cmsgpack library exposed
-        by the Redis scripting engine.
-* [NEW] DEBUG SDSLEN was introduced to debug memory inefficiencies due to
-        SDS allocation more easily.
-
---[ Redis 2.6.15 ] Release date: 21 Aug 2013
-
-UPGRADE URGENCY: MODERATE, upgrade ASAP only if you experience issues related to
-                 the expired keys collection algorithm, or if you use the
-                 ZUNIONSTORE command.
+* [FIX] Fixed an error in rdbWriteRaw() that should have no practical impact.
+* [NEW] Log the new master when SLAVEOF command is used.
+* [NEW] Sentinel code synchronized with the unstable branch, the new Sentinel
+        is a reimplementation that uses more reliable algorithms.
+
+--[ Redis 2.8 Release Candidate 6 (2.7.106) ] Release date: 6 Nov 2013
+
+This is the 6th release candidate of Redis 2.8 (official version is 2.7.106).
+
+# UPGRADE URGENCY: LOW, only new features back ported, no fixes.
+
+* [NEW] SCAN, SSCAN, HSCAN, ZSCAN commands.
+
+--[ Redis 2.8 Release Candidate 5 (2.7.105) ] Release date: 9 Oct 2013
+
+This is the 5th release candidate of Redis 2.8 (official version is 2.7.105).
+Important bugs fixed inside.
+
+# UPGRADE URGENCY: HIGH because of many non critical replication bugs fixed.
+
+* [FIX] redis-cli: don't crash with --bigkeys when the key no longer exist.
+* [FIX] Allow AUTH / PING when disconnected from slave and serve-stale-data is no.
+* [FIX] PSYNC: safer handling of PSYNC requests with offsets in the future.
+* [FIX] Replication: Fix master timeout detection.
+* [FIX] Replication: Correctly install the write handler after successful PSYNC.
+
+--[ Redis 2.8 Release Candidate 4 (2.7.104) ] Release date: 30 Aug 2013
+
+This is the fourth release candidate of Redis 2.8 (official version is 2.7.104).
+Important bugs fixed inside.
+
+# UPGRADE URGENCY: HIGH because of the EVAL memory leak.
+
+* [FIX] Fixed a serious EVAL memory leak in the Lua stack.
+* [FIX] Fixed server startup when no IPv6 address exists in any interface.
+* [FIX] Send MISCONFIG error when BGSAVE fails because can't fork.
+* [FIX] Memory efficiency with large (> a few kbytes) values improved considerably.
+* [NEW] DEBUG SDSLEN for sds memory debugging.
+
+--[ Redis 2.8 Release Candidate 3 (2.7.103) ] Release date: 19 Aug 2013
+
+This is the third release candidate of Redis 2.8 (official version is 2.7.103).
+Important bugs fixed inside.
+
+# UPGRADE URGENCY: HIGH
 
 * [FIX] Improved expired keys collection algorithm. Even under heavy load keys
         to be expired can't accumulate because of lack of CPU time.
+* [FIX] Replication speed regression fixed (issue #1238).
+* [FIX] Fixed an hard to trigger PSYNC bug.
 * [FIX] Fixed Issue #1240, ZUNIONSTORE could lead to wrong result.
+* [NEW] Add per-db average TTL information in INFO output.
 * [NEW] redis-benchmark improvements.
 * [NEW] dict.c API wrong usage detection.
 
-WARNING: redis-benchmark released with 2.6.15 features non backward compatible
-         change in the way the random arguments are specified, use the --help
-         option for more information.
-
---[ Redis 2.6.14 ] Release date: 20 Jun 2013
-
-UPGRADE URGENCY: HIGH because of the following two issues:
-    * Lua scripting + Replication + AOF in slaves problem (see Issue #1164).
-    * AOF + expires possible race condition (see Issue #1079).
-
-* [FIX] AOF bug: expire could be removed from key on AOF rewrite.
-* [FIX] Allow writes from scripts called by AOF loading in read-only slaves.
-* [FIX] Sentinel: parse new version of INFO replication output correctly.
-* [NEW] Reset masterauth if an empty string is configured.
-
---[ Redis 2.6.13 ]
-
-UPGRADE URGENCY: MODERATE, nothing very critical but upgrading is suggested
-                 if you experienced:
-
-                 1) Strange issues with Lua scripting.
-                 2) Not reconfigured reappearing master using Sentinel.
-                 3) Server continusly trying to save on save error.
-
-                 This version of Redis may also help with AOF and slow / busy
-                 disks and latency issues.
-
-* [FIX] Throttle BGSAVE attempt on saving error.
-* [FIX] redis-cli: raise error on bad command line switch.
-* [FIX] Redis/Jemalloc Gitignore were too aggressive.
-* [FIX] Test: fix RDB test checking file permissions.
-* [FIX] Sentinel: always redirect on master->slave transition.
-* [FIX] Lua updated to version 5.1.5. Fixes rare scripting issues.
-* [NEW] AOF: improved latency figures with slow/busy disks.
-* [NEW] Sentinel: turn old master into a slave when it comes back.
-* [NEW] More explicit panic message on out of memory.
-* [NEW] redis-cli: --latency-history mode implemented.
-
---[ Redis 2.6.12 ]
-
-UPGRADE URGENCY: MODERATE, nothing very critical but a few non trivial bugs.
-
-* [BUGFIX]   redis-cli --bigkeys: don't crash with empty DB.
-* [BUGFIX]   stop-writes-on-bgsave-error now works in redis.conf
-* [BUGFIX]   Don't crash at startup if RDB is there but can't be opened.
-* [BUGFIX]   Initial value for master_link_down_since_seconds is now huge.
-* [BUGFIX]   Allow SELECT while loading the DB.
-* [BUGFIX]   Don't replicate/AOF an empty MULTI/EXEC if the transaction
-             is empty or containing just read-only commands.
-* [BUGFIX]   EXPIRE should not be able to resurrect keys (see issue #1026).
-* [IMPROVED] Extended SET back ported from Redis 2.8 / unstable
-             See http://redis.io/commands/set for more information.
-* [IMPROVED] Test suite improved.
-
---[ Redis 2.6.11 ]
-
-UPGRADE URGENCY: LOW, however updating is encouraged if you have many instances
-                 per server and you want to lower the CPU / energy usage.
-
-* [BUGFIX]   Replication: more strict error checking for master PING reply.
-* [BUGFIX]   redis-cli: use keepalive socket option for improved reliability.
-* [BUGFIX]   Allow AUTH while loading the DB in memory.
-* [BUGFIX]   Don't segfault on unbalanced quotes while parsing config file.
-* [BUGFIX]   Don't segfault if command gets propagated to AOF / replication
-             link as another command name that was renamed in redis.conf
-* [IMPROVED] serverCron() frequency is now a runtime parameter (was REDIS_HZ).
-* [IMPROVED] Use a lot less CPU when idle, even with many configured DBs.
-
---[ Redis 2.6.10 ]
-
-UPGRADE URGENCY: MODERATE, this release contains many non-critical fixes
-                 and many small improvements.
-
-* [BUGFIX]   redis-cli --rdb, fixed when the server sends newlines to ping.
-* [BUGFIX]   redis-cli, minor fixes on connection handling, prompt.
-* [BUGFIX]   Slow log: don't log EXEC, just executed commands.
-* [BUGFIX]   On failed shutdown don't try again and again compulsively.
-* [BUGFIX]   Fix build on sunos without backtrace().
-* [BUGFIX]   UNSUBSCRIBE and PUNSUBSCRIBE: always provide a reply (see 742e580)
-* [BUGFIX]   Lua struct library was broken, upgraded.
-* [BUGFIX]   Fix a bug in srandmemberWithCountCommand() with count argument.
-* [BUGFIX]   Test: disable clients timeout to prevent issues on slow systems.
-* [BUGFIX]   Sentinel: don't advertise the promoted slave as master too early.
-* [IMPROVED] Whitelist SIGUSR1, see http://redis.io/topics/signals.
-* [IMPROVED] Simpler to understand redis-cli --bigkeys output.
-* [IMPROVED] Test now works with tclsh > 8.5.
-* [IMPROVED] Added option to turn of the Nagle algorithm in slave socket.
-* [IMPROVED] Optionally use SO_KEEPALIVE to detect dead peers.
-
---[ Redis 2.6.9 ]
-
-UPGRADE URGENCY: MODERATE if you use replication.
-
-* [BUGFIX]   Changing master at runtime (SLAVEOF command) in presence of
-             network problems, or in very rapid succession, could result
-             in non-critical problems (GitHub Issue #828).
-* [IMPROVED] CLINGET GETNAME and SETNAME to set and query connection names
-             reported by CLIENT LIST. Very useful for debugging of
-             problems.
-* [IMPROVED] redis-cli is now able to transfer an RDB file from a remote
-             server to a local file using the --rdb <filename> command
-             line option.
-
---[ Redis 2.6.8 ]
-
-UPGRADE URGENCY: MODERATE if you use Lua scripting. Otherwise LOW.
-
-* [BUGFIX]   Multiple fixes for EVAL (issue #872).
-* [BUGFIX]   Fix overflow in mstime() in redis-cli and benchmark.
-* [BUGFIX]   Fix Linux / PPC64 behavior by correcting endianess detection.
-* [BUGFIX]   Fix NetBSD build by defining _XOPEN_SOURCE appropriately.
-* [BUGFIX]   Added missing license and copyright in a few places.
-* [BUGFIX]   Better error reporting when fd event creation fails.
-
---[ Redis 2.6.7 ]
-
-UPGRADE URGENCY: MODERATE (unless you BLPOP using the same key multiple times).
-
-* [BUGFIX]   Don't crash if BLPOP & co are called with the same key repeated
-             multiple times (Issue #801).
-
---[ Redis 2.6.6 ]
-
-UPGRADE URGENCY: CRITICAL if you experienced one more more crashes.
-                 MODERATE if Redis is running fine for you.
-
-* [BUGFIX]   Jemalloc updated to 3.2.0.
-
---[ Redis 2.6.5 ]
-
-UPGRADE URGENCY: MODERATE
-
-Warning: this release of Redis introduces a different behavior in MULTI/EXEC
-         handling of errors. This was done because the new behavior is safer
-         compared to the old one, and should not break any code targeting
-         Redis 2.6 in a critical way.
-
-         For more information check http://redis.io/topics/transactions
-
-* [IMPROVED] RDB/AOF childern now log amount of additional memory used
-             because of copy on write.
-* [BUGFIX]   MIGRATE non critical fixes (see commits for details).
-* [BUGFIX]   MULTI/EXEC: now EXEC aborts on errors before EXEC.
-* [BUGFIX]   Fix integer overflow in zunionInterGenericCommand resulting
-             into Z[INTER|UNION][STORE] commands to crash under extremely
-             unlikely conditions (almost impossible in real world).
-* [BUGFIX]   EVALSHA is now case insensitive (and will not crash).
-
---[ Redis 2.6.4 ]
-
-UPGRADE URGENCY: LOW
-
-* [IMPROVED] BSD license and copyright notice added to every .c and .h file.
-
---[ Redis 2.6.2 ]
-
-UPGRADE URGENCY: LOW
-
-* [BUGFIX]   The compilation fix for RHLE5 in 2.6.1 was broken. Fixed.
-* [IMPROVED] Linenoise updated, now supports Ctrl+w.
-
----[ Redis 2.6.1 ]
-
-UPGRADE URGENCY: LOW
-
-* [BUGFIX]   Compilation on Linux < 2.6.17 or glibc < 2.6 fixed (RHLE5 & co).
-
----[ Redis 2.6.0 ]
-
-UPGRADE URGENCY: HIGH
-
-* [BUGFIX]   Allow AUTH when server is in -BUSY state because of a slow script.
-* [BUGFIX]   MULTI/EXEC flow now makes sense when observed in MONITOR
-* [BUGFIX]   SCRIPT KILL now uses different error prefixes for different errors.
-* [BUGFIX]   Default memory limit for 32bit archs lowered from 3.5 to 3 GB.
-* [BUGFIX]   redis-check-dump is now compatible with RDB files generated by 2.6.
-* [IMPROVED] New field in INFO: slave_read_only.
-
----[ Redis 2.5.14 (2.6 Release Candidate 8) ]
-
-* [BUGFIX]   Fixed compilation on FreeBSD.
-* [IMPROVED] SRANDMEMBER <count> that returns multiple random elements.
-* [IMPROVED] Sentinel backported to 2.6. It will be taken in sync with 2.8.
-* [IMPROVED] Helper function for scripting to return errors and status replies.
-* [IMPROVED] SORT by nosort [ASC|DESC] uses sorted set elements ordering.
-* [BUGFIX]   Better resistence to system clock skew.
-* [IMPROVED] Warn the user when the configured maxmemory seems odd.
-* [BUGFIX]   Hashing function is now murmurhash2 for security purposes.
-* [IMPROVED] Install script no longer uses a template but redis.conf itself.
-
----[ Redis 2.5.13 (2.6 Release Candidate 7) ]
-
-UPGRADE URGENCY: HIGH
-
-* [BUGFIX]   Theoretical bug in ziplist fixed.
-* [BUGFIX]   Better out of memory handling (Log produced in log file).
-* [BUGFIX]   Incrementally flush RDB file on slave side while performing the
-             first synchronization with the master. This makes Redis less
-             blocking in environments where disk I/O is slow.
-* [BUGFIX]   Don't crash with Lua's redis.call() without arguments.
-* [BUGFIX]   Don't crash after a big number of Lua calls on 32 bit systems
-             because of a failed assertion.
-* [BUGFIX]   Fix SORT behaviour when called from scripting.
-* [BUGFIX]   Adjust slave PING period accordingly to REDIS_HZ define.
-* [BUGFIX]   BITCOUNT: fix crash on overflowing arguments.
-* [BUGFIX]   Return an error when SELECT argument is not an integer.
-* [BUGFIX]   Blocking operations on lists were completely reimplemented for
-             correctness. Now blocking list ops and pushes originated from
-             Lua scripts will play well together and will be replicated
-             and transmitted to the AOF correctly.
-* [IMPROVED] Send async PING before starting replication to avoid blocking if
-             master allows us to connect but it is actually not able to reply.
-* [IMPROVED] Support slave-priority for Redis Sentinel.
-* [IMPROVED] Hiredis library updated.
-
----[ Redis 2.5.12 (2.6 Release Candidate 6) ]
-
-UPGRADE URGENCY: MODERATE.
-
-* [BUGFIX]   Fixed a timing attack on AUTH (Issue #560).
-* [BUGFIX]   Don't assume that "char" is signed.
-* [BUGFIX]   Check that we have connection before enabling pipe mode.
-* [BUGFIX]   Use the optimized version of the function to convert a double to
-             its string representation. Compilation was disabled because of
-             a typo in the #if statement.
-* [IMPROVED} REPLCONF internal command introduced, now INFO shows slaves with
-             correct port numbers. This makes 2.5.12 Redis Sentinel compatible.
-* [IMPROVED] Truncate short write from the AOF for a cleaner restart. On short
-             writes (for instance out of space) Redis will now try to remove
-             the half-written data so that the next restart will work without
-             the need for the "redis-check-aof" utility.
-* [IMPROVED] New in INFO: aof_last_bgrewrite_status
-* [IMPROVED] Allow Pub/Sub in contexts where other commands are blocked.
-* [BUGFIX]   mark fd as writable when EPOLLERR or EPOLLHUP is returned by
-             epoll_wait.
-
----[ Redis 2.5.11 (2.6 Release Candidate 5) ]
-
-UPGRADE URGENCY: HIGH.
-
-* [BUGFIX]   Fixed Hash corruption when loading an RDB file generated by
-             previous versions of Redis that encoded hashes using
-             a different ziplist encoding format for small integers.
-             All the fileds that are integers in the range 0-255 may not
-             be recognized, or duplicated un updates, causing a crash
-             when the ziplist is converted to a real hash. (Issue #547).
-* [BUGFIX]   Fixed the count of memory used by output buffers in the
-             setDeferredMultiBulkLength() function.
-
----[ Redis 2.5.10 (2.6 Release Candidate 4) ]
-
-UPGRADE URGENCY: HIGH.
-
-* [BUGFIX]   Allow PREFIX to be overwritten on "make install".
-* [BUGFIX]   Run the test with just one client if the computer is slow.
-* [BUGFIX]   Event port support in our event driven libray.
-* [BUGFIX]   Jemalloc updated to 3.0.0. This fixes a possibly AOF rewrite issue.
-             See https://github.com/antirez/redis/issues/504 for info.
-* [BUGFIX]   Fixed issue #516: ZINTERSTORE / ZUNIONSTORE with mixed sets/zsets.
-* [BUGFIX]   Set fd to writable when poll(2) detects POLLERR or POLLHUP event.
-* [BUGFIX]   Fixed RESTORE hash failure (Issue #532).
-* [IMPROVED] Allow an AOF rewrite buffer > 2GB (Related to issue #504).
-* [IMPROVED] Server cron function frequency is now configurable (REDIS_HZ).
-* [IMPROVED] Better, less blocking expired keys collection algorithm.
-* [FEATURE]  New commands: BITOP and BITCOUNT.
-* [FEATURE]  redis-cli --pipe for mass import.
-
-What's new in Redis 2.5.9 (aka 2.6 Release Candidate 3)
-=======================================================
-
-UPGRADE URGENCY: critical, upgrade ASAP.
-
-* [BUGFIX] Fix for issue #500 (https://github.com/antirez/redis/pull/500).
-           Redis 2.6-RC1 and RC2 may corrupt ziplist-encoded sorted sets
-           produced by Redis 2.4.x.
-* [BUGFIX] Fixed several bugs in init.d script.
-* [BUGFIX] syncio.c functions modified for speed and correctness. On osx
-           (and possibly other BSD-based systems) the slave would block on
-           replication to send the SYNC command when the master was not
-           available. This is fixed now, but was not affecting Linux installs.
-* Now when slave-serve-stale-data is set to yes and the master is down, instead
-  of reporting a generic error Redis replies with -MASTERDOWN.
-
-What's new in Redis 2.5.8 (aka 2.6 Release Candidate 2)
-=======================================================
-
-UPGRADE URGENCY: high for all the users of the KEYS command, otherwise low.
-
-* [BUGFIX] Fix for KEYS command: if the DB contains keys with expires the KEYS
-           command may return the wrong output, having duplicated or missing
-           keys. See issue #487 and #488 on github for details.
-
-What's new in Redis 2.5.7 (aka 2.6 Release Candidate 1)
-=======================================================
-
-UPGRADE URGENCY: upgrade not recommended because this is an RC release.
-
-* This is the first release candidate for Redis 2.6. We are not aware of
-  bugs, but part of this code is young and was never tested in production
-  environments, so handle with care.
-
-An overview of new features and changes in Redis 2.6.x
-======================================================
-
-* Server side Lua scripting, see http://redis.io/commands/eval
-* Virtual Memory removed (was deprecated in 2.4)
-* Hardcoded limits about max number of clients removed.
-* AOF low level semantics is generally more sane, and especially when used
-  in slaves.
-* Milliseconds resolution expires, also added new commands with milliseconds
-  precision (PEXPIRE, PTTL, ...).
-* Better memory usage for "small" lists, ziplists and hashes when fields or
-  values contain small integers.
-* Read only slaves.
-* New bit opeations: BITCOUNT and BITOP commands.
-* Clients max output buffer soft and hard limits. You can specifiy different
-  limits for different classes of clients (normal,pubsub,slave).
-* More incremental (less blocking) expired keys collection algorithm, in
-  practical terms this means that Redis is more responsive when a very
-  big number of keys expire about at the same time.
-* AOF is now able to rewrite aggregate data types using variadic commands,
-  often producing an AOF that is faster to save, load, and is smaller in size.
-* Every redis.conf directive is now accepted as a command line option for the
-  redis-server binary, with the same name and number of arguments.
-* Hash table seed randomization for protection against collisions attacks.
-* Performances improved when writing large objects to Redis.
-* Integrated memory test, see redis-server --test-memory.
-* INCRBYFLOAT and HINCRBYFLOAT commands.
-* New DUMP, RESTORE, MIGRATE commands (back ported from Redis Cluster to 2.6).
-* CRC64 checksump in RDB files.
-* Better MONITOR output and behavior (now commands are logged before execution).
-* "Software Watchdog" feature to debug latency issues.
-* Significant parts of the core refactored or rewritten. New internal APIs
-  and core changes allowed to develop Redis Cluster on top of the new code,
-  however for 2.6 all the cluster code was removed, and will be released with
-  Redis 3.0 when it is more complete and stable.
-* Redis ASCII art logo added at startup.
-* Crash report on memory violation or failed asserts improved significantly
-  to make debugging of hard to catch bugs simpler.
-* redis-benchmark improvements: ability to run selected tests,
-  CSV output, faster, better help.
-* redis-cli improvements: --eval for comfortable development of Lua scripts.
-* SHUTDOWN now supports two optional arguments: "SAVE" and "NOSAVE".
-* INFO output split into sections, the command is now able to just show 
-  pecific sections.
-* New statistics about how many time a command was called, and how much
-  execution time it used (INFO commandstats).
-* More predictable SORT behavior in edge cases.
-* Better support for big endian and *BSD systems.
-* Build system improved.
+--[ Redis 2.8 Release Candidate 2 (2.7.102) ] Release date: 30 Jul 2013
+
+This is the second release candidate of Redis 2.8 (official version is 2.7.102).
+Important bugs fixed inside.
+
+# UPGRADE URGENCY: HIGH
+
+* [FIX] Fixed a critical replication bug, see issue #1221.
+* [NEW] The new inline protocol now accepts quoted strings like, for example
+        you can now type in a telnet session: set 'foo bar' "hello world\n".
+
+--[ Redis 2.8 Release Candidate 1 (2.7.101) ] Release date: 18 Jul 2013
+
+This is the first release candidate of Redis 2.8 (official version is 2.7.101).
+
+The following is a list of improvements in Redis 2.8, compared to Redis 2.6.
+
+* [NEW] Slaves are now able to partially resynchronize with the master, so most
+        of the times a full resynchronization with the RDB creation in the master
+        side is not needed when the master-slave link is disconnected for a short
+        amount of time.
+* [NEW] Experimental IPv6 support.
+* [NEW] Slaves explicitly ping masters now, a master is able to detect a timed out
+        slave independently.
+* [NEW] Masters can stop accepting writes if not enough slaves with a given
+        maximum latency are connected.
+* [NEW] Keyspace changes notifications via Pub/Sub.
+* [NEW] CONFIG SET maxclients is now available.
+* [NEW] Ability to bind multiple IP addresses.
+* [NEW] Set process names so that you can recognize, in the "ps" command output,
+        the listening port of an instance, or if it is a saving child.
+* [NEW] Automatic memory check on crash.
+* [NEW] CONFIG REWRITE is able to materialize the changes in the configuration
+        operated using CONFIG SET into the redis.conf file.
+* [NEW] More NetBSD friendly code base.
+* [NEW] PUBSUB command for Pub/Sub introspection capabilities.
+* [NEW] EVALSHA can now be replicated as such, without requiring to be expanded
+        to a full EVAL for the replication link.
+* [NEW] Better Lua scripts error reporting.
+* [NEW] SDIFF performance improved.
+* [FIX] A number of bugfixes.
 
-Migrating from 2.4 to 2.6
+Migrating from 2.6 to 2.8
 =========================
 
-Redis 2.4 is mostly a strict subset of 2.6. However there are a few things
+Redis 2.6 is mostly a strict subset of 2.8. However there are a few things
 that you should be aware of:
 
-* You can't use .rdb and AOF files generated with 2.6 into a 2.4 instance.
-* 2.6 slaves can be attached to 2.4 masters, but not the contrary, and only
-  for the time needed to perform the version upgrade.
-
-There are also a few API differences, that are unlikely to cause problems,
-but it is better to keep them in mind:
-
-* SORT now will refuse to sort in numerical mode elements that can't be parsed
-  as numbers.
-* EXPIREs now all have millisecond resolution (but this is very unlikely to
-  break code that was not conceived exploting the previous resolution error
-  in some way.)
-* INFO output is a bit different now, and contains empty lines and comments
-  starting with '#'. All the major clients should be already fixed to work
-  with the new INFO format.
-* Slaves are only read-only by default (but you can change this easily
-  setting the "slave-read-only" configuration option to "no" editing your
-  redis.conf or using CONFIG SET.
-
-The following INFO fields were renamed for consistency:
-
-     changes_since_last_save -> rdb_changes_since_last_save
-     bgsave_in_progress -> rdb_bgsave_in_progress
-     last_save_time -> rdb_last_save_time
-     last_bgsave_status -> rdb_last_bgsave_status
-     bgrewriteaof_in_progress -> aof_rewrite_in_progress
-     bgrewriteaof_scheduled -> aof_rewrite_scheduled
+The following commands changed behavior:
+
+    * SORT with ALPHA now sorts according to local collation locale if no STORE
+      option is used.
+    * ZADD/ZINCRBY are now able to accept a bigger range of values as valid
+      scores, that is, all the values you may end having as a result of
+      calling ZINCRBY multiple times.
+    * Many errors are now prefixed by a more specific error code instead of
+      the generic -ERR, for example -WRONGTYPE, -NOAUTH, ...
+    * PUBLISH called inside Lua scripts is now correctly propagated to slaves.
 
 The following redis.conf and CONFIG GET / SET parameters changed:
 
-    * hash-max-zipmap-entries, now replaced by hash-max-ziplist-entries
-    * hash-max-zipmap-value, now replaced by hash-max-ziplist-value
-    * glueoutputbuf option was now completely removed (was deprecated)
+    * logfile now uses the empty string in order to log to standard output,
+      so 'logfile stdout' is now invalid, use 'logfile ""' instead.
+
+The following INFO fields changed format in a non-backward compatible way:
+
+    * The list of slaves in INFO is now in field=value format.
+
+Replication:
+
+    Redis 2.8 can be used as slave for Redis 2.6, but doing this is only
+    a good idea for the short amount of time needed to upgrade your servers.
+    We suggest to update both master and slaves at about the same time.
 
 --------------------------------------------------------------------------------
 
-Credits: Where not specified the implementation and design are done by
-Salvatore Sanfilippo and Pieter Noordhuis. Thanks to VMware for making all
+Credits: Where not specified the implementation and design is done by
+Salvatore Sanfilippo. Thanks to VMware and Pivotal for making all
 this possible. Also many thanks to all the other contributors and the amazing
 community we have.
 
 See commit messages for more credits.
 
 Cheers,
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/async.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/async.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/async.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/async.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/hiredis.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/hiredis.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/hiredis.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/hiredis.c	2013-11-22 17:25:29.000000000 +0800
@@ -647,13 +647,13 @@
     if (r->err)
         return REDIS_ERR;
 
     /* Discard part of the buffer when we've consumed at least 1k, to avoid
      * doing unnecessary calls to memmove() in sds.c. */
     if (r->pos >= 1024) {
-        r->buf = sdsrange(r->buf,r->pos,-1);
+        sdsrange(r->buf,r->pos,-1);
         r->pos = 0;
         r->len = sdslen(r->buf);
     }
 
     /* Emit a reply when there is one. */
     if (r->ridx == -1) {
@@ -1122,13 +1122,13 @@
             }
         } else if (nwritten > 0) {
             if (nwritten == (signed)sdslen(c->obuf)) {
                 sdsfree(c->obuf);
                 c->obuf = sdsempty();
             } else {
-                c->obuf = sdsrange(c->obuf,nwritten,-1);
+                sdsrange(c->obuf,nwritten,-1);
             }
         }
     }
     if (done != NULL) *done = (sdslen(c->obuf) == 0);
     return REDIS_OK;
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/hiredis.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/hiredis.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/hiredis.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/hiredis.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/libhiredis.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/libhiredis.a differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/net.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/net.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/net.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/net.c	2013-11-22 17:25:29.000000000 +0800
@@ -212,15 +212,23 @@
 
     snprintf(_port, 6, "%d", port);
     memset(&hints,0,sizeof(hints));
     hints.ai_family = AF_INET;
     hints.ai_socktype = SOCK_STREAM;
 
+    /* Try with IPv6 if no IPv4 address was found. We do it in this order since
+     * in a Redis client you can't afford to test if you have IPv6 connectivity
+     * as this would add latency to every connect. Otherwise a more sensible
+     * route could be: Use IPv6 if both addresses are available and there is IPv6
+     * connectivity. */
     if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {
-        __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));
-        return REDIS_ERR;
+         hints.ai_family = AF_INET6;
+         if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {
+            __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));
+            return REDIS_ERR;
+        }
     }
     for (p = servinfo; p != NULL; p = p->ai_next) {
         if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
             continue;
 
         if (redisSetBlocking(c,s,0) != REDIS_OK)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/net.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/net.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/net.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/net.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.c	2013-11-22 17:25:29.000000000 +0800
@@ -1,9 +1,9 @@
 /* SDSLib, A C dynamic strings library
  *
- * Copyright (c) 2006-2010, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  *   * Redistributions of source code must retain the above copyright notice,
@@ -29,87 +29,192 @@
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#include <assert.h>
 #include "sds.h"
+#include "zmalloc.h"
 
-#ifdef SDS_ABORT_ON_OOM
-static void sdsOomAbort(void) {
-    fprintf(stderr,"SDS: Out Of Memory (SDS_ABORT_ON_OOM defined)\n");
-    abort();
-}
-#endif
-
+/* Create a new sds string with the content specified by the 'init' pointer
+ * and 'initlen'.
+ * If NULL is used for 'init' the string is initialized with zero bytes.
+ *
+ * The string is always null-termined (all the sds strings are, always) so
+ * even if you create an sds string with:
+ *
+ * mystring = sdsnewlen("abc",3");
+ *
+ * You can print the string with printf() as there is an implicit \0 at the
+ * end of the string. However the string is binary safe and can contain
+ * \0 characters in the middle, as the length is stored in the sds header. */
 sds sdsnewlen(const void *init, size_t initlen) {
     struct sdshdr *sh;
 
-    sh = malloc(sizeof(struct sdshdr)+initlen+1);
-#ifdef SDS_ABORT_ON_OOM
-    if (sh == NULL) sdsOomAbort();
-#else
+    if (init) {
+        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
+    } else {
+        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);
+    }
     if (sh == NULL) return NULL;
-#endif
     sh->len = initlen;
     sh->free = 0;
-    if (initlen) {
-        if (init) memcpy(sh->buf, init, initlen);
-        else memset(sh->buf,0,initlen);
-    }
+    if (initlen && init)
+        memcpy(sh->buf, init, initlen);
     sh->buf[initlen] = '\0';
     return (char*)sh->buf;
 }
 
+/* Create an empty (zero length) sds string. Even in this case the string
+ * always has an implicit null term. */
 sds sdsempty(void) {
     return sdsnewlen("",0);
 }
 
+/* Create a new sds string starting from a null termined C string. */
 sds sdsnew(const char *init) {
     size_t initlen = (init == NULL) ? 0 : strlen(init);
     return sdsnewlen(init, initlen);
 }
 
+/* Duplicate an sds string. */
 sds sdsdup(const sds s) {
     return sdsnewlen(s, sdslen(s));
 }
 
+/* Free an sds string. No operation is performed if 's' is NULL. */
 void sdsfree(sds s) {
     if (s == NULL) return;
-    free(s-sizeof(struct sdshdr));
+    zfree(s-sizeof(struct sdshdr));
 }
 
+/* Set the sds string length to the length as obtained with strlen(), so
+ * considering as content only up to the first null term character.
+ *
+ * This function is useful when the sds string is hacked manually in some
+ * way, like in the following example:
+ *
+ * s = sdsnew("foobar");
+ * s[2] = '\0';
+ * sdsupdatelen(s);
+ * printf("%d\n", sdslen(s));
+ *
+ * The output will be "2", but if we comment out the call to sdsupdatelen()
+ * the output will be "6" as the string was modified but the logical length
+ * remains 6 bytes. */
 void sdsupdatelen(sds s) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     int reallen = strlen(s);
     sh->free += (sh->len-reallen);
     sh->len = reallen;
 }
 
-static sds sdsMakeRoomFor(sds s, size_t addlen) {
+/* Modify an sds string on-place to make it empty (zero length).
+ * However all the existing buffer is not discarded but set as free space
+ * so that next append operations will not require allocations up to the
+ * number of bytes previously available. */
+void sdsclear(sds s) {
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    sh->free += sh->len;
+    sh->len = 0;
+    sh->buf[0] = '\0';
+}
+
+/* Enlarge the free space at the end of the sds string so that the caller
+ * is sure that after calling this function can overwrite up to addlen
+ * bytes after the end of the string, plus one more byte for nul term.
+ * 
+ * Note: this does not change the *length* of the sds string as returned
+ * by sdslen(), but only the free buffer space we have. */
+sds sdsMakeRoomFor(sds s, size_t addlen) {
     struct sdshdr *sh, *newsh;
     size_t free = sdsavail(s);
     size_t len, newlen;
 
     if (free >= addlen) return s;
     len = sdslen(s);
     sh = (void*) (s-(sizeof(struct sdshdr)));
-    newlen = (len+addlen)*2;
-    newsh = realloc(sh, sizeof(struct sdshdr)+newlen+1);
-#ifdef SDS_ABORT_ON_OOM
-    if (newsh == NULL) sdsOomAbort();
-#else
+    newlen = (len+addlen);
+    if (newlen < SDS_MAX_PREALLOC)
+        newlen *= 2;
+    else
+        newlen += SDS_MAX_PREALLOC;
+    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);
     if (newsh == NULL) return NULL;
-#endif
 
     newsh->free = newlen - len;
     return newsh->buf;
 }
 
+/* Reallocate the sds string so that it has no free space at the end. The
+ * contained string remains not altered, but next concatenation operations
+ * will require a reallocation.
+ *
+ * After the call, the passed sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
+sds sdsRemoveFreeSpace(sds s) {
+    struct sdshdr *sh;
+
+    sh = (void*) (s-(sizeof(struct sdshdr)));
+    sh = zrealloc(sh, sizeof(struct sdshdr)+sh->len+1);
+    sh->free = 0;
+    return sh->buf;
+}
+
+/* Return the total size of the allocation of the specifed sds string,
+ * including:
+ * 1) The sds header before the pointer.
+ * 2) The string.
+ * 3) The free buffer at the end if any.
+ * 4) The implicit null term.
+ */
+size_t sdsAllocSize(sds s) {
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+
+    return sizeof(*sh)+sh->len+sh->free+1;
+}
+
+/* Increment the sds length and decrements the left free space at the
+ * end of the string according to 'incr'. Also set the null term
+ * in the new end of the string.
+ *
+ * This function is used in order to fix the string length after the
+ * user calls sdsMakeRoomFor(), writes something after the end of
+ * the current string, and finally needs to set the new length.
+ *
+ * Note: it is possible to use a negative increment in order to
+ * right-trim the string.
+ *
+ * Usage example:
+ *
+ * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the
+ * following schema, to cat bytes coming from the kernel to the end of an
+ * sds string without copying into an intermediate buffer:
+ *
+ * oldlen = sdslen(s);
+ * s = sdsMakeRoomFor(s, BUFFER_SIZE);
+ * nread = read(fd, s+oldlen, BUFFER_SIZE);
+ * ... check for nread <= 0 and handle it ...
+ * sdsIncrLen(s, nread);
+ */
+void sdsIncrLen(sds s, int incr) {
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+
+    assert(sh->free >= incr);
+    sh->len += incr;
+    sh->free -= incr;
+    assert(sh->free >= 0);
+    s[sh->len] = '\0';
+}
+
 /* Grow the sds to have the specified length. Bytes that were not part of
- * the original length of the sds will be set to zero. */
+ * the original length of the sds will be set to zero.
+ *
+ * if the specified length is smaller than the current length, no operation
+ * is performed. */
 sds sdsgrowzero(sds s, size_t len) {
     struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
     size_t totlen, curlen = sh->len;
 
     if (len <= curlen) return s;
     s = sdsMakeRoomFor(s,len-curlen);
@@ -121,12 +226,17 @@
     totlen = sh->len+sh->free;
     sh->len = len;
     sh->free = totlen-sh->len;
     return s;
 }
 
+/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the
+ * end of the specified sds string 's'.
+ *
+ * After the call, the passed sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
 sds sdscatlen(sds s, const void *t, size_t len) {
     struct sdshdr *sh;
     size_t curlen = sdslen(s);
 
     s = sdsMakeRoomFor(s,len);
     if (s == NULL) return NULL;
@@ -135,17 +245,31 @@
     sh->len = curlen+len;
     sh->free = sh->free-len;
     s[curlen+len] = '\0';
     return s;
 }
 
+/* Append the specified null termianted C string to the sds string 's'.
+ *
+ * After the call, the passed sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
 sds sdscat(sds s, const char *t) {
     return sdscatlen(s, t, strlen(t));
 }
 
-sds sdscpylen(sds s, char *t, size_t len) {
+/* Append the specified sds 't' to the existing sds 's'.
+ *
+ * After the call, the modified sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
+sds sdscatsds(sds s, const sds t) {
+    return sdscatlen(s, t, sdslen(t));
+}
+
+/* Destructively modify the sds string 's' to hold the specified binary
+ * safe string pointed by 't' of length 'len' bytes. */
+sds sdscpylen(sds s, const char *t, size_t len) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     size_t totlen = sh->free+sh->len;
 
     if (totlen < len) {
         s = sdsMakeRoomFor(s,len-sh->len);
         if (s == NULL) return NULL;
@@ -156,52 +280,81 @@
     s[len] = '\0';
     sh->len = len;
     sh->free = totlen-len;
     return s;
 }
 
-sds sdscpy(sds s, char *t) {
+/* Like sdscpylen() but 't' must be a null-termined string so that the length
+ * of the string is obtained with strlen(). */
+sds sdscpy(sds s, const char *t) {
     return sdscpylen(s, t, strlen(t));
 }
 
+/* Like sdscatpritf() but gets va_list instead of being variadic. */
 sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
     va_list cpy;
     char *buf, *t;
     size_t buflen = 16;
 
     while(1) {
-        buf = malloc(buflen);
-#ifdef SDS_ABORT_ON_OOM
-        if (buf == NULL) sdsOomAbort();
-#else
+        buf = zmalloc(buflen);
         if (buf == NULL) return NULL;
-#endif
         buf[buflen-2] = '\0';
         va_copy(cpy,ap);
         vsnprintf(buf, buflen, fmt, cpy);
         if (buf[buflen-2] != '\0') {
-            free(buf);
+            zfree(buf);
             buflen *= 2;
             continue;
         }
         break;
     }
     t = sdscat(s, buf);
-    free(buf);
+    zfree(buf);
     return t;
 }
 
+/* Append to the sds string 's' a string obtained using printf-alike format
+ * specifier.
+ *
+ * After the call, the modified sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call.
+ *
+ * Example:
+ *
+ * s = sdsempty("Sum is: ");
+ * s = sdscatprintf(s,"%d+%d = %d",a,b,a+b).
+ *
+ * Often you need to create a string from scratch with the printf-alike
+ * format. When this is the need, just use sdsempty() as the target string:
+ *
+ * s = sdscatprintf(sdsempty(), "... your format ...", args);
+ */
 sds sdscatprintf(sds s, const char *fmt, ...) {
     va_list ap;
     char *t;
     va_start(ap, fmt);
     t = sdscatvprintf(s,fmt,ap);
     va_end(ap);
     return t;
 }
 
+/* Remove the part of the string from left and from right composed just of
+ * contiguous characters found in 'cset', that is a null terminted C string.
+ *
+ * After the call, the modified sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call.
+ *
+ * Example:
+ *
+ * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");
+ * s = sdstrim(s,"A. :");
+ * printf("%s\n", s);
+ *
+ * Output will be just "Hello World".
+ */
 sds sdstrim(sds s, const char *cset) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     char *start, *end, *sp, *ep;
     size_t len;
 
     sp = start = s;
@@ -213,17 +366,33 @@
     sh->buf[len] = '\0';
     sh->free = sh->free+(sh->len-len);
     sh->len = len;
     return s;
 }
 
-sds sdsrange(sds s, int start, int end) {
+/* Turn the string into a smaller (or equal) string containing only the
+ * substring specified by the 'start' and 'end' indexes.
+ *
+ * start and end can be negative, where -1 means the last character of the
+ * string, -2 the penultimate character, and so forth.
+ *
+ * The interval is inclusive, so the start and end characters will be part
+ * of the resulting string.
+ *
+ * The string is modified in-place.
+ *
+ * Example:
+ *
+ * s = sdsnew("Hello World");
+ * sdstrim(s,1,-1); => "ello Worl"
+ */
+void sdsrange(sds s, int start, int end) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     size_t newlen, len = sdslen(s);
 
-    if (len == 0) return s;
+    if (len == 0) return;
     if (start < 0) {
         start = len+start;
         if (start < 0) start = 0;
     }
     if (end < 0) {
         end = len+end;
@@ -241,28 +410,40 @@
         start = 0;
     }
     if (start && newlen) memmove(sh->buf, sh->buf+start, newlen);
     sh->buf[newlen] = 0;
     sh->free = sh->free+(sh->len-newlen);
     sh->len = newlen;
-    return s;
 }
 
+/* Apply tolower() to every character of the sds string 's'. */
 void sdstolower(sds s) {
     int len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = tolower(s[j]);
 }
 
+/* Apply toupper() to every character of the sds string 's'. */
 void sdstoupper(sds s) {
     int len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = toupper(s[j]);
 }
 
-int sdscmp(sds s1, sds s2) {
+/* Compare two sds strings s1 and s2 with memcmp().
+ *
+ * Return value:
+ *
+ *     1 if s1 > s2.
+ *    -1 if s1 < s2.
+ *     0 if s1 and s2 are exactly the same binary string.
+ *
+ * If two strings share exactly the same prefix, but one of the two has
+ * additional characters, the longer string is considered to be greater than
+ * the smaller one. */
+int sdscmp(const sds s1, const sds s2) {
     size_t l1, l2, minlen;
     int cmp;
 
     l1 = sdslen(s1);
     l2 = sdslen(s2);
     minlen = (l1 < l2) ? l1 : l2;
@@ -284,86 +465,73 @@
  * elements "foo" and "bar".
  *
  * This version of the function is binary-safe but
  * requires length arguments. sdssplit() is just the
  * same function but for zero-terminated strings.
  */
-sds *sdssplitlen(char *s, int len, char *sep, int seplen, int *count) {
+sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {
     int elements = 0, slots = 5, start = 0, j;
+    sds *tokens;
+
+    if (seplen < 1 || len < 0) return NULL;
+
+    tokens = zmalloc(sizeof(sds)*slots);
+    if (tokens == NULL) return NULL;
 
-    sds *tokens = malloc(sizeof(sds)*slots);
-#ifdef SDS_ABORT_ON_OOM
-    if (tokens == NULL) sdsOomAbort();
-#endif
-    if (seplen < 1 || len < 0 || tokens == NULL) return NULL;
     if (len == 0) {
         *count = 0;
         return tokens;
     }
     for (j = 0; j < (len-(seplen-1)); j++) {
         /* make sure there is room for the next element and the final one */
         if (slots < elements+2) {
             sds *newtokens;
 
             slots *= 2;
-            newtokens = realloc(tokens,sizeof(sds)*slots);
-            if (newtokens == NULL) {
-#ifdef SDS_ABORT_ON_OOM
-                sdsOomAbort();
-#else
-                goto cleanup;
-#endif
-            }
+            newtokens = zrealloc(tokens,sizeof(sds)*slots);
+            if (newtokens == NULL) goto cleanup;
             tokens = newtokens;
         }
         /* search the separator */
         if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
             tokens[elements] = sdsnewlen(s+start,j-start);
-            if (tokens[elements] == NULL) {
-#ifdef SDS_ABORT_ON_OOM
-                sdsOomAbort();
-#else
-                goto cleanup;
-#endif
-            }
+            if (tokens[elements] == NULL) goto cleanup;
             elements++;
             start = j+seplen;
             j = j+seplen-1; /* skip the separator */
         }
     }
     /* Add the final element. We are sure there is room in the tokens array. */
     tokens[elements] = sdsnewlen(s+start,len-start);
-    if (tokens[elements] == NULL) {
-#ifdef SDS_ABORT_ON_OOM
-                sdsOomAbort();
-#else
-                goto cleanup;
-#endif
-    }
+    if (tokens[elements] == NULL) goto cleanup;
     elements++;
     *count = elements;
     return tokens;
 
-#ifndef SDS_ABORT_ON_OOM
 cleanup:
     {
         int i;
         for (i = 0; i < elements; i++) sdsfree(tokens[i]);
-        free(tokens);
+        zfree(tokens);
+        *count = 0;
         return NULL;
     }
-#endif
 }
 
+/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */
 void sdsfreesplitres(sds *tokens, int count) {
     if (!tokens) return;
     while(count--)
         sdsfree(tokens[count]);
-    free(tokens);
+    zfree(tokens);
 }
 
+/* Create an sds string from a long long value. It is much faster than:
+ *
+ * sdscatprintf(sdsempty(),"%lld\n", value);
+ */
 sds sdsfromlonglong(long long value) {
     char buf[32], *p;
     unsigned long long v;
 
     v = (value < 0) ? -value : value;
     p = buf+31; /* point to the last character */
@@ -373,16 +541,20 @@
     } while(v);
     if (value < 0) *p-- = '-';
     p++;
     return sdsnewlen(p,32-(p-buf));
 }
 
-sds sdscatrepr(sds s, char *p, size_t len) {
+/* Append to the sds string "s" an escaped string representation where
+ * all the non-printable characters (tested with isprint()) are turned into
+ * escapes in the form "\n\r\a...." or "\x<hex-number>".
+ *
+ * After the call, the modified sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
+sds sdscatrepr(sds s, const char *p, size_t len) {
     s = sdscatlen(s,"\"",1);
-    if (s == NULL) return NULL;
-
     while(len--) {
         switch(*p) {
         case '\\':
         case '"':
             s = sdscatprintf(s,"\\%c",*p);
             break;
@@ -396,51 +568,95 @@
                 s = sdscatprintf(s,"%c",*p);
             else
                 s = sdscatprintf(s,"\\x%02x",(unsigned char)*p);
             break;
         }
         p++;
-        if (s == NULL) return NULL;
     }
     return sdscatlen(s,"\"",1);
 }
 
+/* Helper function for sdssplitargs() that returns non zero if 'c'
+ * is a valid hex digit. */
+int is_hex_digit(char c) {
+    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||
+           (c >= 'A' && c <= 'F');
+}
+
+/* Helper function for sdssplitargs() that converts an hex digit into an
+ * integer from 0 to 15 */
+int hex_digit_to_int(char c) {
+    switch(c) {
+    case '0': return 0;
+    case '1': return 1;
+    case '2': return 2;
+    case '3': return 3;
+    case '4': return 4;
+    case '5': return 5;
+    case '6': return 6;
+    case '7': return 7;
+    case '8': return 8;
+    case '9': return 9;
+    case 'a': case 'A': return 10;
+    case 'b': case 'B': return 11;
+    case 'c': case 'C': return 12;
+    case 'd': case 'D': return 13;
+    case 'e': case 'E': return 14;
+    case 'f': case 'F': return 15;
+    default: return 0;
+    }
+}
+
 /* Split a line into arguments, where every argument can be in the
  * following programming-language REPL-alike form:
  *
  * foo bar "newline are supported\n" and "\xff\x00otherstuff"
  *
  * The number of arguments is stored into *argc, and an array
- * of sds is returned. The caller should sdsfree() all the returned
- * strings and finally free() the array itself.
+ * of sds is returned.
+ *
+ * The caller should free the resulting array of sds strings with
+ * sdsfreesplitres().
  *
  * Note that sdscatrepr() is able to convert back a string into
  * a quoted string in the same format sdssplitargs() is able to parse.
+ *
+ * The function returns the allocated tokens on success, even when the
+ * input string is empty, or NULL if the input contains unbalanced
+ * quotes or closed quotes followed by non space characters
+ * as in: "foo"bar or "foo'
  */
-sds *sdssplitargs(char *line, int *argc) {
-    char *p = line;
+sds *sdssplitargs(const char *line, int *argc) {
+    const char *p = line;
     char *current = NULL;
-    char **vector = NULL, **_vector = NULL;
+    char **vector = NULL;
 
     *argc = 0;
     while(1) {
         /* skip blanks */
         while(*p && isspace(*p)) p++;
         if (*p) {
             /* get a token */
-            int inq=0; /* set to 1 if we are in "quotes" */
+            int inq=0;  /* set to 1 if we are in "quotes" */
+            int insq=0; /* set to 1 if we are in 'single quotes' */
             int done=0;
 
-            if (current == NULL) {
-                current = sdsempty();
-                if (current == NULL) goto err;
-            }
-
+            if (current == NULL) current = sdsempty();
             while(!done) {
                 if (inq) {
-                    if (*p == '\\' && *(p+1)) {
+                    if (*p == '\\' && *(p+1) == 'x' &&
+                                             is_hex_digit(*(p+2)) &&
+                                             is_hex_digit(*(p+3)))
+                    {
+                        unsigned char byte;
+
+                        byte = (hex_digit_to_int(*(p+2))*16)+
+                                hex_digit_to_int(*(p+3));
+                        current = sdscatlen(current,(char*)&byte,1);
+                        p += 3;
+                    } else if (*p == '\\' && *(p+1)) {
                         char c;
 
                         p++;
                         switch(*p) {
                         case 'n': c = '\n'; break;
                         case 'r': c = '\r'; break;
@@ -448,13 +664,29 @@
                         case 'b': c = '\b'; break;
                         case 'a': c = '\a'; break;
                         default: c = *p; break;
                         }
                         current = sdscatlen(current,&c,1);
                     } else if (*p == '"') {
-                        /* closing quote must be followed by a space */
+                        /* closing quote must be followed by a space or
+                         * nothing at all. */
+                        if (*(p+1) && !isspace(*(p+1))) goto err;
+                        done=1;
+                    } else if (!*p) {
+                        /* unterminated quotes */
+                        goto err;
+                    } else {
+                        current = sdscatlen(current,p,1);
+                    }
+                } else if (insq) {
+                    if (*p == '\\' && *(p+1) == '\'') {
+                        p++;
+                        current = sdscatlen(current,"'",1);
+                    } else if (*p == '\'') {
+                        /* closing quote must be followed by a space or
+                         * nothing at all. */
                         if (*(p+1) && !isspace(*(p+1))) goto err;
                         done=1;
                     } else if (!*p) {
                         /* unterminated quotes */
                         goto err;
                     } else {
@@ -469,60 +701,86 @@
                     case '\0':
                         done=1;
                         break;
                     case '"':
                         inq=1;
                         break;
+                    case '\'':
+                        insq=1;
+                        break;
                     default:
                         current = sdscatlen(current,p,1);
                         break;
                     }
                 }
                 if (*p) p++;
-                if (current == NULL) goto err;
             }
             /* add the token to the vector */
-            _vector = realloc(vector,((*argc)+1)*sizeof(char*));
-            if (_vector == NULL) goto err;
-
-            vector = _vector;
+            vector = zrealloc(vector,((*argc)+1)*sizeof(char*));
             vector[*argc] = current;
             (*argc)++;
             current = NULL;
         } else {
+            /* Even on empty input string return something not NULL. */
+            if (vector == NULL) vector = zmalloc(sizeof(void*));
             return vector;
         }
     }
 
 err:
     while((*argc)--)
         sdsfree(vector[*argc]);
-    if (vector != NULL) free(vector);
-    if (current != NULL) sdsfree(current);
+    zfree(vector);
+    if (current) sdsfree(current);
+    *argc = 0;
     return NULL;
 }
 
+/* Modify the string substituting all the occurrences of the set of
+ * characters specified in the 'from' string to the corresponding character
+ * in the 'to' array.
+ *
+ * For instance: sdsmapchars(mystring, "ho", "01", 2)
+ * will have the effect of turning the string "hello" into "0ell1".
+ *
+ * The function returns the sds string pointer, that is always the same
+ * as the input pointer since no resize is needed. */
+sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
+    size_t j, i, l = sdslen(s);
+
+    for (j = 0; j < l; j++) {
+        for (i = 0; i < setlen; i++) {
+            if (s[j] == from[i]) {
+                s[j] = to[i];
+                break;
+            }
+        }
+    }
+    return s;
+}
+
+/* Join an array of C strings using the specified separator (also a C string).
+ * Returns the result as an sds string. */
+sds sdsjoin(char **argv, int argc, char *sep) {
+    sds join = sdsempty();
+    int j;
+
+    for (j = 0; j < argc; j++) {
+        join = sdscat(join, argv[j]);
+        if (j != argc-1) join = sdscat(join,sep);
+    }
+    return join;
+}
+
 #ifdef SDS_TEST_MAIN
 #include <stdio.h>
-
-int __failed_tests = 0;
-int __test_num = 0;
-#define test_cond(descr,_c) do { \
-    __test_num++; printf("%d - %s: ", __test_num, descr); \
-    if(_c) printf("PASSED\n"); else {printf("FAILED\n"); __failed_tests++;} \
-} while(0);
-#define test_report() do { \
-    printf("%d tests, %d passed, %d failed\n", __test_num, \
-                    __test_num-__failed_tests, __failed_tests); \
-    if (__failed_tests) { \
-        printf("=== WARNING === We have failed tests here...\n"); \
-    } \
-} while(0);
+#include "testhelp.h"
 
 int main(void) {
     {
+        struct sdshdr *sh;
         sds x = sdsnew("foo"), y;
 
         test_cond("Create a string and obtain the length",
             sdslen(x) == 3 && memcmp(x,"foo\0",4) == 0)
 
         sdsfree(x);
@@ -596,10 +854,29 @@
 
         sdsfree(y);
         sdsfree(x);
         x = sdsnew("aar");
         y = sdsnew("bar");
         test_cond("sdscmp(bar,bar)", sdscmp(x,y) < 0)
+
+        {
+            int oldfree;
+
+            sdsfree(x);
+            x = sdsnew("0");
+            sh = (void*) (x-(sizeof(struct sdshdr)));
+            test_cond("sdsnew() free/len buffers", sh->len == 1 && sh->free == 0);
+            x = sdsMakeRoomFor(x,1);
+            sh = (void*) (x-(sizeof(struct sdshdr)));
+            test_cond("sdsMakeRoomFor()", sh->len == 1 && sh->free > 0);
+            oldfree = sh->free;
+            x[1] = '1';
+            sdsIncrLen(x,1);
+            test_cond("sdsIncrLen() -- content", x[0] == '0' && x[1] == '1');
+            test_cond("sdsIncrLen() -- len", sh->len == 2);
+            test_cond("sdsIncrLen() -- free", sh->free == oldfree-1);
+        }
     }
     test_report()
+    return 0;
 }
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.h	2013-11-22 17:25:29.000000000 +0800
@@ -28,12 +28,14 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __SDS_H
 #define __SDS_H
 
+#define SDS_MAX_PREALLOC (1024*1024)
+
 #include <sys/types.h>
 #include <stdarg.h>
 
 typedef char *sds;
 
 struct sdshdr {
@@ -55,34 +57,44 @@
 sds sdsnewlen(const void *init, size_t initlen);
 sds sdsnew(const char *init);
 sds sdsempty(void);
 size_t sdslen(const sds s);
 sds sdsdup(const sds s);
 void sdsfree(sds s);
-size_t sdsavail(sds s);
+size_t sdsavail(const sds s);
 sds sdsgrowzero(sds s, size_t len);
 sds sdscatlen(sds s, const void *t, size_t len);
 sds sdscat(sds s, const char *t);
-sds sdscpylen(sds s, char *t, size_t len);
-sds sdscpy(sds s, char *t);
+sds sdscatsds(sds s, const sds t);
+sds sdscpylen(sds s, const char *t, size_t len);
+sds sdscpy(sds s, const char *t);
 
 sds sdscatvprintf(sds s, const char *fmt, va_list ap);
 #ifdef __GNUC__
 sds sdscatprintf(sds s, const char *fmt, ...)
     __attribute__((format(printf, 2, 3)));
 #else
 sds sdscatprintf(sds s, const char *fmt, ...);
 #endif
 
 sds sdstrim(sds s, const char *cset);
-sds sdsrange(sds s, int start, int end);
+void sdsrange(sds s, int start, int end);
 void sdsupdatelen(sds s);
-int sdscmp(sds s1, sds s2);
-sds *sdssplitlen(char *s, int len, char *sep, int seplen, int *count);
+void sdsclear(sds s);
+int sdscmp(const sds s1, const sds s2);
+sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);
 void sdsfreesplitres(sds *tokens, int count);
 void sdstolower(sds s);
 void sdstoupper(sds s);
 sds sdsfromlonglong(long long value);
-sds sdscatrepr(sds s, char *p, size_t len);
-sds *sdssplitargs(char *line, int *argc);
+sds sdscatrepr(sds s, const char *p, size_t len);
+sds *sdssplitargs(const char *line, int *argc);
+sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);
+sds sdsjoin(char **argv, int argc, char *sep);
+
+/* Low level functions exposed to the user API */
+sds sdsMakeRoomFor(sds s, size_t addlen);
+void sdsIncrLen(sds s, int incr);
+sds sdsRemoveFreeSpace(sds s);
+size_t sdsAllocSize(sds s);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis: zmalloc.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/config.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/config.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/config.log	2017-09-27 22:05:56.451055712 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/config.log	2017-09-27 22:07:04.687053211 +0800
@@ -520,14 +520,14 @@
 configure:6048: checking for pthread_create in -lpthread
 configure:6073: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lpthread   -lm >&5
 configure:6073: $? = 0
 configure:6082: result: yes
 configure:6151: checking for _malloc_thread_cleanup
 configure:6151: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lm -lpthread >&5
-/tmp/ccfmRwNA.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c:101: undefined reference to `_malloc_thread_cleanup'
+/tmp/ccxqUfHP.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c:101: undefined reference to `_malloc_thread_cleanup'
 collect2: error: ld returned 1 exit status
 configure:6151: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
@@ -632,14 +632,14 @@
 |   ;
 |   return 0;
 | }
 configure:6151: result: no
 configure:6165: checking for _pthread_mutex_init_calloc_cb
 configure:6165: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lm -lpthread >&5
-/tmp/ccaNOJyD.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c:101: undefined reference to `_pthread_mutex_init_calloc_cb'
+/tmp/ccqB0XrR.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c:101: undefined reference to `_pthread_mutex_init_calloc_cb'
 collect2: error: ld returned 1 exit status
 configure:6165: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
@@ -1441,15 +1441,15 @@
 configure:8207: result: INCLUDEDIR         : /usr/local/include
 configure:8209: result: LIBDIR             : /usr/local/lib
 configure:8211: result: DATADIR            : /usr/local/share
 configure:8213: result: MANDIR             : /usr/local/share/man
 configure:8215: result: 
 configure:8217: result: srcroot            : 
-configure:8219: result: abs_srcroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/
+configure:8219: result: abs_srcroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/
 configure:8221: result: objroot            : 
-configure:8223: result: abs_objroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/
+configure:8223: result: abs_objroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/
 configure:8225: result: 
 configure:8227: result: JEMALLOC_PREFIX    : je_
 configure:8229: result: JEMALLOC_PRIVATE_NAMESPACE
 configure:8231: result:                    : 
 configure:8233: result: install_suffix     : 
 configure:8235: result: autogen            : 0
@@ -1600,14 +1600,14 @@
 SHELL='/bin/bash'
 SOREV='so.1'
 XSLROOT='/usr/share/xml/docbook/stylesheet/docbook-xsl'
 XSLTPROC='/opt/anaconda2/bin/xsltproc'
 a='a'
 abi='elf'
-abs_objroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/'
-abs_srcroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/'
+abs_objroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/'
+abs_srcroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/'
 ac_ct_CC='gcc'
 bindir='${exec_prefix}/bin'
 build='x86_64-unknown-linux-gnu'
 build_alias=''
 build_cpu='x86_64'
 build_os='linux-gnu'
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/config.status /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/config.status
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/config.status	2017-09-27 22:05:56.255055719 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/config.status	2017-09-27 22:07:04.543053217 +0800
@@ -446,13 +446,13 @@
   with options \"$ac_cs_config\"
 
 Copyright (C) 2010 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
-ac_pwd='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc'
+ac_pwd='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc'
 srcdir='.'
 INSTALL='/usr/bin/install -c'
 test -n "$AWK" || AWK=awk
 # The default lists apply if the user does not specify any file.
 ac_need_defaults=:
 while test $# != 0
@@ -699,15 +699,15 @@
 S["MANDIR"]="/usr/local/share/man"
 S["DATADIR"]="/usr/local/share"
 S["LIBDIR"]="/usr/local/lib"
 S["INCLUDEDIR"]="/usr/local/include"
 S["BINDIR"]="/usr/local/bin"
 S["PREFIX"]="/usr/local"
-S["abs_objroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/"
+S["abs_objroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/"
 S["objroot"]=""
-S["abs_srcroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/"
+S["abs_srcroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/"
 S["srcroot"]=""
 S["rev"]="1"
 S["target_alias"]=""
 S["host_alias"]=""
 S["build_alias"]=""
 S["LIBS"]=" -lm -lpthread"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/doc/html.xsl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/doc/html.xsl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/doc/html.xsl	2017-09-27 22:05:56.311055717 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/doc/html.xsl	2017-09-27 22:07:04.583053215 +0800
@@ -1,4 +1,4 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:import href="/usr/share/xml/docbook/stylesheet/docbook-xsl/html/docbook.xsl"/>
-  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/doc/stylesheet.xsl"/>
+  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/doc/stylesheet.xsl"/>
 </xsl:stylesheet>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/doc/manpages.xsl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/doc/manpages.xsl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/doc/manpages.xsl	2017-09-27 22:05:56.323055717 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/doc/manpages.xsl	2017-09-27 22:07:04.591053215 +0800
@@ -1,4 +1,4 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:import href="/usr/share/xml/docbook/stylesheet/docbook-xsl/manpages/docbook.xsl"/>
-  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/doc/stylesheet.xsl"/>
+  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/doc/stylesheet.xsl"/>
 </xsl:stylesheet>
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/lib/libjemalloc.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/lib/libjemalloc.a differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/Makefile	2017-09-27 22:05:56.299055718 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/Makefile	2017-09-27 22:07:04.571053216 +0800
@@ -16,14 +16,14 @@
 INCLUDEDIR := $(DESTDIR)/usr/local/include
 LIBDIR := $(DESTDIR)/usr/local/lib
 DATADIR := $(DESTDIR)/usr/local/share
 MANDIR := $(DESTDIR)/usr/local/share/man
 srcroot := 
 objroot := 
-abs_srcroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/
-abs_objroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/
+abs_srcroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/
+abs_objroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/
 
 # Build parameters.
 CPPFLAGS :=  -D_GNU_SOURCE -D_REENTRANT -I$(srcroot)include -I$(objroot)include
 CFLAGS := -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden
 LDFLAGS := 
 EXTRA_LDFLAGS := 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/arena.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/arena.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/arena.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/arena.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/atomic.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/atomic.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/atomic.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/atomic.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/base.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/base.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/base.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/base.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/bitmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/bitmap.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/bitmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/bitmap.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_dss.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_dss.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_dss.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_dss.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_mmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_mmap.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_mmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_mmap.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ckh.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ckh.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ckh.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ckh.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ctl.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ctl.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ctl.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ctl.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/extent.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/extent.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/extent.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/extent.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/hash.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/hash.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/hash.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/hash.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/huge.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/huge.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/huge.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/huge.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/jemalloc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/jemalloc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/jemalloc.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/jemalloc.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mb.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mb.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mutex.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mutex.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mutex.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mutex.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/prof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/prof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/prof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/prof.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/quarantine.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/quarantine.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/quarantine.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/quarantine.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/rtree.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/rtree.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/rtree.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/rtree.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/stats.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/stats.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/stats.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/stats.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tcache.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tcache.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tcache.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tcache.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tsd.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tsd.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tsd.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tsd.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/util.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/util.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/util.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/util.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/linenoise/linenoise.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/linenoise/linenoise.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/linenoise/linenoise.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/linenoise/linenoise.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lapi.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lapi.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lauxlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lauxlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lbaselib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lbaselib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lcode.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lcode.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldblib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldblib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldebug.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldebug.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldo.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldo.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldump.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldump.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lfunc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lfunc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lgc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lgc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/liblua.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/liblua.a differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/linit.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/linit.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/liolib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/liolib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/llex.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/llex.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmathlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmathlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmem.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmem.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loadlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loadlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lobject.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lobject.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lopcodes.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lopcodes.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loslib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loslib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lparser.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lparser.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstate.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstate.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstring.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstring.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstrlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstrlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltable.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltable.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltablib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltablib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltm.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltm.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/luac.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/luac.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cjson.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cjson.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cmsgpack.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cmsgpack.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_struct.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_struct.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lundump.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lundump.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lvm.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lvm.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lzio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lzio.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/Makefile	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/Makefile	2013-11-22 17:25:29.000000000 +0800
@@ -4,13 +4,13 @@
 
 # == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================
 
 # Your platform. See PLATS for possible values.
 PLAT= none
 
-CC= gcc
+CC?= gcc
 CFLAGS= -O2 -Wall $(MYCFLAGS)
 AR= ar rcu
 RANLIB= ranlib
 RM= rm -f
 LIBS= -lm $(MYLIBS)
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/print.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/print.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/strbuf.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/strbuf.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/Makefile	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/Makefile	2013-11-22 17:25:29.000000000 +0800
@@ -51,14 +51,14 @@
 	@printf '%b %b\n' $(MAKECOLOR)MAKE$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR)
 	cd linenoise && $(MAKE)
 
 .PHONY: linenoise
 
 ifeq ($(uname_S),SunOS)
-  # Make isinf() available
-  LUA_CFLAGS= -D__C99FEATURES__=1
+	# Make isinf() available
+	LUA_CFLAGS= -D__C99FEATURES__=1
 endif
 
 LUA_CFLAGS+= -O2 -Wall -DLUA_ANSI $(CFLAGS)
 LUA_LDFLAGS+= $(LDFLAGS)
 
 lua: .make-prerequisites
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/redis.conf /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/redis.conf
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/redis.conf	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/redis.conf	2013-11-22 17:25:29.000000000 +0800
@@ -21,15 +21,20 @@
 pidfile /var/run/redis.pid
 
 # Accept connections on the specified port, default is 6379.
 # If port 0 is specified Redis will not listen on a TCP socket.
 port 6379
 
-# If you want you can bind a single interface, if the bind option is not
-# specified all the interfaces will listen for incoming connections.
+# By default Redis listens for connections from all the network interfaces
+# available on the server. It is possible to listen to just one or multiple
+# interfaces using the "bind" configuration directive, followed by one or
+# more IP addresses.
 #
+# Examples:
+#
+# bind 192.168.1.100 10.0.0.1
 # bind 127.0.0.1
 
 # Specify the path for the unix socket that will be used to listen for
 # incoming connections. There is no default, so Redis will not listen
 # on a unix socket when not specified.
 #
@@ -60,16 +65,16 @@
 # debug (a lot of information, useful for development/testing)
 # verbose (many rarely useful info, but not a mess like the debug level)
 # notice (moderately verbose, what you want in production probably)
 # warning (only very important / critical messages are logged)
 loglevel notice
 
-# Specify the log file name. Also 'stdout' can be used to force
+# Specify the log file name. Also the emptry string can be used to force
 # Redis to log on the standard output. Note that if you use standard
 # output for logging but daemonize, logs will be sent to /dev/null
-logfile stdout
+logfile ""
 
 # To enable logging to the system logger, just set 'syslog-enabled' to yes,
 # and optionally update the other syslog parameters to suit your needs.
 # syslog-enabled no
 
 # Specify the syslog identity.
@@ -200,14 +205,17 @@
 # Slaves send PINGs to server in a predefined interval. It's possible to change
 # this interval with the repl_ping_slave_period option. The default value is 10
 # seconds.
 #
 # repl-ping-slave-period 10
 
-# The following option sets a timeout for both Bulk transfer I/O timeout and
-# master data or ping response timeout. The default value is 60 seconds.
+# The following option sets the replication timeout for:
+#
+# 1) Bulk transfer I/O during SYNC, from the point of view of slave.
+# 2) Master timeout from the point of view of slaves (data, pings).
+# 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).
 #
 # It is important to make sure that this value is greater than the value
 # specified for repl-ping-slave-period otherwise a timeout will be detected
 # every time there is low traffic between the master and the slave.
 #
 # repl-timeout 60
@@ -224,12 +232,34 @@
 #
 # By default we optimize for low latency, but in very high traffic conditions
 # or when the master and slaves are many hops away, turning this to "yes" may
 # be a good idea.
 repl-disable-tcp-nodelay no
 
+# Set the replication backlog size. The backlog is a buffer that accumulates
+# slave data when slaves are disconnected for some time, so that when a slave
+# wants to reconnect again, often a full resync is not needed, but a partial
+# resync is enough, just passing the portion of data the slave missed while
+# disconnected.
+#
+# The biggest the replication backlog, the longer the time the slave can be
+# disconnected and later be able to perform a partial resynchronization.
+#
+# The backlog is only allocated once there is at least a slave connected.
+#
+# repl-backlog-size 1mb
+
+# After a master has no longer connected slaves for some time, the backlog
+# will be freed. The following option configures the amount of seconds that
+# need to elapse, starting from the time the last slave disconnected, for
+# the backlog buffer to be freed.
+#
+# A value of 0 means to never release the backlog.
+#
+# repl-backlog-ttl 3600
+
 # The slave priority is an integer number published by Redis in the INFO output.
 # It is used by Redis Sentinel in order to select a slave to promote into a
 # master if the master is no longer working correctly.
 #
 # A slave with a low priority number is considered better for promotion, so
 # for instance if there are three slaves with priority 10, 100, 25 Sentinel will
@@ -239,12 +269,34 @@
 # role of master, so a slave with priority of 0 will never be selected by
 # Redis Sentinel for promotion.
 #
 # By default the priority is 100.
 slave-priority 100
 
+# It is possible for a master to stop accepting writes if there are less than
+# N slaves connected, having a lag less or equal than M seconds.
+#
+# The N slaves need to be in "online" state.
+#
+# The lag in seconds, that must be <= the specified value, is calculated from
+# the last ping received from the slave, that is usually sent every second.
+#
+# This option does not GUARANTEES that N replicas will accept the write, but
+# will limit the window of exposure for lost writes in case not enough slaves
+# are available, to the specified number of seconds.
+#
+# For example to require at least 3 slaves with a lag <= 10 seconds use:
+#
+# min-slaves-to-write 3
+# min-slaves-max-lag 10
+#
+# Setting one or the other to 0 disables the feature.
+#
+# By default min-slaves-to-write is set to 0 (feature disabled) and
+# min-slaves-max-lag is set to 10.
+
 ################################## SECURITY ###################################
 
 # Require clients to issue AUTH <PASSWORD> before processing any other
 # commands.  This might be useful in environments in which you do not trust
 # others with access to the host running redis-server.
 #
@@ -476,12 +528,58 @@
 slowlog-log-slower-than 10000
 
 # There is no limit to this length. Just be aware that it will consume memory.
 # You can reclaim memory used by the slow log with SLOWLOG RESET.
 slowlog-max-len 128
 
+############################# Event notification ##############################
+
+# Redis can notify Pub/Sub clients about events happening in the key space.
+# This feature is documented at http://redis.io/topics/keyspace-events
+# 
+# For instance if keyspace events notification is enabled, and a client
+# performs a DEL operation on key "foo" stored in the Database 0, two
+# messages will be published via Pub/Sub:
+#
+# PUBLISH __keyspace@0__:foo del
+# PUBLISH __keyevent@0__:del foo
+#
+# It is possible to select the events that Redis will notify among a set
+# of classes. Every class is identified by a single character:
+#
+#  K     Keyspace events, published with __keyspace@<db>__ prefix.
+#  E     Keyevent events, published with __keyevent@<db>__ prefix.
+#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
+#  $     String commands
+#  l     List commands
+#  s     Set commands
+#  h     Hash commands
+#  z     Sorted set commands
+#  x     Expired events (events generated every time a key expires)
+#  e     Evicted events (events generated when a key is evicted for maxmemory)
+#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.
+#
+#  The "notify-keyspace-events" takes as argument a string that is composed
+#  by zero or multiple characters. The empty string means that notifications
+#  are disabled at all.
+#
+#  Example: to enable list and generic events, from the point of view of the
+#           event name, use:
+#
+#  notify-keyspace-events Elg
+#
+#  Example 2: to get the stream of the expired keys subscribing to channel
+#             name __keyevent@0__:expired use:
+#
+#  notify-keyspace-events Ex
+#
+#  By default all notifications are disabled because most users don't need
+#  this feature and the feature has some overhead. Note that if you don't
+#  specify at least one of K or E, no events will be delivered.
+notify-keyspace-events ""
+
 ############################### ADVANCED CONFIG ###############################
 
 # Hashes are encoded using a memory efficient data structure when they have a
 # small number of entries, and the biggest entry does not exceed a given
 # threshold. These thresholds can be configured using the following directives.
 hash-max-ziplist-entries 512
@@ -564,13 +662,13 @@
 client-output-buffer-limit pubsub 32mb 8mb 60
 
 # Redis calls an internal function to perform many background tasks, like
 # closing connections of clients in timeot, purging expired keys that are
 # never requested, and so forth.
 #
-# Not all tasks are perforemd with the same frequency, but Redis checks for
+# Not all tasks are performed with the same frequency, but Redis checks for
 # tasks to perform accordingly to the specified "hz" value.
 #
 # By default "hz" is set to 10. Raising the value will use more CPU when
 # Redis is idle, but at the same time will make Redis more responsive when
 # there are many keys expiring at the same time, and timeouts may be
 # handled with more precision.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/sentinel.conf /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/sentinel.conf
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/sentinel.conf	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/sentinel.conf	2013-11-22 17:25:29.000000000 +0800
@@ -6,12 +6,16 @@
 
 # sentinel monitor <master-name> <ip> <redis-port> <quorum>
 #
 # Tells Sentinel to monitor this slave, and to consider it in O_DOWN
 # (Objectively Down) state only if at least <quorum> sentinels agree.
 #
+# Note that whatever is the ODOWN quorum, a Sentinel will require to
+# be elected by the majority of the known Sentinels in order to
+# start a failover, so no failover can be performed in minority.
+#
 # Note: master name should not include special characters or spaces.
 # The valid charset is A-z 0-9 and the three characters ".-_".
 sentinel monitor mymaster 127.0.0.1 6379 2
 
 # sentinel auth-pass <master-name> <password>
 #
@@ -39,40 +43,44 @@
 # specified period) in order to consider it in S_DOWN state (Subjectively
 # Down).
 #
 # Default is 30 seconds.
 sentinel down-after-milliseconds mymaster 30000
 
-# sentinel can-failover <master-name> <yes|no>
-#
-# Specify if this Sentinel can start the failover for this master.
-sentinel can-failover mymaster yes
-
 # sentinel parallel-syncs <master-name> <numslaves>
 #
 # How many slaves we can reconfigure to point to the new slave simultaneously
 # during the failover. Use a low number if you use the slaves to serve query
 # to avoid that all the slaves will be unreachable at about the same
 # time while performing the synchronization with the master.
 sentinel parallel-syncs mymaster 1
 
 # sentinel failover-timeout <master-name> <milliseconds>
 #
-# Specifies the failover timeout in milliseconds. When this time has elapsed
-# without any progress in the failover process, it is considered concluded by
-# the sentinel even if not all the attached slaves were correctly configured
-# to replicate with the new master (however a "best effort" SLAVEOF command
-# is sent to all the slaves before).
-#
-# Also when 25% of this time has elapsed without any advancement, and there
-# is a leader switch (the sentinel did not started the failover but is now
-# elected as leader), the sentinel will continue the failover doing a
-# "takeover".
+# Specifies the failover timeout in milliseconds. It is used in many ways:
+#
+# - The time needed to re-start a failover after a previous failover was
+#   already tried against the same master by a given Sentinel, is two
+#   times the failover timeout.
+#
+# - The time needed for a slave replicating to a wrong master according
+#   to a Sentinel currnet configuration, to be forced to replicate
+#   with the right master, is exactly the failover timeout (counting since
+#   the moment a Sentinel detected the misconfiguration).
+#
+# - The time needed to cancel a failover that is already in progress but
+#   did not produced any configuration change (SLAVEOF NO ONE yet not
+#   acknowledged by the promoted slave).
+#
+# - The maximum time a failover in progress waits for all the slaves to be
+#   reconfigured as slaves of the new master. However even after this time
+#   the slaves will be reconfigured by the Sentinels anyway, but not with
+#   the exact parallel-syncs progression as specified.
 #
-# Default is 15 minutes.
-sentinel failover-timeout mymaster 900000
+# Default is 3 minutes.
+sentinel failover-timeout mymaster 180000
 
 # SCRIPTS EXECUTION
 #
 # sentinel notification-script and sentinel reconfig-script are used in order
 # to configure scripts that are called to notify the system administrator
 # or to reconfigure clients after a failover. The scripts are executed
@@ -111,38 +119,26 @@
 # sentinel notification-script mymaster /var/redis/notify.sh
 
 # CLIENTS RECONFIGURATION SCRIPT
 #
 # sentinel client-reconfig-script <master-name> <script-path>
 #
-# When the failover starts, ends, or is aborted, a script can be called in
+# When the master changed because of a failover a script can be called in
 # order to perform application-specific tasks to notify the clients that the
 # configuration has changed and the master is at a different address.
 # 
-# The script is called in the following cases:
-#
-# Failover started (a slave is already promoted)
-# Failover finished (all the additional slaves already reconfigured)
-# Failover aborted (in that case the script was previously called when the
-#                   failover started, and now gets called again with swapped
-#                   addresses).
-#
 # The following arguments are passed to the script:
 #
 # <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>
 #
-# <state> is "start", "end" or "abort"
+# <state> is currently always "failover"
 # <role> is either "leader" or "observer"
 # 
 # The arguments from-ip, from-port, to-ip, to-port are used to communicate
 # the old address of the master and the new address of the elected slave
-# (now a master) in the case state is "start" or "end".
-#
-# For abort instead the "from" is the address of the promoted slave and
-# "to" is the address of the original master address, since the failover
-# was aborted.
+# (now a master).
 #
 # This script should be resistant to multiple invocations.
 #
 # Example:
 #
 # sentinel client-reconfig-script mymaster /var/redis/reconfig.sh
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/adlist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/adlist.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/adlist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/adlist.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.c	2013-11-22 17:25:29.000000000 +0800
@@ -88,12 +88,42 @@
         zfree(eventLoop->fired);
         zfree(eventLoop);
     }
     return NULL;
 }
 
+/* Return the current set size. */
+int aeGetSetSize(aeEventLoop *eventLoop) {
+    return eventLoop->setsize;
+}
+
+/* Resize the maximum set size of the event loop.
+ * If the requested set size is smaller than the current set size, but
+ * there is already a file descriptor in use that is >= the requested
+ * set size minus one, AE_ERR is returned and the operation is not
+ * performed at all.
+ *
+ * Otherwise AE_OK is returned and the operation is successful. */
+int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {
+    int i;
+
+    if (setsize == eventLoop->setsize) return AE_OK;
+    if (eventLoop->maxfd >= setsize) return AE_ERR;
+    if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR;
+
+    eventLoop->events = zrealloc(eventLoop->events,sizeof(aeFileEvent)*setsize);
+    eventLoop->fired = zrealloc(eventLoop->fired,sizeof(aeFiredEvent)*setsize);
+    eventLoop->setsize = setsize;
+
+    /* Make sure that if we created new slots, they are initialized with
+     * an AE_NONE mask. */
+    for (i = eventLoop->maxfd+1; i < setsize; i++)
+        eventLoop->events[i].mask = AE_NONE;
+    return AE_OK;
+}
+
 void aeDeleteEventLoop(aeEventLoop *eventLoop) {
     aeApiFree(eventLoop);
     zfree(eventLoop->events);
     zfree(eventLoop->fired);
     zfree(eventLoop);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae_epoll.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae_epoll.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae_epoll.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae_epoll.c	2013-11-22 17:25:29.000000000 +0800
@@ -52,12 +52,19 @@
         return -1;
     }
     eventLoop->apidata = state;
     return 0;
 }
 
+static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
+    aeApiState *state = eventLoop->apidata;
+
+    state->events = zrealloc(state->events, sizeof(struct epoll_event)*setsize);
+    return 0;
+}
+
 static void aeApiFree(aeEventLoop *eventLoop) {
     aeApiState *state = eventLoop->apidata;
 
     close(state->epfd);
     zfree(state->events);
     zfree(state);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae_evport.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae_evport.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae_evport.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae_evport.c	2013-11-22 17:25:29.000000000 +0800
@@ -91,12 +91,17 @@
     }
 
     eventLoop->apidata = state;
     return 0;
 }
 
+static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
+    /* Nothing to resize here. */
+    return 0;
+}
+
 static void aeApiFree(aeEventLoop *eventLoop) {
     aeApiState *state = eventLoop->apidata;
 
     close(state->portfd);
     zfree(state);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.h	2013-11-22 17:25:29.000000000 +0800
@@ -111,8 +111,10 @@
 int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id);
 int aeProcessEvents(aeEventLoop *eventLoop, int flags);
 int aeWait(int fd, int mask, long long milliseconds);
 void aeMain(aeEventLoop *eventLoop);
 char *aeGetApiName(void);
 void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);
+int aeGetSetSize(aeEventLoop *eventLoop);
+int aeResizeSetSize(aeEventLoop *eventLoop, int setsize);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae_kqueue.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae_kqueue.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae_kqueue.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae_kqueue.c	2013-11-22 17:25:29.000000000 +0800
@@ -51,16 +51,22 @@
     if (state->kqfd == -1) {
         zfree(state->events);
         zfree(state);
         return -1;
     }
     eventLoop->apidata = state;
-    
     return 0;    
 }
 
+static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
+    aeApiState *state = eventLoop->apidata;
+
+    state->events = zrealloc(state->events, sizeof(struct kevent)*setsize);
+    return 0;
+}
+
 static void aeApiFree(aeEventLoop *eventLoop) {
     aeApiState *state = eventLoop->apidata;
 
     close(state->kqfd);
     zfree(state->events);
     zfree(state);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae_select.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae_select.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae_select.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae_select.c	2013-11-22 17:25:29.000000000 +0800
@@ -45,12 +45,18 @@
     FD_ZERO(&state->rfds);
     FD_ZERO(&state->wfds);
     eventLoop->apidata = state;
     return 0;
 }
 
+static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
+    /* Just ensure we have enough room in the fd_set type. */
+    if (setsize >= FD_SETSIZE) return -1;
+    return 0;
+}
+
 static void aeApiFree(aeEventLoop *eventLoop) {
     zfree(eventLoop->apidata);
 }
 
 static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
     aeApiState *state = eventLoop->apidata;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.c	2013-11-22 17:25:29.000000000 +0800
@@ -160,83 +160,107 @@
         anetSetError(err, "setsockopt SO_KEEPALIVE: %s", strerror(errno));
         return ANET_ERR;
     }
     return ANET_OK;
 }
 
-int anetResolve(char *err, char *host, char *ipbuf)
+int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len)
 {
-    struct sockaddr_in sa;
+    struct addrinfo hints, *info;
+    int rv;
 
-    sa.sin_family = AF_INET;
-    if (inet_aton(host, &sa.sin_addr) == 0) {
-        struct hostent *he;
+    memset(&hints,0,sizeof(hints));
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_socktype = SOCK_STREAM;  /* specify socktype to avoid dups */
 
-        he = gethostbyname(host);
-        if (he == NULL) {
-            anetSetError(err, "can't resolve: %s", host);
-            return ANET_ERR;
-        }
-        memcpy(&sa.sin_addr, he->h_addr, sizeof(struct in_addr));
+    if ((rv = getaddrinfo(host, NULL, &hints, &info)) != 0) {
+        anetSetError(err, "%s", gai_strerror(rv));
+        return ANET_ERR;
+    }
+    if (info->ai_family == AF_INET) {
+        struct sockaddr_in *sa = (struct sockaddr_in *)info->ai_addr;
+        inet_ntop(AF_INET, &(sa->sin_addr), ipbuf, ipbuf_len);
+    } else {
+        struct sockaddr_in6 *sa = (struct sockaddr_in6 *)info->ai_addr;
+        inet_ntop(AF_INET6, &(sa->sin6_addr), ipbuf, ipbuf_len);
+    }
+
+    freeaddrinfo(info);
+    return ANET_OK;
+}
+
+static int anetSetReuseAddr(char *err, int fd) {
+    int yes = 1;
+    /* Make sure connection-intensive things like the redis benckmark
+     * will be able to close/open sockets a zillion of times */
+    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1) {
+        anetSetError(err, "setsockopt SO_REUSEADDR: %s", strerror(errno));
+        return ANET_ERR;
     }
-    strcpy(ipbuf,inet_ntoa(sa.sin_addr));
     return ANET_OK;
 }
 
 static int anetCreateSocket(char *err, int domain) {
-    int s, on = 1;
+    int s;
     if ((s = socket(domain, SOCK_STREAM, 0)) == -1) {
         anetSetError(err, "creating socket: %s", strerror(errno));
         return ANET_ERR;
     }
 
     /* Make sure connection-intensive things like the redis benchmark
      * will be able to close/open sockets a zillion of times */
-    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
-        anetSetError(err, "setsockopt SO_REUSEADDR: %s", strerror(errno));
+    if (anetSetReuseAddr(err,s) == ANET_ERR) {
+        close(s);
         return ANET_ERR;
     }
     return s;
 }
 
 #define ANET_CONNECT_NONE 0
 #define ANET_CONNECT_NONBLOCK 1
 static int anetTcpGenericConnect(char *err, char *addr, int port, int flags)
 {
-    int s;
-    struct sockaddr_in sa;
-
-    if ((s = anetCreateSocket(err,AF_INET)) == ANET_ERR)
-        return ANET_ERR;
-
-    sa.sin_family = AF_INET;
-    sa.sin_port = htons(port);
-    if (inet_aton(addr, &sa.sin_addr) == 0) {
-        struct hostent *he;
-
-        he = gethostbyname(addr);
-        if (he == NULL) {
-            anetSetError(err, "can't resolve: %s", addr);
+    int s, rv;
+    char _port[6];  /* strlen("65535"); */
+    struct addrinfo hints, *servinfo, *p;
+
+    snprintf(_port,6,"%d",port);
+    memset(&hints,0,sizeof(hints));
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_socktype = SOCK_STREAM;
+
+    if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {
+        anetSetError(err, "%s", gai_strerror(rv));
+        return ANET_ERR;
+    }
+    for (p = servinfo; p != NULL; p = p->ai_next) {
+        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
+            continue;
+
+        /* if we set err then goto cleanup, otherwise next */
+        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
+        if (flags & ANET_CONNECT_NONBLOCK && anetNonBlock(err,s) != ANET_OK)
+            goto error;
+        if (connect(s,p->ai_addr,p->ai_addrlen) == -1) {
+            if (errno == EINPROGRESS && flags & ANET_CONNECT_NONBLOCK) goto end;
             close(s);
-            return ANET_ERR;
+            continue;
         }
-        memcpy(&sa.sin_addr, he->h_addr, sizeof(struct in_addr));
+
+        /* break with the socket */
+        goto end;
     }
-    if (flags & ANET_CONNECT_NONBLOCK) {
-        if (anetNonBlock(err,s) != ANET_OK)
-            return ANET_ERR;
+    if (p == NULL) {
+        anetSetError(err, "creating socket: %s", strerror(errno));
+        goto error;
     }
-    if (connect(s, (struct sockaddr*)&sa, sizeof(sa)) == -1) {
-        if (errno == EINPROGRESS &&
-            flags & ANET_CONNECT_NONBLOCK)
-            return s;
 
-        anetSetError(err, "connect: %s", strerror(errno));
-        close(s);
-        return ANET_ERR;
-    }
+error:
+    s = ANET_ERR;
+end:
+    freeaddrinfo(servinfo);
     return s;
 }
 
 int anetTcpConnect(char *err, char *addr, int port)
 {
     return anetTcpGenericConnect(err,addr,port,ANET_CONNECT_NONE);
@@ -328,34 +352,69 @@
         close(s);
         return ANET_ERR;
     }
     return ANET_OK;
 }
 
-int anetTcpServer(char *err, int port, char *bindaddr)
+static int anetV6Only(char *err, int s) {
+    int yes = 1;
+    if (setsockopt(s,IPPROTO_IPV6,IPV6_V6ONLY,&yes,sizeof(yes)) == -1) {
+        anetSetError(err, "setsockopt: %s", strerror(errno));
+        close(s);
+        return ANET_ERR;
+    }
+    return ANET_OK;
+}
+
+static int _anetTcpServer(char *err, int port, char *bindaddr, int af)
 {
-    int s;
-    struct sockaddr_in sa;
+    int s, rv;
+    char _port[6];  /* strlen("65535") */
+    struct addrinfo hints, *servinfo, *p;
 
-    if ((s = anetCreateSocket(err,AF_INET)) == ANET_ERR)
-        return ANET_ERR;
+    snprintf(_port,6,"%d",port);
+    memset(&hints,0,sizeof(hints));
+    hints.ai_family = af;
+    hints.ai_socktype = SOCK_STREAM;
+    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */
 
-    memset(&sa,0,sizeof(sa));
-    sa.sin_family = AF_INET;
-    sa.sin_port = htons(port);
-    sa.sin_addr.s_addr = htonl(INADDR_ANY);
-    if (bindaddr && inet_aton(bindaddr, &sa.sin_addr) == 0) {
-        anetSetError(err, "invalid bind address");
-        close(s);
+    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {
+        anetSetError(err, "%s", gai_strerror(rv));
         return ANET_ERR;
     }
-    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa)) == ANET_ERR)
-        return ANET_ERR;
+    for (p = servinfo; p != NULL; p = p->ai_next) {
+        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
+            continue;
+
+        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;
+        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
+        if (anetListen(err,s,p->ai_addr,p->ai_addrlen) == ANET_ERR) goto error;
+        goto end;
+    }
+    if (p == NULL) {
+        anetSetError(err, "unable to bind socket");
+        goto error;
+    }
+
+error:
+    s = ANET_ERR;
+end:
+    freeaddrinfo(servinfo);
     return s;
 }
 
+int anetTcpServer(char *err, int port, char *bindaddr)
+{
+    return _anetTcpServer(err, port, bindaddr, AF_INET);
+}
+
+int anetTcp6Server(char *err, int port, char *bindaddr)
+{
+    return _anetTcpServer(err, port, bindaddr, AF_INET6);
+}
+
 int anetUnixServer(char *err, char *path, mode_t perm)
 {
     int s;
     struct sockaddr_un sa;
 
     if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
@@ -385,21 +444,28 @@
         }
         break;
     }
     return fd;
 }
 
-int anetTcpAccept(char *err, int s, char *ip, int *port) {
+int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {
     int fd;
-    struct sockaddr_in sa;
+    struct sockaddr_storage sa;
     socklen_t salen = sizeof(sa);
     if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == ANET_ERR)
         return ANET_ERR;
 
-    if (ip) strcpy(ip,inet_ntoa(sa.sin_addr));
-    if (port) *port = ntohs(sa.sin_port);
+    if (sa.ss_family == AF_INET) {
+        struct sockaddr_in *s = (struct sockaddr_in *)&sa;
+        if (ip) inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len);
+        if (port) *port = ntohs(s->sin_port);
+    } else {
+        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
+        if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
+        if (port) *port = ntohs(s->sin6_port);
+    }
     return fd;
 }
 
 int anetUnixAccept(char *err, int s) {
     int fd;
     struct sockaddr_un sa;
@@ -407,35 +473,49 @@
     if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == ANET_ERR)
         return ANET_ERR;
 
     return fd;
 }
 
-int anetPeerToString(int fd, char *ip, int *port) {
-    struct sockaddr_in sa;
+int anetPeerToString(int fd, char *ip, size_t ip_len, int *port) {
+    struct sockaddr_storage sa;
     socklen_t salen = sizeof(sa);
 
     if (getpeername(fd,(struct sockaddr*)&sa,&salen) == -1) {
         *port = 0;
         ip[0] = '?';
         ip[1] = '\0';
         return -1;
     }
-    if (ip) strcpy(ip,inet_ntoa(sa.sin_addr));
-    if (port) *port = ntohs(sa.sin_port);
+    if (sa.ss_family == AF_INET) {
+        struct sockaddr_in *s = (struct sockaddr_in *)&sa;
+        if (ip) inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len);
+        if (port) *port = ntohs(s->sin_port);
+    } else {
+        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
+        if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
+        if (port) *port = ntohs(s->sin6_port);
+    }
     return 0;
 }
 
-int anetSockName(int fd, char *ip, int *port) {
-    struct sockaddr_in sa;
+int anetSockName(int fd, char *ip, size_t ip_len, int *port) {
+    struct sockaddr_storage sa;
     socklen_t salen = sizeof(sa);
 
     if (getsockname(fd,(struct sockaddr*)&sa,&salen) == -1) {
         *port = 0;
         ip[0] = '?';
         ip[1] = '\0';
         return -1;
     }
-    if (ip) strcpy(ip,inet_ntoa(sa.sin_addr));
-    if (port) *port = ntohs(sa.sin_port);
+    if (sa.ss_family == AF_INET) {
+        struct sockaddr_in *s = (struct sockaddr_in *)&sa;
+        if (ip) inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len);
+        if (port) *port = ntohs(s->sin_port);
+    } else {
+        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
+        if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
+        if (port) *port = ntohs(s->sin6_port);
+    }
     return 0;
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.h	2013-11-22 17:25:29.000000000 +0800
@@ -41,20 +41,22 @@
 
 int anetTcpConnect(char *err, char *addr, int port);
 int anetTcpNonBlockConnect(char *err, char *addr, int port);
 int anetUnixConnect(char *err, char *path);
 int anetUnixNonBlockConnect(char *err, char *path);
 int anetRead(int fd, char *buf, int count);
-int anetResolve(char *err, char *host, char *ipbuf);
+int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len);
 int anetTcpServer(char *err, int port, char *bindaddr);
+int anetTcp6Server(char *err, int port, char *bindaddr);
 int anetUnixServer(char *err, char *path, mode_t perm);
-int anetTcpAccept(char *err, int serversock, char *ip, int *port);
+int anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port);
 int anetUnixAccept(char *err, int serversock);
 int anetWrite(int fd, char *buf, int count);
 int anetNonBlock(char *err, int fd);
 int anetEnableTcpNoDelay(char *err, int fd);
 int anetDisableTcpNoDelay(char *err, int fd);
 int anetTcpKeepAlive(char *err, int fd);
-int anetPeerToString(int fd, char *ip, int *port);
+int anetPeerToString(int fd, char *ip, size_t ip_len, int *port);
 int anetKeepAlive(char *err, int fd, int interval);
+int anetSockName(int fd, char *ip, size_t ip_len, int *port);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/aof.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/aof.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/aof.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/aof.c	2013-11-22 17:25:29.000000000 +0800
@@ -453,13 +453,13 @@
      * so that Redis will not try to send replies to this client. */
     c->replstate = REDIS_REPL_WAIT_BGSAVE_START;
     c->reply = listCreate();
     c->reply_bytes = 0;
     c->obuf_soft_limit_reached_time = 0;
     c->watched_keys = listCreate();
-    listSetFreeMethod(c->reply,decrRefCount);
+    listSetFreeMethod(c->reply,decrRefCountVoid);
     listSetDupMethod(c->reply,dupClientReplyValue);
     initClientMultiState(c);
     return c;
 }
 
 void freeFakeClient(struct redisClient *c) {
@@ -533,13 +533,13 @@
             if (fread(buf,2,1,fp) == 0) goto fmterr; /* discard CRLF */
         }
 
         /* Command lookup */
         cmd = lookupCommand(argv[0]->ptr);
         if (!cmd) {
-            redisLog(REDIS_WARNING,"Unknown command '%s' reading the append only file", argv[0]->ptr);
+            redisLog(REDIS_WARNING,"Unknown command '%s' reading the append only file", (char*)argv[0]->ptr);
             exit(1);
         }
         /* Run the command in the context of a fake client */
         fakeClient->argc = argc;
         fakeClient->argv = argv;
         cmd->proc(fakeClient);
@@ -959,14 +959,14 @@
     if (server.aof_child_pid != -1) return REDIS_ERR;
     start = ustime();
     if ((childpid = fork()) == 0) {
         char tmpfile[256];
 
         /* Child */
-        if (server.ipfd > 0) close(server.ipfd);
-        if (server.sofd > 0) close(server.sofd);
+        closeListeningSockets(0);
+        redisSetProcTitle("redis-aof-rewrite");
         snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) getpid());
         if (rewriteAppendOnlyFile(tmpfile) == REDIS_OK) {
             size_t private_dirty = zmalloc_get_private_dirty();
 
             if (private_dirty) {
                 redisLog(REDIS_NOTICE,
@@ -994,12 +994,13 @@
         updateDictResizePolicy();
         /* We set appendseldb to -1 in order to force the next call to the
          * feedAppendOnlyFile() to issue a SELECT command, so the differences
          * accumulated by the parent into server.aof_rewrite_buf will start
          * with a SELECT statement and it will be safe to merge. */
         server.aof_selected_db = -1;
+        replicationScriptCacheFlush();
         return REDIS_OK;
     }
     return REDIS_OK; /* unreached */
 }
 
 void bgrewriteaofCommand(redisClient *c) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/aof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/aof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/aof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/aof.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.c	2013-11-22 17:25:29.000000000 +0800
@@ -58,12 +58,13 @@
  */
 
 
 #include "redis.h"
 #include "bio.h"
 
+static pthread_t bio_threads[REDIS_BIO_NUM_OPS];
 static pthread_mutex_t bio_mutex[REDIS_BIO_NUM_OPS];
 static pthread_cond_t bio_condvar[REDIS_BIO_NUM_OPS];
 static list *bio_jobs[REDIS_BIO_NUM_OPS];
 /* The following array is used to hold the number of pending jobs for every
  * OP type. This allows us to export the bioPendingJobsOfType() API that is
  * useful when the main thread wants to perform some operation that may involve
@@ -115,12 +116,13 @@
     for (j = 0; j < REDIS_BIO_NUM_OPS; j++) {
         void *arg = (void*)(unsigned long) j;
         if (pthread_create(&thread,&attr,bioProcessBackgroundJobs,arg) != 0) {
             redisLog(REDIS_WARNING,"Fatal: Can't initialize Background Jobs.");
             exit(1);
         }
+        bio_threads[j] = thread;
     }
 }
 
 void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) {
     struct bio_job *job = zmalloc(sizeof(*job));
 
@@ -137,13 +139,17 @@
 
 void *bioProcessBackgroundJobs(void *arg) {
     struct bio_job *job;
     unsigned long type = (unsigned long) arg;
     sigset_t sigset;
 
-    pthread_detach(pthread_self());
+    /* Make the thread killable at any time, so that bioKillThreads()
+     * can work reliably. */
+    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+
     pthread_mutex_lock(&bio_mutex[type]);
     /* Block SIGALRM so we are sure that only the main thread will
      * receive the watchdog signal. */
     sigemptyset(&sigset);
     sigaddset(&sigset, SIGALRM);
     if (pthread_sigmask(SIG_BLOCK, &sigset, NULL))
@@ -189,59 +195,26 @@
     pthread_mutex_lock(&bio_mutex[type]);
     val = bio_pending[type];
     pthread_mutex_unlock(&bio_mutex[type]);
     return val;
 }
 
-#if 0 /* We don't use the following code for now, and bioWaitPendingJobsLE
-         probably needs a rewrite using conditional variables instead of the
-         current implementation. */
-         
-
-/* Wait until the number of pending jobs of the specified type are
- * less or equal to the specified number.
- *
- * This function may block for long time, it should only be used to perform
- * the following tasks:
- *
- * 1) To avoid that the main thread is pushing jobs of a given time so fast
- *    that the background thread can't process them at the same speed.
- *    So before creating a new job of a given type the main thread should
- *    call something like: bioWaitPendingJobsLE(job_type,10000);
- * 2) In order to perform special operations that make it necessary to be sure
- *    no one is touching shared resourced in the background.
- */
-void bioWaitPendingJobsLE(int type, unsigned long long num) {
-    unsigned long long iteration = 0;
+/* Kill the running bio threads in an unclean way. This function should be
+ * used only when it's critical to stop the threads for some reason.
+ * Currently Redis does this only on crash (for instance on SIGSEGV) in order
+ * to perform a fast memory check without other threads messing with memory. */
+void bioKillThreads(void) {
+    int err, j;
 
-    /* We poll the jobs queue aggressively to start, and gradually relax
-     * the polling speed if it is going to take too much time. */
-    while(1) {
-        iteration++;
-        if (iteration > 1000 && iteration <= 10000) {
-            usleep(100);
-        } else if (iteration > 10000) {
-            usleep(1000);
+    for (j = 0; j < REDIS_BIO_NUM_OPS; j++) {
+        if (pthread_cancel(bio_threads[j]) == 0) {
+            if ((err = pthread_join(bio_threads[j],NULL)) != 0) {
+                redisLog(REDIS_WARNING,
+                    "Bio thread for job type #%d can be joined: %s",
+                        j, strerror(err));
+            } else {
+                redisLog(REDIS_WARNING,
+                    "Bio thread for job type #%d terminated",j);
+            }
         }
-        if (bioPendingJobsOfType(type) <= num) break;
     }
 }
-
-/* Return the older job of the specified type. */
-time_t bioOlderJobOfType(int type) {
-    time_t time;
-    listNode *ln;
-    struct bio_job *job;
-
-    pthread_mutex_lock(&bio_mutex[type]);
-    ln = listFirst(bio_jobs[type]);
-    if (ln == NULL) {
-        pthread_mutex_unlock(&bio_mutex[type]);
-        return 0;
-    }
-    job = ln->value;
-    time = job->time;
-    pthread_mutex_unlock(&bio_mutex[type]);
-    return time;
-}
-
-#endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.h	2013-11-22 17:25:29.000000000 +0800
@@ -30,11 +30,12 @@
 /* Exported API */
 void bioInit(void);
 void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3);
 unsigned long long bioPendingJobsOfType(int type);
 void bioWaitPendingJobsLE(int type, unsigned long long num);
 time_t bioOlderJobOfType(int type);
+void bioKillThreads(void);
 
 /* Background job opcodes */
 #define REDIS_BIO_CLOSE_FILE    0 /* Deferred close(2) syscall. */
 #define REDIS_BIO_AOF_FSYNC     1 /* Deferred AOF fsync. */
 #define REDIS_BIO_NUM_OPS       2
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bitops.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bitops.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bitops.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bitops.c	2013-11-22 17:25:29.000000000 +0800
@@ -55,13 +55,13 @@
     return REDIS_OK;
 }
 
 /* Count number of bits set in the binary array pointed by 's' and long
  * 'count' bytes. The implementation of this function is required to
  * work with a input string length up to 512 MB. */
-size_t popcount(void *s, long count) {
+size_t redisPopcount(void *s, long count) {
     size_t bits = 0;
     unsigned char *p;
     uint32_t *p4 = s;
     static const unsigned char bitsinbyte[256] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8};
 
     /* Count bits 16 bytes at a time */
@@ -150,12 +150,13 @@
 
     /* Update byte with new bit value and return original value */
     byteval &= ~(1 << bit);
     byteval |= ((on & 0x1) << bit);
     ((uint8_t*)o->ptr)[byte] = byteval;
     signalModifiedKey(c->db,c->argv[1]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"setbit",c->argv[1],c->db->id);
     server.dirty++;
     addReply(c, bitval ? shared.cone : shared.czero);
 }
 
 /* GETBIT key offset */
 void getbitCommand(redisClient *c) {
@@ -343,15 +344,17 @@
     zfree(objects);
 
     /* Store the computed value into the target key */
     if (maxlen) {
         o = createObject(REDIS_STRING,res);
         setKey(c->db,targetkey,o);
+        notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"set",targetkey,c->db->id);
         decrRefCount(o);
     } else if (dbDelete(c->db,targetkey)) {
         signalModifiedKey(c->db,targetkey);
+        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",targetkey,c->db->id);
     }
     server.dirty++;
     addReplyLongLong(c,maxlen); /* Return the output string length in bytes. */
 }
 
 /* BITCOUNT key [start end] */
@@ -401,9 +404,9 @@
      * zero can be returned is: start > end. */
     if (start > end) {
         addReply(c,shared.czero);
     } else {
         long bytes = end-start+1;
 
-        addReplyLongLong(c,popcount(p+start,bytes));
+        addReplyLongLong(c,redisPopcount(p+start,bytes));
     }
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bitops.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bitops.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bitops.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bitops.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/build_ir.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/build_ir.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/build_ir.sh	2017-09-27 22:06:10.479055198 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/build_ir.sh	2017-09-27 22:07:19.407052672 +0800
@@ -11,567 +11,577 @@
 	then
 		succ=`expr $succ + 1`;
 	fi
 	total=`expr $total + 1`;
 }
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/net.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/net.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/net.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/net.c.bc
 check
-echo "1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/net.c to bc" >&2
+echo "1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/net.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/hiredis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/hiredis.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/hiredis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/hiredis.c.bc
 check
-echo "2 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/hiredis.c to bc" >&2
+echo "2 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/hiredis.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.c.bc
 check
-echo "3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.c to bc" >&2
+echo "3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/async.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/async.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/async.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/async.c.bc
 check
-echo "4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/async.c to bc" >&2
+echo "4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/async.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/linenoise
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/linenoise/linenoise.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/linenoise/linenoise.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/linenoise
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/linenoise/linenoise.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/linenoise/linenoise.c.bc
 check
-echo "5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/linenoise/linenoise.c to bc" >&2
+echo "5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/linenoise/linenoise.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lapi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lapi.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lapi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lapi.c.bc
 check
-echo "6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lapi.c to bc" >&2
+echo "6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lapi.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lcode.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lcode.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lcode.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lcode.c.bc
 check
-echo "7 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lcode.c to bc" >&2
+echo "7 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lcode.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldebug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldebug.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldebug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldebug.c.bc
 check
-echo "8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldebug.c to bc" >&2
+echo "8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldebug.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldo.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldo.c.bc
 check
-echo "9 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldo.c to bc" >&2
+echo "9 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldo.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldump.c.bc
 check
-echo "10 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldump.c to bc" >&2
+echo "10 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldump.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lfunc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lfunc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lfunc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lfunc.c.bc
 check
-echo "11 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lfunc.c to bc" >&2
+echo "11 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lfunc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lgc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lgc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lgc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lgc.c.bc
 check
-echo "12 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lgc.c to bc" >&2
+echo "12 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lgc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/llex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/llex.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/llex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/llex.c.bc
 check
-echo "13 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/llex.c to bc" >&2
+echo "13 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/llex.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmem.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmem.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmem.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmem.c.bc
 check
-echo "14 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmem.c to bc" >&2
+echo "14 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmem.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lobject.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lobject.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lobject.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lobject.c.bc
 check
-echo "15 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lobject.c to bc" >&2
+echo "15 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lobject.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lopcodes.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lopcodes.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lopcodes.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lopcodes.c.bc
 check
-echo "16 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lopcodes.c to bc" >&2
+echo "16 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lopcodes.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lparser.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lparser.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lparser.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lparser.c.bc
 check
-echo "17 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lparser.c to bc" >&2
+echo "17 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lparser.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstate.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstate.c.bc
 check
-echo "18 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstate.c to bc" >&2
+echo "18 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstate.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstring.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstring.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstring.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstring.c.bc
 check
-echo "19 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstring.c to bc" >&2
+echo "19 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstring.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltable.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltable.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltable.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltable.c.bc
 check
-echo "20 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltable.c to bc" >&2
+echo "20 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltable.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltm.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltm.c.bc
 check
-echo "21 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltm.c to bc" >&2
+echo "21 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltm.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lundump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lundump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lundump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lundump.c.bc
 check
-echo "22 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lundump.c to bc" >&2
+echo "22 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lundump.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lvm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lvm.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lvm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lvm.c.bc
 check
-echo "23 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lvm.c to bc" >&2
+echo "23 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lvm.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lzio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lzio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lzio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lzio.c.bc
 check
-echo "24 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lzio.c to bc" >&2
+echo "24 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lzio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/strbuf.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/strbuf.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/strbuf.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/strbuf.c.bc
 check
-echo "25 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/strbuf.c to bc" >&2
+echo "25 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/strbuf.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lauxlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lauxlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lauxlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lauxlib.c.bc
 check
-echo "26 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lauxlib.c to bc" >&2
+echo "26 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lauxlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lbaselib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lbaselib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lbaselib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lbaselib.c.bc
 check
-echo "27 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lbaselib.c to bc" >&2
+echo "27 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lbaselib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldblib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldblib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldblib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldblib.c.bc
 check
-echo "28 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldblib.c to bc" >&2
+echo "28 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldblib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/liolib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/liolib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/liolib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/liolib.c.bc
 check
-echo "29 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/liolib.c to bc" >&2
+echo "29 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/liolib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmathlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmathlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmathlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmathlib.c.bc
 check
-echo "30 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmathlib.c to bc" >&2
+echo "30 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmathlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loslib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loslib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loslib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loslib.c.bc
 check
-echo "31 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loslib.c to bc" >&2
+echo "31 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loslib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltablib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltablib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltablib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltablib.c.bc
 check
-echo "32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltablib.c to bc" >&2
+echo "32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltablib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstrlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstrlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstrlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstrlib.c.bc
 check
-echo "33 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstrlib.c to bc" >&2
+echo "33 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstrlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loadlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loadlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loadlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loadlib.c.bc
 check
-echo "34 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loadlib.c to bc" >&2
+echo "34 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loadlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/linit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/linit.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/linit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/linit.c.bc
 check
-echo "35 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/linit.c to bc" >&2
+echo "35 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/linit.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cjson.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cjson.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cjson.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cjson.c.bc
 check
-echo "36 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cjson.c to bc" >&2
+echo "36 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cjson.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_struct.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_struct.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_struct.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_struct.c.bc
 check
-echo "37 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_struct.c to bc" >&2
+echo "37 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_struct.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cmsgpack.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cmsgpack.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cmsgpack.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cmsgpack.c.bc
 check
-echo "38 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cmsgpack.c to bc" >&2
+echo "38 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cmsgpack.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua.c.bc
 check
-echo "39 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua.c to bc" >&2
+echo "39 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/luac.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/luac.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/luac.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/luac.c.bc
 check
-echo "40 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/luac.c to bc" >&2
+echo "40 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/luac.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/print.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/print.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/print.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/print.c.bc
 check
-echo "41 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/print.c to bc" >&2
+echo "41 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/print.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c.bc
 check
-echo "42 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c to bc" >&2
+echo "42 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/jemalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/jemalloc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/jemalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/jemalloc.c.bc
 check
-echo "43 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/jemalloc.c to bc" >&2
+echo "43 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/jemalloc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/arena.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/arena.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/arena.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/arena.c.bc
 check
-echo "44 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/arena.c to bc" >&2
+echo "44 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/arena.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/atomic.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/atomic.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/atomic.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/atomic.c.bc
 check
-echo "45 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/atomic.c to bc" >&2
+echo "45 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/atomic.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/base.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/base.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/base.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/base.c.bc
 check
-echo "46 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/base.c to bc" >&2
+echo "46 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/base.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/bitmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/bitmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/bitmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/bitmap.c.bc
 check
-echo "47 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/bitmap.c to bc" >&2
+echo "47 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/bitmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk.c.bc
 check
-echo "48 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk.c to bc" >&2
+echo "48 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_dss.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_dss.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_dss.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_dss.c.bc
 check
-echo "49 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_dss.c to bc" >&2
+echo "49 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_dss.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_mmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_mmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_mmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_mmap.c.bc
 check
-echo "50 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_mmap.c to bc" >&2
+echo "50 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_mmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ckh.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ckh.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ckh.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ckh.c.bc
 check
-echo "51 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ckh.c to bc" >&2
+echo "51 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ckh.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ctl.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ctl.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ctl.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ctl.c.bc
 check
-echo "52 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ctl.c to bc" >&2
+echo "52 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ctl.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/extent.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/extent.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/extent.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/extent.c.bc
 check
-echo "53 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/extent.c to bc" >&2
+echo "53 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/extent.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/hash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/hash.c.bc
 check
-echo "54 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/hash.c to bc" >&2
+echo "54 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/hash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/huge.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/huge.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/huge.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/huge.c.bc
 check
-echo "55 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/huge.c to bc" >&2
+echo "55 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/huge.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mb.c.bc
 check
-echo "56 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mb.c to bc" >&2
+echo "56 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mb.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mutex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mutex.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mutex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mutex.c.bc
 check
-echo "57 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mutex.c to bc" >&2
+echo "57 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mutex.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/prof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/prof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/prof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/prof.c.bc
 check
-echo "58 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/prof.c to bc" >&2
+echo "58 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/prof.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/quarantine.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/quarantine.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/quarantine.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/quarantine.c.bc
 check
-echo "59 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/quarantine.c to bc" >&2
+echo "59 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/quarantine.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/rtree.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/rtree.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/rtree.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/rtree.c.bc
 check
-echo "60 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/rtree.c to bc" >&2
+echo "60 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/rtree.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/stats.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/stats.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/stats.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/stats.c.bc
 check
-echo "61 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/stats.c to bc" >&2
+echo "61 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/stats.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tcache.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tcache.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tcache.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tcache.c.bc
 check
-echo "62 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tcache.c to bc" >&2
+echo "62 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tcache.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/util.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/util.c.bc
 check
-echo "63 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/util.c to bc" >&2
+echo "63 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/util.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tsd.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tsd.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tsd.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tsd.c.bc
 check
-echo "64 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tsd.c to bc" >&2
+echo "64 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tsd.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/adlist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/adlist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/adlist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/adlist.c.bc
 check
-echo "65 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/adlist.c to bc" >&2
+echo "65 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/adlist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.c.bc
 check
-echo "66 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.c to bc" >&2
+echo "66 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.c.bc
 check
-echo "67 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.c to bc" >&2
+echo "67 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.c.bc
 check
-echo "68 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.c to bc" >&2
+echo "68 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.c.bc
 check
-echo "69 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.c to bc" >&2
+echo "69 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.c.bc
 check
-echo "70 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.c to bc" >&2
+echo "70 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zmalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zmalloc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zmalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zmalloc.c.bc
 check
-echo "71 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zmalloc.c to bc" >&2
+echo "71 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zmalloc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_c.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_c.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_c.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_c.c.bc
 check
-echo "72 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_c.c to bc" >&2
+echo "72 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_c.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_d.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_d.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_d.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_d.c.bc
 check
-echo "73 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_d.c to bc" >&2
+echo "73 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_d.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pqsort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pqsort.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pqsort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pqsort.c.bc
 check
-echo "74 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pqsort.c to bc" >&2
+echo "74 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pqsort.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zipmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zipmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zipmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zipmap.c.bc
 check
-echo "75 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zipmap.c to bc" >&2
+echo "75 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zipmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sha1.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sha1.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sha1.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sha1.c.bc
 check
-echo "76 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sha1.c to bc" >&2
+echo "76 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sha1.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ziplist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ziplist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ziplist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ziplist.c.bc
 check
-echo "77 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ziplist.c to bc" >&2
+echo "77 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ziplist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.c.bc
 check
-echo "78 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.c to bc" >&2
+echo "78 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/networking.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/networking.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/networking.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/networking.c.bc
 check
-echo "79 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/networking.c to bc" >&2
+echo "79 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/networking.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.c.bc
 check
-echo "80 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.c to bc" >&2
+echo "80 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/object.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/object.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/object.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/object.c.bc
 check
-echo "81 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/object.c to bc" >&2
+echo "81 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/object.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/db.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/db.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/db.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/db.c.bc
 check
-echo "82 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/db.c to bc" >&2
+echo "82 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/db.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/replication.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/replication.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/replication.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/replication.c.bc
 check
-echo "83 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/replication.c to bc" >&2
+echo "83 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/replication.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rdb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rdb.c.bc
 check
-echo "84 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rdb.c to bc" >&2
+echo "84 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rdb.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_string.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_string.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_string.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_string.c.bc
 check
-echo "85 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_string.c to bc" >&2
+echo "85 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_string.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_list.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_list.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_list.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_list.c.bc
 check
-echo "86 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_list.c to bc" >&2
+echo "86 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_list.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_set.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_set.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_set.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_set.c.bc
 check
-echo "87 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_set.c to bc" >&2
+echo "87 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_set.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_zset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_zset.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_zset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_zset.c.bc
 check
-echo "88 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_zset.c to bc" >&2
+echo "88 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_zset.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_hash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_hash.c.bc
 check
-echo "89 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_hash.c to bc" >&2
+echo "89 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_hash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.c.bc
 check
-echo "90 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.c to bc" >&2
+echo "90 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/aof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/aof.c.bc
 check
-echo "91 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/aof.c to bc" >&2
+echo "91 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/aof.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pubsub.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pubsub.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pubsub.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pubsub.c.bc
 check
-echo "92 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pubsub.c to bc" >&2
+echo "92 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pubsub.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/multi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/multi.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/multi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/multi.c.bc
 check
-echo "93 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/multi.c to bc" >&2
+echo "93 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/multi.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/debug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/debug.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/debug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/debug.c.bc
 check
-echo "94 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/debug.c to bc" >&2
+echo "94 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/debug.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sort.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sort.c.bc
 check
-echo "95 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sort.c to bc" >&2
+echo "95 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sort.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/intset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/intset.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/intset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/intset.c.bc
 check
-echo "96 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/intset.c to bc" >&2
+echo "96 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/intset.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/syncio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/syncio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/syncio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/syncio.c.bc
 check
-echo "97 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/syncio.c to bc" >&2
+echo "97 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/syncio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/migrate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/migrate.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/migrate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/migrate.c.bc
 check
-echo "98 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/migrate.c to bc" >&2
+echo "98 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/migrate.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/endianconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/endianconv.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/endianconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/endianconv.c.bc
 check
-echo "99 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/endianconv.c to bc" >&2
+echo "99 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/endianconv.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/slowlog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/slowlog.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/slowlog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/slowlog.c.bc
 check
-echo "100 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/slowlog.c to bc" >&2
+echo "100 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/slowlog.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/scripting.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/scripting.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/scripting.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/scripting.c.bc
 check
-echo "101 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/scripting.c to bc" >&2
+echo "101 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/scripting.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.c.bc
 check
-echo "102 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.c to bc" >&2
+echo "102 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.c.bc
 check
-echo "103 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.c to bc" >&2
+echo "103 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rand.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rand.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rand.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rand.c.bc
 check
-echo "104 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rand.c to bc" >&2
+echo "104 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rand.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/memtest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/memtest.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/memtest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/memtest.c.bc
 check
-echo "105 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/memtest.c to bc" >&2
+echo "105 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/memtest.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/crc64.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/crc64.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/crc64.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/crc64.c.bc
 check
-echo "106 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/crc64.c to bc" >&2
+echo "106 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/crc64.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bitops.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bitops.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bitops.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bitops.c.bc
 check
-echo "107 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bitops.c to bc" >&2
+echo "107 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bitops.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sentinel.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sentinel.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sentinel.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sentinel.c.bc
 check
-echo "108 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sentinel.c to bc" >&2
+echo "108 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sentinel.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/notify.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/notify.c.bc
 check
-echo "109 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli.c to bc" >&2
+echo "109 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/notify.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/setproctitle.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/setproctitle.c.bc
 check
-echo "110 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark.c to bc" >&2
+echo "110 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/setproctitle.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli.c.bc
 check
-echo "111 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump.c to bc" >&2
+echo "111 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src
-clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-aof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark.c.bc
 check
-echo "112 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-aof.c to bc" >&2
+echo "112 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump.c.bc
+check
+echo "113 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src
+clang -g -emit-llvm -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-aof.c.bc
+check
+echo "114 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-aof.c to bc" >&2
 echo "Total ir $total" >&2
 echo "Succ ir $succ" >&2
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/compile_commands.json /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/compile_commands.json
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/compile_commands.json	2017-09-27 22:06:10.475055198 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/compile_commands.json	2017-09-27 22:07:19.399052672 +0800
@@ -1,1123 +1,1135 @@
 [
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb net.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/net.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/net.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb hiredis.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/hiredis.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/hiredis.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb sds.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb async.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/async.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/async.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/linenoise",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/linenoise",
   "command": "cc -Wall -Os -g -c linenoise.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/linenoise/linenoise.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/linenoise/linenoise.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lapi.o lapi.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lapi.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lapi.o lapi.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lapi.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lcode.o lcode.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lcode.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lcode.o lcode.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lcode.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o ldebug.o ldebug.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldebug.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o ldebug.o ldebug.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldebug.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o ldo.o ldo.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldo.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o ldo.o ldo.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldo.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o ldump.o ldump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldump.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o ldump.o ldump.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldump.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lfunc.o lfunc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lfunc.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lfunc.o lfunc.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lfunc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lgc.o lgc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lgc.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lgc.o lgc.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lgc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o llex.o llex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/llex.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o llex.o llex.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/llex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lmem.o lmem.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmem.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lmem.o lmem.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmem.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lobject.o lobject.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lobject.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lobject.o lobject.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lobject.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lopcodes.o lopcodes.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lopcodes.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lopcodes.o lopcodes.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lopcodes.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lparser.o lparser.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lparser.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lparser.o lparser.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lparser.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lstate.o lstate.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstate.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lstate.o lstate.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstate.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lstring.o lstring.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstring.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lstring.o lstring.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstring.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o ltable.o ltable.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltable.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o ltable.o ltable.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltable.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o ltm.o ltm.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltm.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o ltm.o ltm.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltm.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lundump.o lundump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lundump.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lundump.o lundump.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lundump.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lvm.o lvm.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lvm.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lvm.o lvm.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lvm.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lzio.o lzio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lzio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lzio.o lzio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lzio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o strbuf.o strbuf.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/strbuf.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o strbuf.o strbuf.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/strbuf.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lauxlib.o lauxlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lauxlib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lauxlib.o lauxlib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lauxlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lbaselib.o lbaselib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lbaselib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lbaselib.o lbaselib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lbaselib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o ldblib.o ldblib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldblib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o ldblib.o ldblib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldblib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o liolib.o liolib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/liolib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o liolib.o liolib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/liolib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lmathlib.o lmathlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmathlib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lmathlib.o lmathlib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmathlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o loslib.o loslib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loslib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o loslib.o loslib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loslib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o ltablib.o ltablib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltablib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o ltablib.o ltablib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltablib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lstrlib.o lstrlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstrlib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lstrlib.o lstrlib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstrlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o loadlib.o loadlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loadlib.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o loadlib.o loadlib.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loadlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o linit.o linit.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/linit.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o linit.o linit.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/linit.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lua_cjson.o lua_cjson.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cjson.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lua_cjson.o lua_cjson.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cjson.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lua_struct.o lua_struct.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_struct.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lua_struct.o lua_struct.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_struct.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lua_cmsgpack.o lua_cmsgpack.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cmsgpack.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lua_cmsgpack.o lua_cmsgpack.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cmsgpack.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o lua.o lua.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o lua.o lua.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o luac.o luac.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/luac.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o luac.o luac.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/luac.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src",
-  "command": "gcc -O2 -Wall -DLUA_ANSI -c -o print.o print.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/print.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src",
+  "command": "cc -O2 -Wall -DLUA_ANSI -c -o print.o print.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/print.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -g conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c -lm",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c -lm",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -E -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lpthread -lm",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/jemalloc.o src/jemalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/jemalloc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/jemalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/jemalloc.o -o src/jemalloc.d src/jemalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/jemalloc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/jemalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/arena.o src/arena.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/arena.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/arena.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/arena.o -o src/arena.d src/arena.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/arena.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/arena.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/atomic.o src/atomic.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/atomic.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/atomic.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/atomic.o -o src/atomic.d src/atomic.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/atomic.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/atomic.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/base.o src/base.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/base.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/base.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/base.o -o src/base.d src/base.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/base.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/base.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/bitmap.o src/bitmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/bitmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/bitmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/bitmap.o -o src/bitmap.d src/bitmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/bitmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/bitmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk.o src/chunk.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk.o -o src/chunk.d src/chunk.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk_dss.o src/chunk_dss.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_dss.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_dss.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk_dss.o -o src/chunk_dss.d src/chunk_dss.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_dss.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_dss.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk_mmap.o src/chunk_mmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_mmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_mmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk_mmap.o -o src/chunk_mmap.d src/chunk_mmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_mmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_mmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ckh.o src/ckh.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ckh.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ckh.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/ckh.o -o src/ckh.d src/ckh.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ckh.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ckh.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ctl.o src/ctl.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ctl.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ctl.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/ctl.o -o src/ctl.d src/ctl.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ctl.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ctl.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/extent.o src/extent.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/extent.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/extent.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/extent.o -o src/extent.d src/extent.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/extent.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/extent.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/hash.o src/hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/hash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/hash.o -o src/hash.d src/hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/hash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/huge.o src/huge.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/huge.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/huge.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/huge.o -o src/huge.d src/huge.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/huge.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/huge.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mb.o src/mb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/mb.o -o src/mb.d src/mb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mutex.o src/mutex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mutex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mutex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/mutex.o -o src/mutex.d src/mutex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mutex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mutex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/prof.o src/prof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/prof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/prof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/prof.o -o src/prof.d src/prof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/prof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/prof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/quarantine.o src/quarantine.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/quarantine.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/quarantine.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/quarantine.o -o src/quarantine.d src/quarantine.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/quarantine.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/quarantine.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/rtree.o src/rtree.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/rtree.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/rtree.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/rtree.o -o src/rtree.d src/rtree.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/rtree.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/rtree.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/stats.o src/stats.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/stats.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/stats.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/stats.o -o src/stats.d src/stats.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/stats.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/stats.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tcache.o src/tcache.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tcache.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tcache.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/tcache.o -o src/tcache.d src/tcache.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tcache.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tcache.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/util.o src/util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/util.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/util.o -o src/util.d src/util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/util.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tsd.o src/tsd.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tsd.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tsd.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/tsd.o -o src/tsd.d src/tsd.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tsd.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tsd.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c adlist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/adlist.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c adlist.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/adlist.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ae.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ae.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c anet.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c anet.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c dict.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c dict.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sds.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sds.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zmalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zmalloc.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zmalloc.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zmalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_c.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_c.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_c.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_c.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_d.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_d.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_d.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_d.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pqsort.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pqsort.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pqsort.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pqsort.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zipmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zipmap.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zipmap.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zipmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sha1.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sha1.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sha1.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sha1.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ziplist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ziplist.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ziplist.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ziplist.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c release.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c release.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c networking.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/networking.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c networking.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/networking.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c util.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c object.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/object.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c object.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/object.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c db.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/db.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c db.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/db.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c replication.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/replication.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c replication.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/replication.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rdb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rdb.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rdb.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rdb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_string.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_string.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_string.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_string.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_list.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_list.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_list.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_list.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_set.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_set.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_set.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_set.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_zset.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_zset.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_zset.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_zset.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_hash.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_hash.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c config.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c config.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c aof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/aof.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c aof.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/aof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pubsub.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pubsub.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pubsub.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pubsub.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c multi.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/multi.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c multi.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/multi.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c debug.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/debug.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c debug.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/debug.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sort.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sort.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sort.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sort.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c intset.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/intset.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c intset.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/intset.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c syncio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/syncio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c syncio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/syncio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c migrate.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/migrate.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c migrate.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/migrate.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c endianconv.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/endianconv.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c endianconv.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/endianconv.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c slowlog.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/slowlog.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c slowlog.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/slowlog.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c scripting.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/scripting.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c scripting.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/scripting.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rand.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rand.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rand.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rand.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c memtest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/memtest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c memtest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/memtest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc64.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/crc64.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc64.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/crc64.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bitops.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bitops.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bitops.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bitops.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sentinel.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sentinel.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sentinel.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sentinel.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-cli.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c notify.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/notify.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-benchmark.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c setproctitle.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/setproctitle.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-dump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-cli.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src",
-  "command": "cc -std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-aof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-aof.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-benchmark.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-dump.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src",
+  "command": "cc -std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-aof.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-aof.c"
 }
 ]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/compiled_files.def /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/compiled_files.def
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/compiled_files.def	2017-09-27 22:06:10.479055198 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/compiled_files.def	2017-09-27 22:07:19.407052672 +0800
@@ -1,112 +1,114 @@
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/net.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/hiredis.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/sds.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/hiredis/async.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/linenoise/linenoise.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lapi.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lcode.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldebug.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldo.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lfunc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lgc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/llex.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmem.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lobject.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lopcodes.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lparser.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstate.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstring.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltable.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltm.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lundump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lvm.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lzio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/strbuf.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lauxlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lbaselib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ldblib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/liolib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lmathlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loslib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/ltablib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lstrlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/loadlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/linit.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cjson.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_struct.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua_cmsgpack.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/lua.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/luac.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/lua/src/print.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/conftest.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/jemalloc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/arena.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/atomic.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/base.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/bitmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_dss.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/chunk_mmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ckh.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/ctl.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/extent.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/hash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/huge.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/mutex.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/prof.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/quarantine.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/rtree.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/stats.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tcache.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/util.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/deps/jemalloc/src/tsd.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/adlist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ae.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/anet.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zmalloc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_c.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_d.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pqsort.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zipmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sha1.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ziplist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/networking.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/object.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/db.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/replication.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rdb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_string.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_list.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_set.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_zset.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_hash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/aof.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pubsub.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/multi.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/debug.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sort.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/intset.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/syncio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/migrate.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/endianconv.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/slowlog.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/scripting.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rand.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/memtest.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/crc64.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/bitops.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sentinel.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-aof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/net.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/hiredis.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/sds.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/hiredis/async.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/linenoise/linenoise.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lapi.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lcode.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldebug.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldo.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldump.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lfunc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lgc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/llex.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmem.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lobject.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lopcodes.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lparser.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstate.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstring.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltable.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltm.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lundump.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lvm.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lzio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/strbuf.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lauxlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lbaselib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ldblib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/liolib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lmathlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loslib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/ltablib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lstrlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/loadlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/linit.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cjson.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_struct.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua_cmsgpack.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/lua.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/luac.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/lua/src/print.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/conftest.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/jemalloc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/arena.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/atomic.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/base.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/bitmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_dss.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/chunk_mmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ckh.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/ctl.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/extent.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/hash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/huge.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/mutex.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/prof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/quarantine.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/rtree.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/stats.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tcache.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/util.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/deps/jemalloc/src/tsd.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/adlist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ae.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/anet.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zmalloc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_c.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_d.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pqsort.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zipmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sha1.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ziplist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/networking.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/object.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/db.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/replication.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rdb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_string.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_list.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_set.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_zset.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_hash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/aof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pubsub.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/multi.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/debug.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sort.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/intset.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/syncio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/migrate.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/endianconv.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/slowlog.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/scripting.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rand.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/memtest.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/crc64.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/bitops.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sentinel.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/notify.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/setproctitle.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-aof.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.c	2013-11-22 17:25:29.000000000 +0800
@@ -25,15 +25,39 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-
 #include "redis.h"
 
+#include <fcntl.h>
+#include <sys/stat.h>
+
+static struct {
+    const char     *name;
+    const int       value;
+} validSyslogFacilities[] = {
+    {"user",    LOG_USER},
+    {"local0",  LOG_LOCAL0},
+    {"local1",  LOG_LOCAL1},
+    {"local2",  LOG_LOCAL2},
+    {"local3",  LOG_LOCAL3},
+    {"local4",  LOG_LOCAL4},
+    {"local5",  LOG_LOCAL5},
+    {"local6",  LOG_LOCAL6},
+    {"local7",  LOG_LOCAL7},
+    {NULL, 0}
+};
+
+clientBufferLimitsConfig clientBufferLimitsDefaults[REDIS_CLIENT_LIMIT_NUM_CLASSES] = {
+    {0, 0, 0}, /* normal */
+    {1024*1024*256, 1024*1024*64, 60}, /* slave */
+    {1024*1024*32, 1024*1024*8, 60}  /* pubsub */
+};
+
 /*-----------------------------------------------------------------------------
  * Config file parsing
  *----------------------------------------------------------------------------*/
 
 int yesnotoi(char *s) {
     if (!strcasecmp(s,"yes")) return 1;
@@ -78,13 +102,13 @@
             goto loaderr;
         }
 
         /* Skip this line if the resulting command vector is empty. */
         if (argc == 0) {
             sdsfreesplitres(argv,argc);
-            return;
+            continue;
         }
         sdstolower(argv[0]);
 
         /* Execute config directives */
         if (!strcasecmp(argv[0],"timeout") && argc == 2) {
             server.maxidletime = atoi(argv[1]);
@@ -98,14 +122,21 @@
             }
         } else if (!strcasecmp(argv[0],"port") && argc == 2) {
             server.port = atoi(argv[1]);
             if (server.port < 0 || server.port > 65535) {
                 err = "Invalid port"; goto loaderr;
             }
-        } else if (!strcasecmp(argv[0],"bind") && argc == 2) {
-            server.bindaddr = zstrdup(argv[1]);
+        } else if (!strcasecmp(argv[0],"bind") && argc >= 2) {
+            int j, addresses = argc-1;
+
+            if (addresses > REDIS_BINDADDR_MAX) {
+                err = "Too many bind addresses specified"; goto loaderr;
+            }
+            for (j = 0; j < addresses; j++)
+                server.bindaddr[j] = zstrdup(argv[j+1]);
+            server.bindaddr_count = addresses;
         } else if (!strcasecmp(argv[0],"unixsocket") && argc == 2) {
             server.unixsocket = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"unixsocketperm") && argc == 2) {
             errno = 0;
             server.unixsocketperm = (mode_t)strtol(argv[1], NULL, 8);
             if (errno || server.unixsocketperm > 0777) {
@@ -137,18 +168,15 @@
                 err = "Invalid log level. Must be one of debug, notice, warning";
                 goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"logfile") && argc == 2) {
             FILE *logfp;
 
+            zfree(server.logfile);
             server.logfile = zstrdup(argv[1]);
-            if (!strcasecmp(server.logfile,"stdout")) {
-                zfree(server.logfile);
-                server.logfile = NULL;
-            }
-            if (server.logfile) {
+            if (server.logfile[0] != '\0') {
                 /* Test if we are able to open the file. The server will not
                  * be able to abort just for this problem later... */
                 logfp = fopen(server.logfile,"a");
                 if (logfp == NULL) {
                     err = sdscatprintf(sdsempty(),
                         "Can't open the log file: %s", strerror(errno));
@@ -161,27 +189,12 @@
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"syslog-ident") && argc == 2) {
             if (server.syslog_ident) zfree(server.syslog_ident);
             server.syslog_ident = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"syslog-facility") && argc == 2) {
-            struct {
-                const char     *name;
-                const int       value;
-            } validSyslogFacilities[] = {
-                {"user",    LOG_USER},
-                {"local0",  LOG_LOCAL0},
-                {"local1",  LOG_LOCAL1},
-                {"local2",  LOG_LOCAL2},
-                {"local3",  LOG_LOCAL3},
-                {"local4",  LOG_LOCAL4},
-                {"local5",  LOG_LOCAL5},
-                {"local6",  LOG_LOCAL6},
-                {"local7",  LOG_LOCAL7},
-                {NULL, 0}
-            };
             int i;
 
             for (i = 0; validSyslogFacilities[i].name; i++) {
                 if (!strcasecmp(validSyslogFacilities[i].name, argv[1])) {
                     server.syslog_facility = validSyslogFacilities[i].value;
                     break;
@@ -246,12 +259,25 @@
                 goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"repl-disable-tcp-nodelay") && argc==2) {
             if ((server.repl_disable_tcp_nodelay = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
+        } else if (!strcasecmp(argv[0],"repl-backlog-size") && argc == 2) {
+            long long size = memtoll(argv[1],NULL);
+            if (size <= 0) {
+                err = "repl-backlog-size must be 1 or greater.";
+                goto loaderr;
+            }
+            resizeReplicationBacklog(size);
+        } else if (!strcasecmp(argv[0],"repl-backlog-ttl") && argc == 2) {
+            server.repl_backlog_time_limit = atoi(argv[1]);
+            if (server.repl_backlog_time_limit < 0) {
+                err = "repl-backlog-ttl can't be negative ";
+                goto loaderr;
+            }
         } else if (!strcasecmp(argv[0],"masterauth") && argc == 2) {
         	server.masterauth = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"slave-serve-stale-data") && argc == 2) {
             if ((server.repl_serve_stale_data = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
@@ -284,12 +310,16 @@
 
             if ((yes = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
             server.aof_state = yes ? REDIS_AOF_ON : REDIS_AOF_OFF;
         } else if (!strcasecmp(argv[0],"appendfilename") && argc == 2) {
+            if (!pathIsBaseName(argv[1])) {
+                err = "appendfilename can't be a path, just a filename";
+                goto loaderr;
+            }
             zfree(server.aof_filename);
             server.aof_filename = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"no-appendfsync-on-rewrite")
                    && argc == 2) {
             if ((server.aof_no_fsync_on_rewrite= yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
@@ -330,12 +360,16 @@
             }
             server.requirepass = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"pidfile") && argc == 2) {
             zfree(server.pidfile);
             server.pidfile = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"dbfilename") && argc == 2) {
+            if (!pathIsBaseName(argv[1])) {
+                err = "dbfilename can't be a path, just a filename";
+                goto loaderr;
+            }
             zfree(server.rdb_filename);
             server.rdb_filename = zstrdup(argv[1]);
         } else if (!strcasecmp(argv[0],"hash-max-ziplist-entries") && argc == 2) {
             server.hash_max_ziplist_entries = memtoll(argv[1], NULL);
         } else if (!strcasecmp(argv[0],"hash-max-ziplist-value") && argc == 2) {
             server.hash_max_ziplist_value = memtoll(argv[1], NULL);
@@ -406,12 +440,30 @@
                    argc == 2) {
             if ((server.stop_writes_on_bgsave_err = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"slave-priority") && argc == 2) {
             server.slave_priority = atoi(argv[1]);
+        } else if (!strcasecmp(argv[0],"min-slaves-to-write") && argc == 2) {
+            server.repl_min_slaves_to_write = atoi(argv[1]);
+            if (server.repl_min_slaves_to_write < 0) {
+                err = "Invalid value for min-slaves-to-write."; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"min-slaves-max-lag") && argc == 2) {
+            server.repl_min_slaves_max_lag = atoi(argv[1]);
+            if (server.repl_min_slaves_max_lag < 0) {
+                err = "Invalid value for min-slaves-max-lag."; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"notify-keyspace-events") && argc == 2) {
+            int flags = keyspaceEventsStringToFlags(argv[1]);
+
+            if (flags == -1) {
+                err = "Invalid event class character. Use 'g$lshzxeA'.";
+                goto loaderr;
+            }
+            server.notify_keyspace_events = flags;
         } else if (!strcasecmp(argv[0],"sentinel")) {
             /* argc == 1 is handled by main() as we need to enter the sentinel
              * mode ASAP. */
             if (argc != 1) {
                 if (!server.sentinel_mode) {
                     err = "sentinel directive while not in sentinel mode";
@@ -471,23 +523,27 @@
     }
     loadServerConfigFromString(config);
     sdsfree(config);
 }
 
 /*-----------------------------------------------------------------------------
- * CONFIG command for remote configuration
+ * CONFIG SET implementation
  *----------------------------------------------------------------------------*/
 
 void configSetCommand(redisClient *c) {
     robj *o;
     long long ll;
     redisAssertWithInfo(c,c->argv[2],c->argv[2]->encoding == REDIS_ENCODING_RAW);
     redisAssertWithInfo(c,c->argv[2],c->argv[3]->encoding == REDIS_ENCODING_RAW);
     o = c->argv[3];
 
     if (!strcasecmp(c->argv[2]->ptr,"dbfilename")) {
+        if (!pathIsBaseName(o->ptr)) {
+            addReplyError(c, "dbfilename can't be a path, just a filename");
+            return;
+        }
         zfree(server.rdb_filename);
         server.rdb_filename = zstrdup(o->ptr);
     } else if (!strcasecmp(c->argv[2]->ptr,"requirepass")) {
         if (sdslen(o->ptr) > REDIS_AUTHPASS_MAX_LEN) goto badfmt;
         zfree(server.requirepass);
         server.requirepass = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
@@ -501,16 +557,41 @@
         if (server.maxmemory) {
             if (server.maxmemory < zmalloc_used_memory()) {
                 redisLog(REDIS_WARNING,"WARNING: the new maxmemory value set via CONFIG SET is smaller than the current memory usage. This will result in keys eviction and/or inability to accept new write commands depending on the maxmemory-policy.");
             }
             freeMemoryIfNeeded();
         }
+    } else if (!strcasecmp(c->argv[2]->ptr,"maxclients")) {
+        int orig_value = server.maxclients;
+
+        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
+
+        /* Try to check if the OS is capable of supporting so many FDs. */
+        server.maxclients = ll;
+        if (ll > orig_value) {
+            adjustOpenFilesLimit();
+            if (server.maxclients != ll) {
+                addReplyErrorFormat(c,"The operating system is not able to handle the specified number of clients, try with %d", server.maxclients);
+                server.maxclients = orig_value;
+                return;
+            }
+            if (aeGetSetSize(server.el) <
+                server.maxclients + REDIS_EVENTLOOP_FDSET_INCR)
+            {
+                if (aeResizeSetSize(server.el,
+                    server.maxclients + REDIS_EVENTLOOP_FDSET_INCR) == AE_ERR)
+                {
+                    addReplyError(c,"The event loop API used by Redis is not able to handle the specified number of clients");
+                    server.maxclients = orig_value;
+                    return;
+                }
+            }
+        }
     } else if (!strcasecmp(c->argv[2]->ptr,"hz")) {
-        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll < 0) goto badfmt;
-        server.hz = (int) ll;
+        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
+        server.hz = ll;
         if (server.hz < REDIS_MIN_HZ) server.hz = REDIS_MIN_HZ;
         if (server.hz > REDIS_MAX_HZ) server.hz = REDIS_MAX_HZ;
     } else if (!strcasecmp(c->argv[2]->ptr,"maxmemory-policy")) {
         if (!strcasecmp(o->ptr,"volatile-lru")) {
             server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU;
         } else if (!strcasecmp(o->ptr,"volatile-random")) {
@@ -722,37 +803,53 @@
     } else if (!strcasecmp(c->argv[2]->ptr,"repl-ping-slave-period")) {
         if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll <= 0) goto badfmt;
         server.repl_ping_slave_period = ll;
     } else if (!strcasecmp(c->argv[2]->ptr,"repl-timeout")) {
         if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll <= 0) goto badfmt;
         server.repl_timeout = ll;
+    } else if (!strcasecmp(c->argv[2]->ptr,"repl-backlog-size")) {
+        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll <= 0) goto badfmt;
+        resizeReplicationBacklog(ll);
+    } else if (!strcasecmp(c->argv[2]->ptr,"repl-backlog-ttl")) {
+        if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
+        server.repl_backlog_time_limit = ll;
     } else if (!strcasecmp(c->argv[2]->ptr,"watchdog-period")) {
         if (getLongLongFromObject(o,&ll) == REDIS_ERR || ll < 0) goto badfmt;
         if (ll)
             enableWatchdog(ll);
         else
             disableWatchdog();
     } else if (!strcasecmp(c->argv[2]->ptr,"rdbcompression")) {
         int yn = yesnotoi(o->ptr);
 
         if (yn == -1) goto badfmt;
         server.rdb_compression = yn;
-    } else if (!strcasecmp(c->argv[2]->ptr,"rdbchecksum")) {
-        int yn = yesnotoi(o->ptr);
+    } else if (!strcasecmp(c->argv[2]->ptr,"notify-keyspace-events")) {
+        int flags = keyspaceEventsStringToFlags(o->ptr);
 
-        if (yn == -1) goto badfmt;
-        server.rdb_checksum = yn;
+        if (flags == -1) goto badfmt;
+        server.notify_keyspace_events = flags;
     } else if (!strcasecmp(c->argv[2]->ptr,"repl-disable-tcp-nodelay")) {
         int yn = yesnotoi(o->ptr);
 
         if (yn == -1) goto badfmt;
         server.repl_disable_tcp_nodelay = yn;
     } else if (!strcasecmp(c->argv[2]->ptr,"slave-priority")) {
         if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
-            ll <= 0) goto badfmt;
+            ll < 0) goto badfmt;
         server.slave_priority = ll;
+    } else if (!strcasecmp(c->argv[2]->ptr,"min-slaves-to-write")) {
+        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
+            ll < 0) goto badfmt;
+        server.repl_min_slaves_to_write = ll;
+        refreshGoodSlavesCount();
+    } else if (!strcasecmp(c->argv[2]->ptr,"min-slaves-max-lag")) {
+        if (getLongLongFromObject(o,&ll) == REDIS_ERR ||
+            ll < 0) goto badfmt;
+        server.repl_min_slaves_max_lag = ll;
+        refreshGoodSlavesCount();
     } else {
         addReplyErrorFormat(c,"Unsupported CONFIG parameter: %s",
             (char*)c->argv[2]->ptr);
         return;
     }
     addReply(c,shared.ok);
@@ -761,12 +858,16 @@
 badfmt: /* Bad format errors */
     addReplyErrorFormat(c,"Invalid argument '%s' for CONFIG SET '%s'",
             (char*)o->ptr,
             (char*)c->argv[2]->ptr);
 }
 
+/*-----------------------------------------------------------------------------
+ * CONFIG GET implementation
+ *----------------------------------------------------------------------------*/
+
 #define config_get_string_field(_name,_var) do { \
     if (stringmatch(pattern,_name,0)) { \
         addReplyBulkCString(c,_name); \
         addReplyBulkCString(c,_var ? _var : ""); \
         matches++; \
     } \
@@ -798,13 +899,12 @@
     redisAssertWithInfo(c,o,o->encoding == REDIS_ENCODING_RAW);
 
     /* String values */
     config_get_string_field("dbfilename",server.rdb_filename);
     config_get_string_field("requirepass",server.requirepass);
     config_get_string_field("masterauth",server.masterauth);
-    config_get_string_field("bind",server.bindaddr);
     config_get_string_field("unixsocket",server.unixsocket);
     config_get_string_field("logfile",server.logfile);
     config_get_string_field("pidfile",server.pidfile);
 
     /* Numerical values */
     config_get_numerical_field("maxmemory",server.maxmemory);
@@ -835,15 +935,19 @@
     config_get_numerical_field("slowlog-max-len",
             server.slowlog_max_len);
     config_get_numerical_field("port",server.port);
     config_get_numerical_field("databases",server.dbnum);
     config_get_numerical_field("repl-ping-slave-period",server.repl_ping_slave_period);
     config_get_numerical_field("repl-timeout",server.repl_timeout);
+    config_get_numerical_field("repl-backlog-size",server.repl_backlog_size);
+    config_get_numerical_field("repl-backlog-ttl",server.repl_backlog_time_limit);
     config_get_numerical_field("maxclients",server.maxclients);
     config_get_numerical_field("watchdog-period",server.watchdog_period);
     config_get_numerical_field("slave-priority",server.slave_priority);
+    config_get_numerical_field("min-slaves-to-write",server.repl_min_slaves_to_write);
+    config_get_numerical_field("min-slaves-max-lag",server.repl_min_slaves_max_lag);
     config_get_numerical_field("hz",server.hz);
 
     /* Bool (yes/no) values */
     config_get_bool_field("no-appendfsync-on-rewrite",
             server.aof_no_fsync_on_rewrite);
     config_get_bool_field("slave-serve-stale-data",
@@ -909,14 +1013,14 @@
     }
     if (stringmatch(pattern,"save",0)) {
         sds buf = sdsempty();
         int j;
 
         for (j = 0; j < server.saveparamslen; j++) {
-            buf = sdscatprintf(buf,"%ld %d",
-                    server.saveparams[j].seconds,
+            buf = sdscatprintf(buf,"%jd %d",
+                    (intmax_t)server.saveparams[j].seconds,
                     server.saveparams[j].changes);
             if (j != server.saveparamslen-1)
                 buf = sdscatlen(buf," ",1);
         }
         addReplyBulkCString(c,"save");
         addReplyBulkCString(c,buf);
@@ -971,15 +1075,643 @@
                 server.masterhost, server.masterport);
         else
             buf[0] = '\0';
         addReplyBulkCString(c,buf);
         matches++;
     }
+    if (stringmatch(pattern,"notify-keyspace-events",0)) {
+        robj *flagsobj = createObject(REDIS_STRING,
+            keyspaceEventsFlagsToString(server.notify_keyspace_events));
+
+        addReplyBulkCString(c,"notify-keyspace-events");
+        addReplyBulk(c,flagsobj);
+        decrRefCount(flagsobj);
+        matches++;
+    }
+    if (stringmatch(pattern,"bind",0)) {
+        sds aux = sdsjoin(server.bindaddr,server.bindaddr_count," ");
+
+        addReplyBulkCString(c,"bind");
+        addReplyBulkCString(c,aux);
+        sdsfree(aux);
+        matches++;
+    }
     setDeferredMultiBulkLength(c,replylen,matches*2);
 }
 
+/*-----------------------------------------------------------------------------
+ * CONFIG REWRITE implementation
+ *----------------------------------------------------------------------------*/
+
+#define REDIS_CONFIG_REWRITE_SIGNATURE "# Generated by CONFIG REWRITE"
+
+/* We use the following dictionary type to store where a configuration
+ * option is mentioned in the old configuration file, so it's
+ * like "maxmemory" -> list of line numbers (first line is zero). */
+unsigned int dictSdsHash(const void *key);
+int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
+void dictSdsDestructor(void *privdata, void *val);
+void dictListDestructor(void *privdata, void *val);
+
+/* Sentinel config rewriting is implemented inside sentinel.c by
+ * rewriteConfigSentinelOption(). */
+void rewriteConfigSentinelOption(struct rewriteConfigState *state);
+
+dictType optionToLineDictType = {
+    dictSdsHash,                /* hash function */
+    NULL,                       /* key dup */
+    NULL,                       /* val dup */
+    dictSdsKeyCompare,          /* key compare */
+    dictSdsDestructor,          /* key destructor */
+    dictListDestructor          /* val destructor */
+};
+
+/* The config rewrite state. */
+struct rewriteConfigState {
+    dict *option_to_line; /* Option -> list of config file lines map */
+    int numlines;         /* Number of lines in current config */
+    sds *lines;           /* Current lines as an array of sds strings */
+    int has_tail;         /* True if we already added directives that were
+                             not present in the original config file. */
+};
+
+/* Append the new line to the current configuration state. */
+void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {
+    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));
+    state->lines[state->numlines++] = line;
+}
+
+/* Populate the option -> list of line numbers map. */
+void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {
+    list *l = dictFetchValue(state->option_to_line,option);
+
+    if (l == NULL) {
+        l = listCreate();
+        dictAdd(state->option_to_line,sdsdup(option),l);
+    }
+    listAddNodeTail(l,(void*)(long)linenum);
+}
+
+/* Read the old file, split it into lines to populate a newly created
+ * config rewrite state, and return it to the caller.
+ *
+ * If it is impossible to read the old file, NULL is returned.
+ * If the old file does not exist at all, an empty state is returned. */
+struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
+    FILE *fp = fopen(path,"r");
+    struct rewriteConfigState *state = zmalloc(sizeof(*state));
+    char buf[REDIS_CONFIGLINE_MAX+1];
+    int linenum = -1;
+
+    if (fp == NULL && errno != ENOENT) return NULL;
+
+    state->option_to_line = dictCreate(&optionToLineDictType,NULL);
+    state->numlines = 0;
+    state->lines = NULL;
+    state->has_tail = 0;
+    if (fp == NULL) return state;
+
+    /* Read the old file line by line, populate the state. */
+    while(fgets(buf,REDIS_CONFIGLINE_MAX+1,fp) != NULL) {
+        int argc;
+        sds *argv;
+        sds line = sdstrim(sdsnew(buf),"\r\n\t ");
+
+        linenum++; /* Zero based, so we init at -1 */
+
+        /* Handle comments and empty lines. */
+        if (line[0] == '#' || line[0] == '\0') {
+            if (!state->has_tail && !strcmp(line,REDIS_CONFIG_REWRITE_SIGNATURE))
+                state->has_tail = 1;
+            rewriteConfigAppendLine(state,line);
+            continue;
+        }
+
+        /* Not a comment, split into arguments. */
+        argv = sdssplitargs(line,&argc);
+        if (argv == NULL) {
+            /* Apparently the line is unparsable for some reason, for
+             * instance it may have unbalanced quotes. Load it as a
+             * comment. */
+            sds aux = sdsnew("# ??? ");
+            aux = sdscatsds(aux,line);
+            sdsfree(line);
+            rewriteConfigAppendLine(state,aux);
+            continue;
+        }
+
+        sdstolower(argv[0]); /* We only want lowercase config directives. */
+
+        /* Now we populate the state according to the content of this line.
+         * Append the line and populate the option -> line numbers map. */
+        rewriteConfigAppendLine(state,line);
+        rewriteConfigAddLineNumberToOption(state,argv[0],linenum);
+
+        sdsfreesplitres(argv,argc);
+    }
+    fclose(fp);
+    return state;
+}
+
+/* Rewrite the specified configuration option with the new "line".
+ * It progressively uses lines of the file that were already used for the same
+ * configuration option in the old version of the file, removing that line from
+ * the map of options -> line numbers.
+ *
+ * If there are lines associated with a given configuration option and
+ * "force" is non-zero, the line is appended to the configuration file.
+ * Usually "force" is true when an option has not its default value, so it
+ * must be rewritten even if not present previously.
+ * 
+ * The first time a line is appended into a configuration file, a comment
+ * is added to show that starting from that point the config file was generated
+ * by CONFIG REWRITE.
+ *
+ * "line" is either used, or freed, so the caller does not need to free it
+ * in any way. */
+void rewriteConfigRewriteLine(struct rewriteConfigState *state, char *option, sds line, int force) {
+    sds o = sdsnew(option);
+    list *l = dictFetchValue(state->option_to_line,o);
+
+    if (!l && !force) {
+        /* Option not used previously, and we are not forced to use it. */
+        sdsfree(line);
+        sdsfree(o);
+        return;
+    }
+
+    if (l) {
+        listNode *ln = listFirst(l);
+        int linenum = (long) ln->value;
+
+        /* There are still lines in the old configuration file we can reuse
+         * for this option. Replace the line with the new one. */
+        listDelNode(l,ln);
+        if (listLength(l) == 0) dictDelete(state->option_to_line,o);
+        sdsfree(state->lines[linenum]);
+        state->lines[linenum] = line;
+    } else {
+        /* Append a new line. */
+        if (!state->has_tail) {
+            rewriteConfigAppendLine(state,
+                sdsnew(REDIS_CONFIG_REWRITE_SIGNATURE));
+            state->has_tail = 1;
+        }
+        rewriteConfigAppendLine(state,line);
+    }
+    sdsfree(o);
+}
+
+/* Write the long long 'bytes' value as a string in a way that is parsable
+ * inside redis.conf. If possible uses the GB, MB, KB notation. */
+int rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {
+    int gb = 1024*1024*1024;
+    int mb = 1024*1024;
+    int kb = 1024;
+
+    if (bytes && (bytes % gb) == 0) {
+        return snprintf(buf,len,"%lldgb",bytes/gb);
+    } else if (bytes && (bytes % mb) == 0) {
+        return snprintf(buf,len,"%lldmb",bytes/mb);
+    } else if (bytes && (bytes % kb) == 0) {
+        return snprintf(buf,len,"%lldkb",bytes/kb);
+    } else {
+        return snprintf(buf,len,"%lld",bytes);
+    }
+}
+
+/* Rewrite a simple "option-name <bytes>" configuration option. */
+void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {
+    char buf[64];
+    int force = value != defvalue;
+    sds line;
+
+    rewriteConfigFormatMemory(buf,sizeof(buf),value);
+    line = sdscatprintf(sdsempty(),"%s %s",option,buf);
+    rewriteConfigRewriteLine(state,option,line,force);
+
+}
+
+/* Rewrite a yes/no option. */
+void rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
+    int force = value != defvalue;
+    sds line = sdscatprintf(sdsempty(),"%s %s",option,
+        value ? "yes" : "no");
+
+    rewriteConfigRewriteLine(state,option,line,force);
+}
+
+/* Rewrite a string option. */
+void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {
+    int force = 1;
+    sds line;
+
+    /* String options set to NULL need to be not present at all in the
+     * configuration file to be set to NULL again at the next reboot. */
+    if (value == NULL) return;
+
+    /* Compare the strings as sds strings to have a binary safe comparison. */
+    if (defvalue && strcmp(value,defvalue) == 0) force = 0;
+
+    line = sdsnew(option);
+    line = sdscatlen(line, " ", 1);
+    line = sdscatrepr(line, value, strlen(value));
+
+    rewriteConfigRewriteLine(state,option,line,force);
+}
+
+/* Rewrite a numerical (long long range) option. */
+void rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {
+    int force = value != defvalue;
+    sds line = sdscatprintf(sdsempty(),"%s %lld",option,value);
+
+    rewriteConfigRewriteLine(state,option,line,force);
+}
+
+/* Rewrite a octal option. */
+void rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
+    int force = value != defvalue;
+    sds line = sdscatprintf(sdsempty(),"%s %o",option,value);
+
+    rewriteConfigRewriteLine(state,option,line,force);
+}
+
+/* Rewrite an enumeration option, after the "value" every enum/value pair
+ * is specified, terminated by NULL. After NULL the default value is
+ * specified. See how the function is used for more information. */
+void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, ...) {
+    va_list ap;
+    char *enum_name, *matching_name = NULL;
+    int enum_val, def_val, force;
+    sds line;
+ 
+    va_start(ap, value);
+    while(1) {
+        enum_name = va_arg(ap,char*);
+        enum_val = va_arg(ap,int);
+        if (enum_name == NULL) {
+            def_val = enum_val;
+            break;
+        }
+        if (value == enum_val) matching_name = enum_name;
+    }
+    va_end(ap);
+
+    force = value != def_val;
+    line = sdscatprintf(sdsempty(),"%s %s",option,matching_name);
+    rewriteConfigRewriteLine(state,option,line,force);
+}
+
+/* Rewrite the syslog-fability option. */
+void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {
+    int value = server.syslog_facility, j;
+    int force = value != LOG_LOCAL0;
+    char *name = NULL, *option = "syslog-facility";
+    sds line;
+
+    for (j = 0; validSyslogFacilities[j].name; j++) {
+        if (validSyslogFacilities[j].value == value) {
+            name = (char*) validSyslogFacilities[j].name;
+            break;
+        }
+    }
+    line = sdscatprintf(sdsempty(),"%s %s",option,name);
+    rewriteConfigRewriteLine(state,option,line,force);
+}
+
+/* Rewrite the save option. */
+void rewriteConfigSaveOption(struct rewriteConfigState *state) {
+    int j;
+    sds line;
+
+    /* Note that if there are no save parameters at all, all the current
+     * config line with "save" will be detected as orphaned and deleted,
+     * resulting into no RDB persistence as expected. */
+    for (j = 0; j < server.saveparamslen; j++) {
+        line = sdscatprintf(sdsempty(),"save %ld %d",
+            server.saveparams[j].seconds, server.saveparams[j].changes);
+        rewriteConfigRewriteLine(state,"save",line,1);
+    }
+}
+
+/* Rewrite the dir option, always using absolute paths.*/
+void rewriteConfigDirOption(struct rewriteConfigState *state) {
+    char cwd[1024];
+
+    if (getcwd(cwd,sizeof(cwd)) == NULL) return; /* no rewrite on error. */
+    rewriteConfigStringOption(state,"dir",cwd,NULL);
+}
+
+/* Rewrite the slaveof option. */
+void rewriteConfigSlaveofOption(struct rewriteConfigState *state) {
+    char *option = "slaveof";
+    sds line;
+
+    /* If this is a master, we want all the slaveof config options
+     * in the file to be removed. */
+    if (server.masterhost == NULL) return;
+    line = sdscatprintf(sdsempty(),"%s %s %d", option,
+        server.masterhost, server.masterport);
+    rewriteConfigRewriteLine(state,option,line,1);
+}
+
+/* Rewrite the appendonly option. */
+void rewriteConfigAppendonlyOption(struct rewriteConfigState *state) {
+    int force = server.aof_state != REDIS_AOF_OFF;
+    char *option = "appendonly";
+    sds line;
+
+    line = sdscatprintf(sdsempty(),"%s %s", option,
+        (server.aof_state == REDIS_AOF_OFF) ? "no" : "yes");
+    rewriteConfigRewriteLine(state,option,line,force);
+}
+
+/* Rewrite the notify-keyspace-events option. */
+void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {
+    int force = server.notify_keyspace_events != 0;
+    char *option = "notify-keyspace-events";
+    sds line, flags;
+
+    flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);
+    line = sdsnew(option);
+    line = sdscatlen(line, " ", 1);
+    line = sdscatrepr(line, flags, sdslen(flags));
+    sdsfree(flags);
+    rewriteConfigRewriteLine(state,option,line,force);
+}
+
+/* Rewrite the client-output-buffer-limit option. */
+void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {
+    int j;
+    char *option = "client-output-buffer-limit";
+
+    for (j = 0; j < REDIS_CLIENT_LIMIT_NUM_CLASSES; j++) {
+        int force = (server.client_obuf_limits[j].hard_limit_bytes !=
+                    clientBufferLimitsDefaults[j].hard_limit_bytes) ||
+                    (server.client_obuf_limits[j].soft_limit_bytes !=
+                    clientBufferLimitsDefaults[j].soft_limit_bytes) ||
+                    (server.client_obuf_limits[j].soft_limit_seconds !=
+                    clientBufferLimitsDefaults[j].soft_limit_seconds);
+        sds line;
+        char hard[64], soft[64];
+
+        rewriteConfigFormatMemory(hard,sizeof(hard),
+                server.client_obuf_limits[j].hard_limit_bytes);
+        rewriteConfigFormatMemory(soft,sizeof(soft),
+                server.client_obuf_limits[j].soft_limit_bytes);
+
+        line = sdscatprintf(sdsempty(),"%s %s %s %s %ld",
+                option, getClientLimitClassName(j), hard, soft,
+                (long) server.client_obuf_limits[j].soft_limit_seconds);
+        rewriteConfigRewriteLine(state,option,line,force);
+    }
+}
+
+/* Rewrite the bind option. */
+void rewriteConfigBindOption(struct rewriteConfigState *state) {
+    int force = 1;
+    sds line, addresses;
+    char *option = "bind";
+
+    /* Nothing to rewrite if we don't have bind addresses. */
+    if (server.bindaddr_count == 0) return;
+
+    /* Rewrite as bind <addr1> <addr2> ... <addrN> */
+    addresses = sdsjoin(server.bindaddr,server.bindaddr_count," ");
+    line = sdsnew(option);
+    line = sdscatlen(line, " ", 1);
+    line = sdscatsds(line, addresses);
+    sdsfree(addresses);
+
+    rewriteConfigRewriteLine(state,option,line,force);
+}
+
+/* Glue together the configuration lines in the current configuration
+ * rewrite state into a single string, stripping multiple empty lines. */
+sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
+    sds content = sdsempty();
+    int j, was_empty = 0;
+
+    for (j = 0; j < state->numlines; j++) {
+        /* Every cluster of empty lines is turned into a single empty line. */
+        if (sdslen(state->lines[j]) == 0) {
+            if (was_empty) continue;
+            was_empty = 1;
+        } else {
+            was_empty = 0;
+        }
+        content = sdscatsds(content,state->lines[j]);
+        content = sdscatlen(content,"\n",1);
+    }
+    return content;
+}
+
+/* Free the configuration rewrite state. */
+void rewriteConfigReleaseState(struct rewriteConfigState *state) {
+    sdsfreesplitres(state->lines,state->numlines);
+    dictRelease(state->option_to_line);
+    zfree(state);
+}
+
+/* At the end of the rewrite process the state contains the remaining
+ * map between "option name" => "lines in the original config file".
+ * Lines used by the rewrite process were removed by the function
+ * rewriteConfigRewriteLine(), all the other lines are "orphaned" and
+ * should be replaced by empty lines.
+ *
+ * This function does just this, iterating all the option names and
+ * blanking all the lines still associated. */
+void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
+    dictIterator *di = dictGetIterator(state->option_to_line);
+    dictEntry *de;
+
+    while((de = dictNext(di)) != NULL) {
+        list *l = dictGetVal(de);
+
+        while(listLength(l)) {
+            listNode *ln = listFirst(l);
+            int linenum = (long) ln->value;
+
+            sdsfree(state->lines[linenum]);
+            state->lines[linenum] = sdsempty();
+            listDelNode(l,ln);
+        }
+    }
+    dictReleaseIterator(di);
+}
+
+/* This function overwrites the old configuration file with the new content.
+ *
+ * 1) The old file length is obtained.
+ * 2) If the new content is smaller, padding is added.
+ * 3) A single write(2) call is used to replace the content of the file.
+ * 4) Later the file is truncated to the length of the new content.
+ *
+ * This way we are sure the file is left in a consistent state even if the
+ * process is stopped between any of the four operations.
+ *
+ * The function returns 0 on success, otherwise -1 is returned and errno
+ * set accordingly. */
+int rewriteConfigOverwriteFile(char *configfile, sds content) {
+    int retval = 0;
+    int fd = open(configfile,O_RDWR|O_CREAT,0644);
+    int content_size = sdslen(content), padding = 0;
+    struct stat sb;
+    sds content_padded;
+
+    /* 1) Open the old file (or create a new one if it does not
+     *    exist), get the size. */
+    if (fd == -1) return -1; /* errno set by open(). */
+    if (fstat(fd,&sb) == -1) {
+        close(fd);
+        return -1; /* errno set by fstat(). */
+    }
+
+    /* 2) Pad the content at least match the old file size. */
+    content_padded = sdsdup(content);
+    if (content_size < sb.st_size) {
+        /* If the old file was bigger, pad the content with
+         * a newline plus as many "#" chars as required. */
+        padding = sb.st_size - content_size;
+        content_padded = sdsgrowzero(content_padded,sb.st_size);
+        content_padded[content_size] = '\n';
+        memset(content_padded+content_size+1,'#',padding-1);
+    }
+
+    /* 3) Write the new content using a single write(2). */
+    if (write(fd,content_padded,strlen(content_padded)) == -1) {
+        retval = -1;
+        goto cleanup;
+    }
+
+    /* 4) Truncate the file to the right length if we used padding. */
+    if (padding) {
+        if (ftruncate(fd,content_size) == -1) {
+            /* Non critical error... */
+        }
+    }
+
+cleanup:
+    sdsfree(content_padded);
+    close(fd);
+    return retval;
+}
+
+/* Rewrite the configuration file at "path".
+ * If the configuration file already exists, we try at best to retain comments
+ * and overall structure.
+ *
+ * Configuration parameters that are at their default value, unless already
+ * explicitly included in the old configuration file, are not rewritten.
+ *
+ * On error -1 is returned and errno is set accordingly, otherwise 0. */
+int rewriteConfig(char *path) {
+    struct rewriteConfigState *state;
+    sds newcontent;
+    int retval;
+
+    /* Step 1: read the old config into our rewrite state. */
+    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
+
+    /* Step 2: rewrite every single option, replacing or appending it inside
+     * the rewrite state. */
+
+    /* TODO: Turn every default into a define, use it also in
+     * initServerConfig(). */
+    rewriteConfigYesNoOption(state,"daemonize",server.daemonize,0);
+    rewriteConfigStringOption(state,"pidfile",server.pidfile,REDIS_DEFAULT_PID_FILE);
+    rewriteConfigNumericalOption(state,"port",server.port,REDIS_SERVERPORT);
+    rewriteConfigBindOption(state);
+    rewriteConfigStringOption(state,"unixsocket",server.unixsocket,NULL);
+    rewriteConfigOctalOption(state,"unixsocketperm",server.unixsocketperm,REDIS_DEFAULT_UNIX_SOCKET_PERM);
+    rewriteConfigNumericalOption(state,"timeout",server.maxidletime,REDIS_MAXIDLETIME);
+    rewriteConfigNumericalOption(state,"tcp-keepalive",server.tcpkeepalive,REDIS_DEFAULT_TCP_KEEPALIVE);
+    rewriteConfigEnumOption(state,"loglevel",server.verbosity,
+        "debug", REDIS_DEBUG,
+        "verbose", REDIS_VERBOSE,
+        "notice", REDIS_NOTICE,
+        "warning", REDIS_WARNING,
+        NULL, REDIS_DEFAULT_VERBOSITY);
+    rewriteConfigStringOption(state,"logfile",server.logfile,REDIS_DEFAULT_LOGFILE);
+    rewriteConfigYesNoOption(state,"syslog-enabled",server.syslog_enabled,REDIS_DEFAULT_SYSLOG_ENABLED);
+    rewriteConfigStringOption(state,"syslog-ident",server.syslog_ident,REDIS_DEFAULT_SYSLOG_IDENT);
+    rewriteConfigSyslogfacilityOption(state);
+    rewriteConfigSaveOption(state);
+    rewriteConfigNumericalOption(state,"databases",server.dbnum,REDIS_DEFAULT_DBNUM);
+    rewriteConfigYesNoOption(state,"stop-writes-on-bgsave-error",server.stop_writes_on_bgsave_err,REDIS_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR);
+    rewriteConfigYesNoOption(state,"rdbcompression",server.rdb_compression,REDIS_DEFAULT_RDB_COMPRESSION);
+    rewriteConfigYesNoOption(state,"rdbchecksum",server.rdb_checksum,REDIS_DEFAULT_RDB_CHECKSUM);
+    rewriteConfigStringOption(state,"dbfilename",server.rdb_filename,REDIS_DEFAULT_RDB_FILENAME);
+    rewriteConfigDirOption(state);
+    rewriteConfigSlaveofOption(state);
+    rewriteConfigStringOption(state,"masterauth",server.masterauth,NULL);
+    rewriteConfigYesNoOption(state,"slave-serve-stale-data",server.repl_serve_stale_data,REDIS_DEFAULT_SLAVE_SERVE_STALE_DATA);
+    rewriteConfigYesNoOption(state,"slave-read-only",server.repl_slave_ro,REDIS_DEFAULT_SLAVE_READ_ONLY);
+    rewriteConfigNumericalOption(state,"repl-ping-slave-period",server.repl_ping_slave_period,REDIS_REPL_PING_SLAVE_PERIOD);
+    rewriteConfigNumericalOption(state,"repl-timeout",server.repl_timeout,REDIS_REPL_TIMEOUT);
+    rewriteConfigBytesOption(state,"repl-backlog-size",server.repl_backlog_size,REDIS_DEFAULT_REPL_BACKLOG_SIZE);
+    rewriteConfigBytesOption(state,"repl-backlog-ttl",server.repl_backlog_time_limit,REDIS_DEFAULT_REPL_BACKLOG_TIME_LIMIT);
+    rewriteConfigYesNoOption(state,"repl-disable-tcp-nodelay",server.repl_disable_tcp_nodelay,REDIS_DEFAULT_REPL_DISABLE_TCP_NODELAY);
+    rewriteConfigNumericalOption(state,"slave-priority",server.slave_priority,REDIS_DEFAULT_SLAVE_PRIORITY);
+    rewriteConfigStringOption(state,"requirepass",server.requirepass,NULL);
+    rewriteConfigNumericalOption(state,"maxclients",server.maxclients,REDIS_MAX_CLIENTS);
+    rewriteConfigBytesOption(state,"maxmemory",server.maxmemory,REDIS_DEFAULT_MAXMEMORY);
+    rewriteConfigEnumOption(state,"maxmemory-policy",server.maxmemory_policy,
+        "volatile-lru", REDIS_MAXMEMORY_VOLATILE_LRU,
+        "allkeys-lru", REDIS_MAXMEMORY_ALLKEYS_LRU,
+        "volatile-random", REDIS_MAXMEMORY_VOLATILE_RANDOM,
+        "allkeys-random", REDIS_MAXMEMORY_ALLKEYS_RANDOM,
+        "volatile-ttl", REDIS_MAXMEMORY_VOLATILE_TTL,
+        "noeviction", REDIS_MAXMEMORY_NO_EVICTION,
+        NULL, REDIS_DEFAULT_MAXMEMORY_POLICY);
+    rewriteConfigNumericalOption(state,"maxmemory-samples",server.maxmemory_samples,REDIS_DEFAULT_MAXMEMORY_SAMPLES);
+    rewriteConfigAppendonlyOption(state);
+    rewriteConfigEnumOption(state,"appendfsync",server.aof_fsync,
+        "everysec", AOF_FSYNC_EVERYSEC,
+        "always", AOF_FSYNC_ALWAYS,
+        "no", AOF_FSYNC_NO,
+        NULL, REDIS_DEFAULT_AOF_FSYNC);
+    rewriteConfigYesNoOption(state,"no-appendfsync-on-rewrite",server.aof_no_fsync_on_rewrite,REDIS_DEFAULT_AOF_NO_FSYNC_ON_REWRITE);
+    rewriteConfigNumericalOption(state,"auto-aof-rewrite-percentage",server.aof_rewrite_perc,REDIS_AOF_REWRITE_PERC);
+    rewriteConfigBytesOption(state,"auto-aof-rewrite-min-size",server.aof_rewrite_min_size,REDIS_AOF_REWRITE_MIN_SIZE);
+    rewriteConfigNumericalOption(state,"lua-time-limit",server.lua_time_limit,REDIS_LUA_TIME_LIMIT);
+    rewriteConfigNumericalOption(state,"slowlog-log-slower-than",server.slowlog_log_slower_than,REDIS_SLOWLOG_LOG_SLOWER_THAN);
+    rewriteConfigNumericalOption(state,"slowlog-max-len",server.slowlog_max_len,REDIS_SLOWLOG_MAX_LEN);
+    rewriteConfigNotifykeyspaceeventsOption(state);
+    rewriteConfigNumericalOption(state,"hash-max-ziplist-entries",server.hash_max_ziplist_entries,REDIS_HASH_MAX_ZIPLIST_ENTRIES);
+    rewriteConfigNumericalOption(state,"hash-max-ziplist-value",server.hash_max_ziplist_value,REDIS_HASH_MAX_ZIPLIST_VALUE);
+    rewriteConfigNumericalOption(state,"list-max-ziplist-entries",server.list_max_ziplist_entries,REDIS_LIST_MAX_ZIPLIST_ENTRIES);
+    rewriteConfigNumericalOption(state,"list-max-ziplist-value",server.list_max_ziplist_value,REDIS_LIST_MAX_ZIPLIST_VALUE);
+    rewriteConfigNumericalOption(state,"set-max-intset-entries",server.set_max_intset_entries,REDIS_SET_MAX_INTSET_ENTRIES);
+    rewriteConfigNumericalOption(state,"zset-max-ziplist-entries",server.zset_max_ziplist_entries,REDIS_ZSET_MAX_ZIPLIST_ENTRIES);
+    rewriteConfigNumericalOption(state,"zset-max-ziplist-value",server.zset_max_ziplist_value,REDIS_ZSET_MAX_ZIPLIST_VALUE);
+    rewriteConfigYesNoOption(state,"activerehashing",server.activerehashing,REDIS_DEFAULT_ACTIVE_REHASHING);
+    rewriteConfigClientoutputbufferlimitOption(state);
+    rewriteConfigNumericalOption(state,"hz",server.hz,REDIS_DEFAULT_HZ);
+    rewriteConfigYesNoOption(state,"aof-rewrite-incremental-fsync",server.aof_rewrite_incremental_fsync,REDIS_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC);
+    if (server.sentinel_mode) rewriteConfigSentinelOption(state);
+
+    /* Step 3: remove all the orphaned lines in the old file, that is, lines
+     * that were used by a config option and are no longer used, like in case
+     * of multiple "save" options or duplicated options. */
+    rewriteConfigRemoveOrphaned(state);
+
+    /* Step 4: generate a new configuration file from the modified state
+     * and write it into the original file. */
+    newcontent = rewriteConfigGetContentFromState(state);
+    retval = rewriteConfigOverwriteFile(server.configfile,newcontent);
+
+    sdsfree(newcontent);
+    rewriteConfigReleaseState(state);
+    return retval;
+}
+
+/*-----------------------------------------------------------------------------
+ * CONFIG command entry point
+ *----------------------------------------------------------------------------*/
+
 void configCommand(redisClient *c) {
     if (!strcasecmp(c->argv[1]->ptr,"set")) {
         if (c->argc != 4) goto badarity;
         configSetCommand(c);
     } else if (!strcasecmp(c->argv[1]->ptr,"get")) {
         if (c->argc != 3) goto badarity;
@@ -993,15 +1725,26 @@
         server.stat_expiredkeys = 0;
         server.stat_rejected_conn = 0;
         server.stat_fork_time = 0;
         server.aof_delayed_fsync = 0;
         resetCommandTableStats();
         addReply(c,shared.ok);
+    } else if (!strcasecmp(c->argv[1]->ptr,"rewrite")) {
+        if (c->argc != 2) goto badarity;
+        if (server.configfile == NULL) {
+            addReplyError(c,"The server is running without a config file");
+            return;
+        }
+        if (rewriteConfig(server.configfile) == -1) {
+            addReplyErrorFormat(c,"Rewriting config file: %s", strerror(errno));
+        } else {
+            addReply(c,shared.ok);
+        }
     } else {
         addReplyError(c,
-            "CONFIG subcommand must be one of GET, SET, RESETSTAT");
+            "CONFIG subcommand must be one of GET, SET, RESETSTAT, REWRITE");
     }
     return;
 
 badarity:
     addReplyErrorFormat(c,"Wrong number of arguments for CONFIG %s",
         (char*) c->argv[1]->ptr);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.h	2013-11-22 17:25:29.000000000 +0800
@@ -42,13 +42,15 @@
 #define redis_fstat fstat
 #define redis_stat stat
 #endif
 
 /* Test for proc filesystem */
 #ifdef __linux__
-#define HAVE_PROCFS 1
+#define HAVE_PROC_STAT 1
+#define HAVE_PROC_MAPS 1
+#define HAVE_PROC_SMAPS 1
 #endif
 
 /* Test for task_info() */
 #if defined(__APPLE__)
 #define HAVE_TASKINFO 1
 #endif
@@ -100,12 +102,26 @@
 #ifdef HAVE_SYNC_FILE_RANGE
 #define rdb_fsync_range(fd,off,size) sync_file_range(fd,off,size,SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE)
 #else
 #define rdb_fsync_range(fd,off,size) fsync(fd)
 #endif
 
+/* Check if we can use setproctitle().
+ * BSD systems have support for it, we provide an implementation for
+ * Linux and osx. */
+#if (defined __NetBSD__ || defined __FreeBSD__ || defined __OpenBSD__)
+#define USE_SETPROCTITLE
+#endif
+
+#if (defined __linux || defined __APPLE__)
+#define USE_SETPROCTITLE
+#define INIT_SETPROCTITLE_REPLACEMENT
+void spt_init(int argc, char *argv[]);
+void setproctitle(const char *fmt, ...);
+#endif
+
 /* Byte ordering detection */
 #include <sys/types.h> /* This will likely define BYTE_ORDER */
 
 #ifndef BYTE_ORDER
 #if (BSD >= 199103)
 # include <machine/endian.h>
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/config.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/config.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/crc64.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/crc64.c.bc differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src: crc64.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/crc64.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/crc64.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/db.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/db.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/db.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/db.c	2013-11-22 17:25:29.000000000 +0800
@@ -235,12 +235,14 @@
 void delCommand(redisClient *c) {
     int deleted = 0, j;
 
     for (j = 1; j < c->argc; j++) {
         if (dbDelete(c->db,c->argv[j])) {
             signalModifiedKey(c->db,c->argv[j]);
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,
+                "del",c->argv[j],c->db->id);
             server.dirty++;
             deleted++;
         }
     }
     addReplyLongLong(c,deleted);
 }
@@ -304,12 +306,254 @@
         }
     }
     dictReleaseIterator(di);
     setDeferredMultiBulkLength(c,replylen,numkeys);
 }
 
+/* This callback is used by scanGenericCommand in order to collect elements
+ * returned by the dictionary iterator into a list. */
+void scanCallback(void *privdata, const dictEntry *de) {
+    void **pd = (void**) privdata;
+    list *keys = pd[0];
+    robj *o = pd[1];
+    robj *key, *val = NULL;
+
+    if (o == NULL) {
+        sds sdskey = dictGetKey(de);
+        key = createStringObject(sdskey, sdslen(sdskey));
+    } else if (o->type == REDIS_SET) {
+        key = dictGetKey(de);
+        incrRefCount(key);
+    } else if (o->type == REDIS_HASH) {
+        key = dictGetKey(de);
+        incrRefCount(key);
+        val = dictGetVal(de);
+        incrRefCount(val);
+    } else if (o->type == REDIS_ZSET) {
+        key = dictGetKey(de);
+        incrRefCount(key);
+        val = createStringObjectFromLongDouble(*(double*)dictGetVal(de));
+    } else {
+        redisPanic("Type not handled in SCAN callback.");
+    }
+
+    listAddNodeTail(keys, key);
+    if (val) listAddNodeTail(keys, val);
+}
+
+/* Try to parse a SCAN cursor stored at object 'o':
+ * if the cursor is valid, store it as unsigned integer into *cursor and
+ * returns REDIS_OK. Otherwise return REDIS_ERR and send an error to the
+ * client. */
+int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor) {
+    char *eptr;
+
+    /* Use strtoul() because we need an *unsigned* long, so
+     * getLongLongFromObject() does not cover the whole cursor space. */
+    errno = 0;
+    *cursor = strtoul(o->ptr, &eptr, 10);
+    if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' || errno == ERANGE)
+    {
+        addReplyError(c, "invalid cursor");
+        return REDIS_ERR;
+    }
+    return REDIS_OK;
+}
+
+/* This command implements SCAN, HSCAN and SSCAN commands.
+ * If object 'o' is passed, then it must be an Hash or Set object, otherwise
+ * if 'o' is NULL the command will operate on the dictionary associated with
+ * the current database.
+ *
+ * When 'o' is not NULL the function assumes that the first argument in
+ * the client arguments vector is a key so it skips it before iterating
+ * in order to parse options.
+ *
+ * In the case of an Hash object the function returns both the field and value
+ * of every element on the Hash. */
+void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor) {
+    int rv;
+    int i, j;
+    char buf[REDIS_LONGSTR_SIZE];
+    list *keys = listCreate();
+    listNode *node, *nextnode;
+    long count = 10;
+    sds pat;
+    int patlen, use_pattern = 0;
+    dict *ht;
+
+    /* Object must be NULL (to iterate keys names), or the type of the object
+     * must be Set, Sorted Set, or Hash. */
+    redisAssert(o == NULL || o->type == REDIS_SET || o->type == REDIS_HASH ||
+                o->type == REDIS_ZSET);
+
+    /* Set i to the first option argument. The previous one is the cursor. */
+    i = (o == NULL) ? 2 : 3; /* Skip the key argument if needed. */
+
+    /* Step 1: Parse options. */
+    while (i < c->argc) {
+        j = c->argc - i;
+        if (!strcasecmp(c->argv[i]->ptr, "count") && j >= 2) {
+            if (getLongFromObjectOrReply(c, c->argv[i+1], &count, NULL)
+                != REDIS_OK)
+            {
+                goto cleanup;
+            }
+
+            if (count < 1) {
+                addReply(c,shared.syntaxerr);
+                goto cleanup;
+            }
+
+            i += 2;
+        } else if (!strcasecmp(c->argv[i]->ptr, "match") && j >= 2) {
+            pat = c->argv[i+1]->ptr;
+            patlen = sdslen(pat);
+
+            /* The pattern always matches if it is exactly "*", so it is
+             * equivalent to disabling it. */
+            use_pattern = !(pat[0] == '*' && patlen == 1);
+
+            i += 2;
+        } else {
+            addReply(c,shared.syntaxerr);
+            goto cleanup;
+        }
+    }
+
+    /* Step 2: Iterate the collection.
+     *
+     * Note that if the object is encoded with a ziplist, intset, or any other
+     * representation that is not an hash table, we are sure that it is also
+     * composed of a small number of elements. So to avoid taking state we
+     * just return everything inside the object in a single call, setting the
+     * cursor to zero to signal the end of the iteration. */
+
+    /* Handle the case of an hash table. */
+    ht = NULL;
+    if (o == NULL) {
+        ht = c->db->dict;
+    } else if (o->type == REDIS_SET && o->encoding == REDIS_ENCODING_HT) {
+        ht = o->ptr;
+    } else if (o->type == REDIS_HASH && o->encoding == REDIS_ENCODING_HT) {
+        ht = o->ptr;
+        count *= 2; /* We return key / value for this type. */
+    } else if (o->type == REDIS_ZSET && o->encoding == REDIS_ENCODING_SKIPLIST) {
+        zset *zs = o->ptr;
+        ht = zs->dict;
+        count *= 2; /* We return key / value for this type. */
+    }
+
+    if (ht) {
+        void *privdata[2];
+
+        /* We pass two pointers to the callback: the list to which it will
+         * add new elements, and the object containing the dictionary so that
+         * it is possible to fetch more data in a type-dependent way. */
+        privdata[0] = keys;
+        privdata[1] = o;
+        do {
+            cursor = dictScan(ht, cursor, scanCallback, privdata);
+        } while (cursor && listLength(keys) < count);
+    } else if (o->type == REDIS_SET) {
+        int pos = 0;
+        int64_t ll;
+
+        while(intsetGet(o->ptr,pos++,&ll))
+            listAddNodeTail(keys,createStringObjectFromLongLong(ll));
+        cursor = 0;
+    } else if (o->type == REDIS_HASH || o->type == REDIS_ZSET) {
+        unsigned char *p = ziplistIndex(o->ptr,0);
+        unsigned char *vstr;
+        unsigned int vlen;
+        long long vll;
+
+        while(p) {
+            ziplistGet(p,&vstr,&vlen,&vll);
+            listAddNodeTail(keys,
+                (vstr != NULL) ? createStringObject((char*)vstr,vlen) :
+                                 createStringObjectFromLongLong(vll));
+            p = ziplistNext(o->ptr,p);
+        }
+        cursor = 0;
+    } else {
+        redisPanic("Not handled encoding in SCAN.");
+    }
+
+    /* Step 3: Filter elements. */
+    node = listFirst(keys);
+    while (node) {
+        robj *kobj = listNodeValue(node);
+        nextnode = listNextNode(node);
+        int filter = 0;
+
+        /* Filter element if it does not match the pattern. */
+        if (!filter && use_pattern) {
+            if (kobj->encoding == REDIS_ENCODING_INT) {
+                char buf[REDIS_LONGSTR_SIZE];
+                int len;
+
+                redisAssert(kobj->encoding == REDIS_ENCODING_INT);
+                len = ll2string(buf,sizeof(buf),(long)kobj->ptr);
+                if (!stringmatchlen(pat, patlen, buf, len, 0)) filter = 1;
+            } else {
+                if (!stringmatchlen(pat, patlen, kobj->ptr, sdslen(kobj->ptr), 0))
+                    filter = 1;
+            }
+        }
+
+        /* Filter element if it is an expired key. */
+        if (!filter && o == NULL && expireIfNeeded(c->db, kobj)) filter = 1;
+
+        /* Remove the element and its associted value if needed. */
+        if (filter) {
+            decrRefCount(kobj);
+            listDelNode(keys, node);
+        }
+
+        /* If this is an hash or a sorted set, we have a flat list of
+         * key-value elements, so if this element was filtered, remove the
+         * value, or skip it if it was not filtered: we only match keys. */
+        if (o && (o->type == REDIS_ZSET || o->type == REDIS_HASH)) {
+            node = nextnode;
+            nextnode = listNextNode(node);
+            if (filter) {
+                kobj = listNodeValue(node);
+                decrRefCount(kobj);
+                listDelNode(keys, node);
+            }
+        }
+        node = nextnode;
+    }
+
+    /* Step 4: Reply to the client. */
+    addReplyMultiBulkLen(c, 2);
+    rv = snprintf(buf, sizeof(buf), "%lu", cursor);
+    redisAssert(rv < sizeof(buf));
+    addReplyBulkCBuffer(c, buf, rv);
+
+    addReplyMultiBulkLen(c, listLength(keys));
+    while ((node = listFirst(keys)) != NULL) {
+        robj *kobj = listNodeValue(node);
+        addReplyBulk(c, kobj);
+        decrRefCount(kobj);
+        listDelNode(keys, node);
+    }
+
+cleanup:
+    listSetFreeMethod(keys,decrRefCountVoid);
+    listRelease(keys);
+}
+
+/* The SCAN command completely relies on scanGenericCommand. */
+void scanCommand(redisClient *c) {
+    unsigned long cursor;
+    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == REDIS_ERR) return;
+    scanGenericCommand(c,NULL,cursor);
+}
+
 void dbsizeCommand(redisClient *c) {
     addReplyLongLong(c,dictSize(c->db->dict));
 }
 
 void lastsaveCommand(redisClient *c) {
     addReplyLongLong(c,server.lastsave);
@@ -348,12 +592,18 @@
             flags |= REDIS_SHUTDOWN_SAVE;
         } else {
             addReply(c,shared.syntaxerr);
             return;
         }
     }
+    /* SHUTDOWN can be called even while the server is in "loading" state.
+     * When this happens we need to make sure no attempt is performed to save
+     * the dataset on shutdown (otherwise it could overwrite the current DB
+     * with half-read data). */
+    if (server.loading)
+        flags = (flags & ~REDIS_SHUTDOWN_SAVE) | REDIS_SHUTDOWN_NOSAVE;
     if (prepareForShutdown(flags) == REDIS_OK) exit(0);
     addReplyError(c,"Errors trying to SHUTDOWN. Check logs.");
 }
 
 void renameGenericCommand(redisClient *c, int nx) {
     robj *o;
@@ -373,20 +623,25 @@
     if (lookupKeyWrite(c->db,c->argv[2]) != NULL) {
         if (nx) {
             decrRefCount(o);
             addReply(c,shared.czero);
             return;
         }
-        /* Overwrite: delete the old key before creating the new one with the same name. */
+        /* Overwrite: delete the old key before creating the new one
+         * with the same name. */
         dbDelete(c->db,c->argv[2]);
     }
     dbAdd(c->db,c->argv[2],o);
     if (expire != -1) setExpire(c->db,c->argv[2],expire);
     dbDelete(c->db,c->argv[1]);
     signalModifiedKey(c->db,c->argv[1]);
     signalModifiedKey(c->db,c->argv[2]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"rename_from",
+        c->argv[1],c->db->id);
+    notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"rename_to",
+        c->argv[2],c->db->id);
     server.dirty++;
     addReply(c,nx ? shared.cone : shared.ok);
 }
 
 void renameCommand(redisClient *c) {
     renameGenericCommand(c,0);
@@ -490,14 +745,13 @@
     argv[1] = key;
     incrRefCount(argv[0]);
     incrRefCount(argv[1]);
 
     if (server.aof_state != REDIS_AOF_OFF)
         feedAppendOnlyFile(server.delCommand,db->id,argv,2);
-    if (listLength(server.slaves))
-        replicationFeedSlaves(server.slaves,db->id,argv,2);
+    replicationFeedSlaves(server.slaves,db->id,argv,2);
 
     decrRefCount(argv[0]);
     decrRefCount(argv[1]);
 }
 
 int expireIfNeeded(redisDb *db, robj *key) {
@@ -522,12 +776,14 @@
     /* Return when this key has not expired */
     if (mstime() <= when) return 0;
 
     /* Delete the key */
     server.stat_expiredkeys++;
     propagateExpire(db,key);
+    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,
+        "expired",key,db->id);
     return dbDelete(db,key);
 }
 
 /*-----------------------------------------------------------------------------
  * Expires Commands
  *----------------------------------------------------------------------------*/
@@ -569,18 +825,20 @@
 
         /* Replicate/AOF this as an explicit DEL. */
         aux = createStringObject("DEL",3);
         rewriteClientCommandVector(c,2,aux,key);
         decrRefCount(aux);
         signalModifiedKey(c->db,key);
+        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",key,c->db->id);
         addReply(c, shared.cone);
         return;
     } else {
         setExpire(c->db,key,when);
         addReply(c,shared.cone);
         signalModifiedKey(c->db,key);
+        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"expire",key,c->db->id);
         server.dirty++;
         return;
     }
 }
 
 void expireCommand(redisClient *c) {
@@ -599,16 +857,23 @@
     expireGenericCommand(c,0,UNIT_MILLISECONDS);
 }
 
 void ttlGenericCommand(redisClient *c, int output_ms) {
     long long expire, ttl = -1;
 
+    /* If the key does not exist at all, return -2 */
+    if (lookupKeyRead(c->db,c->argv[1]) == NULL) {
+        addReplyLongLong(c,-2);
+        return;
+    }
+    /* The key exists. Return -1 if it has no expire, or the actual
+     * TTL value otherwise. */
     expire = getExpire(c->db,c->argv[1]);
     if (expire != -1) {
         ttl = expire-mstime();
-        if (ttl < 0) ttl = -1;
+        if (ttl < 0) ttl = 0;
     }
     if (ttl == -1) {
         addReplyLongLong(c,-1);
     } else {
         addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
     }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/db.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/db.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/db.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/db.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/debug.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/debug.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/debug.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/debug.c	2013-11-22 17:25:29.000000000 +0800
@@ -26,20 +26,22 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "redis.h"
 #include "sha1.h"   /* SHA1 is used for DEBUG DIGEST */
+#include "crc64.h"
 
 #include <arpa/inet.h>
 #include <signal.h>
 
 #ifdef HAVE_BACKTRACE
 #include <execinfo.h>
 #include <ucontext.h>
 #include <fcntl.h>
+#include "bio.h"
 #endif /* HAVE_BACKTRACE */
 
 /* ================================= Debugging ============================== */
 
 /* Compute the sha1 of string at 's' with 'len' bytes long.
  * The SHA1 is then xored against the string pointed by digest.
@@ -347,14 +349,17 @@
             d = sdscatprintf(d, "%02x",digest[j]);
         addReplyStatus(c,d);
         sdsfree(d);
     } else if (!strcasecmp(c->argv[1]->ptr,"sleep") && c->argc == 3) {
         double dtime = strtod(c->argv[2]->ptr,NULL);
         long long utime = dtime*1000000;
+        struct timespec tv;
 
-        usleep(utime);
+        tv.tv_sec = utime / 1000000;
+        tv.tv_nsec = (utime % 1000000) * 1000;
+        nanosleep(&tv, NULL);
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"set-active-expire") &&
                c->argc == 3)
     {
         server.active_expire_enabled = atoi(c->argv[2]->ptr);
         addReply(c,shared.ok);
@@ -493,16 +498,19 @@
 #endif
 }
 
 void logStackContent(void **sp) {
     int i;
     for (i = 15; i >= 0; i--) {
+        unsigned long addr = (unsigned long) sp+i;
+        unsigned long val = (unsigned long) sp[i];
+
         if (sizeof(long) == 4)
-            redisLog(REDIS_WARNING, "(%08lx) -> %08lx", sp+i, sp[i]);
+            redisLog(REDIS_WARNING, "(%08lx) -> %08lx", addr, val);
         else
-            redisLog(REDIS_WARNING, "(%016lx) -> %016lx", sp+i, sp[i]);
+            redisLog(REDIS_WARNING, "(%016lx) -> %016lx", addr, val);
     }
 }
 
 void logRegisters(ucontext_t *uc) {
     redisLog(REDIS_WARNING, "--- REGISTERS");
 
@@ -514,59 +522,59 @@
     "\n"
     "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
     "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
     "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
     "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
     "RIP:%016lx EFL:%016lx\nCS :%016lx FS:%016lx  GS:%016lx",
-        uc->uc_mcontext->__ss.__rax,
-        uc->uc_mcontext->__ss.__rbx,
-        uc->uc_mcontext->__ss.__rcx,
-        uc->uc_mcontext->__ss.__rdx,
-        uc->uc_mcontext->__ss.__rdi,
-        uc->uc_mcontext->__ss.__rsi,
-        uc->uc_mcontext->__ss.__rbp,
-        uc->uc_mcontext->__ss.__rsp,
-        uc->uc_mcontext->__ss.__r8,
-        uc->uc_mcontext->__ss.__r9,
-        uc->uc_mcontext->__ss.__r10,
-        uc->uc_mcontext->__ss.__r11,
-        uc->uc_mcontext->__ss.__r12,
-        uc->uc_mcontext->__ss.__r13,
-        uc->uc_mcontext->__ss.__r14,
-        uc->uc_mcontext->__ss.__r15,
-        uc->uc_mcontext->__ss.__rip,
-        uc->uc_mcontext->__ss.__rflags,
-        uc->uc_mcontext->__ss.__cs,
-        uc->uc_mcontext->__ss.__fs,
-        uc->uc_mcontext->__ss.__gs
+        (unsigned long) uc->uc_mcontext->__ss.__rax,
+        (unsigned long) uc->uc_mcontext->__ss.__rbx,
+        (unsigned long) uc->uc_mcontext->__ss.__rcx,
+        (unsigned long) uc->uc_mcontext->__ss.__rdx,
+        (unsigned long) uc->uc_mcontext->__ss.__rdi,
+        (unsigned long) uc->uc_mcontext->__ss.__rsi,
+        (unsigned long) uc->uc_mcontext->__ss.__rbp,
+        (unsigned long) uc->uc_mcontext->__ss.__rsp,
+        (unsigned long) uc->uc_mcontext->__ss.__r8,
+        (unsigned long) uc->uc_mcontext->__ss.__r9,
+        (unsigned long) uc->uc_mcontext->__ss.__r10,
+        (unsigned long) uc->uc_mcontext->__ss.__r11,
+        (unsigned long) uc->uc_mcontext->__ss.__r12,
+        (unsigned long) uc->uc_mcontext->__ss.__r13,
+        (unsigned long) uc->uc_mcontext->__ss.__r14,
+        (unsigned long) uc->uc_mcontext->__ss.__r15,
+        (unsigned long) uc->uc_mcontext->__ss.__rip,
+        (unsigned long) uc->uc_mcontext->__ss.__rflags,
+        (unsigned long) uc->uc_mcontext->__ss.__cs,
+        (unsigned long) uc->uc_mcontext->__ss.__fs,
+        (unsigned long) uc->uc_mcontext->__ss.__gs
     );
     logStackContent((void**)uc->uc_mcontext->__ss.__rsp);
     #else
     /* OSX x86 */
     redisLog(REDIS_WARNING,
     "\n"
     "EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n"
     "EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n"
     "SS:%08lx  EFL:%08lx EIP:%08lx CS :%08lx\n"
     "DS:%08lx  ES:%08lx  FS :%08lx GS :%08lx",
-        uc->uc_mcontext->__ss.__eax,
-        uc->uc_mcontext->__ss.__ebx,
-        uc->uc_mcontext->__ss.__ecx,
-        uc->uc_mcontext->__ss.__edx,
-        uc->uc_mcontext->__ss.__edi,
-        uc->uc_mcontext->__ss.__esi,
-        uc->uc_mcontext->__ss.__ebp,
-        uc->uc_mcontext->__ss.__esp,
-        uc->uc_mcontext->__ss.__ss,
-        uc->uc_mcontext->__ss.__eflags,
-        uc->uc_mcontext->__ss.__eip,
-        uc->uc_mcontext->__ss.__cs,
-        uc->uc_mcontext->__ss.__ds,
-        uc->uc_mcontext->__ss.__es,
-        uc->uc_mcontext->__ss.__fs,
-        uc->uc_mcontext->__ss.__gs
+        (unsigned long) uc->uc_mcontext->__ss.__eax,
+        (unsigned long) uc->uc_mcontext->__ss.__ebx,
+        (unsigned long) uc->uc_mcontext->__ss.__ecx,
+        (unsigned long) uc->uc_mcontext->__ss.__edx,
+        (unsigned long) uc->uc_mcontext->__ss.__edi,
+        (unsigned long) uc->uc_mcontext->__ss.__esi,
+        (unsigned long) uc->uc_mcontext->__ss.__ebp,
+        (unsigned long) uc->uc_mcontext->__ss.__esp,
+        (unsigned long) uc->uc_mcontext->__ss.__ss,
+        (unsigned long) uc->uc_mcontext->__ss.__eflags,
+        (unsigned long) uc->uc_mcontext->__ss.__eip,
+        (unsigned long) uc->uc_mcontext->__ss.__cs,
+        (unsigned long) uc->uc_mcontext->__ss.__ds,
+        (unsigned long) uc->uc_mcontext->__ss.__es,
+        (unsigned long) uc->uc_mcontext->__ss.__fs,
+        (unsigned long) uc->uc_mcontext->__ss.__gs
     );
     logStackContent((void**)uc->uc_mcontext->__ss.__esp);
     #endif
 /* Linux */
 #elif defined(__linux__)
     /* Linux x86 */
@@ -574,58 +582,58 @@
     redisLog(REDIS_WARNING,
     "\n"
     "EAX:%08lx EBX:%08lx ECX:%08lx EDX:%08lx\n"
     "EDI:%08lx ESI:%08lx EBP:%08lx ESP:%08lx\n"
     "SS :%08lx EFL:%08lx EIP:%08lx CS:%08lx\n"
     "DS :%08lx ES :%08lx FS :%08lx GS:%08lx",
-        uc->uc_mcontext.gregs[11],
-        uc->uc_mcontext.gregs[8],
-        uc->uc_mcontext.gregs[10],
-        uc->uc_mcontext.gregs[9],
-        uc->uc_mcontext.gregs[4],
-        uc->uc_mcontext.gregs[5],
-        uc->uc_mcontext.gregs[6],
-        uc->uc_mcontext.gregs[7],
-        uc->uc_mcontext.gregs[18],
-        uc->uc_mcontext.gregs[17],
-        uc->uc_mcontext.gregs[14],
-        uc->uc_mcontext.gregs[15],
-        uc->uc_mcontext.gregs[3],
-        uc->uc_mcontext.gregs[2],
-        uc->uc_mcontext.gregs[1],
-        uc->uc_mcontext.gregs[0]
+        (unsigned long) uc->uc_mcontext.gregs[11],
+        (unsigned long) uc->uc_mcontext.gregs[8],
+        (unsigned long) uc->uc_mcontext.gregs[10],
+        (unsigned long) uc->uc_mcontext.gregs[9],
+        (unsigned long) uc->uc_mcontext.gregs[4],
+        (unsigned long) uc->uc_mcontext.gregs[5],
+        (unsigned long) uc->uc_mcontext.gregs[6],
+        (unsigned long) uc->uc_mcontext.gregs[7],
+        (unsigned long) uc->uc_mcontext.gregs[18],
+        (unsigned long) uc->uc_mcontext.gregs[17],
+        (unsigned long) uc->uc_mcontext.gregs[14],
+        (unsigned long) uc->uc_mcontext.gregs[15],
+        (unsigned long) uc->uc_mcontext.gregs[3],
+        (unsigned long) uc->uc_mcontext.gregs[2],
+        (unsigned long) uc->uc_mcontext.gregs[1],
+        (unsigned long) uc->uc_mcontext.gregs[0]
     );
     logStackContent((void**)uc->uc_mcontext.gregs[7]);
     #elif defined(__X86_64__) || defined(__x86_64__)
     /* Linux AMD64 */
     redisLog(REDIS_WARNING,
     "\n"
     "RAX:%016lx RBX:%016lx\nRCX:%016lx RDX:%016lx\n"
     "RDI:%016lx RSI:%016lx\nRBP:%016lx RSP:%016lx\n"
     "R8 :%016lx R9 :%016lx\nR10:%016lx R11:%016lx\n"
     "R12:%016lx R13:%016lx\nR14:%016lx R15:%016lx\n"
     "RIP:%016lx EFL:%016lx\nCSGSFS:%016lx",
-        uc->uc_mcontext.gregs[13],
-        uc->uc_mcontext.gregs[11],
-        uc->uc_mcontext.gregs[14],
-        uc->uc_mcontext.gregs[12],
-        uc->uc_mcontext.gregs[8],
-        uc->uc_mcontext.gregs[9],
-        uc->uc_mcontext.gregs[10],
-        uc->uc_mcontext.gregs[15],
-        uc->uc_mcontext.gregs[0],
-        uc->uc_mcontext.gregs[1],
-        uc->uc_mcontext.gregs[2],
-        uc->uc_mcontext.gregs[3],
-        uc->uc_mcontext.gregs[4],
-        uc->uc_mcontext.gregs[5],
-        uc->uc_mcontext.gregs[6],
-        uc->uc_mcontext.gregs[7],
-        uc->uc_mcontext.gregs[16],
-        uc->uc_mcontext.gregs[17],
-        uc->uc_mcontext.gregs[18]
+        (unsigned long) uc->uc_mcontext.gregs[13],
+        (unsigned long) uc->uc_mcontext.gregs[11],
+        (unsigned long) uc->uc_mcontext.gregs[14],
+        (unsigned long) uc->uc_mcontext.gregs[12],
+        (unsigned long) uc->uc_mcontext.gregs[8],
+        (unsigned long) uc->uc_mcontext.gregs[9],
+        (unsigned long) uc->uc_mcontext.gregs[10],
+        (unsigned long) uc->uc_mcontext.gregs[15],
+        (unsigned long) uc->uc_mcontext.gregs[0],
+        (unsigned long) uc->uc_mcontext.gregs[1],
+        (unsigned long) uc->uc_mcontext.gregs[2],
+        (unsigned long) uc->uc_mcontext.gregs[3],
+        (unsigned long) uc->uc_mcontext.gregs[4],
+        (unsigned long) uc->uc_mcontext.gregs[5],
+        (unsigned long) uc->uc_mcontext.gregs[6],
+        (unsigned long) uc->uc_mcontext.gregs[7],
+        (unsigned long) uc->uc_mcontext.gregs[16],
+        (unsigned long) uc->uc_mcontext.gregs[17],
+        (unsigned long) uc->uc_mcontext.gregs[18]
     );
     logStackContent((void**)uc->uc_mcontext.gregs[15]);
     #endif
 #else
     redisLog(REDIS_WARNING,
         "  Dumping of registers not supported for this OS/arch");
@@ -634,17 +642,18 @@
 
 /* Logs the stack trace using the backtrace() call. This function is designed
  * to be called from signal handlers safely. */
 void logStackTrace(ucontext_t *uc) {
     void *trace[100];
     int trace_size = 0, fd;
+    int log_to_stdout = server.logfile[0] == '\0';
 
     /* Open the log file in append mode. */
-    fd = server.logfile ?
-        open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644) :
-        STDOUT_FILENO;
+    fd = log_to_stdout ?
+        STDOUT_FILENO :
+        open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
     if (fd == -1) return;
 
     /* Generate the stack trace */
     trace_size = backtrace(trace, 100);
 
     /* overwrite sigaction with caller's address */
@@ -652,13 +661,13 @@
         trace[1] = getMcontextEip(uc);
 
     /* Write symbols to log file */
     backtrace_symbols_fd(trace, trace_size, fd);
 
     /* Cleanup */
-    if (server.logfile) close(fd);
+    if (!log_to_stdout) close(fd);
 }
 
 /* Log information about the "current" client, that is, the client that is
  * currently being served by Redis. May be NULL if Redis is not serving a
  * client right now. */
 void logCurrentClient(void) {
@@ -686,19 +695,102 @@
         dictEntry *de;
 
         key = getDecodedObject(cc->argv[1]);
         de = dictFind(cc->db->dict, key->ptr);
         if (de) {
             val = dictGetVal(de);
-            redisLog(REDIS_WARNING,"key '%s' found in DB containing the following object:", key->ptr);
+            redisLog(REDIS_WARNING,"key '%s' found in DB containing the following object:", (char*)key->ptr);
             redisLogObjectDebugInfo(val);
         }
         decrRefCount(key);
     }
 }
 
+#if defined(HAVE_PROC_MAPS)
+void memtest_non_destructive_invert(void *addr, size_t size);
+void memtest_non_destructive_swap(void *addr, size_t size);
+#define MEMTEST_MAX_REGIONS 128
+
+int memtest_test_linux_anonymous_maps(void) {
+    FILE *fp = fopen("/proc/self/maps","r");
+    char line[1024];
+    size_t start_addr, end_addr, size;
+    size_t start_vect[MEMTEST_MAX_REGIONS];
+    size_t size_vect[MEMTEST_MAX_REGIONS];
+    int regions = 0, j;
+    uint64_t crc1 = 0, crc2 = 0, crc3 = 0;
+
+    while(fgets(line,sizeof(line),fp) != NULL) {
+        char *start, *end, *p = line;
+
+        start = p;
+        p = strchr(p,'-');
+        if (!p) continue;
+        *p++ = '\0';
+        end = p;
+        p = strchr(p,' ');
+        if (!p) continue;
+        *p++ = '\0';
+        if (strstr(p,"stack") ||
+            strstr(p,"vdso") ||
+            strstr(p,"vsyscall")) continue;
+        if (!strstr(p,"00:00")) continue;
+        if (!strstr(p,"rw")) continue;
+
+        start_addr = strtoul(start,NULL,16);
+        end_addr = strtoul(end,NULL,16);
+        size = end_addr-start_addr;
+
+        start_vect[regions] = start_addr;
+        size_vect[regions] = size;
+        printf("Testing %lx %lu\n", (unsigned long) start_vect[regions],
+                                    (unsigned long) size_vect[regions]);
+        regions++;
+    }
+
+    /* Test all the regions as an unique sequential region.
+     * 1) Take the CRC64 of the memory region. */
+    for (j = 0; j < regions; j++) {
+        crc1 = crc64(crc1,(void*)start_vect[j],size_vect[j]);
+    }
+
+    /* 2) Invert bits, swap adjacent words, swap again, invert bits.
+     * This is the error amplification step. */
+    for (j = 0; j < regions; j++)
+        memtest_non_destructive_invert((void*)start_vect[j],size_vect[j]);
+    for (j = 0; j < regions; j++)
+        memtest_non_destructive_swap((void*)start_vect[j],size_vect[j]);
+    for (j = 0; j < regions; j++)
+        memtest_non_destructive_swap((void*)start_vect[j],size_vect[j]);
+    for (j = 0; j < regions; j++)
+        memtest_non_destructive_invert((void*)start_vect[j],size_vect[j]);
+
+    /* 3) Take the CRC64 sum again. */
+    for (j = 0; j < regions; j++)
+        crc2 = crc64(crc2,(void*)start_vect[j],size_vect[j]);
+
+    /* 4) Swap + Swap again */
+    for (j = 0; j < regions; j++)
+        memtest_non_destructive_swap((void*)start_vect[j],size_vect[j]);
+    for (j = 0; j < regions; j++)
+        memtest_non_destructive_swap((void*)start_vect[j],size_vect[j]);
+
+    /* 5) Take the CRC64 sum again. */
+    for (j = 0; j < regions; j++)
+        crc3 = crc64(crc3,(void*)start_vect[j],size_vect[j]);
+
+    /* NOTE: It is very important to close the file descriptor only now
+     * because closing it before may result into unmapping of some memory
+     * region that we are testing. */
+    fclose(fp);
+
+    /* If the two CRC are not the same, we trapped a memory error. */
+    return crc1 != crc2 || crc2 != crc3;
+}
+#endif
+
 void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
     ucontext_t *uc = (ucontext_t*) secret;
     sds infostring, clients;
     struct sigaction act;
     REDIS_NOTUSED(info);
 
@@ -728,12 +820,25 @@
     /* Log the current client */
     logCurrentClient();
 
     /* Log dump of processor registers */
     logRegisters(uc);
 
+#if defined(HAVE_PROC_MAPS)
+    /* Test memory */
+    redisLog(REDIS_WARNING, "--- FAST MEMORY TEST");
+    bioKillThreads();
+    if (memtest_test_linux_anonymous_maps()) {
+        redisLog(REDIS_WARNING,
+            "!!! MEMORY ERROR DETECTED! Check your memory ASAP !!!");
+    } else {
+        redisLog(REDIS_WARNING,
+            "Fast memory test PASSED, however your memory can still be broken. Please run a memory test for several hours if possible.");
+    }
+#endif
+
     redisLog(REDIS_WARNING,
 "\n=== REDIS BUG REPORT END. Make sure to include from START to END. ===\n\n"
 "       Please report the crash opening an issue on github:\n\n"
 "           http://github.com/antirez/redis/issues\n\n"
 "  Suspect RAM error? Use redis-server --test-memory to veryfy it.\n\n"
 );
@@ -805,13 +910,13 @@
     /* Don't automatically restart. */
     it.it_interval.tv_sec = 0;
     it.it_interval.tv_usec = 0;
     setitimer(ITIMER_REAL, &it, NULL);
 }
 
-/* Enable the software watchdong with the specified period in milliseconds. */
+/* Enable the software watchdog with the specified period in milliseconds. */
 void enableWatchdog(int period) {
     int min_period;
 
     if (server.watchdog_period == 0) {
         struct sigaction act;
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/debug.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/debug.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/debug.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/debug.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.c	2013-11-22 17:25:29.000000000 +0800
@@ -645,12 +645,179 @@
     listele = random() % listlen;
     he = orighe;
     while(listele--) he = he->next;
     return he;
 }
 
+/* Function to reverse bits. Algorithm from:
+ * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */
+static unsigned long rev(unsigned long v) {
+    unsigned long s = 8 * sizeof(v); // bit size; must be power of 2
+    unsigned long mask = ~0;
+    while ((s >>= 1) > 0) {
+        mask ^= (mask << s);
+        v = ((v >> s) & mask) | ((v << s) & ~mask);
+    }
+    return v;
+}
+
+/* dictScan() is used to iterate over the elements of a dictionary.
+ *
+ * Iterating works in the following way:
+ *
+ * 1) Initially you call the function using a cursor (v) value of 0.
+ * 2) The function performs one step of the iteration, and returns the
+ *    new cursor value that you must use in the next call.
+ * 3) When the returned cursor is 0, the iteration is complete.
+ *
+ * The function guarantees that all the elements that are present in the
+ * dictionary from the start to the end of the iteration are returned.
+ * However it is possible that some element is returned multiple time.
+ *
+ * For every element returned, the callback 'fn' passed as argument is
+ * called, with 'privdata' as first argument and the dictionar entry
+ * 'de' as second argument.
+ *
+ * HOW IT WORKS.
+ *
+ * The algorithm used in the iteration was designed by Pieter Noordhuis.
+ * The main idea is to increment a cursor starting from the higher order
+ * bits, that is, instead of incrementing the cursor normally, the bits
+ * of the cursor are reversed, then the cursor is incremented, and finally
+ * the bits are reversed again.
+ *
+ * This strategy is needed because the hash table may be resized from one
+ * call to the other call of the same iteration.
+ *
+ * dict.c hash tables are always power of two in size, and they
+ * use chaining, so the position of an element in a given table is given
+ * always by computing the bitwise AND between Hash(key) and SIZE-1
+ * (where SIZE-1 is always the mask that is equivalent to taking the rest
+ *  of the division between the Hash of the key and SIZE).
+ *
+ * For example if the current hash table size is 64, the mask is
+ * (in binary) 1111. The position of a key in the hash table will be always
+ * the last four bits of the hash output, and so forth.
+ *
+ * WHAT HAPPENS IF THE TABLE CHANGES IN SIZE?
+ *
+ * If the hash table grows, elements can go anyway in one multiple of
+ * the old bucket: for example let's say that we already iterated with
+ * a 4 bit cursor 1100, since the mask is 1111 (hash table size = 16).
+ *
+ * If the hash table will be resized to 64 elements, and the new mask will
+ * be 111111, the new buckets that you obtain substituting in ??1100
+ * either 0 or 1, can be targeted only by keys that we already visited
+ * when scanning the bucket 1100 in the smaller hash table.
+ *
+ * By iterating the higher bits first, because of the inverted counter, the
+ * cursor does not need to restart if the table size gets bigger, and will
+ * just continue iterating with cursors that don't have '1100' at the end,
+ * nor any other combination of final 4 bits already explored.
+ *
+ * Similarly when the table size shrinks over time, for example going from
+ * 16 to 8, If a combination of the lower three bits (the mask for size 8
+ * is 111) was already completely explored, it will not be visited again
+ * as we are sure that, we tried for example, both 0111 and 1111 (all the
+ * variations of the higher bit) so we don't need to test it again.
+ *
+ * WAIT... YOU HAVE *TWO* TABLES DURING REHASHING!
+ *
+ * Yes, this is true, but we always iterate the smaller one of the tables,
+ * testing also all the expansions of the current cursor into the larger
+ * table. So for example if the current cursor is 101 and we also have a
+ * larger table of size 16, we also test (0)101 and (1)101 inside the larger
+ * table. This reduces the problem back to having only one table, where
+ * the larger one, if exists, is just an expansion of the smaller one.
+ *
+ * LIMITATIONS
+ *
+ * This iterator is completely stateless, and this is a huge advantage,
+ * including no additional memory used.
+ *
+ * The disadvantages resulting from this design are:
+ *
+ * 1) It is possible that we return duplicated elements. However this is usually
+ *    easy to deal with in the application level.
+ * 2) The iterator must return multiple elements per call, as it needs to always
+ *    return all the keys chained in a given bucket, and all the expansions, so
+ *    we are sure we don't miss keys moving.
+ * 3) The reverse cursor is somewhat hard to understand at first, but this
+ *    comment is supposed to help.
+ */
+unsigned long dictScan(dict *d,
+                       unsigned long v,
+                       dictScanFunction *fn,
+                       void *privdata)
+{
+    dictht *t0, *t1;
+    const dictEntry *de;
+    unsigned long m0, m1;
+
+    if (dictSize(d) == 0) return 0;
+
+    if (!dictIsRehashing(d)) {
+        t0 = &(d->ht[0]);
+        m0 = t0->sizemask;
+
+        /* Emit entries at cursor */
+        de = t0->table[v & m0];
+        while (de) {
+            fn(privdata, de);
+            de = de->next;
+        }
+
+    } else {
+        t0 = &d->ht[0];
+        t1 = &d->ht[1];
+
+        /* Make sure t0 is the smaller and t1 is the bigger table */
+        if (t0->size > t1->size) {
+            t0 = &d->ht[1];
+            t1 = &d->ht[0];
+        }
+
+        m0 = t0->sizemask;
+        m1 = t1->sizemask;
+
+        /* Emit entries at cursor */
+        de = t0->table[v & m0];
+        while (de) {
+            fn(privdata, de);
+            de = de->next;
+        }
+
+        /* Iterate over indices in larger table that are the expansion
+         * of the index pointed to by the cursor in the smaller table */
+        do {
+            /* Emit entries at cursor */
+            de = t1->table[v & m1];
+            while (de) {
+                fn(privdata, de);
+                de = de->next;
+            }
+
+            /* Increment bits not covered by the smaller mask */
+            v = (((v | m0) + 1) & ~m0) | (v & m0);
+
+            /* Continue while bits covered by mask difference is non-zero */
+        } while (v & (m0 ^ m1));
+    }
+
+    /* Set unmasked bits so incrementing the reversed cursor
+     * operates on the masked bits of the smaller table */
+    v |= ~m0;
+
+    /* Increment the reverse cursor */
+    v = rev(v);
+    v++;
+    v = rev(v);
+
+    return v;
+}
+
 /* ------------------------- private functions ------------------------------ */
 
 /* Expand the hash table if needed */
 static int _dictExpandIfNeeded(dict *d)
 {
     /* Incremental rehashing already in progress. Return. */
@@ -664,14 +831,13 @@
      * elements/buckets is over the "safe" threshold, we resize doubling
      * the number of buckets. */
     if (d->ht[0].used >= d->ht[0].size &&
         (dict_can_resize ||
          d->ht[0].used/d->ht[0].size > dict_force_resize_ratio))
     {
-        return dictExpand(d, ((d->ht[0].size > d->ht[0].used) ?
-                                    d->ht[0].size : d->ht[0].used)*2);
+        return dictExpand(d, d->ht[0].used*2);
     }
     return DICT_OK;
 }
 
 /* Our hash table capability is a power of two */
 static unsigned long _dictNextPower(unsigned long size)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.h	2013-11-22 17:25:29.000000000 +0800
@@ -88,12 +88,14 @@
     dict *d;
     int table, index, safe;
     dictEntry *entry, *nextEntry;
     long long fingerprint; /* unsafe iterator fingerprint for misuse detection */
 } dictIterator;
 
+typedef void (dictScanFunction)(void *privdata, const dictEntry *de);
+
 /* This is the initial size of every hash table */
 #define DICT_HT_INITIAL_SIZE     4
 
 /* ------------------------------- Macros ------------------------------------*/
 #define dictFreeVal(d, entry) \
     if ((d)->type->valDestructor) \
@@ -162,12 +164,13 @@
 void dictEnableResize(void);
 void dictDisableResize(void);
 int dictRehash(dict *d, int n);
 int dictRehashMilliseconds(dict *d, int ms);
 void dictSetHashFunctionSeed(unsigned int initval);
 unsigned int dictGetHashFunctionSeed(void);
+unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, void *privdata);
 
 /* Hash table types */
 extern dictType dictTypeHeapStringCopyKey;
 extern dictType dictTypeHeapStrings;
 extern dictType dictTypeHeapStringCopyKeyValue;
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/dict.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/dict.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/endianconv.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/endianconv.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/endianconv.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/endianconv.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/fmacros.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/fmacros.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/fmacros.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/fmacros.h	2013-11-22 17:25:29.000000000 +0800
@@ -33,15 +33,19 @@
 #define _BSD_SOURCE
 
 #if defined(__linux__)
 #define _GNU_SOURCE
 #endif
 
-#if defined(__linux__) || defined(__OpenBSD__) || defined(__NetBSD__)
+#if defined(__linux__) || defined(__OpenBSD__)
 #define _XOPEN_SOURCE 700
-#else
+/*
+ * On NetBSD, _XOPEN_SOURCE undefines _NETBSD_SOURCE and
+ * thus hides inet_aton etc.
+ */
+#elif !defined(__NetBSD__)
 #define _XOPEN_SOURCE
 #endif
 
 #define _LARGEFILE_SOURCE
 #define _FILE_OFFSET_BITS 64
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/intset.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/intset.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/intset.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/intset.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_c.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_c.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_c.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_c.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_d.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_d.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/lzf_d.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/lzf_d.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/Makefile	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/Makefile	2013-11-22 17:25:29.000000000 +0800
@@ -15,78 +15,82 @@
 release_hdr := $(shell sh -c './mkreleasehdr.sh')
 uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')
 OPTIMIZATION?=-O2
 DEPENDENCY_TARGETS=hiredis linenoise lua
 
 # Default settings
-STD= -std=c99 -pedantic
-WARN= -Wall
-OPT= $(OPTIMIZATION)
+STD=-std=c99 -pedantic
+WARN=-Wall
+OPT=$(OPTIMIZATION)
+
+PREFIX?=/usr/local
+INSTALL_BIN=$(PREFIX)/bin
+INSTALL=install
 
 # Default allocator
 ifeq ($(uname_S),Linux)
-  MALLOC=jemalloc
+	MALLOC=jemalloc
 else
-  MALLOC=libc
+	MALLOC=libc
 endif
 
 # Backwards compatibility for selecting an allocator
 ifeq ($(USE_TCMALLOC),yes)
-  MALLOC=tcmalloc
+	MALLOC=tcmalloc
 endif
 
 ifeq ($(USE_TCMALLOC_MINIMAL),yes)
-  MALLOC=tcmalloc_minimal
+	MALLOC=tcmalloc_minimal
 endif
 
 ifeq ($(USE_JEMALLOC),yes)
-  MALLOC=jemalloc
+	MALLOC=jemalloc
 endif
 
 # Override default settings if possible
 -include .make-settings
 
+FINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)
+FINAL_LDFLAGS=$(LDFLAGS) $(REDIS_LDFLAGS) $(DEBUG)
+FINAL_LIBS=-lm
+DEBUG=-g -ggdb
+
 ifeq ($(uname_S),SunOS)
-  FINAL_CFLAGS= $(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS) -D__EXTENSIONS__ -D_XPG6
-  FINAL_LDFLAGS= $(LDFLAGS) $(REDIS_LDFLAGS) -g -ggdb
-  FINAL_LIBS= -ldl -lnsl -lsocket -lm -lpthread
-  DEBUG= -g -ggdb
+	INSTALL=cp -pf
+	FINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6
+	FINAL_LIBS+= -ldl -lnsl -lsocket -lpthread
+else ifeq ($(uname_S),Darwin)
+	
 else
-  FINAL_CFLAGS= $(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)
-  FINAL_LDFLAGS= $(LDFLAGS) $(REDIS_LDFLAGS) -g -rdynamic -ggdb
-  FINAL_LIBS= -lm -pthread
-  DEBUG= -g -rdynamic -ggdb
+	FINAL_LDFLAGS+= -rdynamic
+	FINAL_LIBS+= -pthread
 endif
 
 # Include paths to dependencies
 FINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src
 
 ifeq ($(MALLOC),tcmalloc)
-  FINAL_CFLAGS+= -DUSE_TCMALLOC
-  FINAL_LIBS+= -ltcmalloc
+	FINAL_CFLAGS+= -DUSE_TCMALLOC
+	FINAL_LIBS+= -ltcmalloc
 endif
 
 ifeq ($(MALLOC),tcmalloc_minimal)
-  FINAL_CFLAGS+= -DUSE_TCMALLOC
-  FINAL_LIBS+= -ltcmalloc_minimal
+	FINAL_CFLAGS+= -DUSE_TCMALLOC
+	FINAL_LIBS+= -ltcmalloc_minimal
 endif
 
 ifeq ($(MALLOC),jemalloc)
-  DEPENDENCY_TARGETS+= jemalloc
-  FINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/include
-  FINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a -ldl
+	DEPENDENCY_TARGETS+= jemalloc
+	FINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/include
+	FINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a -ldl
 endif
 
 REDIS_CC=$(QUIET_CC)$(CC) $(FINAL_CFLAGS)
 REDIS_LD=$(QUIET_LINK)$(CC) $(FINAL_LDFLAGS)
 REDIS_INSTALL=$(QUIET_INSTALL)$(INSTALL)
 
-PREFIX?=/usr/local
-INSTALL_BIN= $(PREFIX)/bin
-INSTALL= cp -pf
-
 CCCOLOR="\033[34m"
 LINKCOLOR="\033[34;1m"
 SRCCOLOR="\033[33m"
 BINCOLOR="\033[37;1m"
 MAKECOLOR="\033[32;1m"
 ENDCOLOR="\033[0m"
@@ -94,23 +98,23 @@
 ifndef V
 QUIET_CC = @printf '    %b %b\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;
 QUIET_LINK = @printf '    %b %b\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
 QUIET_INSTALL = @printf '    %b %b\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
 endif
 
-REDIS_SERVER_NAME= redis-server
-REDIS_SENTINEL_NAME= redis-sentinel
-REDIS_SERVER_OBJ= adlist.o ae.o anet.o dict.o redis.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o migrate.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o
-REDIS_CLI_NAME= redis-cli
-REDIS_CLI_OBJ= anet.o sds.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o
-REDIS_BENCHMARK_NAME= redis-benchmark
-REDIS_BENCHMARK_OBJ= ae.o anet.o redis-benchmark.o sds.o adlist.o zmalloc.o redis-benchmark.o
-REDIS_CHECK_DUMP_NAME= redis-check-dump
-REDIS_CHECK_DUMP_OBJ= redis-check-dump.o lzf_c.o lzf_d.o crc64.o
-REDIS_CHECK_AOF_NAME= redis-check-aof
-REDIS_CHECK_AOF_OBJ= redis-check-aof.o
+REDIS_SERVER_NAME=redis-server
+REDIS_SENTINEL_NAME=redis-sentinel
+REDIS_SERVER_OBJ=adlist.o ae.o anet.o dict.o redis.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o migrate.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o
+REDIS_CLI_NAME=redis-cli
+REDIS_CLI_OBJ=anet.o sds.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o
+REDIS_BENCHMARK_NAME=redis-benchmark
+REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o sds.o adlist.o zmalloc.o redis-benchmark.o
+REDIS_CHECK_DUMP_NAME=redis-check-dump
+REDIS_CHECK_DUMP_OBJ=redis-check-dump.o lzf_c.o lzf_d.o crc64.o
+REDIS_CHECK_AOF_NAME=redis-check-aof
+REDIS_CHECK_AOF_OBJ=redis-check-aof.o
 
 all: $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_DUMP_NAME) $(REDIS_CHECK_AOF_NAME)
 	@echo ""
 	@echo "Hint: To run 'make test' is a good idea ;)"
 	@echo ""
 
@@ -193,12 +197,14 @@
 
 .PHONY: distclean
 
 test: $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)
 	@(cd ..; ./runtest)
 
+check: test
+
 lcov:
 	$(MAKE) gcov
 	@(set -e; cd ..; ./runtest --clients 1)
 	@geninfo -o redis.info .
 	@genhtml --legend -o lcov-html redis.info
 
@@ -223,12 +229,12 @@
 	$(MAKE) OPTIMIZATION="-O0" MALLOC="libc"
 
 src/help.h:
 	@../utils/generate-command-help.rb > help.h
 
 install: all
-	mkdir -p $(INSTALL_BIN)
+	@mkdir -p $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_BENCHMARK_NAME) $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_CLI_NAME) $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_CHECK_DUMP_NAME) $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_CHECK_AOF_NAME) $(INSTALL_BIN)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/Makefile.dep /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/Makefile.dep
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/Makefile.dep	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/Makefile.dep	2013-11-22 17:25:29.000000000 +0800
@@ -20,29 +20,32 @@
 crc64.o: crc64.c
 db.o: db.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
   ziplist.h intset.h version.h util.h rdb.h rio.h
 debug.o: debug.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
-  ziplist.h intset.h version.h util.h rdb.h rio.h sha1.h
+  ziplist.h intset.h version.h util.h rdb.h rio.h sha1.h crc64.h bio.h
 dict.o: dict.c fmacros.h dict.h zmalloc.h
 endianconv.o: endianconv.c
 intset.o: intset.c intset.h zmalloc.h endianconv.h config.h
 lzf_c.o: lzf_c.c lzfP.h
 lzf_d.o: lzf_d.c lzfP.h
-memtest.o: memtest.c
+memtest.o: memtest.c config.h
 migrate.o: migrate.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
   ziplist.h intset.h version.h util.h rdb.h rio.h endianconv.h
 multi.o: multi.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
   ziplist.h intset.h version.h util.h rdb.h rio.h
 networking.o: networking.c redis.h fmacros.h config.h \
   ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
   adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h rdb.h \
   rio.h
+notify.o: notify.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
+  ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
+  ziplist.h intset.h version.h util.h rdb.h rio.h
 object.o: object.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
   ziplist.h intset.h version.h util.h rdb.h rio.h
 pqsort.o: pqsort.c
 pubsub.o: pubsub.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
@@ -52,36 +55,37 @@
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
   ziplist.h intset.h version.h util.h rdb.h rio.h lzf.h zipmap.h \
   endianconv.h
 redis-benchmark.o: redis-benchmark.c fmacros.h ae.h \
   ../deps/hiredis/hiredis.h sds.h adlist.h zmalloc.h
 redis-check-aof.o: redis-check-aof.c fmacros.h config.h
-redis-check-dump.o: redis-check-dump.c lzf.h
+redis-check-dump.o: redis-check-dump.c lzf.h crc64.h
 redis-cli.o: redis-cli.c fmacros.h version.h ../deps/hiredis/hiredis.h \
   sds.h zmalloc.h ../deps/linenoise/linenoise.h help.h anet.h ae.h
 redis.o: redis.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
   ziplist.h intset.h version.h util.h rdb.h rio.h slowlog.h bio.h \
   asciilogo.h
-release.o: release.c release.h
+release.o: release.c release.h version.h crc64.h
 replication.o: replication.c redis.h fmacros.h config.h \
   ../deps/lua/src/lua.h ../deps/lua/src/luaconf.h ae.h sds.h dict.h \
   adlist.h zmalloc.h anet.h ziplist.h intset.h version.h util.h rdb.h \
   rio.h
-rio.o: rio.c fmacros.h rio.h sds.h util.h
+rio.o: rio.c fmacros.h rio.h sds.h util.h crc64.h
 scripting.o: scripting.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
   ziplist.h intset.h version.h util.h rdb.h rio.h sha1.h rand.h \
   ../deps/lua/src/lauxlib.h ../deps/lua/src/lua.h \
   ../deps/lua/src/lualib.h
 sds.o: sds.c sds.h zmalloc.h
 sentinel.o: sentinel.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
   ziplist.h intset.h version.h util.h rdb.h rio.h \
   ../deps/hiredis/hiredis.h ../deps/hiredis/async.h \
   ../deps/hiredis/hiredis.h
+setproctitle.o: setproctitle.c
 sha1.o: sha1.c sha1.h config.h
 slowlog.o: slowlog.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
   ziplist.h intset.h version.h util.h rdb.h rio.h slowlog.h
 sort.o: sort.c redis.h fmacros.h config.h ../deps/lua/src/lua.h \
   ../deps/lua/src/luaconf.h ae.h sds.h dict.h adlist.h zmalloc.h anet.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/.make-settings /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/.make-settings
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/.make-settings	2017-09-27 22:05:50.335055936 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/.make-settings	2017-09-27 22:06:58.863053425 +0800
@@ -3,8 +3,8 @@
 OPT=-O2
 MALLOC=jemalloc
 CFLAGS=
 LDFLAGS=
 REDIS_CFLAGS=
 REDIS_LDFLAGS=
-PREV_FINAL_CFLAGS=-std=c99 -pedantic -Wall -O2 -g -rdynamic -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include
-PREV_FINAL_LDFLAGS= -g -rdynamic -ggdb
+PREV_FINAL_CFLAGS=-std=c99 -pedantic -Wall -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include
+PREV_FINAL_LDFLAGS= -g -ggdb -rdynamic
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/memtest.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/memtest.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/memtest.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/memtest.c	2013-11-22 17:25:29.000000000 +0800
@@ -32,12 +32,13 @@
 #include <string.h>
 #include <assert.h>
 #include <limits.h>
 #include <errno.h>
 #include <termios.h>
 #include <sys/ioctl.h>
+#include "config.h"
 
 #if (ULONG_MAX == 4294967295UL)
 #define MEMTEST_32BIT
 #elif (ULONG_MAX == 18446744073709551615ULL)
 #define MEMTEST_64BIT
 #else
@@ -235,12 +236,38 @@
         memtest_fill_value(m,bytes,ULONG_ONEZERO,ULONG_ZEROONE,'C');
         memtest_progress_end();
         memtest_compare_times(m,bytes,pass,4);
     }
 }
 
+void memtest_non_destructive_invert(void *addr, size_t size) {
+    volatile unsigned long *p = addr;
+    size_t words = size / sizeof(unsigned long);
+    size_t j;
+
+    /* Invert */
+    for (j = 0; j < words; j++)
+        p[j] = ~p[j];
+}
+
+void memtest_non_destructive_swap(void *addr, size_t size) {
+    volatile unsigned long *p = addr;
+    size_t words = size / sizeof(unsigned long);
+    size_t j;
+
+    /* Swap */
+    for (j = 0; j < words; j += 2) {
+        unsigned long a, b;
+
+        a = p[j];
+        b = p[j+1];
+        p[j] = b;
+        p[j+1] = a;
+    }
+}
+
 void memtest(size_t megabytes, int passes) {
     if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
         ws.ws_col = 80;
         ws.ws_row = 20;
     }
     memtest_test(megabytes,passes);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/memtest.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/memtest.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/memtest.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/memtest.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/migrate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/migrate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/migrate.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/migrate.c	2013-11-22 17:25:29.000000000 +0800
@@ -136,13 +136,13 @@
 
     /* Sanity check */
     if (getLongFromObjectOrReply(c,c->argv[5],&timeout,NULL) != REDIS_OK)
         return;
     if (getLongFromObjectOrReply(c,c->argv[4],&dbid,NULL) != REDIS_OK)
         return;
-    if (timeout <= 0) timeout = 1000;
+    if (timeout <= 0) timeout = 1;
 
     /* Check if the key is here. If not we reply with success as there is
      * nothing to migrate (for instance the key expired in the meantime), but
      * we include such information in the reply string. */
     if ((o = lookupKeyRead(c->db,c->argv[3])) == NULL) {
         addReplySds(c,sdsnew("+NOKEY\r\n"));
@@ -154,14 +154,13 @@
                 atoi(c->argv[2]->ptr));
     if (fd == -1) {
         addReplyErrorFormat(c,"Can't connect to target node: %s",
             server.neterr);
         return;
     }
-    if ((aeWait(fd,AE_WRITABLE,timeout) & AE_WRITABLE) == 0) {
-        close(fd);
+    if ((aeWait(fd,AE_WRITABLE,timeout*1000) & AE_WRITABLE) == 0) {
         addReplySds(c,sdsnew("-IOERR error or timeout connecting to the client\r\n"));
         return;
     }
 
     /* Create RESTORE payload and generate the protocol to call the command. */
     rioInitWithBuffer(&cmd,sdsempty());
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/migrate.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/migrate.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/migrate.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/migrate.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/mkreleasehdr.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/mkreleasehdr.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/mkreleasehdr.sh	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/mkreleasehdr.sh	2013-11-22 17:25:29.000000000 +0800
@@ -1,9 +1,11 @@
 #!/bin/sh
 GIT_SHA1=`(git show-ref --head --hash=8 2> /dev/null || echo 00000000) | head -n1`
 GIT_DIRTY=`git diff --no-ext-diff 2> /dev/null | wc -l`
+BUILD_ID=`uname -n`"-"`date +%s`
 test -f release.h || touch release.h
 (cat release.h | grep SHA1 | grep $GIT_SHA1) && \
 (cat release.h | grep DIRTY | grep $GIT_DIRTY) && exit 0 # Already up-to-date
 echo "#define REDIS_GIT_SHA1 \"$GIT_SHA1\"" > release.h
 echo "#define REDIS_GIT_DIRTY \"$GIT_DIRTY\"" >> release.h
+echo "#define REDIS_BUILD_ID \"$BUILD_ID\"" >> release.h
 touch release.c # Force recompile of release.c
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/multi.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/multi.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/multi.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/multi.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/networking.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/networking.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/networking.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/networking.c	2013-11-22 17:25:29.000000000 +0800
@@ -26,12 +26,13 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "redis.h"
 #include <sys/uio.h>
+#include <math.h>
 
 static void setProtocolError(redisClient *c, int pos);
 
 /* To evaluate the output buffer size of a client we need to get size of
  * allocated objects, however we can't used zmalloc_size() directly on sds
  * strings because of the trick they use to work (the header is before the
@@ -84,27 +85,30 @@
     c->bulklen = -1;
     c->sentlen = 0;
     c->flags = 0;
     c->ctime = c->lastinteraction = server.unixtime;
     c->authenticated = 0;
     c->replstate = REDIS_REPL_NONE;
+    c->reploff = 0;
+    c->repl_ack_off = 0;
+    c->repl_ack_time = 0;
     c->slave_listening_port = 0;
     c->reply = listCreate();
     c->reply_bytes = 0;
     c->obuf_soft_limit_reached_time = 0;
-    listSetFreeMethod(c->reply,decrRefCount);
+    listSetFreeMethod(c->reply,decrRefCountVoid);
     listSetDupMethod(c->reply,dupClientReplyValue);
     c->bpop.keys = dictCreate(&setDictType,NULL);
     c->bpop.timeout = 0;
     c->bpop.target = NULL;
     c->io_keys = listCreate();
     c->watched_keys = listCreate();
-    listSetFreeMethod(c->io_keys,decrRefCount);
+    listSetFreeMethod(c->io_keys,decrRefCountVoid);
     c->pubsub_channels = dictCreate(&setDictType,NULL);
     c->pubsub_patterns = listCreate();
-    listSetFreeMethod(c->pubsub_patterns,decrRefCount);
+    listSetFreeMethod(c->pubsub_patterns,decrRefCountVoid);
     listSetMatchMethod(c->pubsub_patterns,listMatchObjects);
     if (fd != -1) listAddNodeTail(server.clients,c);
     initClientMultiState(c);
     return c;
 }
 
@@ -112,21 +116,23 @@
  * to the client. The behavior is the following:
  *
  * If the client should receive new data (normal clients will) the function
  * returns REDIS_OK, and make sure to install the write handler in our event
  * loop so that when the socket is writable new data gets written.
  *
- * If the client should not receive new data, because it is a fake client
- * or a slave, or because the setup of the write handler failed, the function
- * returns REDIS_ERR.
+ * If the client should not receive new data, because it is a fake client,
+ * a master, a slave not yet online, or because the setup of the write handler
+ * failed, the function returns REDIS_ERR.
  *
  * Typically gets called every time a reply is built, before adding more
  * data to the clients output buffers. If the function returns REDIS_ERR no
  * data should be appended to the output buffers. */
 int prepareClientToWrite(redisClient *c) {
     if (c->flags & REDIS_LUA_CLIENT) return REDIS_OK;
+    if ((c->flags & REDIS_MASTER) &&
+        !(c->flags & REDIS_MASTER_FORCE_REPLY)) return REDIS_ERR;
     if (c->fd <= 0) return REDIS_ERR; /* Fake client */
     if (c->bufpos == 0 && listLength(c->reply) == 0 &&
         (c->replstate == REDIS_REPL_NONE ||
          c->replstate == REDIS_REPL_ONLINE) &&
         aeCreateFileEvent(server.el, c->fd, AE_WRITABLE,
         sendReplyToClient, c) == AE_ERR) return REDIS_ERR;
@@ -407,15 +413,21 @@
 }
 
 /* Add a double as a bulk reply */
 void addReplyDouble(redisClient *c, double d) {
     char dbuf[128], sbuf[128];
     int dlen, slen;
-    dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
-    slen = snprintf(sbuf,sizeof(sbuf),"$%d\r\n%s\r\n",dlen,dbuf);
-    addReplyString(c,sbuf,slen);
+    if (isinf(d)) {
+        /* Libc in odd systems (Hi Solaris!) will format infinite in a
+         * different way, so better to handle it in an explicit way. */
+        addReplyBulkCString(c, d > 0 ? "inf" : "-inf");
+    } else {
+        dlen = snprintf(dbuf,sizeof(dbuf),"%.17g",d);
+        slen = snprintf(sbuf,sizeof(sbuf),"$%d\r\n%s\r\n",dlen,dbuf);
+        addReplyString(c,sbuf,slen);
+    }
 }
 
 /* Add a long long as integer reply or bulk len / multi bulk count.
  * Basically this is used to output <prefix><long long><crlf>. */
 void addReplyLongLongWithPrefix(redisClient *c, long long ll, char prefix) {
     char buf[128];
@@ -446,13 +458,16 @@
         addReply(c,shared.cone);
     else
         addReplyLongLongWithPrefix(c,ll,':');
 }
 
 void addReplyMultiBulkLen(redisClient *c, long length) {
-    addReplyLongLongWithPrefix(c,length,'*');
+    if (length < REDIS_SHARED_BULKHDR_LEN)
+        addReply(c,shared.mbulkhdr[length]);
+    else
+        addReplyLongLongWithPrefix(c,length,'*');
 }
 
 /* Create the length prefix of a bulk reply, example: $2234 */
 void addReplyBulkLen(redisClient *c, robj *obj) {
     size_t len;
 
@@ -468,13 +483,17 @@
             n = -n;
         }
         while((n = n/10) != 0) {
             len++;
         }
     }
-    addReplyLongLongWithPrefix(c,len,'$');
+
+    if (len < REDIS_SHARED_BULKHDR_LEN)
+        addReply(c,shared.bulkhdr[len]);
+    else
+        addReplyLongLongWithPrefix(c,len,'$');
 }
 
 /* Add a Redis Object as a bulk reply */
 void addReplyBulk(redisClient *c, robj *obj) {
     addReplyBulkLen(c,obj);
     addReply(c,obj);
@@ -544,18 +563,18 @@
     server.stat_numconnections++;
     c->flags |= flags;
 }
 
 void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
     int cport, cfd;
-    char cip[128];
+    char cip[REDIS_IP_STR_LEN];
     REDIS_NOTUSED(el);
     REDIS_NOTUSED(mask);
     REDIS_NOTUSED(privdata);
 
-    cfd = anetTcpAccept(server.neterr, fd, cip, &cport);
+    cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
     if (cfd == AE_ERR) {
         redisLog(REDIS_WARNING,"Accepting client connection: %s", server.neterr);
         return;
     }
     redisLog(REDIS_VERBOSE,"Accepted %s:%d", cip, cport);
     acceptCommonHandler(cfd,0);
@@ -592,18 +611,48 @@
     while (listLength(server.slaves)) {
         listNode *ln = listFirst(server.slaves);
         freeClient((redisClient*)ln->value);
     }
 }
 
+/* This function is called when the slave lose the connection with the
+ * master into an unexpected way. */
+void replicationHandleMasterDisconnection(void) {
+    server.master = NULL;
+    server.repl_state = REDIS_REPL_CONNECT;
+    server.repl_down_since = server.unixtime;
+    /* We lost connection with our master, force our slaves to resync
+     * with us as well to load the new data set.
+     *
+     * If server.masterhost is NULL the user called SLAVEOF NO ONE so
+     * slave resync is not needed. */
+    if (server.masterhost != NULL) disconnectSlaves();
+}
+
 void freeClient(redisClient *c) {
     listNode *ln;
 
     /* If this is marked as current client unset it */
     if (server.current_client == c) server.current_client = NULL;
 
+    /* If it is our master that's beging disconnected we should make sure
+     * to cache the state to try a partial resynchronization later.
+     *
+     * Note that before doing this we make sure that the client is not in
+     * some unexpected state, by checking its flags. */
+    if (server.master &&
+         (c->flags & REDIS_MASTER) &&
+        !(c->flags & (REDIS_CLOSE_AFTER_REPLY|
+                     REDIS_CLOSE_ASAP|
+                     REDIS_BLOCKED|
+                     REDIS_UNBLOCKED)))
+    {
+        replicationCacheMaster(c);
+        return;
+    }
+
     /* Note that if the client we are freeing is blocked into a blocking
      * call, we have to set querybuf to NULL *before* to call
      * unblockClientWaitingData() to avoid processInputBuffer() will get
      * called. Also it is important to remove the file events after
      * this, because this call adds the READABLE event. */
     sdsfree(c->querybuf);
@@ -617,22 +666,27 @@
     listRelease(c->watched_keys);
     /* Unsubscribe from all the pubsub channels */
     pubsubUnsubscribeAllChannels(c,0);
     pubsubUnsubscribeAllPatterns(c,0);
     dictRelease(c->pubsub_channels);
     listRelease(c->pubsub_patterns);
-    /* Obvious cleanup */
-    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
-    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
+    /* Close socket, unregister events, and remove list of replies and
+     * accumulated arguments. */
+    if (c->fd != -1) {
+        aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
+        aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
+        close(c->fd);
+    }
     listRelease(c->reply);
     freeClientArgv(c);
-    close(c->fd);
     /* Remove from the list of clients */
-    ln = listSearchKey(server.clients,c);
-    redisAssert(ln != NULL);
-    listDelNode(server.clients,ln);
+    if (c->fd != -1) {
+        ln = listSearchKey(server.clients,c);
+        redisAssert(ln != NULL);
+        listDelNode(server.clients,ln);
+    }
     /* When client was just unblocked because of a blocking operation,
      * remove it from the list with unblocked clients. */
     if (c->flags & REDIS_UNBLOCKED) {
         ln = listSearchKey(server.unblocked_clients,c);
         redisAssert(ln != NULL);
         listDelNode(server.unblocked_clients,ln);
@@ -644,26 +698,22 @@
         if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)
             close(c->repldbfd);
         list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;
         ln = listSearchKey(l,c);
         redisAssert(ln != NULL);
         listDelNode(l,ln);
+        /* We need to remember the time when we started to have zero
+         * attached slaves, as after some time we'll free the replication
+         * backlog. */
+        if (c->flags & REDIS_SLAVE && listLength(server.slaves) == 0)
+            server.repl_no_slaves_since = server.unixtime;
+        refreshGoodSlavesCount();
     }
 
     /* Case 2: we lost the connection with the master. */
-    if (c->flags & REDIS_MASTER) {
-        server.master = NULL;
-        server.repl_state = REDIS_REPL_CONNECT;
-        server.repl_down_since = server.unixtime;
-        /* We lost connection with our master, force our slaves to resync
-         * with us as well to load the new data set.
-         *
-         * If server.masterhost is NULL the user called SLAVEOF NO ONE so
-         * slave resync is not needed. */
-        if (server.masterhost != NULL) disconnectSlaves();
-    }
+    if (c->flags & REDIS_MASTER) replicationHandleMasterDisconnection();
 
     /* If this client was scheduled for async freeing we need to remove it
      * from the queue. */
     if (c->flags & REDIS_CLOSE_ASAP) {
         ln = listSearchKey(server.clients_to_close,c);
         redisAssert(ln != NULL);
@@ -705,19 +755,14 @@
     robj *o;
     REDIS_NOTUSED(el);
     REDIS_NOTUSED(mask);
 
     while(c->bufpos > 0 || listLength(c->reply)) {
         if (c->bufpos > 0) {
-            if (c->flags & REDIS_MASTER) {
-                /* Don't reply to a master */
-                nwritten = c->bufpos - c->sentlen;
-            } else {
-                nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
-                if (nwritten <= 0) break;
-            }
+            nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
+            if (nwritten <= 0) break;
             c->sentlen += nwritten;
             totwritten += nwritten;
 
             /* If the buffer was sent, set bufpos to zero to continue with
              * the remainder of the reply. */
             if (c->sentlen == c->bufpos) {
@@ -731,19 +776,14 @@
 
             if (objlen == 0) {
                 listDelNode(c->reply,listFirst(c->reply));
                 continue;
             }
 
-            if (c->flags & REDIS_MASTER) {
-                /* Don't reply to a master */
-                nwritten = objlen - c->sentlen;
-            } else {
-                nwritten = write(fd, ((char*)o->ptr)+c->sentlen,objlen-c->sentlen);
-                if (nwritten <= 0) break;
-            }
+            nwritten = write(fd, ((char*)o->ptr)+c->sentlen,objlen-c->sentlen);
+            if (nwritten <= 0) break;
             c->sentlen += nwritten;
             totwritten += nwritten;
 
             /* If we fully sent the object on head go to the next one */
             if (c->sentlen == objlen) {
                 listDelNode(c->reply,listFirst(c->reply));
@@ -770,13 +810,19 @@
             redisLog(REDIS_VERBOSE,
                 "Error writing to client: %s", strerror(errno));
             freeClient(c);
             return;
         }
     }
-    if (totwritten > 0) c->lastinteraction = server.unixtime;
+    if (totwritten > 0) {
+        /* For clients representing masters we don't count sending data
+         * as an interaction, since we always send REPLCONF ACK commands
+         * that take some time to just fill the socket output buffer.
+         * We just rely on data / pings received for timeout detection. */
+        if (!(c->flags & REDIS_MASTER)) c->lastinteraction = server.unixtime;
+    }
     if (c->bufpos == 0 && listLength(c->reply) == 0) {
         c->sentlen = 0;
         aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
 
         /* Close connection after entire reply has been sent. */
         if (c->flags & REDIS_CLOSE_AFTER_REPLY) freeClient(c);
@@ -793,13 +839,13 @@
     if (!(c->flags & REDIS_MULTI)) c->flags &= (~REDIS_ASKING);
 }
 
 int processInlineBuffer(redisClient *c) {
     char *newline = strstr(c->querybuf,"\r\n");
     int argc, j;
-    sds *argv;
+    sds *argv, aux;
     size_t querylen;
 
     /* Nothing to do without a \r\n */
     if (newline == NULL) {
         if (sdslen(c->querybuf) > REDIS_INLINE_MAX_SIZE) {
             addReplyError(c,"Protocol error: too big inline request");
@@ -807,16 +853,18 @@
         }
         return REDIS_ERR;
     }
 
     /* Split the input buffer up to the \r\n */
     querylen = newline-(c->querybuf);
-    argv = sdssplitlen(c->querybuf,querylen," ",1,&argc);
+    aux = sdsnewlen(c->querybuf,querylen);
+    argv = sdssplitargs(aux,&argc);
+    sdsfree(aux);
 
     /* Leave data after the first line of the query in the buffer */
-    c->querybuf = sdsrange(c->querybuf,querylen+2,-1);
+    sdsrange(c->querybuf,querylen+2,-1);
 
     /* Setup argv array on client structure */
     if (c->argv) zfree(c->argv);
     c->argv = zmalloc(sizeof(robj*)*argc);
 
     /* Create redis objects for all arguments. */
@@ -839,13 +887,13 @@
         sds client = getClientInfoString(c);
         redisLog(REDIS_VERBOSE,
             "Protocol error from client: %s", client);
         sdsfree(client);
     }
     c->flags |= REDIS_CLOSE_AFTER_REPLY;
-    c->querybuf = sdsrange(c->querybuf,pos,-1);
+    sdsrange(c->querybuf,pos,-1);
 }
 
 int processMultibulkBuffer(redisClient *c) {
     char *newline = NULL;
     int pos = 0, ok;
     long long ll;
@@ -877,13 +925,13 @@
             setProtocolError(c,pos);
             return REDIS_ERR;
         }
 
         pos = (newline-c->querybuf)+2;
         if (ll <= 0) {
-            c->querybuf = sdsrange(c->querybuf,pos,-1);
+            sdsrange(c->querybuf,pos,-1);
             return REDIS_OK;
         }
 
         c->multibulklen = ll;
 
         /* Setup argv array on client structure */
@@ -928,13 +976,13 @@
                 size_t qblen;
 
                 /* If we are going to read a large object from network
                  * try to make it likely that it will start at c->querybuf
                  * boundary so that we can optimize object creation
                  * avoiding a large copy of data. */
-                c->querybuf = sdsrange(c->querybuf,pos,-1);
+                sdsrange(c->querybuf,pos,-1);
                 pos = 0;
                 qblen = sdslen(c->querybuf);
                 /* Hint the sds library about the amount of bytes this string is
                  * going to contain. */
                 if (qblen < ll+2)
                     c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2-qblen);
@@ -969,13 +1017,13 @@
             c->bulklen = -1;
             c->multibulklen--;
         }
     }
 
     /* Trim to pos */
-    if (pos) c->querybuf = sdsrange(c->querybuf,pos,-1);
+    if (pos) sdsrange(c->querybuf,pos,-1);
 
     /* We're done when c->multibulk == 0 */
     if (c->multibulklen == 0) return REDIS_OK;
 
     /* Still not read to process the command */
     return REDIS_ERR;
@@ -1060,12 +1108,13 @@
         freeClient(c);
         return;
     }
     if (nread) {
         sdsIncrLen(c->querybuf,nread);
         c->lastinteraction = server.unixtime;
+        if (c->flags & REDIS_MASTER) c->reploff += nread;
     } else {
         server.current_client = NULL;
         return;
     }
     if (sdslen(c->querybuf) > server.client_max_querybuf_len) {
         sds ci = getClientInfoString(c), bytes = sdsempty();
@@ -1096,20 +1145,58 @@
         if (sdslen(c->querybuf) > bib) bib = sdslen(c->querybuf);
     }
     *longest_output_list = lol;
     *biggest_input_buffer = bib;
 }
 
+/* This is an helper function for getClientPeerId().
+ * It writes the specified ip/port to "peerid" as a null termiated string
+ * in the form ip:port if ip does not contain ":" itself, otherwise
+ * [ip]:port format is used (for IPv6 addresses basically). */
+void formatPeerId(char *peerid, size_t peerid_len, char *ip, int port) {
+    if (strchr(ip,':'))
+        snprintf(peerid,peerid_len,"[%s]:%d",ip,port);
+    else
+        snprintf(peerid,peerid_len,"%s:%d",ip,port);
+}
+
+/* A Redis "Peer ID" is a colon separated ip:port pair.
+ * For IPv4 it's in the form x.y.z.k:pork, example: "127.0.0.1:1234".
+ * For IPv6 addresses we use [] around the IP part, like in "[::1]:1234".
+ * For Unix socekts we use path:0, like in "/tmp/redis:0".
+ *
+ * A Peer ID always fits inside a buffer of REDIS_PEER_ID_LEN bytes, including
+ * the null term.
+ *
+ * The function returns REDIS_OK on succcess, and REDIS_ERR on failure.
+ *
+ * On failure the function still populates 'peerid' with the "?:0" string
+ * in case you want to relax error checking or need to display something
+ * anyway (see anetPeerToString implementation for more info). */
+int getClientPeerId(redisClient *client, char *peerid, size_t peerid_len) {
+    char ip[REDIS_IP_STR_LEN];
+    int port;
+
+    if (client->flags & REDIS_UNIX_SOCKET) {
+        /* Unix socket client. */
+        snprintf(peerid,peerid_len,"%s:0",server.unixsocket);
+        return REDIS_OK;
+    } else {
+        /* TCP client. */
+        int retval = anetPeerToString(client->fd,ip,sizeof(ip),&port);
+        formatPeerId(peerid,peerid_len,ip,port);
+        return (retval == -1) ? REDIS_ERR : REDIS_OK;
+    }
+}
+
 /* Turn a Redis client into an sds string representing its state. */
 sds getClientInfoString(redisClient *client) {
-    char ip[32], flags[16], events[3], *p;
-    int port = 0; /* initialized to zero for the unix socket case. */
+    char peerid[REDIS_PEER_ID_LEN], flags[16], events[3], *p;
     int emask;
 
-    if (!(client->flags & REDIS_UNIX_SOCKET))
-        anetPeerToString(client->fd,ip,&port);
+    getClientPeerId(client,peerid,sizeof(peerid));
     p = flags;
     if (client->flags & REDIS_SLAVE) {
         if (client->flags & REDIS_MONITOR)
             *p++ = 'O';
         else
             *p++ = 'S';
@@ -1128,15 +1215,14 @@
     emask = client->fd == -1 ? 0 : aeGetFileEvents(server.el,client->fd);
     p = events;
     if (emask & AE_READABLE) *p++ = 'r';
     if (emask & AE_WRITABLE) *p++ = 'w';
     *p = '\0';
     return sdscatprintf(sdsempty(),
-        "addr=%s:%d fd=%d name=%s age=%ld idle=%ld flags=%s db=%d sub=%d psub=%d multi=%d qbuf=%lu qbuf-free=%lu obl=%lu oll=%lu omem=%lu events=%s cmd=%s",
-        (client->flags & REDIS_UNIX_SOCKET) ? server.unixsocket : ip,
-        port,
+        "addr=%s fd=%d name=%s age=%ld idle=%ld flags=%s db=%d sub=%d psub=%d multi=%d qbuf=%lu qbuf-free=%lu obl=%lu oll=%lu omem=%lu events=%s cmd=%s",
+        peerid,
         client->fd,
         client->name ? (char*)client->name->ptr : "",
         (long)(server.unixtime - client->ctime),
         (long)(server.unixtime - client->lastinteraction),
         flags,
         client->db->id,
@@ -1180,19 +1266,18 @@
         sds o = getAllClientsInfoString();
         addReplyBulkCBuffer(c,o,sdslen(o));
         sdsfree(o);
     } else if (!strcasecmp(c->argv[1]->ptr,"kill") && c->argc == 3) {
         listRewind(server.clients,&li);
         while ((ln = listNext(&li)) != NULL) {
-            char ip[32], addr[64];
-            int port;
+            char peerid[REDIS_PEER_ID_LEN];
 
             client = listNodeValue(ln);
-            if (anetPeerToString(client->fd,ip,&port) == -1) continue;
-            snprintf(addr,sizeof(addr),"%s:%d",ip,port);
-            if (strcmp(addr,c->argv[2]->ptr) == 0) {
+            if (getClientPeerId(client,peerid,sizeof(peerid)) == REDIS_ERR)
+                continue;
+            if (strcmp(peerid,c->argv[2]->ptr) == 0) {
                 addReply(c,shared.ok);
                 if (c == client) {
                     client->flags |= REDIS_CLOSE_AFTER_REPLY;
                 } else {
                     freeClient(client);
                 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/networking.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/networking.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/networking.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/networking.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src: notify.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src: notify.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src: notify.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/object.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/object.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/object.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/object.c	2013-11-22 17:25:29.000000000 +0800
@@ -94,13 +94,13 @@
     return createStringObject(o->ptr,sdslen(o->ptr));
 }
 
 robj *createListObject(void) {
     list *l = listCreate();
     robj *o = createObject(REDIS_LIST,l);
-    listSetFreeMethod(l,decrRefCount);
+    listSetFreeMethod(l,decrRefCountVoid);
     o->encoding = REDIS_ENCODING_LINKEDLIST;
     return o;
 }
 
 robj *createZiplistObject(void) {
     unsigned char *zl = ziplistNew();
@@ -212,15 +212,13 @@
 }
 
 void incrRefCount(robj *o) {
     o->refcount++;
 }
 
-void decrRefCount(void *obj) {
-    robj *o = obj;
-
+void decrRefCount(robj *o) {
     if (o->refcount <= 0) redisPanic("decrRefCount against refcount <= 0");
     if (o->refcount == 1) {
         switch(o->type) {
         case REDIS_STRING: freeStringObject(o); break;
         case REDIS_LIST: freeListObject(o); break;
         case REDIS_SET: freeSetObject(o); break;
@@ -231,12 +229,19 @@
         zfree(o);
     } else {
         o->refcount--;
     }
 }
 
+/* This variant of decrRefCount() gets its argument as void, and is useful
+ * as free method in data structures that expect a 'void free_object(void*)'
+ * prototype for the free method. */
+void decrRefCountVoid(void *o) {
+    decrRefCount(o);
+}
+
 /* This function set the ref count to zero without freeing the object.
  * It is useful in order to pass a new object to functions incrementing
  * the ref count of the received object. Example:
  *
  *    functionThatWillIncrementRefCount(resetRefCount(CreateObject(...)));
  *
@@ -345,41 +350,63 @@
         return dec;
     } else {
         redisPanic("Unknown encoding type");
     }
 }
 
-/* Compare two string objects via strcmp() or alike.
+/* Compare two string objects via strcmp() or strcoll() depending on flags.
  * Note that the objects may be integer-encoded. In such a case we
  * use ll2string() to get a string representation of the numbers on the stack
  * and compare the strings, it's much faster than calling getDecodedObject().
  *
- * Important note: if objects are not integer encoded, but binary-safe strings,
- * sdscmp() from sds.c will apply memcmp() so this function ca be considered
- * binary safe. */
-int compareStringObjects(robj *a, robj *b) {
+ * Important note: when REDIS_COMPARE_BINARY is used a binary-safe comparison
+ * is used. */
+
+#define REDIS_COMPARE_BINARY (1<<0)
+#define REDIS_COMPARE_COLL (1<<1)
+
+int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {
     redisAssertWithInfo(NULL,a,a->type == REDIS_STRING && b->type == REDIS_STRING);
     char bufa[128], bufb[128], *astr, *bstr;
-    int bothsds = 1;
+    size_t alen, blen, minlen;
 
     if (a == b) return 0;
     if (a->encoding != REDIS_ENCODING_RAW) {
-        ll2string(bufa,sizeof(bufa),(long) a->ptr);
+        alen = ll2string(bufa,sizeof(bufa),(long) a->ptr);
         astr = bufa;
-        bothsds = 0;
     } else {
         astr = a->ptr;
+        alen = sdslen(astr);
     }
     if (b->encoding != REDIS_ENCODING_RAW) {
-        ll2string(bufb,sizeof(bufb),(long) b->ptr);
+        blen = ll2string(bufb,sizeof(bufb),(long) b->ptr);
         bstr = bufb;
-        bothsds = 0;
     } else {
         bstr = b->ptr;
+        blen = sdslen(bstr);
+    }
+    if (flags & REDIS_COMPARE_COLL) {
+        return strcoll(astr,bstr);
+    } else {
+        int cmp;
+
+        minlen = (alen < blen) ? alen : blen;
+        cmp = memcmp(astr,bstr,minlen);
+        if (cmp == 0) return alen-blen;
+        return cmp;
     }
-    return bothsds ? sdscmp(astr,bstr) : strcmp(astr,bstr);
+}
+
+/* Wrapper for compareStringObjectsWithFlags() using binary comparison. */
+int compareStringObjects(robj *a, robj *b) {
+    return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_BINARY);
+}
+
+/* Wrapper for compareStringObjectsWithFlags() using collation. */
+int collateStringObjects(robj *a, robj *b) {
+    return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_COLL);
 }
 
 /* Equal string objects return 1 if the two objects are the same from the
  * point of view of a string comparison, otherwise 0 is returned. Note that
  * this function is faster then checking for (compareStringObject(a,b) == 0)
  * because it can perform some more optimization. */
@@ -410,14 +437,18 @@
         value = 0;
     } else {
         redisAssertWithInfo(NULL,o,o->type == REDIS_STRING);
         if (o->encoding == REDIS_ENCODING_RAW) {
             errno = 0;
             value = strtod(o->ptr, &eptr);
-            if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' ||
-                errno == ERANGE || isnan(value))
+            if (isspace(((char*)o->ptr)[0]) ||
+                eptr[0] != '\0' ||
+                (errno == ERANGE &&
+                    (value == HUGE_VAL || value == -HUGE_VAL || value == 0)) ||
+                errno == EINVAL ||
+                isnan(value))
                 return REDIS_ERR;
         } else if (o->encoding == REDIS_ENCODING_INT) {
             value = (long)o->ptr;
         } else {
             redisPanic("Unknown string encoding");
         }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/object.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/object.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/object.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/object.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pqsort.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pqsort.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pqsort.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pqsort.c	2013-11-22 17:25:29.000000000 +0800
@@ -98,16 +98,15 @@
 static void
 _pqsort(void *a, size_t n, size_t es,
     int (*cmp) (const void *, const void *), void *lrange, void *rrange)
 {
 	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
 	size_t d, r;
-	int swaptype, swap_cnt, cmp_result;
+	int swaptype, cmp_result;
 
 loop:	SWAPINIT(a, es);
-	swap_cnt = 0;
 	if (n < 7) {
 		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
 			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
 			     pl -= es)
 				swap(pl, pl - es);
 		return;
@@ -128,40 +127,30 @@
 	pa = pb = (char *) a + es;
 
 	pc = pd = (char *) a + (n - 1) * es;
 	for (;;) {
 		while (pb <= pc && (cmp_result = cmp(pb, a)) <= 0) {
 			if (cmp_result == 0) {
-				swap_cnt = 1;
 				swap(pa, pb);
 				pa += es;
 			}
 			pb += es;
 		}
 		while (pb <= pc && (cmp_result = cmp(pc, a)) >= 0) {
 			if (cmp_result == 0) {
-				swap_cnt = 1;
 				swap(pc, pd);
 				pd -= es;
 			}
 			pc -= es;
 		}
 		if (pb > pc)
 			break;
 		swap(pb, pc);
-		swap_cnt = 1;
 		pb += es;
 		pc -= es;
 	}
-	if (swap_cnt == 0) {  /* Switch to insertion sort */
-		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
-			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0; 
-			     pl -= es)
-				swap(pl, pl - es);
-		return;
-	}
 
 	pn = (char *) a + n * es;
 	r = min(pa - (char *) a, pb - pa);
 	vecswap(a, pb - r, r);
 	r = min((size_t)(pd - pc), pn - pd - es);
 	vecswap(pb, pn - r, r);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pqsort.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pqsort.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pqsort.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pqsort.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pubsub.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pubsub.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pubsub.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pubsub.c	2013-11-22 17:25:29.000000000 +0800
@@ -303,8 +303,56 @@
             pubsubUnsubscribePattern(c,c->argv[j],1);
     }
 }
 
 void publishCommand(redisClient *c) {
     int receivers = pubsubPublishMessage(c->argv[1],c->argv[2]);
+    forceCommandPropagation(c,REDIS_PROPAGATE_REPL);
     addReplyLongLong(c,receivers);
 }
+
+/* PUBSUB command for Pub/Sub introspection. */
+void pubsubCommand(redisClient *c) {
+    if (!strcasecmp(c->argv[1]->ptr,"channels") &&
+        (c->argc == 2 || c->argc ==3))
+    {
+        /* PUBSUB CHANNELS [<pattern>] */
+        sds pat = (c->argc == 2) ? NULL : c->argv[2]->ptr;
+        dictIterator *di = dictGetIterator(server.pubsub_channels);
+        dictEntry *de;
+        long mblen = 0;
+        void *replylen;
+
+        replylen = addDeferredMultiBulkLength(c);
+        while((de = dictNext(di)) != NULL) {
+            robj *cobj = dictGetKey(de);
+            sds channel = cobj->ptr;
+
+            if (!pat || stringmatchlen(pat, sdslen(pat),
+                                       channel, sdslen(channel),0))
+            {
+                addReplyBulk(c,cobj);
+                mblen++;
+            }
+        }
+        dictReleaseIterator(di);
+        setDeferredMultiBulkLength(c,replylen,mblen);
+    } else if (!strcasecmp(c->argv[1]->ptr,"numsub") && c->argc >= 2) {
+        /* PUBSUB NUMSUB [Channel_1 ... Channel_N] */
+        int j;
+
+        addReplyMultiBulkLen(c,(c->argc-2)*2);
+        for (j = 2; j < c->argc; j++) {
+            list *l = dictFetchValue(server.pubsub_channels,c->argv[j]);
+
+            addReplyBulk(c,c->argv[j]);
+            addReplyBulkLongLong(c,l ? listLength(l) : 0);
+        }
+    } else if (!strcasecmp(c->argv[1]->ptr,"numpat") && c->argc == 2) {
+        /* PUBSUB NUMPAT */
+        addReplyLongLong(c,listLength(server.pubsub_patterns));
+    } else {
+        addReplyErrorFormat(c,
+            "Unknown PUBSUB subcommand or wrong number of arguments for '%s'",
+            (char*)c->argv[1]->ptr);
+    }
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pubsub.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pubsub.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/pubsub.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/pubsub.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rand.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rand.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rand.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rand.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rdb.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rdb.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rdb.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rdb.c	2013-11-22 17:25:29.000000000 +0800
@@ -726,14 +726,14 @@
 
     start = ustime();
     if ((childpid = fork()) == 0) {
         int retval;
 
         /* Child */
-        if (server.ipfd > 0) close(server.ipfd);
-        if (server.sofd > 0) close(server.sofd);
+        closeListeningSockets(0);
+        redisSetProcTitle("redis-rdb-bgsave");
         retval = rdbSave(filename);
         if (retval == REDIS_OK) {
             size_t private_dirty = zmalloc_get_private_dirty();
 
             if (private_dirty) {
                 redisLog(REDIS_NOTICE,
@@ -771,13 +771,12 @@
  * On success a newly allocated object is returned, otherwise NULL. */
 robj *rdbLoadObject(int rdbtype, rio *rdb) {
     robj *o, *ele, *dec;
     size_t len;
     unsigned int i;
 
-    redisLog(REDIS_DEBUG,"LOADING OBJECT %d (at %d)\n",rdbtype,rioTell(rdb));
     if (rdbtype == REDIS_RDB_TYPE_STRING) {
         /* Read string value */
         if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
         o = tryObjectEncoding(o);
     } else if (rdbtype == REDIS_RDB_TYPE_LIST) {
         /* Read list value */
@@ -1056,27 +1055,38 @@
 
 /* Loading finished */
 void stopLoading(void) {
     server.loading = 0;
 }
 
+/* Track loading progress in order to serve client's from time to time
+   and if needed calculate rdb checksum  */
+void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
+    if (server.rdb_checksum)
+        rioGenericUpdateChecksum(r, buf, len);
+    if (server.loading_process_events_interval_bytes &&
+        (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes) {
+        loadingProgress(r->processed_bytes);
+        aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);
+    }
+}
+
 int rdbLoad(char *filename) {
     uint32_t dbid;
     int type, rdbver;
     redisDb *db = server.db+0;
     char buf[1024];
     long long expiretime, now = mstime();
-    long loops = 0;
     FILE *fp;
     rio rdb;
 
     if ((fp = fopen(filename,"r")) == NULL) return REDIS_ERR;
 
     rioInitWithFile(&rdb,fp);
-    if (server.rdb_checksum)
-        rdb.update_cksum = rioGenericUpdateChecksum;
+    rdb.update_cksum = rdbLoadProgressCallback;
+    rdb.max_processing_chunk = server.loading_process_events_interval_bytes;
     if (rioRead(&rdb,buf,9) == 0) goto eoferr;
     buf[9] = '\0';
     if (memcmp(buf,"REDIS",5) != 0) {
         fclose(fp);
         redisLog(REDIS_WARNING,"Wrong signature trying to load DB from file");
         errno = EINVAL;
@@ -1092,18 +1102,12 @@
 
     startLoading(fp);
     while(1) {
         robj *key, *val;
         expiretime = -1;
 
-        /* Serve the clients from time to time */
-        if (!(loops++ % 1000)) {
-            loadingProgress(rioTell(&rdb));
-            aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);
-        }
-
         /* Read type. */
         if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
         if (type == REDIS_RDB_OPCODE_EXPIRETIME) {
             if ((expiretime = rdbLoadTime(&rdb)) == -1) goto eoferr;
             /* We read the time so we need to read the object type again. */
             if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rdb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rdb.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rdb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rdb.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark.c	2013-11-22 17:25:29.000000000 +0800
@@ -32,12 +32,13 @@
 
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <errno.h>
+#include <time.h>
 #include <sys/time.h>
 #include <signal.h>
 #include <assert.h>
 
 #include "ae.h"
 #include "hiredis.h"
@@ -617,12 +618,13 @@
     int i;
     char *data, *cmd;
     int len;
 
     client c;
 
+    srandom(time(NULL));
     signal(SIGHUP, SIG_IGN);
     signal(SIGPIPE, SIG_IGN);
 
     config.numclients = 50;
     config.requests = 10000;
     config.liveclients = 0;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-benchmark.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-benchmark.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.c	2013-11-22 17:25:29.000000000 +0800
@@ -46,12 +46,13 @@
 #include <sys/uio.h>
 #include <limits.h>
 #include <float.h>
 #include <math.h>
 #include <sys/resource.h>
 #include <sys/utsname.h>
+#include <locale.h>
 
 /* Our shared "common" objects */
 
 struct sharedObjectsStruct shared;
 
 /* Global vars that are actually used as constants. The following double
@@ -158,12 +159,13 @@
     {"sinterstore",sinterstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
     {"sunion",sunionCommand,-2,"rS",0,NULL,1,-1,1,0,0},
     {"sunionstore",sunionstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
     {"sdiff",sdiffCommand,-2,"rS",0,NULL,1,-1,1,0,0},
     {"sdiffstore",sdiffstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
     {"smembers",sinterCommand,2,"rS",0,NULL,1,1,1,0,0},
+    {"sscan",sscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
     {"zadd",zaddCommand,-4,"wm",0,NULL,1,1,1,0,0},
     {"zincrby",zincrbyCommand,4,"wm",0,NULL,1,1,1,0,0},
     {"zrem",zremCommand,-3,"w",0,NULL,1,1,1,0,0},
     {"zremrangebyscore",zremrangebyscoreCommand,4,"w",0,NULL,1,1,1,0,0},
     {"zremrangebyrank",zremrangebyrankCommand,4,"w",0,NULL,1,1,1,0,0},
     {"zunionstore",zunionstoreCommand,-4,"wm",0,zunionInterGetKeys,0,0,0,0,0},
@@ -174,12 +176,13 @@
     {"zcount",zcountCommand,4,"r",0,NULL,1,1,1,0,0},
     {"zrevrange",zrevrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
     {"zcard",zcardCommand,2,"r",0,NULL,1,1,1,0,0},
     {"zscore",zscoreCommand,3,"r",0,NULL,1,1,1,0,0},
     {"zrank",zrankCommand,3,"r",0,NULL,1,1,1,0,0},
     {"zrevrank",zrevrankCommand,3,"r",0,NULL,1,1,1,0,0},
+    {"zscan",zscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
     {"hset",hsetCommand,4,"wm",0,NULL,1,1,1,0,0},
     {"hsetnx",hsetnxCommand,4,"wm",0,NULL,1,1,1,0,0},
     {"hget",hgetCommand,3,"r",0,NULL,1,1,1,0,0},
     {"hmset",hmsetCommand,-4,"wm",0,NULL,1,1,1,0,0},
     {"hmget",hmgetCommand,-3,"r",0,NULL,1,1,1,0,0},
     {"hincrby",hincrbyCommand,4,"wm",0,NULL,1,1,1,0,0},
@@ -187,12 +190,13 @@
     {"hdel",hdelCommand,-3,"w",0,NULL,1,1,1,0,0},
     {"hlen",hlenCommand,2,"r",0,NULL,1,1,1,0,0},
     {"hkeys",hkeysCommand,2,"rS",0,NULL,1,1,1,0,0},
     {"hvals",hvalsCommand,2,"rS",0,NULL,1,1,1,0,0},
     {"hgetall",hgetallCommand,2,"r",0,NULL,1,1,1,0,0},
     {"hexists",hexistsCommand,3,"r",0,NULL,1,1,1,0,0},
+    {"hscan",hscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
     {"incrby",incrbyCommand,3,"wm",0,NULL,1,1,1,0,0},
     {"decrby",decrbyCommand,3,"wm",0,NULL,1,1,1,0,0},
     {"incrbyfloat",incrbyfloatCommand,3,"wm",0,NULL,1,1,1,0,0},
     {"getset",getsetCommand,3,"wm",0,NULL,1,1,1,0,0},
     {"mset",msetCommand,-3,"wm",0,NULL,1,-1,2,0,0},
     {"msetnx",msetnxCommand,-3,"wm",0,NULL,1,-1,2,0,0},
@@ -203,27 +207,29 @@
     {"renamenx",renamenxCommand,3,"w",0,renameGetKeys,1,2,1,0,0},
     {"expire",expireCommand,3,"w",0,NULL,1,1,1,0,0},
     {"expireat",expireatCommand,3,"w",0,NULL,1,1,1,0,0},
     {"pexpire",pexpireCommand,3,"w",0,NULL,1,1,1,0,0},
     {"pexpireat",pexpireatCommand,3,"w",0,NULL,1,1,1,0,0},
     {"keys",keysCommand,2,"rS",0,NULL,0,0,0,0,0},
+    {"scan",scanCommand,-2,"rR",0,NULL,0,0,0,0,0},
     {"dbsize",dbsizeCommand,1,"r",0,NULL,0,0,0,0,0},
     {"auth",authCommand,2,"rslt",0,NULL,0,0,0,0,0},
     {"ping",pingCommand,1,"rt",0,NULL,0,0,0,0,0},
     {"echo",echoCommand,2,"r",0,NULL,0,0,0,0,0},
     {"save",saveCommand,1,"ars",0,NULL,0,0,0,0,0},
     {"bgsave",bgsaveCommand,1,"ar",0,NULL,0,0,0,0,0},
     {"bgrewriteaof",bgrewriteaofCommand,1,"ar",0,NULL,0,0,0,0,0},
-    {"shutdown",shutdownCommand,-1,"ar",0,NULL,0,0,0,0,0},
+    {"shutdown",shutdownCommand,-1,"arl",0,NULL,0,0,0,0,0},
     {"lastsave",lastsaveCommand,1,"rR",0,NULL,0,0,0,0,0},
     {"type",typeCommand,2,"r",0,NULL,1,1,1,0,0},
     {"multi",multiCommand,1,"rs",0,NULL,0,0,0,0,0},
     {"exec",execCommand,1,"sM",0,NULL,0,0,0,0,0},
     {"discard",discardCommand,1,"rs",0,NULL,0,0,0,0,0},
     {"sync",syncCommand,1,"ars",0,NULL,0,0,0,0,0},
-    {"replconf",replconfCommand,-1,"ars",0,NULL,0,0,0,0,0},
+    {"psync",syncCommand,3,"ars",0,NULL,0,0,0,0,0},
+    {"replconf",replconfCommand,-1,"arslt",0,NULL,0,0,0,0,0},
     {"flushdb",flushdbCommand,1,"w",0,NULL,0,0,0,0,0},
     {"flushall",flushallCommand,1,"w",0,NULL,0,0,0,0,0},
     {"sort",sortCommand,-2,"wm",0,NULL,1,1,1,0,0},
     {"info",infoCommand,-1,"rlt",0,NULL,0,0,0,0,0},
     {"monitor",monitorCommand,1,"ars",0,NULL,0,0,0,0,0},
     {"ttl",ttlCommand,2,"r",0,NULL,1,1,1,0,0},
@@ -233,13 +239,14 @@
     {"debug",debugCommand,-2,"as",0,NULL,0,0,0,0,0},
     {"config",configCommand,-2,"ar",0,NULL,0,0,0,0,0},
     {"subscribe",subscribeCommand,-2,"rpslt",0,NULL,0,0,0,0,0},
     {"unsubscribe",unsubscribeCommand,-1,"rpslt",0,NULL,0,0,0,0,0},
     {"psubscribe",psubscribeCommand,-2,"rpslt",0,NULL,0,0,0,0,0},
     {"punsubscribe",punsubscribeCommand,-1,"rpslt",0,NULL,0,0,0,0,0},
-    {"publish",publishCommand,3,"pfltr",0,NULL,0,0,0,0,0},
+    {"publish",publishCommand,3,"pltr",0,NULL,0,0,0,0,0},
+    {"pubsub",pubsubCommand,-2,"pltrR",0,NULL,0,0,0,0,0},
     {"watch",watchCommand,-2,"rs",0,noPreloadGetKeys,1,-1,1,0,0},
     {"unwatch",unwatchCommand,1,"rs",0,NULL,0,0,0,0,0},
     {"restore",restoreCommand,4,"awm",0,NULL,1,1,1,0,0},
     {"migrate",migrateCommand,6,"aw",0,NULL,0,0,0,0,0},
     {"dump",dumpCommand,2,"ar",0,NULL,1,1,1,0,0},
     {"object",objectCommand,-2,"r",0,NULL,2,2,2,0,0},
@@ -260,17 +267,18 @@
 void redisLogRaw(int level, const char *msg) {
     const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };
     const char *c = ".-*#";
     FILE *fp;
     char buf[64];
     int rawmode = (level & REDIS_LOG_RAW);
+    int log_to_stdout = server.logfile[0] == '\0';
 
     level &= 0xff; /* clear flags */
     if (level < server.verbosity) return;
 
-    fp = (server.logfile == NULL) ? stdout : fopen(server.logfile,"a");
+    fp = log_to_stdout ? stdout : fopen(server.logfile,"a");
     if (!fp) return;
 
     if (rawmode) {
         fprintf(fp,"%s",msg);
     } else {
         int off;
@@ -280,14 +288,13 @@
         off = strftime(buf,sizeof(buf),"%d %b %H:%M:%S.",localtime(&tv.tv_sec));
         snprintf(buf+off,sizeof(buf)-off,"%03d",(int)tv.tv_usec/1000);
         fprintf(fp,"[%d] %s %c %s\n",(int)getpid(),buf,c[level],msg);
     }
     fflush(fp);
 
-    if (server.logfile) fclose(fp);
-
+    if (!log_to_stdout) fclose(fp);
     if (server.syslog_enabled) syslog(syslogLevelMap[level], "%s", msg);
 }
 
 /* Like redisLogRaw() but with printf-alike support. This is the function that
  * is used across the code. The raw version is only used in order to dump
  * the INFO output on crash. */
@@ -309,31 +316,31 @@
  *
  * We actually use this only for signals that are not fatal from the point
  * of view of Redis. Signals that are going to kill the server anyway and
  * where we need printf-alike features are served by redisLog(). */
 void redisLogFromHandler(int level, const char *msg) {
     int fd;
+    int log_to_stdout = server.logfile[0] == '\0';
     char buf[64];
 
-    if ((level&0xff) < server.verbosity ||
-        (server.logfile == NULL && server.daemonize)) return;
-    fd = server.logfile ?
-        open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644) :
-        STDOUT_FILENO;
+    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))
+        return;
+    fd = log_to_stdout ? STDOUT_FILENO :
+                         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
     if (fd == -1) return;
     ll2string(buf,sizeof(buf),getpid());
     if (write(fd,"[",1) == -1) goto err;
     if (write(fd,buf,strlen(buf)) == -1) goto err;
     if (write(fd," | signal handler] (",20) == -1) goto err;
     ll2string(buf,sizeof(buf),time(NULL));
     if (write(fd,buf,strlen(buf)) == -1) goto err;
     if (write(fd,") ",2) == -1) goto err;
     if (write(fd,msg,strlen(msg)) == -1) goto err;
     if (write(fd,"\n",1) == -1) goto err;
 err:
-    if (server.logfile) close(fd);
+    if (!log_to_stdout) close(fd);
 }
 
 /* Return the UNIX time in microseconds */
 long long ustime(void) {
     struct timeval tv;
     long long ust;
@@ -556,12 +563,24 @@
     NULL,                       /* val dup */
     dictObjKeyCompare,          /* key compare */
     dictRedisObjectDestructor,  /* key destructor */
     dictListDestructor          /* val destructor */
 };
 
+/* Replication cached script dict (server.repl_scriptcache_dict).
+ * Keys are sds SHA1 strings, while values are not used at all in the current
+ * implementation. */
+dictType replScriptCacheDictType = {
+    dictSdsCaseHash,            /* hash function */
+    NULL,                       /* key dup */
+    NULL,                       /* val dup */
+    dictSdsKeyCaseCompare,      /* key compare */
+    dictSdsDestructor,          /* key destructor */
+    NULL                        /* val destructor */
+};
+
 int htNeedsResize(dict *dict) {
     long long size, used;
 
     size = dictSlots(dict);
     used = dictSize(dict);
     return (size && used && size > DICT_HT_INITIAL_SIZE &&
@@ -629,12 +648,14 @@
     if (now > t) {
         sds key = dictGetKey(de);
         robj *keyobj = createStringObject(key,sdslen(key));
 
         propagateExpire(db,keyobj);
         dbDelete(db,keyobj);
+        notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,
+            "expired",keyobj,db->id);
         decrRefCount(keyobj);
         server.stat_expiredkeys++;
         return 1;
     } else {
         return 0;
     }
@@ -1013,13 +1034,13 @@
     }
 
     /* Show information about connected clients */
     if (!server.sentinel_mode) {
         run_with_period(5000) {
             redisLog(REDIS_VERBOSE,
-                "%d clients connected (%d slaves), %zu bytes in use",
+                "%lu clients connected (%lu slaves), %zu bytes in use",
                 listLength(server.clients)-listLength(server.slaves),
                 listLength(server.slaves),
                 zmalloc_used_memory());
         }
     }
 
@@ -1073,13 +1094,13 @@
                 server.unixtime-server.lastsave > sp->seconds &&
                 (server.unixtime-server.lastbgsave_try >
                  REDIS_BGSAVE_RETRY_DELAY ||
                  server.lastbgsave_status == REDIS_OK))
             {
                 redisLog(REDIS_NOTICE,"%d changes in %d seconds. Saving...",
-                    sp->changes, sp->seconds);
+                    sp->changes, (int)sp->seconds);
                 rdbSaveBackground(server.rdb_filename);
                 break;
             }
          }
 
          /* Trigger an AOF rewrite if needed */
@@ -1166,14 +1187,15 @@
     shared.cnegone = createObject(REDIS_STRING,sdsnew(":-1\r\n"));
     shared.nullbulk = createObject(REDIS_STRING,sdsnew("$-1\r\n"));
     shared.nullmultibulk = createObject(REDIS_STRING,sdsnew("*-1\r\n"));
     shared.emptymultibulk = createObject(REDIS_STRING,sdsnew("*0\r\n"));
     shared.pong = createObject(REDIS_STRING,sdsnew("+PONG\r\n"));
     shared.queued = createObject(REDIS_STRING,sdsnew("+QUEUED\r\n"));
+    shared.emptyscan = createObject(REDIS_STRING,sdsnew("*2\r\n$1\r\n0\r\n*0\r\n"));
     shared.wrongtypeerr = createObject(REDIS_STRING,sdsnew(
-        "-ERR Operation against a key holding the wrong kind of value\r\n"));
+        "-WRONGTYPE Operation against a key holding the wrong kind of value\r\n"));
     shared.nokeyerr = createObject(REDIS_STRING,sdsnew(
         "-ERR no such key\r\n"));
     shared.syntaxerr = createObject(REDIS_STRING,sdsnew(
         "-ERR syntax error\r\n"));
     shared.sameobjecterr = createObject(REDIS_STRING,sdsnew(
         "-ERR source and destination objects are the same\r\n"));
@@ -1188,23 +1210,33 @@
     shared.masterdownerr = createObject(REDIS_STRING,sdsnew(
         "-MASTERDOWN Link with MASTER is down and slave-serve-stale-data is set to 'no'.\r\n"));
     shared.bgsaveerr = createObject(REDIS_STRING,sdsnew(
         "-MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.\r\n"));
     shared.roslaveerr = createObject(REDIS_STRING,sdsnew(
         "-READONLY You can't write against a read only slave.\r\n"));
+    shared.noautherr = createObject(REDIS_STRING,sdsnew(
+        "-NOAUTH Authentication required.\r\n"));
     shared.oomerr = createObject(REDIS_STRING,sdsnew(
         "-OOM command not allowed when used memory > 'maxmemory'.\r\n"));
     shared.execaborterr = createObject(REDIS_STRING,sdsnew(
         "-EXECABORT Transaction discarded because of previous errors.\r\n"));
+    shared.noreplicaserr = createObject(REDIS_STRING,sdsnew(
+        "-NOREPLICAS Not enough good slaves to write.\r\n"));
     shared.space = createObject(REDIS_STRING,sdsnew(" "));
     shared.colon = createObject(REDIS_STRING,sdsnew(":"));
     shared.plus = createObject(REDIS_STRING,sdsnew("+"));
 
     for (j = 0; j < REDIS_SHARED_SELECT_CMDS; j++) {
+        char dictid_str[64];
+        int dictid_len;
+
+        dictid_len = ll2string(dictid_str,sizeof(dictid_str),j);
         shared.select[j] = createObject(REDIS_STRING,
-            sdscatprintf(sdsempty(),"select %d\r\n", j));
+            sdscatprintf(sdsempty(),
+                "*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n",
+                dictid_len, dictid_str));
     }
     shared.messagebulk = createStringObject("$7\r\nmessage\r\n",13);
     shared.pmessagebulk = createStringObject("$8\r\npmessage\r\n",14);
     shared.subscribebulk = createStringObject("$9\r\nsubscribe\r\n",15);
     shared.unsubscribebulk = createStringObject("$11\r\nunsubscribe\r\n",18);
     shared.psubscribebulk = createStringObject("$10\r\npsubscribe\r\n",17);
@@ -1223,108 +1255,120 @@
         shared.bulkhdr[j] = createObject(REDIS_STRING,
             sdscatprintf(sdsempty(),"$%d\r\n",j));
     }
 }
 
 void initServerConfig() {
+    int j;
+
     getRandomHexChars(server.runid,REDIS_RUN_ID_SIZE);
+    server.configfile = NULL;
     server.hz = REDIS_DEFAULT_HZ;
     server.runid[REDIS_RUN_ID_SIZE] = '\0';
     server.arch_bits = (sizeof(long) == 8) ? 64 : 32;
     server.port = REDIS_SERVERPORT;
-    server.bindaddr = NULL;
+    server.bindaddr_count = 0;
     server.unixsocket = NULL;
-    server.unixsocketperm = 0;
-    server.ipfd = -1;
+    server.unixsocketperm = REDIS_DEFAULT_UNIX_SOCKET_PERM;
+    server.ipfd_count = 0;
     server.sofd = -1;
     server.dbnum = REDIS_DEFAULT_DBNUM;
-    server.verbosity = REDIS_NOTICE;
+    server.verbosity = REDIS_DEFAULT_VERBOSITY;
     server.maxidletime = REDIS_MAXIDLETIME;
-    server.tcpkeepalive = 0;
+    server.tcpkeepalive = REDIS_DEFAULT_TCP_KEEPALIVE;
     server.active_expire_enabled = 1;
     server.client_max_querybuf_len = REDIS_MAX_QUERYBUF_LEN;
     server.saveparams = NULL;
     server.loading = 0;
-    server.logfile = NULL; /* NULL = log on standard output */
-    server.syslog_enabled = 0;
-    server.syslog_ident = zstrdup("redis");
+    server.logfile = zstrdup(REDIS_DEFAULT_LOGFILE);
+    server.syslog_enabled = REDIS_DEFAULT_SYSLOG_ENABLED;
+    server.syslog_ident = zstrdup(REDIS_DEFAULT_SYSLOG_IDENT);
     server.syslog_facility = LOG_LOCAL0;
-    server.daemonize = 0;
+    server.daemonize = REDIS_DEFAULT_DAEMONIZE;
     server.aof_state = REDIS_AOF_OFF;
-    server.aof_fsync = AOF_FSYNC_EVERYSEC;
-    server.aof_no_fsync_on_rewrite = 0;
+    server.aof_fsync = REDIS_DEFAULT_AOF_FSYNC;
+    server.aof_no_fsync_on_rewrite = REDIS_DEFAULT_AOF_NO_FSYNC_ON_REWRITE;
     server.aof_rewrite_perc = REDIS_AOF_REWRITE_PERC;
     server.aof_rewrite_min_size = REDIS_AOF_REWRITE_MIN_SIZE;
     server.aof_rewrite_base_size = 0;
     server.aof_rewrite_scheduled = 0;
     server.aof_last_fsync = time(NULL);
     server.aof_rewrite_time_last = -1;
     server.aof_rewrite_time_start = -1;
     server.aof_lastbgrewrite_status = REDIS_OK;
     server.aof_delayed_fsync = 0;
     server.aof_fd = -1;
     server.aof_selected_db = -1; /* Make sure the first time will not match */
     server.aof_flush_postponed_start = 0;
-    server.aof_rewrite_incremental_fsync = 1;
-    server.pidfile = zstrdup("/var/run/redis.pid");
-    server.rdb_filename = zstrdup("dump.rdb");
+    server.aof_rewrite_incremental_fsync = REDIS_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC;
+    server.pidfile = zstrdup(REDIS_DEFAULT_PID_FILE);
+    server.rdb_filename = zstrdup(REDIS_DEFAULT_RDB_FILENAME);
     server.aof_filename = zstrdup("appendonly.aof");
     server.requirepass = NULL;
-    server.rdb_compression = 1;
-    server.rdb_checksum = 1;
-    server.stop_writes_on_bgsave_err = 1;
-    server.activerehashing = 1;
+    server.rdb_compression = REDIS_DEFAULT_RDB_COMPRESSION;
+    server.rdb_checksum = REDIS_DEFAULT_RDB_CHECKSUM;
+    server.stop_writes_on_bgsave_err = REDIS_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR;
+    server.activerehashing = REDIS_DEFAULT_ACTIVE_REHASHING;
+    server.notify_keyspace_events = 0;
     server.maxclients = REDIS_MAX_CLIENTS;
     server.bpop_blocked_clients = 0;
-    server.maxmemory = 0;
-    server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU;
-    server.maxmemory_samples = 3;
+    server.maxmemory = REDIS_DEFAULT_MAXMEMORY;
+    server.maxmemory_policy = REDIS_DEFAULT_MAXMEMORY_POLICY;
+    server.maxmemory_samples = REDIS_DEFAULT_MAXMEMORY_SAMPLES;
     server.hash_max_ziplist_entries = REDIS_HASH_MAX_ZIPLIST_ENTRIES;
     server.hash_max_ziplist_value = REDIS_HASH_MAX_ZIPLIST_VALUE;
     server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES;
     server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE;
     server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES;
     server.zset_max_ziplist_entries = REDIS_ZSET_MAX_ZIPLIST_ENTRIES;
     server.zset_max_ziplist_value = REDIS_ZSET_MAX_ZIPLIST_VALUE;
     server.shutdown_asap = 0;
     server.repl_ping_slave_period = REDIS_REPL_PING_SLAVE_PERIOD;
     server.repl_timeout = REDIS_REPL_TIMEOUT;
+    server.repl_min_slaves_to_write = REDIS_DEFAULT_MIN_SLAVES_TO_WRITE;
+    server.repl_min_slaves_max_lag = REDIS_DEFAULT_MIN_SLAVES_MAX_LAG;
     server.lua_caller = NULL;
     server.lua_time_limit = REDIS_LUA_TIME_LIMIT;
     server.lua_client = NULL;
     server.lua_timedout = 0;
+    server.loading_process_events_interval_bytes = (1024*1024*2);
 
     updateLRUClock();
     resetServerSaveParams();
 
     appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */
     appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */
     appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */
     /* Replication related */
     server.masterauth = NULL;
     server.masterhost = NULL;
     server.masterport = 6379;
     server.master = NULL;
+    server.cached_master = NULL;
+    server.repl_master_initial_offset = -1;
     server.repl_state = REDIS_REPL_NONE;
     server.repl_syncio_timeout = REDIS_REPL_SYNCIO_TIMEOUT;
-    server.repl_serve_stale_data = 1;
-    server.repl_slave_ro = 1;
+    server.repl_serve_stale_data = REDIS_DEFAULT_SLAVE_SERVE_STALE_DATA;
+    server.repl_slave_ro = REDIS_DEFAULT_SLAVE_READ_ONLY;
     server.repl_down_since = 0; /* Never connected, repl is down since EVER. */
-    server.repl_disable_tcp_nodelay = 0;
+    server.repl_disable_tcp_nodelay = REDIS_DEFAULT_REPL_DISABLE_TCP_NODELAY;
     server.slave_priority = REDIS_DEFAULT_SLAVE_PRIORITY;
+    server.master_repl_offset = 0;
+
+    /* Replication partial resync backlog */
+    server.repl_backlog = NULL;
+    server.repl_backlog_size = REDIS_DEFAULT_REPL_BACKLOG_SIZE;
+    server.repl_backlog_histlen = 0;
+    server.repl_backlog_idx = 0;
+    server.repl_backlog_off = 0;
+    server.repl_backlog_time_limit = REDIS_DEFAULT_REPL_BACKLOG_TIME_LIMIT;
+    server.repl_no_slaves_since = time(NULL);
 
     /* Client output buffer limits */
-    server.client_obuf_limits[REDIS_CLIENT_LIMIT_CLASS_NORMAL].hard_limit_bytes = 0;
-    server.client_obuf_limits[REDIS_CLIENT_LIMIT_CLASS_NORMAL].soft_limit_bytes = 0;
-    server.client_obuf_limits[REDIS_CLIENT_LIMIT_CLASS_NORMAL].soft_limit_seconds = 0;
-    server.client_obuf_limits[REDIS_CLIENT_LIMIT_CLASS_SLAVE].hard_limit_bytes = 1024*1024*256;
-    server.client_obuf_limits[REDIS_CLIENT_LIMIT_CLASS_SLAVE].soft_limit_bytes = 1024*1024*64;
-    server.client_obuf_limits[REDIS_CLIENT_LIMIT_CLASS_SLAVE].soft_limit_seconds = 60;
-    server.client_obuf_limits[REDIS_CLIENT_LIMIT_CLASS_PUBSUB].hard_limit_bytes = 1024*1024*32;
-    server.client_obuf_limits[REDIS_CLIENT_LIMIT_CLASS_PUBSUB].soft_limit_bytes = 1024*1024*8;
-    server.client_obuf_limits[REDIS_CLIENT_LIMIT_CLASS_PUBSUB].soft_limit_seconds = 60;
+    for (j = 0; j < REDIS_CLIENT_LIMIT_NUM_CLASSES; j++)
+        server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];
 
     /* Double constants initialization */
     R_Zero = 0.0;
     R_PosInf = 1.0/R_Zero;
     R_NegInf = -1.0/R_Zero;
     R_Nan = R_Zero/R_Zero;
@@ -1394,12 +1438,67 @@
                     (int) maxfiles);
             }
         }
     }
 }
 
+/* Initialize a set of file descriptors to listen to the specified 'port'
+ * binding the addresses specified in the Redis server configuration.
+ *
+ * The listening file descriptors are stored in the integer array 'fds'
+ * and their number is set in '*count'.
+ *
+ * The addresses to bind are specified in the global server.bindaddr array
+ * and their number is server.bindaddr_count. If the server configuration
+ * contains no specific addresses to bind, this function will try to
+ * bind * (all addresses) for both the IPv4 and IPv6 protocols.
+ *
+ * On success the function returns REDIS_OK.
+ *
+ * On error the function returns REDIS_ERR. For the function to be on
+ * error, at least one of the server.bindaddr addresses was
+ * impossible to bind, or no bind addresses were specified in the server
+ * configuration but the function is not able to bind * for at least
+ * one of the IPv4 or IPv6 protocols. */
+int listenToPort(int port, int *fds, int *count) {
+    int j;
+
+    /* Force binding of 0.0.0.0 if no bind address is specified, always
+     * entering the loop if j == 0. */
+    if (server.bindaddr_count == 0) server.bindaddr[0] = NULL;
+    for (j = 0; j < server.bindaddr_count || j == 0; j++) {
+        if (server.bindaddr[j] == NULL) {
+            /* Bind * for both IPv6 and IPv4, we enter here only if
+             * server.bindaddr_count == 0. */
+            fds[*count] = anetTcp6Server(server.neterr,port,NULL);
+            if (fds[*count] != ANET_ERR) (*count)++;
+            fds[*count] = anetTcpServer(server.neterr,port,NULL);
+            if (fds[*count] != ANET_ERR) (*count)++;
+            /* Exit the loop if we were able to bind * on IPv4 or IPv6,
+             * otherwise fds[*count] will be ANET_ERR and we'll print an
+             * error and return to the caller with an error. */
+            if (*count) break;
+        } else if (strchr(server.bindaddr[j],':')) {
+            /* Bind IPv6 address. */
+            fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j]);
+        } else {
+            /* Bind IPv4 address. */
+            fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j]);
+        }
+        if (fds[*count] == ANET_ERR) {
+            redisLog(REDIS_WARNING,
+                "Creating Server TCP listening socket %s:%d: %s",
+                server.bindaddr[j] ? server.bindaddr[j] : "*",
+                server.port, server.neterr);
+            return REDIS_ERR;
+        }
+        (*count)++;
+    }
+    return REDIS_OK;
+}
+
 void initServer() {
     int j;
 
     signal(SIGHUP, SIG_IGN);
     signal(SIGPIPE, SIG_IGN);
     setupSignalHandlers();
@@ -1411,40 +1510,42 @@
 
     server.current_client = NULL;
     server.clients = listCreate();
     server.clients_to_close = listCreate();
     server.slaves = listCreate();
     server.monitors = listCreate();
+    server.slaveseldb = -1; /* Force to emit the first SELECT command. */
     server.unblocked_clients = listCreate();
     server.ready_keys = listCreate();
 
     createSharedObjects();
     adjustOpenFilesLimit();
-    server.el = aeCreateEventLoop(server.maxclients+1024);
+    server.el = aeCreateEventLoop(server.maxclients+REDIS_EVENTLOOP_FDSET_INCR);
     server.db = zmalloc(sizeof(redisDb)*server.dbnum);
 
-    if (server.port != 0) {
-        server.ipfd = anetTcpServer(server.neterr,server.port,server.bindaddr);
-        if (server.ipfd == ANET_ERR) {
-            redisLog(REDIS_WARNING, "Opening port %d: %s",
-                server.port, server.neterr);
-            exit(1);
-        }
-    }
+    /* Open the TCP listening socket for the user commands. */
+    if (listenToPort(server.port,server.ipfd,&server.ipfd_count) == REDIS_ERR)
+        exit(1);
+
+    /* Open the listening Unix domain socket. */
     if (server.unixsocket != NULL) {
         unlink(server.unixsocket); /* don't care if this fails */
         server.sofd = anetUnixServer(server.neterr,server.unixsocket,server.unixsocketperm);
         if (server.sofd == ANET_ERR) {
             redisLog(REDIS_WARNING, "Opening socket: %s", server.neterr);
             exit(1);
         }
     }
-    if (server.ipfd < 0 && server.sofd < 0) {
+
+    /* Abort if there are no listening sockets at all. */
+    if (server.ipfd_count == 0 && server.sofd < 0) {
         redisLog(REDIS_WARNING, "Configured to not listen anywhere, exiting.");
         exit(1);
     }
+
+    /* Create the Redis databases, and initialize other internal state. */
     for (j = 0; j < server.dbnum; j++) {
         server.db[j].dict = dictCreate(&dbDictType,NULL);
         server.db[j].expires = dictCreate(&keyptrDictType,NULL);
         server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);
         server.db[j].ready_keys = dictCreate(&setDictType,NULL);
         server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);
@@ -1472,28 +1573,45 @@
     server.stat_starttime = time(NULL);
     server.stat_keyspace_misses = 0;
     server.stat_keyspace_hits = 0;
     server.stat_peak_memory = 0;
     server.stat_fork_time = 0;
     server.stat_rejected_conn = 0;
+    server.stat_sync_full = 0;
+    server.stat_sync_partial_ok = 0;
+    server.stat_sync_partial_err = 0;
     memset(server.ops_sec_samples,0,sizeof(server.ops_sec_samples));
     server.ops_sec_idx = 0;
     server.ops_sec_last_sample_time = mstime();
     server.ops_sec_last_sample_ops = 0;
     server.unixtime = time(NULL);
     server.mstime = mstime();
     server.lastbgsave_status = REDIS_OK;
+    server.repl_good_slaves_count = 0;
+
+    /* Create the serverCron() time event, that's our main way to process
+     * background operations. */
     if(aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
-        redisPanic("create time event failed");
+        redisPanic("Can't create the serverCron time event.");
         exit(1);
     }
-    if (server.ipfd > 0 && aeCreateFileEvent(server.el,server.ipfd,AE_READABLE,
-        acceptTcpHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.ipfd file event.");
+
+    /* Create an event handler for accepting new connections in TCP and Unix
+     * domain sockets. */
+    for (j = 0; j < server.ipfd_count; j++) {
+        if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,
+            acceptTcpHandler,NULL) == AE_ERR)
+            {
+                redisPanic(
+                    "Unrecoverable error creating server.ipfd file event.");
+            }
+    }
     if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,
         acceptUnixHandler,NULL) == AE_ERR) redisPanic("Unrecoverable error creating server.sofd file event.");
 
+    /* Open the AOF file if needed. */
     if (server.aof_state == REDIS_AOF_ON) {
         server.aof_fd = open(server.aof_filename,
                                O_WRONLY|O_APPEND|O_CREAT,0644);
         if (server.aof_fd == -1) {
             redisLog(REDIS_WARNING, "Can't open the append-only file: %s",
                 strerror(errno));
@@ -1508,12 +1626,13 @@
     if (server.arch_bits == 32 && server.maxmemory == 0) {
         redisLog(REDIS_WARNING,"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.");
         server.maxmemory = 3072LL*(1024*1024); /* 3 GB */
         server.maxmemory_policy = REDIS_MAXMEMORY_NO_EVICTION;
     }
 
+    replicationScriptCacheInit();
     scriptingInit();
     slowlogInit();
     bioInit();
 }
 
 /* Populates the Redis Command Table starting from the hard coded list
@@ -1531,13 +1650,12 @@
             switch(*f) {
             case 'w': c->flags |= REDIS_CMD_WRITE; break;
             case 'r': c->flags |= REDIS_CMD_READONLY; break;
             case 'm': c->flags |= REDIS_CMD_DENYOOM; break;
             case 'a': c->flags |= REDIS_CMD_ADMIN; break;
             case 'p': c->flags |= REDIS_CMD_PUBSUB; break;
-            case 'f': c->flags |= REDIS_CMD_FORCE_REPLICATION; break;
             case 's': c->flags |= REDIS_CMD_NOSCRIPT; break;
             case 'R': c->flags |= REDIS_CMD_RANDOM; break;
             case 'S': c->flags |= REDIS_CMD_SORT_FOR_SCRIPT; break;
             case 'l': c->flags |= REDIS_CMD_LOADING; break;
             case 't': c->flags |= REDIS_CMD_STALE; break;
             case 'M': c->flags |= REDIS_CMD_SKIP_MONITOR; break;
@@ -1642,49 +1760,69 @@
  */
 void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
                int flags)
 {
     if (server.aof_state != REDIS_AOF_OFF && flags & REDIS_PROPAGATE_AOF)
         feedAppendOnlyFile(cmd,dbid,argv,argc);
-    if (flags & REDIS_PROPAGATE_REPL && listLength(server.slaves))
+    if (flags & REDIS_PROPAGATE_REPL)
         replicationFeedSlaves(server.slaves,dbid,argv,argc);
 }
 
 /* Used inside commands to schedule the propagation of additional commands
  * after the current command is propagated to AOF / Replication. */
 void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
                    int target)
 {
     redisOpArrayAppend(&server.also_propagate,cmd,dbid,argv,argc,target);
 }
 
+/* It is possible to call the function forceCommandPropagation() inside a
+ * Redis command implementaiton in order to to force the propagation of a
+ * specific command execution into AOF / Replication. */
+void forceCommandPropagation(redisClient *c, int flags) {
+    if (flags & REDIS_PROPAGATE_REPL) c->flags |= REDIS_FORCE_REPL;
+    if (flags & REDIS_PROPAGATE_AOF) c->flags |= REDIS_FORCE_AOF;
+}
+
 /* Call() is the core of Redis execution of a command */
 void call(redisClient *c, int flags) {
     long long dirty, start = ustime(), duration;
+    int client_old_flags = c->flags;
 
     /* Sent the command to clients in MONITOR mode, only if the commands are
      * not generated from reading an AOF. */
     if (listLength(server.monitors) &&
         !server.loading &&
         !(c->cmd->flags & REDIS_CMD_SKIP_MONITOR))
     {
         replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
     }
 
     /* Call the command. */
+    c->flags &= ~(REDIS_FORCE_AOF|REDIS_FORCE_REPL);
     redisOpArrayInit(&server.also_propagate);
     dirty = server.dirty;
     c->cmd->proc(c);
     dirty = server.dirty-dirty;
     duration = ustime()-start;
 
     /* When EVAL is called loading the AOF we don't want commands called
      * from Lua to go into the slowlog or to populate statistics. */
     if (server.loading && c->flags & REDIS_LUA_CLIENT)
         flags &= ~(REDIS_CALL_SLOWLOG | REDIS_CALL_STATS);
 
+    /* If the caller is Lua, we want to force the EVAL caller to propagate
+     * the script if the command flag or client flag are forcing the
+     * propagation. */
+    if (c->flags & REDIS_LUA_CLIENT && server.lua_caller) {
+        if (c->flags & REDIS_FORCE_REPL)
+            server.lua_caller->flags |= REDIS_FORCE_REPL;
+        if (c->flags & REDIS_FORCE_AOF)
+            server.lua_caller->flags |= REDIS_FORCE_AOF;
+    }
+
     /* Log the command into the Slow log if needed, and populate the
      * per-command statistics that we show in INFO commandstats. */
     if (flags & REDIS_CALL_SLOWLOG && c->cmd->proc != execCommand)
         slowlogPushEntryIfNeeded(c->argv,c->argc,duration);
     if (flags & REDIS_CALL_STATS) {
         c->cmd->microseconds += duration;
@@ -1692,20 +1830,25 @@
     }
 
     /* Propagate the command into the AOF and replication link */
     if (flags & REDIS_CALL_PROPAGATE) {
         int flags = REDIS_PROPAGATE_NONE;
 
-        if (c->cmd->flags & REDIS_CMD_FORCE_REPLICATION)
-            flags |= REDIS_PROPAGATE_REPL;
+        if (c->flags & REDIS_FORCE_REPL) flags |= REDIS_PROPAGATE_REPL;
+        if (c->flags & REDIS_FORCE_AOF) flags |= REDIS_PROPAGATE_AOF;
         if (dirty)
             flags |= (REDIS_PROPAGATE_REPL | REDIS_PROPAGATE_AOF);
         if (flags != REDIS_PROPAGATE_NONE)
             propagate(c->cmd,c->db->id,c->argv,c->argc,flags);
     }
 
+    /* Restore the old FORCE_AOF/REPL flags, since call can be executed
+     * recursively. */
+    c->flags &= ~(REDIS_FORCE_AOF|REDIS_FORCE_REPL);
+    c->flags |= client_old_flags & (REDIS_FORCE_AOF|REDIS_FORCE_REPL);
+
     /* Handle the alsoPropagate() API to handle commands that want to propagate
      * multiple separated commands. */
     if (server.also_propagate.numops) {
         int j;
         redisOp *rop;
 
@@ -1754,13 +1897,13 @@
     }
 
     /* Check if the user is authenticated */
     if (server.requirepass && !c->authenticated && c->cmd->proc != authCommand)
     {
         flagTransaction(c);
-        addReplyError(c,"operation not permitted");
+        addReply(c,shared.noautherr);
         return REDIS_OK;
     }
 
     /* Handle the maxmemory directive.
      *
      * First we try to free some memory if possible (if there are volatile
@@ -1783,12 +1926,24 @@
     {
         flagTransaction(c);
         addReply(c, shared.bgsaveerr);
         return REDIS_OK;
     }
 
+    /* Don't accept write commands if there are not enough good slaves and
+     * used configured the min-slaves-to-write option. */
+    if (server.repl_min_slaves_to_write &&
+        server.repl_min_slaves_max_lag &&
+        c->cmd->flags & REDIS_CMD_WRITE &&
+        server.repl_good_slaves_count < server.repl_min_slaves_to_write)
+    {
+        flagTransaction(c);
+        addReply(c, shared.noreplicaserr);
+        return REDIS_OK;
+    }
+
     /* Don't accept write commands if this is a read only slave. But
      * accept write commands if this is our master. */
     if (server.masterhost && server.repl_slave_ro &&
         !(c->flags & REDIS_MASTER) &&
         c->cmd->flags & REDIS_CMD_WRITE)
     {
@@ -1822,15 +1977,16 @@
      * REDIS_CMD_LOADING flag. */
     if (server.loading && !(c->cmd->flags & REDIS_CMD_LOADING)) {
         addReply(c, shared.loadingerr);
         return REDIS_OK;
     }
 
-    /* Lua script too slow? Only allow commands with REDIS_CMD_STALE flag. */
+    /* Lua script too slow? Only allow a limited number of commands. */
     if (server.lua_timedout &&
           c->cmd->proc != authCommand &&
+          c->cmd->proc != replconfCommand &&
         !(c->cmd->proc == shutdownCommand &&
           c->argc == 2 &&
           tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&
         !(c->cmd->proc == scriptCommand &&
           c->argc == 2 &&
           tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))
@@ -1854,12 +2010,25 @@
     }
     return REDIS_OK;
 }
 
 /*================================== Shutdown =============================== */
 
+/* Close listening sockets. Also unlink the unix domain socket if
+ * unlink_unix_socket is non-zero. */
+void closeListeningSockets(int unlink_unix_socket) {
+    int j;
+
+    for (j = 0; j < server.ipfd_count; j++) close(server.ipfd[j]);
+    if (server.sofd != -1) close(server.sofd);
+    if (unlink_unix_socket && server.unixsocket) {
+        redisLog(REDIS_NOTICE,"Removing the unix socket file.");
+        unlink(server.unixsocket); /* don't care if this fails */
+    }
+}
+
 int prepareForShutdown(int flags) {
     int save = flags & REDIS_SHUTDOWN_SAVE;
     int nosave = flags & REDIS_SHUTDOWN_NOSAVE;
 
     redisLog(REDIS_WARNING,"User requested shutdown...");
     /* Kill the saving child if there is a background saving in progress.
@@ -1897,19 +2066,13 @@
     }
     if (server.daemonize) {
         redisLog(REDIS_NOTICE,"Removing the pid file.");
         unlink(server.pidfile);
     }
     /* Close the listening sockets. Apparently this allows faster restarts. */
-    if (server.ipfd != -1) close(server.ipfd);
-    if (server.sofd != -1) close(server.sofd);
-    if (server.unixsocket) {
-        redisLog(REDIS_NOTICE,"Removing the unix socket file.");
-        unlink(server.unixsocket); /* don't care if this fails */
-    }
-
+    closeListeningSockets(1);
     redisLog(REDIS_WARNING,"Redis is now ready to exit, bye bye...");
     return REDIS_OK;
 }
 
 /*================================== Commands =============================== */
 
@@ -2040,43 +2203,47 @@
         uname(&name);
         info = sdscatprintf(info,
             "# Server\r\n"
             "redis_version:%s\r\n"
             "redis_git_sha1:%s\r\n"
             "redis_git_dirty:%d\r\n"
+            "redis_build_id:%llx\r\n"
             "redis_mode:%s\r\n"
             "os:%s %s %s\r\n"
             "arch_bits:%d\r\n"
             "multiplexing_api:%s\r\n"
             "gcc_version:%d.%d.%d\r\n"
             "process_id:%ld\r\n"
             "run_id:%s\r\n"
             "tcp_port:%d\r\n"
-            "uptime_in_seconds:%ld\r\n"
-            "uptime_in_days:%ld\r\n"
+            "uptime_in_seconds:%jd\r\n"
+            "uptime_in_days:%jd\r\n"
             "hz:%d\r\n"
-            "lru_clock:%ld\r\n",
+            "lru_clock:%ld\r\n"
+            "config_file:%s\r\n",
             REDIS_VERSION,
             redisGitSHA1(),
             strtol(redisGitDirty(),NULL,10) > 0,
+            (unsigned long long) redisBuildId(),
             mode,
             name.sysname, name.release, name.machine,
             server.arch_bits,
             aeGetApiName(),
 #ifdef __GNUC__
             __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,
 #else
             0,0,0,
 #endif
             (long) getpid(),
             server.runid,
             server.port,
-            uptime,
-            uptime/(3600*24),
+            (intmax_t)uptime,
+            (intmax_t)(uptime/(3600*24)),
             server.hz,
-            (unsigned long) server.lruclock);
+            (unsigned long) server.lruclock,
+            server.configfile ? server.configfile : "");
     }
 
     /* Clients */
     if (allsections || defsections || !strcasecmp(section,"clients")) {
         if (sections++) info = sdscat(info,"\r\n");
         info = sdscatprintf(info,
@@ -2124,36 +2291,36 @@
         if (sections++) info = sdscat(info,"\r\n");
         info = sdscatprintf(info,
             "# Persistence\r\n"
             "loading:%d\r\n"
             "rdb_changes_since_last_save:%lld\r\n"
             "rdb_bgsave_in_progress:%d\r\n"
-            "rdb_last_save_time:%ld\r\n"
+            "rdb_last_save_time:%jd\r\n"
             "rdb_last_bgsave_status:%s\r\n"
-            "rdb_last_bgsave_time_sec:%ld\r\n"
-            "rdb_current_bgsave_time_sec:%ld\r\n"
+            "rdb_last_bgsave_time_sec:%jd\r\n"
+            "rdb_current_bgsave_time_sec:%jd\r\n"
             "aof_enabled:%d\r\n"
             "aof_rewrite_in_progress:%d\r\n"
             "aof_rewrite_scheduled:%d\r\n"
-            "aof_last_rewrite_time_sec:%ld\r\n"
-            "aof_current_rewrite_time_sec:%ld\r\n"
+            "aof_last_rewrite_time_sec:%jd\r\n"
+            "aof_current_rewrite_time_sec:%jd\r\n"
             "aof_last_bgrewrite_status:%s\r\n",
             server.loading,
             server.dirty,
             server.rdb_child_pid != -1,
-            server.lastsave,
+            (intmax_t)server.lastsave,
             (server.lastbgsave_status == REDIS_OK) ? "ok" : "err",
-            server.rdb_save_time_last,
-            (server.rdb_child_pid == -1) ?
-                -1 : time(NULL)-server.rdb_save_time_start,
+            (intmax_t)server.rdb_save_time_last,
+            (intmax_t)((server.rdb_child_pid == -1) ?
+                -1 : time(NULL)-server.rdb_save_time_start),
             server.aof_state != REDIS_AOF_OFF,
             server.aof_child_pid != -1,
             server.aof_rewrite_scheduled,
-            server.aof_rewrite_time_last,
-            (server.aof_child_pid == -1) ?
-                -1 : time(NULL)-server.aof_rewrite_time_start,
+            (intmax_t)server.aof_rewrite_time_last,
+            (intmax_t)((server.aof_child_pid == -1) ?
+                -1 : time(NULL)-server.aof_rewrite_time_start),
             (server.aof_lastbgrewrite_status == REDIS_OK) ? "ok" : "err");
 
         if (server.aof_state != REDIS_AOF_OFF) {
             info = sdscatprintf(info,
                 "aof_current_size:%lld\r\n"
                 "aof_base_size:%lld\r\n"
@@ -2186,22 +2353,22 @@
                             enough info */
             } else {
                 eta = (elapsed*remaining_bytes)/server.loading_loaded_bytes;
             }
 
             info = sdscatprintf(info,
-                "loading_start_time:%ld\r\n"
+                "loading_start_time:%jd\r\n"
                 "loading_total_bytes:%llu\r\n"
                 "loading_loaded_bytes:%llu\r\n"
                 "loading_loaded_perc:%.2f\r\n"
-                "loading_eta_seconds:%ld\r\n"
-                ,(unsigned long) server.loading_start_time,
+                "loading_eta_seconds:%jd\r\n",
+                (intmax_t) server.loading_start_time,
                 (unsigned long long) server.loading_total_bytes,
                 (unsigned long long) server.loading_loaded_bytes,
                 perc,
-                eta
+                (intmax_t)eta
             );
         }
     }
 
     /* Stats */
     if (allsections || defsections || !strcasecmp(section,"stats")) {
@@ -2209,23 +2376,29 @@
         info = sdscatprintf(info,
             "# Stats\r\n"
             "total_connections_received:%lld\r\n"
             "total_commands_processed:%lld\r\n"
             "instantaneous_ops_per_sec:%lld\r\n"
             "rejected_connections:%lld\r\n"
+            "sync_full:%lld\r\n"
+            "sync_partial_ok:%lld\r\n"
+            "sync_partial_err:%lld\r\n"
             "expired_keys:%lld\r\n"
             "evicted_keys:%lld\r\n"
             "keyspace_hits:%lld\r\n"
             "keyspace_misses:%lld\r\n"
             "pubsub_channels:%ld\r\n"
             "pubsub_patterns:%lu\r\n"
             "latest_fork_usec:%lld\r\n",
             server.stat_numconnections,
             server.stat_numcommands,
             getOperationsPerSecond(),
             server.stat_rejected_conn,
+            server.stat_sync_full,
+            server.stat_sync_partial_ok,
+            server.stat_sync_partial_err,
             server.stat_expiredkeys,
             server.stat_evictedkeys,
             server.stat_keyspace_hits,
             server.stat_keyspace_misses,
             dictSize(server.pubsub_channels),
             listLength(server.pubsub_patterns),
@@ -2243,19 +2416,21 @@
             info = sdscatprintf(info,
                 "master_host:%s\r\n"
                 "master_port:%d\r\n"
                 "master_link_status:%s\r\n"
                 "master_last_io_seconds_ago:%d\r\n"
                 "master_sync_in_progress:%d\r\n"
+                "slave_repl_offset:%lld\r\n"
                 ,server.masterhost,
                 server.masterport,
                 (server.repl_state == REDIS_REPL_CONNECTED) ?
                     "up" : "down",
                 server.master ?
                 ((int)(server.unixtime-server.master->lastinteraction)) : -1,
-                server.repl_state == REDIS_REPL_TRANSFER
+                server.repl_state == REDIS_REPL_TRANSFER,
+                server.master ? server.master->reploff : -1
             );
 
             if (server.repl_state == REDIS_REPL_TRANSFER) {
                 info = sdscatprintf(info,
                     "master_sync_left_bytes:%lld\r\n"
                     "master_sync_last_io_seconds_ago:%d\r\n"
@@ -2264,14 +2439,14 @@
                     (int)(server.unixtime-server.repl_transfer_lastio)
                 );
             }
 
             if (server.repl_state != REDIS_REPL_CONNECTED) {
                 info = sdscatprintf(info,
-                    "master_link_down_since_seconds:%ld\r\n",
-                    (long)server.unixtime-server.repl_down_since);
+                    "master_link_down_since_seconds:%jd\r\n",
+                    (intmax_t)server.unixtime-server.repl_down_since);
             }
             info = sdscatprintf(info,
                 "slave_priority:%d\r\n"
                 "slave_read_only:%d\r\n",
                 server.slave_priority,
                 server.repl_slave_ro);
@@ -2273,28 +2448,40 @@
             info = sdscatprintf(info,
                 "slave_priority:%d\r\n"
                 "slave_read_only:%d\r\n",
                 server.slave_priority,
                 server.repl_slave_ro);
         }
+
         info = sdscatprintf(info,
             "connected_slaves:%lu\r\n",
             listLength(server.slaves));
+
+        /* If min-slaves-to-write is active, write the number of slaves
+         * currently considered 'good'. */
+        if (server.repl_min_slaves_to_write &&
+            server.repl_min_slaves_max_lag) {
+            info = sdscatprintf(info,
+                "min_slaves_good_slaves:%d\r\n",
+                server.repl_good_slaves_count);
+        }
+
         if (listLength(server.slaves)) {
             int slaveid = 0;
             listNode *ln;
             listIter li;
 
             listRewind(server.slaves,&li);
             while((ln = listNext(&li))) {
                 redisClient *slave = listNodeValue(ln);
                 char *state = NULL;
-                char ip[32];
+                char ip[REDIS_IP_STR_LEN];
                 int port;
+                long lag = 0;
 
-                if (anetPeerToString(slave->fd,ip,&port) == -1) continue;
+                if (anetPeerToString(slave->fd,ip,sizeof(ip),&port) == -1) continue;
                 switch(slave->replstate) {
                 case REDIS_REPL_WAIT_BGSAVE_START:
                 case REDIS_REPL_WAIT_BGSAVE_END:
                     state = "wait_bgsave";
                     break;
                 case REDIS_REPL_SEND_BULK:
@@ -2302,17 +2489,34 @@
                     break;
                 case REDIS_REPL_ONLINE:
                     state = "online";
                     break;
                 }
                 if (state == NULL) continue;
-                info = sdscatprintf(info,"slave%d:%s,%d,%s\r\n",
-                    slaveid,ip,slave->slave_listening_port,state);
+                if (slave->replstate == REDIS_REPL_ONLINE)
+                    lag = time(NULL) - slave->repl_ack_time;
+
+                info = sdscatprintf(info,
+                    "slave%d:ip=%s,port=%d,state=%s,"
+                    "offset=%lld,lag=%ld\r\n",
+                    slaveid,ip,slave->slave_listening_port,state,
+                    slave->repl_ack_off, lag);
                 slaveid++;
             }
         }
+        info = sdscatprintf(info,
+            "master_repl_offset:%lld\r\n"
+            "repl_backlog_active:%d\r\n"
+            "repl_backlog_size:%lld\r\n"
+            "repl_backlog_first_byte_offset:%lld\r\n"
+            "repl_backlog_histlen:%lld\r\n",
+            server.master_repl_offset,
+            server.repl_backlog != NULL,
+            server.repl_backlog_size,
+            server.repl_backlog_off,
+            server.repl_backlog_histlen);
     }
 
     /* CPU */
     if (allsections || defsections || !strcasecmp(section,"cpu")) {
         if (sections++) info = sdscat(info,"\r\n");
         info = sdscatprintf(info,
@@ -2378,13 +2582,12 @@
 
 void monitorCommand(redisClient *c) {
     /* ignore MONITOR if already slave or in monitor mode */
     if (c->flags & REDIS_SLAVE) return;
 
     c->flags |= (REDIS_SLAVE|REDIS_MONITOR);
-    c->slaveseldb = 0;
     listAddNodeTail(server.monitors,c);
     addReply(c,shared.ok);
 }
 
 /* ============================ Maxmemory directive  ======================== */
 
@@ -2526,12 +2729,14 @@
                  * we only care about memory used by the key space. */
                 delta = (long long) zmalloc_used_memory();
                 dbDelete(db,keyobj);
                 delta -= (long long) zmalloc_used_memory();
                 mem_freed += delta;
                 server.stat_evictedkeys++;
+                notifyKeyspaceEvent(REDIS_NOTIFY_EVICTED, "evicted",
+                    keyobj, db->id);
                 decrRefCount(keyobj);
                 keys_freed++;
 
                 /* When the memory to free starts to be big enough, we may
                  * start spending so much time here that is impossible to
                  * deliver data to the slaves fast enough, so we force the
@@ -2592,18 +2797,19 @@
         dup2(fd, STDERR_FILENO);
         if (fd > STDERR_FILENO) close(fd);
     }
 }
 
 void version() {
-    printf("Redis server v=%s sha=%s:%d malloc=%s bits=%d\n",
+    printf("Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\n",
         REDIS_VERSION,
         redisGitSHA1(),
         atoi(redisGitDirty()) > 0,
         ZMALLOC_LIB,
-        sizeof(long) == 4 ? 32 : 64);
+        sizeof(long) == 4 ? 32 : 64,
+        (unsigned long long) redisBuildId());
     exit(0);
 }
 
 void usage() {
     fprintf(stderr,"Usage: ./redis-server [/path/to/redis.conf] [options]\n");
     fprintf(stderr,"       ./redis-server - (read config from stdin)\n");
@@ -2702,16 +2908,31 @@
 void redisOutOfMemoryHandler(size_t allocation_size) {
     redisLog(REDIS_WARNING,"Out Of Memory allocating %zu bytes!",
         allocation_size);
     redisPanic("Redis aborting for OUT OF MEMORY");
 }
 
+void redisSetProcTitle(char *title) {
+#ifdef USE_SETPROCTITLE
+    setproctitle("%s %s:%d",
+        title,
+        server.bindaddr_count ? server.bindaddr[0] : "*",
+        server.port);
+#else
+    REDIS_NOTUSED(title);
+#endif
+}
+
 int main(int argc, char **argv) {
     struct timeval tv;
 
     /* We need to initialize our libraries, and the server configuration. */
+#ifdef INIT_SETPROCTITLE_REPLACEMENT
+    spt_init(argc, argv);
+#endif
+    setlocale(LC_COLLATE,"");
     zmalloc_enable_thread_safeness();
     zmalloc_set_oom_handler(redisOutOfMemoryHandler);
     srand(time(NULL)^getpid());
     gettimeofday(&tv,NULL);
     dictSetHashFunctionSeed(tv.tv_sec^tv.tv_usec^getpid());
     server.sentinel_mode = checkForSentinelMode(argc,argv);
@@ -2766,31 +2987,35 @@
             }
             j++;
         }
         resetServerSaveParams();
         loadServerConfig(configfile,options);
         sdsfree(options);
+        if (configfile) server.configfile = getAbsolutePath(configfile);
     } else {
         redisLog(REDIS_WARNING, "Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf", argv[0], server.sentinel_mode ? "sentinel" : "redis");
     }
     if (server.daemonize) daemonize();
     initServer();
     if (server.daemonize) createPidFile();
+    redisSetProcTitle(argv[0]);
     redisAsciiArt();
 
     if (!server.sentinel_mode) {
-        /* Things only needed when not running in Sentinel mode. */
+        /* Things not needed when running in Sentinel mode. */
         redisLog(REDIS_WARNING,"Server started, Redis version " REDIS_VERSION);
     #ifdef __linux__
         linuxOvercommitMemoryWarning();
     #endif
         loadDataFromDisk();
-        if (server.ipfd > 0)
+        if (server.ipfd_count > 0)
             redisLog(REDIS_NOTICE,"The server is now ready to accept connections on port %d", server.port);
         if (server.sofd > 0)
             redisLog(REDIS_NOTICE,"The server is now ready to accept connections at %s", server.unixsocket);
+    } else {
+        sentinelIsRunning();
     }
 
     /* Warning the user about suspicious maxmemory setting. */
     if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {
         redisLog(REDIS_WARNING,"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?", server.maxmemory);
     }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-aof and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-aof differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-aof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-aof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-aof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-aof.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump.c	2013-11-22 17:25:29.000000000 +0800
@@ -37,12 +37,13 @@
 #include <sys/mman.h>
 #include <string.h>
 #include <arpa/inet.h>
 #include <stdint.h>
 #include <limits.h>
 #include "lzf.h"
+#include "crc64.h"
 
 /* Object types */
 #define REDIS_STRING 0
 #define REDIS_LIST 1
 #define REDIS_SET 2
 #define REDIS_ZSET 3
@@ -137,15 +138,12 @@
  * at runtime to avoid strange compiler optimizations. */
 static double R_Zero, R_PosInf, R_NegInf, R_Nan;
 
 /* store string types for output */
 static char types[256][16];
 
-/* Prototypes */
-uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);
-
 /* Return true if 't' is a valid object type. */
 int checkType(unsigned char t) {
     /* In case a new object type is added, update the following 
      * condition as necessary. */
     return
         (t >= REDIS_HASH_ZIPMAP && t <= REDIS_HASH_ZIPLIST) ||
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-check-dump.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-check-dump.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli.c	2013-11-22 17:25:29.000000000 +0800
@@ -55,12 +55,13 @@
 #define REDIS_NOTUSED(V) ((void) V)
 
 #define OUTPUT_STANDARD 0
 #define OUTPUT_RAW 1
 #define OUTPUT_CSV 2
 #define REDIS_CLI_KEEPALIVE_INTERVAL 15 /* seconds */
+#define REDIS_DEFAULT_PIPE_TIMEOUT 30 /* seconds */
 
 static redisContext *context;
 static struct config {
     char *hostip;
     int hostport;
     char *hostsocket;
@@ -74,12 +75,13 @@
     int latency_mode;
     int latency_history;
     int cluster_mode;
     int cluster_reissue_command;
     int slave_mode;
     int pipe_mode;
+    int pipe_timeout;
     int getrdb_mode;
     int stat_mode;
     char *rdb_filename;
     int bigkeys;
     int stdinarg; /* get last arg from stdin. (-x option) */
     char *auth;
@@ -111,13 +113,14 @@
     int len;
 
     if (config.hostsocket != NULL)
         len = snprintf(config.prompt,sizeof(config.prompt),"redis %s",
                        config.hostsocket);
     else
-        len = snprintf(config.prompt,sizeof(config.prompt),"redis %s:%d",
+        len = snprintf(config.prompt,sizeof(config.prompt),
+                       strchr(config.hostip,':') ? "[%s]:%d" : "%s:%d",
                        config.hostip, config.hostport);
     /* Add [dbnum] if needed */
     if (config.dbnum != 0)
         len += snprintf(config.prompt+len,sizeof(config.prompt)-len,"[%d]",
             config.dbnum);
     snprintf(config.prompt+len,sizeof(config.prompt)-len,"> ");
@@ -710,12 +713,14 @@
             config.stat_mode = 1;
         } else if (!strcmp(argv[i],"--rdb") && !lastarg) {
             config.getrdb_mode = 1;
             config.rdb_filename = argv[++i];
         } else if (!strcmp(argv[i],"--pipe")) {
             config.pipe_mode = 1;
+        } else if (!strcmp(argv[i],"--pipe-timeout") && !lastarg) {
+            config.pipe_timeout = atoi(argv[++i]);
         } else if (!strcmp(argv[i],"--bigkeys")) {
             config.bigkeys = 1;
         } else if (!strcmp(argv[i],"--eval") && !lastarg) {
             config.eval = argv[++i];
         } else if (!strcmp(argv[i],"-c")) {
             config.cluster_mode = 1;
@@ -762,48 +767,52 @@
 static void usage() {
     sds version = cliVersion();
     fprintf(stderr,
 "redis-cli %s\n"
 "\n"
 "Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\n"
-"  -h <hostname>     Server hostname (default: 127.0.0.1)\n"
-"  -p <port>         Server port (default: 6379)\n"
-"  -s <socket>       Server socket (overrides hostname and port)\n"
-"  -a <password>     Password to use when connecting to the server\n"
-"  -r <repeat>       Execute specified command N times\n"
-"  -i <interval>     When -r is used, waits <interval> seconds per command.\n"
-"                    It is possible to specify sub-second times like -i 0.1\n"
-"  -n <db>           Database number\n"
-"  -x                Read last argument from STDIN\n"
-"  -d <delimiter>    Multi-bulk delimiter in for raw formatting (default: \\n)\n"
-"  -c                Enable cluster mode (follow -ASK and -MOVED redirections)\n"
-"  --raw             Use raw formatting for replies (default when STDOUT is\n"
-"                    not a tty)\n"
-"  --latency         Enter a special mode continuously sampling latency\n"
-"  --latency-history Like --latency but tracking latency changes over time.\n"
-"                    Default time interval is 15 sec. Change it using -i.\n"
-"  --slave           Simulate a slave showing commands received from the master\n"
-"  --rdb <filename>  Transfer an RDB dump from remote server to local file.\n"
-"  --pipe            Transfer raw Redis protocol from stdin to server\n"
-"  --bigkeys         Sample Redis keys looking for big keys\n"
-"  --eval <file>     Send an EVAL command using the Lua script at <file>\n"
-"  --help            Output this help and exit\n"
-"  --version         Output version and exit\n"
+"  -h <hostname>      Server hostname (default: 127.0.0.1)\n"
+"  -p <port>          Server port (default: 6379)\n"
+"  -s <socket>        Server socket (overrides hostname and port)\n"
+"  -a <password>      Password to use when connecting to the server\n"
+"  -r <repeat>        Execute specified command N times\n"
+"  -i <interval>      When -r is used, waits <interval> seconds per command.\n"
+"                     It is possible to specify sub-second times like -i 0.1\n"
+"  -n <db>            Database number\n"
+"  -x                 Read last argument from STDIN\n"
+"  -d <delimiter>     Multi-bulk delimiter in for raw formatting (default: \\n)\n"
+"  -c                 Enable cluster mode (follow -ASK and -MOVED redirections)\n"
+"  --raw              Use raw formatting for replies (default when STDOUT is\n"
+"                     not a tty)\n"
+"  --csv              Output in CSV format\n"
+"  --latency          Enter a special mode continuously sampling latency\n"
+"  --latency-history  Like --latency but tracking latency changes over time.\n"
+"                     Default time interval is 15 sec. Change it using -i.\n"
+"  --slave            Simulate a slave showing commands received from the master\n"
+"  --rdb <filename>   Transfer an RDB dump from remote server to local file.\n"
+"  --pipe             Transfer raw Redis protocol from stdin to server\n"
+"  --pipe-timeout <n> In --pipe mode, abort with error if after sending all data\n"
+"                     no reply is received within <n> seconds.\n"
+"                     Default timeout: %d. Use 0 to wait forever.\n"
+"  --bigkeys          Sample Redis keys looking for big keys\n"
+"  --eval <file>      Send an EVAL command using the Lua script at <file>\n"
+"  --help             Output this help and exit\n"
+"  --version          Output version and exit\n"
 "\n"
 "Examples:\n"
 "  cat /etc/passwd | redis-cli -x set mypasswd\n"
 "  redis-cli get mypasswd\n"
 "  redis-cli -r 100 lpush mylist x\n"
 "  redis-cli -r 100 -i 1 info | grep used_memory_human:\n"
 "  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\n"
 "  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\n"
 "\n"
 "When no command is given, redis-cli starts in interactive mode.\n"
 "Type \"help\" in interactive mode for information on available commands.\n"
 "\n",
-        version);
+        version, REDIS_DEFAULT_PIPE_TIMEOUT);
     sdsfree(version);
     exit(1);
 }
 
 /* Turn the plain C strings into Sds strings */
 static char **convertToSds(int count, char** args) {
@@ -1115,12 +1124,13 @@
     char aneterr[ANET_ERR_LEN];
     redisReader *reader = redisReaderCreate();
     redisReply *reply;
     int eof = 0; /* True once we consumed all the standard input. */
     int done = 0;
     char magic[20]; /* Special reply we recognize. */
+    time_t last_read_time = time(NULL);
 
     srand(time(NULL));
 
     /* Use non blocking I/O. */
     if (anetNonBlock(aneterr,fd) == ANET_ERR) {
         fprintf(stderr, "Can't set the socket in non blocking mode: %s\n",
@@ -1145,13 +1155,16 @@
                 nread = read(fd,ibuf,sizeof(ibuf));
                 if (nread == -1 && errno != EAGAIN && errno != EINTR) {
                     fprintf(stderr, "Error reading from the server: %s\n",
                         strerror(errno));
                     exit(1);
                 }
-                if (nread > 0) redisReaderFeed(reader,ibuf,nread);
+                if (nread > 0) {
+                    redisReaderFeed(reader,ibuf,nread);
+                    last_read_time = time(NULL);
+                }
             } while(nread > 0);
 
             /* Consume replies. */
             do {
                 if (redisReaderGetReply(reader,(void**)&reply) == REDIS_ERR) {
                     fprintf(stderr, "Error reading replies from server\n");
@@ -1200,23 +1213,27 @@
                 }
                 /* If buffer is empty, load from stdin. */
                 if (obuf_len == 0 && !eof) {
                     ssize_t nread = read(STDIN_FILENO,obuf,sizeof(obuf));
 
                     if (nread == 0) {
+                        /* The ECHO sequence starts with a "\r\n" so that if there
+                         * is garbage in the protocol we read from stdin, the ECHO
+                         * will likely still be properly formatted.
+                         * CRLF is ignored by Redis, so it has no effects. */
                         char echo[] =
-                        "*2\r\n$4\r\nECHO\r\n$20\r\n01234567890123456789\r\n";
+                        "\r\n*2\r\n$4\r\nECHO\r\n$20\r\n01234567890123456789\r\n";
                         int j;
 
                         eof = 1;
                         /* Everything transferred, so we queue a special
                          * ECHO command that we can match in the replies
                          * to make sure everything was read from the server. */
                         for (j = 0; j < 20; j++)
                             magic[j] = rand() & 0xff;
-                        memcpy(echo+19,magic,20);
+                        memcpy(echo+21,magic,20);
                         memcpy(obuf,echo,sizeof(echo)-1);
                         obuf_len = sizeof(echo)-1;
                         obuf_pos = 0;
                         printf("All data transferred. Waiting for the last reply...\n");
                     } else if (nread == -1) {
                         fprintf(stderr, "Error reading from stdin: %s\n",
@@ -1227,12 +1244,24 @@
                         obuf_pos = 0;
                     }
                 }
                 if (obuf_len == 0 && eof) break;
             }
         }
+
+        /* Handle timeout, that is, we reached EOF, and we are not getting
+         * replies from the server for a few seconds, nor the final ECHO is
+         * received. */
+        if (eof && config.pipe_timeout > 0 &&
+            time(NULL)-last_read_time > config.pipe_timeout)
+        {
+            fprintf(stderr,"No replies for %d seconds: exiting.\n",
+                config.pipe_timeout);
+            errors++;
+            break;
+        }
     }
     redisReaderFree(reader);
     printf("errors: %lld, replies: %lld\n", errors, replies);
     if (errors)
         exit(1);
     else
@@ -1481,12 +1510,13 @@
     config.latency_history = 0;
     config.cluster_mode = 0;
     config.slave_mode = 0;
     config.getrdb_mode = 0;
     config.rdb_filename = NULL;
     config.pipe_mode = 0;
+    config.pipe_timeout = REDIS_DEFAULT_PIPE_TIMEOUT;
     config.bigkeys = 0;
     config.stdinarg = 0;
     config.auth = NULL;
     config.eval = NULL;
     if (!isatty(fileno(stdout)) && (getenv("FAKETTY") == NULL))
         config.output = OUTPUT_RAW;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-cli.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-cli.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.h	2013-11-22 17:25:29.000000000 +0800
@@ -89,13 +89,41 @@
 #define REDIS_AUTHPASS_MAX_LEN 512
 #define REDIS_DEFAULT_SLAVE_PRIORITY 100
 #define REDIS_REPL_TIMEOUT 60
 #define REDIS_REPL_PING_SLAVE_PERIOD 10
 #define REDIS_RUN_ID_SIZE 40
 #define REDIS_OPS_SEC_SAMPLES 16
+#define REDIS_DEFAULT_REPL_BACKLOG_SIZE (1024*1024)    /* 1mb */
+#define REDIS_DEFAULT_REPL_BACKLOG_TIME_LIMIT (60*60)  /* 1 hour */
+#define REDIS_REPL_BACKLOG_MIN_SIZE (1024*16)          /* 16k */
 #define REDIS_BGSAVE_RETRY_DELAY 5 /* Wait a few secs before trying again. */
+#define REDIS_DEFAULT_PID_FILE "/var/run/redis.pid"
+#define REDIS_DEFAULT_SYSLOG_IDENT "redis"
+#define REDIS_DEFAULT_CLUSTER_CONFIG_FILE "nodes.conf"
+#define REDIS_DEFAULT_DAEMONIZE 0
+#define REDIS_DEFAULT_UNIX_SOCKET_PERM 0
+#define REDIS_DEFAULT_TCP_KEEPALIVE 0
+#define REDIS_DEFAULT_LOGFILE ""
+#define REDIS_DEFAULT_SYSLOG_ENABLED 0
+#define REDIS_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR 1
+#define REDIS_DEFAULT_RDB_COMPRESSION 1
+#define REDIS_DEFAULT_RDB_CHECKSUM 1
+#define REDIS_DEFAULT_RDB_FILENAME "dump.rdb"
+#define REDIS_DEFAULT_SLAVE_SERVE_STALE_DATA 1
+#define REDIS_DEFAULT_SLAVE_READ_ONLY 1
+#define REDIS_DEFAULT_REPL_DISABLE_TCP_NODELAY 0
+#define REDIS_DEFAULT_MAXMEMORY 0
+#define REDIS_DEFAULT_MAXMEMORY_SAMPLES 3
+#define REDIS_DEFAULT_AOF_NO_FSYNC_ON_REWRITE 0
+#define REDIS_DEFAULT_ACTIVE_REHASHING 1
+#define REDIS_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC 1
+#define REDIS_DEFAULT_MIN_SLAVES_TO_WRITE 0
+#define REDIS_DEFAULT_MIN_SLAVES_MAX_LAG 10
+#define REDIS_IP_STR_LEN INET6_ADDRSTRLEN
+#define REDIS_PEER_ID_LEN (REDIS_IP_STR_LEN+32) /* Must be enough for ip:port */
+#define REDIS_BINDADDR_MAX 16
 
 #define ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 20 /* Loopkups per loop. */
 #define ACTIVE_EXPIRE_CYCLE_FAST_DURATION 1000 /* Microseconds */
 #define ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 25 /* CPU max % for keys collection */
 #define ACTIVE_EXPIRE_CYCLE_SLOW 0
 #define ACTIVE_EXPIRE_CYCLE_FAST 1
@@ -103,23 +131,28 @@
 /* Protocol and I/O related defines */
 #define REDIS_MAX_QUERYBUF_LEN  (1024*1024*1024) /* 1GB max query buffer. */
 #define REDIS_IOBUF_LEN         (1024*16)  /* Generic I/O buffer size */
 #define REDIS_REPLY_CHUNK_BYTES (16*1024) /* 16k output buffer */
 #define REDIS_INLINE_MAX_SIZE   (1024*64) /* Max size of inline reads */
 #define REDIS_MBULK_BIG_ARG     (1024*32)
+#define REDIS_LONGSTR_SIZE      21          /* Bytes needed for long -> str */
 #define REDIS_AOF_AUTOSYNC_BYTES (1024*1024*32) /* fdatasync every 32MB */
+/* When configuring the Redis eventloop, we setup it so that the total number
+ * of file descriptors we can handle are server.maxclients + FDSET_INCR
+ * that is our safety margin. */
+#define REDIS_EVENTLOOP_FDSET_INCR 128
 
 /* Hash table parameters */
 #define REDIS_HT_MINFILL        10      /* Minimal hash table fill 10% */
 
 /* Command flags. Please check the command table defined in the redis.c file
  * for more information about the meaning of every flag. */
 #define REDIS_CMD_WRITE 1                   /* "w" flag */
 #define REDIS_CMD_READONLY 2                /* "r" flag */
 #define REDIS_CMD_DENYOOM 4                 /* "m" flag */
-#define REDIS_CMD_FORCE_REPLICATION 8       /* "f" flag */
+#define REDIS_CMD_NOT_USED_1 8              /* no longer used flag */
 #define REDIS_CMD_ADMIN 16                  /* "a" flag */
 #define REDIS_CMD_PUBSUB 32                 /* "p" flag */
 #define REDIS_CMD_NOSCRIPT  64              /* "s" flag */
 #define REDIS_CMD_RANDOM 128                /* "R" flag */
 #define REDIS_CMD_SORT_FOR_SCRIPT 256       /* "S" flag */
 #define REDIS_CMD_LOADING 512               /* "l" flag */
@@ -189,43 +222,47 @@
                                   server.unblocked_clients */
 #define REDIS_LUA_CLIENT (1<<8) /* This is a non connected client used by Lua */
 #define REDIS_ASKING (1<<9)     /* Client issued the ASKING command */
 #define REDIS_CLOSE_ASAP (1<<10)/* Close this client ASAP */
 #define REDIS_UNIX_SOCKET (1<<11) /* Client connected via Unix domain socket */
 #define REDIS_DIRTY_EXEC (1<<12)  /* EXEC will fail for errors while queueing */
+#define REDIS_MASTER_FORCE_REPLY (1<<13)  /* Queue replies even if is master */
+#define REDIS_FORCE_AOF (1<<14)   /* Force AOF propagation of current cmd. */
+#define REDIS_FORCE_REPL (1<<15)  /* Force replication of current cmd. */
+#define REDIS_PRE_PSYNC_SLAVE (1<<16) /* Slave don't understand PSYNC. */
 
 /* Client request types */
 #define REDIS_REQ_INLINE 1
 #define REDIS_REQ_MULTIBULK 2
 
 /* Client classes for client limits, currently used only for
  * the max-client-output-buffer limit implementation. */
 #define REDIS_CLIENT_LIMIT_CLASS_NORMAL 0
 #define REDIS_CLIENT_LIMIT_CLASS_SLAVE 1
 #define REDIS_CLIENT_LIMIT_CLASS_PUBSUB 2
 #define REDIS_CLIENT_LIMIT_NUM_CLASSES 3
 
-/* Slave replication state - slave side */
+/* Slave replication state - from the point of view of the slave. */
 #define REDIS_REPL_NONE 0 /* No active replication */
 #define REDIS_REPL_CONNECT 1 /* Must connect to master */
 #define REDIS_REPL_CONNECTING 2 /* Connecting to master */
 #define REDIS_REPL_RECEIVE_PONG 3 /* Wait for PING reply */
 #define REDIS_REPL_TRANSFER 4 /* Receiving .rdb from master */
 #define REDIS_REPL_CONNECTED 5 /* Connected to master */
 
-/* Synchronous read timeout - slave side */
-#define REDIS_REPL_SYNCIO_TIMEOUT 5
-
-/* Slave replication state - from the point of view of master
- * Note that in SEND_BULK and ONLINE state the slave receives new updates
+/* Slave replication state - from the point of view of the master.
+ * In SEND_BULK and ONLINE state the slave receives new updates
  * in its output queue. In the WAIT_BGSAVE state instead the server is waiting
  * to start the next background saving in order to send updates to it. */
-#define REDIS_REPL_WAIT_BGSAVE_START 3 /* master waits bgsave to start feeding it */
-#define REDIS_REPL_WAIT_BGSAVE_END 4 /* master waits bgsave to start bulk DB transmission */
-#define REDIS_REPL_SEND_BULK 5 /* master is sending the bulk DB */
-#define REDIS_REPL_ONLINE 6 /* bulk DB already transmitted, receive updates */
+#define REDIS_REPL_WAIT_BGSAVE_START 6 /* We need to produce a new RDB file. */
+#define REDIS_REPL_WAIT_BGSAVE_END 7 /* Waiting RDB file creation to finish. */
+#define REDIS_REPL_SEND_BULK 8 /* Sending RDB file to slave. */
+#define REDIS_REPL_ONLINE 9 /* RDB file transmitted, sending just updates. */
+
+/* Synchronous read timeout - slave side */
+#define REDIS_REPL_SYNCIO_TIMEOUT 5
 
 /* List related stuff */
 #define REDIS_HEAD 0
 #define REDIS_TAIL 1
 
 /* Sort operations */
@@ -237,23 +274,25 @@
 /* Log levels */
 #define REDIS_DEBUG 0
 #define REDIS_VERBOSE 1
 #define REDIS_NOTICE 2
 #define REDIS_WARNING 3
 #define REDIS_LOG_RAW (1<<10) /* Modifier to log without timestamp */
+#define REDIS_DEFAULT_VERBOSITY REDIS_NOTICE
 
 /* Anti-warning macro... */
 #define REDIS_NOTUSED(V) ((void) V)
 
 #define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^32 elements */
 #define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */
 
 /* Append only defines */
 #define AOF_FSYNC_NO 0
 #define AOF_FSYNC_ALWAYS 1
 #define AOF_FSYNC_EVERYSEC 2
+#define REDIS_DEFAULT_AOF_FSYNC AOF_FSYNC_EVERYSEC
 
 /* Zip structure related defaults */
 #define REDIS_HASH_MAX_ZIPLIST_ENTRIES 512
 #define REDIS_HASH_MAX_ZIPLIST_VALUE 64
 #define REDIS_LIST_MAX_ZIPLIST_ENTRIES 512
 #define REDIS_LIST_MAX_ZIPLIST_VALUE 64
@@ -270,12 +309,13 @@
 #define REDIS_MAXMEMORY_VOLATILE_LRU 0
 #define REDIS_MAXMEMORY_VOLATILE_TTL 1
 #define REDIS_MAXMEMORY_VOLATILE_RANDOM 2
 #define REDIS_MAXMEMORY_ALLKEYS_LRU 3
 #define REDIS_MAXMEMORY_ALLKEYS_RANDOM 4
 #define REDIS_MAXMEMORY_NO_EVICTION 5
+#define REDIS_DEFAULT_MAXMEMORY_POLICY REDIS_MAXMEMORY_VOLATILE_LRU
 
 /* Scripting */
 #define REDIS_LUA_TIME_LIMIT 5000 /* milliseconds */
 
 /* Units */
 #define UNIT_SECONDS 0
@@ -295,12 +335,26 @@
 
 /* Command propagation flags, see propagate() function */
 #define REDIS_PROPAGATE_NONE 0
 #define REDIS_PROPAGATE_AOF 1
 #define REDIS_PROPAGATE_REPL 2
 
+/* Keyspace changes notification classes. Every class is associated with a
+ * character for configuration purposes. */
+#define REDIS_NOTIFY_KEYSPACE (1<<0)    /* K */
+#define REDIS_NOTIFY_KEYEVENT (1<<1)    /* E */
+#define REDIS_NOTIFY_GENERIC (1<<2)     /* g */
+#define REDIS_NOTIFY_STRING (1<<3)      /* $ */
+#define REDIS_NOTIFY_LIST (1<<4)        /* l */
+#define REDIS_NOTIFY_SET (1<<5)         /* s */
+#define REDIS_NOTIFY_HASH (1<<6)        /* h */
+#define REDIS_NOTIFY_ZSET (1<<7)        /* z */
+#define REDIS_NOTIFY_EXPIRED (1<<8)     /* x */
+#define REDIS_NOTIFY_EVICTED (1<<9)     /* e */
+#define REDIS_NOTIFY_ALL (REDIS_NOTIFY_GENERIC | REDIS_NOTIFY_STRING | REDIS_NOTIFY_LIST | REDIS_NOTIFY_SET | REDIS_NOTIFY_HASH | REDIS_NOTIFY_ZSET | REDIS_NOTIFY_EXPIRED | REDIS_NOTIFY_EVICTED)      /* A */
+
 /* Using the following macro you can run code inside serverCron() with the
  * specified period, specified in milliseconds.
  * The actual resolution depends on server.hz. */
 #define run_with_period(_ms_) if ((_ms_ <= 1000/server.hz) || !(server.cronloops%((_ms_)/(1000/server.hz))))
 
 /* We can print the stacktrace, so our assert is defined this way: */
@@ -354,19 +408,21 @@
     struct redisCommand *cmd;
 } multiCmd;
 
 typedef struct multiState {
     multiCmd *commands;     /* Array of MULTI commands */
     int count;              /* Total number of MULTI commands */
+    int minreplicas;        /* MINREPLICAS for synchronous replication */
+    time_t minreplicas_timeout; /* MINREPLICAS timeout as unixtime. */
 } multiState;
 
 typedef struct blockingState {
     dict *keys;             /* The keys we are waiting to terminate a blocking
                              * operation such as BLPOP. Otherwise NULL. */
     time_t timeout;         /* Blocking operation timeout. If UNIX current time
-                             * is >= timeout then the operation timed out. */
+                             * is > timeout then the operation timed out. */
     robj *target;           /* The key that should receive the element,
                              * for BRPOPLPUSH. */
 } blockingState;
 
 /* The following structure represents a node in the server.ready_keys list,
  * where we accumulate all the keys that had clients blocked with a blocking
@@ -398,23 +454,27 @@
     struct redisCommand *cmd, *lastcmd;
     int reqtype;
     int multibulklen;       /* number of multi bulk arguments left to read */
     long bulklen;           /* length of bulk argument in multi bulk request */
     list *reply;
     unsigned long reply_bytes; /* Tot bytes of objects in reply list */
-    int sentlen;
+    int sentlen;            /* Amount of bytes already sent in the current
+                               buffer or object being sent. */
     time_t ctime;           /* Client creation time */
     time_t lastinteraction; /* time of the last interaction, used for timeout */
     time_t obuf_soft_limit_reached_time;
     int flags;              /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */
-    int slaveseldb;         /* slave selected db, if this client is a slave */
     int authenticated;      /* when requirepass is non-NULL */
     int replstate;          /* replication state if this is a slave */
     int repldbfd;           /* replication DB file descriptor */
-    off_t repldboff;        /* replication DB file offset */
+    long repldboff;         /* replication DB file offset */
     off_t repldbsize;       /* replication DB file size */
+    long long reploff;      /* replication offset if this is our master */
+    long long repl_ack_off; /* replication ack offset, if this is a slave */
+    long long repl_ack_time;/* replication ack time, if this is a slave */
+    char replrunid[REDIS_RUN_ID_SIZE+1]; /* master run id if this is a master */
     int slave_listening_port; /* As configured with: SLAVECONF listening-port */
     multiState mstate;      /* MULTI/EXEC state */
     blockingState bpop;   /* blocking state */
     list *io_keys;          /* Keys this client is waiting to be loaded from the
                              * swap file in order to continue. */
     list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */
@@ -433,16 +493,16 @@
 
 struct sharedObjectsStruct {
     robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,
     *colon, *nullbulk, *nullmultibulk, *queued,
     *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,
     *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,
-    *masterdownerr, *roslaveerr, *execaborterr,
+    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,
     *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,
     *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,
-    *lpush,
+    *lpush, *emptyscan,
     *select[REDIS_SHARED_SELECT_CMDS],
     *integers[REDIS_SHARED_INTEGERS],
     *mbulkhdr[REDIS_SHARED_BULKHDR_LEN], /* "*<value>\r\n" */
     *bulkhdr[REDIS_SHARED_BULKHDR_LEN];  /* "$<value>\r\n" */
 };
 
@@ -471,12 +531,14 @@
 typedef struct clientBufferLimitsConfig {
     unsigned long long hard_limit_bytes;
     unsigned long long soft_limit_bytes;
     time_t soft_limit_seconds;
 } clientBufferLimitsConfig;
 
+extern clientBufferLimitsConfig clientBufferLimitsDefaults[REDIS_CLIENT_LIMIT_NUM_CLASSES];
+
 /* The redisOp structure defines a Redis Operation, that is an instance of
  * a command with an argument vector, database ID, propagation target
  * (REDIS_PROPAGATE_*), and command pointer.
  *
  * Currently only used to additionally propagate more commands to AOF/Replication
  * after the propagation of the executed command. */
@@ -501,12 +563,13 @@
 /*-----------------------------------------------------------------------------
  * Global server state
  *----------------------------------------------------------------------------*/
 
 struct redisServer {
     /* General */
+    char *configfile;           /* Absolute config file path, or NULL */
     int hz;                     /* serverCron() calls frequency in hertz */
     redisDb *db;
     dict *commands;             /* Command table */
     dict *orig_commands;        /* Command table before command renaming. */
     aeEventLoop *el;
     unsigned lruclock:22;       /* Clock incrementing every minute, for LRU */
@@ -518,27 +581,30 @@
     int arch_bits;              /* 32 or 64 depending on sizeof(long) */
     int cronloops;              /* Number of times the cron function run */
     char runid[REDIS_RUN_ID_SIZE+1];  /* ID always different at every exec. */
     int sentinel_mode;          /* True if this instance is a Sentinel. */
     /* Networking */
     int port;                   /* TCP listening port */
-    char *bindaddr;             /* Bind address or NULL */
+    char *bindaddr[REDIS_BINDADDR_MAX]; /* Addresses we should bind to */
+    int bindaddr_count;         /* Number of addresses in server.bindaddr[] */
     char *unixsocket;           /* UNIX socket path */
     mode_t unixsocketperm;      /* UNIX socket permission */
-    int ipfd;                   /* TCP socket file descriptor */
+    int ipfd[REDIS_BINDADDR_MAX]; /* TCP socket file descriptors */
+    int ipfd_count;             /* Used slots in ipfd[] */
     int sofd;                   /* Unix socket file descriptor */
     list *clients;              /* List of active clients */
     list *clients_to_close;     /* Clients to close asynchronously */
     list *slaves, *monitors;    /* List of slaves and MONITORs */
     redisClient *current_client; /* Current client, only used on crash report */
     char neterr[ANET_ERR_LEN];  /* Error buffer for anet.c */
     /* RDB / AOF loading information */
     int loading;                /* We are loading data from disk if true */
     off_t loading_total_bytes;
     off_t loading_loaded_bytes;
     time_t loading_start_time;
+    off_t loading_process_events_interval_bytes;
     /* Fast pointers to often looked up command */
     struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,
                         *rpopCommand;
     /* Fields used only for stats */
     time_t stat_starttime;          /* Server start time */
     long long stat_numcommands;     /* Number of processed commands */
@@ -547,12 +613,15 @@
     long long stat_evictedkeys;     /* Number of evicted keys (maxmemory) */
     long long stat_keyspace_hits;   /* Number of successful lookups of keys */
     long long stat_keyspace_misses; /* Number of failed lookups of keys */
     size_t stat_peak_memory;        /* Max used memory record */
     long long stat_fork_time;       /* Time needed to perform latest fork() */
     long long stat_rejected_conn;   /* Clients rejected because of maxclients */
+    long long stat_sync_full;       /* Number of full resyncs with slaves. */
+    long long stat_sync_partial_ok; /* Number of accepted PSYNC requests. */
+    long long stat_sync_partial_err;/* Number of unaccepted PSYNC requests. */
     list *slowlog;                  /* SLOWLOG list of commands */
     long long slowlog_entry_id;     /* SLOWLOG current entry ID */
     long long slowlog_log_slower_than; /* SLOWLOG time limit (to get logged) */
     unsigned long slowlog_max_len;     /* SLOWLOG max number of items logged */
     /* The following two are used to track instantaneous "load" in terms
      * of operations per second. */
@@ -610,19 +679,36 @@
     redisOpArray also_propagate;    /* Additional command to propagate. */
     /* Logging */
     char *logfile;                  /* Path of log file */
     int syslog_enabled;             /* Is syslog enabled? */
     char *syslog_ident;             /* Syslog ident */
     int syslog_facility;            /* Syslog facility */
-    /* Slave specific fields */
+    /* Replication (master) */
+    int slaveseldb;                 /* Last SELECTed DB in replication output */
+    long long master_repl_offset;   /* Global replication offset */
+    int repl_ping_slave_period;     /* Master pings the slave every N seconds */
+    char *repl_backlog;             /* Replication backlog for partial syncs */
+    long long repl_backlog_size;    /* Backlog circular buffer size */
+    long long repl_backlog_histlen; /* Backlog actual data length */
+    long long repl_backlog_idx;     /* Backlog circular buffer current offset */
+    long long repl_backlog_off;     /* Replication offset of first byte in the
+                                       backlog buffer. */
+    time_t repl_backlog_time_limit; /* Time without slaves after the backlog
+                                       gets released. */
+    time_t repl_no_slaves_since;    /* We have no slaves since that time.
+                                       Only valid if server.slaves len is 0. */
+    int repl_min_slaves_to_write;   /* Min number of slaves to write. */
+    int repl_min_slaves_max_lag;    /* Max lag of <count> slaves to write. */
+    int repl_good_slaves_count;     /* Number of slaves with lag <= max_lag. */
+    /* Replication (slave) */
     char *masterauth;               /* AUTH with this password with master */
     char *masterhost;               /* Hostname of master */
     int masterport;                 /* Port of master */
-    int repl_ping_slave_period;     /* Master pings the slave every N seconds */
     int repl_timeout;               /* Timeout after N seconds of master idle */
     redisClient *master;     /* Client that is master for this slave */
+    redisClient *cached_master; /* Cached master to be reused for PSYNC. */
     int repl_syncio_timeout; /* Timeout for synchronous I/O calls */
     int repl_state;          /* Replication status if the instance is a slave */
     off_t repl_transfer_size; /* Size of RDB to read from master during sync. */
     off_t repl_transfer_read; /* Amount of RDB read from master during sync. */
     off_t repl_transfer_last_fsync_off; /* Offset when we fsync-ed last time. */
     int repl_transfer_s;     /* Slave -> Master SYNC socket */
@@ -631,12 +717,18 @@
     time_t repl_transfer_lastio; /* Unix time of the latest read, for timeout */
     int repl_serve_stale_data; /* Serve stale data when link is down? */
     int repl_slave_ro;          /* Slave is read only? */
     time_t repl_down_since; /* Unix time at which link with master went down */
     int repl_disable_tcp_nodelay;   /* Disable TCP_NODELAY after SYNC? */
     int slave_priority;             /* Reported in INFO and used by Sentinel. */
+    char repl_master_runid[REDIS_RUN_ID_SIZE+1];  /* Master run id for PSYNC. */
+    long long repl_master_initial_offset;         /* Master PSYNC offset. */
+    /* Replication script cache. */
+    dict *repl_scriptcache_dict;        /* SHA1 all slaves are aware of. */
+    list *repl_scriptcache_fifo;        /* First in, first out LRU eviction. */
+    int repl_scriptcache_size;          /* Max number of elements. */
     /* Limits */
     unsigned int maxclients;        /* Max number of simultaneous clients */
     unsigned long long maxmemory;   /* Max number of memory bytes to use */
     int maxmemory_policy;           /* Policy for key eviction */
     int maxmemory_samples;          /* Pricision of random sampling */
     /* Blocked clients */
@@ -645,12 +737,13 @@
     list *ready_keys;        /* List of readyList structures for BLPOP & co */
     /* Sort parameters - qsort_r() is only available under BSD so we
      * have to take this state global, in order to pass it to sortCompare() */
     int sort_desc;
     int sort_alpha;
     int sort_bypattern;
+    int sort_store;
     /* Zip structure config, see redis.conf for more information  */
     size_t hash_max_ziplist_entries;
     size_t hash_max_ziplist_value;
     size_t list_max_ziplist_entries;
     size_t list_max_ziplist_value;
     size_t set_max_intset_entries;
@@ -658,12 +751,14 @@
     size_t zset_max_ziplist_value;
     time_t unixtime;        /* Unix time sampled every cron cycle. */
     long long mstime;       /* Like 'unixtime' but with milliseconds resolution. */
     /* Pubsub */
     dict *pubsub_channels;  /* Map channels to list of subscribed clients */
     list *pubsub_patterns;  /* A list of pubsub_patterns */
+    int notify_keyspace_events; /* Events to propagate via Pub/Sub. This is an
+                                   xor of REDIS_NOTIFY... flags. */
     /* Scripting */
     lua_State *lua; /* The Lua interpreter. We use just one for all clients */
     redisClient *lua_client;   /* The "fake client" to query Redis from Lua */
     redisClient *lua_caller;   /* The client running EVAL right now, or NULL */
     dict *lua_scripts;         /* A dictionary of SHA1 -> Lua scripts */
     long long lua_time_limit;  /* Script timeout in seconds */
@@ -773,28 +868,32 @@
 extern dictType setDictType;
 extern dictType zsetDictType;
 extern dictType dbDictType;
 extern dictType shaScriptObjectDictType;
 extern double R_Zero, R_PosInf, R_NegInf, R_Nan;
 extern dictType hashDictType;
+extern dictType replScriptCacheDictType;
 
 /*-----------------------------------------------------------------------------
  * Functions prototypes
  *----------------------------------------------------------------------------*/
 
 /* Utils */
 long long ustime(void);
 long long mstime(void);
 void getRandomHexChars(char *p, unsigned int len);
 uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);
 void exitFromChild(int retcode);
+size_t redisPopcount(void *s, long count);
+void redisSetProcTitle(char *title);
 
 /* networking.c -- Networking and Client related operations */
 redisClient *createClient(int fd);
 void closeTimedoutClients(void);
 void freeClient(redisClient *c);
+void freeClientAsync(redisClient *c);
 void resetClient(redisClient *c);
 void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask);
 void addReply(redisClient *c, robj *obj);
 void *addDeferredMultiBulkLength(redisClient *c);
 void setDeferredMultiBulkLength(redisClient *c, void *node, long length);
 void addReplySds(redisClient *c, sds s);
@@ -815,12 +914,14 @@
 void addReplyLongLong(redisClient *c, long long ll);
 void addReplyMultiBulkLen(redisClient *c, long length);
 void copyClientOutputBuffer(redisClient *dst, redisClient *src);
 void *dupClientReplyValue(void *o);
 void getClientsMaxBuffers(unsigned long *longest_output_list,
                           unsigned long *biggest_input_buffer);
+void formatPeerId(char *peerid, size_t peerid_len, char *ip, int port);
+int getClientPeerId(redisClient *client, char *peerid, size_t peerid_len);
 sds getClientInfoString(redisClient *client);
 sds getAllClientsInfoString(void);
 void rewriteClientCommandVector(redisClient *c, int argc, ...);
 void rewriteClientCommandArgument(redisClient *c, int i, robj *newval);
 unsigned long getClientOutputBufferMemoryUsage(redisClient *c);
 void freeClientsInAsyncFreeQueue(void);
@@ -865,13 +966,14 @@
 void touchWatchedKey(redisDb *db, robj *key);
 void touchWatchedKeysOnFlush(int dbid);
 void discardTransaction(redisClient *c);
 void flagTransaction(redisClient *c);
 
 /* Redis object implementation */
-void decrRefCount(void *o);
+void decrRefCount(robj *o);
+void decrRefCountVoid(void *o);
 void incrRefCount(robj *o);
 robj *resetRefCount(robj *obj);
 void freeStringObject(robj *o);
 void freeListObject(robj *o);
 void freeSetObject(robj *o);
 void freeZsetObject(robj *o);
@@ -898,12 +1000,13 @@
 int getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg);
 int getLongLongFromObject(robj *o, long long *target);
 int getLongDoubleFromObject(robj *o, long double *target);
 int getLongDoubleFromObjectOrReply(redisClient *c, robj *o, long double *target, const char *msg);
 char *strEncoding(int encoding);
 int compareStringObjects(robj *a, robj *b);
+int collateStringObjects(robj *a, robj *b);
 int equalStringObjects(robj *a, robj *b);
 unsigned long estimateObjectIdleTime(robj *o);
 
 /* Synchronous I/O with timeout */
 ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout);
 ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout);
@@ -911,12 +1014,20 @@
 
 /* Replication */
 void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);
 void replicationFeedMonitors(redisClient *c, list *monitors, int dictid, robj **argv, int argc);
 void updateSlavesWaitingBgsave(int bgsaveerr);
 void replicationCron(void);
+void replicationHandleMasterDisconnection(void);
+void replicationCacheMaster(redisClient *c);
+void resizeReplicationBacklog(long long newsize);
+void refreshGoodSlavesCount(void);
+void replicationScriptCacheInit(void);
+void replicationScriptCacheFlush(void);
+void replicationScriptCacheAdd(sds sha1);
+int replicationScriptCacheExists(sds sha1);
 
 /* Generic persistence functions */
 void startLoading(FILE *fp);
 void loadingProgress(off_t pos);
 void stopLoading(void);
 
@@ -962,22 +1073,30 @@
 struct redisCommand *lookupCommand(sds name);
 struct redisCommand *lookupCommandByCString(char *s);
 struct redisCommand *lookupCommandOrOriginal(sds name);
 void call(redisClient *c, int flags);
 void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags);
 void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target);
+void forceCommandPropagation(redisClient *c, int flags);
 int prepareForShutdown();
+#ifdef __GNUC__
+void redisLog(int level, const char *fmt, ...)
+    __attribute__((format(printf, 2, 3)));
+#else
 void redisLog(int level, const char *fmt, ...);
+#endif
 void redisLogRaw(int level, const char *msg);
 void redisLogFromHandler(int level, const char *msg);
 void usage();
 void updateDictResizePolicy(void);
 int htNeedsResize(dict *dict);
 void oom(const char *msg);
 void populateCommandTable(void);
 void resetCommandTableStats(void);
+void adjustOpenFilesLimit(void);
+void closeListeningSockets(int unlink_unix_socket);
 
 /* Set data type */
 robj *setTypeCreate(robj *value);
 int setTypeAdd(robj *subject, robj *value);
 int setTypeRemove(robj *subject, robj *value);
 int setTypeIsMember(robj *subject, robj *value);
@@ -1013,16 +1132,24 @@
 int pubsubUnsubscribeAllChannels(redisClient *c, int notify);
 int pubsubUnsubscribeAllPatterns(redisClient *c, int notify);
 void freePubsubPattern(void *p);
 int listMatchPubsubPattern(void *a, void *b);
 int pubsubPublishMessage(robj *channel, robj *message);
 
+/* Keyspace events notification */
+void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid);
+int keyspaceEventsStringToFlags(char *classes);
+sds keyspaceEventsFlagsToString(int flags);
+
 /* Configuration */
 void loadServerConfig(char *filename, char *options);
 void appendServerSaveParams(time_t seconds, int changes);
 void resetServerSaveParams();
+struct rewriteConfigState; /* Forward declaration to export API. */
+void rewriteConfigRewriteLine(struct rewriteConfigState *state, char *option, sds line, int force);
+int rewriteConfig(char *path);
 
 /* db.c -- Keyspace access API */
 int removeExpire(redisDb *db, robj *key);
 void propagateExpire(redisDb *db, robj *key);
 int expireIfNeeded(redisDb *db, robj *key);
 long long getExpire(redisDb *db, robj *key);
@@ -1040,12 +1167,14 @@
 int dbDelete(redisDb *db, robj *key);
 long long emptyDb();
 int selectDb(redisClient *c, int id);
 void signalModifiedKey(redisDb *db, robj *key);
 void signalFlushedDb(int dbid);
 unsigned int GetKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);
+void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor);
+int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor);
 
 /* API to get key arguments from commands */
 #define REDIS_GETKEYS_ALL 0
 #define REDIS_GETKEYS_PRELOAD 1
 int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys, int flags);
 void getKeysFreeResult(int *result);
@@ -1055,19 +1184,21 @@
 
 /* Sentinel */
 void initSentinelConfig(void);
 void initSentinel(void);
 void sentinelTimer(void);
 char *sentinelHandleConfiguration(char **argv, int argc);
+void sentinelIsRunning(void);
 
 /* Scripting */
 void scriptingInit(void);
 
 /* Git SHA1 */
 char *redisGitSHA1(void);
 char *redisGitDirty(void);
+uint64_t redisBuildId(void);
 
 /* Commands prototypes */
 void authCommand(redisClient *c);
 void pingCommand(redisClient *c);
 void echoCommand(redisClient *c);
 void setCommand(redisClient *c);
@@ -1086,12 +1217,13 @@
 void incrbyCommand(redisClient *c);
 void decrbyCommand(redisClient *c);
 void incrbyfloatCommand(redisClient *c);
 void selectCommand(redisClient *c);
 void randomkeyCommand(redisClient *c);
 void keysCommand(redisClient *c);
+void scanCommand(redisClient *c);
 void dbsizeCommand(redisClient *c);
 void lastsaveCommand(redisClient *c);
 void saveCommand(redisClient *c);
 void bgsaveCommand(redisClient *c);
 void bgrewriteaofCommand(redisClient *c);
 void shutdownCommand(redisClient *c);
@@ -1121,12 +1253,13 @@
 void sinterCommand(redisClient *c);
 void sinterstoreCommand(redisClient *c);
 void sunionCommand(redisClient *c);
 void sunionstoreCommand(redisClient *c);
 void sdiffCommand(redisClient *c);
 void sdiffstoreCommand(redisClient *c);
+void sscanCommand(redisClient *c);
 void syncCommand(redisClient *c);
 void flushdbCommand(redisClient *c);
 void flushallCommand(redisClient *c);
 void sortCommand(redisClient *c);
 void lremCommand(redisClient *c);
 void rpoplpushCommand(redisClient *c);
@@ -1173,24 +1306,27 @@
 void hmgetCommand(redisClient *c);
 void hdelCommand(redisClient *c);
 void hlenCommand(redisClient *c);
 void zremrangebyrankCommand(redisClient *c);
 void zunionstoreCommand(redisClient *c);
 void zinterstoreCommand(redisClient *c);
+void zscanCommand(redisClient *c);
 void hkeysCommand(redisClient *c);
 void hvalsCommand(redisClient *c);
 void hgetallCommand(redisClient *c);
 void hexistsCommand(redisClient *c);
+void hscanCommand(redisClient *c);
 void configCommand(redisClient *c);
 void hincrbyCommand(redisClient *c);
 void hincrbyfloatCommand(redisClient *c);
 void subscribeCommand(redisClient *c);
 void unsubscribeCommand(redisClient *c);
 void psubscribeCommand(redisClient *c);
 void punsubscribeCommand(redisClient *c);
 void publishCommand(redisClient *c);
+void pubsubCommand(redisClient *c);
 void watchCommand(redisClient *c);
 void unwatchCommand(redisClient *c);
 void restoreCommand(redisClient *c);
 void migrateCommand(redisClient *c);
 void dumpCommand(redisClient *c);
 void objectCommand(redisClient *c);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-sentinel and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-sentinel differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/redis-server and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/redis-server differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.c	2017-09-27 22:05:50.299055938 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.c	2017-09-27 22:06:58.827053426 +0800
@@ -28,15 +28,25 @@
  */
 
 /* Every time the Redis Git SHA1 or Dirty status changes only this small 
  * file is recompiled, as we access this information in all the other
  * files using this functions. */
 
+#include <string.h>
+
 #include "release.h"
+#include "version.h"
+#include "crc64.h"
 
 char *redisGitSHA1(void) {
     return REDIS_GIT_SHA1;
 }
 
 char *redisGitDirty(void) {
     return REDIS_GIT_DIRTY;
 }
+
+uint64_t redisBuildId(void) {
+    char *buildid = REDIS_VERSION REDIS_BUILD_ID REDIS_GIT_DIRTY REDIS_GIT_SHA1;
+
+    return crc64(0,(unsigned char*)buildid,strlen(buildid));
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.h	2017-09-27 22:05:50.299055938 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.h	2017-09-27 22:06:58.827053426 +0800
@@ -1,2 +1,3 @@
 #define REDIS_GIT_SHA1 "00000000"
 #define REDIS_GIT_DIRTY "0"
+#define REDIS_BUILD_ID "sarah-Erazer-X310-1506521218"
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/release.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/release.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/replication.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/replication.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/replication.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/replication.c	2013-11-22 17:25:29.000000000 +0800
@@ -34,66 +34,225 @@
 #include <sys/time.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 
+void replicationDiscardCachedMaster(void);
+void replicationResurrectCachedMaster(int newfd);
+
 /* ---------------------------------- MASTER -------------------------------- */
 
+void createReplicationBacklog(void) {
+    redisAssert(server.repl_backlog == NULL);
+    server.repl_backlog = zmalloc(server.repl_backlog_size);
+    server.repl_backlog_histlen = 0;
+    server.repl_backlog_idx = 0;
+    /* When a new backlog buffer is created, we increment the replication
+     * offset by one to make sure we'll not be able to PSYNC with any
+     * previous slave. This is needed because we avoid incrementing the
+     * master_repl_offset if no backlog exists nor slaves are attached. */
+    server.master_repl_offset++;
+
+    /* We don't have any data inside our buffer, but virtually the first
+     * byte we have is the next byte that will be generated for the
+     * replication stream. */
+    server.repl_backlog_off = server.master_repl_offset+1;
+}
+
+/* This function is called when the user modifies the replication backlog
+ * size at runtime. It is up to the function to both update the
+ * server.repl_backlog_size and to resize the buffer and setup it so that
+ * it contains the same data as the previous one (possibly less data, but
+ * the most recent bytes, or the same data and more free space in case the
+ * buffer is enlarged). */
+void resizeReplicationBacklog(long long newsize) {
+    if (newsize < REDIS_REPL_BACKLOG_MIN_SIZE)
+        newsize = REDIS_REPL_BACKLOG_MIN_SIZE;
+    if (server.repl_backlog_size == newsize) return;
+
+    server.repl_backlog_size = newsize;
+    if (server.repl_backlog != NULL) {
+        /* What we actually do is to flush the old buffer and realloc a new
+         * empty one. It will refill with new data incrementally.
+         * The reason is that copying a few gigabytes adds latency and even
+         * worse often we need to alloc additional space before freeing the
+         * old buffer. */
+        zfree(server.repl_backlog);
+        server.repl_backlog = zmalloc(server.repl_backlog_size);
+        server.repl_backlog_histlen = 0;
+        server.repl_backlog_idx = 0;
+        /* Next byte we have is... the next since the buffer is emtpy. */
+        server.repl_backlog_off = server.master_repl_offset+1;
+    }
+}
+
+void freeReplicationBacklog(void) {
+    redisAssert(listLength(server.slaves) == 0);
+    zfree(server.repl_backlog);
+    server.repl_backlog = NULL;
+}
+
+/* Add data to the replication backlog.
+ * This function also increments the global replication offset stored at
+ * server.master_repl_offset, because there is no case where we want to feed
+ * the backlog without incrementing the buffer. */
+void feedReplicationBacklog(void *ptr, size_t len) {
+    unsigned char *p = ptr;
+
+    server.master_repl_offset += len;
+
+    /* This is a circular buffer, so write as much data we can at every
+     * iteration and rewind the "idx" index if we reach the limit. */
+    while(len) {
+        size_t thislen = server.repl_backlog_size - server.repl_backlog_idx;
+        if (thislen > len) thislen = len;
+        memcpy(server.repl_backlog+server.repl_backlog_idx,p,thislen);
+        server.repl_backlog_idx += thislen;
+        if (server.repl_backlog_idx == server.repl_backlog_size)
+            server.repl_backlog_idx = 0;
+        len -= thislen;
+        p += thislen;
+        server.repl_backlog_histlen += thislen;
+    }
+    if (server.repl_backlog_histlen > server.repl_backlog_size)
+        server.repl_backlog_histlen = server.repl_backlog_size;
+    /* Set the offset of the first byte we have in the backlog. */
+    server.repl_backlog_off = server.master_repl_offset -
+                              server.repl_backlog_histlen + 1;
+}
+
+/* Wrapper for feedReplicationBacklog() that takes Redis string objects
+ * as input. */
+void feedReplicationBacklogWithObject(robj *o) {
+    char llstr[REDIS_LONGSTR_SIZE];
+    void *p;
+    size_t len;
+
+    if (o->encoding == REDIS_ENCODING_INT) {
+        len = ll2string(llstr,sizeof(llstr),(long)o->ptr);
+        p = llstr;
+    } else {
+        len = sdslen(o->ptr);
+        p = o->ptr;
+    }
+    feedReplicationBacklog(p,len);
+}
+
 void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
     listNode *ln;
     listIter li;
-    int j;
+    int j, len;
+    char llstr[REDIS_LONGSTR_SIZE];
 
+    /* If there aren't slaves, and there is no backlog buffer to populate,
+     * we can return ASAP. */
+    if (server.repl_backlog == NULL && listLength(slaves) == 0) return;
+
+    /* We can't have slaves attached and no backlog. */
+    redisAssert(!(listLength(slaves) != 0 && server.repl_backlog == NULL));
+
+    /* Send SELECT command to every slave if needed. */
+    if (server.slaveseldb != dictid) {
+        robj *selectcmd;
+
+        /* For a few DBs we have pre-computed SELECT command. */
+        if (dictid >= 0 && dictid < REDIS_SHARED_SELECT_CMDS) {
+            selectcmd = shared.select[dictid];
+        } else {
+            int dictid_len;
+
+            dictid_len = ll2string(llstr,sizeof(llstr),dictid);
+            selectcmd = createObject(REDIS_STRING,
+                sdscatprintf(sdsempty(),
+                "*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n",
+                dictid_len, llstr));
+        }
+
+        /* Add the SELECT command into the backlog. */
+        if (server.repl_backlog) feedReplicationBacklogWithObject(selectcmd);
+
+        /* Send it to slaves. */
+        listRewind(slaves,&li);
+        while((ln = listNext(&li))) {
+            redisClient *slave = ln->value;
+            addReply(slave,selectcmd);
+        }
+
+        if (dictid < 0 || dictid >= REDIS_SHARED_SELECT_CMDS)
+            decrRefCount(selectcmd);
+    }
+    server.slaveseldb = dictid;
+
+    /* Write the command to the replication backlog if any. */
+    if (server.repl_backlog) {
+        char aux[REDIS_LONGSTR_SIZE+3];
+
+        /* Add the multi bulk reply length. */
+        aux[0] = '*';
+        len = ll2string(aux+1,sizeof(aux)-1,argc);
+        aux[len+1] = '\r';
+        aux[len+2] = '\n';
+        feedReplicationBacklog(aux,len+3);
+
+        for (j = 0; j < argc; j++) {
+            long objlen = stringObjectLen(argv[j]);
+
+            /* We need to feed the buffer with the object as a bulk reply
+             * not just as a plain string, so create the $..CRLF payload len 
+             * ad add the final CRLF */
+            aux[0] = '$';
+            len = ll2string(aux+1,sizeof(aux)-1,objlen);
+            aux[len+1] = '\r';
+            aux[len+2] = '\n';
+            feedReplicationBacklog(aux,len+3);
+            feedReplicationBacklogWithObject(argv[j]);
+            feedReplicationBacklog(aux+len+1,2);
+        }
+    }
+
+    /* Write the command to every slave. */
     listRewind(slaves,&li);
     while((ln = listNext(&li))) {
         redisClient *slave = ln->value;
 
         /* Don't feed slaves that are still waiting for BGSAVE to start */
         if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START) continue;
 
         /* Feed slaves that are waiting for the initial SYNC (so these commands
          * are queued in the output buffer until the initial SYNC completes),
          * or are already in sync with the master. */
-        if (slave->slaveseldb != dictid) {
-            robj *selectcmd;
 
-            if (dictid >= 0 && dictid < REDIS_SHARED_SELECT_CMDS) {
-                selectcmd = shared.select[dictid];
-                incrRefCount(selectcmd);
-            } else {
-                selectcmd = createObject(REDIS_STRING,
-                    sdscatprintf(sdsempty(),"select %d\r\n",dictid));
-            }
-            addReply(slave,selectcmd);
-            decrRefCount(selectcmd);
-            slave->slaveseldb = dictid;
-        }
+        /* Add the multi bulk length. */
         addReplyMultiBulkLen(slave,argc);
-        for (j = 0; j < argc; j++) addReplyBulk(slave,argv[j]);
+
+        /* Finally any additional argument that was not stored inside the
+         * static buffer if any (from j to argc). */
+        for (j = 0; j < argc; j++)
+            addReplyBulk(slave,argv[j]);
     }
 }
 
 void replicationFeedMonitors(redisClient *c, list *monitors, int dictid, robj **argv, int argc) {
     listNode *ln;
     listIter li;
-    int j, port;
+    int j;
     sds cmdrepr = sdsnew("+");
     robj *cmdobj;
-    char ip[32];
+    char peerid[REDIS_PEER_ID_LEN];
     struct timeval tv;
 
     gettimeofday(&tv,NULL);
     cmdrepr = sdscatprintf(cmdrepr,"%ld.%06ld ",(long)tv.tv_sec,(long)tv.tv_usec);
     if (c->flags & REDIS_LUA_CLIENT) {
         cmdrepr = sdscatprintf(cmdrepr,"[%d lua] ",dictid);
     } else if (c->flags & REDIS_UNIX_SOCKET) {
         cmdrepr = sdscatprintf(cmdrepr,"[%d unix:%s] ",dictid,server.unixsocket);
     } else {
-        anetPeerToString(c->fd,ip,&port);
-        cmdrepr = sdscatprintf(cmdrepr,"[%d %s:%d] ",dictid,ip,port);
+        getClientPeerId(c,peerid,sizeof(peerid));
+        cmdrepr = sdscatprintf(cmdrepr,"[%d %s] ",dictid,peerid);
     }
 
     for (j = 0; j < argc; j++) {
         if (argv[j]->encoding == REDIS_ENCODING_INT) {
             cmdrepr = sdscatprintf(cmdrepr, "\"%ld\"", (long)argv[j]->ptr);
         } else {
@@ -111,12 +270,149 @@
         redisClient *monitor = ln->value;
         addReply(monitor,cmdobj);
     }
     decrRefCount(cmdobj);
 }
 
+/* Feed the slave 'c' with the replication backlog starting from the
+ * specified 'offset' up to the end of the backlog. */
+long long addReplyReplicationBacklog(redisClient *c, long long offset) {
+    long long j, skip, len;
+
+    redisLog(REDIS_DEBUG, "[PSYNC] Slave request offset: %lld", offset);
+
+    if (server.repl_backlog_histlen == 0) {
+        redisLog(REDIS_DEBUG, "[PSYNC] Backlog history len is zero");
+        return 0;
+    }
+
+    redisLog(REDIS_DEBUG, "[PSYNC] Backlog size: %lld",
+             server.repl_backlog_size);
+    redisLog(REDIS_DEBUG, "[PSYNC] First byte: %lld",
+             server.repl_backlog_off);
+    redisLog(REDIS_DEBUG, "[PSYNC] History len: %lld",
+             server.repl_backlog_histlen);
+    redisLog(REDIS_DEBUG, "[PSYNC] Current index: %lld",
+             server.repl_backlog_idx);
+
+    /* Compute the amount of bytes we need to discard. */
+    skip = offset - server.repl_backlog_off;
+    redisLog(REDIS_DEBUG, "[PSYNC] Skipping: %lld", skip);
+
+    /* Point j to the oldest byte, that is actaully our
+     * server.repl_backlog_off byte. */
+    j = (server.repl_backlog_idx +
+        (server.repl_backlog_size-server.repl_backlog_histlen)) %
+        server.repl_backlog_size;
+    redisLog(REDIS_DEBUG, "[PSYNC] Index of first byte: %lld", j);
+
+    /* Discard the amount of data to seek to the specified 'offset'. */
+    j = (j + skip) % server.repl_backlog_size;
+
+    /* Feed slave with data. Since it is a circular buffer we have to
+     * split the reply in two parts if we are cross-boundary. */
+    len = server.repl_backlog_histlen - skip;
+    redisLog(REDIS_DEBUG, "[PSYNC] Reply total length: %lld", len);
+    while(len) {
+        long long thislen =
+            ((server.repl_backlog_size - j) < len) ?
+            (server.repl_backlog_size - j) : len;
+
+        redisLog(REDIS_DEBUG, "[PSYNC] addReply() length: %lld", thislen);
+        addReplySds(c,sdsnewlen(server.repl_backlog + j, thislen));
+        len -= thislen;
+        j = 0;
+    }
+    return server.repl_backlog_histlen - skip;
+}
+
+/* This function handles the PSYNC command from the point of view of a
+ * master receiving a request for partial resynchronization.
+ *
+ * On success return REDIS_OK, otherwise REDIS_ERR is returned and we proceed
+ * with the usual full resync. */
+int masterTryPartialResynchronization(redisClient *c) {
+    long long psync_offset, psync_len;
+    char *master_runid = c->argv[1]->ptr;
+    char buf[128];
+    int buflen;
+
+    /* Is the runid of this master the same advertised by the wannabe slave
+     * via PSYNC? If runid changed this master is a different instance and
+     * there is no way to continue. */
+    if (strcasecmp(master_runid, server.runid)) {
+        /* Run id "?" is used by slaves that want to force a full resync. */
+        if (master_runid[0] != '?') {
+            redisLog(REDIS_NOTICE,"Partial resynchronization not accepted: "
+                "Runid mismatch (Client asked for '%s', I'm '%s')",
+                master_runid, server.runid);
+        } else {
+            redisLog(REDIS_NOTICE,"Full resync requested by slave.");
+        }
+        goto need_full_resync;
+    }
+
+    /* We still have the data our slave is asking for? */
+    if (getLongLongFromObjectOrReply(c,c->argv[2],&psync_offset,NULL) !=
+       REDIS_OK) goto need_full_resync;
+    if (!server.repl_backlog ||
+        psync_offset < server.repl_backlog_off ||
+        psync_offset > (server.repl_backlog_off + server.repl_backlog_histlen))
+    {
+        redisLog(REDIS_NOTICE,
+            "Unable to partial resync with the slave for lack of backlog (Slave request was: %lld).", psync_offset);
+        if (psync_offset > server.master_repl_offset) {
+            redisLog(REDIS_WARNING,
+                "Warning: slave tried to PSYNC with an offset that is greater than the master replication offset.");
+        }
+        goto need_full_resync;
+    }
+
+    /* If we reached this point, we are able to perform a partial resync:
+     * 1) Set client state to make it a slave.
+     * 2) Inform the client we can continue with +CONTINUE
+     * 3) Send the backlog data (from the offset to the end) to the slave. */
+    c->flags |= REDIS_SLAVE;
+    c->replstate = REDIS_REPL_ONLINE;
+    c->repl_ack_time = server.unixtime;
+    listAddNodeTail(server.slaves,c);
+    /* We can't use the connection buffers since they are used to accumulate
+     * new commands at this stage. But we are sure the socket send buffer is
+     * emtpy so this write will never fail actually. */
+    buflen = snprintf(buf,sizeof(buf),"+CONTINUE\r\n");
+    if (write(c->fd,buf,buflen) != buflen) {
+        freeClientAsync(c);
+        return REDIS_OK;
+    }
+    psync_len = addReplyReplicationBacklog(c,psync_offset);
+    redisLog(REDIS_NOTICE,
+        "Partial resynchronization request accepted. Sending %lld bytes of backlog starting from offset %lld.", psync_len, psync_offset);
+    /* Note that we don't need to set the selected DB at server.slaveseldb
+     * to -1 to force the master to emit SELECT, since the slave already
+     * has this state from the previous connection with the master. */
+
+    refreshGoodSlavesCount();
+    return REDIS_OK; /* The caller can return, no full resync needed. */
+
+need_full_resync:
+    /* We need a full resync for some reason... notify the client. */
+    psync_offset = server.master_repl_offset;
+    /* Add 1 to psync_offset if it the replication backlog does not exists
+     * as when it will be created later we'll increment the offset by one. */
+    if (server.repl_backlog == NULL) psync_offset++;
+    /* Again, we can't use the connection buffers (see above). */
+    buflen = snprintf(buf,sizeof(buf),"+FULLRESYNC %s %lld\r\n",
+                      server.runid,psync_offset);
+    if (write(c->fd,buf,buflen) != buflen) {
+        freeClientAsync(c);
+        return REDIS_OK;
+    }
+    return REDIS_ERR;
+}
+
+/* SYNC ad PSYNC command implemenation. */
 void syncCommand(redisClient *c) {
     /* ignore SYNC if already slave or in monitor mode */
     if (c->flags & REDIS_SLAVE) return;
 
     /* Refuse SYNC requests if we are a slave but the link with our master
      * is not ok... */
@@ -126,18 +422,51 @@
     }
 
     /* SYNC can't be issued when the server has pending data to send to
      * the client about already issued commands. We need a fresh reply
      * buffer registering the differences between the BGSAVE and the current
      * dataset, so that we can copy to other slaves if needed. */
-    if (listLength(c->reply) != 0) {
-        addReplyError(c,"SYNC is invalid with pending input");
+    if (listLength(c->reply) != 0 || c->bufpos != 0) {
+        addReplyError(c,"SYNC and PSYNC are invalid with pending output");
         return;
     }
 
-    redisLog(REDIS_NOTICE,"Slave ask for synchronization");
+    redisLog(REDIS_NOTICE,"Slave asks for synchronization");
+
+    /* Try a partial resynchronization if this is a PSYNC command.
+     * If it fails, we continue with usual full resynchronization, however
+     * when this happens masterTryPartialResynchronization() already
+     * replied with:
+     *
+     * +FULLRESYNC <runid> <offset>
+     *
+     * So the slave knows the new runid and offset to try a PSYNC later
+     * if the connection with the master is lost. */
+    if (!strcasecmp(c->argv[0]->ptr,"psync")) {
+        if (masterTryPartialResynchronization(c) == REDIS_OK) {
+            server.stat_sync_partial_ok++;
+            return; /* No full resync needed, return. */
+        } else {
+            char *master_runid = c->argv[1]->ptr;
+
+            /* Increment stats for failed PSYNCs, but only if the
+             * runid is not "?", as this is used by slaves to force a full
+             * resync on purpose when they are not albe to partially
+             * resync. */
+            if (master_runid[0] != '?') server.stat_sync_partial_err++;
+        }
+    } else {
+        /* If a slave uses SYNC, we are dealing with an old implementation
+         * of the replication protocol (like redis-cli --slave). Flag the client
+         * so that we don't expect to receive REPLCONF ACK feedbacks. */
+        c->flags |= REDIS_PRE_PSYNC_SLAVE;
+    }
+
+    /* Full resynchronization. */
+    server.stat_sync_full++;
+
     /* Here we need to check if there is a background saving operation
      * in progress, or if it is required to start one */
     if (server.rdb_child_pid != -1) {
         /* Ok a background save is in progress. Let's check if it is a good
          * one for replication, i.e. if there is another slave that is
          * registering differences since the server forked to save */
@@ -168,20 +497,24 @@
         if (rdbSaveBackground(server.rdb_filename) != REDIS_OK) {
             redisLog(REDIS_NOTICE,"Replication failed, can't BGSAVE");
             addReplyError(c,"Unable to perform background save");
             return;
         }
         c->replstate = REDIS_REPL_WAIT_BGSAVE_END;
+        /* Flush the script cache for the new slave. */
+        replicationScriptCacheFlush();
     }
 
     if (server.repl_disable_tcp_nodelay)
         anetDisableTcpNoDelay(NULL, c->fd); /* Non critical if it fails. */
     c->repldbfd = -1;
     c->flags |= REDIS_SLAVE;
-    c->slaveseldb = 0;
+    server.slaveseldb = -1; /* Force to re-emit the SELECT command. */
     listAddNodeTail(server.slaves,c);
+    if (listLength(server.slaves) == 1 && server.repl_backlog == NULL)
+        createReplicationBacklog();
     return;
 }
 
 /* REPLCONF <option> <value> <option> <value> ...
  * This command is used by a slave in order to configure the replication
  * process before starting it with the SYNC command.
@@ -210,12 +543,26 @@
             long port;
 
             if ((getLongFromObjectOrReply(c,c->argv[j+1],
                     &port,NULL) != REDIS_OK))
                 return;
             c->slave_listening_port = port;
+        } else if (!strcasecmp(c->argv[j]->ptr,"ack")) {
+            /* REPLCONF ACK is used by slave to inform the master the amount
+             * of replication stream that it processed so far. It is an
+             * internal only command that normal clients should never use. */
+            long long offset;
+
+            if (!(c->flags & REDIS_SLAVE)) return;
+            if ((getLongLongFromObject(c->argv[j+1], &offset) != REDIS_OK))
+                return;
+            if (offset > c->repl_ack_off)
+                c->repl_ack_off = offset;
+            c->repl_ack_time = server.unixtime;
+            /* Note: this command does not reply anything! */
+            return;
         } else {
             addReplyErrorFormat(c,"Unrecognized REPLCONF option: %s",
                 (char*)c->argv[j]->ptr);
             return;
         }
     }
@@ -263,17 +610,19 @@
     slave->repldboff += nwritten;
     if (slave->repldboff == slave->repldbsize) {
         close(slave->repldbfd);
         slave->repldbfd = -1;
         aeDeleteFileEvent(server.el,slave->fd,AE_WRITABLE);
         slave->replstate = REDIS_REPL_ONLINE;
+        slave->repl_ack_time = server.unixtime;
         if (aeCreateFileEvent(server.el, slave->fd, AE_WRITABLE,
             sendReplyToClient, slave) == AE_ERR) {
             freeClient(slave);
             return;
         }
+        refreshGoodSlavesCount();
         redisLog(REDIS_NOTICE,"Synchronization with slave succeeded");
     }
 }
 
 /* This function is called at the end of every background saving.
  * The argument bgsaveerr is REDIS_OK if the background saving succeeded
@@ -315,12 +664,17 @@
                 freeClient(slave);
                 continue;
             }
         }
     }
     if (startbgsave) {
+        /* Since we are starting a new background save for one or more slaves,
+         * we flush the Replication Script Cache to use EVAL to propagate every
+         * new EVALSHA for the first time, since all the new slaves don't know
+         * about previous scripts. */
+        replicationScriptCacheFlush();
         if (rdbSaveBackground(server.rdb_filename) != REDIS_OK) {
             listIter li;
 
             listRewind(server.slaves,&li);
             redisLog(REDIS_WARNING,"SYNC failed. BGSAVE failed");
             while((ln = listNext(&li))) {
@@ -376,19 +730,19 @@
             /* At this stage just a newline works as a PING in order to take
              * the connection live. So we refresh our last interaction
              * timestamp. */
             server.repl_transfer_lastio = server.unixtime;
             return;
         } else if (buf[0] != '$') {
-            redisLog(REDIS_WARNING,"Bad protocol from MASTER, the first byte is not '$', are you sure the host and port are right?");
+            redisLog(REDIS_WARNING,"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?", buf);
             goto error;
         }
         server.repl_transfer_size = strtol(buf+1,NULL,10);
         redisLog(REDIS_NOTICE,
-            "MASTER <-> SLAVE sync: receiving %ld bytes from master",
-            server.repl_transfer_size);
+            "MASTER <-> SLAVE sync: receiving %lld bytes from master",
+            (long long) server.repl_transfer_size);
         return;
     }
 
     /* Read bulk data */
     left = server.repl_transfer_size - server.repl_transfer_read;
     readlen = (left < (signed)sizeof(buf)) ? left : (signed)sizeof(buf);
@@ -443,12 +797,15 @@
         zfree(server.repl_transfer_tmpfile);
         close(server.repl_transfer_fd);
         server.master = createClient(server.repl_transfer_s);
         server.master->flags |= REDIS_MASTER;
         server.master->authenticated = 1;
         server.repl_state = REDIS_REPL_CONNECTED;
+        server.master->reploff = server.repl_master_initial_offset;
+        memcpy(server.master->replrunid, server.repl_master_runid,
+            sizeof(server.repl_master_runid));
         redisLog(REDIS_NOTICE, "MASTER <-> SLAVE sync: Finished with success");
         /* Restart the AOF subsystem now that we finished the sync. This
          * will trigger an AOF rewrite, and when done will start appending
          * to the new file. */
         if (server.aof_state != REDIS_AOF_OFF) {
             int retry = 10;
@@ -472,14 +829,14 @@
     return;
 }
 
 /* Send a synchronous command to the master. Used to send AUTH and
  * REPLCONF commands before starting the replication with SYNC.
  *
- * On success NULL is returned.
- * On error an sds string describing the error is returned.
+ * The command returns an sds string representing the result of the
+ * operation. On error the first byte is a "-".
  */
 char *sendSynchronousCommand(int fd, ...) {
     va_list ap;
     sds cmd = sdsempty();
     char *arg, buf[256];
 
@@ -495,36 +852,142 @@
     }
     cmd = sdscatlen(cmd,"\r\n",2);
 
     /* Transfer command to the server. */
     if (syncWrite(fd,cmd,sdslen(cmd),server.repl_syncio_timeout*1000) == -1) {
         sdsfree(cmd);
-        return sdscatprintf(sdsempty(),"Writing to master: %s",
+        return sdscatprintf(sdsempty(),"-Writing to master: %s",
                 strerror(errno));
     }
     sdsfree(cmd);
 
     /* Read the reply from the server. */
     if (syncReadLine(fd,buf,sizeof(buf),server.repl_syncio_timeout*1000) == -1)
     {
-        return sdscatprintf(sdsempty(),"Reading from master: %s",
+        return sdscatprintf(sdsempty(),"-Reading from master: %s",
                 strerror(errno));
     }
+    return sdsnew(buf);
+}
+
+/* Try a partial resynchronization with the master if we are about to reconnect.
+ * If there is no cached master structure, at least try to issue a
+ * "PSYNC ? -1" command in order to trigger a full resync using the PSYNC
+ * command in order to obtain the master run id and the master replication
+ * global offset.
+ *
+ * This function is designed to be called from syncWithMaster(), so the
+ * following assumptions are made:
+ *
+ * 1) We pass the function an already connected socket "fd".
+ * 2) This function does not close the file descriptor "fd". However in case
+ *    of successful partial resynchronization, the function will reuse
+ *    'fd' as file descriptor of the server.master client structure.
+ *
+ * The function returns:
+ *
+ * PSYNC_CONTINUE: If the PSYNC command succeded and we can continue.
+ * PSYNC_FULLRESYNC: If PSYNC is supported but a full resync is needed.
+ *                   In this case the master run_id and global replication
+ *                   offset is saved.
+ * PSYNC_NOT_SUPPORTED: If the server does not understand PSYNC at all and
+ *                      the caller should fall back to SYNC.
+ */
+
+#define PSYNC_CONTINUE 0
+#define PSYNC_FULLRESYNC 1
+#define PSYNC_NOT_SUPPORTED 2
+int slaveTryPartialResynchronization(int fd) {
+    char *psync_runid;
+    char psync_offset[32];
+    sds reply;
+
+    /* Initially set repl_master_initial_offset to -1 to mark the current
+     * master run_id and offset as not valid. Later if we'll be able to do
+     * a FULL resync using the PSYNC command we'll set the offset at the
+     * right value, so that this information will be propagated to the
+     * client structure representing the master into server.master. */
+    server.repl_master_initial_offset = -1;
+
+    if (server.cached_master) {
+        psync_runid = server.cached_master->replrunid;
+        snprintf(psync_offset,sizeof(psync_offset),"%lld", server.cached_master->reploff+1);
+        redisLog(REDIS_NOTICE,"Trying a partial resynchronization (request %s:%s).", psync_runid, psync_offset);
+    } else {
+        redisLog(REDIS_NOTICE,"Partial resynchronization not possible (no cached master)");
+        psync_runid = "?";
+        memcpy(psync_offset,"-1",3);
+    }
+
+    /* Issue the PSYNC command */
+    reply = sendSynchronousCommand(fd,"PSYNC",psync_runid,psync_offset,NULL);
+
+    if (!strncmp(reply,"+FULLRESYNC",11)) {
+        char *runid = NULL, *offset = NULL;
+
+        /* FULL RESYNC, parse the reply in order to extract the run id
+         * and the replication offset. */
+        runid = strchr(reply,' ');
+        if (runid) {
+            runid++;
+            offset = strchr(runid,' ');
+            if (offset) offset++;
+        }
+        if (!runid || !offset || (offset-runid-1) != REDIS_RUN_ID_SIZE) {
+            redisLog(REDIS_WARNING,
+                "Master replied with wrong +FULLRESYNC syntax.");
+            /* This is an unexpected condition, actually the +FULLRESYNC
+             * reply means that the master supports PSYNC, but the reply
+             * format seems wrong. To stay safe we blank the master
+             * runid to make sure next PSYNCs will fail. */
+            memset(server.repl_master_runid,0,REDIS_RUN_ID_SIZE+1);
+        } else {
+            memcpy(server.repl_master_runid, runid, offset-runid-1);
+            server.repl_master_runid[REDIS_RUN_ID_SIZE] = '\0';
+            server.repl_master_initial_offset = strtoll(offset,NULL,10);
+            redisLog(REDIS_NOTICE,"Full resync from master: %s:%lld",
+                server.repl_master_runid,
+                server.repl_master_initial_offset);
+        }
+        /* We are going to full resync, discard the cached master structure. */
+        replicationDiscardCachedMaster();
+        sdsfree(reply);
+        return PSYNC_FULLRESYNC;
+    }
 
-    /* Check for errors from the server. */
-    if (buf[0] != '+') {
-        return sdscatprintf(sdsempty(),"Error from master: %s", buf);
+    if (!strncmp(reply,"+CONTINUE",9)) {
+        /* Partial resync was accepted, set the replication state accordingly */
+        redisLog(REDIS_NOTICE,
+            "Successful partial resynchronization with master.");
+        sdsfree(reply);
+        replicationResurrectCachedMaster(fd);
+        return PSYNC_CONTINUE;
     }
 
-    return NULL; /* No errors. */
+    /* If we reach this point we receied either an error since the master does
+     * not understand PSYNC, or an unexpected reply from the master.
+     * Reply with PSYNC_NOT_SUPPORTED in both cases. */
+
+    if (strncmp(reply,"-ERR",4)) {
+        /* If it's not an error, log the unexpected event. */
+        redisLog(REDIS_WARNING,
+            "Unexpected reply to PSYNC from master: %s", reply);
+    } else {
+        redisLog(REDIS_NOTICE,
+            "Master does not support PSYNC or is in "
+            "error state (reply: %s)", reply);
+    }
+    sdsfree(reply);
+    replicationDiscardCachedMaster();
+    return PSYNC_NOT_SUPPORTED;
 }
 
 void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {
     char tmpfile[256], *err;
     int dfd, maxtries = 5;
-    int sockerr = 0;
+    int sockerr = 0, psync_result;
     socklen_t errlen = sizeof(sockerr);
     REDIS_NOTUSED(el);
     REDIS_NOTUSED(privdata);
     REDIS_NOTUSED(mask);
 
     /* If this event fired after the user turned the instance into a master
@@ -596,39 +1059,56 @@
         }
     }
 
     /* AUTH with the master if required. */
     if(server.masterauth) {
         err = sendSynchronousCommand(fd,"AUTH",server.masterauth,NULL);
-        if (err) {
+        if (err[0] == '-') {
             redisLog(REDIS_WARNING,"Unable to AUTH to MASTER: %s",err);
             sdsfree(err);
             goto error;
         }
+        sdsfree(err);
     }
 
     /* Set the slave port, so that Master's INFO command can list the
      * slave listening port correctly. */
     {
         sds port = sdsfromlonglong(server.port);
         err = sendSynchronousCommand(fd,"REPLCONF","listening-port",port,
                                          NULL);
         sdsfree(port);
         /* Ignore the error if any, not all the Redis versions support
          * REPLCONF listening-port. */
-        if (err) {
-            redisLog(REDIS_NOTICE,"(non critical): Master does not understand REPLCONF listening-port: %s", err);
-            sdsfree(err);
+        if (err[0] == '-') {
+            redisLog(REDIS_NOTICE,"(Non critical) Master does not understand REPLCONF listening-port: %s", err);
         }
+        sdsfree(err);
     }
 
-    /* Issue the SYNC command */
-    if (syncWrite(fd,"SYNC\r\n",6,server.repl_syncio_timeout*1000) == -1) {
-        redisLog(REDIS_WARNING,"I/O error writing to MASTER: %s",
-            strerror(errno));
-        goto error;
+    /* Try a partial resynchonization. If we don't have a cached master
+     * slaveTryPartialResynchronization() will at least try to use PSYNC
+     * to start a full resynchronization so that we get the master run id
+     * and the global offset, to try a partial resync at the next
+     * reconnection attempt. */
+    psync_result = slaveTryPartialResynchronization(fd);
+    if (psync_result == PSYNC_CONTINUE) {
+        redisLog(REDIS_NOTICE, "MASTER <-> SLAVE sync: Master accepted a Partial Resynchronization.");
+        return;
+    }
+
+    /* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC
+     * and the server.repl_master_runid and repl_master_initial_offset are
+     * already populated. */
+    if (psync_result == PSYNC_NOT_SUPPORTED) {
+        redisLog(REDIS_NOTICE,"Retrying with SYNC...");
+        if (syncWrite(fd,"SYNC\r\n",6,server.repl_syncio_timeout*1000) == -1) {
+            redisLog(REDIS_WARNING,"I/O error writing to MASTER: %s",
+                strerror(errno));
+            goto error;
+        }
     }
 
     /* Prepare a suitable temp file for bulk transfer */
     while(maxtries--) {
         snprintf(tmpfile,256,
             "temp-%d.%ld.rdb",(int)server.unixtime,(long int)getpid());
@@ -729,12 +1209,13 @@
     if (!strcasecmp(c->argv[1]->ptr,"no") &&
         !strcasecmp(c->argv[2]->ptr,"one")) {
         if (server.masterhost) {
             sdsfree(server.masterhost);
             server.masterhost = NULL;
             if (server.master) freeClient(server.master);
+            replicationDiscardCachedMaster();
             cancelReplicationHandshake();
             server.repl_state = REDIS_REPL_NONE;
             redisLog(REDIS_NOTICE,"MASTER MODE enabled (user request)");
         }
     } else {
         long port;
@@ -753,22 +1234,245 @@
          * we can continue. */
         sdsfree(server.masterhost);
         server.masterhost = sdsdup(c->argv[1]->ptr);
         server.masterport = port;
         if (server.master) freeClient(server.master);
         disconnectSlaves(); /* Force our slaves to resync with us as well. */
+        replicationDiscardCachedMaster(); /* Don't try a PSYNC. */
+        freeReplicationBacklog(); /* Don't allow our chained slaves to PSYNC. */
         cancelReplicationHandshake();
         server.repl_state = REDIS_REPL_CONNECT;
         redisLog(REDIS_NOTICE,"SLAVE OF %s:%d enabled (user request)",
             server.masterhost, server.masterport);
     }
     addReply(c,shared.ok);
 }
 
-/* --------------------------- REPLICATION CRON  ---------------------------- */
+/* Send a REPLCONF ACK command to the master to inform it about the current
+ * processed offset. If we are not connected with a master, the command has
+ * no effects. */
+void replicationSendAck(void) {
+    redisClient *c = server.master;
+
+    if (c != NULL) {
+        c->flags |= REDIS_MASTER_FORCE_REPLY;
+        addReplyMultiBulkLen(c,3);
+        addReplyBulkCString(c,"REPLCONF");
+        addReplyBulkCString(c,"ACK");
+        addReplyBulkLongLong(c,c->reploff);
+        c->flags &= ~REDIS_MASTER_FORCE_REPLY;
+    }
+}
+
+/* ---------------------- MASTER CACHING FOR PSYNC -------------------------- */
+
+/* In order to implement partial synchronization we need to be able to cache
+ * our master's client structure after a transient disconnection.
+ * It is cached into server.cached_master and flushed away using the following
+ * functions. */
+
+/* This function is called by freeClient() in order to cache the master
+ * client structure instead of destryoing it. freeClient() will return
+ * ASAP after this function returns, so every action needed to avoid problems
+ * with a client that is really "suspended" has to be done by this function.
+ *
+ * The other functions that will deal with the cached master are:
+ *
+ * replicationDiscardCachedMaster() that will make sure to kill the client
+ * as for some reason we don't want to use it in the future.
+ *
+ * replicationResurrectCachedMaster() that is used after a successful PSYNC
+ * handshake in order to reactivate the cached master.
+ */
+void replicationCacheMaster(redisClient *c) {
+    listNode *ln;
+
+    redisAssert(server.master != NULL && server.cached_master == NULL);
+    redisLog(REDIS_NOTICE,"Caching the disconnected master state.");
+
+    /* Remove from the list of clients, we don't want this client to be
+     * listed by CLIENT LIST or processed in any way by batch operations. */
+    ln = listSearchKey(server.clients,c);
+    redisAssert(ln != NULL);
+    listDelNode(server.clients,ln);
+
+    /* Save the master. Server.master will be set to null later by
+     * replicationHandleMasterDisconnection(). */
+    server.cached_master = server.master;
+
+    /* Remove the event handlers and close the socket. We'll later reuse
+     * the socket of the new connection with the master during PSYNC. */
+    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);
+    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);
+    close(c->fd);
+
+    /* Set fd to -1 so that we can safely call freeClient(c) later. */
+    c->fd = -1;
+
+    /* Caching the master happens instead of the actual freeClient() call,
+     * so make sure to adjust the replication state. This function will
+     * also set server.master to NULL. */
+    replicationHandleMasterDisconnection();
+}
+
+/* Free a cached master, called when there are no longer the conditions for
+ * a partial resync on reconnection. */
+void replicationDiscardCachedMaster(void) {
+    if (server.cached_master == NULL) return;
+
+    redisLog(REDIS_NOTICE,"Discarding previously cached master state.");
+    server.cached_master->flags &= ~REDIS_MASTER;
+    freeClient(server.cached_master);
+    server.cached_master = NULL;
+}
+
+/* Turn the cached master into the current master, using the file descriptor
+ * passed as argument as the socket for the new master.
+ *
+ * This funciton is called when successfully setup a partial resynchronization
+ * so the stream of data that we'll receive will start from were this
+ * master left. */
+void replicationResurrectCachedMaster(int newfd) {
+    server.master = server.cached_master;
+    server.cached_master = NULL;
+    server.master->fd = newfd;
+    server.master->flags &= ~(REDIS_CLOSE_AFTER_REPLY|REDIS_CLOSE_ASAP);
+    server.master->authenticated = 1;
+    server.master->lastinteraction = server.unixtime;
+    server.repl_state = REDIS_REPL_CONNECTED;
+
+    /* Re-add to the list of clients. */
+    listAddNodeTail(server.clients,server.master);
+    if (aeCreateFileEvent(server.el, newfd, AE_READABLE,
+                          readQueryFromClient, server.master)) {
+        redisLog(REDIS_WARNING,"Error resurrecting the cached master, impossible to add the readable handler: %s", strerror(errno));
+        freeClientAsync(server.master); /* Close ASAP. */
+    }
+
+    /* We may also need to install the write handler as well if there is
+     * pending data in the write buffers. */
+    if (server.master->bufpos || listLength(server.master->reply)) {
+        if (aeCreateFileEvent(server.el, newfd, AE_WRITABLE,
+                          sendReplyToClient, server.master)) {
+            redisLog(REDIS_WARNING,"Error resurrecting the cached master, impossible to add the writable handler: %s", strerror(errno));
+            freeClientAsync(server.master); /* Close ASAP. */
+        }
+    }
+}
+
+/* ------------------------- MIN-SLAVES-TO-WRITE  --------------------------- */
+
+/* This function counts the number of slaves with lag <= min-slaves-max-lag.
+ * If the option is active, the server will prevent writes if there are not
+ * enough connected slaves with the specified lag (or less). */
+void refreshGoodSlavesCount(void) {
+    listIter li;
+    listNode *ln;
+    int good = 0;
+
+    if (!server.repl_min_slaves_to_write ||
+        !server.repl_min_slaves_max_lag) return;
+
+    listRewind(server.slaves,&li);
+    while((ln = listNext(&li))) {
+        redisClient *slave = ln->value;
+        time_t lag = server.unixtime - slave->repl_ack_time;
+
+        if (slave->replstate == REDIS_REPL_ONLINE &&
+            lag <= server.repl_min_slaves_max_lag) good++;
+    }
+    server.repl_good_slaves_count = good;
+}
+
+/* ----------------------- REPLICATION SCRIPT CACHE --------------------------
+ * The goal of this code is to keep track of scripts already sent to every
+ * connected slave, in order to be able to replicate EVALSHA as it is without
+ * translating it to EVAL every time it is possible.
+ *
+ * We use a capped collection implemented by an hash table for fast lookup
+ * of scripts we can send as EVALSHA, plus a linked list that is used for
+ * eviction of the oldest entry when the max number of items is reached.
+ *
+ * We don't care about taking a different cache for every different slave
+ * since to fill the cache again is not very costly, the goal of this code
+ * is to avoid that the same big script is trasmitted a big number of times
+ * per second wasting bandwidth and processor speed, but it is not a problem
+ * if we need to rebuild the cache from scratch from time to time, every used
+ * script will need to be transmitted a single time to reappear in the cache.
+ *
+ * This is how the system works:
+ *
+ * 1) Every time a new slave connects, we flush the whole script cache.
+ * 2) We only send as EVALSHA what was sent to the master as EVALSHA, without
+ *    trying to convert EVAL into EVALSHA specifically for slaves.
+ * 3) Every time we trasmit a script as EVAL to the slaves, we also add the
+ *    corresponding SHA1 of the script into the cache as we are sure every
+ *    slave knows about the script starting from now.
+ * 4) On SCRIPT FLUSH command, we replicate the command to all the slaves
+ *    and at the same time flush the script cache.
+ * 5) When the last slave disconnects, flush the cache.
+ * 6) We handle SCRIPT LOAD as well since that's how scripts are loaded
+ *    in the master sometimes.
+ */
+
+/* Initialize the script cache, only called at startup. */
+void replicationScriptCacheInit(void) {
+    server.repl_scriptcache_size = 10000;
+    server.repl_scriptcache_dict = dictCreate(&replScriptCacheDictType,NULL);
+    server.repl_scriptcache_fifo = listCreate();
+}
+
+/* Empty the script cache. Should be called every time we are no longer sure
+ * that every slave knows about all the scripts in our set, or when the
+ * current AOF "context" is no longer aware of the script. In general we
+ * should flush the cache:
+ *
+ * 1) Every time a new slave reconnects to this master and performs a
+ *    full SYNC (PSYNC does not require flushing).
+ * 2) Every time an AOF rewrite is performed.
+ * 3) Every time we are left without slaves at all, and AOF is off, in order
+ *    to reclaim otherwise unused memory.
+ */
+void replicationScriptCacheFlush(void) {
+    dictEmpty(server.repl_scriptcache_dict);
+    listRelease(server.repl_scriptcache_fifo);
+    server.repl_scriptcache_fifo = listCreate();
+}
+
+/* Add an entry into the script cache, if we reach max number of entries the
+ * oldest is removed from the list. */
+void replicationScriptCacheAdd(sds sha1) {
+    int retval;
+    sds key = sdsdup(sha1);
 
+    /* Evict oldest. */
+    if (listLength(server.repl_scriptcache_fifo) == server.repl_scriptcache_size)
+    {
+        listNode *ln = listLast(server.repl_scriptcache_fifo);
+        sds oldest = listNodeValue(ln);
+
+        retval = dictDelete(server.repl_scriptcache_dict,oldest);
+        redisAssert(retval == DICT_OK);
+        listDelNode(server.repl_scriptcache_fifo,ln);
+    }
+
+    /* Add current. */
+    retval = dictAdd(server.repl_scriptcache_dict,key,NULL);
+    listAddNodeHead(server.repl_scriptcache_fifo,key);
+    redisAssert(retval == DICT_OK);
+}
+
+/* Returns non-zero if the specified entry exists inside the cache, that is,
+ * if all the slaves are aware of this script SHA1. */
+int replicationScriptCacheExists(sds sha1) {
+    return dictFind(server.repl_scriptcache_dict,sha1) != NULL;
+}
+
+/* --------------------------- REPLICATION CRON  ----------------------------- */
+
+/* Replication cron funciton, called 1 time per second. */
 void replicationCron(void) {
     /* Non blocking connection timeout? */
     if (server.masterhost &&
         (server.repl_state == REDIS_REPL_CONNECTING ||
          server.repl_state == REDIS_REPL_RECEIVE_PONG) &&
         (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
@@ -786,50 +1490,109 @@
     }
 
     /* Timed out master when we are an already connected slave? */
     if (server.masterhost && server.repl_state == REDIS_REPL_CONNECTED &&
         (time(NULL)-server.master->lastinteraction) > server.repl_timeout)
     {
-        redisLog(REDIS_WARNING,"MASTER time out: no data nor PING received...");
+        redisLog(REDIS_WARNING,"MASTER timeout: no data nor PING received...");
         freeClient(server.master);
     }
 
     /* Check if we should connect to a MASTER */
     if (server.repl_state == REDIS_REPL_CONNECT) {
         redisLog(REDIS_NOTICE,"Connecting to MASTER %s:%d",
             server.masterhost, server.masterport);
         if (connectWithMaster() == REDIS_OK) {
             redisLog(REDIS_NOTICE,"MASTER <-> SLAVE sync started");
         }
     }
+
+    /* Send ACK to master from time to time. */
+    if (server.masterhost && server.master)
+        replicationSendAck();
     
     /* If we have attached slaves, PING them from time to time.
      * So slaves can implement an explicit timeout to masters, and will
      * be able to detect a link disconnection even if the TCP connection
      * will not actually go down. */
     if (!(server.cronloops % (server.repl_ping_slave_period * server.hz))) {
         listIter li;
         listNode *ln;
+        robj *ping_argv[1];
 
+        /* First, send PING */
+        ping_argv[0] = createStringObject("PING",4);
+        replicationFeedSlaves(server.slaves, server.slaveseldb, ping_argv, 1);
+        decrRefCount(ping_argv[0]);
+
+        /* Second, send a newline to all the slaves in pre-synchronization
+         * stage, that is, slaves waiting for the master to create the RDB file.
+         * The newline will be ignored by the slave but will refresh the
+         * last-io timer preventing a timeout. */
         listRewind(server.slaves,&li);
         while((ln = listNext(&li))) {
             redisClient *slave = ln->value;
 
-            /* Don't ping slaves that are in the middle of a bulk transfer
-             * with the master for first synchronization. */
-            if (slave->replstate == REDIS_REPL_SEND_BULK) continue;
-            if (slave->replstate == REDIS_REPL_ONLINE) {
-                /* If the slave is online send a normal ping */
-                addReplySds(slave,sdsnew("*1\r\n$4\r\nPING\r\n"));
-            } else {
-                /* Otherwise we are in the pre-synchronization stage.
-                 * Just a newline will do the work of refreshing the
-                 * connection last interaction time, and at the same time
-                 * we'll be sure that being a single char there are no
-                 * short-write problems. */
+            if (slave->replstate == REDIS_REPL_WAIT_BGSAVE_START ||
+                slave->replstate == REDIS_REPL_WAIT_BGSAVE_END) {
                 if (write(slave->fd, "\n", 1) == -1) {
                     /* Don't worry, it's just a ping. */
                 }
             }
         }
     }
+
+    /* Disconnect timedout slaves. */
+    if (listLength(server.slaves)) {
+        listIter li;
+        listNode *ln;
+
+        listRewind(server.slaves,&li);
+        while((ln = listNext(&li))) {
+            redisClient *slave = ln->value;
+
+            if (slave->replstate != REDIS_REPL_ONLINE) continue;
+            if (slave->flags & REDIS_PRE_PSYNC_SLAVE) continue;
+            if ((server.unixtime - slave->repl_ack_time) > server.repl_timeout)
+            {
+                char ip[REDIS_IP_STR_LEN];
+                int port;
+
+                if (anetPeerToString(slave->fd,ip,sizeof(ip),&port) != -1) {
+                    redisLog(REDIS_WARNING,
+                        "Disconnecting timedout slave: %s:%d",
+                        ip, slave->slave_listening_port);
+                }
+                freeClient(slave);
+            }
+        }
+    }
+
+    /* If we have no attached slaves and there is a replication backlog
+     * using memory, free it after some (configured) time. */
+    if (listLength(server.slaves) == 0 && server.repl_backlog_time_limit &&
+        server.repl_backlog)
+    {
+        time_t idle = server.unixtime - server.repl_no_slaves_since;
+
+        if (idle > server.repl_backlog_time_limit) {
+            freeReplicationBacklog();
+            redisLog(REDIS_NOTICE,
+                "Replication backlog freed after %d seconds "
+                "without connected slaves.",
+                (int) server.repl_backlog_time_limit);
+        }
+    }
+
+    /* If AOF is disabled and we no longer have attached slaves, we can
+     * free our Replication Script Cache as there is no need to propagate
+     * EVALSHA at all. */
+    if (listLength(server.slaves) == 0 &&
+        server.aof_state == REDIS_AOF_OFF &&
+        listLength(server.repl_scriptcache_fifo) != 0)
+    {
+        replicationScriptCacheFlush();
+    }
+
+    /* Refresh the number of slaves with lag <= min-slaves-max-lag. */
+    refreshGoodSlavesCount();
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/replication.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/replication.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/replication.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/replication.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.c	2013-11-22 17:25:29.000000000 +0800
@@ -48,17 +48,16 @@
 #include "fmacros.h"
 #include <string.h>
 #include <stdio.h>
 #include <unistd.h>
 #include "rio.h"
 #include "util.h"
+#include "crc64.h"
 #include "config.h"
 #include "redis.h"
 
-uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);
-
 /* Returns 1 or 0 for success/failure. */
 static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {
     r->io.buffer.ptr = sdscatlen(r->io.buffer.ptr,(char*)buf,len);
     r->io.buffer.pos += len;
     return 1;
 }
@@ -106,21 +105,25 @@
 static const rio rioBufferIO = {
     rioBufferRead,
     rioBufferWrite,
     rioBufferTell,
     NULL,           /* update_checksum */
     0,              /* current checksum */
+    0,              /* bytes read or written */
+    0,              /* read/write chunk size */
     { { NULL, 0 } } /* union for io-specific vars */
 };
 
 static const rio rioFileIO = {
     rioFileRead,
     rioFileWrite,
     rioFileTell,
     NULL,           /* update_checksum */
     0,              /* current checksum */
+    0,              /* bytes read or written */
+    0,              /* read/write chunk size */
     { { NULL, 0 } } /* union for io-specific vars */
 };
 
 void rioInitWithFile(rio *r, FILE *fp) {
     *r = rioFileIO;
     r->io.file.fp = fp;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.h	2013-11-22 17:25:29.000000000 +0800
@@ -50,12 +50,18 @@
      * computation. */
     void (*update_cksum)(struct _rio *, const void *buf, size_t len);
 
     /* The current checksum */
     uint64_t cksum;
 
+    /* number of bytes read or written */
+    size_t processed_bytes;
+
+    /* maximum single read or write chunk size */
+    size_t max_processing_chunk;
+
     /* Backend-specific vars. */
     union {
         struct {
             sds ptr;
             off_t pos;
         } buffer;
@@ -71,22 +77,35 @@
 
 /* The following functions are our interface with the stream. They'll call the
  * actual implementation of read / write / tell, and will update the checksum
  * if needed. */
 
 static inline size_t rioWrite(rio *r, const void *buf, size_t len) {
-    if (r->update_cksum) r->update_cksum(r,buf,len);
-    return r->write(r,buf,len);
+    while (len) {
+        size_t bytes_to_write = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;
+        if (r->update_cksum) r->update_cksum(r,buf,bytes_to_write);
+        if (r->write(r,buf,bytes_to_write) == 0)
+            return 0;
+        buf = (char*)buf + bytes_to_write;
+        len -= bytes_to_write;
+        r->processed_bytes += bytes_to_write;
+    }
+    return 1;
 }
 
 static inline size_t rioRead(rio *r, void *buf, size_t len) {
-    if (r->read(r,buf,len) == 1) {
-        if (r->update_cksum) r->update_cksum(r,buf,len);
-        return 1;
+    while (len) {
+        size_t bytes_to_read = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;
+        if (r->read(r,buf,bytes_to_read) == 0)
+            return 0;
+        if (r->update_cksum) r->update_cksum(r,buf,bytes_to_read);
+        buf = (char*)buf + bytes_to_read;
+        len -= bytes_to_read;
+        r->processed_bytes += bytes_to_read;
     }
-    return 0;
+    return 1;
 }
 
 static inline off_t rioTell(rio *r) {
     return r->tell(r);
 }
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/rio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/rio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/scripting.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/scripting.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/scripting.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/scripting.c	2013-11-22 17:25:29.000000000 +0800
@@ -149,15 +149,26 @@
         lua_settable(lua,-3);
     }
     return p;
 }
 
 void luaPushError(lua_State *lua, char *error) {
+    lua_Debug dbg;
+
     lua_newtable(lua);
     lua_pushstring(lua,"err");
-    lua_pushstring(lua, error);
+
+    /* Attempt to figure out where this function was called, if possible */
+    if(lua_getstack(lua, 1, &dbg) && lua_getinfo(lua, "nSl", &dbg)) {
+        sds msg = sdscatprintf(sdsempty(), "%s: %d: %s",
+            dbg.source, dbg.currentline, error);
+        lua_pushstring(lua, msg);
+        sdsfree(msg);
+    } else {
+        lua_pushstring(lua, error);
+    }
     lua_settable(lua,-3);
 }
 
 /* Sort the array currently in the stack. We do this to make the output
  * of commands like KEYS or SMEMBERS something deterministic when called
  * from Lua (to play well with AOf/replication).
@@ -607,12 +618,32 @@
                                 "  return a<b\n"
                                 "end\n";
         luaL_loadbuffer(lua,compare_func,strlen(compare_func),"@cmp_func_def");
         lua_pcall(lua,0,0,0);
     }
 
+    /* Add a helper function we use for pcall error reporting.
+     * Note that when the error is in the C function we want to report the
+     * information about the caller, that's what makes sense from the point
+     * of view of the user debugging a script. */
+    {
+        char *errh_func =       "function __redis__err__handler(err)\n"
+                                "  local i = debug.getinfo(2,'nSl')\n"
+                                "  if i and i.what == 'C' then\n"
+                                "    i = debug.getinfo(3,'nSl')\n"
+                                "  end\n"
+                                "  if i then\n"
+                                "    return i.source .. ':' .. i.currentline .. ': ' .. err\n"
+                                "  else\n"
+                                "    return err\n"
+                                "  end\n"
+                                "end\n";
+        luaL_loadbuffer(lua,errh_func,strlen(errh_func),"@err_handler_def");
+        lua_pcall(lua,0,0,0);
+    }
+
     /* Create the (non connected) client that we use to execute Redis commands
      * inside the Lua interpreter.
      * Note: there is no need to create it again when this function is called
      * by scriptingReset(). */
     if (server.lua_client == NULL) {
         server.lua_client = createClient(-1);
@@ -827,27 +858,36 @@
 
         for (j = 0; j < 40; j++)
             funcname[j+2] = tolower(sha[j]);
         funcname[42] = '\0';
     }
 
+    /* Push the pcall error handler function on the stack. */
+    lua_getglobal(lua, "__redis__err__handler");
+
     /* Try to lookup the Lua function */
     lua_getglobal(lua, funcname);
-    if (lua_isnil(lua,1)) {
+    if (lua_isnil(lua,-1)) {
         lua_pop(lua,1); /* remove the nil from the stack */
         /* Function not defined... let's define it if we have the
          * body of the function. If this is an EVALSHA call we can just
          * return an error. */
         if (evalsha) {
+            lua_pop(lua,1); /* remove the error handler from the stack. */
             addReply(c, shared.noscripterr);
             return;
         }
-        if (luaCreateFunction(c,lua,funcname,c->argv[1]) == REDIS_ERR) return;
+        if (luaCreateFunction(c,lua,funcname,c->argv[1]) == REDIS_ERR) {
+            lua_pop(lua,1); /* remove the error handler from the stack. */
+            /* The error is sent to the client by luaCreateFunction()
+             * itself when it returns REDIS_ERR. */
+            return;
+        }
         /* Now the following is guaranteed to return non nil */
         lua_getglobal(lua, funcname);
-        redisAssert(!lua_isnil(lua,1));
+        redisAssert(!lua_isnil(lua,-1));
     }
 
     /* Populate the argv and keys table accordingly to the arguments that
      * EVAL received. */
     luaSetGlobalArray(lua,"KEYS",c->argv+3,numkeys);
     luaSetGlobalArray(lua,"ARGV",c->argv+3+numkeys,c->argc-3-numkeys);
@@ -864,16 +904,16 @@
     server.lua_kill = 0;
     if (server.lua_time_limit > 0 && server.masterhost == NULL) {
         lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);
         delhook = 1;
     }
 
-    /* At this point whatever this script was never seen before or if it was
+    /* At this point whether this script was never seen before or if it was
      * already defined, we can call it. We have zero arguments and expect
      * a single return value. */
-    err = lua_pcall(lua,0,1,0);
+    err = lua_pcall(lua,0,1,-2);
 
     /* Perform some cleanup that we need to do both on error and success. */
     if (delhook) lua_sethook(lua,luaMaskCountHook,0,0); /* Disable hook */
     if (server.lua_timedout) {
         server.lua_timedout = 0;
         /* Restore the readable handler that was unregistered when the
@@ -885,36 +925,43 @@
     selectDb(c,server.lua_client->db->id); /* set DB ID from Lua client */
     lua_gc(lua,LUA_GCSTEP,1);
 
     if (err) {
         addReplyErrorFormat(c,"Error running script (call to %s): %s\n",
             funcname, lua_tostring(lua,-1));
-        lua_pop(lua,1); /* Consume the Lua reply. */
+        lua_pop(lua,2); /* Consume the Lua reply and remove error handler. */
     } else {
         /* On success convert the Lua return value into Redis protocol, and
          * send it to * the client. */
-        luaReplyToRedisReply(c,lua);
+        luaReplyToRedisReply(c,lua); /* Convert and consume the reply. */
+        lua_pop(lua,1); /* Remove the error handler. */
     }
 
-    /* If we have slaves attached we want to replicate this command as
-     * EVAL instead of EVALSHA. We do this also in the AOF as currently there
-     * is no easy way to propagate a command in a different way in the AOF
-     * and in the replication link.
+    /* EVALSHA should be propagated to Slave and AOF file as full EVAL, unless
+     * we are sure that the script was already in the context of all the
+     * attached slaves *and* the current AOF file if enabled.
      *
-     * IMPROVEMENT POSSIBLE:
-     * 1) Replicate this command as EVALSHA in the AOF.
-     * 2) Remember what slave already received a given script, and replicate
-     *    the EVALSHA against this slaves when possible.
-     */
+     * To do so we use a cache of SHA1s of scripts that we already propagated
+     * as full EVAL, that's called the Replication Script Cache.
+     *
+     * For repliation, everytime a new slave attaches to the master, we need to
+     * flush our cache of scripts that can be replicated as EVALSHA, while
+     * for AOF we need to do so every time we rewrite the AOF file. */
     if (evalsha) {
-        robj *script = dictFetchValue(server.lua_scripts,c->argv[1]->ptr);
-
-        redisAssertWithInfo(c,NULL,script != NULL);
-        rewriteClientCommandArgument(c,0,
-            resetRefCount(createStringObject("EVAL",4)));
-        rewriteClientCommandArgument(c,1,script);
+        if (!replicationScriptCacheExists(c->argv[1]->ptr)) {
+            /* This script is not in our script cache, replicate it as
+             * EVAL, then add it into the script cache, as from now on
+             * slaves and AOF know about it. */
+            robj *script = dictFetchValue(server.lua_scripts,c->argv[1]->ptr);
+
+            replicationScriptCacheAdd(c->argv[1]->ptr);
+            redisAssertWithInfo(c,NULL,script != NULL);
+            rewriteClientCommandArgument(c,0,
+                resetRefCount(createStringObject("EVAL",4)));
+            rewriteClientCommandArgument(c,1,script);
+        }
     }
 }
 
 void evalCommand(redisClient *c) {
     evalGenericCommand(c,0);
 }
@@ -975,13 +1022,14 @@
  * ------------------------------------------------------------------------- */
 
 void scriptCommand(redisClient *c) {
     if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"flush")) {
         scriptingReset();
         addReply(c,shared.ok);
-        server.dirty++; /* Replicating this command is a good idea. */
+        replicationScriptCacheFlush();
+        server.dirty++; /* Propagating this command is a good idea. */
     } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,"exists")) {
         int j;
 
         addReplyMultiBulkLen(c, c->argc-2);
         for (j = 2; j < c->argc; j++) {
             if (dictFind(server.lua_scripts,c->argv[j]->ptr))
@@ -1003,12 +1051,13 @@
                 sdsfree(sha);
                 return;
             }
         }
         addReplyBulkCBuffer(c,funcname+2,40);
         sdsfree(sha);
+        forceCommandPropagation(c,REDIS_PROPAGATE_REPL|REDIS_PROPAGATE_AOF);
     } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"kill")) {
         if (server.lua_caller == NULL) {
             addReplySds(c,sdsnew("-NOTBUSY No scripts in execution right now.\r\n"));
         } else if (server.lua_write_dirty) {
             addReplySds(c,sdsnew("-UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in an hard way using the SHUTDOWN NOSAVE command.\r\n"));
         } else {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/scripting.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/scripting.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/scripting.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/scripting.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.c	2013-11-22 17:25:29.000000000 +0800
@@ -33,12 +33,24 @@
 #include <string.h>
 #include <ctype.h>
 #include <assert.h>
 #include "sds.h"
 #include "zmalloc.h"
 
+/* Create a new sds string with the content specified by the 'init' pointer
+ * and 'initlen'.
+ * If NULL is used for 'init' the string is initialized with zero bytes.
+ *
+ * The string is always null-termined (all the sds strings are, always) so
+ * even if you create an sds string with:
+ *
+ * mystring = sdsnewlen("abc",3");
+ *
+ * You can print the string with printf() as there is an implicit \0 at the
+ * end of the string. However the string is binary safe and can contain
+ * \0 characters in the middle, as the length is stored in the sds header. */
 sds sdsnewlen(const void *init, size_t initlen) {
     struct sdshdr *sh;
 
     if (init) {
         sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
     } else {
@@ -50,49 +62,72 @@
     if (initlen && init)
         memcpy(sh->buf, init, initlen);
     sh->buf[initlen] = '\0';
     return (char*)sh->buf;
 }
 
+/* Create an empty (zero length) sds string. Even in this case the string
+ * always has an implicit null term. */
 sds sdsempty(void) {
     return sdsnewlen("",0);
 }
 
+/* Create a new sds string starting from a null termined C string. */
 sds sdsnew(const char *init) {
     size_t initlen = (init == NULL) ? 0 : strlen(init);
     return sdsnewlen(init, initlen);
 }
 
+/* Duplicate an sds string. */
 sds sdsdup(const sds s) {
     return sdsnewlen(s, sdslen(s));
 }
 
+/* Free an sds string. No operation is performed if 's' is NULL. */
 void sdsfree(sds s) {
     if (s == NULL) return;
     zfree(s-sizeof(struct sdshdr));
 }
 
+/* Set the sds string length to the length as obtained with strlen(), so
+ * considering as content only up to the first null term character.
+ *
+ * This function is useful when the sds string is hacked manually in some
+ * way, like in the following example:
+ *
+ * s = sdsnew("foobar");
+ * s[2] = '\0';
+ * sdsupdatelen(s);
+ * printf("%d\n", sdslen(s));
+ *
+ * The output will be "2", but if we comment out the call to sdsupdatelen()
+ * the output will be "6" as the string was modified but the logical length
+ * remains 6 bytes. */
 void sdsupdatelen(sds s) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     int reallen = strlen(s);
     sh->free += (sh->len-reallen);
     sh->len = reallen;
 }
 
+/* Modify an sds string on-place to make it empty (zero length).
+ * However all the existing buffer is not discarded but set as free space
+ * so that next append operations will not require allocations up to the
+ * number of bytes previously available. */
 void sdsclear(sds s) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     sh->free += sh->len;
     sh->len = 0;
     sh->buf[0] = '\0';
 }
 
 /* Enlarge the free space at the end of the sds string so that the caller
  * is sure that after calling this function can overwrite up to addlen
  * bytes after the end of the string, plus one more byte for nul term.
  * 
- * Note: this does not change the *size* of the sds string as returned
+ * Note: this does not change the *length* of the sds string as returned
  * by sdslen(), but only the free buffer space we have. */
 sds sdsMakeRoomFor(sds s, size_t addlen) {
     struct sdshdr *sh, *newsh;
     size_t free = sdsavail(s);
     size_t len, newlen;
 
@@ -110,61 +145,76 @@
     newsh->free = newlen - len;
     return newsh->buf;
 }
 
 /* Reallocate the sds string so that it has no free space at the end. The
  * contained string remains not altered, but next concatenation operations
- * will require a reallocation. */
+ * will require a reallocation.
+ *
+ * After the call, the passed sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
 sds sdsRemoveFreeSpace(sds s) {
     struct sdshdr *sh;
 
     sh = (void*) (s-(sizeof(struct sdshdr)));
     sh = zrealloc(sh, sizeof(struct sdshdr)+sh->len+1);
     sh->free = 0;
     return sh->buf;
 }
 
+/* Return the total size of the allocation of the specifed sds string,
+ * including:
+ * 1) The sds header before the pointer.
+ * 2) The string.
+ * 3) The free buffer at the end if any.
+ * 4) The implicit null term.
+ */
 size_t sdsAllocSize(sds s) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
 
     return sizeof(*sh)+sh->len+sh->free+1;
 }
 
 /* Increment the sds length and decrements the left free space at the
- * end of the string accordingly to 'incr'. Also set the null term
+ * end of the string according to 'incr'. Also set the null term
  * in the new end of the string.
  *
  * This function is used in order to fix the string length after the
  * user calls sdsMakeRoomFor(), writes something after the end of
  * the current string, and finally needs to set the new length.
  *
  * Note: it is possible to use a negative increment in order to
  * right-trim the string.
  *
+ * Usage example:
+ *
  * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the
- * following schema to cat bytes coming from the kernel to the end of an
- * sds string new things without copying into an intermediate buffer:
+ * following schema, to cat bytes coming from the kernel to the end of an
+ * sds string without copying into an intermediate buffer:
  *
  * oldlen = sdslen(s);
  * s = sdsMakeRoomFor(s, BUFFER_SIZE);
  * nread = read(fd, s+oldlen, BUFFER_SIZE);
  * ... check for nread <= 0 and handle it ...
- * sdsIncrLen(s, nhread);
+ * sdsIncrLen(s, nread);
  */
 void sdsIncrLen(sds s, int incr) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
 
     assert(sh->free >= incr);
     sh->len += incr;
     sh->free -= incr;
     assert(sh->free >= 0);
     s[sh->len] = '\0';
 }
 
 /* Grow the sds to have the specified length. Bytes that were not part of
- * the original length of the sds will be set to zero. */
+ * the original length of the sds will be set to zero.
+ *
+ * if the specified length is smaller than the current length, no operation
+ * is performed. */
 sds sdsgrowzero(sds s, size_t len) {
     struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
     size_t totlen, curlen = sh->len;
 
     if (len <= curlen) return s;
     s = sdsMakeRoomFor(s,len-curlen);
@@ -176,12 +226,17 @@
     totlen = sh->len+sh->free;
     sh->len = len;
     sh->free = totlen-sh->len;
     return s;
 }
 
+/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the
+ * end of the specified sds string 's'.
+ *
+ * After the call, the passed sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
 sds sdscatlen(sds s, const void *t, size_t len) {
     struct sdshdr *sh;
     size_t curlen = sdslen(s);
 
     s = sdsMakeRoomFor(s,len);
     if (s == NULL) return NULL;
@@ -190,20 +245,30 @@
     sh->len = curlen+len;
     sh->free = sh->free-len;
     s[curlen+len] = '\0';
     return s;
 }
 
+/* Append the specified null termianted C string to the sds string 's'.
+ *
+ * After the call, the passed sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
 sds sdscat(sds s, const char *t) {
     return sdscatlen(s, t, strlen(t));
 }
 
+/* Append the specified sds 't' to the existing sds 's'.
+ *
+ * After the call, the modified sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
 sds sdscatsds(sds s, const sds t) {
     return sdscatlen(s, t, sdslen(t));
 }
 
+/* Destructively modify the sds string 's' to hold the specified binary
+ * safe string pointed by 't' of length 'len' bytes. */
 sds sdscpylen(sds s, const char *t, size_t len) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     size_t totlen = sh->free+sh->len;
 
     if (totlen < len) {
         s = sdsMakeRoomFor(s,len-sh->len);
@@ -215,16 +280,19 @@
     s[len] = '\0';
     sh->len = len;
     sh->free = totlen-len;
     return s;
 }
 
+/* Like sdscpylen() but 't' must be a null-termined string so that the length
+ * of the string is obtained with strlen(). */
 sds sdscpy(sds s, const char *t) {
     return sdscpylen(s, t, strlen(t));
 }
 
+/* Like sdscatpritf() but gets va_list instead of being variadic. */
 sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
     va_list cpy;
     char *buf, *t;
     size_t buflen = 16;
 
     while(1) {
@@ -242,21 +310,51 @@
     }
     t = sdscat(s, buf);
     zfree(buf);
     return t;
 }
 
+/* Append to the sds string 's' a string obtained using printf-alike format
+ * specifier.
+ *
+ * After the call, the modified sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call.
+ *
+ * Example:
+ *
+ * s = sdsempty("Sum is: ");
+ * s = sdscatprintf(s,"%d+%d = %d",a,b,a+b).
+ *
+ * Often you need to create a string from scratch with the printf-alike
+ * format. When this is the need, just use sdsempty() as the target string:
+ *
+ * s = sdscatprintf(sdsempty(), "... your format ...", args);
+ */
 sds sdscatprintf(sds s, const char *fmt, ...) {
     va_list ap;
     char *t;
     va_start(ap, fmt);
     t = sdscatvprintf(s,fmt,ap);
     va_end(ap);
     return t;
 }
 
+/* Remove the part of the string from left and from right composed just of
+ * contiguous characters found in 'cset', that is a null terminted C string.
+ *
+ * After the call, the modified sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call.
+ *
+ * Example:
+ *
+ * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");
+ * s = sdstrim(s,"A. :");
+ * printf("%s\n", s);
+ *
+ * Output will be just "Hello World".
+ */
 sds sdstrim(sds s, const char *cset) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     char *start, *end, *sp, *ep;
     size_t len;
 
     sp = start = s;
@@ -268,17 +366,33 @@
     sh->buf[len] = '\0';
     sh->free = sh->free+(sh->len-len);
     sh->len = len;
     return s;
 }
 
-sds sdsrange(sds s, int start, int end) {
+/* Turn the string into a smaller (or equal) string containing only the
+ * substring specified by the 'start' and 'end' indexes.
+ *
+ * start and end can be negative, where -1 means the last character of the
+ * string, -2 the penultimate character, and so forth.
+ *
+ * The interval is inclusive, so the start and end characters will be part
+ * of the resulting string.
+ *
+ * The string is modified in-place.
+ *
+ * Example:
+ *
+ * s = sdsnew("Hello World");
+ * sdstrim(s,1,-1); => "ello Worl"
+ */
+void sdsrange(sds s, int start, int end) {
     struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
     size_t newlen, len = sdslen(s);
 
-    if (len == 0) return s;
+    if (len == 0) return;
     if (start < 0) {
         start = len+start;
         if (start < 0) start = 0;
     }
     if (end < 0) {
         end = len+end;
@@ -296,27 +410,39 @@
         start = 0;
     }
     if (start && newlen) memmove(sh->buf, sh->buf+start, newlen);
     sh->buf[newlen] = 0;
     sh->free = sh->free+(sh->len-newlen);
     sh->len = newlen;
-    return s;
 }
 
+/* Apply tolower() to every character of the sds string 's'. */
 void sdstolower(sds s) {
     int len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = tolower(s[j]);
 }
 
+/* Apply toupper() to every character of the sds string 's'. */
 void sdstoupper(sds s) {
     int len = sdslen(s), j;
 
     for (j = 0; j < len; j++) s[j] = toupper(s[j]);
 }
 
+/* Compare two sds strings s1 and s2 with memcmp().
+ *
+ * Return value:
+ *
+ *     1 if s1 > s2.
+ *    -1 if s1 < s2.
+ *     0 if s1 and s2 are exactly the same binary string.
+ *
+ * If two strings share exactly the same prefix, but one of the two has
+ * additional characters, the longer string is considered to be greater than
+ * the smaller one. */
 int sdscmp(const sds s1, const sds s2) {
     size_t l1, l2, minlen;
     int cmp;
 
     l1 = sdslen(s1);
     l2 = sdslen(s2);
@@ -388,19 +514,24 @@
         zfree(tokens);
         *count = 0;
         return NULL;
     }
 }
 
+/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */
 void sdsfreesplitres(sds *tokens, int count) {
     if (!tokens) return;
     while(count--)
         sdsfree(tokens[count]);
     zfree(tokens);
 }
 
+/* Create an sds string from a long long value. It is much faster than:
+ *
+ * sdscatprintf(sdsempty(),"%lld\n", value);
+ */
 sds sdsfromlonglong(long long value) {
     char buf[32], *p;
     unsigned long long v;
 
     v = (value < 0) ? -value : value;
     p = buf+31; /* point to the last character */
@@ -410,12 +541,18 @@
     } while(v);
     if (value < 0) *p-- = '-';
     p++;
     return sdsnewlen(p,32-(p-buf));
 }
 
+/* Append to the sds string "s" an escaped string representation where
+ * all the non-printable characters (tested with isprint()) are turned into
+ * escapes in the form "\n\r\a...." or "\x<hex-number>".
+ *
+ * After the call, the modified sds string is no longer valid and all the
+ * references must be substituted with the new pointer returned by the call. */
 sds sdscatrepr(sds s, const char *p, size_t len) {
     s = sdscatlen(s,"\"",1);
     while(len--) {
         switch(*p) {
         case '\\':
         case '"':
@@ -618,12 +755,25 @@
             }
         }
     }
     return s;
 }
 
+/* Join an array of C strings using the specified separator (also a C string).
+ * Returns the result as an sds string. */
+sds sdsjoin(char **argv, int argc, char *sep) {
+    sds join = sdsempty();
+    int j;
+
+    for (j = 0; j < argc; j++) {
+        join = sdscat(join, argv[j]);
+        if (j != argc-1) join = sdscat(join,sep);
+    }
+    return join;
+}
+
 #ifdef SDS_TEST_MAIN
 #include <stdio.h>
 #include "testhelp.h"
 
 int main(void) {
     {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.h	2013-11-22 17:25:29.000000000 +0800
@@ -74,24 +74,25 @@
     __attribute__((format(printf, 2, 3)));
 #else
 sds sdscatprintf(sds s, const char *fmt, ...);
 #endif
 
 sds sdstrim(sds s, const char *cset);
-sds sdsrange(sds s, int start, int end);
+void sdsrange(sds s, int start, int end);
 void sdsupdatelen(sds s);
 void sdsclear(sds s);
 int sdscmp(const sds s1, const sds s2);
 sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);
 void sdsfreesplitres(sds *tokens, int count);
 void sdstolower(sds s);
 void sdstoupper(sds s);
 sds sdsfromlonglong(long long value);
 sds sdscatrepr(sds s, const char *p, size_t len);
 sds *sdssplitargs(const char *line, int *argc);
 sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);
+sds sdsjoin(char **argv, int argc, char *sep);
 
 /* Low level functions exposed to the user API */
 sds sdsMakeRoomFor(sds s, size_t addlen);
 void sdsIncrLen(sds s, int incr);
 sds sdsRemoveFreeSpace(sds s);
 size_t sdsAllocSize(sds s);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sds.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sds.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sentinel.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sentinel.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sentinel.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sentinel.c	2013-11-22 17:25:29.000000000 +0800
@@ -33,12 +33,13 @@
 #include "async.h"
 
 #include <ctype.h>
 #include <arpa/inet.h>
 #include <sys/socket.h>
 #include <sys/wait.h>
+#include <fcntl.h>
 
 extern char **environ;
 
 #define REDIS_SENTINEL_PORT 26379
 
 /* ======================== Sentinel global state =========================== */
@@ -54,76 +55,60 @@
 /* A Sentinel Redis Instance object is monitoring. */
 #define SRI_MASTER  (1<<0)
 #define SRI_SLAVE   (1<<1)
 #define SRI_SENTINEL (1<<2)
 #define SRI_DISCONNECTED (1<<3)
 #define SRI_S_DOWN (1<<4)   /* Subjectively down (no quorum). */
-#define SRI_O_DOWN (1<<5)   /* Objectively down (quorum reached). */
+#define SRI_O_DOWN (1<<5)   /* Objectively down (confirmed by others). */
 #define SRI_MASTER_DOWN (1<<6) /* A Sentinel with this flag set thinks that
                                    its master is down. */
-/* SRI_CAN_FAILOVER when set in an SRI_MASTER instance means that we are
- * allowed to perform the failover for this master.
- * When set in a SRI_SENTINEL instance means that sentinel is allowed to
- * perform the failover on its master. */
-#define SRI_CAN_FAILOVER (1<<7)
-#define SRI_FAILOVER_IN_PROGRESS (1<<8) /* Failover is in progress for
+#define SRI_FAILOVER_IN_PROGRESS (1<<7) /* Failover is in progress for
                                            this master. */
-#define SRI_I_AM_THE_LEADER (1<<9)     /* We are the leader for this master. */
-#define SRI_PROMOTED (1<<10)            /* Slave selected for promotion. */
-#define SRI_RECONF_SENT (1<<11)     /* SLAVEOF <newmaster> sent. */
-#define SRI_RECONF_INPROG (1<<12)   /* Slave synchronization in progress. */
-#define SRI_RECONF_DONE (1<<13)     /* Slave synchronized with new master. */
-#define SRI_FORCE_FAILOVER (1<<14)  /* Force failover with master up. */
-#define SRI_SCRIPT_KILL_SENT (1<<15) /* SCRIPT KILL already sent on -BUSY */
-#define SRI_DEMOTE (1<<16)   /* If the instance claims to be a master, demote
-                                it into a slave sending SLAVEOF. */
+#define SRI_PROMOTED (1<<8)            /* Slave selected for promotion. */
+#define SRI_RECONF_SENT (1<<9)     /* SLAVEOF <newmaster> sent. */
+#define SRI_RECONF_INPROG (1<<10)   /* Slave synchronization in progress. */
+#define SRI_RECONF_DONE (1<<11)     /* Slave synchronized with new master. */
+#define SRI_FORCE_FAILOVER (1<<12)  /* Force failover with master up. */
+#define SRI_SCRIPT_KILL_SENT (1<<13) /* SCRIPT KILL already sent on -BUSY */
 
+/* Note: times are in milliseconds. */
 #define SENTINEL_INFO_PERIOD 10000
 #define SENTINEL_PING_PERIOD 1000
 #define SENTINEL_ASK_PERIOD 1000
-#define SENTINEL_PUBLISH_PERIOD 5000
-#define SENTINEL_DOWN_AFTER_PERIOD 30000
+#define SENTINEL_PUBLISH_PERIOD 2000
+#define SENTINEL_DEFAULT_DOWN_AFTER 30000
 #define SENTINEL_HELLO_CHANNEL "__sentinel__:hello"
 #define SENTINEL_TILT_TRIGGER 2000
 #define SENTINEL_TILT_PERIOD (SENTINEL_PING_PERIOD*30)
 #define SENTINEL_DEFAULT_SLAVE_PRIORITY 100
-#define SENTINEL_PROMOTION_RETRY_PERIOD 30000
 #define SENTINEL_SLAVE_RECONF_RETRY_PERIOD 10000
 #define SENTINEL_DEFAULT_PARALLEL_SYNCS 1
 #define SENTINEL_MIN_LINK_RECONNECT_PERIOD 15000
-#define SENTINEL_DEFAULT_FAILOVER_TIMEOUT (60*15*1000)
+#define SENTINEL_DEFAULT_FAILOVER_TIMEOUT (60*3*1000)
 #define SENTINEL_MAX_PENDING_COMMANDS 100
-#define SENTINEL_EXTENDED_SDOWN_MULTIPLIER 10
-
-/* How many milliseconds is an information valid? This applies for instance
- * to the reply to SENTINEL IS-MASTER-DOWN-BY-ADDR replies. */
-#define SENTINEL_INFO_VALIDITY_TIME 5000
-#define SENTINEL_FAILOVER_FIXED_DELAY 5000
-#define SENTINEL_FAILOVER_MAX_RANDOM_DELAY 10000
+#define SENTINEL_ELECTION_TIMEOUT 10000
 
 /* Failover machine different states. */
 #define SENTINEL_FAILOVER_STATE_NONE 0  /* No failover in progress. */
 #define SENTINEL_FAILOVER_STATE_WAIT_START 1  /* Wait for failover_start_time*/ 
 #define SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2 /* Select slave to promote */
 #define SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 /* Slave -> Master */
 #define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4 /* Wait slave to change role */
 #define SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5 /* SLAVEOF newmaster */
-#define SENTINEL_FAILOVER_STATE_WAIT_NEXT_SLAVE 6 /* wait replication */
-#define SENTINEL_FAILOVER_STATE_ALERT_CLIENTS 7 /* Run user script. */
-#define SENTINEL_FAILOVER_STATE_WAIT_ALERT_SCRIPT 8 /* Wait script exec. */
-#define SENTINEL_FAILOVER_STATE_DETECT_END 9 /* Check for failover end. */
-#define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 10 /* Monitor promoted slave. */
+#define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6 /* Monitor promoted slave. */
 
 #define SENTINEL_MASTER_LINK_STATUS_UP 0
 #define SENTINEL_MASTER_LINK_STATUS_DOWN 1
 
-/* Generic flags that can be used with different functions. */
+/* Generic flags that can be used with different functions.
+ * They use higher bits to avoid colliding with the function specific
+ * flags. */
 #define SENTINEL_NO_FLAGS 0
-#define SENTINEL_GENERATE_EVENT 1
-#define SENTINEL_LEADER 2
-#define SENTINEL_OBSERVER 4
+#define SENTINEL_GENERATE_EVENT (1<<16)
+#define SENTINEL_LEADER (1<<17)
+#define SENTINEL_OBSERVER (1<<18)
 
 /* Script execution flags and limits. */
 #define SENTINEL_SCRIPT_NONE 0
 #define SENTINEL_SCRIPT_RUNNING 1
 #define SENTINEL_SCRIPT_MAX_QUEUE 256
 #define SENTINEL_SCRIPT_MAX_RUNNING 16
@@ -132,12 +117,13 @@
 #define SENTINEL_SCRIPT_RETRY_DELAY 30000 /* 30 seconds between retries. */
 
 typedef struct sentinelRedisInstance {
     int flags;      /* See SRI_... defines */
     char *name;     /* Master name from the point of view of this sentinel. */
     char *runid;    /* run ID of this instance. */
+    uint64_t config_epoch;  /* Configuration epoch. */
     sentinelAddr *addr; /* Master host. */
     redisAsyncContext *cc; /* Hiredis context for commands. */
     redisAsyncContext *pc; /* Hiredis context for Pub / Sub. */
     int pending_commands;   /* Number of commands sent waiting for a reply. */
     mstime_t cc_conn_time; /* cc connection time. */
     mstime_t pc_conn_time; /* pc connection time. */
@@ -155,54 +141,65 @@
                                              SENTINEL is-master-down command. */
     mstime_t s_down_since_time; /* Subjectively down since time. */
     mstime_t o_down_since_time; /* Objectively down since time. */
     mstime_t down_after_period; /* Consider it down after that period. */
     mstime_t info_refresh;  /* Time at which we received INFO output from it. */
 
+    /* Role and the first time we observed it.
+     * This is useful in order to delay replacing what the instance reports
+     * with our own configuration. We need to always wait some time in order
+     * to give a chance to the leader to report the new configuration before
+     * we do silly things. */
+    int role_reported;
+    mstime_t role_reported_time;
+    mstime_t slave_conf_change_time; /* Last time slave master addr changed. */
+
     /* Master specific. */
     dict *sentinels;    /* Other sentinels monitoring the same master. */
     dict *slaves;       /* Slaves for this master instance. */
     int quorum;         /* Number of sentinels that need to agree on failure. */
     int parallel_syncs; /* How many slaves to reconfigure at same time. */
     char *auth_pass;    /* Password to use for AUTH against master & slaves. */
 
     /* Slave specific. */
     mstime_t master_link_down_time; /* Slave replication link down time. */
     int slave_priority; /* Slave priority according to its INFO output. */
     mstime_t slave_reconf_sent_time; /* Time at which we sent SLAVE OF <new> */
-    struct sentinelRedisInstance *master; /* Master instance if SRI_SLAVE is set. */
+    struct sentinelRedisInstance *master; /* Master instance if it's slave. */
     char *slave_master_host;    /* Master host as reported by INFO */
     int slave_master_port;      /* Master port as reported by INFO */
     int slave_master_link_status; /* Master link status as reported by INFO */
+    unsigned long long slave_repl_offset; /* Slave replication offset. */
     /* Failover */
     char *leader;       /* If this is a master instance, this is the runid of
                            the Sentinel that should perform the failover. If
                            this is a Sentinel, this is the runid of the Sentinel
-                           that this other Sentinel is voting as leader.
-                           This field is valid only if SRI_MASTER_DOWN is
-                           set on the Sentinel instance. */
+                           that this Sentinel voted as leader. */
+    uint64_t leader_epoch; /* Epoch of the 'leader' field. */
+    uint64_t failover_epoch; /* Epoch of the currently started failover. */
     int failover_state; /* See SENTINEL_FAILOVER_STATE_* defines. */
     mstime_t failover_state_change_time;
-    mstime_t failover_start_time;   /* When to start to failover if leader. */
+    mstime_t failover_start_time;   /* Last failover attempt start time. */
     mstime_t failover_timeout;      /* Max time to refresh failover state. */
     struct sentinelRedisInstance *promoted_slave; /* Promoted slave instance. */
     /* Scripts executed to notify admin or reconfigure clients: when they
      * are set to NULL no script is executed. */
     char *notification_script;
     char *client_reconfig_script;
 } sentinelRedisInstance;
 
 /* Main state. */
 struct sentinelState {
+    uint64_t current_epoch;     /* Current epoch. */
     dict *masters;      /* Dictionary of master sentinelRedisInstances.
                            Key is the instance name, value is the
                            sentinelRedisInstance structure pointer. */
     int tilt;           /* Are we in TILT mode? */
     int running_scripts;    /* Number of scripts in execution right now. */
     mstime_t tilt_start_time;   /* When TITL started. */
-    mstime_t previous_time;     /* Time last time we ran the time handler. */
+    mstime_t previous_time;     /* Last time we ran the time handler. */
     list *scripts_queue;    /* Queue of user scripts to execute. */
 } sentinel;
 
 /* A script execution job. */
 typedef struct sentinelScriptJob {
     int flags;              /* Script job flags: SENTINEL_SCRIPT_* */
@@ -324,14 +321,17 @@
 void sentinelKillLink(sentinelRedisInstance *ri, redisAsyncContext *c);
 const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri);
 void sentinelAbortFailover(sentinelRedisInstance *ri);
 void sentinelEvent(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...);
 sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master);
 void sentinelScheduleScriptExecution(char *path, ...);
-void sentinelStartFailover(sentinelRedisInstance *master, int state);
+void sentinelStartFailover(sentinelRedisInstance *master);
 void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata);
+int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port);
+char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch);
+void sentinelFlushConfig(void);
 
 /* ========================= Dictionary types =============================== */
 
 unsigned int dictSdsHash(const void *key);
 int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
 void releaseSentinelRedisInstance(sentinelRedisInstance *ri);
@@ -400,20 +400,32 @@
 
         retval = dictAdd(server.commands, sdsnew(cmd->name), cmd);
         redisAssert(retval == DICT_OK);
     }
 
     /* Initialize various data structures. */
+    sentinel.current_epoch = 0;
     sentinel.masters = dictCreate(&instancesDictType,NULL);
     sentinel.tilt = 0;
     sentinel.tilt_start_time = 0;
     sentinel.previous_time = mstime();
     sentinel.running_scripts = 0;
     sentinel.scripts_queue = listCreate();
 }
 
+/* This function gets called when the server is in Sentinel mode, started,
+ * loaded the configuration, and is ready for normal operations. */
+void sentinelIsRunning(void) {
+    redisLog(REDIS_WARNING,"Sentinel runid is %s", server.runid);
+
+    if (server.configfile == NULL || access(server.configfile,W_OK) == -1) {
+        redisLog(REDIS_WARNING,"Sentinel started without a config file, or config file not writable. Exiting...");
+        exit(1);
+    }
+}
+
 /* ============================== sentinelAddr ============================== */
 
 /* Create a sentinelAddr object and return it on success.
  * On error NULL is returned and errno is set to:
  *  ENOENT: Can't resolve the hostname.
  *  EINVAL: Invalid port number.
@@ -423,28 +435,43 @@
     sentinelAddr *sa;
 
     if (port <= 0 || port > 65535) {
         errno = EINVAL;
         return NULL;
     }
-    if (anetResolve(NULL,hostname,buf) == ANET_ERR) {
+    if (anetResolve(NULL,hostname,buf,sizeof(buf)) == ANET_ERR) {
         errno = ENOENT;
         return NULL;
     }
     sa = zmalloc(sizeof(*sa));
     sa->ip = sdsnew(buf);
     sa->port = port;
     return sa;
 }
 
+/* Return a duplicate of the source address. */
+sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
+    sentinelAddr *sa;
+
+    sa = zmalloc(sizeof(*sa));
+    sa->ip = sdsnew(src->ip);
+    sa->port = src->port;
+    return sa;
+}
+
 /* Free a Sentinel address. Can't fail. */
 void releaseSentinelAddr(sentinelAddr *sa) {
     sdsfree(sa->ip);
     zfree(sa);
 }
 
+/* Return non-zero if two addresses are equal. */
+int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {
+    return a->port == b->port && !strcasecmp(a->ip,b->ip);
+}
+
 /* =========================== Events notification ========================== */
 
 /* Send an event to log, pub/sub, user notification script.
  * 
  * 'level' is the log level for logging. Only REDIS_WARNING events will trigger
  * the execution of the user notification script.
@@ -774,21 +801,19 @@
 
 /* This function calls, if any, the client reconfiguration script with the
  * following parameters:
  *
  * <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>
  *
- * It is called every time a failover starts, ends, or is aborted.
+ * It is called every time a failover is performed.
  *
- * <state> is "start", "end" or "abort".
+ * <state> is currently always "failover".
  * <role> is either "leader" or "observer".
  *
  * from/to fields are respectively master -> promoted slave addresses for
- * "start" and "end", or the reverse (promoted slave -> master) in case of
- * "abort".
- */
+ * "start" and "end". */
 void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {
     char fromport[32], toport[32];
 
     if (master->client_reconfig_script == NULL) return;
     ll2string(fromport,sizeof(fromport),from->port);
     ll2string(toport,sizeof(toport),to->port);
@@ -832,13 +857,15 @@
     /* Check address validity. */
     addr = createSentinelAddr(hostname,port);
     if (addr == NULL) return NULL;
 
     /* For slaves and sentinel we use ip:port as name. */
     if (flags & (SRI_SLAVE|SRI_SENTINEL)) {
-        snprintf(slavename,sizeof(slavename),"%s:%d",hostname,port);
+        snprintf(slavename,sizeof(slavename),
+            strchr(hostname,':') ? "[%s]:%d" : "%s:%d",
+            hostname,port);
         name = slavename;
     }
 
     /* Make sure the entry is not duplicated. This may happen when the same
      * name for a master is used multiple times inside the configuration or
      * if we try to add multiple times a slave or sentinel with same ip/port
@@ -857,12 +884,13 @@
     ri = zmalloc(sizeof(*ri));
     /* Note that all the instances are started in the disconnected state,
      * the event loop will take care of connecting them. */
     ri->flags = flags | SRI_DISCONNECTED;
     ri->name = sdsname;
     ri->runid = NULL;
+    ri->config_epoch = 0;
     ri->addr = addr;
     ri->cc = NULL;
     ri->pc = NULL;
     ri->pending_commands = 0;
     ri->cc_conn_time = 0;
     ri->pc_conn_time = 0;
@@ -872,37 +900,45 @@
     ri->last_pub_time = mstime();
     ri->last_hello_time = mstime();
     ri->last_master_down_reply_time = mstime();
     ri->s_down_since_time = 0;
     ri->o_down_since_time = 0;
     ri->down_after_period = master ? master->down_after_period :
-                            SENTINEL_DOWN_AFTER_PERIOD;
+                            SENTINEL_DEFAULT_DOWN_AFTER;
     ri->master_link_down_time = 0;
     ri->auth_pass = NULL;
     ri->slave_priority = SENTINEL_DEFAULT_SLAVE_PRIORITY;
     ri->slave_reconf_sent_time = 0;
     ri->slave_master_host = NULL;
     ri->slave_master_port = 0;
     ri->slave_master_link_status = SENTINEL_MASTER_LINK_STATUS_DOWN;
+    ri->slave_repl_offset = 0;
     ri->sentinels = dictCreate(&instancesDictType,NULL);
     ri->quorum = quorum;
     ri->parallel_syncs = SENTINEL_DEFAULT_PARALLEL_SYNCS;
     ri->master = master;
     ri->slaves = dictCreate(&instancesDictType,NULL);
     ri->info_refresh = 0;
 
     /* Failover state. */
     ri->leader = NULL;
+    ri->leader_epoch = 0;
+    ri->failover_epoch = 0;
     ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
     ri->failover_state_change_time = 0;
     ri->failover_start_time = 0;
     ri->failover_timeout = SENTINEL_DEFAULT_FAILOVER_TIMEOUT;
     ri->promoted_slave = NULL;
     ri->notification_script = NULL;
     ri->client_reconfig_script = NULL;
 
+    /* Role */
+    ri->role_reported = ri->flags & (SRI_MASTER|SRI_SLAVE);
+    ri->role_reported_time = mstime();
+    ri->slave_conf_change_time = mstime();
+
     /* Add into the right table. */
     dictAdd(table, ri->name, ri);
     return ri;
 }
 
 /* Release this instance and all its slaves, sentinels, hiredis connections.
@@ -940,13 +976,15 @@
                 sentinelRedisInstance *ri, char *ip, int port)
 {
     sds key;
     sentinelRedisInstance *slave;
   
     redisAssert(ri->flags & SRI_MASTER);
-    key = sdscatprintf(sdsempty(),"%s:%d",ip,port);
+    key = sdscatprintf(sdsempty(),
+        strchr(ip,':') ? "[%s]:%d" : "%s:%d",
+        ip,port);
     slave = dictFetchValue(ri->slaves,key);
     sdsfree(key);
     return slave;
 }
 
 /* Return the name of the type of the instance as a string. */
@@ -954,31 +992,27 @@
     if (ri->flags & SRI_MASTER) return "master";
     else if (ri->flags & SRI_SLAVE) return "slave";
     else if (ri->flags & SRI_SENTINEL) return "sentinel";
     else return "unknown";
 }
 
-/* This function removes all the instances found in the dictionary of instances
- * 'd', having either:
+/* This function removes all the instances found in the dictionary of
+ * sentinels in the specified 'master', having either:
  * 
  * 1) The same ip/port as specified.
  * 2) The same runid.
  *
  * "1" and "2" don't need to verify at the same time, just one is enough.
  * If "runid" is NULL it is not checked.
  * Similarly if "ip" is NULL it is not checked.
  *
  * This function is useful because every time we add a new Sentinel into
  * a master's Sentinels dictionary, we want to be very sure about not
- * having duplicated instances for any reason. This is so important because
- * we use those other sentinels in order to run our quorum protocol to
- * understand if it's time to proceed with the fail over.
- *
- * Making sure no duplication is possible we greatly improve the robustness
- * of the quorum (otherwise we may end counting the same instance multiple
- * times for some reason).
+ * having duplicated instances for any reason. This is important because
+ * other sentinels are needed to reach ODOWN quorum, and later to get
+ * voted for a given configuration epoch in order to perform the failover.
  *
  * The function returns the number of Sentinels removed. */
 int removeMatchingSentinelsFromMaster(sentinelRedisInstance *master, char *ip, int port, char *runid) {
     dictIterator *di;
     dictEntry *de;
     int removed = 0;
@@ -1024,13 +1058,13 @@
         }
     }
     dictReleaseIterator(di);
     return instance;
 }
 
-/* Simple master lookup by name */
+/* Master lookup by name */
 sentinelRedisInstance *sentinelGetMasterByName(char *name) {
     sentinelRedisInstance *ri;
     sds sdsname = sdsnew(name);
 
     ri = dictFetchValue(sentinel.masters,sdsname);
     sdsfree(sdsname);
@@ -1069,21 +1103,25 @@
  * 2) Remove all sentinels.
  * 3) Remove most of the flags resulting from runtime operations.
  * 4) Reset timers to their default value.
  * 5) In the process of doing this undo the failover if in progress.
  * 6) Disconnect the connections with the master (will reconnect automatically).
  */
+
+#define SENTINEL_RESET_NO_SENTINELS (1<<0)
 void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
     redisAssert(ri->flags & SRI_MASTER);
     dictRelease(ri->slaves);
-    dictRelease(ri->sentinels);
     ri->slaves = dictCreate(&instancesDictType,NULL);
-    ri->sentinels = dictCreate(&instancesDictType,NULL);
+    if (!(flags & SENTINEL_RESET_NO_SENTINELS)) {
+        dictRelease(ri->sentinels);
+        ri->sentinels = dictCreate(&instancesDictType,NULL);
+    }
     if (ri->cc) sentinelKillLink(ri,ri->cc);
     if (ri->pc) sentinelKillLink(ri,ri->pc);
-    ri->flags &= SRI_MASTER|SRI_CAN_FAILOVER|SRI_DISCONNECTED;
+    ri->flags &= SRI_MASTER|SRI_DISCONNECTED;
     if (ri->leader) {
         sdsfree(ri->leader);
         ri->leader = NULL;
     }
     ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
     ri->failover_state_change_time = 0;
@@ -1121,34 +1159,73 @@
     return reset;
 }
 
 /* Reset the specified master with sentinelResetMaster(), and also change
  * the ip:port address, but take the name of the instance unmodified.
  *
- * This is used to handle the +switch-master and +redirect-to-master events.
+ * This is used to handle the +switch-master event.
  *
  * The function returns REDIS_ERR if the address can't be resolved for some
- * reason. Otherwise REDIS_OK is returned.
- *
- * TODO: make this reset so that original sentinels are re-added with
- * same ip / port / runid.
- */
+ * reason. Otherwise REDIS_OK is returned.  */
 int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip, int port) {
     sentinelAddr *oldaddr, *newaddr;
+    sentinelAddr **slaves = NULL;
+    int numslaves = 0, j;
+    dictIterator *di;
+    dictEntry *de;
 
     newaddr = createSentinelAddr(ip,port);
     if (newaddr == NULL) return REDIS_ERR;
-    sentinelResetMaster(master,SENTINEL_NO_FLAGS);
+
+    /* Make a list of slaves to add back after the reset.
+     * Don't include the one having the address we are switching to. */
+    di = dictGetIterator(master->slaves);
+    while((de = dictNext(di)) != NULL) {
+        sentinelRedisInstance *slave = dictGetVal(de);
+
+        if (sentinelAddrIsEqual(slave->addr,newaddr)) continue;
+        slaves = zrealloc(slaves,sizeof(sentinelAddr*)*(numslaves+1));
+        slaves[numslaves++] = createSentinelAddr(slave->addr->ip,
+                                                 slave->addr->port);
+    }
+    dictReleaseIterator(di);
+    
+    /* If we are switching to a different address, include the old address
+     * as a slave as well, so that we'll be able to sense / reconfigure
+     * the old master. */
+    if (!sentinelAddrIsEqual(newaddr,master->addr)) {
+        slaves = zrealloc(slaves,sizeof(sentinelAddr*)*(numslaves+1));
+        slaves[numslaves++] = createSentinelAddr(master->addr->ip,
+                                                 master->addr->port);
+    }
+
+    /* Reset and switch address. */
+    sentinelResetMaster(master,SENTINEL_RESET_NO_SENTINELS);
     oldaddr = master->addr;
     master->addr = newaddr;
     master->o_down_since_time = 0;
     master->s_down_since_time = 0;
 
+    /* Add slaves back. */
+    for (j = 0; j < numslaves; j++) {
+        sentinelRedisInstance *slave;
+
+        slave = createSentinelRedisInstance(NULL,SRI_SLAVE,slaves[j]->ip,
+                    slaves[j]->port, master->quorum, master);
+        releaseSentinelAddr(slaves[j]);
+        if (slave) {
+            sentinelEvent(REDIS_NOTICE,"+slave",slave,"%@");
+            sentinelFlushConfig();
+        }
+    }
+    zfree(slaves);
+
     /* Release the old address at the end so we are safe even if the function
      * gets the master->addr->ip and master->addr->port as arguments. */
     releaseSentinelAddr(oldaddr);
+    sentinelFlushConfig();
     return REDIS_OK;
 }
 
 /* Return non-zero if there was no SDOWN or ODOWN error associated to this
  * instance in the latest 'ms' milliseconds. */
 int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {
@@ -1157,12 +1234,30 @@
     most_recent = ri->s_down_since_time;
     if (ri->o_down_since_time > most_recent)
         most_recent = ri->o_down_since_time;
     return most_recent == 0 || (mstime() - most_recent) > ms;
 }
 
+/* Return the current master address, that is, its address or the address
+ * of the promoted slave if already operational. */
+sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {
+    /* If we are failing over the master, and the state is already
+     * SENTINEL_FAILOVER_STATE_RECONF_SLAVES or greater, it means that we
+     * already have the new configuration epoch in the master, and the
+     * slave acknowledged the configuration switch. Advertise the new
+     * address. */
+    if ((master->flags & SRI_FAILOVER_IN_PROGRESS) &&
+        master->promoted_slave &&
+        master->failover_state >= SENTINEL_FAILOVER_STATE_RECONF_SLAVES)
+    {
+        return master->promoted_slave->addr;
+    } else {
+        return master->addr;
+    }
+}
+
 /* ============================ Config handling ============================= */
 char *sentinelHandleConfiguration(char **argv, int argc) {
     sentinelRedisInstance *ri;
 
     if (!strcasecmp(argv[0],"monitor") && argc == 5) {
         /* monitor <name> <host> <port> <quorum> */
@@ -1189,23 +1284,12 @@
         /* failover-timeout <name> <milliseconds> */
         ri = sentinelGetMasterByName(argv[1]);
         if (!ri) return "No such master with specified name.";
         ri->failover_timeout = atoi(argv[2]);
         if (ri->failover_timeout <= 0)
             return "negative or zero time parameter.";
-    } else if (!strcasecmp(argv[0],"can-failover") && argc == 3) {
-        /* can-failover <name> <yes/no> */
-        int yesno = yesnotoi(argv[2]);
-
-        ri = sentinelGetMasterByName(argv[1]);
-        if (!ri) return "No such master with specified name.";
-        if (yesno == -1) return "Argument must be either yes or no.";
-        if (yesno)
-            ri->flags |= SRI_CAN_FAILOVER;
-        else
-            ri->flags &= ~SRI_CAN_FAILOVER;
    } else if (!strcasecmp(argv[0],"parallel-syncs") && argc == 3) {
         /* parallel-syncs <name> <milliseconds> */
         ri = sentinelGetMasterByName(argv[1]);
         if (!ri) return "No such master with specified name.";
         ri->parallel_syncs = atoi(argv[2]);
    } else if (!strcasecmp(argv[0],"notification-script") && argc == 3) {
@@ -1225,18 +1309,186 @@
         ri->client_reconfig_script = sdsnew(argv[2]);
    } else if (!strcasecmp(argv[0],"auth-pass") && argc == 3) {
         /* auth-pass <name> <password> */
         ri = sentinelGetMasterByName(argv[1]);
         if (!ri) return "No such master with specified name.";
         ri->auth_pass = sdsnew(argv[2]);
+    } else if (!strcasecmp(argv[0],"config-epoch") && argc == 3) {
+        /* config-epoch <name> <epoch> */
+        ri = sentinelGetMasterByName(argv[1]);
+        if (!ri) return "No such master with specified name.";
+        ri->config_epoch = strtoull(argv[2],NULL,10);
+        if (ri->config_epoch > sentinel.current_epoch)
+            sentinel.current_epoch = ri->config_epoch;
+    } else if (!strcasecmp(argv[0],"known-slave") && argc == 4) {
+        sentinelRedisInstance *slave;
+
+        /* known-slave <name> <ip> <port> */
+        ri = sentinelGetMasterByName(argv[1]);
+        if (!ri) return "No such master with specified name.";
+        if ((slave = createSentinelRedisInstance(NULL,SRI_SLAVE,argv[2],
+                    atoi(argv[3]), ri->quorum, ri)) == NULL)
+        {
+            return "Wrong hostname or port for slave.";
+        }
+    } else if (!strcasecmp(argv[0],"known-sentinel") &&
+               (argc == 4 || argc == 5)) {
+        sentinelRedisInstance *si;
+
+        /* known-sentinel <name> <ip> <port> [runid] */
+        ri = sentinelGetMasterByName(argv[1]);
+        if (!ri) return "No such master with specified name.";
+        if ((si = createSentinelRedisInstance(NULL,SRI_SENTINEL,argv[2],
+                    atoi(argv[3]), ri->quorum, ri)) == NULL)
+        {
+            return "Wrong hostname or port for sentinel.";
+        }
+        if (argc == 5) si->runid = sdsnew(argv[4]);
     } else {
         return "Unrecognized sentinel configuration statement.";
     }
     return NULL;
 }
 
+/* Implements CONFIG REWRITE for "sentinel" option.
+ * This is used not just to rewrite the configuration given by the user
+ * (the configured masters) but also in order to retain the state of
+ * Sentinel across restarts: config epoch of masters, associated slaves
+ * and sentinel instances, and so forth. */
+void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
+    dictIterator *di, *di2;
+    dictEntry *de;
+
+    /* For every master emit a "sentinel monitor" config entry. */
+    di = dictGetIterator(sentinel.masters);
+    while((de = dictNext(di)) != NULL) {
+        sentinelRedisInstance *master, *ri;
+        sentinelAddr *master_addr;
+        sds line;
+
+        /* sentinel monitor */
+        master = dictGetVal(de);
+        master_addr = sentinelGetCurrentMasterAddress(master);
+        line = sdscatprintf(sdsempty(),"sentinel monitor %s %s %d %d",
+            master->name, master_addr->ip, master_addr->port,
+            master->quorum);
+        rewriteConfigRewriteLine(state,"sentinel",line,1);
+
+        /* sentinel down-after-milliseconds */
+        if (master->down_after_period != SENTINEL_DEFAULT_DOWN_AFTER) {
+            line = sdscatprintf(sdsempty(),
+                "sentinel down-after-milliseconds %s %ld",
+                master->name, (long) master->down_after_period);
+            rewriteConfigRewriteLine(state,"sentinel",line,1);
+        }
+
+        /* sentinel failover-timeout */
+        if (master->failover_timeout != SENTINEL_DEFAULT_FAILOVER_TIMEOUT) {
+            line = sdscatprintf(sdsempty(),
+                "sentinel failover-timeout %s %ld",
+                master->name, (long) master->failover_timeout);
+            rewriteConfigRewriteLine(state,"sentinel",line,1);
+        }
+
+        /* sentinel parallel-syncs */
+        if (master->parallel_syncs != SENTINEL_DEFAULT_PARALLEL_SYNCS) {
+            line = sdscatprintf(sdsempty(),
+                "sentinel parallel-syncs %s %d",
+                master->name, master->parallel_syncs);
+            rewriteConfigRewriteLine(state,"sentinel",line,1);
+        }
+
+        /* sentinel notification-script */
+        if (master->notification_script) {
+            line = sdscatprintf(sdsempty(),
+                "sentinel notification-script %s %s",
+                master->name, master->notification_script);
+            rewriteConfigRewriteLine(state,"sentinel",line,1);
+        }
+
+        /* sentinel client-reconfig-script */
+        if (master->client_reconfig_script) {
+            line = sdscatprintf(sdsempty(),
+                "sentinel client-reconfig-script %s %s",
+                master->name, master->client_reconfig_script);
+            rewriteConfigRewriteLine(state,"sentinel",line,1);
+        }
+
+        /* sentinel auth-pass */
+        if (master->auth_pass) {
+            line = sdscatprintf(sdsempty(),
+                "sentinel auth-pass %s %s",
+                master->name, master->auth_pass);
+            rewriteConfigRewriteLine(state,"sentinel",line,1);
+        }
+
+        /* sentinel config-epoch */
+        line = sdscatprintf(sdsempty(),
+            "sentinel config-epoch %s %llu",
+            master->name, (unsigned long long) master->config_epoch);
+        rewriteConfigRewriteLine(state,"sentinel",line,1);
+
+        /* sentinel known-slave */
+        di2 = dictGetIterator(master->slaves);
+        while((de = dictNext(di2)) != NULL) {
+            sentinelAddr *slave_addr;
+
+            ri = dictGetVal(de);
+            slave_addr = ri->addr;
+
+            /* If master_addr (obtained using sentinelGetCurrentMasterAddress()
+             * so it may be the address of the promoted slave) is equal to this
+             * slave's address, a failover is in progress and the slave was
+             * already successfully promoted. So as the address of this slave
+             * we use the old master address instead. */
+            if (sentinelAddrIsEqual(slave_addr,master_addr))
+                slave_addr = master->addr;
+            line = sdscatprintf(sdsempty(),
+                "sentinel known-slave %s %s %d",
+                master->name, ri->addr->ip, ri->addr->port);
+            rewriteConfigRewriteLine(state,"sentinel",line,1);
+        }
+        dictReleaseIterator(di2);
+
+        /* sentinel known-sentinel */
+        di2 = dictGetIterator(master->sentinels);
+        while((de = dictNext(di2)) != NULL) {
+            ri = dictGetVal(de);
+            line = sdscatprintf(sdsempty(),
+                "sentinel known-sentinel %s %s %d%s%s",
+                master->name, ri->addr->ip, ri->addr->port,
+                ri->runid ? " " : "",
+                ri->runid ? ri->runid : "");
+            rewriteConfigRewriteLine(state,"sentinel",line,1);
+        }
+        dictReleaseIterator(di2);
+    }
+    dictReleaseIterator(di);
+}
+
+/* This function uses the config rewriting Redis engine in order to persist
+ * the state of the Sentinel in the current configuration file.
+ *
+ * Before returning the function calls fsync() against the generated
+ * configuration file to make sure changes are committed to disk.
+ *
+ * On failure the function logs a warning on the Redis log. */
+void sentinelFlushConfig(void) {
+    int fd;
+
+    if (rewriteConfig(server.configfile) == -1) {
+        redisLog(REDIS_WARNING,"WARNING: Senitnel was not able to save the new configuration on disk!!!: %s", strerror(errno));
+        return;
+    }
+    if ((fd = open(server.configfile,O_RDONLY)) != -1) {
+        fsync(fd);
+        close(fd);
+    }
+    return;
+}
+
 /* ====================== hiredis connection handling ======================= */
 
 /* Completely disconnect an hiredis link from an instance. */
 void sentinelKillLink(sentinelRedisInstance *ri, redisAsyncContext *c) {
     if (ri->cc == c) {
         ri->cc = NULL;
@@ -1293,15 +1545,16 @@
  * to the instance as if it fails Sentinel will detect the instance down,
  * will disconnect and reconnect the link and so forth. */
 void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
     char *auth_pass = (ri->flags & SRI_MASTER) ? ri->auth_pass :
                                                  ri->master->auth_pass;
 
-    if (auth_pass)
-        redisAsyncCommand(c, sentinelDiscardReplyCallback, NULL, "AUTH %s",
-            auth_pass);
+    if (auth_pass) {
+        if (redisAsyncCommand(c, sentinelDiscardReplyCallback, NULL, "AUTH %s",
+            auth_pass) == REDIS_OK) ri->pending_commands++;
+    }
 }
 
 /* Create the async connections for the specified instance if the instance
  * is disconnected. Note that the SRI_DISCONNECTED flag is set even if just
  * one of the two links (commands and pub/sub) is missing. */
 void sentinelReconnectInstance(sentinelRedisInstance *ri) {
@@ -1323,13 +1576,13 @@
             redisAsyncSetDisconnectCallback(ri->cc,
                                             sentinelDisconnectCallback);
             sentinelSendAuthIfNeeded(ri,ri->cc);
         }
     }
     /* Pub / Sub */
-    if ((ri->flags & SRI_MASTER) && ri->pc == NULL) {
+    if ((ri->flags & (SRI_MASTER|SRI_SLAVE)) && ri->pc == NULL) {
         ri->pc = redisAsyncConnect(ri->addr->ip,ri->addr->port);
         if (ri->pc->err) {
             sentinelEvent(REDIS_DEBUG,"-pubsub-link-reconnection",ri,"%@ #%s",
                 ri->pc->errstr);
             sentinelKillLink(ri,ri->pc);
         } else {
@@ -1361,12 +1614,25 @@
     if (ri->cc && (ri->flags & (SRI_SLAVE|SRI_SENTINEL) || ri->pc))
         ri->flags &= ~SRI_DISCONNECTED;
 }
 
 /* ======================== Redis instances pinging  ======================== */
 
+/* Return true if master looks "sane", that is:
+ * 1) It is actually a master in the current configuration.
+ * 2) It reports itself as a master.
+ * 3) It is not SDOWN or ODOWN.
+ * 4) We obtained last INFO no more than two times the INFO period time ago. */
+int sentinelMasterLooksSane(sentinelRedisInstance *master) {
+    return
+        master->flags & SRI_MASTER &&
+        master->role_reported == SRI_MASTER &&
+        (master->flags & (SRI_S_DOWN|SRI_O_DOWN)) == 0 &&
+        (mstime() - master->info_refresh) < SENTINEL_INFO_PERIOD*2;
+}
+
 /* Process the INFO output from masters. */
 void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
     sds *lines;
     int numlines, j;
     int role = 0;
     int runid_changed = 0;  /* true if runid changed. */
@@ -1447,159 +1713,130 @@
         if (!memcmp(l,"role:master",11)) role = SRI_MASTER;
         else if (!memcmp(l,"role:slave",10)) role = SRI_SLAVE;
 
         if (role == SRI_SLAVE) {
             /* master_host:<host> */
             if (sdslen(l) >= 12 && !memcmp(l,"master_host:",12)) {
-                sdsfree(ri->slave_master_host);
-                ri->slave_master_host = sdsnew(l+12);
+                if (ri->slave_master_host == NULL ||
+                    strcasecmp(l+12,ri->slave_master_host))
+                {
+                    sdsfree(ri->slave_master_host);
+                    ri->slave_master_host = sdsnew(l+12);
+                    ri->slave_conf_change_time = mstime();
+                }
             }
 
             /* master_port:<port> */
-            if (sdslen(l) >= 12 && !memcmp(l,"master_port:",12))
-                ri->slave_master_port = atoi(l+12);
+            if (sdslen(l) >= 12 && !memcmp(l,"master_port:",12)) {
+                int slave_master_port = atoi(l+12);
+
+                if (ri->slave_master_port != slave_master_port) {
+                    ri->slave_master_port = slave_master_port;
+                    ri->slave_conf_change_time = mstime();
+                }
+            }
             
             /* master_link_status:<status> */
             if (sdslen(l) >= 19 && !memcmp(l,"master_link_status:",19)) {
                 ri->slave_master_link_status =
                     (strcasecmp(l+19,"up") == 0) ?
                     SENTINEL_MASTER_LINK_STATUS_UP :
                     SENTINEL_MASTER_LINK_STATUS_DOWN;
             }
 
             /* slave_priority:<priority> */
             if (sdslen(l) >= 15 && !memcmp(l,"slave_priority:",15))
                 ri->slave_priority = atoi(l+15);
+
+            /* slave_repl_offset:<offset> */
+            if (sdslen(l) >= 18 && !memcmp(l,"slave_repl_offset:",18))
+                ri->slave_repl_offset = strtoull(l+18,NULL,10);
         }
     }
     ri->info_refresh = mstime();
     sdsfreesplitres(lines,numlines);
 
     /* ---------------------------- Acting half -----------------------------
      * Some things will not happen if sentinel.tilt is true, but some will
      * still be processed. */
 
-    /* When what we believe is our master, turned into a slave, the wiser
-     * thing we can do is to follow the events and redirect to the new
-     * master, always. */
-    if ((ri->flags & SRI_MASTER) && role == SRI_SLAVE && ri->slave_master_host)
-    {
-        sentinelEvent(REDIS_WARNING,"+redirect-to-master",ri,
-            "%s %s %d %s %d",
-            ri->name, ri->addr->ip, ri->addr->port,
-            ri->slave_master_host, ri->slave_master_port);
-        sentinelResetMasterAndChangeAddress(ri,ri->slave_master_host,
-                                               ri->slave_master_port);
-        return; /* Don't process anything after this event. */
+    /* Handle master -> slave role switch. */
+    if ((ri->flags & SRI_MASTER) && role == SRI_SLAVE) {
+        if (ri->role_reported != SRI_SLAVE) {
+            ri->role_reported_time = mstime();
+            ri->role_reported = SRI_SLAVE;
+            ri->slave_conf_change_time = mstime();
+        }
     }
 
     /* Handle slave -> master role switch. */
     if ((ri->flags & SRI_SLAVE) && role == SRI_MASTER) {
-        if (!sentinel.tilt && ri->flags & SRI_DEMOTE) {
-            /* If this sentinel was partitioned from the slave's master,
-             * or tilted recently, wait some time before to act,
-             * so that DOWN and roles INFO will be refreshed. */
-            mstime_t wait_time = SENTINEL_INFO_PERIOD*2 +
-                                 ri->master->down_after_period*2;
-
-            if (!sentinelRedisInstanceNoDownFor(ri->master,wait_time) ||
-                (mstime()-sentinel.tilt_start_time) < wait_time)
-                return;
+        if (ri->role_reported != SRI_MASTER) {
+            ri->role_reported_time = mstime();
+            ri->role_reported = SRI_MASTER;
+        }
 
-            /* Old master returned back? Turn it into a slave ASAP if
-             * we can reach what we believe is the new master now, and
-             * have a recent role information for it.
-             *
-             * Note: we'll clear the DEMOTE flag only when we have the
-             * acknowledge that it's a slave again. */
-            if (ri->master->flags & SRI_MASTER &&
-                (ri->master->flags & (SRI_S_DOWN|SRI_O_DOWN)) == 0 &&
-                (mstime() - ri->master->info_refresh) < SENTINEL_INFO_PERIOD*2)
+        /* If this is a promoted slave we can change state to the
+         * failover state machine. */
+        if (!sentinel.tilt &&
+            (ri->master->flags & SRI_FAILOVER_IN_PROGRESS) &&
+            (ri->master->failover_state ==
+                SENTINEL_FAILOVER_STATE_WAIT_PROMOTION))
+        {
+            /* Now that we are sure the slave was reconfigured as a master
+             * set the master configuration epoch to the epoch we won the
+             * election to perform this failover. This will force the other
+             * Sentinels to update their config (assuming there is not
+             * a newer one already available). */
+            ri->master->config_epoch = ri->master->failover_epoch;
+            ri->master->failover_state = SENTINEL_FAILOVER_STATE_RECONF_SLAVES;
+            ri->master->failover_state_change_time = mstime();
+            sentinelFlushConfig();
+            sentinelEvent(REDIS_WARNING,"+promoted-slave",ri,"%@");
+            sentinelEvent(REDIS_WARNING,"+failover-state-reconf-slaves",
+                ri->master,"%@");
+            sentinelCallClientReconfScript(ri->master,SENTINEL_LEADER,
+                "start",ri->master->addr,ri->addr);
+        } else if (!sentinel.tilt) {
+            /* A slave turned into a master. We want to force our view and
+             * reconfigure as slave. Wait some time after the change before
+             * going forward, to receive new configs if any. */
+            mstime_t wait_time = SENTINEL_PUBLISH_PERIOD*4;
+
+            if (sentinelMasterLooksSane(ri->master) &&
+               sentinelRedisInstanceNoDownFor(ri,wait_time) &&
+               mstime() - ri->role_reported_time > wait_time)
             {
-                int retval;
-                retval = redisAsyncCommand(ri->cc,
-                    sentinelDiscardReplyCallback, NULL, "SLAVEOF %s %d",
+                int retval = sentinelSendSlaveOf(ri,
                         ri->master->addr->ip,
                         ri->master->addr->port);
                 if (retval == REDIS_OK)
-                    sentinelEvent(REDIS_NOTICE,"+demote-old-slave",ri,"%@");
-            } else {
-                /* Otherwise if there are not the conditions to demote, we
-                 * no longer trust the DEMOTE flag and remove it. */
-                ri->flags &= ~SRI_DEMOTE;
-                sentinelEvent(REDIS_NOTICE,"-demote-flag-cleared",ri,"%@");
+                    sentinelEvent(REDIS_NOTICE,"+convert-to-slave",ri,"%@");
             }
-        } else if (!(ri->master->flags & SRI_FAILOVER_IN_PROGRESS) &&
-                    (runid_changed || first_runid))
-        {
-            /* If a slave turned into master but:
-             *
-             * 1) Failover not in progress.
-             * 2) RunID has changed or its the first time we see an INFO output.
-             * 
-             * We assume this is a reboot with a wrong configuration.
-             * Log the event and remove the slave. Note that this is processed
-             * in tilt mode as well, otherwise we lose the information that the
-             * runid changed (reboot?) and when the tilt mode ends a fake
-             * failover will be detected. */
-            int retval;
+        }
+    }
 
-            sentinelEvent(REDIS_WARNING,"-slave-restart-as-master",ri,"%@ #removing it from the attached slaves");
-            retval = dictDelete(ri->master->slaves,ri->name);
-            redisAssert(retval == REDIS_OK);
-            return;
-        } else if (!sentinel.tilt && ri->flags & SRI_PROMOTED) {
-            /* If this is a promoted slave we can change state to the
-             * failover state machine. */
-            if ((ri->master->flags & SRI_FAILOVER_IN_PROGRESS) &&
-                (ri->master->flags & SRI_I_AM_THE_LEADER) &&
-                (ri->master->failover_state ==
-                    SENTINEL_FAILOVER_STATE_WAIT_PROMOTION))
-            {
-                ri->master->failover_state = SENTINEL_FAILOVER_STATE_RECONF_SLAVES;
-                ri->master->failover_state_change_time = mstime();
-                sentinelEvent(REDIS_WARNING,"+promoted-slave",ri,"%@");
-                sentinelEvent(REDIS_WARNING,"+failover-state-reconf-slaves",
-                    ri->master,"%@");
-                sentinelCallClientReconfScript(ri->master,SENTINEL_LEADER,
-                    "start",ri->master->addr,ri->addr);
-            }
-        } else if (!sentinel.tilt && (
-                    !(ri->master->flags & SRI_FAILOVER_IN_PROGRESS) ||
-                     ((ri->master->flags & SRI_FAILOVER_IN_PROGRESS) &&
-                      (ri->master->flags & SRI_I_AM_THE_LEADER) &&
-                       ri->master->failover_state ==
-                       SENTINEL_FAILOVER_STATE_WAIT_START)))
-        {
-            /* No failover in progress? Then it is the start of a failover
-             * and we are an observer.
-             *
-             * We also do that if we are a leader doing a failover, in wait
-             * start, but well, somebody else started before us. */
-
-            if (ri->master->flags & SRI_FAILOVER_IN_PROGRESS) {
-                sentinelEvent(REDIS_WARNING,"-failover-abort-race",
-                                ri->master, "%@");
-                sentinelAbortFailover(ri->master);
-            }
+    /* Handle slaves replicating to a different master address. */
+    if ((ri->flags & SRI_SLAVE) && !sentinel.tilt &&
+        role == SRI_SLAVE &&
+        (ri->slave_master_port != ri->master->addr->port ||
+         strcasecmp(ri->slave_master_host,ri->master->addr->ip)))
+    {
+        mstime_t wait_time = ri->master->failover_timeout;
 
-            ri->master->flags |= SRI_FAILOVER_IN_PROGRESS;
-            sentinelEvent(REDIS_WARNING,"+failover-detected",ri->master,"%@");
-            ri->master->failover_state = SENTINEL_FAILOVER_STATE_DETECT_END;
-            ri->master->failover_state_change_time = mstime();
-            ri->master->promoted_slave = ri;
-            ri->flags |= SRI_PROMOTED;
-            ri->flags &= ~SRI_DEMOTE;
-            sentinelCallClientReconfScript(ri->master,SENTINEL_OBSERVER,
-                "start", ri->master->addr,ri->addr);
-            /* We are an observer, so we can only assume that the leader
-             * is reconfiguring the slave instances. For this reason we
-             * set all the instances as RECONF_SENT waiting for progresses
-             * on this side. */
-            sentinelAddFlagsToDictOfRedisInstances(ri->master->slaves,
-                SRI_RECONF_SENT);
+        /* Make sure the master is sane before reconfiguring this instance
+         * into a slave. */
+        if (sentinelMasterLooksSane(ri->master) &&
+            sentinelRedisInstanceNoDownFor(ri,wait_time) &&
+            mstime() - ri->slave_conf_change_time > wait_time)
+        {
+            int retval = sentinelSendSlaveOf(ri,
+                    ri->master->addr->ip,
+                    ri->master->addr->port);
+            if (retval == REDIS_OK)
+                sentinelEvent(REDIS_NOTICE,"+fix-slave-config",ri,"%@");
         }
     }
 
     /* None of the following conditions are processed when in tilt mode, so
      * return asap. */
     if (sentinel.tilt) return;
@@ -1625,25 +1862,14 @@
         if ((ri->flags & SRI_RECONF_INPROG) &&
             ri->slave_master_link_status == SENTINEL_MASTER_LINK_STATUS_UP)
         {
             ri->flags &= ~SRI_RECONF_INPROG;
             ri->flags |= SRI_RECONF_DONE;
             sentinelEvent(REDIS_NOTICE,"+slave-reconf-done",ri,"%@");
-            /* If we are moving forward (a new slave is now configured)
-             * we update the change_time as we are conceptually passing
-             * to the next slave. */
-            ri->failover_state_change_time = mstime();
         }
     }
-
-    /* Detect if the old master was demoted as slave and generate the
-     * +slave event. */
-    if (role == SRI_SLAVE && ri->flags & SRI_DEMOTE) {
-        sentinelEvent(REDIS_NOTICE,"+slave",ri,"%@");
-        ri->flags &= ~SRI_DEMOTE;
-    }
 }
 
 void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
     sentinelRedisInstance *ri = c->data;
     redisReply *r;
 
@@ -1685,14 +1911,16 @@
             /* Send a SCRIPT KILL command if the instance appears to be
              * down because of a busy script. */
             if (strncmp(r->str,"BUSY",4) == 0 &&
                 (ri->flags & SRI_S_DOWN) &&
                 !(ri->flags & SRI_SCRIPT_KILL_SENT))
             {
-                redisAsyncCommand(ri->cc,
-                    sentinelDiscardReplyCallback, NULL, "SCRIPT KILL");
+                if (redisAsyncCommand(ri->cc,
+                        sentinelDiscardReplyCallback, NULL,
+                        "SCRIPT KILL") == REDIS_OK)
+                    ri->pending_commands++;
                 ri->flags |= SRI_SCRIPT_KILL_SENT;
             }
         }
     }
     ri->last_pong_time = mstime();
 }
@@ -1713,18 +1941,20 @@
         ri->last_pub_time = mstime();
 }
 
 /* This is our Pub/Sub callback for the Hello channel. It's useful in order
  * to discover other sentinels attached at the same master. */
 void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {
-    sentinelRedisInstance *ri = c->data;
+    sentinelRedisInstance *ri = c->data, *master;
     redisReply *r;
 
     if (!reply || !ri) return;
     r = reply;
 
+    master = (ri->flags & SRI_MASTER) ? ri : ri->master;
+
     /* Update the last activity in the pubsub channel. Note that since we
      * receive our messages as well this timestamp can be used to detect
      * if the link is probably disconnected even if it seems otherwise. */
     ri->pc_last_activity = mstime();
    
     /* Sanity check in the reply we expect, so that the code that follows
@@ -1737,62 +1967,138 @@
         strcmp(r->element[0]->str,"message") != 0) return;
 
     /* We are not interested in meeting ourselves */
     if (strstr(r->element[2]->str,server.runid) != NULL) return;
 
     {
-        int numtokens, port, removed, canfailover;
+        /* Format is composed of 8 tokens:
+         * 0=ip,1=port,2=runid,3=current_epoch,4=master_name,
+         * 5=master_ip,6=master_port,7=master_config_epoch. */
+        int numtokens, port, removed, master_port;
+        uint64_t current_epoch, master_config_epoch;
         char **token = sdssplitlen(r->element[2]->str,
                                    r->element[2]->len,
-                                   ":",1,&numtokens);
-        sentinelRedisInstance *sentinel;
+                                   ",",1,&numtokens);
+        sentinelRedisInstance *si;
 
-        if (numtokens == 4) {
+        if (numtokens == 8) {
             /* First, try to see if we already have this sentinel. */
             port = atoi(token[1]);
-            canfailover = atoi(token[3]);
-            sentinel = getSentinelRedisInstanceByAddrAndRunID(
-                            ri->sentinels,token[0],port,token[2]);
+            master_port = atoi(token[6]);
+            si = getSentinelRedisInstanceByAddrAndRunID(
+                            master->sentinels,token[0],port,token[2]);
+            current_epoch = strtoull(token[3],NULL,10);
+            master_config_epoch = strtoull(token[7],NULL,10);
+            sentinelRedisInstance *msgmaster;
 
-            if (!sentinel) {
+            if (!si) {
                 /* If not, remove all the sentinels that have the same runid
                  * OR the same ip/port, because it's either a restart or a
                  * network topology change. */
-                removed = removeMatchingSentinelsFromMaster(ri,token[0],port,
+                removed = removeMatchingSentinelsFromMaster(master,token[0],port,
                                 token[2]);
                 if (removed) {
-                    sentinelEvent(REDIS_NOTICE,"-dup-sentinel",ri,
+                    sentinelEvent(REDIS_NOTICE,"-dup-sentinel",master,
                         "%@ #duplicate of %s:%d or %s",
                         token[0],port,token[2]);
                 }
 
                 /* Add the new sentinel. */
-                sentinel = createSentinelRedisInstance(NULL,SRI_SENTINEL,
-                                token[0],port,ri->quorum,ri);
-                if (sentinel) {
-                    sentinelEvent(REDIS_NOTICE,"+sentinel",sentinel,"%@");
+                si = createSentinelRedisInstance(NULL,SRI_SENTINEL,
+                                token[0],port,master->quorum,master);
+                if (si) {
+                    sentinelEvent(REDIS_NOTICE,"+sentinel",si,"%@");
                     /* The runid is NULL after a new instance creation and
                      * for Sentinels we don't have a later chance to fill it,
                      * so do it now. */
-                    sentinel->runid = sdsnew(token[2]);
+                    si->runid = sdsnew(token[2]);
+                    sentinelFlushConfig();
                 }
             }
 
-            /* Update the state of the Sentinel. */
-            if (sentinel) {
-                sentinel->last_hello_time = mstime();
-                if (canfailover)
-                    sentinel->flags |= SRI_CAN_FAILOVER;
-                else
-                    sentinel->flags &= ~SRI_CAN_FAILOVER;
+            /* Update local current_epoch if received current_epoch is greater.*/
+            if (current_epoch > sentinel.current_epoch) {
+                sentinel.current_epoch = current_epoch;
+                sentinelEvent(REDIS_WARNING,"+new-epoch",ri,"%llu",
+                    (unsigned long long) sentinel.current_epoch);
+            }
+
+            /* Update master info if received configuration is newer. */
+            if ((msgmaster = sentinelGetMasterByName(token[4])) != NULL) {
+                if (msgmaster->config_epoch < master_config_epoch) {
+                    msgmaster->config_epoch = master_config_epoch;
+                    if (master_port != msgmaster->addr->port ||
+                        !strcmp(msgmaster->addr->ip, token[5]))
+                    {
+                        sentinelAddr *old_addr;
+
+                        sentinelEvent(REDIS_WARNING,"+switch-master",
+                            msgmaster,"%s %s %d %s %d",
+                            msgmaster->name,
+                            msgmaster->addr->ip, msgmaster->addr->port,
+                            token[5], master_port);
+
+                        old_addr = dupSentinelAddr(msgmaster->addr);
+                        sentinelResetMasterAndChangeAddress(msgmaster,
+                                                    token[5], master_port);
+                        sentinelCallClientReconfScript(msgmaster,
+                            SENTINEL_OBSERVER,"start",
+                            old_addr,msgmaster->addr);
+                        releaseSentinelAddr(old_addr);
+                    }
+                }
             }
+
+            /* Update the state of the Sentinel. */
+            if (si) si->last_hello_time = mstime();
         }
         sdsfreesplitres(token,numtokens);
     }
 }
 
+/* Send an "Hello" message via Pub/Sub to the specified 'ri' Redis
+ * instance in order to broadcast the current configuraiton for this
+ * master, and to advertise the existence of this Sentinel at the same time.
+ *
+ * The message has the following format:
+ *
+ * sentinel_ip,sentinel_port,sentinel_runid,current_epoch,
+ * master_name,master_ip,master_port,master_config_epoch.
+ *
+ * Returns REDIS_OK if the PUBLISH was queued correctly, otherwise
+ * REDIS_ERR is returned. */
+int sentinelSendHello(sentinelRedisInstance *ri) {
+    char ip[REDIS_IP_STR_LEN];
+    char payload[REDIS_IP_STR_LEN+1024];
+    int retval;
+    sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ? ri : ri->master;
+    sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);
+
+    /* Try to obtain our own IP address. */
+    if (anetSockName(ri->cc->c.fd,ip,sizeof(ip),NULL) == -1) return REDIS_ERR;
+    if (ri->flags & SRI_DISCONNECTED) return REDIS_ERR;
+
+    /* Format and send the Hello message. */
+    snprintf(payload,sizeof(payload),
+        "%s,%d,%s,%llu," /* Info about this sentinel. */
+        "%s,%s,%d,%lld", /* Info about current master. */
+        ip, server.port, server.runid,
+        (unsigned long long) sentinel.current_epoch,
+        /* --- */
+        master->name,master_addr->ip,master_addr->port,
+        master->config_epoch);
+    retval = redisAsyncCommand(ri->cc,
+        sentinelPublishReplyCallback, NULL, "PUBLISH %s %s",
+            SENTINEL_HELLO_CHANNEL,payload);
+    if (retval != REDIS_OK) return REDIS_ERR;
+    ri->pending_commands++;
+    return REDIS_OK;
+}
+
+/* Send periodic PING, INFO, and PUBLISH to the Hello channel to
+ * the specified master or slave instance. */
 void sentinelPingInstance(sentinelRedisInstance *ri) {
     mstime_t now = mstime();
     mstime_t info_period;
     int retval;
 
     /* Return ASAP if we have already a PING or INFO already pending, or
@@ -1830,31 +2136,17 @@
     } else if ((now - ri->last_pong_time) > SENTINEL_PING_PERIOD) {
         /* Send PING to all the three kinds of instances. */
         retval = redisAsyncCommand(ri->cc,
             sentinelPingReplyCallback, NULL, "PING");
         if (retval != REDIS_OK) return;
         ri->pending_commands++;
-    } else if ((ri->flags & SRI_MASTER) &&
+    } else if ((ri->flags & SRI_SENTINEL) == 0 &&
                (now - ri->last_pub_time) > SENTINEL_PUBLISH_PERIOD)
     {
-        /* PUBLISH hello messages only to masters. */
-        struct sockaddr_in sa;
-        socklen_t salen = sizeof(sa);
-
-        if (getsockname(ri->cc->c.fd,(struct sockaddr*)&sa,&salen) != -1) {
-            char myaddr[128];
-
-            snprintf(myaddr,sizeof(myaddr),"%s:%d:%s:%d",
-                inet_ntoa(sa.sin_addr), server.port, server.runid,
-                (ri->flags & SRI_CAN_FAILOVER) != 0);
-            retval = redisAsyncCommand(ri->cc,
-                sentinelPublishReplyCallback, NULL, "PUBLISH %s %s",
-                    SENTINEL_HELLO_CHANNEL,myaddr);
-            if (retval != REDIS_OK) return;
-            ri->pending_commands++;
-        }
+        /* PUBLISH hello messages to masters and slaves. */
+        sentinelSendHello(ri);
     }
 }
 
 /* =========================== SENTINEL command ============================= */
 
 const char *sentinelFailoverStateStr(int state) {
@@ -1862,14 +2154,12 @@
     case SENTINEL_FAILOVER_STATE_NONE: return "none";
     case SENTINEL_FAILOVER_STATE_WAIT_START: return "wait_start";
     case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: return "select_slave";
     case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: return "send_slaveof_noone";
     case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: return "wait_promotion";
     case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: return "reconf_slaves";
-    case SENTINEL_FAILOVER_STATE_ALERT_CLIENTS: return "alert_clients";
-    case SENTINEL_FAILOVER_STATE_DETECT_END: return "detect_end";
     case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return "update_config";
     default: return "unknown";
     }
 }
 
 /* Redis instance to Redis protocol representation. */
@@ -1903,21 +2193,18 @@
     if (ri->flags & SRI_SLAVE) flags = sdscat(flags,"slave,");
     if (ri->flags & SRI_SENTINEL) flags = sdscat(flags,"sentinel,");
     if (ri->flags & SRI_DISCONNECTED) flags = sdscat(flags,"disconnected,");
     if (ri->flags & SRI_MASTER_DOWN) flags = sdscat(flags,"master_down,");
     if (ri->flags & SRI_FAILOVER_IN_PROGRESS)
         flags = sdscat(flags,"failover_in_progress,");
-    if (ri->flags & SRI_I_AM_THE_LEADER)
-        flags = sdscat(flags,"i_am_the_leader,");
     if (ri->flags & SRI_PROMOTED) flags = sdscat(flags,"promoted,");
     if (ri->flags & SRI_RECONF_SENT) flags = sdscat(flags,"reconf_sent,");
     if (ri->flags & SRI_RECONF_INPROG) flags = sdscat(flags,"reconf_inprog,");
     if (ri->flags & SRI_RECONF_DONE) flags = sdscat(flags,"reconf_done,");
-    if (ri->flags & SRI_DEMOTE) flags = sdscat(flags,"demote,");
 
-    if (sdslen(flags) != 0) flags = sdsrange(flags,0,-2); /* remove last "," */
+    if (sdslen(flags) != 0) sdsrange(flags,0,-2); /* remove last "," */
     addReplyBulkCString(c,flags);
     sdsfree(flags);
     fields++;
 
     addReplyBulkCString(c,"pending-commands");
     addReplyBulkLongLong(c,ri->pending_commands);
@@ -1951,16 +2238,29 @@
 
     /* Masters and Slaves */
     if (ri->flags & (SRI_MASTER|SRI_SLAVE)) {
         addReplyBulkCString(c,"info-refresh");
         addReplyBulkLongLong(c,mstime() - ri->info_refresh);
         fields++;
+
+        addReplyBulkCString(c,"role-reported");
+        addReplyBulkCString(c, (ri->role_reported == SRI_MASTER) ? "master" :
+                                                                   "slave");
+        fields++;
+
+        addReplyBulkCString(c,"role-reported-time");
+        addReplyBulkLongLong(c,mstime() - ri->role_reported_time);
+        fields++;
     }
 
     /* Only masters */
     if (ri->flags & SRI_MASTER) {
+        addReplyBulkCString(c,"config-epoch");
+        addReplyBulkLongLong(c,ri->config_epoch);
+        fields++;
+
         addReplyBulkCString(c,"num-slaves");
         addReplyBulkLongLong(c,dictSize(ri->slaves));
         fields++;
 
         addReplyBulkCString(c,"num-other-sentinels");
         addReplyBulkLongLong(c,dictSize(ri->sentinels));
@@ -1992,29 +2292,31 @@
         addReplyBulkLongLong(c,ri->slave_master_port);
         fields++;
 
         addReplyBulkCString(c,"slave-priority");
         addReplyBulkLongLong(c,ri->slave_priority);
         fields++;
+
+        addReplyBulkCString(c,"slave-repl-offset");
+        addReplyBulkLongLong(c,ri->slave_repl_offset);
+        fields++;
     }
 
     /* Only sentinels */
     if (ri->flags & SRI_SENTINEL) {
         addReplyBulkCString(c,"last-hello-message");
         addReplyBulkLongLong(c,mstime() - ri->last_hello_time);
         fields++;
 
-        addReplyBulkCString(c,"can-failover-its-master");
-        addReplyBulkLongLong(c,(ri->flags & SRI_CAN_FAILOVER) != 0);
+        addReplyBulkCString(c,"voted-leader");
+        addReplyBulkCString(c,ri->leader ? ri->leader : "?");
         fields++;
 
-        if (ri->flags & SRI_MASTER_DOWN) {
-            addReplyBulkCString(c,"subjective-leader");
-            addReplyBulkCString(c,ri->leader ? ri->leader : "?");
-            fields++;
-        }
+        addReplyBulkCString(c,"voted-leader-epoch");
+        addReplyBulkLongLong(c,ri->leader_epoch);
+        fields++;
     }
 
     setDeferredMultiBulkLength(c,mbl,fields*2);
 }
 
 /* Output a number of instances contained inside a dictionary as
@@ -2069,35 +2371,48 @@
 
         if (c->argc != 3) goto numargserr;
         if ((ri = sentinelGetMasterByNameOrReplyError(c,c->argv[2])) == NULL)
             return;
         addReplyDictOfRedisInstances(c,ri->sentinels);
     } else if (!strcasecmp(c->argv[1]->ptr,"is-master-down-by-addr")) {
-        /* SENTINEL IS-MASTER-DOWN-BY-ADDR <ip> <port> */
+        /* SENTINEL IS-MASTER-DOWN-BY-ADDR <ip> <port> <current-epoch> <runid> */
         sentinelRedisInstance *ri;
+        long long req_epoch;
+        uint64_t leader_epoch = 0;
         char *leader = NULL;
         long port;
         int isdown = 0;
 
-        if (c->argc != 4) goto numargserr;
-        if (getLongFromObjectOrReply(c,c->argv[3],&port,NULL) != REDIS_OK)
+        if (c->argc != 6) goto numargserr;
+        if (getLongFromObjectOrReply(c,c->argv[3],&port,NULL) != REDIS_OK ||
+            getLongLongFromObjectOrReply(c,c->argv[4],&req_epoch,NULL)
+                                                              != REDIS_OK)
             return;
         ri = getSentinelRedisInstanceByAddrAndRunID(sentinel.masters,
             c->argv[2]->ptr,port,NULL);
 
         /* It exists? Is actually a master? Is subjectively down? It's down.
          * Note: if we are in tilt mode we always reply with "0". */
         if (!sentinel.tilt && ri && (ri->flags & SRI_S_DOWN) &&
                                     (ri->flags & SRI_MASTER))
             isdown = 1;
-        if (ri) leader = sentinelGetSubjectiveLeader(ri);
 
-        /* Reply with a two-elements multi-bulk reply: down state, leader. */
-        addReplyMultiBulkLen(c,2);
+        /* Vote for the master (or fetch the previous vote) if the request
+         * includes a runid, otherwise the sender is not seeking for a vote. */
+        if (ri && ri->flags & SRI_MASTER && strcasecmp(c->argv[5]->ptr,"*")) {
+            leader = sentinelVoteLeader(ri,(uint64_t)req_epoch,
+                                            c->argv[5]->ptr,
+                                            &leader_epoch);
+        }
+
+        /* Reply with a three-elements multi-bulk reply:
+         * down state, leader, vote epoch. */
+        addReplyMultiBulkLen(c,3);
         addReply(c, isdown ? shared.cone : shared.czero);
-        addReplyBulkCString(c, leader ? leader : "?");
+        addReplyBulkCString(c, leader ? leader : "*");
+        addReplyLongLong(c, (long long)leader_epoch);
         if (leader) sdsfree(leader);
     } else if (!strcasecmp(c->argv[1]->ptr,"reset")) {
         /* SENTINEL RESET <pattern> */
         if (c->argc != 3) goto numargserr;
         addReplyLongLong(c,sentinelResetMastersByPattern(c->argv[2]->ptr,SENTINEL_GENERATE_EVENT));
     } else if (!strcasecmp(c->argv[1]->ptr,"get-master-addr-by-name")) {
@@ -2108,24 +2423,14 @@
         ri = sentinelGetMasterByName(c->argv[2]->ptr);
         if (ri == NULL) {
             addReply(c,shared.nullmultibulk);
         } else if (ri->info_refresh == 0) {
             addReplySds(c,sdsnew("-IDONTKNOW I have not enough information to reply. Please ask another Sentinel.\r\n"));
         } else {
-            sentinelAddr *addr = ri->addr;
+            sentinelAddr *addr = sentinelGetCurrentMasterAddress(ri);
 
-            /* If we are in the middle of a failover, and the slave was
-             * already successfully switched to master role, we can advertise
-             * the new address as slave in order to allow clients to talk
-             * with the new master ASAP. */
-            if ((ri->flags & SRI_FAILOVER_IN_PROGRESS) &&
-                ri->promoted_slave &&
-                ri->failover_state >= SENTINEL_FAILOVER_STATE_RECONF_SLAVES)
-            {
-                addr = ri->promoted_slave->addr;
-            }
             addReplyMultiBulkLen(c,2);
             addReplyBulkCString(c,addr->ip);
             addReplyBulkLongLong(c,addr->port);
         }
     } else if (!strcasecmp(c->argv[1]->ptr,"failover")) {
         /* SENTINEL FAILOVER <master-name> */
@@ -2139,13 +2444,15 @@
             return;
         }
         if (sentinelSelectSlave(ri) == NULL) {
             addReplySds(c,sdsnew("-NOGOODSLAVE No suitable slave to promote\r\n"));
             return;
         }
-        sentinelStartFailover(ri,SENTINEL_FAILOVER_STATE_WAIT_START);
+        redisLog(REDIS_WARNING,"Executing user requested FAILOVER of '%s'",
+            ri->name);
+        sentinelStartFailover(ri);
         ri->flags |= SRI_FORCE_FAILOVER;
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"pending-scripts")) {
         /* SENTINEL PENDING-SCRIPTS */
 
         if (c->argc != 2) goto numargserr;
@@ -2248,14 +2555,24 @@
         (mstime() - ri->pc_conn_time) > SENTINEL_MIN_LINK_RECONNECT_PERIOD &&
         (mstime() - ri->pc_last_activity) > (SENTINEL_PUBLISH_PERIOD*3))
     {
         sentinelKillLink(ri,ri->pc);
     }
 
-    /* Update the subjectively down flag. */
-    if (elapsed > ri->down_after_period) {
+    /* Update the SDOWN flag. We believe the instance is SDOWN if:
+     *
+     * 1) It is not replying.
+     * 2) We believe it is a master, it reports to be a slave for enough time
+     *    to meet the down_after_period, plus enough time to get two times
+     *    INFO report from the instance. */
+    if (elapsed > ri->down_after_period ||
+        (ri->flags & SRI_MASTER &&
+         ri->role_reported == SRI_SLAVE &&
+         mstime() - ri->role_reported_time >
+          (ri->down_after_period+SENTINEL_INFO_PERIOD*2)))
+    {
         /* Is subjectively down */
         if ((ri->flags & SRI_S_DOWN) == 0) {
             sentinelEvent(REDIS_WARNING,"+sdown",ri,"%@");
             ri->s_down_since_time = mstime();
             ri->flags |= SRI_S_DOWN;
         }
@@ -2265,13 +2582,18 @@
             sentinelEvent(REDIS_WARNING,"-sdown",ri,"%@");
             ri->flags &= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);
         }
     }
 }
 
-/* Is this instance down accordingly to the configured quorum? */
+/* Is this instance down according to the configured quorum?
+ *
+ * Note that ODOWN is a weak quorum, it only means that enough Sentinels
+ * reported in a given time range that the instance was not reachable.
+ * However messages can be delayed so there are no strong guarantees about
+ * N instances agreeing at the same time about the down state. */
 void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
     dictIterator *di;
     dictEntry *de;
     int quorum = 0, odown = 0;
 
     if (master->flags & SRI_S_DOWN) {
@@ -2314,336 +2636,334 @@
     if (!reply || !ri) return;
     r = reply;
 
     /* Ignore every error or unexpected reply.
      * Note that if the command returns an error for any reason we'll
      * end clearing the SRI_MASTER_DOWN flag for timeout anyway. */
-    if (r->type == REDIS_REPLY_ARRAY && r->elements == 2 &&
+    if (r->type == REDIS_REPLY_ARRAY && r->elements == 3 &&
         r->element[0]->type == REDIS_REPLY_INTEGER &&
-        r->element[1]->type == REDIS_REPLY_STRING)
+        r->element[1]->type == REDIS_REPLY_STRING &&
+        r->element[2]->type == REDIS_REPLY_INTEGER)
     {
         ri->last_master_down_reply_time = mstime();
         if (r->element[0]->integer == 1) {
             ri->flags |= SRI_MASTER_DOWN;
         } else {
             ri->flags &= ~SRI_MASTER_DOWN;
         }
-        sdsfree(ri->leader);
-        ri->leader = sdsnew(r->element[1]->str);
+        if (strcmp(r->element[1]->str,"*")) {
+            /* If the runid in the reply is not "*" the Sentinel actually
+             * replied with a vote. */
+            sdsfree(ri->leader);
+            ri->leader = sdsnew(r->element[1]->str);
+            ri->leader_epoch = r->element[2]->integer;
+        }
     }
 }
 
-/* If we think (subjectively) the master is down, we start sending
+/* If we think the master is down, we start sending
  * SENTINEL IS-MASTER-DOWN-BY-ADDR requests to other sentinels
- * in order to get the replies that allow to reach the quorum and
- * possibly also mark the master as objectively down. */
-void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master) {
+ * in order to get the replies that allow to reach the quorum
+ * needed to mark the master in ODOWN state and trigger a failover. */
+#define SENTINEL_ASK_FORCED (1<<0)
+void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {
     dictIterator *di;
     dictEntry *de;
 
     di = dictGetIterator(master->sentinels);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *ri = dictGetVal(de);
         mstime_t elapsed = mstime() - ri->last_master_down_reply_time;
         char port[32];
         int retval;
 
         /* If the master state from other sentinel is too old, we clear it. */
-        if (elapsed > SENTINEL_INFO_VALIDITY_TIME) {
+        if (elapsed > SENTINEL_ASK_PERIOD*5) {
             ri->flags &= ~SRI_MASTER_DOWN;
             sdsfree(ri->leader);
             ri->leader = NULL;
         }
 
         /* Only ask if master is down to other sentinels if:
          *
          * 1) We believe it is down, or there is a failover in progress.
          * 2) Sentinel is connected.
          * 3) We did not received the info within SENTINEL_ASK_PERIOD ms. */
-        if ((master->flags & (SRI_S_DOWN|SRI_FAILOVER_IN_PROGRESS)) == 0)
-            continue;
+        if ((master->flags & SRI_S_DOWN) == 0) continue;
         if (ri->flags & SRI_DISCONNECTED) continue;
-        if (mstime() - ri->last_master_down_reply_time < SENTINEL_ASK_PERIOD)
+        if (!(flags & SENTINEL_ASK_FORCED) &&
+            mstime() - ri->last_master_down_reply_time < SENTINEL_ASK_PERIOD)
             continue;
 
         /* Ask */
         ll2string(port,sizeof(port),master->addr->port);
         retval = redisAsyncCommand(ri->cc,
                     sentinelReceiveIsMasterDownReply, NULL,
-                    "SENTINEL is-master-down-by-addr %s %s",
-                    master->addr->ip, port);
+                    "SENTINEL is-master-down-by-addr %s %s %llu %s",
+                    master->addr->ip, port,
+                    sentinel.current_epoch,
+                    (master->failover_state > SENTINEL_FAILOVER_STATE_NONE) ?
+                    server.runid : "*");
         if (retval == REDIS_OK) ri->pending_commands++;
     }
     dictReleaseIterator(di);
 }
 
 /* =============================== FAILOVER ================================= */
 
-/* Given a master get the "subjective leader", that is, among all the sentinels
- * with given characteristics, the one with the lexicographically smaller
- * runid. The characteristics required are:
- *
- * 1) Has SRI_CAN_FAILOVER flag.
- * 2) Is not disconnected.
- * 3) Recently answered to our ping (no longer than
- *    SENTINEL_INFO_VALIDITY_TIME milliseconds ago).
- *
- * The function returns a pointer to an sds string representing the runid of the
- * leader sentinel instance (from our point of view). Otherwise NULL is
- * returned if there are no suitable sentinels.
- */
-
-int compareRunID(const void *a, const void *b) {
-    char **aptrptr = (char**)a, **bptrptr = (char**)b;
-    return strcasecmp(*aptrptr, *bptrptr);
-}
-
-char *sentinelGetSubjectiveLeader(sentinelRedisInstance *master) {
-    dictIterator *di;
-    dictEntry *de;
-    char **instance =
-        zmalloc(sizeof(char*)*(dictSize(master->sentinels)+1));
-    int instances = 0;
-    char *leader = NULL;
-
-    if (master->flags & SRI_CAN_FAILOVER) {
-        /* Add myself if I'm a Sentinel that can failover this master. */
-        instance[instances++] = server.runid;
+/* Vote for the sentinel with 'req_runid' or return the old vote if already
+ * voted for the specifed 'req_epoch' or one greater.
+ *
+ * If a vote is not available returns NULL, otherwise return the Sentinel
+ * runid and populate the leader_epoch with the epoch of the vote. */
+char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {
+    if (req_epoch > sentinel.current_epoch) {
+        sentinel.current_epoch = req_epoch;
+        sentinelEvent(REDIS_WARNING,"+new-epoch",master,"%llu",
+            (unsigned long long) sentinel.current_epoch);
     }
 
-    di = dictGetIterator(master->sentinels);
-    while((de = dictNext(di)) != NULL) {
-        sentinelRedisInstance *ri = dictGetVal(de);
-        mstime_t lag = mstime() - ri->last_avail_time;
-
-        if (lag > SENTINEL_INFO_VALIDITY_TIME ||
-            !(ri->flags & SRI_CAN_FAILOVER) ||
-            (ri->flags & SRI_DISCONNECTED) ||
-            ri->runid == NULL)
-            continue;
-        instance[instances++] = ri->runid;
+    if (master->leader_epoch < req_epoch && sentinel.current_epoch <= req_epoch)
+    {
+        sdsfree(master->leader);
+        master->leader = sdsnew(req_runid);
+        master->leader_epoch = sentinel.current_epoch;
+        sentinelEvent(REDIS_WARNING,"+vote-for-leader",master,"%s %llu",
+            master->leader, (unsigned long long) master->leader_epoch);
+        /* If we did not voted for ourselves, set the master failover start
+         * time to now, in order to force a delay before we can start a
+         * failover for the same master.
+         *
+         * The random addition is useful to desynchronize a bit the slaves
+         * and reduce the chance that no slave gets majority. */
+        if (strcasecmp(master->leader,server.runid))
+            master->failover_start_time = mstime() + rand() % 2000;
     }
-    dictReleaseIterator(di);
 
-    /* If we have at least one instance passing our checks, order the array
-     * by runid. */
-    if (instances) {
-        qsort(instance,instances,sizeof(char*),compareRunID);
-        leader = sdsnew(instance[0]);
-    }
-    zfree(instance);
-    return leader;
+    *leader_epoch = master->leader_epoch;
+    return master->leader ? sdsnew(master->leader) : NULL;
 }
 
 struct sentinelLeader {
     char *runid;
     unsigned long votes;
 };
 
-/* Helper function for sentinelGetObjectiveLeader, increment the counter
+/* Helper function for sentinelGetLeader, increment the counter
  * relative to the specified runid. */
-void sentinelObjectiveLeaderIncr(dict *counters, char *runid) {
+int sentinelLeaderIncr(dict *counters, char *runid) {
     dictEntry *de = dictFind(counters,runid);
     uint64_t oldval;
 
     if (de) {
         oldval = dictGetUnsignedIntegerVal(de);
         dictSetUnsignedIntegerVal(de,oldval+1);
+        return oldval+1;
     } else {
         de = dictAddRaw(counters,runid);
         redisAssert(de != NULL);
         dictSetUnsignedIntegerVal(de,1);
+        return 1;
     }
 }
 
-/* Scan all the Sentinels attached to this master to check what is the
- * most voted leader among Sentinels. */
-char *sentinelGetObjectiveLeader(sentinelRedisInstance *master) {
+/* Scan all the Sentinels attached to this master to check if there
+ * is a leader for the specified epoch.
+ *
+ * To be a leader for a given epoch, we should have the majorify of
+ * the Sentinels we know that reported the same instance as
+ * leader for the same epoch. */
+char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
     dict *counters;
     dictIterator *di;
     dictEntry *de;
     unsigned int voters = 0, voters_quorum;
     char *myvote;
     char *winner = NULL;
+    uint64_t leader_epoch;
+    uint64_t max_votes = 0;
 
     redisAssert(master->flags & (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));
     counters = dictCreate(&leaderVotesDictType,NULL);
 
-    /* Count my vote. */
-    myvote = sentinelGetSubjectiveLeader(master);
-    if (myvote) {
-        sentinelObjectiveLeaderIncr(counters,myvote);
-        voters++;
-    }
-
     /* Count other sentinels votes */
     di = dictGetIterator(master->sentinels);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *ri = dictGetVal(de);
-        if (ri->leader == NULL) continue;
-        /* If the failover is not already in progress we are only interested
-         * in Sentinels that believe the master is down. Otherwise the leader
-         * selection is useful for the "failover-takedown" when the original
-         * leader fails. In that case we consider all the voters. */
-        if (!(master->flags & SRI_FAILOVER_IN_PROGRESS) &&
-            !(ri->flags & SRI_MASTER_DOWN)) continue;
-        sentinelObjectiveLeaderIncr(counters,ri->leader);
+        if (ri->leader != NULL && ri->leader_epoch == sentinel.current_epoch)
+            sentinelLeaderIncr(counters,ri->leader);
         voters++;
     }
     dictReleaseIterator(di);
-    voters_quorum = voters/2+1;
 
     /* Check what's the winner. For the winner to win, it needs two conditions:
      * 1) Absolute majority between voters (50% + 1).
      * 2) And anyway at least master->quorum votes. */
-    {
-        uint64_t max_votes = 0; /* Max votes so far. */
+    di = dictGetIterator(counters);
+    while((de = dictNext(di)) != NULL) {
+        uint64_t votes = dictGetUnsignedIntegerVal(de);
 
-        di = dictGetIterator(counters);
-        while((de = dictNext(di)) != NULL) {
-            uint64_t votes = dictGetUnsignedIntegerVal(de);
+        if (votes > max_votes) {
+            max_votes = votes;
+            winner = dictGetKey(de);
+        }
+    }
+    dictReleaseIterator(di);
 
-            if (max_votes < votes) {
-                max_votes = votes;
-                winner = dictGetKey(de);
-            }
+    /* Count this Sentinel vote:
+     * if this Sentinel did not voted yet, either vote for the most
+     * common voted sentinel, or for itself if no vote exists at all. */
+    if (winner)
+        myvote = sentinelVoteLeader(master,epoch,winner,&leader_epoch);
+    else
+        myvote = sentinelVoteLeader(master,epoch,server.runid,&leader_epoch);
+
+    if (myvote && leader_epoch == epoch) {
+        uint64_t votes = sentinelLeaderIncr(counters,myvote);
+
+        if (votes > max_votes) {
+            max_votes = votes;
+            winner = myvote;
         }
-        dictReleaseIterator(di);
-        if (winner && (max_votes < voters_quorum || max_votes < master->quorum))
-            winner = NULL;
     }
+    voters++; /* Anyway, count me as one of the voters. */
+
+    voters_quorum = voters/2+1;
+    if (winner && (max_votes < voters_quorum || max_votes < master->quorum))
+        winner = NULL;
+
     winner = winner ? sdsnew(winner) : NULL;
     sdsfree(myvote);
     dictRelease(counters);
     return winner;
 }
 
-/* Setup the master state to start a failover as a leader.
- *
- * State can be either:
- *
- * SENTINEL_FAILOVER_STATE_WAIT_START: starts a failover from scratch.
- * SENTINEL_FAILOVER_STATE_RECONF_SLAVES: takedown a failed failover.
- */
-void sentinelStartFailover(sentinelRedisInstance *master, int state) {
-    redisAssert(master->flags & SRI_MASTER);
-    redisAssert(state == SENTINEL_FAILOVER_STATE_WAIT_START ||
-                state == SENTINEL_FAILOVER_STATE_RECONF_SLAVES);
+/* Send SLAVEOF to the specified instance, always followed by a
+ * CONFIG REWRITE command in order to store the new configuration on disk
+ * when possible (that is, if the Redis instance is recent enough to support
+ * config rewriting, and if the server was started with a configuration file).
+ *
+ * If Host is NULL the function sends "SLAVEOF NO ONE".
+ *
+ * The command returns REDIS_OK if the SLAVEOF command was accepted for
+ * (later) delivery otherwise REDIS_ERR. The command replies are just
+ * discarded. */
+int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {
+    char portstr[32];
+    int retval;
+
+    ll2string(portstr,sizeof(portstr),port);
 
-    master->failover_state = state;
-    master->flags |= SRI_FAILOVER_IN_PROGRESS|SRI_I_AM_THE_LEADER;
-    sentinelEvent(REDIS_WARNING,"+failover-triggered",master,"%@");
-
-    /* Pick a random delay if it's a fresh failover (WAIT_START), and not
-     * a recovery of a failover started by another sentinel. */
-    if (master->failover_state == SENTINEL_FAILOVER_STATE_WAIT_START) {
-        master->failover_start_time = mstime() +
-            SENTINEL_FAILOVER_FIXED_DELAY +
-            (rand() % SENTINEL_FAILOVER_MAX_RANDOM_DELAY);
-        sentinelEvent(REDIS_WARNING,"+failover-state-wait-start",master,
-            "%@ #starting in %lld milliseconds",
-            master->failover_start_time-mstime());
+    if (host == NULL) {
+        host = "NO";
+        memcpy(portstr,"ONE",4);
     }
+
+    retval = redisAsyncCommand(ri->cc,
+        sentinelDiscardReplyCallback, NULL, "SLAVEOF %s %s", host, portstr);
+    if (retval == REDIS_ERR) return retval;
+
+    ri->pending_commands++;
+    if (redisAsyncCommand(ri->cc,
+        sentinelDiscardReplyCallback, NULL, "CONFIG REWRITE") == REDIS_OK)
+    {
+        ri->pending_commands++;
+    }
+    return REDIS_OK;
+}
+
+/* Setup the master state to start a failover. */
+void sentinelStartFailover(sentinelRedisInstance *master) {
+    redisAssert(master->flags & SRI_MASTER);
+
+    master->failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
+    master->flags |= SRI_FAILOVER_IN_PROGRESS;
+    master->failover_epoch = ++sentinel.current_epoch;
+    sentinelEvent(REDIS_WARNING,"+new-epoch",master,"%llu",
+        (unsigned long long) sentinel.current_epoch);
+    sentinelEvent(REDIS_WARNING,"+try-failover",master,"%@");
+    master->failover_start_time = mstime();
     master->failover_state_change_time = mstime();
 }
 
 /* This function checks if there are the conditions to start the failover,
  * that is:
  *
- * 1) Enough time has passed since O_DOWN.
- * 2) The master is marked as SRI_CAN_FAILOVER, so we can failover it.
- * 3) We are the objectively leader for this master.
+ * 1) Master must be in ODOWN condition.
+ * 2) No failover already in progress.
+ * 3) No failover already attempted recently.
+ * 
+ * We still don't know if we'll win the election so it is possible that we
+ * start the failover but that we'll not be able to act.
  *
- * If the conditions are met we flag the master as SRI_FAILOVER_IN_PROGRESS
- * and SRI_I_AM_THE_LEADER.
- */
-void sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
-    char *leader;
-    int isleader;
-
-    /* We can't failover if the master is not in O_DOWN state or if
-     * there is not already a failover in progress (to perform the
-     * takedown if the leader died) or if this Sentinel is not allowed
-     * to start a failover. */
-    if (!(master->flags & SRI_CAN_FAILOVER) ||
-        !(master->flags & (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS))) return;
-
-    leader = sentinelGetObjectiveLeader(master);
-    isleader = leader && strcasecmp(leader,server.runid) == 0;
-    sdsfree(leader);
-
-    /* If I'm not the leader, I can't failover for sure. */
-    if (!isleader) return;
-
-    /* If the failover is already in progress there are two options... */
-    if (master->flags & SRI_FAILOVER_IN_PROGRESS) {
-        if (master->flags & SRI_I_AM_THE_LEADER) {
-            /* 1) I'm flagged as leader so I already started the failover.
-             *    Just return. */
-            return;
-        } else {
-            mstime_t elapsed = mstime() - master->failover_state_change_time;
+ * Return non-zero if a failover was started. */
+int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
+    /* We can't failover if the master is not in O_DOWN state. */
+    if (!(master->flags & SRI_O_DOWN)) return 0;
+
+    /* Failover already in progress? */
+    if (master->flags & SRI_FAILOVER_IN_PROGRESS) return 0;
+
+    /* Last failover attempt started too little time ago? */
+    if (mstime() - master->failover_start_time <
+        master->failover_timeout*2) return 0;
 
-            /* 2) I'm the new leader, but I'm not flagged as leader in the
-             *    master: I did not started the failover, but the original
-             *    leader has no longer the leadership.
-             *
-             *    In this case if the failover appears to be lagging
-             *    for at least 25% of the configured failover timeout,
-             *    I can assume I can take control. Otherwise
-             *    it's better to return and wait more. */
-            if (elapsed < (master->failover_timeout/4)) return;
-            sentinelEvent(REDIS_WARNING,"+failover-takedown",master,"%@");
-            /* We have already an elected slave if we are in
-             * FAILOVER_IN_PROGRESS state, that is, the slave that we
-             * observed turning into a master. */
-            sentinelStartFailover(master,SENTINEL_FAILOVER_STATE_RECONF_SLAVES);
-            /* As an observer we flagged all the slaves as RECONF_SENT but
-             * now we are in charge of actually sending the reconfiguration
-             * command so let's clear this flag for all the instances. */
-            sentinelDelFlagsToDictOfRedisInstances(master->slaves,
-                SRI_RECONF_SENT);
-        }
-    } else {
-        /* Brand new failover as SRI_FAILOVER_IN_PROGRESS was not set.
-         *
-         * Do we have a slave to promote? Otherwise don't start a failover
-         * at all. */
-        if (sentinelSelectSlave(master) == NULL) return;
-        sentinelStartFailover(master,SENTINEL_FAILOVER_STATE_WAIT_START);
-    }
+    sentinelStartFailover(master);
+    return 1;
 }
 
 /* Select a suitable slave to promote. The current algorithm only uses
  * the following parameters:
  *
  * 1) None of the following conditions: S_DOWN, O_DOWN, DISCONNECTED.
- * 2) last_avail_time more recent than SENTINEL_INFO_VALIDITY_TIME.
- * 3) info_refresh more recent than SENTINEL_INFO_VALIDITY_TIME.
+ * 2) Last time the slave replied to ping no more than 5 times the PING period.
+ * 3) info_refresh not older than 3 times the INFO refresh period.
  * 4) master_link_down_time no more than:
  *     (now - master->s_down_since_time) + (master->down_after_period * 10).
+ *    Basically since the master is down from our POV, the slave reports
+ *    to be disconnected no more than 10 times the configured down-after-period.
+ *    This is pretty much black magic but the idea is, the master was not
+ *    available so the slave may be lagging, but not over a certain time.
+ *    Anyway we'll select the best slave according to replication offset.
  * 5) Slave priority can't be zero, otherwise the slave is discarded.
  *
  * Among all the slaves matching the above conditions we select the slave
- * with lower slave_priority. If priority is the same we select the slave
- * with lexicographically smaller runid.
+ * with, in order of sorting key:
+ *
+ * - lower slave_priority.
+ * - bigger processed replication offset.
+ * - lexicographically smaller runid.
+ *
+ * Basically if runid is the same, the slave that processed more commands
+ * from the master is selected.
  *
  * The function returns the pointer to the selected slave, otherwise
  * NULL if no suitable slave was found.
  */
 
+/* Helper for sentinelSelectSlave(). This is used by qsort() in order to
+ * sort suitable slaves in a "better first" order, to take the first of
+ * the list. */
 int compareSlavesForPromotion(const void *a, const void *b) {
     sentinelRedisInstance **sa = (sentinelRedisInstance **)a,
                           **sb = (sentinelRedisInstance **)b;
     char *sa_runid, *sb_runid;
 
     if ((*sa)->slave_priority != (*sb)->slave_priority)
         return (*sa)->slave_priority - (*sb)->slave_priority;
 
-    /* If priority is the same, select the slave with that has the
-     * lexicographically smaller runid. Note that we try to handle runid
+    /* If priority is the same, select the slave with greater replication
+     * offset (processed more data frmo the master). */
+    if ((*sa)->slave_repl_offset > (*sb)->slave_repl_offset) {
+        return -1; /* a < b */
+    } else if ((*sa)->slave_repl_offset < (*sb)->slave_repl_offset) {
+        return 1; /* b > a */
+    }
+
+    /* If the replication offset is the same select the slave with that has
+     * the lexicographically smaller runid. Note that we try to handle runid
      * == NULL as there are old Redis versions that don't publish runid in
      * INFO. A NULL runid is considered bigger than any other runid. */
     sa_runid = (*sa)->runid;
     sb_runid = (*sb)->runid;
     if (sa_runid == NULL && sb_runid == NULL) return 0;
     else if (sa_runid == NULL) return 1;  /* a > b */
@@ -2664,25 +2984,26 @@
         max_master_down_time += mstime() - master->s_down_since_time;
     max_master_down_time += master->down_after_period * 10;
 
     di = dictGetIterator(master->slaves);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *slave = dictGetVal(de);
-        mstime_t info_validity_time = mstime()-SENTINEL_INFO_VALIDITY_TIME;
+        mstime_t info_validity_time;
 
         if (slave->flags & (SRI_S_DOWN|SRI_O_DOWN|SRI_DISCONNECTED)) continue;
-        if (slave->flags & SRI_DEMOTE) continue; /* Old master not yet ready. */
-        if (slave->last_avail_time < info_validity_time) continue;
+        if (mstime() - slave->last_avail_time > SENTINEL_PING_PERIOD*5) continue;
         if (slave->slave_priority == 0) continue;
 
         /* If the master is in SDOWN state we get INFO for slaves every second.
          * Otherwise we get it with the usual period so we need to account for
          * a larger delay. */
-        if ((master->flags & SRI_S_DOWN) == 0)
-            info_validity_time -= SENTINEL_INFO_PERIOD;
-        if (slave->info_refresh < info_validity_time) continue;
+        if (master->flags & SRI_S_DOWN)
+            info_validity_time = SENTINEL_PING_PERIOD*5;
+        else
+            info_validity_time = SENTINEL_INFO_PERIOD*3;
+        if (mstime() - slave->info_refresh > info_validity_time) continue;
         if (slave->master_link_down_time > max_master_down_time) continue;
         instance[instances++] = slave;
     }
     dictReleaseIterator(di);
     if (instances) {
         qsort(instance,instances,sizeof(sentinelRedisInstance*),
@@ -2692,40 +3013,47 @@
     zfree(instance);
     return selected;
 }
 
 /* ---------------- Failover state machine implementation ------------------- */
 void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
-    /* If we in "wait start" but the master is no longer in ODOWN nor in
-     * SDOWN condition we abort the failover. This is important as it
-     * prevents a useless failover in a a notable case of netsplit, where
-     * the sentinels are split from the redis instances. In this case
-     * the failover will not start while there is the split because no
-     * good slave can be reached. However when the split is resolved, we
-     * can go to waitstart if the slave is back reachable a few milliseconds
-     * before the master is. In that case when the master is back online
-     * we cancel the failover. */
-    if ((ri->flags & (SRI_S_DOWN|SRI_O_DOWN|SRI_FORCE_FAILOVER)) == 0) {
-        sentinelEvent(REDIS_WARNING,"-failover-abort-master-is-back",
-            ri,"%@");
-        sentinelAbortFailover(ri);
-        return;
-    }
+    char *leader;
+    int isleader;
 
-    /* Start the failover going to the next state if enough time has
-     * elapsed. */
-    if (mstime() >= ri->failover_start_time) {
-        ri->failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;
-        ri->failover_state_change_time = mstime();
-        sentinelEvent(REDIS_WARNING,"+failover-state-select-slave",ri,"%@");
+    /* Check if we are the leader for the failover epoch. */
+    leader = sentinelGetLeader(ri, ri->failover_epoch);
+    isleader = leader && strcasecmp(leader,server.runid) == 0;
+    sdsfree(leader);
+
+    /* If I'm not the leader, and it is not a forced failover via
+     * SENTINEL FAILOVER, then I can't continue with the failover. */
+    if (!isleader && !(ri->flags & SRI_FORCE_FAILOVER)) {
+        int election_timeout = SENTINEL_ELECTION_TIMEOUT;
+
+        /* The election timeout is the MIN between SENTINEL_ELECTION_TIMEOUT
+         * and the configured failover timeout. */
+        if (election_timeout > ri->failover_timeout)
+            election_timeout = ri->failover_timeout;
+        /* Abort the failover if I'm not the leader after some time. */
+        if (mstime() - ri->failover_start_time > election_timeout) {
+            sentinelEvent(REDIS_WARNING,"-failover-abort-not-elected",ri,"%@");
+            sentinelAbortFailover(ri);
+        }
+        return;
     }
+    sentinelEvent(REDIS_WARNING,"+elected-leader",ri,"%@");
+    ri->failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;
+    ri->failover_state_change_time = mstime();
+    sentinelEvent(REDIS_WARNING,"+failover-state-select-slave",ri,"%@");
 }
 
 void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
     sentinelRedisInstance *slave = sentinelSelectSlave(ri);
 
+    /* We don't handle the timeout in this state as the function aborts
+     * the failover or go forward in the next state. */
     if (slave == NULL) {
         sentinelEvent(REDIS_WARNING,"-failover-abort-no-good-slave",ri,"%@");
         sentinelAbortFailover(ri);
     } else {
         sentinelEvent(REDIS_WARNING,"+selected-slave",slave,"%@");
         slave->flags |= SRI_PROMOTED;
@@ -2737,41 +3065,43 @@
     }
 }
 
 void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
     int retval;
 
-    if (ri->promoted_slave->flags & SRI_DISCONNECTED) return;
+    /* We can't send the command to the promoted slave if it is now
+     * disconnected. Retry again and again with this state until the timeout
+     * is reached, then abort the failover. */
+    if (ri->promoted_slave->flags & SRI_DISCONNECTED) {
+        if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
+            sentinelEvent(REDIS_WARNING,"-failover-abort-slave-timeout",ri,"%@");
+            sentinelAbortFailover(ri);
+        }
+        return;
+    }
 
     /* Send SLAVEOF NO ONE command to turn the slave into a master.
      * We actually register a generic callback for this command as we don't
      * really care about the reply. We check if it worked indirectly observing
      * if INFO returns a different role (master instead of slave). */
-    retval = redisAsyncCommand(ri->promoted_slave->cc,
-        sentinelDiscardReplyCallback, NULL, "SLAVEOF NO ONE");
+    retval = sentinelSendSlaveOf(ri->promoted_slave,NULL,0);
     if (retval != REDIS_OK) return;
-    ri->promoted_slave->pending_commands++;
     sentinelEvent(REDIS_NOTICE, "+failover-state-wait-promotion",
         ri->promoted_slave,"%@");
     ri->failover_state = SENTINEL_FAILOVER_STATE_WAIT_PROMOTION;
     ri->failover_state_change_time = mstime();
 }
 
 /* We actually wait for promotion indirectly checking with INFO when the
  * slave turns into a master. */
 void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
-    mstime_t elapsed = mstime() - ri->failover_state_change_time;
-
-    if (elapsed >= SENTINEL_PROMOTION_RETRY_PERIOD) {
-        sentinelEvent(REDIS_WARNING,"-promotion-timeout",ri->promoted_slave,
-            "%@");
-        sentinelEvent(REDIS_WARNING,"+failover-state-select-slave",ri,"%@");
-        ri->failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;
-        ri->failover_state_change_time = mstime();
-        ri->promoted_slave->flags &= ~SRI_PROMOTED;
-        ri->promoted_slave = NULL;
+    /* Just handle the timeout. Switching to the next state is handled
+     * by the function parsing the INFO command of the promoted slave. */
+    if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
+        sentinelEvent(REDIS_WARNING,"-failover-abort-slave-timeout",ri,"%@");
+        sentinelAbortFailover(ri);
     }
 }
 
 void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
     int not_reconfigured = 0, timeout = 0;
     dictIterator *di;
@@ -2800,45 +3130,35 @@
         not_reconfigured = 0;
         timeout = 1;
         sentinelEvent(REDIS_WARNING,"+failover-end-for-timeout",master,"%@");
     }
 
     if (not_reconfigured == 0) {
-        int role = (master->flags & SRI_I_AM_THE_LEADER) ? SENTINEL_LEADER :
-                                                           SENTINEL_OBSERVER;
-
         sentinelEvent(REDIS_WARNING,"+failover-end",master,"%@");
         master->failover_state = SENTINEL_FAILOVER_STATE_UPDATE_CONFIG;
         master->failover_state_change_time = mstime();
-        sentinelCallClientReconfScript(master,role,"end",master->addr,
-            master->promoted_slave->addr);
     }
 
     /* If I'm the leader it is a good idea to send a best effort SLAVEOF
      * command to all the slaves still not reconfigured to replicate with
      * the new master. */
-    if (timeout && (master->flags & SRI_I_AM_THE_LEADER)) {
+    if (timeout) {
         dictIterator *di;
         dictEntry *de;
-        char master_port[32];
-
-        ll2string(master_port,sizeof(master_port),
-            master->promoted_slave->addr->port);
 
         di = dictGetIterator(master->slaves);
         while((de = dictNext(di)) != NULL) {
             sentinelRedisInstance *slave = dictGetVal(de);
             int retval;
 
             if (slave->flags &
                 (SRI_RECONF_DONE|SRI_RECONF_SENT|SRI_DISCONNECTED)) continue;
 
-            retval = redisAsyncCommand(slave->cc,
-                sentinelDiscardReplyCallback, NULL, "SLAVEOF %s %s",
+            retval = sentinelSendSlaveOf(slave,
                     master->promoted_slave->addr->ip,
-                    master_port);
+                    master->promoted_slave->addr->port);
             if (retval == REDIS_OK) {
                 sentinelEvent(REDIS_NOTICE,"+slave-reconf-sent-be",slave,"%@");
                 slave->flags |= SRI_RECONF_SENT;
             }
         }
         dictReleaseIterator(di);
@@ -2864,13 +3184,12 @@
     di = dictGetIterator(master->slaves);
     while(in_progress < master->parallel_syncs &&
           (de = dictNext(di)) != NULL)
     {
         sentinelRedisInstance *slave = dictGetVal(de);
         int retval;
-        char master_port[32];
 
         /* Skip the promoted slave, and already configured slaves. */
         if (slave->flags & (SRI_PROMOTED|SRI_RECONF_DONE)) continue;
 
         /* Clear the SRI_RECONF_SENT flag if too much time elapsed without
          * the slave moving forward to the next state. */
@@ -2885,37 +3204,31 @@
         /* Nothing to do for instances that are disconnected or already
          * in RECONF_SENT state. */
         if (slave->flags & (SRI_DISCONNECTED|SRI_RECONF_SENT|SRI_RECONF_INPROG))
             continue;
 
         /* Send SLAVEOF <new master>. */
-        ll2string(master_port,sizeof(master_port),
-            master->promoted_slave->addr->port);
-        retval = redisAsyncCommand(slave->cc,
-            sentinelDiscardReplyCallback, NULL, "SLAVEOF %s %s",
+        retval = sentinelSendSlaveOf(slave,
                 master->promoted_slave->addr->ip,
-                master_port);
+                master->promoted_slave->addr->port);
         if (retval == REDIS_OK) {
             slave->flags |= SRI_RECONF_SENT;
-            slave->pending_commands++;
             slave->slave_reconf_sent_time = mstime();
             sentinelEvent(REDIS_NOTICE,"+slave-reconf-sent",slave,"%@");
             in_progress++;
         }
     }
     dictReleaseIterator(di);
+
+    /* Check if all the slaves are reconfigured and handle timeout. */
     sentinelFailoverDetectEnd(master);
 }
 
 /* This function is called when the slave is in
  * SENTINEL_FAILOVER_STATE_UPDATE_CONFIG state. In this state we need
- * to remove it from the master table and add the promoted slave instead.
- *
- * If there are no promoted slaves as this instance is unique, we remove
- * and re-add it with the same address to trigger a complete state
- * refresh. */
+ * to remove it from the master table and add the promoted slave instead. */
 void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
     sentinelRedisInstance *ref = master->promoted_slave ?
                                  master->promoted_slave : master;
     sds old_master_ip;
     int old_master_port;
 
@@ -2923,23 +3236,12 @@
         master->name, master->addr->ip, master->addr->port,
         ref->addr->ip, ref->addr->port);
 
     old_master_ip = sdsdup(master->addr->ip);
     old_master_port = master->addr->port;
     sentinelResetMasterAndChangeAddress(master,ref->addr->ip,ref->addr->port);
-    /* If this is a real switch, that is, we have master->promoted_slave not
-     * NULL, then we want to add the old master as a slave of the new master,
-     * but flagging it with SRI_DEMOTE so that we know we'll need to send
-     * SLAVEOF once the old master is reachable again. */
-    if (master != ref) {
-        /* Add the new slave, but don't generate a Sentinel event as it will
-         * happen later when finally the instance will claim to be a slave
-         * in the INFO output. */
-        createSentinelRedisInstance(NULL,SRI_SLAVE|SRI_DEMOTE,
-                    old_master_ip, old_master_port, master->quorum, master);
-    }
     sdsfree(old_master_ip);
 }
 
 void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
     redisAssert(ri->flags & SRI_MASTER);
 
@@ -2958,117 +3260,45 @@
         case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:
             sentinelFailoverWaitPromotion(ri);
             break;
         case SENTINEL_FAILOVER_STATE_RECONF_SLAVES:
             sentinelFailoverReconfNextSlave(ri);
             break;
-        case SENTINEL_FAILOVER_STATE_DETECT_END:
-            sentinelFailoverDetectEnd(ri);
-            break;
     }
 }
 
-/* Abort a failover in progress with the following steps:
- * 1) If this instance is the leaer send a SLAVEOF command to all the already
- *    reconfigured slaves if any to configure them to replicate with the
- *    original master.
- * 2) For both leaders and observers: clear the failover flags and state in
- *    the master instance.
- * 3) If there is already a promoted slave and we are the leader, and this
- *    slave is not DISCONNECTED, try to reconfigure it to replicate
- *    back to the master as well, sending a best effort SLAVEOF command.
- */
+/* Abort a failover in progress:
+ *
+ * This function can only be called before the promoted slave acknowledged
+ * the slave -> master switch. Otherwise the failover can't be aborted and
+ * will reach its end (possibly by timeout). */
 void sentinelAbortFailover(sentinelRedisInstance *ri) {
-    char master_port[32];
-    dictIterator *di;
-    dictEntry *de;
-    int sentinel_role;
-
     redisAssert(ri->flags & SRI_FAILOVER_IN_PROGRESS);
-    ll2string(master_port,sizeof(master_port),ri->addr->port);
+    redisAssert(ri->failover_state <= SENTINEL_FAILOVER_STATE_WAIT_PROMOTION);
 
-    /* Clear failover related flags from slaves.
-     * Also if we are the leader make sure to send SLAVEOF commands to all the
-     * already reconfigured slaves in order to turn them back into slaves of
-     * the original master. */
-    di = dictGetIterator(ri->slaves);
-    while((de = dictNext(di)) != NULL) {
-        sentinelRedisInstance *slave = dictGetVal(de);
-        if ((ri->flags & SRI_I_AM_THE_LEADER) &&
-            !(slave->flags & SRI_DISCONNECTED) &&
-             (slave->flags & (SRI_PROMOTED|SRI_RECONF_SENT|SRI_RECONF_INPROG|
-                              SRI_RECONF_DONE)))
-        {
-            int retval;
-
-            retval = redisAsyncCommand(slave->cc,
-                sentinelDiscardReplyCallback, NULL, "SLAVEOF %s %s",
-                    ri->addr->ip,
-                    master_port);
-            if (retval == REDIS_OK)
-                sentinelEvent(REDIS_NOTICE,"-slave-reconf-undo",slave,"%@");
-        }
-        slave->flags &= ~(SRI_RECONF_SENT|SRI_RECONF_INPROG|SRI_RECONF_DONE);
-    }
-    dictReleaseIterator(di);
-
-    sentinel_role = (ri->flags & SRI_I_AM_THE_LEADER) ? SENTINEL_LEADER :
-                                                        SENTINEL_OBSERVER;
-    ri->flags &= ~(SRI_FAILOVER_IN_PROGRESS|SRI_I_AM_THE_LEADER|SRI_FORCE_FAILOVER);
+    ri->flags &= ~(SRI_FAILOVER_IN_PROGRESS|SRI_FORCE_FAILOVER);
     ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
     ri->failover_state_change_time = mstime();
     if (ri->promoted_slave) {
-        sentinelCallClientReconfScript(ri,sentinel_role,"abort",
-            ri->promoted_slave->addr,ri->addr);
         ri->promoted_slave->flags &= ~SRI_PROMOTED;
         ri->promoted_slave = NULL;
     }
 }
 
-/* The following is called only for master instances and will abort the
- * failover process if:
- *
- * 1) The failover is in progress.
- * 2) We already promoted a slave.
- * 3) The promoted slave is in extended SDOWN condition.
- */
-void sentinelAbortFailoverIfNeeded(sentinelRedisInstance *ri) {
-    /* Failover is in progress? Do we have a promoted slave? */
-    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS) || !ri->promoted_slave) return;
-
-    /* Is the promoted slave into an extended SDOWN state? */
-    if (!(ri->promoted_slave->flags & SRI_S_DOWN) ||
-        (mstime() - ri->promoted_slave->s_down_since_time) <
-        (ri->down_after_period * SENTINEL_EXTENDED_SDOWN_MULTIPLIER)) return;
-
-    sentinelEvent(REDIS_WARNING,"-failover-abort-x-sdown",ri->promoted_slave,"%@");
-    sentinelAbortFailover(ri);
-}
-
 /* ======================== SENTINEL timer handler ==========================
  * This is the "main" our Sentinel, being sentinel completely non blocking
  * in design. The function is called every second.
  * -------------------------------------------------------------------------- */
 
 /* Perform scheduled operations for the specified Redis instance. */
 void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
     /* ========== MONITORING HALF ============ */
     /* Every kind of instance */
     sentinelReconnectInstance(ri);
     sentinelPingInstance(ri);
 
-    /* Masters and slaves */
-    if (ri->flags & (SRI_MASTER|SRI_SLAVE)) {
-        /* Nothing so far. */
-    }
-
-    /* Only masters */
-    if (ri->flags & SRI_MASTER) {
-        sentinelAskMasterStateToOtherSentinels(ri);
-    }
-
     /* ============== ACTING HALF ============= */
     /* We don't proceed with the acting half if we are in TILT mode.
      * TILT happens when we find something odd with the time, like a
      * sudden change in the clock. */
     if (sentinel.tilt) {
         if (mstime()-sentinel.tilt_start_time < SENTINEL_TILT_PERIOD) return;
@@ -3084,15 +3314,16 @@
         /* Nothing so far. */
     }
 
     /* Only masters */
     if (ri->flags & SRI_MASTER) {
         sentinelCheckObjectivelyDown(ri);
-        sentinelStartFailoverIfNeeded(ri);
+        if (sentinelStartFailoverIfNeeded(ri))
+            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);
         sentinelFailoverStateMachine(ri);
-        sentinelAbortFailoverIfNeeded(ri);
+        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);
     }
 }
 
 /* Perform scheduled operations for all the instances in the dictionary.
  * Recursively call the function against dictionaries of slaves. */
 void sentinelHandleDictOfRedisInstances(dict *instances) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sentinel.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sentinel.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sentinel.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sentinel.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src: setproctitle.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src: setproctitle.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src: setproctitle.o
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sha1.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sha1.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sha1.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sha1.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/slowlog.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/slowlog.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/slowlog.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/slowlog.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sort.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sort.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sort.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sort.c	2013-11-22 17:25:29.000000000 +0800
@@ -160,18 +160,28 @@
                     cmp = 0;
                 else if (so1->u.cmpobj == NULL)
                     cmp = -1;
                 else
                     cmp = 1;
             } else {
-                /* We have both the objects, use strcoll */
-                cmp = strcoll(so1->u.cmpobj->ptr,so2->u.cmpobj->ptr);
+                /* We have both the objects, compare them. */
+                if (server.sort_store) {
+                    cmp = compareStringObjects(so1->u.cmpobj,so2->u.cmpobj);
+                } else {
+                    /* Here we can use strcoll() directly as we are sure that
+                     * the objects are decoded string objects. */
+                    cmp = strcoll(so1->u.cmpobj->ptr,so2->u.cmpobj->ptr);
+                }
             }
         } else {
             /* Compare elements directly. */
-            cmp = compareStringObjects(so1->obj,so2->obj);
+            if (server.sort_store) {
+                cmp = compareStringObjects(so1->obj,so2->obj);
+            } else {
+                cmp = collateStringObjects(so1->obj,so2->obj);
+            }
         }
     }
     return server.sort_desc ? -cmp : cmp;
 }
 
 /* The SORT command is the most complex command in Redis. Warning: this code
@@ -429,12 +439,13 @@
     }
 
     if (dontsort == 0) {
         server.sort_desc = desc;
         server.sort_alpha = alpha;
         server.sort_bypattern = sortby ? 1 : 0;
+        server.sort_store = storekey ? 1 : 0;
         if (sortby && (start != 0 || end != vectorlen-1))
             pqsort(vector,vectorlen,sizeof(redisSortObject),sortCompare, start,end);
         else
             qsort(vector,vectorlen,sizeof(redisSortObject),sortCompare);
     }
 
@@ -501,15 +512,18 @@
                     }
                 }
             }
         }
         if (outputlen) {
             setKey(c->db,storekey,sobj);
+            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"sortstore",storekey,
+                                c->db->id);
             server.dirty += outputlen;
         } else if (dbDelete(c->db,storekey)) {
             signalModifiedKey(c->db,storekey);
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",storekey,c->db->id);
             server.dirty++;
         }
         decrRefCount(sobj);
         addReplyLongLong(c,outputlen);
     }
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sort.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sort.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/sort.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/sort.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/syncio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/syncio.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/syncio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/syncio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_hash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_hash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_hash.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_hash.c	2013-11-22 17:25:29.000000000 +0800
@@ -471,12 +471,13 @@
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
     hashTypeTryConversion(o,c->argv,2,3);
     hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);
     update = hashTypeSet(o,c->argv[2],c->argv[3]);
     addReply(c, update ? shared.czero : shared.cone);
     signalModifiedKey(c->db,c->argv[1]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hset",c->argv[1],c->db->id);
     server.dirty++;
 }
 
 void hsetnxCommand(redisClient *c) {
     robj *o;
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
@@ -486,12 +487,13 @@
         addReply(c, shared.czero);
     } else {
         hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);
         hashTypeSet(o,c->argv[2],c->argv[3]);
         addReply(c, shared.cone);
         signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hset",c->argv[1],c->db->id);
         server.dirty++;
     }
 }
 
 void hmsetCommand(redisClient *c) {
     int i;
@@ -507,12 +509,13 @@
     for (i = 2; i < c->argc; i += 2) {
         hashTypeTryObjectEncoding(o,&c->argv[i], &c->argv[i+1]);
         hashTypeSet(o,c->argv[i],c->argv[i+1]);
     }
     addReply(c, shared.ok);
     signalModifiedKey(c->db,c->argv[1]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hset",c->argv[1],c->db->id);
     server.dirty++;
 }
 
 void hincrbyCommand(redisClient *c) {
     long long value, incr, oldvalue;
     robj *o, *current, *new;
@@ -540,12 +543,13 @@
     new = createStringObjectFromLongLong(value);
     hashTypeTryObjectEncoding(o,&c->argv[2],NULL);
     hashTypeSet(o,c->argv[2],new);
     decrRefCount(new);
     addReplyLongLong(c,value);
     signalModifiedKey(c->db,c->argv[1]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hincrby",c->argv[1],c->db->id);
     server.dirty++;
 }
 
 void hincrbyfloatCommand(redisClient *c) {
     double long value, incr;
     robj *o, *current, *new, *aux;
@@ -566,12 +570,13 @@
     value += incr;
     new = createStringObjectFromLongDouble(value);
     hashTypeTryObjectEncoding(o,&c->argv[2],NULL);
     hashTypeSet(o,c->argv[2],new);
     addReplyBulk(c,new);
     signalModifiedKey(c->db,c->argv[1]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hincrbyfloat",c->argv[1],c->db->id);
     server.dirty++;
 
     /* Always replicate HINCRBYFLOAT as an HSET command with the final value
      * in order to make sure that differences in float pricision or formatting
      * will not create differences in replicas or after an AOF restart. */
     aux = createStringObject("HSET",4);
@@ -646,28 +651,33 @@
         addHashFieldToReply(c, o, c->argv[i]);
     }
 }
 
 void hdelCommand(redisClient *c) {
     robj *o;
-    int j, deleted = 0;
+    int j, deleted = 0, keyremoved = 0;
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,o,REDIS_HASH)) return;
 
     for (j = 2; j < c->argc; j++) {
         if (hashTypeDelete(o,c->argv[j])) {
             deleted++;
             if (hashTypeLength(o) == 0) {
                 dbDelete(c->db,c->argv[1]);
+                keyremoved = 1;
                 break;
             }
         }
     }
     if (deleted) {
         signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_HASH,"hdel",c->argv[1],c->db->id);
+        if (keyremoved)
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],
+                                c->db->id);
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
 }
 
 void hlenCommand(redisClient *c) {
@@ -749,6 +759,16 @@
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,o,REDIS_HASH)) return;
 
     addReply(c, hashTypeExists(o,c->argv[2]) ? shared.cone : shared.czero);
 }
+
+void hscanCommand(redisClient *c) {
+    robj *o;
+    unsigned long cursor;
+
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == REDIS_ERR) return;
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
+        checkType(c,o,REDIS_HASH)) return;
+    scanGenericCommand(c,o,cursor);
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_hash.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_hash.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_hash.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_hash.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_list.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_list.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_list.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_list.c	2013-11-22 17:25:29.000000000 +0800
@@ -272,13 +272,13 @@
     listTypeIterator *li;
     listTypeEntry entry;
     redisAssertWithInfo(NULL,subject,subject->type == REDIS_LIST);
 
     if (enc == REDIS_ENCODING_LINKEDLIST) {
         list *l = listCreate();
-        listSetFreeMethod(l,decrRefCount);
+        listSetFreeMethod(l,decrRefCountVoid);
 
         /* listTypeGet returns a robj with incremented refcount */
         li = listTypeInitIterator(subject,0,REDIS_TAIL);
         while (listTypeNext(li,&entry)) listAddNodeTail(l,listTypeGet(&entry));
         listTypeReleaseIterator(li);
 
@@ -313,13 +313,18 @@
             dbAdd(c->db,c->argv[1],lobj);
         }
         listTypePush(lobj,c->argv[j],where);
         pushed++;
     }
     addReplyLongLong(c, waiting + (lobj ? listTypeLength(lobj) : 0));
-    if (pushed) signalModifiedKey(c->db,c->argv[1]);
+    if (pushed) {
+        char *event = (where == REDIS_HEAD) ? "lpush" : "rpush";
+
+        signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,c->argv[1],c->db->id);
+    }
     server.dirty += pushed;
 }
 
 void lpushCommand(redisClient *c) {
     pushGenericCommand(c,REDIS_HEAD);
 }
@@ -335,16 +340,12 @@
     int inserted = 0;
 
     if ((subject = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,subject,REDIS_LIST)) return;
 
     if (refval != NULL) {
-        /* Note: we expect refval to be string-encoded because it is *not* the
-         * last argument of the multi-bulk LINSERT. */
-        redisAssertWithInfo(c,refval,refval->encoding == REDIS_ENCODING_RAW);
-
         /* We're not sure if this value can be inserted yet, but we cannot
          * convert the list inside the iterator. We don't want to loop over
          * the list twice (once to see if the value can be inserted and once
          * to do the actual insert), so we assume this value can be inserted
          * and convert the ziplist to a regular list if necessary. */
         listTypeTryConversion(subject,val);
@@ -363,21 +364,26 @@
         if (inserted) {
             /* Check if the length exceeds the ziplist length threshold. */
             if (subject->encoding == REDIS_ENCODING_ZIPLIST &&
                 ziplistLen(subject->ptr) > server.list_max_ziplist_entries)
                     listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);
             signalModifiedKey(c->db,c->argv[1]);
+            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"linsert",
+                                c->argv[1],c->db->id);
             server.dirty++;
         } else {
             /* Notify client of a failed insert */
             addReply(c,shared.cnegone);
             return;
         }
     } else {
+        char *event = (where == REDIS_HEAD) ? "lpush" : "rpush";
+
         listTypePush(subject,val,where);
         signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,c->argv[1],c->db->id);
         server.dirty++;
     }
 
     addReplyLongLong(c,listTypeLength(subject));
 }
 
@@ -466,24 +472,26 @@
             o->ptr = ziplistDelete(o->ptr,&p);
             value = getDecodedObject(value);
             o->ptr = ziplistInsert(o->ptr,p,value->ptr,sdslen(value->ptr));
             decrRefCount(value);
             addReply(c,shared.ok);
             signalModifiedKey(c->db,c->argv[1]);
+            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"lset",c->argv[1],c->db->id);
             server.dirty++;
         }
     } else if (o->encoding == REDIS_ENCODING_LINKEDLIST) {
         listNode *ln = listIndex(o->ptr,index);
         if (ln == NULL) {
             addReply(c,shared.outofrangeerr);
         } else {
             decrRefCount((robj*)listNodeValue(ln));
             listNodeValue(ln) = value;
             incrRefCount(value);
             addReply(c,shared.ok);
             signalModifiedKey(c->db,c->argv[1]);
+            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"lset",c->argv[1],c->db->id);
             server.dirty++;
         }
     } else {
         redisPanic("Unknown list encoding");
     }
 }
@@ -493,15 +501,22 @@
     if (o == NULL || checkType(c,o,REDIS_LIST)) return;
 
     robj *value = listTypePop(o,where);
     if (value == NULL) {
         addReply(c,shared.nullbulk);
     } else {
+        char *event = (where == REDIS_HEAD) ? "lpop" : "rpop";
+
         addReplyBulk(c,value);
         decrRefCount(value);
-        if (listTypeLength(o) == 0) dbDelete(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,c->argv[1],c->db->id);
+        if (listTypeLength(o) == 0) {
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+                                c->argv[1],c->db->id);
+            dbDelete(c->db,c->argv[1]);
+        }
         signalModifiedKey(c->db,c->argv[1]);
         server.dirty++;
     }
 }
 
 void lpopCommand(redisClient *c) {
@@ -615,13 +630,18 @@
             ln = listLast(list);
             listDelNode(list,ln);
         }
     } else {
         redisPanic("Unknown list encoding");
     }
-    if (listTypeLength(o) == 0) dbDelete(c->db,c->argv[1]);
+
+    notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"ltrim",c->argv[1],c->db->id);
+    if (listTypeLength(o) == 0) {
+        dbDelete(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
+    }
     signalModifiedKey(c->db,c->argv[1]);
     server.dirty++;
     addReply(c,shared.ok);
 }
 
 void lremCommand(redisClient *c) {
@@ -690,12 +710,13 @@
         dstobj = createZiplistObject();
         dbAdd(c->db,dstkey,dstobj);
         signalListAsReady(c,dstkey);
     }
     signalModifiedKey(c->db,dstkey);
     listTypePush(dstobj,value,REDIS_HEAD);
+    notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"lpush",dstkey,c->db->id);
     /* Always send the pushed value to the client. */
     addReplyBulk(c,value);
 }
 
 void rpoplpushCommand(redisClient *c) {
     robj *sobj, *value;
@@ -719,13 +740,18 @@
         rpoplpushHandlePush(c,c->argv[2],dobj,value);
 
         /* listTypePop returns an object with its refcount incremented */
         decrRefCount(value);
 
         /* Delete the source list when it is empty */
-        if (listTypeLength(sobj) == 0) dbDelete(c->db,touchedkey);
+        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,"rpop",touchedkey,c->db->id);
+        if (listTypeLength(sobj) == 0) {
+            dbDelete(c->db,touchedkey);
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+                                touchedkey,c->db->id);
+        }
         signalModifiedKey(c->db,touchedkey);
         decrRefCount(touchedkey);
         server.dirty++;
     }
 }
 
@@ -1043,20 +1069,27 @@
             if (o->type != REDIS_LIST) {
                 addReply(c,shared.wrongtypeerr);
                 return;
             } else {
                 if (listTypeLength(o) != 0) {
                     /* Non empty list, this is like a non normal [LR]POP. */
+                    char *event = (where == REDIS_HEAD) ? "lpop" : "rpop";
                     robj *value = listTypePop(o,where);
                     redisAssert(value != NULL);
 
                     addReplyMultiBulkLen(c,2);
                     addReplyBulk(c,c->argv[j]);
                     addReplyBulk(c,value);
                     decrRefCount(value);
-                    if (listTypeLength(o) == 0) dbDelete(c->db,c->argv[j]);
+                    notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,
+                                        c->argv[j],c->db->id);
+                    if (listTypeLength(o) == 0) {
+                        dbDelete(c->db,c->argv[j]);
+                        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+                                            c->argv[j],c->db->id);
+                    }
                     signalModifiedKey(c->db,c->argv[j]);
                     server.dirty++;
 
                     /* Replicate it as an [LR]POP instead of B[LR]POP. */
                     rewriteClientCommandVector(c,2,
                         (where == REDIS_HEAD) ? shared.lpop : shared.rpop,
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_list.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_list.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_list.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_list.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_set.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_set.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_set.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_set.c	2013-11-22 17:25:29.000000000 +0800
@@ -263,35 +263,43 @@
     }
 
     for (j = 2; j < c->argc; j++) {
         c->argv[j] = tryObjectEncoding(c->argv[j]);
         if (setTypeAdd(set,c->argv[j])) added++;
     }
-    if (added) signalModifiedKey(c->db,c->argv[1]);
+    if (added) {
+        signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_SET,"sadd",c->argv[1],c->db->id);
+    }
     server.dirty += added;
     addReplyLongLong(c,added);
 }
 
 void sremCommand(redisClient *c) {
     robj *set;
-    int j, deleted = 0;
+    int j, deleted = 0, keyremoved = 0;
 
     if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,set,REDIS_SET)) return;
 
     for (j = 2; j < c->argc; j++) {
         if (setTypeRemove(set,c->argv[j])) {
             deleted++;
             if (setTypeSize(set) == 0) {
                 dbDelete(c->db,c->argv[1]);
+                keyremoved = 1;
                 break;
             }
         }
     }
     if (deleted) {
         signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_SET,"srem",c->argv[1],c->db->id);
+        if (keyremoved)
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],
+                                c->db->id);
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
 }
 
 void smoveCommand(redisClient *c) {
@@ -319,27 +327,34 @@
 
     /* If the element cannot be removed from the src set, return 0. */
     if (!setTypeRemove(srcset,ele)) {
         addReply(c,shared.czero);
         return;
     }
+    notifyKeyspaceEvent(REDIS_NOTIFY_SET,"srem",c->argv[1],c->db->id);
 
     /* Remove the src set from the database when empty */
-    if (setTypeSize(srcset) == 0) dbDelete(c->db,c->argv[1]);
+    if (setTypeSize(srcset) == 0) {
+        dbDelete(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
+    }
     signalModifiedKey(c->db,c->argv[1]);
     signalModifiedKey(c->db,c->argv[2]);
     server.dirty++;
 
     /* Create the destination set when it doesn't exist */
     if (!dstset) {
         dstset = setTypeCreate(ele);
         dbAdd(c->db,c->argv[2],dstset);
     }
 
     /* An extra key has changed when ele was successfully added to dstset */
-    if (setTypeAdd(dstset,ele)) server.dirty++;
+    if (setTypeAdd(dstset,ele)) {
+        server.dirty++;
+        notifyKeyspaceEvent(REDIS_NOTIFY_SET,"sadd",c->argv[2],c->db->id);
+    }
     addReply(c,shared.cone);
 }
 
 void sismemberCommand(redisClient *c) {
     robj *set;
 
@@ -375,21 +390,25 @@
         ele = createStringObjectFromLongLong(llele);
         set->ptr = intsetRemove(set->ptr,llele,NULL);
     } else {
         incrRefCount(ele);
         setTypeRemove(set,ele);
     }
+    notifyKeyspaceEvent(REDIS_NOTIFY_SET,"spop",c->argv[1],c->db->id);
 
     /* Replicate/AOF this command as an SREM operation */
     aux = createStringObject("SREM",4);
     rewriteClientCommandVector(c,3,aux,c->argv[1],ele);
     decrRefCount(ele);
     decrRefCount(aux);
 
     addReplyBulk(c,ele);
-    if (setTypeSize(set) == 0) dbDelete(c->db,c->argv[1]);
+    if (setTypeSize(set) == 0) {
+        dbDelete(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
+    }
     signalModifiedKey(c->db,c->argv[1]);
     server.dirty++;
 }
 
 /* handle the "SRANDMEMBER key <count>" variant. The normal version of the
  * command is handled by the srandmemberCommand() function itself. */
@@ -562,12 +581,20 @@
 }
 
 int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
     return setTypeSize(*(robj**)s1)-setTypeSize(*(robj**)s2);
 }
 
+/* This is used by SDIFF and in this case we can receive NULL that should
+ * be handled as empty sets. */
+int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
+    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
+
+    return  (o2 ? setTypeSize(o2) : 0) - (o1 ? setTypeSize(o1) : 0);
+}
+
 void sinterGenericCommand(redisClient *c, robj **setkeys, unsigned long setnum, robj *dstkey) {
     robj **sets = zmalloc(sizeof(robj*)*setnum);
     setTypeIterator *si;
     robj *eleobj, *dstset = NULL;
     int64_t intobj;
     void *replylen = NULL;
@@ -676,19 +703,24 @@
     }
     setTypeReleaseIterator(si);
 
     if (dstkey) {
         /* Store the resulting set into the target, if the intersection
          * is not an empty set. */
-        dbDelete(c->db,dstkey);
+        int deleted = dbDelete(c->db,dstkey);
         if (setTypeSize(dstset) > 0) {
             dbAdd(c->db,dstkey,dstset);
             addReplyLongLong(c,setTypeSize(dstset));
+            notifyKeyspaceEvent(REDIS_NOTIFY_SET,"sinterstore",
+                dstkey,c->db->id);
         } else {
             decrRefCount(dstset);
             addReply(c,shared.czero);
+            if (deleted)
+                notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+                    dstkey,c->db->id);
         }
         signalModifiedKey(c->db,dstkey);
         server.dirty++;
     } else {
         setDeferredMultiBulkLength(c,replylen,cardinality);
     }
@@ -709,12 +741,13 @@
 
 void sunionDiffGenericCommand(redisClient *c, robj **setkeys, int setnum, robj *dstkey, int op) {
     robj **sets = zmalloc(sizeof(robj*)*setnum);
     setTypeIterator *si;
     robj *ele, *dstset = NULL;
     int j, cardinality = 0;
+    int diff_algo = 1;
 
     for (j = 0; j < setnum; j++) {
         robj *setobj = dstkey ?
             lookupKeyWrite(c->db,setkeys[j]) :
             lookupKeyRead(c->db,setkeys[j]);
         if (!setobj) {
@@ -725,40 +758,112 @@
             zfree(sets);
             return;
         }
         sets[j] = setobj;
     }
 
+    /* Select what DIFF algorithm to use.
+     *
+     * Algorithm 1 is O(N*M) where N is the size of the element first set
+     * and M the total number of sets.
+     *
+     * Algorithm 2 is O(N) where N is the total number of elements in all
+     * the sets.
+     *
+     * We compute what is the best bet with the current input here. */
+    if (op == REDIS_OP_DIFF && sets[0]) {
+        long long algo_one_work = 0, algo_two_work = 0;
+
+        for (j = 0; j < setnum; j++) {
+            if (sets[j] == NULL) continue;
+
+            algo_one_work += setTypeSize(sets[0]);
+            algo_two_work += setTypeSize(sets[j]);
+        }
+
+        /* Algorithm 1 has better constant times and performs less operations
+         * if there are elements in common. Give it some advantage. */
+        algo_one_work /= 2;
+        diff_algo = (algo_one_work <= algo_two_work) ? 1 : 2;
+
+        if (diff_algo == 1 && setnum > 1) {
+            /* With algorithm 1 it is better to order the sets to subtract
+             * by decreasing size, so that we are more likely to find
+             * duplicated elements ASAP. */
+            qsort(sets+1,setnum-1,sizeof(robj*),
+                qsortCompareSetsByRevCardinality);
+        }
+    }
+
     /* We need a temp set object to store our union. If the dstkey
      * is not NULL (that is, we are inside an SUNIONSTORE operation) then
      * this set object will be the resulting object to set into the target key*/
     dstset = createIntsetObject();
 
-    /* Iterate all the elements of all the sets, add every element a single
-     * time to the result set */
-    for (j = 0; j < setnum; j++) {
-        if (op == REDIS_OP_DIFF && j == 0 && !sets[j]) break; /* result set is empty */
-        if (!sets[j]) continue; /* non existing keys are like empty sets */
-
-        si = setTypeInitIterator(sets[j]);
+    if (op == REDIS_OP_UNION) {
+        /* Union is trivial, just add every element of every set to the
+         * temporary set. */
+        for (j = 0; j < setnum; j++) {
+            if (!sets[j]) continue; /* non existing keys are like empty sets */
+
+            si = setTypeInitIterator(sets[j]);
+            while((ele = setTypeNextObject(si)) != NULL) {
+                if (setTypeAdd(dstset,ele)) cardinality++;
+                decrRefCount(ele);
+            }
+            setTypeReleaseIterator(si);
+        }
+    } else if (op == REDIS_OP_DIFF && sets[0] && diff_algo == 1) {
+        /* DIFF Algorithm 1:
+         *
+         * We perform the diff by iterating all the elements of the first set,
+         * and only adding it to the target set if the element does not exist
+         * into all the other sets.
+         *
+         * This way we perform at max N*M operations, where N is the size of
+         * the first set, and M the number of sets. */
+        si = setTypeInitIterator(sets[0]);
         while((ele = setTypeNextObject(si)) != NULL) {
-            if (op == REDIS_OP_UNION || j == 0) {
-                if (setTypeAdd(dstset,ele)) {
-                    cardinality++;
-                }
-            } else if (op == REDIS_OP_DIFF) {
-                if (setTypeRemove(dstset,ele)) {
-                    cardinality--;
-                }
+            for (j = 1; j < setnum; j++) {
+                if (!sets[j]) continue; /* no key is an empty set. */
+                if (setTypeIsMember(sets[j],ele)) break;
+            }
+            if (j == setnum) {
+                /* There is no other set with this element. Add it. */
+                setTypeAdd(dstset,ele);
+                cardinality++;
             }
             decrRefCount(ele);
         }
         setTypeReleaseIterator(si);
+    } else if (op == REDIS_OP_DIFF && sets[0] && diff_algo == 2) {
+        /* DIFF Algorithm 2:
+         *
+         * Add all the elements of the first set to the auxiliary set.
+         * Then remove all the elements of all the next sets from it.
+         *
+         * This is O(N) where N is the sum of all the elements in every
+         * set. */
+        for (j = 0; j < setnum; j++) {
+            if (!sets[j]) continue; /* non existing keys are like empty sets */
+
+            si = setTypeInitIterator(sets[j]);
+            while((ele = setTypeNextObject(si)) != NULL) {
+                if (j == 0) {
+                    if (setTypeAdd(dstset,ele)) cardinality++;
+                } else {
+                    if (setTypeRemove(dstset,ele)) cardinality--;
+                }
+                decrRefCount(ele);
+            }
+            setTypeReleaseIterator(si);
 
-        /* Exit when result set is empty. */
-        if (op == REDIS_OP_DIFF && cardinality == 0) break;
+            /* Exit if result set is empty as any additional removal
+             * of elements will have no effect. */
+            if (cardinality == 0) break;
+        }
     }
 
     /* Output the content of the resulting set, if not in STORE mode */
     if (!dstkey) {
         addReplyMultiBulkLen(c,cardinality);
         si = setTypeInitIterator(dstset);
@@ -768,19 +873,25 @@
         }
         setTypeReleaseIterator(si);
         decrRefCount(dstset);
     } else {
         /* If we have a target key where to store the resulting set
          * create this key with the result set inside */
-        dbDelete(c->db,dstkey);
+        int deleted = dbDelete(c->db,dstkey);
         if (setTypeSize(dstset) > 0) {
             dbAdd(c->db,dstkey,dstset);
             addReplyLongLong(c,setTypeSize(dstset));
+            notifyKeyspaceEvent(REDIS_NOTIFY_SET,
+                op == REDIS_OP_UNION ? "sunionstore" : "sdiffstore",
+                dstkey,c->db->id);
         } else {
             decrRefCount(dstset);
             addReply(c,shared.czero);
+            if (deleted)
+                notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",
+                    dstkey,c->db->id);
         }
         signalModifiedKey(c->db,dstkey);
         server.dirty++;
     }
     zfree(sets);
 }
@@ -797,6 +908,16 @@
     sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,REDIS_OP_DIFF);
 }
 
 void sdiffstoreCommand(redisClient *c) {
     sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],REDIS_OP_DIFF);
 }
+
+void sscanCommand(redisClient *c) {
+    robj *set;
+    unsigned long cursor;
+
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == REDIS_ERR) return;
+    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
+        checkType(c,set,REDIS_SET)) return;
+    scanGenericCommand(c,set,cursor);
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_set.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_set.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_set.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_set.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_string.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_string.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_string.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_string.c	2013-11-22 17:25:29.000000000 +0800
@@ -81,12 +81,15 @@
         addReply(c, abort_reply ? abort_reply : shared.nullbulk);
         return;
     }
     setKey(c->db,key,val);
     server.dirty++;
     if (expire) setExpire(c->db,key,mstime()+milliseconds);
+    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"set",key,c->db->id);
+    if (expire) notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,
+        "expire",key,c->db->id);
     addReply(c, ok_reply ? ok_reply : shared.ok);
 }
 
 /* SET key value [NX] [XX] [EX <seconds>] [PX <milliseconds>] */
 void setCommand(redisClient *c) {
     int j;
@@ -159,12 +162,13 @@
 }
 
 void getsetCommand(redisClient *c) {
     if (getGenericCommand(c) == REDIS_ERR) return;
     c->argv[2] = tryObjectEncoding(c->argv[2]);
     setKey(c->db,c->argv[1],c->argv[2]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"set",c->argv[1],c->db->id);
     server.dirty++;
 }
 
 void setrangeCommand(redisClient *c) {
     robj *o;
     long offset;
@@ -220,12 +224,14 @@
     }
 
     if (sdslen(value) > 0) {
         o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));
         memcpy((char*)o->ptr+offset,value,sdslen(value));
         signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_STRING,
+            "setrange",c->argv[1],c->db->id);
         server.dirty++;
     }
     addReplyLongLong(c,sdslen(o->ptr));
 }
 
 void getrangeCommand(redisClient *c) {
@@ -304,12 +310,13 @@
         }
     }
 
     for (j = 1; j < c->argc; j += 2) {
         c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
         setKey(c->db,c->argv[j],c->argv[j+1]);
+        notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"set",c->argv[j],c->db->id);
     }
     server.dirty += (c->argc-1)/2;
     addReply(c, nx ? shared.cone : shared.ok);
 }
 
 void msetCommand(redisClient *c) {
@@ -338,12 +345,13 @@
     new = createStringObjectFromLongLong(value);
     if (o)
         dbOverwrite(c->db,c->argv[1],new);
     else
         dbAdd(c->db,c->argv[1],new);
     signalModifiedKey(c->db,c->argv[1]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"incrby",c->argv[1],c->db->id);
     server.dirty++;
     addReply(c,shared.colon);
     addReply(c,new);
     addReply(c,shared.crlf);
 }
 
@@ -387,12 +395,13 @@
     new = createStringObjectFromLongDouble(value);
     if (o)
         dbOverwrite(c->db,c->argv[1],new);
     else
         dbAdd(c->db,c->argv[1],new);
     signalModifiedKey(c->db,c->argv[1]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"incrbyfloat",c->argv[1],c->db->id);
     server.dirty++;
     addReplyBulk(c,new);
 
     /* Always replicate INCRBYFLOAT as a SET command with the final value
      * in order to make sure that differences in float precision or formatting
      * will not create differences in replicas or after an AOF restart. */
@@ -434,12 +443,13 @@
 
         /* Append the value */
         o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));
         totlen = sdslen(o->ptr);
     }
     signalModifiedKey(c->db,c->argv[1]);
+    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,"append",c->argv[1],c->db->id);
     server.dirty++;
     addReplyLongLong(c,totlen);
 }
 
 void strlenCommand(redisClient *c) {
     robj *o;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_string.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_string.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_string.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_string.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_zset.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_zset.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_zset.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_zset.c	2013-11-22 17:25:29.000000000 +0800
@@ -841,32 +841,28 @@
 void zaddGenericCommand(redisClient *c, int incr) {
     static char *nanerr = "resulting score is not a number (NaN)";
     robj *key = c->argv[1];
     robj *ele;
     robj *zobj;
     robj *curobj;
-    double score = 0, *scores, curscore = 0.0;
+    double score = 0, *scores = NULL, curscore = 0.0;
     int j, elements = (c->argc-2)/2;
-    int added = 0;
+    int added = 0, updated = 0;
 
     if (c->argc % 2) {
         addReply(c,shared.syntaxerr);
         return;
     }
 
     /* Start parsing all the scores, we need to emit any syntax error
      * before executing additions to the sorted set, as the command should
      * either execute fully or nothing at all. */
     scores = zmalloc(sizeof(double)*elements);
     for (j = 0; j < elements; j++) {
         if (getDoubleFromObjectOrReply(c,c->argv[2+j*2],&scores[j],NULL)
-            != REDIS_OK)
-        {
-            zfree(scores);
-            return;
-        }
+            != REDIS_OK) goto cleanup;
     }
 
     /* Lookup the key and create the sorted set if does not exist. */
     zobj = lookupKeyWrite(c->db,key);
     if (zobj == NULL) {
         if (server.zset_max_ziplist_entries == 0 ||
@@ -877,14 +873,13 @@
             zobj = createZsetZiplistObject();
         }
         dbAdd(c->db,key,zobj);
     } else {
         if (zobj->type != REDIS_ZSET) {
             addReply(c,shared.wrongtypeerr);
-            zfree(scores);
-            return;
+            goto cleanup;
         }
     }
 
     for (j = 0; j < elements; j++) {
         score = scores[j];
 
@@ -895,39 +890,33 @@
             ele = c->argv[3+j*2];
             if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {
                 if (incr) {
                     score += curscore;
                     if (isnan(score)) {
                         addReplyError(c,nanerr);
-                        /* Don't need to check if the sorted set is empty
-                         * because we know it has at least one element. */
-                        zfree(scores);
-                        return;
+                        goto cleanup;
                     }
                 }
 
                 /* Remove and re-insert when score changed. */
                 if (score != curscore) {
                     zobj->ptr = zzlDelete(zobj->ptr,eptr);
                     zobj->ptr = zzlInsert(zobj->ptr,ele,score);
-
-                    signalModifiedKey(c->db,key);
                     server.dirty++;
+                    updated++;
                 }
             } else {
                 /* Optimize: check if the element is too large or the list
                  * becomes too long *before* executing zzlInsert. */
                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);
                 if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries)
                     zsetConvert(zobj,REDIS_ENCODING_SKIPLIST);
                 if (sdslen(ele->ptr) > server.zset_max_ziplist_value)
                     zsetConvert(zobj,REDIS_ENCODING_SKIPLIST);
-
-                signalModifiedKey(c->db,key);
                 server.dirty++;
-                if (!incr) added++;
+                added++;
             }
         } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
             zset *zs = zobj->ptr;
             zskiplistNode *znode;
             dictEntry *de;
 
@@ -940,48 +929,51 @@
                 if (incr) {
                     score += curscore;
                     if (isnan(score)) {
                         addReplyError(c,nanerr);
                         /* Don't need to check if the sorted set is empty
                          * because we know it has at least one element. */
-                        zfree(scores);
-                        return;
+                        goto cleanup;
                     }
                 }
 
                 /* Remove and re-insert when score changed. We can safely
                  * delete the key object from the skiplist, since the
                  * dictionary still has a reference to it. */
                 if (score != curscore) {
                     redisAssertWithInfo(c,curobj,zslDelete(zs->zsl,curscore,curobj));
                     znode = zslInsert(zs->zsl,score,curobj);
                     incrRefCount(curobj); /* Re-inserted in skiplist. */
                     dictGetVal(de) = &znode->score; /* Update score ptr. */
-
-                    signalModifiedKey(c->db,key);
                     server.dirty++;
+                    updated++;
                 }
             } else {
                 znode = zslInsert(zs->zsl,score,ele);
                 incrRefCount(ele); /* Inserted in skiplist. */
                 redisAssertWithInfo(c,NULL,dictAdd(zs->dict,ele,&znode->score) == DICT_OK);
                 incrRefCount(ele); /* Added to dictionary. */
-
-                signalModifiedKey(c->db,key);
                 server.dirty++;
-                if (!incr) added++;
+                added++;
             }
         } else {
             redisPanic("Unknown sorted set encoding");
         }
     }
-    zfree(scores);
     if (incr) /* ZINCRBY */
         addReplyDouble(c,score);
     else /* ZADD */
         addReplyLongLong(c,added);
+
+cleanup:
+    zfree(scores);
+    if (added || updated) {
+        signalModifiedKey(c->db,key);
+        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,
+            incr ? "zincr" : "zadd", key, c->db->id);
+    }
 }
 
 void zaddCommand(redisClient *c) {
     zaddGenericCommand(c,0);
 }
 
@@ -989,13 +981,13 @@
     zaddGenericCommand(c,1);
 }
 
 void zremCommand(redisClient *c) {
     robj *key = c->argv[1];
     robj *zobj;
-    int deleted = 0, j;
+    int deleted = 0, keyremoved = 0, j;
 
     if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
         checkType(c,zobj,REDIS_ZSET)) return;
 
     if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
         unsigned char *eptr;
@@ -1035,22 +1027,26 @@
         }
     } else {
         redisPanic("Unknown sorted set encoding");
     }
 
     if (deleted) {
+        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,"zrem",key,c->db->id);
+        if (keyremoved)
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",key,c->db->id);
         signalModifiedKey(c->db,key);
         server.dirty += deleted;
     }
     addReplyLongLong(c,deleted);
 }
 
 void zremrangebyscoreCommand(redisClient *c) {
     robj *key = c->argv[1];
     robj *zobj;
     zrangespec range;
+    int keyremoved = 0;
     unsigned long deleted;
 
     /* Parse the range arguments. */
     if (zslParseRange(c->argv[2],c->argv[3],&range) != REDIS_OK) {
         addReplyError(c,"min or max is not a float");
         return;
@@ -1058,34 +1054,46 @@
 
     if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
         checkType(c,zobj,REDIS_ZSET)) return;
 
     if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
         zobj->ptr = zzlDeleteRangeByScore(zobj->ptr,range,&deleted);
-        if (zzlLength(zobj->ptr) == 0) dbDelete(c->db,key);
+        if (zzlLength(zobj->ptr) == 0) {
+            dbDelete(c->db,key);
+            keyremoved = 1;
+        }
     } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         deleted = zslDeleteRangeByScore(zs->zsl,range,zs->dict);
         if (htNeedsResize(zs->dict)) dictResize(zs->dict);
-        if (dictSize(zs->dict) == 0) dbDelete(c->db,key);
+        if (dictSize(zs->dict) == 0) {
+            dbDelete(c->db,key);
+            keyremoved = 1;
+        }
     } else {
         redisPanic("Unknown sorted set encoding");
     }
 
-    if (deleted) signalModifiedKey(c->db,key);
+    if (deleted) {
+        signalModifiedKey(c->db,key);
+        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,"zrembyscore",key,c->db->id);
+        if (keyremoved)
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",key,c->db->id);
+    }
     server.dirty += deleted;
     addReplyLongLong(c,deleted);
 }
 
 void zremrangebyrankCommand(redisClient *c) {
     robj *key = c->argv[1];
     robj *zobj;
     long start;
     long end;
     int llen;
     unsigned long deleted;
+    int keyremoved = 0;
 
     if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != REDIS_OK) ||
         (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != REDIS_OK)) return;
 
     if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
         checkType(c,zobj,REDIS_ZSET)) return;
@@ -1104,25 +1112,36 @@
     }
     if (end >= llen) end = llen-1;
 
     if (zobj->encoding == REDIS_ENCODING_ZIPLIST) {
         /* Correct for 1-based rank. */
         zobj->ptr = zzlDeleteRangeByRank(zobj->ptr,start+1,end+1,&deleted);
-        if (zzlLength(zobj->ptr) == 0) dbDelete(c->db,key);
+        if (zzlLength(zobj->ptr) == 0) {
+            dbDelete(c->db,key);
+            keyremoved = 1;
+        }
     } else if (zobj->encoding == REDIS_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
 
         /* Correct for 1-based rank. */
         deleted = zslDeleteRangeByRank(zs->zsl,start+1,end+1,zs->dict);
         if (htNeedsResize(zs->dict)) dictResize(zs->dict);
-        if (dictSize(zs->dict) == 0) dbDelete(c->db,key);
+        if (dictSize(zs->dict) == 0) {
+            dbDelete(c->db,key);
+            keyremoved = 1;
+        }
     } else {
         redisPanic("Unknown sorted set encoding");
     }
 
-    if (deleted) signalModifiedKey(c->db,key);
+    if (deleted) {
+        signalModifiedKey(c->db,key);
+        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,"zrembyrank",key,c->db->id);
+        if (keyremoved)
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",key,c->db->id);
+    }
     server.dirty += deleted;
     addReplyLongLong(c,deleted);
 }
 
 typedef struct {
     robj *subject;
@@ -1671,16 +1690,21 @@
             maxelelen <= server.zset_max_ziplist_value)
                 zsetConvert(dstobj,REDIS_ENCODING_ZIPLIST);
 
         dbAdd(c->db,dstkey,dstobj);
         addReplyLongLong(c,zsetLength(dstobj));
         if (!touched) signalModifiedKey(c->db,dstkey);
+        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,
+            (op == REDIS_OP_UNION) ? "zunionstore" : "zinterstore",
+            dstkey,c->db->id);
         server.dirty++;
     } else {
         decrRefCount(dstobj);
         addReply(c,shared.czero);
+        if (touched)
+            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,"del",dstkey,c->db->id);
     }
     zfree(src);
 }
 
 void zunionstoreCommand(redisClient *c) {
     zunionInterGenericCommand(c,c->argv[1], REDIS_OP_UNION);
@@ -2177,6 +2201,16 @@
     zrankGenericCommand(c, 0);
 }
 
 void zrevrankCommand(redisClient *c) {
     zrankGenericCommand(c, 1);
 }
+
+void zscanCommand(redisClient *c) {
+    robj *o;
+    unsigned long cursor;
+
+    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == REDIS_ERR) return;
+    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
+        checkType(c,o,REDIS_ZSET)) return;
+    scanGenericCommand(c,o,cursor);
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_zset.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_zset.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/t_zset.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/t_zset.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.c	2013-11-22 17:25:29.000000000 +0800
@@ -402,12 +402,72 @@
     /* Turn it into hex digits taking just 4 bits out of 8 for every byte. */
     for (j = 0; j < len; j++)
         p[j] = charset[p[j] & 0x0F];
     fclose(fp);
 }
 
+/* Given the filename, return the absolute path as an SDS string, or NULL
+ * if it fails for some reason. Note that "filename" may be an absolute path
+ * already, this will be detected and handled correctly.
+ *
+ * The function does not try to normalize everything, but only the obvious
+ * case of one or more "../" appearning at the start of "filename"
+ * relative path. */
+sds getAbsolutePath(char *filename) {
+    char cwd[1024];
+    sds abspath;
+    sds relpath = sdsnew(filename);
+
+    relpath = sdstrim(relpath," \r\n\t");
+    if (relpath[0] == '/') return relpath; /* Path is already absolute. */
+
+    /* If path is relative, join cwd and relative path. */
+    if (getcwd(cwd,sizeof(cwd)) == NULL) {
+        sdsfree(relpath);
+        return NULL;
+    }
+    abspath = sdsnew(cwd);
+    if (sdslen(abspath) && abspath[sdslen(abspath)-1] != '/')
+        abspath = sdscat(abspath,"/");
+
+    /* At this point we have the current path always ending with "/", and
+     * the trimmed relative path. Try to normalize the obvious case of
+     * trailing ../ elements at the start of the path.
+     *
+     * For every "../" we find in the filename, we remove it and also remove
+     * the last element of the cwd, unless the current cwd is "/". */
+    while (sdslen(relpath) >= 3 &&
+           relpath[0] == '.' && relpath[1] == '.' && relpath[2] == '/')
+    {
+        sdsrange(relpath,3,-1);
+        if (sdslen(abspath) > 1) {
+            char *p = abspath + sdslen(abspath)-2;
+            int trimlen = 1;
+
+            while(*p != '/') {
+                p--;
+                trimlen++;
+            }
+            sdsrange(abspath,0,-(trimlen+1));
+        }
+    }
+
+    /* Finally glue the two parts together. */
+    abspath = sdscatsds(abspath,relpath);
+    sdsfree(relpath);
+    return abspath;
+}
+
+/* Return true if the specified path is just a file basename without any
+ * relative or absolute path. This function just checks that no / or \
+ * character exists inside the specified path, that's enough in the
+ * environments where Redis runs. */
+int pathIsBaseName(char *path) {
+    return strchr(path,'/') == NULL && strchr(path,'\\') == NULL;
+}
+
 #ifdef UTIL_TEST_MAIN
 #include <assert.h>
 
 void test_string2ll(void) {
     char buf[32];
     long long v;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.h	2013-11-22 17:25:29.000000000 +0800
@@ -27,15 +27,19 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __REDIS_UTIL_H
 #define __REDIS_UTIL_H
 
+#include "sds.h"
+
 int stringmatchlen(const char *p, int plen, const char *s, int slen, int nocase);
 int stringmatch(const char *p, const char *s, int nocase);
 long long memtoll(const char *p, int *err);
 int ll2string(char *s, size_t len, long long value);
 int string2ll(const char *s, size_t slen, long long *value);
 int string2l(const char *s, size_t slen, long *value);
 int d2string(char *buf, size_t len, double value);
+sds getAbsolutePath(char *filename);
+int pathIsBaseName(char *path);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/util.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/util.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/version.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/version.h	2013-11-22 17:25:29.000000000 +0800
@@ -1 +1 @@
-#define REDIS_VERSION "2.6.17"
+#define REDIS_VERSION "2.8.0"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ziplist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ziplist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ziplist.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ziplist.c	2013-11-22 17:25:29.000000000 +0800
@@ -1038,13 +1038,14 @@
         printf("ERROR: Could not pop\n");
         exit(1);
     }
 }
 
 int randstring(char *target, unsigned int min, unsigned int max) {
-    int p, len = min+rand()%(max-min+1);
+    int p = 0;
+    int len = min+rand()%(max-min+1);
     int minval, maxval;
     switch(rand() % 3) {
     case 0:
         minval = 0;
         maxval = 255;
     break;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ziplist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ziplist.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/ziplist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/ziplist.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zipmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zipmap.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zipmap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zipmap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zipmap.h	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zipmap.h	2013-11-22 17:25:29.000000000 +0800
@@ -29,13 +29,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef _ZIMMAP_H
+#ifndef _ZIPMAP_H
 #define _ZIPMAP_H
 
 unsigned char *zipmapNew(void);
 unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update);
 unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted);
 unsigned char *zipmapRewind(unsigned char *zm);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zipmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zipmap.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zmalloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zmalloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zmalloc.c	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zmalloc.c	2013-11-22 17:25:29.000000000 +0800
@@ -249,13 +249,13 @@
  * memory expiring or swapping out objects.
  *
  * For this kind of "fast RSS reporting" usages use instead the
  * function RedisEstimateRSS() that is a much faster (and less precise)
  * version of the function. */
 
-#if defined(HAVE_PROCFS)
+#if defined(HAVE_PROC_STAT)
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 
 size_t zmalloc_get_rss(void) {
@@ -322,13 +322,13 @@
 
 /* Fragmentation = RSS / allocated-bytes */
 float zmalloc_get_fragmentation_ratio(void) {
     return (float)zmalloc_get_rss()/zmalloc_used_memory();
 }
 
-#if defined(HAVE_PROCFS)
+#if defined(HAVE_PROC_SMAPS)
 size_t zmalloc_get_private_dirty(void) {
     char line[1024];
     size_t pd = 0;
     FILE *fp = fopen("/proc/self/smaps","r");
 
     if (!fp) return 0;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zmalloc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zmalloc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/src/zmalloc.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/src/zmalloc.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/assets/default.conf /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/assets/default.conf
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/assets/default.conf	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/assets/default.conf	2013-11-22 17:25:29.000000000 +0800
@@ -1,14 +1,16 @@
 # Redis configuration for testing.
 
+notify-keyspace-events KEA
 daemonize no
 pidfile /var/run/redis.pid
 port 6379
 timeout 0
+bind 127.0.0.1
 loglevel verbose
-logfile stdout
+logfile ''
 databases 16
 
 save 900 1
 save 300 10
 save 60 10000
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/integration/aof.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/integration/aof.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/integration/aof.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/integration/aof.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -95,13 +95,13 @@
             set client [redis [dict get $srv host] [dict get $srv port]]
             assert_equal "hello" [$client get foo]
             assert_equal "" [$client get bar]
         }
     }
 
-    ## Test that SPOP (that modifies the client its argc/argv) is correctly free'd
+    ## Test that SPOP (that modifies the client's argc/argv) is correctly free'd
     create_aof {
         append_to_aof [formatCommand sadd set foo]
         append_to_aof [formatCommand sadd set bar]
         append_to_aof [formatCommand spop set]
     }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/integration/replication-3.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/integration/replication-3.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/integration/replication-3.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/integration/replication-3.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -1,13 +1,16 @@
 start_server {tags {"repl"}} {
     start_server {} {
         test {First server should have role slave after SLAVEOF} {
             r -1 slaveof [srv 0 host] [srv 0 port]
-            after 1000
-            s -1 role
-        } {slave}
+            wait_for_condition 50 100 {
+                [s -1 master_link_status] eq {up}
+            } else {
+                fail "Replication not started."
+            }
+        }
 
         if {$::accurate} {set numops 50000} else {set numops 5000}
 
         test {MASTER and SLAVE consistency with expire} {
             createComplexDataset r $numops useexpire
             after 4000 ;# Make sure everything expired before taking the digest
@@ -26,6 +29,73 @@
                 puts "Run diff -u against /tmp/repldump*.txt for more info"
             }
             assert_equal [r debug digest] [r -1 debug digest]
         }
     }
 }
+
+start_server {tags {"repl"}} {
+    start_server {} {
+        test {First server should have role slave after SLAVEOF} {
+            r -1 slaveof [srv 0 host] [srv 0 port]
+            wait_for_condition 50 100 {
+                [s -1 master_link_status] eq {up}
+            } else {
+                fail "Replication not started."
+            }
+        }
+
+        set numops 20000 ;# Enough to trigger the Script Cache LRU eviction.
+
+        # While we are at it, enable AOF to test it will be consistent as well
+        # after the test.
+        r config set appendonly yes
+
+        test {MASTER and SLAVE consistency with EVALSHA replication} {
+            array set oldsha {}
+            for {set j 0} {$j < $numops} {incr j} {
+                set key "key:$j"
+                # Make sure to create scripts that have different SHA1s
+                set script "return redis.call('incr','$key')"
+                set sha1 [r eval "return redis.sha1hex(\"$script\")" 0]
+                set oldsha($j) $sha1
+                r eval $script 0
+                set res [r evalsha $sha1 0]
+                assert {$res == 2}
+                # Additionally call one of the old scripts as well, at random.
+                set res [r evalsha $oldsha([randomInt $j]) 0]
+                assert {$res > 2}
+
+                # Trigger an AOF rewrite while we are half-way, this also
+                # forces the flush of the script cache, and we will cover
+                # more code as a result.
+                if {$j == $numops / 2} {
+                    catch {r bgrewriteaof}
+                }
+            }
+
+            wait_for_condition 50 100 {
+                [r dbsize] == $numops &&
+                [r -1 dbsize] == $numops &&
+                [r debug digest] eq [r -1 debug digest]
+            } else {
+                set csv1 [csvdump r]
+                set csv2 [csvdump {r -1}]
+                set fd [open /tmp/repldump1.txt w]
+                puts -nonewline $fd $csv1
+                close $fd
+                set fd [open /tmp/repldump2.txt w]
+                puts -nonewline $fd $csv2
+                close $fd
+                puts "Master - Slave inconsistency"
+                puts "Run diff -u against /tmp/repldump*.txt for more info"
+
+            }
+
+            set old_digest [r debug digest]
+            r config set appendonly no
+            r debug loadaof
+            set new_digest [r debug digest]
+            assert {$old_digest eq $new_digest}
+        }
+    }
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/integration/replication-4.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/integration/replication-4.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/integration/replication-4.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/integration/replication-4.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -51,6 +51,86 @@
                 puts "Run diff -u against /tmp/repldump*.txt for more info"
             }
             assert_equal [r debug digest] [r -1 debug digest]
         }
     }
 }
+
+start_server {tags {"repl"}} {
+    start_server {} {
+        set master [srv -1 client]
+        set master_host [srv -1 host]
+        set master_port [srv -1 port]
+        set slave [srv 0 client]
+
+        test {First server should have role slave after SLAVEOF} {
+            $slave slaveof $master_host $master_port
+            wait_for_condition 50 100 {
+                [s 0 master_link_status] eq {up}
+            } else {
+                fail "Replication not started."
+            }
+        }
+
+        test {With min-slaves-to-write (1,3): master should be writable} {
+            $master config set min-slaves-max-lag 3
+            $master config set min-slaves-to-write 1
+            $master set foo bar
+        } {OK}
+
+        test {With min-slaves-to-write (2,3): master should not be writable} {
+            $master config set min-slaves-max-lag 3
+            $master config set min-slaves-to-write 2
+            catch {$master set foo bar} e
+            set e
+        } {NOREPLICAS*}
+
+        test {With min-slaves-to-write: master not writable with lagged slave} {
+            $master config set min-slaves-max-lag 2
+            $master config set min-slaves-to-write 1
+            assert {[$master set foo bar] eq {OK}}
+            $slave deferred 1
+            $slave debug sleep 6
+            after 4000
+            catch {$master set foo bar} e
+            set e
+        } {NOREPLICAS*}
+    }
+}
+
+start_server {tags {"repl"}} {
+    start_server {} {
+        set master [srv -1 client]
+        set master_host [srv -1 host]
+        set master_port [srv -1 port]
+        set slave [srv 0 client]
+
+        test {First server should have role slave after SLAVEOF} {
+            $slave slaveof $master_host $master_port
+            wait_for_condition 50 100 {
+                [s 0 role] eq {slave}
+            } else {
+                fail "Replication not started."
+            }
+        }
+
+        test {Replication: commands with many arguments (issue #1221)} {
+            # We now issue large MSET commands, that may trigger a specific
+            # class of bugs, see issue #1221.
+            for {set j 0} {$j < 100} {incr j} {
+                set cmd [list mset]
+                for {set x 0} {$x < 1000} {incr x} {
+                    lappend cmd [randomKey] [randomValue]
+                }
+                $master {*}$cmd
+            }
+
+            set retry 10
+            while {$retry && ([$master debug digest] ne [$slave debug digest])}\
+            {
+                after 1000
+                incr retry -1
+            }
+            assert {[$master dbsize] > 0}
+        }
+    }
+}
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/integration: replication-psync.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/integration/replication.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/integration/replication.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/integration/replication.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/integration/replication.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -109,13 +109,13 @@
                     [lindex $slaves 2] slaveof $master_host $master_port
 
                     # Wait for all the three slaves to reach the "online" state
                     set retry 500
                     while {$retry} {
                         set info [r -3 info]
-                        if {[string match {*slave0:*,online*slave1:*,online*slave2:*,online*} $info]} {
+                        if {[string match {*slave0:*state=online*slave1:*state=online*slave2:*state=online*} $info]} {
                             break
                         } else {
                             incr retry -1
                             after 100
                         }
                     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/support/redis.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/support/redis.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/support/redis.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/support/redis.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -112,12 +112,16 @@
 }
 
 proc ::redis::__method__channel {id fd} {
     return $fd
 }
 
+proc ::redis::__method__deferred {id fd val} {
+    set ::redis::deferred($id) $val
+}
+
 proc ::redis::redis_write {fd buf} {
     puts -nonewline $fd $buf
 }
 
 proc ::redis::redis_writenl {fd buf} {
     redis_write $fd $buf
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/support/server.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/support/server.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/support/server.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/support/server.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -81,14 +81,14 @@
     if {[catch {
         set fd [socket $::host $::port]
         fconfigure $fd -translation binary
         puts $fd "PING\r\n"
         flush $fd
         set reply [gets $fd]
-        if {[string range $reply 0 4] eq {+PONG} ||
-            [string range $reply 0 3] eq {-ERR}} {
+        if {[string range $reply 0 0] eq {+} ||
+            [string range $reply 0 0] eq {-}} {
             set retval 1
         }
         close $fd
     } e]} {
         if {$::verbose} {
             puts -nonewline "."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/support/util.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/support/util.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/support/util.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/support/util.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -88,16 +88,18 @@
         } else {
             break
         }
     }
 }
 
+# Random integer between 0 and max (excluded).
 proc randomInt {max} {
     expr {int(rand()*$max)}
 }
 
+# Random signed integer between -max and max (both extremes excluded).
 proc randomSignedInt {max} {
     set i [randomInt $max]
     if {rand() > 0.5} {
         set i -$i
     }
     return $i
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/test_helper.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/test_helper.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/test_helper.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/test_helper.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -13,12 +13,13 @@
 
 set ::all_tests {
     unit/printver
     unit/auth
     unit/protocol
     unit/basic
+    unit/scan
     unit/type/list
     unit/type/list-2
     unit/type/list-3
     unit/type/set
     unit/type/zset
     unit/type/hash
@@ -29,24 +30,26 @@
     unit/quit
     unit/aofrw
     integration/replication
     integration/replication-2
     integration/replication-3
     integration/replication-4
+    integration/replication-psync
     integration/aof
     integration/rdb
     integration/convert-zipmap-hash-on-load
     unit/pubsub
     unit/slowlog
     unit/scripting
     unit/maxmemory
     unit/introspection
     unit/limits
     unit/obuf-limits
     unit/dump
     unit/bitops
+    unit/memefficiency
 }
 # Index to the next test to run in the ::all_tests list.
 set ::next_test 0
 
 set ::host 127.0.0.1
 set ::port 21111
@@ -182,13 +185,13 @@
     # Open a listening socket, trying different ports in order to find a
     # non busy one.
     set port [find_available_port 11111]
     if {!$::quiet} {
         puts "Starting test server at port $port"
     }
-    socket -server accept_test_clients $port
+    socket -server accept_test_clients -myaddr 127.0.0.1 $port
 
     # Start the client instances
     set ::clients_pids {}
     set start_port [expr {$::port+100}]
     for {set j 0} {$j < $::numclients} {incr j} {
         set start_port [find_available_port $start_port]
@@ -435,21 +438,15 @@
     set attempt 0
     while {[gets $s count] == -1} {
         if {[incr attempt] == 10} return ""
         after 100
     }
     fconfigure $s -blocking 1
-
-    # Workaround for Redis 2.6, not always using the new protocol in the
-    # replication channel (this was fixed in >= 2.8).
-    if {[string tolower [lindex [split $count] 0]] eq {select}} {
-        return $count
-    }
+    set count [string range $count 1 end]
 
     # Return a list of arguments for the command.
-    set count [string range $count 1 end]
     set res {}
     for {set j 0} {$j < $count} {incr j} {
         read $s 1
         set arg [::redis::redis_bulk_read $s]
         if {$j == 0} {set arg [string tolower $arg]}
         lappend res $arg
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/auth.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/auth.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/auth.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/auth.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -11,13 +11,13 @@
         set _ $err
     } {ERR*invalid password}
     
     test {Arbitrary command gives an error when AUTH is required} {
         catch {r set foo bar} err
         set _ $err
-    } {ERR*operation not permitted}
+    } {NOAUTH*}
 
     test {AUTH succeeds when the right password is given} {
         r auth foobar
     } {OK}
 
     test {Once AUTH succeeded we can actually send commands to the server} {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/basic.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/basic.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/basic.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/basic.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -140,13 +140,13 @@
 
     test {INCR fails against a key holding a list} {
         r rpush mylist 1
         catch {r incr mylist} err
         r rpop mylist
         format $err
-    } {ERR*}
+    } {WRONGTYPE*}
 
     test {DECRBY over 32bit value with over 32bit increment, negative res} {
         r set novar 17179869184
         r decrby novar 17179869185
     } {-1}
 
@@ -198,13 +198,13 @@
         r del mylist
         set err {}
         r rpush mylist 1
         catch {r incrbyfloat mylist 1.0} err
         r del mylist
         format $err
-    } {ERR*kind*}
+    } {WRONGTYPE*}
 
     test {INCRBYFLOAT does not allow NaN or Infinity} {
         r set foo 0
         set err {}
         catch {r incrbyfloat foo +inf} err
         set err
@@ -528,13 +528,13 @@
         assert_equal [binary format B* 00010011] [r get mykey]
     }
 
     test "SETBIT against key with wrong type" {
         r del mykey
         r lpush mykey "foo"
-        assert_error "*wrong kind*" {r setbit mykey 0 1}
+        assert_error "WRONGTYPE*" {r setbit mykey 0 1}
     }
 
     test "SETBIT with out of range bit offset" {
         r del mykey
         assert_error "*out of range*" {r setbit mykey [expr 4*1024*1024*1024] 1}
         assert_error "*out of range*" {r setbit mykey -1 1}
@@ -662,13 +662,13 @@
         assert_equal "1234\0002" [r get mykey]
     }
 
     test "SETRANGE against key with wrong type" {
         r del mykey
         r lpush mykey "foo"
-        assert_error "*wrong kind*" {r setrange mykey 0 bar}
+        assert_error "WRONGTYPE*" {r setrange mykey 0 bar}
     }
 
     test "SETRANGE with out of range offset" {
         r del mykey
         assert_error "*maximum allowed size*" {r setrange mykey [expr 512*1024*1024-4] world}
 
@@ -751,7 +751,14 @@
     test {Extended SET using multiple options at once} {
         r set foo val
         assert {[r set foo bar xx px 10000] eq {OK}}
         set ttl [r ttl foo]
         assert {$ttl <= 10 && $ttl > 5}
     }
+
+    test {KEYS * two times with long key, Github issue #1208} {
+        r flushdb
+        r set dlskeriewrioeuwqoirueioqwrueoqwrueqw test
+        r keys *
+        r keys *
+    } {dlskeriewrioeuwqoirueioqwrueoqwrueqw}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/bitops.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/bitops.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/bitops.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/bitops.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -167,13 +167,13 @@
         r del c
         r set a 1
         r set b 2
         r lpush c foo
         catch {r bitop xor dest a b c d} e
         set e
-    } {*ERR*}
+    } {WRONGTYPE*}
 
     test {BITOP with empty string after non empty string (issue #529)} {
         r flushdb
         r set a "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
         r bitop or x a b
     } {32}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/expire.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/expire.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/expire.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/expire.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -118,19 +118,37 @@
                 $c eq {somevalue} && $d eq {} &&
                 $e eq {somevalue} && $f eq {}} break
         }
         list $a $b
     } {somevalue {}}
 
-    test {PTTL returns millisecond time to live} {
+    test {TTL returns tiem to live in seconds} {
+        r del x
+        r setex x 10 somevalue
+        set ttl [r ttl x]
+        assert {$ttl > 8 && $ttl <= 10}
+    }
+
+    test {PTTL returns time to live in milliseconds} {
         r del x
         r setex x 1 somevalue
         set ttl [r pttl x]
         assert {$ttl > 900 && $ttl <= 1000}
     }
 
+    test {TTL / PTTL return -1 if key has no expire} {
+        r del x
+        r set x hello
+        list [r ttl x] [r pttl x]
+    } {-1 -1}
+
+    test {TTL / PTTL return -2 if key does not exit} {
+        r del x
+        list [r ttl x] [r pttl x]
+    } {-2 -2}
+
     test {Redis should actively expire keys incrementally} {
         r flushdb
         r psetex key1 500 a
         r psetex key2 500 a
         r psetex key3 500 a
         set size1 [r dbsize]
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit: memefficiency.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/pubsub.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/pubsub.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/pubsub.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/pubsub.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -190,16 +190,170 @@
         assert_equal {pmessage foo.* foo.bar hello} [$rd1 read]
 
         # clean up clients
         $rd1 close
     }
 
-    test "PUNSUBSCRIBE and UNSUBSCRIBE should always reply." {
+    test "PUNSUBSCRIBE and UNSUBSCRIBE should always reply" {
         # Make sure we are not subscribed to any channel at all.
         r punsubscribe
         r unsubscribe
         # Now check if the commands still reply correctly.
         set reply1 [r punsubscribe]
         set reply2 [r unsubscribe]
         concat $reply1 $reply2
     } {punsubscribe {} 0 unsubscribe {} 0}
+
+    ### Keyspace events notification tests
+
+    test "Keyspace notifications: we receive keyspace notifications" {
+        r config set notify-keyspace-events KA
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r set foo bar
+        assert_equal {pmessage * __keyspace@9__:foo set} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: we receive keyevent notifications" {
+        r config set notify-keyspace-events EA
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r set foo bar
+        assert_equal {pmessage * __keyevent@9__:set foo} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: we can receive both kind of events" {
+        r config set notify-keyspace-events KEA
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r set foo bar
+        assert_equal {pmessage * __keyspace@9__:foo set} [$rd1 read]
+        assert_equal {pmessage * __keyevent@9__:set foo} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: we are able to mask events" {
+        r config set notify-keyspace-events KEl
+        r del mylist
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r set foo bar
+        r lpush mylist a
+        # No notification for set, because only list commands are enabled.
+        assert_equal {pmessage * __keyspace@9__:mylist lpush} [$rd1 read]
+        assert_equal {pmessage * __keyevent@9__:lpush mylist} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: general events test" {
+        r config set notify-keyspace-events KEg
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r set foo bar
+        r expire foo 1
+        r del foo
+        assert_equal {pmessage * __keyspace@9__:foo expire} [$rd1 read]
+        assert_equal {pmessage * __keyevent@9__:expire foo} [$rd1 read]
+        assert_equal {pmessage * __keyspace@9__:foo del} [$rd1 read]
+        assert_equal {pmessage * __keyevent@9__:del foo} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: list events test" {
+        r config set notify-keyspace-events KEl
+        r del mylist
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r lpush mylist a
+        r rpush mylist a
+        r rpop mylist
+        assert_equal {pmessage * __keyspace@9__:mylist lpush} [$rd1 read]
+        assert_equal {pmessage * __keyevent@9__:lpush mylist} [$rd1 read]
+        assert_equal {pmessage * __keyspace@9__:mylist rpush} [$rd1 read]
+        assert_equal {pmessage * __keyevent@9__:rpush mylist} [$rd1 read]
+        assert_equal {pmessage * __keyspace@9__:mylist rpop} [$rd1 read]
+        assert_equal {pmessage * __keyevent@9__:rpop mylist} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: set events test" {
+        r config set notify-keyspace-events Ks
+        r del myset
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r sadd myset a b c d
+        r srem myset x
+        r sadd myset x y z
+        r srem myset x
+        assert_equal {pmessage * __keyspace@9__:myset sadd} [$rd1 read]
+        assert_equal {pmessage * __keyspace@9__:myset sadd} [$rd1 read]
+        assert_equal {pmessage * __keyspace@9__:myset srem} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: zset events test" {
+        r config set notify-keyspace-events Kz
+        r del myzset
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r zadd myzset 1 a 2 b
+        r zrem myzset x
+        r zadd myzset 3 x 4 y 5 z
+        r zrem myzset x
+        assert_equal {pmessage * __keyspace@9__:myzset zadd} [$rd1 read]
+        assert_equal {pmessage * __keyspace@9__:myzset zadd} [$rd1 read]
+        assert_equal {pmessage * __keyspace@9__:myzset zrem} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: hash events test" {
+        r config set notify-keyspace-events Kh
+        r del myhash
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r hmset myhash yes 1 no 0
+        r hincrby myhash yes 10
+        assert_equal {pmessage * __keyspace@9__:myhash hset} [$rd1 read]
+        assert_equal {pmessage * __keyspace@9__:myhash hincrby} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: expired events (triggered expire)" {
+        r config set notify-keyspace-events Ex
+        r del foo
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r psetex foo 100 1
+        wait_for_condition 50 100 {
+            [r exists foo] == 0
+        } else {
+            fail "Key does not expire?!"
+        }
+        assert_equal {pmessage * __keyevent@9__:expired foo} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: expired events (background expire)" {
+        r config set notify-keyspace-events Ex
+        r del foo
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r psetex foo 100 1
+        assert_equal {pmessage * __keyevent@9__:expired foo} [$rd1 read]
+        $rd1 close
+    }
+
+    test "Keyspace notifications: evicted events" {
+        r config set notify-keyspace-events Ee
+        r config set maxmemory-policy allkeys-lru
+        r flushdb
+        set rd1 [redis_deferring_client]
+        assert_equal {1} [psubscribe $rd1 *]
+        r set foo bar
+        r config set maxmemory 1
+        assert_equal {pmessage * __keyevent@9__:evicted foo} [$rd1 read]
+        r config set maxmemory 0
+        $rd1 close
+    }
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit: scan.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/scripting.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/scripting.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/scripting.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/scripting.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -279,12 +279,27 @@
             math.randomseed(ARGV[1]); return tostring(math.random())
         } 0 20]
         assert_equal $rand1 $rand2
         assert {$rand2 ne $rand3}
     }
 
+    test {EVAL does not leak in the Lua stack} {
+        r set x 0
+        # Use a non blocking client to speedup the loop.
+        set rd [redis_deferring_client]
+        for {set j 0} {$j < 10000} {incr j} {
+            $rd eval {return redis.call("incr",KEYS[1])} 1 x
+        }
+        for {set j 0} {$j < 10000} {incr j} {
+            $rd read
+        }
+        assert {[s used_memory_lua] < 1024*100}
+        $rd close
+        r get x
+    } {10000}
+
     test {EVAL processes writes from AOF in read-only slaves} {
         r flushall
         r config set appendonly yes
         r eval {redis.call("set","foo","100")} 0
         r eval {redis.call("incr","foo")} 0
         r eval {redis.call("incr","foo")} 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/type/list.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/type/list.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/type/list.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/type/list.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -260,53 +260,53 @@
 
     test "BRPOPLPUSH with wrong source type" {
         set rd [redis_deferring_client]
         r del blist target
         r set blist nolist
         $rd brpoplpush blist target 1
-        assert_error "ERR*wrong kind*" {$rd read}
+        assert_error "WRONGTYPE*" {$rd read}
     }
 
     test "BRPOPLPUSH with wrong destination type" {
         set rd [redis_deferring_client]
         r del blist target
         r set target nolist
         r lpush blist foo
         $rd brpoplpush blist target 1
-        assert_error "ERR*wrong kind*" {$rd read}
+        assert_error "WRONGTYPE*" {$rd read}
 
         set rd [redis_deferring_client]
         r del blist target
         r set target nolist
         $rd brpoplpush blist target 0
         after 1000
         r rpush blist foo
-        assert_error "ERR*wrong kind*" {$rd read}
+        assert_error "WRONGTYPE*" {$rd read}
         assert_equal {foo} [r lrange blist 0 -1]
     }
 
     test "BRPOPLPUSH maintains order of elements after failure" {
         set rd [redis_deferring_client]
         r del blist target
         r set target nolist
         $rd brpoplpush blist target 0
         r rpush blist a b c
-        assert_error "ERR*wrong kind*" {$rd read}
+        assert_error "WRONGTYPE*" {$rd read}
         r lrange blist 0 -1
     } {a b c}
 
     test "BRPOPLPUSH with multiple blocked clients" {
         set rd1 [redis_deferring_client]
         set rd2 [redis_deferring_client]
         r del blist target1 target2
         r set target1 nolist
         $rd1 brpoplpush blist target1 0
         $rd2 brpoplpush blist target2 0
         r lpush blist foo
 
-        assert_error "ERR*wrong kind*" {$rd1 read}
+        assert_error "WRONGTYPE*" {$rd1 read}
         assert_equal {foo} [$rd2 read]
         assert_equal {foo} [r lrange target2 0 -1]
     }
 
     test "Linked BRPOPLPUSH" {
       set rd1 [redis_deferring_client]
@@ -442,13 +442,13 @@
 
         test "$pop: second argument is not a list" {
             set rd [redis_deferring_client]
             r del blist1 blist2
             r set blist2 nolist
             $rd $pop blist1 blist2 1
-            assert_error "ERR*wrong kind*" {$rd read}
+            assert_error "WRONGTYPE*" {$rd read}
         }
 
         test "$pop: timeout" {
             set rd [redis_deferring_client]
             r del blist1 blist2
             $rd $pop blist1 blist2 1
@@ -612,33 +612,33 @@
         }
     }
 
     test {LLEN against non-list value error} {
         r del mylist
         r set mylist foobar
-        assert_error ERR* {r llen mylist}
+        assert_error WRONGTYPE* {r llen mylist}
     }
 
     test {LLEN against non existing key} {
         assert_equal 0 [r llen not-a-key]
     }
 
     test {LINDEX against non-list value error} {
-        assert_error ERR* {r lindex mylist 0}
+        assert_error WRONGTYPE* {r lindex mylist 0}
     }
 
     test {LINDEX against non existing key} {
         assert_equal "" [r lindex not-a-key 10]
     }
 
     test {LPUSH against non-list value error} {
-        assert_error ERR* {r lpush mylist 0}
+        assert_error WRONGTYPE* {r lpush mylist 0}
     }
 
     test {RPUSH against non-list value error} {
-        assert_error ERR* {r rpush mylist 0}
+        assert_error WRONGTYPE* {r rpush mylist 0}
     }
 
     foreach {type large} [array get largevalue] {
         test "RPOPLPUSH base case - $type" {
             r del mylist1 mylist2
             create_$type mylist1 "a $large c d"
@@ -681,21 +681,21 @@
         assert_equal 0 [r exists dstlist]
     }
 
     test {RPOPLPUSH against non list src key} {
         r del srclist dstlist
         r set srclist x
-        assert_error ERR* {r rpoplpush srclist dstlist}
+        assert_error WRONGTYPE* {r rpoplpush srclist dstlist}
         assert_type string srclist
         assert_equal 0 [r exists newlist]
     }
 
     test {RPOPLPUSH against non list dst key} {
         create_ziplist srclist {a b c d}
         r set dstlist x
-        assert_error ERR* {r rpoplpush srclist dstlist}
+        assert_error WRONGTYPE* {r rpoplpush srclist dstlist}
         assert_type string dstlist
         assert_equal {a b c d} [r lrange srclist 0 -1]
     }
 
     test {RPOPLPUSH against non existing src key} {
         r del srclist dstlist
@@ -715,14 +715,14 @@
             assert_equal {} [r rpop mylist]
         }
     }
 
     test {LPOP/RPOP against non list value} {
         r set notalist foo
-        assert_error ERR*kind* {r lpop notalist}
-        assert_error ERR*kind* {r rpop notalist}
+        assert_error WRONGTYPE* {r lpop notalist}
+        assert_error WRONGTYPE* {r rpop notalist}
     }
 
     foreach {type num} {ziplist 250 linkedlist 500} {
         test "Mass RPOP/LPOP - $type" {
             r del mylist
             set sum1 0
@@ -816,13 +816,13 @@
     test {LSET against non existing key} {
         assert_error ERR*key* {r lset nosuchkey 10 foo}
     }
 
     test {LSET against non list value} {
         r set nolist foobar
-        assert_error ERR*value* {r lset nolist 0 foo}
+        assert_error WRONGTYPE* {r lset nolist 0 foo}
     }
 
     foreach {type e} [array get largevalue] {
         test "LREM remove all the occurrences - $type" {
             create_$type mylist "$e foo bar foobar foobared zap bar test foo"
             assert_equal 2 [r lrem mylist 0 bar]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/type/set.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/type/set.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/tests/unit/type/set.tcl	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/tests/unit/type/set.tcl	2013-11-22 17:25:29.000000000 +0800
@@ -32,13 +32,13 @@
         assert_equal 0 [r sismember myset 18]
         assert_equal {16 17} [lsort [r smembers myset]]
     }
 
     test {SADD against non set} {
         r lpush mylist foo
-        assert_error ERR*kind* {r sadd mylist bar}
+        assert_error WRONGTYPE* {r sadd mylist bar}
     }
 
     test "SADD a non-integer against an intset" {
         create_set myset {1 2 3}
         assert_encoding intset myset
         assert_equal 1 [r sadd myset a]
@@ -196,34 +196,61 @@
         test "SDIFF with three sets - $type" {
             assert_equal {1 2 3 4} [lsort [r sdiff set1 set4 set5]]
         }
 
         test "SDIFFSTORE with three sets - $type" {
             r sdiffstore setres set1 set4 set5
-            # The type is determined by type of the first key to diff against.
-            # See the implementation for more information.
-            assert_encoding $type setres
+            # When we start with intsets, we should always end with intsets.
+            if {$type eq {intset}} {
+                assert_encoding intset setres
+            }
             assert_equal {1 2 3 4} [lsort [r smembers setres]]
         }
     }
 
     test "SDIFF with first set empty" {
         r del set1 set2 set3
         r sadd set2 1 2 3 4
         r sadd set3 a b c d
         r sdiff set1 set2 set3
     } {}
 
+    test "SDIFF fuzzing" {
+        for {set j 0} {$j < 100} {incr j} {
+            unset -nocomplain s
+            array set s {}
+            set args {}
+            set num_sets [expr {[randomInt 10]+1}]
+            for {set i 0} {$i < $num_sets} {incr i} {
+                set num_elements [randomInt 100]
+                r del set_$i
+                lappend args set_$i
+                while {$num_elements} {
+                    set ele [randomValue]
+                    r sadd set_$i $ele
+                    if {$i == 0} {
+                        set s($ele) x
+                    } else {
+                        unset -nocomplain s($ele)
+                    }
+                    incr num_elements -1
+                }
+            }
+            set result [lsort [r sdiff {*}$args]]
+            assert_equal $result [lsort [array names s]]
+        }
+    }
+
     test "SINTER against non-set should throw error" {
         r set key1 x
-        assert_error "ERR*wrong kind*" {r sinter key1 noset}
+        assert_error "WRONGTYPE*" {r sinter key1 noset}
     }
 
     test "SUNION against non-set should throw error" {
         r set key1 x
-        assert_error "ERR*wrong kind*" {r sunion key1 noset}
+        assert_error "WRONGTYPE*" {r sunion key1 noset}
     }
 
     test "SINTER should handle non existing key as empty" {
         r del set1 set2 set3
         r sadd set1 a b c
         r sadd set2 b c d
@@ -442,18 +469,18 @@
         assert_equal {2} [lsort [r smembers myset3]]
         assert_encoding intset myset3
     }
 
     test "SMOVE wrong src key type" {
         r set x 10
-        assert_error "ERR*wrong kind*" {r smove x myset2 foo}
+        assert_error "WRONGTYPE*" {r smove x myset2 foo}
     }
 
     test "SMOVE wrong dst key type" {
         r set x 10
-        assert_error "ERR*wrong kind*" {r smove myset2 x foo}
+        assert_error "WRONGTYPE*" {r smove myset2 x foo}
     }
 
     test "SMOVE with identical source and destination" {
         r del set
         r sadd set a b c
         r smove set set b
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/utils/redis-copy.rb /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/utils/redis-copy.rb
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.6.17/utils/redis-copy.rb	2013-12-11 22:35:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-2.8.0/utils/redis-copy.rb	2013-11-22 17:25:29.000000000 +0800
@@ -1,28 +1,71 @@
 # redis-copy.rb - Copyright (C) 2009-2010 Salvatore Sanfilippo
 # BSD license, See the COPYING file for more information.
 #
 # Copy the whole dataset from one Redis instance to another one
 #
-# WARNING: this utility is deprecated and serves as a legacy adapter
-#          for the more-robust redis-copy gem.
+# WARNING: currently hashes and sorted sets are not supported! This
+#          program should be updated.
 
-require 'shellwords'
+require 'rubygems'
+require 'redis'
+require 'digest/sha1'
 
 def redisCopy(opts={})
-  src = "#{opts[:srchost]}:#{opts[:srcport]}"
-  dst = "#{opts[:dsthost]}:#{opts[:dstport]}"
-  `redis-copy #{src.shellescape} #{dst.shellescape}`
-rescue Errno::ENOENT
-  $stderr.puts 'This utility requires the redis-copy executable',
-               'from the redis-copy gem on https://rubygems.org',
-               'To install it, run `gem install redis-copy`.'
-  exit 1
+    sha1=""
+    src = Redis.new(:host => opts[:srchost], :port => opts[:srcport])
+    dst = Redis.new(:host => opts[:dsthost], :port => opts[:dstport])
+    puts "Loading key names..."
+    keys = src.keys('*')
+    puts "Copying #{keys.length} keys..."
+    c = 0
+    keys.each{|k|
+        vtype = src.type?(k)
+        ttl = src.ttl(k).to_i if vtype != "none"
+
+        if vtype == "string"
+            dst[k] = src[k]
+        elsif vtype == "list"
+            list = src.lrange(k,0,-1)
+            if list.length == 0
+                # Empty list special case
+                dst.lpush(k,"")
+                dst.lpop(k)
+            else
+                list.each{|ele|
+                    dst.rpush(k,ele)
+                }
+            end
+        elsif vtype == "set"
+            set = src.smembers(k)
+            if set.length == 0
+                # Empty set special case
+                dst.sadd(k,"")
+                dst.srem(k,"")
+            else
+                set.each{|ele|
+                    dst.sadd(k,ele)
+                }
+            end
+        elsif vtype == "none"
+            puts "WARNING: key '#{k}' was removed in the meanwhile."
+        end
+
+        # Handle keys with an expire time set
+        if ttl != -1 and vtype != "none"
+            dst.expire(k,ttl)
+        end
+
+        c = c+1
+        if (c % 1000) == 0
+            puts "#{c}/#{keys.length} completed"
+        end
+    }
+    puts "DONE!"
 end
 
-$stderr.puts "This utility is deprecated. Use the redis-copy gem instead."
 if ARGV.length != 4
     puts "Usage: redis-copy.rb <srchost> <srcport> <dsthost> <dstport>"
     exit 1
 end
 puts "WARNING: it's up to you to FLUSHDB the destination host before to continue, press any key when ready."
 STDIN.gets
