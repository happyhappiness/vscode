diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/00-RELEASENOTES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/00-RELEASENOTES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/00-RELEASENOTES	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/00-RELEASENOTES	2017-01-31 23:32:23.000000000 +0800
@@ -8,12 +8,151 @@
 MODERATE: Program an upgrade of the server, but it's not urgent.
 HIGH:     There is a critical bug that may affect a subset of users. Upgrade!
 CRITICAL: There is a critical bug affecting MOST USERS. Upgrade ASAP.
 --------------------------------------------------------------------------------
 
 ================================================================================
+Redis 3.2.7     Released Tue Jan 31 16:21:41 CET 2017
+================================================================================
+
+Upgrade urgency HIGH: This release fixes important security and correctness
+                      issues. It is especially important to upgrade for Redis
+                      Cluster users and for users running Redis in their laptop
+                      since a cross-scripting attack is fixed in this release.
+
+Main bugs fixes and improvements in this release:
+
+1. MIGRATE could incorrectly move keys between Redis Cluster nodes by turning
+   keys with an expire set into persisting keys. This bug was introduced with
+   the multiple-keys migration recently. It is now fixed. Only applies to
+   Redis Cluster users that use the resharding features of Redis Cluster.
+
+2. As Redis 4.0 beta and the unstable branch already did (for some months at
+   this point), Redis 3.2.7 also aliases the Host: and POST commands to QUIT
+   avoiding to process the remaining pipeline if there are pending commands.
+   This is a security protection against a "Cross Scripting" attack, that
+   usually involves trying to feed Redis with HTTP in order to execute commands.
+   Example: a developer is running a local copy of Redis for development
+   purposes. She also runs a web browser in the same computer. The web browser
+   could send an HTTP request to http://127.0.0.1:6379 in order to access the
+   Redis instance, since a specially crafted HTTP requesta may also be partially
+   valid Redis protocol. However if POST and Host: break the connection, this
+   problem should be avoided. IMPORTANT: It is important to realize that it
+   is not impossible that another way will be found to talk with a localhost
+   Redis using a Cross Protocol attack not involving sending POST or Host: so
+   this is only a layer of protection but not a definitive fix for this class
+   of issues.
+
+3. A ziplist bug that could cause data corruption, could crash the server and
+   MAY ALSO HAVE SECURITY IMPLICATIONS was fixed. The bug looks complex to
+   exploit, but attacks always get worse, never better (cit). The bug is very
+   very hard to catch in practice, it required manual analysis of the ziplist
+   code in order to be found. However it is also possible that rarely it
+   happened in the wild. Upgrading is required if you use LINSERT and other
+   in-the-middle list manipulation commands.
+
+4. We upgraded to Jemalloc 4.4.0 since the version we used to ship with Redis
+   was an early 4.0 release of Jemalloc. This version may have several
+   improvements including the ability to better reclaim/use the memory of
+   system.
+
+The following is the list of commits:
+
+antirez in commit 3876d98:
+ Ziplist: insertion bug under particular conditions fixed.
+ 1 file changed, 9 insertions(+), 1 deletion(-)
+
+antirez in commit 153f2f0:
+ Jemalloc updated to 4.4.0.
+ 150 files changed, 17271 insertions(+), 6356 deletions(-)
+
+miter in commit ca532c9:
+ Change switch statment to if statment
+ 1 file changed, 2 insertions(+), 4 deletions(-)
+
+oranagra in commit a735035:
+ fix rare assertion in DEBUG DIGEST
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+Itamar Haber in commit b917e3f:
+ Verify pairs are provided after subcommands
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 1177cf6:
+ Avoid geo.c warning in initialization.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 874804d:
+ Security: Cross Protocol Scripting protection.
+ 3 files changed, 27 insertions(+), 2 deletions(-)
+
+antirez in commit 273cd7f:
+ Ziplist: remove static from functions, they prevent good crash reports.
+ 1 file changed, 14 insertions(+), 14 deletions(-)
+
+Jan-Erik Rediger in commit 389b9f5:
+ Initialize help only in repl mode
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+Yossi Gottlieb in commit 1370a88:
+ Fix redis-cli rare crash.
+ 1 file changed, 4 insertions(+)
+
+antirez in commit 68aab8e:
+ MIGRATE: Remove upfront ttl initialization.
+ 1 file changed, 3 insertions(+), 4 deletions(-)
+
+Jan-Erik Rediger in commit 788e892:
+ Reset the ttl for additional keys
+ 1 file changed, 1 insertion(+)
+
+================================================================================
+Redis 3.2.6     Released Tue Dec 06 09:33:29 CET 2016
+================================================================================
+
+Upgrade urgency MODERATE: GEORADIUS, BITFIELD and Redis Cluster minor fixes.
+
+This release mainly fixes three bugs:
+
+1. A bug with BITFIELD that may cause the bitmap corruption when setting offsets
+   larger than the current string size.
+
+2. A GEORADIUS bug that may happen when using very large radius lengths, in
+   the range of 10000km or alike, due to wrong bounding box calculation.
+
+3. A bug with Redis Cluster which crashes when reading a nodes configuration
+   file with zero bytes at the end, which sometimes happens with certain ext4
+   configurations after a system crash.
+
+The following is the list of commits:
+
+antirez in commit f20f3ea:
+ Geo: improve fuzz test.
+ 1 file changed, 11 insertions(+), 3 deletions(-)
+
+antirez in commit 8c22086:
+ Geo: fix computation of bounding box.
+ 2 files changed, 33 insertions(+), 27 deletions(-)
+
+antirez in commit 92958df:
+ Cluster: handle zero bytes at the end of nodes.conf.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 0ee28ae:
+ Test: regression test for #3564 added.
+ 1 file changed, 9 insertions(+)
+
+sunhe in commit 289fadb:
+ bitops.c/bitfieldCommand: update higest_write_offset with check
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+jybaek in commit f4f7d2c:
+ Add missing fclose()
+ 1 file changed, 1 insertion(+)
+
+================================================================================
 Redis 3.2.5     Released Wed Oct 26 09:16:40 CEST 2016
 ================================================================================
 
 Upgrade urgency LOW: This release only fixes a compilation issue due to the
                      missing -ldl at linking time.
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash_helper.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash_helper.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash_helper.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash_helper.c	2017-01-31 23:32:23.000000000 +0800
@@ -77,41 +77,24 @@
     /* Frame to valid range. */
     if (step < 1) step = 1;
     if (step > 26) step = 26;
     return step;
 }
 
-int geohashBitsComparator(const GeoHashBits *a, const GeoHashBits *b) {
-    /* If step not equal, compare on step.  Else, compare on bits. */
-    return a->step != b->step ? a->step - b->step : a->bits - b->bits;
-}
-
+/* Return the bounding box of the search area centered at latitude,longitude
+ * having a radius of radius_meter. bounds[0] - bounds[2] is the minimum
+ * and maxium longitude, while bounds[1] - bounds[3] is the minimum and
+ * maximum latitude. */
 int geohashBoundingBox(double longitude, double latitude, double radius_meters,
                        double *bounds) {
     if (!bounds) return 0;
 
-    double lonr, latr;
-    lonr = deg_rad(longitude);
-    latr = deg_rad(latitude);
-
-    if (radius_meters > EARTH_RADIUS_IN_METERS)
-        radius_meters = EARTH_RADIUS_IN_METERS;
-    double distance = radius_meters / EARTH_RADIUS_IN_METERS;
-    double min_latitude = latr - distance;
-    double max_latitude = latr + distance;
-
-    /* Note: we're being lazy and not accounting for coordinates near poles */
-    double min_longitude, max_longitude;
-    double difference_longitude = asin(sin(distance) / cos(latr));
-    min_longitude = lonr - difference_longitude;
-    max_longitude = lonr + difference_longitude;
-
-    bounds[0] = rad_deg(min_longitude);
-    bounds[1] = rad_deg(min_latitude);
-    bounds[2] = rad_deg(max_longitude);
-    bounds[3] = rad_deg(max_latitude);
+    bounds[0] = longitude - rad_deg(radius_meters/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude)));
+    bounds[2] = longitude + rad_deg(radius_meters/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude)));
+    bounds[1] = latitude - rad_deg(radius_meters/EARTH_RADIUS_IN_METERS);
+    bounds[3] = latitude + rad_deg(radius_meters/EARTH_RADIUS_IN_METERS);
     return 1;
 }
 
 /* Return a set of areas (center + 8) that are able to cover a range query
  * for the specified position and radius. */
 GeoHashRadius geohashGetAreasByRadius(double longitude, double latitude, double radius_meters) {
@@ -158,13 +141,13 @@
         if (geohashGetDistance(longitude,latitude,east.longitude.max,latitude)
             < radius_meters) decrease_step = 1;
         if (geohashGetDistance(longitude,latitude,west.longitude.min,latitude)
             < radius_meters) decrease_step = 1;
     }
 
-    if (decrease_step) {
+    if (steps > 1 && decrease_step) {
         steps--;
         geohashEncode(&long_range,&lat_range,longitude,latitude,steps,&hash);
         geohashNeighbors(&hash,&neighbors);
         geohashDecode(long_range,lat_range,hash,&area);
     }
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash_helper.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash_helper.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash_helper.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash_helper.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/async.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/async.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/async.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/async.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/hiredis.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/hiredis.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/hiredis.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/hiredis.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/libhiredis.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/libhiredis.a differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/net.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/net.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/net.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/net.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/sds.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/sds.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/sds.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/sds.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc: .appveyor.yml
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/bin/jemalloc-config /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/bin/jemalloc-config
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/bin/jemalloc-config	2017-09-27 23:00:17.482936197 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/bin/jemalloc-config	2017-09-27 23:01:52.482932716 +0800
@@ -29,13 +29,13 @@
 case "$1" in
 --help | -h)
 	usage
 	exit 0
 	;;
 --version)
-	echo "4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c"
+	echo "4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc"
 	;;
 --revision)
 	echo "2"
 	;;
 --config)
 	echo "--with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence 'CFLAGS=-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops ' LDFLAGS="
@@ -68,12 +68,12 @@
 	echo " -D_GNU_SOURCE -D_REENTRANT"
 	;;
 --ldflags)
 	echo " "
 	;;
 --libs)
-	echo " -lpthread"
+	echo "-lm  -lpthread"
 	;;
 *)
 	usage
 	exit 1
 esac
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/bin/jeprof /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/bin/jeprof
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/bin/jeprof	2017-09-27 23:00:17.506936197 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/bin/jeprof	2017-09-27 23:01:52.506932715 +0800
@@ -69,13 +69,13 @@
 # TODO: Use color to indicate files?
 
 use strict;
 use warnings;
 use Getopt::Long;
 
-my $JEPROF_VERSION = "4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c";
+my $JEPROF_VERSION = "4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc";
 my $PPROF_VERSION = "2.0";
 
 # These are the object tools we use which can come from a
 # user-specified location using --tools, from the JEPROF_TOOLS
 # environment variable, or from the environment.
 my %obj_tool_map = (
@@ -92,13 +92,13 @@
 my @DOT = ("dot");          # leave non-absolute, since it may be in /usr/local
 my @GV = ("gv");
 my @EVINCE = ("evince");    # could also be xpdf or perhaps acroread
 my @KCACHEGRIND = ("kcachegrind");
 my @PS2PDF = ("ps2pdf");
 # These are used for dynamic profiles
-my @URL_FETCHER = ("curl", "-s");
+my @URL_FETCHER = ("curl", "-s", "--fail");
 
 # These are the web pages that servers need to support for dynamic profiles
 my $HEAP_PAGE = "/pprof/heap";
 my $PROFILE_PAGE = "/pprof/profile";   # must support cgi-param "?seconds=#"
 my $PMUPROFILE_PAGE = "/pprof/pmuprofile(?:\\?.*)?"; # must support cgi-param
                                                 # ?seconds=#&event=x&period=n
@@ -220,18 +220,20 @@
 
 Call-graph Options:
    --nodecount=<n>     Show at most so many nodes [default=80]
    --nodefraction=<f>  Hide nodes below <f>*total [default=.005]
    --edgefraction=<f>  Hide edges below <f>*total [default=.001]
    --maxdegree=<n>     Max incoming/outgoing edges per node [default=8]
-   --focus=<regexp>    Focus on nodes matching <regexp>
+   --focus=<regexp>    Focus on backtraces with nodes matching <regexp>
    --thread=<n>        Show profile for thread <n>
-   --ignore=<regexp>   Ignore nodes matching <regexp>
+   --ignore=<regexp>   Ignore backtraces with nodes matching <regexp>
    --scale=<n>         Set GV scaling [default=0]
    --heapcheck         Make nodes with non-0 object counts
                        (i.e. direct leak generators) more visible
+   --retain=<regexp>   Retain only nodes that match <regexp>
+   --exclude=<regexp>  Exclude all nodes that match <regexp>
 
 Miscellaneous:
    --tools=<prefix or binary:fullpath>[,...]   \$PATH for object tool pathnames
    --test              Run unit tests
    --help              This message
    --version           Version information
@@ -336,12 +338,14 @@
   $main::opt_maxdegree = 8;
   $main::opt_focus = '';
   $main::opt_thread = undef;
   $main::opt_ignore = '';
   $main::opt_scale = 0;
   $main::opt_heapcheck = 0;
+  $main::opt_retain = '';
+  $main::opt_exclude = '';
   $main::opt_seconds = 30;
   $main::opt_lib = "";
 
   $main::opt_inuse_space   = 0;
   $main::opt_inuse_objects = 0;
   $main::opt_alloc_space   = 0;
@@ -407,12 +411,14 @@
              "maxdegree=i"    => \$main::opt_maxdegree,
              "focus=s"        => \$main::opt_focus,
              "thread=s"       => \$main::opt_thread,
              "ignore=s"       => \$main::opt_ignore,
              "scale=i"        => \$main::opt_scale,
              "heapcheck"      => \$main::opt_heapcheck,
+             "retain=s"       => \$main::opt_retain,
+             "exclude=s"      => \$main::opt_exclude,
              "inuse_space!"   => \$main::opt_inuse_space,
              "inuse_objects!" => \$main::opt_inuse_objects,
              "alloc_space!"   => \$main::opt_alloc_space,
              "alloc_objects!" => \$main::opt_alloc_objects,
              "show_bytes!"    => \$main::opt_show_bytes,
              "drop_negative!" => \$main::opt_drop_negative,
@@ -1157,23 +1163,42 @@
       $sep = '--';
     }
     print "\n";
   }
   print '---', "\n";
 
-  $PROFILE_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
-  my $profile_marker = $&;
+  my $profile_marker;
+  if ($main::profile_type eq 'heap') {
+    $HEAP_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+    $profile_marker = $&;
+  } elsif ($main::profile_type eq 'growth') {
+    $GROWTH_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+    $profile_marker = $&;
+  } elsif ($main::profile_type eq 'contention') {
+    $CONTENTION_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+    $profile_marker = $&;
+  } else { # elsif ($main::profile_type eq 'cpu')
+    $PROFILE_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+    $profile_marker = $&;
+  }
+
   print '--- ', $profile_marker, "\n";
   if (defined($main::collected_profile)) {
     # if used with remote fetch, simply dump the collected profile to output.
     open(SRC, "<$main::collected_profile");
     while (<SRC>) {
       print $_;
     }
     close(SRC);
   } else {
+    # --raw/http: For everything to work correctly for non-remote profiles, we
+    # would need to extend PrintProfileData() to handle all possible profile
+    # types, re-enable the code that is currently disabled in ReadCPUProfile()
+    # and FixCallerAddresses(), and remove the remote profile dumping code in
+    # the block above.
+    die "--raw/http: jeprof can only dump remote profiles for --raw\n";
     # dump a cpu-format profile to standard out
     PrintProfileData($profile);
   }
 }
 
 # Print text output
@@ -2818,12 +2843,49 @@
     }
   }
 
   return $calls;
 }
 
+sub FilterFrames {
+  my $symbols = shift;
+  my $profile = shift;
+
+  if ($main::opt_retain eq '' && $main::opt_exclude eq '') {
+    return $profile;
+  }
+
+  my $result = {};
+  foreach my $k (keys(%{$profile})) {
+    my $count = $profile->{$k};
+    my @addrs = split(/\n/, $k);
+    my @path = ();
+    foreach my $a (@addrs) {
+      my $sym;
+      if (exists($symbols->{$a})) {
+        $sym = $symbols->{$a}->[0];
+      } else {
+        $sym = $a;
+      }
+      if ($main::opt_retain ne '' && $sym !~ m/$main::opt_retain/) {
+        next;
+      }
+      if ($main::opt_exclude ne '' && $sym =~ m/$main::opt_exclude/) {
+        next;
+      }
+      push(@path, $a);
+    }
+    if (scalar(@path) > 0) {
+      my $reduced_path = join("\n", @path);
+      AddEntry($result, $reduced_path, $count);
+    }
+  }
+
+  return $result;
+}
+
 sub RemoveUninterestingFrames {
   my $symbols = shift;
   my $profile = shift;
 
   # List of function names to skip
   my %skip = ();
@@ -2962,12 +3024,15 @@
       }
       push(@path, $a);
     }
     my $reduced_path = join("\n", @path);
     AddEntry($result, $reduced_path, $count);
   }
+
+  $result = FilterFrames($symbols, $result);
+
   return $result;
 }
 
 # Reduce profile to granularity given by user
 sub ReduceProfile {
   my $symbols = shift;
@@ -3271,13 +3336,13 @@
   return $url;
 }
 
 # Add a timeout flat to URL_FETCHER.  Returns a new list.
 sub AddFetchTimeout {
   my $timeout = shift;
-  my @fetcher = shift;
+  my @fetcher = @_;
   if (defined($timeout)) {
     if (join(" ", @fetcher) =~ m/\bcurl -s/) {
       push(@fetcher, "--max-time", sprintf("%d", $timeout));
     } elsif (join(" ", @fetcher) =~ m/\brpcget\b/) {
       push(@fetcher, sprintf("--deadline=%d", $timeout));
     }
@@ -3317,12 +3382,33 @@
       }
     }
   }
   return $map;
 }
 
+sub URLEncode {
+  my $str = shift;
+  $str =~ s/([^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%02x", ord $1 /eg;
+  return $str;
+}
+
+sub AppendSymbolFilterParams {
+  my $url = shift;
+  my @params = ();
+  if ($main::opt_retain ne '') {
+    push(@params, sprintf("retain=%s", URLEncode($main::opt_retain)));
+  }
+  if ($main::opt_exclude ne '') {
+    push(@params, sprintf("exclude=%s", URLEncode($main::opt_exclude)));
+  }
+  if (scalar @params > 0) {
+    $url = sprintf("%s?%s", $url, join("&", @params));
+  }
+  return $url;
+}
+
 # Fetches and processes symbols to prepare them for use in the profile output
 # code.  If the optional 'symbol_map' arg is not given, fetches symbols from
 # $SYMBOL_PAGE for all PC values found in profile.  Otherwise, the raw symbols
 # are assumed to have already been fetched into 'symbol_map' and are simply
 # extracted and processed.
 sub FetchSymbols {
@@ -3341,15 +3427,17 @@
 
     my $url = SymbolPageURL();
 
     my $command_line;
     if (join(" ", @URL_FETCHER) =~ m/\bcurl -s/) {
       $url = ResolveRedirectionForCurl($url);
+      $url = AppendSymbolFilterParams($url);
       $command_line = ShellEscape(@URL_FETCHER, "-d", "\@$main::tmpfile_sym",
                                   $url);
     } else {
+      $url = AppendSymbolFilterParams($url);
       $command_line = (ShellEscape(@URL_FETCHER, "--post", $url)
                        . " < " . ShellEscape($main::tmpfile_sym));
     }
     # We use c++filt in case $SYMBOL_PAGE gives us mangled symbols.
     my $escaped_cppfilt = ShellEscape($obj_tool_map{"c++filt"});
     open(SYMBOL, "$command_line | $escaped_cppfilt |") or error($command_line);
@@ -3424,18 +3512,28 @@
         $url .= "&";
       } else {
         $url .= "?";
       }
       $url .= sprintf("seconds=%d", $main::opt_seconds);
       $fetch_timeout = $main::opt_seconds * 1.01 + 60;
+      # Set $profile_type for consumption by PrintSymbolizedProfile.
+      $main::profile_type = 'cpu';
     } else {
       # For non-CPU profiles, we add a type-extension to
       # the target profile file name.
       my $suffix = $path;
       $suffix =~ s,/,.,g;
       $profile_file .= $suffix;
+      # Set $profile_type for consumption by PrintSymbolizedProfile.
+      if ($path =~ m/$HEAP_PAGE/) {
+        $main::profile_type = 'heap';
+      } elsif ($path =~ m/$GROWTH_PAGE/) {
+        $main::profile_type = 'growth';
+      } elsif ($path =~ m/$CONTENTION_PAGE/) {
+        $main::profile_type = 'contention';
+      }
     }
 
     my $profile_dir = $ENV{"JEPROF_TMPDIR"} || ($ENV{HOME} . "/jeprof");
     if (! -d $profile_dir) {
       mkdir($profile_dir)
           || die("Unable to create profile directory $profile_dir: $!\n");
@@ -3727,12 +3825,14 @@
   $GROWTH_PAGE  =~ m,[^/]+$,;    # matches everything after the last slash
   my $growth_marker = $&;
   $SYMBOL_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
   my $symbol_marker = $&;
   $PROFILE_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
   my $profile_marker = $&;
+  $HEAP_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+  my $heap_marker = $&;
 
   # Look at first line to see if it is a heap or a CPU profile.
   # CPU profile may start with no header at all, and just binary data
   # (starting with \0\0\0\0) -- in that case, don't try to read the
   # whole firstline, since it may be gigabytes(!) of data.
   open(PROFILE, "<$fname") || error("$fname: $!\n");
@@ -3753,13 +3853,19 @@
     # Read the symbol section of the symbolized profile file.
     $symbols = ReadSymbols(*PROFILE{IO});
     # Read the next line to get the header for the remaining profile.
     $header = ReadProfileHeader(*PROFILE) || "";
   }
 
+  if ($header =~ m/^--- *($heap_marker|$growth_marker)/o) {
+    # Skip "--- ..." line for profile types that have their own headers.
+    $header = ReadProfileHeader(*PROFILE) || "";
+  }
+
   $main::profile_type = '';
+
   if ($header =~ m/^heap profile:.*$growth_marker/o) {
     $main::profile_type = 'growth';
     $result =  ReadHeapProfile($prog, *PROFILE, $header);
   } elsif ($header =~ m/^heap profile:/) {
     $main::profile_type = 'heap';
     $result =  ReadHeapProfile($prog, *PROFILE, $header);
@@ -3805,15 +3911,15 @@
 # was written.
 #
 # We apply the same logic to all readers, though ReadCPUProfile uses an
 # independent implementation.
 sub FixCallerAddresses {
   my $stack = shift;
-  if ($main::use_symbolized_profile) {
-    return $stack;
-  } else {
+  # --raw/http: Always subtract one from pc's, because PrintSymbolizedProfile()
+  # dumps unadjusted profiles.
+  {
     $stack =~ /(\s)/;
     my $delimiter = $1;
     my @addrs = split(' ', $stack);
     my @fixedaddrs;
     $#fixedaddrs = $#addrs;
     if ($#addrs >= 0) {
@@ -3875,18 +3981,13 @@
 
     # Make key out of the stack entries
     my @k = ();
     for (my $j = 0; $j < $d; $j++) {
       my $pc = $slots->get($i+$j);
       # Subtract one from caller pc so we map back to call instr.
-      # However, don't do this if we're reading a symbolized profile
-      # file, in which case the subtract-one was done when the file
-      # was written.
-      if ($j > 0 && !$main::use_symbolized_profile) {
-        $pc--;
-      }
+      $pc--;
       $pc = sprintf("%0*x", $address_length, $pc);
       $pcs->{$pc} = 1;
       push @k, $pc;
     }
 
     AddEntry($profile, (join "\n", @k), $n);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/bin/jeprof.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/bin/jeprof.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/bin/jeprof.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/bin/jeprof.in	2017-01-31 23:32:23.000000000 +0800
@@ -92,13 +92,13 @@
 my @DOT = ("dot");          # leave non-absolute, since it may be in /usr/local
 my @GV = ("gv");
 my @EVINCE = ("evince");    # could also be xpdf or perhaps acroread
 my @KCACHEGRIND = ("kcachegrind");
 my @PS2PDF = ("ps2pdf");
 # These are used for dynamic profiles
-my @URL_FETCHER = ("curl", "-s");
+my @URL_FETCHER = ("curl", "-s", "--fail");
 
 # These are the web pages that servers need to support for dynamic profiles
 my $HEAP_PAGE = "/pprof/heap";
 my $PROFILE_PAGE = "/pprof/profile";   # must support cgi-param "?seconds=#"
 my $PMUPROFILE_PAGE = "/pprof/pmuprofile(?:\\?.*)?"; # must support cgi-param
                                                 # ?seconds=#&event=x&period=n
@@ -220,18 +220,20 @@
 
 Call-graph Options:
    --nodecount=<n>     Show at most so many nodes [default=80]
    --nodefraction=<f>  Hide nodes below <f>*total [default=.005]
    --edgefraction=<f>  Hide edges below <f>*total [default=.001]
    --maxdegree=<n>     Max incoming/outgoing edges per node [default=8]
-   --focus=<regexp>    Focus on nodes matching <regexp>
+   --focus=<regexp>    Focus on backtraces with nodes matching <regexp>
    --thread=<n>        Show profile for thread <n>
-   --ignore=<regexp>   Ignore nodes matching <regexp>
+   --ignore=<regexp>   Ignore backtraces with nodes matching <regexp>
    --scale=<n>         Set GV scaling [default=0]
    --heapcheck         Make nodes with non-0 object counts
                        (i.e. direct leak generators) more visible
+   --retain=<regexp>   Retain only nodes that match <regexp>
+   --exclude=<regexp>  Exclude all nodes that match <regexp>
 
 Miscellaneous:
    --tools=<prefix or binary:fullpath>[,...]   \$PATH for object tool pathnames
    --test              Run unit tests
    --help              This message
    --version           Version information
@@ -336,12 +338,14 @@
   $main::opt_maxdegree = 8;
   $main::opt_focus = '';
   $main::opt_thread = undef;
   $main::opt_ignore = '';
   $main::opt_scale = 0;
   $main::opt_heapcheck = 0;
+  $main::opt_retain = '';
+  $main::opt_exclude = '';
   $main::opt_seconds = 30;
   $main::opt_lib = "";
 
   $main::opt_inuse_space   = 0;
   $main::opt_inuse_objects = 0;
   $main::opt_alloc_space   = 0;
@@ -407,12 +411,14 @@
              "maxdegree=i"    => \$main::opt_maxdegree,
              "focus=s"        => \$main::opt_focus,
              "thread=s"       => \$main::opt_thread,
              "ignore=s"       => \$main::opt_ignore,
              "scale=i"        => \$main::opt_scale,
              "heapcheck"      => \$main::opt_heapcheck,
+             "retain=s"       => \$main::opt_retain,
+             "exclude=s"      => \$main::opt_exclude,
              "inuse_space!"   => \$main::opt_inuse_space,
              "inuse_objects!" => \$main::opt_inuse_objects,
              "alloc_space!"   => \$main::opt_alloc_space,
              "alloc_objects!" => \$main::opt_alloc_objects,
              "show_bytes!"    => \$main::opt_show_bytes,
              "drop_negative!" => \$main::opt_drop_negative,
@@ -1157,23 +1163,42 @@
       $sep = '--';
     }
     print "\n";
   }
   print '---', "\n";
 
-  $PROFILE_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
-  my $profile_marker = $&;
+  my $profile_marker;
+  if ($main::profile_type eq 'heap') {
+    $HEAP_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+    $profile_marker = $&;
+  } elsif ($main::profile_type eq 'growth') {
+    $GROWTH_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+    $profile_marker = $&;
+  } elsif ($main::profile_type eq 'contention') {
+    $CONTENTION_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+    $profile_marker = $&;
+  } else { # elsif ($main::profile_type eq 'cpu')
+    $PROFILE_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+    $profile_marker = $&;
+  }
+
   print '--- ', $profile_marker, "\n";
   if (defined($main::collected_profile)) {
     # if used with remote fetch, simply dump the collected profile to output.
     open(SRC, "<$main::collected_profile");
     while (<SRC>) {
       print $_;
     }
     close(SRC);
   } else {
+    # --raw/http: For everything to work correctly for non-remote profiles, we
+    # would need to extend PrintProfileData() to handle all possible profile
+    # types, re-enable the code that is currently disabled in ReadCPUProfile()
+    # and FixCallerAddresses(), and remove the remote profile dumping code in
+    # the block above.
+    die "--raw/http: jeprof can only dump remote profiles for --raw\n";
     # dump a cpu-format profile to standard out
     PrintProfileData($profile);
   }
 }
 
 # Print text output
@@ -2818,12 +2843,49 @@
     }
   }
 
   return $calls;
 }
 
+sub FilterFrames {
+  my $symbols = shift;
+  my $profile = shift;
+
+  if ($main::opt_retain eq '' && $main::opt_exclude eq '') {
+    return $profile;
+  }
+
+  my $result = {};
+  foreach my $k (keys(%{$profile})) {
+    my $count = $profile->{$k};
+    my @addrs = split(/\n/, $k);
+    my @path = ();
+    foreach my $a (@addrs) {
+      my $sym;
+      if (exists($symbols->{$a})) {
+        $sym = $symbols->{$a}->[0];
+      } else {
+        $sym = $a;
+      }
+      if ($main::opt_retain ne '' && $sym !~ m/$main::opt_retain/) {
+        next;
+      }
+      if ($main::opt_exclude ne '' && $sym =~ m/$main::opt_exclude/) {
+        next;
+      }
+      push(@path, $a);
+    }
+    if (scalar(@path) > 0) {
+      my $reduced_path = join("\n", @path);
+      AddEntry($result, $reduced_path, $count);
+    }
+  }
+
+  return $result;
+}
+
 sub RemoveUninterestingFrames {
   my $symbols = shift;
   my $profile = shift;
 
   # List of function names to skip
   my %skip = ();
@@ -2962,12 +3024,15 @@
       }
       push(@path, $a);
     }
     my $reduced_path = join("\n", @path);
     AddEntry($result, $reduced_path, $count);
   }
+
+  $result = FilterFrames($symbols, $result);
+
   return $result;
 }
 
 # Reduce profile to granularity given by user
 sub ReduceProfile {
   my $symbols = shift;
@@ -3271,13 +3336,13 @@
   return $url;
 }
 
 # Add a timeout flat to URL_FETCHER.  Returns a new list.
 sub AddFetchTimeout {
   my $timeout = shift;
-  my @fetcher = shift;
+  my @fetcher = @_;
   if (defined($timeout)) {
     if (join(" ", @fetcher) =~ m/\bcurl -s/) {
       push(@fetcher, "--max-time", sprintf("%d", $timeout));
     } elsif (join(" ", @fetcher) =~ m/\brpcget\b/) {
       push(@fetcher, sprintf("--deadline=%d", $timeout));
     }
@@ -3317,12 +3382,33 @@
       }
     }
   }
   return $map;
 }
 
+sub URLEncode {
+  my $str = shift;
+  $str =~ s/([^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%02x", ord $1 /eg;
+  return $str;
+}
+
+sub AppendSymbolFilterParams {
+  my $url = shift;
+  my @params = ();
+  if ($main::opt_retain ne '') {
+    push(@params, sprintf("retain=%s", URLEncode($main::opt_retain)));
+  }
+  if ($main::opt_exclude ne '') {
+    push(@params, sprintf("exclude=%s", URLEncode($main::opt_exclude)));
+  }
+  if (scalar @params > 0) {
+    $url = sprintf("%s?%s", $url, join("&", @params));
+  }
+  return $url;
+}
+
 # Fetches and processes symbols to prepare them for use in the profile output
 # code.  If the optional 'symbol_map' arg is not given, fetches symbols from
 # $SYMBOL_PAGE for all PC values found in profile.  Otherwise, the raw symbols
 # are assumed to have already been fetched into 'symbol_map' and are simply
 # extracted and processed.
 sub FetchSymbols {
@@ -3341,15 +3427,17 @@
 
     my $url = SymbolPageURL();
 
     my $command_line;
     if (join(" ", @URL_FETCHER) =~ m/\bcurl -s/) {
       $url = ResolveRedirectionForCurl($url);
+      $url = AppendSymbolFilterParams($url);
       $command_line = ShellEscape(@URL_FETCHER, "-d", "\@$main::tmpfile_sym",
                                   $url);
     } else {
+      $url = AppendSymbolFilterParams($url);
       $command_line = (ShellEscape(@URL_FETCHER, "--post", $url)
                        . " < " . ShellEscape($main::tmpfile_sym));
     }
     # We use c++filt in case $SYMBOL_PAGE gives us mangled symbols.
     my $escaped_cppfilt = ShellEscape($obj_tool_map{"c++filt"});
     open(SYMBOL, "$command_line | $escaped_cppfilt |") or error($command_line);
@@ -3424,18 +3512,28 @@
         $url .= "&";
       } else {
         $url .= "?";
       }
       $url .= sprintf("seconds=%d", $main::opt_seconds);
       $fetch_timeout = $main::opt_seconds * 1.01 + 60;
+      # Set $profile_type for consumption by PrintSymbolizedProfile.
+      $main::profile_type = 'cpu';
     } else {
       # For non-CPU profiles, we add a type-extension to
       # the target profile file name.
       my $suffix = $path;
       $suffix =~ s,/,.,g;
       $profile_file .= $suffix;
+      # Set $profile_type for consumption by PrintSymbolizedProfile.
+      if ($path =~ m/$HEAP_PAGE/) {
+        $main::profile_type = 'heap';
+      } elsif ($path =~ m/$GROWTH_PAGE/) {
+        $main::profile_type = 'growth';
+      } elsif ($path =~ m/$CONTENTION_PAGE/) {
+        $main::profile_type = 'contention';
+      }
     }
 
     my $profile_dir = $ENV{"JEPROF_TMPDIR"} || ($ENV{HOME} . "/jeprof");
     if (! -d $profile_dir) {
       mkdir($profile_dir)
           || die("Unable to create profile directory $profile_dir: $!\n");
@@ -3727,12 +3825,14 @@
   $GROWTH_PAGE  =~ m,[^/]+$,;    # matches everything after the last slash
   my $growth_marker = $&;
   $SYMBOL_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
   my $symbol_marker = $&;
   $PROFILE_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
   my $profile_marker = $&;
+  $HEAP_PAGE =~ m,[^/]+$,;    # matches everything after the last slash
+  my $heap_marker = $&;
 
   # Look at first line to see if it is a heap or a CPU profile.
   # CPU profile may start with no header at all, and just binary data
   # (starting with \0\0\0\0) -- in that case, don't try to read the
   # whole firstline, since it may be gigabytes(!) of data.
   open(PROFILE, "<$fname") || error("$fname: $!\n");
@@ -3753,13 +3853,19 @@
     # Read the symbol section of the symbolized profile file.
     $symbols = ReadSymbols(*PROFILE{IO});
     # Read the next line to get the header for the remaining profile.
     $header = ReadProfileHeader(*PROFILE) || "";
   }
 
+  if ($header =~ m/^--- *($heap_marker|$growth_marker)/o) {
+    # Skip "--- ..." line for profile types that have their own headers.
+    $header = ReadProfileHeader(*PROFILE) || "";
+  }
+
   $main::profile_type = '';
+
   if ($header =~ m/^heap profile:.*$growth_marker/o) {
     $main::profile_type = 'growth';
     $result =  ReadHeapProfile($prog, *PROFILE, $header);
   } elsif ($header =~ m/^heap profile:/) {
     $main::profile_type = 'heap';
     $result =  ReadHeapProfile($prog, *PROFILE, $header);
@@ -3805,15 +3911,15 @@
 # was written.
 #
 # We apply the same logic to all readers, though ReadCPUProfile uses an
 # independent implementation.
 sub FixCallerAddresses {
   my $stack = shift;
-  if ($main::use_symbolized_profile) {
-    return $stack;
-  } else {
+  # --raw/http: Always subtract one from pc's, because PrintSymbolizedProfile()
+  # dumps unadjusted profiles.
+  {
     $stack =~ /(\s)/;
     my $delimiter = $1;
     my @addrs = split(' ', $stack);
     my @fixedaddrs;
     $#fixedaddrs = $#addrs;
     if ($#addrs >= 0) {
@@ -3875,18 +3981,13 @@
 
     # Make key out of the stack entries
     my @k = ();
     for (my $j = 0; $j < $d; $j++) {
       my $pc = $slots->get($i+$j);
       # Subtract one from caller pc so we map back to call instr.
-      # However, don't do this if we're reading a symbolized profile
-      # file, in which case the subtract-one was done when the file
-      # was written.
-      if ($j > 0 && !$main::use_symbolized_profile) {
-        $pc--;
-      }
+      $pc--;
       $pc = sprintf("%0*x", $address_length, $pc);
       $pcs->{$pc} = 1;
       push @k, $pc;
     }
 
     AddEntry($profile, (join "\n", @k), $n);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc: build-aux
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/ChangeLog /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/ChangeLog
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/ChangeLog	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/ChangeLog	2017-01-31 23:32:23.000000000 +0800
@@ -1,12 +1,232 @@
 Following are change highlights associated with official releases.  Important
 bug fixes are all mentioned, but some internal enhancements are omitted here for
 brevity.  Much more detail can be found in the git revision history:
 
     https://github.com/jemalloc/jemalloc
 
+* 4.4.0 (December 3, 2016)
+
+  New features:
+  - Add configure support for *-*-linux-android.  (@cferris1000, @jasone)
+  - Add the --disable-syscall configure option, for use on systems that place
+    security-motivated limitations on syscall(2).  (@jasone)
+  - Add support for Debian GNU/kFreeBSD.  (@thesam)
+
+  Optimizations:
+  - Add extent serial numbers and use them where appropriate as a sort key that
+    is higher priority than address, so that the allocation policy prefers older
+    extents.  This tends to improve locality (decrease fragmentation) when
+    memory grows downward.  (@jasone)
+  - Refactor madvise(2) configuration so that MADV_FREE is detected and utilized
+    on Linux 4.5 and newer.  (@jasone)
+  - Mark partially purged arena chunks as non-huge-page.  This improves
+    interaction with Linux's transparent huge page functionality.  (@jasone)
+
+  Bug fixes:
+  - Fix size class computations for edge conditions involving extremely large
+    allocations.  This regression was first released in 4.0.0.  (@jasone,
+    @ingvarha)
+  - Remove overly restrictive assertions related to the cactive statistic.  This
+    regression was first released in 4.1.0.  (@jasone)
+  - Implement a more reliable detection scheme for os_unfair_lock on macOS.
+    (@jszakmeister)
+
+* 4.3.1 (November 7, 2016)
+
+  Bug fixes:
+  - Fix a severe virtual memory leak.  This regression was first released in
+    4.3.0.  (@interwq, @jasone)
+  - Refactor atomic and prng APIs to restore support for 32-bit platforms that
+    use pre-C11 toolchains, e.g. FreeBSD's mips.  (@jasone)
+
+* 4.3.0 (November 4, 2016)
+
+  This is the first release that passes the test suite for multiple Windows
+  configurations, thanks in large part to @glandium setting up continuous
+  integration via AppVeyor (and Travis CI for Linux and OS X).
+
+  New features:
+  - Add "J" (JSON) support to malloc_stats_print().  (@jasone)
+  - Add Cray compiler support.  (@ronawho)
+
+  Optimizations:
+  - Add/use adaptive spinning for bootstrapping and radix tree node
+    initialization.  (@jasone)
+
+  Bug fixes:
+  - Fix large allocation to search starting in the optimal size class heap,
+    which can substantially reduce virtual memory churn and fragmentation.  This
+    regression was first released in 4.0.0.  (@mjp41, @jasone)
+  - Fix stats.arenas.<i>.nthreads accounting.  (@interwq)
+  - Fix and simplify decay-based purging.  (@jasone)
+  - Make DSS (sbrk(2)-related) operations lockless, which resolves potential
+    deadlocks during thread exit.  (@jasone)
+  - Fix over-sized allocation of radix tree leaf nodes.  (@mjp41, @ogaun,
+    @jasone)
+  - Fix over-sized allocation of arena_t (plus associated stats) data
+    structures.  (@jasone, @interwq)
+  - Fix EXTRA_CFLAGS to not affect configuration.  (@jasone)
+  - Fix a Valgrind integration bug.  (@ronawho)
+  - Disallow 0x5a junk filling when running in Valgrind.  (@jasone)
+  - Fix a file descriptor leak on Linux.  This regression was first released in
+    4.2.0.  (@vsarunas, @jasone)
+  - Fix static linking of jemalloc with glibc.  (@djwatson)
+  - Use syscall(2) rather than {open,read,close}(2) during boot on Linux.  This
+    works around other libraries' system call wrappers performing reentrant
+    allocation.  (@kspinka, @Whissi, @jasone)
+  - Fix OS X default zone replacement to work with OS X 10.12.  (@glandium,
+    @jasone)
+  - Fix cached memory management to avoid needless commit/decommit operations
+    during purging, which resolves permanent virtual memory map fragmentation
+    issues on Windows.  (@mjp41, @jasone)
+  - Fix TSD fetches to avoid (recursive) allocation.  This is relevant to
+    non-TLS and Windows configurations.  (@jasone)
+  - Fix malloc_conf overriding to work on Windows.  (@jasone)
+  - Forcibly disable lazy-lock on Windows (was forcibly *enabled*).  (@jasone)
+
+* 4.2.1 (June 8, 2016)
+
+  Bug fixes:
+  - Fix bootstrapping issues for configurations that require allocation during
+    tsd initialization (e.g. --disable-tls).  (@cferris1000, @jasone)
+  - Fix gettimeofday() version of nstime_update().  (@ronawho)
+  - Fix Valgrind regressions in calloc() and chunk_alloc_wrapper().  (@ronawho)
+  - Fix potential VM map fragmentation regression.  (@jasone)
+  - Fix opt_zero-triggered in-place huge reallocation zeroing.  (@jasone)
+  - Fix heap profiling context leaks in reallocation edge cases.  (@jasone)
+
+* 4.2.0 (May 12, 2016)
+
+  New features:
+  - Add the arena.<i>.reset mallctl, which makes it possible to discard all of
+    an arena's allocations in a single operation.  (@jasone)
+  - Add the stats.retained and stats.arenas.<i>.retained statistics.  (@jasone)
+  - Add the --with-version configure option.  (@jasone)
+  - Support --with-lg-page values larger than actual page size.  (@jasone)
+
+  Optimizations:
+  - Use pairing heaps rather than red-black trees for various hot data
+    structures.  (@djwatson, @jasone)
+  - Streamline fast paths of rtree operations.  (@jasone)
+  - Optimize the fast paths of calloc() and [m,d,sd]allocx().  (@jasone)
+  - Decommit unused virtual memory if the OS does not overcommit.  (@jasone)
+  - Specify MAP_NORESERVE on Linux if [heuristic] overcommit is active, in order
+    to avoid unfortunate interactions during fork(2).  (@jasone)
+
+  Bug fixes:
+  - Fix chunk accounting related to triggering gdump profiles.  (@jasone)
+  - Link against librt for clock_gettime(2) if glibc < 2.17.  (@jasone)
+  - Scale leak report summary according to sampling probability.  (@jasone)
+
+* 4.1.1 (May 3, 2016)
+
+  This bugfix release resolves a variety of mostly minor issues, though the
+  bitmap fix is critical for 64-bit Windows.
+
+  Bug fixes:
+  - Fix the linear scan version of bitmap_sfu() to shift by the proper amount
+    even when sizeof(long) is not the same as sizeof(void *), as on 64-bit
+    Windows.  (@jasone)
+  - Fix hashing functions to avoid unaligned memory accesses (and resulting
+    crashes).  This is relevant at least to some ARM-based platforms.
+    (@rkmisra)
+  - Fix fork()-related lock rank ordering reversals.  These reversals were
+    unlikely to cause deadlocks in practice except when heap profiling was
+    enabled and active.  (@jasone)
+  - Fix various chunk leaks in OOM code paths.  (@jasone)
+  - Fix malloc_stats_print() to print opt.narenas correctly.  (@jasone)
+  - Fix MSVC-specific build/test issues.  (@rustyx, @yuslepukhin)
+  - Fix a variety of test failures that were due to test fragility rather than
+    core bugs.  (@jasone)
+
+* 4.1.0 (February 28, 2016)
+
+  This release is primarily about optimizations, but it also incorporates a lot
+  of portability-motivated refactoring and enhancements.  Many people worked on
+  this release, to an extent that even with the omission here of minor changes
+  (see git revision history), and of the people who reported and diagnosed
+  issues, so much of the work was contributed that starting with this release,
+  changes are annotated with author credits to help reflect the collaborative
+  effort involved.
+
+  New features:
+  - Implement decay-based unused dirty page purging, a major optimization with
+    mallctl API impact.  This is an alternative to the existing ratio-based
+    unused dirty page purging, and is intended to eventually become the sole
+    purging mechanism.  New mallctls:
+    + opt.purge
+    + opt.decay_time
+    + arena.<i>.decay
+    + arena.<i>.decay_time
+    + arenas.decay_time
+    + stats.arenas.<i>.decay_time
+    (@jasone, @cevans87)
+  - Add --with-malloc-conf, which makes it possible to embed a default
+    options string during configuration.  This was motivated by the desire to
+    specify --with-malloc-conf=purge:decay , since the default must remain
+    purge:ratio until the 5.0.0 release.  (@jasone)
+  - Add MS Visual Studio 2015 support.  (@rustyx, @yuslepukhin)
+  - Make *allocx() size class overflow behavior defined.  The maximum
+    size class is now less than PTRDIFF_MAX to protect applications against
+    numerical overflow, and all allocation functions are guaranteed to indicate
+    errors rather than potentially crashing if the request size exceeds the
+    maximum size class.  (@jasone)
+  - jeprof:
+    + Add raw heap profile support.  (@jasone)
+    + Add --retain and --exclude for backtrace symbol filtering.  (@jasone)
+
+  Optimizations:
+  - Optimize the fast path to combine various bootstrapping and configuration
+    checks and execute more streamlined code in the common case.  (@interwq)
+  - Use linear scan for small bitmaps (used for small object tracking).  In
+    addition to speeding up bitmap operations on 64-bit systems, this reduces
+    allocator metadata overhead by approximately 0.2%.  (@djwatson)
+  - Separate arena_avail trees, which substantially speeds up run tree
+    operations.  (@djwatson)
+  - Use memoization (boot-time-computed table) for run quantization.  Separate
+    arena_avail trees reduced the importance of this optimization.  (@jasone)
+  - Attempt mmap-based in-place huge reallocation.  This can dramatically speed
+    up incremental huge reallocation.  (@jasone)
+
+  Incompatible changes:
+  - Make opt.narenas unsigned rather than size_t.  (@jasone)
+
+  Bug fixes:
+  - Fix stats.cactive accounting regression.  (@rustyx, @jasone)
+  - Handle unaligned keys in hash().  This caused problems for some ARM systems.
+    (@jasone, @cferris1000)
+  - Refactor arenas array.  In addition to fixing a fork-related deadlock, this
+    makes arena lookups faster and simpler.  (@jasone)
+  - Move retained memory allocation out of the default chunk allocation
+    function, to a location that gets executed even if the application installs
+    a custom chunk allocation function.  This resolves a virtual memory leak.
+    (@buchgr)
+  - Fix a potential tsd cleanup leak.  (@cferris1000, @jasone)
+  - Fix run quantization.  In practice this bug had no impact unless
+    applications requested memory with alignment exceeding one page.
+    (@jasone, @djwatson)
+  - Fix LinuxThreads-specific bootstrapping deadlock.  (Cosmin Paraschiv)
+  - jeprof:
+    + Don't discard curl options if timeout is not defined.  (@djwatson)
+    + Detect failed profile fetches.  (@djwatson)
+  - Fix stats.arenas.<i>.{dss,lg_dirty_mult,decay_time,pactive,pdirty} for
+    --disable-stats case.  (@jasone)
+
+* 4.0.4 (October 24, 2015)
+
+  This bugfix release fixes another xallocx() regression.  No other regressions
+  have come to light in over a month, so this is likely a good starting point
+  for people who prefer to wait for "dot one" releases with all the major issues
+  shaken out.
+
+  Bug fixes:
+  - Fix xallocx(..., MALLOCX_ZERO to zero the last full trailing page of large
+    allocations that have been randomly assigned an offset of 0 when
+    --enable-cache-oblivious configure option is enabled.
+
 * 4.0.3 (September 24, 2015)
 
   This bugfix release continues the trend of xallocx() and heap profiling fixes.
 
   Bug fixes:
   - Fix xallocx(..., MALLOCX_ZERO) to zero all trailing bytes of large
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc: config.guess
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/config.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/config.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/config.log	2017-09-27 23:00:17.806936186 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/config.log	2017-09-27 23:01:52.834932703 +0800
@@ -40,173 +40,203 @@
 
 
 ## ----------- ##
 ## Core tests. ##
 ## ----------- ##
 
-configure:2540: checking for xsltproc
-configure:2558: found /opt/anaconda2/bin/xsltproc
-configure:2571: result: /opt/anaconda2/bin/xsltproc
-configure:2652: checking for gcc
-configure:2668: found /usr/bin/gcc
-configure:2679: result: gcc
-configure:2908: checking for C compiler version
-configure:2917: gcc --version >&5
+configure:2593: checking for xsltproc
+configure:2611: found /opt/anaconda2/bin/xsltproc
+configure:2624: result: /opt/anaconda2/bin/xsltproc
+configure:2705: checking for gcc
+configure:2721: found /usr/bin/gcc
+configure:2732: result: gcc
+configure:2961: checking for C compiler version
+configure:2970: gcc --version >&5
 gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4
 Copyright (C) 2013 Free Software Foundation, Inc.
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-configure:2928: $? = 0
-configure:2917: gcc -v >&5
+configure:2981: $? = 0
+configure:2970: gcc -v >&5
 Using built-in specs.
 COLLECT_GCC=gcc
 COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper
 Target: x86_64-linux-gnu
 Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04.3' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
 Thread model: posix
 gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.3) 
-configure:2928: $? = 0
-configure:2917: gcc -V >&5
+configure:2981: $? = 0
+configure:2970: gcc -V >&5
 gcc: error: unrecognized command line option '-V'
 gcc: fatal error: no input files
 compilation terminated.
-configure:2928: $? = 4
-configure:2917: gcc -qversion >&5
+configure:2981: $? = 4
+configure:2970: gcc -qversion >&5
 gcc: error: unrecognized command line option '-qversion'
 gcc: fatal error: no input files
 compilation terminated.
-configure:2928: $? = 4
-configure:2948: checking whether the C compiler works
-configure:2970: gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:2974: $? = 0
-configure:3022: result: yes
-configure:3025: checking for C compiler default output file name
-configure:3027: result: a.out
-configure:3033: checking for suffix of executables
-configure:3040: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:3044: $? = 0
-configure:3066: result: 
-configure:3088: checking whether we are cross compiling
-configure:3096: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:3100: $? = 0
-configure:3107: ./conftest
-configure:3111: $? = 0
-configure:3126: result: no
-configure:3131: checking for suffix of object files
-configure:3153: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:3157: $? = 0
-configure:3178: result: o
-configure:3182: checking whether we are using the GNU C compiler
-configure:3201: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:3201: $? = 0
-configure:3210: result: yes
-configure:3219: checking whether gcc accepts -g
-configure:3239: gcc -c -g  conftest.c >&5
-configure:3239: $? = 0
-configure:3280: result: yes
-configure:3297: checking for gcc option to accept ISO C89
-configure:3360: gcc  -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:3360: $? = 0
-configure:3373: result: none needed
-configure:3807: checking how to run the C preprocessor
-configure:3838: gcc -E  conftest.c
-configure:3838: $? = 0
-configure:3852: gcc -E  conftest.c
+configure:2981: $? = 4
+configure:3001: checking whether the C compiler works
+configure:3023: gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:3027: $? = 0
+configure:3075: result: yes
+configure:3078: checking for C compiler default output file name
+configure:3080: result: a.out
+configure:3086: checking for suffix of executables
+configure:3093: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:3097: $? = 0
+configure:3119: result: 
+configure:3141: checking whether we are cross compiling
+configure:3149: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:3153: $? = 0
+configure:3160: ./conftest
+configure:3164: $? = 0
+configure:3179: result: no
+configure:3184: checking for suffix of object files
+configure:3206: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:3210: $? = 0
+configure:3231: result: o
+configure:3235: checking whether we are using the GNU C compiler
+configure:3254: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:3254: $? = 0
+configure:3263: result: yes
+configure:3272: checking whether gcc accepts -g
+configure:3292: gcc -c -g  conftest.c >&5
+configure:3292: $? = 0
+configure:3333: result: yes
+configure:3350: checking for gcc option to accept ISO C89
+configure:3413: gcc  -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:3413: $? = 0
+configure:3426: result: none needed
+configure:3491: checking whether compiler is cray
+configure:3511: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+conftest.c: In function 'main':
+conftest.c:15:11: error: expected '=', ',', ';', 'asm' or '__attribute__' before '-' token
+   int fail-1;
+           ^
+conftest.c:15:11: warning: statement with no effect [-Wunused-value]
+configure:3511: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| /* end confdefs.h.  */
+| 
+| int
+| main ()
+| {
+| 
+| #ifndef _CRAYC
+|   int fail-1;
+| #endif
+| 
+|   ;
+|   return 0;
+| }
+configure:3518: result: no
+configure:4162: checking how to run the C preprocessor
+configure:4193: gcc -E  conftest.c
+configure:4193: $? = 0
+configure:4207: gcc -E  conftest.c
 conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
  #include <ac_nonexistent.h>
                             ^
 compilation terminated.
-configure:3852: $? = 1
+configure:4207: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
 | #define PACKAGE_BUGREPORT ""
 | #define PACKAGE_URL ""
 | /* end confdefs.h.  */
 | #include <ac_nonexistent.h>
-configure:3877: result: gcc -E
-configure:3897: gcc -E  conftest.c
-configure:3897: $? = 0
-configure:3911: gcc -E  conftest.c
+configure:4232: result: gcc -E
+configure:4252: gcc -E  conftest.c
+configure:4252: $? = 0
+configure:4266: gcc -E  conftest.c
 conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
  #include <ac_nonexistent.h>
                             ^
 compilation terminated.
-configure:3911: $? = 1
+configure:4266: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
 | #define PACKAGE_BUGREPORT ""
 | #define PACKAGE_URL ""
 | /* end confdefs.h.  */
 | #include <ac_nonexistent.h>
-configure:3941: checking for grep that handles long lines and -e
-configure:3999: result: /bin/grep
-configure:4004: checking for egrep
-configure:4066: result: /bin/grep -E
-configure:4071: checking for ANSI C header files
-configure:4091: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4091: $? = 0
-configure:4164: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4164: $? = 0
-configure:4164: ./conftest
-configure:4164: $? = 0
-configure:4175: result: yes
-configure:4188: checking for sys/types.h
-configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4188: $? = 0
-configure:4188: result: yes
-configure:4188: checking for sys/stat.h
-configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4188: $? = 0
-configure:4188: result: yes
-configure:4188: checking for stdlib.h
-configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4188: $? = 0
-configure:4188: result: yes
-configure:4188: checking for string.h
-configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4188: $? = 0
-configure:4188: result: yes
-configure:4188: checking for memory.h
-configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4188: $? = 0
-configure:4188: result: yes
-configure:4188: checking for strings.h
-configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4188: $? = 0
-configure:4188: result: yes
-configure:4188: checking for inttypes.h
-configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4188: $? = 0
-configure:4188: result: yes
-configure:4188: checking for stdint.h
-configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4188: $? = 0
-configure:4188: result: yes
-configure:4188: checking for unistd.h
-configure:4188: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4188: $? = 0
-configure:4188: result: yes
-configure:4200: checking whether byte ordering is bigendian
-configure:4215: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4296: checking for grep that handles long lines and -e
+configure:4354: result: /bin/grep
+configure:4359: checking for egrep
+configure:4421: result: /bin/grep -E
+configure:4426: checking for ANSI C header files
+configure:4446: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4446: $? = 0
+configure:4519: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4519: $? = 0
+configure:4519: ./conftest
+configure:4519: $? = 0
+configure:4530: result: yes
+configure:4543: checking for sys/types.h
+configure:4543: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4543: $? = 0
+configure:4543: result: yes
+configure:4543: checking for sys/stat.h
+configure:4543: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4543: $? = 0
+configure:4543: result: yes
+configure:4543: checking for stdlib.h
+configure:4543: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4543: $? = 0
+configure:4543: result: yes
+configure:4543: checking for string.h
+configure:4543: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4543: $? = 0
+configure:4543: result: yes
+configure:4543: checking for memory.h
+configure:4543: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4543: $? = 0
+configure:4543: result: yes
+configure:4543: checking for strings.h
+configure:4543: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4543: $? = 0
+configure:4543: result: yes
+configure:4543: checking for inttypes.h
+configure:4543: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4543: $? = 0
+configure:4543: result: yes
+configure:4543: checking for stdint.h
+configure:4543: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4543: $? = 0
+configure:4543: result: yes
+configure:4543: checking for unistd.h
+configure:4543: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4543: $? = 0
+configure:4543: result: yes
+configure:4555: checking whether byte ordering is bigendian
+configure:4570: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
 conftest.c:20:9: error: unknown type name 'not'
          not a universal capable compiler
          ^
 conftest.c:20:15: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'universal'
          not a universal capable compiler
                ^
 conftest.c:20:15: error: unknown type name 'universal'
-configure:4215: $? = 1
+configure:4570: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -225,23 +255,23 @@
 | /* end confdefs.h.  */
 | #ifndef __APPLE_CC__
 | 	       not a universal capable compiler
 | 	     #endif
 | 	     typedef int dummy;
 | 
-configure:4260: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
-configure:4260: $? = 0
-configure:4278: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4615: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
+configure:4615: $? = 0
+configure:4633: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   conftest.c >&5
 conftest.c: In function 'main':
 conftest.c:26:4: error: unknown type name 'not'
     not big endian
     ^
 conftest.c:26:12: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'endian'
     not big endian
             ^
-configure:4278: $? = 1
+configure:4633: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -268,68 +298,74 @@
 | 		 not big endian
 | 		#endif
 | 
 |   ;
 |   return 0;
 | }
-configure:4406: result: no
-configure:4438: checking size of void *
-configure:4443: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4443: $? = 0
-configure:4443: ./conftest
-configure:4443: $? = 0
-configure:4457: result: 8
-configure:4483: checking size of int
-configure:4488: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4488: $? = 0
-configure:4488: ./conftest
-configure:4488: $? = 0
-configure:4502: result: 4
-configure:4528: checking size of long
-configure:4533: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4533: $? = 0
-configure:4533: ./conftest
-configure:4533: $? = 0
-configure:4547: result: 8
-configure:4573: checking size of intmax_t
-configure:4578: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4578: $? = 0
-configure:4578: ./conftest
-configure:4578: $? = 0
-configure:4592: result: 8
-configure:4649: checking build system type
-configure:4663: result: x86_64-unknown-linux-gnu
-configure:4683: checking host system type
-configure:4696: result: x86_64-unknown-linux-gnu
-configure:4723: checking whether pause instruction is compilable
-configure:4739: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
-configure:4739: $? = 0
-configure:4747: result: yes
-configure:4834: checking for ar
-configure:4850: found /usr/bin/ar
-configure:4861: result: ar
-configure:5024: checking malloc.h usability
-configure:5024: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE conftest.c >&5
-configure:5024: $? = 0
-configure:5024: result: yes
-configure:5024: checking malloc.h presence
-configure:5024: gcc -E  -D_GNU_SOURCE conftest.c
-configure:5024: $? = 0
-configure:5024: result: yes
-configure:5024: checking for malloc.h
-configure:5024: result: yes
-configure:5030: checking whether malloc_usable_size definition can use const argument
-configure:5046: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE conftest.c >&5
-conftest.c:35:12: error: conflicting types for 'malloc_usable_size'
+configure:4761: result: no
+configure:4798: checking size of void *
+configure:4803: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4803: $? = 0
+configure:4803: ./conftest
+configure:4803: $? = 0
+configure:4817: result: 8
+configure:4844: checking size of int
+configure:4849: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4849: $? = 0
+configure:4849: ./conftest
+configure:4849: $? = 0
+configure:4863: result: 4
+configure:4889: checking size of long
+configure:4894: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4894: $? = 0
+configure:4894: ./conftest
+configure:4894: $? = 0
+configure:4908: result: 8
+configure:4934: checking size of long long
+configure:4939: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4939: $? = 0
+configure:4939: ./conftest
+configure:4939: $? = 0
+configure:4953: result: 8
+configure:4979: checking size of intmax_t
+configure:4984: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:4984: $? = 0
+configure:4984: ./conftest
+configure:4984: $? = 0
+configure:4998: result: 8
+configure:5026: checking build system type
+configure:5040: result: x86_64-pc-linux-gnu
+configure:5060: checking host system type
+configure:5073: result: x86_64-pc-linux-gnu
+configure:5138: checking whether pause instruction is compilable
+configure:5154: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops    conftest.c  >&5
+configure:5154: $? = 0
+configure:5162: result: yes
+configure:5260: checking for ar
+configure:5276: found /usr/bin/ar
+configure:5287: result: ar
+configure:5446: checking malloc.h usability
+configure:5446: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE conftest.c >&5
+configure:5446: $? = 0
+configure:5446: result: yes
+configure:5446: checking malloc.h presence
+configure:5446: gcc -E  -D_GNU_SOURCE conftest.c
+configure:5446: $? = 0
+configure:5446: result: yes
+configure:5446: checking for malloc.h
+configure:5446: result: yes
+configure:5452: checking whether malloc_usable_size definition can use const argument
+configure:5468: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE conftest.c >&5
+conftest.c:37:12: error: conflicting types for 'malloc_usable_size'
      size_t malloc_usable_size(const void *ptr);
             ^
-In file included from conftest.c:33:0:
+In file included from conftest.c:35:0:
 /usr/include/malloc.h:129:15: note: previous declaration of 'malloc_usable_size' was here
  extern size_t malloc_usable_size (void *__ptr) __THROW;
                ^
-configure:5046: $? = 1
+configure:5468: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -348,17 +384,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | /* end confdefs.h.  */
 | #include <malloc.h>
 |      #include <stddef.h>
@@ -368,85 +406,369 @@
 | main ()
 | {
 | 
 |   ;
 |   return 0;
 | }
-configure:5054: result: no
-configure:5089: checking whether __attribute__ syntax is compilable
-configure:5105: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE  conftest.c  >&5
-configure:5105: $? = 0
-configure:5113: result: yes
-configure:5121: checking whether compiler supports -fvisibility=hidden
-configure:5143: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE conftest.c >&5
-configure:5143: $? = 0
-configure:5145: result: yes
-configure:5160: checking whether compiler supports -Werror
-configure:5182: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
-configure:5182: $? = 0
-configure:5184: result: yes
-configure:5196: checking whether tls_model attribute is compilable
-configure:5214: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c  >&5
-configure:5214: $? = 0
-configure:5222: result: yes
-configure:5235: checking whether compiler supports -Werror
-configure:5257: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
-configure:5257: $? = 0
-configure:5259: result: yes
-configure:5271: checking whether alloc_size attribute is compilable
-configure:5287: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c  >&5
-configure:5287: $? = 0
-configure:5295: result: yes
-configure:5305: checking whether compiler supports -Werror
-configure:5327: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
-configure:5327: $? = 0
-configure:5329: result: yes
-configure:5341: checking whether format(gnu_printf, ...) attribute is compilable
-configure:5357: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c  >&5
-configure:5357: $? = 0
-configure:5365: result: yes
-configure:5375: checking whether compiler supports -Werror
-configure:5397: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
-configure:5397: $? = 0
-configure:5399: result: yes
-configure:5411: checking whether format(printf, ...) attribute is compilable
-configure:5427: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c  >&5
-configure:5427: $? = 0
-configure:5435: result: yes
-configure:5488: checking for a BSD-compatible install
-configure:5556: result: /usr/bin/install -c
-configure:5610: checking for ranlib
-configure:5626: found /usr/bin/ranlib
-configure:5637: result: ranlib
-configure:5661: checking for ld
-configure:5679: found /usr/bin/ld
-configure:5692: result: /usr/bin/ld
-configure:5702: checking for autoconf
-configure:5720: found /usr/bin/autoconf
-configure:5733: result: /usr/bin/autoconf
-configure:5744: checking for memalign
-configure:5744: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-configure:5744: $? = 0
-configure:5744: result: yes
-configure:5751: checking for valloc
-configure:5751: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-configure:5751: $? = 0
-configure:5751: result: yes
-configure:6493: checking configured backtracing method
-configure:6495: result: N/A
-configure:6551: checking for sbrk
-configure:6551: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-configure:6551: $? = 0
-configure:6551: result: yes
-configure:6606: checking whether utrace(2) is compilable
-configure:6630: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-conftest.c:55:24: fatal error: sys/ktrace.h: No such file or directory
+configure:5476: result: no
+configure:5512: checking for library containing log
+configure:5543: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE  conftest.c  >&5
+conftest.c:43:6: warning: conflicting types for built-in function 'log' [enabled by default]
+ char log ();
+      ^
+/tmp/ccNNrnTb.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c:47: undefined reference to `log'
+collect2: error: ld returned 1 exit status
+configure:5543: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| /* end confdefs.h.  */
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char log ();
+| int
+| main ()
+| {
+| return log ();
+|   ;
+|   return 0;
+| }
+configure:5543: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE  conftest.c -lm   >&5
+conftest.c:43:6: warning: conflicting types for built-in function 'log' [enabled by default]
+ char log ();
+      ^
+configure:5543: $? = 0
+configure:5560: result: -lm
+configure:5578: checking whether __attribute__ syntax is compilable
+configure:5594: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops   -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:5594: $? = 0
+configure:5602: result: yes
+configure:5610: checking whether compiler supports -fvisibility=hidden
+configure:5632: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE conftest.c >&5
+configure:5632: $? = 0
+configure:5634: result: yes
+configure:5649: checking whether compiler supports -Werror
+configure:5671: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
+configure:5671: $? = 0
+configure:5673: result: yes
+configure:5685: checking whether compiler supports -herror_on_warning
+configure:5707: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror -herror_on_warning  -D_GNU_SOURCE conftest.c >&5
+gcc: error: unrecognized command line option '-h'
+configure:5707: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| #define JEMALLOC_HAVE_ATTR  
+| /* end confdefs.h.  */
+| 
+| 
+| int
+| main ()
+| {
+| 
+|     return 0;
+| 
+|   ;
+|   return 0;
+| }
+configure:5713: result: no
+configure:5721: checking whether tls_model attribute is compilable
+configure:5739: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:5739: $? = 0
+configure:5747: result: yes
+configure:5760: checking whether compiler supports -Werror
+configure:5782: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
+configure:5782: $? = 0
+configure:5784: result: yes
+configure:5796: checking whether compiler supports -herror_on_warning
+configure:5818: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror -herror_on_warning  -D_GNU_SOURCE conftest.c >&5
+gcc: error: unrecognized command line option '-h'
+configure:5818: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| #define JEMALLOC_HAVE_ATTR  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| /* end confdefs.h.  */
+| 
+| 
+| int
+| main ()
+| {
+| 
+|     return 0;
+| 
+|   ;
+|   return 0;
+| }
+configure:5824: result: no
+configure:5832: checking whether alloc_size attribute is compilable
+configure:5848: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:5848: $? = 0
+configure:5856: result: yes
+configure:5866: checking whether compiler supports -Werror
+configure:5888: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
+configure:5888: $? = 0
+configure:5890: result: yes
+configure:5902: checking whether compiler supports -herror_on_warning
+configure:5924: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror -herror_on_warning  -D_GNU_SOURCE conftest.c >&5
+gcc: error: unrecognized command line option '-h'
+configure:5924: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| #define JEMALLOC_HAVE_ATTR  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| /* end confdefs.h.  */
+| 
+| 
+| int
+| main ()
+| {
+| 
+|     return 0;
+| 
+|   ;
+|   return 0;
+| }
+configure:5930: result: no
+configure:5938: checking whether format(gnu_printf, ...) attribute is compilable
+configure:5954: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:5954: $? = 0
+configure:5962: result: yes
+configure:5972: checking whether compiler supports -Werror
+configure:5994: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE conftest.c >&5
+configure:5994: $? = 0
+configure:5996: result: yes
+configure:6008: checking whether compiler supports -herror_on_warning
+configure:6030: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror -herror_on_warning  -D_GNU_SOURCE conftest.c >&5
+gcc: error: unrecognized command line option '-h'
+configure:6030: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| #define JEMALLOC_HAVE_ATTR  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| /* end confdefs.h.  */
+| 
+| 
+| int
+| main ()
+| {
+| 
+|     return 0;
+| 
+|   ;
+|   return 0;
+| }
+configure:6036: result: no
+configure:6044: checking whether format(printf, ...) attribute is compilable
+configure:6060: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:6060: $? = 0
+configure:6068: result: yes
+configure:6121: checking for a BSD-compatible install
+configure:6189: result: /usr/bin/install -c
+configure:6243: checking for ranlib
+configure:6259: found /usr/bin/ranlib
+configure:6270: result: ranlib
+configure:6294: checking for ld
+configure:6312: found /usr/bin/ld
+configure:6325: result: /usr/bin/ld
+configure:6335: checking for autoconf
+configure:6353: found /usr/bin/autoconf
+configure:6366: result: /usr/bin/autoconf
+configure:6377: checking for memalign
+configure:6377: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:6377: $? = 0
+configure:6377: result: yes
+configure:6384: checking for valloc
+configure:6384: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:6384: $? = 0
+configure:6384: result: yes
+configure:7141: checking configured backtracing method
+configure:7143: result: N/A
+configure:7199: checking for sbrk
+configure:7199: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:7199: $? = 0
+configure:7199: result: yes
+configure:7254: checking whether utrace(2) is compilable
+configure:7278: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lm  >&5
+conftest.c:58:24: fatal error: sys/ktrace.h: No such file or directory
  #include <sys/ktrace.h>
                         ^
 compilation terminated.
-configure:6630: $? = 1
+configure:7278: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -465,17 +787,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -484,12 +808,13 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
@@ -507,20 +832,20 @@
 | 
 | 	utrace((void *)0, 0);
 | 
 |   ;
 |   return 0;
 | }
-configure:6638: result: no
-configure:6665: checking whether valgrind is compilable
-configure:6688: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-conftest.c:51:31: fatal error: valgrind/valgrind.h: No such file or directory
+configure:7286: result: no
+configure:7313: checking whether valgrind is compilable
+configure:7336: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lm  >&5
+conftest.c:54:31: fatal error: valgrind/valgrind.h: No such file or directory
  #include <valgrind/valgrind.h>
                                ^
 compilation terminated.
-configure:6688: $? = 1
+configure:7336: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -539,17 +864,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -558,12 +885,13 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
@@ -580,51 +908,160 @@
 | main ()
 | {
 | 
 |   ;
 |   return 0;
 | }
-configure:6696: result: no
-configure:6748: checking whether a program using __builtin_ffsl is compilable
-configure:6773: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-configure:6773: $? = 0
-configure:6781: result: yes
-configure:6874: checking LG_PAGE
-configure:6925: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c  >&5
-configure:6925: $? = 0
-configure:6925: ./conftest
-configure:6925: $? = 0
-configure:6935: result: 12
-configure:6994: checking pthread.h usability
-configure:6994: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE conftest.c >&5
-configure:6994: $? = 0
-configure:6994: result: yes
-configure:6994: checking pthread.h presence
-configure:6994: gcc -E  -D_GNU_SOURCE conftest.c
-configure:6994: $? = 0
-configure:6994: result: yes
-configure:6994: checking for pthread.h
-configure:6994: result: yes
-configure:7006: checking for pthread_create in -lpthread
-configure:7031: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lpthread   >&5
-configure:7031: $? = 0
-configure:7040: result: yes
-configure:7111: checking for library containing clock_gettime
-configure:7142: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  >&5
-configure:7142: $? = 0
-configure:7159: result: none required
-configure:7170: checking for secure_getenv
-configure:7170: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-configure:7170: $? = 0
-configure:7170: result: yes
-configure:7183: checking for issetugid
-configure:7183: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-/tmp/cca4E5gC.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c:92: undefined reference to `issetugid'
+configure:7344: result: no
+configure:7398: checking whether a program using __builtin_unreachable is compilable
+configure:7422: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:7422: $? = 0
+configure:7430: result: yes
+configure:7442: checking whether a program using __builtin_ffsl is compilable
+configure:7467: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:7467: $? = 0
+configure:7475: result: yes
+configure:7572: checking LG_PAGE
+configure:7623: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lm  >&5
+configure:7623: $? = 0
+configure:7623: ./conftest
+configure:7623: $? = 0
+configure:7633: result: 12
+configure:7691: checking pthread.h usability
+configure:7691: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE conftest.c >&5
+configure:7691: $? = 0
+configure:7691: result: yes
+configure:7691: checking pthread.h presence
+configure:7691: gcc -E  -D_GNU_SOURCE conftest.c
+configure:7691: $? = 0
+configure:7691: result: yes
+configure:7691: checking for pthread.h
+configure:7691: result: yes
+configure:7703: checking for pthread_create in -lpthread
+configure:7728: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lpthread  -lm  >&5
+configure:7728: $? = 0
+configure:7737: result: yes
+configure:7803: checking whether pthread_atfork(3) is compilable
+configure:7823: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE  conftest.c -lm  -lpthread >&5
+configure:7823: $? = 0
+configure:7831: result: yes
+configure:7842: checking for library containing clock_gettime
+configure:7873: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:7873: $? = 0
+configure:7890: result: none required
+configure:8002: checking whether clock_gettime(CLOCK_MONOTONIC_COARSE, ...) is compilable
+configure:8024: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:8024: $? = 0
+configure:8032: result: yes
+configure:8041: checking whether clock_gettime(CLOCK_MONOTONIC, ...) is compilable
+configure:8067: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:8067: $? = 0
+configure:8075: result: yes
+configure:8084: checking whether mach_absolute_time() is compilable
+configure:8104: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+conftest.c:66:28: fatal error: mach/mach_time.h: No such file or directory
+ #include <mach/mach_time.h>
+                            ^
+compilation terminated.
+configure:8104: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| #define JEMALLOC_HAVE_ATTR  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
+| #define JEMALLOC_OVERRIDE_MEMALIGN  
+| #define JEMALLOC_OVERRIDE_VALLOC  
+| #define JEMALLOC_PREFIX "je_"
+| #define JEMALLOC_CPREFIX "JE_"
+| #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
+| #define JEMALLOC_CC_SILENCE  
+| #define JEMALLOC_STATS  
+| #define JEMALLOC_TCACHE  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
+| #define JEMALLOC_FILL  
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_QUANTUM 3
+| #define LG_PAGE 12
+| #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| /* end confdefs.h.  */
+| 
+| #include <mach/mach_time.h>
+| 
+| int
+| main ()
+| {
+| 
+| 	mach_absolute_time();
+| 
+|   ;
+|   return 0;
+| }
+configure:8112: result: no
+configure:8136: checking whether compiler supports -Werror
+configure:8158: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
+configure:8158: $? = 0
+configure:8160: result: yes
+configure:8172: checking whether syscall(2) is compilable
+configure:8193: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden -Werror  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:8193: $? = 0
+configure:8201: result: yes
+configure:8211: checking for secure_getenv
+configure:8211: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:8211: $? = 0
+configure:8211: result: yes
+configure:8224: checking for issetugid
+configure:8224: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+/tmp/ccFzJcW1.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c:101: undefined reference to `issetugid'
 collect2: error: ld returned 1 exit status
-configure:7183: $? = 1
+configure:8224: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -643,17 +1080,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -662,25 +1101,32 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | /* end confdefs.h.  */
 | /* Define issetugid to an innocuous variant, in case <limits.h> declares issetugid.
 |    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
 | #define issetugid innocuous_issetugid
 | 
@@ -715,19 +1161,19 @@
 | main ()
 | {
 | return issetugid ();
 |   ;
 |   return 0;
 | }
-configure:7183: result: no
-configure:7196: checking for _malloc_thread_cleanup
-configure:7196: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-/tmp/ccp8f8YE.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c:92: undefined reference to `_malloc_thread_cleanup'
+configure:8224: result: no
+configure:8237: checking for _malloc_thread_cleanup
+configure:8237: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+/tmp/ccDghYx4.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c:101: undefined reference to `_malloc_thread_cleanup'
 collect2: error: ld returned 1 exit status
-configure:7196: $? = 1
+configure:8237: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -746,17 +1192,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -765,25 +1213,32 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | /* end confdefs.h.  */
 | /* Define _malloc_thread_cleanup to an innocuous variant, in case <limits.h> declares _malloc_thread_cleanup.
 |    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
 | #define _malloc_thread_cleanup innocuous__malloc_thread_cleanup
 | 
@@ -818,19 +1273,19 @@
 | main ()
 | {
 | return _malloc_thread_cleanup ();
 |   ;
 |   return 0;
 | }
-configure:7196: result: no
-configure:7210: checking for _pthread_mutex_init_calloc_cb
-configure:7210: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-/tmp/ccnDj05I.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c:92: undefined reference to `_pthread_mutex_init_calloc_cb'
+configure:8237: result: no
+configure:8251: checking for _pthread_mutex_init_calloc_cb
+configure:8251: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+/tmp/ccjFXih6.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c:101: undefined reference to `_pthread_mutex_init_calloc_cb'
 collect2: error: ld returned 1 exit status
-configure:7210: $? = 1
+configure:8251: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -849,17 +1304,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -868,25 +1325,32 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | /* end confdefs.h.  */
 | /* Define _pthread_mutex_init_calloc_cb to an innocuous variant, in case <limits.h> declares _pthread_mutex_init_calloc_cb.
 |    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
 | #define _pthread_mutex_init_calloc_cb innocuous__pthread_mutex_init_calloc_cb
 | 
@@ -921,31 +1385,31 @@
 | main ()
 | {
 | return _pthread_mutex_init_calloc_cb ();
 |   ;
 |   return 0;
 | }
-configure:7210: result: no
-configure:7341: checking for TLS
-configure:7360: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
-configure:7360: $? = 0
-configure:7361: result: yes
-configure:7389: checking whether C11 atomics is compilable
-configure:7418: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-conftest.c:64:2: error: #error Atomics not available
+configure:8251: result: no
+configure:8389: checking for TLS
+configure:8408: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
+configure:8408: $? = 0
+configure:8409: result: yes
+configure:8437: checking whether C11 atomics is compilable
+configure:8466: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+conftest.c:73:2: error: #error Atomics not available
  #error Atomics not available
   ^
 conftest.c: In function 'main':
-conftest.c:73:5: error: unknown type name 'atomic_uint_least64_t'
+conftest.c:82:5: error: unknown type name 'atomic_uint_least64_t'
      volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;
      ^
-conftest.c:73:5: error: unknown type name 'atomic_uint_least64_t'
-conftest.c:74:5: warning: implicit declaration of function 'atomic_fetch_add' [-Wimplicit-function-declaration]
+conftest.c:82:5: error: unknown type name 'atomic_uint_least64_t'
+conftest.c:83:5: warning: implicit declaration of function 'atomic_fetch_add' [-Wimplicit-function-declaration]
      uint64_t r = atomic_fetch_add(a, x) + x;
      ^
-configure:7418: $? = 1
+configure:8466: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -964,17 +1428,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -983,25 +1449,32 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
 | /* end confdefs.h.  */
 | 
 | #include <stdint.h>
 | #if (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__)
@@ -1020,20 +1493,20 @@
 |     uint64_t r = atomic_fetch_add(a, x) + x;
 |     return (r == 0);
 | 
 |   ;
 |   return 0;
 | }
-configure:7426: result: no
-configure:7436: checking whether atomic(9) is compilable
-configure:7467: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-conftest.c:61:28: fatal error: machine/atomic.h: No such file or directory
+configure:8474: result: no
+configure:8484: checking whether atomic(9) is compilable
+configure:8515: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+conftest.c:70:28: fatal error: machine/atomic.h: No such file or directory
  #include <machine/atomic.h>
                             ^
 compilation terminated.
-configure:7467: $? = 1
+configure:8515: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -1052,17 +1525,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -1071,25 +1546,32 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
 | /* end confdefs.h.  */
 | 
 | #include <sys/types.h>
 | #include <machine/atomic.h>
@@ -1110,20 +1592,20 @@
 | 		atomic_fetchadd_long(xlongp, 1);
 | 	}
 | 
 |   ;
 |   return 0;
 | }
-configure:7475: result: no
-configure:7485: checking whether Darwin OSAtomic*() is compilable
-configure:7515: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-conftest.c:60:30: fatal error: libkern/OSAtomic.h: No such file or directory
+configure:8523: result: no
+configure:8533: checking whether Darwin OSAtomic*() is compilable
+configure:8563: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+conftest.c:69:30: fatal error: libkern/OSAtomic.h: No such file or directory
  #include <libkern/OSAtomic.h>
                               ^
 compilation terminated.
-configure:7515: $? = 1
+configure:8563: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -1142,17 +1624,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -1161,25 +1645,32 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
 | /* end confdefs.h.  */
 | 
 | #include <libkern/OSAtomic.h>
 | #include <inttypes.h>
@@ -1199,24 +1690,122 @@
 | 		OSAtomicAdd64(1, x64p);
 | 	}
 | 
 |   ;
 |   return 0;
 | }
-configure:7523: result: no
-configure:7533: checking whether madvise(2) is compilable
-configure:7555: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-configure:7555: $? = 0
-configure:7563: result: yes
-configure:7576: checking whether to force 32-bit __sync_{add,sub}_and_fetch()
-configure:7604: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:8571: result: no
+configure:8581: checking whether madvise(2) is compilable
+configure:8601: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:8601: $? = 0
+configure:8609: result: yes
+configure:8617: checking whether madvise(..., MADV_FREE) is compilable
+configure:8637: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
 conftest.c: In function 'main':
-conftest.c:74:51: error: #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 is defined, no need to force
+conftest.c:76:24: error: 'MADV_FREE' undeclared (first use in this function)
+  madvise((void *)0, 0, MADV_FREE);
+                        ^
+conftest.c:76:24: note: each undeclared identifier is reported only once for each function it appears in
+configure:8637: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| #define JEMALLOC_HAVE_ATTR  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
+| #define JEMALLOC_OVERRIDE_MEMALIGN  
+| #define JEMALLOC_OVERRIDE_VALLOC  
+| #define JEMALLOC_PREFIX "je_"
+| #define JEMALLOC_CPREFIX "JE_"
+| #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
+| #define JEMALLOC_CC_SILENCE  
+| #define JEMALLOC_STATS  
+| #define JEMALLOC_TCACHE  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
+| #define JEMALLOC_FILL  
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_QUANTUM 3
+| #define LG_PAGE 12
+| #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
+| #define JEMALLOC_HAVE_SECURE_GETENV  
+| #define JEMALLOC_TLS
+| #define JEMALLOC_HAVE_MADVISE  
+| /* end confdefs.h.  */
+| 
+| #include <sys/mman.h>
+| 
+| int
+| main ()
+| {
+| 
+| 	madvise((void *)0, 0, MADV_FREE);
+| 
+|   ;
+|   return 0;
+| }
+configure:8645: result: no
+configure:8654: checking whether madvise(..., MADV_DONTNEED) is compilable
+configure:8674: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:8674: $? = 0
+configure:8682: result: yes
+configure:8691: checking whether madvise(..., MADV_[NO]HUGEPAGE) is compilable
+configure:8712: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:8712: $? = 0
+configure:8720: result: yes
+configure:8734: checking whether to force 32-bit __sync_{add,sub}_and_fetch()
+configure:8762: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+conftest.c: In function 'main':
+conftest.c:85:51: error: #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 is defined, no need to force
                                                   #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 is defined, no need to force
                                                    ^
-configure:7604: $? = 1
+configure:8762: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -1235,17 +1824,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -1254,28 +1845,37 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
 | #define JEMALLOC_HAVE_MADVISE  
+| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_THP  
 | /* end confdefs.h.  */
 | 
 |                                                  #include <stdint.h>
 | 
 | int
 | main ()
@@ -1291,20 +1891,20 @@
 |                                                  #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 is defined, no need to force
 |                                                  #endif
 | 
 |   ;
 |   return 0;
 | }
-configure:7612: result: no
-configure:7621: checking whether to force 64-bit __sync_{add,sub}_and_fetch()
-configure:7649: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:8770: result: no
+configure:8779: checking whether to force 64-bit __sync_{add,sub}_and_fetch()
+configure:8807: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
 conftest.c: In function 'main':
-conftest.c:74:51: error: #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 is defined, no need to force
+conftest.c:85:51: error: #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 is defined, no need to force
                                                   #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 is defined, no need to force
                                                    ^
-configure:7649: $? = 1
+configure:8807: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -1323,17 +1923,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -1342,28 +1944,37 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
 | #define JEMALLOC_HAVE_MADVISE  
+| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_THP  
 | /* end confdefs.h.  */
 | 
 |                                                  #include <stdint.h>
 | 
 | int
 | main ()
@@ -1379,31 +1990,130 @@
 |                                                  #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 is defined, no need to force
 |                                                  #endif
 | 
 |   ;
 |   return 0;
 | }
-configure:7657: result: no
-configure:7668: checking for __builtin_clz
-configure:7693: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:8815: result: no
+configure:8826: checking for __builtin_clz
+configure:8851: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
 conftest.c: In function 'main':
-conftest.c:67:61: warning: unused variable 'y' [-Wunused-variable]
+conftest.c:78:61: warning: unused variable 'y' [-Wunused-variable]
                                                          int y = __builtin_clz(x);
                                                              ^
-conftest.c:71:61: warning: unused variable 'y' [-Wunused-variable]
+conftest.c:82:61: warning: unused variable 'y' [-Wunused-variable]
                                                          int y = __builtin_clzl(x);
                                                              ^
-configure:7693: $? = 0
-configure:7701: result: yes
-configure:7711: checking whether Darwin OSSpin*() is compilable
-configure:7734: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-conftest.c:62:30: fatal error: libkern/OSAtomic.h: No such file or directory
+configure:8851: $? = 0
+configure:8859: result: yes
+configure:8869: checking whether Darwin os_unfair_lock_*() is compilable
+configure:8896: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+conftest.c:73:21: fatal error: os/lock.h: No such file or directory
+ #include <os/lock.h>
+                     ^
+compilation terminated.
+configure:8896: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define SIZEOF_VOID_P 8
+| #define LG_SIZEOF_PTR 3
+| #define SIZEOF_INT 4
+| #define LG_SIZEOF_INT 2
+| #define SIZEOF_LONG 8
+| #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
+| #define SIZEOF_INTMAX_T 8
+| #define LG_SIZEOF_INTMAX_T 3
+| #define CPU_SPINWAIT __asm__ volatile("pause")
+| #define JEMALLOC_HAS_ALLOCA_H 1
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
+| #define JEMALLOC_THREADED_INIT  
+| #define JEMALLOC_USE_CXX_THROW  
+| #define HAVE_MALLOC_H 1
+| #define JEMALLOC_USABLE_SIZE_CONST 
+| #define JEMALLOC_HAVE_ATTR  
+| #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
+| #define JEMALLOC_HAVE_ATTR_ALLOC_SIZE  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF  
+| #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
+| #define JEMALLOC_OVERRIDE_MEMALIGN  
+| #define JEMALLOC_OVERRIDE_VALLOC  
+| #define JEMALLOC_PREFIX "je_"
+| #define JEMALLOC_CPREFIX "JE_"
+| #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
+| #define JEMALLOC_CC_SILENCE  
+| #define JEMALLOC_STATS  
+| #define JEMALLOC_TCACHE  
+| #define JEMALLOC_MAPS_COALESCE  
+| #define JEMALLOC_DSS  
+| #define JEMALLOC_FILL  
+| #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
+| #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
+| #define JEMALLOC_INTERNAL_FFS __builtin_ffs
+| #define LG_TINY_MIN 3
+| #define LG_QUANTUM 3
+| #define LG_PAGE 12
+| #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
+| #define JEMALLOC_HAVE_SECURE_GETENV  
+| #define JEMALLOC_TLS
+| #define JEMALLOC_HAVE_MADVISE  
+| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_THP  
+| #define JEMALLOC_HAVE_BUILTIN_CLZ  
+| /* end confdefs.h.  */
+| 
+| #include <os/lock.h>
+| #include <AvailabilityMacros.h>
+| 
+| int
+| main ()
+| {
+| 
+| 	#if MAC_OS_X_VERSION_MIN_REQUIRED < 101200
+| 	#error "os_unfair_lock is not supported"
+| 	#else
+| 	os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;
+| 	os_unfair_lock_lock(&lock);
+| 	os_unfair_lock_unlock(&lock);
+| 	#endif
+| 
+|   ;
+|   return 0;
+| }
+configure:8904: result: no
+configure:8914: checking whether Darwin OSSpin*() is compilable
+configure:8937: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+conftest.c:73:30: fatal error: libkern/OSAtomic.h: No such file or directory
  #include <libkern/OSAtomic.h>
                               ^
 compilation terminated.
-configure:7734: $? = 1
+configure:8937: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -1422,17 +2132,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -1441,28 +2153,37 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
 | #define JEMALLOC_HAVE_MADVISE  
+| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_THP  
 | #define JEMALLOC_HAVE_BUILTIN_CLZ  
 | /* end confdefs.h.  */
 | 
 | #include <libkern/OSAtomic.h>
 | #include <inttypes.h>
 | 
@@ -1474,76 +2195,76 @@
 | 	OSSpinLockLock(&lock);
 | 	OSSpinLockUnlock(&lock);
 | 
 |   ;
 |   return 0;
 | }
-configure:7742: result: no
-configure:7929: checking whether glibc malloc hook is compilable
-configure:7956: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-configure:7956: $? = 0
-configure:7964: result: yes
-configure:7973: checking whether glibc memalign hook is compilable
-configure:7996: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
+configure:8945: result: no
+configure:9132: checking whether glibc malloc hook is compilable
+configure:9159: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:9159: $? = 0
+configure:9167: result: yes
+configure:9176: checking whether glibc memalign hook is compilable
+configure:9199: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
 conftest.c: In function 'main':
-conftest.c:71:9: warning: variable 'ptr' set but not used [-Wunused-but-set-variable]
+conftest.c:82:9: warning: variable 'ptr' set but not used [-Wunused-but-set-variable]
    void *ptr = 0L;
          ^
-configure:7996: $? = 0
-configure:8004: result: yes
-configure:8013: checking whether pthreads adaptive mutexes is compilable
-configure:8036: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-configure:8036: $? = 0
-configure:8044: result: yes
-configure:8052: checking for stdbool.h that conforms to C99
-configure:8119: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
+configure:9199: $? = 0
+configure:9207: result: yes
+configure:9216: checking whether pthreads adaptive mutexes is compilable
+configure:9239: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c -lm  -lpthread >&5
+configure:9239: $? = 0
+configure:9247: result: yes
+configure:9255: checking for stdbool.h that conforms to C99
+configure:9322: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
 conftest.c: In function 'main':
-conftest.c:113:14: warning: the address of 's' will always evaluate as 'true' [-Waddress]
+conftest.c:124:14: warning: the address of 's' will always evaluate as 'true' [-Waddress]
               bool e = &s;
               ^
-conftest.c:117:22: warning: the address of 'a' will always evaluate as 'true' [-Waddress]
+conftest.c:128:22: warning: the address of 'a' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                       ^
-conftest.c:117:27: warning: the address of 'b' will always evaluate as 'true' [-Waddress]
+conftest.c:128:27: warning: the address of 'b' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                            ^
-conftest.c:117:32: warning: the address of 'c' will always evaluate as 'true' [-Waddress]
+conftest.c:128:32: warning: the address of 'c' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                 ^
-conftest.c:117:37: warning: the address of 'd' will always evaluate as 'true' [-Waddress]
+conftest.c:128:37: warning: the address of 'd' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                      ^
-conftest.c:117:47: warning: the address of 'f' will always evaluate as 'true' [-Waddress]
+conftest.c:128:47: warning: the address of 'f' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                                ^
-conftest.c:117:52: warning: the address of 'g' will always evaluate as 'true' [-Waddress]
+conftest.c:128:52: warning: the address of 'g' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                                     ^
-conftest.c:117:57: warning: the address of 'h' will always evaluate as 'true' [-Waddress]
+conftest.c:128:57: warning: the address of 'h' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                                          ^
-conftest.c:117:62: warning: the address of 'i' will always evaluate as 'true' [-Waddress]
+conftest.c:128:62: warning: the address of 'i' will always evaluate as 'true' [-Waddress]
               return (!a + !b + !c + !d + !e + !f + !g + !h + !i + !!j + !k + !!l
                                                               ^
-conftest.c:118:29: warning: the address of 'n' will always evaluate as 'true' [-Waddress]
+conftest.c:129:29: warning: the address of 'n' will always evaluate as 'true' [-Waddress]
                              ^
-conftest.c:118:34: warning: the address of 'o' will always evaluate as 'true' [-Waddress]
+conftest.c:129:34: warning: the address of 'o' will always evaluate as 'true' [-Waddress]
                                   ^
-conftest.c:118:39: warning: the address of 'p' will always evaluate as 'true' [-Waddress]
+conftest.c:129:39: warning: the address of 'p' will always evaluate as 'true' [-Waddress]
                                        ^
-configure:8119: $? = 0
-configure:8126: result: yes
-configure:8128: checking for _Bool
-configure:8128: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
-configure:8128: $? = 0
-configure:8128: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
+configure:9322: $? = 0
+configure:9329: result: yes
+configure:9331: checking for _Bool
+configure:9331: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
+configure:9331: $? = 0
+configure:9331: gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT conftest.c >&5
 conftest.c: In function 'main':
-conftest.c:100:20: error: expected expression before ')' token
+conftest.c:111:20: error: expected expression before ')' token
  if (sizeof ((_Bool)))
                     ^
-configure:8128: $? = 1
+configure:9331: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
 | #define PACKAGE_VERSION ""
 | #define PACKAGE_STRING ""
@@ -1562,17 +2283,19 @@
 | #define SIZEOF_VOID_P 8
 | #define LG_SIZEOF_PTR 3
 | #define SIZEOF_INT 4
 | #define LG_SIZEOF_INT 2
 | #define SIZEOF_LONG 8
 | #define LG_SIZEOF_LONG 3
+| #define SIZEOF_LONG_LONG 8
+| #define LG_SIZEOF_LONG_LONG 3
 | #define SIZEOF_INTMAX_T 8
 | #define LG_SIZEOF_INTMAX_T 3
 | #define CPU_SPINWAIT __asm__ volatile("pause")
 | #define JEMALLOC_HAS_ALLOCA_H 1
-| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 | #define JEMALLOC_THREADED_INIT  
 | #define JEMALLOC_USE_CXX_THROW  
 | #define HAVE_MALLOC_H 1
 | #define JEMALLOC_USABLE_SIZE_CONST 
 | #define JEMALLOC_HAVE_ATTR  
 | #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -1581,28 +2304,37 @@
 | #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 | #define JEMALLOC_OVERRIDE_MEMALIGN  
 | #define JEMALLOC_OVERRIDE_VALLOC  
 | #define JEMALLOC_PREFIX "je_"
 | #define JEMALLOC_CPREFIX "JE_"
 | #define JEMALLOC_PRIVATE_NAMESPACE je_
+| #define JEMALLOC_CONFIG_MALLOC_CONF ""
 | #define JEMALLOC_CC_SILENCE  
 | #define JEMALLOC_STATS  
 | #define JEMALLOC_TCACHE  
 | #define JEMALLOC_MAPS_COALESCE  
 | #define JEMALLOC_DSS  
 | #define JEMALLOC_FILL  
 | #define JEMALLOC_CACHE_OBLIVIOUS  
+| #define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+| #define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 | #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 | #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 | #define LG_TINY_MIN 3
 | #define LG_QUANTUM 3
 | #define LG_PAGE 12
 | #define HAVE_PTHREAD_H 1
+| #define JEMALLOC_HAVE_PTHREAD_ATFORK  
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+| #define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+| #define JEMALLOC_USE_SYSCALL  
 | #define JEMALLOC_HAVE_SECURE_GETENV  
 | #define JEMALLOC_TLS
 | #define JEMALLOC_HAVE_MADVISE  
+| #define JEMALLOC_PURGE_MADVISE_DONTNEED  
+| #define JEMALLOC_THP  
 | #define JEMALLOC_HAVE_BUILTIN_CLZ  
 | #define JEMALLOC_GLIBC_MALLOC_HOOK  
 | #define JEMALLOC_GLIBC_MEMALIGN_HOOK  
 | #define JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP  
 | /* end confdefs.h.  */
 | #include <stdio.h>
@@ -1643,14 +2375,14 @@
 | {
 | if (sizeof ((_Bool)))
 | 	    return 0;
 |   ;
 |   return 0;
 | }
-configure:8128: result: yes
-configure:8295: creating ./config.status
+configure:9331: result: yes
+configure:9498: creating ./config.status
 
 ## ---------------------- ##
 ## Running config.status. ##
 ## ---------------------- ##
 
 This file was extended by config.status, which was
@@ -1661,100 +2393,101 @@
   CONFIG_LINKS    = 
   CONFIG_COMMANDS = 
   $ ./config.status 
 
 on sarah-Erazer-X310
 
-config.status:1010: creating Makefile
-config.status:1010: creating jemalloc.pc
-config.status:1010: creating doc/html.xsl
-config.status:1010: creating doc/manpages.xsl
-config.status:1010: creating doc/jemalloc.xml
-config.status:1010: creating include/jemalloc/jemalloc_macros.h
-config.status:1010: creating include/jemalloc/jemalloc_protos.h
-config.status:1010: creating include/jemalloc/jemalloc_typedefs.h
-config.status:1010: creating include/jemalloc/internal/jemalloc_internal.h
-config.status:1010: creating test/test.sh
-config.status:1010: creating test/include/test/jemalloc_test.h
-config.status:1010: creating config.stamp
-config.status:1010: creating bin/jemalloc-config
-config.status:1010: creating bin/jemalloc.sh
-config.status:1010: creating bin/jeprof
-config.status:1010: creating include/jemalloc/jemalloc_defs.h
-config.status:1010: creating include/jemalloc/internal/jemalloc_internal_defs.h
-config.status:1010: creating test/include/test/jemalloc_test_defs.h
-config.status:1199: executing include/jemalloc/internal/private_namespace.h commands
-config.status:1199: executing include/jemalloc/internal/private_unnamespace.h commands
-config.status:1199: executing include/jemalloc/internal/public_symbols.txt commands
-config.status:1199: executing include/jemalloc/internal/public_namespace.h commands
-config.status:1199: executing include/jemalloc/internal/public_unnamespace.h commands
-config.status:1199: executing include/jemalloc/internal/size_classes.h commands
-config.status:1199: executing include/jemalloc/jemalloc_protos_jet.h commands
-config.status:1199: executing include/jemalloc/jemalloc_rename.h commands
-config.status:1199: executing include/jemalloc/jemalloc_mangle.h commands
-config.status:1199: executing include/jemalloc/jemalloc_mangle_jet.h commands
-config.status:1199: executing include/jemalloc/jemalloc.h commands
-configure:9599: result: ===============================================================================
-configure:9601: result: jemalloc version   : 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c
-configure:9603: result: library revision   : 2
-configure:9605: result: 
-configure:9607: result: CONFIG             : --with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence 'CFLAGS=-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops ' LDFLAGS=
-configure:9609: result: CC                 : gcc
-configure:9611: result: CFLAGS             : -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden
-configure:9613: result: CPPFLAGS           :  -D_GNU_SOURCE -D_REENTRANT
-configure:9615: result: LDFLAGS            : 
-configure:9617: result: EXTRA_LDFLAGS      : 
-configure:9619: result: LIBS               :  -lpthread
-configure:9621: result: TESTLIBS           : 
-configure:9623: result: RPATH_EXTRA        : 
-configure:9625: result: 
-configure:9627: result: XSLTPROC           : /opt/anaconda2/bin/xsltproc
-configure:9629: result: XSLROOT            : /usr/share/xml/docbook/stylesheet/docbook-xsl
-configure:9631: result: 
-configure:9633: result: PREFIX             : /usr/local
-configure:9635: result: BINDIR             : /usr/local/bin
-configure:9637: result: DATADIR            : /usr/local/share
-configure:9639: result: INCLUDEDIR         : /usr/local/include
-configure:9641: result: LIBDIR             : /usr/local/lib
-configure:9643: result: MANDIR             : /usr/local/share/man
-configure:9645: result: 
-configure:9647: result: srcroot            : 
-configure:9649: result: abs_srcroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/
-configure:9651: result: objroot            : 
-configure:9653: result: abs_objroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/
-configure:9655: result: 
-configure:9657: result: JEMALLOC_PREFIX    : je_
-configure:9659: result: JEMALLOC_PRIVATE_NAMESPACE
-configure:9661: result:                    : je_
-configure:9663: result: install_suffix     : 
-configure:9665: result: autogen            : 0
-configure:9667: result: cc-silence         : 1
-configure:9669: result: debug              : 0
-configure:9671: result: code-coverage      : 0
-configure:9673: result: stats              : 1
-configure:9675: result: prof               : 0
-configure:9677: result: prof-libunwind     : 0
-configure:9679: result: prof-libgcc        : 0
-configure:9681: result: prof-gcc           : 0
-configure:9683: result: tcache             : 1
-configure:9685: result: fill               : 1
-configure:9687: result: utrace             : 0
-configure:9689: result: valgrind           : 0
-configure:9691: result: xmalloc            : 0
-configure:9693: result: munmap             : 0
-configure:9695: result: lazy_lock          : 0
-configure:9697: result: tls                : 1
-configure:9699: result: cache-oblivious    : 1
-configure:9701: result: ===============================================================================
+config.status:1025: creating Makefile
+config.status:1025: creating jemalloc.pc
+config.status:1025: creating doc/html.xsl
+config.status:1025: creating doc/manpages.xsl
+config.status:1025: creating doc/jemalloc.xml
+config.status:1025: creating include/jemalloc/jemalloc_macros.h
+config.status:1025: creating include/jemalloc/jemalloc_protos.h
+config.status:1025: creating include/jemalloc/jemalloc_typedefs.h
+config.status:1025: creating include/jemalloc/internal/jemalloc_internal.h
+config.status:1025: creating test/test.sh
+config.status:1025: creating test/include/test/jemalloc_test.h
+config.status:1025: creating config.stamp
+config.status:1025: creating bin/jemalloc-config
+config.status:1025: creating bin/jemalloc.sh
+config.status:1025: creating bin/jeprof
+config.status:1025: creating include/jemalloc/jemalloc_defs.h
+config.status:1025: creating include/jemalloc/internal/jemalloc_internal_defs.h
+config.status:1025: creating test/include/test/jemalloc_test_defs.h
+config.status:1214: executing include/jemalloc/internal/private_namespace.h commands
+config.status:1214: executing include/jemalloc/internal/private_unnamespace.h commands
+config.status:1214: executing include/jemalloc/internal/public_symbols.txt commands
+config.status:1214: executing include/jemalloc/internal/public_namespace.h commands
+config.status:1214: executing include/jemalloc/internal/public_unnamespace.h commands
+config.status:1214: executing include/jemalloc/internal/size_classes.h commands
+config.status:1214: executing include/jemalloc/jemalloc_protos_jet.h commands
+config.status:1214: executing include/jemalloc/jemalloc_rename.h commands
+config.status:1214: executing include/jemalloc/jemalloc_mangle.h commands
+config.status:1214: executing include/jemalloc/jemalloc_mangle_jet.h commands
+config.status:1214: executing include/jemalloc/jemalloc.h commands
+configure:10802: result: ===============================================================================
+configure:10804: result: jemalloc version   : 4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc
+configure:10806: result: library revision   : 2
+configure:10808: result: 
+configure:10810: result: CONFIG             : --with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence 'CFLAGS=-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops ' LDFLAGS=
+configure:10812: result: CC                 : gcc
+configure:10814: result: CFLAGS             : -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden
+configure:10816: result: EXTRA_CFLAGS       : 
+configure:10818: result: CPPFLAGS           :  -D_GNU_SOURCE -D_REENTRANT
+configure:10820: result: LDFLAGS            : 
+configure:10822: result: EXTRA_LDFLAGS      : 
+configure:10824: result: LIBS               : -lm  -lpthread
+configure:10826: result: RPATH_EXTRA        : 
+configure:10828: result: 
+configure:10830: result: XSLTPROC           : /opt/anaconda2/bin/xsltproc
+configure:10832: result: XSLROOT            : /usr/share/xml/docbook/stylesheet/docbook-xsl
+configure:10834: result: 
+configure:10836: result: PREFIX             : /usr/local
+configure:10838: result: BINDIR             : /usr/local/bin
+configure:10840: result: DATADIR            : /usr/local/share
+configure:10842: result: INCLUDEDIR         : /usr/local/include
+configure:10844: result: LIBDIR             : /usr/local/lib
+configure:10846: result: MANDIR             : /usr/local/share/man
+configure:10848: result: 
+configure:10850: result: srcroot            : 
+configure:10852: result: abs_srcroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/
+configure:10854: result: objroot            : 
+configure:10856: result: abs_objroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/
+configure:10858: result: 
+configure:10860: result: JEMALLOC_PREFIX    : je_
+configure:10862: result: JEMALLOC_PRIVATE_NAMESPACE
+configure:10864: result:                    : je_
+configure:10866: result: install_suffix     : 
+configure:10868: result: malloc_conf        : 
+configure:10870: result: autogen            : 0
+configure:10872: result: cc-silence         : 1
+configure:10874: result: debug              : 0
+configure:10876: result: code-coverage      : 0
+configure:10878: result: stats              : 1
+configure:10880: result: prof               : 0
+configure:10882: result: prof-libunwind     : 0
+configure:10884: result: prof-libgcc        : 0
+configure:10886: result: prof-gcc           : 0
+configure:10888: result: tcache             : 1
+configure:10890: result: fill               : 1
+configure:10892: result: utrace             : 0
+configure:10894: result: valgrind           : 0
+configure:10896: result: xmalloc            : 0
+configure:10898: result: munmap             : 0
+configure:10900: result: lazy_lock          : 0
+configure:10902: result: tls                : 1
+configure:10904: result: cache-oblivious    : 1
+configure:10906: result: ===============================================================================
 
 ## ---------------- ##
 ## Cache variables. ##
 ## ---------------- ##
 
 ac_cv_big_endian=0
-ac_cv_build=x86_64-unknown-linux-gnu
+ac_cv_build=x86_64-pc-linux-gnu
 ac_cv_c_bigendian=no
 ac_cv_c_compiler_gnu=yes
 ac_cv_env_CC_set=
 ac_cv_env_CC_value=
 ac_cv_env_CFLAGS_set=set
 ac_cv_env_CFLAGS_value='-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops '
@@ -1789,13 +2522,13 @@
 ac_cv_header_stdlib_h=yes
 ac_cv_header_string_h=yes
 ac_cv_header_strings_h=yes
 ac_cv_header_sys_stat_h=yes
 ac_cv_header_sys_types_h=yes
 ac_cv_header_unistd_h=yes
-ac_cv_host=x86_64-unknown-linux-gnu
+ac_cv_host=x86_64-pc-linux-gnu
 ac_cv_lib_pthread_pthread_create=yes
 ac_cv_objext=o
 ac_cv_path_AUTOCONF=/usr/bin/autoconf
 ac_cv_path_EGREP='/bin/grep -E'
 ac_cv_path_GREP=/bin/grep
 ac_cv_path_LD=/usr/bin/ld
@@ -1805,36 +2538,50 @@
 ac_cv_prog_ac_ct_AR=ar
 ac_cv_prog_ac_ct_CC=gcc
 ac_cv_prog_ac_ct_RANLIB=ranlib
 ac_cv_prog_cc_c89=
 ac_cv_prog_cc_g=yes
 ac_cv_search_clock_gettime='none required'
+ac_cv_search_log=-lm
 ac_cv_sizeof_int=4
 ac_cv_sizeof_intmax_t=8
 ac_cv_sizeof_long=8
+ac_cv_sizeof_long_long=8
 ac_cv_sizeof_void_p=8
 ac_cv_type__Bool=yes
 je_cv_alloc_size=yes
 je_cv_atomic9=no
 je_cv_attribute=yes
 je_cv_builtin_clz=yes
 je_cv_c11atomics=no
 je_cv_cflags_appended=-Werror
+je_cv_clock_monotonic=yes
+je_cv_clock_monotonic_coarse=yes
+je_cv_cray=no
+je_cv_cray_prgenv_wrapper=
 je_cv_format_gnu_printf=yes
 je_cv_format_printf=yes
 je_cv_gcc_builtin_ffsl=yes
+je_cv_gcc_builtin_unreachable=yes
 je_cv_glibc_malloc_hook=yes
 je_cv_glibc_memalign_hook=yes
 je_cv_lg_page=12
+je_cv_mach_absolute_time=no
+je_cv_madv_dontneed=yes
+je_cv_madv_free=no
 je_cv_madvise=yes
+je_cv_os_unfair_lock=no
 je_cv_osatomic=no
 je_cv_osspin=no
 je_cv_pause=yes
+je_cv_pthread_atfork=yes
 je_cv_pthread_mutex_adaptive_np=yes
 je_cv_sync_compare_and_swap_4=no
 je_cv_sync_compare_and_swap_8=no
+je_cv_syscall=yes
+je_cv_thp=yes
 je_cv_tls_model=yes
 je_cv_utrace=no
 je_cv_valgrind=no
 
 ## ----------------- ##
 ## Output variables. ##
@@ -1857,12 +2604,13 @@
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 ECHO_C=''
 ECHO_N='-n'
 ECHO_T=''
 EGREP='/bin/grep -E'
 EXEEXT=''
+EXTRA_CFLAGS=''
 EXTRA_LDFLAGS=''
 GREP='/bin/grep'
 INCLUDEDIR='/usr/local/include'
 INSTALL_DATA='${INSTALL} -m 644'
 INSTALL_PROGRAM='${INSTALL}'
 INSTALL_SCRIPT='${INSTALL}'
@@ -1870,13 +2618,14 @@
 LD='/usr/bin/ld'
 LDFLAGS=''
 LDTARGET='-o $@'
 LD_PRELOAD_VAR='LD_PRELOAD'
 LIBDIR='/usr/local/lib'
 LIBOBJS=''
-LIBS=' -lpthread'
+LIBS='-lm  -lpthread'
+LM='-lm'
 LTLIBOBJS=''
 MANDIR='/usr/local/share/man'
 MKLIB=''
 OBJEXT='o'
 PACKAGE_BUGREPORT=''
 PACKAGE_NAME=''
@@ -1889,26 +2638,26 @@
 PREFIX='/usr/local'
 RANLIB='ranlib'
 RPATH='-Wl,-rpath,$(1)'
 RPATH_EXTRA=''
 SHELL='/bin/bash'
 SOREV='so.2'
-TESTLIBS=''
+TEST_LD_MODE=''
 XSLROOT='/usr/share/xml/docbook/stylesheet/docbook-xsl'
 XSLTPROC='/opt/anaconda2/bin/xsltproc'
 a='a'
 abi='elf'
-abs_objroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/'
-abs_srcroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/'
+abs_objroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/'
+abs_srcroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/'
 ac_ct_CC='gcc'
 bindir='${exec_prefix}/bin'
-build='x86_64-unknown-linux-gnu'
+build='x86_64-pc-linux-gnu'
 build_alias=''
 build_cpu='x86_64'
 build_os='linux-gnu'
-build_vendor='unknown'
+build_vendor='pc'
 cfghdrs_in='include/jemalloc/jemalloc_defs.h.in include/jemalloc/internal/jemalloc_internal_defs.h.in include/jemalloc/internal/private_namespace.sh include/jemalloc/internal/private_unnamespace.sh include/jemalloc/internal/private_symbols.txt include/jemalloc/internal/public_namespace.sh include/jemalloc/internal/public_unnamespace.sh include/jemalloc/internal/size_classes.sh include/jemalloc/jemalloc_rename.sh include/jemalloc/jemalloc_mangle.sh include/jemalloc/jemalloc.sh test/include/test/jemalloc_test_defs.h.in'
 cfghdrs_out='include/jemalloc/jemalloc_defs.h include/jemalloc/jemalloc.h include/jemalloc/internal/private_namespace.h include/jemalloc/internal/private_unnamespace.h include/jemalloc/internal/public_symbols.txt include/jemalloc/internal/public_namespace.h include/jemalloc/internal/public_unnamespace.h include/jemalloc/internal/size_classes.h include/jemalloc/jemalloc_protos_jet.h include/jemalloc/jemalloc_rename.h include/jemalloc/jemalloc_mangle.h include/jemalloc/jemalloc_mangle_jet.h include/jemalloc/internal/jemalloc_internal_defs.h test/include/test/jemalloc_test_defs.h'
 cfgoutputs_in='Makefile.in jemalloc.pc.in doc/html.xsl.in doc/manpages.xsl.in doc/jemalloc.xml.in include/jemalloc/jemalloc_macros.h.in include/jemalloc/jemalloc_protos.h.in include/jemalloc/jemalloc_typedefs.h.in include/jemalloc/internal/jemalloc_internal.h.in test/test.sh.in test/include/test/jemalloc_test.h.in'
 cfgoutputs_out='Makefile jemalloc.pc doc/html.xsl doc/manpages.xsl doc/jemalloc.xml include/jemalloc/jemalloc_macros.h include/jemalloc/jemalloc_protos.h include/jemalloc/jemalloc_typedefs.h include/jemalloc/internal/jemalloc_internal.h test/test.sh test/include/test/jemalloc_test.h'
 datadir='${datarootdir}'
 datarootdir='${prefix}/share'
@@ -1928,44 +2677,46 @@
 enable_utrace='0'
 enable_valgrind='0'
 enable_xmalloc='0'
 enable_zone_allocator=''
 exe=''
 exec_prefix='/usr/local'
-host='x86_64-unknown-linux-gnu'
+host='x86_64-pc-linux-gnu'
 host_alias=''
 host_cpu='x86_64'
 host_os='linux-gnu'
-host_vendor='unknown'
+host_vendor='pc'
 htmldir='${docdir}'
 importlib='so'
 includedir='${prefix}/include'
 infodir='${datarootdir}/info'
 install_suffix=''
 je_='je_'
-jemalloc_version='4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c'
-jemalloc_version_bugfix='3'
-jemalloc_version_gid='e9192eacf8935e29fc62fddc2701f7942b1cc02c'
+jemalloc_version='4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc'
+jemalloc_version_bugfix='0'
+jemalloc_version_gid='f1f76357313e7dcad7262f17a48ff0a2e005fcdc'
 jemalloc_version_major='4'
-jemalloc_version_minor='0'
+jemalloc_version_minor='4'
 jemalloc_version_nrev='0'
 libdir='${exec_prefix}/lib'
 libexecdir='${exec_prefix}/libexec'
 libprefix='lib'
+link_whole_archive='0'
 localedir='${datarootdir}/locale'
 localstatedir='${prefix}/var'
 mandir='${datarootdir}/man'
 o='o'
 objroot=''
 oldincludedir='/usr/include'
 pdfdir='${docdir}'
 prefix='/usr/local'
 private_namespace='je_'
 program_transform_name='s,x,x,'
 psdir='${docdir}'
 rev='2'
+runstatedir='${localstatedir}/run'
 sbindir='${exec_prefix}/sbin'
 sharedstatedir='${prefix}/com'
 so='so'
 srcroot=''
 sysconfdir='${prefix}/etc'
 target_alias=''
@@ -1994,17 +2745,19 @@
 #define SIZEOF_VOID_P 8
 #define LG_SIZEOF_PTR 3
 #define SIZEOF_INT 4
 #define LG_SIZEOF_INT 2
 #define SIZEOF_LONG 8
 #define LG_SIZEOF_LONG 3
+#define SIZEOF_LONG_LONG 8
+#define LG_SIZEOF_LONG_LONG 3
 #define SIZEOF_INTMAX_T 8
 #define LG_SIZEOF_INTMAX_T 3
 #define CPU_SPINWAIT __asm__ volatile("pause")
 #define JEMALLOC_HAS_ALLOCA_H 1
-#define JEMALLOC_PURGE_MADVISE_DONTNEED  
+#define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  
 #define JEMALLOC_THREADED_INIT  
 #define JEMALLOC_USE_CXX_THROW  
 #define HAVE_MALLOC_H 1
 #define JEMALLOC_USABLE_SIZE_CONST 
 #define JEMALLOC_HAVE_ATTR  
 #define JEMALLOC_TLS_MODEL __attribute__((tls_model("initial-exec")))
@@ -2013,28 +2766,37 @@
 #define JEMALLOC_HAVE_ATTR_FORMAT_PRINTF  
 #define JEMALLOC_OVERRIDE_MEMALIGN  
 #define JEMALLOC_OVERRIDE_VALLOC  
 #define JEMALLOC_PREFIX "je_"
 #define JEMALLOC_CPREFIX "JE_"
 #define JEMALLOC_PRIVATE_NAMESPACE je_
+#define JEMALLOC_CONFIG_MALLOC_CONF ""
 #define JEMALLOC_CC_SILENCE  
 #define JEMALLOC_STATS  
 #define JEMALLOC_TCACHE  
 #define JEMALLOC_MAPS_COALESCE  
 #define JEMALLOC_DSS  
 #define JEMALLOC_FILL  
 #define JEMALLOC_CACHE_OBLIVIOUS  
+#define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+#define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 #define LG_TINY_MIN 3
 #define LG_QUANTUM 3
 #define LG_PAGE 12
 #define HAVE_PTHREAD_H 1
+#define JEMALLOC_HAVE_PTHREAD_ATFORK  
+#define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+#define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+#define JEMALLOC_USE_SYSCALL  
 #define JEMALLOC_HAVE_SECURE_GETENV  
 #define JEMALLOC_TLS
 #define JEMALLOC_HAVE_MADVISE  
+#define JEMALLOC_PURGE_MADVISE_DONTNEED  
+#define JEMALLOC_THP  
 #define JEMALLOC_HAVE_BUILTIN_CLZ  
 #define JEMALLOC_GLIBC_MALLOC_HOOK  
 #define JEMALLOC_GLIBC_MEMALIGN_HOOK  
 #define JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP  
 #define HAVE__BOOL 1
 #define HAVE_STDBOOL_H 1
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/config.status /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/config.status
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/config.status	2017-09-27 23:00:17.334936203 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/config.status	2017-09-27 23:01:52.318932722 +0800
@@ -434,13 +434,13 @@
   with options \"$ac_cs_config\"
 
 Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
-ac_pwd='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc'
+ac_pwd='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc'
 srcdir='.'
 INSTALL='/usr/bin/install -c'
 test -n "$AWK" || AWK=awk
 # The default lists apply if the user does not specify any file.
 ac_need_defaults=:
 while test $# != 0
@@ -693,19 +693,18 @@
 "alloc/internal/private_unnamespace.sh include/jemalloc/internal/private_symbols.txt include/jemalloc/internal/public_namespace.sh include/jemalloc/i"\
 "nternal/public_unnamespace.sh include/jemalloc/internal/size_classes.sh include/jemalloc/jemalloc_rename.sh include/jemalloc/jemalloc_mangle.sh incl"\
 "ude/jemalloc/jemalloc.sh test/include/test/jemalloc_test_defs.h.in"
 S["enable_zone_allocator"]=""
 S["enable_tls"]="1"
 S["enable_lazy_lock"]="0"
-S["TESTLIBS"]=""
-S["jemalloc_version_gid"]="e9192eacf8935e29fc62fddc2701f7942b1cc02c"
+S["jemalloc_version_gid"]="f1f76357313e7dcad7262f17a48ff0a2e005fcdc"
 S["jemalloc_version_nrev"]="0"
-S["jemalloc_version_bugfix"]="3"
-S["jemalloc_version_minor"]="0"
+S["jemalloc_version_bugfix"]="0"
+S["jemalloc_version_minor"]="4"
 S["jemalloc_version_major"]="4"
-S["jemalloc_version"]="4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c"
+S["jemalloc_version"]="4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc"
 S["enable_cache_oblivious"]="1"
 S["enable_xmalloc"]="0"
 S["enable_valgrind"]="0"
 S["enable_utrace"]="0"
 S["enable_fill"]="1"
 S["enable_munmap"]="0"
@@ -723,43 +722,47 @@
 S["RANLIB"]="ranlib"
 S["INSTALL_DATA"]="${INSTALL} -m 644"
 S["INSTALL_SCRIPT"]="${INSTALL}"
 S["INSTALL_PROGRAM"]="${INSTALL}"
 S["enable_autogen"]="0"
 S["RPATH_EXTRA"]=""
+S["LM"]="-lm"
 S["CC_MM"]="1"
 S["AROUT"]=" $@"
 S["ARFLAGS"]="crus"
 S["MKLIB"]=""
+S["TEST_LD_MODE"]=""
 S["LDTARGET"]="-o $@"
 S["CTARGET"]="-o $@"
 S["PIC_CFLAGS"]="-fPIC -DPIC"
 S["SOREV"]="so.2"
 S["EXTRA_LDFLAGS"]=""
 S["DSO_LDFLAGS"]="-shared -Wl,-soname,$(@F)"
+S["link_whole_archive"]="0"
 S["libprefix"]="lib"
 S["exe"]=""
 S["a"]="a"
 S["o"]="o"
 S["importlib"]="so"
 S["so"]="so"
 S["LD_PRELOAD_VAR"]="LD_PRELOAD"
 S["RPATH"]="-Wl,-rpath,$(1)"
 S["abi"]="elf"
 S["AR"]="ar"
 S["host_os"]="linux-gnu"
-S["host_vendor"]="unknown"
+S["host_vendor"]="pc"
 S["host_cpu"]="x86_64"
-S["host"]="x86_64-unknown-linux-gnu"
+S["host"]="x86_64-pc-linux-gnu"
 S["build_os"]="linux-gnu"
-S["build_vendor"]="unknown"
+S["build_vendor"]="pc"
 S["build_cpu"]="x86_64"
-S["build"]="x86_64-unknown-linux-gnu"
+S["build"]="x86_64-pc-linux-gnu"
 S["EGREP"]="/bin/grep -E"
 S["GREP"]="/bin/grep"
 S["CPP"]="gcc -E"
+S["EXTRA_CFLAGS"]=""
 S["OBJEXT"]="o"
 S["EXEEXT"]=""
 S["ac_ct_CC"]="gcc"
 S["CPPFLAGS"]=" -D_GNU_SOURCE -D_REENTRANT"
 S["LDFLAGS"]=""
 S["CFLAGS"]="-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden"
@@ -769,22 +772,22 @@
 S["MANDIR"]="/usr/local/share/man"
 S["DATADIR"]="/usr/local/share"
 S["LIBDIR"]="/usr/local/lib"
 S["INCLUDEDIR"]="/usr/local/include"
 S["BINDIR"]="/usr/local/bin"
 S["PREFIX"]="/usr/local"
-S["abs_objroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/"
+S["abs_objroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/"
 S["objroot"]=""
-S["abs_srcroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/"
+S["abs_srcroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/"
 S["srcroot"]=""
 S["rev"]="2"
 S["CONFIG"]="--with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence 'CFLAGS=-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops ' LDFLAGS="
 S["target_alias"]=""
 S["host_alias"]=""
 S["build_alias"]=""
-S["LIBS"]=" -lpthread"
+S["LIBS"]="-lm  -lpthread"
 S["ECHO_T"]=""
 S["ECHO_N"]="-n"
 S["ECHO_C"]=""
 S["DEFS"]="-DHAVE_CONFIG_H"
 S["mandir"]="${datarootdir}/man"
 S["localedir"]="${datarootdir}/locale"
@@ -794,12 +797,13 @@
 S["dvidir"]="${docdir}"
 S["htmldir"]="${docdir}"
 S["infodir"]="${datarootdir}/info"
 S["docdir"]="${datarootdir}/doc/${PACKAGE}"
 S["oldincludedir"]="/usr/include"
 S["includedir"]="${prefix}/include"
+S["runstatedir"]="${localstatedir}/run"
 S["localstatedir"]="${prefix}/var"
 S["sharedstatedir"]="${prefix}/com"
 S["sysconfdir"]="${prefix}/etc"
 S["datadir"]="${datarootdir}"
 S["datarootdir"]="${prefix}/share"
 S["libexecdir"]="${exec_prefix}/libexec"
@@ -876,17 +880,19 @@
 D["SIZEOF_VOID_P"]=" 8"
 D["LG_SIZEOF_PTR"]=" 3"
 D["SIZEOF_INT"]=" 4"
 D["LG_SIZEOF_INT"]=" 2"
 D["SIZEOF_LONG"]=" 8"
 D["LG_SIZEOF_LONG"]=" 3"
+D["SIZEOF_LONG_LONG"]=" 8"
+D["LG_SIZEOF_LONG_LONG"]=" 3"
 D["SIZEOF_INTMAX_T"]=" 8"
 D["LG_SIZEOF_INTMAX_T"]=" 3"
 D["CPU_SPINWAIT"]=" __asm__ volatile(\"pause\")"
 D["JEMALLOC_HAS_ALLOCA_H"]=" 1"
-D["JEMALLOC_PURGE_MADVISE_DONTNEED"]=" "
+D["JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY"]=" "
 D["JEMALLOC_THREADED_INIT"]=" "
 D["JEMALLOC_USE_CXX_THROW"]=" "
 D["HAVE_MALLOC_H"]=" 1"
 D["JEMALLOC_USABLE_SIZE_CONST"]=" "
 D["JEMALLOC_HAVE_ATTR"]=" "
 D["JEMALLOC_TLS_MODEL"]=" __attribute__((tls_model(\"initial-exec\")))"
@@ -895,28 +901,37 @@
 D["JEMALLOC_HAVE_ATTR_FORMAT_PRINTF"]=" "
 D["JEMALLOC_OVERRIDE_MEMALIGN"]=" "
 D["JEMALLOC_OVERRIDE_VALLOC"]=" "
 D["JEMALLOC_PREFIX"]=" \"je_\""
 D["JEMALLOC_CPREFIX"]=" \"JE_\""
 D["JEMALLOC_PRIVATE_NAMESPACE"]=" je_"
+D["JEMALLOC_CONFIG_MALLOC_CONF"]=" \"\""
 D["JEMALLOC_CC_SILENCE"]=" "
 D["JEMALLOC_STATS"]=" "
 D["JEMALLOC_TCACHE"]=" "
 D["JEMALLOC_MAPS_COALESCE"]=" "
 D["JEMALLOC_DSS"]=" "
 D["JEMALLOC_FILL"]=" "
 D["JEMALLOC_CACHE_OBLIVIOUS"]=" "
+D["JEMALLOC_INTERNAL_UNREACHABLE"]=" __builtin_unreachable"
+D["JEMALLOC_INTERNAL_FFSLL"]=" __builtin_ffsll"
 D["JEMALLOC_INTERNAL_FFSL"]=" __builtin_ffsl"
 D["JEMALLOC_INTERNAL_FFS"]=" __builtin_ffs"
 D["LG_TINY_MIN"]=" 3"
 D["LG_QUANTUM"]=" 3"
 D["LG_PAGE"]=" 12"
 D["HAVE_PTHREAD_H"]=" 1"
+D["JEMALLOC_HAVE_PTHREAD_ATFORK"]=" "
+D["JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE"]=" 1"
+D["JEMALLOC_HAVE_CLOCK_MONOTONIC"]=" 1"
+D["JEMALLOC_USE_SYSCALL"]=" "
 D["JEMALLOC_HAVE_SECURE_GETENV"]=" "
 D["JEMALLOC_TLS"]=" "
 D["JEMALLOC_HAVE_MADVISE"]=" "
+D["JEMALLOC_PURGE_MADVISE_DONTNEED"]=" "
+D["JEMALLOC_THP"]=" "
 D["JEMALLOC_HAVE_BUILTIN_CLZ"]=" "
 D["JEMALLOC_GLIBC_MALLOC_HOOK"]=" "
 D["JEMALLOC_GLIBC_MEMALIGN_HOOK"]=" "
 D["JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP"]=" "
 D["HAVE__BOOL"]=" 1"
 D["HAVE_STDBOOL_H"]=" 1"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc: config.sub
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/configure	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/configure	2017-01-31 23:32:23.000000000 +0800
@@ -625,13 +625,12 @@
 cfgoutputs_in
 cfghdrs_out
 cfghdrs_in
 enable_zone_allocator
 enable_tls
 enable_lazy_lock
-TESTLIBS
 jemalloc_version_gid
 jemalloc_version_nrev
 jemalloc_version_bugfix
 jemalloc_version_minor
 jemalloc_version_major
 jemalloc_version
@@ -655,22 +654,25 @@
 RANLIB
 INSTALL_DATA
 INSTALL_SCRIPT
 INSTALL_PROGRAM
 enable_autogen
 RPATH_EXTRA
+LM
 CC_MM
 AROUT
 ARFLAGS
 MKLIB
+TEST_LD_MODE
 LDTARGET
 CTARGET
 PIC_CFLAGS
 SOREV
 EXTRA_LDFLAGS
 DSO_LDFLAGS
+link_whole_archive
 libprefix
 exe
 a
 o
 importlib
 so
@@ -686,12 +688,13 @@
 build_vendor
 build_cpu
 build
 EGREP
 GREP
 CPP
+EXTRA_CFLAGS
 OBJEXT
 EXEEXT
 ac_ct_CC
 CPPFLAGS
 LDFLAGS
 CFLAGS
@@ -726,12 +729,13 @@
 dvidir
 htmldir
 infodir
 docdir
 oldincludedir
 includedir
+runstatedir
 localstatedir
 sharedstatedir
 sysconfdir
 datadir
 datarootdir
 libexecdir
@@ -757,12 +761,13 @@
 enable_code_coverage
 with_mangling
 with_jemalloc_prefix
 with_export
 with_private_namespace
 with_install_suffix
+with_malloc_conf
 enable_cc_silence
 enable_debug
 enable_ivsalloc
 enable_stats
 enable_prof
 enable_prof_libunwind
@@ -778,12 +783,14 @@
 enable_cache_oblivious
 with_lg_tiny_min
 with_lg_quantum
 with_lg_page
 with_lg_page_sizes
 with_lg_size_class_group
+with_version
+enable_syscall
 enable_lazy_lock
 enable_tls
 enable_zone_allocator
 '
       ac_precious_vars='build_alias
 host_alias
@@ -829,12 +836,13 @@
 libexecdir='${exec_prefix}/libexec'
 datarootdir='${prefix}/share'
 datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
+runstatedir='${localstatedir}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE}'
 infodir='${datarootdir}/info'
 htmldir='${docdir}'
 dvidir='${docdir}'
@@ -1081,12 +1089,21 @@
     psdir=$ac_optarg ;;
 
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
 
+  -runstatedir | --runstatedir | --runstatedi | --runstated \
+  | --runstate | --runstat | --runsta | --runst | --runs \
+  | --run | --ru | --r)
+    ac_prev=runstatedir ;;
+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
+  | --run=* | --ru=* | --r=*)
+    runstatedir=$ac_optarg ;;
+
   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
     ac_prev=sbindir ;;
   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
   | --sbi=* | --sb=*)
     sbindir=$ac_optarg ;;
 
@@ -1218,13 +1235,13 @@
 fi
 
 # Check all directory arguments for consistency.
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
+		libdir localedir mandir runstatedir
 do
   eval ac_val=\$$ac_var
   # Remove trailing slashes.
   case $ac_val in
     */ )
       ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
@@ -1371,12 +1388,13 @@
   --bindir=DIR            user executables [EPREFIX/bin]
   --sbindir=DIR           system admin executables [EPREFIX/sbin]
   --libexecdir=DIR        program executables [EPREFIX/libexec]
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
   --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
   --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
   --infodir=DIR           info documentation [DATAROOTDIR/info]
@@ -1422,12 +1440,13 @@
   --enable-utrace         Enable utrace(2)-based tracing
   --disable-valgrind      Disable support for Valgrind
   --enable-xmalloc        Support xmalloc option
   --disable-cache-oblivious
                           Disable support for cache-oblivious allocation
                           alignment
+  --disable-syscall       Disable use of syscall(2)
   --enable-lazy-lock      Enable lazy locking (only lock when multi-threaded)
   --disable-tls           Disable thread-local storage (__thread keyword)
   --disable-zone-allocator
                           Disable zone allocator for Darwin
 
 Optional Packages:
@@ -1440,12 +1459,14 @@
                           Prefix to prepend to all public APIs
   --without-export        disable exporting jemalloc public APIs
   --with-private-namespace=<prefix>
                           Prefix to prepend to all library-private APIs
   --with-install-suffix=<suffix>
                           Suffix to append to all installed files
+  --with-malloc-conf=<malloc_conf>
+                          config.malloc_conf options string
   --with-static-libunwind=<libunwind.a>
                           Path to static libunwind library; use rather than
                           dynamically linking
   --with-lg-tiny-min=<lg-tiny-min>
                           Base 2 log of minimum tiny size class to support
   --with-lg-quantum=<lg-quantum>
@@ -1453,12 +1474,14 @@
   --with-lg-page=<lg-page>
                           Base 2 log of system page size
   --with-lg-page-sizes=<lg-page-sizes>
                           Base 2 logs of system page sizes to support
   --with-lg-size-class-group=<lg-size-class-group>
                           Base 2 log of size classes per doubling
+  --with-version=<major>.<minor>.<bugfix>-<nrev>-g<gid>
+                          Version string
 
 Some influential environment variables:
   CC          C compiler command
   CFLAGS      C compiler flags
   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
               nonstandard directory <lib dir>
@@ -2481,12 +2504,42 @@
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
+ac_aux_dir=
+for ac_dir in build-aux "$srcdir"/build-aux; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error $? "cannot find install-sh, install.sh, or shtool in build-aux \"$srcdir\"/build-aux" "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+
 
 
 
 
 
 
@@ -3420,16 +3474,131 @@
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_msvc" >&5
 $as_echo "$je_cv_msvc" >&6; }
 fi
 
+je_cv_cray_prgenv_wrapper=""
+if test "x${PE_ENV}" != "x" ; then
+  case "${CC}" in
+    CC|cc)
+	je_cv_cray_prgenv_wrapper="yes"
+	;;
+    *)
+       ;;
+  esac
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler is cray" >&5
+$as_echo_n "checking whether compiler is cray... " >&6; }
+if ${je_cv_cray+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+#ifndef _CRAYC
+  int fail-1;
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cray=yes
+else
+  je_cv_cray=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_cray" >&5
+$as_echo "$je_cv_cray" >&6; }
+
+if test "x${je_cv_cray}" = "xyes" ; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether cray compiler version is 8.4" >&5
+$as_echo_n "checking whether cray compiler version is 8.4... " >&6; }
+if ${je_cv_cray_84+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+#if !(_RELEASE_MAJOR == 8 && _RELEASE_MINOR == 4)
+  int fail-1;
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cray_84=yes
+else
+  je_cv_cray_84=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_cray_84" >&5
+$as_echo "$je_cv_cray_84" >&6; }
+fi
+
 if test "x$CFLAGS" = "x" ; then
   no_CFLAGS="yes"
   if test "x$GCC" = "xyes" ; then
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -std=gnu11" >&5
+$as_echo_n "checking whether compiler supports -std=gnu11... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-std=gnu11"
+else
+  CFLAGS="${CFLAGS} -std=gnu11"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-std=gnu11
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+    if test "x$je_cv_cflags_appended" = "x-std=gnu11" ; then
+      cat >>confdefs.h <<_ACEOF
+#define JEMALLOC_HAS_RESTRICT 1
+_ACEOF
+
+    else
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -std=gnu99" >&5
 $as_echo_n "checking whether compiler supports -std=gnu99... " >&6; }
 TCFLAGS="${CFLAGS}"
 if test "x${CFLAGS}" = "x" ; then
   CFLAGS="-std=gnu99"
 else
@@ -3459,17 +3628,18 @@
 $as_echo "no" >&6; }
               CFLAGS="${TCFLAGS}"
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
-    if test "x$je_cv_cflags_appended" = "x-std=gnu99" ; then
-      cat >>confdefs.h <<_ACEOF
+      if test "x$je_cv_cflags_appended" = "x-std=gnu99" ; then
+        cat >>confdefs.h <<_ACEOF
 #define JEMALLOC_HAS_RESTRICT 1
 _ACEOF
 
+      fi
     fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -Wall" >&5
 $as_echo_n "checking whether compiler supports -Wall... " >&6; }
 TCFLAGS="${CFLAGS}"
 if test "x${CFLAGS}" = "x" ; then
@@ -3538,12 +3708,84 @@
               CFLAGS="${TCFLAGS}"
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -Wshorten-64-to-32" >&5
+$as_echo_n "checking whether compiler supports -Wshorten-64-to-32... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-Wshorten-64-to-32"
+else
+  CFLAGS="${CFLAGS} -Wshorten-64-to-32"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-Wshorten-64-to-32
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -Wsign-compare" >&5
+$as_echo_n "checking whether compiler supports -Wsign-compare... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-Wsign-compare"
+else
+  CFLAGS="${CFLAGS} -Wsign-compare"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-Wsign-compare
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -pipe" >&5
 $as_echo_n "checking whether compiler supports -pipe... " >&6; }
 TCFLAGS="${CFLAGS}"
 if test "x${CFLAGS}" = "x" ; then
   CFLAGS="-pipe"
 else
@@ -3757,22 +3999,22 @@
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
     CPPFLAGS="$CPPFLAGS -I${srcdir}/include/msvc_compat"
   fi
-fi
-if test "x$EXTRA_CFLAGS" != "x" ; then
+  if test "x$je_cv_cray" = "xyes" ; then
+        if test "x$je_cv_cray_84" = "xyes" ; then
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports $EXTRA_CFLAGS" >&5
-$as_echo_n "checking whether compiler supports $EXTRA_CFLAGS... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -hipa2" >&5
+$as_echo_n "checking whether compiler supports -hipa2... " >&6; }
 TCFLAGS="${CFLAGS}"
 if test "x${CFLAGS}" = "x" ; then
-  CFLAGS="$EXTRA_CFLAGS"
+  CFLAGS="-hipa2"
 else
-  CFLAGS="${CFLAGS} $EXTRA_CFLAGS"
+  CFLAGS="${CFLAGS} -hipa2"
 fi
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 
 int
@@ -3783,99 +4025,212 @@
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
-  je_cv_cflags_appended=$EXTRA_CFLAGS
+  je_cv_cflags_appended=-hipa2
               { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
 else
   je_cv_cflags_appended=
               { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
               CFLAGS="${TCFLAGS}"
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
-fi
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if ${ac_cv_prog_CPP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -hnognu" >&5
+$as_echo_n "checking whether compiler supports -hnognu... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-hnognu"
 else
-  # Broken: fails on valid input.
-continue
+  CFLAGS="${CFLAGS} -hnognu"
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
 
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
 
-    done
-    ac_cv_prog_CPP=$CPP
+int
+main ()
+{
 
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-hnognu
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+    fi
+    if test "x$enable_cc_silence" != "xno" ; then
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -hnomessage=128" >&5
+$as_echo_n "checking whether compiler supports -hnomessage=128... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-hnomessage=128"
+else
+  CFLAGS="${CFLAGS} -hnomessage=128"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-hnomessage=128
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -hnomessage=1357" >&5
+$as_echo_n "checking whether compiler supports -hnomessage=1357... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-hnomessage=1357"
+else
+  CFLAGS="${CFLAGS} -hnomessage=1357"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-hnomessage=1357
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+    fi
+  fi
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if ${ac_cv_prog_CPP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
 $as_echo "$CPP" >&6; }
 ac_preproc_ok=false
 for ac_c_preproc_warn_flag in '' yes
 do
@@ -4428,13 +4783,18 @@
 fi
 
 if test "x${je_cv_msvc}" = "xyes" -a "x${ac_cv_header_inttypes_h}" = "xno"; then
   CPPFLAGS="$CPPFLAGS -I${srcdir}/include/msvc_compat/C99"
 fi
 
-# The cast to long int works around a bug in the HP C Compiler
+if test "x${je_cv_msvc}" = "xyes" ; then
+  LG_SIZEOF_PTR=LG_SIZEOF_PTR_WIN
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: Using a predefined value for sizeof(void *): 4 for 32-bit, 8 for 64-bit" >&5
+$as_echo "Using a predefined value for sizeof(void *): 4 for 32-bit, 8 for 64-bit" >&6; }
+else
+  # The cast to long int works around a bug in the HP C Compiler
 # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
 # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
 # This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of void *" >&5
 $as_echo_n "checking size of void *... " >&6; }
 if ${ac_cv_sizeof_void_p+:} false; then :
@@ -4461,18 +4821,19 @@
 
 cat >>confdefs.h <<_ACEOF
 #define SIZEOF_VOID_P $ac_cv_sizeof_void_p
 _ACEOF
 
 
-if test "x${ac_cv_sizeof_void_p}" = "x8" ; then
-  LG_SIZEOF_PTR=3
-elif test "x${ac_cv_sizeof_void_p}" = "x4" ; then
-  LG_SIZEOF_PTR=2
-else
-  as_fn_error $? "Unsupported pointer size: ${ac_cv_sizeof_void_p}" "$LINENO" 5
+  if test "x${ac_cv_sizeof_void_p}" = "x8" ; then
+    LG_SIZEOF_PTR=3
+  elif test "x${ac_cv_sizeof_void_p}" = "x4" ; then
+    LG_SIZEOF_PTR=2
+  else
+    as_fn_error $? "Unsupported pointer size: ${ac_cv_sizeof_void_p}" "$LINENO" 5
+  fi
 fi
 cat >>confdefs.h <<_ACEOF
 #define LG_SIZEOF_PTR $LG_SIZEOF_PTR
 _ACEOF
 
 
@@ -4567,12 +4928,57 @@
 
 
 # The cast to long int works around a bug in the HP C Compiler
 # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
 # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
 # This bug is HP SR number 8606223364.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking size of long long" >&5
+$as_echo_n "checking size of long long... " >&6; }
+if ${ac_cv_sizeof_long_long+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long long))" "ac_cv_sizeof_long_long"        "$ac_includes_default"; then :
+
+else
+  if test "$ac_cv_type_long_long" = yes; then
+     { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot compute sizeof (long long)
+See \`config.log' for more details" "$LINENO" 5; }
+   else
+     ac_cv_sizeof_long_long=0
+   fi
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long_long" >&5
+$as_echo "$ac_cv_sizeof_long_long" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long
+_ACEOF
+
+
+if test "x${ac_cv_sizeof_long_long}" = "x8" ; then
+  LG_SIZEOF_LONG_LONG=3
+elif test "x${ac_cv_sizeof_long_long}" = "x4" ; then
+  LG_SIZEOF_LONG_LONG=2
+else
+  as_fn_error $? "Unsupported long long size: ${ac_cv_sizeof_long_long}" "$LINENO" 5
+fi
+cat >>confdefs.h <<_ACEOF
+#define LG_SIZEOF_LONG_LONG $LG_SIZEOF_LONG_LONG
+_ACEOF
+
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking size of intmax_t" >&5
 $as_echo_n "checking size of intmax_t... " >&6; }
 if ${ac_cv_sizeof_intmax_t+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (intmax_t))" "ac_cv_sizeof_intmax_t"        "$ac_includes_default"; then :
@@ -4610,41 +5016,12 @@
 fi
 cat >>confdefs.h <<_ACEOF
 #define LG_SIZEOF_INTMAX_T $LG_SIZEOF_INTMAX_T
 _ACEOF
 
 
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  as_fn_error $? "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
-fi
-
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
-
-
 # Make sure we can run config.sub.
 $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
   as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
 $as_echo_n "checking build system type... " >&6; }
@@ -4713,13 +5090,51 @@
 case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
 CPU_SPINWAIT=""
 case "${host_cpu}" in
   i686|x86_64)
-	if ${je_cv_pause+:} false; then :
+	if test "x${je_cv_msvc}" = "xyes" ; then
+	    if ${je_cv_pause_msvc+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether pause instruction MSVC is compilable" >&5
+$as_echo_n "checking whether pause instruction MSVC is compilable... " >&6; }
+if ${je_cv_pause_msvc+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+_mm_pause(); return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_pause_msvc=yes
+else
+  je_cv_pause_msvc=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_pause_msvc" >&5
+$as_echo "$je_cv_pause_msvc" >&6; }
+
+fi
+
+	    if test "x${je_cv_pause_msvc}" = "xyes" ; then
+		CPU_SPINWAIT='_mm_pause()'
+	    fi
+	else
+	    if ${je_cv_pause+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether pause instruction is compilable" >&5
 $as_echo_n "checking whether pause instruction is compilable... " >&6; }
 if ${je_cv_pause+:} false; then :
@@ -4746,14 +5161,15 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_pause" >&5
 $as_echo "$je_cv_pause" >&6; }
 
 fi
 
-	if test "x${je_cv_pause}" = "xyes" ; then
-	    CPU_SPINWAIT='__asm__ volatile("pause")'
+	    if test "x${je_cv_pause}" = "xyes" ; then
+		CPU_SPINWAIT='__asm__ volatile("pause")'
+	    fi
 	fi
 	;;
   powerpc)
 	cat >>confdefs.h <<_ACEOF
 #define HAVE_ALTIVEC
 _ACEOF
@@ -4771,23 +5187,33 @@
 so="so"
 importlib="${so}"
 o="$ac_objext"
 a="a"
 exe="$ac_exeext"
 libprefix="lib"
+link_whole_archive="0"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
 SOREV="${so}.${rev}"
 PIC_CFLAGS='-fPIC -DPIC'
 CTARGET='-o $@'
 LDTARGET='-o $@'
+TEST_LD_MODE=
 EXTRA_LDFLAGS=
 ARFLAGS='crus'
 AROUT=' $@'
 CC_MM=1
 
+if test "x$je_cv_cray_prgenv_wrapper" = "xyes" ; then
+  TEST_LD_MODE='-dynamic'
+fi
+
+if test "x${je_cv_cray}" = "xyes" ; then
+  CC_MM=
+fi
+
 
 
 
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ar; ac_word=$2
@@ -4878,66 +5304,67 @@
   fi
 else
   AR="$ac_cv_prog_AR"
 fi
 
 
+CFLAGS="$CFLAGS"
 default_munmap="1"
 maps_coalesce="1"
 case "${host}" in
   *-*-darwin* | *-*-ios*)
-	CFLAGS="$CFLAGS"
 	abi="macho"
-	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
-
 	RPATH=""
 	LD_PRELOAD_VAR="DYLD_INSERT_LIBRARIES"
 	so="dylib"
 	importlib="${so}"
 	force_tls="0"
 	DSO_LDFLAGS='-shared -Wl,-install_name,$(LIBDIR)/$(@F)'
 	SOREV="${rev}.${so}"
 	sbrk_deprecated="1"
 	;;
   *-*-freebsd*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
+	$as_echo "#define JEMALLOC_SYSCTL_VM_OVERCOMMIT  " >>confdefs.h
 
 	force_lazy_lock="1"
 	;;
   *-*-dragonfly*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
-
 	;;
   *-*-openbsd*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
-
 	force_tls="0"
 	;;
   *-*-bitrig*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
-
 	;;
-  *-*-linux*)
-	CFLAGS="$CFLAGS"
-	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
+  *-*-linux-android)
+		CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
 	abi="elf"
 	$as_echo "#define JEMALLOC_HAS_ALLOCA_H 1" >>confdefs.h
 
-	$as_echo "#define JEMALLOC_PURGE_MADVISE_DONTNEED  " >>confdefs.h
+	$as_echo "#define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  " >>confdefs.h
 
 	$as_echo "#define JEMALLOC_THREADED_INIT  " >>confdefs.h
 
-	$as_echo "#define JEMALLOC_USE_CXX_THROW  " >>confdefs.h
+	$as_echo "#define JEMALLOC_C11ATOMICS 1" >>confdefs.h
+
+	force_tls="0"
+	default_munmap="0"
+	;;
+  *-*-linux* | *-*-kfreebsd*)
+		CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
+	abi="elf"
+	$as_echo "#define JEMALLOC_HAS_ALLOCA_H 1" >>confdefs.h
+
+	$as_echo "#define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY  " >>confdefs.h
+
+	$as_echo "#define JEMALLOC_THREADED_INIT  " >>confdefs.h
+
+	$as_echo "#define JEMALLOC_USE_CXX_THROW  " >>confdefs.h
 
 	default_munmap="0"
 	;;
   *-*-netbsd*)
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking ABI" >&5
 $as_echo_n "checking ABI... " >&6; }
@@ -4955,27 +5382,22 @@
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
-  CFLAGS="$CFLAGS"; abi="elf"
+  abi="elf"
 else
   abi="aout"
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $abi" >&5
 $as_echo "$abi" >&6; }
-	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
-
 	;;
   *-*-solaris2*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	$as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
-
 	RPATH='-Wl,-R,$(1)'
 		CPPFLAGS="$CPPFLAGS -D_POSIX_PTHREAD_SEMANTICS"
 	LIBS="$LIBS -lposix4 -lsocket -lnsl"
 	;;
   *-ibm-aix*)
 	if "$LG_SIZEOF_PTR" = "8"; then
@@ -4985,13 +5407,12 @@
 	fi
 	abi="xcoff"
 	;;
   *-*-mingw* | *-*-cygwin*)
 	abi="pecoff"
 	force_tls="0"
-	force_lazy_lock="1"
 	maps_coalesce="0"
 	RPATH=""
 	so="dll"
 	if test "x$je_cv_msvc" = "xyes" ; then
 	  importlib="lib"
 	  DSO_LDFLAGS="-LD"
@@ -5002,12 +5423,13 @@
 	  ARFLAGS='-nologo -out:'
 	  AROUT='$@'
 	  CC_MM=
         else
 	  importlib="${so}"
 	  DSO_LDFLAGS="-shared"
+	  link_whole_archive="1"
 	fi
 	a="lib"
 	libprefix=""
 	SOREV="${so}"
 	PIC_CFLAGS=""
 	;;
@@ -5083,12 +5505,79 @@
 
 
 
 
 
 
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing log" >&5
+$as_echo_n "checking for library containing log... " >&6; }
+if ${ac_cv_search_log+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char log ();
+int
+main ()
+{
+return log ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' m; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_log=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_log+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_log+:} false; then :
+
+else
+  ac_cv_search_log=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_log" >&5
+$as_echo "$ac_cv_search_log" >&6; }
+ac_res=$ac_cv_search_log
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+else
+  as_fn_error $? "Missing math functions" "$LINENO" 5
+fi
+
+if test "x$ac_cv_search_log" != "xnone required" ; then
+  LM="$ac_cv_search_log"
+else
+  LM=
+fi
+
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether __attribute__ syntax is compilable" >&5
 $as_echo_n "checking whether __attribute__ syntax is compilable... " >&6; }
 if ${je_cv_attribute+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -5190,12 +5679,48 @@
               CFLAGS="${TCFLAGS}"
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -herror_on_warning" >&5
+$as_echo_n "checking whether compiler supports -herror_on_warning... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-herror_on_warning"
+else
+  CFLAGS="${CFLAGS} -herror_on_warning"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-herror_on_warning
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether tls_model attribute is compilable" >&5
 $as_echo_n "checking whether tls_model attribute is compilable... " >&6; }
 if ${je_cv_tls_model+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -5265,12 +5790,48 @@
               CFLAGS="${TCFLAGS}"
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -herror_on_warning" >&5
+$as_echo_n "checking whether compiler supports -herror_on_warning... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-herror_on_warning"
+else
+  CFLAGS="${CFLAGS} -herror_on_warning"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-herror_on_warning
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether alloc_size attribute is compilable" >&5
 $as_echo_n "checking whether alloc_size attribute is compilable... " >&6; }
 if ${je_cv_alloc_size+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -5335,12 +5896,48 @@
               CFLAGS="${TCFLAGS}"
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -herror_on_warning" >&5
+$as_echo_n "checking whether compiler supports -herror_on_warning... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-herror_on_warning"
+else
+  CFLAGS="${CFLAGS} -herror_on_warning"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-herror_on_warning
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether format(gnu_printf, ...) attribute is compilable" >&5
 $as_echo_n "checking whether format(gnu_printf, ...) attribute is compilable... " >&6; }
 if ${je_cv_format_gnu_printf+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -5405,12 +6002,48 @@
               CFLAGS="${TCFLAGS}"
 
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -herror_on_warning" >&5
+$as_echo_n "checking whether compiler supports -herror_on_warning... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-herror_on_warning"
+else
+  CFLAGS="${CFLAGS} -herror_on_warning"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-herror_on_warning
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether format(printf, ...) attribute is compilable" >&5
 $as_echo_n "checking whether format(printf, ...) attribute is compilable... " >&6; }
 if ${je_cv_format_printf+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -5924,12 +6557,27 @@
 
 fi
 
 install_suffix="$INSTALL_SUFFIX"
 
 
+
+# Check whether --with-malloc_conf was given.
+if test "${with_malloc_conf+set}" = set; then :
+  withval=$with_malloc_conf; JEMALLOC_CONFIG_MALLOC_CONF="$with_malloc_conf"
+else
+  JEMALLOC_CONFIG_MALLOC_CONF=""
+
+fi
+
+config_malloc_conf="$JEMALLOC_CONFIG_MALLOC_CONF"
+cat >>confdefs.h <<_ACEOF
+#define JEMALLOC_CONFIG_MALLOC_CONF "$config_malloc_conf"
+_ACEOF
+
+
 je_="je_"
 
 
 cfgoutputs_in="Makefile.in"
 cfgoutputs_in="${cfgoutputs_in} jemalloc.pc.in"
 cfgoutputs_in="${cfgoutputs_in} doc/html.xsl.in"
@@ -6492,14 +7140,14 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking configured backtracing method" >&5
 $as_echo_n "checking configured backtracing method... " >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $backtrace_method" >&5
 $as_echo "$backtrace_method" >&6; }
 if test "x$enable_prof" = "x1" ; then
-  if test "x$abi" != "xpecoff"; then
-        LIBS="$LIBS -lm"
+    if test "x$LM" != "x" ; then
+    LIBS="$LIBS $LM"
   fi
 
   $as_echo "#define JEMALLOC_PROF  " >>confdefs.h
 
 fi
 
@@ -6742,12 +7390,58 @@
   $as_echo "#define JEMALLOC_CACHE_OBLIVIOUS  " >>confdefs.h
 
 fi
 
 
 
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program using __builtin_unreachable is compilable" >&5
+$as_echo_n "checking whether a program using __builtin_unreachable is compilable... " >&6; }
+if ${je_cv_gcc_builtin_unreachable+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+void foo (void) {
+  __builtin_unreachable();
+}
+
+int
+main ()
+{
+
+	{
+		foo();
+	}
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_gcc_builtin_unreachable=yes
+else
+  je_cv_gcc_builtin_unreachable=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_gcc_builtin_unreachable" >&5
+$as_echo "$je_cv_gcc_builtin_unreachable" >&6; }
+
+if test "x${je_cv_gcc_builtin_unreachable}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable" >>confdefs.h
+
+else
+  $as_echo "#define JEMALLOC_INTERNAL_UNREACHABLE abort" >>confdefs.h
+
+fi
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program using __builtin_ffsl is compilable" >&5
 $as_echo_n "checking whether a program using __builtin_ffsl is compilable... " >&6; }
 if ${je_cv_gcc_builtin_ffsl+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -6779,12 +7473,14 @@
     conftest$ac_exeext conftest.$ac_ext
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_gcc_builtin_ffsl" >&5
 $as_echo "$je_cv_gcc_builtin_ffsl" >&6; }
 
 if test "x${je_cv_gcc_builtin_ffsl}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll" >>confdefs.h
+
   $as_echo "#define JEMALLOC_INTERNAL_FFSL __builtin_ffsl" >>confdefs.h
 
   $as_echo "#define JEMALLOC_INTERNAL_FFS __builtin_ffs" >>confdefs.h
 
 else
 
@@ -6822,12 +7518,14 @@
     conftest$ac_exeext conftest.$ac_ext
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_function_ffsl" >&5
 $as_echo "$je_cv_function_ffsl" >&6; }
 
   if test "x${je_cv_function_ffsl}" = "xyes" ; then
+    $as_echo "#define JEMALLOC_INTERNAL_FFSLL ffsll" >>confdefs.h
+
     $as_echo "#define JEMALLOC_INTERNAL_FFSL ffsl" >>confdefs.h
 
     $as_echo "#define JEMALLOC_INTERNAL_FFS ffs" >>confdefs.h
 
   else
     as_fn_error $? "Cannot build without ffsl(3) or __builtin_ffsl()" "$LINENO" 5
@@ -6910,13 +7608,13 @@
     result = JEMALLOC_INTERNAL_FFSL(result) - 1;
 
     f = fopen("conftest.out", "w");
     if (f == NULL) {
 	return 1;
     }
-    fprintf(f, "%d\n", result);
+    fprintf(f, "%d", result);
     fclose(f);
 
     return 0;
 
   ;
   return 0;
@@ -7099,44 +7796,176 @@
 else
   as_fn_error $? "libpthread is missing" "$LINENO" 5
 fi
 
 fi
 
-fi
-
-CPPFLAGS="$CPPFLAGS -D_REENTRANT"
 
-SAVED_LIBS="${LIBS}"
-LIBS=
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime" >&5
-$as_echo_n "checking for library containing clock_gettime... " >&6; }
-if ${ac_cv_search_clock_gettime+:} false; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether pthread_atfork(3) is compilable" >&5
+$as_echo_n "checking whether pthread_atfork(3) is compilable... " >&6; }
+if ${je_cv_pthread_atfork+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_func_search_save_LIBS=$LIBS
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char clock_gettime ();
+#include <pthread.h>
+
 int
 main ()
 {
-return clock_gettime ();
+
+  pthread_atfork((void *)0, (void *)0, (void *)0);
+
   ;
   return 0;
 }
 _ACEOF
-for ac_lib in '' rt; do
-  if test -z "$ac_lib"; then
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_pthread_atfork=yes
+else
+  je_cv_pthread_atfork=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_pthread_atfork" >&5
+$as_echo "$je_cv_pthread_atfork" >&6; }
+
+  if test "x${je_cv_pthread_atfork}" = "xyes" ; then
+    $as_echo "#define JEMALLOC_HAVE_PTHREAD_ATFORK  " >>confdefs.h
+
+  fi
+fi
+
+CPPFLAGS="$CPPFLAGS -D_REENTRANT"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime" >&5
+$as_echo_n "checking for library containing clock_gettime... " >&6; }
+if ${ac_cv_search_clock_gettime+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char clock_gettime ();
+int
+main ()
+{
+return clock_gettime ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' rt; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_clock_gettime=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_clock_gettime+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_clock_gettime+:} false; then :
+
+else
+  ac_cv_search_clock_gettime=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_clock_gettime" >&5
+$as_echo "$ac_cv_search_clock_gettime" >&6; }
+ac_res=$ac_cv_search_clock_gettime
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+fi
+
+
+if test "x$je_cv_cray_prgenv_wrapper" = "xyes" ; then
+  if test "$ac_cv_search_clock_gettime" != "-lrt"; then
+    SAVED_CFLAGS="${CFLAGS}"
+
+    unset ac_cv_search_clock_gettime
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -dynamic" >&5
+$as_echo_n "checking whether compiler supports -dynamic... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-dynamic"
+else
+  CFLAGS="${CFLAGS} -dynamic"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-dynamic
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime" >&5
+$as_echo_n "checking for library containing clock_gettime... " >&6; }
+if ${ac_cv_search_clock_gettime+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char clock_gettime ();
+int
+main ()
+{
+return clock_gettime ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' rt; do
+  if test -z "$ac_lib"; then
     ac_res="none required"
   else
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
   if ac_fn_c_try_link "$LINENO"; then :
@@ -7158,17 +7987,229 @@
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_clock_gettime" >&5
 $as_echo "$ac_cv_search_clock_gettime" >&6; }
 ac_res=$ac_cv_search_clock_gettime
 if test "$ac_res" != no; then :
   test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
-  TESTLIBS="${LIBS}"
+
+fi
+
+
+    CFLAGS="${SAVED_CFLAGS}"
+  fi
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether clock_gettime(CLOCK_MONOTONIC_COARSE, ...) is compilable" >&5
+$as_echo_n "checking whether clock_gettime(CLOCK_MONOTONIC_COARSE, ...) is compilable... " >&6; }
+if ${je_cv_clock_monotonic_coarse+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <time.h>
+
+int
+main ()
+{
+
+	struct timespec ts;
+
+	clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_clock_monotonic_coarse=yes
+else
+  je_cv_clock_monotonic_coarse=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_clock_monotonic_coarse" >&5
+$as_echo "$je_cv_clock_monotonic_coarse" >&6; }
+
+if test "x${je_cv_clock_monotonic_coarse}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1" >>confdefs.h
+
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether clock_gettime(CLOCK_MONOTONIC, ...) is compilable" >&5
+$as_echo_n "checking whether clock_gettime(CLOCK_MONOTONIC, ...) is compilable... " >&6; }
+if ${je_cv_clock_monotonic+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <unistd.h>
+#include <time.h>
+
+int
+main ()
+{
+
+	struct timespec ts;
+
+	clock_gettime(CLOCK_MONOTONIC, &ts);
+#if !defined(_POSIX_MONOTONIC_CLOCK) || _POSIX_MONOTONIC_CLOCK < 0
+#  error _POSIX_MONOTONIC_CLOCK missing/invalid
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_clock_monotonic=yes
+else
+  je_cv_clock_monotonic=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_clock_monotonic" >&5
+$as_echo "$je_cv_clock_monotonic" >&6; }
+
+if test "x${je_cv_clock_monotonic}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_HAVE_CLOCK_MONOTONIC 1" >>confdefs.h
+
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether mach_absolute_time() is compilable" >&5
+$as_echo_n "checking whether mach_absolute_time() is compilable... " >&6; }
+if ${je_cv_mach_absolute_time+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <mach/mach_time.h>
+
+int
+main ()
+{
+
+	mach_absolute_time();
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_mach_absolute_time=yes
+else
+  je_cv_mach_absolute_time=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_mach_absolute_time" >&5
+$as_echo "$je_cv_mach_absolute_time" >&6; }
+
+if test "x${je_cv_mach_absolute_time}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_HAVE_MACH_ABSOLUTE_TIME 1" >>confdefs.h
+
+fi
+
+# Check whether --enable-syscall was given.
+if test "${enable_syscall+set}" = set; then :
+  enableval=$enable_syscall; if test "x$enable_syscall" = "xno" ; then
+  enable_syscall="0"
+else
+  enable_syscall="1"
+fi
+
+else
+  enable_syscall="1"
+
+fi
+
+if test "x$enable_syscall" = "x1" ; then
+      SAVED_CFLAGS="${CFLAGS}"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler supports -Werror" >&5
+$as_echo_n "checking whether compiler supports -Werror... " >&6; }
+TCFLAGS="${CFLAGS}"
+if test "x${CFLAGS}" = "x" ; then
+  CFLAGS="-Werror"
+else
+  CFLAGS="${CFLAGS} -Werror"
+fi
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+
+    return 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  je_cv_cflags_appended=-Werror
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  je_cv_cflags_appended=
+              { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+              CFLAGS="${TCFLAGS}"
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether syscall(2) is compilable" >&5
+$as_echo_n "checking whether syscall(2) is compilable... " >&6; }
+if ${je_cv_syscall+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/syscall.h>
+#include <unistd.h>
+
+int
+main ()
+{
+
+	syscall(SYS_write, 2, "hello", 5);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_syscall=yes
+else
+  je_cv_syscall=no
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_syscall" >&5
+$as_echo "$je_cv_syscall" >&6; }
 
+  CFLAGS="${SAVED_CFLAGS}"
+  if test "x$je_cv_syscall" = "xyes" ; then
+    $as_echo "#define JEMALLOC_USE_SYSCALL  " >>confdefs.h
 
-LIBS="${SAVED_LIBS}"
+  fi
+fi
 
 ac_fn_c_check_func "$LINENO" "secure_getenv" "ac_cv_func_secure_getenv"
 if test "x$ac_cv_func_secure_getenv" = xyes; then :
   have_secure_getenv="1"
 else
   have_secure_getenv="0"
@@ -7230,16 +8271,25 @@
 
 else
   enable_lazy_lock=""
 
 fi
 
-if test "x$enable_lazy_lock" = "x" -a "x${force_lazy_lock}" = "x1" ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: Forcing lazy-lock to avoid allocator/threading bootstrap issues" >&5
+if test "x${enable_lazy_lock}" = "x" ; then
+  if test "x${force_lazy_lock}" = "x1" ; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: Forcing lazy-lock to avoid allocator/threading bootstrap issues" >&5
 $as_echo "Forcing lazy-lock to avoid allocator/threading bootstrap issues" >&6; }
-  enable_lazy_lock="1"
+    enable_lazy_lock="1"
+  else
+    enable_lazy_lock="0"
+  fi
+fi
+if test "x${enable_lazy_lock}" = "x1" -a "x${abi}" = "xpecoff" ; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: Forcing no lazy-lock because thread creation monitoring is unimplemented" >&5
+$as_echo "Forcing no lazy-lock because thread creation monitoring is unimplemented" >&6; }
+  enable_lazy_lock="0"
 fi
 if test "x$enable_lazy_lock" = "x1" ; then
   if test "x$abi" != "xpecoff" ; then
     for ac_header in dlfcn.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default"
@@ -7303,14 +8353,12 @@
 
 fi
 
   fi
   $as_echo "#define JEMALLOC_LAZY_LOCK  " >>confdefs.h
 
-else
-  enable_lazy_lock="0"
 fi
 
 
 # Check whether --enable-tls was given.
 if test "${enable_tls+set}" = set; then :
   enableval=$enable_tls; if test "x$enable_tls" = "xno" ; then
@@ -7541,15 +8589,13 @@
 #include <sys/mman.h>
 
 int
 main ()
 {
 
-	{
-		madvise((void *)0, 0, 0);
-	}
+	madvise((void *)0, 0, 0);
 
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
@@ -7563,12 +8609,124 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_madvise" >&5
 $as_echo "$je_cv_madvise" >&6; }
 
 if test "x${je_cv_madvise}" = "xyes" ; then
   $as_echo "#define JEMALLOC_HAVE_MADVISE  " >>confdefs.h
 
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether madvise(..., MADV_FREE) is compilable" >&5
+$as_echo_n "checking whether madvise(..., MADV_FREE) is compilable... " >&6; }
+if ${je_cv_madv_free+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/mman.h>
+
+int
+main ()
+{
+
+	madvise((void *)0, 0, MADV_FREE);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_madv_free=yes
+else
+  je_cv_madv_free=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_madv_free" >&5
+$as_echo "$je_cv_madv_free" >&6; }
+
+  if test "x${je_cv_madv_free}" = "xyes" ; then
+    $as_echo "#define JEMALLOC_PURGE_MADVISE_FREE  " >>confdefs.h
+
+  fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether madvise(..., MADV_DONTNEED) is compilable" >&5
+$as_echo_n "checking whether madvise(..., MADV_DONTNEED) is compilable... " >&6; }
+if ${je_cv_madv_dontneed+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/mman.h>
+
+int
+main ()
+{
+
+	madvise((void *)0, 0, MADV_DONTNEED);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_madv_dontneed=yes
+else
+  je_cv_madv_dontneed=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_madv_dontneed" >&5
+$as_echo "$je_cv_madv_dontneed" >&6; }
+
+  if test "x${je_cv_madv_dontneed}" = "xyes" ; then
+    $as_echo "#define JEMALLOC_PURGE_MADVISE_DONTNEED  " >>confdefs.h
+
+  fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether madvise(..., MADV_[NO]HUGEPAGE) is compilable" >&5
+$as_echo_n "checking whether madvise(..., MADV_[NO]HUGEPAGE) is compilable... " >&6; }
+if ${je_cv_thp+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <sys/mman.h>
+
+int
+main ()
+{
+
+	madvise((void *)0, 0, MADV_HUGEPAGE);
+	madvise((void *)0, 0, MADV_NOHUGEPAGE);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_thp=yes
+else
+  je_cv_thp=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_thp" >&5
+$as_echo "$je_cv_thp" >&6; }
+
+  if test "x${je_cv_thp}" = "xyes" ; then
+    $as_echo "#define JEMALLOC_THP  " >>confdefs.h
+
+  fi
 fi
 
 
 
 
 if test "x${je_cv_atomic9}" != "xyes" -a "x${je_cv_osatomic}" != "xyes" ; then
@@ -7705,12 +8863,57 @@
   $as_echo "#define JEMALLOC_HAVE_BUILTIN_CLZ  " >>confdefs.h
 
 fi
 
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether Darwin os_unfair_lock_*() is compilable" >&5
+$as_echo_n "checking whether Darwin os_unfair_lock_*() is compilable... " >&6; }
+if ${je_cv_os_unfair_lock+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <os/lock.h>
+#include <AvailabilityMacros.h>
+
+int
+main ()
+{
+
+	#if MAC_OS_X_VERSION_MIN_REQUIRED < 101200
+	#error "os_unfair_lock is not supported"
+	#else
+	os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;
+	os_unfair_lock_lock(&lock);
+	os_unfair_lock_unlock(&lock);
+	#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  je_cv_os_unfair_lock=yes
+else
+  je_cv_os_unfair_lock=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $je_cv_os_unfair_lock" >&5
+$as_echo "$je_cv_os_unfair_lock" >&6; }
+
+if test "x${je_cv_os_unfair_lock}" = "xyes" ; then
+  $as_echo "#define JEMALLOC_OS_UNFAIR_LOCK  " >>confdefs.h
+
+fi
+
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether Darwin OSSpin*() is compilable" >&5
 $as_echo_n "checking whether Darwin OSSpin*() is compilable... " >&6; }
 if ${je_cv_osspin+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -9607,22 +10810,22 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: CONFIG             : ${CONFIG}" >&5
 $as_echo "CONFIG             : ${CONFIG}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: CC                 : ${CC}" >&5
 $as_echo "CC                 : ${CC}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: CFLAGS             : ${CFLAGS}" >&5
 $as_echo "CFLAGS             : ${CFLAGS}" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: EXTRA_CFLAGS       : ${EXTRA_CFLAGS}" >&5
+$as_echo "EXTRA_CFLAGS       : ${EXTRA_CFLAGS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: CPPFLAGS           : ${CPPFLAGS}" >&5
 $as_echo "CPPFLAGS           : ${CPPFLAGS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: LDFLAGS            : ${LDFLAGS}" >&5
 $as_echo "LDFLAGS            : ${LDFLAGS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: EXTRA_LDFLAGS      : ${EXTRA_LDFLAGS}" >&5
 $as_echo "EXTRA_LDFLAGS      : ${EXTRA_LDFLAGS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: LIBS               : ${LIBS}" >&5
 $as_echo "LIBS               : ${LIBS}" >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: TESTLIBS           : ${TESTLIBS}" >&5
-$as_echo "TESTLIBS           : ${TESTLIBS}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: RPATH_EXTRA        : ${RPATH_EXTRA}" >&5
 $as_echo "RPATH_EXTRA        : ${RPATH_EXTRA}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: " >&5
 $as_echo "" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: XSLTPROC           : ${XSLTPROC}" >&5
 $as_echo "XSLTPROC           : ${XSLTPROC}" >&6; }
@@ -9659,12 +10862,14 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: JEMALLOC_PRIVATE_NAMESPACE" >&5
 $as_echo "JEMALLOC_PRIVATE_NAMESPACE" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:                    : ${JEMALLOC_PRIVATE_NAMESPACE}" >&5
 $as_echo "                   : ${JEMALLOC_PRIVATE_NAMESPACE}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: install_suffix     : ${install_suffix}" >&5
 $as_echo "install_suffix     : ${install_suffix}" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: malloc_conf        : ${config_malloc_conf}" >&5
+$as_echo "malloc_conf        : ${config_malloc_conf}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: autogen            : ${enable_autogen}" >&5
 $as_echo "autogen            : ${enable_autogen}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: cc-silence         : ${enable_cc_silence}" >&5
 $as_echo "cc-silence         : ${enable_cc_silence}" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: debug              : ${enable_debug}" >&5
 $as_echo "debug              : ${enable_debug}" >&6; }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/configure.ac	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/configure.ac	2017-01-31 23:32:23.000000000 +0800
@@ -1,9 +1,11 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_INIT([Makefile.in])
 
+AC_CONFIG_AUX_DIR([build-aux])
+
 dnl ============================================================================
 dnl Custom macro definitions.
 
 dnl JE_CFLAGS_APPEND(cflag)
 AC_DEFUN([JE_CFLAGS_APPEND],
 [
@@ -126,54 +129,112 @@
 #endif
 ])],
                                [je_cv_msvc=yes],
                                [je_cv_msvc=no])])
 fi
 
+dnl check if a cray prgenv wrapper compiler is being used
+je_cv_cray_prgenv_wrapper=""
+if test "x${PE_ENV}" != "x" ; then
+  case "${CC}" in
+    CC|cc)
+	je_cv_cray_prgenv_wrapper="yes"
+	;;
+    *)
+       ;;
+  esac
+fi
+
+AC_CACHE_CHECK([whether compiler is cray],
+              [je_cv_cray],
+              [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],
+                                                  [
+#ifndef _CRAYC
+  int fail[-1];
+#endif
+])],
+                            [je_cv_cray=yes],
+                            [je_cv_cray=no])])
+
+if test "x${je_cv_cray}" = "xyes" ; then
+  AC_CACHE_CHECK([whether cray compiler version is 8.4],
+                [je_cv_cray_84],
+                [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],
+                                                      [
+#if !(_RELEASE_MAJOR == 8 && _RELEASE_MINOR == 4)
+  int fail[-1];
+#endif
+])],
+                              [je_cv_cray_84=yes],
+                              [je_cv_cray_84=no])])
+fi
+
 if test "x$CFLAGS" = "x" ; then
   no_CFLAGS="yes"
   if test "x$GCC" = "xyes" ; then
-    JE_CFLAGS_APPEND([-std=gnu99])
-    if test "x$je_cv_cflags_appended" = "x-std=gnu99" ; then
+    JE_CFLAGS_APPEND([-std=gnu11])
+    if test "x$je_cv_cflags_appended" = "x-std=gnu11" ; then
       AC_DEFINE_UNQUOTED([JEMALLOC_HAS_RESTRICT])
+    else
+      JE_CFLAGS_APPEND([-std=gnu99])
+      if test "x$je_cv_cflags_appended" = "x-std=gnu99" ; then
+        AC_DEFINE_UNQUOTED([JEMALLOC_HAS_RESTRICT])
+      fi
     fi
     JE_CFLAGS_APPEND([-Wall])
     JE_CFLAGS_APPEND([-Werror=declaration-after-statement])
+    JE_CFLAGS_APPEND([-Wshorten-64-to-32])
+    JE_CFLAGS_APPEND([-Wsign-compare])
     JE_CFLAGS_APPEND([-pipe])
     JE_CFLAGS_APPEND([-g3])
   elif test "x$je_cv_msvc" = "xyes" ; then
     CC="$CC -nologo"
     JE_CFLAGS_APPEND([-Zi])
     JE_CFLAGS_APPEND([-MT])
     JE_CFLAGS_APPEND([-W3])
     JE_CFLAGS_APPEND([-FS])
     CPPFLAGS="$CPPFLAGS -I${srcdir}/include/msvc_compat"
   fi
+  if test "x$je_cv_cray" = "xyes" ; then
+    dnl cray compiler 8.4 has an inlining bug
+    if test "x$je_cv_cray_84" = "xyes" ; then
+      JE_CFLAGS_APPEND([-hipa2])
+      JE_CFLAGS_APPEND([-hnognu])
+    fi
+    if test "x$enable_cc_silence" != "xno" ; then
+      dnl ignore unreachable code warning
+      JE_CFLAGS_APPEND([-hnomessage=128])
+      dnl ignore redefinition of "malloc", "free", etc warning
+      JE_CFLAGS_APPEND([-hnomessage=1357])
+    fi
+  fi
 fi
-dnl Append EXTRA_CFLAGS to CFLAGS, if defined.
-if test "x$EXTRA_CFLAGS" != "x" ; then
-  JE_CFLAGS_APPEND([$EXTRA_CFLAGS])
-fi
+AC_SUBST([EXTRA_CFLAGS])
 AC_PROG_CPP
 
 AC_C_BIGENDIAN([ac_cv_big_endian=1], [ac_cv_big_endian=0])
 if test "x${ac_cv_big_endian}" = "x1" ; then
   AC_DEFINE_UNQUOTED([JEMALLOC_BIG_ENDIAN], [ ])
 fi
 
 if test "x${je_cv_msvc}" = "xyes" -a "x${ac_cv_header_inttypes_h}" = "xno"; then
   CPPFLAGS="$CPPFLAGS -I${srcdir}/include/msvc_compat/C99"
 fi
 
-AC_CHECK_SIZEOF([void *])
-if test "x${ac_cv_sizeof_void_p}" = "x8" ; then
-  LG_SIZEOF_PTR=3
-elif test "x${ac_cv_sizeof_void_p}" = "x4" ; then
-  LG_SIZEOF_PTR=2
-else
-  AC_MSG_ERROR([Unsupported pointer size: ${ac_cv_sizeof_void_p}])
+if test "x${je_cv_msvc}" = "xyes" ; then
+  LG_SIZEOF_PTR=LG_SIZEOF_PTR_WIN
+  AC_MSG_RESULT([Using a predefined value for sizeof(void *): 4 for 32-bit, 8 for 64-bit])
+else
+  AC_CHECK_SIZEOF([void *])
+  if test "x${ac_cv_sizeof_void_p}" = "x8" ; then
+    LG_SIZEOF_PTR=3
+  elif test "x${ac_cv_sizeof_void_p}" = "x4" ; then
+    LG_SIZEOF_PTR=2
+  else
+    AC_MSG_ERROR([Unsupported pointer size: ${ac_cv_sizeof_void_p}])
+  fi
 fi
 AC_DEFINE_UNQUOTED([LG_SIZEOF_PTR], [$LG_SIZEOF_PTR])
 
 AC_CHECK_SIZEOF([int])
 if test "x${ac_cv_sizeof_int}" = "x8" ; then
   LG_SIZEOF_INT=3
@@ -191,12 +252,22 @@
   LG_SIZEOF_LONG=2
 else
   AC_MSG_ERROR([Unsupported long size: ${ac_cv_sizeof_long}])
 fi
 AC_DEFINE_UNQUOTED([LG_SIZEOF_LONG], [$LG_SIZEOF_LONG])
 
+AC_CHECK_SIZEOF([long long])
+if test "x${ac_cv_sizeof_long_long}" = "x8" ; then
+  LG_SIZEOF_LONG_LONG=3
+elif test "x${ac_cv_sizeof_long_long}" = "x4" ; then
+  LG_SIZEOF_LONG_LONG=2
+else
+  AC_MSG_ERROR([Unsupported long long size: ${ac_cv_sizeof_long_long}])
+fi
+AC_DEFINE_UNQUOTED([LG_SIZEOF_LONG_LONG], [$LG_SIZEOF_LONG_LONG])
+
 AC_CHECK_SIZEOF([intmax_t])
 if test "x${ac_cv_sizeof_intmax_t}" = "x16" ; then
   LG_SIZEOF_INTMAX_T=4
 elif test "x${ac_cv_sizeof_intmax_t}" = "x8" ; then
   LG_SIZEOF_INTMAX_T=3
 elif test "x${ac_cv_sizeof_intmax_t}" = "x4" ; then
@@ -208,18 +279,28 @@
 
 AC_CANONICAL_HOST
 dnl CPU-specific settings.
 CPU_SPINWAIT=""
 case "${host_cpu}" in
   i686|x86_64)
-	AC_CACHE_VAL([je_cv_pause],
-	  [JE_COMPILABLE([pause instruction], [],
-	                [[__asm__ volatile("pause"); return 0;]],
-	                [je_cv_pause])])
-	if test "x${je_cv_pause}" = "xyes" ; then
-	    CPU_SPINWAIT='__asm__ volatile("pause")'
+	if test "x${je_cv_msvc}" = "xyes" ; then
+	    AC_CACHE_VAL([je_cv_pause_msvc],
+	      [JE_COMPILABLE([pause instruction MSVC], [],
+					[[_mm_pause(); return 0;]],
+					[je_cv_pause_msvc])])
+	    if test "x${je_cv_pause_msvc}" = "xyes" ; then
+		CPU_SPINWAIT='_mm_pause()'
+	    fi
+	else
+	    AC_CACHE_VAL([je_cv_pause],
+	      [JE_COMPILABLE([pause instruction], [],
+					[[__asm__ volatile("pause"); return 0;]],
+					[je_cv_pause])])
+	    if test "x${je_cv_pause}" = "xyes" ; then
+		CPU_SPINWAIT='__asm__ volatile("pause")'
+	    fi
 	fi
 	;;
   powerpc)
 	AC_DEFINE_UNQUOTED([HAVE_ALTIVEC], [ ])
 	;;
   *)
@@ -231,79 +312,92 @@
 so="so"
 importlib="${so}"
 o="$ac_objext"
 a="a"
 exe="$ac_exeext"
 libprefix="lib"
+link_whole_archive="0"
 DSO_LDFLAGS='-shared -Wl,-soname,$(@F)'
 RPATH='-Wl,-rpath,$(1)'
 SOREV="${so}.${rev}"
 PIC_CFLAGS='-fPIC -DPIC'
 CTARGET='-o $@'
 LDTARGET='-o $@'
+TEST_LD_MODE=
 EXTRA_LDFLAGS=
 ARFLAGS='crus'
 AROUT=' $@'
 CC_MM=1
 
+if test "x$je_cv_cray_prgenv_wrapper" = "xyes" ; then
+  TEST_LD_MODE='-dynamic'
+fi
+
+if test "x${je_cv_cray}" = "xyes" ; then
+  CC_MM=
+fi
+
 AN_MAKEVAR([AR], [AC_PROG_AR])
 AN_PROGRAM([ar], [AC_PROG_AR])
 AC_DEFUN([AC_PROG_AR], [AC_CHECK_TOOL(AR, ar, :)])
 AC_PROG_AR
 
 dnl Platform-specific settings.  abi and RPATH can probably be determined
 dnl programmatically, but doing so is error-prone, which makes it generally
 dnl not worth the trouble.
 dnl 
 dnl Define cpp macros in CPPFLAGS, rather than doing AC_DEFINE(macro), since the
 dnl definitions need to be seen before any headers are included, which is a pain
 dnl to make happen otherwise.
+CFLAGS="$CFLAGS"
 default_munmap="1"
 maps_coalesce="1"
 case "${host}" in
   *-*-darwin* | *-*-ios*)
-	CFLAGS="$CFLAGS"
 	abi="macho"
-	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
 	RPATH=""
 	LD_PRELOAD_VAR="DYLD_INSERT_LIBRARIES"
 	so="dylib"
 	importlib="${so}"
 	force_tls="0"
 	DSO_LDFLAGS='-shared -Wl,-install_name,$(LIBDIR)/$(@F)'
 	SOREV="${rev}.${so}"
 	sbrk_deprecated="1"
 	;;
   *-*-freebsd*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
+	AC_DEFINE([JEMALLOC_SYSCTL_VM_OVERCOMMIT], [ ])
 	force_lazy_lock="1"
 	;;
   *-*-dragonfly*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
 	;;
   *-*-openbsd*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
 	force_tls="0"
 	;;
   *-*-bitrig*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
 	;;
-  *-*-linux*)
-	CFLAGS="$CFLAGS"
+  *-*-linux-android)
+	dnl syscall(2) and secure_getenv(3) are exposed by _GNU_SOURCE.
 	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
 	abi="elf"
 	AC_DEFINE([JEMALLOC_HAS_ALLOCA_H])
-	AC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED], [ ])
+	AC_DEFINE([JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY], [ ])
+	AC_DEFINE([JEMALLOC_THREADED_INIT], [ ])
+	AC_DEFINE([JEMALLOC_C11ATOMICS])
+	force_tls="0"
+	default_munmap="0"
+	;;
+  *-*-linux* | *-*-kfreebsd*)
+	dnl syscall(2) and secure_getenv(3) are exposed by _GNU_SOURCE.
+	CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE"
+	abi="elf"
+	AC_DEFINE([JEMALLOC_HAS_ALLOCA_H])
+	AC_DEFINE([JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY], [ ])
 	AC_DEFINE([JEMALLOC_THREADED_INIT], [ ])
 	AC_DEFINE([JEMALLOC_USE_CXX_THROW], [ ])
 	default_munmap="0"
 	;;
   *-*-netbsd*)
 	AC_MSG_CHECKING([ABI])
@@ -311,21 +405,18 @@
 [[#ifdef __ELF__
 /* ELF */
 #else
 #error aout
 #endif
 ]])],
-                          [CFLAGS="$CFLAGS"; abi="elf"],
+                          [abi="elf"],
                           [abi="aout"])
 	AC_MSG_RESULT([$abi])
-	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
 	;;
   *-*-solaris2*)
-	CFLAGS="$CFLAGS"
 	abi="elf"
-	AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
 	RPATH='-Wl,-R,$(1)'
 	dnl Solaris needs this for sigwait().
 	CPPFLAGS="$CPPFLAGS -D_POSIX_PTHREAD_SEMANTICS"
 	LIBS="$LIBS -lposix4 -lsocket -lnsl"
 	;;
   *-ibm-aix*)
@@ -338,13 +429,12 @@
 	fi
 	abi="xcoff"
 	;;
   *-*-mingw* | *-*-cygwin*)
 	abi="pecoff"
 	force_tls="0"
-	force_lazy_lock="1"
 	maps_coalesce="0"
 	RPATH=""
 	so="dll"
 	if test "x$je_cv_msvc" = "xyes" ; then
 	  importlib="lib"
 	  DSO_LDFLAGS="-LD"
@@ -355,12 +445,13 @@
 	  ARFLAGS='-nologo -out:'
 	  AROUT='$@'
 	  CC_MM=
         else
 	  importlib="${so}"
 	  DSO_LDFLAGS="-shared"
+	  link_whole_archive="1"
 	fi
 	a="lib"
 	libprefix=""
 	SOREV="${so}"
 	PIC_CFLAGS=""
 	;;
@@ -392,23 +483,34 @@
 AC_SUBST([so])
 AC_SUBST([importlib])
 AC_SUBST([o])
 AC_SUBST([a])
 AC_SUBST([exe])
 AC_SUBST([libprefix])
+AC_SUBST([link_whole_archive])
 AC_SUBST([DSO_LDFLAGS])
 AC_SUBST([EXTRA_LDFLAGS])
 AC_SUBST([SOREV])
 AC_SUBST([PIC_CFLAGS])
 AC_SUBST([CTARGET])
 AC_SUBST([LDTARGET])
+AC_SUBST([TEST_LD_MODE])
 AC_SUBST([MKLIB])
 AC_SUBST([ARFLAGS])
 AC_SUBST([AROUT])
 AC_SUBST([CC_MM])
 
+dnl Determine whether libm must be linked to use e.g. log(3).
+AC_SEARCH_LIBS([log], [m], , [AC_MSG_ERROR([Missing math functions])])
+if test "x$ac_cv_search_log" != "xnone required" ; then
+  LM="$ac_cv_search_log"
+else
+  LM=
+fi
+AC_SUBST(LM)
+
 JE_COMPILABLE([__attribute__ syntax],
               [static __attribute__((unused)) void foo(void){}],
               [],
               [je_cv_attribute])
 if test "x${je_cv_attribute}" = "xyes" ; then
   AC_DEFINE([JEMALLOC_HAVE_ATTR], [ ])
@@ -416,12 +518,13 @@
     JE_CFLAGS_APPEND([-fvisibility=hidden])
   fi
 fi
 dnl Check for tls_model attribute support (clang 3.0 still lacks support).
 SAVED_CFLAGS="${CFLAGS}"
 JE_CFLAGS_APPEND([-Werror])
+JE_CFLAGS_APPEND([-herror_on_warning])
 JE_COMPILABLE([tls_model attribute], [],
               [static __thread int
                __attribute__((tls_model("initial-exec"), unused)) foo;
                foo = 0;],
               [je_cv_tls_model])
 CFLAGS="${SAVED_CFLAGS}"
@@ -431,32 +534,35 @@
 else
   AC_DEFINE([JEMALLOC_TLS_MODEL], [ ])
 fi
 dnl Check for alloc_size attribute support.
 SAVED_CFLAGS="${CFLAGS}"
 JE_CFLAGS_APPEND([-Werror])
+JE_CFLAGS_APPEND([-herror_on_warning])
 JE_COMPILABLE([alloc_size attribute], [#include <stdlib.h>],
               [void *foo(size_t size) __attribute__((alloc_size(1)));],
               [je_cv_alloc_size])
 CFLAGS="${SAVED_CFLAGS}"
 if test "x${je_cv_alloc_size}" = "xyes" ; then
   AC_DEFINE([JEMALLOC_HAVE_ATTR_ALLOC_SIZE], [ ])
 fi
 dnl Check for format(gnu_printf, ...) attribute support.
 SAVED_CFLAGS="${CFLAGS}"
 JE_CFLAGS_APPEND([-Werror])
+JE_CFLAGS_APPEND([-herror_on_warning])
 JE_COMPILABLE([format(gnu_printf, ...) attribute], [#include <stdlib.h>],
               [void *foo(const char *format, ...) __attribute__((format(gnu_printf, 1, 2)));],
               [je_cv_format_gnu_printf])
 CFLAGS="${SAVED_CFLAGS}"
 if test "x${je_cv_format_gnu_printf}" = "xyes" ; then
   AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF], [ ])
 fi
 dnl Check for format(printf, ...) attribute support.
 SAVED_CFLAGS="${CFLAGS}"
 JE_CFLAGS_APPEND([-Werror])
+JE_CFLAGS_APPEND([-herror_on_warning])
 JE_COMPILABLE([format(printf, ...) attribute], [#include <stdlib.h>],
               [void *foo(const char *format, ...) __attribute__((format(printf, 1, 2)));],
               [je_cv_format_printf])
 CFLAGS="${SAVED_CFLAGS}"
 if test "x${je_cv_format_printf}" = "xyes" ; then
   AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_PRINTF], [ ])
@@ -572,12 +678,21 @@
   [INSTALL_SUFFIX="$with_install_suffix"],
   [INSTALL_SUFFIX=]
 )
 install_suffix="$INSTALL_SUFFIX"
 AC_SUBST([install_suffix])
 
+dnl Specify default malloc_conf.
+AC_ARG_WITH([malloc_conf],
+  [AS_HELP_STRING([--with-malloc-conf=<malloc_conf>], [config.malloc_conf options string])],
+  [JEMALLOC_CONFIG_MALLOC_CONF="$with_malloc_conf"],
+  [JEMALLOC_CONFIG_MALLOC_CONF=""]
+)
+config_malloc_conf="$JEMALLOC_CONFIG_MALLOC_CONF"
+AC_DEFINE_UNQUOTED([JEMALLOC_CONFIG_MALLOC_CONF], ["$config_malloc_conf"])
+
 dnl Substitute @je_@ in jemalloc_protos.h.in, primarily to make generation of
 dnl jemalloc_protos_jet.h easy.
 je_="je_"
 AC_SUBST([je_])
 
 cfgoutputs_in="Makefile.in"
@@ -836,15 +951,15 @@
   backtrace_method="none (disabling profiling)"
   enable_prof="0"
 fi
 AC_MSG_CHECKING([configured backtracing method])
 AC_MSG_RESULT([$backtrace_method])
 if test "x$enable_prof" = "x1" ; then
-  if test "x$abi" != "xpecoff"; then
-    dnl Heap profiling uses the log(3) function.
-    LIBS="$LIBS -lm"
+  dnl Heap profiling uses the log(3) function.
+  if test "x$LM" != "x" ; then
+    LIBS="$LIBS $LM"
   fi
 
   AC_DEFINE([JEMALLOC_PROF], [ ])
 fi
 AC_SUBST([enable_prof])
 
@@ -1007,29 +1122,47 @@
 )
 if test "x$enable_cache_oblivious" = "x1" ; then
   AC_DEFINE([JEMALLOC_CACHE_OBLIVIOUS], [ ])
 fi
 AC_SUBST([enable_cache_oblivious])
 
+
+
+JE_COMPILABLE([a program using __builtin_unreachable], [
+void foo (void) {
+  __builtin_unreachable();
+}
+], [
+	{
+		foo();
+	}
+], [je_cv_gcc_builtin_unreachable])
+if test "x${je_cv_gcc_builtin_unreachable}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_INTERNAL_UNREACHABLE], [__builtin_unreachable])
+else
+  AC_DEFINE([JEMALLOC_INTERNAL_UNREACHABLE], [abort])
+fi
+
 dnl ============================================================================
 dnl Check for  __builtin_ffsl(), then ffsl(3), and fail if neither are found.
 dnl One of those two functions should (theoretically) exist on all platforms
 dnl that jemalloc currently has a chance of functioning on without modification.
-dnl We additionally assume ffs() or __builtin_ffs() are defined if
+dnl We additionally assume ffs[ll]() or __builtin_ffs[ll]() are defined if
 dnl ffsl() or __builtin_ffsl() are defined, respectively.
 JE_COMPILABLE([a program using __builtin_ffsl], [
 #include <stdio.h>
 #include <strings.h>
 #include <string.h>
 ], [
 	{
 		int rv = __builtin_ffsl(0x08);
 		printf("%d\n", rv);
 	}
 ], [je_cv_gcc_builtin_ffsl])
 if test "x${je_cv_gcc_builtin_ffsl}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_INTERNAL_FFSLL], [__builtin_ffsll])
   AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [__builtin_ffsl])
   AC_DEFINE([JEMALLOC_INTERNAL_FFS], [__builtin_ffs])
 else
   JE_COMPILABLE([a program using ffsl], [
   #include <stdio.h>
   #include <strings.h>
@@ -1038,12 +1171,13 @@
 	{
 		int rv = ffsl(0x08);
 		printf("%d\n", rv);
 	}
   ], [je_cv_function_ffsl])
   if test "x${je_cv_function_ffsl}" = "xyes" ; then
+    AC_DEFINE([JEMALLOC_INTERNAL_FFSLL], [ffsll])
     AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [ffsl])
     AC_DEFINE([JEMALLOC_INTERNAL_FFS], [ffs])
   else
     AC_MSG_ERROR([Cannot build without ffsl(3) or __builtin_ffsl()])
   fi
 fi
@@ -1097,13 +1231,13 @@
     result = JEMALLOC_INTERNAL_FFSL(result) - 1;
 
     f = fopen("conftest.out", "w");
     if (f == NULL) {
 	return 1;
     }
-    fprintf(f, "%d\n", result);
+    fprintf(f, "%d", result);
     fclose(f);
 
     return 0;
 ]])],
                              [je_cv_lg_page=`cat conftest.out`],
                              [je_cv_lg_page=undefined],
@@ -1130,33 +1264,42 @@
   [LG_SIZE_CLASS_GROUP="2"])
 
 dnl ============================================================================
 dnl jemalloc configuration.
 dnl 
 
-dnl Set VERSION if source directory is inside a git repository.
-if test "x`test ! \"${srcroot}\" && cd \"${srcroot}\"; git rev-parse --is-inside-work-tree 2>/dev/null`" = "xtrue" ; then
-  dnl Pattern globs aren't powerful enough to match both single- and
-  dnl double-digit version numbers, so iterate over patterns to support up to
-  dnl version 99.99.99 without any accidental matches.
-  rm -f "${objroot}VERSION"
-  for pattern in ['[0-9].[0-9].[0-9]' '[0-9].[0-9].[0-9][0-9]' \
-                 '[0-9].[0-9][0-9].[0-9]' '[0-9].[0-9][0-9].[0-9][0-9]' \
-                 '[0-9][0-9].[0-9].[0-9]' '[0-9][0-9].[0-9].[0-9][0-9]' \
-                 '[0-9][0-9].[0-9][0-9].[0-9]' \
-                 '[0-9][0-9].[0-9][0-9].[0-9][0-9]']; do
-    if test ! -e "${objroot}VERSION" ; then
-      (test ! "${srcroot}" && cd "${srcroot}"; git describe --long --abbrev=40 --match="${pattern}") > "${objroot}VERSION.tmp" 2>/dev/null
-      if test $? -eq 0 ; then
-        mv "${objroot}VERSION.tmp" "${objroot}VERSION"
-        break
-      fi
+AC_ARG_WITH([version],
+  [AS_HELP_STRING([--with-version=<major>.<minor>.<bugfix>-<nrev>-g<gid>],
+   [Version string])],
+  [
+    echo "${with_version}" | grep ['^[0-9]\+\.[0-9]\+\.[0-9]\+-[0-9]\+-g[0-9a-f]\+$'] 2>&1 1>/dev/null
+    if test $? -ne 0 ; then
+      AC_MSG_ERROR([${with_version} does not match <major>.<minor>.<bugfix>-<nrev>-g<gid>])
     fi
-  done
-fi
-rm -f "${objroot}VERSION.tmp"
+    echo "$with_version" > "${objroot}VERSION"
+  ], [
+    dnl Set VERSION if source directory is inside a git repository.
+    if test "x`test ! \"${srcroot}\" && cd \"${srcroot}\"; git rev-parse --is-inside-work-tree 2>/dev/null`" = "xtrue" ; then
+      dnl Pattern globs aren't powerful enough to match both single- and
+      dnl double-digit version numbers, so iterate over patterns to support up
+      dnl to version 99.99.99 without any accidental matches.
+      for pattern in ['[0-9].[0-9].[0-9]' '[0-9].[0-9].[0-9][0-9]' \
+                     '[0-9].[0-9][0-9].[0-9]' '[0-9].[0-9][0-9].[0-9][0-9]' \
+                     '[0-9][0-9].[0-9].[0-9]' '[0-9][0-9].[0-9].[0-9][0-9]' \
+                     '[0-9][0-9].[0-9][0-9].[0-9]' \
+                     '[0-9][0-9].[0-9][0-9].[0-9][0-9]']; do
+        (test ! "${srcroot}" && cd "${srcroot}"; git describe --long --abbrev=40 --match="${pattern}") > "${objroot}VERSION.tmp" 2>/dev/null
+        if test $? -eq 0 ; then
+          mv "${objroot}VERSION.tmp" "${objroot}VERSION"
+          break
+        fi
+      done
+    fi
+    rm -f "${objroot}VERSION.tmp"
+  ])
+
 if test ! -e "${objroot}VERSION" ; then
   if test ! -e "${srcroot}VERSION" ; then
     AC_MSG_RESULT(
       [Missing VERSION file, and unable to generate it; creating bogus VERSION])
     echo "0.0.0-0-g0000000000000000000000000000000000000000" > "${objroot}VERSION"
   else
@@ -1183,23 +1326,107 @@
   AC_CHECK_HEADERS([pthread.h], , [AC_MSG_ERROR([pthread.h is missing])])
   dnl Some systems may embed pthreads functionality in libc; check for libpthread
   dnl first, but try libc too before failing.
   AC_CHECK_LIB([pthread], [pthread_create], [LIBS="$LIBS -lpthread"],
                [AC_SEARCH_LIBS([pthread_create], , ,
                                AC_MSG_ERROR([libpthread is missing]))])
+  JE_COMPILABLE([pthread_atfork(3)], [
+#include <pthread.h>
+], [
+  pthread_atfork((void *)0, (void *)0, (void *)0);
+], [je_cv_pthread_atfork])
+  if test "x${je_cv_pthread_atfork}" = "xyes" ; then
+    AC_DEFINE([JEMALLOC_HAVE_PTHREAD_ATFORK], [ ])
+  fi
 fi
 
 CPPFLAGS="$CPPFLAGS -D_REENTRANT"
 
-dnl Check whether clock_gettime(2) is in libc or librt.  This function is only
-dnl used in test code, so save the result to TESTLIBS to avoid poluting LIBS.
-SAVED_LIBS="${LIBS}"
-LIBS=
-AC_SEARCH_LIBS([clock_gettime], [rt], [TESTLIBS="${LIBS}"])
-AC_SUBST([TESTLIBS])
-LIBS="${SAVED_LIBS}"
+dnl Check whether clock_gettime(2) is in libc or librt.
+AC_SEARCH_LIBS([clock_gettime], [rt])
+
+dnl Cray wrapper compiler often adds `-lrt` when using `-static`. Check with
+dnl `-dynamic` as well in case a user tries to dynamically link in jemalloc
+if test "x$je_cv_cray_prgenv_wrapper" = "xyes" ; then
+  if test "$ac_cv_search_clock_gettime" != "-lrt"; then
+    SAVED_CFLAGS="${CFLAGS}"
+
+    unset ac_cv_search_clock_gettime
+    JE_CFLAGS_APPEND([-dynamic])
+    AC_SEARCH_LIBS([clock_gettime], [rt])
+
+    CFLAGS="${SAVED_CFLAGS}"
+  fi
+fi
+
+dnl check for CLOCK_MONOTONIC_COARSE (Linux-specific).
+JE_COMPILABLE([clock_gettime(CLOCK_MONOTONIC_COARSE, ...)], [
+#include <time.h>
+], [
+	struct timespec ts;
+
+	clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);
+], [je_cv_clock_monotonic_coarse])
+if test "x${je_cv_clock_monotonic_coarse}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE])
+fi
+
+dnl check for CLOCK_MONOTONIC.
+JE_COMPILABLE([clock_gettime(CLOCK_MONOTONIC, ...)], [
+#include <unistd.h>
+#include <time.h>
+], [
+	struct timespec ts;
+
+	clock_gettime(CLOCK_MONOTONIC, &ts);
+#if !defined(_POSIX_MONOTONIC_CLOCK) || _POSIX_MONOTONIC_CLOCK < 0
+#  error _POSIX_MONOTONIC_CLOCK missing/invalid
+#endif
+], [je_cv_clock_monotonic])
+if test "x${je_cv_clock_monotonic}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_HAVE_CLOCK_MONOTONIC])
+fi
+
+dnl Check for mach_absolute_time().
+JE_COMPILABLE([mach_absolute_time()], [
+#include <mach/mach_time.h>
+], [
+	mach_absolute_time();
+], [je_cv_mach_absolute_time])
+if test "x${je_cv_mach_absolute_time}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_HAVE_MACH_ABSOLUTE_TIME])
+fi
+
+dnl Use syscall(2) (if available) by default.
+AC_ARG_ENABLE([syscall],
+  [AS_HELP_STRING([--disable-syscall], [Disable use of syscall(2)])],
+[if test "x$enable_syscall" = "xno" ; then
+  enable_syscall="0"
+else
+  enable_syscall="1"
+fi
+],
+[enable_syscall="1"]
+)
+if test "x$enable_syscall" = "x1" ; then
+  dnl Check if syscall(2) is usable.  Treat warnings as errors, so that e.g. OS
+  dnl X 10.12's deprecation warning prevents use.
+  SAVED_CFLAGS="${CFLAGS}"
+  JE_CFLAGS_APPEND([-Werror])
+  JE_COMPILABLE([syscall(2)], [
+#include <sys/syscall.h>
+#include <unistd.h>
+], [
+	syscall(SYS_write, 2, "hello", 5);
+],
+                [je_cv_syscall])
+  CFLAGS="${SAVED_CFLAGS}"
+  if test "x$je_cv_syscall" = "xyes" ; then
+    AC_DEFINE([JEMALLOC_USE_SYSCALL], [ ])
+  fi
+fi
 
 dnl Check if the GNU-specific secure_getenv function exists.
 AC_CHECK_FUNC([secure_getenv],
               [have_secure_getenv="1"],
               [have_secure_getenv="0"]
              )
@@ -1249,27 +1476,33 @@
 else
   enable_lazy_lock="1"
 fi
 ],
 [enable_lazy_lock=""]
 )
-if test "x$enable_lazy_lock" = "x" -a "x${force_lazy_lock}" = "x1" ; then
-  AC_MSG_RESULT([Forcing lazy-lock to avoid allocator/threading bootstrap issues])
-  enable_lazy_lock="1"
+if test "x${enable_lazy_lock}" = "x" ; then
+  if test "x${force_lazy_lock}" = "x1" ; then
+    AC_MSG_RESULT([Forcing lazy-lock to avoid allocator/threading bootstrap issues])
+    enable_lazy_lock="1"
+  else
+    enable_lazy_lock="0"
+  fi
+fi
+if test "x${enable_lazy_lock}" = "x1" -a "x${abi}" = "xpecoff" ; then
+  AC_MSG_RESULT([Forcing no lazy-lock because thread creation monitoring is unimplemented])
+  enable_lazy_lock="0"
 fi
 if test "x$enable_lazy_lock" = "x1" ; then
   if test "x$abi" != "xpecoff" ; then
     AC_CHECK_HEADERS([dlfcn.h], , [AC_MSG_ERROR([dlfcn.h is missing])])
     AC_CHECK_FUNC([dlsym], [],
       [AC_CHECK_LIB([dl], [dlsym], [LIBS="$LIBS -ldl"],
                     [AC_MSG_ERROR([libdl is missing])])
       ])
   fi
   AC_DEFINE([JEMALLOC_LAZY_LOCK], [ ])
-else
-  enable_lazy_lock="0"
 fi
 AC_SUBST([enable_lazy_lock])
 
 AC_ARG_ENABLE([tls],
   [AS_HELP_STRING([--disable-tls], [Disable thread-local storage (__thread keyword)])],
 if test "x$enable_tls" = "xno" ; then
@@ -1386,18 +1619,47 @@
 dnl ============================================================================
 dnl Check for madvise(2).
 
 JE_COMPILABLE([madvise(2)], [
 #include <sys/mman.h>
 ], [
-	{
-		madvise((void *)0, 0, 0);
-	}
+	madvise((void *)0, 0, 0);
 ], [je_cv_madvise])
 if test "x${je_cv_madvise}" = "xyes" ; then
   AC_DEFINE([JEMALLOC_HAVE_MADVISE], [ ])
+
+  dnl Check for madvise(..., MADV_FREE).
+  JE_COMPILABLE([madvise(..., MADV_FREE)], [
+#include <sys/mman.h>
+], [
+	madvise((void *)0, 0, MADV_FREE);
+], [je_cv_madv_free])
+  if test "x${je_cv_madv_free}" = "xyes" ; then
+    AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])
+  fi
+
+  dnl Check for madvise(..., MADV_DONTNEED).
+  JE_COMPILABLE([madvise(..., MADV_DONTNEED)], [
+#include <sys/mman.h>
+], [
+	madvise((void *)0, 0, MADV_DONTNEED);
+], [je_cv_madv_dontneed])
+  if test "x${je_cv_madv_dontneed}" = "xyes" ; then
+    AC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED], [ ])
+  fi
+
+  dnl Check for madvise(..., MADV_[NO]HUGEPAGE).
+  JE_COMPILABLE([madvise(..., MADV_[[NO]]HUGEPAGE)], [
+#include <sys/mman.h>
+], [
+	madvise((void *)0, 0, MADV_HUGEPAGE);
+	madvise((void *)0, 0, MADV_NOHUGEPAGE);
+], [je_cv_thp])
+  if test "x${je_cv_thp}" = "xyes" ; then
+    AC_DEFINE([JEMALLOC_THP], [ ])
+  fi
 fi
 
 dnl ============================================================================
 dnl Check whether __sync_{add,sub}_and_fetch() are available despite
 dnl __GCC_HAVE_SYNC_COMPARE_AND_SWAP_n macros being undefined.
 
@@ -1452,12 +1714,31 @@
 
 if test "x${je_cv_builtin_clz}" = "xyes" ; then
   AC_DEFINE([JEMALLOC_HAVE_BUILTIN_CLZ], [ ])
 fi
 
 dnl ============================================================================
+dnl Check for os_unfair_lock operations as provided on Darwin.
+
+JE_COMPILABLE([Darwin os_unfair_lock_*()], [
+#include <os/lock.h>
+#include <AvailabilityMacros.h>
+], [
+	#if MAC_OS_X_VERSION_MIN_REQUIRED < 101200
+	#error "os_unfair_lock is not supported"
+	#else
+	os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;
+	os_unfair_lock_lock(&lock);
+	os_unfair_lock_unlock(&lock);
+	#endif
+], [je_cv_os_unfair_lock])
+if test "x${je_cv_os_unfair_lock}" = "xyes" ; then
+  AC_DEFINE([JEMALLOC_OS_UNFAIR_LOCK], [ ])
+fi
+
+dnl ============================================================================
 dnl Check for spinlock(3) operations as provided on Darwin.
 
 JE_COMPILABLE([Darwin OSSpin*()], [
 #include <libkern/OSAtomic.h>
 #include <inttypes.h>
 ], [
@@ -1695,17 +1976,17 @@
 AC_MSG_RESULT([jemalloc version   : ${jemalloc_version}])
 AC_MSG_RESULT([library revision   : ${rev}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([CONFIG             : ${CONFIG}])
 AC_MSG_RESULT([CC                 : ${CC}])
 AC_MSG_RESULT([CFLAGS             : ${CFLAGS}])
+AC_MSG_RESULT([EXTRA_CFLAGS       : ${EXTRA_CFLAGS}])
 AC_MSG_RESULT([CPPFLAGS           : ${CPPFLAGS}])
 AC_MSG_RESULT([LDFLAGS            : ${LDFLAGS}])
 AC_MSG_RESULT([EXTRA_LDFLAGS      : ${EXTRA_LDFLAGS}])
 AC_MSG_RESULT([LIBS               : ${LIBS}])
-AC_MSG_RESULT([TESTLIBS           : ${TESTLIBS}])
 AC_MSG_RESULT([RPATH_EXTRA        : ${RPATH_EXTRA}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([XSLTPROC           : ${XSLTPROC}])
 AC_MSG_RESULT([XSLROOT            : ${XSLROOT}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([PREFIX             : ${PREFIX}])
@@ -1721,12 +2002,13 @@
 AC_MSG_RESULT([abs_objroot        : ${abs_objroot}])
 AC_MSG_RESULT([])
 AC_MSG_RESULT([JEMALLOC_PREFIX    : ${JEMALLOC_PREFIX}])
 AC_MSG_RESULT([JEMALLOC_PRIVATE_NAMESPACE])
 AC_MSG_RESULT([                   : ${JEMALLOC_PRIVATE_NAMESPACE}])
 AC_MSG_RESULT([install_suffix     : ${install_suffix}])
+AC_MSG_RESULT([malloc_conf        : ${config_malloc_conf}])
 AC_MSG_RESULT([autogen            : ${enable_autogen}])
 AC_MSG_RESULT([cc-silence         : ${enable_cc_silence}])
 AC_MSG_RESULT([debug              : ${enable_debug}])
 AC_MSG_RESULT([code-coverage      : ${enable_code_coverage}])
 AC_MSG_RESULT([stats              : ${enable_stats}])
 AC_MSG_RESULT([prof               : ${enable_prof}])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/COPYING /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/COPYING
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/COPYING	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/COPYING	2017-01-31 23:32:23.000000000 +0800
@@ -1,13 +1,13 @@
 Unless otherwise specified, files in the jemalloc source distribution are
 subject to the following license:
 --------------------------------------------------------------------------------
-Copyright (C) 2002-2015 Jason Evans <jasone@canonware.com>.
+Copyright (C) 2002-2016 Jason Evans <jasone@canonware.com>.
 All rights reserved.
 Copyright (C) 2007-2012 Mozilla Foundation.  All rights reserved.
-Copyright (C) 2009-2015 Facebook, Inc.  All rights reserved.
+Copyright (C) 2009-2016 Facebook, Inc.  All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 1. Redistributions of source code must retain the above copyright notice(s),
    this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright notice(s),
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/html.xsl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/html.xsl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/html.xsl	2017-09-27 23:00:17.382936201 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/html.xsl	2017-09-27 23:01:52.362932720 +0800
@@ -1,4 +1,5 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:import href="/usr/share/xml/docbook/stylesheet/docbook-xsl/html/docbook.xsl"/>
-  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/stylesheet.xsl"/>
+  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/stylesheet.xsl"/>
+  <xsl:output method="xml" encoding="utf-8"/>
 </xsl:stylesheet>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/html.xsl.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/html.xsl.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/html.xsl.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/html.xsl.in	2017-01-31 23:32:23.000000000 +0800
@@ -1,4 +1,5 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:import href="@XSLROOT@/html/docbook.xsl"/>
   <xsl:import href="@abs_srcroot@doc/stylesheet.xsl"/>
+  <xsl:output method="xml" encoding="utf-8"/>
 </xsl:stylesheet>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/jemalloc.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/jemalloc.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/jemalloc.3	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/jemalloc.3	2017-01-31 23:32:23.000000000 +0800
@@ -1,16 +1,16 @@
 '\" t
 .\"     Title: JEMALLOC
 .\"    Author: Jason Evans
-.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
-.\"      Date: 09/24/2015
+.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
+.\"      Date: 12/03/2016
 .\"    Manual: User Manual
-.\"    Source: jemalloc 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c
+.\"    Source: jemalloc 4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc
 .\"  Language: English
 .\"
-.TH "JEMALLOC" "3" "09/24/2015" "jemalloc 4.0.3-0-ge9192eacf893" "User Manual"
+.TH "JEMALLOC" "3" "12/03/2016" "jemalloc 4.4.0-0-gf1f76357313e" "User Manual"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
 .\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 .\" http://bugs.debian.org/507673
 .\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
@@ -28,13 +28,13 @@
 .\" * MAIN CONTENT STARTS HERE *
 .\" -----------------------------------------------------------------
 .SH "NAME"
 jemalloc \- general purpose memory allocation functions
 .SH "LIBRARY"
 .PP
-This manual describes jemalloc 4\&.0\&.3\-0\-ge9192eacf8935e29fc62fddc2701f7942b1cc02c\&. More information can be found at the
+This manual describes jemalloc 4\&.4\&.0\-0\-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc\&. More information can be found at the
 \m[blue]\fBjemalloc website\fR\m[]\&\s-2\u[1]\d\s+2\&.
 .SH "SYNOPSIS"
 .sp
 .ft B
 .nf
 #include <jemalloc/jemalloc\&.h>
@@ -83,91 +83,91 @@
 .PP
 const char *\fImalloc_conf\fR;
 .SH "DESCRIPTION"
 .SS "Standard API"
 .PP
 The
-\fBmalloc\fR\fB\fR
+malloc()
 function allocates
 \fIsize\fR
 bytes of uninitialized memory\&. The allocated space is suitably aligned (after possible pointer coercion) for storage of any type of object\&.
 .PP
 The
-\fBcalloc\fR\fB\fR
+calloc()
 function allocates space for
 \fInumber\fR
 objects, each
 \fIsize\fR
 bytes in length\&. The result is identical to calling
-\fBmalloc\fR\fB\fR
+malloc()
 with an argument of
 \fInumber\fR
 *
 \fIsize\fR, with the exception that the allocated memory is explicitly initialized to zero bytes\&.
 .PP
 The
-\fBposix_memalign\fR\fB\fR
+posix_memalign()
 function allocates
 \fIsize\fR
 bytes of memory such that the allocation\*(Aqs base address is a multiple of
 \fIalignment\fR, and returns the allocation in the value pointed to by
 \fIptr\fR\&. The requested
 \fIalignment\fR
 must be a power of 2 at least as large as
 sizeof(\fBvoid *\fR)\&.
 .PP
 The
-\fBaligned_alloc\fR\fB\fR
+aligned_alloc()
 function allocates
 \fIsize\fR
 bytes of memory such that the allocation\*(Aqs base address is a multiple of
 \fIalignment\fR\&. The requested
 \fIalignment\fR
 must be a power of 2\&. Behavior is undefined if
 \fIsize\fR
 is not an integral multiple of
 \fIalignment\fR\&.
 .PP
 The
-\fBrealloc\fR\fB\fR
+realloc()
 function changes the size of the previously allocated memory referenced by
 \fIptr\fR
 to
 \fIsize\fR
 bytes\&. The contents of the memory are unchanged up to the lesser of the new and old sizes\&. If the new size is larger, the contents of the newly allocated portion of the memory are undefined\&. Upon success, the memory referenced by
 \fIptr\fR
 is freed and a pointer to the newly allocated memory is returned\&. Note that
-\fBrealloc\fR\fB\fR
+realloc()
 may move the memory allocation, resulting in a different return value than
 \fIptr\fR\&. If
 \fIptr\fR
 is
 \fBNULL\fR, the
-\fBrealloc\fR\fB\fR
+realloc()
 function behaves identically to
-\fBmalloc\fR\fB\fR
+malloc()
 for the specified size\&.
 .PP
 The
-\fBfree\fR\fB\fR
+free()
 function causes the allocated memory referenced by
 \fIptr\fR
 to be made available for future allocations\&. If
 \fIptr\fR
 is
 \fBNULL\fR, no action occurs\&.
 .SS "Non\-standard API"
 .PP
 The
-\fBmallocx\fR\fB\fR,
-\fBrallocx\fR\fB\fR,
-\fBxallocx\fR\fB\fR,
-\fBsallocx\fR\fB\fR,
-\fBdallocx\fR\fB\fR,
-\fBsdallocx\fR\fB\fR, and
-\fBnallocx\fR\fB\fR
+mallocx(),
+rallocx(),
+xallocx(),
+sallocx(),
+dallocx(),
+sdallocx(), and
+nallocx()
 functions all have a
 \fIflags\fR
 argument that can be used to specify options\&. The functions only check the options that are contextually relevant\&. Use bitwise or (|) operations to specify one or more of the following:
 .PP
 \fBMALLOCX_LG_ALIGN(\fR\fB\fIla\fR\fR\fB) \fR
 .RS 4
@@ -193,13 +193,13 @@
 .RE
 .PP
 \fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB) \fR
 .RS 4
 Use the thread\-specific cache (tcache) specified by the identifier
 \fItc\fR, which must have been acquired via the
-"tcache\&.create"
+tcache\&.create
 mallctl\&. This macro does not validate that
 \fItc\fR
 specifies a valid identifier\&.
 .RE
 .PP
 \fBMALLOCX_TCACHE_NONE\fR
@@ -220,33 +220,33 @@
 \fIa\fR\&. This macro has no effect for regions that were allocated via an arena other than the one specified\&. This macro does not validate that
 \fIa\fR
 specifies an arena index in the valid range\&.
 .RE
 .PP
 The
-\fBmallocx\fR\fB\fR
+mallocx()
 function allocates at least
 \fIsize\fR
 bytes of memory, and returns a pointer to the base address of the allocation\&. Behavior is undefined if
 \fIsize\fR
 is
-\fB0\fR, or if request size overflows due to size class and/or alignment constraints\&.
+\fB0\fR\&.
 .PP
 The
-\fBrallocx\fR\fB\fR
+rallocx()
 function resizes the allocation at
 \fIptr\fR
 to be at least
 \fIsize\fR
 bytes, and returns a pointer to the base address of the resulting allocation, which may or may not have moved from its original location\&. Behavior is undefined if
 \fIsize\fR
 is
-\fB0\fR, or if request size overflows due to size class and/or alignment constraints\&.
+\fB0\fR\&.
 .PP
 The
-\fBxallocx\fR\fB\fR
+xallocx()
 function resizes the allocation at
 \fIptr\fR
 in place to be at least
 \fIsize\fR
 bytes, and returns the real size of the allocation\&. If
 \fIextra\fR
@@ -256,46 +256,48 @@
 \fIsize\fR
 is
 \fB0\fR, or if
 (\fIsize\fR + \fIextra\fR > \fBSIZE_T_MAX\fR)\&.
 .PP
 The
-\fBsallocx\fR\fB\fR
+sallocx()
 function returns the real size of the allocation at
 \fIptr\fR\&.
 .PP
 The
-\fBdallocx\fR\fB\fR
+dallocx()
 function causes the memory referenced by
 \fIptr\fR
 to be made available for future allocations\&.
 .PP
 The
-\fBsdallocx\fR\fB\fR
+sdallocx()
 function is an extension of
-\fBdallocx\fR\fB\fR
+dallocx()
 with a
 \fIsize\fR
 parameter to allow the caller to pass in the allocation size as an optimization\&. The minimum valid input size is the original requested size of the allocation, and the maximum valid input size is the corresponding value returned by
-\fBnallocx\fR\fB\fR
+nallocx()
 or
-\fBsallocx\fR\fB\fR\&.
+sallocx()\&.
 .PP
 The
-\fBnallocx\fR\fB\fR
+nallocx()
 function allocates no memory, but it performs the same size computation as the
-\fBmallocx\fR\fB\fR
+mallocx()
 function, and returns the real size of the allocation that would result from the equivalent
-\fBmallocx\fR\fB\fR
-function call\&. Behavior is undefined if
+mallocx()
+function call, or
+\fB0\fR
+if the inputs exceed the maximum supported size class and/or alignment\&. Behavior is undefined if
 \fIsize\fR
 is
-\fB0\fR, or if request size overflows due to size class and/or alignment constraints\&.
+\fB0\fR\&.
 .PP
 The
-\fBmallctl\fR\fB\fR
+mallctl()
 function provides a general interface for introspecting the memory allocator, as well as setting modifiable parameters and triggering actions\&. The period\-separated
 \fIname\fR
 argument specifies a location in a tree\-structured namespace; see the
 MALLCTL NAMESPACE
 section for documentation on the tree contents\&. To read a value, pass a pointer via
 \fIoldp\fR
@@ -308,28 +310,30 @@
 \fInewlen\fR; otherwise pass
 \fBNULL\fR
 and
 \fB0\fR\&.
 .PP
 The
-\fBmallctlnametomib\fR\fB\fR
-function provides a way to avoid repeated name lookups for applications that repeatedly query the same portion of the namespace, by translating a name to a \(lqManagement Information Base\(rq (MIB) that can be passed repeatedly to
-\fBmallctlbymib\fR\fB\fR\&. Upon successful return from
-\fBmallctlnametomib\fR\fB\fR,
+mallctlnametomib()
+function provides a way to avoid repeated name lookups for applications that repeatedly query the same portion of the namespace, by translating a name to a
+\(lqManagement Information Base\(rq
+(MIB) that can be passed repeatedly to
+mallctlbymib()\&. Upon successful return from
+mallctlnametomib(),
 \fImibp\fR
 contains an array of
 \fI*miblenp\fR
 integers, where
 \fI*miblenp\fR
 is the lesser of the number of components in
 \fIname\fR
 and the input value of
 \fI*miblenp\fR\&. Thus it is possible to pass a
 \fI*miblenp\fR
 that is smaller than the number of period\-separated name components, which results in a partial MIB that can be used as the basis for constructing a complete MIB\&. For name components that are integers (e\&.g\&. the 2 in
-"arenas\&.bin\&.2\&.size"), the corresponding MIB component will always be that integer\&. Therefore, it is legitimate to construct code like the following:
+arenas\&.bin\&.2\&.size), the corresponding MIB component will always be that integer\&. Therefore, it is legitimate to construct code like the following:
 .sp
 .if n \{\
 .RS 4
 .\}
 .nf
 unsigned nbins, i;
@@ -343,82 +347,102 @@
 mallctlnametomib("arenas\&.bin\&.0\&.size", mib, &miblen);
 for (i = 0; i < nbins; i++) {
 	size_t bin_size;
 
 	mib[2] = i;
 	len = sizeof(bin_size);
-	mallctlbymib(mib, miblen, &bin_size, &len, NULL, 0);
+	mallctlbymib(mib, miblen, (void *)&bin_size, &len, NULL, 0);
 	/* Do something with bin_size\&.\&.\&. */
 }
 .fi
 .if n \{\
 .RE
 .\}
 .PP
 The
-\fBmalloc_stats_print\fR\fB\fR
-function writes human\-readable summary statistics via the
+malloc_stats_print()
+function writes summary statistics via the
 \fIwrite_cb\fR
 callback function pointer and
 \fIcbopaque\fR
 data passed to
 \fIwrite_cb\fR, or
-\fBmalloc_message\fR\fB\fR
+malloc_message()
 if
 \fIwrite_cb\fR
 is
-\fBNULL\fR\&. This function can be called repeatedly\&. General information that never changes during execution can be omitted by specifying "g" as a character within the
+\fBNULL\fR\&. The statistics are presented in human\-readable form unless
+\(lqJ\(rq
+is specified as a character within the
+\fIopts\fR
+string, in which case the statistics are presented in
+\m[blue]\fBJSON format\fR\m[]\&\s-2\u[2]\d\s+2\&. This function can be called repeatedly\&. General information that never changes during execution can be omitted by specifying
+\(lqg\(rq
+as a character within the
 \fIopts\fR
 string\&. Note that
-\fBmalloc_message\fR\fB\fR
+malloc_message()
 uses the
-\fBmallctl*\fR\fB\fR
+mallctl*()
 functions internally, so inconsistent statistics can be reported if multiple threads use these functions simultaneously\&. If
 \fB\-\-enable\-stats\fR
-is specified during configuration, \(lqm\(rq and \(lqa\(rq can be specified to omit merged arena and per arena statistics, respectively; \(lqb\(rq, \(lql\(rq, and \(lqh\(rq can be specified to omit per size class statistics for bins, large objects, and huge objects, respectively\&. Unrecognized characters are silently ignored\&. Note that thread caching may prevent some statistics from being completely up to date, since extra locking would be required to merge counters that track thread cache operations\&.
+is specified during configuration,
+\(lqm\(rq
+and
+\(lqa\(rq
+can be specified to omit merged arena and per arena statistics, respectively;
+\(lqb\(rq,
+\(lql\(rq, and
+\(lqh\(rq
+can be specified to omit per size class statistics for bins, large objects, and huge objects, respectively\&. Unrecognized characters are silently ignored\&. Note that thread caching may prevent some statistics from being completely up to date, since extra locking would be required to merge counters that track thread cache operations\&.
 .PP
 The
-\fBmalloc_usable_size\fR\fB\fR
+malloc_usable_size()
 function returns the usable size of the allocation pointed to by
 \fIptr\fR\&. The return value may be larger than the size that was requested during allocation\&. The
-\fBmalloc_usable_size\fR\fB\fR
+malloc_usable_size()
 function is not a mechanism for in\-place
-\fBrealloc\fR\fB\fR; rather it is provided solely as a tool for introspection purposes\&. Any discrepancy between the requested allocation size and the size reported by
-\fBmalloc_usable_size\fR\fB\fR
+realloc(); rather it is provided solely as a tool for introspection purposes\&. Any discrepancy between the requested allocation size and the size reported by
+malloc_usable_size()
 should not be depended on, since such behavior is entirely implementation\-dependent\&.
 .SH "TUNING"
 .PP
 Once, when the first call is made to one of the memory allocation routines, the allocator initializes its internals based in part on various options that can be specified at compile\- or run\-time\&.
 .PP
-The string pointed to by the global variable
-\fImalloc_conf\fR, the \(lqname\(rq of the file referenced by the symbolic link named
+The string specified via
+\fB\-\-with\-malloc\-conf\fR, the string pointed to by the global variable
+\fImalloc_conf\fR, the
+\(lqname\(rq
+of the file referenced by the symbolic link named
 /etc/malloc\&.conf, and the value of the environment variable
 \fBMALLOC_CONF\fR, will be interpreted, in that order, from left to right as options\&. Note that
 \fImalloc_conf\fR
 may be read before
-\fBmain\fR\fB\fR
+main()
 is entered, so the declaration of
 \fImalloc_conf\fR
 should specify an initializer that contains the final value to be read by jemalloc\&.
+\fB\-\-with\-malloc\-conf\fR
+and
 \fImalloc_conf\fR
-is a compile\-time setting, whereas
+are compile\-time mechanisms, whereas
 /etc/malloc\&.conf
 and
 \fBMALLOC_CONF\fR
 can be safely set any time prior to program invocation\&.
 .PP
 An options string is a comma\-separated list of option:value pairs\&. There is one key corresponding to each
-"opt\&.*"
+opt\&.*
 mallctl (see the
 MALLCTL NAMESPACE
 section for options documentation)\&. For example,
 abort:true,narenas:1
 sets the
-"opt\&.abort"
+opt\&.abort
 and
-"opt\&.narenas"
+opt\&.narenas
 options\&. Some options have boolean values (true/false), others have integer values (base 8, 10, or 16, depending on prefix), and yet others have raw string values\&.
 .SH "IMPLEMENTATION NOTES"
 .PP
 Traditionally, allocators have used
 \fBsbrk\fR(2)
 to obtain memory, which is suboptimal for several reasons, including race conditions, increased fragmentation, and artificial limitations on maximum usable memory\&. If
@@ -433,35 +457,32 @@
 This allocator uses multiple arenas in order to reduce lock contention for threaded programs on multi\-processor systems\&. This works well with regard to threading scalability, but incurs some costs\&. There is a small fixed per\-arena overhead, and additionally, arenas manage memory completely independently of each other, which means a small fixed increase in overall memory fragmentation\&. These overheads are not generally an issue, given the number of arenas normally used\&. Note that using substantially more arenas than the default is not likely to improve performance, mainly due to reduced cache performance\&. However, it may make sense to reduce the number of arenas if an application does not make much use of the allocation functions\&.
 .PP
 In addition to multiple arenas, unless
 \fB\-\-disable\-tcache\fR
 is specified during configuration, this allocator supports thread\-specific caching for small and large objects, in order to make it possible to completely avoid synchronization for most allocation requests\&. Such caching allows very fast allocation in the common case, but it increases memory usage and fragmentation, since a bounded number of objects can remain allocated in each thread cache\&.
 .PP
-Memory is conceptually broken into equal\-sized chunks, where the chunk size is a power of two that is greater than the page size\&. Chunks are always aligned to multiples of the chunk size\&. This alignment makes it possible to find metadata for user objects very quickly\&.
-.PP
-User objects are broken into three categories according to size: small, large, and huge\&. Small and large objects are managed entirely by arenas; huge objects are additionally aggregated in a single data structure that is shared by all threads\&. Huge objects are typically used by applications infrequently enough that this single data structure is not a scalability issue\&.
-.PP
-Each chunk that is managed by an arena tracks its contents as runs of contiguous pages (unused, backing a set of small objects, or backing one large object)\&. The combination of chunk alignment and chunk page maps makes it possible to determine all metadata regarding small and large allocations in constant time\&.
+Memory is conceptually broken into equal\-sized chunks, where the chunk size is a power of two that is greater than the page size\&. Chunks are always aligned to multiples of the chunk size\&. This alignment makes it possible to find metadata for user objects very quickly\&. User objects are broken into three categories according to size: small, large, and huge\&. Multiple small and large objects can reside within a single chunk, whereas huge objects each have one or more chunks backing them\&. Each chunk that contains small and/or large objects tracks its contents as runs of contiguous pages (unused, backing a set of small objects, or backing one large object)\&. The combination of chunk alignment and chunk page maps makes it possible to determine all metadata regarding small and large allocations in constant time\&.
 .PP
 Small objects are managed in groups by page runs\&. Each run maintains a bitmap to track which regions are in use\&. Allocation requests that are no more than half the quantum (8 or 16, depending on architecture) are rounded up to the nearest power of two that is at least
 sizeof(\fBdouble\fR)\&. All other object size classes are multiples of the quantum, spaced such that there are four size classes for each doubling in size, which limits internal fragmentation to approximately 20% for all but the smallest size classes\&. Small size classes are smaller than four times the page size, large size classes are smaller than the chunk size (see the
-"opt\&.lg_chunk"
-option), and huge size classes extend from the chunk size up to one size class less than the full address space size\&.
+opt\&.lg_chunk
+option), and huge size classes extend from the chunk size up to the largest size class that does not exceed
+\fBPTRDIFF_MAX\fR\&.
 .PP
 Allocations are packed tightly together, which can be an issue for multi\-threaded applications\&. If you need to assure that allocations do not suffer from cacheline sharing, round your allocation requests up to the nearest multiple of the cacheline size, or specify cacheline alignment when allocating\&.
 .PP
 The
-\fBrealloc\fR\fB\fR,
-\fBrallocx\fR\fB\fR, and
-\fBxallocx\fR\fB\fR
+realloc(),
+rallocx(), and
+xallocx()
 functions may resize allocations without moving them under limited circumstances\&. Unlike the
-\fB*allocx\fR\fB\fR
+*allocx()
 API, the standard API does not officially round up the usable size of an allocation to the nearest size class, so technically it is necessary to call
-\fBrealloc\fR\fB\fR
+realloc()
 to grow e\&.g\&. a 9\-byte allocation to 16 bytes, or shrink a 16\-byte allocation to 9 bytes\&. Growth and shrinkage trivially succeeds in place as long as the pre\-size and post\-size both round up to the same size class\&. No other API guarantees are made regarding in\-place resizing, but the current implementation also tries to resize large and huge allocations in place, as long as the pre\-size and post\-size are both large or both huge\&. In such cases shrinkage always succeeds for large size classes, but for huge size classes the chunk allocator must support splitting (see
-"arena\&.<i>\&.chunk_hooks")\&. Growth only succeeds if the trailing memory is currently available, and additionally for huge size classes the chunk allocator must support merging\&.
+arena\&.<i>\&.chunk_hooks)\&. Growth only succeeds if the trailing memory is currently available, and additionally for huge size classes the chunk allocator must support merging\&.
 .PP
 Assuming 2 MiB chunks, 4 KiB pages, and a 16\-byte quantum on a 64\-bit system, the size classes in each category are as shown in
 Table 1\&.
 .sp
 .it 1 an-trap
 .nr an-no-space-flag 1
@@ -499,12 +520,14 @@
 l r l
 ^ r l
 ^ r l
 ^ r l
 ^ r l
 ^ r l
+^ r l
+^ r l
 ^ r l.
 T{
 Small
 T}:T{
 lg
 T}:T{
@@ -626,231 +649,283 @@
 T}
 :T{
 \&.\&.\&.
 T}:T{
 \&.\&.\&.
 T}
+:T{
+512 PiB
+T}:T{
+[2560 PiB, 3 EiB, 3584 PiB, 4 EiB]
+T}
+:T{
+1 EiB
+T}:T{
+[5 EiB, 6 EiB, 7 EiB]
+T}
 .TE
 .sp 1
 .SH "MALLCTL NAMESPACE"
 .PP
 The following names are defined in the namespace accessible via the
-\fBmallctl*\fR\fB\fR
+mallctl*()
 functions\&. Value types are specified in parentheses, their readable/writable statuses are encoded as
 rw,
 r\-,
 \-w, or
 \-\-, and required build configuration flags follow, if any\&. A name element encoded as
 <i>
 or
 <j>
 indicates an integer component, where the integer varies from 0 to some upper value that must be determined via introspection\&. In the case of
-"stats\&.arenas\&.<i>\&.*",
+stats\&.arenas\&.<i>\&.*,
 <i>
 equal to
-"arenas\&.narenas"
+arenas\&.narenas
 can be used to access the summation of statistics from all arenas\&. Take special note of the
-"epoch"
+epoch
 mallctl, which controls refreshing of cached dynamic statistics\&.
 .PP
-"version" (\fBconst char *\fR) r\-
+version (\fBconst char *\fR) r\-
 .RS 4
 Return the jemalloc version string\&.
 .RE
 .PP
-"epoch" (\fBuint64_t\fR) rw
+epoch (\fBuint64_t\fR) rw
 .RS 4
 If a value is passed in, refresh the data from which the
-\fBmallctl*\fR\fB\fR
+mallctl*()
 functions report values, and increment the epoch\&. Return the current epoch\&. This is useful for detecting whether another thread caused a refresh\&.
 .RE
 .PP
-"config\&.cache_oblivious" (\fBbool\fR) r\-
+config\&.cache_oblivious (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-cache\-oblivious\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.debug" (\fBbool\fR) r\-
+config\&.debug (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-debug\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.fill" (\fBbool\fR) r\-
+config\&.fill (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-fill\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.lazy_lock" (\fBbool\fR) r\-
+config\&.lazy_lock (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-lazy\-lock\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.munmap" (\fBbool\fR) r\-
+config\&.malloc_conf (\fBconst char *\fR) r\-
+.RS 4
+Embedded configure\-time\-specified run\-time options string, empty unless
+\fB\-\-with\-malloc\-conf\fR
+was specified during build configuration\&.
+.RE
+.PP
+config\&.munmap (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-munmap\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.prof" (\fBbool\fR) r\-
+config\&.prof (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-prof\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.prof_libgcc" (\fBbool\fR) r\-
+config\&.prof_libgcc (\fBbool\fR) r\-
 .RS 4
 \fB\-\-disable\-prof\-libgcc\fR
 was not specified during build configuration\&.
 .RE
 .PP
-"config\&.prof_libunwind" (\fBbool\fR) r\-
+config\&.prof_libunwind (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-prof\-libunwind\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.stats" (\fBbool\fR) r\-
+config\&.stats (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-stats\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.tcache" (\fBbool\fR) r\-
+config\&.tcache (\fBbool\fR) r\-
 .RS 4
 \fB\-\-disable\-tcache\fR
 was not specified during build configuration\&.
 .RE
 .PP
-"config\&.tls" (\fBbool\fR) r\-
+config\&.tls (\fBbool\fR) r\-
 .RS 4
 \fB\-\-disable\-tls\fR
 was not specified during build configuration\&.
 .RE
 .PP
-"config\&.utrace" (\fBbool\fR) r\-
+config\&.utrace (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-utrace\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.valgrind" (\fBbool\fR) r\-
+config\&.valgrind (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-valgrind\fR
 was specified during build configuration\&.
 .RE
 .PP
-"config\&.xmalloc" (\fBbool\fR) r\-
+config\&.xmalloc (\fBbool\fR) r\-
 .RS 4
 \fB\-\-enable\-xmalloc\fR
 was specified during build configuration\&.
 .RE
 .PP
-"opt\&.abort" (\fBbool\fR) r\-
+opt\&.abort (\fBbool\fR) r\-
 .RS 4
 Abort\-on\-warning enabled/disabled\&. If true, most warnings are fatal\&. The process will call
 \fBabort\fR(3)
 in these cases\&. This option is disabled by default unless
 \fB\-\-enable\-debug\fR
 is specified during configuration, in which case it is enabled by default\&.
 .RE
 .PP
-"opt\&.dss" (\fBconst char *\fR) r\-
+opt\&.dss (\fBconst char *\fR) r\-
 .RS 4
 dss (\fBsbrk\fR(2)) allocation precedence as related to
 \fBmmap\fR(2)
 allocation\&. The following settings are supported if
 \fBsbrk\fR(2)
-is supported by the operating system: \(lqdisabled\(rq, \(lqprimary\(rq, and \(lqsecondary\(rq; otherwise only \(lqdisabled\(rq is supported\&. The default is \(lqsecondary\(rq if
+is supported by the operating system:
+\(lqdisabled\(rq,
+\(lqprimary\(rq, and
+\(lqsecondary\(rq; otherwise only
+\(lqdisabled\(rq
+is supported\&. The default is
+\(lqsecondary\(rq
+if
 \fBsbrk\fR(2)
-is supported by the operating system; \(lqdisabled\(rq otherwise\&.
+is supported by the operating system;
+\(lqdisabled\(rq
+otherwise\&.
 .RE
 .PP
-"opt\&.lg_chunk" (\fBsize_t\fR) r\-
+opt\&.lg_chunk (\fBsize_t\fR) r\-
 .RS 4
 Virtual memory chunk size (log base 2)\&. If a chunk size outside the supported size range is specified, the size is silently clipped to the minimum/maximum supported size\&. The default chunk size is 2 MiB (2^21)\&.
 .RE
 .PP
-"opt\&.narenas" (\fBsize_t\fR) r\-
+opt\&.narenas (\fBunsigned\fR) r\-
 .RS 4
 Maximum number of arenas to use for automatic multiplexing of threads and arenas\&. The default is four times the number of CPUs, or one if there is a single CPU\&.
 .RE
 .PP
-"opt\&.lg_dirty_mult" (\fBssize_t\fR) r\-
+opt\&.purge (\fBconst char *\fR) r\-
+.RS 4
+Purge mode is \(lqratio\(rq (default) or \(lqdecay\(rq\&. See
+opt\&.lg_dirty_mult
+for details of the ratio mode\&. See
+opt\&.decay_time
+for details of the decay mode\&.
+.RE
+.PP
+opt\&.lg_dirty_mult (\fBssize_t\fR) r\-
 .RS 4
 Per\-arena minimum ratio (log base 2) of active to dirty pages\&. Some dirty unused pages may be allowed to accumulate, within the limit set by the ratio (or one chunk worth of dirty pages, whichever is greater), before informing the kernel about some of those pages via
 \fBmadvise\fR(2)
 or a similar system call\&. This provides the kernel with sufficient information to recycle dirty pages if physical memory becomes scarce and the pages remain unused\&. The default minimum ratio is 8:1 (2^3:1); an option value of \-1 will disable dirty page purging\&. See
-"arenas\&.lg_dirty_mult"
+arenas\&.lg_dirty_mult
 and
-"arena\&.<i>\&.lg_dirty_mult"
+arena\&.<i>\&.lg_dirty_mult
 for related dynamic control options\&.
 .RE
 .PP
-"opt\&.stats_print" (\fBbool\fR) r\-
+opt\&.decay_time (\fBssize_t\fR) r\-
+.RS 4
+Approximate time in seconds from the creation of a set of unused dirty pages until an equivalent set of unused dirty pages is purged and/or reused\&. The pages are incrementally purged according to a sigmoidal decay curve that starts and ends with zero purge rate\&. A decay time of 0 causes all unused dirty pages to be purged immediately upon creation\&. A decay time of \-1 disables purging\&. The default decay time is 10 seconds\&. See
+arenas\&.decay_time
+and
+arena\&.<i>\&.decay_time
+for related dynamic control options\&.
+.RE
+.PP
+opt\&.stats_print (\fBbool\fR) r\-
 .RS 4
 Enable/disable statistics printing at exit\&. If enabled, the
-\fBmalloc_stats_print\fR\fB\fR
+malloc_stats_print()
 function is called at program exit via an
 \fBatexit\fR(3)
 function\&. If
 \fB\-\-enable\-stats\fR
 is specified during configuration, this has the potential to cause deadlock for a multi\-threaded process that exits while one or more threads are executing in the memory allocation functions\&. Furthermore,
-\fBatexit\fR\fB\fR
+atexit()
 may allocate memory during application initialization and then deadlock internally when jemalloc in turn calls
-\fBatexit\fR\fB\fR, so this option is not univerally usable (though the application can register its own
-\fBatexit\fR\fB\fR
+atexit(), so this option is not universally usable (though the application can register its own
+atexit()
 function with equivalent functionality)\&. Therefore, this option should only be used with care; it is primarily intended as a performance tuning aid during application development\&. This option is disabled by default\&.
 .RE
 .PP
-"opt\&.junk" (\fBconst char *\fR) r\- [\fB\-\-enable\-fill\fR]
+opt\&.junk (\fBconst char *\fR) r\- [\fB\-\-enable\-fill\fR]
 .RS 4
-Junk filling\&. If set to "alloc", each byte of uninitialized allocated memory will be initialized to
-0xa5\&. If set to "free", all deallocated memory will be initialized to
-0x5a\&. If set to "true", both allocated and deallocated memory will be initialized, and if set to "false", junk filling be disabled entirely\&. This is intended for debugging and will impact performance negatively\&. This option is "false" by default unless
+Junk filling\&. If set to
+\(lqalloc\(rq, each byte of uninitialized allocated memory will be initialized to
+0xa5\&. If set to
+\(lqfree\(rq, all deallocated memory will be initialized to
+0x5a\&. If set to
+\(lqtrue\(rq, both allocated and deallocated memory will be initialized, and if set to
+\(lqfalse\(rq, junk filling be disabled entirely\&. This is intended for debugging and will impact performance negatively\&. This option is
+\(lqfalse\(rq
+by default unless
 \fB\-\-enable\-debug\fR
-is specified during configuration, in which case it is "true" by default unless running inside
-\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2\&.
+is specified during configuration, in which case it is
+\(lqtrue\(rq
+by default unless running inside
+\m[blue]\fBValgrind\fR\m[]\&\s-2\u[3]\d\s+2\&.
 .RE
 .PP
-"opt\&.quarantine" (\fBsize_t\fR) r\- [\fB\-\-enable\-fill\fR]
+opt\&.quarantine (\fBsize_t\fR) r\- [\fB\-\-enable\-fill\fR]
 .RS 4
 Per thread quarantine size in bytes\&. If non\-zero, each thread maintains a FIFO object quarantine that stores up to the specified number of bytes of memory\&. The quarantined memory is not freed until it is released from quarantine, though it is immediately junk\-filled if the
-"opt\&.junk"
+opt\&.junk
 option is enabled\&. This feature is of particular use in combination with
-\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, which can detect attempts to access quarantined objects\&. This is intended for debugging and will impact performance negatively\&. The default quarantine size is 0 unless running inside Valgrind, in which case the default is 16 MiB\&.
+\m[blue]\fBValgrind\fR\m[]\&\s-2\u[3]\d\s+2, which can detect attempts to access quarantined objects\&. This is intended for debugging and will impact performance negatively\&. The default quarantine size is 0 unless running inside Valgrind, in which case the default is 16 MiB\&.
 .RE
 .PP
-"opt\&.redzone" (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
+opt\&.redzone (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
 .RS 4
 Redzones enabled/disabled\&. If enabled, small allocations have redzones before and after them\&. Furthermore, if the
-"opt\&.junk"
+opt\&.junk
 option is enabled, the redzones are checked for corruption during deallocation\&. However, the primary intended purpose of this feature is to be used in combination with
-\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, which needs redzones in order to do effective buffer overflow/underflow detection\&. This option is intended for debugging and will impact performance negatively\&. This option is disabled by default unless running inside Valgrind\&.
+\m[blue]\fBValgrind\fR\m[]\&\s-2\u[3]\d\s+2, which needs redzones in order to do effective buffer overflow/underflow detection\&. This option is intended for debugging and will impact performance negatively\&. This option is disabled by default unless running inside Valgrind\&.
 .RE
 .PP
-"opt\&.zero" (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
+opt\&.zero (\fBbool\fR) r\- [\fB\-\-enable\-fill\fR]
 .RS 4
 Zero filling enabled/disabled\&. If enabled, each byte of uninitialized allocated memory will be initialized to 0\&. Note that this initialization only happens once for each byte, so
-\fBrealloc\fR\fB\fR
+realloc()
 and
-\fBrallocx\fR\fB\fR
+rallocx()
 calls do not zero memory that was previously allocated\&. This is intended for debugging and will impact performance negatively\&. This option is disabled by default\&.
 .RE
 .PP
-"opt\&.utrace" (\fBbool\fR) r\- [\fB\-\-enable\-utrace\fR]
+opt\&.utrace (\fBbool\fR) r\- [\fB\-\-enable\-utrace\fR]
 .RS 4
 Allocation tracing based on
 \fButrace\fR(2)
 enabled/disabled\&. This option is disabled by default\&.
 .RE
 .PP
-"opt\&.xmalloc" (\fBbool\fR) r\- [\fB\-\-enable\-xmalloc\fR]
+opt\&.xmalloc (\fBbool\fR) r\- [\fB\-\-enable\-xmalloc\fR]
 .RS 4
 Abort\-on\-out\-of\-memory enabled/disabled\&. If enabled, rather than returning failure for any allocation function, display a diagnostic message on
 \fBSTDERR_FILENO\fR
 and cause the program to drop core (using
 \fBabort\fR(3))\&. If an application is designed to depend on this behavior, set the option at compile time by including the following in the source code:
 .sp
@@ -864,226 +939,251 @@
 .RE
 .\}
 .sp
 This option is disabled by default\&.
 .RE
 .PP
-"opt\&.tcache" (\fBbool\fR) r\- [\fB\-\-enable\-tcache\fR]
+opt\&.tcache (\fBbool\fR) r\- [\fB\-\-enable\-tcache\fR]
 .RS 4
 Thread\-specific caching (tcache) enabled/disabled\&. When there are multiple threads, each thread uses a tcache for objects up to a certain size\&. Thread\-specific caching allows many allocations to be satisfied without performing any thread synchronization, at the cost of increased memory use\&. See the
-"opt\&.lg_tcache_max"
+opt\&.lg_tcache_max
 option for related tuning information\&. This option is enabled by default unless running inside
-\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2, in which case it is forcefully disabled\&.
+\m[blue]\fBValgrind\fR\m[]\&\s-2\u[3]\d\s+2, in which case it is forcefully disabled\&.
 .RE
 .PP
-"opt\&.lg_tcache_max" (\fBsize_t\fR) r\- [\fB\-\-enable\-tcache\fR]
+opt\&.lg_tcache_max (\fBsize_t\fR) r\- [\fB\-\-enable\-tcache\fR]
 .RS 4
 Maximum size class (log base 2) to cache in the thread\-specific cache (tcache)\&. At a minimum, all small size classes are cached, and at a maximum all large size classes are cached\&. The default maximum is 32 KiB (2^15)\&.
 .RE
 .PP
-"opt\&.prof" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.prof (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Memory profiling enabled/disabled\&. If enabled, profile memory allocation activity\&. See the
-"opt\&.prof_active"
+opt\&.prof_active
 option for on\-the\-fly activation/deactivation\&. See the
-"opt\&.lg_prof_sample"
+opt\&.lg_prof_sample
 option for probabilistic sampling control\&. See the
-"opt\&.prof_accum"
+opt\&.prof_accum
 option for control of cumulative sample reporting\&. See the
-"opt\&.lg_prof_interval"
+opt\&.lg_prof_interval
 option for information on interval\-triggered profile dumping, the
-"opt\&.prof_gdump"
+opt\&.prof_gdump
 option for information on high\-water\-triggered profile dumping, and the
-"opt\&.prof_final"
+opt\&.prof_final
 option for final profile dumping\&. Profile output is compatible with the
 \fBjeprof\fR
 command, which is based on the
 \fBpprof\fR
 that is developed as part of the
-\m[blue]\fBgperftools package\fR\m[]\&\s-2\u[3]\d\s+2\&.
+\m[blue]\fBgperftools package\fR\m[]\&\s-2\u[4]\d\s+2\&. See
+HEAP PROFILE FORMAT
+for heap profile format documentation\&.
 .RE
 .PP
-"opt\&.prof_prefix" (\fBconst char *\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.prof_prefix (\fBconst char *\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Filename prefix for profile dumps\&. If the prefix is set to the empty string, no automatic dumps will occur; this is primarily useful for disabling the automatic final heap dump (which also disables leak reporting, if enabled)\&. The default prefix is
 jeprof\&.
 .RE
 .PP
-"opt\&.prof_active" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.prof_active (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Profiling activated/deactivated\&. This is a secondary control mechanism that makes it possible to start the application with profiling enabled (see the
-"opt\&.prof"
+opt\&.prof
 option) but inactive, then toggle profiling at any time during program execution with the
-"prof\&.active"
+prof\&.active
 mallctl\&. This option is enabled by default\&.
 .RE
 .PP
-"opt\&.prof_thread_active_init" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.prof_thread_active_init (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Initial setting for
-"thread\&.prof\&.active"
+thread\&.prof\&.active
 in newly created threads\&. The initial setting for newly created threads can also be changed during execution via the
-"prof\&.thread_active_init"
+prof\&.thread_active_init
 mallctl\&. This option is enabled by default\&.
 .RE
 .PP
-"opt\&.lg_prof_sample" (\fBsize_t\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.lg_prof_sample (\fBsize_t\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Average interval (log base 2) between allocation samples, as measured in bytes of allocation activity\&. Increasing the sampling interval decreases profile fidelity, but also decreases the computational overhead\&. The default sample interval is 512 KiB (2^19 B)\&.
 .RE
 .PP
-"opt\&.prof_accum" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.prof_accum (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Reporting of cumulative object/byte counts in profile dumps enabled/disabled\&. If this option is enabled, every unique backtrace must be stored for the duration of execution\&. Depending on the application, this can impose a large memory overhead, and the cumulative counts are not always of interest\&. This option is disabled by default\&.
 .RE
 .PP
-"opt\&.lg_prof_interval" (\fBssize_t\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.lg_prof_interval (\fBssize_t\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Average interval (log base 2) between memory profile dumps, as measured in bytes of allocation activity\&. The actual interval between dumps may be sporadic because decentralized allocation counters are used to avoid synchronization bottlenecks\&. Profiles are dumped to files named according to the pattern
 <prefix>\&.<pid>\&.<seq>\&.i<iseq>\&.heap, where
 <prefix>
 is controlled by the
-"opt\&.prof_prefix"
+opt\&.prof_prefix
 option\&. By default, interval\-triggered profile dumping is disabled (encoded as \-1)\&.
 .RE
 .PP
-"opt\&.prof_gdump" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.prof_gdump (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Set the initial state of
-"prof\&.gdump", which when enabled triggers a memory profile dump every time the total virtual memory exceeds the previous maximum\&. This option is disabled by default\&.
+prof\&.gdump, which when enabled triggers a memory profile dump every time the total virtual memory exceeds the previous maximum\&. This option is disabled by default\&.
 .RE
 .PP
-"opt\&.prof_final" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.prof_final (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Use an
 \fBatexit\fR(3)
 function to dump final memory usage to a file named according to the pattern
 <prefix>\&.<pid>\&.<seq>\&.f\&.heap, where
 <prefix>
 is controlled by the
-"opt\&.prof_prefix"
+opt\&.prof_prefix
 option\&. Note that
-\fBatexit\fR\fB\fR
+atexit()
 may allocate memory during application initialization and then deadlock internally when jemalloc in turn calls
-\fBatexit\fR\fB\fR, so this option is not univerally usable (though the application can register its own
-\fBatexit\fR\fB\fR
+atexit(), so this option is not universally usable (though the application can register its own
+atexit()
 function with equivalent functionality)\&. This option is disabled by default\&.
 .RE
 .PP
-"opt\&.prof_leak" (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
+opt\&.prof_leak (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Leak reporting enabled/disabled\&. If enabled, use an
 \fBatexit\fR(3)
 function to report memory leaks detected by allocation sampling\&. See the
-"opt\&.prof"
+opt\&.prof
 option for information on analyzing heap profile output\&. This option is disabled by default\&.
 .RE
 .PP
-"thread\&.arena" (\fBunsigned\fR) rw
+thread\&.arena (\fBunsigned\fR) rw
 .RS 4
 Get or set the arena associated with the calling thread\&. If the specified arena was not initialized beforehand (see the
-"arenas\&.initialized"
+arenas\&.initialized
 mallctl), it will be automatically initialized as a side effect of calling this interface\&.
 .RE
 .PP
-"thread\&.allocated" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+thread\&.allocated (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Get the total number of bytes ever allocated by the calling thread\&. This counter has the potential to wrap around; it is up to the application to appropriately interpret the counter in such cases\&.
 .RE
 .PP
-"thread\&.allocatedp" (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
+thread\&.allocatedp (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Get a pointer to the the value that is returned by the
-"thread\&.allocated"
+thread\&.allocated
 mallctl\&. This is useful for avoiding the overhead of repeated
-\fBmallctl*\fR\fB\fR
+mallctl*()
 calls\&.
 .RE
 .PP
-"thread\&.deallocated" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+thread\&.deallocated (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Get the total number of bytes ever deallocated by the calling thread\&. This counter has the potential to wrap around; it is up to the application to appropriately interpret the counter in such cases\&.
 .RE
 .PP
-"thread\&.deallocatedp" (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
+thread\&.deallocatedp (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Get a pointer to the the value that is returned by the
-"thread\&.deallocated"
+thread\&.deallocated
 mallctl\&. This is useful for avoiding the overhead of repeated
-\fBmallctl*\fR\fB\fR
+mallctl*()
 calls\&.
 .RE
 .PP
-"thread\&.tcache\&.enabled" (\fBbool\fR) rw [\fB\-\-enable\-tcache\fR]
+thread\&.tcache\&.enabled (\fBbool\fR) rw [\fB\-\-enable\-tcache\fR]
 .RS 4
 Enable/disable calling thread\*(Aqs tcache\&. The tcache is implicitly flushed as a side effect of becoming disabled (see
-"thread\&.tcache\&.flush")\&.
+thread\&.tcache\&.flush)\&.
 .RE
 .PP
-"thread\&.tcache\&.flush" (\fBvoid\fR) \-\- [\fB\-\-enable\-tcache\fR]
+thread\&.tcache\&.flush (\fBvoid\fR) \-\- [\fB\-\-enable\-tcache\fR]
 .RS 4
 Flush calling thread\*(Aqs thread\-specific cache (tcache)\&. This interface releases all cached objects and internal data structures associated with the calling thread\*(Aqs tcache\&. Ordinarily, this interface need not be called, since automatic periodic incremental garbage collection occurs, and the thread cache is automatically discarded when a thread exits\&. However, garbage collection is triggered by allocation activity, so it is possible for a thread that stops allocating/deallocating to retain its cache indefinitely, in which case the developer may find manual flushing useful\&.
 .RE
 .PP
-"thread\&.prof\&.name" (\fBconst char *\fR) r\- or \-w [\fB\-\-enable\-prof\fR]
+thread\&.prof\&.name (\fBconst char *\fR) r\- or \-w [\fB\-\-enable\-prof\fR]
 .RS 4
-Get/set the descriptive name associated with the calling thread in memory profile dumps\&. An internal copy of the name string is created, so the input string need not be maintained after this interface completes execution\&. The output string of this interface should be copied for non\-ephemeral uses, because multiple implementation details can cause asynchronous string deallocation\&. Furthermore, each invocation of this interface can only read or write; simultaneous read/write is not supported due to string lifetime limitations\&. The name string must nil\-terminated and comprised only of characters in the sets recognized by
+Get/set the descriptive name associated with the calling thread in memory profile dumps\&. An internal copy of the name string is created, so the input string need not be maintained after this interface completes execution\&. The output string of this interface should be copied for non\-ephemeral uses, because multiple implementation details can cause asynchronous string deallocation\&. Furthermore, each invocation of this interface can only read or write; simultaneous read/write is not supported due to string lifetime limitations\&. The name string must be nil\-terminated and comprised only of characters in the sets recognized by
 \fBisgraph\fR(3)
 and
 \fBisblank\fR(3)\&.
 .RE
 .PP
-"thread\&.prof\&.active" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
+thread\&.prof\&.active (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
 .RS 4
 Control whether sampling is currently active for the calling thread\&. This is an activation mechanism in addition to
-"prof\&.active"; both must be active for the calling thread to sample\&. This flag is enabled by default\&.
+prof\&.active; both must be active for the calling thread to sample\&. This flag is enabled by default\&.
 .RE
 .PP
-"tcache\&.create" (\fBunsigned\fR) r\- [\fB\-\-enable\-tcache\fR]
+tcache\&.create (\fBunsigned\fR) r\- [\fB\-\-enable\-tcache\fR]
 .RS 4
 Create an explicit thread\-specific cache (tcache) and return an identifier that can be passed to the
 \fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR
 macro to explicitly use the specified cache rather than the automatically managed one that is used by default\&. Each explicit cache can be used by only one thread at a time; the application must assure that this constraint holds\&.
 .RE
 .PP
-"tcache\&.flush" (\fBunsigned\fR) \-w [\fB\-\-enable\-tcache\fR]
+tcache\&.flush (\fBunsigned\fR) \-w [\fB\-\-enable\-tcache\fR]
 .RS 4
 Flush the specified thread\-specific cache (tcache)\&. The same considerations apply to this interface as to
-"thread\&.tcache\&.flush", except that the tcache will never be automatically be discarded\&.
+thread\&.tcache\&.flush, except that the tcache will never be automatically discarded\&.
 .RE
 .PP
-"tcache\&.destroy" (\fBunsigned\fR) \-w [\fB\-\-enable\-tcache\fR]
+tcache\&.destroy (\fBunsigned\fR) \-w [\fB\-\-enable\-tcache\fR]
 .RS 4
 Flush the specified thread\-specific cache (tcache) and make the identifier available for use during a future tcache creation\&.
 .RE
 .PP
-"arena\&.<i>\&.purge" (\fBvoid\fR) \-\-
+arena\&.<i>\&.purge (\fBvoid\fR) \-\-
 .RS 4
-Purge unused dirty pages for arena <i>, or for all arenas if <i> equals
-"arenas\&.narenas"\&.
+Purge all unused dirty pages for arena <i>, or for all arenas if <i> equals
+arenas\&.narenas\&.
+.RE
+.PP
+arena\&.<i>\&.decay (\fBvoid\fR) \-\-
+.RS 4
+Trigger decay\-based purging of unused dirty pages for arena <i>, or for all arenas if <i> equals
+arenas\&.narenas\&. The proportion of unused dirty pages to be purged depends on the current time; see
+opt\&.decay_time
+for details\&.
 .RE
 .PP
-"arena\&.<i>\&.dss" (\fBconst char *\fR) rw
+arena\&.<i>\&.reset (\fBvoid\fR) \-\-
+.RS 4
+Discard all of the arena\*(Aqs extant allocations\&. This interface can only be used with arenas created via
+arenas\&.extend\&. None of the arena\*(Aqs discarded/cached allocations may accessed afterward\&. As part of this requirement, all thread caches which were used to allocate/deallocate in conjunction with the arena must be flushed beforehand\&. This interface cannot be used if running inside Valgrind, nor if the
+quarantine
+size is non\-zero\&.
+.RE
+.PP
+arena\&.<i>\&.dss (\fBconst char *\fR) rw
 .RS 4
 Set the precedence of dss allocation as related to mmap allocation for arena <i>, or for all arenas if <i> equals
-"arenas\&.narenas"\&. See
-"opt\&.dss"
+arenas\&.narenas\&. See
+opt\&.dss
 for supported settings\&.
 .RE
 .PP
-"arena\&.<i>\&.lg_dirty_mult" (\fBssize_t\fR) rw
+arena\&.<i>\&.lg_dirty_mult (\fBssize_t\fR) rw
 .RS 4
 Current per\-arena minimum ratio (log base 2) of active to dirty pages for arena <i>\&. Each time this interface is set and the ratio is increased, pages are synchronously purged as necessary to impose the new ratio\&. See
-"opt\&.lg_dirty_mult"
+opt\&.lg_dirty_mult
+for additional information\&.
+.RE
+.PP
+arena\&.<i>\&.decay_time (\fBssize_t\fR) rw
+.RS 4
+Current per\-arena approximate time in seconds from the creation of a set of unused dirty pages until an equivalent set of unused dirty pages is purged and/or reused\&. Each time this interface is set, all currently unused dirty pages are considered to have fully decayed, which causes immediate purging of all unused dirty pages unless the decay time is set to \-1 (i\&.e\&. purging disabled)\&. See
+opt\&.decay_time
 for additional information\&.
 .RE
 .PP
-"arena\&.<i>\&.chunk_hooks" (\fBchunk_hooks_t\fR) rw
+arena\&.<i>\&.chunk_hooks (\fBchunk_hooks_t\fR) rw
 .RS 4
 Get or set the chunk management hook functions for arena <i>\&. The functions must be capable of operating on all extant chunks associated with arena <i>, usually by passing unknown chunks to the replaced functions\&. In practice, it is feasible to control allocation for arenas created via
-"arenas\&.extend"
+arenas\&.extend
 such that all chunks originate from an application\-supplied chunk allocator (by setting custom chunk hook functions just after arena creation), but the automatically created arenas may have already created chunks prior to the application having an opportunity to take over chunk allocation\&.
 .sp
 .if n \{\
 .RS 4
 .\}
 .nf
@@ -1146,13 +1246,13 @@
 is not
 \fBNULL\fR, the returned pointer must be
 \fIchunk\fR
 on success or
 \fBNULL\fR
 on error\&. Committed memory may be committed in absolute terms as on a system that does not overcommit, or in implicit terms as on a system that overcommits and satisfies physical memory needs on demand via soft page faults\&. Note that replacing the default chunk allocation function makes the arena\*(Aqs
-"arena\&.<i>\&.dss"
+arena\&.<i>\&.dss
 setting irrelevant\&.
 .HP \w'typedef\ bool\ (chunk_dalloc_t)('u
 .BI "typedef bool (chunk_dalloc_t)(void\ *" "chunk" ", size_t\ " "size" ", bool\ " "committed" ", unsigned\ " "arena_ind" ");"
 .sp
 .if n \{\
 .RS 4
@@ -1293,471 +1393,571 @@
 \fIsize_b\fR
 into one contiguous chunk, operating on
 \fIcommitted\fR/decommitted memory as indicated, on behalf of arena
 \fIarena_ind\fR, returning false upon success\&. If the function returns true, this indicates that the chunks remain distinct mappings and therefore should continue to be operated on independently\&.
 .RE
 .PP
-"arenas\&.narenas" (\fBunsigned\fR) r\-
+arenas\&.narenas (\fBunsigned\fR) r\-
 .RS 4
 Current limit on number of arenas\&.
 .RE
 .PP
-"arenas\&.initialized" (\fBbool *\fR) r\-
+arenas\&.initialized (\fBbool *\fR) r\-
 .RS 4
 An array of
-"arenas\&.narenas"
+arenas\&.narenas
 booleans\&. Each boolean indicates whether the corresponding arena is initialized\&.
 .RE
 .PP
-"arenas\&.lg_dirty_mult" (\fBssize_t\fR) rw
+arenas\&.lg_dirty_mult (\fBssize_t\fR) rw
 .RS 4
 Current default per\-arena minimum ratio (log base 2) of active to dirty pages, used to initialize
-"arena\&.<i>\&.lg_dirty_mult"
+arena\&.<i>\&.lg_dirty_mult
 during arena creation\&. See
-"opt\&.lg_dirty_mult"
+opt\&.lg_dirty_mult
 for additional information\&.
 .RE
 .PP
-"arenas\&.quantum" (\fBsize_t\fR) r\-
+arenas\&.decay_time (\fBssize_t\fR) rw
+.RS 4
+Current default per\-arena approximate time in seconds from the creation of a set of unused dirty pages until an equivalent set of unused dirty pages is purged and/or reused, used to initialize
+arena\&.<i>\&.decay_time
+during arena creation\&. See
+opt\&.decay_time
+for additional information\&.
+.RE
+.PP
+arenas\&.quantum (\fBsize_t\fR) r\-
 .RS 4
 Quantum size\&.
 .RE
 .PP
-"arenas\&.page" (\fBsize_t\fR) r\-
+arenas\&.page (\fBsize_t\fR) r\-
 .RS 4
 Page size\&.
 .RE
 .PP
-"arenas\&.tcache_max" (\fBsize_t\fR) r\- [\fB\-\-enable\-tcache\fR]
+arenas\&.tcache_max (\fBsize_t\fR) r\- [\fB\-\-enable\-tcache\fR]
 .RS 4
 Maximum thread\-cached size class\&.
 .RE
 .PP
-"arenas\&.nbins" (\fBunsigned\fR) r\-
+arenas\&.nbins (\fBunsigned\fR) r\-
 .RS 4
 Number of bin size classes\&.
 .RE
 .PP
-"arenas\&.nhbins" (\fBunsigned\fR) r\- [\fB\-\-enable\-tcache\fR]
+arenas\&.nhbins (\fBunsigned\fR) r\- [\fB\-\-enable\-tcache\fR]
 .RS 4
 Total number of thread cache bin size classes\&.
 .RE
 .PP
-"arenas\&.bin\&.<i>\&.size" (\fBsize_t\fR) r\-
+arenas\&.bin\&.<i>\&.size (\fBsize_t\fR) r\-
 .RS 4
 Maximum size supported by size class\&.
 .RE
 .PP
-"arenas\&.bin\&.<i>\&.nregs" (\fBuint32_t\fR) r\-
+arenas\&.bin\&.<i>\&.nregs (\fBuint32_t\fR) r\-
 .RS 4
 Number of regions per page run\&.
 .RE
 .PP
-"arenas\&.bin\&.<i>\&.run_size" (\fBsize_t\fR) r\-
+arenas\&.bin\&.<i>\&.run_size (\fBsize_t\fR) r\-
 .RS 4
 Number of bytes per page run\&.
 .RE
 .PP
-"arenas\&.nlruns" (\fBunsigned\fR) r\-
+arenas\&.nlruns (\fBunsigned\fR) r\-
 .RS 4
 Total number of large size classes\&.
 .RE
 .PP
-"arenas\&.lrun\&.<i>\&.size" (\fBsize_t\fR) r\-
+arenas\&.lrun\&.<i>\&.size (\fBsize_t\fR) r\-
 .RS 4
 Maximum size supported by this large size class\&.
 .RE
 .PP
-"arenas\&.nhchunks" (\fBunsigned\fR) r\-
+arenas\&.nhchunks (\fBunsigned\fR) r\-
 .RS 4
 Total number of huge size classes\&.
 .RE
 .PP
-"arenas\&.hchunk\&.<i>\&.size" (\fBsize_t\fR) r\-
+arenas\&.hchunk\&.<i>\&.size (\fBsize_t\fR) r\-
 .RS 4
 Maximum size supported by this huge size class\&.
 .RE
 .PP
-"arenas\&.extend" (\fBunsigned\fR) r\-
+arenas\&.extend (\fBunsigned\fR) r\-
 .RS 4
 Extend the array of arenas by appending a new arena, and returning the new arena index\&.
 .RE
 .PP
-"prof\&.thread_active_init" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
+prof\&.thread_active_init (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
 .RS 4
 Control the initial setting for
-"thread\&.prof\&.active"
+thread\&.prof\&.active
 in newly created threads\&. See the
-"opt\&.prof_thread_active_init"
+opt\&.prof_thread_active_init
 option for additional information\&.
 .RE
 .PP
-"prof\&.active" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
+prof\&.active (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
 .RS 4
 Control whether sampling is currently active\&. See the
-"opt\&.prof_active"
+opt\&.prof_active
 option for additional information, as well as the interrelated
-"thread\&.prof\&.active"
+thread\&.prof\&.active
 mallctl\&.
 .RE
 .PP
-"prof\&.dump" (\fBconst char *\fR) \-w [\fB\-\-enable\-prof\fR]
+prof\&.dump (\fBconst char *\fR) \-w [\fB\-\-enable\-prof\fR]
 .RS 4
 Dump a memory profile to the specified file, or if NULL is specified, to a file according to the pattern
 <prefix>\&.<pid>\&.<seq>\&.m<mseq>\&.heap, where
 <prefix>
 is controlled by the
-"opt\&.prof_prefix"
+opt\&.prof_prefix
 option\&.
 .RE
 .PP
-"prof\&.gdump" (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
+prof\&.gdump (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
 .RS 4
 When enabled, trigger a memory profile dump every time the total virtual memory exceeds the previous maximum\&. Profiles are dumped to files named according to the pattern
 <prefix>\&.<pid>\&.<seq>\&.u<useq>\&.heap, where
 <prefix>
 is controlled by the
-"opt\&.prof_prefix"
+opt\&.prof_prefix
 option\&.
 .RE
 .PP
-"prof\&.reset" (\fBsize_t\fR) \-w [\fB\-\-enable\-prof\fR]
+prof\&.reset (\fBsize_t\fR) \-w [\fB\-\-enable\-prof\fR]
 .RS 4
 Reset all memory profile statistics, and optionally update the sample rate (see
-"opt\&.lg_prof_sample"
+opt\&.lg_prof_sample
 and
-"prof\&.lg_sample")\&.
+prof\&.lg_sample)\&.
 .RE
 .PP
-"prof\&.lg_sample" (\fBsize_t\fR) r\- [\fB\-\-enable\-prof\fR]
+prof\&.lg_sample (\fBsize_t\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
 Get the current sample rate (see
-"opt\&.lg_prof_sample")\&.
+opt\&.lg_prof_sample)\&.
 .RE
 .PP
-"prof\&.interval" (\fBuint64_t\fR) r\- [\fB\-\-enable\-prof\fR]
+prof\&.interval (\fBuint64_t\fR) r\- [\fB\-\-enable\-prof\fR]
 .RS 4
-Average number of bytes allocated between inverval\-based profile dumps\&. See the
-"opt\&.lg_prof_interval"
+Average number of bytes allocated between interval\-based profile dumps\&. See the
+opt\&.lg_prof_interval
 option for additional information\&.
 .RE
 .PP
-"stats\&.cactive" (\fBsize_t *\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.cactive (\fBsize_t *\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Pointer to a counter that contains an approximate count of the current number of bytes in active pages\&. The estimate may be high, but never low, because each arena rounds up when computing its contribution to the counter\&. Note that the
-"epoch"
+epoch
 mallctl has no bearing on this counter\&. Furthermore, counter consistency is maintained via atomic operations, so it is necessary to use an atomic operation in order to guarantee a consistent read when dereferencing the pointer\&.
 .RE
 .PP
-"stats\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.allocated (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Total number of bytes allocated by the application\&.
 .RE
 .PP
-"stats\&.active" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.active (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Total number of bytes in active pages allocated by the application\&. This is a multiple of the page size, and greater than or equal to
-"stats\&.allocated"\&. This does not include
-"stats\&.arenas\&.<i>\&.pdirty", nor pages entirely devoted to allocator metadata\&.
+stats\&.allocated\&. This does not include
+stats\&.arenas\&.<i>\&.pdirty, nor pages entirely devoted to allocator metadata\&.
 .RE
 .PP
-"stats\&.metadata" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.metadata (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Total number of bytes dedicated to metadata, which comprise base allocations used for bootstrap\-sensitive internal allocator data structures, arena chunk headers (see
-"stats\&.arenas\&.<i>\&.metadata\&.mapped"), and internal allocations (see
-"stats\&.arenas\&.<i>\&.metadata\&.allocated")\&.
+stats\&.arenas\&.<i>\&.metadata\&.mapped), and internal allocations (see
+stats\&.arenas\&.<i>\&.metadata\&.allocated)\&.
 .RE
 .PP
-"stats\&.resident" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.resident (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Maximum number of bytes in physically resident data pages mapped by the allocator, comprising all pages dedicated to allocator metadata, pages backing active allocations, and unused dirty pages\&. This is a maximum rather than precise because pages may not actually be physically resident if they correspond to demand\-zeroed virtual memory that has not yet been touched\&. This is a multiple of the page size, and is larger than
-"stats\&.active"\&.
+stats\&.active\&.
 .RE
 .PP
-"stats\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.mapped (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Total number of bytes in active chunks mapped by the allocator\&. This is a multiple of the chunk size, and is larger than
-"stats\&.active"\&. This does not include inactive chunks, even those that contain unused dirty pages, which means that there is no strict ordering between this and
-"stats\&.resident"\&.
+stats\&.active\&. This does not include inactive chunks, even those that contain unused dirty pages, which means that there is no strict ordering between this and
+stats\&.resident\&.
+.RE
+.PP
+stats\&.retained (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Total number of bytes in virtual memory mappings that were retained rather than being returned to the operating system via e\&.g\&.
+\fBmunmap\fR(2)\&. Retained virtual memory is typically untouched, decommitted, or purged, so it has no strongly associated physical memory (see
+chunk hooks
+for details)\&. Retained memory is excluded from mapped memory statistics, e\&.g\&.
+stats\&.mapped\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.dss" (\fBconst char *\fR) r\-
+stats\&.arenas\&.<i>\&.dss (\fBconst char *\fR) r\-
 .RS 4
 dss (\fBsbrk\fR(2)) allocation precedence as related to
 \fBmmap\fR(2)
 allocation\&. See
-"opt\&.dss"
+opt\&.dss
 for details\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.lg_dirty_mult" (\fBssize_t\fR) r\-
+stats\&.arenas\&.<i>\&.lg_dirty_mult (\fBssize_t\fR) r\-
 .RS 4
 Minimum ratio (log base 2) of active to dirty pages\&. See
-"opt\&.lg_dirty_mult"
+opt\&.lg_dirty_mult
 for details\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.nthreads" (\fBunsigned\fR) r\-
+stats\&.arenas\&.<i>\&.decay_time (\fBssize_t\fR) r\-
+.RS 4
+Approximate time in seconds from the creation of a set of unused dirty pages until an equivalent set of unused dirty pages is purged and/or reused\&. See
+opt\&.decay_time
+for details\&.
+.RE
+.PP
+stats\&.arenas\&.<i>\&.nthreads (\fBunsigned\fR) r\-
 .RS 4
 Number of threads currently assigned to arena\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.pactive" (\fBsize_t\fR) r\-
+stats\&.arenas\&.<i>\&.pactive (\fBsize_t\fR) r\-
 .RS 4
 Number of pages in active runs\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.pdirty" (\fBsize_t\fR) r\-
+stats\&.arenas\&.<i>\&.pdirty (\fBsize_t\fR) r\-
 .RS 4
 Number of pages within unused runs that are potentially dirty, and for which
-\fBmadvise\fR\fB\fI\&.\&.\&.\fR\fR\fB \fR\fB\fI\fBMADV_DONTNEED\fR\fR\fR
+madvise\fI\&.\&.\&.\fR \fI\fBMADV_DONTNEED\fR\fR
 or similar has not been called\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.mapped (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of mapped bytes\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.metadata\&.mapped" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.retained (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+.RS 4
+Number of retained bytes\&. See
+stats\&.retained
+for details\&.
+.RE
+.PP
+stats\&.arenas\&.<i>\&.metadata\&.mapped (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of mapped bytes in arena chunk headers, which track the states of the non\-metadata pages\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.metadata\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.metadata\&.allocated (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of bytes dedicated to internal allocations\&. Internal allocations differ from application\-originated allocations in that they are for internal use, and that they are omitted from heap profiles\&. This statistic is reported separately from
-"stats\&.metadata"
+stats\&.metadata
 and
-"stats\&.arenas\&.<i>\&.metadata\&.mapped"
+stats\&.arenas\&.<i>\&.metadata\&.mapped
 because it overlaps with e\&.g\&. the
-"stats\&.allocated"
+stats\&.allocated
 and
-"stats\&.active"
+stats\&.active
 statistics, whereas the other metadata statistics do not\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.npurge" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.npurge (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of dirty page purge sweeps performed\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.nmadvise" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.nmadvise (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of
-\fBmadvise\fR\fB\fI\&.\&.\&.\fR\fR\fB \fR\fB\fI\fBMADV_DONTNEED\fR\fR\fR
+madvise\fI\&.\&.\&.\fR \fI\fBMADV_DONTNEED\fR\fR
 or similar calls made to purge dirty pages\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.purged" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.purged (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of pages purged\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.small\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.small\&.allocated (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of bytes currently allocated by small objects\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.small\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.small\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocation requests served by small bins\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.small\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.small\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of small objects returned to bins\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.small\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.small\&.nrequests (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of small allocation requests\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.large\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.large\&.allocated (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of bytes currently allocated by large objects\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.large\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.large\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of large allocation requests served directly by the arena\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.large\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.large\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of large deallocation requests served directly by the arena\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.large\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.large\&.nrequests (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of large allocation requests\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.huge\&.allocated" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.huge\&.allocated (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Number of bytes currently allocated by huge objects\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.huge\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.huge\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of huge allocation requests served directly by the arena\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.huge\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.huge\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of huge deallocation requests served directly by the arena\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.huge\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.huge\&.nrequests (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of huge allocation requests\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.bins\&.<j>\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocations served by bin\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.bins\&.<j>\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocations returned to bin\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.bins\&.<j>\&.nrequests (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocation requests\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.curregs" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.bins\&.<j>\&.curregs (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Current number of regions for this size class\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nfills" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
+stats\&.arenas\&.<i>\&.bins\&.<j>\&.nfills (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
 .RS 4
 Cumulative number of tcache fills\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nflushes" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
+stats\&.arenas\&.<i>\&.bins\&.<j>\&.nflushes (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR \fB\-\-enable\-tcache\fR]
 .RS 4
 Cumulative number of tcache flushes\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nruns" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.bins\&.<j>\&.nruns (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of runs created\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.nreruns" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.bins\&.<j>\&.nreruns (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of times the current run from which to allocate changed\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.bins\&.<j>\&.curruns" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.bins\&.<j>\&.curruns (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Current number of runs\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.lruns\&.<j>\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocation requests for this size class served directly by the arena\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.lruns\&.<j>\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of deallocation requests for this size class served directly by the arena\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.lruns\&.<j>\&.nrequests (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocation requests for this size class\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.lruns\&.<j>\&.curruns" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.lruns\&.<j>\&.curruns (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Current number of runs for this size class\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.nmalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocation requests for this size class served directly by the arena\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.ndalloc" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of deallocation requests for this size class served directly by the arena\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.nrequests" (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.nrequests (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Cumulative number of allocation requests for this size class\&.
 .RE
 .PP
-"stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.curhchunks" (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
+stats\&.arenas\&.<i>\&.hchunks\&.<j>\&.curhchunks (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
 .RS 4
 Current number of huge allocations for this size class\&.
 .RE
+.SH "HEAP PROFILE FORMAT"
+.PP
+Although the heap profiling functionality was originally designed to be compatible with the
+\fBpprof\fR
+command that is developed as part of the
+\m[blue]\fBgperftools package\fR\m[]\&\s-2\u[4]\d\s+2, the addition of per thread heap profiling functionality required a different heap profile format\&. The
+\fBjeprof\fR
+command is derived from
+\fBpprof\fR, with enhancements to support the heap profile format described here\&.
+.PP
+In the following hypothetical heap profile,
+\fB[\&.\&.\&.]\fR
+indicates elision for the sake of compactness\&.
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+heap_v2/524288
+  t*: 28106: 56637512 [0: 0]
+  [\&.\&.\&.]
+  t3: 352: 16777344 [0: 0]
+  [\&.\&.\&.]
+  t99: 17754: 29341640 [0: 0]
+  [\&.\&.\&.]
+@ 0x5f86da8 0x5f5a1dc [\&.\&.\&.] 0x29e4d4e 0xa200316 0xabb2988 [\&.\&.\&.]
+  t*: 13: 6688 [0: 0]
+  t3: 12: 6496 [0: ]
+  t99: 1: 192 [0: 0]
+[\&.\&.\&.]
+
+MAPPED_LIBRARIES:
+[\&.\&.\&.]
+.fi
+.if n \{\
+.RE
+.\}
+.sp
+The following matches the above heap profile, but most tokens are replaced with
+\fB<description>\fR
+to indicate descriptions of the corresponding fields\&.
+.sp
+.if n \{\
+.RS 4
+.\}
+.nf
+<heap_profile_format_version>/<mean_sample_interval>
+  <aggregate>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+  [\&.\&.\&.]
+  <thread_3_aggregate>: <curobjs>: <curbytes>[<cumobjs>: <cumbytes>]
+  [\&.\&.\&.]
+  <thread_99_aggregate>: <curobjs>: <curbytes>[<cumobjs>: <cumbytes>]
+  [\&.\&.\&.]
+@ <top_frame> <frame> [\&.\&.\&.] <frame> <frame> <frame> [\&.\&.\&.]
+  <backtrace_aggregate>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+  <backtrace_thread_3>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+  <backtrace_thread_99>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+[\&.\&.\&.]
+
+MAPPED_LIBRARIES:
+</proc/<pid>/maps>
+.fi
+.if n \{\
+.RE
+.\}
 .SH "DEBUGGING MALLOC PROBLEMS"
 .PP
 When debugging, it is a good idea to configure/build jemalloc with the
 \fB\-\-enable\-debug\fR
 and
 \fB\-\-enable\-fill\fR
 options, and recompile the program with suitable options and symbols for debugger support\&. When so configured, jemalloc incorporates a wide variety of run\-time assertions that catch application errors such as double\-free, write\-after\-free, etc\&.
 .PP
-Programs often accidentally depend on \(lquninitialized\(rq memory actually being filled with zero bytes\&. Junk filling (see the
-"opt\&.junk"
+Programs often accidentally depend on
+\(lquninitialized\(rq
+memory actually being filled with zero bytes\&. Junk filling (see the
+opt\&.junk
 option) tends to expose such bugs in the form of obviously incorrect results and/or coredumps\&. Conversely, zero filling (see the
-"opt\&.zero"
+opt\&.zero
 option) eliminates the symptoms of such bugs\&. Between these two options, it is usually possible to quickly detect, diagnose, and eliminate such bugs\&.
 .PP
 This implementation does not provide much detail about the problems it detects, because the performance impact for storing such information would be prohibitive\&. However, jemalloc does integrate with the most excellent
-\m[blue]\fBValgrind\fR\m[]\&\s-2\u[2]\d\s+2
+\m[blue]\fBValgrind\fR\m[]\&\s-2\u[3]\d\s+2
 tool if the
 \fB\-\-enable\-valgrind\fR
 configuration option is enabled\&.
 .SH "DIAGNOSTIC MESSAGES"
 .PP
 If any of the memory allocation/deallocation functions detect an error or warning condition, a message will be printed to file descriptor
 \fBSTDERR_FILENO\fR\&. Errors will result in the process dumping core\&. If the
-"opt\&.abort"
+opt\&.abort
 option is set, most warnings are treated as errors\&.
 .PP
 The
 \fImalloc_message\fR
 variable allows the programmer to override the function which emits the text strings forming the errors and warnings if for some reason the
 \fBSTDERR_FILENO\fR
 file descriptor is not suitable for this\&.
-\fBmalloc_message\fR\fB\fR
+malloc_message()
 takes the
 \fIcbopaque\fR
 pointer argument that is
 \fBNULL\fR
 unless overridden by the arguments in a call to
-\fBmalloc_stats_print\fR\fB\fR, followed by a string pointer\&. Please note that doing anything which tries to allocate memory in this function is likely to result in a crash or deadlock\&.
+malloc_stats_print(), followed by a string pointer\&. Please note that doing anything which tries to allocate memory in this function is likely to result in a crash or deadlock\&.
 .PP
-All messages are prefixed by \(lq<jemalloc>:\(rq\&.
+All messages are prefixed by
+\(lq<jemalloc>: \(rq\&.
 .SH "RETURN VALUES"
 .SS "Standard API"
 .PP
 The
-\fBmalloc\fR\fB\fR
+malloc()
 and
-\fBcalloc\fR\fB\fR
+calloc()
 functions return a pointer to the allocated memory if successful; otherwise a
 \fBNULL\fR
 pointer is returned and
 \fIerrno\fR
 is set to
 ENOMEM\&.
 .PP
 The
-\fBposix_memalign\fR\fB\fR
+posix_memalign()
 function returns the value 0 if successful; otherwise it returns an error value\&. The
-\fBposix_memalign\fR\fB\fR
+posix_memalign()
 function will fail if:
 .PP
 EINVAL
 .RS 4
 The
 \fIalignment\fR
@@ -1768,19 +1968,19 @@
 ENOMEM
 .RS 4
 Memory allocation error\&.
 .RE
 .PP
 The
-\fBaligned_alloc\fR\fB\fR
+aligned_alloc()
 function returns a pointer to the allocated memory if successful; otherwise a
 \fBNULL\fR
 pointer is returned and
 \fIerrno\fR
 is set\&. The
-\fBaligned_alloc\fR\fB\fR
+aligned_alloc()
 function will fail if:
 .PP
 EINVAL
 .RS 4
 The
 \fIalignment\fR
@@ -1790,59 +1990,59 @@
 ENOMEM
 .RS 4
 Memory allocation error\&.
 .RE
 .PP
 The
-\fBrealloc\fR\fB\fR
+realloc()
 function returns a pointer, possibly identical to
 \fIptr\fR, to the allocated memory if successful; otherwise a
 \fBNULL\fR
 pointer is returned, and
 \fIerrno\fR
 is set to
 ENOMEM
 if the error was the result of an allocation failure\&. The
-\fBrealloc\fR\fB\fR
+realloc()
 function always leaves the original buffer intact when an error occurs\&.
 .PP
 The
-\fBfree\fR\fB\fR
+free()
 function returns no value\&.
 .SS "Non\-standard API"
 .PP
 The
-\fBmallocx\fR\fB\fR
+mallocx()
 and
-\fBrallocx\fR\fB\fR
+rallocx()
 functions return a pointer to the allocated memory if successful; otherwise a
 \fBNULL\fR
 pointer is returned to indicate insufficient contiguous memory was available to service the allocation request\&.
 .PP
 The
-\fBxallocx\fR\fB\fR
+xallocx()
 function returns the real size of the resulting resized allocation pointed to by
 \fIptr\fR, which is a value less than
 \fIsize\fR
 if the allocation could not be adequately grown in place\&.
 .PP
 The
-\fBsallocx\fR\fB\fR
+sallocx()
 function returns the real size of the allocation pointed to by
 \fIptr\fR\&.
 .PP
 The
-\fBnallocx\fR\fB\fR
+nallocx()
 returns the real size that would result from a successful equivalent
-\fBmallocx\fR\fB\fR
+mallocx()
 function call, or zero if insufficient memory is available to perform the size computation\&.
 .PP
 The
-\fBmallctl\fR\fB\fR,
-\fBmallctlnametomib\fR\fB\fR, and
-\fBmallctlbymib\fR\fB\fR
+mallctl(),
+mallctlnametomib(), and
+mallctlbymib()
 functions return 0 on success; otherwise they return an error value\&. The functions will fail if:
 .PP
 EINVAL
 .RS 4
 \fInewp\fR
 is not
@@ -1871,18 +2071,18 @@
 A memory allocation failure occurred\&.
 .RE
 .PP
 EFAULT
 .RS 4
 An interface with side effects failed in some way not directly related to
-\fBmallctl*\fR\fB\fR
+mallctl*()
 read/write processing\&.
 .RE
 .PP
 The
-\fBmalloc_usable_size\fR\fB\fR
+malloc_usable_size()
 function returns the usable size of the allocation pointed to by
 \fIptr\fR\&.
 .SH "ENVIRONMENT"
 .PP
 The following environment variable affects the execution of the allocation functions:
 .PP
@@ -1926,36 +2126,41 @@
 \fBalloca\fR(3),
 \fBatexit\fR(3),
 \fBgetpagesize\fR(3)
 .SH "STANDARDS"
 .PP
 The
-\fBmalloc\fR\fB\fR,
-\fBcalloc\fR\fB\fR,
-\fBrealloc\fR\fB\fR, and
-\fBfree\fR\fB\fR
+malloc(),
+calloc(),
+realloc(), and
+free()
 functions conform to ISO/IEC 9899:1990 (\(lqISO C90\(rq)\&.
 .PP
 The
-\fBposix_memalign\fR\fB\fR
+posix_memalign()
 function conforms to IEEE Std 1003\&.1\-2001 (\(lqPOSIX\&.1\(rq)\&.
 .SH "AUTHOR"
 .PP
 \fBJason Evans\fR
 .RS 4
 .RE
 .SH "NOTES"
 .IP " 1." 4
 jemalloc website
 .RS 4
-\%http://www.canonware.com/jemalloc/
+\%http://jemalloc.net/
 .RE
 .IP " 2." 4
+JSON format
+.RS 4
+\%http://www.json.org/
+.RE
+.IP " 3." 4
 Valgrind
 .RS 4
 \%http://valgrind.org/
 .RE
-.IP " 3." 4
+.IP " 4." 4
 gperftools package
 .RS 4
 \%http://code.google.com/p/gperftools/
 .RE
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/jemalloc.html /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/jemalloc.html
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/jemalloc.html	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/jemalloc.html	2017-01-31 23:32:23.000000000 +0800
@@ -1,156 +1,151 @@
-<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>JEMALLOC</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="idp45223136"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>jemalloc &#8212; general purpose memory allocation functions</p></div><div class="refsect1"><a name="library"></a><h2>LIBRARY</h2><p>This manual describes jemalloc 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c.  More information
-    can be found at the <a class="ulink" href="http://www.canonware.com/jemalloc/" target="_top">jemalloc website</a>.</p></div><div class="refsynopsisdiv"><h2>SYNOPSIS</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;<code class="filename">jemalloc/jemalloc.h</code>&gt;</pre><div class="refsect2"><a name="idp44244480"></a><h3>Standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">malloc</b>(</code></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">calloc</b>(</code></td><td>size_t <var class="pdparam">number</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">posix_memalign</b>(</code></td><td>void **<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">aligned_alloc</b>(</code></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">realloc</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">free</b>(</code></td><td>void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="refsect2"><a name="idp46062768"></a><h3>Non-standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">mallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">rallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">xallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">extra</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">sallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">dallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">sdallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">nallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctl</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlnametomib</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">mibp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">miblenp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlbymib</b>(</code></td><td>const size_t *<var class="pdparam">mib</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">miblen</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">malloc_stats_print</b>(</code></td><td>void <var class="pdparam">(*write_cb)</var>
+<?xml version="1.0" encoding="utf-8"?>
+<html><head><title>JEMALLOC</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="idm45291902356496"/><div class="titlepage"/><div class="refnamediv"><h2>Name</h2><p>jemalloc  general purpose memory allocation functions</p></div><div class="refsect1"><a name="library"/><h2>LIBRARY</h2><p>This manual describes jemalloc 4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc.  More information
+    can be found at the <a class="ulink" href="http://jemalloc.net/" target="_top">jemalloc website</a>.</p></div><div class="refsynopsisdiv"><h2>SYNOPSIS</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;<code class="filename">jemalloc/jemalloc.h</code>&gt;</pre><div class="refsect2"><a name="idm45291899537440"/><h3>Standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">malloc</b>(</code></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">calloc</b>(</code></td><td>size_t <var class="pdparam">number</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">posix_memalign</b>(</code></td><td>void **<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">aligned_alloc</b>(</code></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">realloc</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">free</b>(</code></td><td>void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="refsect2"><a name="idm45291903783248"/><h3>Non-standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">mallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">rallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">xallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">extra</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">sallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">dallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">sdallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">nallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctl</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlnametomib</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">mibp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">miblenp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlbymib</b>(</code></td><td>const size_t *<var class="pdparam">mib</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">miblen</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td></td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">malloc_stats_print</b>(</code></td><td>void <var class="pdparam">(*write_cb)</var>
             <code>(</code>void *, const char *<code>)</code>
-          , </td></tr><tr><td></td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td></td><td>const char *<var class="pdparam">opts</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">malloc_usable_size</b>(</code></td><td>const void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">(*malloc_message)</b>(</code></td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td></td><td>const char *<var class="pdparam">s</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><p><span class="type">const char *</span><code class="varname">malloc_conf</code>;</p></div></div></div><div class="refsect1"><a name="description"></a><h2>DESCRIPTION</h2><div class="refsect2"><a name="idp46115952"></a><h3>Standard API</h3><p>The <code class="function">malloc</code>(<em class="parameter"><code></code></em>) function allocates
+          , </td></tr><tr><td></td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td></td><td>const char *<var class="pdparam">opts</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">malloc_usable_size</b>(</code></td><td>const void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">(*malloc_message)</b>(</code></td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td></td><td>const char *<var class="pdparam">s</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div><p><span class="type">const char *</span><code class="varname">malloc_conf</code>;</p></div></div></div><div class="refsect1"><a name="description"/><h2>DESCRIPTION</h2><div class="refsect2"><a name="idm45291898401136"/><h3>Standard API</h3><p>The <code class="function">malloc()</code> function allocates
       <em class="parameter"><code>size</code></em> bytes of uninitialized memory.  The allocated
       space is suitably aligned (after possible pointer coercion) for storage
-      of any type of object.</p><p>The <code class="function">calloc</code>(<em class="parameter"><code></code></em>) function allocates
+      of any type of object.</p><p>The <code class="function">calloc()</code> function allocates
       space for <em class="parameter"><code>number</code></em> objects, each
       <em class="parameter"><code>size</code></em> bytes in length.  The result is identical to
-      calling <code class="function">malloc</code>(<em class="parameter"><code></code></em>) with an argument of
+      calling <code class="function">malloc()</code> with an argument of
       <em class="parameter"><code>number</code></em> * <em class="parameter"><code>size</code></em>, with the
       exception that the allocated memory is explicitly initialized to zero
-      bytes.</p><p>The <code class="function">posix_memalign</code>(<em class="parameter"><code></code></em>) function
+      bytes.</p><p>The <code class="function">posix_memalign()</code> function
       allocates <em class="parameter"><code>size</code></em> bytes of memory such that the
       allocation's base address is a multiple of
       <em class="parameter"><code>alignment</code></em>, and returns the allocation in the value
       pointed to by <em class="parameter"><code>ptr</code></em>.  The requested
       <em class="parameter"><code>alignment</code></em> must be a power of 2 at least as large as
-      <code class="code">sizeof(<span class="type">void *</span>)</code>.</p><p>The <code class="function">aligned_alloc</code>(<em class="parameter"><code></code></em>) function
+      <code class="code">sizeof(<span class="type">void *</span>)</code>.</p><p>The <code class="function">aligned_alloc()</code> function
       allocates <em class="parameter"><code>size</code></em> bytes of memory such that the
       allocation's base address is a multiple of
       <em class="parameter"><code>alignment</code></em>.  The requested
       <em class="parameter"><code>alignment</code></em> must be a power of 2.  Behavior is
       undefined if <em class="parameter"><code>size</code></em> is not an integral multiple of
-      <em class="parameter"><code>alignment</code></em>.</p><p>The <code class="function">realloc</code>(<em class="parameter"><code></code></em>) function changes the
+      <em class="parameter"><code>alignment</code></em>.</p><p>The <code class="function">realloc()</code> function changes the
       size of the previously allocated memory referenced by
       <em class="parameter"><code>ptr</code></em> to <em class="parameter"><code>size</code></em> bytes.  The
       contents of the memory are unchanged up to the lesser of the new and old
       sizes.  If the new size is larger, the contents of the newly allocated
       portion of the memory are undefined.  Upon success, the memory referenced
       by <em class="parameter"><code>ptr</code></em> is freed and a pointer to the newly
       allocated memory is returned.  Note that
-      <code class="function">realloc</code>(<em class="parameter"><code></code></em>) may move the memory allocation,
+      <code class="function">realloc()</code> may move the memory allocation,
       resulting in a different return value than <em class="parameter"><code>ptr</code></em>.
       If <em class="parameter"><code>ptr</code></em> is <code class="constant">NULL</code>, the
-      <code class="function">realloc</code>(<em class="parameter"><code></code></em>) function behaves identically to
-      <code class="function">malloc</code>(<em class="parameter"><code></code></em>) for the specified size.</p><p>The <code class="function">free</code>(<em class="parameter"><code></code></em>) function causes the
+      <code class="function">realloc()</code> function behaves identically to
+      <code class="function">malloc()</code> for the specified size.</p><p>The <code class="function">free()</code> function causes the
       allocated memory referenced by <em class="parameter"><code>ptr</code></em> to be made
       available for future allocations.  If <em class="parameter"><code>ptr</code></em> is
-      <code class="constant">NULL</code>, no action occurs.</p></div><div class="refsect2"><a name="idp46144704"></a><h3>Non-standard API</h3><p>The <code class="function">mallocx</code>(<em class="parameter"><code></code></em>),
-      <code class="function">rallocx</code>(<em class="parameter"><code></code></em>),
-      <code class="function">xallocx</code>(<em class="parameter"><code></code></em>),
-      <code class="function">sallocx</code>(<em class="parameter"><code></code></em>),
-      <code class="function">dallocx</code>(<em class="parameter"><code></code></em>),
-      <code class="function">sdallocx</code>(<em class="parameter"><code></code></em>), and
-      <code class="function">nallocx</code>(<em class="parameter"><code></code></em>) functions all have a
+      <code class="constant">NULL</code>, no action occurs.</p></div><div class="refsect2"><a name="idm45291898376160"/><h3>Non-standard API</h3><p>The <code class="function">mallocx()</code>,
+      <code class="function">rallocx()</code>,
+      <code class="function">xallocx()</code>,
+      <code class="function">sallocx()</code>,
+      <code class="function">dallocx()</code>,
+      <code class="function">sdallocx()</code>, and
+      <code class="function">nallocx()</code> functions all have a
       <em class="parameter"><code>flags</code></em> argument that can be used to specify
       options.  The functions only check the options that are contextually
       relevant.  Use bitwise or (<code class="code">|</code>) operations to
       specify one or more of the following:
-        </p><div class="variablelist"><dl class="variablelist"><dt><a name="MALLOCX_LG_ALIGN"></a><span class="term"><code class="constant">MALLOCX_LG_ALIGN(<em class="parameter"><code>la</code></em>)
+        </p><div class="variablelist"><dl class="variablelist"><dt><a name="MALLOCX_LG_ALIGN"/><span class="term"><code class="constant">MALLOCX_LG_ALIGN(<em class="parameter"><code>la</code></em>)
             </code></span></dt><dd><p>Align the memory allocation to start at an address
             that is a multiple of <code class="code">(1 &lt;&lt;
             <em class="parameter"><code>la</code></em>)</code>.  This macro does not validate
             that <em class="parameter"><code>la</code></em> is within the valid
-            range.</p></dd><dt><a name="MALLOCX_ALIGN"></a><span class="term"><code class="constant">MALLOCX_ALIGN(<em class="parameter"><code>a</code></em>)
+            range.</p></dd><dt><a name="MALLOCX_ALIGN"/><span class="term"><code class="constant">MALLOCX_ALIGN(<em class="parameter"><code>a</code></em>)
             </code></span></dt><dd><p>Align the memory allocation to start at an address
             that is a multiple of <em class="parameter"><code>a</code></em>, where
             <em class="parameter"><code>a</code></em> is a power of two.  This macro does not
             validate that <em class="parameter"><code>a</code></em> is a power of 2.
-            </p></dd><dt><a name="MALLOCX_ZERO"></a><span class="term"><code class="constant">MALLOCX_ZERO</code></span></dt><dd><p>Initialize newly allocated memory to contain zero
+            </p></dd><dt><a name="MALLOCX_ZERO"/><span class="term"><code class="constant">MALLOCX_ZERO</code></span></dt><dd><p>Initialize newly allocated memory to contain zero
             bytes.  In the growing reallocation case, the real size prior to
             reallocation defines the boundary between untouched bytes and those
             that are initialized to contain zero bytes.  If this macro is
-            absent, newly allocated memory is uninitialized.</p></dd><dt><a name="MALLOCX_TCACHE"></a><span class="term"><code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)
+            absent, newly allocated memory is uninitialized.</p></dd><dt><a name="MALLOCX_TCACHE"/><span class="term"><code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)
             </code></span></dt><dd><p>Use the thread-specific cache (tcache) specified by
             the identifier <em class="parameter"><code>tc</code></em>, which must have been
-            acquired via the <a class="link" href="#tcache.create">
-    "<code class="mallctl">tcache.create</code>"
-  </a>
+            acquired via the <a class="link" href="#tcache.create"><quote><code class="mallctl">tcache.create</code></quote></a>
             mallctl.  This macro does not validate that
             <em class="parameter"><code>tc</code></em> specifies a valid
-            identifier.</p></dd><dt><a name="MALLOC_TCACHE_NONE"></a><span class="term"><code class="constant">MALLOCX_TCACHE_NONE</code></span></dt><dd><p>Do not use a thread-specific cache (tcache).  Unless
+            identifier.</p></dd><dt><a name="MALLOC_TCACHE_NONE"/><span class="term"><code class="constant">MALLOCX_TCACHE_NONE</code></span></dt><dd><p>Do not use a thread-specific cache (tcache).  Unless
             <code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code> or
             <code class="constant">MALLOCX_TCACHE_NONE</code> is specified, an
             automatically managed tcache will be used under many circumstances.
             This macro cannot be used in the same <em class="parameter"><code>flags</code></em>
             argument as
-            <code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code>.</p></dd><dt><a name="MALLOCX_ARENA"></a><span class="term"><code class="constant">MALLOCX_ARENA(<em class="parameter"><code>a</code></em>)
+            <code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code>.</p></dd><dt><a name="MALLOCX_ARENA"/><span class="term"><code class="constant">MALLOCX_ARENA(<em class="parameter"><code>a</code></em>)
             </code></span></dt><dd><p>Use the arena specified by the index
             <em class="parameter"><code>a</code></em>.  This macro has no effect for regions that
             were allocated via an arena other than the one specified.  This
             macro does not validate that <em class="parameter"><code>a</code></em> specifies an
             arena index in the valid range.</p></dd></dl></div><p>
-      </p><p>The <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) function allocates at
+      </p><p>The <code class="function">mallocx()</code> function allocates at
       least <em class="parameter"><code>size</code></em> bytes of memory, and returns a pointer
       to the base address of the allocation.  Behavior is undefined if
-      <em class="parameter"><code>size</code></em> is <code class="constant">0</code>, or if request size
-      overflows due to size class and/or alignment constraints.</p><p>The <code class="function">rallocx</code>(<em class="parameter"><code></code></em>) function resizes the
+      <em class="parameter"><code>size</code></em> is <code class="constant">0</code>.</p><p>The <code class="function">rallocx()</code> function resizes the
       allocation at <em class="parameter"><code>ptr</code></em> to be at least
       <em class="parameter"><code>size</code></em> bytes, and returns a pointer to the base
       address of the resulting allocation, which may or may not have moved from
       its original location.  Behavior is undefined if
-      <em class="parameter"><code>size</code></em> is <code class="constant">0</code>, or if request size
-      overflows due to size class and/or alignment constraints.</p><p>The <code class="function">xallocx</code>(<em class="parameter"><code></code></em>) function resizes the
+      <em class="parameter"><code>size</code></em> is <code class="constant">0</code>.</p><p>The <code class="function">xallocx()</code> function resizes the
       allocation at <em class="parameter"><code>ptr</code></em> in place to be at least
       <em class="parameter"><code>size</code></em> bytes, and returns the real size of the
       allocation.  If <em class="parameter"><code>extra</code></em> is non-zero, an attempt is
       made to resize the allocation to be at least <code class="code">(<em class="parameter"><code>size</code></em> +
       <em class="parameter"><code>extra</code></em>)</code> bytes, though inability to allocate
       the extra byte(s) will not by itself result in failure to resize.
       Behavior is undefined if <em class="parameter"><code>size</code></em> is
       <code class="constant">0</code>, or if <code class="code">(<em class="parameter"><code>size</code></em> + <em class="parameter"><code>extra</code></em>
-      &gt; <code class="constant">SIZE_T_MAX</code>)</code>.</p><p>The <code class="function">sallocx</code>(<em class="parameter"><code></code></em>) function returns the
-      real size of the allocation at <em class="parameter"><code>ptr</code></em>.</p><p>The <code class="function">dallocx</code>(<em class="parameter"><code></code></em>) function causes the
+      &gt; <code class="constant">SIZE_T_MAX</code>)</code>.</p><p>The <code class="function">sallocx()</code> function returns the
+      real size of the allocation at <em class="parameter"><code>ptr</code></em>.</p><p>The <code class="function">dallocx()</code> function causes the
       memory referenced by <em class="parameter"><code>ptr</code></em> to be made available for
-      future allocations.</p><p>The <code class="function">sdallocx</code>(<em class="parameter"><code></code></em>) function is an
-      extension of <code class="function">dallocx</code>(<em class="parameter"><code></code></em>) with a
+      future allocations.</p><p>The <code class="function">sdallocx()</code> function is an
+      extension of <code class="function">dallocx()</code> with a
       <em class="parameter"><code>size</code></em> parameter to allow the caller to pass in the
       allocation size as an optimization.  The minimum valid input size is the
       original requested size of the allocation, and the maximum valid input
       size is the corresponding value returned by
-      <code class="function">nallocx</code>(<em class="parameter"><code></code></em>) or
-      <code class="function">sallocx</code>(<em class="parameter"><code></code></em>).</p><p>The <code class="function">nallocx</code>(<em class="parameter"><code></code></em>) function allocates no
+      <code class="function">nallocx()</code> or
+      <code class="function">sallocx()</code>.</p><p>The <code class="function">nallocx()</code> function allocates no
       memory, but it performs the same size computation as the
-      <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) function, and returns the real
+      <code class="function">mallocx()</code> function, and returns the real
       size of the allocation that would result from the equivalent
-      <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) function call.  Behavior is
-      undefined if <em class="parameter"><code>size</code></em> is <code class="constant">0</code>, or if
-      request size overflows due to size class and/or alignment
-      constraints.</p><p>The <code class="function">mallctl</code>(<em class="parameter"><code></code></em>) function provides a
+      <code class="function">mallocx()</code> function call, or
+      <code class="constant">0</code> if the inputs exceed the maximum supported size
+      class and/or alignment.  Behavior is undefined if
+      <em class="parameter"><code>size</code></em> is <code class="constant">0</code>.</p><p>The <code class="function">mallctl()</code> function provides a
       general interface for introspecting the memory allocator, as well as
       setting modifiable parameters and triggering actions.  The
       period-separated <em class="parameter"><code>name</code></em> argument specifies a
       location in a tree-structured namespace; see the <a class="xref" href="#mallctl_namespace" title="MALLCTL NAMESPACE">MALLCTL NAMESPACE</a> section for
       documentation on the tree contents.  To read a value, pass a pointer via
       <em class="parameter"><code>oldp</code></em> to adequate space to contain the value, and a
       pointer to its length via <em class="parameter"><code>oldlenp</code></em>; otherwise pass
       <code class="constant">NULL</code> and <code class="constant">NULL</code>.  Similarly, to
       write a value, pass a pointer to the value via
       <em class="parameter"><code>newp</code></em>, and its length via
       <em class="parameter"><code>newlen</code></em>; otherwise pass <code class="constant">NULL</code>
-      and <code class="constant">0</code>.</p><p>The <code class="function">mallctlnametomib</code>(<em class="parameter"><code></code></em>) function
+      and <code class="constant">0</code>.</p><p>The <code class="function">mallctlnametomib()</code> function
       provides a way to avoid repeated name lookups for applications that
       repeatedly query the same portion of the namespace, by translating a name
-      to a &#8220;Management Information Base&#8221; (MIB) that can be passed
-      repeatedly to <code class="function">mallctlbymib</code>(<em class="parameter"><code></code></em>).  Upon
-      successful return from <code class="function">mallctlnametomib</code>(<em class="parameter"><code></code></em>),
+      to a <span class="quote"><span class="quote">Management Information Base</span></span> (MIB) that can be passed
+      repeatedly to <code class="function">mallctlbymib()</code>.  Upon
+      successful return from <code class="function">mallctlnametomib()</code>,
       <em class="parameter"><code>mibp</code></em> contains an array of
       <em class="parameter"><code>*miblenp</code></em> integers, where
       <em class="parameter"><code>*miblenp</code></em> is the lesser of the number of components
       in <em class="parameter"><code>name</code></em> and the input value of
       <em class="parameter"><code>*miblenp</code></em>.  Thus it is possible to pass a
       <em class="parameter"><code>*miblenp</code></em> that is smaller than the number of
       period-separated name components, which results in a partial MIB that can
       be used as the basis for constructing a complete MIB.  For name
       components that are integers (e.g. the 2 in
-      <a class="link" href="#arenas.bin.i.size">
-    "<code class="mallctl">arenas.bin.2.size</code>"
-  </a>),
+      <a class="link" href="#arenas.bin.i.size"><quote><code class="mallctl">arenas.bin.2.size</code></quote></a>),
       the corresponding MIB component will always be that integer.  Therefore,
       it is legitimate to construct code like the following: </p><pre class="programlisting">
 unsigned nbins, i;
 size_t mib[4];
 size_t len, miblen;
 
@@ -161,71 +156,68 @@
 mallctlnametomib("arenas.bin.0.size", mib, &amp;miblen);
 for (i = 0; i &lt; nbins; i++) {
 	size_t bin_size;
 
 	mib[2] = i;
 	len = sizeof(bin_size);
-	mallctlbymib(mib, miblen, &amp;bin_size, &amp;len, NULL, 0);
+	mallctlbymib(mib, miblen, (void *)&amp;bin_size, &amp;len, NULL, 0);
 	/* Do something with bin_size... */
-}</pre><p>The <code class="function">malloc_stats_print</code>(<em class="parameter"><code></code></em>) function
-      writes human-readable summary statistics via the
-      <em class="parameter"><code>write_cb</code></em> callback function pointer and
-      <em class="parameter"><code>cbopaque</code></em> data passed to
-      <em class="parameter"><code>write_cb</code></em>, or
-      <code class="function">malloc_message</code>(<em class="parameter"><code></code></em>) if
-      <em class="parameter"><code>write_cb</code></em> is <code class="constant">NULL</code>.  This
-      function can be called repeatedly.  General information that never
-      changes during execution can be omitted by specifying "g" as a character
+}</pre><p>The <code class="function">malloc_stats_print()</code> function writes
+      summary statistics via the <em class="parameter"><code>write_cb</code></em> callback
+      function pointer and <em class="parameter"><code>cbopaque</code></em> data passed to
+      <em class="parameter"><code>write_cb</code></em>, or <code class="function">malloc_message()</code>
+      if <em class="parameter"><code>write_cb</code></em> is <code class="constant">NULL</code>.  The
+      statistics are presented in human-readable form unless <span class="quote"><span class="quote">J</span></span> is
+      specified as a character within the <em class="parameter"><code>opts</code></em> string, in
+      which case the statistics are presented in <a class="ulink" href="http://www.json.org/" target="_top">JSON format</a>.  This function can be
+      called repeatedly.  General information that never changes during
+      execution can be omitted by specifying <span class="quote"><span class="quote">g</span></span> as a character
       within the <em class="parameter"><code>opts</code></em> string.  Note that
-      <code class="function">malloc_message</code>(<em class="parameter"><code></code></em>) uses the
-      <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>) functions internally, so
-      inconsistent statistics can be reported if multiple threads use these
-      functions simultaneously.  If <code class="option">--enable-stats</code> is
-      specified during configuration, &#8220;m&#8221; and &#8220;a&#8221; can
-      be specified to omit merged arena and per arena statistics, respectively;
-      &#8220;b&#8221;, &#8220;l&#8221;, and &#8220;h&#8221; can be specified to
-      omit per size class statistics for bins, large objects, and huge objects,
-      respectively.  Unrecognized characters are silently ignored.  Note that
-      thread caching may prevent some statistics from being completely up to
-      date, since extra locking would be required to merge counters that track
-      thread cache operations.
-      </p><p>The <code class="function">malloc_usable_size</code>(<em class="parameter"><code></code></em>) function
+      <code class="function">malloc_message()</code> uses the
+      <code class="function">mallctl*()</code> functions internally, so inconsistent
+      statistics can be reported if multiple threads use these functions
+      simultaneously.  If <code class="option">--enable-stats</code> is specified during
+      configuration, <span class="quote"><span class="quote">m</span></span> and <span class="quote"><span class="quote">a</span></span> can be specified to
+      omit merged arena and per arena statistics, respectively;
+      <span class="quote"><span class="quote">b</span></span>, <span class="quote"><span class="quote">l</span></span>, and <span class="quote"><span class="quote">h</span></span> can be specified
+      to omit per size class statistics for bins, large objects, and huge
+      objects, respectively.  Unrecognized characters are silently ignored.
+      Note that thread caching may prevent some statistics from being completely
+      up to date, since extra locking would be required to merge counters that
+      track thread cache operations.</p><p>The <code class="function">malloc_usable_size()</code> function
       returns the usable size of the allocation pointed to by
       <em class="parameter"><code>ptr</code></em>.  The return value may be larger than the size
       that was requested during allocation.  The
-      <code class="function">malloc_usable_size</code>(<em class="parameter"><code></code></em>) function is not a
-      mechanism for in-place <code class="function">realloc</code>(<em class="parameter"><code></code></em>); rather
+      <code class="function">malloc_usable_size()</code> function is not a
+      mechanism for in-place <code class="function">realloc()</code>; rather
       it is provided solely as a tool for introspection purposes.  Any
       discrepancy between the requested allocation size and the size reported
-      by <code class="function">malloc_usable_size</code>(<em class="parameter"><code></code></em>) should not be
+      by <code class="function">malloc_usable_size()</code> should not be
       depended on, since such behavior is entirely implementation-dependent.
-      </p></div></div><div class="refsect1"><a name="tuning"></a><h2>TUNING</h2><p>Once, when the first call is made to one of the memory allocation
+      </p></div></div><div class="refsect1"><a name="tuning"/><h2>TUNING</h2><p>Once, when the first call is made to one of the memory allocation
     routines, the allocator initializes its internals based in part on various
-    options that can be specified at compile- or run-time.</p><p>The string pointed to by the global variable
-    <code class="varname">malloc_conf</code>, the &#8220;name&#8221; of the file
-    referenced by the symbolic link named <code class="filename">/etc/malloc.conf</code>, and the value of the
+    options that can be specified at compile- or run-time.</p><p>The string specified via <code class="option">--with-malloc-conf</code>, the
+    string pointed to by the global variable <code class="varname">malloc_conf</code>, the
+    <span class="quote"><span class="quote">name</span></span> of the file referenced by the symbolic link named
+    <code class="filename">/etc/malloc.conf</code>, and the value of the
     environment variable <code class="envar">MALLOC_CONF</code>, will be interpreted, in
     that order, from left to right as options.  Note that
     <code class="varname">malloc_conf</code> may be read before
-    <code class="function">main</code>(<em class="parameter"><code></code></em>) is entered, so the declaration of
+    <code class="function">main()</code> is entered, so the declaration of
     <code class="varname">malloc_conf</code> should specify an initializer that contains
-    the final value to be read by jemalloc.  <code class="varname">malloc_conf</code> is
-    a compile-time setting, whereas <code class="filename">/etc/malloc.conf</code> and <code class="envar">MALLOC_CONF</code>
-    can be safely set any time prior to program invocation.</p><p>An options string is a comma-separated list of option:value pairs.
-    There is one key corresponding to each <a class="link" href="#opt.abort">
-    "<code class="mallctl">opt.*</code>"
-  </a> mallctl (see the <a class="xref" href="#mallctl_namespace" title="MALLCTL NAMESPACE">MALLCTL NAMESPACE</a> section for options
+    the final value to be read by jemalloc.  <code class="option">--with-malloc-conf</code>
+    and <code class="varname">malloc_conf</code> are compile-time mechanisms, whereas
+    <code class="filename">/etc/malloc.conf</code> and
+    <code class="envar">MALLOC_CONF</code> can be safely set any time prior to program
+    invocation.</p><p>An options string is a comma-separated list of option:value pairs.
+    There is one key corresponding to each <a class="link" href="#opt.abort"><quote><code class="mallctl">opt.*</code></quote></a> mallctl (see the <a class="xref" href="#mallctl_namespace" title="MALLCTL NAMESPACE">MALLCTL NAMESPACE</a> section for options
     documentation).  For example, <code class="literal">abort:true,narenas:1</code> sets
-    the <a class="link" href="#opt.abort">
-    "<code class="mallctl">opt.abort</code>"
-  </a> and <a class="link" href="#opt.narenas">
-    "<code class="mallctl">opt.narenas</code>"
-  </a> options.  Some
+    the <a class="link" href="#opt.abort"><quote><code class="mallctl">opt.abort</code></quote></a> and <a class="link" href="#opt.narenas"><quote><code class="mallctl">opt.narenas</code></quote></a> options.  Some
     options have boolean values (true/false), others have integer values (base
     8, 10, or 16, depending on prefix), and yet others have raw string
-    values.</p></div><div class="refsect1"><a name="implementation_notes"></a><h2>IMPLEMENTATION NOTES</h2><p>Traditionally, allocators have used
+    values.</p></div><div class="refsect1"><a name="implementation_notes"/><h2>IMPLEMENTATION NOTES</h2><p>Traditionally, allocators have used
     <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> to obtain memory, which is
     suboptimal for several reasons, including race conditions, increased
     fragmentation, and artificial limitations on maximum usable memory.  If
     <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> is supported by the operating
     system, this allocator uses both
     <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> and
@@ -243,750 +235,624 @@
     use of the allocation functions.</p><p>In addition to multiple arenas, unless
     <code class="option">--disable-tcache</code> is specified during configuration, this
     allocator supports thread-specific caching for small and large objects, in
     order to make it possible to completely avoid synchronization for most
     allocation requests.  Such caching allows very fast allocation in the
     common case, but it increases memory usage and fragmentation, since a
-    bounded number of objects can remain allocated in each thread cache.</p><p>Memory is conceptually broken into equal-sized chunks, where the
-    chunk size is a power of two that is greater than the page size.  Chunks
-    are always aligned to multiples of the chunk size.  This alignment makes it
-    possible to find metadata for user objects very quickly.</p><p>User objects are broken into three categories according to size:
-    small, large, and huge.  Small and large objects are managed entirely by
-    arenas; huge objects are additionally aggregated in a single data structure
-    that is shared by all threads.  Huge objects are typically used by
-    applications infrequently enough that this single data structure is not a
-    scalability issue.</p><p>Each chunk that is managed by an arena tracks its contents as runs of
+    bounded number of objects can remain allocated in each thread cache.</p><p>Memory is conceptually broken into equal-sized chunks, where the chunk
+    size is a power of two that is greater than the page size.  Chunks are
+    always aligned to multiples of the chunk size.  This alignment makes it
+    possible to find metadata for user objects very quickly.  User objects are
+    broken into three categories according to size: small, large, and huge.
+    Multiple small and large objects can reside within a single chunk, whereas
+    huge objects each have one or more chunks backing them.  Each chunk that
+    contains small and/or large objects tracks its contents as runs of
     contiguous pages (unused, backing a set of small objects, or backing one
-    large object).  The combination of chunk alignment and chunk page maps
-    makes it possible to determine all metadata regarding small and large
-    allocations in constant time.</p><p>Small objects are managed in groups by page runs.  Each run maintains
+    large object).  The combination of chunk alignment and chunk page maps makes
+    it possible to determine all metadata regarding small and large allocations
+    in constant time.</p><p>Small objects are managed in groups by page runs.  Each run maintains
     a bitmap to track which regions are in use.  Allocation requests that are no
     more than half the quantum (8 or 16, depending on architecture) are rounded
     up to the nearest power of two that is at least <code class="code">sizeof(<span class="type">double</span>)</code>.  All other object size
     classes are multiples of the quantum, spaced such that there are four size
     classes for each doubling in size, which limits internal fragmentation to
     approximately 20% for all but the smallest size classes.  Small size classes
     are smaller than four times the page size, large size classes are smaller
-    than the chunk size (see the <a class="link" href="#opt.lg_chunk">
-    "<code class="mallctl">opt.lg_chunk</code>"
-  </a> option), and
-    huge size classes extend from the chunk size up to one size class less than
-    the full address space size.</p><p>Allocations are packed tightly together, which can be an issue for
+    than the chunk size (see the <a class="link" href="#opt.lg_chunk"><quote><code class="mallctl">opt.lg_chunk</code></quote></a> option), and
+    huge size classes extend from the chunk size up to the largest size class
+    that does not exceed <code class="constant">PTRDIFF_MAX</code>.</p><p>Allocations are packed tightly together, which can be an issue for
     multi-threaded applications.  If you need to assure that allocations do not
     suffer from cacheline sharing, round your allocation requests up to the
     nearest multiple of the cacheline size, or specify cacheline alignment when
-    allocating.</p><p>The <code class="function">realloc</code>(<em class="parameter"><code></code></em>),
-    <code class="function">rallocx</code>(<em class="parameter"><code></code></em>), and
-    <code class="function">xallocx</code>(<em class="parameter"><code></code></em>) functions may resize allocations
+    allocating.</p><p>The <code class="function">realloc()</code>,
+    <code class="function">rallocx()</code>, and
+    <code class="function">xallocx()</code> functions may resize allocations
     without moving them under limited circumstances.  Unlike the
-    <code class="function">*allocx</code>(<em class="parameter"><code></code></em>) API, the standard API does not
+    <code class="function">*allocx()</code> API, the standard API does not
     officially round up the usable size of an allocation to the nearest size
     class, so technically it is necessary to call
-    <code class="function">realloc</code>(<em class="parameter"><code></code></em>) to grow e.g. a 9-byte allocation to
+    <code class="function">realloc()</code> to grow e.g. a 9-byte allocation to
     16 bytes, or shrink a 16-byte allocation to 9 bytes.  Growth and shrinkage
     trivially succeeds in place as long as the pre-size and post-size both round
     up to the same size class.  No other API guarantees are made regarding
     in-place resizing, but the current implementation also tries to resize large
     and huge allocations in place, as long as the pre-size and post-size are
     both large or both huge.  In such cases shrinkage always succeeds for large
     size classes, but for huge size classes the chunk allocator must support
-    splitting (see <a class="link" href="#arena.i.chunk_hooks">
-    "<code class="mallctl">arena.&lt;i&gt;.chunk_hooks</code>"
-  </a>).
+    splitting (see <a class="link" href="#arena.i.chunk_hooks"><quote><code class="mallctl">arena.&lt;i&gt;.chunk_hooks</code></quote></a>).
     Growth only succeeds if the trailing memory is currently available, and
     additionally for huge size classes the chunk allocator must support
     merging.</p><p>Assuming 2 MiB chunks, 4 KiB pages, and a 16-byte quantum on a
-    64-bit system, the size classes in each category are as shown in <a class="xref" href="#size_classes" title="Table1.Size classes">Table 1</a>.</p><div class="table"><a name="size_classes"></a><p class="title"><b>Table1.Size classes</b></p><div class="table-contents"><table summary="Size classes" border="1"><colgroup><col align="left" class="c1"><col align="right" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Category</th><th align="right">Spacing</th><th align="left">Size</th></tr></thead><tbody><tr><td rowspan="9" align="left">Small</td><td align="right">lg</td><td align="left">[8]</td></tr><tr><td align="right">16</td><td align="left">[16, 32, 48, 64, 80, 96, 112, 128]</td></tr><tr><td align="right">32</td><td align="left">[160, 192, 224, 256]</td></tr><tr><td align="right">64</td><td align="left">[320, 384, 448, 512]</td></tr><tr><td align="right">128</td><td align="left">[640, 768, 896, 1024]</td></tr><tr><td align="right">256</td><td align="left">[1280, 1536, 1792, 2048]</td></tr><tr><td align="right">512</td><td align="left">[2560, 3072, 3584, 4096]</td></tr><tr><td align="right">1 KiB</td><td align="left">[5 KiB, 6 KiB, 7 KiB, 8 KiB]</td></tr><tr><td align="right">2 KiB</td><td align="left">[10 KiB, 12 KiB, 14 KiB]</td></tr><tr><td rowspan="8" align="left">Large</td><td align="right">2 KiB</td><td align="left">[16 KiB]</td></tr><tr><td align="right">4 KiB</td><td align="left">[20 KiB, 24 KiB, 28 KiB, 32 KiB]</td></tr><tr><td align="right">8 KiB</td><td align="left">[40 KiB, 48 KiB, 54 KiB, 64 KiB]</td></tr><tr><td align="right">16 KiB</td><td align="left">[80 KiB, 96 KiB, 112 KiB, 128 KiB]</td></tr><tr><td align="right">32 KiB</td><td align="left">[160 KiB, 192 KiB, 224 KiB, 256 KiB]</td></tr><tr><td align="right">64 KiB</td><td align="left">[320 KiB, 384 KiB, 448 KiB, 512 KiB]</td></tr><tr><td align="right">128 KiB</td><td align="left">[640 KiB, 768 KiB, 896 KiB, 1 MiB]</td></tr><tr><td align="right">256 KiB</td><td align="left">[1280 KiB, 1536 KiB, 1792 KiB]</td></tr><tr><td rowspan="7" align="left">Huge</td><td align="right">256 KiB</td><td align="left">[2 MiB]</td></tr><tr><td align="right">512 KiB</td><td align="left">[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]</td></tr><tr><td align="right">1 MiB</td><td align="left">[5 MiB, 6 MiB, 7 MiB, 8 MiB]</td></tr><tr><td align="right">2 MiB</td><td align="left">[10 MiB, 12 MiB, 14 MiB, 16 MiB]</td></tr><tr><td align="right">4 MiB</td><td align="left">[20 MiB, 24 MiB, 28 MiB, 32 MiB]</td></tr><tr><td align="right">8 MiB</td><td align="left">[40 MiB, 48 MiB, 56 MiB, 64 MiB]</td></tr><tr><td align="right">...</td><td align="left">...</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="mallctl_namespace"></a><h2>MALLCTL NAMESPACE</h2><p>The following names are defined in the namespace accessible via the
-    <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>) functions.  Value types are
+    64-bit system, the size classes in each category are as shown in <a class="xref" href="#size_classes" title="Table1.Size classes">Table 1</a>.</p><div class="table"><a name="size_classes"/><p class="title"><b>Table1.Size classes</b></p><div class="table-contents"><table class="table" summary="Size classes" border="1"><colgroup><col align="left" class="c1"/><col align="right" class="c2"/><col align="left" class="c3"/></colgroup><thead><tr><th align="left">Category</th><th align="right">Spacing</th><th align="left">Size</th></tr></thead><tbody><tr><td rowspan="9" align="left">Small</td><td align="right">lg</td><td align="left">[8]</td></tr><tr><td align="right">16</td><td align="left">[16, 32, 48, 64, 80, 96, 112, 128]</td></tr><tr><td align="right">32</td><td align="left">[160, 192, 224, 256]</td></tr><tr><td align="right">64</td><td align="left">[320, 384, 448, 512]</td></tr><tr><td align="right">128</td><td align="left">[640, 768, 896, 1024]</td></tr><tr><td align="right">256</td><td align="left">[1280, 1536, 1792, 2048]</td></tr><tr><td align="right">512</td><td align="left">[2560, 3072, 3584, 4096]</td></tr><tr><td align="right">1 KiB</td><td align="left">[5 KiB, 6 KiB, 7 KiB, 8 KiB]</td></tr><tr><td align="right">2 KiB</td><td align="left">[10 KiB, 12 KiB, 14 KiB]</td></tr><tr><td rowspan="8" align="left">Large</td><td align="right">2 KiB</td><td align="left">[16 KiB]</td></tr><tr><td align="right">4 KiB</td><td align="left">[20 KiB, 24 KiB, 28 KiB, 32 KiB]</td></tr><tr><td align="right">8 KiB</td><td align="left">[40 KiB, 48 KiB, 54 KiB, 64 KiB]</td></tr><tr><td align="right">16 KiB</td><td align="left">[80 KiB, 96 KiB, 112 KiB, 128 KiB]</td></tr><tr><td align="right">32 KiB</td><td align="left">[160 KiB, 192 KiB, 224 KiB, 256 KiB]</td></tr><tr><td align="right">64 KiB</td><td align="left">[320 KiB, 384 KiB, 448 KiB, 512 KiB]</td></tr><tr><td align="right">128 KiB</td><td align="left">[640 KiB, 768 KiB, 896 KiB, 1 MiB]</td></tr><tr><td align="right">256 KiB</td><td align="left">[1280 KiB, 1536 KiB, 1792 KiB]</td></tr><tr><td rowspan="9" align="left">Huge</td><td align="right">256 KiB</td><td align="left">[2 MiB]</td></tr><tr><td align="right">512 KiB</td><td align="left">[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]</td></tr><tr><td align="right">1 MiB</td><td align="left">[5 MiB, 6 MiB, 7 MiB, 8 MiB]</td></tr><tr><td align="right">2 MiB</td><td align="left">[10 MiB, 12 MiB, 14 MiB, 16 MiB]</td></tr><tr><td align="right">4 MiB</td><td align="left">[20 MiB, 24 MiB, 28 MiB, 32 MiB]</td></tr><tr><td align="right">8 MiB</td><td align="left">[40 MiB, 48 MiB, 56 MiB, 64 MiB]</td></tr><tr><td align="right">...</td><td align="left">...</td></tr><tr><td align="right">512 PiB</td><td align="left">[2560 PiB, 3 EiB, 3584 PiB, 4 EiB]</td></tr><tr><td align="right">1 EiB</td><td align="left">[5 EiB, 6 EiB, 7 EiB]</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="refsect1"><a name="mallctl_namespace"/><h2>MALLCTL NAMESPACE</h2><p>The following names are defined in the namespace accessible via the
+    <code class="function">mallctl*()</code> functions.  Value types are
     specified in parentheses, their readable/writable statuses are encoded as
     <code class="literal">rw</code>, <code class="literal">r-</code>, <code class="literal">-w</code>, or
     <code class="literal">--</code>, and required build configuration flags follow, if
     any.  A name element encoded as <code class="literal">&lt;i&gt;</code> or
     <code class="literal">&lt;j&gt;</code> indicates an integer component, where the
     integer varies from 0 to some upper value that must be determined via
-    introspection.  In the case of 
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.*</code>"
-  ,
-    <code class="literal">&lt;i&gt;</code> equal to <a class="link" href="#arenas.narenas">
-    "<code class="mallctl">arenas.narenas</code>"
-  </a> can be
+    introspection.  In the case of <quote><code class="mallctl">stats.arenas.&lt;i&gt;.*</code></quote>,
+    <code class="literal">&lt;i&gt;</code> equal to <a class="link" href="#arenas.narenas"><quote><code class="mallctl">arenas.narenas</code></quote></a> can be
     used to access the summation of statistics from all arenas.  Take special
-    note of the <a class="link" href="#epoch">
-    "<code class="mallctl">epoch</code>"
-  </a> mallctl,
-    which controls refreshing of cached dynamic statistics.</p><div class="variablelist"><dl class="variablelist"><dt><a name="version"></a><span class="term">
-          
-    "<code class="mallctl">version</code>"
-  
+    note of the <a class="link" href="#epoch"><quote><code class="mallctl">epoch</code></quote></a> mallctl,
+    which controls refreshing of cached dynamic statistics.</p><div class="variablelist"><dl class="variablelist"><dt><a name="version"/><span class="term">
+          <quote><code class="mallctl">version</code></quote>
           (<span class="type">const char *</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>Return the jemalloc version string.</p></dd><dt><a name="epoch"></a><span class="term">
-          
-    "<code class="mallctl">epoch</code>"
-  
+        </span></dt><dd><p>Return the jemalloc version string.</p></dd><dt><a name="epoch"/><span class="term">
+          <quote><code class="mallctl">epoch</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">rw</code>
         </span></dt><dd><p>If a value is passed in, refresh the data from which
-        the <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>) functions report values,
+        the <code class="function">mallctl*()</code> functions report values,
         and increment the epoch.  Return the current epoch.  This is useful for
-        detecting whether another thread caused a refresh.</p></dd><dt><a name="config.cache_oblivious"></a><span class="term">
-          
-    "<code class="mallctl">config.cache_oblivious</code>"
-  
+        detecting whether another thread caused a refresh.</p></dd><dt><a name="config.cache_oblivious"/><span class="term">
+          <quote><code class="mallctl">config.cache_oblivious</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-cache-oblivious</code> was specified
-        during build configuration.</p></dd><dt><a name="config.debug"></a><span class="term">
-          
-    "<code class="mallctl">config.debug</code>"
-  
+        during build configuration.</p></dd><dt><a name="config.debug"/><span class="term">
+          <quote><code class="mallctl">config.debug</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-debug</code> was specified during
-        build configuration.</p></dd><dt><a name="config.fill"></a><span class="term">
-          
-    "<code class="mallctl">config.fill</code>"
-  
+        build configuration.</p></dd><dt><a name="config.fill"/><span class="term">
+          <quote><code class="mallctl">config.fill</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-fill</code> was specified during
-        build configuration.</p></dd><dt><a name="config.lazy_lock"></a><span class="term">
-          
-    "<code class="mallctl">config.lazy_lock</code>"
-  
+        build configuration.</p></dd><dt><a name="config.lazy_lock"/><span class="term">
+          <quote><code class="mallctl">config.lazy_lock</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-lazy-lock</code> was specified
-        during build configuration.</p></dd><dt><a name="config.munmap"></a><span class="term">
-          
-    "<code class="mallctl">config.munmap</code>"
-  
+        during build configuration.</p></dd><dt><a name="config.malloc_conf"/><span class="term">
+          <quote><code class="mallctl">config.malloc_conf</code></quote>
+          (<span class="type">const char *</span>)
+          <code class="literal">r-</code>
+        </span></dt><dd><p>Embedded configure-time-specified run-time options
+        string, empty unless <code class="option">--with-malloc-conf</code> was specified
+        during build configuration.</p></dd><dt><a name="config.munmap"/><span class="term">
+          <quote><code class="mallctl">config.munmap</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-munmap</code> was specified during
-        build configuration.</p></dd><dt><a name="config.prof"></a><span class="term">
-          
-    "<code class="mallctl">config.prof</code>"
-  
+        build configuration.</p></dd><dt><a name="config.prof"/><span class="term">
+          <quote><code class="mallctl">config.prof</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-prof</code> was specified during
-        build configuration.</p></dd><dt><a name="config.prof_libgcc"></a><span class="term">
-          
-    "<code class="mallctl">config.prof_libgcc</code>"
-  
+        build configuration.</p></dd><dt><a name="config.prof_libgcc"/><span class="term">
+          <quote><code class="mallctl">config.prof_libgcc</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--disable-prof-libgcc</code> was not
-        specified during build configuration.</p></dd><dt><a name="config.prof_libunwind"></a><span class="term">
-          
-    "<code class="mallctl">config.prof_libunwind</code>"
-  
+        specified during build configuration.</p></dd><dt><a name="config.prof_libunwind"/><span class="term">
+          <quote><code class="mallctl">config.prof_libunwind</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-prof-libunwind</code> was specified
-        during build configuration.</p></dd><dt><a name="config.stats"></a><span class="term">
-          
-    "<code class="mallctl">config.stats</code>"
-  
+        during build configuration.</p></dd><dt><a name="config.stats"/><span class="term">
+          <quote><code class="mallctl">config.stats</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-stats</code> was specified during
-        build configuration.</p></dd><dt><a name="config.tcache"></a><span class="term">
-          
-    "<code class="mallctl">config.tcache</code>"
-  
+        build configuration.</p></dd><dt><a name="config.tcache"/><span class="term">
+          <quote><code class="mallctl">config.tcache</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--disable-tcache</code> was not specified
-        during build configuration.</p></dd><dt><a name="config.tls"></a><span class="term">
-          
-    "<code class="mallctl">config.tls</code>"
-  
+        during build configuration.</p></dd><dt><a name="config.tls"/><span class="term">
+          <quote><code class="mallctl">config.tls</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--disable-tls</code> was not specified during
-        build configuration.</p></dd><dt><a name="config.utrace"></a><span class="term">
-          
-    "<code class="mallctl">config.utrace</code>"
-  
+        build configuration.</p></dd><dt><a name="config.utrace"/><span class="term">
+          <quote><code class="mallctl">config.utrace</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-utrace</code> was specified during
-        build configuration.</p></dd><dt><a name="config.valgrind"></a><span class="term">
-          
-    "<code class="mallctl">config.valgrind</code>"
-  
+        build configuration.</p></dd><dt><a name="config.valgrind"/><span class="term">
+          <quote><code class="mallctl">config.valgrind</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-valgrind</code> was specified during
-        build configuration.</p></dd><dt><a name="config.xmalloc"></a><span class="term">
-          
-    "<code class="mallctl">config.xmalloc</code>"
-  
+        build configuration.</p></dd><dt><a name="config.xmalloc"/><span class="term">
+          <quote><code class="mallctl">config.xmalloc</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p><code class="option">--enable-xmalloc</code> was specified during
-        build configuration.</p></dd><dt><a name="opt.abort"></a><span class="term">
-          
-    "<code class="mallctl">opt.abort</code>"
-  
+        build configuration.</p></dd><dt><a name="opt.abort"/><span class="term">
+          <quote><code class="mallctl">opt.abort</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Abort-on-warning enabled/disabled.  If true, most
         warnings are fatal.  The process will call
         <span class="citerefentry"><span class="refentrytitle">abort</span>(3)</span> in these cases.  This option is
         disabled by default unless <code class="option">--enable-debug</code> is
         specified during configuration, in which case it is enabled by default.
-        </p></dd><dt><a name="opt.dss"></a><span class="term">
-          
-    "<code class="mallctl">opt.dss</code>"
-  
+        </p></dd><dt><a name="opt.dss"/><span class="term">
+          <quote><code class="mallctl">opt.dss</code></quote>
           (<span class="type">const char *</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>dss (<span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>) allocation precedence as
         related to <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> allocation.  The following
         settings are supported if
         <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> is supported by the operating
-        system: &#8220;disabled&#8221;, &#8220;primary&#8221;, and
-        &#8220;secondary&#8221;; otherwise only &#8220;disabled&#8221; is
-        supported.  The default is &#8220;secondary&#8221; if
+        system: <span class="quote"><span class="quote">disabled</span></span>, <span class="quote"><span class="quote">primary</span></span>, and
+        <span class="quote"><span class="quote">secondary</span></span>; otherwise only <span class="quote"><span class="quote">disabled</span></span> is
+        supported.  The default is <span class="quote"><span class="quote">secondary</span></span> if
         <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> is supported by the operating
-        system; &#8220;disabled&#8221; otherwise.
-        </p></dd><dt><a name="opt.lg_chunk"></a><span class="term">
-          
-    "<code class="mallctl">opt.lg_chunk</code>"
-  
+        system; <span class="quote"><span class="quote">disabled</span></span> otherwise.
+        </p></dd><dt><a name="opt.lg_chunk"/><span class="term">
+          <quote><code class="mallctl">opt.lg_chunk</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Virtual memory chunk size (log base 2).  If a chunk
         size outside the supported size range is specified, the size is
         silently clipped to the minimum/maximum supported size.  The default
         chunk size is 2 MiB (2^21).
-        </p></dd><dt><a name="opt.narenas"></a><span class="term">
-          
-    "<code class="mallctl">opt.narenas</code>"
-  
-          (<span class="type">size_t</span>)
+        </p></dd><dt><a name="opt.narenas"/><span class="term">
+          <quote><code class="mallctl">opt.narenas</code></quote>
+          (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Maximum number of arenas to use for automatic
         multiplexing of threads and arenas.  The default is four times the
-        number of CPUs, or one if there is a single CPU.</p></dd><dt><a name="opt.lg_dirty_mult"></a><span class="term">
-          
-    "<code class="mallctl">opt.lg_dirty_mult</code>"
-  
+        number of CPUs, or one if there is a single CPU.</p></dd><dt><a name="opt.purge"/><span class="term">
+          <quote><code class="mallctl">opt.purge</code></quote>
+          (<span class="type">const char *</span>)
+          <code class="literal">r-</code>
+        </span></dt><dd><p>Purge mode is ratio (default) or
+        decay.  See <a class="link" href="#opt.lg_dirty_mult"><quote><code class="mallctl">opt.lg_dirty_mult</code></quote></a>
+        for details of the ratio mode.  See <a class="link" href="#opt.decay_time"><quote><code class="mallctl">opt.decay_time</code></quote></a> for
+        details of the decay mode.</p></dd><dt><a name="opt.lg_dirty_mult"/><span class="term">
+          <quote><code class="mallctl">opt.lg_dirty_mult</code></quote>
           (<span class="type">ssize_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Per-arena minimum ratio (log base 2) of active to dirty
         pages.  Some dirty unused pages may be allowed to accumulate, within
         the limit set by the ratio (or one chunk worth of dirty pages,
         whichever is greater), before informing the kernel about some of those
         pages via <span class="citerefentry"><span class="refentrytitle">madvise</span>(2)</span> or a similar system call.  This
         provides the kernel with sufficient information to recycle dirty pages
         if physical memory becomes scarce and the pages remain unused.  The
         default minimum ratio is 8:1 (2^3:1); an option value of -1 will
-        disable dirty page purging.  See <a class="link" href="#arenas.lg_dirty_mult">
-    "<code class="mallctl">arenas.lg_dirty_mult</code>"
-  </a>
-        and <a class="link" href="#arena.i.lg_dirty_mult">
-    "<code class="mallctl">arena.&lt;i&gt;.lg_dirty_mult</code>"
-  </a>
-        for related dynamic control options.</p></dd><dt><a name="opt.stats_print"></a><span class="term">
-          
-    "<code class="mallctl">opt.stats_print</code>"
-  
+        disable dirty page purging.  See <a class="link" href="#arenas.lg_dirty_mult"><quote><code class="mallctl">arenas.lg_dirty_mult</code></quote></a>
+        and <a class="link" href="#arena.i.lg_dirty_mult"><quote><code class="mallctl">arena.&lt;i&gt;.lg_dirty_mult</code></quote></a>
+        for related dynamic control options.</p></dd><dt><a name="opt.decay_time"/><span class="term">
+          <quote><code class="mallctl">opt.decay_time</code></quote>
+          (<span class="type">ssize_t</span>)
+          <code class="literal">r-</code>
+        </span></dt><dd><p>Approximate time in seconds from the creation of a set
+        of unused dirty pages until an equivalent set of unused dirty pages is
+        purged and/or reused.  The pages are incrementally purged according to a
+        sigmoidal decay curve that starts and ends with zero purge rate.  A
+        decay time of 0 causes all unused dirty pages to be purged immediately
+        upon creation.  A decay time of -1 disables purging.  The default decay
+        time is 10 seconds.  See <a class="link" href="#arenas.decay_time"><quote><code class="mallctl">arenas.decay_time</code></quote></a>
+        and <a class="link" href="#arena.i.decay_time"><quote><code class="mallctl">arena.&lt;i&gt;.decay_time</code></quote></a>
+        for related dynamic control options.
+        </p></dd><dt><a name="opt.stats_print"/><span class="term">
+          <quote><code class="mallctl">opt.stats_print</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Enable/disable statistics printing at exit.  If
-        enabled, the <code class="function">malloc_stats_print</code>(<em class="parameter"><code></code></em>)
+        enabled, the <code class="function">malloc_stats_print()</code>
         function is called at program exit via an
         <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span> function.  If
         <code class="option">--enable-stats</code> is specified during configuration, this
         has the potential to cause deadlock for a multi-threaded process that
         exits while one or more threads are executing in the memory allocation
-        functions.  Furthermore, <code class="function">atexit</code>(<em class="parameter"><code></code></em>) may
+        functions.  Furthermore, <code class="function">atexit()</code> may
         allocate memory during application initialization and then deadlock
         internally when jemalloc in turn calls
-        <code class="function">atexit</code>(<em class="parameter"><code></code></em>), so this option is not
-        univerally usable (though the application can register its own
-        <code class="function">atexit</code>(<em class="parameter"><code></code></em>) function with equivalent
+        <code class="function">atexit()</code>, so this option is not
+        universally usable (though the application can register its own
+        <code class="function">atexit()</code> function with equivalent
         functionality).  Therefore, this option should only be used with care;
         it is primarily intended as a performance tuning aid during application
-        development.  This option is disabled by default.</p></dd><dt><a name="opt.junk"></a><span class="term">
-          
-    "<code class="mallctl">opt.junk</code>"
-  
+        development.  This option is disabled by default.</p></dd><dt><a name="opt.junk"/><span class="term">
+          <quote><code class="mallctl">opt.junk</code></quote>
           (<span class="type">const char *</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-fill</code>]
-        </span></dt><dd><p>Junk filling.  If set to "alloc", each byte of
-        uninitialized allocated memory will be initialized to
-        <code class="literal">0xa5</code>.  If set to "free", all deallocated memory will
-        be initialized to <code class="literal">0x5a</code>.  If set to "true", both
-        allocated and deallocated memory will be initialized, and if set to
-        "false", junk filling be disabled entirely.  This is intended for
-        debugging and will impact performance negatively.  This option is
-        "false" by default unless <code class="option">--enable-debug</code> is specified
-        during configuration, in which case it is "true" by default unless
-        running inside <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>.</p></dd><dt><a name="opt.quarantine"></a><span class="term">
-          
-    "<code class="mallctl">opt.quarantine</code>"
-  
+        </span></dt><dd><p>Junk filling.  If set to <span class="quote"><span class="quote">alloc</span></span>, each byte
+        of uninitialized allocated memory will be initialized to
+        <code class="literal">0xa5</code>.  If set to <span class="quote"><span class="quote">free</span></span>, all deallocated
+        memory will be initialized to <code class="literal">0x5a</code>.  If set to
+        <span class="quote"><span class="quote">true</span></span>, both allocated and deallocated memory will be
+        initialized, and if set to <span class="quote"><span class="quote">false</span></span>, junk filling be
+        disabled entirely.  This is intended for debugging and will impact
+        performance negatively.  This option is <span class="quote"><span class="quote">false</span></span> by default
+        unless <code class="option">--enable-debug</code> is specified during
+        configuration, in which case it is <span class="quote"><span class="quote">true</span></span> by default unless
+        running inside <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>.</p></dd><dt><a name="opt.quarantine"/><span class="term">
+          <quote><code class="mallctl">opt.quarantine</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-fill</code>]
         </span></dt><dd><p>Per thread quarantine size in bytes.  If non-zero, each
         thread maintains a FIFO object quarantine that stores up to the
         specified number of bytes of memory.  The quarantined memory is not
         freed until it is released from quarantine, though it is immediately
-        junk-filled if the <a class="link" href="#opt.junk">
-    "<code class="mallctl">opt.junk</code>"
-  </a> option is
+        junk-filled if the <a class="link" href="#opt.junk"><quote><code class="mallctl">opt.junk</code></quote></a> option is
         enabled.  This feature is of particular use in combination with <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>, which can detect attempts
         to access quarantined objects.  This is intended for debugging and will
         impact performance negatively.  The default quarantine size is 0 unless
         running inside Valgrind, in which case the default is 16
-        MiB.</p></dd><dt><a name="opt.redzone"></a><span class="term">
-          
-    "<code class="mallctl">opt.redzone</code>"
-  
+        MiB.</p></dd><dt><a name="opt.redzone"/><span class="term">
+          <quote><code class="mallctl">opt.redzone</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-fill</code>]
         </span></dt><dd><p>Redzones enabled/disabled.  If enabled, small
         allocations have redzones before and after them.  Furthermore, if the
-        <a class="link" href="#opt.junk">
-    "<code class="mallctl">opt.junk</code>"
-  </a> option is
+        <a class="link" href="#opt.junk"><quote><code class="mallctl">opt.junk</code></quote></a> option is
         enabled, the redzones are checked for corruption during deallocation.
         However, the primary intended purpose of this feature is to be used in
         combination with <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>,
         which needs redzones in order to do effective buffer overflow/underflow
         detection.  This option is intended for debugging and will impact
         performance negatively.  This option is disabled by
-        default unless running inside Valgrind.</p></dd><dt><a name="opt.zero"></a><span class="term">
-          
-    "<code class="mallctl">opt.zero</code>"
-  
+        default unless running inside Valgrind.</p></dd><dt><a name="opt.zero"/><span class="term">
+          <quote><code class="mallctl">opt.zero</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-fill</code>]
         </span></dt><dd><p>Zero filling enabled/disabled.  If enabled, each byte
         of uninitialized allocated memory will be initialized to 0.  Note that
         this initialization only happens once for each byte, so
-        <code class="function">realloc</code>(<em class="parameter"><code></code></em>) and
-        <code class="function">rallocx</code>(<em class="parameter"><code></code></em>) calls do not zero memory that
+        <code class="function">realloc()</code> and
+        <code class="function">rallocx()</code> calls do not zero memory that
         was previously allocated.  This is intended for debugging and will
         impact performance negatively.  This option is disabled by default.
-        </p></dd><dt><a name="opt.utrace"></a><span class="term">
-          
-    "<code class="mallctl">opt.utrace</code>"
-  
+        </p></dd><dt><a name="opt.utrace"/><span class="term">
+          <quote><code class="mallctl">opt.utrace</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-utrace</code>]
         </span></dt><dd><p>Allocation tracing based on
         <span class="citerefentry"><span class="refentrytitle">utrace</span>(2)</span> enabled/disabled.  This option
-        is disabled by default.</p></dd><dt><a name="opt.xmalloc"></a><span class="term">
-          
-    "<code class="mallctl">opt.xmalloc</code>"
-  
+        is disabled by default.</p></dd><dt><a name="opt.xmalloc"/><span class="term">
+          <quote><code class="mallctl">opt.xmalloc</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-xmalloc</code>]
         </span></dt><dd><p>Abort-on-out-of-memory enabled/disabled.  If enabled,
         rather than returning failure for any allocation function, display a
         diagnostic message on <code class="constant">STDERR_FILENO</code> and cause the
         program to drop core (using
         <span class="citerefentry"><span class="refentrytitle">abort</span>(3)</span>).  If an application is
         designed to depend on this behavior, set the option at compile time by
         including the following in the source code:
         </p><pre class="programlisting">
 malloc_conf = "xmalloc:true";</pre><p>
-        This option is disabled by default.</p></dd><dt><a name="opt.tcache"></a><span class="term">
-          
-    "<code class="mallctl">opt.tcache</code>"
-  
+        This option is disabled by default.</p></dd><dt><a name="opt.tcache"/><span class="term">
+          <quote><code class="mallctl">opt.tcache</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Thread-specific caching (tcache) enabled/disabled.  When
         there are multiple threads, each thread uses a tcache for objects up to
         a certain size.  Thread-specific caching allows many allocations to be
         satisfied without performing any thread synchronization, at the cost of
-        increased memory use.  See the <a class="link" href="#opt.lg_tcache_max">
-    "<code class="mallctl">opt.lg_tcache_max</code>"
-  </a>
+        increased memory use.  See the <a class="link" href="#opt.lg_tcache_max"><quote><code class="mallctl">opt.lg_tcache_max</code></quote></a>
         option for related tuning information.  This option is enabled by
         default unless running inside <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a>, in which case it is
-        forcefully disabled.</p></dd><dt><a name="opt.lg_tcache_max"></a><span class="term">
-          
-    "<code class="mallctl">opt.lg_tcache_max</code>"
-  
+        forcefully disabled.</p></dd><dt><a name="opt.lg_tcache_max"/><span class="term">
+          <quote><code class="mallctl">opt.lg_tcache_max</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Maximum size class (log base 2) to cache in the
         thread-specific cache (tcache).  At a minimum, all small size classes
         are cached, and at a maximum all large size classes are cached.  The
-        default maximum is 32 KiB (2^15).</p></dd><dt><a name="opt.prof"></a><span class="term">
-          
-    "<code class="mallctl">opt.prof</code>"
-  
+        default maximum is 32 KiB (2^15).</p></dd><dt><a name="opt.prof"/><span class="term">
+          <quote><code class="mallctl">opt.prof</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Memory profiling enabled/disabled.  If enabled, profile
-        memory allocation activity.  See the <a class="link" href="#opt.prof_active">
-    "<code class="mallctl">opt.prof_active</code>"
-  </a>
-        option for on-the-fly activation/deactivation.  See the <a class="link" href="#opt.lg_prof_sample">
-    "<code class="mallctl">opt.lg_prof_sample</code>"
-  </a>
-        option for probabilistic sampling control.  See the <a class="link" href="#opt.prof_accum">
-    "<code class="mallctl">opt.prof_accum</code>"
-  </a>
-        option for control of cumulative sample reporting.  See the <a class="link" href="#opt.lg_prof_interval">
-    "<code class="mallctl">opt.lg_prof_interval</code>"
-  </a>
-        option for information on interval-triggered profile dumping, the <a class="link" href="#opt.prof_gdump">
-    "<code class="mallctl">opt.prof_gdump</code>"
-  </a>
+        memory allocation activity.  See the <a class="link" href="#opt.prof_active"><quote><code class="mallctl">opt.prof_active</code></quote></a>
+        option for on-the-fly activation/deactivation.  See the <a class="link" href="#opt.lg_prof_sample"><quote><code class="mallctl">opt.lg_prof_sample</code></quote></a>
+        option for probabilistic sampling control.  See the <a class="link" href="#opt.prof_accum"><quote><code class="mallctl">opt.prof_accum</code></quote></a>
+        option for control of cumulative sample reporting.  See the <a class="link" href="#opt.lg_prof_interval"><quote><code class="mallctl">opt.lg_prof_interval</code></quote></a>
+        option for information on interval-triggered profile dumping, the <a class="link" href="#opt.prof_gdump"><quote><code class="mallctl">opt.prof_gdump</code></quote></a>
         option for information on high-water-triggered profile dumping, and the
-        <a class="link" href="#opt.prof_final">
-    "<code class="mallctl">opt.prof_final</code>"
-  </a>
+        <a class="link" href="#opt.prof_final"><quote><code class="mallctl">opt.prof_final</code></quote></a>
         option for final profile dumping.  Profile output is compatible with
         the <span class="command"><strong>jeprof</strong></span> command, which is based on the
         <span class="command"><strong>pprof</strong></span> that is developed as part of the <a class="ulink" href="http://code.google.com/p/gperftools/" target="_top">gperftools
-        package</a>.</p></dd><dt><a name="opt.prof_prefix"></a><span class="term">
-          
-    "<code class="mallctl">opt.prof_prefix</code>"
-  
+        package</a>.  See <a class="link" href="#heap_profile_format" title="HEAP PROFILE FORMAT">HEAP PROFILE
+        FORMAT</a> for heap profile format documentation.</p></dd><dt><a name="opt.prof_prefix"/><span class="term">
+          <quote><code class="mallctl">opt.prof_prefix</code></quote>
           (<span class="type">const char *</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Filename prefix for profile dumps.  If the prefix is
         set to the empty string, no automatic dumps will occur; this is
         primarily useful for disabling the automatic final heap dump (which
         also disables leak reporting, if enabled).  The default prefix is
-        <code class="filename">jeprof</code>.</p></dd><dt><a name="opt.prof_active"></a><span class="term">
-          
-    "<code class="mallctl">opt.prof_active</code>"
-  
+        <code class="filename">jeprof</code>.</p></dd><dt><a name="opt.prof_active"/><span class="term">
+          <quote><code class="mallctl">opt.prof_active</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Profiling activated/deactivated.  This is a secondary
         control mechanism that makes it possible to start the application with
-        profiling enabled (see the <a class="link" href="#opt.prof">
-    "<code class="mallctl">opt.prof</code>"
-  </a> option) but
+        profiling enabled (see the <a class="link" href="#opt.prof"><quote><code class="mallctl">opt.prof</code></quote></a> option) but
         inactive, then toggle profiling at any time during program execution
-        with the <a class="link" href="#prof.active">
-    "<code class="mallctl">prof.active</code>"
-  </a> mallctl.
-        This option is enabled by default.</p></dd><dt><a name="opt.prof_thread_active_init"></a><span class="term">
-          
-    "<code class="mallctl">opt.prof_thread_active_init</code>"
-  
+        with the <a class="link" href="#prof.active"><quote><code class="mallctl">prof.active</code></quote></a> mallctl.
+        This option is enabled by default.</p></dd><dt><a name="opt.prof_thread_active_init"/><span class="term">
+          <quote><code class="mallctl">opt.prof_thread_active_init</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
-        </span></dt><dd><p>Initial setting for <a class="link" href="#thread.prof.active">
-    "<code class="mallctl">thread.prof.active</code>"
-  </a>
+        </span></dt><dd><p>Initial setting for <a class="link" href="#thread.prof.active"><quote><code class="mallctl">thread.prof.active</code></quote></a>
         in newly created threads.  The initial setting for newly created threads
-        can also be changed during execution via the <a class="link" href="#prof.thread_active_init">
-    "<code class="mallctl">prof.thread_active_init</code>"
-  </a>
-        mallctl.  This option is enabled by default.</p></dd><dt><a name="opt.lg_prof_sample"></a><span class="term">
-          
-    "<code class="mallctl">opt.lg_prof_sample</code>"
-  
+        can also be changed during execution via the <a class="link" href="#prof.thread_active_init"><quote><code class="mallctl">prof.thread_active_init</code></quote></a>
+        mallctl.  This option is enabled by default.</p></dd><dt><a name="opt.lg_prof_sample"/><span class="term">
+          <quote><code class="mallctl">opt.lg_prof_sample</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Average interval (log base 2) between allocation
         samples, as measured in bytes of allocation activity.  Increasing the
         sampling interval decreases profile fidelity, but also decreases the
         computational overhead.  The default sample interval is 512 KiB (2^19
-        B).</p></dd><dt><a name="opt.prof_accum"></a><span class="term">
-          
-    "<code class="mallctl">opt.prof_accum</code>"
-  
+        B).</p></dd><dt><a name="opt.prof_accum"/><span class="term">
+          <quote><code class="mallctl">opt.prof_accum</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Reporting of cumulative object/byte counts in profile
         dumps enabled/disabled.  If this option is enabled, every unique
         backtrace must be stored for the duration of execution.  Depending on
         the application, this can impose a large memory overhead, and the
         cumulative counts are not always of interest.  This option is disabled
-        by default.</p></dd><dt><a name="opt.lg_prof_interval"></a><span class="term">
-          
-    "<code class="mallctl">opt.lg_prof_interval</code>"
-  
+        by default.</p></dd><dt><a name="opt.lg_prof_interval"/><span class="term">
+          <quote><code class="mallctl">opt.lg_prof_interval</code></quote>
           (<span class="type">ssize_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Average interval (log base 2) between memory profile
         dumps, as measured in bytes of allocation activity.  The actual
         interval between dumps may be sporadic because decentralized allocation
         counters are used to avoid synchronization bottlenecks.  Profiles are
         dumped to files named according to the pattern
         <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.i&lt;iseq&gt;.heap</code>,
         where <code class="literal">&lt;prefix&gt;</code> is controlled by the
-        <a class="link" href="#opt.prof_prefix">
-    "<code class="mallctl">opt.prof_prefix</code>"
-  </a>
+        <a class="link" href="#opt.prof_prefix"><quote><code class="mallctl">opt.prof_prefix</code></quote></a>
         option.  By default, interval-triggered profile dumping is disabled
         (encoded as -1).
-        </p></dd><dt><a name="opt.prof_gdump"></a><span class="term">
-          
-    "<code class="mallctl">opt.prof_gdump</code>"
-  
+        </p></dd><dt><a name="opt.prof_gdump"/><span class="term">
+          <quote><code class="mallctl">opt.prof_gdump</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
-        </span></dt><dd><p>Set the initial state of <a class="link" href="#prof.gdump">
-    "<code class="mallctl">prof.gdump</code>"
-  </a>, which when
+        </span></dt><dd><p>Set the initial state of <a class="link" href="#prof.gdump"><quote><code class="mallctl">prof.gdump</code></quote></a>, which when
         enabled triggers a memory profile dump every time the total virtual
         memory exceeds the previous maximum.  This option is disabled by
-        default.</p></dd><dt><a name="opt.prof_final"></a><span class="term">
-          
-    "<code class="mallctl">opt.prof_final</code>"
-  
+        default.</p></dd><dt><a name="opt.prof_final"/><span class="term">
+          <quote><code class="mallctl">opt.prof_final</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Use an
         <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span> function to dump final memory
         usage to a file named according to the pattern
         <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap</code>,
-        where <code class="literal">&lt;prefix&gt;</code> is controlled by the <a class="link" href="#opt.prof_prefix">
-    "<code class="mallctl">opt.prof_prefix</code>"
-  </a>
-        option.  Note that <code class="function">atexit</code>(<em class="parameter"><code></code></em>) may allocate
+        where <code class="literal">&lt;prefix&gt;</code> is controlled by the <a class="link" href="#opt.prof_prefix"><quote><code class="mallctl">opt.prof_prefix</code></quote></a>
+        option.  Note that <code class="function">atexit()</code> may allocate
         memory during application initialization and then deadlock internally
-        when jemalloc in turn calls <code class="function">atexit</code>(<em class="parameter"><code></code></em>), so
-        this option is not univerally usable (though the application can
-        register its own <code class="function">atexit</code>(<em class="parameter"><code></code></em>) function with
+        when jemalloc in turn calls <code class="function">atexit()</code>, so
+        this option is not universally usable (though the application can
+        register its own <code class="function">atexit()</code> function with
         equivalent functionality).  This option is disabled by
-        default.</p></dd><dt><a name="opt.prof_leak"></a><span class="term">
-          
-    "<code class="mallctl">opt.prof_leak</code>"
-  
+        default.</p></dd><dt><a name="opt.prof_leak"/><span class="term">
+          <quote><code class="mallctl">opt.prof_leak</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Leak reporting enabled/disabled.  If enabled, use an
         <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span> function to report memory leaks
         detected by allocation sampling.  See the
-        <a class="link" href="#opt.prof">
-    "<code class="mallctl">opt.prof</code>"
-  </a> option for
+        <a class="link" href="#opt.prof"><quote><code class="mallctl">opt.prof</code></quote></a> option for
         information on analyzing heap profile output.  This option is disabled
-        by default.</p></dd><dt><a name="thread.arena"></a><span class="term">
-          
-    "<code class="mallctl">thread.arena</code>"
-  
+        by default.</p></dd><dt><a name="thread.arena"/><span class="term">
+          <quote><code class="mallctl">thread.arena</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">rw</code>
         </span></dt><dd><p>Get or set the arena associated with the calling
         thread.  If the specified arena was not initialized beforehand (see the
-        <a class="link" href="#arenas.initialized">
-    "<code class="mallctl">arenas.initialized</code>"
-  </a>
+        <a class="link" href="#arenas.initialized"><quote><code class="mallctl">arenas.initialized</code></quote></a>
         mallctl), it will be automatically initialized as a side effect of
-        calling this interface.</p></dd><dt><a name="thread.allocated"></a><span class="term">
-          
-    "<code class="mallctl">thread.allocated</code>"
-  
+        calling this interface.</p></dd><dt><a name="thread.allocated"/><span class="term">
+          <quote><code class="mallctl">thread.allocated</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Get the total number of bytes ever allocated by the
         calling thread.  This counter has the potential to wrap around; it is
         up to the application to appropriately interpret the counter in such
-        cases.</p></dd><dt><a name="thread.allocatedp"></a><span class="term">
-          
-    "<code class="mallctl">thread.allocatedp</code>"
-  
+        cases.</p></dd><dt><a name="thread.allocatedp"/><span class="term">
+          <quote><code class="mallctl">thread.allocatedp</code></quote>
           (<span class="type">uint64_t *</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Get a pointer to the the value that is returned by the
-        <a class="link" href="#thread.allocated">
-    "<code class="mallctl">thread.allocated</code>"
-  </a>
+        <a class="link" href="#thread.allocated"><quote><code class="mallctl">thread.allocated</code></quote></a>
         mallctl.  This is useful for avoiding the overhead of repeated
-        <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>) calls.</p></dd><dt><a name="thread.deallocated"></a><span class="term">
-          
-    "<code class="mallctl">thread.deallocated</code>"
-  
+        <code class="function">mallctl*()</code> calls.</p></dd><dt><a name="thread.deallocated"/><span class="term">
+          <quote><code class="mallctl">thread.deallocated</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Get the total number of bytes ever deallocated by the
         calling thread.  This counter has the potential to wrap around; it is
         up to the application to appropriately interpret the counter in such
-        cases.</p></dd><dt><a name="thread.deallocatedp"></a><span class="term">
-          
-    "<code class="mallctl">thread.deallocatedp</code>"
-  
+        cases.</p></dd><dt><a name="thread.deallocatedp"/><span class="term">
+          <quote><code class="mallctl">thread.deallocatedp</code></quote>
           (<span class="type">uint64_t *</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Get a pointer to the the value that is returned by the
-        <a class="link" href="#thread.deallocated">
-    "<code class="mallctl">thread.deallocated</code>"
-  </a>
+        <a class="link" href="#thread.deallocated"><quote><code class="mallctl">thread.deallocated</code></quote></a>
         mallctl.  This is useful for avoiding the overhead of repeated
-        <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>) calls.</p></dd><dt><a name="thread.tcache.enabled"></a><span class="term">
-          
-    "<code class="mallctl">thread.tcache.enabled</code>"
-  
+        <code class="function">mallctl*()</code> calls.</p></dd><dt><a name="thread.tcache.enabled"/><span class="term">
+          <quote><code class="mallctl">thread.tcache.enabled</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">rw</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Enable/disable calling thread's tcache.  The tcache is
         implicitly flushed as a side effect of becoming
-        disabled (see <a class="link" href="#thread.tcache.flush">
-    "<code class="mallctl">thread.tcache.flush</code>"
-  </a>).
-        </p></dd><dt><a name="thread.tcache.flush"></a><span class="term">
-          
-    "<code class="mallctl">thread.tcache.flush</code>"
-  
+        disabled (see <a class="link" href="#thread.tcache.flush"><quote><code class="mallctl">thread.tcache.flush</code></quote></a>).
+        </p></dd><dt><a name="thread.tcache.flush"/><span class="term">
+          <quote><code class="mallctl">thread.tcache.flush</code></quote>
           (<span class="type">void</span>)
           <code class="literal">--</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Flush calling thread's thread-specific cache (tcache).
         This interface releases all cached objects and internal data structures
         associated with the calling thread's tcache.  Ordinarily, this interface
         need not be called, since automatic periodic incremental garbage
         collection occurs, and the thread cache is automatically discarded when
         a thread exits.  However, garbage collection is triggered by allocation
         activity, so it is possible for a thread that stops
         allocating/deallocating to retain its cache indefinitely, in which case
-        the developer may find manual flushing useful.</p></dd><dt><a name="thread.prof.name"></a><span class="term">
-          
-    "<code class="mallctl">thread.prof.name</code>"
-  
+        the developer may find manual flushing useful.</p></dd><dt><a name="thread.prof.name"/><span class="term">
+          <quote><code class="mallctl">thread.prof.name</code></quote>
           (<span class="type">const char *</span>)
           <code class="literal">r-</code> or
           <code class="literal">-w</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Get/set the descriptive name associated with the calling
         thread in memory profile dumps.  An internal copy of the name string is
         created, so the input string need not be maintained after this interface
         completes execution.  The output string of this interface should be
         copied for non-ephemeral uses, because multiple implementation details
         can cause asynchronous string deallocation.  Furthermore, each
         invocation of this interface can only read or write; simultaneous
         read/write is not supported due to string lifetime limitations.  The
-        name string must nil-terminated and comprised only of characters in the
-        sets recognized
+        name string must be nil-terminated and comprised only of characters in
+        the sets recognized
         by <span class="citerefentry"><span class="refentrytitle">isgraph</span>(3)</span> and
-        <span class="citerefentry"><span class="refentrytitle">isblank</span>(3)</span>.</p></dd><dt><a name="thread.prof.active"></a><span class="term">
-          
-    "<code class="mallctl">thread.prof.active</code>"
-  
+        <span class="citerefentry"><span class="refentrytitle">isblank</span>(3)</span>.</p></dd><dt><a name="thread.prof.active"/><span class="term">
+          <quote><code class="mallctl">thread.prof.active</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">rw</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Control whether sampling is currently active for the
-        calling thread.  This is an activation mechanism in addition to <a class="link" href="#prof.active">
-    "<code class="mallctl">prof.active</code>"
-  </a>; both must
+        calling thread.  This is an activation mechanism in addition to <a class="link" href="#prof.active"><quote><code class="mallctl">prof.active</code></quote></a>; both must
         be active for the calling thread to sample.  This flag is enabled by
-        default.</p></dd><dt><a name="tcache.create"></a><span class="term">
-          
-    "<code class="mallctl">tcache.create</code>"
-  
+        default.</p></dd><dt><a name="tcache.create"/><span class="term">
+          <quote><code class="mallctl">tcache.create</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Create an explicit thread-specific cache (tcache) and
         return an identifier that can be passed to the <a class="link" href="#MALLOCX_TCACHE"><code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code></a>
         macro to explicitly use the specified cache rather than the
         automatically managed one that is used by default.  Each explicit cache
         can be used by only one thread at a time; the application must assure
         that this constraint holds.
-        </p></dd><dt><a name="tcache.flush"></a><span class="term">
-          
-    "<code class="mallctl">tcache.flush</code>"
-  
+        </p></dd><dt><a name="tcache.flush"/><span class="term">
+          <quote><code class="mallctl">tcache.flush</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">-w</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Flush the specified thread-specific cache (tcache).  The
-        same considerations apply to this interface as to <a class="link" href="#thread.tcache.flush">
-    "<code class="mallctl">thread.tcache.flush</code>"
-  </a>,
-        except that the tcache will never be automatically be discarded.
-        </p></dd><dt><a name="tcache.destroy"></a><span class="term">
-          
-    "<code class="mallctl">tcache.destroy</code>"
-  
+        same considerations apply to this interface as to <a class="link" href="#thread.tcache.flush"><quote><code class="mallctl">thread.tcache.flush</code></quote></a>,
+        except that the tcache will never be automatically discarded.
+        </p></dd><dt><a name="tcache.destroy"/><span class="term">
+          <quote><code class="mallctl">tcache.destroy</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">-w</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Flush the specified thread-specific cache (tcache) and
         make the identifier available for use during a future tcache creation.
-        </p></dd><dt><a name="arena.i.purge"></a><span class="term">
-          
-    "<code class="mallctl">arena.&lt;i&gt;.purge</code>"
-  
+        </p></dd><dt><a name="arena.i.purge"/><span class="term">
+          <quote><code class="mallctl">arena.&lt;i&gt;.purge</code></quote>
           (<span class="type">void</span>)
           <code class="literal">--</code>
-        </span></dt><dd><p>Purge unused dirty pages for arena &lt;i&gt;, or for
-        all arenas if &lt;i&gt; equals <a class="link" href="#arenas.narenas">
-    "<code class="mallctl">arenas.narenas</code>"
-  </a>.
-        </p></dd><dt><a name="arena.i.dss"></a><span class="term">
-          
-    "<code class="mallctl">arena.&lt;i&gt;.dss</code>"
-  
+        </span></dt><dd><p>Purge all unused dirty pages for arena &lt;i&gt;, or for
+        all arenas if &lt;i&gt; equals <a class="link" href="#arenas.narenas"><quote><code class="mallctl">arenas.narenas</code></quote></a>.
+        </p></dd><dt><a name="arena.i.decay"/><span class="term">
+          <quote><code class="mallctl">arena.&lt;i&gt;.decay</code></quote>
+          (<span class="type">void</span>)
+          <code class="literal">--</code>
+        </span></dt><dd><p>Trigger decay-based purging of unused dirty pages for
+        arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals <a class="link" href="#arenas.narenas"><quote><code class="mallctl">arenas.narenas</code></quote></a>.
+        The proportion of unused dirty pages to be purged depends on the current
+        time; see <a class="link" href="#opt.decay_time"><quote><code class="mallctl">opt.decay_time</code></quote></a> for
+        details.</p></dd><dt><a name="arena.i.reset"/><span class="term">
+          <quote><code class="mallctl">arena.&lt;i&gt;.reset</code></quote>
+          (<span class="type">void</span>)
+          <code class="literal">--</code>
+        </span></dt><dd><p>Discard all of the arena's extant allocations.  This
+        interface can only be used with arenas created via <a class="link" href="#arenas.extend"><quote><code class="mallctl">arenas.extend</code></quote></a>.  None
+        of the arena's discarded/cached allocations may accessed afterward.  As
+        part of this requirement, all thread caches which were used to
+        allocate/deallocate in conjunction with the arena must be flushed
+        beforehand.  This interface cannot be used if running inside Valgrind,
+        nor if the <a class="link" href="#opt.quarantine">quarantine</a> size is
+        non-zero.</p></dd><dt><a name="arena.i.dss"/><span class="term">
+          <quote><code class="mallctl">arena.&lt;i&gt;.dss</code></quote>
           (<span class="type">const char *</span>)
           <code class="literal">rw</code>
         </span></dt><dd><p>Set the precedence of dss allocation as related to mmap
         allocation for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals
-        <a class="link" href="#arenas.narenas">
-    "<code class="mallctl">arenas.narenas</code>"
-  </a>.  See
-        <a class="link" href="#opt.dss">
-    "<code class="mallctl">opt.dss</code>"
-  </a> for supported
-        settings.</p></dd><dt><a name="arena.i.lg_dirty_mult"></a><span class="term">
-          
-    "<code class="mallctl">arena.&lt;i&gt;.lg_dirty_mult</code>"
-  
+        <a class="link" href="#arenas.narenas"><quote><code class="mallctl">arenas.narenas</code></quote></a>.  See
+        <a class="link" href="#opt.dss"><quote><code class="mallctl">opt.dss</code></quote></a> for supported
+        settings.</p></dd><dt><a name="arena.i.lg_dirty_mult"/><span class="term">
+          <quote><code class="mallctl">arena.&lt;i&gt;.lg_dirty_mult</code></quote>
           (<span class="type">ssize_t</span>)
           <code class="literal">rw</code>
         </span></dt><dd><p>Current per-arena minimum ratio (log base 2) of active
         to dirty pages for arena &lt;i&gt;.  Each time this interface is set and
         the ratio is increased, pages are synchronously purged as necessary to
-        impose the new ratio.  See <a class="link" href="#opt.lg_dirty_mult">
-    "<code class="mallctl">opt.lg_dirty_mult</code>"
-  </a>
-        for additional information.</p></dd><dt><a name="arena.i.chunk_hooks"></a><span class="term">
-          
-    "<code class="mallctl">arena.&lt;i&gt;.chunk_hooks</code>"
-  
+        impose the new ratio.  See <a class="link" href="#opt.lg_dirty_mult"><quote><code class="mallctl">opt.lg_dirty_mult</code></quote></a>
+        for additional information.</p></dd><dt><a name="arena.i.decay_time"/><span class="term">
+          <quote><code class="mallctl">arena.&lt;i&gt;.decay_time</code></quote>
+          (<span class="type">ssize_t</span>)
+          <code class="literal">rw</code>
+        </span></dt><dd><p>Current per-arena approximate time in seconds from the
+        creation of a set of unused dirty pages until an equivalent set of
+        unused dirty pages is purged and/or reused.  Each time this interface is
+        set, all currently unused dirty pages are considered to have fully
+        decayed, which causes immediate purging of all unused dirty pages unless
+        the decay time is set to -1 (i.e. purging disabled).  See <a class="link" href="#opt.decay_time"><quote><code class="mallctl">opt.decay_time</code></quote></a> for
+        additional information.</p></dd><dt><a name="arena.i.chunk_hooks"/><span class="term">
+          <quote><code class="mallctl">arena.&lt;i&gt;.chunk_hooks</code></quote>
           (<span class="type">chunk_hooks_t</span>)
           <code class="literal">rw</code>
         </span></dt><dd><p>Get or set the chunk management hook functions for arena
         &lt;i&gt;.  The functions must be capable of operating on all extant
         chunks associated with arena &lt;i&gt;, usually by passing unknown
         chunks to the replaced functions.  In practice, it is feasible to
-        control allocation for arenas created via <a class="link" href="#arenas.extend">
-    "<code class="mallctl">arenas.extend</code>"
-  </a> such
+        control allocation for arenas created via <a class="link" href="#arenas.extend"><quote><code class="mallctl">arenas.extend</code></quote></a> such
         that all chunks originate from an application-supplied chunk allocator
         (by setting custom chunk hook functions just after arena creation), but
         the automatically created arenas may have already created chunks prior
         to the application having an opportunity to take over chunk
         allocation.</p><pre class="programlisting">
 typedef struct {
@@ -1006,13 +872,13 @@
         purging, which gives the chunk management functions opportunities to
         reject the most permanent cleanup operations in favor of less permanent
         (and often less costly) operations.  The chunk splitting and merging
         operations can also be opted out of, but this is mainly intended to
         support platforms on which virtual memory mappings provided by the
         operating system kernel do not automatically coalesce and split, e.g.
-        Windows.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef void *<b class="fsfunc">(chunk_alloc_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>bool *<var class="pdparam">zero</var>, </td></tr><tr><td></td><td>bool *<var class="pdparam">commit</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk allocation function conforms to the
+        Windows.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef void *<b class="fsfunc">(chunk_alloc_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td></td><td>bool *<var class="pdparam">zero</var>, </td></tr><tr><td></td><td>bool *<var class="pdparam">commit</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p/></div><p>A chunk allocation function conforms to the
         <span class="type">chunk_alloc_t</span> type and upon success returns a pointer to
         <em class="parameter"><code>size</code></em> bytes of mapped memory on behalf of arena
         <em class="parameter"><code>arena_ind</code></em> such that the chunk's base address is a
         multiple of <em class="parameter"><code>alignment</code></em>, as well as setting
         <em class="parameter"><code>*zero</code></em> to indicate whether the chunk is zeroed and
         <em class="parameter"><code>*commit</code></em> to indicate whether the chunk is
@@ -1027,799 +893,670 @@
         If <em class="parameter"><code>chunk</code></em> is not <code class="constant">NULL</code>, the
         returned pointer must be <em class="parameter"><code>chunk</code></em> on success or
         <code class="constant">NULL</code> on error.  Committed memory may be committed
         in absolute terms as on a system that does not overcommit, or in
         implicit terms as on a system that overcommits and satisfies physical
         memory needs on demand via soft page faults.  Note that replacing the
-        default chunk allocation function makes the arena's <a class="link" href="#arena.i.dss">
-    "<code class="mallctl">arena.&lt;i&gt;.dss</code>"
-  </a>
-        setting irrelevant.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_dalloc_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>
+        default chunk allocation function makes the arena's <a class="link" href="#arena.i.dss"><quote><code class="mallctl">arena.&lt;i&gt;.dss</code></quote></a>
+        setting irrelevant.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_dalloc_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p/></div><p>
         A chunk deallocation function conforms to the
         <span class="type">chunk_dalloc_t</span> type and deallocates a
         <em class="parameter"><code>chunk</code></em> of given <em class="parameter"><code>size</code></em> with
         <em class="parameter"><code>committed</code></em>/decommited memory as indicated, on
         behalf of arena <em class="parameter"><code>arena_ind</code></em>, returning false upon
         success.  If the function returns true, this indicates opt-out from
         deallocation; the virtual memory mapping associated with the chunk
         remains mapped, in the same commit state, and available for future use,
-        in which case it will be automatically retained for later reuse.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_commit_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk commit function conforms to the
+        in which case it will be automatically retained for later reuse.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_commit_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p/></div><p>A chunk commit function conforms to the
         <span class="type">chunk_commit_t</span> type and commits zeroed physical memory to
         back pages within a <em class="parameter"><code>chunk</code></em> of given
         <em class="parameter"><code>size</code></em> at <em class="parameter"><code>offset</code></em> bytes,
         extending for <em class="parameter"><code>length</code></em> on behalf of arena
         <em class="parameter"><code>arena_ind</code></em>, returning false upon success.
         Committed memory may be committed in absolute terms as on a system that
         does not overcommit, or in implicit terms as on a system that
         overcommits and satisfies physical memory needs on demand via soft page
         faults. If the function returns true, this indicates insufficient
-        physical memory to satisfy the request.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_decommit_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk decommit function conforms to the
+        physical memory to satisfy the request.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_decommit_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p/></div><p>A chunk decommit function conforms to the
         <span class="type">chunk_decommit_t</span> type and decommits any physical memory
         that is backing pages within a <em class="parameter"><code>chunk</code></em> of given
         <em class="parameter"><code>size</code></em> at <em class="parameter"><code>offset</code></em> bytes,
         extending for <em class="parameter"><code>length</code></em> on behalf of arena
         <em class="parameter"><code>arena_ind</code></em>, returning false upon success, in which
         case the pages will be committed via the chunk commit function before
         being reused.  If the function returns true, this indicates opt-out from
         decommit; the memory remains committed and available for future use, in
-        which case it will be automatically retained for later reuse.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_purge_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t<var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk purge function conforms to the <span class="type">chunk_purge_t</span>
+        which case it will be automatically retained for later reuse.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_purge_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t<var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p/></div><p>A chunk purge function conforms to the <span class="type">chunk_purge_t</span>
         type and optionally discards physical pages within the virtual memory
         mapping associated with <em class="parameter"><code>chunk</code></em> of given
         <em class="parameter"><code>size</code></em> at <em class="parameter"><code>offset</code></em> bytes,
         extending for <em class="parameter"><code>length</code></em> on behalf of arena
         <em class="parameter"><code>arena_ind</code></em>, returning false if pages within the
         purged virtual memory range will be zero-filled the next time they are
-        accessed.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_split_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_a</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_b</var>, </td></tr><tr><td></td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk split function conforms to the <span class="type">chunk_split_t</span>
+        accessed.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_split_t)</b>(</code></td><td>void *<var class="pdparam">chunk</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_a</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_b</var>, </td></tr><tr><td></td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p/></div><p>A chunk split function conforms to the <span class="type">chunk_split_t</span>
         type and optionally splits <em class="parameter"><code>chunk</code></em> of given
         <em class="parameter"><code>size</code></em> into two adjacent chunks, the first of
         <em class="parameter"><code>size_a</code></em> bytes, and the second of
         <em class="parameter"><code>size_b</code></em> bytes, operating on
         <em class="parameter"><code>committed</code></em>/decommitted memory as indicated, on
         behalf of arena <em class="parameter"><code>arena_ind</code></em>, returning false upon
         success.  If the function returns true, this indicates that the chunk
         remains unsplit and therefore should continue to be operated on as a
-        whole.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_merge_t)</b>(</code></td><td>void *<var class="pdparam">chunk_a</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_a</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">chunk_b</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_b</var>, </td></tr><tr><td></td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p></p></div><p>A chunk merge function conforms to the <span class="type">chunk_merge_t</span>
+        whole.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(chunk_merge_t)</b>(</code></td><td>void *<var class="pdparam">chunk_a</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_a</var>, </td></tr><tr><td></td><td>void *<var class="pdparam">chunk_b</var>, </td></tr><tr><td></td><td>size_t <var class="pdparam">size_b</var>, </td></tr><tr><td></td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td></td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"></div></div><div class="literallayout"><p/></div><p>A chunk merge function conforms to the <span class="type">chunk_merge_t</span>
         type and optionally merges adjacent chunks,
         <em class="parameter"><code>chunk_a</code></em> of given <em class="parameter"><code>size_a</code></em>
         and <em class="parameter"><code>chunk_b</code></em> of given
         <em class="parameter"><code>size_b</code></em> into one contiguous chunk, operating on
         <em class="parameter"><code>committed</code></em>/decommitted memory as indicated, on
         behalf of arena <em class="parameter"><code>arena_ind</code></em>, returning false upon
         success.  If the function returns true, this indicates that the chunks
         remain distinct mappings and therefore should continue to be operated on
-        independently.</p></dd><dt><a name="arenas.narenas"></a><span class="term">
-          
-    "<code class="mallctl">arenas.narenas</code>"
-  
+        independently.</p></dd><dt><a name="arenas.narenas"/><span class="term">
+          <quote><code class="mallctl">arenas.narenas</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>Current limit on number of arenas.</p></dd><dt><a name="arenas.initialized"></a><span class="term">
-          
-    "<code class="mallctl">arenas.initialized</code>"
-  
+        </span></dt><dd><p>Current limit on number of arenas.</p></dd><dt><a name="arenas.initialized"/><span class="term">
+          <quote><code class="mallctl">arenas.initialized</code></quote>
           (<span class="type">bool *</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>An array of <a class="link" href="#arenas.narenas">
-    "<code class="mallctl">arenas.narenas</code>"
-  </a>
+        </span></dt><dd><p>An array of <a class="link" href="#arenas.narenas"><quote><code class="mallctl">arenas.narenas</code></quote></a>
         booleans.  Each boolean indicates whether the corresponding arena is
-        initialized.</p></dd><dt><a name="arenas.lg_dirty_mult"></a><span class="term">
-          
-    "<code class="mallctl">arenas.lg_dirty_mult</code>"
-  
+        initialized.</p></dd><dt><a name="arenas.lg_dirty_mult"/><span class="term">
+          <quote><code class="mallctl">arenas.lg_dirty_mult</code></quote>
           (<span class="type">ssize_t</span>)
           <code class="literal">rw</code>
         </span></dt><dd><p>Current default per-arena minimum ratio (log base 2) of
-        active to dirty pages, used to initialize <a class="link" href="#arena.i.lg_dirty_mult">
-    "<code class="mallctl">arena.&lt;i&gt;.lg_dirty_mult</code>"
-  </a>
-        during arena creation.  See <a class="link" href="#opt.lg_dirty_mult">
-    "<code class="mallctl">opt.lg_dirty_mult</code>"
-  </a>
-        for additional information.</p></dd><dt><a name="arenas.quantum"></a><span class="term">
-          
-    "<code class="mallctl">arenas.quantum</code>"
-  
-          (<span class="type">size_t</span>)
-          <code class="literal">r-</code>
-        </span></dt><dd><p>Quantum size.</p></dd><dt><a name="arenas.page"></a><span class="term">
-          
-    "<code class="mallctl">arenas.page</code>"
-  
-          (<span class="type">size_t</span>)
-          <code class="literal">r-</code>
-        </span></dt><dd><p>Page size.</p></dd><dt><a name="arenas.tcache_max"></a><span class="term">
-          
-    "<code class="mallctl">arenas.tcache_max</code>"
-  
+        active to dirty pages, used to initialize <a class="link" href="#arena.i.lg_dirty_mult"><quote><code class="mallctl">arena.&lt;i&gt;.lg_dirty_mult</code></quote></a>
+        during arena creation.  See <a class="link" href="#opt.lg_dirty_mult"><quote><code class="mallctl">opt.lg_dirty_mult</code></quote></a>
+        for additional information.</p></dd><dt><a name="arenas.decay_time"/><span class="term">
+          <quote><code class="mallctl">arenas.decay_time</code></quote>
+          (<span class="type">ssize_t</span>)
+          <code class="literal">rw</code>
+        </span></dt><dd><p>Current default per-arena approximate time in seconds
+        from the creation of a set of unused dirty pages until an equivalent set
+        of unused dirty pages is purged and/or reused, used to initialize <a class="link" href="#arena.i.decay_time"><quote><code class="mallctl">arena.&lt;i&gt;.decay_time</code></quote></a>
+        during arena creation.  See <a class="link" href="#opt.decay_time"><quote><code class="mallctl">opt.decay_time</code></quote></a> for
+        additional information.</p></dd><dt><a name="arenas.quantum"/><span class="term">
+          <quote><code class="mallctl">arenas.quantum</code></quote>
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+        </span></dt><dd><p>Quantum size.</p></dd><dt><a name="arenas.page"/><span class="term">
+          <quote><code class="mallctl">arenas.page</code></quote>
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+        </span></dt><dd><p>Page size.</p></dd><dt><a name="arenas.tcache_max"/><span class="term">
+          <quote><code class="mallctl">arenas.tcache_max</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-tcache</code>]
-        </span></dt><dd><p>Maximum thread-cached size class.</p></dd><dt><a name="arenas.nbins"></a><span class="term">
-          
-    "<code class="mallctl">arenas.nbins</code>"
-  
+        </span></dt><dd><p>Maximum thread-cached size class.</p></dd><dt><a name="arenas.nbins"/><span class="term">
+          <quote><code class="mallctl">arenas.nbins</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>Number of bin size classes.</p></dd><dt><a name="arenas.nhbins"></a><span class="term">
-          
-    "<code class="mallctl">arenas.nhbins</code>"
-  
+        </span></dt><dd><p>Number of bin size classes.</p></dd><dt><a name="arenas.nhbins"/><span class="term">
+          <quote><code class="mallctl">arenas.nhbins</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-tcache</code>]
         </span></dt><dd><p>Total number of thread cache bin size
-        classes.</p></dd><dt><a name="arenas.bin.i.size"></a><span class="term">
-          
-    "<code class="mallctl">arenas.bin.&lt;i&gt;.size</code>"
-  
+        classes.</p></dd><dt><a name="arenas.bin.i.size"/><span class="term">
+          <quote><code class="mallctl">arenas.bin.&lt;i&gt;.size</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>Maximum size supported by size class.</p></dd><dt><a name="arenas.bin.i.nregs"></a><span class="term">
-          
-    "<code class="mallctl">arenas.bin.&lt;i&gt;.nregs</code>"
-  
+        </span></dt><dd><p>Maximum size supported by size class.</p></dd><dt><a name="arenas.bin.i.nregs"/><span class="term">
+          <quote><code class="mallctl">arenas.bin.&lt;i&gt;.nregs</code></quote>
           (<span class="type">uint32_t</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>Number of regions per page run.</p></dd><dt><a name="arenas.bin.i.run_size"></a><span class="term">
-          
-    "<code class="mallctl">arenas.bin.&lt;i&gt;.run_size</code>"
-  
+        </span></dt><dd><p>Number of regions per page run.</p></dd><dt><a name="arenas.bin.i.run_size"/><span class="term">
+          <quote><code class="mallctl">arenas.bin.&lt;i&gt;.run_size</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>Number of bytes per page run.</p></dd><dt><a name="arenas.nlruns"></a><span class="term">
-          
-    "<code class="mallctl">arenas.nlruns</code>"
-  
+        </span></dt><dd><p>Number of bytes per page run.</p></dd><dt><a name="arenas.nlruns"/><span class="term">
+          <quote><code class="mallctl">arenas.nlruns</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>Total number of large size classes.</p></dd><dt><a name="arenas.lrun.i.size"></a><span class="term">
-          
-    "<code class="mallctl">arenas.lrun.&lt;i&gt;.size</code>"
-  
+        </span></dt><dd><p>Total number of large size classes.</p></dd><dt><a name="arenas.lrun.i.size"/><span class="term">
+          <quote><code class="mallctl">arenas.lrun.&lt;i&gt;.size</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Maximum size supported by this large size
-        class.</p></dd><dt><a name="arenas.nhchunks"></a><span class="term">
-          
-    "<code class="mallctl">arenas.nhchunks</code>"
-  
+        class.</p></dd><dt><a name="arenas.nhchunks"/><span class="term">
+          <quote><code class="mallctl">arenas.nhchunks</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>Total number of huge size classes.</p></dd><dt><a name="arenas.hchunk.i.size"></a><span class="term">
-          
-    "<code class="mallctl">arenas.hchunk.&lt;i&gt;.size</code>"
-  
+        </span></dt><dd><p>Total number of huge size classes.</p></dd><dt><a name="arenas.hchunk.i.size"/><span class="term">
+          <quote><code class="mallctl">arenas.hchunk.&lt;i&gt;.size</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Maximum size supported by this huge size
-        class.</p></dd><dt><a name="arenas.extend"></a><span class="term">
-          
-    "<code class="mallctl">arenas.extend</code>"
-  
+        class.</p></dd><dt><a name="arenas.extend"/><span class="term">
+          <quote><code class="mallctl">arenas.extend</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Extend the array of arenas by appending a new arena,
-        and returning the new arena index.</p></dd><dt><a name="prof.thread_active_init"></a><span class="term">
-          
-    "<code class="mallctl">prof.thread_active_init</code>"
-  
+        and returning the new arena index.</p></dd><dt><a name="prof.thread_active_init"/><span class="term">
+          <quote><code class="mallctl">prof.thread_active_init</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">rw</code>
           [<code class="option">--enable-prof</code>]
-        </span></dt><dd><p>Control the initial setting for <a class="link" href="#thread.prof.active">
-    "<code class="mallctl">thread.prof.active</code>"
-  </a>
-        in newly created threads.  See the <a class="link" href="#opt.prof_thread_active_init">
-    "<code class="mallctl">opt.prof_thread_active_init</code>"
-  </a>
-        option for additional information.</p></dd><dt><a name="prof.active"></a><span class="term">
-          
-    "<code class="mallctl">prof.active</code>"
-  
+        </span></dt><dd><p>Control the initial setting for <a class="link" href="#thread.prof.active"><quote><code class="mallctl">thread.prof.active</code></quote></a>
+        in newly created threads.  See the <a class="link" href="#opt.prof_thread_active_init"><quote><code class="mallctl">opt.prof_thread_active_init</code></quote></a>
+        option for additional information.</p></dd><dt><a name="prof.active"/><span class="term">
+          <quote><code class="mallctl">prof.active</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">rw</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Control whether sampling is currently active.  See the
-        <a class="link" href="#opt.prof_active">
-    "<code class="mallctl">opt.prof_active</code>"
-  </a>
-        option for additional information, as well as the interrelated <a class="link" href="#thread.prof.active">
-    "<code class="mallctl">thread.prof.active</code>"
-  </a>
-        mallctl.</p></dd><dt><a name="prof.dump"></a><span class="term">
-          
-    "<code class="mallctl">prof.dump</code>"
-  
+        <a class="link" href="#opt.prof_active"><quote><code class="mallctl">opt.prof_active</code></quote></a>
+        option for additional information, as well as the interrelated <a class="link" href="#thread.prof.active"><quote><code class="mallctl">thread.prof.active</code></quote></a>
+        mallctl.</p></dd><dt><a name="prof.dump"/><span class="term">
+          <quote><code class="mallctl">prof.dump</code></quote>
           (<span class="type">const char *</span>)
           <code class="literal">-w</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Dump a memory profile to the specified file, or if NULL
         is specified, to a file according to the pattern
         <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.m&lt;mseq&gt;.heap</code>,
         where <code class="literal">&lt;prefix&gt;</code> is controlled by the
-        <a class="link" href="#opt.prof_prefix">
-    "<code class="mallctl">opt.prof_prefix</code>"
-  </a>
-        option.</p></dd><dt><a name="prof.gdump"></a><span class="term">
-          
-    "<code class="mallctl">prof.gdump</code>"
-  
+        <a class="link" href="#opt.prof_prefix"><quote><code class="mallctl">opt.prof_prefix</code></quote></a>
+        option.</p></dd><dt><a name="prof.gdump"/><span class="term">
+          <quote><code class="mallctl">prof.gdump</code></quote>
           (<span class="type">bool</span>)
           <code class="literal">rw</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>When enabled, trigger a memory profile dump every time
         the total virtual memory exceeds the previous maximum.  Profiles are
         dumped to files named according to the pattern
         <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap</code>,
-        where <code class="literal">&lt;prefix&gt;</code> is controlled by the <a class="link" href="#opt.prof_prefix">
-    "<code class="mallctl">opt.prof_prefix</code>"
-  </a>
-        option.</p></dd><dt><a name="prof.reset"></a><span class="term">
-          
-    "<code class="mallctl">prof.reset</code>"
-  
+        where <code class="literal">&lt;prefix&gt;</code> is controlled by the <a class="link" href="#opt.prof_prefix"><quote><code class="mallctl">opt.prof_prefix</code></quote></a>
+        option.</p></dd><dt><a name="prof.reset"/><span class="term">
+          <quote><code class="mallctl">prof.reset</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">-w</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Reset all memory profile statistics, and optionally
-        update the sample rate (see <a class="link" href="#opt.lg_prof_sample">
-    "<code class="mallctl">opt.lg_prof_sample</code>"
-  </a>
-        and <a class="link" href="#prof.lg_sample">
-    "<code class="mallctl">prof.lg_sample</code>"
-  </a>).
-        </p></dd><dt><a name="prof.lg_sample"></a><span class="term">
-          
-    "<code class="mallctl">prof.lg_sample</code>"
-  
+        update the sample rate (see <a class="link" href="#opt.lg_prof_sample"><quote><code class="mallctl">opt.lg_prof_sample</code></quote></a>
+        and <a class="link" href="#prof.lg_sample"><quote><code class="mallctl">prof.lg_sample</code></quote></a>).
+        </p></dd><dt><a name="prof.lg_sample"/><span class="term">
+          <quote><code class="mallctl">prof.lg_sample</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
-        </span></dt><dd><p>Get the current sample rate (see <a class="link" href="#opt.lg_prof_sample">
-    "<code class="mallctl">opt.lg_prof_sample</code>"
-  </a>).
-        </p></dd><dt><a name="prof.interval"></a><span class="term">
-          
-    "<code class="mallctl">prof.interval</code>"
-  
+        </span></dt><dd><p>Get the current sample rate (see <a class="link" href="#opt.lg_prof_sample"><quote><code class="mallctl">opt.lg_prof_sample</code></quote></a>).
+        </p></dd><dt><a name="prof.interval"/><span class="term">
+          <quote><code class="mallctl">prof.interval</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-prof</code>]
         </span></dt><dd><p>Average number of bytes allocated between
-        inverval-based profile dumps.  See the
-        <a class="link" href="#opt.lg_prof_interval">
-    "<code class="mallctl">opt.lg_prof_interval</code>"
-  </a>
-        option for additional information.</p></dd><dt><a name="stats.cactive"></a><span class="term">
-          
-    "<code class="mallctl">stats.cactive</code>"
-  
+        interval-based profile dumps.  See the
+        <a class="link" href="#opt.lg_prof_interval"><quote><code class="mallctl">opt.lg_prof_interval</code></quote></a>
+        option for additional information.</p></dd><dt><a name="stats.cactive"/><span class="term">
+          <quote><code class="mallctl">stats.cactive</code></quote>
           (<span class="type">size_t *</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Pointer to a counter that contains an approximate count
         of the current number of bytes in active pages.  The estimate may be
         high, but never low, because each arena rounds up when computing its
-        contribution to the counter.  Note that the <a class="link" href="#epoch">
-    "<code class="mallctl">epoch</code>"
-  </a> mallctl has no bearing
+        contribution to the counter.  Note that the <a class="link" href="#epoch"><quote><code class="mallctl">epoch</code></quote></a> mallctl has no bearing
         on this counter.  Furthermore, counter consistency is maintained via
         atomic operations, so it is necessary to use an atomic operation in
         order to guarantee a consistent read when dereferencing the pointer.
-        </p></dd><dt><a name="stats.allocated"></a><span class="term">
-          
-    "<code class="mallctl">stats.allocated</code>"
-  
+        </p></dd><dt><a name="stats.allocated"/><span class="term">
+          <quote><code class="mallctl">stats.allocated</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Total number of bytes allocated by the
-        application.</p></dd><dt><a name="stats.active"></a><span class="term">
-          
-    "<code class="mallctl">stats.active</code>"
-  
+        application.</p></dd><dt><a name="stats.active"/><span class="term">
+          <quote><code class="mallctl">stats.active</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Total number of bytes in active pages allocated by the
         application.  This is a multiple of the page size, and greater than or
-        equal to <a class="link" href="#stats.allocated">
-    "<code class="mallctl">stats.allocated</code>"
-  </a>.
+        equal to <a class="link" href="#stats.allocated"><quote><code class="mallctl">stats.allocated</code></quote></a>.
         This does not include <a class="link" href="#stats.arenas.i.pdirty">
-        
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.pdirty</code>"
-  </a>, nor pages
-        entirely devoted to allocator metadata.</p></dd><dt><a name="stats.metadata"></a><span class="term">
-          
-    "<code class="mallctl">stats.metadata</code>"
-  
+        <quote><code class="mallctl">stats.arenas.&lt;i&gt;.pdirty</code></quote></a>, nor pages
+        entirely devoted to allocator metadata.</p></dd><dt><a name="stats.metadata"/><span class="term">
+          <quote><code class="mallctl">stats.metadata</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Total number of bytes dedicated to metadata, which
         comprise base allocations used for bootstrap-sensitive internal
-        allocator data structures, arena chunk headers (see <a class="link" href="#stats.arenas.i.metadata.mapped">
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.mapped</code>"
-  </a>),
-        and internal allocations (see <a class="link" href="#stats.arenas.i.metadata.allocated">
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.allocated</code>"
-  </a>).</p></dd><dt><a name="stats.resident"></a><span class="term">
-          
-    "<code class="mallctl">stats.resident</code>"
-  
+        allocator data structures, arena chunk headers (see <a class="link" href="#stats.arenas.i.metadata.mapped"><quote><code class="mallctl">stats.arenas.&lt;i&gt;.metadata.mapped</code></quote></a>),
+        and internal allocations (see <a class="link" href="#stats.arenas.i.metadata.allocated"><quote><code class="mallctl">stats.arenas.&lt;i&gt;.metadata.allocated</code></quote></a>).</p></dd><dt><a name="stats.resident"/><span class="term">
+          <quote><code class="mallctl">stats.resident</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Maximum number of bytes in physically resident data
         pages mapped by the allocator, comprising all pages dedicated to
         allocator metadata, pages backing active allocations, and unused dirty
         pages.  This is a maximum rather than precise because pages may not
         actually be physically resident if they correspond to demand-zeroed
         virtual memory that has not yet been touched.  This is a multiple of the
-        page size, and is larger than <a class="link" href="#stats.active">
-    "<code class="mallctl">stats.active</code>"
-  </a>.</p></dd><dt><a name="stats.mapped"></a><span class="term">
-          
-    "<code class="mallctl">stats.mapped</code>"
-  
+        page size, and is larger than <a class="link" href="#stats.active"><quote><code class="mallctl">stats.active</code></quote></a>.</p></dd><dt><a name="stats.mapped"/><span class="term">
+          <quote><code class="mallctl">stats.mapped</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Total number of bytes in active chunks mapped by the
         allocator.  This is a multiple of the chunk size, and is larger than
-        <a class="link" href="#stats.active">
-    "<code class="mallctl">stats.active</code>"
-  </a>.
+        <a class="link" href="#stats.active"><quote><code class="mallctl">stats.active</code></quote></a>.
         This does not include inactive chunks, even those that contain unused
         dirty pages, which means that there is no strict ordering between this
-        and <a class="link" href="#stats.resident">
-    "<code class="mallctl">stats.resident</code>"
-  </a>.</p></dd><dt><a name="stats.arenas.i.dss"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.dss</code>"
-  
+        and <a class="link" href="#stats.resident"><quote><code class="mallctl">stats.resident</code></quote></a>.</p></dd><dt><a name="stats.retained"/><span class="term">
+          <quote><code class="mallctl">stats.retained</code></quote>
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Total number of bytes in virtual memory mappings that
+        were retained rather than being returned to the operating system via
+        e.g. <span class="citerefentry"><span class="refentrytitle">munmap</span>(2)</span>.  Retained virtual memory is
+        typically untouched, decommitted, or purged, so it has no strongly
+        associated physical memory (see <a class="link" href="#arena.i.chunk_hooks">chunk hooks</a> for details).  Retained
+        memory is excluded from mapped memory statistics, e.g. <a class="link" href="#stats.mapped"><quote><code class="mallctl">stats.mapped</code></quote></a>.
+        </p></dd><dt><a name="stats.arenas.i.dss"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.dss</code></quote>
           (<span class="type">const char *</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>dss (<span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>) allocation precedence as
-        related to <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> allocation.  See <a class="link" href="#opt.dss">
-    "<code class="mallctl">opt.dss</code>"
-  </a> for details.
-        </p></dd><dt><a name="stats.arenas.i.lg_dirty_mult"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.lg_dirty_mult</code>"
-  
+        related to <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> allocation.  See <a class="link" href="#opt.dss"><quote><code class="mallctl">opt.dss</code></quote></a> for details.
+        </p></dd><dt><a name="stats.arenas.i.lg_dirty_mult"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.lg_dirty_mult</code></quote>
           (<span class="type">ssize_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Minimum ratio (log base 2) of active to dirty pages.
-        See <a class="link" href="#opt.lg_dirty_mult">
-    "<code class="mallctl">opt.lg_dirty_mult</code>"
-  </a>
-        for details.</p></dd><dt><a name="stats.arenas.i.nthreads"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.nthreads</code>"
-  
+        See <a class="link" href="#opt.lg_dirty_mult"><quote><code class="mallctl">opt.lg_dirty_mult</code></quote></a>
+        for details.</p></dd><dt><a name="stats.arenas.i.decay_time"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.decay_time</code></quote>
+          (<span class="type">ssize_t</span>)
+          <code class="literal">r-</code>
+        </span></dt><dd><p>Approximate time in seconds from the creation of a set
+        of unused dirty pages until an equivalent set of unused dirty pages is
+        purged and/or reused.  See <a class="link" href="#opt.decay_time"><quote><code class="mallctl">opt.decay_time</code></quote></a>
+        for details.</p></dd><dt><a name="stats.arenas.i.nthreads"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.nthreads</code></quote>
           (<span class="type">unsigned</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Number of threads currently assigned to
-        arena.</p></dd><dt><a name="stats.arenas.i.pactive"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.pactive</code>"
-  
+        arena.</p></dd><dt><a name="stats.arenas.i.pactive"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.pactive</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
-        </span></dt><dd><p>Number of pages in active runs.</p></dd><dt><a name="stats.arenas.i.pdirty"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.pdirty</code>"
-  
+        </span></dt><dd><p>Number of pages in active runs.</p></dd><dt><a name="stats.arenas.i.pdirty"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.pdirty</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
         </span></dt><dd><p>Number of pages within unused runs that are potentially
-        dirty, and for which <code class="function">madvise</code>(<em class="parameter"><code>...</code></em>, 
-        <em class="parameter"><code><code class="constant">MADV_DONTNEED</code></code></em>) or
-        similar has not been called.</p></dd><dt><a name="stats.arenas.i.mapped"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.mapped</code>"
-  
+        dirty, and for which <code class="function">madvise<em class="parameter"><code>...</code></em>
+        <em class="parameter"><code><code class="constant">MADV_DONTNEED</code></code></em></code> or
+        similar has not been called.</p></dd><dt><a name="stats.arenas.i.mapped"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mapped</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Number of mapped bytes.</p></dd><dt><a name="stats.arenas.i.metadata.mapped"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.mapped</code>"
-  
+        </span></dt><dd><p>Number of mapped bytes.</p></dd><dt><a name="stats.arenas.i.retained"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.retained</code></quote>
+          (<span class="type">size_t</span>)
+          <code class="literal">r-</code>
+          [<code class="option">--enable-stats</code>]
+        </span></dt><dd><p>Number of retained bytes.  See <a class="link" href="#stats.retained"><quote><code class="mallctl">stats.retained</code></quote></a> for
+        details.</p></dd><dt><a name="stats.arenas.i.metadata.mapped"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.metadata.mapped</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Number of mapped bytes in arena chunk headers, which
-        track the states of the non-metadata pages.</p></dd><dt><a name="stats.arenas.i.metadata.allocated"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.allocated</code>"
-  
+        track the states of the non-metadata pages.</p></dd><dt><a name="stats.arenas.i.metadata.allocated"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.metadata.allocated</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Number of bytes dedicated to internal allocations.
         Internal allocations differ from application-originated allocations in
         that they are for internal use, and that they are omitted from heap
-        profiles.  This statistic is reported separately from <a class="link" href="#stats.metadata">
-    "<code class="mallctl">stats.metadata</code>"
-  </a> and
-        <a class="link" href="#stats.arenas.i.metadata.mapped">
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.metadata.mapped</code>"
-  </a>
-        because it overlaps with e.g. the <a class="link" href="#stats.allocated">
-    "<code class="mallctl">stats.allocated</code>"
-  </a> and
-        <a class="link" href="#stats.active">
-    "<code class="mallctl">stats.active</code>"
-  </a>
+        profiles.  This statistic is reported separately from <a class="link" href="#stats.metadata"><quote><code class="mallctl">stats.metadata</code></quote></a> and
+        <a class="link" href="#stats.arenas.i.metadata.mapped"><quote><code class="mallctl">stats.arenas.&lt;i&gt;.metadata.mapped</code></quote></a>
+        because it overlaps with e.g. the <a class="link" href="#stats.allocated"><quote><code class="mallctl">stats.allocated</code></quote></a> and
+        <a class="link" href="#stats.active"><quote><code class="mallctl">stats.active</code></quote></a>
         statistics, whereas the other metadata statistics do
-        not.</p></dd><dt><a name="stats.arenas.i.npurge"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.npurge</code>"
-  
+        not.</p></dd><dt><a name="stats.arenas.i.npurge"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.npurge</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Number of dirty page purge sweeps performed.
-        </p></dd><dt><a name="stats.arenas.i.nmadvise"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.nmadvise</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.nmadvise"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.nmadvise</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Number of <code class="function">madvise</code>(<em class="parameter"><code>...</code></em>, 
-        <em class="parameter"><code><code class="constant">MADV_DONTNEED</code></code></em>) or
-        similar calls made to purge dirty pages.</p></dd><dt><a name="stats.arenas.i.purged"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.purged</code>"
-  
+        </span></dt><dd><p>Number of <code class="function">madvise<em class="parameter"><code>...</code></em>
+        <em class="parameter"><code><code class="constant">MADV_DONTNEED</code></code></em></code> or
+        similar calls made to purge dirty pages.</p></dd><dt><a name="stats.arenas.i.purged"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.purged</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Number of pages purged.</p></dd><dt><a name="stats.arenas.i.small.allocated"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.small.allocated</code>"
-  
+        </span></dt><dd><p>Number of pages purged.</p></dd><dt><a name="stats.arenas.i.small.allocated"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.small.allocated</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Number of bytes currently allocated by small objects.
-        </p></dd><dt><a name="stats.arenas.i.small.nmalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.small.nmalloc</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.small.nmalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.small.nmalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of allocation requests served by
-        small bins.</p></dd><dt><a name="stats.arenas.i.small.ndalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.small.ndalloc</code>"
-  
+        small bins.</p></dd><dt><a name="stats.arenas.i.small.ndalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.small.ndalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of small objects returned to bins.
-        </p></dd><dt><a name="stats.arenas.i.small.nrequests"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.small.nrequests</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.small.nrequests"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.small.nrequests</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of small allocation requests.
-        </p></dd><dt><a name="stats.arenas.i.large.allocated"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.large.allocated</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.large.allocated"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.large.allocated</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Number of bytes currently allocated by large objects.
-        </p></dd><dt><a name="stats.arenas.i.large.nmalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.large.nmalloc</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.large.nmalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.large.nmalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of large allocation requests served
-        directly by the arena.</p></dd><dt><a name="stats.arenas.i.large.ndalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.large.ndalloc</code>"
-  
+        directly by the arena.</p></dd><dt><a name="stats.arenas.i.large.ndalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.large.ndalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of large deallocation requests served
-        directly by the arena.</p></dd><dt><a name="stats.arenas.i.large.nrequests"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.large.nrequests</code>"
-  
+        directly by the arena.</p></dd><dt><a name="stats.arenas.i.large.nrequests"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.large.nrequests</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of large allocation requests.
-        </p></dd><dt><a name="stats.arenas.i.huge.allocated"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.huge.allocated</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.huge.allocated"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.huge.allocated</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Number of bytes currently allocated by huge objects.
-        </p></dd><dt><a name="stats.arenas.i.huge.nmalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.huge.nmalloc</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.huge.nmalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.huge.nmalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of huge allocation requests served
-        directly by the arena.</p></dd><dt><a name="stats.arenas.i.huge.ndalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.huge.ndalloc</code>"
-  
+        directly by the arena.</p></dd><dt><a name="stats.arenas.i.huge.ndalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.huge.ndalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of huge deallocation requests served
-        directly by the arena.</p></dd><dt><a name="stats.arenas.i.huge.nrequests"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.huge.nrequests</code>"
-  
+        directly by the arena.</p></dd><dt><a name="stats.arenas.i.huge.nrequests"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.huge.nrequests</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of huge allocation requests.
-        </p></dd><dt><a name="stats.arenas.i.bins.j.nmalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nmalloc</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.bins.j.nmalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nmalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of allocations served by bin.
-        </p></dd><dt><a name="stats.arenas.i.bins.j.ndalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.ndalloc</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.bins.j.ndalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.ndalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of allocations returned to bin.
-        </p></dd><dt><a name="stats.arenas.i.bins.j.nrequests"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nrequests</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.bins.j.nrequests"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nrequests</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of allocation
-        requests.</p></dd><dt><a name="stats.arenas.i.bins.j.curregs"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curregs</code>"
-  
+        requests.</p></dd><dt><a name="stats.arenas.i.bins.j.curregs"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curregs</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Current number of regions for this size
-        class.</p></dd><dt><a name="stats.arenas.i.bins.j.nfills"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nfills</code>"
-  
+        class.</p></dd><dt><a name="stats.arenas.i.bins.j.nfills"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nfills</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code> <code class="option">--enable-tcache</code>]
-        </span></dt><dd><p>Cumulative number of tcache fills.</p></dd><dt><a name="stats.arenas.i.bins.j.nflushes"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nflushes</code>"
-  
+        </span></dt><dd><p>Cumulative number of tcache fills.</p></dd><dt><a name="stats.arenas.i.bins.j.nflushes"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nflushes</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code> <code class="option">--enable-tcache</code>]
-        </span></dt><dd><p>Cumulative number of tcache flushes.</p></dd><dt><a name="stats.arenas.i.bins.j.nruns"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nruns</code>"
-  
+        </span></dt><dd><p>Cumulative number of tcache flushes.</p></dd><dt><a name="stats.arenas.i.bins.j.nruns"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nruns</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Cumulative number of runs created.</p></dd><dt><a name="stats.arenas.i.bins.j.nreruns"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nreruns</code>"
-  
+        </span></dt><dd><p>Cumulative number of runs created.</p></dd><dt><a name="stats.arenas.i.bins.j.nreruns"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nreruns</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of times the current run from which
-        to allocate changed.</p></dd><dt><a name="stats.arenas.i.bins.j.curruns"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curruns</code>"
-  
+        to allocate changed.</p></dd><dt><a name="stats.arenas.i.bins.j.curruns"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curruns</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
-        </span></dt><dd><p>Current number of runs.</p></dd><dt><a name="stats.arenas.i.lruns.j.nmalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.nmalloc</code>"
-  
+        </span></dt><dd><p>Current number of runs.</p></dd><dt><a name="stats.arenas.i.lruns.j.nmalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.nmalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of allocation requests for this size
-        class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.lruns.j.ndalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.ndalloc</code>"
-  
+        class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.lruns.j.ndalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.ndalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of deallocation requests for this
-        size class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.lruns.j.nrequests"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.nrequests</code>"
-  
+        size class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.lruns.j.nrequests"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.nrequests</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of allocation requests for this size
-        class.</p></dd><dt><a name="stats.arenas.i.lruns.j.curruns"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.curruns</code>"
-  
+        class.</p></dd><dt><a name="stats.arenas.i.lruns.j.curruns"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.curruns</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Current number of runs for this size class.
-        </p></dd><dt><a name="stats.arenas.i.hchunks.j.nmalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nmalloc</code>"
-  
+        </p></dd><dt><a name="stats.arenas.i.hchunks.j.nmalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nmalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of allocation requests for this size
-        class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.hchunks.j.ndalloc"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.ndalloc</code>"
-  
+        class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.hchunks.j.ndalloc"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.ndalloc</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of deallocation requests for this
-        size class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.hchunks.j.nrequests"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nrequests</code>"
-  
+        size class served directly by the arena.</p></dd><dt><a name="stats.arenas.i.hchunks.j.nrequests"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.nrequests</code></quote>
           (<span class="type">uint64_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Cumulative number of allocation requests for this size
-        class.</p></dd><dt><a name="stats.arenas.i.hchunks.j.curhchunks"></a><span class="term">
-          
-    "<code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.curhchunks</code>"
-  
+        class.</p></dd><dt><a name="stats.arenas.i.hchunks.j.curhchunks"/><span class="term">
+          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.hchunks.&lt;j&gt;.curhchunks</code></quote>
           (<span class="type">size_t</span>)
           <code class="literal">r-</code>
           [<code class="option">--enable-stats</code>]
         </span></dt><dd><p>Current number of huge allocations for this size class.
-        </p></dd></dl></div></div><div class="refsect1"><a name="debugging_malloc_problems"></a><h2>DEBUGGING MALLOC PROBLEMS</h2><p>When debugging, it is a good idea to configure/build jemalloc with
+        </p></dd></dl></div></div><div class="refsect1"><a name="heap_profile_format"/><h2>HEAP PROFILE FORMAT</h2><p>Although the heap profiling functionality was originally designed to
+    be compatible with the
+    <span class="command"><strong>pprof</strong></span> command that is developed as part of the <a class="ulink" href="http://code.google.com/p/gperftools/" target="_top">gperftools
+    package</a>, the addition of per thread heap profiling functionality
+    required a different heap profile format.  The <span class="command"><strong>jeprof</strong></span>
+    command is derived from <span class="command"><strong>pprof</strong></span>, with enhancements to
+    support the heap profile format described here.</p><p>In the following hypothetical heap profile, <code class="constant">[...]</code>
+    indicates elision for the sake of compactness.  </p><pre class="programlisting">
+heap_v2/524288
+  t*: 28106: 56637512 [0: 0]
+  [...]
+  t3: 352: 16777344 [0: 0]
+  [...]
+  t99: 17754: 29341640 [0: 0]
+  [...]
+@ 0x5f86da8 0x5f5a1dc [...] 0x29e4d4e 0xa200316 0xabb2988 [...]
+  t*: 13: 6688 [0: 0]
+  t3: 12: 6496 [0: ]
+  t99: 1: 192 [0: 0]
+[...]
+
+MAPPED_LIBRARIES:
+[...]</pre><p> The following matches the above heap profile, but most
+tokens are replaced with <code class="constant">&lt;description&gt;</code> to indicate
+descriptions of the corresponding fields.  </p><pre class="programlisting">
+&lt;heap_profile_format_version&gt;/&lt;mean_sample_interval&gt;
+  &lt;aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
+  [...]
+  &lt;thread_3_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt;[&lt;cumobjs&gt;: &lt;cumbytes&gt;]
+  [...]
+  &lt;thread_99_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt;[&lt;cumobjs&gt;: &lt;cumbytes&gt;]
+  [...]
+@ &lt;top_frame&gt; &lt;frame&gt; [...] &lt;frame&gt; &lt;frame&gt; &lt;frame&gt; [...]
+  &lt;backtrace_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
+  &lt;backtrace_thread_3&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
+  &lt;backtrace_thread_99&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
+[...]
+
+MAPPED_LIBRARIES:
+&lt;/proc/&lt;pid&gt;/maps&gt;</pre></div><div class="refsect1"><a name="debugging_malloc_problems"/><h2>DEBUGGING MALLOC PROBLEMS</h2><p>When debugging, it is a good idea to configure/build jemalloc with
     the <code class="option">--enable-debug</code> and <code class="option">--enable-fill</code>
     options, and recompile the program with suitable options and symbols for
     debugger support.  When so configured, jemalloc incorporates a wide variety
     of run-time assertions that catch application errors such as double-free,
-    write-after-free, etc.</p><p>Programs often accidentally depend on &#8220;uninitialized&#8221;
+    write-after-free, etc.</p><p>Programs often accidentally depend on <span class="quote"><span class="quote">uninitialized</span></span>
     memory actually being filled with zero bytes.  Junk filling
-    (see the <a class="link" href="#opt.junk">
-    "<code class="mallctl">opt.junk</code>"
-  </a>
+    (see the <a class="link" href="#opt.junk"><quote><code class="mallctl">opt.junk</code></quote></a>
     option) tends to expose such bugs in the form of obviously incorrect
     results and/or coredumps.  Conversely, zero
-    filling (see the <a class="link" href="#opt.zero">
-    "<code class="mallctl">opt.zero</code>"
-  </a> option) eliminates
+    filling (see the <a class="link" href="#opt.zero"><quote><code class="mallctl">opt.zero</code></quote></a> option) eliminates
     the symptoms of such bugs.  Between these two options, it is usually
     possible to quickly detect, diagnose, and eliminate such bugs.</p><p>This implementation does not provide much detail about the problems
     it detects, because the performance impact for storing such information
     would be prohibitive.  However, jemalloc does integrate with the most
     excellent <a class="ulink" href="http://valgrind.org/" target="_top">Valgrind</a> tool if the
-    <code class="option">--enable-valgrind</code> configuration option is enabled.</p></div><div class="refsect1"><a name="diagnostic_messages"></a><h2>DIAGNOSTIC MESSAGES</h2><p>If any of the memory allocation/deallocation functions detect an
+    <code class="option">--enable-valgrind</code> configuration option is enabled.</p></div><div class="refsect1"><a name="diagnostic_messages"/><h2>DIAGNOSTIC MESSAGES</h2><p>If any of the memory allocation/deallocation functions detect an
     error or warning condition, a message will be printed to file descriptor
     <code class="constant">STDERR_FILENO</code>.  Errors will result in the process
-    dumping core.  If the <a class="link" href="#opt.abort">
-    "<code class="mallctl">opt.abort</code>"
-  </a> option is set, most
+    dumping core.  If the <a class="link" href="#opt.abort"><quote><code class="mallctl">opt.abort</code></quote></a> option is set, most
     warnings are treated as errors.</p><p>The <code class="varname">malloc_message</code> variable allows the programmer
     to override the function which emits the text strings forming the errors
     and warnings if for some reason the <code class="constant">STDERR_FILENO</code> file
     descriptor is not suitable for this.
-    <code class="function">malloc_message</code>(<em class="parameter"><code></code></em>) takes the
+    <code class="function">malloc_message()</code> takes the
     <em class="parameter"><code>cbopaque</code></em> pointer argument that is
     <code class="constant">NULL</code> unless overridden by the arguments in a call to
-    <code class="function">malloc_stats_print</code>(<em class="parameter"><code></code></em>), followed by a string
+    <code class="function">malloc_stats_print()</code>, followed by a string
     pointer.  Please note that doing anything which tries to allocate memory in
     this function is likely to result in a crash or deadlock.</p><p>All messages are prefixed by
-    &#8220;<code class="computeroutput">&lt;jemalloc&gt;: </code>&#8221;.</p></div><div class="refsect1"><a name="return_values"></a><h2>RETURN VALUES</h2><div class="refsect2"><a name="idp46949776"></a><h3>Standard API</h3><p>The <code class="function">malloc</code>(<em class="parameter"><code></code></em>) and
-      <code class="function">calloc</code>(<em class="parameter"><code></code></em>) functions return a pointer to the
+    <span class="quote"><span class="quote"><code class="computeroutput">&lt;jemalloc&gt;: </code></span></span>.</p></div><div class="refsect1"><a name="return_values"/><h2>RETURN VALUES</h2><div class="refsect2"><a name="idm45291897515152"/><h3>Standard API</h3><p>The <code class="function">malloc()</code> and
+      <code class="function">calloc()</code> functions return a pointer to the
       allocated memory if successful; otherwise a <code class="constant">NULL</code>
       pointer is returned and <code class="varname">errno</code> is set to
-      <span class="errorname">ENOMEM</span>.</p><p>The <code class="function">posix_memalign</code>(<em class="parameter"><code></code></em>) function
+      <span class="errorname">ENOMEM</span>.</p><p>The <code class="function">posix_memalign()</code> function
       returns the value 0 if successful; otherwise it returns an error value.
-      The <code class="function">posix_memalign</code>(<em class="parameter"><code></code></em>) function will fail
+      The <code class="function">posix_memalign()</code> function will fail
       if:
         </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorname">EINVAL</span></span></dt><dd><p>The <em class="parameter"><code>alignment</code></em> parameter is
             not a power of 2 at least as large as
             <code class="code">sizeof(<span class="type">void *</span>)</code>.
             </p></dd><dt><span class="term"><span class="errorname">ENOMEM</span></span></dt><dd><p>Memory allocation error.</p></dd></dl></div><p>
-      </p><p>The <code class="function">aligned_alloc</code>(<em class="parameter"><code></code></em>) function returns
+      </p><p>The <code class="function">aligned_alloc()</code> function returns
       a pointer to the allocated memory if successful; otherwise a
       <code class="constant">NULL</code> pointer is returned and
       <code class="varname">errno</code> is set.  The
-      <code class="function">aligned_alloc</code>(<em class="parameter"><code></code></em>) function will fail if:
+      <code class="function">aligned_alloc()</code> function will fail if:
         </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorname">EINVAL</span></span></dt><dd><p>The <em class="parameter"><code>alignment</code></em> parameter is
             not a power of 2.
             </p></dd><dt><span class="term"><span class="errorname">ENOMEM</span></span></dt><dd><p>Memory allocation error.</p></dd></dl></div><p>
-      </p><p>The <code class="function">realloc</code>(<em class="parameter"><code></code></em>) function returns a
+      </p><p>The <code class="function">realloc()</code> function returns a
       pointer, possibly identical to <em class="parameter"><code>ptr</code></em>, to the
       allocated memory if successful; otherwise a <code class="constant">NULL</code>
       pointer is returned, and <code class="varname">errno</code> is set to
       <span class="errorname">ENOMEM</span> if the error was the result of an
-      allocation failure.  The <code class="function">realloc</code>(<em class="parameter"><code></code></em>)
+      allocation failure.  The <code class="function">realloc()</code>
       function always leaves the original buffer intact when an error occurs.
-      </p><p>The <code class="function">free</code>(<em class="parameter"><code></code></em>) function returns no
-      value.</p></div><div class="refsect2"><a name="idp46974576"></a><h3>Non-standard API</h3><p>The <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) and
-      <code class="function">rallocx</code>(<em class="parameter"><code></code></em>) functions return a pointer to
+      </p><p>The <code class="function">free()</code> function returns no
+      value.</p></div><div class="refsect2"><a name="idm45291897493664"/><h3>Non-standard API</h3><p>The <code class="function">mallocx()</code> and
+      <code class="function">rallocx()</code> functions return a pointer to
       the allocated memory if successful; otherwise a <code class="constant">NULL</code>
       pointer is returned to indicate insufficient contiguous memory was
-      available to service the allocation request.  </p><p>The <code class="function">xallocx</code>(<em class="parameter"><code></code></em>) function returns the
+      available to service the allocation request.  </p><p>The <code class="function">xallocx()</code> function returns the
       real size of the resulting resized allocation pointed to by
       <em class="parameter"><code>ptr</code></em>, which is a value less than
       <em class="parameter"><code>size</code></em> if the allocation could not be adequately
-      grown in place.  </p><p>The <code class="function">sallocx</code>(<em class="parameter"><code></code></em>) function returns the
+      grown in place.  </p><p>The <code class="function">sallocx()</code> function returns the
       real size of the allocation pointed to by <em class="parameter"><code>ptr</code></em>.
-      </p><p>The <code class="function">nallocx</code>(<em class="parameter"><code></code></em>) returns the real size
+      </p><p>The <code class="function">nallocx()</code> returns the real size
       that would result from a successful equivalent
-      <code class="function">mallocx</code>(<em class="parameter"><code></code></em>) function call, or zero if
-      insufficient memory is available to perform the size computation.  </p><p>The <code class="function">mallctl</code>(<em class="parameter"><code></code></em>),
-      <code class="function">mallctlnametomib</code>(<em class="parameter"><code></code></em>), and
-      <code class="function">mallctlbymib</code>(<em class="parameter"><code></code></em>) functions return 0 on
+      <code class="function">mallocx()</code> function call, or zero if
+      insufficient memory is available to perform the size computation.  </p><p>The <code class="function">mallctl()</code>,
+      <code class="function">mallctlnametomib()</code>, and
+      <code class="function">mallctlbymib()</code> functions return 0 on
       success; otherwise they return an error value.  The functions will fail
       if:
         </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorname">EINVAL</span></span></dt><dd><p><em class="parameter"><code>newp</code></em> is not
             <code class="constant">NULL</code>, and <em class="parameter"><code>newlen</code></em> is too
             large or too small.  Alternatively, <em class="parameter"><code>*oldlenp</code></em>
             is too large or too small; in this case as much data as possible
             are read despite the error.</p></dd><dt><span class="term"><span class="errorname">ENOENT</span></span></dt><dd><p><em class="parameter"><code>name</code></em> or
             <em class="parameter"><code>mib</code></em> specifies an unknown/invalid
             value.</p></dd><dt><span class="term"><span class="errorname">EPERM</span></span></dt><dd><p>Attempt to read or write void value, or attempt to
             write read-only value.</p></dd><dt><span class="term"><span class="errorname">EAGAIN</span></span></dt><dd><p>A memory allocation failure
             occurred.</p></dd><dt><span class="term"><span class="errorname">EFAULT</span></span></dt><dd><p>An interface with side effects failed in some way
-            not directly related to <code class="function">mallctl*</code>(<em class="parameter"><code></code></em>)
+            not directly related to <code class="function">mallctl*()</code>
             read/write processing.</p></dd></dl></div><p>
-      </p><p>The <code class="function">malloc_usable_size</code>(<em class="parameter"><code></code></em>) function
+      </p><p>The <code class="function">malloc_usable_size()</code> function
       returns the usable size of the allocation pointed to by
-      <em class="parameter"><code>ptr</code></em>.  </p></div></div><div class="refsect1"><a name="environment"></a><h2>ENVIRONMENT</h2><p>The following environment variable affects the execution of the
+      <em class="parameter"><code>ptr</code></em>.  </p></div></div><div class="refsect1"><a name="environment"/><h2>ENVIRONMENT</h2><p>The following environment variable affects the execution of the
     allocation functions:
       </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="envar">MALLOC_CONF</code></span></dt><dd><p>If the environment variable
           <code class="envar">MALLOC_CONF</code> is set, the characters it contains
           will be interpreted as options.</p></dd></dl></div><p>
-    </p></div><div class="refsect1"><a name="examples"></a><h2>EXAMPLES</h2><p>To dump core whenever a problem occurs:
+    </p></div><div class="refsect1"><a name="examples"/><h2>EXAMPLES</h2><p>To dump core whenever a problem occurs:
       </p><pre class="screen">ln -s 'abort:true' /etc/malloc.conf</pre><p>
     </p><p>To specify in the source a chunk size that is 16 MiB:
       </p><pre class="programlisting">
-malloc_conf = "lg_chunk:24";</pre></div><div class="refsect1"><a name="see_also"></a><h2>SEE ALSO</h2><p><span class="citerefentry"><span class="refentrytitle">madvise</span>(2)</span>,
+malloc_conf = "lg_chunk:24";</pre></div><div class="refsect1"><a name="see_also"/><h2>SEE ALSO</h2><p><span class="citerefentry"><span class="refentrytitle">madvise</span>(2)</span>,
     <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span>,
     <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>,
     <span class="citerefentry"><span class="refentrytitle">utrace</span>(2)</span>,
     <span class="citerefentry"><span class="refentrytitle">alloca</span>(3)</span>,
     <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span>,
-    <span class="citerefentry"><span class="refentrytitle">getpagesize</span>(3)</span></p></div><div class="refsect1"><a name="standards"></a><h2>STANDARDS</h2><p>The <code class="function">malloc</code>(<em class="parameter"><code></code></em>),
-    <code class="function">calloc</code>(<em class="parameter"><code></code></em>),
-    <code class="function">realloc</code>(<em class="parameter"><code></code></em>), and
-    <code class="function">free</code>(<em class="parameter"><code></code></em>) functions conform to ISO/IEC
-    9899:1990 (&#8220;ISO C90&#8221;).</p><p>The <code class="function">posix_memalign</code>(<em class="parameter"><code></code></em>) function conforms
-    to IEEE Std 1003.1-2001 (&#8220;POSIX.1&#8221;).</p></div></div></body></html>
+    <span class="citerefentry"><span class="refentrytitle">getpagesize</span>(3)</span></p></div><div class="refsect1"><a name="standards"/><h2>STANDARDS</h2><p>The <code class="function">malloc()</code>,
+    <code class="function">calloc()</code>,
+    <code class="function">realloc()</code>, and
+    <code class="function">free()</code> functions conform to ISO/IEC
+    9899:1990 (<span class="quote"><span class="quote">ISO C90</span></span>).</p><p>The <code class="function">posix_memalign()</code> function conforms
+    to IEEE Std 1003.1-2001 (<span class="quote"><span class="quote">POSIX.1</span></span>).</p></div></div></body></html>
\ No newline at end of file
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/jemalloc.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/jemalloc.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/jemalloc.xml	2017-09-27 23:00:17.402936200 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/jemalloc.xml	2017-09-27 23:01:52.382932719 +0800
@@ -6,13 +6,13 @@
 ]>
 
 <refentry>
   <refentryinfo>
     <title>User Manual</title>
     <productname>jemalloc</productname>
-    <releaseinfo role="version">4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c</releaseinfo>
+    <releaseinfo role="version">4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc</releaseinfo>
     <authorgroup>
       <author>
         <firstname>Jason</firstname>
         <surname>Evans</surname>
         <personblurb>Author</personblurb>
       </author>
@@ -47,15 +47,15 @@
     <refname>malloc_usable_size</refname>
     -->
     <refpurpose>general purpose memory allocation functions</refpurpose>
   </refnamediv>
   <refsect1 id="library">
     <title>LIBRARY</title>
-    <para>This manual describes jemalloc 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c.  More information
+    <para>This manual describes jemalloc 4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc.  More information
     can be found at the <ulink
-    url="http://www.canonware.com/jemalloc/">jemalloc website</ulink>.</para>
+    url="http://jemalloc.net/">jemalloc website</ulink>.</para>
   </refsect1>
   <refsynopsisdiv>
     <title>SYNOPSIS</title>
     <funcsynopsis>
       <funcsynopsisinfo>#include &lt;<filename class="headerfile">jemalloc/jemalloc.h</filename>&gt;</funcsynopsisinfo>
       <refsect2>
@@ -177,69 +177,69 @@
   </refsynopsisdiv>
   <refsect1 id="description">
     <title>DESCRIPTION</title>
     <refsect2>
       <title>Standard API</title>
 
-      <para>The <function>malloc<parameter/></function> function allocates
+      <para>The <function>malloc()</function> function allocates
       <parameter>size</parameter> bytes of uninitialized memory.  The allocated
       space is suitably aligned (after possible pointer coercion) for storage
       of any type of object.</para>
 
-      <para>The <function>calloc<parameter/></function> function allocates
+      <para>The <function>calloc()</function> function allocates
       space for <parameter>number</parameter> objects, each
       <parameter>size</parameter> bytes in length.  The result is identical to
-      calling <function>malloc<parameter/></function> with an argument of
+      calling <function>malloc()</function> with an argument of
       <parameter>number</parameter> * <parameter>size</parameter>, with the
       exception that the allocated memory is explicitly initialized to zero
       bytes.</para>
 
-      <para>The <function>posix_memalign<parameter/></function> function
+      <para>The <function>posix_memalign()</function> function
       allocates <parameter>size</parameter> bytes of memory such that the
       allocation's base address is a multiple of
       <parameter>alignment</parameter>, and returns the allocation in the value
       pointed to by <parameter>ptr</parameter>.  The requested
       <parameter>alignment</parameter> must be a power of 2 at least as large as
       <code language="C">sizeof(<type>void *</type>)</code>.</para>
 
-      <para>The <function>aligned_alloc<parameter/></function> function
+      <para>The <function>aligned_alloc()</function> function
       allocates <parameter>size</parameter> bytes of memory such that the
       allocation's base address is a multiple of
       <parameter>alignment</parameter>.  The requested
       <parameter>alignment</parameter> must be a power of 2.  Behavior is
       undefined if <parameter>size</parameter> is not an integral multiple of
       <parameter>alignment</parameter>.</para>
 
-      <para>The <function>realloc<parameter/></function> function changes the
+      <para>The <function>realloc()</function> function changes the
       size of the previously allocated memory referenced by
       <parameter>ptr</parameter> to <parameter>size</parameter> bytes.  The
       contents of the memory are unchanged up to the lesser of the new and old
       sizes.  If the new size is larger, the contents of the newly allocated
       portion of the memory are undefined.  Upon success, the memory referenced
       by <parameter>ptr</parameter> is freed and a pointer to the newly
       allocated memory is returned.  Note that
-      <function>realloc<parameter/></function> may move the memory allocation,
+      <function>realloc()</function> may move the memory allocation,
       resulting in a different return value than <parameter>ptr</parameter>.
       If <parameter>ptr</parameter> is <constant>NULL</constant>, the
-      <function>realloc<parameter/></function> function behaves identically to
-      <function>malloc<parameter/></function> for the specified size.</para>
+      <function>realloc()</function> function behaves identically to
+      <function>malloc()</function> for the specified size.</para>
 
-      <para>The <function>free<parameter/></function> function causes the
+      <para>The <function>free()</function> function causes the
       allocated memory referenced by <parameter>ptr</parameter> to be made
       available for future allocations.  If <parameter>ptr</parameter> is
       <constant>NULL</constant>, no action occurs.</para>
     </refsect2>
     <refsect2>
       <title>Non-standard API</title>
-      <para>The <function>mallocx<parameter/></function>,
-      <function>rallocx<parameter/></function>,
-      <function>xallocx<parameter/></function>,
-      <function>sallocx<parameter/></function>,
-      <function>dallocx<parameter/></function>,
-      <function>sdallocx<parameter/></function>, and
-      <function>nallocx<parameter/></function> functions all have a
+      <para>The <function>mallocx()</function>,
+      <function>rallocx()</function>,
+      <function>xallocx()</function>,
+      <function>sallocx()</function>,
+      <function>dallocx()</function>,
+      <function>sdallocx()</function>, and
+      <function>nallocx()</function> functions all have a
       <parameter>flags</parameter> argument that can be used to specify
       options.  The functions only check the options that are contextually
       relevant.  Use bitwise or (<code language="C">|</code>) operations to
       specify one or more of the following:
         <variablelist>
           <varlistentry id="MALLOCX_LG_ALIGN">
@@ -304,65 +304,63 @@
             macro does not validate that <parameter>a</parameter> specifies an
             arena index in the valid range.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
-      <para>The <function>mallocx<parameter/></function> function allocates at
+      <para>The <function>mallocx()</function> function allocates at
       least <parameter>size</parameter> bytes of memory, and returns a pointer
       to the base address of the allocation.  Behavior is undefined if
-      <parameter>size</parameter> is <constant>0</constant>, or if request size
-      overflows due to size class and/or alignment constraints.</para>
+      <parameter>size</parameter> is <constant>0</constant>.</para>
 
-      <para>The <function>rallocx<parameter/></function> function resizes the
+      <para>The <function>rallocx()</function> function resizes the
       allocation at <parameter>ptr</parameter> to be at least
       <parameter>size</parameter> bytes, and returns a pointer to the base
       address of the resulting allocation, which may or may not have moved from
       its original location.  Behavior is undefined if
-      <parameter>size</parameter> is <constant>0</constant>, or if request size
-      overflows due to size class and/or alignment constraints.</para>
+      <parameter>size</parameter> is <constant>0</constant>.</para>
 
-      <para>The <function>xallocx<parameter/></function> function resizes the
+      <para>The <function>xallocx()</function> function resizes the
       allocation at <parameter>ptr</parameter> in place to be at least
       <parameter>size</parameter> bytes, and returns the real size of the
       allocation.  If <parameter>extra</parameter> is non-zero, an attempt is
       made to resize the allocation to be at least <code
       language="C">(<parameter>size</parameter> +
       <parameter>extra</parameter>)</code> bytes, though inability to allocate
       the extra byte(s) will not by itself result in failure to resize.
       Behavior is undefined if <parameter>size</parameter> is
       <constant>0</constant>, or if <code
       language="C">(<parameter>size</parameter> + <parameter>extra</parameter>
       &gt; <constant>SIZE_T_MAX</constant>)</code>.</para>
 
-      <para>The <function>sallocx<parameter/></function> function returns the
+      <para>The <function>sallocx()</function> function returns the
       real size of the allocation at <parameter>ptr</parameter>.</para>
 
-      <para>The <function>dallocx<parameter/></function> function causes the
+      <para>The <function>dallocx()</function> function causes the
       memory referenced by <parameter>ptr</parameter> to be made available for
       future allocations.</para>
 
-      <para>The <function>sdallocx<parameter/></function> function is an
-      extension of <function>dallocx<parameter/></function> with a
+      <para>The <function>sdallocx()</function> function is an
+      extension of <function>dallocx()</function> with a
       <parameter>size</parameter> parameter to allow the caller to pass in the
       allocation size as an optimization.  The minimum valid input size is the
       original requested size of the allocation, and the maximum valid input
       size is the corresponding value returned by
-      <function>nallocx<parameter/></function> or
-      <function>sallocx<parameter/></function>.</para>
+      <function>nallocx()</function> or
+      <function>sallocx()</function>.</para>
 
-      <para>The <function>nallocx<parameter/></function> function allocates no
+      <para>The <function>nallocx()</function> function allocates no
       memory, but it performs the same size computation as the
-      <function>mallocx<parameter/></function> function, and returns the real
+      <function>mallocx()</function> function, and returns the real
       size of the allocation that would result from the equivalent
-      <function>mallocx<parameter/></function> function call.  Behavior is
-      undefined if <parameter>size</parameter> is <constant>0</constant>, or if
-      request size overflows due to size class and/or alignment
-      constraints.</para>
+      <function>mallocx()</function> function call, or
+      <constant>0</constant> if the inputs exceed the maximum supported size
+      class and/or alignment.  Behavior is undefined if
+      <parameter>size</parameter> is <constant>0</constant>.</para>
 
-      <para>The <function>mallctl<parameter/></function> function provides a
+      <para>The <function>mallctl()</function> function provides a
       general interface for introspecting the memory allocator, as well as
       setting modifiable parameters and triggering actions.  The
       period-separated <parameter>name</parameter> argument specifies a
       location in a tree-structured namespace; see the <xref
       linkend="mallctl_namespace" xrefstyle="template:%t"/> section for
       documentation on the tree contents.  To read a value, pass a pointer via
@@ -371,18 +369,18 @@
       <constant>NULL</constant> and <constant>NULL</constant>.  Similarly, to
       write a value, pass a pointer to the value via
       <parameter>newp</parameter>, and its length via
       <parameter>newlen</parameter>; otherwise pass <constant>NULL</constant>
       and <constant>0</constant>.</para>
 
-      <para>The <function>mallctlnametomib<parameter/></function> function
+      <para>The <function>mallctlnametomib()</function> function
       provides a way to avoid repeated name lookups for applications that
       repeatedly query the same portion of the namespace, by translating a name
-      to a &ldquo;Management Information Base&rdquo; (MIB) that can be passed
-      repeatedly to <function>mallctlbymib<parameter/></function>.  Upon
-      successful return from <function>mallctlnametomib<parameter/></function>,
+      to a <quote>Management Information Base</quote> (MIB) that can be passed
+      repeatedly to <function>mallctlbymib()</function>.  Upon
+      successful return from <function>mallctlnametomib()</function>,
       <parameter>mibp</parameter> contains an array of
       <parameter>*miblenp</parameter> integers, where
       <parameter>*miblenp</parameter> is the lesser of the number of components
       in <parameter>name</parameter> and the input value of
       <parameter>*miblenp</parameter>.  Thus it is possible to pass a
       <parameter>*miblenp</parameter> that is smaller than the number of
@@ -405,72 +403,74 @@
 mallctlnametomib("arenas.bin.0.size", mib, &miblen);
 for (i = 0; i < nbins; i++) {
 	size_t bin_size;
 
 	mib[2] = i;
 	len = sizeof(bin_size);
-	mallctlbymib(mib, miblen, &bin_size, &len, NULL, 0);
+	mallctlbymib(mib, miblen, (void *)&bin_size, &len, NULL, 0);
 	/* Do something with bin_size... */
 }]]></programlisting></para>
 
-      <para>The <function>malloc_stats_print<parameter/></function> function
-      writes human-readable summary statistics via the
-      <parameter>write_cb</parameter> callback function pointer and
-      <parameter>cbopaque</parameter> data passed to
-      <parameter>write_cb</parameter>, or
-      <function>malloc_message<parameter/></function> if
-      <parameter>write_cb</parameter> is <constant>NULL</constant>.  This
-      function can be called repeatedly.  General information that never
-      changes during execution can be omitted by specifying "g" as a character
+      <para>The <function>malloc_stats_print()</function> function writes
+      summary statistics via the <parameter>write_cb</parameter> callback
+      function pointer and <parameter>cbopaque</parameter> data passed to
+      <parameter>write_cb</parameter>, or <function>malloc_message()</function>
+      if <parameter>write_cb</parameter> is <constant>NULL</constant>.  The
+      statistics are presented in human-readable form unless <quote>J</quote> is
+      specified as a character within the <parameter>opts</parameter> string, in
+      which case the statistics are presented in <ulink
+      url="http://www.json.org/">JSON format</ulink>.  This function can be
+      called repeatedly.  General information that never changes during
+      execution can be omitted by specifying <quote>g</quote> as a character
       within the <parameter>opts</parameter> string.  Note that
-      <function>malloc_message<parameter/></function> uses the
-      <function>mallctl*<parameter/></function> functions internally, so
-      inconsistent statistics can be reported if multiple threads use these
-      functions simultaneously.  If <option>--enable-stats</option> is
-      specified during configuration, &ldquo;m&rdquo; and &ldquo;a&rdquo; can
-      be specified to omit merged arena and per arena statistics, respectively;
-      &ldquo;b&rdquo;, &ldquo;l&rdquo;, and &ldquo;h&rdquo; can be specified to
-      omit per size class statistics for bins, large objects, and huge objects,
-      respectively.  Unrecognized characters are silently ignored.  Note that
-      thread caching may prevent some statistics from being completely up to
-      date, since extra locking would be required to merge counters that track
-      thread cache operations.
-      </para>
+      <function>malloc_message()</function> uses the
+      <function>mallctl*()</function> functions internally, so inconsistent
+      statistics can be reported if multiple threads use these functions
+      simultaneously.  If <option>--enable-stats</option> is specified during
+      configuration, <quote>m</quote> and <quote>a</quote> can be specified to
+      omit merged arena and per arena statistics, respectively;
+      <quote>b</quote>, <quote>l</quote>, and <quote>h</quote> can be specified
+      to omit per size class statistics for bins, large objects, and huge
+      objects, respectively.  Unrecognized characters are silently ignored.
+      Note that thread caching may prevent some statistics from being completely
+      up to date, since extra locking would be required to merge counters that
+      track thread cache operations.</para>
 
-      <para>The <function>malloc_usable_size<parameter/></function> function
+      <para>The <function>malloc_usable_size()</function> function
       returns the usable size of the allocation pointed to by
       <parameter>ptr</parameter>.  The return value may be larger than the size
       that was requested during allocation.  The
-      <function>malloc_usable_size<parameter/></function> function is not a
-      mechanism for in-place <function>realloc<parameter/></function>; rather
+      <function>malloc_usable_size()</function> function is not a
+      mechanism for in-place <function>realloc()</function>; rather
       it is provided solely as a tool for introspection purposes.  Any
       discrepancy between the requested allocation size and the size reported
-      by <function>malloc_usable_size<parameter/></function> should not be
+      by <function>malloc_usable_size()</function> should not be
       depended on, since such behavior is entirely implementation-dependent.
       </para>
     </refsect2>
   </refsect1>
   <refsect1 id="tuning">
     <title>TUNING</title>
     <para>Once, when the first call is made to one of the memory allocation
     routines, the allocator initializes its internals based in part on various
     options that can be specified at compile- or run-time.</para>
 
-    <para>The string pointed to by the global variable
-    <varname>malloc_conf</varname>, the &ldquo;name&rdquo; of the file
-    referenced by the symbolic link named <filename
-    class="symlink">/etc/malloc.conf</filename>, and the value of the
+    <para>The string specified via <option>--with-malloc-conf</option>, the
+    string pointed to by the global variable <varname>malloc_conf</varname>, the
+    <quote>name</quote> of the file referenced by the symbolic link named
+    <filename class="symlink">/etc/malloc.conf</filename>, and the value of the
     environment variable <envar>MALLOC_CONF</envar>, will be interpreted, in
     that order, from left to right as options.  Note that
     <varname>malloc_conf</varname> may be read before
-    <function>main<parameter/></function> is entered, so the declaration of
+    <function>main()</function> is entered, so the declaration of
     <varname>malloc_conf</varname> should specify an initializer that contains
-    the final value to be read by jemalloc.  <varname>malloc_conf</varname> is
-    a compile-time setting, whereas <filename
-    class="symlink">/etc/malloc.conf</filename> and <envar>MALLOC_CONF</envar>
-    can be safely set any time prior to program invocation.</para>
+    the final value to be read by jemalloc.  <option>--with-malloc-conf</option>
+    and <varname>malloc_conf</varname> are compile-time mechanisms, whereas
+    <filename class="symlink">/etc/malloc.conf</filename> and
+    <envar>MALLOC_CONF</envar> can be safely set any time prior to program
+    invocation.</para>
 
     <para>An options string is a comma-separated list of option:value pairs.
     There is one key corresponding to each <link
     linkend="opt.abort"><mallctl>opt.*</mallctl></link> mallctl (see the <xref
     linkend="mallctl_namespace" xrefstyle="template:%t"/> section for options
     documentation).  For example, <literal>abort:true,narenas:1</literal> sets
@@ -514,58 +514,53 @@
     allocator supports thread-specific caching for small and large objects, in
     order to make it possible to completely avoid synchronization for most
     allocation requests.  Such caching allows very fast allocation in the
     common case, but it increases memory usage and fragmentation, since a
     bounded number of objects can remain allocated in each thread cache.</para>
 
-    <para>Memory is conceptually broken into equal-sized chunks, where the
-    chunk size is a power of two that is greater than the page size.  Chunks
-    are always aligned to multiples of the chunk size.  This alignment makes it
-    possible to find metadata for user objects very quickly.</para>
-
-    <para>User objects are broken into three categories according to size:
-    small, large, and huge.  Small and large objects are managed entirely by
-    arenas; huge objects are additionally aggregated in a single data structure
-    that is shared by all threads.  Huge objects are typically used by
-    applications infrequently enough that this single data structure is not a
-    scalability issue.</para>
-
-    <para>Each chunk that is managed by an arena tracks its contents as runs of
+    <para>Memory is conceptually broken into equal-sized chunks, where the chunk
+    size is a power of two that is greater than the page size.  Chunks are
+    always aligned to multiples of the chunk size.  This alignment makes it
+    possible to find metadata for user objects very quickly.  User objects are
+    broken into three categories according to size: small, large, and huge.
+    Multiple small and large objects can reside within a single chunk, whereas
+    huge objects each have one or more chunks backing them.  Each chunk that
+    contains small and/or large objects tracks its contents as runs of
     contiguous pages (unused, backing a set of small objects, or backing one
-    large object).  The combination of chunk alignment and chunk page maps
-    makes it possible to determine all metadata regarding small and large
-    allocations in constant time.</para>
+    large object).  The combination of chunk alignment and chunk page maps makes
+    it possible to determine all metadata regarding small and large allocations
+    in constant time.</para>
 
     <para>Small objects are managed in groups by page runs.  Each run maintains
     a bitmap to track which regions are in use.  Allocation requests that are no
     more than half the quantum (8 or 16, depending on architecture) are rounded
     up to the nearest power of two that is at least <code
     language="C">sizeof(<type>double</type>)</code>.  All other object size
     classes are multiples of the quantum, spaced such that there are four size
     classes for each doubling in size, which limits internal fragmentation to
     approximately 20% for all but the smallest size classes.  Small size classes
     are smaller than four times the page size, large size classes are smaller
     than the chunk size (see the <link
     linkend="opt.lg_chunk"><mallctl>opt.lg_chunk</mallctl></link> option), and
-    huge size classes extend from the chunk size up to one size class less than
-    the full address space size.</para>
+    huge size classes extend from the chunk size up to the largest size class
+    that does not exceed <constant>PTRDIFF_MAX</constant>.</para>
 
     <para>Allocations are packed tightly together, which can be an issue for
     multi-threaded applications.  If you need to assure that allocations do not
     suffer from cacheline sharing, round your allocation requests up to the
     nearest multiple of the cacheline size, or specify cacheline alignment when
     allocating.</para>
 
-    <para>The <function>realloc<parameter/></function>,
-    <function>rallocx<parameter/></function>, and
-    <function>xallocx<parameter/></function> functions may resize allocations
+    <para>The <function>realloc()</function>,
+    <function>rallocx()</function>, and
+    <function>xallocx()</function> functions may resize allocations
     without moving them under limited circumstances.  Unlike the
-    <function>*allocx<parameter/></function> API, the standard API does not
+    <function>*allocx()</function> API, the standard API does not
     officially round up the usable size of an allocation to the nearest size
     class, so technically it is necessary to call
-    <function>realloc<parameter/></function> to grow e.g. a 9-byte allocation to
+    <function>realloc()</function> to grow e.g. a 9-byte allocation to
     16 bytes, or shrink a 16-byte allocation to 9 bytes.  Growth and shrinkage
     trivially succeeds in place as long as the pre-size and post-size both round
     up to the same size class.  No other API guarantees are made regarding
     in-place resizing, but the current implementation also tries to resize large
     and huge allocations in place, as long as the pre-size and post-size are
     both large or both huge.  In such cases shrinkage always succeeds for large
@@ -662,13 +657,13 @@
         </row>
         <row>
           <entry>256 KiB</entry>
           <entry>[1280 KiB, 1536 KiB, 1792 KiB]</entry>
         </row>
         <row>
-          <entry morerows="6">Huge</entry>
+          <entry morerows="8">Huge</entry>
           <entry>256 KiB</entry>
           <entry>[2 MiB]</entry>
         </row>
         <row>
           <entry>512 KiB</entry>
           <entry>[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]</entry>
@@ -690,20 +685,28 @@
           <entry>[40 MiB, 48 MiB, 56 MiB, 64 MiB]</entry>
         </row>
         <row>
           <entry>...</entry>
           <entry>...</entry>
         </row>
+        <row>
+          <entry>512 PiB</entry>
+          <entry>[2560 PiB, 3 EiB, 3584 PiB, 4 EiB]</entry>
+        </row>
+        <row>
+          <entry>1 EiB</entry>
+          <entry>[5 EiB, 6 EiB, 7 EiB]</entry>
+        </row>
       </tbody>
       </tgroup>
     </table>
   </refsect1>
   <refsect1 id="mallctl_namespace">
     <title>MALLCTL NAMESPACE</title>
     <para>The following names are defined in the namespace accessible via the
-    <function>mallctl*<parameter/></function> functions.  Value types are
+    <function>mallctl*()</function> functions.  Value types are
     specified in parentheses, their readable/writable statuses are encoded as
     <literal>rw</literal>, <literal>r-</literal>, <literal>-w</literal>, or
     <literal>--</literal>, and required build configuration flags follow, if
     any.  A name element encoded as <literal>&lt;i&gt;</literal> or
     <literal>&lt;j&gt;</literal> indicates an integer component, where the
     integer varies from 0 to some upper value that must be determined via
@@ -728,13 +731,13 @@
         <term>
           <mallctl>epoch</mallctl>
           (<type>uint64_t</type>)
           <literal>rw</literal>
         </term>
         <listitem><para>If a value is passed in, refresh the data from which
-        the <function>mallctl*<parameter/></function> functions report values,
+        the <function>mallctl*()</function> functions report values,
         and increment the epoch.  Return the current epoch.  This is useful for
         detecting whether another thread caused a refresh.</para></listitem>
       </varlistentry>
 
       <varlistentry id="config.cache_oblivious">
         <term>
@@ -773,12 +776,23 @@
           <literal>r-</literal>
         </term>
         <listitem><para><option>--enable-lazy-lock</option> was specified
         during build configuration.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="config.malloc_conf">
+        <term>
+          <mallctl>config.malloc_conf</mallctl>
+          (<type>const char *</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Embedded configure-time-specified run-time options
+        string, empty unless <option>--with-malloc-conf</option> was specified
+        during build configuration.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="config.munmap">
         <term>
           <mallctl>config.munmap</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
@@ -901,18 +915,18 @@
         <manvolnum>2</manvolnum></citerefentry>) allocation precedence as
         related to <citerefentry><refentrytitle>mmap</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> allocation.  The following
         settings are supported if
         <citerefentry><refentrytitle>sbrk</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> is supported by the operating
-        system: &ldquo;disabled&rdquo;, &ldquo;primary&rdquo;, and
-        &ldquo;secondary&rdquo;; otherwise only &ldquo;disabled&rdquo; is
-        supported.  The default is &ldquo;secondary&rdquo; if
+        system: <quote>disabled</quote>, <quote>primary</quote>, and
+        <quote>secondary</quote>; otherwise only <quote>disabled</quote> is
+        supported.  The default is <quote>secondary</quote> if
         <citerefentry><refentrytitle>sbrk</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> is supported by the operating
-        system; &ldquo;disabled&rdquo; otherwise.
+        system; <quote>disabled</quote> otherwise.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.lg_chunk">
         <term>
           <mallctl>opt.lg_chunk</mallctl>
@@ -926,20 +940,34 @@
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.narenas">
         <term>
           <mallctl>opt.narenas</mallctl>
-          (<type>size_t</type>)
+          (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Maximum number of arenas to use for automatic
         multiplexing of threads and arenas.  The default is four times the
         number of CPUs, or one if there is a single CPU.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="opt.purge">
+        <term>
+          <mallctl>opt.purge</mallctl>
+          (<type>const char *</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Purge mode is &ldquo;ratio&rdquo; (default) or
+        &ldquo;decay&rdquo;.  See <link
+        linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
+        for details of the ratio mode.  See <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link> for
+        details of the decay mode.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="opt.lg_dirty_mult">
         <term>
           <mallctl>opt.lg_dirty_mult</mallctl>
           (<type>ssize_t</type>)
           <literal>r-</literal>
         </term>
@@ -956,53 +984,74 @@
         linkend="arenas.lg_dirty_mult"><mallctl>arenas.lg_dirty_mult</mallctl></link>
         and <link
         linkend="arena.i.lg_dirty_mult"><mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl></link>
         for related dynamic control options.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="opt.decay_time">
+        <term>
+          <mallctl>opt.decay_time</mallctl>
+          (<type>ssize_t</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Approximate time in seconds from the creation of a set
+        of unused dirty pages until an equivalent set of unused dirty pages is
+        purged and/or reused.  The pages are incrementally purged according to a
+        sigmoidal decay curve that starts and ends with zero purge rate.  A
+        decay time of 0 causes all unused dirty pages to be purged immediately
+        upon creation.  A decay time of -1 disables purging.  The default decay
+        time is 10 seconds.  See <link
+        linkend="arenas.decay_time"><mallctl>arenas.decay_time</mallctl></link>
+        and <link
+        linkend="arena.i.decay_time"><mallctl>arena.&lt;i&gt;.decay_time</mallctl></link>
+        for related dynamic control options.
+        </para></listitem>
+      </varlistentry>
+
       <varlistentry id="opt.stats_print">
         <term>
           <mallctl>opt.stats_print</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Enable/disable statistics printing at exit.  If
-        enabled, the <function>malloc_stats_print<parameter/></function>
+        enabled, the <function>malloc_stats_print()</function>
         function is called at program exit via an
         <citerefentry><refentrytitle>atexit</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> function.  If
         <option>--enable-stats</option> is specified during configuration, this
         has the potential to cause deadlock for a multi-threaded process that
         exits while one or more threads are executing in the memory allocation
-        functions.  Furthermore, <function>atexit<parameter/></function> may
+        functions.  Furthermore, <function>atexit()</function> may
         allocate memory during application initialization and then deadlock
         internally when jemalloc in turn calls
-        <function>atexit<parameter/></function>, so this option is not
-        univerally usable (though the application can register its own
-        <function>atexit<parameter/></function> function with equivalent
+        <function>atexit()</function>, so this option is not
+        universally usable (though the application can register its own
+        <function>atexit()</function> function with equivalent
         functionality).  Therefore, this option should only be used with care;
         it is primarily intended as a performance tuning aid during application
         development.  This option is disabled by default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.junk">
         <term>
           <mallctl>opt.junk</mallctl>
           (<type>const char *</type>)
           <literal>r-</literal>
           [<option>--enable-fill</option>]
         </term>
-        <listitem><para>Junk filling.  If set to "alloc", each byte of
-        uninitialized allocated memory will be initialized to
-        <literal>0xa5</literal>.  If set to "free", all deallocated memory will
-        be initialized to <literal>0x5a</literal>.  If set to "true", both
-        allocated and deallocated memory will be initialized, and if set to
-        "false", junk filling be disabled entirely.  This is intended for
-        debugging and will impact performance negatively.  This option is
-        "false" by default unless <option>--enable-debug</option> is specified
-        during configuration, in which case it is "true" by default unless
+        <listitem><para>Junk filling.  If set to <quote>alloc</quote>, each byte
+        of uninitialized allocated memory will be initialized to
+        <literal>0xa5</literal>.  If set to <quote>free</quote>, all deallocated
+        memory will be initialized to <literal>0x5a</literal>.  If set to
+        <quote>true</quote>, both allocated and deallocated memory will be
+        initialized, and if set to <quote>false</quote>, junk filling be
+        disabled entirely.  This is intended for debugging and will impact
+        performance negatively.  This option is <quote>false</quote> by default
+        unless <option>--enable-debug</option> is specified during
+        configuration, in which case it is <quote>true</quote> by default unless
         running inside <ulink
         url="http://valgrind.org/">Valgrind</ulink>.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.quarantine">
         <term>
@@ -1051,14 +1100,14 @@
           <literal>r-</literal>
           [<option>--enable-fill</option>]
         </term>
         <listitem><para>Zero filling enabled/disabled.  If enabled, each byte
         of uninitialized allocated memory will be initialized to 0.  Note that
         this initialization only happens once for each byte, so
-        <function>realloc<parameter/></function> and
-        <function>rallocx<parameter/></function> calls do not zero memory that
+        <function>realloc()</function> and
+        <function>rallocx()</function> calls do not zero memory that
         was previously allocated.  This is intended for debugging and will
         impact performance negatively.  This option is disabled by default.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.utrace">
@@ -1147,13 +1196,14 @@
         option for information on high-water-triggered profile dumping, and the
         <link linkend="opt.prof_final"><mallctl>opt.prof_final</mallctl></link>
         option for final profile dumping.  Profile output is compatible with
         the <command>jeprof</command> command, which is based on the
         <command>pprof</command> that is developed as part of the <ulink
         url="http://code.google.com/p/gperftools/">gperftools
-        package</ulink>.</para></listitem>
+        package</ulink>.  See <link linkend="heap_profile_format">HEAP PROFILE
+        FORMAT</link> for heap profile format documentation.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_prefix">
         <term>
           <mallctl>opt.prof_prefix</mallctl>
           (<type>const char *</type>)
@@ -1274,17 +1324,17 @@
         <citerefentry><refentrytitle>atexit</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> function to dump final memory
         usage to a file named according to the pattern
         <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap</filename>,
         where <literal>&lt;prefix&gt;</literal> is controlled by the <link
         linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
-        option.  Note that <function>atexit<parameter/></function> may allocate
+        option.  Note that <function>atexit()</function> may allocate
         memory during application initialization and then deadlock internally
-        when jemalloc in turn calls <function>atexit<parameter/></function>, so
-        this option is not univerally usable (though the application can
-        register its own <function>atexit<parameter/></function> function with
+        when jemalloc in turn calls <function>atexit()</function>, so
+        this option is not universally usable (though the application can
+        register its own <function>atexit()</function> function with
         equivalent functionality).  This option is disabled by
         default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_leak">
         <term>
@@ -1337,13 +1387,13 @@
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Get a pointer to the the value that is returned by the
         <link
         linkend="thread.allocated"><mallctl>thread.allocated</mallctl></link>
         mallctl.  This is useful for avoiding the overhead of repeated
-        <function>mallctl*<parameter/></function> calls.</para></listitem>
+        <function>mallctl*()</function> calls.</para></listitem>
       </varlistentry>
 
       <varlistentry id="thread.deallocated">
         <term>
           <mallctl>thread.deallocated</mallctl>
           (<type>uint64_t</type>)
@@ -1364,13 +1414,13 @@
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Get a pointer to the the value that is returned by the
         <link
         linkend="thread.deallocated"><mallctl>thread.deallocated</mallctl></link>
         mallctl.  This is useful for avoiding the overhead of repeated
-        <function>mallctl*<parameter/></function> calls.</para></listitem>
+        <function>mallctl*()</function> calls.</para></listitem>
       </varlistentry>
 
       <varlistentry id="thread.tcache.enabled">
         <term>
           <mallctl>thread.tcache.enabled</mallctl>
           (<type>bool</type>)
@@ -1415,14 +1465,14 @@
         created, so the input string need not be maintained after this interface
         completes execution.  The output string of this interface should be
         copied for non-ephemeral uses, because multiple implementation details
         can cause asynchronous string deallocation.  Furthermore, each
         invocation of this interface can only read or write; simultaneous
         read/write is not supported due to string lifetime limitations.  The
-        name string must nil-terminated and comprised only of characters in the
-        sets recognized
+        name string must be nil-terminated and comprised only of characters in
+        the sets recognized
         by <citerefentry><refentrytitle>isgraph</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> and
         <citerefentry><refentrytitle>isblank</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry>.</para></listitem>
       </varlistentry>
 
@@ -1464,13 +1514,13 @@
           <literal>-w</literal>
           [<option>--enable-tcache</option>]
         </term>
         <listitem><para>Flush the specified thread-specific cache (tcache).  The
         same considerations apply to this interface as to <link
         linkend="thread.tcache.flush"><mallctl>thread.tcache.flush</mallctl></link>,
-        except that the tcache will never be automatically be discarded.
+        except that the tcache will never be automatically discarded.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="tcache.destroy">
         <term>
           <mallctl>tcache.destroy</mallctl>
@@ -1486,18 +1536,50 @@
       <varlistentry id="arena.i.purge">
         <term>
           <mallctl>arena.&lt;i&gt;.purge</mallctl>
           (<type>void</type>)
           <literal>--</literal>
         </term>
-        <listitem><para>Purge unused dirty pages for arena &lt;i&gt;, or for
+        <listitem><para>Purge all unused dirty pages for arena &lt;i&gt;, or for
         all arenas if &lt;i&gt; equals <link
         linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.
         </para></listitem>
       </varlistentry>
 
+      <varlistentry id="arena.i.decay">
+        <term>
+          <mallctl>arena.&lt;i&gt;.decay</mallctl>
+          (<type>void</type>)
+          <literal>--</literal>
+        </term>
+        <listitem><para>Trigger decay-based purging of unused dirty pages for
+        arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals <link
+        linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.
+        The proportion of unused dirty pages to be purged depends on the current
+        time; see <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link> for
+        details.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="arena.i.reset">
+        <term>
+          <mallctl>arena.&lt;i&gt;.reset</mallctl>
+          (<type>void</type>)
+          <literal>--</literal>
+        </term>
+        <listitem><para>Discard all of the arena's extant allocations.  This
+        interface can only be used with arenas created via <link
+        linkend="arenas.extend"><mallctl>arenas.extend</mallctl></link>.  None
+        of the arena's discarded/cached allocations may accessed afterward.  As
+        part of this requirement, all thread caches which were used to
+        allocate/deallocate in conjunction with the arena must be flushed
+        beforehand.  This interface cannot be used if running inside Valgrind,
+        nor if the <link linkend="opt.quarantine">quarantine</link> size is
+        non-zero.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="arena.i.dss">
         <term>
           <mallctl>arena.&lt;i&gt;.dss</mallctl>
           (<type>const char *</type>)
           <literal>rw</literal>
         </term>
@@ -1520,12 +1602,28 @@
         the ratio is increased, pages are synchronously purged as necessary to
         impose the new ratio.  See <link
         linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
         for additional information.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="arena.i.decay_time">
+        <term>
+          <mallctl>arena.&lt;i&gt;.decay_time</mallctl>
+          (<type>ssize_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Current per-arena approximate time in seconds from the
+        creation of a set of unused dirty pages until an equivalent set of
+        unused dirty pages is purged and/or reused.  Each time this interface is
+        set, all currently unused dirty pages are considered to have fully
+        decayed, which causes immediate purging of all unused dirty pages unless
+        the decay time is set to -1 (i.e. purging disabled).  See <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link> for
+        additional information.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="arena.i.chunk_hooks">
         <term>
           <mallctl>arena.&lt;i&gt;.chunk_hooks</mallctl>
           (<type>chunk_hooks_t</type>)
           <literal>rw</literal>
         </term>
@@ -1754,12 +1852,27 @@
         linkend="arena.i.lg_dirty_mult"><mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl></link>
         during arena creation.  See <link
         linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
         for additional information.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="arenas.decay_time">
+        <term>
+          <mallctl>arenas.decay_time</mallctl>
+          (<type>ssize_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Current default per-arena approximate time in seconds
+        from the creation of a set of unused dirty pages until an equivalent set
+        of unused dirty pages is purged and/or reused, used to initialize <link
+        linkend="arena.i.decay_time"><mallctl>arena.&lt;i&gt;.decay_time</mallctl></link>
+        during arena creation.  See <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link> for
+        additional information.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="arenas.quantum">
         <term>
           <mallctl>arenas.quantum</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
         </term>
@@ -1973,13 +2086,13 @@
           <mallctl>prof.interval</mallctl>
           (<type>uint64_t</type>)
           <literal>r-</literal>
           [<option>--enable-prof</option>]
         </term>
         <listitem><para>Average number of bytes allocated between
-        inverval-based profile dumps.  See the
+        interval-based profile dumps.  See the
         <link
         linkend="opt.lg_prof_interval"><mallctl>opt.lg_prof_interval</mallctl></link>
         option for additional information.</para></listitem>
       </varlistentry>
 
       <varlistentry id="stats.cactive">
@@ -2072,12 +2185,31 @@
         This does not include inactive chunks, even those that contain unused
         dirty pages, which means that there is no strict ordering between this
         and <link
         linkend="stats.resident"><mallctl>stats.resident</mallctl></link>.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.retained">
+        <term>
+          <mallctl>stats.retained</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Total number of bytes in virtual memory mappings that
+        were retained rather than being returned to the operating system via
+        e.g. <citerefentry><refentrytitle>munmap</refentrytitle>
+        <manvolnum>2</manvolnum></citerefentry>.  Retained virtual memory is
+        typically untouched, decommitted, or purged, so it has no strongly
+        associated physical memory (see <link
+        linkend="arena.i.chunk_hooks">chunk hooks</link> for details).  Retained
+        memory is excluded from mapped memory statistics, e.g. <link
+        linkend="stats.mapped"><mallctl>stats.mapped</mallctl></link>.
+        </para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.dss">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.dss</mallctl>
           (<type>const char *</type>)
           <literal>r-</literal>
         </term>
@@ -2098,12 +2230,25 @@
         <listitem><para>Minimum ratio (log base 2) of active to dirty pages.
         See <link
         linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
         for details.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.decay_time">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.decay_time</mallctl>
+          (<type>ssize_t</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Approximate time in seconds from the creation of a set
+        of unused dirty pages until an equivalent set of unused dirty pages is
+        purged and/or reused.  See <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link>
+        for details.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.nthreads">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.nthreads</mallctl>
           (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
@@ -2139,12 +2284,24 @@
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Number of mapped bytes.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.retained">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.retained</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Number of retained bytes.  See <link
+        linkend="stats.retained"><mallctl>stats.retained</mallctl></link> for
+        details.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.metadata.mapped">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.metadata.mapped</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
@@ -2520,22 +2677,69 @@
         </term>
         <listitem><para>Current number of huge allocations for this size class.
         </para></listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
+  <refsect1 id="heap_profile_format">
+    <title>HEAP PROFILE FORMAT</title>
+    <para>Although the heap profiling functionality was originally designed to
+    be compatible with the
+    <command>pprof</command> command that is developed as part of the <ulink
+    url="http://code.google.com/p/gperftools/">gperftools
+    package</ulink>, the addition of per thread heap profiling functionality
+    required a different heap profile format.  The <command>jeprof</command>
+    command is derived from <command>pprof</command>, with enhancements to
+    support the heap profile format described here.</para>
+
+    <para>In the following hypothetical heap profile, <constant>[...]</constant>
+    indicates elision for the sake of compactness.  <programlisting><![CDATA[
+heap_v2/524288
+  t*: 28106: 56637512 [0: 0]
+  [...]
+  t3: 352: 16777344 [0: 0]
+  [...]
+  t99: 17754: 29341640 [0: 0]
+  [...]
+@ 0x5f86da8 0x5f5a1dc [...] 0x29e4d4e 0xa200316 0xabb2988 [...]
+  t*: 13: 6688 [0: 0]
+  t3: 12: 6496 [0: ]
+  t99: 1: 192 [0: 0]
+[...]
+
+MAPPED_LIBRARIES:
+[...]]]></programlisting> The following matches the above heap profile, but most
+tokens are replaced with <constant>&lt;description&gt;</constant> to indicate
+descriptions of the corresponding fields.  <programlisting><![CDATA[
+<heap_profile_format_version>/<mean_sample_interval>
+  <aggregate>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+  [...]
+  <thread_3_aggregate>: <curobjs>: <curbytes>[<cumobjs>: <cumbytes>]
+  [...]
+  <thread_99_aggregate>: <curobjs>: <curbytes>[<cumobjs>: <cumbytes>]
+  [...]
+@ <top_frame> <frame> [...] <frame> <frame> <frame> [...]
+  <backtrace_aggregate>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+  <backtrace_thread_3>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+  <backtrace_thread_99>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+[...]
+
+MAPPED_LIBRARIES:
+</proc/<pid>/maps>]]></programlisting></para>
+  </refsect1>
+
   <refsect1 id="debugging_malloc_problems">
     <title>DEBUGGING MALLOC PROBLEMS</title>
     <para>When debugging, it is a good idea to configure/build jemalloc with
     the <option>--enable-debug</option> and <option>--enable-fill</option>
     options, and recompile the program with suitable options and symbols for
     debugger support.  When so configured, jemalloc incorporates a wide variety
     of run-time assertions that catch application errors such as double-free,
     write-after-free, etc.</para>
 
-    <para>Programs often accidentally depend on &ldquo;uninitialized&rdquo;
+    <para>Programs often accidentally depend on <quote>uninitialized</quote>
     memory actually being filled with zero bytes.  Junk filling
     (see the <link linkend="opt.junk"><mallctl>opt.junk</mallctl></link>
     option) tends to expose such bugs in the form of obviously incorrect
     results and/or coredumps.  Conversely, zero
     filling (see the <link
     linkend="opt.zero"><mallctl>opt.zero</mallctl></link> option) eliminates
@@ -2558,35 +2762,35 @@
     warnings are treated as errors.</para>
 
     <para>The <varname>malloc_message</varname> variable allows the programmer
     to override the function which emits the text strings forming the errors
     and warnings if for some reason the <constant>STDERR_FILENO</constant> file
     descriptor is not suitable for this.
-    <function>malloc_message<parameter/></function> takes the
+    <function>malloc_message()</function> takes the
     <parameter>cbopaque</parameter> pointer argument that is
     <constant>NULL</constant> unless overridden by the arguments in a call to
-    <function>malloc_stats_print<parameter/></function>, followed by a string
+    <function>malloc_stats_print()</function>, followed by a string
     pointer.  Please note that doing anything which tries to allocate memory in
     this function is likely to result in a crash or deadlock.</para>
 
     <para>All messages are prefixed by
-    &ldquo;<computeroutput>&lt;jemalloc&gt;: </computeroutput>&rdquo;.</para>
+    <quote><computeroutput>&lt;jemalloc&gt;: </computeroutput></quote>.</para>
   </refsect1>
   <refsect1 id="return_values">
     <title>RETURN VALUES</title>
     <refsect2>
       <title>Standard API</title>
-      <para>The <function>malloc<parameter/></function> and
-      <function>calloc<parameter/></function> functions return a pointer to the
+      <para>The <function>malloc()</function> and
+      <function>calloc()</function> functions return a pointer to the
       allocated memory if successful; otherwise a <constant>NULL</constant>
       pointer is returned and <varname>errno</varname> is set to
       <errorname>ENOMEM</errorname>.</para>
 
-      <para>The <function>posix_memalign<parameter/></function> function
+      <para>The <function>posix_memalign()</function> function
       returns the value 0 if successful; otherwise it returns an error value.
-      The <function>posix_memalign<parameter/></function> function will fail
+      The <function>posix_memalign()</function> function will fail
       if:
         <variablelist>
           <varlistentry>
             <term><errorname>EINVAL</errorname></term>
 
             <listitem><para>The <parameter>alignment</parameter> parameter is
@@ -2599,17 +2803,17 @@
 
             <listitem><para>Memory allocation error.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
-      <para>The <function>aligned_alloc<parameter/></function> function returns
+      <para>The <function>aligned_alloc()</function> function returns
       a pointer to the allocated memory if successful; otherwise a
       <constant>NULL</constant> pointer is returned and
       <varname>errno</varname> is set.  The
-      <function>aligned_alloc<parameter/></function> function will fail if:
+      <function>aligned_alloc()</function> function will fail if:
         <variablelist>
           <varlistentry>
             <term><errorname>EINVAL</errorname></term>
 
             <listitem><para>The <parameter>alignment</parameter> parameter is
             not a power of 2.
@@ -2620,50 +2824,50 @@
 
             <listitem><para>Memory allocation error.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
-      <para>The <function>realloc<parameter/></function> function returns a
+      <para>The <function>realloc()</function> function returns a
       pointer, possibly identical to <parameter>ptr</parameter>, to the
       allocated memory if successful; otherwise a <constant>NULL</constant>
       pointer is returned, and <varname>errno</varname> is set to
       <errorname>ENOMEM</errorname> if the error was the result of an
-      allocation failure.  The <function>realloc<parameter/></function>
+      allocation failure.  The <function>realloc()</function>
       function always leaves the original buffer intact when an error occurs.
       </para>
 
-      <para>The <function>free<parameter/></function> function returns no
+      <para>The <function>free()</function> function returns no
       value.</para>
     </refsect2>
     <refsect2>
       <title>Non-standard API</title>
-      <para>The <function>mallocx<parameter/></function> and
-      <function>rallocx<parameter/></function> functions return a pointer to
+      <para>The <function>mallocx()</function> and
+      <function>rallocx()</function> functions return a pointer to
       the allocated memory if successful; otherwise a <constant>NULL</constant>
       pointer is returned to indicate insufficient contiguous memory was
       available to service the allocation request.  </para>
 
-      <para>The <function>xallocx<parameter/></function> function returns the
+      <para>The <function>xallocx()</function> function returns the
       real size of the resulting resized allocation pointed to by
       <parameter>ptr</parameter>, which is a value less than
       <parameter>size</parameter> if the allocation could not be adequately
       grown in place.  </para>
 
-      <para>The <function>sallocx<parameter/></function> function returns the
+      <para>The <function>sallocx()</function> function returns the
       real size of the allocation pointed to by <parameter>ptr</parameter>.
       </para>
 
-      <para>The <function>nallocx<parameter/></function> returns the real size
+      <para>The <function>nallocx()</function> returns the real size
       that would result from a successful equivalent
-      <function>mallocx<parameter/></function> function call, or zero if
+      <function>mallocx()</function> function call, or zero if
       insufficient memory is available to perform the size computation.  </para>
 
-      <para>The <function>mallctl<parameter/></function>,
-      <function>mallctlnametomib<parameter/></function>, and
-      <function>mallctlbymib<parameter/></function> functions return 0 on
+      <para>The <function>mallctl()</function>,
+      <function>mallctlnametomib()</function>, and
+      <function>mallctlbymib()</function> functions return 0 on
       success; otherwise they return an error value.  The functions will fail
       if:
         <variablelist>
           <varlistentry>
             <term><errorname>EINVAL</errorname></term>
 
@@ -2693,19 +2897,19 @@
             occurred.</para></listitem>
           </varlistentry>
           <varlistentry>
             <term><errorname>EFAULT</errorname></term>
 
             <listitem><para>An interface with side effects failed in some way
-            not directly related to <function>mallctl*<parameter/></function>
+            not directly related to <function>mallctl*()</function>
             read/write processing.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
-      <para>The <function>malloc_usable_size<parameter/></function> function
+      <para>The <function>malloc_usable_size()</function> function
       returns the usable size of the allocation pointed to by
       <parameter>ptr</parameter>.  </para>
     </refsect2>
   </refsect1>
   <refsect1 id="environment">
     <title>ENVIRONMENT</title>
@@ -2747,16 +2951,16 @@
     <manvolnum>3</manvolnum></citerefentry>,
     <citerefentry><refentrytitle>getpagesize</refentrytitle>
     <manvolnum>3</manvolnum></citerefentry></para>
   </refsect1>
   <refsect1 id="standards">
     <title>STANDARDS</title>
-    <para>The <function>malloc<parameter/></function>,
-    <function>calloc<parameter/></function>,
-    <function>realloc<parameter/></function>, and
-    <function>free<parameter/></function> functions conform to ISO/IEC
-    9899:1990 (&ldquo;ISO C90&rdquo;).</para>
+    <para>The <function>malloc()</function>,
+    <function>calloc()</function>,
+    <function>realloc()</function>, and
+    <function>free()</function> functions conform to ISO/IEC
+    9899:1990 (<quote>ISO C90</quote>).</para>
 
-    <para>The <function>posix_memalign<parameter/></function> function conforms
-    to IEEE Std 1003.1-2001 (&ldquo;POSIX.1&rdquo;).</para>
+    <para>The <function>posix_memalign()</function> function conforms
+    to IEEE Std 1003.1-2001 (<quote>POSIX.1</quote>).</para>
   </refsect1>
 </refentry>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/jemalloc.xml.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/jemalloc.xml.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/jemalloc.xml.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/jemalloc.xml.in	2017-01-31 23:32:23.000000000 +0800
@@ -49,13 +49,13 @@
     <refpurpose>general purpose memory allocation functions</refpurpose>
   </refnamediv>
   <refsect1 id="library">
     <title>LIBRARY</title>
     <para>This manual describes jemalloc @jemalloc_version@.  More information
     can be found at the <ulink
-    url="http://www.canonware.com/jemalloc/">jemalloc website</ulink>.</para>
+    url="http://jemalloc.net/">jemalloc website</ulink>.</para>
   </refsect1>
   <refsynopsisdiv>
     <title>SYNOPSIS</title>
     <funcsynopsis>
       <funcsynopsisinfo>#include &lt;<filename class="headerfile">jemalloc/jemalloc.h</filename>&gt;</funcsynopsisinfo>
       <refsect2>
@@ -177,69 +177,69 @@
   </refsynopsisdiv>
   <refsect1 id="description">
     <title>DESCRIPTION</title>
     <refsect2>
       <title>Standard API</title>
 
-      <para>The <function>malloc<parameter/></function> function allocates
+      <para>The <function>malloc()</function> function allocates
       <parameter>size</parameter> bytes of uninitialized memory.  The allocated
       space is suitably aligned (after possible pointer coercion) for storage
       of any type of object.</para>
 
-      <para>The <function>calloc<parameter/></function> function allocates
+      <para>The <function>calloc()</function> function allocates
       space for <parameter>number</parameter> objects, each
       <parameter>size</parameter> bytes in length.  The result is identical to
-      calling <function>malloc<parameter/></function> with an argument of
+      calling <function>malloc()</function> with an argument of
       <parameter>number</parameter> * <parameter>size</parameter>, with the
       exception that the allocated memory is explicitly initialized to zero
       bytes.</para>
 
-      <para>The <function>posix_memalign<parameter/></function> function
+      <para>The <function>posix_memalign()</function> function
       allocates <parameter>size</parameter> bytes of memory such that the
       allocation's base address is a multiple of
       <parameter>alignment</parameter>, and returns the allocation in the value
       pointed to by <parameter>ptr</parameter>.  The requested
       <parameter>alignment</parameter> must be a power of 2 at least as large as
       <code language="C">sizeof(<type>void *</type>)</code>.</para>
 
-      <para>The <function>aligned_alloc<parameter/></function> function
+      <para>The <function>aligned_alloc()</function> function
       allocates <parameter>size</parameter> bytes of memory such that the
       allocation's base address is a multiple of
       <parameter>alignment</parameter>.  The requested
       <parameter>alignment</parameter> must be a power of 2.  Behavior is
       undefined if <parameter>size</parameter> is not an integral multiple of
       <parameter>alignment</parameter>.</para>
 
-      <para>The <function>realloc<parameter/></function> function changes the
+      <para>The <function>realloc()</function> function changes the
       size of the previously allocated memory referenced by
       <parameter>ptr</parameter> to <parameter>size</parameter> bytes.  The
       contents of the memory are unchanged up to the lesser of the new and old
       sizes.  If the new size is larger, the contents of the newly allocated
       portion of the memory are undefined.  Upon success, the memory referenced
       by <parameter>ptr</parameter> is freed and a pointer to the newly
       allocated memory is returned.  Note that
-      <function>realloc<parameter/></function> may move the memory allocation,
+      <function>realloc()</function> may move the memory allocation,
       resulting in a different return value than <parameter>ptr</parameter>.
       If <parameter>ptr</parameter> is <constant>NULL</constant>, the
-      <function>realloc<parameter/></function> function behaves identically to
-      <function>malloc<parameter/></function> for the specified size.</para>
+      <function>realloc()</function> function behaves identically to
+      <function>malloc()</function> for the specified size.</para>
 
-      <para>The <function>free<parameter/></function> function causes the
+      <para>The <function>free()</function> function causes the
       allocated memory referenced by <parameter>ptr</parameter> to be made
       available for future allocations.  If <parameter>ptr</parameter> is
       <constant>NULL</constant>, no action occurs.</para>
     </refsect2>
     <refsect2>
       <title>Non-standard API</title>
-      <para>The <function>mallocx<parameter/></function>,
-      <function>rallocx<parameter/></function>,
-      <function>xallocx<parameter/></function>,
-      <function>sallocx<parameter/></function>,
-      <function>dallocx<parameter/></function>,
-      <function>sdallocx<parameter/></function>, and
-      <function>nallocx<parameter/></function> functions all have a
+      <para>The <function>mallocx()</function>,
+      <function>rallocx()</function>,
+      <function>xallocx()</function>,
+      <function>sallocx()</function>,
+      <function>dallocx()</function>,
+      <function>sdallocx()</function>, and
+      <function>nallocx()</function> functions all have a
       <parameter>flags</parameter> argument that can be used to specify
       options.  The functions only check the options that are contextually
       relevant.  Use bitwise or (<code language="C">|</code>) operations to
       specify one or more of the following:
         <variablelist>
           <varlistentry id="MALLOCX_LG_ALIGN">
@@ -304,65 +304,63 @@
             macro does not validate that <parameter>a</parameter> specifies an
             arena index in the valid range.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
-      <para>The <function>mallocx<parameter/></function> function allocates at
+      <para>The <function>mallocx()</function> function allocates at
       least <parameter>size</parameter> bytes of memory, and returns a pointer
       to the base address of the allocation.  Behavior is undefined if
-      <parameter>size</parameter> is <constant>0</constant>, or if request size
-      overflows due to size class and/or alignment constraints.</para>
+      <parameter>size</parameter> is <constant>0</constant>.</para>
 
-      <para>The <function>rallocx<parameter/></function> function resizes the
+      <para>The <function>rallocx()</function> function resizes the
       allocation at <parameter>ptr</parameter> to be at least
       <parameter>size</parameter> bytes, and returns a pointer to the base
       address of the resulting allocation, which may or may not have moved from
       its original location.  Behavior is undefined if
-      <parameter>size</parameter> is <constant>0</constant>, or if request size
-      overflows due to size class and/or alignment constraints.</para>
+      <parameter>size</parameter> is <constant>0</constant>.</para>
 
-      <para>The <function>xallocx<parameter/></function> function resizes the
+      <para>The <function>xallocx()</function> function resizes the
       allocation at <parameter>ptr</parameter> in place to be at least
       <parameter>size</parameter> bytes, and returns the real size of the
       allocation.  If <parameter>extra</parameter> is non-zero, an attempt is
       made to resize the allocation to be at least <code
       language="C">(<parameter>size</parameter> +
       <parameter>extra</parameter>)</code> bytes, though inability to allocate
       the extra byte(s) will not by itself result in failure to resize.
       Behavior is undefined if <parameter>size</parameter> is
       <constant>0</constant>, or if <code
       language="C">(<parameter>size</parameter> + <parameter>extra</parameter>
       &gt; <constant>SIZE_T_MAX</constant>)</code>.</para>
 
-      <para>The <function>sallocx<parameter/></function> function returns the
+      <para>The <function>sallocx()</function> function returns the
       real size of the allocation at <parameter>ptr</parameter>.</para>
 
-      <para>The <function>dallocx<parameter/></function> function causes the
+      <para>The <function>dallocx()</function> function causes the
       memory referenced by <parameter>ptr</parameter> to be made available for
       future allocations.</para>
 
-      <para>The <function>sdallocx<parameter/></function> function is an
-      extension of <function>dallocx<parameter/></function> with a
+      <para>The <function>sdallocx()</function> function is an
+      extension of <function>dallocx()</function> with a
       <parameter>size</parameter> parameter to allow the caller to pass in the
       allocation size as an optimization.  The minimum valid input size is the
       original requested size of the allocation, and the maximum valid input
       size is the corresponding value returned by
-      <function>nallocx<parameter/></function> or
-      <function>sallocx<parameter/></function>.</para>
+      <function>nallocx()</function> or
+      <function>sallocx()</function>.</para>
 
-      <para>The <function>nallocx<parameter/></function> function allocates no
+      <para>The <function>nallocx()</function> function allocates no
       memory, but it performs the same size computation as the
-      <function>mallocx<parameter/></function> function, and returns the real
+      <function>mallocx()</function> function, and returns the real
       size of the allocation that would result from the equivalent
-      <function>mallocx<parameter/></function> function call.  Behavior is
-      undefined if <parameter>size</parameter> is <constant>0</constant>, or if
-      request size overflows due to size class and/or alignment
-      constraints.</para>
+      <function>mallocx()</function> function call, or
+      <constant>0</constant> if the inputs exceed the maximum supported size
+      class and/or alignment.  Behavior is undefined if
+      <parameter>size</parameter> is <constant>0</constant>.</para>
 
-      <para>The <function>mallctl<parameter/></function> function provides a
+      <para>The <function>mallctl()</function> function provides a
       general interface for introspecting the memory allocator, as well as
       setting modifiable parameters and triggering actions.  The
       period-separated <parameter>name</parameter> argument specifies a
       location in a tree-structured namespace; see the <xref
       linkend="mallctl_namespace" xrefstyle="template:%t"/> section for
       documentation on the tree contents.  To read a value, pass a pointer via
@@ -371,18 +369,18 @@
       <constant>NULL</constant> and <constant>NULL</constant>.  Similarly, to
       write a value, pass a pointer to the value via
       <parameter>newp</parameter>, and its length via
       <parameter>newlen</parameter>; otherwise pass <constant>NULL</constant>
       and <constant>0</constant>.</para>
 
-      <para>The <function>mallctlnametomib<parameter/></function> function
+      <para>The <function>mallctlnametomib()</function> function
       provides a way to avoid repeated name lookups for applications that
       repeatedly query the same portion of the namespace, by translating a name
-      to a &ldquo;Management Information Base&rdquo; (MIB) that can be passed
-      repeatedly to <function>mallctlbymib<parameter/></function>.  Upon
-      successful return from <function>mallctlnametomib<parameter/></function>,
+      to a <quote>Management Information Base</quote> (MIB) that can be passed
+      repeatedly to <function>mallctlbymib()</function>.  Upon
+      successful return from <function>mallctlnametomib()</function>,
       <parameter>mibp</parameter> contains an array of
       <parameter>*miblenp</parameter> integers, where
       <parameter>*miblenp</parameter> is the lesser of the number of components
       in <parameter>name</parameter> and the input value of
       <parameter>*miblenp</parameter>.  Thus it is possible to pass a
       <parameter>*miblenp</parameter> that is smaller than the number of
@@ -405,72 +403,74 @@
 mallctlnametomib("arenas.bin.0.size", mib, &miblen);
 for (i = 0; i < nbins; i++) {
 	size_t bin_size;
 
 	mib[2] = i;
 	len = sizeof(bin_size);
-	mallctlbymib(mib, miblen, &bin_size, &len, NULL, 0);
+	mallctlbymib(mib, miblen, (void *)&bin_size, &len, NULL, 0);
 	/* Do something with bin_size... */
 }]]></programlisting></para>
 
-      <para>The <function>malloc_stats_print<parameter/></function> function
-      writes human-readable summary statistics via the
-      <parameter>write_cb</parameter> callback function pointer and
-      <parameter>cbopaque</parameter> data passed to
-      <parameter>write_cb</parameter>, or
-      <function>malloc_message<parameter/></function> if
-      <parameter>write_cb</parameter> is <constant>NULL</constant>.  This
-      function can be called repeatedly.  General information that never
-      changes during execution can be omitted by specifying "g" as a character
+      <para>The <function>malloc_stats_print()</function> function writes
+      summary statistics via the <parameter>write_cb</parameter> callback
+      function pointer and <parameter>cbopaque</parameter> data passed to
+      <parameter>write_cb</parameter>, or <function>malloc_message()</function>
+      if <parameter>write_cb</parameter> is <constant>NULL</constant>.  The
+      statistics are presented in human-readable form unless <quote>J</quote> is
+      specified as a character within the <parameter>opts</parameter> string, in
+      which case the statistics are presented in <ulink
+      url="http://www.json.org/">JSON format</ulink>.  This function can be
+      called repeatedly.  General information that never changes during
+      execution can be omitted by specifying <quote>g</quote> as a character
       within the <parameter>opts</parameter> string.  Note that
-      <function>malloc_message<parameter/></function> uses the
-      <function>mallctl*<parameter/></function> functions internally, so
-      inconsistent statistics can be reported if multiple threads use these
-      functions simultaneously.  If <option>--enable-stats</option> is
-      specified during configuration, &ldquo;m&rdquo; and &ldquo;a&rdquo; can
-      be specified to omit merged arena and per arena statistics, respectively;
-      &ldquo;b&rdquo;, &ldquo;l&rdquo;, and &ldquo;h&rdquo; can be specified to
-      omit per size class statistics for bins, large objects, and huge objects,
-      respectively.  Unrecognized characters are silently ignored.  Note that
-      thread caching may prevent some statistics from being completely up to
-      date, since extra locking would be required to merge counters that track
-      thread cache operations.
-      </para>
+      <function>malloc_message()</function> uses the
+      <function>mallctl*()</function> functions internally, so inconsistent
+      statistics can be reported if multiple threads use these functions
+      simultaneously.  If <option>--enable-stats</option> is specified during
+      configuration, <quote>m</quote> and <quote>a</quote> can be specified to
+      omit merged arena and per arena statistics, respectively;
+      <quote>b</quote>, <quote>l</quote>, and <quote>h</quote> can be specified
+      to omit per size class statistics for bins, large objects, and huge
+      objects, respectively.  Unrecognized characters are silently ignored.
+      Note that thread caching may prevent some statistics from being completely
+      up to date, since extra locking would be required to merge counters that
+      track thread cache operations.</para>
 
-      <para>The <function>malloc_usable_size<parameter/></function> function
+      <para>The <function>malloc_usable_size()</function> function
       returns the usable size of the allocation pointed to by
       <parameter>ptr</parameter>.  The return value may be larger than the size
       that was requested during allocation.  The
-      <function>malloc_usable_size<parameter/></function> function is not a
-      mechanism for in-place <function>realloc<parameter/></function>; rather
+      <function>malloc_usable_size()</function> function is not a
+      mechanism for in-place <function>realloc()</function>; rather
       it is provided solely as a tool for introspection purposes.  Any
       discrepancy between the requested allocation size and the size reported
-      by <function>malloc_usable_size<parameter/></function> should not be
+      by <function>malloc_usable_size()</function> should not be
       depended on, since such behavior is entirely implementation-dependent.
       </para>
     </refsect2>
   </refsect1>
   <refsect1 id="tuning">
     <title>TUNING</title>
     <para>Once, when the first call is made to one of the memory allocation
     routines, the allocator initializes its internals based in part on various
     options that can be specified at compile- or run-time.</para>
 
-    <para>The string pointed to by the global variable
-    <varname>malloc_conf</varname>, the &ldquo;name&rdquo; of the file
-    referenced by the symbolic link named <filename
-    class="symlink">/etc/malloc.conf</filename>, and the value of the
+    <para>The string specified via <option>--with-malloc-conf</option>, the
+    string pointed to by the global variable <varname>malloc_conf</varname>, the
+    <quote>name</quote> of the file referenced by the symbolic link named
+    <filename class="symlink">/etc/malloc.conf</filename>, and the value of the
     environment variable <envar>MALLOC_CONF</envar>, will be interpreted, in
     that order, from left to right as options.  Note that
     <varname>malloc_conf</varname> may be read before
-    <function>main<parameter/></function> is entered, so the declaration of
+    <function>main()</function> is entered, so the declaration of
     <varname>malloc_conf</varname> should specify an initializer that contains
-    the final value to be read by jemalloc.  <varname>malloc_conf</varname> is
-    a compile-time setting, whereas <filename
-    class="symlink">/etc/malloc.conf</filename> and <envar>MALLOC_CONF</envar>
-    can be safely set any time prior to program invocation.</para>
+    the final value to be read by jemalloc.  <option>--with-malloc-conf</option>
+    and <varname>malloc_conf</varname> are compile-time mechanisms, whereas
+    <filename class="symlink">/etc/malloc.conf</filename> and
+    <envar>MALLOC_CONF</envar> can be safely set any time prior to program
+    invocation.</para>
 
     <para>An options string is a comma-separated list of option:value pairs.
     There is one key corresponding to each <link
     linkend="opt.abort"><mallctl>opt.*</mallctl></link> mallctl (see the <xref
     linkend="mallctl_namespace" xrefstyle="template:%t"/> section for options
     documentation).  For example, <literal>abort:true,narenas:1</literal> sets
@@ -514,58 +514,53 @@
     allocator supports thread-specific caching for small and large objects, in
     order to make it possible to completely avoid synchronization for most
     allocation requests.  Such caching allows very fast allocation in the
     common case, but it increases memory usage and fragmentation, since a
     bounded number of objects can remain allocated in each thread cache.</para>
 
-    <para>Memory is conceptually broken into equal-sized chunks, where the
-    chunk size is a power of two that is greater than the page size.  Chunks
-    are always aligned to multiples of the chunk size.  This alignment makes it
-    possible to find metadata for user objects very quickly.</para>
-
-    <para>User objects are broken into three categories according to size:
-    small, large, and huge.  Small and large objects are managed entirely by
-    arenas; huge objects are additionally aggregated in a single data structure
-    that is shared by all threads.  Huge objects are typically used by
-    applications infrequently enough that this single data structure is not a
-    scalability issue.</para>
-
-    <para>Each chunk that is managed by an arena tracks its contents as runs of
+    <para>Memory is conceptually broken into equal-sized chunks, where the chunk
+    size is a power of two that is greater than the page size.  Chunks are
+    always aligned to multiples of the chunk size.  This alignment makes it
+    possible to find metadata for user objects very quickly.  User objects are
+    broken into three categories according to size: small, large, and huge.
+    Multiple small and large objects can reside within a single chunk, whereas
+    huge objects each have one or more chunks backing them.  Each chunk that
+    contains small and/or large objects tracks its contents as runs of
     contiguous pages (unused, backing a set of small objects, or backing one
-    large object).  The combination of chunk alignment and chunk page maps
-    makes it possible to determine all metadata regarding small and large
-    allocations in constant time.</para>
+    large object).  The combination of chunk alignment and chunk page maps makes
+    it possible to determine all metadata regarding small and large allocations
+    in constant time.</para>
 
     <para>Small objects are managed in groups by page runs.  Each run maintains
     a bitmap to track which regions are in use.  Allocation requests that are no
     more than half the quantum (8 or 16, depending on architecture) are rounded
     up to the nearest power of two that is at least <code
     language="C">sizeof(<type>double</type>)</code>.  All other object size
     classes are multiples of the quantum, spaced such that there are four size
     classes for each doubling in size, which limits internal fragmentation to
     approximately 20% for all but the smallest size classes.  Small size classes
     are smaller than four times the page size, large size classes are smaller
     than the chunk size (see the <link
     linkend="opt.lg_chunk"><mallctl>opt.lg_chunk</mallctl></link> option), and
-    huge size classes extend from the chunk size up to one size class less than
-    the full address space size.</para>
+    huge size classes extend from the chunk size up to the largest size class
+    that does not exceed <constant>PTRDIFF_MAX</constant>.</para>
 
     <para>Allocations are packed tightly together, which can be an issue for
     multi-threaded applications.  If you need to assure that allocations do not
     suffer from cacheline sharing, round your allocation requests up to the
     nearest multiple of the cacheline size, or specify cacheline alignment when
     allocating.</para>
 
-    <para>The <function>realloc<parameter/></function>,
-    <function>rallocx<parameter/></function>, and
-    <function>xallocx<parameter/></function> functions may resize allocations
+    <para>The <function>realloc()</function>,
+    <function>rallocx()</function>, and
+    <function>xallocx()</function> functions may resize allocations
     without moving them under limited circumstances.  Unlike the
-    <function>*allocx<parameter/></function> API, the standard API does not
+    <function>*allocx()</function> API, the standard API does not
     officially round up the usable size of an allocation to the nearest size
     class, so technically it is necessary to call
-    <function>realloc<parameter/></function> to grow e.g. a 9-byte allocation to
+    <function>realloc()</function> to grow e.g. a 9-byte allocation to
     16 bytes, or shrink a 16-byte allocation to 9 bytes.  Growth and shrinkage
     trivially succeeds in place as long as the pre-size and post-size both round
     up to the same size class.  No other API guarantees are made regarding
     in-place resizing, but the current implementation also tries to resize large
     and huge allocations in place, as long as the pre-size and post-size are
     both large or both huge.  In such cases shrinkage always succeeds for large
@@ -662,13 +657,13 @@
         </row>
         <row>
           <entry>256 KiB</entry>
           <entry>[1280 KiB, 1536 KiB, 1792 KiB]</entry>
         </row>
         <row>
-          <entry morerows="6">Huge</entry>
+          <entry morerows="8">Huge</entry>
           <entry>256 KiB</entry>
           <entry>[2 MiB]</entry>
         </row>
         <row>
           <entry>512 KiB</entry>
           <entry>[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]</entry>
@@ -690,20 +685,28 @@
           <entry>[40 MiB, 48 MiB, 56 MiB, 64 MiB]</entry>
         </row>
         <row>
           <entry>...</entry>
           <entry>...</entry>
         </row>
+        <row>
+          <entry>512 PiB</entry>
+          <entry>[2560 PiB, 3 EiB, 3584 PiB, 4 EiB]</entry>
+        </row>
+        <row>
+          <entry>1 EiB</entry>
+          <entry>[5 EiB, 6 EiB, 7 EiB]</entry>
+        </row>
       </tbody>
       </tgroup>
     </table>
   </refsect1>
   <refsect1 id="mallctl_namespace">
     <title>MALLCTL NAMESPACE</title>
     <para>The following names are defined in the namespace accessible via the
-    <function>mallctl*<parameter/></function> functions.  Value types are
+    <function>mallctl*()</function> functions.  Value types are
     specified in parentheses, their readable/writable statuses are encoded as
     <literal>rw</literal>, <literal>r-</literal>, <literal>-w</literal>, or
     <literal>--</literal>, and required build configuration flags follow, if
     any.  A name element encoded as <literal>&lt;i&gt;</literal> or
     <literal>&lt;j&gt;</literal> indicates an integer component, where the
     integer varies from 0 to some upper value that must be determined via
@@ -728,13 +731,13 @@
         <term>
           <mallctl>epoch</mallctl>
           (<type>uint64_t</type>)
           <literal>rw</literal>
         </term>
         <listitem><para>If a value is passed in, refresh the data from which
-        the <function>mallctl*<parameter/></function> functions report values,
+        the <function>mallctl*()</function> functions report values,
         and increment the epoch.  Return the current epoch.  This is useful for
         detecting whether another thread caused a refresh.</para></listitem>
       </varlistentry>
 
       <varlistentry id="config.cache_oblivious">
         <term>
@@ -773,12 +776,23 @@
           <literal>r-</literal>
         </term>
         <listitem><para><option>--enable-lazy-lock</option> was specified
         during build configuration.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="config.malloc_conf">
+        <term>
+          <mallctl>config.malloc_conf</mallctl>
+          (<type>const char *</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Embedded configure-time-specified run-time options
+        string, empty unless <option>--with-malloc-conf</option> was specified
+        during build configuration.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="config.munmap">
         <term>
           <mallctl>config.munmap</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
@@ -901,18 +915,18 @@
         <manvolnum>2</manvolnum></citerefentry>) allocation precedence as
         related to <citerefentry><refentrytitle>mmap</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> allocation.  The following
         settings are supported if
         <citerefentry><refentrytitle>sbrk</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> is supported by the operating
-        system: &ldquo;disabled&rdquo;, &ldquo;primary&rdquo;, and
-        &ldquo;secondary&rdquo;; otherwise only &ldquo;disabled&rdquo; is
-        supported.  The default is &ldquo;secondary&rdquo; if
+        system: <quote>disabled</quote>, <quote>primary</quote>, and
+        <quote>secondary</quote>; otherwise only <quote>disabled</quote> is
+        supported.  The default is <quote>secondary</quote> if
         <citerefentry><refentrytitle>sbrk</refentrytitle>
         <manvolnum>2</manvolnum></citerefentry> is supported by the operating
-        system; &ldquo;disabled&rdquo; otherwise.
+        system; <quote>disabled</quote> otherwise.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.lg_chunk">
         <term>
           <mallctl>opt.lg_chunk</mallctl>
@@ -926,20 +940,34 @@
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.narenas">
         <term>
           <mallctl>opt.narenas</mallctl>
-          (<type>size_t</type>)
+          (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Maximum number of arenas to use for automatic
         multiplexing of threads and arenas.  The default is four times the
         number of CPUs, or one if there is a single CPU.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="opt.purge">
+        <term>
+          <mallctl>opt.purge</mallctl>
+          (<type>const char *</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Purge mode is &ldquo;ratio&rdquo; (default) or
+        &ldquo;decay&rdquo;.  See <link
+        linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
+        for details of the ratio mode.  See <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link> for
+        details of the decay mode.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="opt.lg_dirty_mult">
         <term>
           <mallctl>opt.lg_dirty_mult</mallctl>
           (<type>ssize_t</type>)
           <literal>r-</literal>
         </term>
@@ -956,53 +984,74 @@
         linkend="arenas.lg_dirty_mult"><mallctl>arenas.lg_dirty_mult</mallctl></link>
         and <link
         linkend="arena.i.lg_dirty_mult"><mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl></link>
         for related dynamic control options.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="opt.decay_time">
+        <term>
+          <mallctl>opt.decay_time</mallctl>
+          (<type>ssize_t</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Approximate time in seconds from the creation of a set
+        of unused dirty pages until an equivalent set of unused dirty pages is
+        purged and/or reused.  The pages are incrementally purged according to a
+        sigmoidal decay curve that starts and ends with zero purge rate.  A
+        decay time of 0 causes all unused dirty pages to be purged immediately
+        upon creation.  A decay time of -1 disables purging.  The default decay
+        time is 10 seconds.  See <link
+        linkend="arenas.decay_time"><mallctl>arenas.decay_time</mallctl></link>
+        and <link
+        linkend="arena.i.decay_time"><mallctl>arena.&lt;i&gt;.decay_time</mallctl></link>
+        for related dynamic control options.
+        </para></listitem>
+      </varlistentry>
+
       <varlistentry id="opt.stats_print">
         <term>
           <mallctl>opt.stats_print</mallctl>
           (<type>bool</type>)
           <literal>r-</literal>
         </term>
         <listitem><para>Enable/disable statistics printing at exit.  If
-        enabled, the <function>malloc_stats_print<parameter/></function>
+        enabled, the <function>malloc_stats_print()</function>
         function is called at program exit via an
         <citerefentry><refentrytitle>atexit</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> function.  If
         <option>--enable-stats</option> is specified during configuration, this
         has the potential to cause deadlock for a multi-threaded process that
         exits while one or more threads are executing in the memory allocation
-        functions.  Furthermore, <function>atexit<parameter/></function> may
+        functions.  Furthermore, <function>atexit()</function> may
         allocate memory during application initialization and then deadlock
         internally when jemalloc in turn calls
-        <function>atexit<parameter/></function>, so this option is not
-        univerally usable (though the application can register its own
-        <function>atexit<parameter/></function> function with equivalent
+        <function>atexit()</function>, so this option is not
+        universally usable (though the application can register its own
+        <function>atexit()</function> function with equivalent
         functionality).  Therefore, this option should only be used with care;
         it is primarily intended as a performance tuning aid during application
         development.  This option is disabled by default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.junk">
         <term>
           <mallctl>opt.junk</mallctl>
           (<type>const char *</type>)
           <literal>r-</literal>
           [<option>--enable-fill</option>]
         </term>
-        <listitem><para>Junk filling.  If set to "alloc", each byte of
-        uninitialized allocated memory will be initialized to
-        <literal>0xa5</literal>.  If set to "free", all deallocated memory will
-        be initialized to <literal>0x5a</literal>.  If set to "true", both
-        allocated and deallocated memory will be initialized, and if set to
-        "false", junk filling be disabled entirely.  This is intended for
-        debugging and will impact performance negatively.  This option is
-        "false" by default unless <option>--enable-debug</option> is specified
-        during configuration, in which case it is "true" by default unless
+        <listitem><para>Junk filling.  If set to <quote>alloc</quote>, each byte
+        of uninitialized allocated memory will be initialized to
+        <literal>0xa5</literal>.  If set to <quote>free</quote>, all deallocated
+        memory will be initialized to <literal>0x5a</literal>.  If set to
+        <quote>true</quote>, both allocated and deallocated memory will be
+        initialized, and if set to <quote>false</quote>, junk filling be
+        disabled entirely.  This is intended for debugging and will impact
+        performance negatively.  This option is <quote>false</quote> by default
+        unless <option>--enable-debug</option> is specified during
+        configuration, in which case it is <quote>true</quote> by default unless
         running inside <ulink
         url="http://valgrind.org/">Valgrind</ulink>.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.quarantine">
         <term>
@@ -1051,14 +1100,14 @@
           <literal>r-</literal>
           [<option>--enable-fill</option>]
         </term>
         <listitem><para>Zero filling enabled/disabled.  If enabled, each byte
         of uninitialized allocated memory will be initialized to 0.  Note that
         this initialization only happens once for each byte, so
-        <function>realloc<parameter/></function> and
-        <function>rallocx<parameter/></function> calls do not zero memory that
+        <function>realloc()</function> and
+        <function>rallocx()</function> calls do not zero memory that
         was previously allocated.  This is intended for debugging and will
         impact performance negatively.  This option is disabled by default.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.utrace">
@@ -1147,13 +1196,14 @@
         option for information on high-water-triggered profile dumping, and the
         <link linkend="opt.prof_final"><mallctl>opt.prof_final</mallctl></link>
         option for final profile dumping.  Profile output is compatible with
         the <command>jeprof</command> command, which is based on the
         <command>pprof</command> that is developed as part of the <ulink
         url="http://code.google.com/p/gperftools/">gperftools
-        package</ulink>.</para></listitem>
+        package</ulink>.  See <link linkend="heap_profile_format">HEAP PROFILE
+        FORMAT</link> for heap profile format documentation.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_prefix">
         <term>
           <mallctl>opt.prof_prefix</mallctl>
           (<type>const char *</type>)
@@ -1274,17 +1324,17 @@
         <citerefentry><refentrytitle>atexit</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> function to dump final memory
         usage to a file named according to the pattern
         <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap</filename>,
         where <literal>&lt;prefix&gt;</literal> is controlled by the <link
         linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
-        option.  Note that <function>atexit<parameter/></function> may allocate
+        option.  Note that <function>atexit()</function> may allocate
         memory during application initialization and then deadlock internally
-        when jemalloc in turn calls <function>atexit<parameter/></function>, so
-        this option is not univerally usable (though the application can
-        register its own <function>atexit<parameter/></function> function with
+        when jemalloc in turn calls <function>atexit()</function>, so
+        this option is not universally usable (though the application can
+        register its own <function>atexit()</function> function with
         equivalent functionality).  This option is disabled by
         default.</para></listitem>
       </varlistentry>
 
       <varlistentry id="opt.prof_leak">
         <term>
@@ -1337,13 +1387,13 @@
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Get a pointer to the the value that is returned by the
         <link
         linkend="thread.allocated"><mallctl>thread.allocated</mallctl></link>
         mallctl.  This is useful for avoiding the overhead of repeated
-        <function>mallctl*<parameter/></function> calls.</para></listitem>
+        <function>mallctl*()</function> calls.</para></listitem>
       </varlistentry>
 
       <varlistentry id="thread.deallocated">
         <term>
           <mallctl>thread.deallocated</mallctl>
           (<type>uint64_t</type>)
@@ -1364,13 +1414,13 @@
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Get a pointer to the the value that is returned by the
         <link
         linkend="thread.deallocated"><mallctl>thread.deallocated</mallctl></link>
         mallctl.  This is useful for avoiding the overhead of repeated
-        <function>mallctl*<parameter/></function> calls.</para></listitem>
+        <function>mallctl*()</function> calls.</para></listitem>
       </varlistentry>
 
       <varlistentry id="thread.tcache.enabled">
         <term>
           <mallctl>thread.tcache.enabled</mallctl>
           (<type>bool</type>)
@@ -1415,14 +1465,14 @@
         created, so the input string need not be maintained after this interface
         completes execution.  The output string of this interface should be
         copied for non-ephemeral uses, because multiple implementation details
         can cause asynchronous string deallocation.  Furthermore, each
         invocation of this interface can only read or write; simultaneous
         read/write is not supported due to string lifetime limitations.  The
-        name string must nil-terminated and comprised only of characters in the
-        sets recognized
+        name string must be nil-terminated and comprised only of characters in
+        the sets recognized
         by <citerefentry><refentrytitle>isgraph</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry> and
         <citerefentry><refentrytitle>isblank</refentrytitle>
         <manvolnum>3</manvolnum></citerefentry>.</para></listitem>
       </varlistentry>
 
@@ -1464,13 +1514,13 @@
           <literal>-w</literal>
           [<option>--enable-tcache</option>]
         </term>
         <listitem><para>Flush the specified thread-specific cache (tcache).  The
         same considerations apply to this interface as to <link
         linkend="thread.tcache.flush"><mallctl>thread.tcache.flush</mallctl></link>,
-        except that the tcache will never be automatically be discarded.
+        except that the tcache will never be automatically discarded.
         </para></listitem>
       </varlistentry>
 
       <varlistentry id="tcache.destroy">
         <term>
           <mallctl>tcache.destroy</mallctl>
@@ -1486,18 +1536,50 @@
       <varlistentry id="arena.i.purge">
         <term>
           <mallctl>arena.&lt;i&gt;.purge</mallctl>
           (<type>void</type>)
           <literal>--</literal>
         </term>
-        <listitem><para>Purge unused dirty pages for arena &lt;i&gt;, or for
+        <listitem><para>Purge all unused dirty pages for arena &lt;i&gt;, or for
         all arenas if &lt;i&gt; equals <link
         linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.
         </para></listitem>
       </varlistentry>
 
+      <varlistentry id="arena.i.decay">
+        <term>
+          <mallctl>arena.&lt;i&gt;.decay</mallctl>
+          (<type>void</type>)
+          <literal>--</literal>
+        </term>
+        <listitem><para>Trigger decay-based purging of unused dirty pages for
+        arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals <link
+        linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.
+        The proportion of unused dirty pages to be purged depends on the current
+        time; see <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link> for
+        details.</para></listitem>
+      </varlistentry>
+
+      <varlistentry id="arena.i.reset">
+        <term>
+          <mallctl>arena.&lt;i&gt;.reset</mallctl>
+          (<type>void</type>)
+          <literal>--</literal>
+        </term>
+        <listitem><para>Discard all of the arena's extant allocations.  This
+        interface can only be used with arenas created via <link
+        linkend="arenas.extend"><mallctl>arenas.extend</mallctl></link>.  None
+        of the arena's discarded/cached allocations may accessed afterward.  As
+        part of this requirement, all thread caches which were used to
+        allocate/deallocate in conjunction with the arena must be flushed
+        beforehand.  This interface cannot be used if running inside Valgrind,
+        nor if the <link linkend="opt.quarantine">quarantine</link> size is
+        non-zero.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="arena.i.dss">
         <term>
           <mallctl>arena.&lt;i&gt;.dss</mallctl>
           (<type>const char *</type>)
           <literal>rw</literal>
         </term>
@@ -1520,12 +1602,28 @@
         the ratio is increased, pages are synchronously purged as necessary to
         impose the new ratio.  See <link
         linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
         for additional information.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="arena.i.decay_time">
+        <term>
+          <mallctl>arena.&lt;i&gt;.decay_time</mallctl>
+          (<type>ssize_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Current per-arena approximate time in seconds from the
+        creation of a set of unused dirty pages until an equivalent set of
+        unused dirty pages is purged and/or reused.  Each time this interface is
+        set, all currently unused dirty pages are considered to have fully
+        decayed, which causes immediate purging of all unused dirty pages unless
+        the decay time is set to -1 (i.e. purging disabled).  See <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link> for
+        additional information.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="arena.i.chunk_hooks">
         <term>
           <mallctl>arena.&lt;i&gt;.chunk_hooks</mallctl>
           (<type>chunk_hooks_t</type>)
           <literal>rw</literal>
         </term>
@@ -1754,12 +1852,27 @@
         linkend="arena.i.lg_dirty_mult"><mallctl>arena.&lt;i&gt;.lg_dirty_mult</mallctl></link>
         during arena creation.  See <link
         linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
         for additional information.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="arenas.decay_time">
+        <term>
+          <mallctl>arenas.decay_time</mallctl>
+          (<type>ssize_t</type>)
+          <literal>rw</literal>
+        </term>
+        <listitem><para>Current default per-arena approximate time in seconds
+        from the creation of a set of unused dirty pages until an equivalent set
+        of unused dirty pages is purged and/or reused, used to initialize <link
+        linkend="arena.i.decay_time"><mallctl>arena.&lt;i&gt;.decay_time</mallctl></link>
+        during arena creation.  See <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link> for
+        additional information.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="arenas.quantum">
         <term>
           <mallctl>arenas.quantum</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
         </term>
@@ -1973,13 +2086,13 @@
           <mallctl>prof.interval</mallctl>
           (<type>uint64_t</type>)
           <literal>r-</literal>
           [<option>--enable-prof</option>]
         </term>
         <listitem><para>Average number of bytes allocated between
-        inverval-based profile dumps.  See the
+        interval-based profile dumps.  See the
         <link
         linkend="opt.lg_prof_interval"><mallctl>opt.lg_prof_interval</mallctl></link>
         option for additional information.</para></listitem>
       </varlistentry>
 
       <varlistentry id="stats.cactive">
@@ -2072,12 +2185,31 @@
         This does not include inactive chunks, even those that contain unused
         dirty pages, which means that there is no strict ordering between this
         and <link
         linkend="stats.resident"><mallctl>stats.resident</mallctl></link>.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.retained">
+        <term>
+          <mallctl>stats.retained</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Total number of bytes in virtual memory mappings that
+        were retained rather than being returned to the operating system via
+        e.g. <citerefentry><refentrytitle>munmap</refentrytitle>
+        <manvolnum>2</manvolnum></citerefentry>.  Retained virtual memory is
+        typically untouched, decommitted, or purged, so it has no strongly
+        associated physical memory (see <link
+        linkend="arena.i.chunk_hooks">chunk hooks</link> for details).  Retained
+        memory is excluded from mapped memory statistics, e.g. <link
+        linkend="stats.mapped"><mallctl>stats.mapped</mallctl></link>.
+        </para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.dss">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.dss</mallctl>
           (<type>const char *</type>)
           <literal>r-</literal>
         </term>
@@ -2098,12 +2230,25 @@
         <listitem><para>Minimum ratio (log base 2) of active to dirty pages.
         See <link
         linkend="opt.lg_dirty_mult"><mallctl>opt.lg_dirty_mult</mallctl></link>
         for details.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.decay_time">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.decay_time</mallctl>
+          (<type>ssize_t</type>)
+          <literal>r-</literal>
+        </term>
+        <listitem><para>Approximate time in seconds from the creation of a set
+        of unused dirty pages until an equivalent set of unused dirty pages is
+        purged and/or reused.  See <link
+        linkend="opt.decay_time"><mallctl>opt.decay_time</mallctl></link>
+        for details.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.nthreads">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.nthreads</mallctl>
           (<type>unsigned</type>)
           <literal>r-</literal>
         </term>
@@ -2139,12 +2284,24 @@
           <literal>r-</literal>
           [<option>--enable-stats</option>]
         </term>
         <listitem><para>Number of mapped bytes.</para></listitem>
       </varlistentry>
 
+      <varlistentry id="stats.arenas.i.retained">
+        <term>
+          <mallctl>stats.arenas.&lt;i&gt;.retained</mallctl>
+          (<type>size_t</type>)
+          <literal>r-</literal>
+          [<option>--enable-stats</option>]
+        </term>
+        <listitem><para>Number of retained bytes.  See <link
+        linkend="stats.retained"><mallctl>stats.retained</mallctl></link> for
+        details.</para></listitem>
+      </varlistentry>
+
       <varlistentry id="stats.arenas.i.metadata.mapped">
         <term>
           <mallctl>stats.arenas.&lt;i&gt;.metadata.mapped</mallctl>
           (<type>size_t</type>)
           <literal>r-</literal>
           [<option>--enable-stats</option>]
@@ -2520,22 +2677,69 @@
         </term>
         <listitem><para>Current number of huge allocations for this size class.
         </para></listitem>
       </varlistentry>
     </variablelist>
   </refsect1>
+  <refsect1 id="heap_profile_format">
+    <title>HEAP PROFILE FORMAT</title>
+    <para>Although the heap profiling functionality was originally designed to
+    be compatible with the
+    <command>pprof</command> command that is developed as part of the <ulink
+    url="http://code.google.com/p/gperftools/">gperftools
+    package</ulink>, the addition of per thread heap profiling functionality
+    required a different heap profile format.  The <command>jeprof</command>
+    command is derived from <command>pprof</command>, with enhancements to
+    support the heap profile format described here.</para>
+
+    <para>In the following hypothetical heap profile, <constant>[...]</constant>
+    indicates elision for the sake of compactness.  <programlisting><![CDATA[
+heap_v2/524288
+  t*: 28106: 56637512 [0: 0]
+  [...]
+  t3: 352: 16777344 [0: 0]
+  [...]
+  t99: 17754: 29341640 [0: 0]
+  [...]
+@ 0x5f86da8 0x5f5a1dc [...] 0x29e4d4e 0xa200316 0xabb2988 [...]
+  t*: 13: 6688 [0: 0]
+  t3: 12: 6496 [0: ]
+  t99: 1: 192 [0: 0]
+[...]
+
+MAPPED_LIBRARIES:
+[...]]]></programlisting> The following matches the above heap profile, but most
+tokens are replaced with <constant>&lt;description&gt;</constant> to indicate
+descriptions of the corresponding fields.  <programlisting><![CDATA[
+<heap_profile_format_version>/<mean_sample_interval>
+  <aggregate>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+  [...]
+  <thread_3_aggregate>: <curobjs>: <curbytes>[<cumobjs>: <cumbytes>]
+  [...]
+  <thread_99_aggregate>: <curobjs>: <curbytes>[<cumobjs>: <cumbytes>]
+  [...]
+@ <top_frame> <frame> [...] <frame> <frame> <frame> [...]
+  <backtrace_aggregate>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+  <backtrace_thread_3>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+  <backtrace_thread_99>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
+[...]
+
+MAPPED_LIBRARIES:
+</proc/<pid>/maps>]]></programlisting></para>
+  </refsect1>
+
   <refsect1 id="debugging_malloc_problems">
     <title>DEBUGGING MALLOC PROBLEMS</title>
     <para>When debugging, it is a good idea to configure/build jemalloc with
     the <option>--enable-debug</option> and <option>--enable-fill</option>
     options, and recompile the program with suitable options and symbols for
     debugger support.  When so configured, jemalloc incorporates a wide variety
     of run-time assertions that catch application errors such as double-free,
     write-after-free, etc.</para>
 
-    <para>Programs often accidentally depend on &ldquo;uninitialized&rdquo;
+    <para>Programs often accidentally depend on <quote>uninitialized</quote>
     memory actually being filled with zero bytes.  Junk filling
     (see the <link linkend="opt.junk"><mallctl>opt.junk</mallctl></link>
     option) tends to expose such bugs in the form of obviously incorrect
     results and/or coredumps.  Conversely, zero
     filling (see the <link
     linkend="opt.zero"><mallctl>opt.zero</mallctl></link> option) eliminates
@@ -2558,35 +2762,35 @@
     warnings are treated as errors.</para>
 
     <para>The <varname>malloc_message</varname> variable allows the programmer
     to override the function which emits the text strings forming the errors
     and warnings if for some reason the <constant>STDERR_FILENO</constant> file
     descriptor is not suitable for this.
-    <function>malloc_message<parameter/></function> takes the
+    <function>malloc_message()</function> takes the
     <parameter>cbopaque</parameter> pointer argument that is
     <constant>NULL</constant> unless overridden by the arguments in a call to
-    <function>malloc_stats_print<parameter/></function>, followed by a string
+    <function>malloc_stats_print()</function>, followed by a string
     pointer.  Please note that doing anything which tries to allocate memory in
     this function is likely to result in a crash or deadlock.</para>
 
     <para>All messages are prefixed by
-    &ldquo;<computeroutput>&lt;jemalloc&gt;: </computeroutput>&rdquo;.</para>
+    <quote><computeroutput>&lt;jemalloc&gt;: </computeroutput></quote>.</para>
   </refsect1>
   <refsect1 id="return_values">
     <title>RETURN VALUES</title>
     <refsect2>
       <title>Standard API</title>
-      <para>The <function>malloc<parameter/></function> and
-      <function>calloc<parameter/></function> functions return a pointer to the
+      <para>The <function>malloc()</function> and
+      <function>calloc()</function> functions return a pointer to the
       allocated memory if successful; otherwise a <constant>NULL</constant>
       pointer is returned and <varname>errno</varname> is set to
       <errorname>ENOMEM</errorname>.</para>
 
-      <para>The <function>posix_memalign<parameter/></function> function
+      <para>The <function>posix_memalign()</function> function
       returns the value 0 if successful; otherwise it returns an error value.
-      The <function>posix_memalign<parameter/></function> function will fail
+      The <function>posix_memalign()</function> function will fail
       if:
         <variablelist>
           <varlistentry>
             <term><errorname>EINVAL</errorname></term>
 
             <listitem><para>The <parameter>alignment</parameter> parameter is
@@ -2599,17 +2803,17 @@
 
             <listitem><para>Memory allocation error.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
-      <para>The <function>aligned_alloc<parameter/></function> function returns
+      <para>The <function>aligned_alloc()</function> function returns
       a pointer to the allocated memory if successful; otherwise a
       <constant>NULL</constant> pointer is returned and
       <varname>errno</varname> is set.  The
-      <function>aligned_alloc<parameter/></function> function will fail if:
+      <function>aligned_alloc()</function> function will fail if:
         <variablelist>
           <varlistentry>
             <term><errorname>EINVAL</errorname></term>
 
             <listitem><para>The <parameter>alignment</parameter> parameter is
             not a power of 2.
@@ -2620,50 +2824,50 @@
 
             <listitem><para>Memory allocation error.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
-      <para>The <function>realloc<parameter/></function> function returns a
+      <para>The <function>realloc()</function> function returns a
       pointer, possibly identical to <parameter>ptr</parameter>, to the
       allocated memory if successful; otherwise a <constant>NULL</constant>
       pointer is returned, and <varname>errno</varname> is set to
       <errorname>ENOMEM</errorname> if the error was the result of an
-      allocation failure.  The <function>realloc<parameter/></function>
+      allocation failure.  The <function>realloc()</function>
       function always leaves the original buffer intact when an error occurs.
       </para>
 
-      <para>The <function>free<parameter/></function> function returns no
+      <para>The <function>free()</function> function returns no
       value.</para>
     </refsect2>
     <refsect2>
       <title>Non-standard API</title>
-      <para>The <function>mallocx<parameter/></function> and
-      <function>rallocx<parameter/></function> functions return a pointer to
+      <para>The <function>mallocx()</function> and
+      <function>rallocx()</function> functions return a pointer to
       the allocated memory if successful; otherwise a <constant>NULL</constant>
       pointer is returned to indicate insufficient contiguous memory was
       available to service the allocation request.  </para>
 
-      <para>The <function>xallocx<parameter/></function> function returns the
+      <para>The <function>xallocx()</function> function returns the
       real size of the resulting resized allocation pointed to by
       <parameter>ptr</parameter>, which is a value less than
       <parameter>size</parameter> if the allocation could not be adequately
       grown in place.  </para>
 
-      <para>The <function>sallocx<parameter/></function> function returns the
+      <para>The <function>sallocx()</function> function returns the
       real size of the allocation pointed to by <parameter>ptr</parameter>.
       </para>
 
-      <para>The <function>nallocx<parameter/></function> returns the real size
+      <para>The <function>nallocx()</function> returns the real size
       that would result from a successful equivalent
-      <function>mallocx<parameter/></function> function call, or zero if
+      <function>mallocx()</function> function call, or zero if
       insufficient memory is available to perform the size computation.  </para>
 
-      <para>The <function>mallctl<parameter/></function>,
-      <function>mallctlnametomib<parameter/></function>, and
-      <function>mallctlbymib<parameter/></function> functions return 0 on
+      <para>The <function>mallctl()</function>,
+      <function>mallctlnametomib()</function>, and
+      <function>mallctlbymib()</function> functions return 0 on
       success; otherwise they return an error value.  The functions will fail
       if:
         <variablelist>
           <varlistentry>
             <term><errorname>EINVAL</errorname></term>
 
@@ -2693,19 +2897,19 @@
             occurred.</para></listitem>
           </varlistentry>
           <varlistentry>
             <term><errorname>EFAULT</errorname></term>
 
             <listitem><para>An interface with side effects failed in some way
-            not directly related to <function>mallctl*<parameter/></function>
+            not directly related to <function>mallctl*()</function>
             read/write processing.</para></listitem>
           </varlistentry>
         </variablelist>
       </para>
 
-      <para>The <function>malloc_usable_size<parameter/></function> function
+      <para>The <function>malloc_usable_size()</function> function
       returns the usable size of the allocation pointed to by
       <parameter>ptr</parameter>.  </para>
     </refsect2>
   </refsect1>
   <refsect1 id="environment">
     <title>ENVIRONMENT</title>
@@ -2747,16 +2951,16 @@
     <manvolnum>3</manvolnum></citerefentry>,
     <citerefentry><refentrytitle>getpagesize</refentrytitle>
     <manvolnum>3</manvolnum></citerefentry></para>
   </refsect1>
   <refsect1 id="standards">
     <title>STANDARDS</title>
-    <para>The <function>malloc<parameter/></function>,
-    <function>calloc<parameter/></function>,
-    <function>realloc<parameter/></function>, and
-    <function>free<parameter/></function> functions conform to ISO/IEC
-    9899:1990 (&ldquo;ISO C90&rdquo;).</para>
+    <para>The <function>malloc()</function>,
+    <function>calloc()</function>,
+    <function>realloc()</function>, and
+    <function>free()</function> functions conform to ISO/IEC
+    9899:1990 (<quote>ISO C90</quote>).</para>
 
-    <para>The <function>posix_memalign<parameter/></function> function conforms
-    to IEEE Std 1003.1-2001 (&ldquo;POSIX.1&rdquo;).</para>
+    <para>The <function>posix_memalign()</function> function conforms
+    to IEEE Std 1003.1-2001 (<quote>POSIX.1</quote>).</para>
   </refsect1>
 </refentry>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/manpages.xsl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/manpages.xsl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/manpages.xsl	2017-09-27 23:00:17.390936201 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/manpages.xsl	2017-09-27 23:01:52.370932720 +0800
@@ -1,4 +1,4 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:import href="/usr/share/xml/docbook/stylesheet/docbook-xsl/manpages/docbook.xsl"/>
-  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/stylesheet.xsl"/>
+  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/stylesheet.xsl"/>
 </xsl:stylesheet>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/stylesheet.xsl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/stylesheet.xsl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/doc/stylesheet.xsl	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/doc/stylesheet.xsl	2017-01-31 23:32:23.000000000 +0800
@@ -1,7 +1,10 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:param name="funcsynopsis.style">ansi</xsl:param>
-  <xsl:param name="function.parens" select="1"/>
+  <xsl:param name="function.parens" select="0"/>
+  <xsl:template match="function">
+    <xsl:call-template name="inline.monoseq"/>
+  </xsl:template>
   <xsl:template match="mallctl">
-    "<xsl:call-template name="inline.monoseq"/>"
+    <quote><xsl:call-template name="inline.monoseq"/></quote>
   </xsl:template>
 </xsl:stylesheet>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/.gitignore /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/.gitignore
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/.gitignore	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/.gitignore	2017-01-31 23:32:23.000000000 +0800
@@ -70,6 +70,22 @@
 /test/unit/*.[od]
 /test/unit/*.gcda
 /test/unit/*.gcno
 /test/unit/*.out
 
 /VERSION
+
+*.pdb
+*.sdf
+*.opendb
+*.opensdf
+*.cachefile
+*.suo
+*.user
+*.sln.docstates
+*.tmp
+/msvc/Win32/
+/msvc/x64/
+/msvc/projects/*/*/Debug*/
+/msvc/projects/*/*/Release*/
+/msvc/projects/*/*/Win32/
+/msvc/projects/*/*/x64/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/arena.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/arena.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/arena.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/arena.h	2017-01-31 23:32:23.000000000 +0800
@@ -20,20 +20,35 @@
  *
  * So, supposing that lg_dirty_mult is 3, there can be no less than 8 times as
  * many active pages as dirty pages.
  */
 #define	LG_DIRTY_MULT_DEFAULT	3
 
+typedef enum {
+	purge_mode_ratio = 0,
+	purge_mode_decay = 1,
+
+	purge_mode_limit = 2
+} purge_mode_t;
+#define	PURGE_DEFAULT		purge_mode_ratio
+/* Default decay time in seconds. */
+#define	DECAY_TIME_DEFAULT	10
+/* Number of event ticks between time checks. */
+#define	DECAY_NTICKS_PER_UPDATE	1000
+
 typedef struct arena_runs_dirty_link_s arena_runs_dirty_link_t;
+typedef struct arena_avail_links_s arena_avail_links_t;
 typedef struct arena_run_s arena_run_t;
 typedef struct arena_chunk_map_bits_s arena_chunk_map_bits_t;
 typedef struct arena_chunk_map_misc_s arena_chunk_map_misc_t;
 typedef struct arena_chunk_s arena_chunk_t;
 typedef struct arena_bin_info_s arena_bin_info_t;
+typedef struct arena_decay_s arena_decay_t;
 typedef struct arena_bin_s arena_bin_t;
 typedef struct arena_s arena_t;
+typedef struct arena_tdata_s arena_tdata_t;
 
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
 
 #ifdef JEMALLOC_ARENA_STRUCTS_A
@@ -137,36 +152,35 @@
  * Each arena_chunk_map_misc_t corresponds to one page within the chunk, just
  * like arena_chunk_map_bits_t.  Two separate arrays are stored within each
  * chunk header in order to improve cache locality.
  */
 struct arena_chunk_map_misc_s {
 	/*
-	 * Linkage for run trees.  There are two disjoint uses:
+	 * Linkage for run heaps.  There are two disjoint uses:
 	 *
-	 * 1) arena_t's runs_avail tree.
+	 * 1) arena_t's runs_avail heaps.
 	 * 2) arena_run_t conceptually uses this linkage for in-use non-full
 	 *    runs, rather than directly embedding linkage.
 	 */
-	rb_node(arena_chunk_map_misc_t)		rb_link;
+	phn(arena_chunk_map_misc_t)		ph_link;
 
 	union {
 		/* Linkage for list of dirty runs. */
 		arena_runs_dirty_link_t		rd;
 
 		/* Profile counters, used for large object runs. */
 		union {
-			void				*prof_tctx_pun;
-			prof_tctx_t			*prof_tctx;
+			void			*prof_tctx_pun;
+			prof_tctx_t		*prof_tctx;
 		};
 
 		/* Small region run metadata. */
 		arena_run_t			run;
 	};
 };
-typedef rb_tree(arena_chunk_map_misc_t) arena_avail_tree_t;
-typedef rb_tree(arena_chunk_map_misc_t) arena_run_tree_t;
+typedef ph(arena_chunk_map_misc_t) arena_run_heap_t;
 #endif /* JEMALLOC_ARENA_STRUCTS_A */
 
 #ifdef JEMALLOC_ARENA_STRUCTS_B
 /* Arena chunk header. */
 struct arena_chunk_s {
 	/*
@@ -174,12 +188,20 @@
 	 * This field as a whole is used by chunks_rtree to support both
 	 * ivsalloc() and core-based debugging.
 	 */
 	extent_node_t		node;
 
 	/*
+	 * True if memory could be backed by transparent huge pages.  This is
+	 * only directly relevant to Linux, since it is the only supported
+	 * platform on which jemalloc interacts with explicit transparent huge
+	 * page controls.
+	 */
+	bool			hugepage;
+
+	/*
 	 * Map of pages within chunk that keeps track of free/large/small.  The
 	 * first map_bias entries are omitted, since the chunk header does not
 	 * need to be tracked in the map.  This omission saves a header page
 	 * for common chunk sizes (e.g. 4 MiB).
 	 */
 	arena_chunk_map_bits_t	map_bits[1]; /* Dynamically sized. */
@@ -217,78 +239,129 @@
  * reg_interval has at least the same minimum alignment as reg_size; this
  * preserves the alignment constraint that sa2u() depends on.  Alignment pad is
  * either 0 or redzone_size; it is present only if needed to align reg0_offset.
  */
 struct arena_bin_info_s {
 	/* Size of regions in a run for this bin's size class. */
-	size_t		reg_size;
+	size_t			reg_size;
 
 	/* Redzone size. */
-	size_t		redzone_size;
+	size_t			redzone_size;
 
 	/* Interval between regions (reg_size + (redzone_size << 1)). */
-	size_t		reg_interval;
+	size_t			reg_interval;
 
 	/* Total size of a run for this bin's size class. */
-	size_t		run_size;
+	size_t			run_size;
 
 	/* Total number of regions in a run for this bin's size class. */
-	uint32_t	nregs;
+	uint32_t		nregs;
 
 	/*
 	 * Metadata used to manipulate bitmaps for runs associated with this
 	 * bin.
 	 */
-	bitmap_info_t	bitmap_info;
+	bitmap_info_t		bitmap_info;
 
 	/* Offset of first region in a run for this bin's size class. */
-	uint32_t	reg0_offset;
+	uint32_t		reg0_offset;
+};
+
+struct arena_decay_s {
+	/*
+	 * Approximate time in seconds from the creation of a set of unused
+	 * dirty pages until an equivalent set of unused dirty pages is purged
+	 * and/or reused.
+	 */
+	ssize_t			time;
+	/* time / SMOOTHSTEP_NSTEPS. */
+	nstime_t		interval;
+	/*
+	 * Time at which the current decay interval logically started.  We do
+	 * not actually advance to a new epoch until sometime after it starts
+	 * because of scheduling and computation delays, and it is even possible
+	 * to completely skip epochs.  In all cases, during epoch advancement we
+	 * merge all relevant activity into the most recently recorded epoch.
+	 */
+	nstime_t		epoch;
+	/* Deadline randomness generator. */
+	uint64_t		jitter_state;
+	/*
+	 * Deadline for current epoch.  This is the sum of interval and per
+	 * epoch jitter which is a uniform random variable in [0..interval).
+	 * Epochs always advance by precise multiples of interval, but we
+	 * randomize the deadline to reduce the likelihood of arenas purging in
+	 * lockstep.
+	 */
+	nstime_t		deadline;
+	/*
+	 * Number of dirty pages at beginning of current epoch.  During epoch
+	 * advancement we use the delta between arena->decay.ndirty and
+	 * arena->ndirty to determine how many dirty pages, if any, were
+	 * generated.
+	 */
+	size_t			ndirty;
+	/*
+	 * Trailing log of how many unused dirty pages were generated during
+	 * each of the past SMOOTHSTEP_NSTEPS decay epochs, where the last
+	 * element is the most recent epoch.  Corresponding epoch times are
+	 * relative to epoch.
+	 */
+	size_t			backlog[SMOOTHSTEP_NSTEPS];
 };
 
 struct arena_bin_s {
 	/*
 	 * All operations on runcur, runs, and stats require that lock be
 	 * locked.  Run allocation/deallocation are protected by the arena lock,
 	 * which may be acquired while holding one or more bin locks, but not
 	 * vise versa.
 	 */
-	malloc_mutex_t	lock;
+	malloc_mutex_t		lock;
 
 	/*
 	 * Current run being used to service allocations of this bin's size
 	 * class.
 	 */
-	arena_run_t	*runcur;
+	arena_run_t		*runcur;
 
 	/*
-	 * Tree of non-full runs.  This tree is used when looking for an
+	 * Heap of non-full runs.  This heap is used when looking for an
 	 * existing run when runcur is no longer usable.  We choose the
 	 * non-full run that is lowest in memory; this policy tends to keep
 	 * objects packed well, and it can also help reduce the number of
 	 * almost-empty chunks.
 	 */
-	arena_run_tree_t runs;
+	arena_run_heap_t	runs;
 
 	/* Bin statistics. */
-	malloc_bin_stats_t stats;
+	malloc_bin_stats_t	stats;
 };
 
 struct arena_s {
 	/* This arena's index within the arenas array. */
 	unsigned		ind;
 
 	/*
-	 * Number of threads currently assigned to this arena.  This field is
-	 * protected by arenas_lock.
+	 * Number of threads currently assigned to this arena, synchronized via
+	 * atomic operations.  Each thread has two distinct assignments, one for
+	 * application-serving allocation, and the other for internal metadata
+	 * allocation.  Internal metadata must not be allocated from arenas
+	 * created via the arenas.extend mallctl, because the arena.<i>.reset
+	 * mallctl indiscriminately discards all allocations for the affected
+	 * arena.
+	 *
+	 *   0: Application allocation.
+	 *   1: Internal metadata allocation.
 	 */
-	unsigned		nthreads;
+	unsigned		nthreads[2];
 
 	/*
 	 * There are three classes of arena operations from a locking
 	 * perspective:
-	 * 1) Thread assignment (modifies nthreads) is protected by arenas_lock.
+	 * 1) Thread assignment (modifies nthreads) is synchronized via atomics.
 	 * 2) Bin-related operations are protected by bin locks.
 	 * 3) Chunk- and run-related operations are protected by this mutex.
 	 */
 	malloc_mutex_t		lock;
 
 	arena_stats_t		stats;
@@ -302,16 +375,22 @@
 	uint64_t		prof_accumbytes;
 
 	/*
 	 * PRNG state for cache index randomization of large allocation base
 	 * pointers.
 	 */
-	uint64_t		offset_state;
+	size_t			offset_state;
 
 	dss_prec_t		dss_prec;
 
+	/* Extant arena chunks. */
+	ql_head(extent_node_t)	achunks;
+
+	/* Extent serial number generator state. */
+	size_t			extent_sn_next;
+
 	/*
 	 * In order to avoid rapid chunk allocation/deallocation when an arena
 	 * oscillates right on the cusp of needing a new chunk, cache the most
 	 * recently freed chunk.  The spare is left in the arena's chunk trees
 	 * until it is deleted.
 	 *
@@ -321,13 +400,13 @@
 	 */
 	arena_chunk_t		*spare;
 
 	/* Minimum ratio (log base 2) of nactive:ndirty. */
 	ssize_t			lg_dirty_mult;
 
-	/* True if a thread is currently executing arena_purge(). */
+	/* True if a thread is currently executing arena_purge_to_limit(). */
 	bool			purging;
 
 	/* Number of pages in active runs and huge regions. */
 	size_t			nactive;
 
 	/*
@@ -336,18 +415,12 @@
 	 * By tracking this, we can institute a limit on how much dirty unused
 	 * memory is mapped for each arena.
 	 */
 	size_t			ndirty;
 
 	/*
-	 * Size/address-ordered tree of this arena's available runs.  The tree
-	 * is used for first-best-fit run allocation.
-	 */
-	arena_avail_tree_t	runs_avail;
-
-	/*
 	 * Unused dirty memory this arena manages.  Dirty memory is conceptually
 	 * tracked as an arbitrarily interleaved LRU of dirty runs and cached
 	 * chunks, but the list linkage is actually semi-duplicated in order to
 	 * avoid extra arena_chunk_map_misc_t space overhead.
 	 *
 	 *   LRU-----------------------------------------------------------MRU
@@ -372,39 +445,55 @@
 	 *        |            |                             |         |
 	 *        \------------/                             \---------/
 	 */
 	arena_runs_dirty_link_t	runs_dirty;
 	extent_node_t		chunks_cache;
 
+	/* Decay-based purging state. */
+	arena_decay_t		decay;
+
 	/* Extant huge allocations. */
 	ql_head(extent_node_t)	huge;
 	/* Synchronizes all huge allocation/update/deallocation. */
 	malloc_mutex_t		huge_mtx;
 
 	/*
 	 * Trees of chunks that were previously allocated (trees differ only in
 	 * node ordering).  These are used when allocating chunks, in an attempt
 	 * to re-use address space.  Depending on function, different tree
 	 * orderings are needed, which is why there are two trees with the same
 	 * contents.
 	 */
-	extent_tree_t		chunks_szad_cached;
+	extent_tree_t		chunks_szsnad_cached;
 	extent_tree_t		chunks_ad_cached;
-	extent_tree_t		chunks_szad_retained;
+	extent_tree_t		chunks_szsnad_retained;
 	extent_tree_t		chunks_ad_retained;
 
 	malloc_mutex_t		chunks_mtx;
 	/* Cache of nodes that were allocated via base_alloc(). */
 	ql_head(extent_node_t)	node_cache;
 	malloc_mutex_t		node_cache_mtx;
 
 	/* User-configurable chunk hook functions. */
 	chunk_hooks_t		chunk_hooks;
 
 	/* bins is used to store trees of free regions. */
 	arena_bin_t		bins[NBINS];
+
+	/*
+	 * Size-segregated address-ordered heaps of this arena's available runs,
+	 * used for first-best-fit run allocation.  Runs are quantized, i.e.
+	 * they reside in the last heap which corresponds to a size class less
+	 * than or equal to the run size.
+	 */
+	arena_run_heap_t	runs_avail[NPSIZES];
+};
+
+/* Used in conjunction with tsd for fast arena-related context lookup. */
+struct arena_tdata_s {
+	ticker_t		decay_ticker;
 };
 #endif /* JEMALLOC_ARENA_STRUCTS_B */
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
@@ -414,125 +503,163 @@
     PAGE
 #else
     0
 #endif
     ;
 
+extern purge_mode_t	opt_purge;
+extern const char	*purge_mode_names[];
 extern ssize_t		opt_lg_dirty_mult;
+extern ssize_t		opt_decay_time;
 
 extern arena_bin_info_t	arena_bin_info[NBINS];
 
 extern size_t		map_bias; /* Number of arena chunk header pages. */
 extern size_t		map_misc_offset;
 extern size_t		arena_maxrun; /* Max run size for arenas. */
 extern size_t		large_maxclass; /* Max large size class. */
 extern unsigned		nlclasses; /* Number of large size classes. */
 extern unsigned		nhclasses; /* Number of huge size classes. */
 
+#ifdef JEMALLOC_JET
+typedef size_t (run_quantize_t)(size_t);
+extern run_quantize_t *run_quantize_floor;
+extern run_quantize_t *run_quantize_ceil;
+#endif
 void	arena_chunk_cache_maybe_insert(arena_t *arena, extent_node_t *node,
     bool cache);
 void	arena_chunk_cache_maybe_remove(arena_t *arena, extent_node_t *node,
     bool cache);
-extent_node_t	*arena_node_alloc(arena_t *arena);
-void	arena_node_dalloc(arena_t *arena, extent_node_t *node);
-void	*arena_chunk_alloc_huge(arena_t *arena, size_t usize, size_t alignment,
-    bool *zero);
-void	arena_chunk_dalloc_huge(arena_t *arena, void *chunk, size_t usize);
-void	arena_chunk_ralloc_huge_similar(arena_t *arena, void *chunk,
-    size_t oldsize, size_t usize);
-void	arena_chunk_ralloc_huge_shrink(arena_t *arena, void *chunk,
-    size_t oldsize, size_t usize);
-bool	arena_chunk_ralloc_huge_expand(arena_t *arena, void *chunk,
-    size_t oldsize, size_t usize, bool *zero);
-ssize_t	arena_lg_dirty_mult_get(arena_t *arena);
-bool	arena_lg_dirty_mult_set(arena_t *arena, ssize_t lg_dirty_mult);
-void	arena_maybe_purge(arena_t *arena);
-void	arena_purge_all(arena_t *arena);
-void	arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin,
-    szind_t binind, uint64_t prof_accumbytes);
+extent_node_t	*arena_node_alloc(tsdn_t *tsdn, arena_t *arena);
+void	arena_node_dalloc(tsdn_t *tsdn, arena_t *arena, extent_node_t *node);
+void	*arena_chunk_alloc_huge(tsdn_t *tsdn, arena_t *arena, size_t usize,
+    size_t alignment, size_t *sn, bool *zero);
+void	arena_chunk_dalloc_huge(tsdn_t *tsdn, arena_t *arena, void *chunk,
+    size_t usize, size_t sn);
+void	arena_chunk_ralloc_huge_similar(tsdn_t *tsdn, arena_t *arena,
+    void *chunk, size_t oldsize, size_t usize);
+void	arena_chunk_ralloc_huge_shrink(tsdn_t *tsdn, arena_t *arena,
+    void *chunk, size_t oldsize, size_t usize, size_t sn);
+bool	arena_chunk_ralloc_huge_expand(tsdn_t *tsdn, arena_t *arena,
+    void *chunk, size_t oldsize, size_t usize, bool *zero);
+ssize_t	arena_lg_dirty_mult_get(tsdn_t *tsdn, arena_t *arena);
+bool	arena_lg_dirty_mult_set(tsdn_t *tsdn, arena_t *arena,
+    ssize_t lg_dirty_mult);
+ssize_t	arena_decay_time_get(tsdn_t *tsdn, arena_t *arena);
+bool	arena_decay_time_set(tsdn_t *tsdn, arena_t *arena, ssize_t decay_time);
+void	arena_purge(tsdn_t *tsdn, arena_t *arena, bool all);
+void	arena_maybe_purge(tsdn_t *tsdn, arena_t *arena);
+void	arena_reset(tsd_t *tsd, arena_t *arena);
+void	arena_tcache_fill_small(tsdn_t *tsdn, arena_t *arena,
+    tcache_bin_t *tbin, szind_t binind, uint64_t prof_accumbytes);
 void	arena_alloc_junk_small(void *ptr, arena_bin_info_t *bin_info,
     bool zero);
 #ifdef JEMALLOC_JET
 typedef void (arena_redzone_corruption_t)(void *, size_t, bool, size_t,
     uint8_t);
 extern arena_redzone_corruption_t *arena_redzone_corruption;
 typedef void (arena_dalloc_junk_small_t)(void *, arena_bin_info_t *);
 extern arena_dalloc_junk_small_t *arena_dalloc_junk_small;
 #else
 void	arena_dalloc_junk_small(void *ptr, arena_bin_info_t *bin_info);
 #endif
 void	arena_quarantine_junk_small(void *ptr, size_t usize);
-void	*arena_malloc_small(arena_t *arena, size_t size, bool zero);
-void	*arena_malloc_large(arena_t *arena, size_t size, bool zero);
-void	*arena_palloc(tsd_t *tsd, arena_t *arena, size_t usize,
+void	*arena_malloc_large(tsdn_t *tsdn, arena_t *arena, szind_t ind,
+    bool zero);
+void	*arena_malloc_hard(tsdn_t *tsdn, arena_t *arena, size_t size,
+    szind_t ind, bool zero);
+void	*arena_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize,
     size_t alignment, bool zero, tcache_t *tcache);
-void	arena_prof_promoted(const void *ptr, size_t size);
-void	arena_dalloc_bin_junked_locked(arena_t *arena, arena_chunk_t *chunk,
-    void *ptr, arena_chunk_map_bits_t *bitselm);
-void	arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    size_t pageind, arena_chunk_map_bits_t *bitselm);
-void	arena_dalloc_small(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    size_t pageind);
+void	arena_prof_promoted(tsdn_t *tsdn, const void *ptr, size_t size);
+void	arena_dalloc_bin_junked_locked(tsdn_t *tsdn, arena_t *arena,
+    arena_chunk_t *chunk, void *ptr, arena_chunk_map_bits_t *bitselm);
+void	arena_dalloc_bin(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, size_t pageind, arena_chunk_map_bits_t *bitselm);
+void	arena_dalloc_small(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, size_t pageind);
 #ifdef JEMALLOC_JET
 typedef void (arena_dalloc_junk_large_t)(void *, size_t);
 extern arena_dalloc_junk_large_t *arena_dalloc_junk_large;
 #else
 void	arena_dalloc_junk_large(void *ptr, size_t usize);
 #endif
-void	arena_dalloc_large_junked_locked(arena_t *arena, arena_chunk_t *chunk,
+void	arena_dalloc_large_junked_locked(tsdn_t *tsdn, arena_t *arena,
+    arena_chunk_t *chunk, void *ptr);
+void	arena_dalloc_large(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
     void *ptr);
-void	arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr);
 #ifdef JEMALLOC_JET
 typedef void (arena_ralloc_junk_large_t)(void *, size_t, size_t);
 extern arena_ralloc_junk_large_t *arena_ralloc_junk_large;
 #endif
-bool	arena_ralloc_no_move(void *ptr, size_t oldsize, size_t size,
-    size_t extra, bool zero);
+bool	arena_ralloc_no_move(tsdn_t *tsdn, void *ptr, size_t oldsize,
+    size_t size, size_t extra, bool zero);
 void	*arena_ralloc(tsd_t *tsd, arena_t *arena, void *ptr, size_t oldsize,
     size_t size, size_t alignment, bool zero, tcache_t *tcache);
-dss_prec_t	arena_dss_prec_get(arena_t *arena);
-bool	arena_dss_prec_set(arena_t *arena, dss_prec_t dss_prec);
+dss_prec_t	arena_dss_prec_get(tsdn_t *tsdn, arena_t *arena);
+bool	arena_dss_prec_set(tsdn_t *tsdn, arena_t *arena, dss_prec_t dss_prec);
 ssize_t	arena_lg_dirty_mult_default_get(void);
 bool	arena_lg_dirty_mult_default_set(ssize_t lg_dirty_mult);
-void	arena_stats_merge(arena_t *arena, const char **dss,
-    ssize_t *lg_dirty_mult, size_t *nactive, size_t *ndirty,
-    arena_stats_t *astats, malloc_bin_stats_t *bstats,
-    malloc_large_stats_t *lstats, malloc_huge_stats_t *hstats);
-arena_t	*arena_new(unsigned ind);
-bool	arena_boot(void);
-void	arena_prefork(arena_t *arena);
-void	arena_postfork_parent(arena_t *arena);
-void	arena_postfork_child(arena_t *arena);
+ssize_t	arena_decay_time_default_get(void);
+bool	arena_decay_time_default_set(ssize_t decay_time);
+void	arena_basic_stats_merge(tsdn_t *tsdn, arena_t *arena,
+    unsigned *nthreads, const char **dss, ssize_t *lg_dirty_mult,
+    ssize_t *decay_time, size_t *nactive, size_t *ndirty);
+void	arena_stats_merge(tsdn_t *tsdn, arena_t *arena, unsigned *nthreads,
+    const char **dss, ssize_t *lg_dirty_mult, ssize_t *decay_time,
+    size_t *nactive, size_t *ndirty, arena_stats_t *astats,
+    malloc_bin_stats_t *bstats, malloc_large_stats_t *lstats,
+    malloc_huge_stats_t *hstats);
+unsigned	arena_nthreads_get(arena_t *arena, bool internal);
+void	arena_nthreads_inc(arena_t *arena, bool internal);
+void	arena_nthreads_dec(arena_t *arena, bool internal);
+size_t	arena_extent_sn_next(arena_t *arena);
+arena_t	*arena_new(tsdn_t *tsdn, unsigned ind);
+void	arena_boot(void);
+void	arena_prefork0(tsdn_t *tsdn, arena_t *arena);
+void	arena_prefork1(tsdn_t *tsdn, arena_t *arena);
+void	arena_prefork2(tsdn_t *tsdn, arena_t *arena);
+void	arena_prefork3(tsdn_t *tsdn, arena_t *arena);
+void	arena_postfork_parent(tsdn_t *tsdn, arena_t *arena);
+void	arena_postfork_child(tsdn_t *tsdn, arena_t *arena);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
-arena_chunk_map_bits_t	*arena_bitselm_get(arena_chunk_t *chunk,
+arena_chunk_map_bits_t	*arena_bitselm_get_mutable(arena_chunk_t *chunk,
     size_t pageind);
-arena_chunk_map_misc_t	*arena_miscelm_get(arena_chunk_t *chunk,
+const arena_chunk_map_bits_t	*arena_bitselm_get_const(
+    const arena_chunk_t *chunk, size_t pageind);
+arena_chunk_map_misc_t	*arena_miscelm_get_mutable(arena_chunk_t *chunk,
     size_t pageind);
-size_t	arena_miscelm_to_pageind(arena_chunk_map_misc_t *miscelm);
-void	*arena_miscelm_to_rpages(arena_chunk_map_misc_t *miscelm);
+const arena_chunk_map_misc_t	*arena_miscelm_get_const(
+    const arena_chunk_t *chunk, size_t pageind);
+size_t	arena_miscelm_to_pageind(const arena_chunk_map_misc_t *miscelm);
+void	*arena_miscelm_to_rpages(const arena_chunk_map_misc_t *miscelm);
 arena_chunk_map_misc_t	*arena_rd_to_miscelm(arena_runs_dirty_link_t *rd);
 arena_chunk_map_misc_t	*arena_run_to_miscelm(arena_run_t *run);
-size_t	*arena_mapbitsp_get(arena_chunk_t *chunk, size_t pageind);
-size_t	arena_mapbitsp_read(size_t *mapbitsp);
-size_t	arena_mapbits_get(arena_chunk_t *chunk, size_t pageind);
+size_t	*arena_mapbitsp_get_mutable(arena_chunk_t *chunk, size_t pageind);
+const size_t	*arena_mapbitsp_get_const(const arena_chunk_t *chunk,
+    size_t pageind);
+size_t	arena_mapbitsp_read(const size_t *mapbitsp);
+size_t	arena_mapbits_get(const arena_chunk_t *chunk, size_t pageind);
 size_t	arena_mapbits_size_decode(size_t mapbits);
-size_t	arena_mapbits_unallocated_size_get(arena_chunk_t *chunk,
+size_t	arena_mapbits_unallocated_size_get(const arena_chunk_t *chunk,
+    size_t pageind);
+size_t	arena_mapbits_large_size_get(const arena_chunk_t *chunk,
+    size_t pageind);
+size_t	arena_mapbits_small_runind_get(const arena_chunk_t *chunk,
+    size_t pageind);
+szind_t	arena_mapbits_binind_get(const arena_chunk_t *chunk, size_t pageind);
+size_t	arena_mapbits_dirty_get(const arena_chunk_t *chunk, size_t pageind);
+size_t	arena_mapbits_unzeroed_get(const arena_chunk_t *chunk, size_t pageind);
+size_t	arena_mapbits_decommitted_get(const arena_chunk_t *chunk,
     size_t pageind);
-size_t	arena_mapbits_large_size_get(arena_chunk_t *chunk, size_t pageind);
-size_t	arena_mapbits_small_runind_get(arena_chunk_t *chunk, size_t pageind);
-szind_t	arena_mapbits_binind_get(arena_chunk_t *chunk, size_t pageind);
-size_t	arena_mapbits_dirty_get(arena_chunk_t *chunk, size_t pageind);
-size_t	arena_mapbits_unzeroed_get(arena_chunk_t *chunk, size_t pageind);
-size_t	arena_mapbits_decommitted_get(arena_chunk_t *chunk, size_t pageind);
-size_t	arena_mapbits_large_get(arena_chunk_t *chunk, size_t pageind);
-size_t	arena_mapbits_allocated_get(arena_chunk_t *chunk, size_t pageind);
+size_t	arena_mapbits_large_get(const arena_chunk_t *chunk, size_t pageind);
+size_t	arena_mapbits_allocated_get(const arena_chunk_t *chunk, size_t pageind);
 void	arena_mapbitsp_write(size_t *mapbitsp, size_t mapbits);
 size_t	arena_mapbits_size_encode(size_t size);
 void	arena_mapbits_unallocated_set(arena_chunk_t *chunk, size_t pageind,
     size_t size, size_t flags);
 void	arena_mapbits_unallocated_size_set(arena_chunk_t *chunk, size_t pageind,
     size_t size);
@@ -546,67 +673,85 @@
     size_t runind, szind_t binind, size_t flags);
 void	arena_metadata_allocated_add(arena_t *arena, size_t size);
 void	arena_metadata_allocated_sub(arena_t *arena, size_t size);
 size_t	arena_metadata_allocated_get(arena_t *arena);
 bool	arena_prof_accum_impl(arena_t *arena, uint64_t accumbytes);
 bool	arena_prof_accum_locked(arena_t *arena, uint64_t accumbytes);
-bool	arena_prof_accum(arena_t *arena, uint64_t accumbytes);
+bool	arena_prof_accum(tsdn_t *tsdn, arena_t *arena, uint64_t accumbytes);
 szind_t	arena_ptr_small_binind_get(const void *ptr, size_t mapbits);
 szind_t	arena_bin_index(arena_t *arena, arena_bin_t *bin);
-unsigned	arena_run_regind(arena_run_t *run, arena_bin_info_t *bin_info,
+size_t	arena_run_regind(arena_run_t *run, arena_bin_info_t *bin_info,
     const void *ptr);
-prof_tctx_t	*arena_prof_tctx_get(const void *ptr);
-void	arena_prof_tctx_set(const void *ptr, size_t usize, prof_tctx_t *tctx);
-void	arena_prof_tctx_reset(const void *ptr, size_t usize,
+prof_tctx_t	*arena_prof_tctx_get(tsdn_t *tsdn, const void *ptr);
+void	arena_prof_tctx_set(tsdn_t *tsdn, const void *ptr, size_t usize,
+    prof_tctx_t *tctx);
+void	arena_prof_tctx_reset(tsdn_t *tsdn, const void *ptr, size_t usize,
     const void *old_ptr, prof_tctx_t *old_tctx);
-void	*arena_malloc(tsd_t *tsd, arena_t *arena, size_t size, bool zero,
-    tcache_t *tcache);
+void	arena_decay_ticks(tsdn_t *tsdn, arena_t *arena, unsigned nticks);
+void	arena_decay_tick(tsdn_t *tsdn, arena_t *arena);
+void	*arena_malloc(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind,
+    bool zero, tcache_t *tcache, bool slow_path);
 arena_t	*arena_aalloc(const void *ptr);
-size_t	arena_salloc(const void *ptr, bool demote);
-void	arena_dalloc(tsd_t *tsd, void *ptr, tcache_t *tcache);
-void	arena_sdalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
+size_t	arena_salloc(tsdn_t *tsdn, const void *ptr, bool demote);
+void	arena_dalloc(tsdn_t *tsdn, void *ptr, tcache_t *tcache, bool slow_path);
+void	arena_sdalloc(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
+    bool slow_path);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_ARENA_C_))
 #  ifdef JEMALLOC_ARENA_INLINE_A
 JEMALLOC_ALWAYS_INLINE arena_chunk_map_bits_t *
-arena_bitselm_get(arena_chunk_t *chunk, size_t pageind)
+arena_bitselm_get_mutable(arena_chunk_t *chunk, size_t pageind)
 {
 
 	assert(pageind >= map_bias);
 	assert(pageind < chunk_npages);
 
 	return (&chunk->map_bits[pageind-map_bias]);
 }
 
+JEMALLOC_ALWAYS_INLINE const arena_chunk_map_bits_t *
+arena_bitselm_get_const(const arena_chunk_t *chunk, size_t pageind)
+{
+
+	return (arena_bitselm_get_mutable((arena_chunk_t *)chunk, pageind));
+}
+
 JEMALLOC_ALWAYS_INLINE arena_chunk_map_misc_t *
-arena_miscelm_get(arena_chunk_t *chunk, size_t pageind)
+arena_miscelm_get_mutable(arena_chunk_t *chunk, size_t pageind)
 {
 
 	assert(pageind >= map_bias);
 	assert(pageind < chunk_npages);
 
 	return ((arena_chunk_map_misc_t *)((uintptr_t)chunk +
 	    (uintptr_t)map_misc_offset) + pageind-map_bias);
 }
 
+JEMALLOC_ALWAYS_INLINE const arena_chunk_map_misc_t *
+arena_miscelm_get_const(const arena_chunk_t *chunk, size_t pageind)
+{
+
+	return (arena_miscelm_get_mutable((arena_chunk_t *)chunk, pageind));
+}
+
 JEMALLOC_ALWAYS_INLINE size_t
-arena_miscelm_to_pageind(arena_chunk_map_misc_t *miscelm)
+arena_miscelm_to_pageind(const arena_chunk_map_misc_t *miscelm)
 {
 	arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(miscelm);
 	size_t pageind = ((uintptr_t)miscelm - ((uintptr_t)chunk +
 	    map_misc_offset)) / sizeof(arena_chunk_map_misc_t) + map_bias;
 
 	assert(pageind >= map_bias);
 	assert(pageind < chunk_npages);
 
 	return (pageind);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-arena_miscelm_to_rpages(arena_chunk_map_misc_t *miscelm)
+arena_miscelm_to_rpages(const arena_chunk_map_misc_t *miscelm)
 {
 	arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(miscelm);
 	size_t pageind = arena_miscelm_to_pageind(miscelm);
 
 	return ((void *)((uintptr_t)chunk + (pageind << LG_PAGE)));
 }
@@ -633,30 +778,37 @@
 	assert(arena_miscelm_to_pageind(miscelm) < chunk_npages);
 
 	return (miscelm);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t *
-arena_mapbitsp_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbitsp_get_mutable(arena_chunk_t *chunk, size_t pageind)
 {
 
-	return (&arena_bitselm_get(chunk, pageind)->bits);
+	return (&arena_bitselm_get_mutable(chunk, pageind)->bits);
+}
+
+JEMALLOC_ALWAYS_INLINE const size_t *
+arena_mapbitsp_get_const(const arena_chunk_t *chunk, size_t pageind)
+{
+
+	return (arena_mapbitsp_get_mutable((arena_chunk_t *)chunk, pageind));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbitsp_read(size_t *mapbitsp)
+arena_mapbitsp_read(const size_t *mapbitsp)
 {
 
 	return (*mapbitsp);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbits_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_get(const arena_chunk_t *chunk, size_t pageind)
 {
 
-	return (arena_mapbitsp_read(arena_mapbitsp_get(chunk, pageind)));
+	return (arena_mapbitsp_read(arena_mapbitsp_get_const(chunk, pageind)));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 arena_mapbits_size_decode(size_t mapbits)
 {
 	size_t size;
@@ -670,99 +822,99 @@
 #endif
 
 	return (size);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbits_unallocated_size_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_unallocated_size_get(const arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	assert((mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) == 0);
 	return (arena_mapbits_size_decode(mapbits));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbits_large_size_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_large_size_get(const arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	assert((mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) ==
 	    (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED));
 	return (arena_mapbits_size_decode(mapbits));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbits_small_runind_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_small_runind_get(const arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	assert((mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) ==
 	    CHUNK_MAP_ALLOCATED);
 	return (mapbits >> CHUNK_MAP_RUNIND_SHIFT);
 }
 
 JEMALLOC_ALWAYS_INLINE szind_t
-arena_mapbits_binind_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_binind_get(const arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 	szind_t binind;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	binind = (mapbits & CHUNK_MAP_BININD_MASK) >> CHUNK_MAP_BININD_SHIFT;
 	assert(binind < NBINS || binind == BININD_INVALID);
 	return (binind);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbits_dirty_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_dirty_get(const arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	assert((mapbits & CHUNK_MAP_DECOMMITTED) == 0 || (mapbits &
 	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
 	return (mapbits & CHUNK_MAP_DIRTY);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbits_unzeroed_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_unzeroed_get(const arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	assert((mapbits & CHUNK_MAP_DECOMMITTED) == 0 || (mapbits &
 	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
 	return (mapbits & CHUNK_MAP_UNZEROED);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbits_decommitted_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_decommitted_get(const arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	assert((mapbits & CHUNK_MAP_DECOMMITTED) == 0 || (mapbits &
 	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
 	return (mapbits & CHUNK_MAP_DECOMMITTED);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbits_large_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_large_get(const arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	return (mapbits & CHUNK_MAP_LARGE);
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-arena_mapbits_allocated_get(arena_chunk_t *chunk, size_t pageind)
+arena_mapbits_allocated_get(const arena_chunk_t *chunk, size_t pageind)
 {
 	size_t mapbits;
 
 	mapbits = arena_mapbits_get(chunk, pageind);
 	return (mapbits & CHUNK_MAP_ALLOCATED);
 }
@@ -792,13 +944,13 @@
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_unallocated_set(arena_chunk_t *chunk, size_t pageind, size_t size,
     size_t flags)
 {
-	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
+	size_t *mapbitsp = arena_mapbitsp_get_mutable(chunk, pageind);
 
 	assert((size & PAGE_MASK) == 0);
 	assert((flags & CHUNK_MAP_FLAGS_MASK) == flags);
 	assert((flags & CHUNK_MAP_DECOMMITTED) == 0 || (flags &
 	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
 	arena_mapbitsp_write(mapbitsp, arena_mapbits_size_encode(size) |
@@ -806,35 +958,35 @@
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_unallocated_size_set(arena_chunk_t *chunk, size_t pageind,
     size_t size)
 {
-	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
+	size_t *mapbitsp = arena_mapbitsp_get_mutable(chunk, pageind);
 	size_t mapbits = arena_mapbitsp_read(mapbitsp);
 
 	assert((size & PAGE_MASK) == 0);
 	assert((mapbits & (CHUNK_MAP_LARGE|CHUNK_MAP_ALLOCATED)) == 0);
 	arena_mapbitsp_write(mapbitsp, arena_mapbits_size_encode(size) |
 	    (mapbits & ~CHUNK_MAP_SIZE_MASK));
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_internal_set(arena_chunk_t *chunk, size_t pageind, size_t flags)
 {
-	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
+	size_t *mapbitsp = arena_mapbitsp_get_mutable(chunk, pageind);
 
 	assert((flags & CHUNK_MAP_UNZEROED) == flags);
 	arena_mapbitsp_write(mapbitsp, flags);
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_large_set(arena_chunk_t *chunk, size_t pageind, size_t size,
     size_t flags)
 {
-	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
+	size_t *mapbitsp = arena_mapbitsp_get_mutable(chunk, pageind);
 
 	assert((size & PAGE_MASK) == 0);
 	assert((flags & CHUNK_MAP_FLAGS_MASK) == flags);
 	assert((flags & CHUNK_MAP_DECOMMITTED) == 0 || (flags &
 	    (CHUNK_MAP_DIRTY|CHUNK_MAP_UNZEROED)) == 0);
 	arena_mapbitsp_write(mapbitsp, arena_mapbits_size_encode(size) |
@@ -843,13 +995,13 @@
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_large_binind_set(arena_chunk_t *chunk, size_t pageind,
     szind_t binind)
 {
-	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
+	size_t *mapbitsp = arena_mapbitsp_get_mutable(chunk, pageind);
 	size_t mapbits = arena_mapbitsp_read(mapbitsp);
 
 	assert(binind <= BININD_INVALID);
 	assert(arena_mapbits_large_size_get(chunk, pageind) == LARGE_MINCLASS +
 	    large_pad);
 	arena_mapbitsp_write(mapbitsp, (mapbits & ~CHUNK_MAP_BININD_MASK) |
@@ -857,13 +1009,13 @@
 }
 
 JEMALLOC_ALWAYS_INLINE void
 arena_mapbits_small_set(arena_chunk_t *chunk, size_t pageind, size_t runind,
     szind_t binind, size_t flags)
 {
-	size_t *mapbitsp = arena_mapbitsp_get(chunk, pageind);
+	size_t *mapbitsp = arena_mapbitsp_get_mutable(chunk, pageind);
 
 	assert(binind < BININD_INVALID);
 	assert(pageind - runind >= map_bias);
 	assert((flags & CHUNK_MAP_UNZEROED) == flags);
 	arena_mapbitsp_write(mapbitsp, (runind << CHUNK_MAP_RUNIND_SHIFT) |
 	    (binind << CHUNK_MAP_BININD_SHIFT) | flags | CHUNK_MAP_ALLOCATED);
@@ -914,26 +1066,26 @@
 	if (likely(prof_interval == 0))
 		return (false);
 	return (arena_prof_accum_impl(arena, accumbytes));
 }
 
 JEMALLOC_INLINE bool
-arena_prof_accum(arena_t *arena, uint64_t accumbytes)
+arena_prof_accum(tsdn_t *tsdn, arena_t *arena, uint64_t accumbytes)
 {
 
 	cassert(config_prof);
 
 	if (likely(prof_interval == 0))
 		return (false);
 
 	{
 		bool ret;
 
-		malloc_mutex_lock(&arena->lock);
+		malloc_mutex_lock(tsdn, &arena->lock);
 		ret = arena_prof_accum_impl(arena, accumbytes);
-		malloc_mutex_unlock(&arena->lock);
+		malloc_mutex_unlock(tsdn, &arena->lock);
 		return (ret);
 	}
 }
 
 JEMALLOC_ALWAYS_INLINE szind_t
 arena_ptr_small_binind_get(const void *ptr, size_t mapbits)
@@ -945,35 +1097,35 @@
 	if (config_debug) {
 		arena_chunk_t *chunk;
 		arena_t *arena;
 		size_t pageind;
 		size_t actual_mapbits;
 		size_t rpages_ind;
-		arena_run_t *run;
+		const arena_run_t *run;
 		arena_bin_t *bin;
 		szind_t run_binind, actual_binind;
 		arena_bin_info_t *bin_info;
-		arena_chunk_map_misc_t *miscelm;
-		void *rpages;
+		const arena_chunk_map_misc_t *miscelm;
+		const void *rpages;
 
 		assert(binind != BININD_INVALID);
 		assert(binind < NBINS);
 		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 		arena = extent_node_arena_get(&chunk->node);
 		pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 		actual_mapbits = arena_mapbits_get(chunk, pageind);
 		assert(mapbits == actual_mapbits);
 		assert(arena_mapbits_large_get(chunk, pageind) == 0);
 		assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
 		rpages_ind = pageind - arena_mapbits_small_runind_get(chunk,
 		    pageind);
-		miscelm = arena_miscelm_get(chunk, rpages_ind);
+		miscelm = arena_miscelm_get_const(chunk, rpages_ind);
 		run = &miscelm->run;
 		run_binind = run->binind;
 		bin = &arena->bins[run_binind];
-		actual_binind = bin - arena->bins;
+		actual_binind = (szind_t)(bin - arena->bins);
 		assert(run_binind == actual_binind);
 		bin_info = &arena_bin_info[actual_binind];
 		rpages = arena_miscelm_to_rpages(miscelm);
 		assert(((uintptr_t)ptr - ((uintptr_t)rpages +
 		    (uintptr_t)bin_info->reg0_offset)) % bin_info->reg_interval
 		    == 0);
@@ -984,22 +1136,21 @@
 #  endif /* JEMALLOC_ARENA_INLINE_A */
 
 #  ifdef JEMALLOC_ARENA_INLINE_B
 JEMALLOC_INLINE szind_t
 arena_bin_index(arena_t *arena, arena_bin_t *bin)
 {
-	szind_t binind = bin - arena->bins;
+	szind_t binind = (szind_t)(bin - arena->bins);
 	assert(binind < NBINS);
 	return (binind);
 }
 
-JEMALLOC_INLINE unsigned
+JEMALLOC_INLINE size_t
 arena_run_regind(arena_run_t *run, arena_bin_info_t *bin_info, const void *ptr)
 {
-	unsigned shift, diff, regind;
-	size_t interval;
+	size_t diff, interval, shift, regind;
 	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
 	void *rpages = arena_miscelm_to_rpages(miscelm);
 
 	/*
 	 * Freeing a pointer lower than region zero can cause assertion
 	 * failure.
@@ -1008,18 +1159,18 @@
 	    (uintptr_t)bin_info->reg0_offset);
 
 	/*
 	 * Avoid doing division with a variable divisor if possible.  Using
 	 * actual division here can reduce allocator throughput by over 20%!
 	 */
-	diff = (unsigned)((uintptr_t)ptr - (uintptr_t)rpages -
+	diff = (size_t)((uintptr_t)ptr - (uintptr_t)rpages -
 	    bin_info->reg0_offset);
 
 	/* Rescale (factor powers of 2 out of the numerator and denominator). */
 	interval = bin_info->reg_interval;
-	shift = jemalloc_ffs(interval) - 1;
+	shift = ffs_zu(interval) - 1;
 	diff >>= shift;
 	interval >>= shift;
 
 	if (interval == 1) {
 		/* The divisor was a power of 2. */
 		regind = diff;
@@ -1035,27 +1186,27 @@
 		 *   (X * interval_invs[D - 3]) >> SIZE_INV_SHIFT
 		 *
 		 * We can omit the first three elements, because we never
 		 * divide by 0, and 1 and 2 are both powers of two, which are
 		 * handled above.
 		 */
-#define	SIZE_INV_SHIFT	((sizeof(unsigned) << 3) - LG_RUN_MAXREGS)
-#define	SIZE_INV(s)	(((1U << SIZE_INV_SHIFT) / (s)) + 1)
-		static const unsigned interval_invs[] = {
+#define	SIZE_INV_SHIFT	((sizeof(size_t) << 3) - LG_RUN_MAXREGS)
+#define	SIZE_INV(s)	(((ZU(1) << SIZE_INV_SHIFT) / (s)) + 1)
+		static const size_t interval_invs[] = {
 		    SIZE_INV(3),
 		    SIZE_INV(4), SIZE_INV(5), SIZE_INV(6), SIZE_INV(7),
 		    SIZE_INV(8), SIZE_INV(9), SIZE_INV(10), SIZE_INV(11),
 		    SIZE_INV(12), SIZE_INV(13), SIZE_INV(14), SIZE_INV(15),
 		    SIZE_INV(16), SIZE_INV(17), SIZE_INV(18), SIZE_INV(19),
 		    SIZE_INV(20), SIZE_INV(21), SIZE_INV(22), SIZE_INV(23),
 		    SIZE_INV(24), SIZE_INV(25), SIZE_INV(26), SIZE_INV(27),
 		    SIZE_INV(28), SIZE_INV(29), SIZE_INV(30), SIZE_INV(31)
 		};
 
-		if (likely(interval <= ((sizeof(interval_invs) /
-		    sizeof(unsigned)) + 2))) {
+		if (likely(interval <= ((sizeof(interval_invs) / sizeof(size_t))
+		    + 2))) {
 			regind = (diff * interval_invs[interval - 3]) >>
 			    SIZE_INV_SHIFT;
 		} else
 			regind = diff / interval;
 #undef SIZE_INV
 #undef SIZE_INV_SHIFT
@@ -1064,13 +1215,13 @@
 	assert(regind < bin_info->nregs);
 
 	return (regind);
 }
 
 JEMALLOC_INLINE prof_tctx_t *
-arena_prof_tctx_get(const void *ptr)
+arena_prof_tctx_get(tsdn_t *tsdn, const void *ptr)
 {
 	prof_tctx_t *ret;
 	arena_chunk_t *chunk;
 
 	cassert(config_prof);
 	assert(ptr != NULL);
@@ -1080,24 +1231,25 @@
 		size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 		size_t mapbits = arena_mapbits_get(chunk, pageind);
 		assert((mapbits & CHUNK_MAP_ALLOCATED) != 0);
 		if (likely((mapbits & CHUNK_MAP_LARGE) == 0))
 			ret = (prof_tctx_t *)(uintptr_t)1U;
 		else {
-			arena_chunk_map_misc_t *elm = arena_miscelm_get(chunk,
-			    pageind);
+			arena_chunk_map_misc_t *elm =
+			    arena_miscelm_get_mutable(chunk, pageind);
 			ret = atomic_read_p(&elm->prof_tctx_pun);
 		}
 	} else
-		ret = huge_prof_tctx_get(ptr);
+		ret = huge_prof_tctx_get(tsdn, ptr);
 
 	return (ret);
 }
 
 JEMALLOC_INLINE void
-arena_prof_tctx_set(const void *ptr, size_t usize, prof_tctx_t *tctx)
+arena_prof_tctx_set(tsdn_t *tsdn, const void *ptr, size_t usize,
+    prof_tctx_t *tctx)
 {
 	arena_chunk_t *chunk;
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 
@@ -1110,30 +1262,30 @@
 		if (unlikely(usize > SMALL_MAXCLASS || (uintptr_t)tctx >
 		    (uintptr_t)1U)) {
 			arena_chunk_map_misc_t *elm;
 
 			assert(arena_mapbits_large_get(chunk, pageind) != 0);
 
-			elm = arena_miscelm_get(chunk, pageind);
+			elm = arena_miscelm_get_mutable(chunk, pageind);
 			atomic_write_p(&elm->prof_tctx_pun, tctx);
 		} else {
 			/*
 			 * tctx must always be initialized for large runs.
 			 * Assert that the surrounding conditional logic is
 			 * equivalent to checking whether ptr refers to a large
 			 * run.
 			 */
 			assert(arena_mapbits_large_get(chunk, pageind) == 0);
 		}
 	} else
-		huge_prof_tctx_set(ptr, tctx);
+		huge_prof_tctx_set(tsdn, ptr, tctx);
 }
 
 JEMALLOC_INLINE void
-arena_prof_tctx_reset(const void *ptr, size_t usize, const void *old_ptr,
-    prof_tctx_t *old_tctx)
+arena_prof_tctx_reset(tsdn_t *tsdn, const void *ptr, size_t usize,
+    const void *old_ptr, prof_tctx_t *old_tctx)
 {
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 
 	if (unlikely(usize > SMALL_MAXCLASS || (ptr == old_ptr &&
@@ -1146,49 +1298,65 @@
 			pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >>
 			    LG_PAGE;
 			assert(arena_mapbits_allocated_get(chunk, pageind) !=
 			    0);
 			assert(arena_mapbits_large_get(chunk, pageind) != 0);
 
-			elm = arena_miscelm_get(chunk, pageind);
+			elm = arena_miscelm_get_mutable(chunk, pageind);
 			atomic_write_p(&elm->prof_tctx_pun,
 			    (prof_tctx_t *)(uintptr_t)1U);
 		} else
-			huge_prof_tctx_reset(ptr);
+			huge_prof_tctx_reset(tsdn, ptr);
 	}
 }
 
+JEMALLOC_ALWAYS_INLINE void
+arena_decay_ticks(tsdn_t *tsdn, arena_t *arena, unsigned nticks)
+{
+	tsd_t *tsd;
+	ticker_t *decay_ticker;
+
+	if (unlikely(tsdn_null(tsdn)))
+		return;
+	tsd = tsdn_tsd(tsdn);
+	decay_ticker = decay_ticker_get(tsd, arena->ind);
+	if (unlikely(decay_ticker == NULL))
+		return;
+	if (unlikely(ticker_ticks(decay_ticker, nticks)))
+		arena_purge(tsdn, arena, false);
+}
+
+JEMALLOC_ALWAYS_INLINE void
+arena_decay_tick(tsdn_t *tsdn, arena_t *arena)
+{
+
+	arena_decay_ticks(tsdn, arena, 1);
+}
+
 JEMALLOC_ALWAYS_INLINE void *
-arena_malloc(tsd_t *tsd, arena_t *arena, size_t size, bool zero,
-    tcache_t *tcache)
+arena_malloc(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind, bool zero,
+    tcache_t *tcache, bool slow_path)
 {
 
+	assert(!tsdn_null(tsdn) || tcache == NULL);
 	assert(size != 0);
 
-	arena = arena_choose(tsd, arena);
-	if (unlikely(arena == NULL))
-		return (NULL);
-
-	if (likely(size <= SMALL_MAXCLASS)) {
-		if (likely(tcache != NULL)) {
-			return (tcache_alloc_small(tsd, arena, tcache, size,
-			    zero));
-		} else
-			return (arena_malloc_small(arena, size, zero));
-	} else if (likely(size <= large_maxclass)) {
-		/*
-		 * Initialize tcache after checking size in order to avoid
-		 * infinite recursion during tcache initialization.
-		 */
-		if (likely(tcache != NULL) && size <= tcache_maxclass) {
-			return (tcache_alloc_large(tsd, arena, tcache, size,
-			    zero));
-		} else
-			return (arena_malloc_large(arena, size, zero));
-	} else
-		return (huge_malloc(tsd, arena, size, zero, tcache));
+	if (likely(tcache != NULL)) {
+		if (likely(size <= SMALL_MAXCLASS)) {
+			return (tcache_alloc_small(tsdn_tsd(tsdn), arena,
+			    tcache, size, ind, zero, slow_path));
+		}
+		if (likely(size <= tcache_maxclass)) {
+			return (tcache_alloc_large(tsdn_tsd(tsdn), arena,
+			    tcache, size, ind, zero, slow_path));
+		}
+		/* (size > tcache_maxclass) case falls through. */
+		assert(size > tcache_maxclass);
+	}
+
+	return (arena_malloc_hard(tsdn, arena, size, ind, zero));
 }
 
 JEMALLOC_ALWAYS_INLINE arena_t *
 arena_aalloc(const void *ptr)
 {
 	arena_chunk_t *chunk;
@@ -1199,13 +1367,13 @@
 	else
 		return (huge_aalloc(ptr));
 }
 
 /* Return the size of the allocation pointed to by ptr. */
 JEMALLOC_ALWAYS_INLINE size_t
-arena_salloc(const void *ptr, bool demote)
+arena_salloc(tsdn_t *tsdn, const void *ptr, bool demote)
 {
 	size_t ret;
 	arena_chunk_t *chunk;
 	size_t pageind;
 	szind_t binind;
 
@@ -1242,106 +1410,118 @@
 			assert(arena_mapbits_large_get(chunk, pageind) != 0 ||
 			    arena_ptr_small_binind_get(ptr,
 			    arena_mapbits_get(chunk, pageind)) == binind);
 			ret = index2size(binind);
 		}
 	} else
-		ret = huge_salloc(ptr);
+		ret = huge_salloc(tsdn, ptr);
 
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-arena_dalloc(tsd_t *tsd, void *ptr, tcache_t *tcache)
+arena_dalloc(tsdn_t *tsdn, void *ptr, tcache_t *tcache, bool slow_path)
 {
 	arena_chunk_t *chunk;
 	size_t pageind, mapbits;
 
+	assert(!tsdn_null(tsdn) || tcache == NULL);
 	assert(ptr != NULL);
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 	if (likely(chunk != ptr)) {
 		pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 		mapbits = arena_mapbits_get(chunk, pageind);
 		assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
 		if (likely((mapbits & CHUNK_MAP_LARGE) == 0)) {
 			/* Small allocation. */
 			if (likely(tcache != NULL)) {
 				szind_t binind = arena_ptr_small_binind_get(ptr,
 				    mapbits);
-				tcache_dalloc_small(tsd, tcache, ptr, binind);
+				tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr,
+				    binind, slow_path);
 			} else {
-				arena_dalloc_small(extent_node_arena_get(
-				    &chunk->node), chunk, ptr, pageind);
+				arena_dalloc_small(tsdn,
+				    extent_node_arena_get(&chunk->node), chunk,
+				    ptr, pageind);
 			}
 		} else {
 			size_t size = arena_mapbits_large_size_get(chunk,
 			    pageind);
 
 			assert(config_cache_oblivious || ((uintptr_t)ptr &
 			    PAGE_MASK) == 0);
 
 			if (likely(tcache != NULL) && size - large_pad <=
 			    tcache_maxclass) {
-				tcache_dalloc_large(tsd, tcache, ptr, size -
-				    large_pad);
+				tcache_dalloc_large(tsdn_tsd(tsdn), tcache, ptr,
+				    size - large_pad, slow_path);
 			} else {
-				arena_dalloc_large(extent_node_arena_get(
-				    &chunk->node), chunk, ptr);
+				arena_dalloc_large(tsdn,
+				    extent_node_arena_get(&chunk->node), chunk,
+				    ptr);
 			}
 		}
 	} else
-		huge_dalloc(tsd, ptr, tcache);
+		huge_dalloc(tsdn, ptr);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-arena_sdalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
+arena_sdalloc(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
+    bool slow_path)
 {
 	arena_chunk_t *chunk;
 
+	assert(!tsdn_null(tsdn) || tcache == NULL);
+
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 	if (likely(chunk != ptr)) {
 		if (config_prof && opt_prof) {
 			size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >>
 			    LG_PAGE;
-			assert(arena_mapbits_allocated_get(chunk, pageind) != 0);
+			assert(arena_mapbits_allocated_get(chunk, pageind) !=
+			    0);
 			if (arena_mapbits_large_get(chunk, pageind) != 0) {
 				/*
 				 * Make sure to use promoted size, not request
 				 * size.
 				 */
 				size = arena_mapbits_large_size_get(chunk,
 				    pageind) - large_pad;
 			}
 		}
-		assert(s2u(size) == s2u(arena_salloc(ptr, false)));
+		assert(s2u(size) == s2u(arena_salloc(tsdn, ptr, false)));
 
 		if (likely(size <= SMALL_MAXCLASS)) {
 			/* Small allocation. */
 			if (likely(tcache != NULL)) {
 				szind_t binind = size2index(size);
-				tcache_dalloc_small(tsd, tcache, ptr, binind);
+				tcache_dalloc_small(tsdn_tsd(tsdn), tcache, ptr,
+				    binind, slow_path);
 			} else {
 				size_t pageind = ((uintptr_t)ptr -
 				    (uintptr_t)chunk) >> LG_PAGE;
-				arena_dalloc_small(extent_node_arena_get(
-				    &chunk->node), chunk, ptr, pageind);
+				arena_dalloc_small(tsdn,
+				    extent_node_arena_get(&chunk->node), chunk,
+				    ptr, pageind);
 			}
 		} else {
 			assert(config_cache_oblivious || ((uintptr_t)ptr &
 			    PAGE_MASK) == 0);
 
-			if (likely(tcache != NULL) && size <= tcache_maxclass)
-				tcache_dalloc_large(tsd, tcache, ptr, size);
-			else {
-				arena_dalloc_large(extent_node_arena_get(
-				    &chunk->node), chunk, ptr);
+			if (likely(tcache != NULL) && size <= tcache_maxclass) {
+				tcache_dalloc_large(tsdn_tsd(tsdn), tcache, ptr,
+				    size, slow_path);
+			} else {
+				arena_dalloc_large(tsdn,
+				    extent_node_arena_get(&chunk->node), chunk,
+				    ptr);
 			}
 		}
 	} else
-		huge_dalloc(tsd, ptr, tcache);
+		huge_dalloc(tsdn, ptr);
 }
 #  endif /* JEMALLOC_ARENA_INLINE_B */
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal: assert.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/atomic.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/atomic.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/atomic.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/atomic.h	2017-01-31 23:32:23.000000000 +0800
@@ -25,14 +25,14 @@
  * which case the following functions must redundantly compute the result so
  * that it can be returned.  These functions are normally inlined, so the extra
  * operations can be optimized away if the return values aren't used by the
  * callers.
  *
  *   <t> atomic_read_<t>(<t> *p) { return (*p); }
- *   <t> atomic_add_<t>(<t> *p, <t> x) { return (*p + x); }
- *   <t> atomic_sub_<t>(<t> *p, <t> x) { return (*p - x); }
+ *   <t> atomic_add_<t>(<t> *p, <t> x) { return (*p += x); }
+ *   <t> atomic_sub_<t>(<t> *p, <t> x) { return (*p -= x); }
  *   bool atomic_cas_<t>(<t> *p, <t> c, <t> s)
  *   {
  *     if (*p != c)
  *       return (true);
  *     *p = s;
  *     return (false);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/base.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/base.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/base.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/base.h	2017-01-31 23:32:23.000000000 +0800
@@ -6,18 +6,19 @@
 #ifdef JEMALLOC_H_STRUCTS
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-void	*base_alloc(size_t size);
-void	base_stats_get(size_t *allocated, size_t *resident, size_t *mapped);
+void	*base_alloc(tsdn_t *tsdn, size_t size);
+void	base_stats_get(tsdn_t *tsdn, size_t *allocated, size_t *resident,
+    size_t *mapped);
 bool	base_boot(void);
-void	base_prefork(void);
-void	base_postfork_parent(void);
-void	base_postfork_child(void);
+void	base_prefork(tsdn_t *tsdn);
+void	base_postfork_parent(tsdn_t *tsdn);
+void	base_postfork_child(tsdn_t *tsdn);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #endif /* JEMALLOC_H_INLINES */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/bitmap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/bitmap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/bitmap.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/bitmap.h	2017-01-31 23:32:23.000000000 +0800
@@ -12,12 +12,21 @@
 
 /* Number of bits per group. */
 #define	LG_BITMAP_GROUP_NBITS		(LG_SIZEOF_BITMAP + 3)
 #define	BITMAP_GROUP_NBITS		(ZU(1) << LG_BITMAP_GROUP_NBITS)
 #define	BITMAP_GROUP_NBITS_MASK		(BITMAP_GROUP_NBITS-1)
 
+/*
+ * Do some analysis on how big the bitmap is before we use a tree.  For a brute
+ * force linear search, if we would have to call ffs_lu() more than 2^3 times,
+ * use a tree instead.
+ */
+#if LG_BITMAP_MAXBITS - LG_BITMAP_GROUP_NBITS > 3
+#  define USE_TREE
+#endif
+
 /* Number of groups required to store a given number of bits. */
 #define	BITMAP_BITS2GROUPS(nbits)					\
     ((nbits + BITMAP_GROUP_NBITS_MASK) >> LG_BITMAP_GROUP_NBITS)
 
 /*
  * Number of groups required at a particular level for a given number of bits.
@@ -45,12 +54,14 @@
 #define	BITMAP_GROUPS_4_LEVEL(nbits)					\
     (BITMAP_GROUPS_3_LEVEL(nbits) + BITMAP_GROUPS_L3(nbits))
 
 /*
  * Maximum number of groups required to support LG_BITMAP_MAXBITS.
  */
+#ifdef USE_TREE
+
 #if LG_BITMAP_MAXBITS <= LG_BITMAP_GROUP_NBITS
 #  define BITMAP_GROUPS_MAX	BITMAP_GROUPS_1_LEVEL(BITMAP_MAXBITS)
 #elif LG_BITMAP_MAXBITS <= LG_BITMAP_GROUP_NBITS * 2
 #  define BITMAP_GROUPS_MAX	BITMAP_GROUPS_2_LEVEL(BITMAP_MAXBITS)
 #elif LG_BITMAP_MAXBITS <= LG_BITMAP_GROUP_NBITS * 3
 #  define BITMAP_GROUPS_MAX	BITMAP_GROUPS_3_LEVEL(BITMAP_MAXBITS)
@@ -62,12 +73,18 @@
 
 /* Maximum number of levels possible. */
 #define	BITMAP_MAX_LEVELS						\
     (LG_BITMAP_MAXBITS / LG_SIZEOF_BITMAP)				\
     + !!(LG_BITMAP_MAXBITS % LG_SIZEOF_BITMAP)
 
+#else /* USE_TREE */
+
+#define	BITMAP_GROUPS_MAX BITMAP_BITS2GROUPS(BITMAP_MAXBITS)
+
+#endif /* USE_TREE */
+
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
 
 struct bitmap_level_s {
 	/* Offset of this level's groups within the array of groups. */
@@ -75,30 +92,34 @@
 };
 
 struct bitmap_info_s {
 	/* Logical number of bits in bitmap (stored at bottom level). */
 	size_t nbits;
 
+#ifdef USE_TREE
 	/* Number of levels necessary for nbits. */
 	unsigned nlevels;
 
 	/*
 	 * Only the first (nlevels+1) elements are used, and levels are ordered
 	 * bottom to top (e.g. the bottom level is stored in levels[0]).
 	 */
 	bitmap_level_t levels[BITMAP_MAX_LEVELS+1];
+#else /* USE_TREE */
+	/* Number of groups necessary for nbits. */
+	size_t ngroups;
+#endif /* USE_TREE */
 };
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 void	bitmap_info_init(bitmap_info_t *binfo, size_t nbits);
-size_t	bitmap_info_ngroups(const bitmap_info_t *binfo);
-size_t	bitmap_size(size_t nbits);
 void	bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo);
+size_t	bitmap_size(const bitmap_info_t *binfo);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
@@ -110,28 +131,38 @@
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_BITMAP_C_))
 JEMALLOC_INLINE bool
 bitmap_full(bitmap_t *bitmap, const bitmap_info_t *binfo)
 {
-	unsigned rgoff = binfo->levels[binfo->nlevels].group_offset - 1;
+#ifdef USE_TREE
+	size_t rgoff = binfo->levels[binfo->nlevels].group_offset - 1;
 	bitmap_t rg = bitmap[rgoff];
 	/* The bitmap is full iff the root group is 0. */
 	return (rg == 0);
+#else
+	size_t i;
+
+	for (i = 0; i < binfo->ngroups; i++) {
+		if (bitmap[i] != 0)
+			return (false);
+	}
+	return (true);
+#endif
 }
 
 JEMALLOC_INLINE bool
 bitmap_get(bitmap_t *bitmap, const bitmap_info_t *binfo, size_t bit)
 {
 	size_t goff;
 	bitmap_t g;
 
 	assert(bit < binfo->nbits);
 	goff = bit >> LG_BITMAP_GROUP_NBITS;
 	g = bitmap[goff];
-	return (!(g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK))));
+	return (!(g & (ZU(1) << (bit & BITMAP_GROUP_NBITS_MASK))));
 }
 
 JEMALLOC_INLINE void
 bitmap_set(bitmap_t *bitmap, const bitmap_info_t *binfo, size_t bit)
 {
 	size_t goff;
@@ -140,91 +171,104 @@
 
 	assert(bit < binfo->nbits);
 	assert(!bitmap_get(bitmap, binfo, bit));
 	goff = bit >> LG_BITMAP_GROUP_NBITS;
 	gp = &bitmap[goff];
 	g = *gp;
-	assert(g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK)));
-	g ^= 1LU << (bit & BITMAP_GROUP_NBITS_MASK);
+	assert(g & (ZU(1) << (bit & BITMAP_GROUP_NBITS_MASK)));
+	g ^= ZU(1) << (bit & BITMAP_GROUP_NBITS_MASK);
 	*gp = g;
 	assert(bitmap_get(bitmap, binfo, bit));
+#ifdef USE_TREE
 	/* Propagate group state transitions up the tree. */
 	if (g == 0) {
 		unsigned i;
 		for (i = 1; i < binfo->nlevels; i++) {
 			bit = goff;
 			goff = bit >> LG_BITMAP_GROUP_NBITS;
 			gp = &bitmap[binfo->levels[i].group_offset + goff];
 			g = *gp;
-			assert(g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK)));
-			g ^= 1LU << (bit & BITMAP_GROUP_NBITS_MASK);
+			assert(g & (ZU(1) << (bit & BITMAP_GROUP_NBITS_MASK)));
+			g ^= ZU(1) << (bit & BITMAP_GROUP_NBITS_MASK);
 			*gp = g;
 			if (g != 0)
 				break;
 		}
 	}
+#endif
 }
 
 /* sfu: set first unset. */
 JEMALLOC_INLINE size_t
 bitmap_sfu(bitmap_t *bitmap, const bitmap_info_t *binfo)
 {
 	size_t bit;
 	bitmap_t g;
 	unsigned i;
 
 	assert(!bitmap_full(bitmap, binfo));
 
+#ifdef USE_TREE
 	i = binfo->nlevels - 1;
 	g = bitmap[binfo->levels[i].group_offset];
-	bit = jemalloc_ffsl(g) - 1;
+	bit = ffs_lu(g) - 1;
 	while (i > 0) {
 		i--;
 		g = bitmap[binfo->levels[i].group_offset + bit];
-		bit = (bit << LG_BITMAP_GROUP_NBITS) + (jemalloc_ffsl(g) - 1);
+		bit = (bit << LG_BITMAP_GROUP_NBITS) + (ffs_lu(g) - 1);
 	}
-
+#else
+	i = 0;
+	g = bitmap[0];
+	while ((bit = ffs_lu(g)) == 0) {
+		i++;
+		g = bitmap[i];
+	}
+	bit = (i << LG_BITMAP_GROUP_NBITS) + (bit - 1);
+#endif
 	bitmap_set(bitmap, binfo, bit);
 	return (bit);
 }
 
 JEMALLOC_INLINE void
 bitmap_unset(bitmap_t *bitmap, const bitmap_info_t *binfo, size_t bit)
 {
 	size_t goff;
 	bitmap_t *gp;
 	bitmap_t g;
-	bool propagate;
+	UNUSED bool propagate;
 
 	assert(bit < binfo->nbits);
 	assert(bitmap_get(bitmap, binfo, bit));
 	goff = bit >> LG_BITMAP_GROUP_NBITS;
 	gp = &bitmap[goff];
 	g = *gp;
 	propagate = (g == 0);
-	assert((g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK))) == 0);
-	g ^= 1LU << (bit & BITMAP_GROUP_NBITS_MASK);
+	assert((g & (ZU(1) << (bit & BITMAP_GROUP_NBITS_MASK))) == 0);
+	g ^= ZU(1) << (bit & BITMAP_GROUP_NBITS_MASK);
 	*gp = g;
 	assert(!bitmap_get(bitmap, binfo, bit));
+#ifdef USE_TREE
 	/* Propagate group state transitions up the tree. */
 	if (propagate) {
 		unsigned i;
 		for (i = 1; i < binfo->nlevels; i++) {
 			bit = goff;
 			goff = bit >> LG_BITMAP_GROUP_NBITS;
 			gp = &bitmap[binfo->levels[i].group_offset + goff];
 			g = *gp;
 			propagate = (g == 0);
-			assert((g & (1LU << (bit & BITMAP_GROUP_NBITS_MASK)))
+			assert((g & (ZU(1) << (bit & BITMAP_GROUP_NBITS_MASK)))
 			    == 0);
-			g ^= 1LU << (bit & BITMAP_GROUP_NBITS_MASK);
+			g ^= ZU(1) << (bit & BITMAP_GROUP_NBITS_MASK);
 			*gp = g;
 			if (!propagate)
 				break;
 		}
 	}
+#endif /* USE_TREE */
 }
 
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/chunk_dss.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/chunk_dss.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/chunk_dss.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/chunk_dss.h	2017-01-31 23:32:23.000000000 +0800
@@ -20,19 +20,17 @@
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 dss_prec_t	chunk_dss_prec_get(void);
 bool	chunk_dss_prec_set(dss_prec_t dss_prec);
-void	*chunk_alloc_dss(arena_t *arena, void *new_addr, size_t size,
-    size_t alignment, bool *zero, bool *commit);
+void	*chunk_alloc_dss(tsdn_t *tsdn, arena_t *arena, void *new_addr,
+    size_t size, size_t alignment, bool *zero, bool *commit);
 bool	chunk_in_dss(void *chunk);
-bool	chunk_dss_boot(void);
-void	chunk_dss_prefork(void);
-void	chunk_dss_postfork_parent(void);
-void	chunk_dss_postfork_child(void);
+bool	chunk_dss_mergeable(void *chunk_a, void *chunk_b);
+void	chunk_dss_boot(void);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #endif /* JEMALLOC_H_INLINES */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/chunk.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/chunk.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/chunk.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/chunk.h	2017-01-31 23:32:23.000000000 +0800
@@ -45,38 +45,36 @@
 extern size_t		chunksize;
 extern size_t		chunksize_mask; /* (chunksize - 1). */
 extern size_t		chunk_npages;
 
 extern const chunk_hooks_t	chunk_hooks_default;
 
-chunk_hooks_t	chunk_hooks_get(arena_t *arena);
-chunk_hooks_t	chunk_hooks_set(arena_t *arena,
+chunk_hooks_t	chunk_hooks_get(tsdn_t *tsdn, arena_t *arena);
+chunk_hooks_t	chunk_hooks_set(tsdn_t *tsdn, arena_t *arena,
     const chunk_hooks_t *chunk_hooks);
 
-bool	chunk_register(const void *chunk, const extent_node_t *node);
+bool	chunk_register(tsdn_t *tsdn, const void *chunk,
+    const extent_node_t *node);
 void	chunk_deregister(const void *chunk, const extent_node_t *node);
 void	*chunk_alloc_base(size_t size);
-void	*chunk_alloc_cache(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    void *new_addr, size_t size, size_t alignment, bool *zero,
-    bool dalloc_node);
-void	*chunk_alloc_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    void *new_addr, size_t size, size_t alignment, bool *zero, bool *commit);
-void	chunk_dalloc_cache(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    void *chunk, size_t size, bool committed);
-void	chunk_dalloc_arena(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    void *chunk, size_t size, bool zeroed, bool committed);
-void	chunk_dalloc_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    void *chunk, size_t size, bool committed);
-bool	chunk_purge_arena(arena_t *arena, void *chunk, size_t offset,
+void	*chunk_alloc_cache(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, void *new_addr, size_t size, size_t alignment,
+    size_t *sn, bool *zero, bool *commit, bool dalloc_node);
+void	*chunk_alloc_wrapper(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, void *new_addr, size_t size, size_t alignment,
+    size_t *sn, bool *zero, bool *commit);
+void	chunk_dalloc_cache(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, void *chunk, size_t size, size_t sn,
+    bool committed);
+void	chunk_dalloc_wrapper(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, void *chunk, size_t size, size_t sn,
+    bool zeroed, bool committed);
+bool	chunk_purge_wrapper(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, void *chunk, size_t size, size_t offset,
     size_t length);
-bool	chunk_purge_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    void *chunk, size_t size, size_t offset, size_t length);
 bool	chunk_boot(void);
-void	chunk_prefork(void);
-void	chunk_postfork_parent(void);
-void	chunk_postfork_child(void);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/chunk_mmap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/chunk_mmap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/chunk_mmap.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/chunk_mmap.h	2017-01-31 23:32:23.000000000 +0800
@@ -6,14 +6,14 @@
 #ifdef JEMALLOC_H_STRUCTS
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-void	*chunk_alloc_mmap(size_t size, size_t alignment, bool *zero,
-    bool *commit);
+void	*chunk_alloc_mmap(void *new_addr, size_t size, size_t alignment,
+    bool *zero, bool *commit);
 bool	chunk_dalloc_mmap(void *chunk, size_t size);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/ckh.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/ckh.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/ckh.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/ckh.h	2017-01-31 23:32:23.000000000 +0800
@@ -37,15 +37,13 @@
 	uint64_t	nshrinkfails;
 	uint64_t	ninserts;
 	uint64_t	nrelocs;
 #endif
 
 	/* Used for pseudo-random number generation. */
-#define	CKH_A		1103515241
-#define	CKH_C		12347
-	uint32_t	prng_state;
+	uint64_t	prng_state;
 
 	/* Total number of items. */
 	size_t		count;
 
 	/*
 	 * Minimum and current number of hash table buckets.  There are
@@ -71,13 +69,13 @@
 void	ckh_delete(tsd_t *tsd, ckh_t *ckh);
 size_t	ckh_count(ckh_t *ckh);
 bool	ckh_iter(ckh_t *ckh, size_t *tabind, void **key, void **data);
 bool	ckh_insert(tsd_t *tsd, ckh_t *ckh, const void *key, const void *data);
 bool	ckh_remove(tsd_t *tsd, ckh_t *ckh, const void *searchkey, void **key,
     void **data);
-bool	ckh_search(ckh_t *ckh, const void *seachkey, void **key, void **data);
+bool	ckh_search(ckh_t *ckh, const void *searchkey, void **key, void **data);
 void	ckh_string_hash(const void *key, size_t r_hash[2]);
 bool	ckh_string_keycomp(const void *k1, const void *k2);
 void	ckh_pointer_hash(const void *key, size_t r_hash[2]);
 bool	ckh_pointer_keycomp(const void *k1, const void *k2);
 
 #endif /* JEMALLOC_H_EXTERNS */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/ctl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/ctl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/ctl.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/ctl.h	2017-01-31 23:32:23.000000000 +0800
@@ -18,28 +18,33 @@
 struct ctl_named_node_s {
 	struct ctl_node_s	node;
 	const char		*name;
 	/* If (nchildren == 0), this is a terminal node. */
 	unsigned		nchildren;
 	const			ctl_node_t *children;
-	int			(*ctl)(const size_t *, size_t, void *, size_t *,
-	    void *, size_t);
+	int			(*ctl)(tsd_t *, const size_t *, size_t, void *,
+	    size_t *, void *, size_t);
 };
 
 struct ctl_indexed_node_s {
 	struct ctl_node_s	node;
-	const ctl_named_node_t	*(*index)(const size_t *, size_t, size_t);
+	const ctl_named_node_t	*(*index)(tsdn_t *, const size_t *, size_t,
+	    size_t);
 };
 
 struct ctl_arena_stats_s {
 	bool			initialized;
 	unsigned		nthreads;
 	const char		*dss;
 	ssize_t			lg_dirty_mult;
+	ssize_t			decay_time;
 	size_t			pactive;
 	size_t			pdirty;
+
+	/* The remainder are only populated if config_stats is true. */
+
 	arena_stats_t		astats;
 
 	/* Aggregate stats for small size classes, based on bin stats. */
 	size_t			allocated_small;
 	uint64_t		nmalloc_small;
 	uint64_t		ndalloc_small;
@@ -53,30 +58,32 @@
 struct ctl_stats_s {
 	size_t			allocated;
 	size_t			active;
 	size_t			metadata;
 	size_t			resident;
 	size_t			mapped;
+	size_t			retained;
 	unsigned		narenas;
 	ctl_arena_stats_t	*arenas;	/* (narenas + 1) elements. */
 };
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-int	ctl_byname(const char *name, void *oldp, size_t *oldlenp, void *newp,
-    size_t newlen);
-int	ctl_nametomib(const char *name, size_t *mibp, size_t *miblenp);
-
-int	ctl_bymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
+int	ctl_byname(tsd_t *tsd, const char *name, void *oldp, size_t *oldlenp,
     void *newp, size_t newlen);
+int	ctl_nametomib(tsdn_t *tsdn, const char *name, size_t *mibp,
+    size_t *miblenp);
+
+int	ctl_bymib(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen);
 bool	ctl_boot(void);
-void	ctl_prefork(void);
-void	ctl_postfork_parent(void);
-void	ctl_postfork_child(void);
+void	ctl_prefork(tsdn_t *tsdn);
+void	ctl_postfork_parent(tsdn_t *tsdn);
+void	ctl_postfork_child(tsdn_t *tsdn);
 
 #define	xmallctl(name, oldp, oldlenp, newp, newlen) do {		\
 	if (je_mallctl(name, oldp, oldlenp, newp, newlen)		\
 	    != 0) {							\
 		malloc_printf(						\
 		    "<jemalloc>: Failure in xmallctl(\"%s\", ...)\n",	\
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/extent.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/extent.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/extent.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/extent.h	2017-01-31 23:32:23.000000000 +0800
@@ -16,12 +16,26 @@
 	void			*en_addr;
 
 	/* Total region size. */
 	size_t			en_size;
 
 	/*
+	 * Serial number (potentially non-unique).
+	 *
+	 * In principle serial numbers can wrap around on 32-bit systems if
+	 * JEMALLOC_MUNMAP is defined, but as long as comparison functions fall
+	 * back on address comparison for equal serial numbers, stable (if
+	 * imperfect) ordering is maintained.
+	 *
+	 * Serial numbers may not be unique even in the absence of wrap-around,
+	 * e.g. when splitting an extent and assigning the same serial number to
+	 * both resulting adjacent extents.
+	 */
+	size_t			en_sn;
+
+	/*
 	 * The zeroed flag is used by chunk recycling code to track whether
 	 * memory is zero-filled.
 	 */
 	bool			en_zeroed;
 
 	/*
@@ -42,53 +56,55 @@
 
 	/* Linkage for arena's runs_dirty and chunks_cache rings. */
 	arena_runs_dirty_link_t	rd;
 	qr(extent_node_t)	cc_link;
 
 	union {
-		/* Linkage for the size/address-ordered tree. */
-		rb_node(extent_node_t)	szad_link;
+		/* Linkage for the size/sn/address-ordered tree. */
+		rb_node(extent_node_t)	szsnad_link;
 
-		/* Linkage for arena's huge and node_cache lists. */
+		/* Linkage for arena's achunks, huge, and node_cache lists. */
 		ql_elm(extent_node_t)	ql_link;
 	};
 
 	/* Linkage for the address-ordered tree. */
 	rb_node(extent_node_t)	ad_link;
 };
 typedef rb_tree(extent_node_t) extent_tree_t;
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-rb_proto(, extent_tree_szad_, extent_tree_t, extent_node_t)
+rb_proto(, extent_tree_szsnad_, extent_tree_t, extent_node_t)
 
 rb_proto(, extent_tree_ad_, extent_tree_t, extent_node_t)
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
 arena_t	*extent_node_arena_get(const extent_node_t *node);
 void	*extent_node_addr_get(const extent_node_t *node);
 size_t	extent_node_size_get(const extent_node_t *node);
+size_t	extent_node_sn_get(const extent_node_t *node);
 bool	extent_node_zeroed_get(const extent_node_t *node);
 bool	extent_node_committed_get(const extent_node_t *node);
 bool	extent_node_achunk_get(const extent_node_t *node);
 prof_tctx_t	*extent_node_prof_tctx_get(const extent_node_t *node);
 void	extent_node_arena_set(extent_node_t *node, arena_t *arena);
 void	extent_node_addr_set(extent_node_t *node, void *addr);
 void	extent_node_size_set(extent_node_t *node, size_t size);
+void	extent_node_sn_set(extent_node_t *node, size_t sn);
 void	extent_node_zeroed_set(extent_node_t *node, bool zeroed);
 void	extent_node_committed_set(extent_node_t *node, bool committed);
 void	extent_node_achunk_set(extent_node_t *node, bool achunk);
 void	extent_node_prof_tctx_set(extent_node_t *node, prof_tctx_t *tctx);
 void	extent_node_init(extent_node_t *node, arena_t *arena, void *addr,
-    size_t size, bool zeroed, bool committed);
+    size_t size, size_t sn, bool zeroed, bool committed);
 void	extent_node_dirty_linkage_init(extent_node_t *node);
 void	extent_node_dirty_insert(extent_node_t *node,
     arena_runs_dirty_link_t *runs_dirty, extent_node_t *chunks_dirty);
 void	extent_node_dirty_remove(extent_node_t *node);
 #endif
 
@@ -111,12 +127,19 @@
 extent_node_size_get(const extent_node_t *node)
 {
 
 	return (node->en_size);
 }
 
+JEMALLOC_INLINE size_t
+extent_node_sn_get(const extent_node_t *node)
+{
+
+	return (node->en_sn);
+}
+
 JEMALLOC_INLINE bool
 extent_node_zeroed_get(const extent_node_t *node)
 {
 
 	return (node->en_zeroed);
 }
@@ -162,12 +185,19 @@
 {
 
 	node->en_size = size;
 }
 
 JEMALLOC_INLINE void
+extent_node_sn_set(extent_node_t *node, size_t sn)
+{
+
+	node->en_sn = sn;
+}
+
+JEMALLOC_INLINE void
 extent_node_zeroed_set(extent_node_t *node, bool zeroed)
 {
 
 	node->en_zeroed = zeroed;
 }
 
@@ -191,18 +221,19 @@
 
 	node->en_prof_tctx = tctx;
 }
 
 JEMALLOC_INLINE void
 extent_node_init(extent_node_t *node, arena_t *arena, void *addr, size_t size,
-    bool zeroed, bool committed)
+    size_t sn, bool zeroed, bool committed)
 {
 
 	extent_node_arena_set(node, arena);
 	extent_node_addr_set(node, addr);
 	extent_node_size_set(node, size);
+	extent_node_sn_set(node, sn);
 	extent_node_zeroed_set(node, zeroed);
 	extent_node_committed_set(node, committed);
 	extent_node_achunk_set(node, false);
 	if (config_prof)
 		extent_node_prof_tctx_set(node, NULL);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/hash.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/hash.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/hash.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/hash.h	2017-01-31 23:32:23.000000000 +0800
@@ -1,9 +1,9 @@
 /*
  * The following hash function is based on MurmurHash3, placed into the public
- * domain by Austin Appleby.  See http://code.google.com/p/smhasher/ for
+ * domain by Austin Appleby.  See https://github.com/aappleby/smhasher for
  * details.
  */
 /******************************************************************************/
 #ifdef JEMALLOC_H_TYPES
 
 #endif /* JEMALLOC_H_TYPES */
@@ -46,19 +46,35 @@
 }
 
 JEMALLOC_INLINE uint32_t
 hash_get_block_32(const uint32_t *p, int i)
 {
 
+	/* Handle unaligned read. */
+	if (unlikely((uintptr_t)p & (sizeof(uint32_t)-1)) != 0) {
+		uint32_t ret;
+
+		memcpy(&ret, (uint8_t *)(p + i), sizeof(uint32_t));
+		return (ret);
+	}
+
 	return (p[i]);
 }
 
 JEMALLOC_INLINE uint64_t
 hash_get_block_64(const uint64_t *p, int i)
 {
 
+	/* Handle unaligned read. */
+	if (unlikely((uintptr_t)p & (sizeof(uint64_t)-1)) != 0) {
+		uint64_t ret;
+
+		memcpy(&ret, (uint8_t *)(p + i), sizeof(uint64_t));
+		return (ret);
+	}
+
 	return (p[i]);
 }
 
 JEMALLOC_INLINE uint32_t
 hash_fmix_32(uint32_t h)
 {
@@ -318,19 +334,24 @@
 
 /******************************************************************************/
 /* API. */
 JEMALLOC_INLINE void
 hash(const void *key, size_t len, const uint32_t seed, size_t r_hash[2])
 {
+
+	assert(len <= INT_MAX); /* Unfortunate implementation limitation. */
+
 #if (LG_SIZEOF_PTR == 3 && !defined(JEMALLOC_BIG_ENDIAN))
-	hash_x64_128(key, len, seed, (uint64_t *)r_hash);
+	hash_x64_128(key, (int)len, seed, (uint64_t *)r_hash);
 #else
-	uint64_t hashes[2];
-	hash_x86_128(key, len, seed, hashes);
-	r_hash[0] = (size_t)hashes[0];
-	r_hash[1] = (size_t)hashes[1];
+	{
+		uint64_t hashes[2];
+		hash_x86_128(key, (int)len, seed, hashes);
+		r_hash[0] = (size_t)hashes[0];
+		r_hash[1] = (size_t)hashes[1];
+	}
 #endif
 }
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/huge.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/huge.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/huge.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/huge.h	2017-01-31 23:32:23.000000000 +0800
@@ -6,30 +6,29 @@
 #ifdef JEMALLOC_H_STRUCTS
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-void	*huge_malloc(tsd_t *tsd, arena_t *arena, size_t size, bool zero,
-    tcache_t *tcache);
-void	*huge_palloc(tsd_t *tsd, arena_t *arena, size_t size, size_t alignment,
-    bool zero, tcache_t *tcache);
-bool	huge_ralloc_no_move(void *ptr, size_t oldsize, size_t usize_min,
-    size_t usize_max, bool zero);
+void	*huge_malloc(tsdn_t *tsdn, arena_t *arena, size_t usize, bool zero);
+void	*huge_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize,
+    size_t alignment, bool zero);
+bool	huge_ralloc_no_move(tsdn_t *tsdn, void *ptr, size_t oldsize,
+    size_t usize_min, size_t usize_max, bool zero);
 void	*huge_ralloc(tsd_t *tsd, arena_t *arena, void *ptr, size_t oldsize,
     size_t usize, size_t alignment, bool zero, tcache_t *tcache);
 #ifdef JEMALLOC_JET
 typedef void (huge_dalloc_junk_t)(void *, size_t);
 extern huge_dalloc_junk_t *huge_dalloc_junk;
 #endif
-void	huge_dalloc(tsd_t *tsd, void *ptr, tcache_t *tcache);
+void	huge_dalloc(tsdn_t *tsdn, void *ptr);
 arena_t	*huge_aalloc(const void *ptr);
-size_t	huge_salloc(const void *ptr);
-prof_tctx_t	*huge_prof_tctx_get(const void *ptr);
-void	huge_prof_tctx_set(const void *ptr, prof_tctx_t *tctx);
-void	huge_prof_tctx_reset(const void *ptr);
+size_t	huge_salloc(tsdn_t *tsdn, const void *ptr);
+prof_tctx_t	*huge_prof_tctx_get(tsdn_t *tsdn, const void *ptr);
+void	huge_prof_tctx_set(tsdn_t *tsdn, const void *ptr, prof_tctx_t *tctx);
+void	huge_prof_tctx_reset(tsdn_t *tsdn, const void *ptr);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #endif /* JEMALLOC_H_INLINES */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_decls.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_decls.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_decls.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_decls.h	2017-01-31 23:32:23.000000000 +0800
@@ -14,13 +14,24 @@
 #    if !defined(SYS_write) && defined(__NR_write)
 #      define SYS_write __NR_write
 #    endif
 #    include <sys/uio.h>
 #  endif
 #  include <pthread.h>
+#  ifdef JEMALLOC_OS_UNFAIR_LOCK
+#    include <os/lock.h>
+#  endif
+#  ifdef JEMALLOC_GLIBC_MALLOC_HOOK
+#    include <sched.h>
+#  endif
 #  include <errno.h>
+#  include <sys/time.h>
+#  include <time.h>
+#  ifdef JEMALLOC_HAVE_MACH_ABSOLUTE_TIME
+#    include <mach/mach_time.h>
+#  endif
 #endif
 #include <sys/types.h>
 
 #include <limits.h>
 #ifndef SIZE_T_MAX
 #  define SIZE_T_MAX	SIZE_MAX
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h	2017-09-27 23:00:17.522936196 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h	2017-09-27 23:01:52.522932714 +0800
@@ -54,32 +54,53 @@
 /*
  * Defined if __builtin_clz() and __builtin_clzl() are available.
  */
 #define JEMALLOC_HAVE_BUILTIN_CLZ 
 
 /*
- * Defined if madvise(2) is available.
+ * Defined if os_unfair_lock_*() functions are available, as provided by Darwin.
  */
-#define JEMALLOC_HAVE_MADVISE 
+/* #undef JEMALLOC_OS_UNFAIR_LOCK */
 
 /*
  * Defined if OSSpin*() functions are available, as provided by Darwin, and
  * documented in the spinlock(3) manual page.
  */
 /* #undef JEMALLOC_OSSPIN */
 
+/* Defined if syscall(2) is usable. */
+#define JEMALLOC_USE_SYSCALL 
+
 /*
  * Defined if secure_getenv(3) is available.
  */
 #define JEMALLOC_HAVE_SECURE_GETENV 
 
 /*
  * Defined if issetugid(2) is available.
  */
 /* #undef JEMALLOC_HAVE_ISSETUGID */
 
+/* Defined if pthread_atfork(3) is available. */
+#define JEMALLOC_HAVE_PTHREAD_ATFORK 
+
+/*
+ * Defined if clock_gettime(CLOCK_MONOTONIC_COARSE, ...) is available.
+ */
+#define JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE 1
+
+/*
+ * Defined if clock_gettime(CLOCK_MONOTONIC, ...) is available.
+ */
+#define JEMALLOC_HAVE_CLOCK_MONOTONIC 1
+
+/*
+ * Defined if mach_absolute_time() is available.
+ */
+/* #undef JEMALLOC_HAVE_MACH_ABSOLUTE_TIME */
+
 /*
  * Defined if _malloc_thread_cleanup() exists.  At least in the case of
  * FreeBSD, pthread_key_create() allocates, which if used during malloc
  * bootstrapping will cause recursion into the pthreads library.  Therefore, if
  * _malloc_thread_cleanup() exists, use it as the basis for thread cleanup in
  * malloc_tsd.
@@ -187,15 +208,22 @@
 /* #undef JEMALLOC_MUNMAP */
 
 /* TLS is used to map arenas and magazine caches to threads. */
 #define JEMALLOC_TLS 
 
 /*
- * ffs()/ffsl() functions to use for bitmapping.  Don't use these directly;
- * instead, use jemalloc_ffs() or jemalloc_ffsl() from util.h.
+ * Used to mark unreachable code to quiet "end of non-void" compiler warnings.
+ * Don't use this directly; instead use unreachable() from util.h
  */
+#define JEMALLOC_INTERNAL_UNREACHABLE __builtin_unreachable
+
+/*
+ * ffs*() functions to use for bitmapping.  Don't use these directly; instead,
+ * use ffs_*() from util.h.
+ */
+#define JEMALLOC_INTERNAL_FFSLL __builtin_ffsll
 #define JEMALLOC_INTERNAL_FFSL __builtin_ffsl
 #define JEMALLOC_INTERNAL_FFS __builtin_ffs
 
 /*
  * JEMALLOC_IVSALLOC enables ivsalloc(), which verifies that pointers reside
  * within jemalloc-owned chunks before dereferencing them.
@@ -212,23 +240,40 @@
  * Darwin (OS X) uses zones to work around Mach-O symbol override shortcomings.
  */
 /* #undef JEMALLOC_ZONE */
 /* #undef JEMALLOC_ZONE_VERSION */
 
 /*
+ * Methods for determining whether the OS overcommits.
+ * JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY: Linux's
+ *                                         /proc/sys/vm.overcommit_memory file.
+ * JEMALLOC_SYSCTL_VM_OVERCOMMIT: FreeBSD's vm.overcommit sysctl.
+ */
+/* #undef JEMALLOC_SYSCTL_VM_OVERCOMMIT */
+#define JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY 
+
+/* Defined if madvise(2) is available. */
+#define JEMALLOC_HAVE_MADVISE 
+
+/*
  * Methods for purging unused pages differ between operating systems.
  *
- *   madvise(..., MADV_DONTNEED) : On Linux, this immediately discards pages,
- *                                 such that new pages will be demand-zeroed if
- *                                 the address region is later touched.
- *   madvise(..., MADV_FREE) : On FreeBSD and Darwin, this marks pages as being
- *                             unused, such that they will be discarded rather
- *                             than swapped out.
+ *   madvise(..., MADV_FREE) : This marks pages as being unused, such that they
+ *                             will be discarded rather than swapped out.
+ *   madvise(..., MADV_DONTNEED) : This immediately discards pages, such that
+ *                                 new pages will be demand-zeroed if the
+ *                                 address region is later touched.
  */
-#define JEMALLOC_PURGE_MADVISE_DONTNEED 
 /* #undef JEMALLOC_PURGE_MADVISE_FREE */
+#define JEMALLOC_PURGE_MADVISE_DONTNEED 
+
+/*
+ * Defined if transparent huge pages are supported via the MADV_[NO]HUGEPAGE
+ * arguments to madvise(2).
+ */
+#define JEMALLOC_THP 
 
 /* Define if operating system has alloca.h header. */
 #define JEMALLOC_HAS_ALLOCA_H 1
 
 /* C99 restrict keyword supported. */
 /* #undef JEMALLOC_HAS_RESTRICT */
@@ -239,12 +284,15 @@
 /* sizeof(int) == 2^LG_SIZEOF_INT. */
 #define LG_SIZEOF_INT 2
 
 /* sizeof(long) == 2^LG_SIZEOF_LONG. */
 #define LG_SIZEOF_LONG 3
 
+/* sizeof(long long) == 2^LG_SIZEOF_LONG_LONG. */
+#define LG_SIZEOF_LONG_LONG 3
+
 /* sizeof(intmax_t) == 2^LG_SIZEOF_INTMAX_T. */
 #define LG_SIZEOF_INTMAX_T 3
 
 /* glibc malloc hooks (__malloc_hook, __realloc_hook, __free_hook). */
 #define JEMALLOC_GLIBC_MALLOC_HOOK 
 
@@ -257,7 +305,10 @@
 /*
  * If defined, jemalloc symbols are not exported (doesn't work when
  * JEMALLOC_PREFIX is not defined).
  */
 /* #undef JEMALLOC_EXPORT */
 
+/* config.malloc_conf options string. */
+#define JEMALLOC_CONFIG_MALLOC_CONF ""
+
 #endif /* JEMALLOC_INTERNAL_DEFS_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h.in	2017-01-31 23:32:23.000000000 +0800
@@ -53,32 +53,53 @@
 /*
  * Defined if __builtin_clz() and __builtin_clzl() are available.
  */
 #undef JEMALLOC_HAVE_BUILTIN_CLZ
 
 /*
- * Defined if madvise(2) is available.
+ * Defined if os_unfair_lock_*() functions are available, as provided by Darwin.
  */
-#undef JEMALLOC_HAVE_MADVISE
+#undef JEMALLOC_OS_UNFAIR_LOCK
 
 /*
  * Defined if OSSpin*() functions are available, as provided by Darwin, and
  * documented in the spinlock(3) manual page.
  */
 #undef JEMALLOC_OSSPIN
 
+/* Defined if syscall(2) is usable. */
+#undef JEMALLOC_USE_SYSCALL
+
 /*
  * Defined if secure_getenv(3) is available.
  */
 #undef JEMALLOC_HAVE_SECURE_GETENV
 
 /*
  * Defined if issetugid(2) is available.
  */
 #undef JEMALLOC_HAVE_ISSETUGID
 
+/* Defined if pthread_atfork(3) is available. */
+#undef JEMALLOC_HAVE_PTHREAD_ATFORK
+
+/*
+ * Defined if clock_gettime(CLOCK_MONOTONIC_COARSE, ...) is available.
+ */
+#undef JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE
+
+/*
+ * Defined if clock_gettime(CLOCK_MONOTONIC, ...) is available.
+ */
+#undef JEMALLOC_HAVE_CLOCK_MONOTONIC
+
+/*
+ * Defined if mach_absolute_time() is available.
+ */
+#undef JEMALLOC_HAVE_MACH_ABSOLUTE_TIME
+
 /*
  * Defined if _malloc_thread_cleanup() exists.  At least in the case of
  * FreeBSD, pthread_key_create() allocates, which if used during malloc
  * bootstrapping will cause recursion into the pthreads library.  Therefore, if
  * _malloc_thread_cleanup() exists, use it as the basis for thread cleanup in
  * malloc_tsd.
@@ -186,15 +207,22 @@
 #undef JEMALLOC_MUNMAP
 
 /* TLS is used to map arenas and magazine caches to threads. */
 #undef JEMALLOC_TLS
 
 /*
- * ffs()/ffsl() functions to use for bitmapping.  Don't use these directly;
- * instead, use jemalloc_ffs() or jemalloc_ffsl() from util.h.
+ * Used to mark unreachable code to quiet "end of non-void" compiler warnings.
+ * Don't use this directly; instead use unreachable() from util.h
  */
+#undef JEMALLOC_INTERNAL_UNREACHABLE
+
+/*
+ * ffs*() functions to use for bitmapping.  Don't use these directly; instead,
+ * use ffs_*() from util.h.
+ */
+#undef JEMALLOC_INTERNAL_FFSLL
 #undef JEMALLOC_INTERNAL_FFSL
 #undef JEMALLOC_INTERNAL_FFS
 
 /*
  * JEMALLOC_IVSALLOC enables ivsalloc(), which verifies that pointers reside
  * within jemalloc-owned chunks before dereferencing them.
@@ -211,23 +239,40 @@
  * Darwin (OS X) uses zones to work around Mach-O symbol override shortcomings.
  */
 #undef JEMALLOC_ZONE
 #undef JEMALLOC_ZONE_VERSION
 
 /*
+ * Methods for determining whether the OS overcommits.
+ * JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY: Linux's
+ *                                         /proc/sys/vm.overcommit_memory file.
+ * JEMALLOC_SYSCTL_VM_OVERCOMMIT: FreeBSD's vm.overcommit sysctl.
+ */
+#undef JEMALLOC_SYSCTL_VM_OVERCOMMIT
+#undef JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY
+
+/* Defined if madvise(2) is available. */
+#undef JEMALLOC_HAVE_MADVISE
+
+/*
  * Methods for purging unused pages differ between operating systems.
  *
- *   madvise(..., MADV_DONTNEED) : On Linux, this immediately discards pages,
- *                                 such that new pages will be demand-zeroed if
- *                                 the address region is later touched.
- *   madvise(..., MADV_FREE) : On FreeBSD and Darwin, this marks pages as being
- *                             unused, such that they will be discarded rather
- *                             than swapped out.
+ *   madvise(..., MADV_FREE) : This marks pages as being unused, such that they
+ *                             will be discarded rather than swapped out.
+ *   madvise(..., MADV_DONTNEED) : This immediately discards pages, such that
+ *                                 new pages will be demand-zeroed if the
+ *                                 address region is later touched.
  */
-#undef JEMALLOC_PURGE_MADVISE_DONTNEED
 #undef JEMALLOC_PURGE_MADVISE_FREE
+#undef JEMALLOC_PURGE_MADVISE_DONTNEED
+
+/*
+ * Defined if transparent huge pages are supported via the MADV_[NO]HUGEPAGE
+ * arguments to madvise(2).
+ */
+#undef JEMALLOC_THP
 
 /* Define if operating system has alloca.h header. */
 #undef JEMALLOC_HAS_ALLOCA_H
 
 /* C99 restrict keyword supported. */
 #undef JEMALLOC_HAS_RESTRICT
@@ -238,12 +283,15 @@
 /* sizeof(int) == 2^LG_SIZEOF_INT. */
 #undef LG_SIZEOF_INT
 
 /* sizeof(long) == 2^LG_SIZEOF_LONG. */
 #undef LG_SIZEOF_LONG
 
+/* sizeof(long long) == 2^LG_SIZEOF_LONG_LONG. */
+#undef LG_SIZEOF_LONG_LONG
+
 /* sizeof(intmax_t) == 2^LG_SIZEOF_INTMAX_T. */
 #undef LG_SIZEOF_INTMAX_T
 
 /* glibc malloc hooks (__malloc_hook, __realloc_hook, __free_hook). */
 #undef JEMALLOC_GLIBC_MALLOC_HOOK
 
@@ -256,7 +304,10 @@
 /*
  * If defined, jemalloc symbols are not exported (doesn't work when
  * JEMALLOC_PREFIX is not defined).
  */
 #undef JEMALLOC_EXPORT
 
+/* config.malloc_conf options string. */
+#undef JEMALLOC_CONFIG_MALLOC_CONF
+
 #endif /* JEMALLOC_INTERNAL_DEFS_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h	2017-09-27 23:00:17.438936199 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h	2017-09-27 23:01:52.422932718 +0800
@@ -46,12 +46,13 @@
 #ifdef JEMALLOC_LAZY_LOCK
     true
 #else
     false
 #endif
     ;
+static const char * const config_malloc_conf = JEMALLOC_CONFIG_MALLOC_CONF;
 static const bool config_prof =
 #ifdef JEMALLOC_PROF
     true
 #else
     false
 #endif
@@ -157,13 +158,16 @@
 #include <mach/mach_error.h>
 #include <mach/mach_init.h>
 #include <mach/vm_map.h>
 #include <malloc/malloc.h>
 #endif
 
+#include "jemalloc/internal/ph.h"
+#ifndef __PGI
 #define	RB_COMPACT
+#endif
 #include "jemalloc/internal/rb.h"
 #include "jemalloc/internal/qr.h"
 #include "jemalloc/internal/ql.h"
 
 /*
  * jemalloc can conceptually be broken into components (arena, tcache, etc.),
@@ -180,12 +184,15 @@
  */
 /******************************************************************************/
 #define	JEMALLOC_H_TYPES
 
 #include "jemalloc/internal/jemalloc_internal_macros.h"
 
+/* Page size index type. */
+typedef unsigned pszind_t;
+
 /* Size class index type. */
 typedef unsigned szind_t;
 
 /*
  * Flags bits:
  *
@@ -229,13 +236,13 @@
 #  ifdef __ia64__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __alpha__
 #    define LG_QUANTUM		4
 #  endif
-#  if (defined(__sparc64__) || defined(__sparcv9))
+#  if (defined(__sparc64__) || defined(__sparcv9) || defined(__sparc_v9__))
 #    define LG_QUANTUM		4
 #  endif
 #  if (defined(__amd64__) || defined(__x86_64__) || defined(_M_X64))
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __arm__
@@ -253,12 +260,15 @@
 #  ifdef __or1k__
 #    define LG_QUANTUM		3
 #  endif
 #  ifdef __powerpc__
 #    define LG_QUANTUM		4
 #  endif
+#  ifdef __riscv__
+#    define LG_QUANTUM		4
+#  endif
 #  ifdef __s390__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __SH4__
 #    define LG_QUANTUM		4
 #  endif
@@ -314,27 +324,31 @@
 #ifdef PAGE_MASK
 #  undef PAGE_MASK
 #endif
 #define	PAGE		((size_t)(1U << LG_PAGE))
 #define	PAGE_MASK	((size_t)(PAGE - 1))
 
+/* Return the page base address for the page containing address a. */
+#define	PAGE_ADDR2BASE(a)						\
+	((void *)((uintptr_t)(a) & ~PAGE_MASK))
+
 /* Return the smallest pagesize multiple that is >= s. */
 #define	PAGE_CEILING(s)							\
 	(((s) + PAGE_MASK) & ~PAGE_MASK)
 
 /* Return the nearest aligned address at or below a. */
 #define	ALIGNMENT_ADDR2BASE(a, alignment)				\
-	((void *)((uintptr_t)(a) & (-(alignment))))
+	((void *)((uintptr_t)(a) & ((~(alignment)) + 1)))
 
 /* Return the offset between a and the nearest aligned address at or below a. */
 #define	ALIGNMENT_ADDR2OFFSET(a, alignment)				\
 	((size_t)((uintptr_t)(a) & (alignment - 1)))
 
 /* Return the smallest alignment multiple that is >= s. */
 #define	ALIGNMENT_CEILING(s, alignment)					\
-	(((s) + (alignment - 1)) & (-(alignment)))
+	(((s) + (alignment - 1)) & ((~(alignment)) + 1))
 
 /* Declare a variable-length array. */
 #if __STDC_VERSION__ < 199901L
 #  ifdef _MSC_VER
 #    include <malloc.h>
 #    define alloca _alloca
@@ -348,20 +362,25 @@
 #  define VARIABLE_ARRAY(type, name, count) \
 	type *name = alloca(sizeof(type) * (count))
 #else
 #  define VARIABLE_ARRAY(type, name, count) type name[(count)]
 #endif
 
+#include "jemalloc/internal/nstime.h"
 #include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
+#include "jemalloc/internal/spin.h"
 #include "jemalloc/internal/prng.h"
+#include "jemalloc/internal/ticker.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
+#include "jemalloc/internal/smoothstep.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
+#include "jemalloc/internal/witness.h"
 #include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/arena.h"
 #include "jemalloc/internal/bitmap.h"
@@ -376,20 +395,25 @@
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_TYPES
 /******************************************************************************/
 #define	JEMALLOC_H_STRUCTS
 
+#include "jemalloc/internal/nstime.h"
 #include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
+#include "jemalloc/internal/spin.h"
 #include "jemalloc/internal/prng.h"
+#include "jemalloc/internal/ticker.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
+#include "jemalloc/internal/smoothstep.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
+#include "jemalloc/internal/witness.h"
 #include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/bitmap.h"
 #define	JEMALLOC_ARENA_STRUCTS_A
 #include "jemalloc/internal/arena.h"
 #undef JEMALLOC_ARENA_STRUCTS_A
@@ -419,20 +443,34 @@
 extern bool	opt_junk_free;
 extern size_t	opt_quarantine;
 extern bool	opt_redzone;
 extern bool	opt_utrace;
 extern bool	opt_xmalloc;
 extern bool	opt_zero;
-extern size_t	opt_narenas;
+extern unsigned	opt_narenas;
 
 extern bool	in_valgrind;
 
 /* Number of CPUs. */
-extern unsigned		ncpus;
+extern unsigned	ncpus;
+
+/* Number of arenas used for automatic multiplexing of threads and arenas. */
+extern unsigned	narenas_auto;
 
 /*
+ * Arenas that are used to service external requests.  Not all elements of the
+ * arenas array are necessarily used; arenas are created lazily as needed.
+ */
+extern arena_t	**arenas;
+
+/*
+ * pind2sz_tab encodes the same information as could be computed by
+ * pind2sz_compute().
+ */
+extern size_t const	pind2sz_tab[NPSIZES];
+/*
  * index2size_tab encodes the same information as could be computed (at
  * unacceptable cost in some code paths) by index2size_compute().
  */
 extern size_t const	index2size_tab[NSIZES];
 /*
  * size2index_tab is a compact lookup table that rounds request sizes up to
@@ -444,37 +482,41 @@
 arena_t	*a0get(void);
 void	*a0malloc(size_t size);
 void	a0dalloc(void *ptr);
 void	*bootstrap_malloc(size_t size);
 void	*bootstrap_calloc(size_t num, size_t size);
 void	bootstrap_free(void *ptr);
-arena_t	*arenas_extend(unsigned ind);
-arena_t	*arena_init(unsigned ind);
 unsigned	narenas_total_get(void);
-arena_t	*arena_get_hard(tsd_t *tsd, unsigned ind, bool init_if_missing);
-arena_t	*arena_choose_hard(tsd_t *tsd);
+arena_t	*arena_init(tsdn_t *tsdn, unsigned ind);
+arena_tdata_t	*arena_tdata_get_hard(tsd_t *tsd, unsigned ind);
+arena_t	*arena_choose_hard(tsd_t *tsd, bool internal);
 void	arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind);
-unsigned	arena_nbound(unsigned ind);
 void	thread_allocated_cleanup(tsd_t *tsd);
 void	thread_deallocated_cleanup(tsd_t *tsd);
+void	iarena_cleanup(tsd_t *tsd);
 void	arena_cleanup(tsd_t *tsd);
-void	arenas_cache_cleanup(tsd_t *tsd);
-void	narenas_cache_cleanup(tsd_t *tsd);
-void	arenas_cache_bypass_cleanup(tsd_t *tsd);
+void	arenas_tdata_cleanup(tsd_t *tsd);
+void	narenas_tdata_cleanup(tsd_t *tsd);
+void	arenas_tdata_bypass_cleanup(tsd_t *tsd);
 void	jemalloc_prefork(void);
 void	jemalloc_postfork_parent(void);
 void	jemalloc_postfork_child(void);
 
+#include "jemalloc/internal/nstime.h"
 #include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
+#include "jemalloc/internal/spin.h"
 #include "jemalloc/internal/prng.h"
+#include "jemalloc/internal/ticker.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
+#include "jemalloc/internal/smoothstep.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
+#include "jemalloc/internal/witness.h"
 #include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/bitmap.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/arena.h"
 #include "jemalloc/internal/base.h"
@@ -489,86 +531,177 @@
 #include "jemalloc/internal/tsd.h"
 
 #undef JEMALLOC_H_EXTERNS
 /******************************************************************************/
 #define	JEMALLOC_H_INLINES
 
+#include "jemalloc/internal/nstime.h"
 #include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
+#include "jemalloc/internal/spin.h"
 #include "jemalloc/internal/prng.h"
+#include "jemalloc/internal/ticker.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
+#include "jemalloc/internal/smoothstep.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
-#include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/tsd.h"
+#include "jemalloc/internal/witness.h"
+#include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/base.h"
 #include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
 
 #ifndef JEMALLOC_ENABLE_INLINE
+pszind_t	psz2ind(size_t psz);
+size_t	pind2sz_compute(pszind_t pind);
+size_t	pind2sz_lookup(pszind_t pind);
+size_t	pind2sz(pszind_t pind);
+size_t	psz2u(size_t psz);
 szind_t	size2index_compute(size_t size);
 szind_t	size2index_lookup(size_t size);
 szind_t	size2index(size_t size);
 size_t	index2size_compute(szind_t index);
 size_t	index2size_lookup(szind_t index);
 size_t	index2size(szind_t index);
 size_t	s2u_compute(size_t size);
 size_t	s2u_lookup(size_t size);
 size_t	s2u(size_t size);
 size_t	sa2u(size_t size, size_t alignment);
+arena_t	*arena_choose_impl(tsd_t *tsd, arena_t *arena, bool internal);
 arena_t	*arena_choose(tsd_t *tsd, arena_t *arena);
-arena_t	*arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
+arena_t	*arena_ichoose(tsd_t *tsd, arena_t *arena);
+arena_tdata_t	*arena_tdata_get(tsd_t *tsd, unsigned ind,
     bool refresh_if_missing);
+arena_t	*arena_get(tsdn_t *tsdn, unsigned ind, bool init_if_missing);
+ticker_t	*decay_ticker_get(tsd_t *tsd, unsigned ind);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
+JEMALLOC_INLINE pszind_t
+psz2ind(size_t psz)
+{
+
+	if (unlikely(psz > HUGE_MAXCLASS))
+		return (NPSIZES);
+	{
+		pszind_t x = lg_floor((psz<<1)-1);
+		pszind_t shift = (x < LG_SIZE_CLASS_GROUP + LG_PAGE) ? 0 : x -
+		    (LG_SIZE_CLASS_GROUP + LG_PAGE);
+		pszind_t grp = shift << LG_SIZE_CLASS_GROUP;
+
+		pszind_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_PAGE + 1) ?
+		    LG_PAGE : x - LG_SIZE_CLASS_GROUP - 1;
+
+		size_t delta_inverse_mask = ZI(-1) << lg_delta;
+		pszind_t mod = ((((psz-1) & delta_inverse_mask) >> lg_delta)) &
+		    ((ZU(1) << LG_SIZE_CLASS_GROUP) - 1);
+
+		pszind_t ind = grp + mod;
+		return (ind);
+	}
+}
+
+JEMALLOC_INLINE size_t
+pind2sz_compute(pszind_t pind)
+{
+
+	{
+		size_t grp = pind >> LG_SIZE_CLASS_GROUP;
+		size_t mod = pind & ((ZU(1) << LG_SIZE_CLASS_GROUP) - 1);
+
+		size_t grp_size_mask = ~((!!grp)-1);
+		size_t grp_size = ((ZU(1) << (LG_PAGE +
+		    (LG_SIZE_CLASS_GROUP-1))) << grp) & grp_size_mask;
+
+		size_t shift = (grp == 0) ? 1 : grp;
+		size_t lg_delta = shift + (LG_PAGE-1);
+		size_t mod_size = (mod+1) << lg_delta;
+
+		size_t sz = grp_size + mod_size;
+		return (sz);
+	}
+}
+
+JEMALLOC_INLINE size_t
+pind2sz_lookup(pszind_t pind)
+{
+	size_t ret = (size_t)pind2sz_tab[pind];
+	assert(ret == pind2sz_compute(pind));
+	return (ret);
+}
+
+JEMALLOC_INLINE size_t
+pind2sz(pszind_t pind)
+{
+
+	assert(pind < NPSIZES);
+	return (pind2sz_lookup(pind));
+}
+
+JEMALLOC_INLINE size_t
+psz2u(size_t psz)
+{
+
+	if (unlikely(psz > HUGE_MAXCLASS))
+		return (0);
+	{
+		size_t x = lg_floor((psz<<1)-1);
+		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_PAGE + 1) ?
+		    LG_PAGE : x - LG_SIZE_CLASS_GROUP - 1;
+		size_t delta = ZU(1) << lg_delta;
+		size_t delta_mask = delta - 1;
+		size_t usize = (psz + delta_mask) & ~delta_mask;
+		return (usize);
+	}
+}
+
 JEMALLOC_INLINE szind_t
 size2index_compute(size_t size)
 {
 
+	if (unlikely(size > HUGE_MAXCLASS))
+		return (NSIZES);
 #if (NTBINS != 0)
 	if (size <= (ZU(1) << LG_TINY_MAXCLASS)) {
-		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
-		size_t lg_ceil = lg_floor(pow2_ceil(size));
+		szind_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
+		szind_t lg_ceil = lg_floor(pow2_ceil_zu(size));
 		return (lg_ceil < lg_tmin ? 0 : lg_ceil - lg_tmin);
 	}
 #endif
 	{
-		size_t x = unlikely(ZI(size) < 0) ? ((size<<1) ?
-		    (ZU(1)<<(LG_SIZEOF_PTR+3)) : ((ZU(1)<<(LG_SIZEOF_PTR+3))-1))
-		    : lg_floor((size<<1)-1);
-		size_t shift = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? 0 :
+		szind_t x = lg_floor((size<<1)-1);
+		szind_t shift = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? 0 :
 		    x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);
-		size_t grp = shift << LG_SIZE_CLASS_GROUP;
+		szind_t grp = shift << LG_SIZE_CLASS_GROUP;
 
-		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
+		szind_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
 		    ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
 
 		size_t delta_inverse_mask = ZI(-1) << lg_delta;
-		size_t mod = ((((size-1) & delta_inverse_mask) >> lg_delta)) &
+		szind_t mod = ((((size-1) & delta_inverse_mask) >> lg_delta)) &
 		    ((ZU(1) << LG_SIZE_CLASS_GROUP) - 1);
 
-		size_t index = NTBINS + grp + mod;
+		szind_t index = NTBINS + grp + mod;
 		return (index);
 	}
 }
 
 JEMALLOC_ALWAYS_INLINE szind_t
 size2index_lookup(size_t size)
 {
 
 	assert(size <= LOOKUP_MAXCLASS);
 	{
-		size_t ret = ((size_t)(size2index_tab[(size-1) >>
-		    LG_TINY_MIN]));
+		szind_t ret = (size2index_tab[(size-1) >> LG_TINY_MIN]);
 		assert(ret == size2index_compute(size));
 		return (ret);
 	}
 }
 
 JEMALLOC_ALWAYS_INLINE szind_t
@@ -625,24 +758,24 @@
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 s2u_compute(size_t size)
 {
 
+	if (unlikely(size > HUGE_MAXCLASS))
+		return (0);
 #if (NTBINS > 0)
 	if (size <= (ZU(1) << LG_TINY_MAXCLASS)) {
 		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
-		size_t lg_ceil = lg_floor(pow2_ceil(size));
+		size_t lg_ceil = lg_floor(pow2_ceil_zu(size));
 		return (lg_ceil < lg_tmin ? (ZU(1) << lg_tmin) :
 		    (ZU(1) << lg_ceil));
 	}
 #endif
 	{
-		size_t x = unlikely(ZI(size) < 0) ? ((size<<1) ?
-		    (ZU(1)<<(LG_SIZEOF_PTR+3)) : ((ZU(1)<<(LG_SIZEOF_PTR+3))-1))
-		    : lg_floor((size<<1)-1);
+		size_t x = lg_floor((size<<1)-1);
 		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
 		    ?  LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
 		size_t delta = ZU(1) << lg_delta;
 		size_t delta_mask = delta - 1;
 		size_t usize = (size + delta_mask) & ~delta_mask;
 		return (usize);
@@ -720,23 +853,22 @@
 		 * would need to allocate in order to guarantee the alignment.
 		 */
 		if (usize + large_pad + alignment - PAGE <= arena_maxrun)
 			return (usize);
 	}
 
-	/* Huge size class.  Beware of size_t overflow. */
+	/* Huge size class.  Beware of overflow. */
+
+	if (unlikely(alignment > HUGE_MAXCLASS))
+		return (0);
 
 	/*
 	 * We can't achieve subchunk alignment, so round up alignment to the
 	 * minimum that can actually be supported.
 	 */
 	alignment = CHUNK_CEILING(alignment);
-	if (alignment == 0) {
-		/* size_t overflow. */
-		return (0);
-	}
 
 	/* Make sure result is a huge size class. */
 	if (size <= chunksize)
 		usize = chunksize;
 	else {
 		usize = s2u(size);
@@ -756,51 +888,90 @@
 	}
 	return (usize);
 }
 
 /* Choose an arena based on a per-thread value. */
 JEMALLOC_INLINE arena_t *
-arena_choose(tsd_t *tsd, arena_t *arena)
+arena_choose_impl(tsd_t *tsd, arena_t *arena, bool internal)
 {
 	arena_t *ret;
 
 	if (arena != NULL)
 		return (arena);
 
-	if (unlikely((ret = tsd_arena_get(tsd)) == NULL))
-		ret = arena_choose_hard(tsd);
+	ret = internal ? tsd_iarena_get(tsd) : tsd_arena_get(tsd);
+	if (unlikely(ret == NULL))
+		ret = arena_choose_hard(tsd, internal);
 
 	return (ret);
 }
 
 JEMALLOC_INLINE arena_t *
-arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
-    bool refresh_if_missing)
+arena_choose(tsd_t *tsd, arena_t *arena)
 {
-	arena_t *arena;
-	arena_t **arenas_cache = tsd_arenas_cache_get(tsd);
 
-	/* init_if_missing requires refresh_if_missing. */
-	assert(!init_if_missing || refresh_if_missing);
+	return (arena_choose_impl(tsd, arena, false));
+}
+
+JEMALLOC_INLINE arena_t *
+arena_ichoose(tsd_t *tsd, arena_t *arena)
+{
 
-	if (unlikely(arenas_cache == NULL)) {
-		/* arenas_cache hasn't been initialized yet. */
-		return (arena_get_hard(tsd, ind, init_if_missing));
+	return (arena_choose_impl(tsd, arena, true));
+}
+
+JEMALLOC_INLINE arena_tdata_t *
+arena_tdata_get(tsd_t *tsd, unsigned ind, bool refresh_if_missing)
+{
+	arena_tdata_t *tdata;
+	arena_tdata_t *arenas_tdata = tsd_arenas_tdata_get(tsd);
+
+	if (unlikely(arenas_tdata == NULL)) {
+		/* arenas_tdata hasn't been initialized yet. */
+		return (arena_tdata_get_hard(tsd, ind));
 	}
-	if (unlikely(ind >= tsd_narenas_cache_get(tsd))) {
+	if (unlikely(ind >= tsd_narenas_tdata_get(tsd))) {
 		/*
-		 * ind is invalid, cache is old (too small), or arena to be
+		 * ind is invalid, cache is old (too small), or tdata to be
 		 * initialized.
 		 */
-		return (refresh_if_missing ? arena_get_hard(tsd, ind,
-		    init_if_missing) : NULL);
+		return (refresh_if_missing ? arena_tdata_get_hard(tsd, ind) :
+		    NULL);
 	}
-	arena = arenas_cache[ind];
-	if (likely(arena != NULL) || !refresh_if_missing)
-		return (arena);
-	return (arena_get_hard(tsd, ind, init_if_missing));
+
+	tdata = &arenas_tdata[ind];
+	if (likely(tdata != NULL) || !refresh_if_missing)
+		return (tdata);
+	return (arena_tdata_get_hard(tsd, ind));
+}
+
+JEMALLOC_INLINE arena_t *
+arena_get(tsdn_t *tsdn, unsigned ind, bool init_if_missing)
+{
+	arena_t *ret;
+
+	assert(ind <= MALLOCX_ARENA_MAX);
+
+	ret = arenas[ind];
+	if (unlikely(ret == NULL)) {
+		ret = atomic_read_p((void *)&arenas[ind]);
+		if (init_if_missing && unlikely(ret == NULL))
+			ret = arena_init(tsdn, ind);
+	}
+	return (ret);
+}
+
+JEMALLOC_INLINE ticker_t *
+decay_ticker_get(tsd_t *tsd, unsigned ind)
+{
+	arena_tdata_t *tdata;
+
+	tdata = arena_tdata_get(tsd, ind, true);
+	if (unlikely(tdata == NULL))
+		return (NULL);
+	return (&tdata->decay_ticker);
 }
 #endif
 
 #include "jemalloc/internal/bitmap.h"
 /*
  * Include portions of arena.h interleaved with tcache.h in order to resolve
@@ -815,42 +986,42 @@
 #undef JEMALLOC_ARENA_INLINE_B
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 
 #ifndef JEMALLOC_ENABLE_INLINE
 arena_t	*iaalloc(const void *ptr);
-size_t	isalloc(const void *ptr, bool demote);
-void	*iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache,
-    bool is_metadata, arena_t *arena);
-void	*imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
-void	*imalloc(tsd_t *tsd, size_t size);
-void	*icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
-void	*icalloc(tsd_t *tsd, size_t size);
-void	*ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+size_t	isalloc(tsdn_t *tsdn, const void *ptr, bool demote);
+void	*iallocztm(tsdn_t *tsdn, size_t size, szind_t ind, bool zero,
+    tcache_t *tcache, bool is_metadata, arena_t *arena, bool slow_path);
+void	*ialloc(tsd_t *tsd, size_t size, szind_t ind, bool zero,
+    bool slow_path);
+void	*ipallocztm(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     tcache_t *tcache, bool is_metadata, arena_t *arena);
-void	*ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+void	*ipalloct(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     tcache_t *tcache, arena_t *arena);
 void	*ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero);
-size_t	ivsalloc(const void *ptr, bool demote);
+size_t	ivsalloc(tsdn_t *tsdn, const void *ptr, bool demote);
 size_t	u2rz(size_t usize);
-size_t	p2rz(const void *ptr);
-void	idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata);
-void	idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache);
+size_t	p2rz(tsdn_t *tsdn, const void *ptr);
+void	idalloctm(tsdn_t *tsdn, void *ptr, tcache_t *tcache, bool is_metadata,
+    bool slow_path);
 void	idalloc(tsd_t *tsd, void *ptr);
-void	iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache);
-void	isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
-void	isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
+void	iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path);
+void	isdalloct(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
+    bool slow_path);
+void	isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache,
+    bool slow_path);
 void	*iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
     size_t extra, size_t alignment, bool zero, tcache_t *tcache,
     arena_t *arena);
 void	*iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
     size_t alignment, bool zero, tcache_t *tcache, arena_t *arena);
 void	*iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
     size_t alignment, bool zero);
-bool	ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra,
-    size_t alignment, bool zero);
+bool	ixalloc(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size,
+    size_t extra, size_t alignment, bool zero);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
 JEMALLOC_ALWAYS_INLINE arena_t *
 iaalloc(const void *ptr)
 {
@@ -859,118 +1030,103 @@
 
 	return (arena_aalloc(ptr));
 }
 
 /*
  * Typical usage:
+ *   tsdn_t *tsdn = [...]
  *   void *ptr = [...]
- *   size_t sz = isalloc(ptr, config_prof);
+ *   size_t sz = isalloc(tsdn, ptr, config_prof);
  */
 JEMALLOC_ALWAYS_INLINE size_t
-isalloc(const void *ptr, bool demote)
+isalloc(tsdn_t *tsdn, const void *ptr, bool demote)
 {
 
 	assert(ptr != NULL);
 	/* Demotion only makes sense if config_prof is true. */
 	assert(config_prof || !demote);
 
-	return (arena_salloc(ptr, demote));
+	return (arena_salloc(tsdn, ptr, demote));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache, bool is_metadata,
-    arena_t *arena)
+iallocztm(tsdn_t *tsdn, size_t size, szind_t ind, bool zero, tcache_t *tcache,
+    bool is_metadata, arena_t *arena, bool slow_path)
 {
 	void *ret;
 
 	assert(size != 0);
+	assert(!is_metadata || tcache == NULL);
+	assert(!is_metadata || arena == NULL || arena->ind < narenas_auto);
 
-	ret = arena_malloc(tsd, arena, size, zero, tcache);
+	ret = arena_malloc(tsdn, arena, size, ind, zero, tcache, slow_path);
 	if (config_stats && is_metadata && likely(ret != NULL)) {
-		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
-		    config_prof));
+		arena_metadata_allocated_add(iaalloc(ret),
+		    isalloc(tsdn, ret, config_prof));
 	}
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
+ialloc(tsd_t *tsd, size_t size, szind_t ind, bool zero, bool slow_path)
 {
 
-	return (iallocztm(tsd, size, false, tcache, false, arena));
+	return (iallocztm(tsd_tsdn(tsd), size, ind, zero, tcache_get(tsd, true),
+	    false, NULL, slow_path));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-imalloc(tsd_t *tsd, size_t size)
-{
-
-	return (iallocztm(tsd, size, false, tcache_get(tsd, true), false, NULL));
-}
-
-JEMALLOC_ALWAYS_INLINE void *
-icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
-{
-
-	return (iallocztm(tsd, size, true, tcache, false, arena));
-}
-
-JEMALLOC_ALWAYS_INLINE void *
-icalloc(tsd_t *tsd, size_t size)
-{
-
-	return (iallocztm(tsd, size, true, tcache_get(tsd, true), false, NULL));
-}
-
-JEMALLOC_ALWAYS_INLINE void *
-ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+ipallocztm(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     tcache_t *tcache, bool is_metadata, arena_t *arena)
 {
 	void *ret;
 
 	assert(usize != 0);
 	assert(usize == sa2u(usize, alignment));
+	assert(!is_metadata || tcache == NULL);
+	assert(!is_metadata || arena == NULL || arena->ind < narenas_auto);
 
-	ret = arena_palloc(tsd, arena, usize, alignment, zero, tcache);
+	ret = arena_palloc(tsdn, arena, usize, alignment, zero, tcache);
 	assert(ALIGNMENT_ADDR2BASE(ret, alignment) == ret);
 	if (config_stats && is_metadata && likely(ret != NULL)) {
-		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
+		arena_metadata_allocated_add(iaalloc(ret), isalloc(tsdn, ret,
 		    config_prof));
 	}
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+ipalloct(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     tcache_t *tcache, arena_t *arena)
 {
 
-	return (ipallocztm(tsd, usize, alignment, zero, tcache, false, arena));
+	return (ipallocztm(tsdn, usize, alignment, zero, tcache, false, arena));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
 ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero)
 {
 
-	return (ipallocztm(tsd, usize, alignment, zero, tcache_get(tsd,
-	    NULL), false, NULL));
+	return (ipallocztm(tsd_tsdn(tsd), usize, alignment, zero,
+	    tcache_get(tsd, true), false, NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-ivsalloc(const void *ptr, bool demote)
+ivsalloc(tsdn_t *tsdn, const void *ptr, bool demote)
 {
 	extent_node_t *node;
 
 	/* Return 0 if ptr is not within a chunk managed by jemalloc. */
 	node = chunk_lookup(ptr, false);
 	if (node == NULL)
 		return (0);
 	/* Only arena chunks should be looked up via interior pointers. */
 	assert(extent_node_addr_get(node) == ptr ||
 	    extent_node_achunk_get(node));
 
-	return (isalloc(ptr, demote));
+	return (isalloc(tsdn, ptr, demote));
 }
 
 JEMALLOC_INLINE size_t
 u2rz(size_t usize)
 {
 	size_t ret;
@@ -982,102 +1138,100 @@
 		ret = 0;
 
 	return (ret);
 }
 
 JEMALLOC_INLINE size_t
-p2rz(const void *ptr)
+p2rz(tsdn_t *tsdn, const void *ptr)
 {
-	size_t usize = isalloc(ptr, false);
+	size_t usize = isalloc(tsdn, ptr, false);
 
 	return (u2rz(usize));
 }
 
 JEMALLOC_ALWAYS_INLINE void
-idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata)
+idalloctm(tsdn_t *tsdn, void *ptr, tcache_t *tcache, bool is_metadata,
+    bool slow_path)
 {
 
 	assert(ptr != NULL);
+	assert(!is_metadata || tcache == NULL);
+	assert(!is_metadata || iaalloc(ptr)->ind < narenas_auto);
 	if (config_stats && is_metadata) {
-		arena_metadata_allocated_sub(iaalloc(ptr), isalloc(ptr,
+		arena_metadata_allocated_sub(iaalloc(ptr), isalloc(tsdn, ptr,
 		    config_prof));
 	}
 
-	arena_dalloc(tsd, ptr, tcache);
-}
-
-JEMALLOC_ALWAYS_INLINE void
-idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache)
-{
-
-	idalloctm(tsd, ptr, tcache, false);
+	arena_dalloc(tsdn, ptr, tcache, slow_path);
 }
 
 JEMALLOC_ALWAYS_INLINE void
 idalloc(tsd_t *tsd, void *ptr)
 {
 
-	idalloctm(tsd, ptr, tcache_get(tsd, false), false);
+	idalloctm(tsd_tsdn(tsd), ptr, tcache_get(tsd, false), false, true);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache)
+iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path)
 {
 
-	if (config_fill && unlikely(opt_quarantine))
+	if (slow_path && config_fill && unlikely(opt_quarantine))
 		quarantine(tsd, ptr);
 	else
-		idalloctm(tsd, ptr, tcache, false);
+		idalloctm(tsd_tsdn(tsd), ptr, tcache, false, slow_path);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
+isdalloct(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
+    bool slow_path)
 {
 
-	arena_sdalloc(tsd, ptr, size, tcache);
+	arena_sdalloc(tsdn, ptr, size, tcache, slow_path);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
+isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache, bool slow_path)
 {
 
-	if (config_fill && unlikely(opt_quarantine))
+	if (slow_path && config_fill && unlikely(opt_quarantine))
 		quarantine(tsd, ptr);
 	else
-		isdalloct(tsd, ptr, size, tcache);
+		isdalloct(tsd_tsdn(tsd), ptr, size, tcache, slow_path);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
 iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
     size_t extra, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena)
 {
 	void *p;
 	size_t usize, copysize;
 
 	usize = sa2u(size + extra, alignment);
-	if (usize == 0)
+	if (unlikely(usize == 0 || usize > HUGE_MAXCLASS))
 		return (NULL);
-	p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
+	p = ipalloct(tsd_tsdn(tsd), usize, alignment, zero, tcache, arena);
 	if (p == NULL) {
 		if (extra == 0)
 			return (NULL);
 		/* Try again, without extra this time. */
 		usize = sa2u(size, alignment);
-		if (usize == 0)
+		if (unlikely(usize == 0 || usize > HUGE_MAXCLASS))
 			return (NULL);
-		p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
+		p = ipalloct(tsd_tsdn(tsd), usize, alignment, zero, tcache,
+		    arena);
 		if (p == NULL)
 			return (NULL);
 	}
 	/*
 	 * Copy at most size bytes (not size+extra), since the caller has no
 	 * expectation that the extra bytes will be reliably preserved.
 	 */
 	copysize = (size < oldsize) ? size : oldsize;
 	memcpy(p, ptr, copysize);
-	isqalloc(tsd, ptr, oldsize, tcache);
+	isqalloc(tsd, ptr, oldsize, tcache, true);
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
 iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
     bool zero, tcache_t *tcache, arena_t *arena)
@@ -1107,26 +1261,26 @@
 
 	return (iralloct(tsd, ptr, oldsize, size, alignment, zero,
 	    tcache_get(tsd, true), NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE bool
-ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra, size_t alignment,
-    bool zero)
+ixalloc(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size, size_t extra,
+    size_t alignment, bool zero)
 {
 
 	assert(ptr != NULL);
 	assert(size != 0);
 
 	if (alignment != 0 && ((uintptr_t)ptr & ((uintptr_t)alignment-1))
 	    != 0) {
 		/* Existing object alignment is inadequate. */
 		return (true);
 	}
 
-	return (arena_ralloc_no_move(ptr, oldsize, size, extra, zero));
+	return (arena_ralloc_no_move(tsdn, ptr, oldsize, size, extra, zero));
 }
 #endif
 
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_INLINES
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/jemalloc_internal.h.in	2017-01-31 23:32:23.000000000 +0800
@@ -46,12 +46,13 @@
 #ifdef JEMALLOC_LAZY_LOCK
     true
 #else
     false
 #endif
     ;
+static const char * const config_malloc_conf = JEMALLOC_CONFIG_MALLOC_CONF;
 static const bool config_prof =
 #ifdef JEMALLOC_PROF
     true
 #else
     false
 #endif
@@ -157,13 +158,16 @@
 #include <mach/mach_error.h>
 #include <mach/mach_init.h>
 #include <mach/vm_map.h>
 #include <malloc/malloc.h>
 #endif
 
+#include "jemalloc/internal/ph.h"
+#ifndef __PGI
 #define	RB_COMPACT
+#endif
 #include "jemalloc/internal/rb.h"
 #include "jemalloc/internal/qr.h"
 #include "jemalloc/internal/ql.h"
 
 /*
  * jemalloc can conceptually be broken into components (arena, tcache, etc.),
@@ -180,12 +184,15 @@
  */
 /******************************************************************************/
 #define	JEMALLOC_H_TYPES
 
 #include "jemalloc/internal/jemalloc_internal_macros.h"
 
+/* Page size index type. */
+typedef unsigned pszind_t;
+
 /* Size class index type. */
 typedef unsigned szind_t;
 
 /*
  * Flags bits:
  *
@@ -229,13 +236,13 @@
 #  ifdef __ia64__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __alpha__
 #    define LG_QUANTUM		4
 #  endif
-#  if (defined(__sparc64__) || defined(__sparcv9))
+#  if (defined(__sparc64__) || defined(__sparcv9) || defined(__sparc_v9__))
 #    define LG_QUANTUM		4
 #  endif
 #  if (defined(__amd64__) || defined(__x86_64__) || defined(_M_X64))
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __arm__
@@ -253,12 +260,15 @@
 #  ifdef __or1k__
 #    define LG_QUANTUM		3
 #  endif
 #  ifdef __powerpc__
 #    define LG_QUANTUM		4
 #  endif
+#  ifdef __riscv__
+#    define LG_QUANTUM		4
+#  endif
 #  ifdef __s390__
 #    define LG_QUANTUM		4
 #  endif
 #  ifdef __SH4__
 #    define LG_QUANTUM		4
 #  endif
@@ -314,27 +324,31 @@
 #ifdef PAGE_MASK
 #  undef PAGE_MASK
 #endif
 #define	PAGE		((size_t)(1U << LG_PAGE))
 #define	PAGE_MASK	((size_t)(PAGE - 1))
 
+/* Return the page base address for the page containing address a. */
+#define	PAGE_ADDR2BASE(a)						\
+	((void *)((uintptr_t)(a) & ~PAGE_MASK))
+
 /* Return the smallest pagesize multiple that is >= s. */
 #define	PAGE_CEILING(s)							\
 	(((s) + PAGE_MASK) & ~PAGE_MASK)
 
 /* Return the nearest aligned address at or below a. */
 #define	ALIGNMENT_ADDR2BASE(a, alignment)				\
-	((void *)((uintptr_t)(a) & (-(alignment))))
+	((void *)((uintptr_t)(a) & ((~(alignment)) + 1)))
 
 /* Return the offset between a and the nearest aligned address at or below a. */
 #define	ALIGNMENT_ADDR2OFFSET(a, alignment)				\
 	((size_t)((uintptr_t)(a) & (alignment - 1)))
 
 /* Return the smallest alignment multiple that is >= s. */
 #define	ALIGNMENT_CEILING(s, alignment)					\
-	(((s) + (alignment - 1)) & (-(alignment)))
+	(((s) + (alignment - 1)) & ((~(alignment)) + 1))
 
 /* Declare a variable-length array. */
 #if __STDC_VERSION__ < 199901L
 #  ifdef _MSC_VER
 #    include <malloc.h>
 #    define alloca _alloca
@@ -348,20 +362,25 @@
 #  define VARIABLE_ARRAY(type, name, count) \
 	type *name = alloca(sizeof(type) * (count))
 #else
 #  define VARIABLE_ARRAY(type, name, count) type name[(count)]
 #endif
 
+#include "jemalloc/internal/nstime.h"
 #include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
+#include "jemalloc/internal/spin.h"
 #include "jemalloc/internal/prng.h"
+#include "jemalloc/internal/ticker.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
+#include "jemalloc/internal/smoothstep.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
+#include "jemalloc/internal/witness.h"
 #include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/tsd.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/arena.h"
 #include "jemalloc/internal/bitmap.h"
@@ -376,20 +395,25 @@
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_TYPES
 /******************************************************************************/
 #define	JEMALLOC_H_STRUCTS
 
+#include "jemalloc/internal/nstime.h"
 #include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
+#include "jemalloc/internal/spin.h"
 #include "jemalloc/internal/prng.h"
+#include "jemalloc/internal/ticker.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
+#include "jemalloc/internal/smoothstep.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
+#include "jemalloc/internal/witness.h"
 #include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/bitmap.h"
 #define	JEMALLOC_ARENA_STRUCTS_A
 #include "jemalloc/internal/arena.h"
 #undef JEMALLOC_ARENA_STRUCTS_A
@@ -419,20 +443,34 @@
 extern bool	opt_junk_free;
 extern size_t	opt_quarantine;
 extern bool	opt_redzone;
 extern bool	opt_utrace;
 extern bool	opt_xmalloc;
 extern bool	opt_zero;
-extern size_t	opt_narenas;
+extern unsigned	opt_narenas;
 
 extern bool	in_valgrind;
 
 /* Number of CPUs. */
-extern unsigned		ncpus;
+extern unsigned	ncpus;
+
+/* Number of arenas used for automatic multiplexing of threads and arenas. */
+extern unsigned	narenas_auto;
 
 /*
+ * Arenas that are used to service external requests.  Not all elements of the
+ * arenas array are necessarily used; arenas are created lazily as needed.
+ */
+extern arena_t	**arenas;
+
+/*
+ * pind2sz_tab encodes the same information as could be computed by
+ * pind2sz_compute().
+ */
+extern size_t const	pind2sz_tab[NPSIZES];
+/*
  * index2size_tab encodes the same information as could be computed (at
  * unacceptable cost in some code paths) by index2size_compute().
  */
 extern size_t const	index2size_tab[NSIZES];
 /*
  * size2index_tab is a compact lookup table that rounds request sizes up to
@@ -444,37 +482,41 @@
 arena_t	*a0get(void);
 void	*a0malloc(size_t size);
 void	a0dalloc(void *ptr);
 void	*bootstrap_malloc(size_t size);
 void	*bootstrap_calloc(size_t num, size_t size);
 void	bootstrap_free(void *ptr);
-arena_t	*arenas_extend(unsigned ind);
-arena_t	*arena_init(unsigned ind);
 unsigned	narenas_total_get(void);
-arena_t	*arena_get_hard(tsd_t *tsd, unsigned ind, bool init_if_missing);
-arena_t	*arena_choose_hard(tsd_t *tsd);
+arena_t	*arena_init(tsdn_t *tsdn, unsigned ind);
+arena_tdata_t	*arena_tdata_get_hard(tsd_t *tsd, unsigned ind);
+arena_t	*arena_choose_hard(tsd_t *tsd, bool internal);
 void	arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind);
-unsigned	arena_nbound(unsigned ind);
 void	thread_allocated_cleanup(tsd_t *tsd);
 void	thread_deallocated_cleanup(tsd_t *tsd);
+void	iarena_cleanup(tsd_t *tsd);
 void	arena_cleanup(tsd_t *tsd);
-void	arenas_cache_cleanup(tsd_t *tsd);
-void	narenas_cache_cleanup(tsd_t *tsd);
-void	arenas_cache_bypass_cleanup(tsd_t *tsd);
+void	arenas_tdata_cleanup(tsd_t *tsd);
+void	narenas_tdata_cleanup(tsd_t *tsd);
+void	arenas_tdata_bypass_cleanup(tsd_t *tsd);
 void	jemalloc_prefork(void);
 void	jemalloc_postfork_parent(void);
 void	jemalloc_postfork_child(void);
 
+#include "jemalloc/internal/nstime.h"
 #include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
+#include "jemalloc/internal/spin.h"
 #include "jemalloc/internal/prng.h"
+#include "jemalloc/internal/ticker.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
+#include "jemalloc/internal/smoothstep.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
+#include "jemalloc/internal/witness.h"
 #include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/bitmap.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/arena.h"
 #include "jemalloc/internal/base.h"
@@ -489,86 +531,177 @@
 #include "jemalloc/internal/tsd.h"
 
 #undef JEMALLOC_H_EXTERNS
 /******************************************************************************/
 #define	JEMALLOC_H_INLINES
 
+#include "jemalloc/internal/nstime.h"
 #include "jemalloc/internal/valgrind.h"
 #include "jemalloc/internal/util.h"
 #include "jemalloc/internal/atomic.h"
+#include "jemalloc/internal/spin.h"
 #include "jemalloc/internal/prng.h"
+#include "jemalloc/internal/ticker.h"
 #include "jemalloc/internal/ckh.h"
 #include "jemalloc/internal/size_classes.h"
+#include "jemalloc/internal/smoothstep.h"
 #include "jemalloc/internal/stats.h"
 #include "jemalloc/internal/ctl.h"
-#include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/tsd.h"
+#include "jemalloc/internal/witness.h"
+#include "jemalloc/internal/mutex.h"
 #include "jemalloc/internal/mb.h"
 #include "jemalloc/internal/extent.h"
 #include "jemalloc/internal/base.h"
 #include "jemalloc/internal/rtree.h"
 #include "jemalloc/internal/pages.h"
 #include "jemalloc/internal/chunk.h"
 #include "jemalloc/internal/huge.h"
 
 #ifndef JEMALLOC_ENABLE_INLINE
+pszind_t	psz2ind(size_t psz);
+size_t	pind2sz_compute(pszind_t pind);
+size_t	pind2sz_lookup(pszind_t pind);
+size_t	pind2sz(pszind_t pind);
+size_t	psz2u(size_t psz);
 szind_t	size2index_compute(size_t size);
 szind_t	size2index_lookup(size_t size);
 szind_t	size2index(size_t size);
 size_t	index2size_compute(szind_t index);
 size_t	index2size_lookup(szind_t index);
 size_t	index2size(szind_t index);
 size_t	s2u_compute(size_t size);
 size_t	s2u_lookup(size_t size);
 size_t	s2u(size_t size);
 size_t	sa2u(size_t size, size_t alignment);
+arena_t	*arena_choose_impl(tsd_t *tsd, arena_t *arena, bool internal);
 arena_t	*arena_choose(tsd_t *tsd, arena_t *arena);
-arena_t	*arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
+arena_t	*arena_ichoose(tsd_t *tsd, arena_t *arena);
+arena_tdata_t	*arena_tdata_get(tsd_t *tsd, unsigned ind,
     bool refresh_if_missing);
+arena_t	*arena_get(tsdn_t *tsdn, unsigned ind, bool init_if_missing);
+ticker_t	*decay_ticker_get(tsd_t *tsd, unsigned ind);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
+JEMALLOC_INLINE pszind_t
+psz2ind(size_t psz)
+{
+
+	if (unlikely(psz > HUGE_MAXCLASS))
+		return (NPSIZES);
+	{
+		pszind_t x = lg_floor((psz<<1)-1);
+		pszind_t shift = (x < LG_SIZE_CLASS_GROUP + LG_PAGE) ? 0 : x -
+		    (LG_SIZE_CLASS_GROUP + LG_PAGE);
+		pszind_t grp = shift << LG_SIZE_CLASS_GROUP;
+
+		pszind_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_PAGE + 1) ?
+		    LG_PAGE : x - LG_SIZE_CLASS_GROUP - 1;
+
+		size_t delta_inverse_mask = ZI(-1) << lg_delta;
+		pszind_t mod = ((((psz-1) & delta_inverse_mask) >> lg_delta)) &
+		    ((ZU(1) << LG_SIZE_CLASS_GROUP) - 1);
+
+		pszind_t ind = grp + mod;
+		return (ind);
+	}
+}
+
+JEMALLOC_INLINE size_t
+pind2sz_compute(pszind_t pind)
+{
+
+	{
+		size_t grp = pind >> LG_SIZE_CLASS_GROUP;
+		size_t mod = pind & ((ZU(1) << LG_SIZE_CLASS_GROUP) - 1);
+
+		size_t grp_size_mask = ~((!!grp)-1);
+		size_t grp_size = ((ZU(1) << (LG_PAGE +
+		    (LG_SIZE_CLASS_GROUP-1))) << grp) & grp_size_mask;
+
+		size_t shift = (grp == 0) ? 1 : grp;
+		size_t lg_delta = shift + (LG_PAGE-1);
+		size_t mod_size = (mod+1) << lg_delta;
+
+		size_t sz = grp_size + mod_size;
+		return (sz);
+	}
+}
+
+JEMALLOC_INLINE size_t
+pind2sz_lookup(pszind_t pind)
+{
+	size_t ret = (size_t)pind2sz_tab[pind];
+	assert(ret == pind2sz_compute(pind));
+	return (ret);
+}
+
+JEMALLOC_INLINE size_t
+pind2sz(pszind_t pind)
+{
+
+	assert(pind < NPSIZES);
+	return (pind2sz_lookup(pind));
+}
+
+JEMALLOC_INLINE size_t
+psz2u(size_t psz)
+{
+
+	if (unlikely(psz > HUGE_MAXCLASS))
+		return (0);
+	{
+		size_t x = lg_floor((psz<<1)-1);
+		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_PAGE + 1) ?
+		    LG_PAGE : x - LG_SIZE_CLASS_GROUP - 1;
+		size_t delta = ZU(1) << lg_delta;
+		size_t delta_mask = delta - 1;
+		size_t usize = (psz + delta_mask) & ~delta_mask;
+		return (usize);
+	}
+}
+
 JEMALLOC_INLINE szind_t
 size2index_compute(size_t size)
 {
 
+	if (unlikely(size > HUGE_MAXCLASS))
+		return (NSIZES);
 #if (NTBINS != 0)
 	if (size <= (ZU(1) << LG_TINY_MAXCLASS)) {
-		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
-		size_t lg_ceil = lg_floor(pow2_ceil(size));
+		szind_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
+		szind_t lg_ceil = lg_floor(pow2_ceil_zu(size));
 		return (lg_ceil < lg_tmin ? 0 : lg_ceil - lg_tmin);
 	}
 #endif
 	{
-		size_t x = unlikely(ZI(size) < 0) ? ((size<<1) ?
-		    (ZU(1)<<(LG_SIZEOF_PTR+3)) : ((ZU(1)<<(LG_SIZEOF_PTR+3))-1))
-		    : lg_floor((size<<1)-1);
-		size_t shift = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? 0 :
+		szind_t x = lg_floor((size<<1)-1);
+		szind_t shift = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM) ? 0 :
 		    x - (LG_SIZE_CLASS_GROUP + LG_QUANTUM);
-		size_t grp = shift << LG_SIZE_CLASS_GROUP;
+		szind_t grp = shift << LG_SIZE_CLASS_GROUP;
 
-		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
+		szind_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
 		    ? LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
 
 		size_t delta_inverse_mask = ZI(-1) << lg_delta;
-		size_t mod = ((((size-1) & delta_inverse_mask) >> lg_delta)) &
+		szind_t mod = ((((size-1) & delta_inverse_mask) >> lg_delta)) &
 		    ((ZU(1) << LG_SIZE_CLASS_GROUP) - 1);
 
-		size_t index = NTBINS + grp + mod;
+		szind_t index = NTBINS + grp + mod;
 		return (index);
 	}
 }
 
 JEMALLOC_ALWAYS_INLINE szind_t
 size2index_lookup(size_t size)
 {
 
 	assert(size <= LOOKUP_MAXCLASS);
 	{
-		size_t ret = ((size_t)(size2index_tab[(size-1) >>
-		    LG_TINY_MIN]));
+		szind_t ret = (size2index_tab[(size-1) >> LG_TINY_MIN]);
 		assert(ret == size2index_compute(size));
 		return (ret);
 	}
 }
 
 JEMALLOC_ALWAYS_INLINE szind_t
@@ -625,24 +758,24 @@
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
 s2u_compute(size_t size)
 {
 
+	if (unlikely(size > HUGE_MAXCLASS))
+		return (0);
 #if (NTBINS > 0)
 	if (size <= (ZU(1) << LG_TINY_MAXCLASS)) {
 		size_t lg_tmin = LG_TINY_MAXCLASS - NTBINS + 1;
-		size_t lg_ceil = lg_floor(pow2_ceil(size));
+		size_t lg_ceil = lg_floor(pow2_ceil_zu(size));
 		return (lg_ceil < lg_tmin ? (ZU(1) << lg_tmin) :
 		    (ZU(1) << lg_ceil));
 	}
 #endif
 	{
-		size_t x = unlikely(ZI(size) < 0) ? ((size<<1) ?
-		    (ZU(1)<<(LG_SIZEOF_PTR+3)) : ((ZU(1)<<(LG_SIZEOF_PTR+3))-1))
-		    : lg_floor((size<<1)-1);
+		size_t x = lg_floor((size<<1)-1);
 		size_t lg_delta = (x < LG_SIZE_CLASS_GROUP + LG_QUANTUM + 1)
 		    ?  LG_QUANTUM : x - LG_SIZE_CLASS_GROUP - 1;
 		size_t delta = ZU(1) << lg_delta;
 		size_t delta_mask = delta - 1;
 		size_t usize = (size + delta_mask) & ~delta_mask;
 		return (usize);
@@ -720,23 +853,22 @@
 		 * would need to allocate in order to guarantee the alignment.
 		 */
 		if (usize + large_pad + alignment - PAGE <= arena_maxrun)
 			return (usize);
 	}
 
-	/* Huge size class.  Beware of size_t overflow. */
+	/* Huge size class.  Beware of overflow. */
+
+	if (unlikely(alignment > HUGE_MAXCLASS))
+		return (0);
 
 	/*
 	 * We can't achieve subchunk alignment, so round up alignment to the
 	 * minimum that can actually be supported.
 	 */
 	alignment = CHUNK_CEILING(alignment);
-	if (alignment == 0) {
-		/* size_t overflow. */
-		return (0);
-	}
 
 	/* Make sure result is a huge size class. */
 	if (size <= chunksize)
 		usize = chunksize;
 	else {
 		usize = s2u(size);
@@ -756,51 +888,90 @@
 	}
 	return (usize);
 }
 
 /* Choose an arena based on a per-thread value. */
 JEMALLOC_INLINE arena_t *
-arena_choose(tsd_t *tsd, arena_t *arena)
+arena_choose_impl(tsd_t *tsd, arena_t *arena, bool internal)
 {
 	arena_t *ret;
 
 	if (arena != NULL)
 		return (arena);
 
-	if (unlikely((ret = tsd_arena_get(tsd)) == NULL))
-		ret = arena_choose_hard(tsd);
+	ret = internal ? tsd_iarena_get(tsd) : tsd_arena_get(tsd);
+	if (unlikely(ret == NULL))
+		ret = arena_choose_hard(tsd, internal);
 
 	return (ret);
 }
 
 JEMALLOC_INLINE arena_t *
-arena_get(tsd_t *tsd, unsigned ind, bool init_if_missing,
-    bool refresh_if_missing)
+arena_choose(tsd_t *tsd, arena_t *arena)
 {
-	arena_t *arena;
-	arena_t **arenas_cache = tsd_arenas_cache_get(tsd);
 
-	/* init_if_missing requires refresh_if_missing. */
-	assert(!init_if_missing || refresh_if_missing);
+	return (arena_choose_impl(tsd, arena, false));
+}
+
+JEMALLOC_INLINE arena_t *
+arena_ichoose(tsd_t *tsd, arena_t *arena)
+{
 
-	if (unlikely(arenas_cache == NULL)) {
-		/* arenas_cache hasn't been initialized yet. */
-		return (arena_get_hard(tsd, ind, init_if_missing));
+	return (arena_choose_impl(tsd, arena, true));
+}
+
+JEMALLOC_INLINE arena_tdata_t *
+arena_tdata_get(tsd_t *tsd, unsigned ind, bool refresh_if_missing)
+{
+	arena_tdata_t *tdata;
+	arena_tdata_t *arenas_tdata = tsd_arenas_tdata_get(tsd);
+
+	if (unlikely(arenas_tdata == NULL)) {
+		/* arenas_tdata hasn't been initialized yet. */
+		return (arena_tdata_get_hard(tsd, ind));
 	}
-	if (unlikely(ind >= tsd_narenas_cache_get(tsd))) {
+	if (unlikely(ind >= tsd_narenas_tdata_get(tsd))) {
 		/*
-		 * ind is invalid, cache is old (too small), or arena to be
+		 * ind is invalid, cache is old (too small), or tdata to be
 		 * initialized.
 		 */
-		return (refresh_if_missing ? arena_get_hard(tsd, ind,
-		    init_if_missing) : NULL);
+		return (refresh_if_missing ? arena_tdata_get_hard(tsd, ind) :
+		    NULL);
 	}
-	arena = arenas_cache[ind];
-	if (likely(arena != NULL) || !refresh_if_missing)
-		return (arena);
-	return (arena_get_hard(tsd, ind, init_if_missing));
+
+	tdata = &arenas_tdata[ind];
+	if (likely(tdata != NULL) || !refresh_if_missing)
+		return (tdata);
+	return (arena_tdata_get_hard(tsd, ind));
+}
+
+JEMALLOC_INLINE arena_t *
+arena_get(tsdn_t *tsdn, unsigned ind, bool init_if_missing)
+{
+	arena_t *ret;
+
+	assert(ind <= MALLOCX_ARENA_MAX);
+
+	ret = arenas[ind];
+	if (unlikely(ret == NULL)) {
+		ret = atomic_read_p((void *)&arenas[ind]);
+		if (init_if_missing && unlikely(ret == NULL))
+			ret = arena_init(tsdn, ind);
+	}
+	return (ret);
+}
+
+JEMALLOC_INLINE ticker_t *
+decay_ticker_get(tsd_t *tsd, unsigned ind)
+{
+	arena_tdata_t *tdata;
+
+	tdata = arena_tdata_get(tsd, ind, true);
+	if (unlikely(tdata == NULL))
+		return (NULL);
+	return (&tdata->decay_ticker);
 }
 #endif
 
 #include "jemalloc/internal/bitmap.h"
 /*
  * Include portions of arena.h interleaved with tcache.h in order to resolve
@@ -815,42 +986,42 @@
 #undef JEMALLOC_ARENA_INLINE_B
 #include "jemalloc/internal/hash.h"
 #include "jemalloc/internal/quarantine.h"
 
 #ifndef JEMALLOC_ENABLE_INLINE
 arena_t	*iaalloc(const void *ptr);
-size_t	isalloc(const void *ptr, bool demote);
-void	*iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache,
-    bool is_metadata, arena_t *arena);
-void	*imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
-void	*imalloc(tsd_t *tsd, size_t size);
-void	*icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena);
-void	*icalloc(tsd_t *tsd, size_t size);
-void	*ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+size_t	isalloc(tsdn_t *tsdn, const void *ptr, bool demote);
+void	*iallocztm(tsdn_t *tsdn, size_t size, szind_t ind, bool zero,
+    tcache_t *tcache, bool is_metadata, arena_t *arena, bool slow_path);
+void	*ialloc(tsd_t *tsd, size_t size, szind_t ind, bool zero,
+    bool slow_path);
+void	*ipallocztm(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     tcache_t *tcache, bool is_metadata, arena_t *arena);
-void	*ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+void	*ipalloct(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     tcache_t *tcache, arena_t *arena);
 void	*ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero);
-size_t	ivsalloc(const void *ptr, bool demote);
+size_t	ivsalloc(tsdn_t *tsdn, const void *ptr, bool demote);
 size_t	u2rz(size_t usize);
-size_t	p2rz(const void *ptr);
-void	idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata);
-void	idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache);
+size_t	p2rz(tsdn_t *tsdn, const void *ptr);
+void	idalloctm(tsdn_t *tsdn, void *ptr, tcache_t *tcache, bool is_metadata,
+    bool slow_path);
 void	idalloc(tsd_t *tsd, void *ptr);
-void	iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache);
-void	isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
-void	isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache);
+void	iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path);
+void	isdalloct(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
+    bool slow_path);
+void	isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache,
+    bool slow_path);
 void	*iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
     size_t extra, size_t alignment, bool zero, tcache_t *tcache,
     arena_t *arena);
 void	*iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
     size_t alignment, bool zero, tcache_t *tcache, arena_t *arena);
 void	*iralloc(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
     size_t alignment, bool zero);
-bool	ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra,
-    size_t alignment, bool zero);
+bool	ixalloc(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size,
+    size_t extra, size_t alignment, bool zero);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_C_))
 JEMALLOC_ALWAYS_INLINE arena_t *
 iaalloc(const void *ptr)
 {
@@ -859,118 +1030,103 @@
 
 	return (arena_aalloc(ptr));
 }
 
 /*
  * Typical usage:
+ *   tsdn_t *tsdn = [...]
  *   void *ptr = [...]
- *   size_t sz = isalloc(ptr, config_prof);
+ *   size_t sz = isalloc(tsdn, ptr, config_prof);
  */
 JEMALLOC_ALWAYS_INLINE size_t
-isalloc(const void *ptr, bool demote)
+isalloc(tsdn_t *tsdn, const void *ptr, bool demote)
 {
 
 	assert(ptr != NULL);
 	/* Demotion only makes sense if config_prof is true. */
 	assert(config_prof || !demote);
 
-	return (arena_salloc(ptr, demote));
+	return (arena_salloc(tsdn, ptr, demote));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-iallocztm(tsd_t *tsd, size_t size, bool zero, tcache_t *tcache, bool is_metadata,
-    arena_t *arena)
+iallocztm(tsdn_t *tsdn, size_t size, szind_t ind, bool zero, tcache_t *tcache,
+    bool is_metadata, arena_t *arena, bool slow_path)
 {
 	void *ret;
 
 	assert(size != 0);
+	assert(!is_metadata || tcache == NULL);
+	assert(!is_metadata || arena == NULL || arena->ind < narenas_auto);
 
-	ret = arena_malloc(tsd, arena, size, zero, tcache);
+	ret = arena_malloc(tsdn, arena, size, ind, zero, tcache, slow_path);
 	if (config_stats && is_metadata && likely(ret != NULL)) {
-		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
-		    config_prof));
+		arena_metadata_allocated_add(iaalloc(ret),
+		    isalloc(tsdn, ret, config_prof));
 	}
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-imalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
+ialloc(tsd_t *tsd, size_t size, szind_t ind, bool zero, bool slow_path)
 {
 
-	return (iallocztm(tsd, size, false, tcache, false, arena));
+	return (iallocztm(tsd_tsdn(tsd), size, ind, zero, tcache_get(tsd, true),
+	    false, NULL, slow_path));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-imalloc(tsd_t *tsd, size_t size)
-{
-
-	return (iallocztm(tsd, size, false, tcache_get(tsd, true), false, NULL));
-}
-
-JEMALLOC_ALWAYS_INLINE void *
-icalloct(tsd_t *tsd, size_t size, tcache_t *tcache, arena_t *arena)
-{
-
-	return (iallocztm(tsd, size, true, tcache, false, arena));
-}
-
-JEMALLOC_ALWAYS_INLINE void *
-icalloc(tsd_t *tsd, size_t size)
-{
-
-	return (iallocztm(tsd, size, true, tcache_get(tsd, true), false, NULL));
-}
-
-JEMALLOC_ALWAYS_INLINE void *
-ipallocztm(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+ipallocztm(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     tcache_t *tcache, bool is_metadata, arena_t *arena)
 {
 	void *ret;
 
 	assert(usize != 0);
 	assert(usize == sa2u(usize, alignment));
+	assert(!is_metadata || tcache == NULL);
+	assert(!is_metadata || arena == NULL || arena->ind < narenas_auto);
 
-	ret = arena_palloc(tsd, arena, usize, alignment, zero, tcache);
+	ret = arena_palloc(tsdn, arena, usize, alignment, zero, tcache);
 	assert(ALIGNMENT_ADDR2BASE(ret, alignment) == ret);
 	if (config_stats && is_metadata && likely(ret != NULL)) {
-		arena_metadata_allocated_add(iaalloc(ret), isalloc(ret,
+		arena_metadata_allocated_add(iaalloc(ret), isalloc(tsdn, ret,
 		    config_prof));
 	}
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-ipalloct(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
+ipalloct(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
     tcache_t *tcache, arena_t *arena)
 {
 
-	return (ipallocztm(tsd, usize, alignment, zero, tcache, false, arena));
+	return (ipallocztm(tsdn, usize, alignment, zero, tcache, false, arena));
 }
 
 JEMALLOC_ALWAYS_INLINE void *
 ipalloc(tsd_t *tsd, size_t usize, size_t alignment, bool zero)
 {
 
-	return (ipallocztm(tsd, usize, alignment, zero, tcache_get(tsd,
-	    NULL), false, NULL));
+	return (ipallocztm(tsd_tsdn(tsd), usize, alignment, zero,
+	    tcache_get(tsd, true), false, NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE size_t
-ivsalloc(const void *ptr, bool demote)
+ivsalloc(tsdn_t *tsdn, const void *ptr, bool demote)
 {
 	extent_node_t *node;
 
 	/* Return 0 if ptr is not within a chunk managed by jemalloc. */
 	node = chunk_lookup(ptr, false);
 	if (node == NULL)
 		return (0);
 	/* Only arena chunks should be looked up via interior pointers. */
 	assert(extent_node_addr_get(node) == ptr ||
 	    extent_node_achunk_get(node));
 
-	return (isalloc(ptr, demote));
+	return (isalloc(tsdn, ptr, demote));
 }
 
 JEMALLOC_INLINE size_t
 u2rz(size_t usize)
 {
 	size_t ret;
@@ -982,102 +1138,100 @@
 		ret = 0;
 
 	return (ret);
 }
 
 JEMALLOC_INLINE size_t
-p2rz(const void *ptr)
+p2rz(tsdn_t *tsdn, const void *ptr)
 {
-	size_t usize = isalloc(ptr, false);
+	size_t usize = isalloc(tsdn, ptr, false);
 
 	return (u2rz(usize));
 }
 
 JEMALLOC_ALWAYS_INLINE void
-idalloctm(tsd_t *tsd, void *ptr, tcache_t *tcache, bool is_metadata)
+idalloctm(tsdn_t *tsdn, void *ptr, tcache_t *tcache, bool is_metadata,
+    bool slow_path)
 {
 
 	assert(ptr != NULL);
+	assert(!is_metadata || tcache == NULL);
+	assert(!is_metadata || iaalloc(ptr)->ind < narenas_auto);
 	if (config_stats && is_metadata) {
-		arena_metadata_allocated_sub(iaalloc(ptr), isalloc(ptr,
+		arena_metadata_allocated_sub(iaalloc(ptr), isalloc(tsdn, ptr,
 		    config_prof));
 	}
 
-	arena_dalloc(tsd, ptr, tcache);
-}
-
-JEMALLOC_ALWAYS_INLINE void
-idalloct(tsd_t *tsd, void *ptr, tcache_t *tcache)
-{
-
-	idalloctm(tsd, ptr, tcache, false);
+	arena_dalloc(tsdn, ptr, tcache, slow_path);
 }
 
 JEMALLOC_ALWAYS_INLINE void
 idalloc(tsd_t *tsd, void *ptr)
 {
 
-	idalloctm(tsd, ptr, tcache_get(tsd, false), false);
+	idalloctm(tsd_tsdn(tsd), ptr, tcache_get(tsd, false), false, true);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache)
+iqalloc(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path)
 {
 
-	if (config_fill && unlikely(opt_quarantine))
+	if (slow_path && config_fill && unlikely(opt_quarantine))
 		quarantine(tsd, ptr);
 	else
-		idalloctm(tsd, ptr, tcache, false);
+		idalloctm(tsd_tsdn(tsd), ptr, tcache, false, slow_path);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-isdalloct(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
+isdalloct(tsdn_t *tsdn, void *ptr, size_t size, tcache_t *tcache,
+    bool slow_path)
 {
 
-	arena_sdalloc(tsd, ptr, size, tcache);
+	arena_sdalloc(tsdn, ptr, size, tcache, slow_path);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache)
+isqalloc(tsd_t *tsd, void *ptr, size_t size, tcache_t *tcache, bool slow_path)
 {
 
-	if (config_fill && unlikely(opt_quarantine))
+	if (slow_path && config_fill && unlikely(opt_quarantine))
 		quarantine(tsd, ptr);
 	else
-		isdalloct(tsd, ptr, size, tcache);
+		isdalloct(tsd_tsdn(tsd), ptr, size, tcache, slow_path);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
 iralloct_realign(tsd_t *tsd, void *ptr, size_t oldsize, size_t size,
     size_t extra, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena)
 {
 	void *p;
 	size_t usize, copysize;
 
 	usize = sa2u(size + extra, alignment);
-	if (usize == 0)
+	if (unlikely(usize == 0 || usize > HUGE_MAXCLASS))
 		return (NULL);
-	p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
+	p = ipalloct(tsd_tsdn(tsd), usize, alignment, zero, tcache, arena);
 	if (p == NULL) {
 		if (extra == 0)
 			return (NULL);
 		/* Try again, without extra this time. */
 		usize = sa2u(size, alignment);
-		if (usize == 0)
+		if (unlikely(usize == 0 || usize > HUGE_MAXCLASS))
 			return (NULL);
-		p = ipalloct(tsd, usize, alignment, zero, tcache, arena);
+		p = ipalloct(tsd_tsdn(tsd), usize, alignment, zero, tcache,
+		    arena);
 		if (p == NULL)
 			return (NULL);
 	}
 	/*
 	 * Copy at most size bytes (not size+extra), since the caller has no
 	 * expectation that the extra bytes will be reliably preserved.
 	 */
 	copysize = (size < oldsize) ? size : oldsize;
 	memcpy(p, ptr, copysize);
-	isqalloc(tsd, ptr, oldsize, tcache);
+	isqalloc(tsd, ptr, oldsize, tcache, true);
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
 iralloct(tsd_t *tsd, void *ptr, size_t oldsize, size_t size, size_t alignment,
     bool zero, tcache_t *tcache, arena_t *arena)
@@ -1107,26 +1261,26 @@
 
 	return (iralloct(tsd, ptr, oldsize, size, alignment, zero,
 	    tcache_get(tsd, true), NULL));
 }
 
 JEMALLOC_ALWAYS_INLINE bool
-ixalloc(void *ptr, size_t oldsize, size_t size, size_t extra, size_t alignment,
-    bool zero)
+ixalloc(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size, size_t extra,
+    size_t alignment, bool zero)
 {
 
 	assert(ptr != NULL);
 	assert(size != 0);
 
 	if (alignment != 0 && ((uintptr_t)ptr & ((uintptr_t)alignment-1))
 	    != 0) {
 		/* Existing object alignment is inadequate. */
 		return (true);
 	}
 
-	return (arena_ralloc_no_move(ptr, oldsize, size, extra, zero));
+	return (arena_ralloc_no_move(tsdn, ptr, oldsize, size, extra, zero));
 }
 #endif
 
 #include "jemalloc/internal/prof.h"
 
 #undef JEMALLOC_H_INLINES
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/mb.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/mb.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/mb.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/mb.h	2017-01-31 23:32:23.000000000 +0800
@@ -39,23 +39,23 @@
 	    "cpuid;"
 	    "popa;"
 	    : /* Outputs. */
 	    : /* Inputs. */
 	    : "memory" /* Clobbers. */
 	    );
-#else
+#  else
 	/*
 	 * This is hopefully enough to keep the compiler from reordering
 	 * instructions around this one.
 	 */
 	asm volatile ("nop;"
 	    : /* Outputs. */
 	    : /* Inputs. */
 	    : "memory" /* Clobbers. */
 	    );
-#endif
+#  endif
 }
 #elif (defined(__amd64__) || defined(__x86_64__))
 JEMALLOC_INLINE void
 mb_write(void)
 {
 
@@ -101,15 +101,15 @@
  */
 JEMALLOC_INLINE void
 mb_write(void)
 {
 	malloc_mutex_t mtx;
 
-	malloc_mutex_init(&mtx);
-	malloc_mutex_lock(&mtx);
-	malloc_mutex_unlock(&mtx);
+	malloc_mutex_init(&mtx, "mb", WITNESS_RANK_OMIT);
+	malloc_mutex_lock(TSDN_NULL, &mtx);
+	malloc_mutex_unlock(TSDN_NULL, &mtx);
 }
 #endif
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/mutex.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/mutex.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/mutex.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/mutex.h	2017-01-31 23:32:23.000000000 +0800
@@ -2,24 +2,31 @@
 #ifdef JEMALLOC_H_TYPES
 
 typedef struct malloc_mutex_s malloc_mutex_t;
 
 #ifdef _WIN32
 #  define MALLOC_MUTEX_INITIALIZER
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
+#  define MALLOC_MUTEX_INITIALIZER					\
+     {OS_UNFAIR_LOCK_INIT, WITNESS_INITIALIZER(WITNESS_RANK_OMIT)}
 #elif (defined(JEMALLOC_OSSPIN))
-#  define MALLOC_MUTEX_INITIALIZER {0}
+#  define MALLOC_MUTEX_INITIALIZER {0, WITNESS_INITIALIZER(WITNESS_RANK_OMIT)}
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
-#  define MALLOC_MUTEX_INITIALIZER {PTHREAD_MUTEX_INITIALIZER, NULL}
+#  define MALLOC_MUTEX_INITIALIZER					\
+    {PTHREAD_MUTEX_INITIALIZER, NULL, WITNESS_INITIALIZER(WITNESS_RANK_OMIT)}
 #else
 #  if (defined(JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP) &&		\
        defined(PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP))
 #    define MALLOC_MUTEX_TYPE PTHREAD_MUTEX_ADAPTIVE_NP
-#    define MALLOC_MUTEX_INITIALIZER {PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP}
+#    define MALLOC_MUTEX_INITIALIZER					\
+       {PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP,				\
+        WITNESS_INITIALIZER(WITNESS_RANK_OMIT)}
 #  else
 #    define MALLOC_MUTEX_TYPE PTHREAD_MUTEX_DEFAULT
-#    define MALLOC_MUTEX_INITIALIZER {PTHREAD_MUTEX_INITIALIZER}
+#    define MALLOC_MUTEX_INITIALIZER					\
+       {PTHREAD_MUTEX_INITIALIZER, WITNESS_INITIALIZER(WITNESS_RANK_OMIT)}
 #  endif
 #endif
 
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
@@ -28,20 +35,23 @@
 #ifdef _WIN32
 #  if _WIN32_WINNT >= 0x0600
 	SRWLOCK         	lock;
 #  else
 	CRITICAL_SECTION	lock;
 #  endif
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
+	os_unfair_lock		lock;
 #elif (defined(JEMALLOC_OSSPIN))
 	OSSpinLock		lock;
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 	pthread_mutex_t		lock;
 	malloc_mutex_t		*postponed_next;
 #else
 	pthread_mutex_t		lock;
 #endif
+	witness_t		witness;
 };
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
@@ -49,63 +59,89 @@
 extern bool isthreaded;
 #else
 #  undef isthreaded /* Undo private_namespace.h definition. */
 #  define isthreaded true
 #endif
 
-bool	malloc_mutex_init(malloc_mutex_t *mutex);
-void	malloc_mutex_prefork(malloc_mutex_t *mutex);
-void	malloc_mutex_postfork_parent(malloc_mutex_t *mutex);
-void	malloc_mutex_postfork_child(malloc_mutex_t *mutex);
-bool	mutex_boot(void);
+bool	malloc_mutex_init(malloc_mutex_t *mutex, const char *name,
+    witness_rank_t rank);
+void	malloc_mutex_prefork(tsdn_t *tsdn, malloc_mutex_t *mutex);
+void	malloc_mutex_postfork_parent(tsdn_t *tsdn, malloc_mutex_t *mutex);
+void	malloc_mutex_postfork_child(tsdn_t *tsdn, malloc_mutex_t *mutex);
+bool	malloc_mutex_boot(void);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
-void	malloc_mutex_lock(malloc_mutex_t *mutex);
-void	malloc_mutex_unlock(malloc_mutex_t *mutex);
+void	malloc_mutex_lock(tsdn_t *tsdn, malloc_mutex_t *mutex);
+void	malloc_mutex_unlock(tsdn_t *tsdn, malloc_mutex_t *mutex);
+void	malloc_mutex_assert_owner(tsdn_t *tsdn, malloc_mutex_t *mutex);
+void	malloc_mutex_assert_not_owner(tsdn_t *tsdn, malloc_mutex_t *mutex);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_MUTEX_C_))
 JEMALLOC_INLINE void
-malloc_mutex_lock(malloc_mutex_t *mutex)
+malloc_mutex_lock(tsdn_t *tsdn, malloc_mutex_t *mutex)
 {
 
 	if (isthreaded) {
+		witness_assert_not_owner(tsdn, &mutex->witness);
 #ifdef _WIN32
 #  if _WIN32_WINNT >= 0x0600
 		AcquireSRWLockExclusive(&mutex->lock);
 #  else
 		EnterCriticalSection(&mutex->lock);
 #  endif
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
+		os_unfair_lock_lock(&mutex->lock);
 #elif (defined(JEMALLOC_OSSPIN))
 		OSSpinLockLock(&mutex->lock);
 #else
 		pthread_mutex_lock(&mutex->lock);
 #endif
+		witness_lock(tsdn, &mutex->witness);
 	}
 }
 
 JEMALLOC_INLINE void
-malloc_mutex_unlock(malloc_mutex_t *mutex)
+malloc_mutex_unlock(tsdn_t *tsdn, malloc_mutex_t *mutex)
 {
 
 	if (isthreaded) {
+		witness_unlock(tsdn, &mutex->witness);
 #ifdef _WIN32
 #  if _WIN32_WINNT >= 0x0600
 		ReleaseSRWLockExclusive(&mutex->lock);
 #  else
 		LeaveCriticalSection(&mutex->lock);
 #  endif
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
+		os_unfair_lock_unlock(&mutex->lock);
 #elif (defined(JEMALLOC_OSSPIN))
 		OSSpinLockUnlock(&mutex->lock);
 #else
 		pthread_mutex_unlock(&mutex->lock);
 #endif
 	}
 }
+
+JEMALLOC_INLINE void
+malloc_mutex_assert_owner(tsdn_t *tsdn, malloc_mutex_t *mutex)
+{
+
+	if (isthreaded)
+		witness_assert_owner(tsdn, &mutex->witness);
+}
+
+JEMALLOC_INLINE void
+malloc_mutex_assert_not_owner(tsdn_t *tsdn, malloc_mutex_t *mutex)
+{
+
+	if (isthreaded)
+		witness_assert_not_owner(tsdn, &mutex->witness);
+}
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal: nstime.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/pages.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/pages.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/pages.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/pages.h	2017-01-31 23:32:23.000000000 +0800
@@ -6,19 +6,22 @@
 #ifdef JEMALLOC_H_STRUCTS
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
-void	*pages_map(void *addr, size_t size);
+void	*pages_map(void *addr, size_t size, bool *commit);
 void	pages_unmap(void *addr, size_t size);
 void	*pages_trim(void *addr, size_t alloc_size, size_t leadsize,
-    size_t size);
+    size_t size, bool *commit);
 bool	pages_commit(void *addr, size_t size);
 bool	pages_decommit(void *addr, size_t size);
 bool	pages_purge(void *addr, size_t size);
+bool	pages_huge(void *addr, size_t size);
+bool	pages_nohuge(void *addr, size_t size);
+void	pages_boot(void);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #endif /* JEMALLOC_H_INLINES */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal: ph.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/private_namespace.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/private_namespace.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/private_namespace.h	2017-09-27 23:00:17.538936195 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/private_namespace.h	2017-09-27 23:01:52.538932714 +0800
@@ -1,17 +1,20 @@
 #define	a0dalloc JEMALLOC_N(a0dalloc)
 #define	a0get JEMALLOC_N(a0get)
 #define	a0malloc JEMALLOC_N(a0malloc)
 #define	arena_aalloc JEMALLOC_N(arena_aalloc)
 #define	arena_alloc_junk_small JEMALLOC_N(arena_alloc_junk_small)
+#define	arena_basic_stats_merge JEMALLOC_N(arena_basic_stats_merge)
 #define	arena_bin_index JEMALLOC_N(arena_bin_index)
 #define	arena_bin_info JEMALLOC_N(arena_bin_info)
-#define	arena_bitselm_get JEMALLOC_N(arena_bitselm_get)
+#define	arena_bitselm_get_const JEMALLOC_N(arena_bitselm_get_const)
+#define	arena_bitselm_get_mutable JEMALLOC_N(arena_bitselm_get_mutable)
 #define	arena_boot JEMALLOC_N(arena_boot)
 #define	arena_choose JEMALLOC_N(arena_choose)
 #define	arena_choose_hard JEMALLOC_N(arena_choose_hard)
+#define	arena_choose_impl JEMALLOC_N(arena_choose_impl)
 #define	arena_chunk_alloc_huge JEMALLOC_N(arena_chunk_alloc_huge)
 #define	arena_chunk_cache_maybe_insert JEMALLOC_N(arena_chunk_cache_maybe_insert)
 #define	arena_chunk_cache_maybe_remove JEMALLOC_N(arena_chunk_cache_maybe_remove)
 #define	arena_chunk_dalloc_huge JEMALLOC_N(arena_chunk_dalloc_huge)
 #define	arena_chunk_ralloc_huge_expand JEMALLOC_N(arena_chunk_ralloc_huge_expand)
 #define	arena_chunk_ralloc_huge_shrink JEMALLOC_N(arena_chunk_ralloc_huge_shrink)
@@ -22,85 +25,103 @@
 #define	arena_dalloc_bin_junked_locked JEMALLOC_N(arena_dalloc_bin_junked_locked)
 #define	arena_dalloc_junk_large JEMALLOC_N(arena_dalloc_junk_large)
 #define	arena_dalloc_junk_small JEMALLOC_N(arena_dalloc_junk_small)
 #define	arena_dalloc_large JEMALLOC_N(arena_dalloc_large)
 #define	arena_dalloc_large_junked_locked JEMALLOC_N(arena_dalloc_large_junked_locked)
 #define	arena_dalloc_small JEMALLOC_N(arena_dalloc_small)
+#define	arena_decay_tick JEMALLOC_N(arena_decay_tick)
+#define	arena_decay_ticks JEMALLOC_N(arena_decay_ticks)
+#define	arena_decay_time_default_get JEMALLOC_N(arena_decay_time_default_get)
+#define	arena_decay_time_default_set JEMALLOC_N(arena_decay_time_default_set)
+#define	arena_decay_time_get JEMALLOC_N(arena_decay_time_get)
+#define	arena_decay_time_set JEMALLOC_N(arena_decay_time_set)
 #define	arena_dss_prec_get JEMALLOC_N(arena_dss_prec_get)
 #define	arena_dss_prec_set JEMALLOC_N(arena_dss_prec_set)
+#define	arena_extent_sn_next JEMALLOC_N(arena_extent_sn_next)
 #define	arena_get JEMALLOC_N(arena_get)
-#define	arena_get_hard JEMALLOC_N(arena_get_hard)
+#define	arena_ichoose JEMALLOC_N(arena_ichoose)
 #define	arena_init JEMALLOC_N(arena_init)
 #define	arena_lg_dirty_mult_default_get JEMALLOC_N(arena_lg_dirty_mult_default_get)
 #define	arena_lg_dirty_mult_default_set JEMALLOC_N(arena_lg_dirty_mult_default_set)
 #define	arena_lg_dirty_mult_get JEMALLOC_N(arena_lg_dirty_mult_get)
 #define	arena_lg_dirty_mult_set JEMALLOC_N(arena_lg_dirty_mult_set)
 #define	arena_malloc JEMALLOC_N(arena_malloc)
+#define	arena_malloc_hard JEMALLOC_N(arena_malloc_hard)
 #define	arena_malloc_large JEMALLOC_N(arena_malloc_large)
-#define	arena_malloc_small JEMALLOC_N(arena_malloc_small)
 #define	arena_mapbits_allocated_get JEMALLOC_N(arena_mapbits_allocated_get)
 #define	arena_mapbits_binind_get JEMALLOC_N(arena_mapbits_binind_get)
 #define	arena_mapbits_decommitted_get JEMALLOC_N(arena_mapbits_decommitted_get)
 #define	arena_mapbits_dirty_get JEMALLOC_N(arena_mapbits_dirty_get)
 #define	arena_mapbits_get JEMALLOC_N(arena_mapbits_get)
 #define	arena_mapbits_internal_set JEMALLOC_N(arena_mapbits_internal_set)
 #define	arena_mapbits_large_binind_set JEMALLOC_N(arena_mapbits_large_binind_set)
 #define	arena_mapbits_large_get JEMALLOC_N(arena_mapbits_large_get)
 #define	arena_mapbits_large_set JEMALLOC_N(arena_mapbits_large_set)
 #define	arena_mapbits_large_size_get JEMALLOC_N(arena_mapbits_large_size_get)
-#define	arena_mapbitsp_get JEMALLOC_N(arena_mapbitsp_get)
-#define	arena_mapbitsp_read JEMALLOC_N(arena_mapbitsp_read)
-#define	arena_mapbitsp_write JEMALLOC_N(arena_mapbitsp_write)
 #define	arena_mapbits_size_decode JEMALLOC_N(arena_mapbits_size_decode)
 #define	arena_mapbits_size_encode JEMALLOC_N(arena_mapbits_size_encode)
 #define	arena_mapbits_small_runind_get JEMALLOC_N(arena_mapbits_small_runind_get)
 #define	arena_mapbits_small_set JEMALLOC_N(arena_mapbits_small_set)
 #define	arena_mapbits_unallocated_set JEMALLOC_N(arena_mapbits_unallocated_set)
 #define	arena_mapbits_unallocated_size_get JEMALLOC_N(arena_mapbits_unallocated_size_get)
 #define	arena_mapbits_unallocated_size_set JEMALLOC_N(arena_mapbits_unallocated_size_set)
 #define	arena_mapbits_unzeroed_get JEMALLOC_N(arena_mapbits_unzeroed_get)
+#define	arena_mapbitsp_get_const JEMALLOC_N(arena_mapbitsp_get_const)
+#define	arena_mapbitsp_get_mutable JEMALLOC_N(arena_mapbitsp_get_mutable)
+#define	arena_mapbitsp_read JEMALLOC_N(arena_mapbitsp_read)
+#define	arena_mapbitsp_write JEMALLOC_N(arena_mapbitsp_write)
 #define	arena_maxrun JEMALLOC_N(arena_maxrun)
 #define	arena_maybe_purge JEMALLOC_N(arena_maybe_purge)
 #define	arena_metadata_allocated_add JEMALLOC_N(arena_metadata_allocated_add)
 #define	arena_metadata_allocated_get JEMALLOC_N(arena_metadata_allocated_get)
 #define	arena_metadata_allocated_sub JEMALLOC_N(arena_metadata_allocated_sub)
 #define	arena_migrate JEMALLOC_N(arena_migrate)
-#define	arena_miscelm_get JEMALLOC_N(arena_miscelm_get)
+#define	arena_miscelm_get_const JEMALLOC_N(arena_miscelm_get_const)
+#define	arena_miscelm_get_mutable JEMALLOC_N(arena_miscelm_get_mutable)
 #define	arena_miscelm_to_pageind JEMALLOC_N(arena_miscelm_to_pageind)
 #define	arena_miscelm_to_rpages JEMALLOC_N(arena_miscelm_to_rpages)
-#define	arena_nbound JEMALLOC_N(arena_nbound)
 #define	arena_new JEMALLOC_N(arena_new)
 #define	arena_node_alloc JEMALLOC_N(arena_node_alloc)
 #define	arena_node_dalloc JEMALLOC_N(arena_node_dalloc)
+#define	arena_nthreads_dec JEMALLOC_N(arena_nthreads_dec)
+#define	arena_nthreads_get JEMALLOC_N(arena_nthreads_get)
+#define	arena_nthreads_inc JEMALLOC_N(arena_nthreads_inc)
 #define	arena_palloc JEMALLOC_N(arena_palloc)
 #define	arena_postfork_child JEMALLOC_N(arena_postfork_child)
 #define	arena_postfork_parent JEMALLOC_N(arena_postfork_parent)
-#define	arena_prefork JEMALLOC_N(arena_prefork)
+#define	arena_prefork0 JEMALLOC_N(arena_prefork0)
+#define	arena_prefork1 JEMALLOC_N(arena_prefork1)
+#define	arena_prefork2 JEMALLOC_N(arena_prefork2)
+#define	arena_prefork3 JEMALLOC_N(arena_prefork3)
 #define	arena_prof_accum JEMALLOC_N(arena_prof_accum)
 #define	arena_prof_accum_impl JEMALLOC_N(arena_prof_accum_impl)
 #define	arena_prof_accum_locked JEMALLOC_N(arena_prof_accum_locked)
 #define	arena_prof_promoted JEMALLOC_N(arena_prof_promoted)
 #define	arena_prof_tctx_get JEMALLOC_N(arena_prof_tctx_get)
 #define	arena_prof_tctx_reset JEMALLOC_N(arena_prof_tctx_reset)
 #define	arena_prof_tctx_set JEMALLOC_N(arena_prof_tctx_set)
 #define	arena_ptr_small_binind_get JEMALLOC_N(arena_ptr_small_binind_get)
-#define	arena_purge_all JEMALLOC_N(arena_purge_all)
+#define	arena_purge JEMALLOC_N(arena_purge)
 #define	arena_quarantine_junk_small JEMALLOC_N(arena_quarantine_junk_small)
 #define	arena_ralloc JEMALLOC_N(arena_ralloc)
 #define	arena_ralloc_junk_large JEMALLOC_N(arena_ralloc_junk_large)
 #define	arena_ralloc_no_move JEMALLOC_N(arena_ralloc_no_move)
 #define	arena_rd_to_miscelm JEMALLOC_N(arena_rd_to_miscelm)
 #define	arena_redzone_corruption JEMALLOC_N(arena_redzone_corruption)
+#define	arena_reset JEMALLOC_N(arena_reset)
 #define	arena_run_regind JEMALLOC_N(arena_run_regind)
 #define	arena_run_to_miscelm JEMALLOC_N(arena_run_to_miscelm)
 #define	arena_salloc JEMALLOC_N(arena_salloc)
-#define	arenas_cache_bypass_cleanup JEMALLOC_N(arenas_cache_bypass_cleanup)
-#define	arenas_cache_cleanup JEMALLOC_N(arenas_cache_cleanup)
 #define	arena_sdalloc JEMALLOC_N(arena_sdalloc)
 #define	arena_stats_merge JEMALLOC_N(arena_stats_merge)
 #define	arena_tcache_fill_small JEMALLOC_N(arena_tcache_fill_small)
+#define	arena_tdata_get JEMALLOC_N(arena_tdata_get)
+#define	arena_tdata_get_hard JEMALLOC_N(arena_tdata_get_hard)
+#define	arenas JEMALLOC_N(arenas)
+#define	arenas_tdata_bypass_cleanup JEMALLOC_N(arenas_tdata_bypass_cleanup)
+#define	arenas_tdata_cleanup JEMALLOC_N(arenas_tdata_cleanup)
 #define	atomic_add_p JEMALLOC_N(atomic_add_p)
 #define	atomic_add_u JEMALLOC_N(atomic_add_u)
 #define	atomic_add_uint32 JEMALLOC_N(atomic_add_uint32)
 #define	atomic_add_uint64 JEMALLOC_N(atomic_add_uint64)
 #define	atomic_add_z JEMALLOC_N(atomic_add_z)
 #define	atomic_cas_p JEMALLOC_N(atomic_cas_p)
@@ -110,22 +131,26 @@
 #define	atomic_cas_z JEMALLOC_N(atomic_cas_z)
 #define	atomic_sub_p JEMALLOC_N(atomic_sub_p)
 #define	atomic_sub_u JEMALLOC_N(atomic_sub_u)
 #define	atomic_sub_uint32 JEMALLOC_N(atomic_sub_uint32)
 #define	atomic_sub_uint64 JEMALLOC_N(atomic_sub_uint64)
 #define	atomic_sub_z JEMALLOC_N(atomic_sub_z)
+#define	atomic_write_p JEMALLOC_N(atomic_write_p)
+#define	atomic_write_u JEMALLOC_N(atomic_write_u)
+#define	atomic_write_uint32 JEMALLOC_N(atomic_write_uint32)
+#define	atomic_write_uint64 JEMALLOC_N(atomic_write_uint64)
+#define	atomic_write_z JEMALLOC_N(atomic_write_z)
 #define	base_alloc JEMALLOC_N(base_alloc)
 #define	base_boot JEMALLOC_N(base_boot)
 #define	base_postfork_child JEMALLOC_N(base_postfork_child)
 #define	base_postfork_parent JEMALLOC_N(base_postfork_parent)
 #define	base_prefork JEMALLOC_N(base_prefork)
 #define	base_stats_get JEMALLOC_N(base_stats_get)
 #define	bitmap_full JEMALLOC_N(bitmap_full)
 #define	bitmap_get JEMALLOC_N(bitmap_get)
 #define	bitmap_info_init JEMALLOC_N(bitmap_info_init)
-#define	bitmap_info_ngroups JEMALLOC_N(bitmap_info_ngroups)
 #define	bitmap_init JEMALLOC_N(bitmap_init)
 #define	bitmap_set JEMALLOC_N(bitmap_set)
 #define	bitmap_sfu JEMALLOC_N(bitmap_sfu)
 #define	bitmap_size JEMALLOC_N(bitmap_size)
 #define	bitmap_unset JEMALLOC_N(bitmap_unset)
 #define	bootstrap_calloc JEMALLOC_N(bootstrap_calloc)
@@ -136,38 +161,31 @@
 #define	chunk_alloc_base JEMALLOC_N(chunk_alloc_base)
 #define	chunk_alloc_cache JEMALLOC_N(chunk_alloc_cache)
 #define	chunk_alloc_dss JEMALLOC_N(chunk_alloc_dss)
 #define	chunk_alloc_mmap JEMALLOC_N(chunk_alloc_mmap)
 #define	chunk_alloc_wrapper JEMALLOC_N(chunk_alloc_wrapper)
 #define	chunk_boot JEMALLOC_N(chunk_boot)
-#define	chunk_dalloc_arena JEMALLOC_N(chunk_dalloc_arena)
 #define	chunk_dalloc_cache JEMALLOC_N(chunk_dalloc_cache)
 #define	chunk_dalloc_mmap JEMALLOC_N(chunk_dalloc_mmap)
 #define	chunk_dalloc_wrapper JEMALLOC_N(chunk_dalloc_wrapper)
 #define	chunk_deregister JEMALLOC_N(chunk_deregister)
 #define	chunk_dss_boot JEMALLOC_N(chunk_dss_boot)
-#define	chunk_dss_postfork_child JEMALLOC_N(chunk_dss_postfork_child)
-#define	chunk_dss_postfork_parent JEMALLOC_N(chunk_dss_postfork_parent)
+#define	chunk_dss_mergeable JEMALLOC_N(chunk_dss_mergeable)
 #define	chunk_dss_prec_get JEMALLOC_N(chunk_dss_prec_get)
 #define	chunk_dss_prec_set JEMALLOC_N(chunk_dss_prec_set)
-#define	chunk_dss_prefork JEMALLOC_N(chunk_dss_prefork)
 #define	chunk_hooks_default JEMALLOC_N(chunk_hooks_default)
 #define	chunk_hooks_get JEMALLOC_N(chunk_hooks_get)
 #define	chunk_hooks_set JEMALLOC_N(chunk_hooks_set)
 #define	chunk_in_dss JEMALLOC_N(chunk_in_dss)
 #define	chunk_lookup JEMALLOC_N(chunk_lookup)
 #define	chunk_npages JEMALLOC_N(chunk_npages)
-#define	chunk_postfork_child JEMALLOC_N(chunk_postfork_child)
-#define	chunk_postfork_parent JEMALLOC_N(chunk_postfork_parent)
-#define	chunk_prefork JEMALLOC_N(chunk_prefork)
-#define	chunk_purge_arena JEMALLOC_N(chunk_purge_arena)
 #define	chunk_purge_wrapper JEMALLOC_N(chunk_purge_wrapper)
 #define	chunk_register JEMALLOC_N(chunk_register)
+#define	chunks_rtree JEMALLOC_N(chunks_rtree)
 #define	chunksize JEMALLOC_N(chunksize)
 #define	chunksize_mask JEMALLOC_N(chunksize_mask)
-#define	chunks_rtree JEMALLOC_N(chunks_rtree)
 #define	ckh_count JEMALLOC_N(ckh_count)
 #define	ckh_delete JEMALLOC_N(ckh_delete)
 #define	ckh_insert JEMALLOC_N(ckh_insert)
 #define	ckh_iter JEMALLOC_N(ckh_iter)
 #define	ckh_new JEMALLOC_N(ckh_new)
 #define	ckh_pointer_hash JEMALLOC_N(ckh_pointer_hash)
@@ -180,29 +198,36 @@
 #define	ctl_bymib JEMALLOC_N(ctl_bymib)
 #define	ctl_byname JEMALLOC_N(ctl_byname)
 #define	ctl_nametomib JEMALLOC_N(ctl_nametomib)
 #define	ctl_postfork_child JEMALLOC_N(ctl_postfork_child)
 #define	ctl_postfork_parent JEMALLOC_N(ctl_postfork_parent)
 #define	ctl_prefork JEMALLOC_N(ctl_prefork)
+#define	decay_ticker_get JEMALLOC_N(decay_ticker_get)
 #define	dss_prec_names JEMALLOC_N(dss_prec_names)
 #define	extent_node_achunk_get JEMALLOC_N(extent_node_achunk_get)
 #define	extent_node_achunk_set JEMALLOC_N(extent_node_achunk_set)
 #define	extent_node_addr_get JEMALLOC_N(extent_node_addr_get)
 #define	extent_node_addr_set JEMALLOC_N(extent_node_addr_set)
 #define	extent_node_arena_get JEMALLOC_N(extent_node_arena_get)
 #define	extent_node_arena_set JEMALLOC_N(extent_node_arena_set)
+#define	extent_node_committed_get JEMALLOC_N(extent_node_committed_get)
+#define	extent_node_committed_set JEMALLOC_N(extent_node_committed_set)
 #define	extent_node_dirty_insert JEMALLOC_N(extent_node_dirty_insert)
 #define	extent_node_dirty_linkage_init JEMALLOC_N(extent_node_dirty_linkage_init)
 #define	extent_node_dirty_remove JEMALLOC_N(extent_node_dirty_remove)
 #define	extent_node_init JEMALLOC_N(extent_node_init)
 #define	extent_node_prof_tctx_get JEMALLOC_N(extent_node_prof_tctx_get)
 #define	extent_node_prof_tctx_set JEMALLOC_N(extent_node_prof_tctx_set)
 #define	extent_node_size_get JEMALLOC_N(extent_node_size_get)
 #define	extent_node_size_set JEMALLOC_N(extent_node_size_set)
+#define	extent_node_sn_get JEMALLOC_N(extent_node_sn_get)
+#define	extent_node_sn_set JEMALLOC_N(extent_node_sn_set)
 #define	extent_node_zeroed_get JEMALLOC_N(extent_node_zeroed_get)
 #define	extent_node_zeroed_set JEMALLOC_N(extent_node_zeroed_set)
+#define	extent_tree_ad_destroy JEMALLOC_N(extent_tree_ad_destroy)
+#define	extent_tree_ad_destroy_recurse JEMALLOC_N(extent_tree_ad_destroy_recurse)
 #define	extent_tree_ad_empty JEMALLOC_N(extent_tree_ad_empty)
 #define	extent_tree_ad_first JEMALLOC_N(extent_tree_ad_first)
 #define	extent_tree_ad_insert JEMALLOC_N(extent_tree_ad_insert)
 #define	extent_tree_ad_iter JEMALLOC_N(extent_tree_ad_iter)
 #define	extent_tree_ad_iter_recurse JEMALLOC_N(extent_tree_ad_iter_recurse)
 #define	extent_tree_ad_iter_start JEMALLOC_N(extent_tree_ad_iter_start)
@@ -214,29 +239,37 @@
 #define	extent_tree_ad_psearch JEMALLOC_N(extent_tree_ad_psearch)
 #define	extent_tree_ad_remove JEMALLOC_N(extent_tree_ad_remove)
 #define	extent_tree_ad_reverse_iter JEMALLOC_N(extent_tree_ad_reverse_iter)
 #define	extent_tree_ad_reverse_iter_recurse JEMALLOC_N(extent_tree_ad_reverse_iter_recurse)
 #define	extent_tree_ad_reverse_iter_start JEMALLOC_N(extent_tree_ad_reverse_iter_start)
 #define	extent_tree_ad_search JEMALLOC_N(extent_tree_ad_search)
-#define	extent_tree_szad_empty JEMALLOC_N(extent_tree_szad_empty)
-#define	extent_tree_szad_first JEMALLOC_N(extent_tree_szad_first)
-#define	extent_tree_szad_insert JEMALLOC_N(extent_tree_szad_insert)
-#define	extent_tree_szad_iter JEMALLOC_N(extent_tree_szad_iter)
-#define	extent_tree_szad_iter_recurse JEMALLOC_N(extent_tree_szad_iter_recurse)
-#define	extent_tree_szad_iter_start JEMALLOC_N(extent_tree_szad_iter_start)
-#define	extent_tree_szad_last JEMALLOC_N(extent_tree_szad_last)
-#define	extent_tree_szad_new JEMALLOC_N(extent_tree_szad_new)
-#define	extent_tree_szad_next JEMALLOC_N(extent_tree_szad_next)
-#define	extent_tree_szad_nsearch JEMALLOC_N(extent_tree_szad_nsearch)
-#define	extent_tree_szad_prev JEMALLOC_N(extent_tree_szad_prev)
-#define	extent_tree_szad_psearch JEMALLOC_N(extent_tree_szad_psearch)
-#define	extent_tree_szad_remove JEMALLOC_N(extent_tree_szad_remove)
-#define	extent_tree_szad_reverse_iter JEMALLOC_N(extent_tree_szad_reverse_iter)
-#define	extent_tree_szad_reverse_iter_recurse JEMALLOC_N(extent_tree_szad_reverse_iter_recurse)
-#define	extent_tree_szad_reverse_iter_start JEMALLOC_N(extent_tree_szad_reverse_iter_start)
-#define	extent_tree_szad_search JEMALLOC_N(extent_tree_szad_search)
+#define	extent_tree_szsnad_destroy JEMALLOC_N(extent_tree_szsnad_destroy)
+#define	extent_tree_szsnad_destroy_recurse JEMALLOC_N(extent_tree_szsnad_destroy_recurse)
+#define	extent_tree_szsnad_empty JEMALLOC_N(extent_tree_szsnad_empty)
+#define	extent_tree_szsnad_first JEMALLOC_N(extent_tree_szsnad_first)
+#define	extent_tree_szsnad_insert JEMALLOC_N(extent_tree_szsnad_insert)
+#define	extent_tree_szsnad_iter JEMALLOC_N(extent_tree_szsnad_iter)
+#define	extent_tree_szsnad_iter_recurse JEMALLOC_N(extent_tree_szsnad_iter_recurse)
+#define	extent_tree_szsnad_iter_start JEMALLOC_N(extent_tree_szsnad_iter_start)
+#define	extent_tree_szsnad_last JEMALLOC_N(extent_tree_szsnad_last)
+#define	extent_tree_szsnad_new JEMALLOC_N(extent_tree_szsnad_new)
+#define	extent_tree_szsnad_next JEMALLOC_N(extent_tree_szsnad_next)
+#define	extent_tree_szsnad_nsearch JEMALLOC_N(extent_tree_szsnad_nsearch)
+#define	extent_tree_szsnad_prev JEMALLOC_N(extent_tree_szsnad_prev)
+#define	extent_tree_szsnad_psearch JEMALLOC_N(extent_tree_szsnad_psearch)
+#define	extent_tree_szsnad_remove JEMALLOC_N(extent_tree_szsnad_remove)
+#define	extent_tree_szsnad_reverse_iter JEMALLOC_N(extent_tree_szsnad_reverse_iter)
+#define	extent_tree_szsnad_reverse_iter_recurse JEMALLOC_N(extent_tree_szsnad_reverse_iter_recurse)
+#define	extent_tree_szsnad_reverse_iter_start JEMALLOC_N(extent_tree_szsnad_reverse_iter_start)
+#define	extent_tree_szsnad_search JEMALLOC_N(extent_tree_szsnad_search)
+#define	ffs_llu JEMALLOC_N(ffs_llu)
+#define	ffs_lu JEMALLOC_N(ffs_lu)
+#define	ffs_u JEMALLOC_N(ffs_u)
+#define	ffs_u32 JEMALLOC_N(ffs_u32)
+#define	ffs_u64 JEMALLOC_N(ffs_u64)
+#define	ffs_zu JEMALLOC_N(ffs_zu)
 #define	get_errno JEMALLOC_N(get_errno)
 #define	hash JEMALLOC_N(hash)
 #define	hash_fmix_32 JEMALLOC_N(hash_fmix_32)
 #define	hash_fmix_64 JEMALLOC_N(hash_fmix_64)
 #define	hash_get_block_32 JEMALLOC_N(hash_get_block_32)
 #define	hash_get_block_64 JEMALLOC_N(hash_get_block_64)
@@ -254,25 +287,22 @@
 #define	huge_prof_tctx_reset JEMALLOC_N(huge_prof_tctx_reset)
 #define	huge_prof_tctx_set JEMALLOC_N(huge_prof_tctx_set)
 #define	huge_ralloc JEMALLOC_N(huge_ralloc)
 #define	huge_ralloc_no_move JEMALLOC_N(huge_ralloc_no_move)
 #define	huge_salloc JEMALLOC_N(huge_salloc)
 #define	iaalloc JEMALLOC_N(iaalloc)
+#define	ialloc JEMALLOC_N(ialloc)
 #define	iallocztm JEMALLOC_N(iallocztm)
-#define	icalloc JEMALLOC_N(icalloc)
-#define	icalloct JEMALLOC_N(icalloct)
+#define	iarena_cleanup JEMALLOC_N(iarena_cleanup)
 #define	idalloc JEMALLOC_N(idalloc)
-#define	idalloct JEMALLOC_N(idalloct)
 #define	idalloctm JEMALLOC_N(idalloctm)
-#define	imalloc JEMALLOC_N(imalloc)
-#define	imalloct JEMALLOC_N(imalloct)
+#define	in_valgrind JEMALLOC_N(in_valgrind)
 #define	index2size JEMALLOC_N(index2size)
 #define	index2size_compute JEMALLOC_N(index2size_compute)
 #define	index2size_lookup JEMALLOC_N(index2size_lookup)
 #define	index2size_tab JEMALLOC_N(index2size_tab)
-#define	in_valgrind JEMALLOC_N(in_valgrind)
 #define	ipalloc JEMALLOC_N(ipalloc)
 #define	ipalloct JEMALLOC_N(ipalloct)
 #define	ipallocztm JEMALLOC_N(ipallocztm)
 #define	iqalloc JEMALLOC_N(iqalloc)
 #define	iralloc JEMALLOC_N(iralloc)
 #define	iralloct JEMALLOC_N(iralloct)
@@ -285,13 +315,17 @@
 #define	ixalloc JEMALLOC_N(ixalloc)
 #define	jemalloc_postfork_child JEMALLOC_N(jemalloc_postfork_child)
 #define	jemalloc_postfork_parent JEMALLOC_N(jemalloc_postfork_parent)
 #define	jemalloc_prefork JEMALLOC_N(jemalloc_prefork)
 #define	large_maxclass JEMALLOC_N(large_maxclass)
 #define	lg_floor JEMALLOC_N(lg_floor)
+#define	lg_prof_sample JEMALLOC_N(lg_prof_sample)
 #define	malloc_cprintf JEMALLOC_N(malloc_cprintf)
+#define	malloc_mutex_assert_not_owner JEMALLOC_N(malloc_mutex_assert_not_owner)
+#define	malloc_mutex_assert_owner JEMALLOC_N(malloc_mutex_assert_owner)
+#define	malloc_mutex_boot JEMALLOC_N(malloc_mutex_boot)
 #define	malloc_mutex_init JEMALLOC_N(malloc_mutex_init)
 #define	malloc_mutex_lock JEMALLOC_N(malloc_mutex_lock)
 #define	malloc_mutex_postfork_child JEMALLOC_N(malloc_mutex_postfork_child)
 #define	malloc_mutex_postfork_parent JEMALLOC_N(malloc_mutex_postfork_parent)
 #define	malloc_mutex_prefork JEMALLOC_N(malloc_mutex_prefork)
 #define	malloc_mutex_unlock JEMALLOC_N(malloc_mutex_unlock)
@@ -307,18 +341,35 @@
 #define	malloc_vcprintf JEMALLOC_N(malloc_vcprintf)
 #define	malloc_vsnprintf JEMALLOC_N(malloc_vsnprintf)
 #define	malloc_write JEMALLOC_N(malloc_write)
 #define	map_bias JEMALLOC_N(map_bias)
 #define	map_misc_offset JEMALLOC_N(map_misc_offset)
 #define	mb_write JEMALLOC_N(mb_write)
-#define	mutex_boot JEMALLOC_N(mutex_boot)
-#define	narenas_cache_cleanup JEMALLOC_N(narenas_cache_cleanup)
+#define	narenas_auto JEMALLOC_N(narenas_auto)
+#define	narenas_tdata_cleanup JEMALLOC_N(narenas_tdata_cleanup)
 #define	narenas_total_get JEMALLOC_N(narenas_total_get)
 #define	ncpus JEMALLOC_N(ncpus)
 #define	nhbins JEMALLOC_N(nhbins)
+#define	nhclasses JEMALLOC_N(nhclasses)
+#define	nlclasses JEMALLOC_N(nlclasses)
+#define	nstime_add JEMALLOC_N(nstime_add)
+#define	nstime_compare JEMALLOC_N(nstime_compare)
+#define	nstime_copy JEMALLOC_N(nstime_copy)
+#define	nstime_divide JEMALLOC_N(nstime_divide)
+#define	nstime_idivide JEMALLOC_N(nstime_idivide)
+#define	nstime_imultiply JEMALLOC_N(nstime_imultiply)
+#define	nstime_init JEMALLOC_N(nstime_init)
+#define	nstime_init2 JEMALLOC_N(nstime_init2)
+#define	nstime_monotonic JEMALLOC_N(nstime_monotonic)
+#define	nstime_ns JEMALLOC_N(nstime_ns)
+#define	nstime_nsec JEMALLOC_N(nstime_nsec)
+#define	nstime_sec JEMALLOC_N(nstime_sec)
+#define	nstime_subtract JEMALLOC_N(nstime_subtract)
+#define	nstime_update JEMALLOC_N(nstime_update)
 #define	opt_abort JEMALLOC_N(opt_abort)
+#define	opt_decay_time JEMALLOC_N(opt_decay_time)
 #define	opt_dss JEMALLOC_N(opt_dss)
 #define	opt_junk JEMALLOC_N(opt_junk)
 #define	opt_junk_alloc JEMALLOC_N(opt_junk_alloc)
 #define	opt_junk_free JEMALLOC_N(opt_junk_free)
 #define	opt_lg_chunk JEMALLOC_N(opt_lg_chunk)
 #define	opt_lg_dirty_mult JEMALLOC_N(opt_lg_dirty_mult)
@@ -331,36 +382,57 @@
 #define	opt_prof_active JEMALLOC_N(opt_prof_active)
 #define	opt_prof_final JEMALLOC_N(opt_prof_final)
 #define	opt_prof_gdump JEMALLOC_N(opt_prof_gdump)
 #define	opt_prof_leak JEMALLOC_N(opt_prof_leak)
 #define	opt_prof_prefix JEMALLOC_N(opt_prof_prefix)
 #define	opt_prof_thread_active_init JEMALLOC_N(opt_prof_thread_active_init)
+#define	opt_purge JEMALLOC_N(opt_purge)
 #define	opt_quarantine JEMALLOC_N(opt_quarantine)
 #define	opt_redzone JEMALLOC_N(opt_redzone)
 #define	opt_stats_print JEMALLOC_N(opt_stats_print)
 #define	opt_tcache JEMALLOC_N(opt_tcache)
 #define	opt_utrace JEMALLOC_N(opt_utrace)
 #define	opt_xmalloc JEMALLOC_N(opt_xmalloc)
 #define	opt_zero JEMALLOC_N(opt_zero)
 #define	p2rz JEMALLOC_N(p2rz)
+#define	pages_boot JEMALLOC_N(pages_boot)
 #define	pages_commit JEMALLOC_N(pages_commit)
 #define	pages_decommit JEMALLOC_N(pages_decommit)
+#define	pages_huge JEMALLOC_N(pages_huge)
 #define	pages_map JEMALLOC_N(pages_map)
+#define	pages_nohuge JEMALLOC_N(pages_nohuge)
 #define	pages_purge JEMALLOC_N(pages_purge)
 #define	pages_trim JEMALLOC_N(pages_trim)
 #define	pages_unmap JEMALLOC_N(pages_unmap)
-#define	pow2_ceil JEMALLOC_N(pow2_ceil)
+#define	pind2sz JEMALLOC_N(pind2sz)
+#define	pind2sz_compute JEMALLOC_N(pind2sz_compute)
+#define	pind2sz_lookup JEMALLOC_N(pind2sz_lookup)
+#define	pind2sz_tab JEMALLOC_N(pind2sz_tab)
+#define	pow2_ceil_u32 JEMALLOC_N(pow2_ceil_u32)
+#define	pow2_ceil_u64 JEMALLOC_N(pow2_ceil_u64)
+#define	pow2_ceil_zu JEMALLOC_N(pow2_ceil_zu)
+#define	prng_lg_range_u32 JEMALLOC_N(prng_lg_range_u32)
+#define	prng_lg_range_u64 JEMALLOC_N(prng_lg_range_u64)
+#define	prng_lg_range_zu JEMALLOC_N(prng_lg_range_zu)
+#define	prng_range_u32 JEMALLOC_N(prng_range_u32)
+#define	prng_range_u64 JEMALLOC_N(prng_range_u64)
+#define	prng_range_zu JEMALLOC_N(prng_range_zu)
+#define	prng_state_next_u32 JEMALLOC_N(prng_state_next_u32)
+#define	prng_state_next_u64 JEMALLOC_N(prng_state_next_u64)
+#define	prng_state_next_zu JEMALLOC_N(prng_state_next_zu)
+#define	prof_active JEMALLOC_N(prof_active)
 #define	prof_active_get JEMALLOC_N(prof_active_get)
 #define	prof_active_get_unlocked JEMALLOC_N(prof_active_get_unlocked)
 #define	prof_active_set JEMALLOC_N(prof_active_set)
 #define	prof_alloc_prep JEMALLOC_N(prof_alloc_prep)
 #define	prof_alloc_rollback JEMALLOC_N(prof_alloc_rollback)
 #define	prof_backtrace JEMALLOC_N(prof_backtrace)
 #define	prof_boot0 JEMALLOC_N(prof_boot0)
 #define	prof_boot1 JEMALLOC_N(prof_boot1)
 #define	prof_boot2 JEMALLOC_N(prof_boot2)
+#define	prof_bt_count JEMALLOC_N(prof_bt_count)
 #define	prof_dump_header JEMALLOC_N(prof_dump_header)
 #define	prof_dump_open JEMALLOC_N(prof_dump_open)
 #define	prof_free JEMALLOC_N(prof_free)
 #define	prof_free_sampled_object JEMALLOC_N(prof_free_sampled_object)
 #define	prof_gdump JEMALLOC_N(prof_gdump)
 #define	prof_gdump_get JEMALLOC_N(prof_gdump_get)
@@ -372,35 +444,39 @@
 #define	prof_lookup JEMALLOC_N(prof_lookup)
 #define	prof_malloc JEMALLOC_N(prof_malloc)
 #define	prof_malloc_sample_object JEMALLOC_N(prof_malloc_sample_object)
 #define	prof_mdump JEMALLOC_N(prof_mdump)
 #define	prof_postfork_child JEMALLOC_N(prof_postfork_child)
 #define	prof_postfork_parent JEMALLOC_N(prof_postfork_parent)
-#define	prof_prefork JEMALLOC_N(prof_prefork)
+#define	prof_prefork0 JEMALLOC_N(prof_prefork0)
+#define	prof_prefork1 JEMALLOC_N(prof_prefork1)
 #define	prof_realloc JEMALLOC_N(prof_realloc)
 #define	prof_reset JEMALLOC_N(prof_reset)
 #define	prof_sample_accum_update JEMALLOC_N(prof_sample_accum_update)
 #define	prof_sample_threshold_update JEMALLOC_N(prof_sample_threshold_update)
 #define	prof_tctx_get JEMALLOC_N(prof_tctx_get)
 #define	prof_tctx_reset JEMALLOC_N(prof_tctx_reset)
 #define	prof_tctx_set JEMALLOC_N(prof_tctx_set)
 #define	prof_tdata_cleanup JEMALLOC_N(prof_tdata_cleanup)
+#define	prof_tdata_count JEMALLOC_N(prof_tdata_count)
 #define	prof_tdata_get JEMALLOC_N(prof_tdata_get)
 #define	prof_tdata_init JEMALLOC_N(prof_tdata_init)
 #define	prof_tdata_reinit JEMALLOC_N(prof_tdata_reinit)
 #define	prof_thread_active_get JEMALLOC_N(prof_thread_active_get)
 #define	prof_thread_active_init_get JEMALLOC_N(prof_thread_active_init_get)
 #define	prof_thread_active_init_set JEMALLOC_N(prof_thread_active_init_set)
 #define	prof_thread_active_set JEMALLOC_N(prof_thread_active_set)
 #define	prof_thread_name_get JEMALLOC_N(prof_thread_name_get)
 #define	prof_thread_name_set JEMALLOC_N(prof_thread_name_set)
+#define	psz2ind JEMALLOC_N(psz2ind)
+#define	psz2u JEMALLOC_N(psz2u)
+#define	purge_mode_names JEMALLOC_N(purge_mode_names)
 #define	quarantine JEMALLOC_N(quarantine)
 #define	quarantine_alloc_hook JEMALLOC_N(quarantine_alloc_hook)
 #define	quarantine_alloc_hook_work JEMALLOC_N(quarantine_alloc_hook_work)
 #define	quarantine_cleanup JEMALLOC_N(quarantine_cleanup)
-#define	register_zone JEMALLOC_N(register_zone)
 #define	rtree_child_read JEMALLOC_N(rtree_child_read)
 #define	rtree_child_read_hard JEMALLOC_N(rtree_child_read_hard)
 #define	rtree_child_tryread JEMALLOC_N(rtree_child_tryread)
 #define	rtree_delete JEMALLOC_N(rtree_delete)
 #define	rtree_get JEMALLOC_N(rtree_get)
 #define	rtree_new JEMALLOC_N(rtree_new)
@@ -410,32 +486,34 @@
 #define	rtree_subkey JEMALLOC_N(rtree_subkey)
 #define	rtree_subtree_read JEMALLOC_N(rtree_subtree_read)
 #define	rtree_subtree_read_hard JEMALLOC_N(rtree_subtree_read_hard)
 #define	rtree_subtree_tryread JEMALLOC_N(rtree_subtree_tryread)
 #define	rtree_val_read JEMALLOC_N(rtree_val_read)
 #define	rtree_val_write JEMALLOC_N(rtree_val_write)
+#define	run_quantize_ceil JEMALLOC_N(run_quantize_ceil)
+#define	run_quantize_floor JEMALLOC_N(run_quantize_floor)
 #define	s2u JEMALLOC_N(s2u)
 #define	s2u_compute JEMALLOC_N(s2u_compute)
 #define	s2u_lookup JEMALLOC_N(s2u_lookup)
 #define	sa2u JEMALLOC_N(sa2u)
 #define	set_errno JEMALLOC_N(set_errno)
 #define	size2index JEMALLOC_N(size2index)
 #define	size2index_compute JEMALLOC_N(size2index_compute)
 #define	size2index_lookup JEMALLOC_N(size2index_lookup)
 #define	size2index_tab JEMALLOC_N(size2index_tab)
+#define	spin_adaptive JEMALLOC_N(spin_adaptive)
+#define	spin_init JEMALLOC_N(spin_init)
 #define	stats_cactive JEMALLOC_N(stats_cactive)
 #define	stats_cactive_add JEMALLOC_N(stats_cactive_add)
 #define	stats_cactive_get JEMALLOC_N(stats_cactive_get)
 #define	stats_cactive_sub JEMALLOC_N(stats_cactive_sub)
 #define	stats_print JEMALLOC_N(stats_print)
 #define	tcache_alloc_easy JEMALLOC_N(tcache_alloc_easy)
 #define	tcache_alloc_large JEMALLOC_N(tcache_alloc_large)
 #define	tcache_alloc_small JEMALLOC_N(tcache_alloc_small)
 #define	tcache_alloc_small_hard JEMALLOC_N(tcache_alloc_small_hard)
-#define	tcache_arena_associate JEMALLOC_N(tcache_arena_associate)
-#define	tcache_arena_dissociate JEMALLOC_N(tcache_arena_dissociate)
 #define	tcache_arena_reassociate JEMALLOC_N(tcache_arena_reassociate)
 #define	tcache_bin_flush_large JEMALLOC_N(tcache_bin_flush_large)
 #define	tcache_bin_flush_small JEMALLOC_N(tcache_bin_flush_small)
 #define	tcache_bin_info JEMALLOC_N(tcache_bin_info)
 #define	tcache_boot JEMALLOC_N(tcache_boot)
 #define	tcache_cleanup JEMALLOC_N(tcache_cleanup)
@@ -448,52 +526,106 @@
 #define	tcache_event JEMALLOC_N(tcache_event)
 #define	tcache_event_hard JEMALLOC_N(tcache_event_hard)
 #define	tcache_flush JEMALLOC_N(tcache_flush)
 #define	tcache_get JEMALLOC_N(tcache_get)
 #define	tcache_get_hard JEMALLOC_N(tcache_get_hard)
 #define	tcache_maxclass JEMALLOC_N(tcache_maxclass)
-#define	tcaches JEMALLOC_N(tcaches)
 #define	tcache_salloc JEMALLOC_N(tcache_salloc)
+#define	tcache_stats_merge JEMALLOC_N(tcache_stats_merge)
+#define	tcaches JEMALLOC_N(tcaches)
 #define	tcaches_create JEMALLOC_N(tcaches_create)
 #define	tcaches_destroy JEMALLOC_N(tcaches_destroy)
 #define	tcaches_flush JEMALLOC_N(tcaches_flush)
 #define	tcaches_get JEMALLOC_N(tcaches_get)
-#define	tcache_stats_merge JEMALLOC_N(tcache_stats_merge)
 #define	thread_allocated_cleanup JEMALLOC_N(thread_allocated_cleanup)
 #define	thread_deallocated_cleanup JEMALLOC_N(thread_deallocated_cleanup)
+#define	ticker_copy JEMALLOC_N(ticker_copy)
+#define	ticker_init JEMALLOC_N(ticker_init)
+#define	ticker_read JEMALLOC_N(ticker_read)
+#define	ticker_tick JEMALLOC_N(ticker_tick)
+#define	ticker_ticks JEMALLOC_N(ticker_ticks)
 #define	tsd_arena_get JEMALLOC_N(tsd_arena_get)
 #define	tsd_arena_set JEMALLOC_N(tsd_arena_set)
+#define	tsd_arenap_get JEMALLOC_N(tsd_arenap_get)
+#define	tsd_arenas_tdata_bypass_get JEMALLOC_N(tsd_arenas_tdata_bypass_get)
+#define	tsd_arenas_tdata_bypass_set JEMALLOC_N(tsd_arenas_tdata_bypass_set)
+#define	tsd_arenas_tdata_bypassp_get JEMALLOC_N(tsd_arenas_tdata_bypassp_get)
+#define	tsd_arenas_tdata_get JEMALLOC_N(tsd_arenas_tdata_get)
+#define	tsd_arenas_tdata_set JEMALLOC_N(tsd_arenas_tdata_set)
+#define	tsd_arenas_tdatap_get JEMALLOC_N(tsd_arenas_tdatap_get)
 #define	tsd_boot JEMALLOC_N(tsd_boot)
 #define	tsd_boot0 JEMALLOC_N(tsd_boot0)
 #define	tsd_boot1 JEMALLOC_N(tsd_boot1)
 #define	tsd_booted JEMALLOC_N(tsd_booted)
+#define	tsd_booted_get JEMALLOC_N(tsd_booted_get)
 #define	tsd_cleanup JEMALLOC_N(tsd_cleanup)
 #define	tsd_cleanup_wrapper JEMALLOC_N(tsd_cleanup_wrapper)
 #define	tsd_fetch JEMALLOC_N(tsd_fetch)
+#define	tsd_fetch_impl JEMALLOC_N(tsd_fetch_impl)
 #define	tsd_get JEMALLOC_N(tsd_get)
-#define	tsd_wrapper_get JEMALLOC_N(tsd_wrapper_get)
-#define	tsd_wrapper_set JEMALLOC_N(tsd_wrapper_set)
+#define	tsd_get_allocates JEMALLOC_N(tsd_get_allocates)
+#define	tsd_iarena_get JEMALLOC_N(tsd_iarena_get)
+#define	tsd_iarena_set JEMALLOC_N(tsd_iarena_set)
+#define	tsd_iarenap_get JEMALLOC_N(tsd_iarenap_get)
 #define	tsd_initialized JEMALLOC_N(tsd_initialized)
 #define	tsd_init_check_recursion JEMALLOC_N(tsd_init_check_recursion)
 #define	tsd_init_finish JEMALLOC_N(tsd_init_finish)
 #define	tsd_init_head JEMALLOC_N(tsd_init_head)
+#define	tsd_narenas_tdata_get JEMALLOC_N(tsd_narenas_tdata_get)
+#define	tsd_narenas_tdata_set JEMALLOC_N(tsd_narenas_tdata_set)
+#define	tsd_narenas_tdatap_get JEMALLOC_N(tsd_narenas_tdatap_get)
+#define	tsd_wrapper_get JEMALLOC_N(tsd_wrapper_get)
+#define	tsd_wrapper_set JEMALLOC_N(tsd_wrapper_set)
 #define	tsd_nominal JEMALLOC_N(tsd_nominal)
+#define	tsd_prof_tdata_get JEMALLOC_N(tsd_prof_tdata_get)
+#define	tsd_prof_tdata_set JEMALLOC_N(tsd_prof_tdata_set)
+#define	tsd_prof_tdatap_get JEMALLOC_N(tsd_prof_tdatap_get)
 #define	tsd_quarantine_get JEMALLOC_N(tsd_quarantine_get)
 #define	tsd_quarantine_set JEMALLOC_N(tsd_quarantine_set)
+#define	tsd_quarantinep_get JEMALLOC_N(tsd_quarantinep_get)
 #define	tsd_set JEMALLOC_N(tsd_set)
 #define	tsd_tcache_enabled_get JEMALLOC_N(tsd_tcache_enabled_get)
 #define	tsd_tcache_enabled_set JEMALLOC_N(tsd_tcache_enabled_set)
+#define	tsd_tcache_enabledp_get JEMALLOC_N(tsd_tcache_enabledp_get)
 #define	tsd_tcache_get JEMALLOC_N(tsd_tcache_get)
 #define	tsd_tcache_set JEMALLOC_N(tsd_tcache_set)
-#define	tsd_tls JEMALLOC_N(tsd_tls)
-#define	tsd_tsd JEMALLOC_N(tsd_tsd)
-#define	tsd_prof_tdata_get JEMALLOC_N(tsd_prof_tdata_get)
-#define	tsd_prof_tdata_set JEMALLOC_N(tsd_prof_tdata_set)
+#define	tsd_tcachep_get JEMALLOC_N(tsd_tcachep_get)
 #define	tsd_thread_allocated_get JEMALLOC_N(tsd_thread_allocated_get)
 #define	tsd_thread_allocated_set JEMALLOC_N(tsd_thread_allocated_set)
+#define	tsd_thread_allocatedp_get JEMALLOC_N(tsd_thread_allocatedp_get)
 #define	tsd_thread_deallocated_get JEMALLOC_N(tsd_thread_deallocated_get)
 #define	tsd_thread_deallocated_set JEMALLOC_N(tsd_thread_deallocated_set)
+#define	tsd_thread_deallocatedp_get JEMALLOC_N(tsd_thread_deallocatedp_get)
+#define	tsd_tls JEMALLOC_N(tsd_tls)
+#define	tsd_tsd JEMALLOC_N(tsd_tsd)
+#define	tsd_tsdn JEMALLOC_N(tsd_tsdn)
+#define	tsd_witness_fork_get JEMALLOC_N(tsd_witness_fork_get)
+#define	tsd_witness_fork_set JEMALLOC_N(tsd_witness_fork_set)
+#define	tsd_witness_forkp_get JEMALLOC_N(tsd_witness_forkp_get)
+#define	tsd_witnesses_get JEMALLOC_N(tsd_witnesses_get)
+#define	tsd_witnesses_set JEMALLOC_N(tsd_witnesses_set)
+#define	tsd_witnessesp_get JEMALLOC_N(tsd_witnessesp_get)
+#define	tsdn_fetch JEMALLOC_N(tsdn_fetch)
+#define	tsdn_null JEMALLOC_N(tsdn_null)
+#define	tsdn_tsd JEMALLOC_N(tsdn_tsd)
 #define	u2rz JEMALLOC_N(u2rz)
 #define	valgrind_freelike_block JEMALLOC_N(valgrind_freelike_block)
 #define	valgrind_make_mem_defined JEMALLOC_N(valgrind_make_mem_defined)
 #define	valgrind_make_mem_noaccess JEMALLOC_N(valgrind_make_mem_noaccess)
 #define	valgrind_make_mem_undefined JEMALLOC_N(valgrind_make_mem_undefined)
+#define	witness_assert_lockless JEMALLOC_N(witness_assert_lockless)
+#define	witness_assert_not_owner JEMALLOC_N(witness_assert_not_owner)
+#define	witness_assert_owner JEMALLOC_N(witness_assert_owner)
+#define	witness_fork_cleanup JEMALLOC_N(witness_fork_cleanup)
+#define	witness_init JEMALLOC_N(witness_init)
+#define	witness_lock JEMALLOC_N(witness_lock)
+#define	witness_lock_error JEMALLOC_N(witness_lock_error)
+#define	witness_lockless_error JEMALLOC_N(witness_lockless_error)
+#define	witness_not_owner_error JEMALLOC_N(witness_not_owner_error)
+#define	witness_owner JEMALLOC_N(witness_owner)
+#define	witness_owner_error JEMALLOC_N(witness_owner_error)
+#define	witness_postfork_child JEMALLOC_N(witness_postfork_child)
+#define	witness_postfork_parent JEMALLOC_N(witness_postfork_parent)
+#define	witness_prefork JEMALLOC_N(witness_prefork)
+#define	witness_unlock JEMALLOC_N(witness_unlock)
+#define	witnesses_cleanup JEMALLOC_N(witnesses_cleanup)
+#define	zone_register JEMALLOC_N(zone_register)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/private_symbols.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/private_symbols.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/private_symbols.txt	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/private_symbols.txt	2017-01-31 23:32:23.000000000 +0800
@@ -1,17 +1,20 @@
 a0dalloc
 a0get
 a0malloc
 arena_aalloc
 arena_alloc_junk_small
+arena_basic_stats_merge
 arena_bin_index
 arena_bin_info
-arena_bitselm_get
+arena_bitselm_get_const
+arena_bitselm_get_mutable
 arena_boot
 arena_choose
 arena_choose_hard
+arena_choose_impl
 arena_chunk_alloc_huge
 arena_chunk_cache_maybe_insert
 arena_chunk_cache_maybe_remove
 arena_chunk_dalloc_huge
 arena_chunk_ralloc_huge_expand
 arena_chunk_ralloc_huge_shrink
@@ -22,85 +25,103 @@
 arena_dalloc_bin_junked_locked
 arena_dalloc_junk_large
 arena_dalloc_junk_small
 arena_dalloc_large
 arena_dalloc_large_junked_locked
 arena_dalloc_small
+arena_decay_tick
+arena_decay_ticks
+arena_decay_time_default_get
+arena_decay_time_default_set
+arena_decay_time_get
+arena_decay_time_set
 arena_dss_prec_get
 arena_dss_prec_set
+arena_extent_sn_next
 arena_get
-arena_get_hard
+arena_ichoose
 arena_init
 arena_lg_dirty_mult_default_get
 arena_lg_dirty_mult_default_set
 arena_lg_dirty_mult_get
 arena_lg_dirty_mult_set
 arena_malloc
+arena_malloc_hard
 arena_malloc_large
-arena_malloc_small
 arena_mapbits_allocated_get
 arena_mapbits_binind_get
 arena_mapbits_decommitted_get
 arena_mapbits_dirty_get
 arena_mapbits_get
 arena_mapbits_internal_set
 arena_mapbits_large_binind_set
 arena_mapbits_large_get
 arena_mapbits_large_set
 arena_mapbits_large_size_get
-arena_mapbitsp_get
-arena_mapbitsp_read
-arena_mapbitsp_write
 arena_mapbits_size_decode
 arena_mapbits_size_encode
 arena_mapbits_small_runind_get
 arena_mapbits_small_set
 arena_mapbits_unallocated_set
 arena_mapbits_unallocated_size_get
 arena_mapbits_unallocated_size_set
 arena_mapbits_unzeroed_get
+arena_mapbitsp_get_const
+arena_mapbitsp_get_mutable
+arena_mapbitsp_read
+arena_mapbitsp_write
 arena_maxrun
 arena_maybe_purge
 arena_metadata_allocated_add
 arena_metadata_allocated_get
 arena_metadata_allocated_sub
 arena_migrate
-arena_miscelm_get
+arena_miscelm_get_const
+arena_miscelm_get_mutable
 arena_miscelm_to_pageind
 arena_miscelm_to_rpages
-arena_nbound
 arena_new
 arena_node_alloc
 arena_node_dalloc
+arena_nthreads_dec
+arena_nthreads_get
+arena_nthreads_inc
 arena_palloc
 arena_postfork_child
 arena_postfork_parent
-arena_prefork
+arena_prefork0
+arena_prefork1
+arena_prefork2
+arena_prefork3
 arena_prof_accum
 arena_prof_accum_impl
 arena_prof_accum_locked
 arena_prof_promoted
 arena_prof_tctx_get
 arena_prof_tctx_reset
 arena_prof_tctx_set
 arena_ptr_small_binind_get
-arena_purge_all
+arena_purge
 arena_quarantine_junk_small
 arena_ralloc
 arena_ralloc_junk_large
 arena_ralloc_no_move
 arena_rd_to_miscelm
 arena_redzone_corruption
+arena_reset
 arena_run_regind
 arena_run_to_miscelm
 arena_salloc
-arenas_cache_bypass_cleanup
-arenas_cache_cleanup
 arena_sdalloc
 arena_stats_merge
 arena_tcache_fill_small
+arena_tdata_get
+arena_tdata_get_hard
+arenas
+arenas_tdata_bypass_cleanup
+arenas_tdata_cleanup
 atomic_add_p
 atomic_add_u
 atomic_add_uint32
 atomic_add_uint64
 atomic_add_z
 atomic_cas_p
@@ -110,22 +131,26 @@
 atomic_cas_z
 atomic_sub_p
 atomic_sub_u
 atomic_sub_uint32
 atomic_sub_uint64
 atomic_sub_z
+atomic_write_p
+atomic_write_u
+atomic_write_uint32
+atomic_write_uint64
+atomic_write_z
 base_alloc
 base_boot
 base_postfork_child
 base_postfork_parent
 base_prefork
 base_stats_get
 bitmap_full
 bitmap_get
 bitmap_info_init
-bitmap_info_ngroups
 bitmap_init
 bitmap_set
 bitmap_sfu
 bitmap_size
 bitmap_unset
 bootstrap_calloc
@@ -136,38 +161,31 @@
 chunk_alloc_base
 chunk_alloc_cache
 chunk_alloc_dss
 chunk_alloc_mmap
 chunk_alloc_wrapper
 chunk_boot
-chunk_dalloc_arena
 chunk_dalloc_cache
 chunk_dalloc_mmap
 chunk_dalloc_wrapper
 chunk_deregister
 chunk_dss_boot
-chunk_dss_postfork_child
-chunk_dss_postfork_parent
+chunk_dss_mergeable
 chunk_dss_prec_get
 chunk_dss_prec_set
-chunk_dss_prefork
 chunk_hooks_default
 chunk_hooks_get
 chunk_hooks_set
 chunk_in_dss
 chunk_lookup
 chunk_npages
-chunk_postfork_child
-chunk_postfork_parent
-chunk_prefork
-chunk_purge_arena
 chunk_purge_wrapper
 chunk_register
+chunks_rtree
 chunksize
 chunksize_mask
-chunks_rtree
 ckh_count
 ckh_delete
 ckh_insert
 ckh_iter
 ckh_new
 ckh_pointer_hash
@@ -180,29 +198,36 @@
 ctl_bymib
 ctl_byname
 ctl_nametomib
 ctl_postfork_child
 ctl_postfork_parent
 ctl_prefork
+decay_ticker_get
 dss_prec_names
 extent_node_achunk_get
 extent_node_achunk_set
 extent_node_addr_get
 extent_node_addr_set
 extent_node_arena_get
 extent_node_arena_set
+extent_node_committed_get
+extent_node_committed_set
 extent_node_dirty_insert
 extent_node_dirty_linkage_init
 extent_node_dirty_remove
 extent_node_init
 extent_node_prof_tctx_get
 extent_node_prof_tctx_set
 extent_node_size_get
 extent_node_size_set
+extent_node_sn_get
+extent_node_sn_set
 extent_node_zeroed_get
 extent_node_zeroed_set
+extent_tree_ad_destroy
+extent_tree_ad_destroy_recurse
 extent_tree_ad_empty
 extent_tree_ad_first
 extent_tree_ad_insert
 extent_tree_ad_iter
 extent_tree_ad_iter_recurse
 extent_tree_ad_iter_start
@@ -214,29 +239,37 @@
 extent_tree_ad_psearch
 extent_tree_ad_remove
 extent_tree_ad_reverse_iter
 extent_tree_ad_reverse_iter_recurse
 extent_tree_ad_reverse_iter_start
 extent_tree_ad_search
-extent_tree_szad_empty
-extent_tree_szad_first
-extent_tree_szad_insert
-extent_tree_szad_iter
-extent_tree_szad_iter_recurse
-extent_tree_szad_iter_start
-extent_tree_szad_last
-extent_tree_szad_new
-extent_tree_szad_next
-extent_tree_szad_nsearch
-extent_tree_szad_prev
-extent_tree_szad_psearch
-extent_tree_szad_remove
-extent_tree_szad_reverse_iter
-extent_tree_szad_reverse_iter_recurse
-extent_tree_szad_reverse_iter_start
-extent_tree_szad_search
+extent_tree_szsnad_destroy
+extent_tree_szsnad_destroy_recurse
+extent_tree_szsnad_empty
+extent_tree_szsnad_first
+extent_tree_szsnad_insert
+extent_tree_szsnad_iter
+extent_tree_szsnad_iter_recurse
+extent_tree_szsnad_iter_start
+extent_tree_szsnad_last
+extent_tree_szsnad_new
+extent_tree_szsnad_next
+extent_tree_szsnad_nsearch
+extent_tree_szsnad_prev
+extent_tree_szsnad_psearch
+extent_tree_szsnad_remove
+extent_tree_szsnad_reverse_iter
+extent_tree_szsnad_reverse_iter_recurse
+extent_tree_szsnad_reverse_iter_start
+extent_tree_szsnad_search
+ffs_llu
+ffs_lu
+ffs_u
+ffs_u32
+ffs_u64
+ffs_zu
 get_errno
 hash
 hash_fmix_32
 hash_fmix_64
 hash_get_block_32
 hash_get_block_64
@@ -254,25 +287,22 @@
 huge_prof_tctx_reset
 huge_prof_tctx_set
 huge_ralloc
 huge_ralloc_no_move
 huge_salloc
 iaalloc
+ialloc
 iallocztm
-icalloc
-icalloct
+iarena_cleanup
 idalloc
-idalloct
 idalloctm
-imalloc
-imalloct
+in_valgrind
 index2size
 index2size_compute
 index2size_lookup
 index2size_tab
-in_valgrind
 ipalloc
 ipalloct
 ipallocztm
 iqalloc
 iralloc
 iralloct
@@ -285,13 +315,17 @@
 ixalloc
 jemalloc_postfork_child
 jemalloc_postfork_parent
 jemalloc_prefork
 large_maxclass
 lg_floor
+lg_prof_sample
 malloc_cprintf
+malloc_mutex_assert_not_owner
+malloc_mutex_assert_owner
+malloc_mutex_boot
 malloc_mutex_init
 malloc_mutex_lock
 malloc_mutex_postfork_child
 malloc_mutex_postfork_parent
 malloc_mutex_prefork
 malloc_mutex_unlock
@@ -307,18 +341,35 @@
 malloc_vcprintf
 malloc_vsnprintf
 malloc_write
 map_bias
 map_misc_offset
 mb_write
-mutex_boot
-narenas_cache_cleanup
+narenas_auto
+narenas_tdata_cleanup
 narenas_total_get
 ncpus
 nhbins
+nhclasses
+nlclasses
+nstime_add
+nstime_compare
+nstime_copy
+nstime_divide
+nstime_idivide
+nstime_imultiply
+nstime_init
+nstime_init2
+nstime_monotonic
+nstime_ns
+nstime_nsec
+nstime_sec
+nstime_subtract
+nstime_update
 opt_abort
+opt_decay_time
 opt_dss
 opt_junk
 opt_junk_alloc
 opt_junk_free
 opt_lg_chunk
 opt_lg_dirty_mult
@@ -331,36 +382,57 @@
 opt_prof_active
 opt_prof_final
 opt_prof_gdump
 opt_prof_leak
 opt_prof_prefix
 opt_prof_thread_active_init
+opt_purge
 opt_quarantine
 opt_redzone
 opt_stats_print
 opt_tcache
 opt_utrace
 opt_xmalloc
 opt_zero
 p2rz
+pages_boot
 pages_commit
 pages_decommit
+pages_huge
 pages_map
+pages_nohuge
 pages_purge
 pages_trim
 pages_unmap
-pow2_ceil
+pind2sz
+pind2sz_compute
+pind2sz_lookup
+pind2sz_tab
+pow2_ceil_u32
+pow2_ceil_u64
+pow2_ceil_zu
+prng_lg_range_u32
+prng_lg_range_u64
+prng_lg_range_zu
+prng_range_u32
+prng_range_u64
+prng_range_zu
+prng_state_next_u32
+prng_state_next_u64
+prng_state_next_zu
+prof_active
 prof_active_get
 prof_active_get_unlocked
 prof_active_set
 prof_alloc_prep
 prof_alloc_rollback
 prof_backtrace
 prof_boot0
 prof_boot1
 prof_boot2
+prof_bt_count
 prof_dump_header
 prof_dump_open
 prof_free
 prof_free_sampled_object
 prof_gdump
 prof_gdump_get
@@ -372,35 +444,39 @@
 prof_lookup
 prof_malloc
 prof_malloc_sample_object
 prof_mdump
 prof_postfork_child
 prof_postfork_parent
-prof_prefork
+prof_prefork0
+prof_prefork1
 prof_realloc
 prof_reset
 prof_sample_accum_update
 prof_sample_threshold_update
 prof_tctx_get
 prof_tctx_reset
 prof_tctx_set
 prof_tdata_cleanup
+prof_tdata_count
 prof_tdata_get
 prof_tdata_init
 prof_tdata_reinit
 prof_thread_active_get
 prof_thread_active_init_get
 prof_thread_active_init_set
 prof_thread_active_set
 prof_thread_name_get
 prof_thread_name_set
+psz2ind
+psz2u
+purge_mode_names
 quarantine
 quarantine_alloc_hook
 quarantine_alloc_hook_work
 quarantine_cleanup
-register_zone
 rtree_child_read
 rtree_child_read_hard
 rtree_child_tryread
 rtree_delete
 rtree_get
 rtree_new
@@ -410,32 +486,34 @@
 rtree_subkey
 rtree_subtree_read
 rtree_subtree_read_hard
 rtree_subtree_tryread
 rtree_val_read
 rtree_val_write
+run_quantize_ceil
+run_quantize_floor
 s2u
 s2u_compute
 s2u_lookup
 sa2u
 set_errno
 size2index
 size2index_compute
 size2index_lookup
 size2index_tab
+spin_adaptive
+spin_init
 stats_cactive
 stats_cactive_add
 stats_cactive_get
 stats_cactive_sub
 stats_print
 tcache_alloc_easy
 tcache_alloc_large
 tcache_alloc_small
 tcache_alloc_small_hard
-tcache_arena_associate
-tcache_arena_dissociate
 tcache_arena_reassociate
 tcache_bin_flush_large
 tcache_bin_flush_small
 tcache_bin_info
 tcache_boot
 tcache_cleanup
@@ -448,52 +526,106 @@
 tcache_event
 tcache_event_hard
 tcache_flush
 tcache_get
 tcache_get_hard
 tcache_maxclass
-tcaches
 tcache_salloc
+tcache_stats_merge
+tcaches
 tcaches_create
 tcaches_destroy
 tcaches_flush
 tcaches_get
-tcache_stats_merge
 thread_allocated_cleanup
 thread_deallocated_cleanup
+ticker_copy
+ticker_init
+ticker_read
+ticker_tick
+ticker_ticks
 tsd_arena_get
 tsd_arena_set
+tsd_arenap_get
+tsd_arenas_tdata_bypass_get
+tsd_arenas_tdata_bypass_set
+tsd_arenas_tdata_bypassp_get
+tsd_arenas_tdata_get
+tsd_arenas_tdata_set
+tsd_arenas_tdatap_get
 tsd_boot
 tsd_boot0
 tsd_boot1
 tsd_booted
+tsd_booted_get
 tsd_cleanup
 tsd_cleanup_wrapper
 tsd_fetch
+tsd_fetch_impl
 tsd_get
-tsd_wrapper_get
-tsd_wrapper_set
+tsd_get_allocates
+tsd_iarena_get
+tsd_iarena_set
+tsd_iarenap_get
 tsd_initialized
 tsd_init_check_recursion
 tsd_init_finish
 tsd_init_head
+tsd_narenas_tdata_get
+tsd_narenas_tdata_set
+tsd_narenas_tdatap_get
+tsd_wrapper_get
+tsd_wrapper_set
 tsd_nominal
+tsd_prof_tdata_get
+tsd_prof_tdata_set
+tsd_prof_tdatap_get
 tsd_quarantine_get
 tsd_quarantine_set
+tsd_quarantinep_get
 tsd_set
 tsd_tcache_enabled_get
 tsd_tcache_enabled_set
+tsd_tcache_enabledp_get
 tsd_tcache_get
 tsd_tcache_set
-tsd_tls
-tsd_tsd
-tsd_prof_tdata_get
-tsd_prof_tdata_set
+tsd_tcachep_get
 tsd_thread_allocated_get
 tsd_thread_allocated_set
+tsd_thread_allocatedp_get
 tsd_thread_deallocated_get
 tsd_thread_deallocated_set
+tsd_thread_deallocatedp_get
+tsd_tls
+tsd_tsd
+tsd_tsdn
+tsd_witness_fork_get
+tsd_witness_fork_set
+tsd_witness_forkp_get
+tsd_witnesses_get
+tsd_witnesses_set
+tsd_witnessesp_get
+tsdn_fetch
+tsdn_null
+tsdn_tsd
 u2rz
 valgrind_freelike_block
 valgrind_make_mem_defined
 valgrind_make_mem_noaccess
 valgrind_make_mem_undefined
+witness_assert_lockless
+witness_assert_not_owner
+witness_assert_owner
+witness_fork_cleanup
+witness_init
+witness_lock
+witness_lock_error
+witness_lockless_error
+witness_not_owner_error
+witness_owner
+witness_owner_error
+witness_postfork_child
+witness_postfork_parent
+witness_prefork
+witness_unlock
+witnesses_cleanup
+zone_register
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/private_unnamespace.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/private_unnamespace.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/private_unnamespace.h	2017-09-27 23:00:17.542936195 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/private_unnamespace.h	2017-09-27 23:01:52.542932714 +0800
@@ -1,17 +1,20 @@
 #undef a0dalloc
 #undef a0get
 #undef a0malloc
 #undef arena_aalloc
 #undef arena_alloc_junk_small
+#undef arena_basic_stats_merge
 #undef arena_bin_index
 #undef arena_bin_info
-#undef arena_bitselm_get
+#undef arena_bitselm_get_const
+#undef arena_bitselm_get_mutable
 #undef arena_boot
 #undef arena_choose
 #undef arena_choose_hard
+#undef arena_choose_impl
 #undef arena_chunk_alloc_huge
 #undef arena_chunk_cache_maybe_insert
 #undef arena_chunk_cache_maybe_remove
 #undef arena_chunk_dalloc_huge
 #undef arena_chunk_ralloc_huge_expand
 #undef arena_chunk_ralloc_huge_shrink
@@ -22,85 +25,103 @@
 #undef arena_dalloc_bin_junked_locked
 #undef arena_dalloc_junk_large
 #undef arena_dalloc_junk_small
 #undef arena_dalloc_large
 #undef arena_dalloc_large_junked_locked
 #undef arena_dalloc_small
+#undef arena_decay_tick
+#undef arena_decay_ticks
+#undef arena_decay_time_default_get
+#undef arena_decay_time_default_set
+#undef arena_decay_time_get
+#undef arena_decay_time_set
 #undef arena_dss_prec_get
 #undef arena_dss_prec_set
+#undef arena_extent_sn_next
 #undef arena_get
-#undef arena_get_hard
+#undef arena_ichoose
 #undef arena_init
 #undef arena_lg_dirty_mult_default_get
 #undef arena_lg_dirty_mult_default_set
 #undef arena_lg_dirty_mult_get
 #undef arena_lg_dirty_mult_set
 #undef arena_malloc
+#undef arena_malloc_hard
 #undef arena_malloc_large
-#undef arena_malloc_small
 #undef arena_mapbits_allocated_get
 #undef arena_mapbits_binind_get
 #undef arena_mapbits_decommitted_get
 #undef arena_mapbits_dirty_get
 #undef arena_mapbits_get
 #undef arena_mapbits_internal_set
 #undef arena_mapbits_large_binind_set
 #undef arena_mapbits_large_get
 #undef arena_mapbits_large_set
 #undef arena_mapbits_large_size_get
-#undef arena_mapbitsp_get
-#undef arena_mapbitsp_read
-#undef arena_mapbitsp_write
 #undef arena_mapbits_size_decode
 #undef arena_mapbits_size_encode
 #undef arena_mapbits_small_runind_get
 #undef arena_mapbits_small_set
 #undef arena_mapbits_unallocated_set
 #undef arena_mapbits_unallocated_size_get
 #undef arena_mapbits_unallocated_size_set
 #undef arena_mapbits_unzeroed_get
+#undef arena_mapbitsp_get_const
+#undef arena_mapbitsp_get_mutable
+#undef arena_mapbitsp_read
+#undef arena_mapbitsp_write
 #undef arena_maxrun
 #undef arena_maybe_purge
 #undef arena_metadata_allocated_add
 #undef arena_metadata_allocated_get
 #undef arena_metadata_allocated_sub
 #undef arena_migrate
-#undef arena_miscelm_get
+#undef arena_miscelm_get_const
+#undef arena_miscelm_get_mutable
 #undef arena_miscelm_to_pageind
 #undef arena_miscelm_to_rpages
-#undef arena_nbound
 #undef arena_new
 #undef arena_node_alloc
 #undef arena_node_dalloc
+#undef arena_nthreads_dec
+#undef arena_nthreads_get
+#undef arena_nthreads_inc
 #undef arena_palloc
 #undef arena_postfork_child
 #undef arena_postfork_parent
-#undef arena_prefork
+#undef arena_prefork0
+#undef arena_prefork1
+#undef arena_prefork2
+#undef arena_prefork3
 #undef arena_prof_accum
 #undef arena_prof_accum_impl
 #undef arena_prof_accum_locked
 #undef arena_prof_promoted
 #undef arena_prof_tctx_get
 #undef arena_prof_tctx_reset
 #undef arena_prof_tctx_set
 #undef arena_ptr_small_binind_get
-#undef arena_purge_all
+#undef arena_purge
 #undef arena_quarantine_junk_small
 #undef arena_ralloc
 #undef arena_ralloc_junk_large
 #undef arena_ralloc_no_move
 #undef arena_rd_to_miscelm
 #undef arena_redzone_corruption
+#undef arena_reset
 #undef arena_run_regind
 #undef arena_run_to_miscelm
 #undef arena_salloc
-#undef arenas_cache_bypass_cleanup
-#undef arenas_cache_cleanup
 #undef arena_sdalloc
 #undef arena_stats_merge
 #undef arena_tcache_fill_small
+#undef arena_tdata_get
+#undef arena_tdata_get_hard
+#undef arenas
+#undef arenas_tdata_bypass_cleanup
+#undef arenas_tdata_cleanup
 #undef atomic_add_p
 #undef atomic_add_u
 #undef atomic_add_uint32
 #undef atomic_add_uint64
 #undef atomic_add_z
 #undef atomic_cas_p
@@ -110,22 +131,26 @@
 #undef atomic_cas_z
 #undef atomic_sub_p
 #undef atomic_sub_u
 #undef atomic_sub_uint32
 #undef atomic_sub_uint64
 #undef atomic_sub_z
+#undef atomic_write_p
+#undef atomic_write_u
+#undef atomic_write_uint32
+#undef atomic_write_uint64
+#undef atomic_write_z
 #undef base_alloc
 #undef base_boot
 #undef base_postfork_child
 #undef base_postfork_parent
 #undef base_prefork
 #undef base_stats_get
 #undef bitmap_full
 #undef bitmap_get
 #undef bitmap_info_init
-#undef bitmap_info_ngroups
 #undef bitmap_init
 #undef bitmap_set
 #undef bitmap_sfu
 #undef bitmap_size
 #undef bitmap_unset
 #undef bootstrap_calloc
@@ -136,38 +161,31 @@
 #undef chunk_alloc_base
 #undef chunk_alloc_cache
 #undef chunk_alloc_dss
 #undef chunk_alloc_mmap
 #undef chunk_alloc_wrapper
 #undef chunk_boot
-#undef chunk_dalloc_arena
 #undef chunk_dalloc_cache
 #undef chunk_dalloc_mmap
 #undef chunk_dalloc_wrapper
 #undef chunk_deregister
 #undef chunk_dss_boot
-#undef chunk_dss_postfork_child
-#undef chunk_dss_postfork_parent
+#undef chunk_dss_mergeable
 #undef chunk_dss_prec_get
 #undef chunk_dss_prec_set
-#undef chunk_dss_prefork
 #undef chunk_hooks_default
 #undef chunk_hooks_get
 #undef chunk_hooks_set
 #undef chunk_in_dss
 #undef chunk_lookup
 #undef chunk_npages
-#undef chunk_postfork_child
-#undef chunk_postfork_parent
-#undef chunk_prefork
-#undef chunk_purge_arena
 #undef chunk_purge_wrapper
 #undef chunk_register
+#undef chunks_rtree
 #undef chunksize
 #undef chunksize_mask
-#undef chunks_rtree
 #undef ckh_count
 #undef ckh_delete
 #undef ckh_insert
 #undef ckh_iter
 #undef ckh_new
 #undef ckh_pointer_hash
@@ -180,29 +198,36 @@
 #undef ctl_bymib
 #undef ctl_byname
 #undef ctl_nametomib
 #undef ctl_postfork_child
 #undef ctl_postfork_parent
 #undef ctl_prefork
+#undef decay_ticker_get
 #undef dss_prec_names
 #undef extent_node_achunk_get
 #undef extent_node_achunk_set
 #undef extent_node_addr_get
 #undef extent_node_addr_set
 #undef extent_node_arena_get
 #undef extent_node_arena_set
+#undef extent_node_committed_get
+#undef extent_node_committed_set
 #undef extent_node_dirty_insert
 #undef extent_node_dirty_linkage_init
 #undef extent_node_dirty_remove
 #undef extent_node_init
 #undef extent_node_prof_tctx_get
 #undef extent_node_prof_tctx_set
 #undef extent_node_size_get
 #undef extent_node_size_set
+#undef extent_node_sn_get
+#undef extent_node_sn_set
 #undef extent_node_zeroed_get
 #undef extent_node_zeroed_set
+#undef extent_tree_ad_destroy
+#undef extent_tree_ad_destroy_recurse
 #undef extent_tree_ad_empty
 #undef extent_tree_ad_first
 #undef extent_tree_ad_insert
 #undef extent_tree_ad_iter
 #undef extent_tree_ad_iter_recurse
 #undef extent_tree_ad_iter_start
@@ -214,29 +239,37 @@
 #undef extent_tree_ad_psearch
 #undef extent_tree_ad_remove
 #undef extent_tree_ad_reverse_iter
 #undef extent_tree_ad_reverse_iter_recurse
 #undef extent_tree_ad_reverse_iter_start
 #undef extent_tree_ad_search
-#undef extent_tree_szad_empty
-#undef extent_tree_szad_first
-#undef extent_tree_szad_insert
-#undef extent_tree_szad_iter
-#undef extent_tree_szad_iter_recurse
-#undef extent_tree_szad_iter_start
-#undef extent_tree_szad_last
-#undef extent_tree_szad_new
-#undef extent_tree_szad_next
-#undef extent_tree_szad_nsearch
-#undef extent_tree_szad_prev
-#undef extent_tree_szad_psearch
-#undef extent_tree_szad_remove
-#undef extent_tree_szad_reverse_iter
-#undef extent_tree_szad_reverse_iter_recurse
-#undef extent_tree_szad_reverse_iter_start
-#undef extent_tree_szad_search
+#undef extent_tree_szsnad_destroy
+#undef extent_tree_szsnad_destroy_recurse
+#undef extent_tree_szsnad_empty
+#undef extent_tree_szsnad_first
+#undef extent_tree_szsnad_insert
+#undef extent_tree_szsnad_iter
+#undef extent_tree_szsnad_iter_recurse
+#undef extent_tree_szsnad_iter_start
+#undef extent_tree_szsnad_last
+#undef extent_tree_szsnad_new
+#undef extent_tree_szsnad_next
+#undef extent_tree_szsnad_nsearch
+#undef extent_tree_szsnad_prev
+#undef extent_tree_szsnad_psearch
+#undef extent_tree_szsnad_remove
+#undef extent_tree_szsnad_reverse_iter
+#undef extent_tree_szsnad_reverse_iter_recurse
+#undef extent_tree_szsnad_reverse_iter_start
+#undef extent_tree_szsnad_search
+#undef ffs_llu
+#undef ffs_lu
+#undef ffs_u
+#undef ffs_u32
+#undef ffs_u64
+#undef ffs_zu
 #undef get_errno
 #undef hash
 #undef hash_fmix_32
 #undef hash_fmix_64
 #undef hash_get_block_32
 #undef hash_get_block_64
@@ -254,25 +287,22 @@
 #undef huge_prof_tctx_reset
 #undef huge_prof_tctx_set
 #undef huge_ralloc
 #undef huge_ralloc_no_move
 #undef huge_salloc
 #undef iaalloc
+#undef ialloc
 #undef iallocztm
-#undef icalloc
-#undef icalloct
+#undef iarena_cleanup
 #undef idalloc
-#undef idalloct
 #undef idalloctm
-#undef imalloc
-#undef imalloct
+#undef in_valgrind
 #undef index2size
 #undef index2size_compute
 #undef index2size_lookup
 #undef index2size_tab
-#undef in_valgrind
 #undef ipalloc
 #undef ipalloct
 #undef ipallocztm
 #undef iqalloc
 #undef iralloc
 #undef iralloct
@@ -285,13 +315,17 @@
 #undef ixalloc
 #undef jemalloc_postfork_child
 #undef jemalloc_postfork_parent
 #undef jemalloc_prefork
 #undef large_maxclass
 #undef lg_floor
+#undef lg_prof_sample
 #undef malloc_cprintf
+#undef malloc_mutex_assert_not_owner
+#undef malloc_mutex_assert_owner
+#undef malloc_mutex_boot
 #undef malloc_mutex_init
 #undef malloc_mutex_lock
 #undef malloc_mutex_postfork_child
 #undef malloc_mutex_postfork_parent
 #undef malloc_mutex_prefork
 #undef malloc_mutex_unlock
@@ -307,18 +341,35 @@
 #undef malloc_vcprintf
 #undef malloc_vsnprintf
 #undef malloc_write
 #undef map_bias
 #undef map_misc_offset
 #undef mb_write
-#undef mutex_boot
-#undef narenas_cache_cleanup
+#undef narenas_auto
+#undef narenas_tdata_cleanup
 #undef narenas_total_get
 #undef ncpus
 #undef nhbins
+#undef nhclasses
+#undef nlclasses
+#undef nstime_add
+#undef nstime_compare
+#undef nstime_copy
+#undef nstime_divide
+#undef nstime_idivide
+#undef nstime_imultiply
+#undef nstime_init
+#undef nstime_init2
+#undef nstime_monotonic
+#undef nstime_ns
+#undef nstime_nsec
+#undef nstime_sec
+#undef nstime_subtract
+#undef nstime_update
 #undef opt_abort
+#undef opt_decay_time
 #undef opt_dss
 #undef opt_junk
 #undef opt_junk_alloc
 #undef opt_junk_free
 #undef opt_lg_chunk
 #undef opt_lg_dirty_mult
@@ -331,36 +382,57 @@
 #undef opt_prof_active
 #undef opt_prof_final
 #undef opt_prof_gdump
 #undef opt_prof_leak
 #undef opt_prof_prefix
 #undef opt_prof_thread_active_init
+#undef opt_purge
 #undef opt_quarantine
 #undef opt_redzone
 #undef opt_stats_print
 #undef opt_tcache
 #undef opt_utrace
 #undef opt_xmalloc
 #undef opt_zero
 #undef p2rz
+#undef pages_boot
 #undef pages_commit
 #undef pages_decommit
+#undef pages_huge
 #undef pages_map
+#undef pages_nohuge
 #undef pages_purge
 #undef pages_trim
 #undef pages_unmap
-#undef pow2_ceil
+#undef pind2sz
+#undef pind2sz_compute
+#undef pind2sz_lookup
+#undef pind2sz_tab
+#undef pow2_ceil_u32
+#undef pow2_ceil_u64
+#undef pow2_ceil_zu
+#undef prng_lg_range_u32
+#undef prng_lg_range_u64
+#undef prng_lg_range_zu
+#undef prng_range_u32
+#undef prng_range_u64
+#undef prng_range_zu
+#undef prng_state_next_u32
+#undef prng_state_next_u64
+#undef prng_state_next_zu
+#undef prof_active
 #undef prof_active_get
 #undef prof_active_get_unlocked
 #undef prof_active_set
 #undef prof_alloc_prep
 #undef prof_alloc_rollback
 #undef prof_backtrace
 #undef prof_boot0
 #undef prof_boot1
 #undef prof_boot2
+#undef prof_bt_count
 #undef prof_dump_header
 #undef prof_dump_open
 #undef prof_free
 #undef prof_free_sampled_object
 #undef prof_gdump
 #undef prof_gdump_get
@@ -372,35 +444,39 @@
 #undef prof_lookup
 #undef prof_malloc
 #undef prof_malloc_sample_object
 #undef prof_mdump
 #undef prof_postfork_child
 #undef prof_postfork_parent
-#undef prof_prefork
+#undef prof_prefork0
+#undef prof_prefork1
 #undef prof_realloc
 #undef prof_reset
 #undef prof_sample_accum_update
 #undef prof_sample_threshold_update
 #undef prof_tctx_get
 #undef prof_tctx_reset
 #undef prof_tctx_set
 #undef prof_tdata_cleanup
+#undef prof_tdata_count
 #undef prof_tdata_get
 #undef prof_tdata_init
 #undef prof_tdata_reinit
 #undef prof_thread_active_get
 #undef prof_thread_active_init_get
 #undef prof_thread_active_init_set
 #undef prof_thread_active_set
 #undef prof_thread_name_get
 #undef prof_thread_name_set
+#undef psz2ind
+#undef psz2u
+#undef purge_mode_names
 #undef quarantine
 #undef quarantine_alloc_hook
 #undef quarantine_alloc_hook_work
 #undef quarantine_cleanup
-#undef register_zone
 #undef rtree_child_read
 #undef rtree_child_read_hard
 #undef rtree_child_tryread
 #undef rtree_delete
 #undef rtree_get
 #undef rtree_new
@@ -410,32 +486,34 @@
 #undef rtree_subkey
 #undef rtree_subtree_read
 #undef rtree_subtree_read_hard
 #undef rtree_subtree_tryread
 #undef rtree_val_read
 #undef rtree_val_write
+#undef run_quantize_ceil
+#undef run_quantize_floor
 #undef s2u
 #undef s2u_compute
 #undef s2u_lookup
 #undef sa2u
 #undef set_errno
 #undef size2index
 #undef size2index_compute
 #undef size2index_lookup
 #undef size2index_tab
+#undef spin_adaptive
+#undef spin_init
 #undef stats_cactive
 #undef stats_cactive_add
 #undef stats_cactive_get
 #undef stats_cactive_sub
 #undef stats_print
 #undef tcache_alloc_easy
 #undef tcache_alloc_large
 #undef tcache_alloc_small
 #undef tcache_alloc_small_hard
-#undef tcache_arena_associate
-#undef tcache_arena_dissociate
 #undef tcache_arena_reassociate
 #undef tcache_bin_flush_large
 #undef tcache_bin_flush_small
 #undef tcache_bin_info
 #undef tcache_boot
 #undef tcache_cleanup
@@ -448,52 +526,106 @@
 #undef tcache_event
 #undef tcache_event_hard
 #undef tcache_flush
 #undef tcache_get
 #undef tcache_get_hard
 #undef tcache_maxclass
-#undef tcaches
 #undef tcache_salloc
+#undef tcache_stats_merge
+#undef tcaches
 #undef tcaches_create
 #undef tcaches_destroy
 #undef tcaches_flush
 #undef tcaches_get
-#undef tcache_stats_merge
 #undef thread_allocated_cleanup
 #undef thread_deallocated_cleanup
+#undef ticker_copy
+#undef ticker_init
+#undef ticker_read
+#undef ticker_tick
+#undef ticker_ticks
 #undef tsd_arena_get
 #undef tsd_arena_set
+#undef tsd_arenap_get
+#undef tsd_arenas_tdata_bypass_get
+#undef tsd_arenas_tdata_bypass_set
+#undef tsd_arenas_tdata_bypassp_get
+#undef tsd_arenas_tdata_get
+#undef tsd_arenas_tdata_set
+#undef tsd_arenas_tdatap_get
 #undef tsd_boot
 #undef tsd_boot0
 #undef tsd_boot1
 #undef tsd_booted
+#undef tsd_booted_get
 #undef tsd_cleanup
 #undef tsd_cleanup_wrapper
 #undef tsd_fetch
+#undef tsd_fetch_impl
 #undef tsd_get
-#undef tsd_wrapper_get
-#undef tsd_wrapper_set
+#undef tsd_get_allocates
+#undef tsd_iarena_get
+#undef tsd_iarena_set
+#undef tsd_iarenap_get
 #undef tsd_initialized
 #undef tsd_init_check_recursion
 #undef tsd_init_finish
 #undef tsd_init_head
+#undef tsd_narenas_tdata_get
+#undef tsd_narenas_tdata_set
+#undef tsd_narenas_tdatap_get
+#undef tsd_wrapper_get
+#undef tsd_wrapper_set
 #undef tsd_nominal
+#undef tsd_prof_tdata_get
+#undef tsd_prof_tdata_set
+#undef tsd_prof_tdatap_get
 #undef tsd_quarantine_get
 #undef tsd_quarantine_set
+#undef tsd_quarantinep_get
 #undef tsd_set
 #undef tsd_tcache_enabled_get
 #undef tsd_tcache_enabled_set
+#undef tsd_tcache_enabledp_get
 #undef tsd_tcache_get
 #undef tsd_tcache_set
-#undef tsd_tls
-#undef tsd_tsd
-#undef tsd_prof_tdata_get
-#undef tsd_prof_tdata_set
+#undef tsd_tcachep_get
 #undef tsd_thread_allocated_get
 #undef tsd_thread_allocated_set
+#undef tsd_thread_allocatedp_get
 #undef tsd_thread_deallocated_get
 #undef tsd_thread_deallocated_set
+#undef tsd_thread_deallocatedp_get
+#undef tsd_tls
+#undef tsd_tsd
+#undef tsd_tsdn
+#undef tsd_witness_fork_get
+#undef tsd_witness_fork_set
+#undef tsd_witness_forkp_get
+#undef tsd_witnesses_get
+#undef tsd_witnesses_set
+#undef tsd_witnessesp_get
+#undef tsdn_fetch
+#undef tsdn_null
+#undef tsdn_tsd
 #undef u2rz
 #undef valgrind_freelike_block
 #undef valgrind_make_mem_defined
 #undef valgrind_make_mem_noaccess
 #undef valgrind_make_mem_undefined
+#undef witness_assert_lockless
+#undef witness_assert_not_owner
+#undef witness_assert_owner
+#undef witness_fork_cleanup
+#undef witness_init
+#undef witness_lock
+#undef witness_lock_error
+#undef witness_lockless_error
+#undef witness_not_owner_error
+#undef witness_owner
+#undef witness_owner_error
+#undef witness_postfork_child
+#undef witness_postfork_parent
+#undef witness_prefork
+#undef witness_unlock
+#undef witnesses_cleanup
+#undef zone_register
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/prng.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/prng.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/prng.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/prng.h	2017-01-31 23:32:23.000000000 +0800
@@ -15,37 +15,19 @@
  * See Knuth's TAOCP 3rd Ed., Vol. 2, pg. 17 for details on these constraints.
  *
  * This choice of m has the disadvantage that the quality of the bits is
  * proportional to bit position.  For example, the lowest bit has a cycle of 2,
  * the next has a cycle of 4, etc.  For this reason, we prefer to use the upper
  * bits.
- *
- * Macro parameters:
- *   uint32_t r          : Result.
- *   unsigned lg_range   : (0..32], number of least significant bits to return.
- *   uint32_t state      : Seed value.
- *   const uint32_t a, c : See above discussion.
  */
-#define	prng32(r, lg_range, state, a, c) do {				\
-	assert((lg_range) > 0);						\
-	assert((lg_range) <= 32);					\
-									\
-	r = (state * (a)) + (c);					\
-	state = r;							\
-	r >>= (32 - (lg_range));					\
-} while (false)
-
-/* Same as prng32(), but 64 bits of pseudo-randomness, using uint64_t. */
-#define	prng64(r, lg_range, state, a, c) do {				\
-	assert((lg_range) > 0);						\
-	assert((lg_range) <= 64);					\
-									\
-	r = (state * (a)) + (c);					\
-	state = r;							\
-	r >>= (64 - (lg_range));					\
-} while (false)
+
+#define	PRNG_A_32	UINT32_C(1103515241)
+#define	PRNG_C_32	UINT32_C(12347)
+
+#define	PRNG_A_64	UINT64_C(6364136223846793005)
+#define	PRNG_C_64	UINT64_C(1442695040888963407)
 
 #endif /* JEMALLOC_H_TYPES */
 /******************************************************************************/
 #ifdef JEMALLOC_H_STRUCTS
 
 #endif /* JEMALLOC_H_STRUCTS */
@@ -53,8 +35,173 @@
 #ifdef JEMALLOC_H_EXTERNS
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
+#ifndef JEMALLOC_ENABLE_INLINE
+uint32_t	prng_state_next_u32(uint32_t state);
+uint64_t	prng_state_next_u64(uint64_t state);
+size_t	prng_state_next_zu(size_t state);
+
+uint32_t	prng_lg_range_u32(uint32_t *state, unsigned lg_range,
+    bool atomic);
+uint64_t	prng_lg_range_u64(uint64_t *state, unsigned lg_range);
+size_t	prng_lg_range_zu(size_t *state, unsigned lg_range, bool atomic);
+
+uint32_t	prng_range_u32(uint32_t *state, uint32_t range, bool atomic);
+uint64_t	prng_range_u64(uint64_t *state, uint64_t range);
+size_t	prng_range_zu(size_t *state, size_t range, bool atomic);
+#endif
+
+#if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_PRNG_C_))
+JEMALLOC_ALWAYS_INLINE uint32_t
+prng_state_next_u32(uint32_t state)
+{
+
+	return ((state * PRNG_A_32) + PRNG_C_32);
+}
+
+JEMALLOC_ALWAYS_INLINE uint64_t
+prng_state_next_u64(uint64_t state)
+{
+
+	return ((state * PRNG_A_64) + PRNG_C_64);
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+prng_state_next_zu(size_t state)
+{
+
+#if LG_SIZEOF_PTR == 2
+	return ((state * PRNG_A_32) + PRNG_C_32);
+#elif LG_SIZEOF_PTR == 3
+	return ((state * PRNG_A_64) + PRNG_C_64);
+#else
+#error Unsupported pointer size
+#endif
+}
+
+JEMALLOC_ALWAYS_INLINE uint32_t
+prng_lg_range_u32(uint32_t *state, unsigned lg_range, bool atomic)
+{
+	uint32_t ret, state1;
+
+	assert(lg_range > 0);
+	assert(lg_range <= 32);
+
+	if (atomic) {
+		uint32_t state0;
+
+		do {
+			state0 = atomic_read_uint32(state);
+			state1 = prng_state_next_u32(state0);
+		} while (atomic_cas_uint32(state, state0, state1));
+	} else {
+		state1 = prng_state_next_u32(*state);
+		*state = state1;
+	}
+	ret = state1 >> (32 - lg_range);
+
+	return (ret);
+}
+
+/* 64-bit atomic operations cannot be supported on all relevant platforms. */
+JEMALLOC_ALWAYS_INLINE uint64_t
+prng_lg_range_u64(uint64_t *state, unsigned lg_range)
+{
+	uint64_t ret, state1;
+
+	assert(lg_range > 0);
+	assert(lg_range <= 64);
+
+	state1 = prng_state_next_u64(*state);
+	*state = state1;
+	ret = state1 >> (64 - lg_range);
+
+	return (ret);
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+prng_lg_range_zu(size_t *state, unsigned lg_range, bool atomic)
+{
+	size_t ret, state1;
+
+	assert(lg_range > 0);
+	assert(lg_range <= ZU(1) << (3 + LG_SIZEOF_PTR));
+
+	if (atomic) {
+		size_t state0;
+
+		do {
+			state0 = atomic_read_z(state);
+			state1 = prng_state_next_zu(state0);
+		} while (atomic_cas_z(state, state0, state1));
+	} else {
+		state1 = prng_state_next_zu(*state);
+		*state = state1;
+	}
+	ret = state1 >> ((ZU(1) << (3 + LG_SIZEOF_PTR)) - lg_range);
+
+	return (ret);
+}
+
+JEMALLOC_ALWAYS_INLINE uint32_t
+prng_range_u32(uint32_t *state, uint32_t range, bool atomic)
+{
+	uint32_t ret;
+	unsigned lg_range;
+
+	assert(range > 1);
+
+	/* Compute the ceiling of lg(range). */
+	lg_range = ffs_u32(pow2_ceil_u32(range)) - 1;
+
+	/* Generate a result in [0..range) via repeated trial. */
+	do {
+		ret = prng_lg_range_u32(state, lg_range, atomic);
+	} while (ret >= range);
+
+	return (ret);
+}
+
+JEMALLOC_ALWAYS_INLINE uint64_t
+prng_range_u64(uint64_t *state, uint64_t range)
+{
+	uint64_t ret;
+	unsigned lg_range;
+
+	assert(range > 1);
+
+	/* Compute the ceiling of lg(range). */
+	lg_range = ffs_u64(pow2_ceil_u64(range)) - 1;
+
+	/* Generate a result in [0..range) via repeated trial. */
+	do {
+		ret = prng_lg_range_u64(state, lg_range);
+	} while (ret >= range);
+
+	return (ret);
+}
+
+JEMALLOC_ALWAYS_INLINE size_t
+prng_range_zu(size_t *state, size_t range, bool atomic)
+{
+	size_t ret;
+	unsigned lg_range;
+
+	assert(range > 1);
+
+	/* Compute the ceiling of lg(range). */
+	lg_range = ffs_u64(pow2_ceil_u64(range)) - 1;
+
+	/* Generate a result in [0..range) via repeated trial. */
+	do {
+		ret = prng_lg_range_zu(state, lg_range, atomic);
+	} while (ret >= range);
+
+	return (ret);
+}
+#endif
+
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/prof.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/prof.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/prof.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/prof.h	2017-01-31 23:32:23.000000000 +0800
@@ -278,71 +278,72 @@
  * Initialized as opt_lg_prof_sample, and potentially modified during profiling
  * resets.
  */
 extern size_t	lg_prof_sample;
 
 void	prof_alloc_rollback(tsd_t *tsd, prof_tctx_t *tctx, bool updated);
-void	prof_malloc_sample_object(const void *ptr, size_t usize,
+void	prof_malloc_sample_object(tsdn_t *tsdn, const void *ptr, size_t usize,
     prof_tctx_t *tctx);
 void	prof_free_sampled_object(tsd_t *tsd, size_t usize, prof_tctx_t *tctx);
 void	bt_init(prof_bt_t *bt, void **vec);
 void	prof_backtrace(prof_bt_t *bt);
 prof_tctx_t	*prof_lookup(tsd_t *tsd, prof_bt_t *bt);
 #ifdef JEMALLOC_JET
 size_t	prof_tdata_count(void);
 size_t	prof_bt_count(void);
 const prof_cnt_t *prof_cnt_all(void);
 typedef int (prof_dump_open_t)(bool, const char *);
 extern prof_dump_open_t *prof_dump_open;
-typedef bool (prof_dump_header_t)(bool, const prof_cnt_t *);
+typedef bool (prof_dump_header_t)(tsdn_t *, bool, const prof_cnt_t *);
 extern prof_dump_header_t *prof_dump_header;
 #endif
-void	prof_idump(void);
-bool	prof_mdump(const char *filename);
-void	prof_gdump(void);
+void	prof_idump(tsdn_t *tsdn);
+bool	prof_mdump(tsd_t *tsd, const char *filename);
+void	prof_gdump(tsdn_t *tsdn);
 prof_tdata_t	*prof_tdata_init(tsd_t *tsd);
 prof_tdata_t	*prof_tdata_reinit(tsd_t *tsd, prof_tdata_t *tdata);
 void	prof_reset(tsd_t *tsd, size_t lg_sample);
 void	prof_tdata_cleanup(tsd_t *tsd);
-const char	*prof_thread_name_get(void);
-bool	prof_active_get(void);
-bool	prof_active_set(bool active);
+bool	prof_active_get(tsdn_t *tsdn);
+bool	prof_active_set(tsdn_t *tsdn, bool active);
+const char	*prof_thread_name_get(tsd_t *tsd);
 int	prof_thread_name_set(tsd_t *tsd, const char *thread_name);
-bool	prof_thread_active_get(void);
-bool	prof_thread_active_set(bool active);
-bool	prof_thread_active_init_get(void);
-bool	prof_thread_active_init_set(bool active_init);
-bool	prof_gdump_get(void);
-bool	prof_gdump_set(bool active);
+bool	prof_thread_active_get(tsd_t *tsd);
+bool	prof_thread_active_set(tsd_t *tsd, bool active);
+bool	prof_thread_active_init_get(tsdn_t *tsdn);
+bool	prof_thread_active_init_set(tsdn_t *tsdn, bool active_init);
+bool	prof_gdump_get(tsdn_t *tsdn);
+bool	prof_gdump_set(tsdn_t *tsdn, bool active);
 void	prof_boot0(void);
 void	prof_boot1(void);
-bool	prof_boot2(void);
-void	prof_prefork(void);
-void	prof_postfork_parent(void);
-void	prof_postfork_child(void);
+bool	prof_boot2(tsd_t *tsd);
+void	prof_prefork0(tsdn_t *tsdn);
+void	prof_prefork1(tsdn_t *tsdn);
+void	prof_postfork_parent(tsdn_t *tsdn);
+void	prof_postfork_child(tsdn_t *tsdn);
 void	prof_sample_threshold_update(prof_tdata_t *tdata);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
 bool	prof_active_get_unlocked(void);
 bool	prof_gdump_get_unlocked(void);
 prof_tdata_t	*prof_tdata_get(tsd_t *tsd, bool create);
+prof_tctx_t	*prof_tctx_get(tsdn_t *tsdn, const void *ptr);
+void	prof_tctx_set(tsdn_t *tsdn, const void *ptr, size_t usize,
+    prof_tctx_t *tctx);
+void	prof_tctx_reset(tsdn_t *tsdn, const void *ptr, size_t usize,
+    const void *old_ptr, prof_tctx_t *tctx);
 bool	prof_sample_accum_update(tsd_t *tsd, size_t usize, bool commit,
     prof_tdata_t **tdata_out);
 prof_tctx_t	*prof_alloc_prep(tsd_t *tsd, size_t usize, bool prof_active,
     bool update);
-prof_tctx_t	*prof_tctx_get(const void *ptr);
-void	prof_tctx_set(const void *ptr, size_t usize, prof_tctx_t *tctx);
-void	prof_tctx_reset(const void *ptr, size_t usize, const void *old_ptr,
-    prof_tctx_t *tctx);
-void	prof_malloc_sample_object(const void *ptr, size_t usize,
+void	prof_malloc(tsdn_t *tsdn, const void *ptr, size_t usize,
     prof_tctx_t *tctx);
-void	prof_malloc(const void *ptr, size_t usize, prof_tctx_t *tctx);
 void	prof_realloc(tsd_t *tsd, const void *ptr, size_t usize,
     prof_tctx_t *tctx, bool prof_active, bool updated, const void *old_ptr,
     size_t old_usize, prof_tctx_t *old_tctx);
 void	prof_free(tsd_t *tsd, const void *ptr, size_t usize);
 #endif
 
@@ -394,61 +395,61 @@
 	}
 
 	return (tdata);
 }
 
 JEMALLOC_ALWAYS_INLINE prof_tctx_t *
-prof_tctx_get(const void *ptr)
+prof_tctx_get(tsdn_t *tsdn, const void *ptr)
 {
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 
-	return (arena_prof_tctx_get(ptr));
+	return (arena_prof_tctx_get(tsdn, ptr));
 }
 
 JEMALLOC_ALWAYS_INLINE void
-prof_tctx_set(const void *ptr, size_t usize, prof_tctx_t *tctx)
+prof_tctx_set(tsdn_t *tsdn, const void *ptr, size_t usize, prof_tctx_t *tctx)
 {
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 
-	arena_prof_tctx_set(ptr, usize, tctx);
+	arena_prof_tctx_set(tsdn, ptr, usize, tctx);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-prof_tctx_reset(const void *ptr, size_t usize, const void *old_ptr,
+prof_tctx_reset(tsdn_t *tsdn, const void *ptr, size_t usize, const void *old_ptr,
     prof_tctx_t *old_tctx)
 {
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 
-	arena_prof_tctx_reset(ptr, usize, old_ptr, old_tctx);
+	arena_prof_tctx_reset(tsdn, ptr, usize, old_ptr, old_tctx);
 }
 
 JEMALLOC_ALWAYS_INLINE bool
 prof_sample_accum_update(tsd_t *tsd, size_t usize, bool update,
     prof_tdata_t **tdata_out)
 {
 	prof_tdata_t *tdata;
 
 	cassert(config_prof);
 
 	tdata = prof_tdata_get(tsd, true);
-	if ((uintptr_t)tdata <= (uintptr_t)PROF_TDATA_STATE_MAX)
+	if (unlikely((uintptr_t)tdata <= (uintptr_t)PROF_TDATA_STATE_MAX))
 		tdata = NULL;
 
 	if (tdata_out != NULL)
 		*tdata_out = tdata;
 
-	if (tdata == NULL)
+	if (unlikely(tdata == NULL))
 		return (true);
 
-	if (tdata->bytes_until_sample >= usize) {
+	if (likely(tdata->bytes_until_sample >= usize)) {
 		if (update)
 			tdata->bytes_until_sample -= usize;
 		return (true);
 	} else {
 		/* Compute new sample threshold. */
 		if (update)
@@ -476,23 +477,23 @@
 	}
 
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-prof_malloc(const void *ptr, size_t usize, prof_tctx_t *tctx)
+prof_malloc(tsdn_t *tsdn, const void *ptr, size_t usize, prof_tctx_t *tctx)
 {
 
 	cassert(config_prof);
 	assert(ptr != NULL);
-	assert(usize == isalloc(ptr, true));
+	assert(usize == isalloc(tsdn, ptr, true));
 
 	if (unlikely((uintptr_t)tctx > (uintptr_t)1U))
-		prof_malloc_sample_object(ptr, usize, tctx);
+		prof_malloc_sample_object(tsdn, ptr, usize, tctx);
 	else
-		prof_tctx_set(ptr, usize, (prof_tctx_t *)(uintptr_t)1U);
+		prof_tctx_set(tsdn, ptr, usize, (prof_tctx_t *)(uintptr_t)1U);
 }
 
 JEMALLOC_ALWAYS_INLINE void
 prof_realloc(tsd_t *tsd, const void *ptr, size_t usize, prof_tctx_t *tctx,
     bool prof_active, bool updated, const void *old_ptr, size_t old_usize,
     prof_tctx_t *old_tctx)
@@ -500,44 +501,45 @@
 	bool sampled, old_sampled;
 
 	cassert(config_prof);
 	assert(ptr != NULL || (uintptr_t)tctx <= (uintptr_t)1U);
 
 	if (prof_active && !updated && ptr != NULL) {
-		assert(usize == isalloc(ptr, true));
+		assert(usize == isalloc(tsd_tsdn(tsd), ptr, true));
 		if (prof_sample_accum_update(tsd, usize, true, NULL)) {
 			/*
 			 * Don't sample.  The usize passed to prof_alloc_prep()
 			 * was larger than what actually got allocated, so a
 			 * backtrace was captured for this allocation, even
 			 * though its actual usize was insufficient to cross the
 			 * sample threshold.
 			 */
+			prof_alloc_rollback(tsd, tctx, true);
 			tctx = (prof_tctx_t *)(uintptr_t)1U;
 		}
 	}
 
 	sampled = ((uintptr_t)tctx > (uintptr_t)1U);
 	old_sampled = ((uintptr_t)old_tctx > (uintptr_t)1U);
 
 	if (unlikely(sampled))
-		prof_malloc_sample_object(ptr, usize, tctx);
+		prof_malloc_sample_object(tsd_tsdn(tsd), ptr, usize, tctx);
 	else
-		prof_tctx_reset(ptr, usize, old_ptr, old_tctx);
+		prof_tctx_reset(tsd_tsdn(tsd), ptr, usize, old_ptr, old_tctx);
 
 	if (unlikely(old_sampled))
 		prof_free_sampled_object(tsd, old_usize, old_tctx);
 }
 
 JEMALLOC_ALWAYS_INLINE void
 prof_free(tsd_t *tsd, const void *ptr, size_t usize)
 {
-	prof_tctx_t *tctx = prof_tctx_get(ptr);
+	prof_tctx_t *tctx = prof_tctx_get(tsd_tsdn(tsd), ptr);
 
 	cassert(config_prof);
-	assert(usize == isalloc(ptr, true));
+	assert(usize == isalloc(tsd_tsdn(tsd), ptr, true));
 
 	if (unlikely((uintptr_t)tctx > (uintptr_t)1U))
 		prof_free_sampled_object(tsd, usize, tctx);
 }
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/rb.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/rb.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/rb.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/rb.h	2017-01-31 23:32:23.000000000 +0800
@@ -39,13 +39,12 @@
 #endif
 
 /* Root structure. */
 #define	rb_tree(a_type)							\
 struct {								\
     a_type *rbt_root;							\
-    a_type rbt_nil;							\
 }
 
 /* Left accessors. */
 #define	rbtn_left_get(a_type, a_field, a_node)				\
     ((a_node)->a_field.rbn_left)
 #define	rbtn_left_set(a_type, a_field, a_node, a_left) do {		\
@@ -76,12 +75,21 @@
       (a_node)->a_field.rbn_right_red) | ((size_t)1));			\
 } while (0)
 #define	rbtn_black_set(a_type, a_field, a_node) do {			\
     (a_node)->a_field.rbn_right_red = (a_type *) (((intptr_t)		\
       (a_node)->a_field.rbn_right_red) & ((ssize_t)-2));		\
 } while (0)
+
+/* Node initializer. */
+#define	rbt_node_new(a_type, a_field, a_rbt, a_node) do {		\
+    /* Bookkeeping bit cannot be used by node pointer. */		\
+    assert(((uintptr_t)(a_node) & 0x1) == 0);				\
+    rbtn_left_set(a_type, a_field, (a_node), NULL);	\
+    rbtn_right_set(a_type, a_field, (a_node), NULL);	\
+    rbtn_red_set(a_type, a_field, (a_node));				\
+} while (0)
 #else
 /* Right accessors. */
 #define	rbtn_right_get(a_type, a_field, a_node)				\
     ((a_node)->a_field.rbn_right)
 #define	rbtn_right_set(a_type, a_field, a_node, a_right) do {		\
     (a_node)->a_field.rbn_right = a_right;				\
@@ -96,45 +104,42 @@
 #define	rbtn_red_set(a_type, a_field, a_node) do {			\
     (a_node)->a_field.rbn_red = true;					\
 } while (0)
 #define	rbtn_black_set(a_type, a_field, a_node) do {			\
     (a_node)->a_field.rbn_red = false;					\
 } while (0)
-#endif
 
 /* Node initializer. */
 #define	rbt_node_new(a_type, a_field, a_rbt, a_node) do {		\
-    rbtn_left_set(a_type, a_field, (a_node), &(a_rbt)->rbt_nil);	\
-    rbtn_right_set(a_type, a_field, (a_node), &(a_rbt)->rbt_nil);	\
+    rbtn_left_set(a_type, a_field, (a_node), NULL);	\
+    rbtn_right_set(a_type, a_field, (a_node), NULL);	\
     rbtn_red_set(a_type, a_field, (a_node));				\
 } while (0)
+#endif
 
 /* Tree initializer. */
 #define	rb_new(a_type, a_field, a_rbt) do {				\
-    (a_rbt)->rbt_root = &(a_rbt)->rbt_nil;				\
-    rbt_node_new(a_type, a_field, a_rbt, &(a_rbt)->rbt_nil);		\
-    rbtn_black_set(a_type, a_field, &(a_rbt)->rbt_nil);			\
+    (a_rbt)->rbt_root = NULL;						\
 } while (0)
 
 /* Internal utility macros. */
 #define	rbtn_first(a_type, a_field, a_rbt, a_root, r_node) do {		\
     (r_node) = (a_root);						\
-    if ((r_node) != &(a_rbt)->rbt_nil) {				\
+    if ((r_node) != NULL) {						\
 	for (;								\
-	  rbtn_left_get(a_type, a_field, (r_node)) != &(a_rbt)->rbt_nil;\
+	  rbtn_left_get(a_type, a_field, (r_node)) != NULL;		\
 	  (r_node) = rbtn_left_get(a_type, a_field, (r_node))) {	\
 	}								\
     }									\
 } while (0)
 
 #define	rbtn_last(a_type, a_field, a_rbt, a_root, r_node) do {		\
     (r_node) = (a_root);						\
-    if ((r_node) != &(a_rbt)->rbt_nil) {				\
-	for (; rbtn_right_get(a_type, a_field, (r_node)) !=		\
-	  &(a_rbt)->rbt_nil; (r_node) = rbtn_right_get(a_type, a_field,	\
-	  (r_node))) {							\
+    if ((r_node) != NULL) {						\
+	for (; rbtn_right_get(a_type, a_field, (r_node)) != NULL;	\
+	  (r_node) = rbtn_right_get(a_type, a_field, (r_node))) {	\
 	}								\
     }									\
 } while (0)
 
 #define	rbtn_rotate_left(a_type, a_field, a_node, r_node) do {		\
     (r_node) = rbtn_right_get(a_type, a_field, (a_node));		\
@@ -166,27 +171,30 @@
 a_prefix##last(a_rbt_type *rbtree);					\
 a_attr a_type *								\
 a_prefix##next(a_rbt_type *rbtree, a_type *node);			\
 a_attr a_type *								\
 a_prefix##prev(a_rbt_type *rbtree, a_type *node);			\
 a_attr a_type *								\
-a_prefix##search(a_rbt_type *rbtree, a_type *key);			\
+a_prefix##search(a_rbt_type *rbtree, const a_type *key);		\
 a_attr a_type *								\
-a_prefix##nsearch(a_rbt_type *rbtree, a_type *key);			\
+a_prefix##nsearch(a_rbt_type *rbtree, const a_type *key);		\
 a_attr a_type *								\
-a_prefix##psearch(a_rbt_type *rbtree, a_type *key);			\
+a_prefix##psearch(a_rbt_type *rbtree, const a_type *key);		\
 a_attr void								\
 a_prefix##insert(a_rbt_type *rbtree, a_type *node);			\
 a_attr void								\
 a_prefix##remove(a_rbt_type *rbtree, a_type *node);			\
 a_attr a_type *								\
 a_prefix##iter(a_rbt_type *rbtree, a_type *start, a_type *(*cb)(	\
   a_rbt_type *, a_type *, void *), void *arg);				\
 a_attr a_type *								\
 a_prefix##reverse_iter(a_rbt_type *rbtree, a_type *start,		\
-  a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg);
+  a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg);		\
+a_attr void								\
+a_prefix##destroy(a_rbt_type *rbtree, void (*cb)(a_type *, void *),	\
+  void *arg);
 
 /*
  * The rb_gen() macro generates a type-specific red-black tree implementation,
  * based on the above cpp macros.
  *
  * Arguments:
@@ -251,23 +259,23 @@
  *         tree: Pointer to an initialized red-black tree object.
  *         node: A node in tree.
  *       Ret: node's successor/predecessor in tree, or NULL if node is
  *            last/first.
  *
  *   static ex_node_t *
- *   ex_search(ex_t *tree, ex_node_t *key);
+ *   ex_search(ex_t *tree, const ex_node_t *key);
  *       Description: Search for node that matches key.
  *       Args:
  *         tree: Pointer to an initialized red-black tree object.
  *         key : Search key.
  *       Ret: Node in tree that matches key, or NULL if no match.
  *
  *   static ex_node_t *
- *   ex_nsearch(ex_t *tree, ex_node_t *key);
+ *   ex_nsearch(ex_t *tree, const ex_node_t *key);
  *   static ex_node_t *
- *   ex_psearch(ex_t *tree, ex_node_t *key);
+ *   ex_psearch(ex_t *tree, const ex_node_t *key);
  *       Description: Search for node that matches key.  If no match is found,
  *                    return what would be key's successor/predecessor, were
  *                    key in tree.
  *       Args:
  *         tree: Pointer to an initialized red-black tree object.
  *         key : Search key.
@@ -309,168 +317,161 @@
  *                terminated and the non-NULL return value is returned by the
  *                iterator.  This is useful for re-starting iteration after
  *                modifying tree.
  *         arg  : Opaque pointer passed to cb().
  *       Ret: NULL if iteration completed, or the non-NULL callback return value
  *            that caused termination of the iteration.
+ *
+ *   static void
+ *   ex_destroy(ex_t *tree, void (*cb)(ex_node_t *, void *), void *arg);
+ *       Description: Iterate over the tree with post-order traversal, remove
+ *                    each node, and run the callback if non-null.  This is
+ *                    used for destroying a tree without paying the cost to
+ *                    rebalance it.  The tree must not be otherwise altered
+ *                    during traversal.
+ *       Args:
+ *         tree: Pointer to an initialized red-black tree object.
+ *         cb  : Callback function, which, if non-null, is called for each node
+ *               during iteration.  There is no way to stop iteration once it
+ *               has begun.
+ *         arg : Opaque pointer passed to cb().
  */
 #define	rb_gen(a_attr, a_prefix, a_rbt_type, a_type, a_field, a_cmp)	\
 a_attr void								\
 a_prefix##new(a_rbt_type *rbtree) {					\
     rb_new(a_type, a_field, rbtree);					\
 }									\
 a_attr bool								\
 a_prefix##empty(a_rbt_type *rbtree) {					\
-    return (rbtree->rbt_root == &rbtree->rbt_nil);			\
+    return (rbtree->rbt_root == NULL);					\
 }									\
 a_attr a_type *								\
 a_prefix##first(a_rbt_type *rbtree) {					\
     a_type *ret;							\
     rbtn_first(a_type, a_field, rbtree, rbtree->rbt_root, ret);		\
-    if (ret == &rbtree->rbt_nil) {					\
-	ret = NULL;							\
-    }									\
     return (ret);							\
 }									\
 a_attr a_type *								\
 a_prefix##last(a_rbt_type *rbtree) {					\
     a_type *ret;							\
     rbtn_last(a_type, a_field, rbtree, rbtree->rbt_root, ret);		\
-    if (ret == &rbtree->rbt_nil) {					\
-	ret = NULL;							\
-    }									\
     return (ret);							\
 }									\
 a_attr a_type *								\
 a_prefix##next(a_rbt_type *rbtree, a_type *node) {			\
     a_type *ret;							\
-    if (rbtn_right_get(a_type, a_field, node) != &rbtree->rbt_nil) {	\
+    if (rbtn_right_get(a_type, a_field, node) != NULL) {		\
 	rbtn_first(a_type, a_field, rbtree, rbtn_right_get(a_type,	\
 	  a_field, node), ret);						\
     } else {								\
 	a_type *tnode = rbtree->rbt_root;				\
-	assert(tnode != &rbtree->rbt_nil);				\
-	ret = &rbtree->rbt_nil;						\
+	assert(tnode != NULL);						\
+	ret = NULL;							\
 	while (true) {							\
 	    int cmp = (a_cmp)(node, tnode);				\
 	    if (cmp < 0) {						\
 		ret = tnode;						\
 		tnode = rbtn_left_get(a_type, a_field, tnode);		\
 	    } else if (cmp > 0) {					\
 		tnode = rbtn_right_get(a_type, a_field, tnode);		\
 	    } else {							\
 		break;							\
 	    }								\
-	    assert(tnode != &rbtree->rbt_nil);				\
+	    assert(tnode != NULL);					\
 	}								\
     }									\
-    if (ret == &rbtree->rbt_nil) {					\
-	ret = (NULL);							\
-    }									\
     return (ret);							\
 }									\
 a_attr a_type *								\
 a_prefix##prev(a_rbt_type *rbtree, a_type *node) {			\
     a_type *ret;							\
-    if (rbtn_left_get(a_type, a_field, node) != &rbtree->rbt_nil) {	\
+    if (rbtn_left_get(a_type, a_field, node) != NULL) {			\
 	rbtn_last(a_type, a_field, rbtree, rbtn_left_get(a_type,	\
 	  a_field, node), ret);						\
     } else {								\
 	a_type *tnode = rbtree->rbt_root;				\
-	assert(tnode != &rbtree->rbt_nil);				\
-	ret = &rbtree->rbt_nil;						\
+	assert(tnode != NULL);						\
+	ret = NULL;							\
 	while (true) {							\
 	    int cmp = (a_cmp)(node, tnode);				\
 	    if (cmp < 0) {						\
 		tnode = rbtn_left_get(a_type, a_field, tnode);		\
 	    } else if (cmp > 0) {					\
 		ret = tnode;						\
 		tnode = rbtn_right_get(a_type, a_field, tnode);		\
 	    } else {							\
 		break;							\
 	    }								\
-	    assert(tnode != &rbtree->rbt_nil);				\
+	    assert(tnode != NULL);					\
 	}								\
     }									\
-    if (ret == &rbtree->rbt_nil) {					\
-	ret = (NULL);							\
-    }									\
     return (ret);							\
 }									\
 a_attr a_type *								\
-a_prefix##search(a_rbt_type *rbtree, a_type *key) {			\
+a_prefix##search(a_rbt_type *rbtree, const a_type *key) {		\
     a_type *ret;							\
     int cmp;								\
     ret = rbtree->rbt_root;						\
-    while (ret != &rbtree->rbt_nil					\
+    while (ret != NULL							\
       && (cmp = (a_cmp)(key, ret)) != 0) {				\
 	if (cmp < 0) {							\
 	    ret = rbtn_left_get(a_type, a_field, ret);			\
 	} else {							\
 	    ret = rbtn_right_get(a_type, a_field, ret);			\
 	}								\
     }									\
-    if (ret == &rbtree->rbt_nil) {					\
-	ret = (NULL);							\
-    }									\
     return (ret);							\
 }									\
 a_attr a_type *								\
-a_prefix##nsearch(a_rbt_type *rbtree, a_type *key) {			\
+a_prefix##nsearch(a_rbt_type *rbtree, const a_type *key) {		\
     a_type *ret;							\
     a_type *tnode = rbtree->rbt_root;					\
-    ret = &rbtree->rbt_nil;						\
-    while (tnode != &rbtree->rbt_nil) {					\
+    ret = NULL;								\
+    while (tnode != NULL) {						\
 	int cmp = (a_cmp)(key, tnode);					\
 	if (cmp < 0) {							\
 	    ret = tnode;						\
 	    tnode = rbtn_left_get(a_type, a_field, tnode);		\
 	} else if (cmp > 0) {						\
 	    tnode = rbtn_right_get(a_type, a_field, tnode);		\
 	} else {							\
 	    ret = tnode;						\
 	    break;							\
 	}								\
     }									\
-    if (ret == &rbtree->rbt_nil) {					\
-	ret = (NULL);							\
-    }									\
     return (ret);							\
 }									\
 a_attr a_type *								\
-a_prefix##psearch(a_rbt_type *rbtree, a_type *key) {			\
+a_prefix##psearch(a_rbt_type *rbtree, const a_type *key) {		\
     a_type *ret;							\
     a_type *tnode = rbtree->rbt_root;					\
-    ret = &rbtree->rbt_nil;						\
-    while (tnode != &rbtree->rbt_nil) {					\
+    ret = NULL;								\
+    while (tnode != NULL) {						\
 	int cmp = (a_cmp)(key, tnode);					\
 	if (cmp < 0) {							\
 	    tnode = rbtn_left_get(a_type, a_field, tnode);		\
 	} else if (cmp > 0) {						\
 	    ret = tnode;						\
 	    tnode = rbtn_right_get(a_type, a_field, tnode);		\
 	} else {							\
 	    ret = tnode;						\
 	    break;							\
 	}								\
     }									\
-    if (ret == &rbtree->rbt_nil) {					\
-	ret = (NULL);							\
-    }									\
     return (ret);							\
 }									\
 a_attr void								\
 a_prefix##insert(a_rbt_type *rbtree, a_type *node) {			\
     struct {								\
 	a_type *node;							\
 	int cmp;							\
     } path[sizeof(void *) << 4], *pathp;				\
     rbt_node_new(a_type, a_field, rbtree, node);			\
     /* Wind. */								\
     path->node = rbtree->rbt_root;					\
-    for (pathp = path; pathp->node != &rbtree->rbt_nil; pathp++) {	\
+    for (pathp = path; pathp->node != NULL; pathp++) {			\
 	int cmp = pathp->cmp = a_cmp(node, pathp->node);		\
 	assert(cmp != 0);						\
 	if (cmp < 0) {							\
 	    pathp[1].node = rbtn_left_get(a_type, a_field,		\
 	      pathp->node);						\
 	} else {							\
@@ -484,13 +485,14 @@
 	a_type *cnode = pathp->node;					\
 	if (pathp->cmp < 0) {						\
 	    a_type *left = pathp[1].node;				\
 	    rbtn_left_set(a_type, a_field, cnode, left);		\
 	    if (rbtn_red_get(a_type, a_field, left)) {			\
 		a_type *leftleft = rbtn_left_get(a_type, a_field, left);\
-		if (rbtn_red_get(a_type, a_field, leftleft)) {		\
+		if (leftleft != NULL && rbtn_red_get(a_type, a_field,	\
+		  leftleft)) {						\
 		    /* Fix up 4-node. */				\
 		    a_type *tnode;					\
 		    rbtn_black_set(a_type, a_field, leftleft);		\
 		    rbtn_rotate_right(a_type, a_field, cnode, tnode);	\
 		    cnode = tnode;					\
 		}							\
@@ -499,13 +501,14 @@
 	    }								\
 	} else {							\
 	    a_type *right = pathp[1].node;				\
 	    rbtn_right_set(a_type, a_field, cnode, right);		\
 	    if (rbtn_red_get(a_type, a_field, right)) {			\
 		a_type *left = rbtn_left_get(a_type, a_field, cnode);	\
-		if (rbtn_red_get(a_type, a_field, left)) {		\
+		if (left != NULL && rbtn_red_get(a_type, a_field,	\
+		  left)) {						\
 		    /* Split 4-node. */					\
 		    rbtn_black_set(a_type, a_field, left);		\
 		    rbtn_black_set(a_type, a_field, right);		\
 		    rbtn_red_set(a_type, a_field, cnode);		\
 		} else {						\
 		    /* Lean left. */					\
@@ -532,25 +535,25 @@
 	a_type *node;							\
 	int cmp;							\
     } *pathp, *nodep, path[sizeof(void *) << 4];			\
     /* Wind. */								\
     nodep = NULL; /* Silence compiler warning. */			\
     path->node = rbtree->rbt_root;					\
-    for (pathp = path; pathp->node != &rbtree->rbt_nil; pathp++) {	\
+    for (pathp = path; pathp->node != NULL; pathp++) {			\
 	int cmp = pathp->cmp = a_cmp(node, pathp->node);		\
 	if (cmp < 0) {							\
 	    pathp[1].node = rbtn_left_get(a_type, a_field,		\
 	      pathp->node);						\
 	} else {							\
 	    pathp[1].node = rbtn_right_get(a_type, a_field,		\
 	      pathp->node);						\
 	    if (cmp == 0) {						\
 	        /* Find node's successor, in preparation for swap. */	\
 		pathp->cmp = 1;						\
 		nodep = pathp;						\
-		for (pathp++; pathp->node != &rbtree->rbt_nil;		\
+		for (pathp++; pathp->node != NULL;			\
 		  pathp++) {						\
 		    pathp->cmp = -1;					\
 		    pathp[1].node = rbtn_left_get(a_type, a_field,	\
 		      pathp->node);					\
 		}							\
 		break;							\
@@ -587,13 +590,13 @@
 		rbtn_right_set(a_type, a_field, nodep[-1].node,		\
 		  nodep->node);						\
 	    }								\
 	}								\
     } else {								\
 	a_type *left = rbtn_left_get(a_type, a_field, node);		\
-	if (left != &rbtree->rbt_nil) {					\
+	if (left != NULL) {						\
 	    /* node has no successor, but it has a left child.        */\
 	    /* Splice node out, without losing the left child.        */\
 	    assert(!rbtn_red_get(a_type, a_field, node));		\
 	    assert(rbtn_red_get(a_type, a_field, left));		\
 	    rbtn_black_set(a_type, a_field, left);			\
 	    if (pathp == path) {					\
@@ -607,39 +610,38 @@
 		      left);						\
 		}							\
 	    }								\
 	    return;							\
 	} else if (pathp == path) {					\
 	    /* The tree only contained one node. */			\
-	    rbtree->rbt_root = &rbtree->rbt_nil;			\
+	    rbtree->rbt_root = NULL;					\
 	    return;							\
 	}								\
     }									\
     if (rbtn_red_get(a_type, a_field, pathp->node)) {			\
 	/* Prune red node, which requires no fixup. */			\
 	assert(pathp[-1].cmp < 0);					\
-	rbtn_left_set(a_type, a_field, pathp[-1].node,			\
-	  &rbtree->rbt_nil);						\
+	rbtn_left_set(a_type, a_field, pathp[-1].node, NULL);		\
 	return;								\
     }									\
     /* The node to be pruned is black, so unwind until balance is     */\
     /* restored.                                                      */\
-    pathp->node = &rbtree->rbt_nil;					\
+    pathp->node = NULL;							\
     for (pathp--; (uintptr_t)pathp >= (uintptr_t)path; pathp--) {	\
 	assert(pathp->cmp != 0);					\
 	if (pathp->cmp < 0) {						\
 	    rbtn_left_set(a_type, a_field, pathp->node,			\
 	      pathp[1].node);						\
-	    assert(!rbtn_red_get(a_type, a_field, pathp[1].node));	\
 	    if (rbtn_red_get(a_type, a_field, pathp->node)) {		\
 		a_type *right = rbtn_right_get(a_type, a_field,		\
 		  pathp->node);						\
 		a_type *rightleft = rbtn_left_get(a_type, a_field,	\
 		  right);						\
 		a_type *tnode;						\
-		if (rbtn_red_get(a_type, a_field, rightleft)) {		\
+		if (rightleft != NULL && rbtn_red_get(a_type, a_field,	\
+		  rightleft)) {						\
 		    /* In the following diagrams, ||, //, and \\      */\
 		    /* indicate the path to the removed node.         */\
 		    /*                                                */\
 		    /*      ||                                        */\
 		    /*    pathp(r)                                    */\
 		    /*  //        \                                   */\
@@ -676,13 +678,14 @@
 		return;							\
 	    } else {							\
 		a_type *right = rbtn_right_get(a_type, a_field,		\
 		  pathp->node);						\
 		a_type *rightleft = rbtn_left_get(a_type, a_field,	\
 		  right);						\
-		if (rbtn_red_get(a_type, a_field, rightleft)) {		\
+		if (rightleft != NULL && rbtn_red_get(a_type, a_field,	\
+		  rightleft)) {						\
 		    /*      ||                                        */\
 		    /*    pathp(b)                                    */\
 		    /*  //        \                                   */\
 		    /* (b)        (b)                                 */\
 		    /*           /                                    */\
 		    /*          (r)                                   */\
@@ -730,13 +733,14 @@
 	    if (rbtn_red_get(a_type, a_field, left)) {			\
 		a_type *tnode;						\
 		a_type *leftright = rbtn_right_get(a_type, a_field,	\
 		  left);						\
 		a_type *leftrightleft = rbtn_left_get(a_type, a_field,	\
 		  leftright);						\
-		if (rbtn_red_get(a_type, a_field, leftrightleft)) {	\
+		if (leftrightleft != NULL && rbtn_red_get(a_type,	\
+		  a_field, leftrightleft)) {				\
 		    /*      ||                                        */\
 		    /*    pathp(b)                                    */\
 		    /*   /        \\                                  */\
 		    /* (r)        (b)                                 */\
 		    /*   \                                            */\
 		    /*   (b)                                          */\
@@ -756,13 +760,13 @@
 		    /*   /        \\                                  */\
 		    /* (r)        (b)                                 */\
 		    /*   \                                            */\
 		    /*   (b)                                          */\
 		    /*   /                                            */\
 		    /* (b)                                            */\
-		    assert(leftright != &rbtree->rbt_nil);		\
+		    assert(leftright != NULL);				\
 		    rbtn_red_set(a_type, a_field, leftright);		\
 		    rbtn_rotate_right(a_type, a_field, pathp->node,	\
 		      tnode);						\
 		    rbtn_black_set(a_type, a_field, tnode);		\
 		}							\
 		/* Balance restored, but rotation modified subtree    */\
@@ -779,13 +783,14 @@
 			  tnode);					\
 		    }							\
 		}							\
 		return;							\
 	    } else if (rbtn_red_get(a_type, a_field, pathp->node)) {	\
 		a_type *leftleft = rbtn_left_get(a_type, a_field, left);\
-		if (rbtn_red_get(a_type, a_field, leftleft)) {		\
+		if (leftleft != NULL && rbtn_red_get(a_type, a_field,	\
+		  leftleft)) {						\
 		    /*        ||                                      */\
 		    /*      pathp(r)                                  */\
 		    /*     /        \\                                */\
 		    /*   (b)        (b)                               */\
 		    /*   /                                            */\
 		    /* (r)                                            */\
@@ -817,13 +822,14 @@
 		    rbtn_black_set(a_type, a_field, pathp->node);	\
 		    /* Balance restored. */				\
 		    return;						\
 		}							\
 	    } else {							\
 		a_type *leftleft = rbtn_left_get(a_type, a_field, left);\
-		if (rbtn_red_get(a_type, a_field, leftleft)) {		\
+		if (leftleft != NULL && rbtn_red_get(a_type, a_field,	\
+		  leftleft)) {						\
 		    /*               ||                               */\
 		    /*             pathp(b)                           */\
 		    /*            /        \\                         */\
 		    /*          (b)        (b)                        */\
 		    /*          /                                     */\
 		    /*        (r)                                     */\
@@ -863,19 +869,19 @@
     rbtree->rbt_root = path->node;					\
     assert(!rbtn_red_get(a_type, a_field, rbtree->rbt_root));		\
 }									\
 a_attr a_type *								\
 a_prefix##iter_recurse(a_rbt_type *rbtree, a_type *node,		\
   a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
-    if (node == &rbtree->rbt_nil) {					\
-	return (&rbtree->rbt_nil);					\
+    if (node == NULL) {							\
+	return (NULL);							\
     } else {								\
 	a_type *ret;							\
 	if ((ret = a_prefix##iter_recurse(rbtree, rbtn_left_get(a_type,	\
-	  a_field, node), cb, arg)) != &rbtree->rbt_nil			\
-	  || (ret = cb(rbtree, node, arg)) != NULL) {			\
+	  a_field, node), cb, arg)) != NULL || (ret = cb(rbtree, node,	\
+	  arg)) != NULL) {						\
 	    return (ret);						\
 	}								\
 	return (a_prefix##iter_recurse(rbtree, rbtn_right_get(a_type,	\
 	  a_field, node), cb, arg));					\
     }									\
 }									\
@@ -883,14 +889,14 @@
 a_prefix##iter_start(a_rbt_type *rbtree, a_type *start, a_type *node,	\
   a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
     int cmp = a_cmp(start, node);					\
     if (cmp < 0) {							\
 	a_type *ret;							\
 	if ((ret = a_prefix##iter_start(rbtree, start,			\
-	  rbtn_left_get(a_type, a_field, node), cb, arg)) !=		\
-	  &rbtree->rbt_nil || (ret = cb(rbtree, node, arg)) != NULL) {	\
+	  rbtn_left_get(a_type, a_field, node), cb, arg)) != NULL ||	\
+	  (ret = cb(rbtree, node, arg)) != NULL) {			\
 	    return (ret);						\
 	}								\
 	return (a_prefix##iter_recurse(rbtree, rbtn_right_get(a_type,	\
 	  a_field, node), cb, arg));					\
     } else if (cmp > 0) {						\
 	return (a_prefix##iter_start(rbtree, start,			\
@@ -911,27 +917,24 @@
     if (start != NULL) {						\
 	ret = a_prefix##iter_start(rbtree, start, rbtree->rbt_root,	\
 	  cb, arg);							\
     } else {								\
 	ret = a_prefix##iter_recurse(rbtree, rbtree->rbt_root, cb, arg);\
     }									\
-    if (ret == &rbtree->rbt_nil) {					\
-	ret = NULL;							\
-    }									\
     return (ret);							\
 }									\
 a_attr a_type *								\
 a_prefix##reverse_iter_recurse(a_rbt_type *rbtree, a_type *node,	\
   a_type *(*cb)(a_rbt_type *, a_type *, void *), void *arg) {		\
-    if (node == &rbtree->rbt_nil) {					\
-	return (&rbtree->rbt_nil);					\
+    if (node == NULL) {							\
+	return (NULL);							\
     } else {								\
 	a_type *ret;							\
 	if ((ret = a_prefix##reverse_iter_recurse(rbtree,		\
-	  rbtn_right_get(a_type, a_field, node), cb, arg)) !=		\
-	  &rbtree->rbt_nil || (ret = cb(rbtree, node, arg)) != NULL) {	\
+	  rbtn_right_get(a_type, a_field, node), cb, arg)) != NULL ||	\
+	  (ret = cb(rbtree, node, arg)) != NULL) {			\
 	    return (ret);						\
 	}								\
 	return (a_prefix##reverse_iter_recurse(rbtree,			\
 	  rbtn_left_get(a_type, a_field, node), cb, arg));		\
     }									\
 }									\
@@ -940,14 +943,14 @@
   a_type *node, a_type *(*cb)(a_rbt_type *, a_type *, void *),		\
   void *arg) {								\
     int cmp = a_cmp(start, node);					\
     if (cmp > 0) {							\
 	a_type *ret;							\
 	if ((ret = a_prefix##reverse_iter_start(rbtree, start,		\
-	  rbtn_right_get(a_type, a_field, node), cb, arg)) !=		\
-	  &rbtree->rbt_nil || (ret = cb(rbtree, node, arg)) != NULL) {	\
+	  rbtn_right_get(a_type, a_field, node), cb, arg)) != NULL ||	\
+	  (ret = cb(rbtree, node, arg)) != NULL) {			\
 	    return (ret);						\
 	}								\
 	return (a_prefix##reverse_iter_recurse(rbtree,			\
 	  rbtn_left_get(a_type, a_field, node), cb, arg));		\
     } else if (cmp < 0) {						\
 	return (a_prefix##reverse_iter_start(rbtree, start,		\
@@ -969,13 +972,32 @@
 	ret = a_prefix##reverse_iter_start(rbtree, start,		\
 	  rbtree->rbt_root, cb, arg);					\
     } else {								\
 	ret = a_prefix##reverse_iter_recurse(rbtree, rbtree->rbt_root,	\
 	  cb, arg);							\
     }									\
-    if (ret == &rbtree->rbt_nil) {					\
-	ret = NULL;							\
-    }									\
     return (ret);							\
+}									\
+a_attr void								\
+a_prefix##destroy_recurse(a_rbt_type *rbtree, a_type *node, void (*cb)(	\
+  a_type *, void *), void *arg) {					\
+    if (node == NULL) {							\
+	return;								\
+    }									\
+    a_prefix##destroy_recurse(rbtree, rbtn_left_get(a_type, a_field,	\
+      node), cb, arg);							\
+    rbtn_left_set(a_type, a_field, (node), NULL);			\
+    a_prefix##destroy_recurse(rbtree, rbtn_right_get(a_type, a_field,	\
+      node), cb, arg);							\
+    rbtn_right_set(a_type, a_field, (node), NULL);			\
+    if (cb) {								\
+	cb(node, arg);							\
+    }									\
+}									\
+a_attr void								\
+a_prefix##destroy(a_rbt_type *rbtree, void (*cb)(a_type *, void *),	\
+  void *arg) {								\
+    a_prefix##destroy_recurse(rbtree, rbtree->rbt_root, cb, arg);	\
+    rbtree->rbt_root = NULL;						\
 }
 
 #endif /* RB_H_ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/rtree.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/rtree.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/rtree.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/rtree.h	2017-01-31 23:32:23.000000000 +0800
@@ -12,15 +12,16 @@
 
 /*
  * RTREE_BITS_PER_LEVEL must be a power of two that is no larger than the
  * machine address width.
  */
 #define	LG_RTREE_BITS_PER_LEVEL	4
-#define	RTREE_BITS_PER_LEVEL	(ZU(1) << LG_RTREE_BITS_PER_LEVEL)
+#define	RTREE_BITS_PER_LEVEL	(1U << LG_RTREE_BITS_PER_LEVEL)
+/* Maximum rtree height. */
 #define	RTREE_HEIGHT_MAX						\
-    ((ZU(1) << (LG_SIZEOF_PTR+3)) / RTREE_BITS_PER_LEVEL)
+    ((1U << (LG_SIZEOF_PTR+3)) / RTREE_BITS_PER_LEVEL)
 
 /* Used for two-stage lock-free node initialization. */
 #define	RTREE_NODE_INITIALIZING	((rtree_node_elm_t *)0x1)
 
 /*
  * The node allocation callback function's argument is the number of contiguous
@@ -108,28 +109,31 @@
 
 #ifndef JEMALLOC_ENABLE_INLINE
 unsigned	rtree_start_level(rtree_t *rtree, uintptr_t key);
 uintptr_t	rtree_subkey(rtree_t *rtree, uintptr_t key, unsigned level);
 
 bool	rtree_node_valid(rtree_node_elm_t *node);
-rtree_node_elm_t	*rtree_child_tryread(rtree_node_elm_t *elm);
+rtree_node_elm_t	*rtree_child_tryread(rtree_node_elm_t *elm,
+    bool dependent);
 rtree_node_elm_t	*rtree_child_read(rtree_t *rtree, rtree_node_elm_t *elm,
-    unsigned level);
+    unsigned level, bool dependent);
 extent_node_t	*rtree_val_read(rtree_t *rtree, rtree_node_elm_t *elm,
     bool dependent);
 void	rtree_val_write(rtree_t *rtree, rtree_node_elm_t *elm,
     const extent_node_t *val);
-rtree_node_elm_t	*rtree_subtree_tryread(rtree_t *rtree, unsigned level);
-rtree_node_elm_t	*rtree_subtree_read(rtree_t *rtree, unsigned level);
+rtree_node_elm_t	*rtree_subtree_tryread(rtree_t *rtree, unsigned level,
+    bool dependent);
+rtree_node_elm_t	*rtree_subtree_read(rtree_t *rtree, unsigned level,
+    bool dependent);
 
 extent_node_t	*rtree_get(rtree_t *rtree, uintptr_t key, bool dependent);
 bool	rtree_set(rtree_t *rtree, uintptr_t key, const extent_node_t *val);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_RTREE_C_))
-JEMALLOC_INLINE unsigned
+JEMALLOC_ALWAYS_INLINE unsigned
 rtree_start_level(rtree_t *rtree, uintptr_t key)
 {
 	unsigned start_level;
 
 	if (unlikely(key == 0))
 		return (rtree->height - 1);
@@ -137,52 +141,55 @@
 	start_level = rtree->start_level[lg_floor(key) >>
 	    LG_RTREE_BITS_PER_LEVEL];
 	assert(start_level < rtree->height);
 	return (start_level);
 }
 
-JEMALLOC_INLINE uintptr_t
+JEMALLOC_ALWAYS_INLINE uintptr_t
 rtree_subkey(rtree_t *rtree, uintptr_t key, unsigned level)
 {
 
 	return ((key >> ((ZU(1) << (LG_SIZEOF_PTR+3)) -
 	    rtree->levels[level].cumbits)) & ((ZU(1) <<
 	    rtree->levels[level].bits) - 1));
 }
 
-JEMALLOC_INLINE bool
+JEMALLOC_ALWAYS_INLINE bool
 rtree_node_valid(rtree_node_elm_t *node)
 {
 
 	return ((uintptr_t)node > (uintptr_t)RTREE_NODE_INITIALIZING);
 }
 
-JEMALLOC_INLINE rtree_node_elm_t *
-rtree_child_tryread(rtree_node_elm_t *elm)
+JEMALLOC_ALWAYS_INLINE rtree_node_elm_t *
+rtree_child_tryread(rtree_node_elm_t *elm, bool dependent)
 {
 	rtree_node_elm_t *child;
 
 	/* Double-checked read (first read may be stale. */
 	child = elm->child;
-	if (!rtree_node_valid(child))
+	if (!dependent && !rtree_node_valid(child))
 		child = atomic_read_p(&elm->pun);
+	assert(!dependent || child != NULL);
 	return (child);
 }
 
-JEMALLOC_INLINE rtree_node_elm_t *
-rtree_child_read(rtree_t *rtree, rtree_node_elm_t *elm, unsigned level)
+JEMALLOC_ALWAYS_INLINE rtree_node_elm_t *
+rtree_child_read(rtree_t *rtree, rtree_node_elm_t *elm, unsigned level,
+    bool dependent)
 {
 	rtree_node_elm_t *child;
 
-	child = rtree_child_tryread(elm);
-	if (unlikely(!rtree_node_valid(child)))
+	child = rtree_child_tryread(elm, dependent);
+	if (!dependent && unlikely(!rtree_node_valid(child)))
 		child = rtree_child_read_hard(rtree, elm, level);
+	assert(!dependent || child != NULL);
 	return (child);
 }
 
-JEMALLOC_INLINE extent_node_t *
+JEMALLOC_ALWAYS_INLINE extent_node_t *
 rtree_val_read(rtree_t *rtree, rtree_node_elm_t *elm, bool dependent)
 {
 
 	if (dependent) {
 		/*
 		 * Reading a val on behalf of a pointer to a valid allocation is
@@ -205,73 +212,138 @@
 rtree_val_write(rtree_t *rtree, rtree_node_elm_t *elm, const extent_node_t *val)
 {
 
 	atomic_write_p(&elm->pun, val);
 }
 
-JEMALLOC_INLINE rtree_node_elm_t *
-rtree_subtree_tryread(rtree_t *rtree, unsigned level)
+JEMALLOC_ALWAYS_INLINE rtree_node_elm_t *
+rtree_subtree_tryread(rtree_t *rtree, unsigned level, bool dependent)
 {
 	rtree_node_elm_t *subtree;
 
 	/* Double-checked read (first read may be stale. */
 	subtree = rtree->levels[level].subtree;
-	if (!rtree_node_valid(subtree))
+	if (!dependent && unlikely(!rtree_node_valid(subtree)))
 		subtree = atomic_read_p(&rtree->levels[level].subtree_pun);
+	assert(!dependent || subtree != NULL);
 	return (subtree);
 }
 
-JEMALLOC_INLINE rtree_node_elm_t *
-rtree_subtree_read(rtree_t *rtree, unsigned level)
+JEMALLOC_ALWAYS_INLINE rtree_node_elm_t *
+rtree_subtree_read(rtree_t *rtree, unsigned level, bool dependent)
 {
 	rtree_node_elm_t *subtree;
 
-	subtree = rtree_subtree_tryread(rtree, level);
-	if (unlikely(!rtree_node_valid(subtree)))
+	subtree = rtree_subtree_tryread(rtree, level, dependent);
+	if (!dependent && unlikely(!rtree_node_valid(subtree)))
 		subtree = rtree_subtree_read_hard(rtree, level);
+	assert(!dependent || subtree != NULL);
 	return (subtree);
 }
 
-JEMALLOC_INLINE extent_node_t *
+JEMALLOC_ALWAYS_INLINE extent_node_t *
 rtree_get(rtree_t *rtree, uintptr_t key, bool dependent)
 {
 	uintptr_t subkey;
-	unsigned i, start_level;
-	rtree_node_elm_t *node, *child;
+	unsigned start_level;
+	rtree_node_elm_t *node;
 
 	start_level = rtree_start_level(rtree, key);
 
-	for (i = start_level, node = rtree_subtree_tryread(rtree, start_level);
-	    /**/; i++, node = child) {
-		if (!dependent && unlikely(!rtree_node_valid(node)))
-			return (NULL);
-		subkey = rtree_subkey(rtree, key, i);
-		if (i == rtree->height - 1) {
-			/*
-			 * node is a leaf, so it contains values rather than
-			 * child pointers.
-			 */
-			return (rtree_val_read(rtree, &node[subkey],
-			    dependent));
-		}
-		assert(i < rtree->height - 1);
-		child = rtree_child_tryread(&node[subkey]);
+	node = rtree_subtree_tryread(rtree, start_level, dependent);
+#define	RTREE_GET_BIAS	(RTREE_HEIGHT_MAX - rtree->height)
+	switch (start_level + RTREE_GET_BIAS) {
+#define	RTREE_GET_SUBTREE(level)					\
+	case level:							\
+		assert(level < (RTREE_HEIGHT_MAX-1));			\
+		if (!dependent && unlikely(!rtree_node_valid(node)))	\
+			return (NULL);					\
+		subkey = rtree_subkey(rtree, key, level -		\
+		    RTREE_GET_BIAS);					\
+		node = rtree_child_tryread(&node[subkey], dependent);	\
+		/* Fall through. */
+#define	RTREE_GET_LEAF(level)						\
+	case level:							\
+		assert(level == (RTREE_HEIGHT_MAX-1));			\
+		if (!dependent && unlikely(!rtree_node_valid(node)))	\
+			return (NULL);					\
+		subkey = rtree_subkey(rtree, key, level -		\
+		    RTREE_GET_BIAS);					\
+		/*							\
+		 * node is a leaf, so it contains values rather than	\
+		 * child pointers.					\
+		 */							\
+		return (rtree_val_read(rtree, &node[subkey],		\
+		    dependent));
+#if RTREE_HEIGHT_MAX > 1
+	RTREE_GET_SUBTREE(0)
+#endif
+#if RTREE_HEIGHT_MAX > 2
+	RTREE_GET_SUBTREE(1)
+#endif
+#if RTREE_HEIGHT_MAX > 3
+	RTREE_GET_SUBTREE(2)
+#endif
+#if RTREE_HEIGHT_MAX > 4
+	RTREE_GET_SUBTREE(3)
+#endif
+#if RTREE_HEIGHT_MAX > 5
+	RTREE_GET_SUBTREE(4)
+#endif
+#if RTREE_HEIGHT_MAX > 6
+	RTREE_GET_SUBTREE(5)
+#endif
+#if RTREE_HEIGHT_MAX > 7
+	RTREE_GET_SUBTREE(6)
+#endif
+#if RTREE_HEIGHT_MAX > 8
+	RTREE_GET_SUBTREE(7)
+#endif
+#if RTREE_HEIGHT_MAX > 9
+	RTREE_GET_SUBTREE(8)
+#endif
+#if RTREE_HEIGHT_MAX > 10
+	RTREE_GET_SUBTREE(9)
+#endif
+#if RTREE_HEIGHT_MAX > 11
+	RTREE_GET_SUBTREE(10)
+#endif
+#if RTREE_HEIGHT_MAX > 12
+	RTREE_GET_SUBTREE(11)
+#endif
+#if RTREE_HEIGHT_MAX > 13
+	RTREE_GET_SUBTREE(12)
+#endif
+#if RTREE_HEIGHT_MAX > 14
+	RTREE_GET_SUBTREE(13)
+#endif
+#if RTREE_HEIGHT_MAX > 15
+	RTREE_GET_SUBTREE(14)
+#endif
+#if RTREE_HEIGHT_MAX > 16
+#  error Unsupported RTREE_HEIGHT_MAX
+#endif
+	RTREE_GET_LEAF(RTREE_HEIGHT_MAX-1)
+#undef RTREE_GET_SUBTREE
+#undef RTREE_GET_LEAF
+	default: not_reached();
 	}
+#undef RTREE_GET_BIAS
 	not_reached();
 }
 
 JEMALLOC_INLINE bool
 rtree_set(rtree_t *rtree, uintptr_t key, const extent_node_t *val)
 {
 	uintptr_t subkey;
 	unsigned i, start_level;
 	rtree_node_elm_t *node, *child;
 
 	start_level = rtree_start_level(rtree, key);
 
-	node = rtree_subtree_read(rtree, start_level);
+	node = rtree_subtree_read(rtree, start_level, false);
 	if (node == NULL)
 		return (true);
 	for (i = start_level; /**/; i++, node = child) {
 		subkey = rtree_subkey(rtree, key, i);
 		if (i == rtree->height - 1) {
 			/*
@@ -279,13 +351,13 @@
 			 * child pointers.
 			 */
 			rtree_val_write(rtree, &node[subkey], val);
 			return (false);
 		}
 		assert(i + 1 < rtree->height);
-		child = rtree_child_read(rtree, &node[subkey], i);
+		child = rtree_child_read(rtree, &node[subkey], i, false);
 		if (child == NULL)
 			return (true);
 	}
 	not_reached();
 }
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/size_classes.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/size_classes.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/size_classes.h	2017-09-27 23:00:17.646936191 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/size_classes.h	2017-09-27 23:01:52.674932709 +0800
@@ -4,501 +4,494 @@
 
 /*
  * This header requires LG_SIZEOF_PTR, LG_TINY_MIN, LG_QUANTUM, and LG_PAGE to
  * be defined prior to inclusion, and it in turn defines:
  *
  *   LG_SIZE_CLASS_GROUP: Lg of size class count for each size doubling.
- *   SIZE_CLASSES: Complete table of
- *                 SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup)
- *                 tuples.
+ *   SIZE_CLASSES: Complete table of SC(index, lg_grp, lg_delta, ndelta, psz,
+ *                 bin, lg_delta_lookup) tuples.
  *     index: Size class index.
  *     lg_grp: Lg group base size (no deltas added).
  *     lg_delta: Lg delta to previous size class.
  *     ndelta: Delta multiplier.  size == 1<<lg_grp + ndelta<<lg_delta
+ *     psz: 'yes' if a multiple of the page size, 'no' otherwise.
  *     bin: 'yes' if a small bin size class, 'no' otherwise.
  *     lg_delta_lookup: Same as lg_delta if a lookup table size class, 'no'
  *                      otherwise.
  *   NTBINS: Number of tiny bins.
  *   NLBINS: Number of bins supported by the lookup table.
  *   NBINS: Number of small size class bins.
  *   NSIZES: Number of size classes.
+ *   NPSIZES: Number of size classes that are a multiple of (1U << LG_PAGE).
  *   LG_TINY_MAXCLASS: Lg of maximum tiny size class.
  *   LOOKUP_MAXCLASS: Maximum size class included in lookup table.
  *   SMALL_MAXCLASS: Maximum small size class.
  *   LG_LARGE_MINCLASS: Lg of minimum large size class.
  *   HUGE_MAXCLASS: Maximum (huge) size class.
  */
 
 #define	LG_SIZE_CLASS_GROUP	2
 
 #if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)
 #define	SIZE_CLASSES \
-  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \
-    SC(  0,      3,        3,      0, yes,  3) \
-    SC(  1,      3,        3,      1, yes,  3) \
-    SC(  2,      3,        3,      2, yes,  3) \
-    SC(  3,      3,        3,      3, yes,  3) \
-                                               \
-    SC(  4,      5,        3,      1, yes,  3) \
-    SC(  5,      5,        3,      2, yes,  3) \
-    SC(  6,      5,        3,      3, yes,  3) \
-    SC(  7,      5,        3,      4, yes,  3) \
-                                               \
-    SC(  8,      6,        4,      1, yes,  4) \
-    SC(  9,      6,        4,      2, yes,  4) \
-    SC( 10,      6,        4,      3, yes,  4) \
-    SC( 11,      6,        4,      4, yes,  4) \
-                                               \
-    SC( 12,      7,        5,      1, yes,  5) \
-    SC( 13,      7,        5,      2, yes,  5) \
-    SC( 14,      7,        5,      3, yes,  5) \
-    SC( 15,      7,        5,      4, yes,  5) \
-                                               \
-    SC( 16,      8,        6,      1, yes,  6) \
-    SC( 17,      8,        6,      2, yes,  6) \
-    SC( 18,      8,        6,      3, yes,  6) \
-    SC( 19,      8,        6,      4, yes,  6) \
-                                               \
-    SC( 20,      9,        7,      1, yes,  7) \
-    SC( 21,      9,        7,      2, yes,  7) \
-    SC( 22,      9,        7,      3, yes,  7) \
-    SC( 23,      9,        7,      4, yes,  7) \
-                                               \
-    SC( 24,     10,        8,      1, yes,  8) \
-    SC( 25,     10,        8,      2, yes,  8) \
-    SC( 26,     10,        8,      3, yes,  8) \
-    SC( 27,     10,        8,      4, yes,  8) \
-                                               \
-    SC( 28,     11,        9,      1, yes,  9) \
-    SC( 29,     11,        9,      2, yes,  9) \
-    SC( 30,     11,        9,      3, yes,  9) \
-    SC( 31,     11,        9,      4, yes,  9) \
-                                               \
-    SC( 32,     12,       10,      1, yes, no) \
-    SC( 33,     12,       10,      2, yes, no) \
-    SC( 34,     12,       10,      3, yes, no) \
-    SC( 35,     12,       10,      4, yes, no) \
-                                               \
-    SC( 36,     13,       11,      1, yes, no) \
-    SC( 37,     13,       11,      2, yes, no) \
-    SC( 38,     13,       11,      3, yes, no) \
-    SC( 39,     13,       11,      4,  no, no) \
-                                               \
-    SC( 40,     14,       12,      1,  no, no) \
-    SC( 41,     14,       12,      2,  no, no) \
-    SC( 42,     14,       12,      3,  no, no) \
-    SC( 43,     14,       12,      4,  no, no) \
-                                               \
-    SC( 44,     15,       13,      1,  no, no) \
-    SC( 45,     15,       13,      2,  no, no) \
-    SC( 46,     15,       13,      3,  no, no) \
-    SC( 47,     15,       13,      4,  no, no) \
-                                               \
-    SC( 48,     16,       14,      1,  no, no) \
-    SC( 49,     16,       14,      2,  no, no) \
-    SC( 50,     16,       14,      3,  no, no) \
-    SC( 51,     16,       14,      4,  no, no) \
-                                               \
-    SC( 52,     17,       15,      1,  no, no) \
-    SC( 53,     17,       15,      2,  no, no) \
-    SC( 54,     17,       15,      3,  no, no) \
-    SC( 55,     17,       15,      4,  no, no) \
-                                               \
-    SC( 56,     18,       16,      1,  no, no) \
-    SC( 57,     18,       16,      2,  no, no) \
-    SC( 58,     18,       16,      3,  no, no) \
-    SC( 59,     18,       16,      4,  no, no) \
-                                               \
-    SC( 60,     19,       17,      1,  no, no) \
-    SC( 61,     19,       17,      2,  no, no) \
-    SC( 62,     19,       17,      3,  no, no) \
-    SC( 63,     19,       17,      4,  no, no) \
-                                               \
-    SC( 64,     20,       18,      1,  no, no) \
-    SC( 65,     20,       18,      2,  no, no) \
-    SC( 66,     20,       18,      3,  no, no) \
-    SC( 67,     20,       18,      4,  no, no) \
-                                               \
-    SC( 68,     21,       19,      1,  no, no) \
-    SC( 69,     21,       19,      2,  no, no) \
-    SC( 70,     21,       19,      3,  no, no) \
-    SC( 71,     21,       19,      4,  no, no) \
-                                               \
-    SC( 72,     22,       20,      1,  no, no) \
-    SC( 73,     22,       20,      2,  no, no) \
-    SC( 74,     22,       20,      3,  no, no) \
-    SC( 75,     22,       20,      4,  no, no) \
-                                               \
-    SC( 76,     23,       21,      1,  no, no) \
-    SC( 77,     23,       21,      2,  no, no) \
-    SC( 78,     23,       21,      3,  no, no) \
-    SC( 79,     23,       21,      4,  no, no) \
-                                               \
-    SC( 80,     24,       22,      1,  no, no) \
-    SC( 81,     24,       22,      2,  no, no) \
-    SC( 82,     24,       22,      3,  no, no) \
-    SC( 83,     24,       22,      4,  no, no) \
-                                               \
-    SC( 84,     25,       23,      1,  no, no) \
-    SC( 85,     25,       23,      2,  no, no) \
-    SC( 86,     25,       23,      3,  no, no) \
-    SC( 87,     25,       23,      4,  no, no) \
-                                               \
-    SC( 88,     26,       24,      1,  no, no) \
-    SC( 89,     26,       24,      2,  no, no) \
-    SC( 90,     26,       24,      3,  no, no) \
-    SC( 91,     26,       24,      4,  no, no) \
-                                               \
-    SC( 92,     27,       25,      1,  no, no) \
-    SC( 93,     27,       25,      2,  no, no) \
-    SC( 94,     27,       25,      3,  no, no) \
-    SC( 95,     27,       25,      4,  no, no) \
-                                               \
-    SC( 96,     28,       26,      1,  no, no) \
-    SC( 97,     28,       26,      2,  no, no) \
-    SC( 98,     28,       26,      3,  no, no) \
-    SC( 99,     28,       26,      4,  no, no) \
-                                               \
-    SC(100,     29,       27,      1,  no, no) \
-    SC(101,     29,       27,      2,  no, no) \
-    SC(102,     29,       27,      3,  no, no) \
-    SC(103,     29,       27,      4,  no, no) \
-                                               \
-    SC(104,     30,       28,      1,  no, no) \
-    SC(105,     30,       28,      2,  no, no) \
-    SC(106,     30,       28,      3,  no, no) \
-    SC(107,     30,       28,      4,  no, no) \
-                                               \
-    SC(108,     31,       29,      1,  no, no) \
-    SC(109,     31,       29,      2,  no, no) \
-    SC(110,     31,       29,      3,  no, no) \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,  3) \
+    SC(  1,      3,        3,      1,  no, yes,  3) \
+    SC(  2,      3,        3,      2,  no, yes,  3) \
+    SC(  3,      3,        3,      3,  no, yes,  3) \
+                                                         \
+    SC(  4,      5,        3,      1,  no, yes,  3) \
+    SC(  5,      5,        3,      2,  no, yes,  3) \
+    SC(  6,      5,        3,      3,  no, yes,  3) \
+    SC(  7,      5,        3,      4,  no, yes,  3) \
+                                                         \
+    SC(  8,      6,        4,      1,  no, yes,  4) \
+    SC(  9,      6,        4,      2,  no, yes,  4) \
+    SC( 10,      6,        4,      3,  no, yes,  4) \
+    SC( 11,      6,        4,      4,  no, yes,  4) \
+                                                         \
+    SC( 12,      7,        5,      1,  no, yes,  5) \
+    SC( 13,      7,        5,      2,  no, yes,  5) \
+    SC( 14,      7,        5,      3,  no, yes,  5) \
+    SC( 15,      7,        5,      4,  no, yes,  5) \
+                                                         \
+    SC( 16,      8,        6,      1,  no, yes,  6) \
+    SC( 17,      8,        6,      2,  no, yes,  6) \
+    SC( 18,      8,        6,      3,  no, yes,  6) \
+    SC( 19,      8,        6,      4,  no, yes,  6) \
+                                                         \
+    SC( 20,      9,        7,      1,  no, yes,  7) \
+    SC( 21,      9,        7,      2,  no, yes,  7) \
+    SC( 22,      9,        7,      3,  no, yes,  7) \
+    SC( 23,      9,        7,      4,  no, yes,  7) \
+                                                         \
+    SC( 24,     10,        8,      1,  no, yes,  8) \
+    SC( 25,     10,        8,      2,  no, yes,  8) \
+    SC( 26,     10,        8,      3,  no, yes,  8) \
+    SC( 27,     10,        8,      4,  no, yes,  8) \
+                                                         \
+    SC( 28,     11,        9,      1,  no, yes,  9) \
+    SC( 29,     11,        9,      2,  no, yes,  9) \
+    SC( 30,     11,        9,      3,  no, yes,  9) \
+    SC( 31,     11,        9,      4, yes, yes,  9) \
+                                                         \
+    SC( 32,     12,       10,      1,  no, yes, no) \
+    SC( 33,     12,       10,      2,  no, yes, no) \
+    SC( 34,     12,       10,      3,  no, yes, no) \
+    SC( 35,     12,       10,      4, yes, yes, no) \
+                                                         \
+    SC( 36,     13,       11,      1,  no, yes, no) \
+    SC( 37,     13,       11,      2, yes, yes, no) \
+    SC( 38,     13,       11,      3,  no, yes, no) \
+    SC( 39,     13,       11,      4, yes,  no, no) \
+                                                         \
+    SC( 40,     14,       12,      1, yes,  no, no) \
+    SC( 41,     14,       12,      2, yes,  no, no) \
+    SC( 42,     14,       12,      3, yes,  no, no) \
+    SC( 43,     14,       12,      4, yes,  no, no) \
+                                                         \
+    SC( 44,     15,       13,      1, yes,  no, no) \
+    SC( 45,     15,       13,      2, yes,  no, no) \
+    SC( 46,     15,       13,      3, yes,  no, no) \
+    SC( 47,     15,       13,      4, yes,  no, no) \
+                                                         \
+    SC( 48,     16,       14,      1, yes,  no, no) \
+    SC( 49,     16,       14,      2, yes,  no, no) \
+    SC( 50,     16,       14,      3, yes,  no, no) \
+    SC( 51,     16,       14,      4, yes,  no, no) \
+                                                         \
+    SC( 52,     17,       15,      1, yes,  no, no) \
+    SC( 53,     17,       15,      2, yes,  no, no) \
+    SC( 54,     17,       15,      3, yes,  no, no) \
+    SC( 55,     17,       15,      4, yes,  no, no) \
+                                                         \
+    SC( 56,     18,       16,      1, yes,  no, no) \
+    SC( 57,     18,       16,      2, yes,  no, no) \
+    SC( 58,     18,       16,      3, yes,  no, no) \
+    SC( 59,     18,       16,      4, yes,  no, no) \
+                                                         \
+    SC( 60,     19,       17,      1, yes,  no, no) \
+    SC( 61,     19,       17,      2, yes,  no, no) \
+    SC( 62,     19,       17,      3, yes,  no, no) \
+    SC( 63,     19,       17,      4, yes,  no, no) \
+                                                         \
+    SC( 64,     20,       18,      1, yes,  no, no) \
+    SC( 65,     20,       18,      2, yes,  no, no) \
+    SC( 66,     20,       18,      3, yes,  no, no) \
+    SC( 67,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 68,     21,       19,      1, yes,  no, no) \
+    SC( 69,     21,       19,      2, yes,  no, no) \
+    SC( 70,     21,       19,      3, yes,  no, no) \
+    SC( 71,     21,       19,      4, yes,  no, no) \
+                                                         \
+    SC( 72,     22,       20,      1, yes,  no, no) \
+    SC( 73,     22,       20,      2, yes,  no, no) \
+    SC( 74,     22,       20,      3, yes,  no, no) \
+    SC( 75,     22,       20,      4, yes,  no, no) \
+                                                         \
+    SC( 76,     23,       21,      1, yes,  no, no) \
+    SC( 77,     23,       21,      2, yes,  no, no) \
+    SC( 78,     23,       21,      3, yes,  no, no) \
+    SC( 79,     23,       21,      4, yes,  no, no) \
+                                                         \
+    SC( 80,     24,       22,      1, yes,  no, no) \
+    SC( 81,     24,       22,      2, yes,  no, no) \
+    SC( 82,     24,       22,      3, yes,  no, no) \
+    SC( 83,     24,       22,      4, yes,  no, no) \
+                                                         \
+    SC( 84,     25,       23,      1, yes,  no, no) \
+    SC( 85,     25,       23,      2, yes,  no, no) \
+    SC( 86,     25,       23,      3, yes,  no, no) \
+    SC( 87,     25,       23,      4, yes,  no, no) \
+                                                         \
+    SC( 88,     26,       24,      1, yes,  no, no) \
+    SC( 89,     26,       24,      2, yes,  no, no) \
+    SC( 90,     26,       24,      3, yes,  no, no) \
+    SC( 91,     26,       24,      4, yes,  no, no) \
+                                                         \
+    SC( 92,     27,       25,      1, yes,  no, no) \
+    SC( 93,     27,       25,      2, yes,  no, no) \
+    SC( 94,     27,       25,      3, yes,  no, no) \
+    SC( 95,     27,       25,      4, yes,  no, no) \
+                                                         \
+    SC( 96,     28,       26,      1, yes,  no, no) \
+    SC( 97,     28,       26,      2, yes,  no, no) \
+    SC( 98,     28,       26,      3, yes,  no, no) \
+    SC( 99,     28,       26,      4, yes,  no, no) \
+                                                         \
+    SC(100,     29,       27,      1, yes,  no, no) \
+    SC(101,     29,       27,      2, yes,  no, no) \
+    SC(102,     29,       27,      3, yes,  no, no) \
+    SC(103,     29,       27,      4, yes,  no, no) \
+                                                         \
+    SC(104,     30,       28,      1, yes,  no, no) \
+    SC(105,     30,       28,      2, yes,  no, no) \
+    SC(106,     30,       28,      3, yes,  no, no) \
 
 #define	SIZE_CLASSES_DEFINED
 #define	NTBINS			0
 #define	NLBINS			32
 #define	NBINS			39
-#define	NSIZES			111
+#define	NSIZES			107
+#define	NPSIZES			71
 #define	LG_TINY_MAXCLASS	"NA"
 #define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
 #define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
 #define	LG_LARGE_MINCLASS	14
-#define	HUGE_MAXCLASS		((((size_t)1) << 31) + (((size_t)3) << 29))
+#define	HUGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
 #endif
 
 #if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)
 #define	SIZE_CLASSES \
-  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \
-    SC(  0,      3,        3,      0, yes,  3) \
-    SC(  1,      3,        3,      1, yes,  3) \
-    SC(  2,      3,        3,      2, yes,  3) \
-    SC(  3,      3,        3,      3, yes,  3) \
-                                               \
-    SC(  4,      5,        3,      1, yes,  3) \
-    SC(  5,      5,        3,      2, yes,  3) \
-    SC(  6,      5,        3,      3, yes,  3) \
-    SC(  7,      5,        3,      4, yes,  3) \
-                                               \
-    SC(  8,      6,        4,      1, yes,  4) \
-    SC(  9,      6,        4,      2, yes,  4) \
-    SC( 10,      6,        4,      3, yes,  4) \
-    SC( 11,      6,        4,      4, yes,  4) \
-                                               \
-    SC( 12,      7,        5,      1, yes,  5) \
-    SC( 13,      7,        5,      2, yes,  5) \
-    SC( 14,      7,        5,      3, yes,  5) \
-    SC( 15,      7,        5,      4, yes,  5) \
-                                               \
-    SC( 16,      8,        6,      1, yes,  6) \
-    SC( 17,      8,        6,      2, yes,  6) \
-    SC( 18,      8,        6,      3, yes,  6) \
-    SC( 19,      8,        6,      4, yes,  6) \
-                                               \
-    SC( 20,      9,        7,      1, yes,  7) \
-    SC( 21,      9,        7,      2, yes,  7) \
-    SC( 22,      9,        7,      3, yes,  7) \
-    SC( 23,      9,        7,      4, yes,  7) \
-                                               \
-    SC( 24,     10,        8,      1, yes,  8) \
-    SC( 25,     10,        8,      2, yes,  8) \
-    SC( 26,     10,        8,      3, yes,  8) \
-    SC( 27,     10,        8,      4, yes,  8) \
-                                               \
-    SC( 28,     11,        9,      1, yes,  9) \
-    SC( 29,     11,        9,      2, yes,  9) \
-    SC( 30,     11,        9,      3, yes,  9) \
-    SC( 31,     11,        9,      4, yes,  9) \
-                                               \
-    SC( 32,     12,       10,      1, yes, no) \
-    SC( 33,     12,       10,      2, yes, no) \
-    SC( 34,     12,       10,      3, yes, no) \
-    SC( 35,     12,       10,      4, yes, no) \
-                                               \
-    SC( 36,     13,       11,      1, yes, no) \
-    SC( 37,     13,       11,      2, yes, no) \
-    SC( 38,     13,       11,      3, yes, no) \
-    SC( 39,     13,       11,      4,  no, no) \
-                                               \
-    SC( 40,     14,       12,      1,  no, no) \
-    SC( 41,     14,       12,      2,  no, no) \
-    SC( 42,     14,       12,      3,  no, no) \
-    SC( 43,     14,       12,      4,  no, no) \
-                                               \
-    SC( 44,     15,       13,      1,  no, no) \
-    SC( 45,     15,       13,      2,  no, no) \
-    SC( 46,     15,       13,      3,  no, no) \
-    SC( 47,     15,       13,      4,  no, no) \
-                                               \
-    SC( 48,     16,       14,      1,  no, no) \
-    SC( 49,     16,       14,      2,  no, no) \
-    SC( 50,     16,       14,      3,  no, no) \
-    SC( 51,     16,       14,      4,  no, no) \
-                                               \
-    SC( 52,     17,       15,      1,  no, no) \
-    SC( 53,     17,       15,      2,  no, no) \
-    SC( 54,     17,       15,      3,  no, no) \
-    SC( 55,     17,       15,      4,  no, no) \
-                                               \
-    SC( 56,     18,       16,      1,  no, no) \
-    SC( 57,     18,       16,      2,  no, no) \
-    SC( 58,     18,       16,      3,  no, no) \
-    SC( 59,     18,       16,      4,  no, no) \
-                                               \
-    SC( 60,     19,       17,      1,  no, no) \
-    SC( 61,     19,       17,      2,  no, no) \
-    SC( 62,     19,       17,      3,  no, no) \
-    SC( 63,     19,       17,      4,  no, no) \
-                                               \
-    SC( 64,     20,       18,      1,  no, no) \
-    SC( 65,     20,       18,      2,  no, no) \
-    SC( 66,     20,       18,      3,  no, no) \
-    SC( 67,     20,       18,      4,  no, no) \
-                                               \
-    SC( 68,     21,       19,      1,  no, no) \
-    SC( 69,     21,       19,      2,  no, no) \
-    SC( 70,     21,       19,      3,  no, no) \
-    SC( 71,     21,       19,      4,  no, no) \
-                                               \
-    SC( 72,     22,       20,      1,  no, no) \
-    SC( 73,     22,       20,      2,  no, no) \
-    SC( 74,     22,       20,      3,  no, no) \
-    SC( 75,     22,       20,      4,  no, no) \
-                                               \
-    SC( 76,     23,       21,      1,  no, no) \
-    SC( 77,     23,       21,      2,  no, no) \
-    SC( 78,     23,       21,      3,  no, no) \
-    SC( 79,     23,       21,      4,  no, no) \
-                                               \
-    SC( 80,     24,       22,      1,  no, no) \
-    SC( 81,     24,       22,      2,  no, no) \
-    SC( 82,     24,       22,      3,  no, no) \
-    SC( 83,     24,       22,      4,  no, no) \
-                                               \
-    SC( 84,     25,       23,      1,  no, no) \
-    SC( 85,     25,       23,      2,  no, no) \
-    SC( 86,     25,       23,      3,  no, no) \
-    SC( 87,     25,       23,      4,  no, no) \
-                                               \
-    SC( 88,     26,       24,      1,  no, no) \
-    SC( 89,     26,       24,      2,  no, no) \
-    SC( 90,     26,       24,      3,  no, no) \
-    SC( 91,     26,       24,      4,  no, no) \
-                                               \
-    SC( 92,     27,       25,      1,  no, no) \
-    SC( 93,     27,       25,      2,  no, no) \
-    SC( 94,     27,       25,      3,  no, no) \
-    SC( 95,     27,       25,      4,  no, no) \
-                                               \
-    SC( 96,     28,       26,      1,  no, no) \
-    SC( 97,     28,       26,      2,  no, no) \
-    SC( 98,     28,       26,      3,  no, no) \
-    SC( 99,     28,       26,      4,  no, no) \
-                                               \
-    SC(100,     29,       27,      1,  no, no) \
-    SC(101,     29,       27,      2,  no, no) \
-    SC(102,     29,       27,      3,  no, no) \
-    SC(103,     29,       27,      4,  no, no) \
-                                               \
-    SC(104,     30,       28,      1,  no, no) \
-    SC(105,     30,       28,      2,  no, no) \
-    SC(106,     30,       28,      3,  no, no) \
-    SC(107,     30,       28,      4,  no, no) \
-                                               \
-    SC(108,     31,       29,      1,  no, no) \
-    SC(109,     31,       29,      2,  no, no) \
-    SC(110,     31,       29,      3,  no, no) \
-    SC(111,     31,       29,      4,  no, no) \
-                                               \
-    SC(112,     32,       30,      1,  no, no) \
-    SC(113,     32,       30,      2,  no, no) \
-    SC(114,     32,       30,      3,  no, no) \
-    SC(115,     32,       30,      4,  no, no) \
-                                               \
-    SC(116,     33,       31,      1,  no, no) \
-    SC(117,     33,       31,      2,  no, no) \
-    SC(118,     33,       31,      3,  no, no) \
-    SC(119,     33,       31,      4,  no, no) \
-                                               \
-    SC(120,     34,       32,      1,  no, no) \
-    SC(121,     34,       32,      2,  no, no) \
-    SC(122,     34,       32,      3,  no, no) \
-    SC(123,     34,       32,      4,  no, no) \
-                                               \
-    SC(124,     35,       33,      1,  no, no) \
-    SC(125,     35,       33,      2,  no, no) \
-    SC(126,     35,       33,      3,  no, no) \
-    SC(127,     35,       33,      4,  no, no) \
-                                               \
-    SC(128,     36,       34,      1,  no, no) \
-    SC(129,     36,       34,      2,  no, no) \
-    SC(130,     36,       34,      3,  no, no) \
-    SC(131,     36,       34,      4,  no, no) \
-                                               \
-    SC(132,     37,       35,      1,  no, no) \
-    SC(133,     37,       35,      2,  no, no) \
-    SC(134,     37,       35,      3,  no, no) \
-    SC(135,     37,       35,      4,  no, no) \
-                                               \
-    SC(136,     38,       36,      1,  no, no) \
-    SC(137,     38,       36,      2,  no, no) \
-    SC(138,     38,       36,      3,  no, no) \
-    SC(139,     38,       36,      4,  no, no) \
-                                               \
-    SC(140,     39,       37,      1,  no, no) \
-    SC(141,     39,       37,      2,  no, no) \
-    SC(142,     39,       37,      3,  no, no) \
-    SC(143,     39,       37,      4,  no, no) \
-                                               \
-    SC(144,     40,       38,      1,  no, no) \
-    SC(145,     40,       38,      2,  no, no) \
-    SC(146,     40,       38,      3,  no, no) \
-    SC(147,     40,       38,      4,  no, no) \
-                                               \
-    SC(148,     41,       39,      1,  no, no) \
-    SC(149,     41,       39,      2,  no, no) \
-    SC(150,     41,       39,      3,  no, no) \
-    SC(151,     41,       39,      4,  no, no) \
-                                               \
-    SC(152,     42,       40,      1,  no, no) \
-    SC(153,     42,       40,      2,  no, no) \
-    SC(154,     42,       40,      3,  no, no) \
-    SC(155,     42,       40,      4,  no, no) \
-                                               \
-    SC(156,     43,       41,      1,  no, no) \
-    SC(157,     43,       41,      2,  no, no) \
-    SC(158,     43,       41,      3,  no, no) \
-    SC(159,     43,       41,      4,  no, no) \
-                                               \
-    SC(160,     44,       42,      1,  no, no) \
-    SC(161,     44,       42,      2,  no, no) \
-    SC(162,     44,       42,      3,  no, no) \
-    SC(163,     44,       42,      4,  no, no) \
-                                               \
-    SC(164,     45,       43,      1,  no, no) \
-    SC(165,     45,       43,      2,  no, no) \
-    SC(166,     45,       43,      3,  no, no) \
-    SC(167,     45,       43,      4,  no, no) \
-                                               \
-    SC(168,     46,       44,      1,  no, no) \
-    SC(169,     46,       44,      2,  no, no) \
-    SC(170,     46,       44,      3,  no, no) \
-    SC(171,     46,       44,      4,  no, no) \
-                                               \
-    SC(172,     47,       45,      1,  no, no) \
-    SC(173,     47,       45,      2,  no, no) \
-    SC(174,     47,       45,      3,  no, no) \
-    SC(175,     47,       45,      4,  no, no) \
-                                               \
-    SC(176,     48,       46,      1,  no, no) \
-    SC(177,     48,       46,      2,  no, no) \
-    SC(178,     48,       46,      3,  no, no) \
-    SC(179,     48,       46,      4,  no, no) \
-                                               \
-    SC(180,     49,       47,      1,  no, no) \
-    SC(181,     49,       47,      2,  no, no) \
-    SC(182,     49,       47,      3,  no, no) \
-    SC(183,     49,       47,      4,  no, no) \
-                                               \
-    SC(184,     50,       48,      1,  no, no) \
-    SC(185,     50,       48,      2,  no, no) \
-    SC(186,     50,       48,      3,  no, no) \
-    SC(187,     50,       48,      4,  no, no) \
-                                               \
-    SC(188,     51,       49,      1,  no, no) \
-    SC(189,     51,       49,      2,  no, no) \
-    SC(190,     51,       49,      3,  no, no) \
-    SC(191,     51,       49,      4,  no, no) \
-                                               \
-    SC(192,     52,       50,      1,  no, no) \
-    SC(193,     52,       50,      2,  no, no) \
-    SC(194,     52,       50,      3,  no, no) \
-    SC(195,     52,       50,      4,  no, no) \
-                                               \
-    SC(196,     53,       51,      1,  no, no) \
-    SC(197,     53,       51,      2,  no, no) \
-    SC(198,     53,       51,      3,  no, no) \
-    SC(199,     53,       51,      4,  no, no) \
-                                               \
-    SC(200,     54,       52,      1,  no, no) \
-    SC(201,     54,       52,      2,  no, no) \
-    SC(202,     54,       52,      3,  no, no) \
-    SC(203,     54,       52,      4,  no, no) \
-                                               \
-    SC(204,     55,       53,      1,  no, no) \
-    SC(205,     55,       53,      2,  no, no) \
-    SC(206,     55,       53,      3,  no, no) \
-    SC(207,     55,       53,      4,  no, no) \
-                                               \
-    SC(208,     56,       54,      1,  no, no) \
-    SC(209,     56,       54,      2,  no, no) \
-    SC(210,     56,       54,      3,  no, no) \
-    SC(211,     56,       54,      4,  no, no) \
-                                               \
-    SC(212,     57,       55,      1,  no, no) \
-    SC(213,     57,       55,      2,  no, no) \
-    SC(214,     57,       55,      3,  no, no) \
-    SC(215,     57,       55,      4,  no, no) \
-                                               \
-    SC(216,     58,       56,      1,  no, no) \
-    SC(217,     58,       56,      2,  no, no) \
-    SC(218,     58,       56,      3,  no, no) \
-    SC(219,     58,       56,      4,  no, no) \
-                                               \
-    SC(220,     59,       57,      1,  no, no) \
-    SC(221,     59,       57,      2,  no, no) \
-    SC(222,     59,       57,      3,  no, no) \
-    SC(223,     59,       57,      4,  no, no) \
-                                               \
-    SC(224,     60,       58,      1,  no, no) \
-    SC(225,     60,       58,      2,  no, no) \
-    SC(226,     60,       58,      3,  no, no) \
-    SC(227,     60,       58,      4,  no, no) \
-                                               \
-    SC(228,     61,       59,      1,  no, no) \
-    SC(229,     61,       59,      2,  no, no) \
-    SC(230,     61,       59,      3,  no, no) \
-    SC(231,     61,       59,      4,  no, no) \
-                                               \
-    SC(232,     62,       60,      1,  no, no) \
-    SC(233,     62,       60,      2,  no, no) \
-    SC(234,     62,       60,      3,  no, no) \
-    SC(235,     62,       60,      4,  no, no) \
-                                               \
-    SC(236,     63,       61,      1,  no, no) \
-    SC(237,     63,       61,      2,  no, no) \
-    SC(238,     63,       61,      3,  no, no) \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,  3) \
+    SC(  1,      3,        3,      1,  no, yes,  3) \
+    SC(  2,      3,        3,      2,  no, yes,  3) \
+    SC(  3,      3,        3,      3,  no, yes,  3) \
+                                                         \
+    SC(  4,      5,        3,      1,  no, yes,  3) \
+    SC(  5,      5,        3,      2,  no, yes,  3) \
+    SC(  6,      5,        3,      3,  no, yes,  3) \
+    SC(  7,      5,        3,      4,  no, yes,  3) \
+                                                         \
+    SC(  8,      6,        4,      1,  no, yes,  4) \
+    SC(  9,      6,        4,      2,  no, yes,  4) \
+    SC( 10,      6,        4,      3,  no, yes,  4) \
+    SC( 11,      6,        4,      4,  no, yes,  4) \
+                                                         \
+    SC( 12,      7,        5,      1,  no, yes,  5) \
+    SC( 13,      7,        5,      2,  no, yes,  5) \
+    SC( 14,      7,        5,      3,  no, yes,  5) \
+    SC( 15,      7,        5,      4,  no, yes,  5) \
+                                                         \
+    SC( 16,      8,        6,      1,  no, yes,  6) \
+    SC( 17,      8,        6,      2,  no, yes,  6) \
+    SC( 18,      8,        6,      3,  no, yes,  6) \
+    SC( 19,      8,        6,      4,  no, yes,  6) \
+                                                         \
+    SC( 20,      9,        7,      1,  no, yes,  7) \
+    SC( 21,      9,        7,      2,  no, yes,  7) \
+    SC( 22,      9,        7,      3,  no, yes,  7) \
+    SC( 23,      9,        7,      4,  no, yes,  7) \
+                                                         \
+    SC( 24,     10,        8,      1,  no, yes,  8) \
+    SC( 25,     10,        8,      2,  no, yes,  8) \
+    SC( 26,     10,        8,      3,  no, yes,  8) \
+    SC( 27,     10,        8,      4,  no, yes,  8) \
+                                                         \
+    SC( 28,     11,        9,      1,  no, yes,  9) \
+    SC( 29,     11,        9,      2,  no, yes,  9) \
+    SC( 30,     11,        9,      3,  no, yes,  9) \
+    SC( 31,     11,        9,      4, yes, yes,  9) \
+                                                         \
+    SC( 32,     12,       10,      1,  no, yes, no) \
+    SC( 33,     12,       10,      2,  no, yes, no) \
+    SC( 34,     12,       10,      3,  no, yes, no) \
+    SC( 35,     12,       10,      4, yes, yes, no) \
+                                                         \
+    SC( 36,     13,       11,      1,  no, yes, no) \
+    SC( 37,     13,       11,      2, yes, yes, no) \
+    SC( 38,     13,       11,      3,  no, yes, no) \
+    SC( 39,     13,       11,      4, yes,  no, no) \
+                                                         \
+    SC( 40,     14,       12,      1, yes,  no, no) \
+    SC( 41,     14,       12,      2, yes,  no, no) \
+    SC( 42,     14,       12,      3, yes,  no, no) \
+    SC( 43,     14,       12,      4, yes,  no, no) \
+                                                         \
+    SC( 44,     15,       13,      1, yes,  no, no) \
+    SC( 45,     15,       13,      2, yes,  no, no) \
+    SC( 46,     15,       13,      3, yes,  no, no) \
+    SC( 47,     15,       13,      4, yes,  no, no) \
+                                                         \
+    SC( 48,     16,       14,      1, yes,  no, no) \
+    SC( 49,     16,       14,      2, yes,  no, no) \
+    SC( 50,     16,       14,      3, yes,  no, no) \
+    SC( 51,     16,       14,      4, yes,  no, no) \
+                                                         \
+    SC( 52,     17,       15,      1, yes,  no, no) \
+    SC( 53,     17,       15,      2, yes,  no, no) \
+    SC( 54,     17,       15,      3, yes,  no, no) \
+    SC( 55,     17,       15,      4, yes,  no, no) \
+                                                         \
+    SC( 56,     18,       16,      1, yes,  no, no) \
+    SC( 57,     18,       16,      2, yes,  no, no) \
+    SC( 58,     18,       16,      3, yes,  no, no) \
+    SC( 59,     18,       16,      4, yes,  no, no) \
+                                                         \
+    SC( 60,     19,       17,      1, yes,  no, no) \
+    SC( 61,     19,       17,      2, yes,  no, no) \
+    SC( 62,     19,       17,      3, yes,  no, no) \
+    SC( 63,     19,       17,      4, yes,  no, no) \
+                                                         \
+    SC( 64,     20,       18,      1, yes,  no, no) \
+    SC( 65,     20,       18,      2, yes,  no, no) \
+    SC( 66,     20,       18,      3, yes,  no, no) \
+    SC( 67,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 68,     21,       19,      1, yes,  no, no) \
+    SC( 69,     21,       19,      2, yes,  no, no) \
+    SC( 70,     21,       19,      3, yes,  no, no) \
+    SC( 71,     21,       19,      4, yes,  no, no) \
+                                                         \
+    SC( 72,     22,       20,      1, yes,  no, no) \
+    SC( 73,     22,       20,      2, yes,  no, no) \
+    SC( 74,     22,       20,      3, yes,  no, no) \
+    SC( 75,     22,       20,      4, yes,  no, no) \
+                                                         \
+    SC( 76,     23,       21,      1, yes,  no, no) \
+    SC( 77,     23,       21,      2, yes,  no, no) \
+    SC( 78,     23,       21,      3, yes,  no, no) \
+    SC( 79,     23,       21,      4, yes,  no, no) \
+                                                         \
+    SC( 80,     24,       22,      1, yes,  no, no) \
+    SC( 81,     24,       22,      2, yes,  no, no) \
+    SC( 82,     24,       22,      3, yes,  no, no) \
+    SC( 83,     24,       22,      4, yes,  no, no) \
+                                                         \
+    SC( 84,     25,       23,      1, yes,  no, no) \
+    SC( 85,     25,       23,      2, yes,  no, no) \
+    SC( 86,     25,       23,      3, yes,  no, no) \
+    SC( 87,     25,       23,      4, yes,  no, no) \
+                                                         \
+    SC( 88,     26,       24,      1, yes,  no, no) \
+    SC( 89,     26,       24,      2, yes,  no, no) \
+    SC( 90,     26,       24,      3, yes,  no, no) \
+    SC( 91,     26,       24,      4, yes,  no, no) \
+                                                         \
+    SC( 92,     27,       25,      1, yes,  no, no) \
+    SC( 93,     27,       25,      2, yes,  no, no) \
+    SC( 94,     27,       25,      3, yes,  no, no) \
+    SC( 95,     27,       25,      4, yes,  no, no) \
+                                                         \
+    SC( 96,     28,       26,      1, yes,  no, no) \
+    SC( 97,     28,       26,      2, yes,  no, no) \
+    SC( 98,     28,       26,      3, yes,  no, no) \
+    SC( 99,     28,       26,      4, yes,  no, no) \
+                                                         \
+    SC(100,     29,       27,      1, yes,  no, no) \
+    SC(101,     29,       27,      2, yes,  no, no) \
+    SC(102,     29,       27,      3, yes,  no, no) \
+    SC(103,     29,       27,      4, yes,  no, no) \
+                                                         \
+    SC(104,     30,       28,      1, yes,  no, no) \
+    SC(105,     30,       28,      2, yes,  no, no) \
+    SC(106,     30,       28,      3, yes,  no, no) \
+    SC(107,     30,       28,      4, yes,  no, no) \
+                                                         \
+    SC(108,     31,       29,      1, yes,  no, no) \
+    SC(109,     31,       29,      2, yes,  no, no) \
+    SC(110,     31,       29,      3, yes,  no, no) \
+    SC(111,     31,       29,      4, yes,  no, no) \
+                                                         \
+    SC(112,     32,       30,      1, yes,  no, no) \
+    SC(113,     32,       30,      2, yes,  no, no) \
+    SC(114,     32,       30,      3, yes,  no, no) \
+    SC(115,     32,       30,      4, yes,  no, no) \
+                                                         \
+    SC(116,     33,       31,      1, yes,  no, no) \
+    SC(117,     33,       31,      2, yes,  no, no) \
+    SC(118,     33,       31,      3, yes,  no, no) \
+    SC(119,     33,       31,      4, yes,  no, no) \
+                                                         \
+    SC(120,     34,       32,      1, yes,  no, no) \
+    SC(121,     34,       32,      2, yes,  no, no) \
+    SC(122,     34,       32,      3, yes,  no, no) \
+    SC(123,     34,       32,      4, yes,  no, no) \
+                                                         \
+    SC(124,     35,       33,      1, yes,  no, no) \
+    SC(125,     35,       33,      2, yes,  no, no) \
+    SC(126,     35,       33,      3, yes,  no, no) \
+    SC(127,     35,       33,      4, yes,  no, no) \
+                                                         \
+    SC(128,     36,       34,      1, yes,  no, no) \
+    SC(129,     36,       34,      2, yes,  no, no) \
+    SC(130,     36,       34,      3, yes,  no, no) \
+    SC(131,     36,       34,      4, yes,  no, no) \
+                                                         \
+    SC(132,     37,       35,      1, yes,  no, no) \
+    SC(133,     37,       35,      2, yes,  no, no) \
+    SC(134,     37,       35,      3, yes,  no, no) \
+    SC(135,     37,       35,      4, yes,  no, no) \
+                                                         \
+    SC(136,     38,       36,      1, yes,  no, no) \
+    SC(137,     38,       36,      2, yes,  no, no) \
+    SC(138,     38,       36,      3, yes,  no, no) \
+    SC(139,     38,       36,      4, yes,  no, no) \
+                                                         \
+    SC(140,     39,       37,      1, yes,  no, no) \
+    SC(141,     39,       37,      2, yes,  no, no) \
+    SC(142,     39,       37,      3, yes,  no, no) \
+    SC(143,     39,       37,      4, yes,  no, no) \
+                                                         \
+    SC(144,     40,       38,      1, yes,  no, no) \
+    SC(145,     40,       38,      2, yes,  no, no) \
+    SC(146,     40,       38,      3, yes,  no, no) \
+    SC(147,     40,       38,      4, yes,  no, no) \
+                                                         \
+    SC(148,     41,       39,      1, yes,  no, no) \
+    SC(149,     41,       39,      2, yes,  no, no) \
+    SC(150,     41,       39,      3, yes,  no, no) \
+    SC(151,     41,       39,      4, yes,  no, no) \
+                                                         \
+    SC(152,     42,       40,      1, yes,  no, no) \
+    SC(153,     42,       40,      2, yes,  no, no) \
+    SC(154,     42,       40,      3, yes,  no, no) \
+    SC(155,     42,       40,      4, yes,  no, no) \
+                                                         \
+    SC(156,     43,       41,      1, yes,  no, no) \
+    SC(157,     43,       41,      2, yes,  no, no) \
+    SC(158,     43,       41,      3, yes,  no, no) \
+    SC(159,     43,       41,      4, yes,  no, no) \
+                                                         \
+    SC(160,     44,       42,      1, yes,  no, no) \
+    SC(161,     44,       42,      2, yes,  no, no) \
+    SC(162,     44,       42,      3, yes,  no, no) \
+    SC(163,     44,       42,      4, yes,  no, no) \
+                                                         \
+    SC(164,     45,       43,      1, yes,  no, no) \
+    SC(165,     45,       43,      2, yes,  no, no) \
+    SC(166,     45,       43,      3, yes,  no, no) \
+    SC(167,     45,       43,      4, yes,  no, no) \
+                                                         \
+    SC(168,     46,       44,      1, yes,  no, no) \
+    SC(169,     46,       44,      2, yes,  no, no) \
+    SC(170,     46,       44,      3, yes,  no, no) \
+    SC(171,     46,       44,      4, yes,  no, no) \
+                                                         \
+    SC(172,     47,       45,      1, yes,  no, no) \
+    SC(173,     47,       45,      2, yes,  no, no) \
+    SC(174,     47,       45,      3, yes,  no, no) \
+    SC(175,     47,       45,      4, yes,  no, no) \
+                                                         \
+    SC(176,     48,       46,      1, yes,  no, no) \
+    SC(177,     48,       46,      2, yes,  no, no) \
+    SC(178,     48,       46,      3, yes,  no, no) \
+    SC(179,     48,       46,      4, yes,  no, no) \
+                                                         \
+    SC(180,     49,       47,      1, yes,  no, no) \
+    SC(181,     49,       47,      2, yes,  no, no) \
+    SC(182,     49,       47,      3, yes,  no, no) \
+    SC(183,     49,       47,      4, yes,  no, no) \
+                                                         \
+    SC(184,     50,       48,      1, yes,  no, no) \
+    SC(185,     50,       48,      2, yes,  no, no) \
+    SC(186,     50,       48,      3, yes,  no, no) \
+    SC(187,     50,       48,      4, yes,  no, no) \
+                                                         \
+    SC(188,     51,       49,      1, yes,  no, no) \
+    SC(189,     51,       49,      2, yes,  no, no) \
+    SC(190,     51,       49,      3, yes,  no, no) \
+    SC(191,     51,       49,      4, yes,  no, no) \
+                                                         \
+    SC(192,     52,       50,      1, yes,  no, no) \
+    SC(193,     52,       50,      2, yes,  no, no) \
+    SC(194,     52,       50,      3, yes,  no, no) \
+    SC(195,     52,       50,      4, yes,  no, no) \
+                                                         \
+    SC(196,     53,       51,      1, yes,  no, no) \
+    SC(197,     53,       51,      2, yes,  no, no) \
+    SC(198,     53,       51,      3, yes,  no, no) \
+    SC(199,     53,       51,      4, yes,  no, no) \
+                                                         \
+    SC(200,     54,       52,      1, yes,  no, no) \
+    SC(201,     54,       52,      2, yes,  no, no) \
+    SC(202,     54,       52,      3, yes,  no, no) \
+    SC(203,     54,       52,      4, yes,  no, no) \
+                                                         \
+    SC(204,     55,       53,      1, yes,  no, no) \
+    SC(205,     55,       53,      2, yes,  no, no) \
+    SC(206,     55,       53,      3, yes,  no, no) \
+    SC(207,     55,       53,      4, yes,  no, no) \
+                                                         \
+    SC(208,     56,       54,      1, yes,  no, no) \
+    SC(209,     56,       54,      2, yes,  no, no) \
+    SC(210,     56,       54,      3, yes,  no, no) \
+    SC(211,     56,       54,      4, yes,  no, no) \
+                                                         \
+    SC(212,     57,       55,      1, yes,  no, no) \
+    SC(213,     57,       55,      2, yes,  no, no) \
+    SC(214,     57,       55,      3, yes,  no, no) \
+    SC(215,     57,       55,      4, yes,  no, no) \
+                                                         \
+    SC(216,     58,       56,      1, yes,  no, no) \
+    SC(217,     58,       56,      2, yes,  no, no) \
+    SC(218,     58,       56,      3, yes,  no, no) \
+    SC(219,     58,       56,      4, yes,  no, no) \
+                                                         \
+    SC(220,     59,       57,      1, yes,  no, no) \
+    SC(221,     59,       57,      2, yes,  no, no) \
+    SC(222,     59,       57,      3, yes,  no, no) \
+    SC(223,     59,       57,      4, yes,  no, no) \
+                                                         \
+    SC(224,     60,       58,      1, yes,  no, no) \
+    SC(225,     60,       58,      2, yes,  no, no) \
+    SC(226,     60,       58,      3, yes,  no, no) \
+    SC(227,     60,       58,      4, yes,  no, no) \
+                                                         \
+    SC(228,     61,       59,      1, yes,  no, no) \
+    SC(229,     61,       59,      2, yes,  no, no) \
+    SC(230,     61,       59,      3, yes,  no, no) \
+    SC(231,     61,       59,      4, yes,  no, no) \
+                                                         \
+    SC(232,     62,       60,      1, yes,  no, no) \
+    SC(233,     62,       60,      2, yes,  no, no) \
+    SC(234,     62,       60,      3, yes,  no, no) \
 
 #define	SIZE_CLASSES_DEFINED
 #define	NTBINS			0
 #define	NLBINS			32
 #define	NBINS			39
-#define	NSIZES			239
+#define	NSIZES			235
+#define	NPSIZES			199
 #define	LG_TINY_MAXCLASS	"NA"
 #define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
 #define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
 #define	LG_LARGE_MINCLASS	14
-#define	HUGE_MAXCLASS		((((size_t)1) << 63) + (((size_t)3) << 61))
+#define	HUGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
 #endif
 
 #ifndef SIZE_CLASSES_DEFINED
 #  error "No size class definitions match configuration"
 #endif
 #undef SIZE_CLASSES_DEFINED
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/size_classes.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/size_classes.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/size_classes.sh	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/size_classes.sh	2017-01-31 23:32:23.000000000 +0800
@@ -45,12 +45,27 @@
   lg_grp=$2
   lg_delta=$3
   ndelta=$4
   lg_p=$5
   lg_kmax=$6
 
+  if [ ${lg_delta} -ge ${lg_p} ] ; then
+    psz="yes"
+  else
+    pow2 ${lg_p}; p=${pow2_result}
+    pow2 ${lg_grp}; grp=${pow2_result}
+    pow2 ${lg_delta}; delta=${pow2_result}
+    sz=$((${grp} + ${delta} * ${ndelta}))
+    npgs=$((${sz} / ${p}))
+    if [ ${sz} -eq $((${npgs} * ${p})) ] ; then
+      psz="yes"
+    else
+      psz="no"
+    fi
+  fi
+
   lg ${ndelta}; lg_ndelta=${lg_result}; pow2 ${lg_ndelta}
   if [ ${pow2_result} -lt ${ndelta} ] ; then
     rem="yes"
   else
     rem="no"
   fi
@@ -71,20 +86,21 @@
   if [ ${lg_size} -lt ${lg_kmax} \
       -o ${lg_size} -eq ${lg_kmax} -a ${rem} = "no" ] ; then
     lg_delta_lookup=${lg_delta}
   else
     lg_delta_lookup="no"
   fi
-  printf '    SC(%3d, %6d, %8d, %6d, %3s, %2s) \\\n' ${index} ${lg_grp} ${lg_delta} ${ndelta} ${bin} ${lg_delta_lookup}
+  printf '    SC(%3d, %6d, %8d, %6d, %3s, %3s, %2s) \\\n' ${index} ${lg_grp} ${lg_delta} ${ndelta} ${psz} ${bin} ${lg_delta_lookup}
   # Defined upon return:
-  # - lg_delta_lookup (${lg_delta} or "no")
+  # - psz ("yes" or "no")
   # - bin ("yes" or "no")
+  # - lg_delta_lookup (${lg_delta} or "no")
 }
 
 sep_line() {
-  echo "                                               \\"
+  echo "                                                         \\"
 }
 
 size_classes() {
   lg_z=$1
   lg_q=$2
   lg_t=$3
@@ -92,29 +108,33 @@
   lg_g=$5
 
   pow2 $((${lg_z} + 3)); ptr_bits=${pow2_result}
   pow2 ${lg_g}; g=${pow2_result}
 
   echo "#define	SIZE_CLASSES \\"
-  echo "  /* index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup */ \\"
+  echo "  /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \\"
 
   ntbins=0
   nlbins=0
   lg_tiny_maxclass='"NA"'
   nbins=0
+  npsizes=0
 
   # Tiny size classes.
   ndelta=0
   index=0
   lg_grp=${lg_t}
   lg_delta=${lg_grp}
   while [ ${lg_grp} -lt ${lg_q} ] ; do
     size_class ${index} ${lg_grp} ${lg_delta} ${ndelta} ${lg_p} ${lg_kmax}
     if [ ${lg_delta_lookup} != "no" ] ; then
       nlbins=$((${index} + 1))
     fi
+    if [ ${psz} = "yes" ] ; then
+      npsizes=$((${npsizes} + 1))
+    fi
     if [ ${bin} != "no" ] ; then
       nbins=$((${index} + 1))
     fi
     ntbins=$((${ntbins} + 1))
     lg_tiny_maxclass=${lg_grp} # Final written value is correct.
     index=$((${index} + 1))
@@ -130,36 +150,45 @@
     lg_grp=$((${lg_grp} - 1))
     ndelta=1
     size_class ${index} ${lg_grp} ${lg_delta} ${ndelta} ${lg_p} ${lg_kmax}
     index=$((${index} + 1))
     lg_grp=$((${lg_grp} + 1))
     lg_delta=$((${lg_delta} + 1))
+    if [ ${psz} = "yes" ] ; then
+      npsizes=$((${npsizes} + 1))
+    fi
   fi
   while [ ${ndelta} -lt ${g} ] ; do
     size_class ${index} ${lg_grp} ${lg_delta} ${ndelta} ${lg_p} ${lg_kmax}
     index=$((${index} + 1))
     ndelta=$((${ndelta} + 1))
+    if [ ${psz} = "yes" ] ; then
+      npsizes=$((${npsizes} + 1))
+    fi
   done
 
   # All remaining groups.
   lg_grp=$((${lg_grp} + ${lg_g}))
-  while [ ${lg_grp} -lt ${ptr_bits} ] ; do
+  while [ ${lg_grp} -lt $((${ptr_bits} - 1)) ] ; do
     sep_line
     ndelta=1
-    if [ ${lg_grp} -eq $((${ptr_bits} - 1)) ] ; then
+    if [ ${lg_grp} -eq $((${ptr_bits} - 2)) ] ; then
       ndelta_limit=$((${g} - 1))
     else
       ndelta_limit=${g}
     fi
     while [ ${ndelta} -le ${ndelta_limit} ] ; do
       size_class ${index} ${lg_grp} ${lg_delta} ${ndelta} ${lg_p} ${lg_kmax}
       if [ ${lg_delta_lookup} != "no" ] ; then
         nlbins=$((${index} + 1))
         # Final written value is correct:
         lookup_maxclass="((((size_t)1) << ${lg_grp}) + (((size_t)${ndelta}) << ${lg_delta}))"
       fi
+      if [ ${psz} = "yes" ] ; then
+        npsizes=$((${npsizes} + 1))
+      fi
       if [ ${bin} != "no" ] ; then
         nbins=$((${index} + 1))
         # Final written value is correct:
         small_maxclass="((((size_t)1) << ${lg_grp}) + (((size_t)${ndelta}) << ${lg_delta}))"
         if [ ${lg_g} -gt 0 ] ; then
           lg_large_minclass=$((${lg_grp} + 1))
@@ -180,12 +209,13 @@
 
   # Defined upon completion:
   # - ntbins
   # - nlbins
   # - nbins
   # - nsizes
+  # - npsizes
   # - lg_tiny_maxclass
   # - lookup_maxclass
   # - small_maxclass
   # - lg_large_minclass
   # - huge_maxclass
 }
@@ -197,26 +227,27 @@
 
 /*
  * This header requires LG_SIZEOF_PTR, LG_TINY_MIN, LG_QUANTUM, and LG_PAGE to
  * be defined prior to inclusion, and it in turn defines:
  *
  *   LG_SIZE_CLASS_GROUP: Lg of size class count for each size doubling.
- *   SIZE_CLASSES: Complete table of
- *                 SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup)
- *                 tuples.
+ *   SIZE_CLASSES: Complete table of SC(index, lg_grp, lg_delta, ndelta, psz,
+ *                 bin, lg_delta_lookup) tuples.
  *     index: Size class index.
  *     lg_grp: Lg group base size (no deltas added).
  *     lg_delta: Lg delta to previous size class.
  *     ndelta: Delta multiplier.  size == 1<<lg_grp + ndelta<<lg_delta
+ *     psz: 'yes' if a multiple of the page size, 'no' otherwise.
  *     bin: 'yes' if a small bin size class, 'no' otherwise.
  *     lg_delta_lookup: Same as lg_delta if a lookup table size class, 'no'
  *                      otherwise.
  *   NTBINS: Number of tiny bins.
  *   NLBINS: Number of bins supported by the lookup table.
  *   NBINS: Number of small size class bins.
  *   NSIZES: Number of size classes.
+ *   NPSIZES: Number of size classes that are a multiple of (1U << LG_PAGE).
  *   LG_TINY_MAXCLASS: Lg of maximum tiny size class.
  *   LOOKUP_MAXCLASS: Maximum size class included in lookup table.
  *   SMALL_MAXCLASS: Maximum small size class.
  *   LG_LARGE_MINCLASS: Lg of minimum large size class.
  *   HUGE_MAXCLASS: Maximum (huge) size class.
  */
@@ -235,12 +266,13 @@
         size_classes ${lg_z} ${lg_q} ${lg_t} ${lg_p} ${lg_g}
         echo "#define	SIZE_CLASSES_DEFINED"
         echo "#define	NTBINS			${ntbins}"
         echo "#define	NLBINS			${nlbins}"
         echo "#define	NBINS			${nbins}"
         echo "#define	NSIZES			${nsizes}"
+        echo "#define	NPSIZES			${npsizes}"
         echo "#define	LG_TINY_MAXCLASS	${lg_tiny_maxclass}"
         echo "#define	LOOKUP_MAXCLASS		${lookup_maxclass}"
         echo "#define	SMALL_MAXCLASS		${small_maxclass}"
         echo "#define	LG_LARGE_MINCLASS	${lg_large_minclass}"
         echo "#define	HUGE_MAXCLASS		${huge_maxclass}"
         echo "#endif"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal: smoothstep.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal: smoothstep.sh
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal: spin.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/stats.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/stats.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/stats.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/stats.h	2017-01-31 23:32:23.000000000 +0800
@@ -100,12 +100,20 @@
 
 struct arena_stats_s {
 	/* Number of bytes currently mapped. */
 	size_t		mapped;
 
 	/*
+	 * Number of bytes currently retained as a side effect of munmap() being
+	 * disabled/bypassed.  Retained bytes are technically mapped (though
+	 * always decommitted or purged), but they are excluded from the mapped
+	 * statistic (above).
+	 */
+	size_t		retained;
+
+	/*
 	 * Total number of purge sweeps, total number of madvise calls made,
 	 * and total pages purged in order to keep dirty unused memory under
 	 * control.
 	 */
 	uint64_t	npurge;
 	uint64_t	nmadvise;
@@ -165,19 +173,25 @@
 }
 
 JEMALLOC_INLINE void
 stats_cactive_add(size_t size)
 {
 
+	assert(size > 0);
+	assert((size & chunksize_mask) == 0);
+
 	atomic_add_z(&stats_cactive, size);
 }
 
 JEMALLOC_INLINE void
 stats_cactive_sub(size_t size)
 {
 
+	assert(size > 0);
+	assert((size & chunksize_mask) == 0);
+
 	atomic_sub_z(&stats_cactive, size);
 }
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/tcache.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/tcache.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/tcache.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/tcache.h	2017-01-31 23:32:23.000000000 +0800
@@ -67,19 +67,26 @@
 
 struct tcache_bin_s {
 	tcache_bin_stats_t tstats;
 	int		low_water;	/* Min # cached since last GC. */
 	unsigned	lg_fill_div;	/* Fill (ncached_max >> lg_fill_div). */
 	unsigned	ncached;	/* # of cached objects. */
+	/*
+	 * To make use of adjacent cacheline prefetch, the items in the avail
+	 * stack goes to higher address for newer allocations.  avail points
+	 * just above the available space, which means that
+	 * avail[-ncached, ... -1] are available items and the lowest item will
+	 * be allocated first.
+	 */
 	void		**avail;	/* Stack of available objects. */
 };
 
 struct tcache_s {
 	ql_elm(tcache_t) link;		/* Used for aggregating stats. */
 	uint64_t	prof_accumbytes;/* Cleared after arena_prof_accum(). */
-	unsigned	ev_cnt;		/* Event count since incremental GC. */
+	ticker_t	gc_ticker;	/* Drives incremental GC. */
 	szind_t		next_gc_bin;	/* Next bin to GC. */
 	tcache_bin_t	tbins[1];	/* Dynamically sized. */
 	/*
 	 * The pointer stacks associated with tbins follow as a contiguous
 	 * array.  During tcache initialization, the avail pointer in each
 	 * element of tbins is initialized to point to the proper offset within
@@ -105,13 +112,13 @@
 extern tcache_bin_info_t	*tcache_bin_info;
 
 /*
  * Number of tcache bins.  There are NBINS small-object bins, plus 0 or more
  * large-object bins.
  */
-extern size_t	nhbins;
+extern unsigned	nhbins;
 
 /* Maximum cached size class. */
 extern size_t	tcache_maxclass;
 
 /*
  * Explicit tcaches, managed via the tcache.{create,flush,destroy} mallctls and
@@ -120,53 +127,51 @@
  * array, so it has no physical memory footprint until individual pages are
  * touched.  This allows the entire array to be allocated the first time an
  * explicit tcache is created without a disproportionate impact on memory usage.
  */
 extern tcaches_t	*tcaches;
 
-size_t	tcache_salloc(const void *ptr);
+size_t	tcache_salloc(tsdn_t *tsdn, const void *ptr);
 void	tcache_event_hard(tsd_t *tsd, tcache_t *tcache);
-void	*tcache_alloc_small_hard(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
-    tcache_bin_t *tbin, szind_t binind);
+void	*tcache_alloc_small_hard(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache,
+    tcache_bin_t *tbin, szind_t binind, bool *tcache_success);
 void	tcache_bin_flush_small(tsd_t *tsd, tcache_t *tcache, tcache_bin_t *tbin,
     szind_t binind, unsigned rem);
 void	tcache_bin_flush_large(tsd_t *tsd, tcache_bin_t *tbin, szind_t binind,
     unsigned rem, tcache_t *tcache);
-void	tcache_arena_associate(tcache_t *tcache, arena_t *arena);
-void	tcache_arena_reassociate(tcache_t *tcache, arena_t *oldarena,
-    arena_t *newarena);
-void	tcache_arena_dissociate(tcache_t *tcache, arena_t *arena);
+void	tcache_arena_reassociate(tsdn_t *tsdn, tcache_t *tcache,
+    arena_t *oldarena, arena_t *newarena);
 tcache_t *tcache_get_hard(tsd_t *tsd);
-tcache_t *tcache_create(tsd_t *tsd, arena_t *arena);
+tcache_t *tcache_create(tsdn_t *tsdn, arena_t *arena);
 void	tcache_cleanup(tsd_t *tsd);
 void	tcache_enabled_cleanup(tsd_t *tsd);
-void	tcache_stats_merge(tcache_t *tcache, arena_t *arena);
+void	tcache_stats_merge(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena);
 bool	tcaches_create(tsd_t *tsd, unsigned *r_ind);
 void	tcaches_flush(tsd_t *tsd, unsigned ind);
 void	tcaches_destroy(tsd_t *tsd, unsigned ind);
-bool	tcache_boot(void);
+bool	tcache_boot(tsdn_t *tsdn);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
 void	tcache_event(tsd_t *tsd, tcache_t *tcache);
 void	tcache_flush(void);
 bool	tcache_enabled_get(void);
 tcache_t *tcache_get(tsd_t *tsd, bool create);
 void	tcache_enabled_set(bool enabled);
-void	*tcache_alloc_easy(tcache_bin_t *tbin);
+void	*tcache_alloc_easy(tcache_bin_t *tbin, bool *tcache_success);
 void	*tcache_alloc_small(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
-    size_t size, bool zero);
+    size_t size, szind_t ind, bool zero, bool slow_path);
 void	*tcache_alloc_large(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
-    size_t size, bool zero);
+    size_t size, szind_t ind, bool zero, bool slow_path);
 void	tcache_dalloc_small(tsd_t *tsd, tcache_t *tcache, void *ptr,
-    szind_t binind);
+    szind_t binind, bool slow_path);
 void	tcache_dalloc_large(tsd_t *tsd, tcache_t *tcache, void *ptr,
-    size_t size);
+    size_t size, bool slow_path);
 tcache_t	*tcaches_get(tsd_t *tsd, unsigned ind);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_TCACHE_C_))
 JEMALLOC_INLINE void
 tcache_flush(void)
@@ -237,65 +242,88 @@
 tcache_event(tsd_t *tsd, tcache_t *tcache)
 {
 
 	if (TCACHE_GC_INCR == 0)
 		return;
 
-	tcache->ev_cnt++;
-	assert(tcache->ev_cnt <= TCACHE_GC_INCR);
-	if (unlikely(tcache->ev_cnt == TCACHE_GC_INCR))
+	if (unlikely(ticker_tick(&tcache->gc_ticker)))
 		tcache_event_hard(tsd, tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
-tcache_alloc_easy(tcache_bin_t *tbin)
+tcache_alloc_easy(tcache_bin_t *tbin, bool *tcache_success)
 {
 	void *ret;
 
 	if (unlikely(tbin->ncached == 0)) {
 		tbin->low_water = -1;
+		*tcache_success = false;
 		return (NULL);
 	}
+	/*
+	 * tcache_success (instead of ret) should be checked upon the return of
+	 * this function.  We avoid checking (ret == NULL) because there is
+	 * never a null stored on the avail stack (which is unknown to the
+	 * compiler), and eagerly checking ret would cause pipeline stall
+	 * (waiting for the cacheline).
+	 */
+	*tcache_success = true;
+	ret = *(tbin->avail - tbin->ncached);
 	tbin->ncached--;
+
 	if (unlikely((int)tbin->ncached < tbin->low_water))
 		tbin->low_water = tbin->ncached;
-	ret = tbin->avail[tbin->ncached];
+
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
 tcache_alloc_small(tsd_t *tsd, arena_t *arena, tcache_t *tcache, size_t size,
-    bool zero)
+    szind_t binind, bool zero, bool slow_path)
 {
 	void *ret;
-	szind_t binind;
-	size_t usize;
 	tcache_bin_t *tbin;
+	bool tcache_success;
+	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
 
-	binind = size2index(size);
 	assert(binind < NBINS);
 	tbin = &tcache->tbins[binind];
-	usize = index2size(binind);
-	ret = tcache_alloc_easy(tbin);
-	if (unlikely(ret == NULL)) {
-		ret = tcache_alloc_small_hard(tsd, arena, tcache, tbin, binind);
-		if (ret == NULL)
+	ret = tcache_alloc_easy(tbin, &tcache_success);
+	assert(tcache_success == (ret != NULL));
+	if (unlikely(!tcache_success)) {
+		bool tcache_hard_success;
+		arena = arena_choose(tsd, arena);
+		if (unlikely(arena == NULL))
+			return (NULL);
+
+		ret = tcache_alloc_small_hard(tsd_tsdn(tsd), arena, tcache,
+		    tbin, binind, &tcache_hard_success);
+		if (tcache_hard_success == false)
 			return (NULL);
 	}
-	assert(tcache_salloc(ret) == usize);
+
+	assert(ret);
+	/*
+	 * Only compute usize if required.  The checks in the following if
+	 * statement are all static.
+	 */
+	if (config_prof || (slow_path && config_fill) || unlikely(zero)) {
+		usize = index2size(binind);
+		assert(tcache_salloc(tsd_tsdn(tsd), ret) == usize);
+	}
 
 	if (likely(!zero)) {
-		if (config_fill) {
+		if (slow_path && config_fill) {
 			if (unlikely(opt_junk_alloc)) {
 				arena_alloc_junk_small(ret,
 				    &arena_bin_info[binind], false);
 			} else if (unlikely(opt_zero))
 				memset(ret, 0, usize);
 		}
 	} else {
-		if (config_fill && unlikely(opt_junk_alloc)) {
+		if (slow_path && config_fill && unlikely(opt_junk_alloc)) {
 			arena_alloc_junk_small(ret, &arena_bin_info[binind],
 			    true);
 		}
 		memset(ret, 0, usize);
 	}
 
@@ -306,47 +334,58 @@
 	tcache_event(tsd, tcache);
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void *
 tcache_alloc_large(tsd_t *tsd, arena_t *arena, tcache_t *tcache, size_t size,
-    bool zero)
+    szind_t binind, bool zero, bool slow_path)
 {
 	void *ret;
-	szind_t binind;
-	size_t usize;
 	tcache_bin_t *tbin;
+	bool tcache_success;
 
-	binind = size2index(size);
-	usize = index2size(binind);
-	assert(usize <= tcache_maxclass);
 	assert(binind < nhbins);
 	tbin = &tcache->tbins[binind];
-	ret = tcache_alloc_easy(tbin);
-	if (unlikely(ret == NULL)) {
+	ret = tcache_alloc_easy(tbin, &tcache_success);
+	assert(tcache_success == (ret != NULL));
+	if (unlikely(!tcache_success)) {
 		/*
 		 * Only allocate one large object at a time, because it's quite
 		 * expensive to create one and not use it.
 		 */
-		ret = arena_malloc_large(arena, usize, zero);
+		arena = arena_choose(tsd, arena);
+		if (unlikely(arena == NULL))
+			return (NULL);
+
+		ret = arena_malloc_large(tsd_tsdn(tsd), arena, binind, zero);
 		if (ret == NULL)
 			return (NULL);
 	} else {
+		size_t usize JEMALLOC_CC_SILENCE_INIT(0);
+
+		/* Only compute usize on demand */
+		if (config_prof || (slow_path && config_fill) ||
+		    unlikely(zero)) {
+			usize = index2size(binind);
+			assert(usize <= tcache_maxclass);
+		}
+
 		if (config_prof && usize == LARGE_MINCLASS) {
 			arena_chunk_t *chunk =
 			    (arena_chunk_t *)CHUNK_ADDR2BASE(ret);
 			size_t pageind = (((uintptr_t)ret - (uintptr_t)chunk) >>
 			    LG_PAGE);
 			arena_mapbits_large_binind_set(chunk, pageind,
 			    BININD_INVALID);
 		}
 		if (likely(!zero)) {
-			if (config_fill) {
-				if (unlikely(opt_junk_alloc))
-					memset(ret, 0xa5, usize);
-				else if (unlikely(opt_zero))
+			if (slow_path && config_fill) {
+				if (unlikely(opt_junk_alloc)) {
+					memset(ret, JEMALLOC_ALLOC_JUNK,
+					    usize);
+				} else if (unlikely(opt_zero))
 					memset(ret, 0, usize);
 			}
 		} else
 			memset(ret, 0, usize);
 
 		if (config_stats)
@@ -357,70 +396,74 @@
 
 	tcache_event(tsd, tcache);
 	return (ret);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-tcache_dalloc_small(tsd_t *tsd, tcache_t *tcache, void *ptr, szind_t binind)
+tcache_dalloc_small(tsd_t *tsd, tcache_t *tcache, void *ptr, szind_t binind,
+    bool slow_path)
 {
 	tcache_bin_t *tbin;
 	tcache_bin_info_t *tbin_info;
 
-	assert(tcache_salloc(ptr) <= SMALL_MAXCLASS);
+	assert(tcache_salloc(tsd_tsdn(tsd), ptr) <= SMALL_MAXCLASS);
 
-	if (config_fill && unlikely(opt_junk_free))
+	if (slow_path && config_fill && unlikely(opt_junk_free))
 		arena_dalloc_junk_small(ptr, &arena_bin_info[binind]);
 
 	tbin = &tcache->tbins[binind];
 	tbin_info = &tcache_bin_info[binind];
 	if (unlikely(tbin->ncached == tbin_info->ncached_max)) {
 		tcache_bin_flush_small(tsd, tcache, tbin, binind,
 		    (tbin_info->ncached_max >> 1));
 	}
 	assert(tbin->ncached < tbin_info->ncached_max);
-	tbin->avail[tbin->ncached] = ptr;
 	tbin->ncached++;
+	*(tbin->avail - tbin->ncached) = ptr;
 
 	tcache_event(tsd, tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE void
-tcache_dalloc_large(tsd_t *tsd, tcache_t *tcache, void *ptr, size_t size)
+tcache_dalloc_large(tsd_t *tsd, tcache_t *tcache, void *ptr, size_t size,
+    bool slow_path)
 {
 	szind_t binind;
 	tcache_bin_t *tbin;
 	tcache_bin_info_t *tbin_info;
 
 	assert((size & PAGE_MASK) == 0);
-	assert(tcache_salloc(ptr) > SMALL_MAXCLASS);
-	assert(tcache_salloc(ptr) <= tcache_maxclass);
+	assert(tcache_salloc(tsd_tsdn(tsd), ptr) > SMALL_MAXCLASS);
+	assert(tcache_salloc(tsd_tsdn(tsd), ptr) <= tcache_maxclass);
 
 	binind = size2index(size);
 
-	if (config_fill && unlikely(opt_junk_free))
+	if (slow_path && config_fill && unlikely(opt_junk_free))
 		arena_dalloc_junk_large(ptr, size);
 
 	tbin = &tcache->tbins[binind];
 	tbin_info = &tcache_bin_info[binind];
 	if (unlikely(tbin->ncached == tbin_info->ncached_max)) {
 		tcache_bin_flush_large(tsd, tbin, binind,
 		    (tbin_info->ncached_max >> 1), tcache);
 	}
 	assert(tbin->ncached < tbin_info->ncached_max);
-	tbin->avail[tbin->ncached] = ptr;
 	tbin->ncached++;
+	*(tbin->avail - tbin->ncached) = ptr;
 
 	tcache_event(tsd, tcache);
 }
 
 JEMALLOC_ALWAYS_INLINE tcache_t *
 tcaches_get(tsd_t *tsd, unsigned ind)
 {
 	tcaches_t *elm = &tcaches[ind];
-	if (unlikely(elm->tcache == NULL))
-		elm->tcache = tcache_create(tsd, arena_choose(tsd, NULL));
+	if (unlikely(elm->tcache == NULL)) {
+		elm->tcache = tcache_create(tsd_tsdn(tsd), arena_choose(tsd,
+		    NULL));
+	}
 	return (elm->tcache);
 }
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal: ticker.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/tsd.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/tsd.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/tsd.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/tsd.h	2017-01-31 23:32:23.000000000 +0800
@@ -10,12 +10,15 @@
     !defined(_WIN32))
 typedef struct tsd_init_block_s tsd_init_block_t;
 typedef struct tsd_init_head_s tsd_init_head_t;
 #endif
 
 typedef struct tsd_s tsd_t;
+typedef struct tsdn_s tsdn_t;
+
+#define	TSDN_NULL	((tsdn_t *)0)
 
 typedef enum {
 	tsd_state_uninitialized,
 	tsd_state_nominal,
 	tsd_state_purgatory,
 	tsd_state_reincarnated
@@ -41,13 +44,14 @@
  *   malloc_tsd_funcs(, example_, example_t, EX_INITIALIZER,
  *       example_tsd_cleanup)
  *
  * The result is a set of generated functions, e.g.:
  *
  *   bool example_tsd_boot(void) {...}
- *   example_t *example_tsd_get() {...}
+ *   bool example_tsd_booted_get(void) {...}
+ *   example_t *example_tsd_get(bool init) {...}
  *   void example_tsd_set(example_t *val) {...}
  *
  * Note that all of the functions deal in terms of (a_type *) rather than
  * (a_type) so that it is possible to support non-pointer types (unlike
  * pthreads TSD).  example_tsd_cleanup() is passed an (a_type *) pointer that is
  * cast to (void *).  This means that the cleanup function needs to cast the
@@ -95,14 +99,16 @@
 a_attr bool								\
 a_name##tsd_boot0(void);						\
 a_attr void								\
 a_name##tsd_boot1(void);						\
 a_attr bool								\
 a_name##tsd_boot(void);							\
+a_attr bool								\
+a_name##tsd_booted_get(void);						\
 a_attr a_type *								\
-a_name##tsd_get(void);							\
+a_name##tsd_get(bool init);						\
 a_attr void								\
 a_name##tsd_set(a_type *val);
 
 /* malloc_tsd_externs(). */
 #ifdef JEMALLOC_MALLOC_THREAD_CLEANUP
 #define	malloc_tsd_externs(a_name, a_type)				\
@@ -198,15 +204,27 @@
 a_attr bool								\
 a_name##tsd_boot(void)							\
 {									\
 									\
 	return (a_name##tsd_boot0());					\
 }									\
+a_attr bool								\
+a_name##tsd_booted_get(void)						\
+{									\
+									\
+	return (a_name##tsd_booted);					\
+}									\
+a_attr bool								\
+a_name##tsd_get_allocates(void)						\
+{									\
+									\
+	return (false);							\
+}									\
 /* Get/set. */								\
 a_attr a_type *								\
-a_name##tsd_get(void)							\
+a_name##tsd_get(bool init)						\
 {									\
 									\
 	assert(a_name##tsd_booted);					\
 	return (&a_name##tsd_tls);					\
 }									\
 a_attr void								\
@@ -243,15 +261,27 @@
 a_attr bool								\
 a_name##tsd_boot(void)							\
 {									\
 									\
 	return (a_name##tsd_boot0());					\
 }									\
+a_attr bool								\
+a_name##tsd_booted_get(void)						\
+{									\
+									\
+	return (a_name##tsd_booted);					\
+}									\
+a_attr bool								\
+a_name##tsd_get_allocates(void)						\
+{									\
+									\
+	return (false);							\
+}									\
 /* Get/set. */								\
 a_attr a_type *								\
-a_name##tsd_get(void)							\
+a_name##tsd_get(bool init)						\
 {									\
 									\
 	assert(a_name##tsd_booted);					\
 	return (&a_name##tsd_tls);					\
 }									\
 a_attr void								\
@@ -304,20 +334,20 @@
 		malloc_write("<jemalloc>: Error setting"		\
 		    " TSD for "#a_name"\n");				\
 		abort();						\
 	}								\
 }									\
 a_attr a_name##tsd_wrapper_t *						\
-a_name##tsd_wrapper_get(void)						\
+a_name##tsd_wrapper_get(bool init)					\
 {									\
 	DWORD error = GetLastError();					\
 	a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *)	\
 	    TlsGetValue(a_name##tsd_tsd);				\
 	SetLastError(error);						\
 									\
-	if (unlikely(wrapper == NULL)) {				\
+	if (init && unlikely(wrapper == NULL)) {			\
 		wrapper = (a_name##tsd_wrapper_t *)			\
 		    malloc_tsd_malloc(sizeof(a_name##tsd_wrapper_t));	\
 		if (wrapper == NULL) {					\
 			malloc_write("<jemalloc>: Error allocating"	\
 			    " TSD for "#a_name"\n");			\
 			abort();					\
@@ -365,29 +395,43 @@
 									\
 	if (a_name##tsd_boot0())					\
 		return (true);						\
 	a_name##tsd_boot1();						\
 	return (false);							\
 }									\
+a_attr bool								\
+a_name##tsd_booted_get(void)						\
+{									\
+									\
+	return (a_name##tsd_booted);					\
+}									\
+a_attr bool								\
+a_name##tsd_get_allocates(void)						\
+{									\
+									\
+	return (true);							\
+}									\
 /* Get/set. */								\
 a_attr a_type *								\
-a_name##tsd_get(void)							\
+a_name##tsd_get(bool init)						\
 {									\
 	a_name##tsd_wrapper_t *wrapper;					\
 									\
 	assert(a_name##tsd_booted);					\
-	wrapper = a_name##tsd_wrapper_get();				\
+	wrapper = a_name##tsd_wrapper_get(init);			\
+	if (a_name##tsd_get_allocates() && !init && wrapper == NULL)	\
+		return (NULL);						\
 	return (&wrapper->val);						\
 }									\
 a_attr void								\
 a_name##tsd_set(a_type *val)						\
 {									\
 	a_name##tsd_wrapper_t *wrapper;					\
 									\
 	assert(a_name##tsd_booted);					\
-	wrapper = a_name##tsd_wrapper_get();				\
+	wrapper = a_name##tsd_wrapper_get(true);			\
 	wrapper->val = *(val);						\
 	if (a_cleanup != malloc_tsd_no_cleanup)				\
 		wrapper->initialized = true;				\
 }
 #else
 #define	malloc_tsd_funcs(a_attr, a_name, a_type, a_initializer,		\
@@ -425,18 +469,18 @@
 		malloc_write("<jemalloc>: Error setting"		\
 		    " TSD for "#a_name"\n");				\
 		abort();						\
 	}								\
 }									\
 a_attr a_name##tsd_wrapper_t *						\
-a_name##tsd_wrapper_get(void)						\
+a_name##tsd_wrapper_get(bool init)					\
 {									\
 	a_name##tsd_wrapper_t *wrapper = (a_name##tsd_wrapper_t *)	\
 	    pthread_getspecific(a_name##tsd_tsd);			\
 									\
-	if (unlikely(wrapper == NULL)) {				\
+	if (init && unlikely(wrapper == NULL)) {			\
 		tsd_init_block_t block;					\
 		wrapper = tsd_init_check_recursion(			\
 		    &a_name##tsd_init_head, &block);			\
 		if (wrapper)						\
 		    return (wrapper);					\
 		wrapper = (a_name##tsd_wrapper_t *)			\
@@ -487,29 +531,43 @@
 									\
 	if (a_name##tsd_boot0())					\
 		return (true);						\
 	a_name##tsd_boot1();						\
 	return (false);							\
 }									\
+a_attr bool								\
+a_name##tsd_booted_get(void)						\
+{									\
+									\
+	return (a_name##tsd_booted);					\
+}									\
+a_attr bool								\
+a_name##tsd_get_allocates(void)						\
+{									\
+									\
+	return (true);							\
+}									\
 /* Get/set. */								\
 a_attr a_type *								\
-a_name##tsd_get(void)							\
+a_name##tsd_get(bool init)						\
 {									\
 	a_name##tsd_wrapper_t *wrapper;					\
 									\
 	assert(a_name##tsd_booted);					\
-	wrapper = a_name##tsd_wrapper_get();				\
+	wrapper = a_name##tsd_wrapper_get(init);			\
+	if (a_name##tsd_get_allocates() && !init && wrapper == NULL)	\
+		return (NULL);						\
 	return (&wrapper->val);						\
 }									\
 a_attr void								\
 a_name##tsd_set(a_type *val)						\
 {									\
 	a_name##tsd_wrapper_t *wrapper;					\
 									\
 	assert(a_name##tsd_booted);					\
-	wrapper = a_name##tsd_wrapper_get();				\
+	wrapper = a_name##tsd_wrapper_get(true);			\
 	wrapper->val = *(val);						\
 	if (a_cleanup != malloc_tsd_no_cleanup)				\
 		wrapper->initialized = true;				\
 }
 #endif
 
@@ -533,54 +591,69 @@
 #define	MALLOC_TSD							\
 /*  O(name,			type) */				\
     O(tcache,			tcache_t *)				\
     O(thread_allocated,		uint64_t)				\
     O(thread_deallocated,	uint64_t)				\
     O(prof_tdata,		prof_tdata_t *)				\
+    O(iarena,			arena_t *)				\
     O(arena,			arena_t *)				\
-    O(arenas_cache,		arena_t **)				\
-    O(narenas_cache,		unsigned)				\
-    O(arenas_cache_bypass,	bool)					\
+    O(arenas_tdata,		arena_tdata_t *)			\
+    O(narenas_tdata,		unsigned)				\
+    O(arenas_tdata_bypass,	bool)					\
     O(tcache_enabled,		tcache_enabled_t)			\
     O(quarantine,		quarantine_t *)				\
+    O(witnesses,		witness_list_t)				\
+    O(witness_fork,		bool)					\
 
 #define	TSD_INITIALIZER {						\
     tsd_state_uninitialized,						\
     NULL,								\
     0,									\
     0,									\
     NULL,								\
     NULL,								\
     NULL,								\
+    NULL,								\
     0,									\
     false,								\
     tcache_enabled_default,						\
-    NULL								\
+    NULL,								\
+    ql_head_initializer(witnesses),					\
+    false								\
 }
 
 struct tsd_s {
 	tsd_state_t	state;
 #define	O(n, t)								\
 	t		n;
 MALLOC_TSD
 #undef O
 };
 
+/*
+ * Wrapper around tsd_t that makes it possible to avoid implicit conversion
+ * between tsd_t and tsdn_t, where tsdn_t is "nullable" and has to be
+ * explicitly converted to tsd_t, which is non-nullable.
+ */
+struct tsdn_s {
+	tsd_t	tsd;
+};
+
 static const tsd_t tsd_initializer = TSD_INITIALIZER;
 
 malloc_tsd_types(, tsd_t)
 
 #endif /* JEMALLOC_H_STRUCTS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_EXTERNS
 
 void	*malloc_tsd_malloc(size_t size);
 void	malloc_tsd_dalloc(void *wrapper);
 void	malloc_tsd_no_cleanup(void *arg);
 void	malloc_tsd_cleanup_register(bool (*f)(void));
-bool	malloc_tsd_boot0(void);
+tsd_t	*malloc_tsd_boot0(void);
 void	malloc_tsd_boot1(void);
 #if (!defined(JEMALLOC_MALLOC_THREAD_CLEANUP) && !defined(JEMALLOC_TLS) && \
     !defined(_WIN32))
 void	*tsd_init_check_recursion(tsd_init_head_t *head,
     tsd_init_block_t *block);
 void	tsd_init_finish(tsd_init_head_t *head, tsd_init_block_t *block);
@@ -591,30 +664,39 @@
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
 malloc_tsd_protos(JEMALLOC_ATTR(unused), , tsd_t)
 
+tsd_t	*tsd_fetch_impl(bool init);
 tsd_t	*tsd_fetch(void);
+tsdn_t	*tsd_tsdn(tsd_t *tsd);
 bool	tsd_nominal(tsd_t *tsd);
 #define	O(n, t)								\
 t	*tsd_##n##p_get(tsd_t *tsd);					\
 t	tsd_##n##_get(tsd_t *tsd);					\
 void	tsd_##n##_set(tsd_t *tsd, t n);
 MALLOC_TSD
 #undef O
+tsdn_t	*tsdn_fetch(void);
+bool	tsdn_null(const tsdn_t *tsdn);
+tsd_t	*tsdn_tsd(tsdn_t *tsdn);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_TSD_C_))
 malloc_tsd_externs(, tsd_t)
 malloc_tsd_funcs(JEMALLOC_ALWAYS_INLINE, , tsd_t, tsd_initializer, tsd_cleanup)
 
 JEMALLOC_ALWAYS_INLINE tsd_t *
-tsd_fetch(void)
+tsd_fetch_impl(bool init)
 {
-	tsd_t *tsd = tsd_get();
+	tsd_t *tsd = tsd_get(init);
+
+	if (!init && tsd_get_allocates() && tsd == NULL)
+		return (NULL);
+	assert(tsd != NULL);
 
 	if (unlikely(tsd->state != tsd_state_nominal)) {
 		if (tsd->state == tsd_state_uninitialized) {
 			tsd->state = tsd_state_nominal;
 			/* Trigger cleanup handler registration. */
 			tsd_set(tsd);
@@ -625,12 +707,26 @@
 			assert(tsd->state == tsd_state_reincarnated);
 	}
 
 	return (tsd);
 }
 
+JEMALLOC_ALWAYS_INLINE tsd_t *
+tsd_fetch(void)
+{
+
+	return (tsd_fetch_impl(true));
+}
+
+JEMALLOC_ALWAYS_INLINE tsdn_t *
+tsd_tsdn(tsd_t *tsd)
+{
+
+	return ((tsdn_t *)tsd);
+}
+
 JEMALLOC_INLINE bool
 tsd_nominal(tsd_t *tsd)
 {
 
 	return (tsd->state == tsd_state_nominal);
 }
@@ -656,10 +752,36 @@
 									\
 	assert(tsd->state == tsd_state_nominal);			\
 	tsd->n = n;							\
 }
 MALLOC_TSD
 #undef O
+
+JEMALLOC_ALWAYS_INLINE tsdn_t *
+tsdn_fetch(void)
+{
+
+	if (!tsd_booted_get())
+		return (NULL);
+
+	return (tsd_tsdn(tsd_fetch_impl(false)));
+}
+
+JEMALLOC_ALWAYS_INLINE bool
+tsdn_null(const tsdn_t *tsdn)
+{
+
+	return (tsdn == NULL);
+}
+
+JEMALLOC_ALWAYS_INLINE tsd_t *
+tsdn_tsd(tsdn_t *tsdn)
+{
+
+	assert(!tsdn_null(tsdn));
+
+	return (&tsdn->tsd);
+}
 #endif
 
 #endif /* JEMALLOC_H_INLINES */
 /******************************************************************************/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/util.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/util.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/util.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/util.h	2017-01-31 23:32:23.000000000 +0800
@@ -37,12 +37,20 @@
 /*
  * Size of stack-allocated buffer used by malloc_{,v,vc}printf().  This must be
  * large enough for all possible uses within jemalloc.
  */
 #define	MALLOC_PRINTF_BUFSIZE	4096
 
+/* Junk fill patterns. */
+#ifndef JEMALLOC_ALLOC_JUNK
+#  define JEMALLOC_ALLOC_JUNK	((uint8_t)0xa5)
+#endif
+#ifndef JEMALLOC_FREE_JUNK
+#  define JEMALLOC_FREE_JUNK	((uint8_t)0x5a)
+#endif
+
 /*
  * Wrap a cpp argument that contains commas such that it isn't broken up into
  * multiple arguments.
  */
 #define	JEMALLOC_ARG_CONCAT(...) __VA_ARGS__
 
@@ -54,79 +62,27 @@
 #ifdef JEMALLOC_CC_SILENCE
 #	define JEMALLOC_CC_SILENCE_INIT(v) = v
 #else
 #	define JEMALLOC_CC_SILENCE_INIT(v)
 #endif
 
-#define	JEMALLOC_GNUC_PREREQ(major, minor)				\
-    (!defined(__clang__) &&						\
-    (__GNUC__ > (major) || (__GNUC__ == (major) && __GNUC_MINOR__ >= (minor))))
-#ifndef __has_builtin
-#  define __has_builtin(builtin) (0)
-#endif
-#define	JEMALLOC_CLANG_HAS_BUILTIN(builtin)				\
-    (defined(__clang__) && __has_builtin(builtin))
-
 #ifdef __GNUC__
 #	define likely(x)   __builtin_expect(!!(x), 1)
 #	define unlikely(x) __builtin_expect(!!(x), 0)
-#  if JEMALLOC_GNUC_PREREQ(4, 6) ||					\
-      JEMALLOC_CLANG_HAS_BUILTIN(__builtin_unreachable)
-#	define unreachable() __builtin_unreachable()
-#  else
-#	define unreachable()
-#  endif
 #else
 #	define likely(x)   !!(x)
 #	define unlikely(x) !!(x)
-#	define unreachable()
-#endif
-
-/*
- * Define a custom assert() in order to reduce the chances of deadlock during
- * assertion failure.
- */
-#ifndef assert
-#define	assert(e) do {							\
-	if (unlikely(config_debug && !(e))) {				\
-		malloc_printf(						\
-		    "<jemalloc>: %s:%d: Failed assertion: \"%s\"\n",	\
-		    __FILE__, __LINE__, #e);				\
-		abort();						\
-	}								\
-} while (0)
 #endif
 
-#ifndef not_reached
-#define	not_reached() do {						\
-	if (config_debug) {						\
-		malloc_printf(						\
-		    "<jemalloc>: %s:%d: Unreachable code reached\n",	\
-		    __FILE__, __LINE__);				\
-		abort();						\
-	}								\
-	unreachable();							\
-} while (0)
+#if !defined(JEMALLOC_INTERNAL_UNREACHABLE)
+#  error JEMALLOC_INTERNAL_UNREACHABLE should have been defined by configure
 #endif
 
-#ifndef not_implemented
-#define	not_implemented() do {						\
-	if (config_debug) {						\
-		malloc_printf("<jemalloc>: %s:%d: Not implemented\n",	\
-		    __FILE__, __LINE__);				\
-		abort();						\
-	}								\
-} while (0)
-#endif
+#define unreachable() JEMALLOC_INTERNAL_UNREACHABLE()
 
-#ifndef assert_not_implemented
-#define	assert_not_implemented(e) do {					\
-	if (unlikely(config_debug && !(e)))				\
-		not_implemented();					\
-} while (0)
-#endif
+#include "jemalloc/internal/assert.h"
 
 /* Use to assert a particular configuration, e.g., cassert(config_debug). */
 #define	cassert(c) do {							\
 	if (unlikely(!(c)))						\
 		not_reached();						\
 } while (0)
@@ -145,146 +101,218 @@
 void	malloc_write(const char *s);
 
 /*
  * malloc_vsnprintf() supports a subset of snprintf(3) that avoids floating
  * point math.
  */
-int	malloc_vsnprintf(char *str, size_t size, const char *format,
+size_t	malloc_vsnprintf(char *str, size_t size, const char *format,
     va_list ap);
-int	malloc_snprintf(char *str, size_t size, const char *format, ...)
+size_t	malloc_snprintf(char *str, size_t size, const char *format, ...)
     JEMALLOC_FORMAT_PRINTF(3, 4);
 void	malloc_vcprintf(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *format, va_list ap);
 void malloc_cprintf(void (*write)(void *, const char *), void *cbopaque,
     const char *format, ...) JEMALLOC_FORMAT_PRINTF(3, 4);
 void	malloc_printf(const char *format, ...) JEMALLOC_FORMAT_PRINTF(1, 2);
 
 #endif /* JEMALLOC_H_EXTERNS */
 /******************************************************************************/
 #ifdef JEMALLOC_H_INLINES
 
 #ifndef JEMALLOC_ENABLE_INLINE
-int	jemalloc_ffsl(long bitmap);
-int	jemalloc_ffs(int bitmap);
-size_t	pow2_ceil(size_t x);
-size_t	lg_floor(size_t x);
+unsigned	ffs_llu(unsigned long long bitmap);
+unsigned	ffs_lu(unsigned long bitmap);
+unsigned	ffs_u(unsigned bitmap);
+unsigned	ffs_zu(size_t bitmap);
+unsigned	ffs_u64(uint64_t bitmap);
+unsigned	ffs_u32(uint32_t bitmap);
+uint64_t	pow2_ceil_u64(uint64_t x);
+uint32_t	pow2_ceil_u32(uint32_t x);
+size_t	pow2_ceil_zu(size_t x);
+unsigned	lg_floor(size_t x);
 void	set_errno(int errnum);
 int	get_errno(void);
 #endif
 
 #if (defined(JEMALLOC_ENABLE_INLINE) || defined(JEMALLOC_UTIL_C_))
 
 /* Sanity check. */
-#if !defined(JEMALLOC_INTERNAL_FFSL) || !defined(JEMALLOC_INTERNAL_FFS)
-#  error Both JEMALLOC_INTERNAL_FFSL && JEMALLOC_INTERNAL_FFS should have been defined by configure
+#if !defined(JEMALLOC_INTERNAL_FFSLL) || !defined(JEMALLOC_INTERNAL_FFSL) \
+    || !defined(JEMALLOC_INTERNAL_FFS)
+#  error JEMALLOC_INTERNAL_FFS{,L,LL} should have been defined by configure
 #endif
 
-JEMALLOC_ALWAYS_INLINE int
-jemalloc_ffsl(long bitmap)
+JEMALLOC_ALWAYS_INLINE unsigned
+ffs_llu(unsigned long long bitmap)
+{
+
+	return (JEMALLOC_INTERNAL_FFSLL(bitmap));
+}
+
+JEMALLOC_ALWAYS_INLINE unsigned
+ffs_lu(unsigned long bitmap)
 {
 
 	return (JEMALLOC_INTERNAL_FFSL(bitmap));
 }
 
-JEMALLOC_ALWAYS_INLINE int
-jemalloc_ffs(int bitmap)
+JEMALLOC_ALWAYS_INLINE unsigned
+ffs_u(unsigned bitmap)
 {
 
 	return (JEMALLOC_INTERNAL_FFS(bitmap));
 }
 
-/* Compute the smallest power of 2 that is >= x. */
-JEMALLOC_INLINE size_t
-pow2_ceil(size_t x)
+JEMALLOC_ALWAYS_INLINE unsigned
+ffs_zu(size_t bitmap)
+{
+
+#if LG_SIZEOF_PTR == LG_SIZEOF_INT
+	return (ffs_u(bitmap));
+#elif LG_SIZEOF_PTR == LG_SIZEOF_LONG
+	return (ffs_lu(bitmap));
+#elif LG_SIZEOF_PTR == LG_SIZEOF_LONG_LONG
+	return (ffs_llu(bitmap));
+#else
+#error No implementation for size_t ffs()
+#endif
+}
+
+JEMALLOC_ALWAYS_INLINE unsigned
+ffs_u64(uint64_t bitmap)
+{
+
+#if LG_SIZEOF_LONG == 3
+	return (ffs_lu(bitmap));
+#elif LG_SIZEOF_LONG_LONG == 3
+	return (ffs_llu(bitmap));
+#else
+#error No implementation for 64-bit ffs()
+#endif
+}
+
+JEMALLOC_ALWAYS_INLINE unsigned
+ffs_u32(uint32_t bitmap)
+{
+
+#if LG_SIZEOF_INT == 2
+	return (ffs_u(bitmap));
+#else
+#error No implementation for 32-bit ffs()
+#endif
+	return (ffs_u(bitmap));
+}
+
+JEMALLOC_INLINE uint64_t
+pow2_ceil_u64(uint64_t x)
 {
 
 	x--;
 	x |= x >> 1;
 	x |= x >> 2;
 	x |= x >> 4;
 	x |= x >> 8;
 	x |= x >> 16;
-#if (LG_SIZEOF_PTR == 3)
 	x |= x >> 32;
-#endif
 	x++;
 	return (x);
 }
 
-#if (defined(__i386__) || defined(__amd64__) || defined(__x86_64__))
+JEMALLOC_INLINE uint32_t
+pow2_ceil_u32(uint32_t x)
+{
+
+	x--;
+	x |= x >> 1;
+	x |= x >> 2;
+	x |= x >> 4;
+	x |= x >> 8;
+	x |= x >> 16;
+	x++;
+	return (x);
+}
+
+/* Compute the smallest power of 2 that is >= x. */
 JEMALLOC_INLINE size_t
+pow2_ceil_zu(size_t x)
+{
+
+#if (LG_SIZEOF_PTR == 3)
+	return (pow2_ceil_u64(x));
+#else
+	return (pow2_ceil_u32(x));
+#endif
+}
+
+#if (defined(__i386__) || defined(__amd64__) || defined(__x86_64__))
+JEMALLOC_INLINE unsigned
 lg_floor(size_t x)
 {
 	size_t ret;
 
 	assert(x != 0);
 
 	asm ("bsr %1, %0"
 	    : "=r"(ret) // Outputs.
 	    : "r"(x)    // Inputs.
 	    );
-	return (ret);
+	assert(ret < UINT_MAX);
+	return ((unsigned)ret);
 }
 #elif (defined(_MSC_VER))
-JEMALLOC_INLINE size_t
+JEMALLOC_INLINE unsigned
 lg_floor(size_t x)
 {
 	unsigned long ret;
 
 	assert(x != 0);
 
 #if (LG_SIZEOF_PTR == 3)
 	_BitScanReverse64(&ret, x);
 #elif (LG_SIZEOF_PTR == 2)
 	_BitScanReverse(&ret, x);
 #else
-#  error "Unsupported type sizes for lg_floor()"
+#  error "Unsupported type size for lg_floor()"
 #endif
-	return (ret);
+	assert(ret < UINT_MAX);
+	return ((unsigned)ret);
 }
 #elif (defined(JEMALLOC_HAVE_BUILTIN_CLZ))
-JEMALLOC_INLINE size_t
+JEMALLOC_INLINE unsigned
 lg_floor(size_t x)
 {
 
 	assert(x != 0);
 
 #if (LG_SIZEOF_PTR == LG_SIZEOF_INT)
 	return (((8 << LG_SIZEOF_PTR) - 1) - __builtin_clz(x));
 #elif (LG_SIZEOF_PTR == LG_SIZEOF_LONG)
 	return (((8 << LG_SIZEOF_PTR) - 1) - __builtin_clzl(x));
 #else
-#  error "Unsupported type sizes for lg_floor()"
+#  error "Unsupported type size for lg_floor()"
 #endif
 }
 #else
-JEMALLOC_INLINE size_t
+JEMALLOC_INLINE unsigned
 lg_floor(size_t x)
 {
 
 	assert(x != 0);
 
 	x |= (x >> 1);
 	x |= (x >> 2);
 	x |= (x >> 4);
 	x |= (x >> 8);
 	x |= (x >> 16);
-#if (LG_SIZEOF_PTR == 3 && LG_SIZEOF_PTR == LG_SIZEOF_LONG)
+#if (LG_SIZEOF_PTR == 3)
 	x |= (x >> 32);
-	if (x == KZU(0xffffffffffffffff))
-		return (63);
-	x++;
-	return (jemalloc_ffsl(x) - 2);
-#elif (LG_SIZEOF_PTR == 2)
-	if (x == KZU(0xffffffff))
-		return (31);
-	x++;
-	return (jemalloc_ffs(x) - 2);
-#else
-#  error "Unsupported type sizes for lg_floor()"
 #endif
+	if (x == SIZE_T_MAX)
+		return ((8 << LG_SIZEOF_PTR) - 1);
+	x++;
+	return (ffs_zu(x) - 2);
 }
 #endif
 
 /* Set error code. */
 JEMALLOC_INLINE void
 set_errno(int errnum)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/valgrind.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/valgrind.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/internal/valgrind.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal/valgrind.h	2017-01-31 23:32:23.000000000 +0800
@@ -27,36 +27,52 @@
 } while (0)
 /*
  * The VALGRIND_MALLOCLIKE_BLOCK() and VALGRIND_RESIZEINPLACE_BLOCK() macro
  * calls must be embedded in macros rather than in functions so that when
  * Valgrind reports errors, there are no extra stack frames in the backtraces.
  */
-#define	JEMALLOC_VALGRIND_MALLOC(cond, ptr, usize, zero) do {		\
-	if (unlikely(in_valgrind && cond))				\
-		VALGRIND_MALLOCLIKE_BLOCK(ptr, usize, p2rz(ptr), zero);	\
+#define	JEMALLOC_VALGRIND_MALLOC(cond, tsdn, ptr, usize, zero) do {	\
+	if (unlikely(in_valgrind && cond)) {				\
+		VALGRIND_MALLOCLIKE_BLOCK(ptr, usize, p2rz(tsdn, ptr),	\
+		    zero);						\
+	}								\
 } while (0)
-#define	JEMALLOC_VALGRIND_REALLOC(maybe_moved, ptr, usize,		\
-    ptr_maybe_null, old_ptr, old_usize, old_rzsize, old_ptr_maybe_null,	\
-    zero) do {								\
+#define	JEMALLOC_VALGRIND_REALLOC_MOVED_no(ptr, old_ptr)		\
+    (false)
+#define	JEMALLOC_VALGRIND_REALLOC_MOVED_maybe(ptr, old_ptr)		\
+    ((ptr) != (old_ptr))
+#define	JEMALLOC_VALGRIND_REALLOC_PTR_NULL_no(ptr)			\
+    (false)
+#define	JEMALLOC_VALGRIND_REALLOC_PTR_NULL_maybe(ptr)			\
+    (ptr == NULL)
+#define	JEMALLOC_VALGRIND_REALLOC_OLD_PTR_NULL_no(old_ptr)		\
+    (false)
+#define	JEMALLOC_VALGRIND_REALLOC_OLD_PTR_NULL_maybe(old_ptr)		\
+    (old_ptr == NULL)
+#define	JEMALLOC_VALGRIND_REALLOC(moved, tsdn, ptr, usize, ptr_null,	\
+    old_ptr, old_usize, old_rzsize, old_ptr_null, zero) do {		\
 	if (unlikely(in_valgrind)) {					\
-		size_t rzsize = p2rz(ptr);				\
+		size_t rzsize = p2rz(tsdn, ptr);			\
 									\
-		if (!maybe_moved || ptr == old_ptr) {			\
+		if (!JEMALLOC_VALGRIND_REALLOC_MOVED_##moved(ptr,	\
+		    old_ptr)) {						\
 			VALGRIND_RESIZEINPLACE_BLOCK(ptr, old_usize,	\
 			    usize, rzsize);				\
 			if (zero && old_usize < usize) {		\
 				valgrind_make_mem_defined(		\
 				    (void *)((uintptr_t)ptr +		\
 				    old_usize), usize - old_usize);	\
 			}						\
 		} else {						\
-			if (!old_ptr_maybe_null || old_ptr != NULL) {	\
+			if (!JEMALLOC_VALGRIND_REALLOC_OLD_PTR_NULL_##	\
+			    old_ptr_null(old_ptr)) {			\
 				valgrind_freelike_block(old_ptr,	\
 				    old_rzsize);			\
 			}						\
-			if (!ptr_maybe_null || ptr != NULL) {		\
+			if (!JEMALLOC_VALGRIND_REALLOC_PTR_NULL_##	\
+			    ptr_null(ptr)) {				\
 				size_t copy_size = (old_usize < usize)	\
 				    ?  old_usize : usize;		\
 				size_t tail_size = usize - copy_size;	\
 				VALGRIND_MALLOCLIKE_BLOCK(ptr, usize,	\
 				    rzsize, false);			\
 				if (copy_size > 0) {			\
@@ -78,14 +94,14 @@
 } while (0)
 #else
 #define	RUNNING_ON_VALGRIND	((unsigned)0)
 #define	JEMALLOC_VALGRIND_MAKE_MEM_NOACCESS(ptr, usize) do {} while (0)
 #define	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ptr, usize) do {} while (0)
 #define	JEMALLOC_VALGRIND_MAKE_MEM_DEFINED(ptr, usize) do {} while (0)
-#define	JEMALLOC_VALGRIND_MALLOC(cond, ptr, usize, zero) do {} while (0)
-#define	JEMALLOC_VALGRIND_REALLOC(maybe_moved, ptr, usize,		\
+#define	JEMALLOC_VALGRIND_MALLOC(cond, tsdn, ptr, usize, zero) do {} while (0)
+#define	JEMALLOC_VALGRIND_REALLOC(maybe_moved, tsdn, ptr, usize,	\
     ptr_maybe_null, old_ptr, old_usize, old_rzsize, old_ptr_maybe_null,	\
     zero) do {} while (0)
 #define	JEMALLOC_VALGRIND_FREE(ptr, rzsize) do {} while (0)
 #endif
 
 #endif /* JEMALLOC_H_TYPES */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/internal: witness.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc_defs.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc_defs.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc_defs.h	2017-09-27 23:00:17.514936196 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc_defs.h	2017-09-27 23:01:52.514932715 +0800
@@ -31,8 +31,16 @@
  * If defined, specify throw() for the public function prototypes when compiling
  * with C++.  The only justification for this is to match the prototypes that
  * glibc defines.
  */
 #define JEMALLOC_USE_CXX_THROW 
 
+#ifdef _MSC_VER
+#  ifdef _WIN64
+#    define LG_SIZEOF_PTR_WIN 3
+#  else
+#    define LG_SIZEOF_PTR_WIN 2
+#  endif
+#endif
+
 /* sizeof(void *) == 2^LG_SIZEOF_PTR. */
 #define LG_SIZEOF_PTR 3
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc_defs.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc_defs.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc_defs.h.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc_defs.h.in	2017-01-31 23:32:23.000000000 +0800
@@ -30,8 +30,16 @@
  * If defined, specify throw() for the public function prototypes when compiling
  * with C++.  The only justification for this is to match the prototypes that
  * glibc defines.
  */
 #undef JEMALLOC_USE_CXX_THROW
 
+#ifdef _MSC_VER
+#  ifdef _WIN64
+#    define LG_SIZEOF_PTR_WIN 3
+#  else
+#    define LG_SIZEOF_PTR_WIN 2
+#  endif
+#endif
+
 /* sizeof(void *) == 2^LG_SIZEOF_PTR. */
 #undef LG_SIZEOF_PTR
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc.h	2017-09-27 23:00:17.790936186 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc.h	2017-09-27 23:01:52.814932704 +0800
@@ -36,12 +36,20 @@
  * If defined, specify throw() for the public function prototypes when compiling
  * with C++.  The only justification for this is to match the prototypes that
  * glibc defines.
  */
 #define	JEMALLOC_USE_CXX_THROW
 
+#ifdef _MSC_VER
+#  ifdef _WIN64
+#    define LG_SIZEOF_PTR_WIN 3
+#  else
+#    define LG_SIZEOF_PTR_WIN 2
+#  endif
+#endif
+
 /* sizeof(void *) == 2^LG_SIZEOF_PTR. */
 #define	LG_SIZEOF_PTR 3
 
 /*
  * Name mangling for public symbols is controlled by --with-mangling and
  * --with-jemalloc-prefix.  With default settings the je_ prefix is stripped by
@@ -75,70 +83,46 @@
 #include <stdlib.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <limits.h>
 #include <strings.h>
 
-#define	JEMALLOC_VERSION "4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c"
+#define	JEMALLOC_VERSION "4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc"
 #define	JEMALLOC_VERSION_MAJOR 4
-#define	JEMALLOC_VERSION_MINOR 0
-#define	JEMALLOC_VERSION_BUGFIX 3
+#define	JEMALLOC_VERSION_MINOR 4
+#define	JEMALLOC_VERSION_BUGFIX 0
 #define	JEMALLOC_VERSION_NREV 0
-#define	JEMALLOC_VERSION_GID "e9192eacf8935e29fc62fddc2701f7942b1cc02c"
+#define	JEMALLOC_VERSION_GID "f1f76357313e7dcad7262f17a48ff0a2e005fcdc"
 
-#  define MALLOCX_LG_ALIGN(la)	(la)
+#  define MALLOCX_LG_ALIGN(la)	((int)(la))
 #  if LG_SIZEOF_PTR == 2
-#    define MALLOCX_ALIGN(a)	(ffs(a)-1)
+#    define MALLOCX_ALIGN(a)	((int)(ffs((int)(a))-1))
 #  else
 #    define MALLOCX_ALIGN(a)						\
-	 ((a < (size_t)INT_MAX) ? ffs(a)-1 : ffs(a>>32)+31)
+       ((int)(((size_t)(a) < (size_t)INT_MAX) ? ffs((int)(a))-1 :	\
+       ffs((int)(((size_t)(a))>>32))+31))
 #  endif
 #  define MALLOCX_ZERO	((int)0x40)
 /*
  * Bias tcache index bits so that 0 encodes "automatic tcache management", and 1
  * encodes MALLOCX_TCACHE_NONE.
  */
 #  define MALLOCX_TCACHE(tc)	((int)(((tc)+2) << 8))
 #  define MALLOCX_TCACHE_NONE	MALLOCX_TCACHE(-1)
 /*
  * Bias arena index bits so that 0 encodes "use an automatically chosen arena".
  */
-#  define MALLOCX_ARENA(a)	((int)(((a)+1) << 20))
+#  define MALLOCX_ARENA(a)	((((int)(a))+1) << 20)
 
 #if defined(__cplusplus) && defined(JEMALLOC_USE_CXX_THROW)
 #  define JEMALLOC_CXX_THROW throw()
 #else
 #  define JEMALLOC_CXX_THROW
 #endif
 
-#ifdef JEMALLOC_HAVE_ATTR
-#  define JEMALLOC_ATTR(s) __attribute__((s))
-#  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
-#  ifdef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
-#    define JEMALLOC_ALLOC_SIZE(s) JEMALLOC_ATTR(alloc_size(s))
-#    define JEMALLOC_ALLOC_SIZE2(s1, s2) JEMALLOC_ATTR(alloc_size(s1, s2))
-#  else
-#    define JEMALLOC_ALLOC_SIZE(s)
-#    define JEMALLOC_ALLOC_SIZE2(s1, s2)
-#  endif
-#  ifndef JEMALLOC_EXPORT
-#    define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
-#  endif
-#  ifdef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
-#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(gnu_printf, s, i))
-#  elif defined(JEMALLOC_HAVE_ATTR_FORMAT_PRINTF)
-#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(printf, s, i))
-#  else
-#    define JEMALLOC_FORMAT_PRINTF(s, i)
-#  endif
-#  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
-#  define JEMALLOC_NOTHROW JEMALLOC_ATTR(nothrow)
-#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
-#  define JEMALLOC_RESTRICT_RETURN
-#  define JEMALLOC_ALLOCATOR
-#elif _MSC_VER
+#if _MSC_VER
 #  define JEMALLOC_ATTR(s)
 #  define JEMALLOC_ALIGNED(s) __declspec(align(s))
 #  define JEMALLOC_ALLOC_SIZE(s)
 #  define JEMALLOC_ALLOC_SIZE2(s1, s2)
 #  ifndef JEMALLOC_EXPORT
 #    ifdef DLLEXPORT
@@ -158,12 +142,37 @@
 #  define JEMALLOC_RESTRICT_RETURN __declspec(restrict)
 #  if _MSC_VER >= 1900 && !defined(__EDG__)
 #    define JEMALLOC_ALLOCATOR __declspec(allocator)
 #  else
 #    define JEMALLOC_ALLOCATOR
 #  endif
+#elif defined(JEMALLOC_HAVE_ATTR)
+#  define JEMALLOC_ATTR(s) __attribute__((s))
+#  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
+#  ifdef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
+#    define JEMALLOC_ALLOC_SIZE(s) JEMALLOC_ATTR(alloc_size(s))
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2) JEMALLOC_ATTR(alloc_size(s1, s2))
+#  else
+#    define JEMALLOC_ALLOC_SIZE(s)
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  endif
+#  ifndef JEMALLOC_EXPORT
+#    define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
+#  endif
+#  ifdef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(gnu_printf, s, i))
+#  elif defined(JEMALLOC_HAVE_ATTR_FORMAT_PRINTF)
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(printf, s, i))
+#  else
+#    define JEMALLOC_FORMAT_PRINTF(s, i)
+#  endif
+#  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
+#  define JEMALLOC_NOTHROW JEMALLOC_ATTR(nothrow)
+#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  define JEMALLOC_RESTRICT_RETURN
+#  define JEMALLOC_ALLOCATOR
 #else
 #  define JEMALLOC_ATTR(s)
 #  define JEMALLOC_ALIGNED(s)
 #  define JEMALLOC_ALLOC_SIZE(s)
 #  define JEMALLOC_ALLOC_SIZE2(s1, s2)
 #  define JEMALLOC_EXPORT
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc_macros.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc_macros.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc_macros.h	2017-09-27 23:00:17.414936200 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc_macros.h	2017-09-27 23:01:52.394932719 +0800
@@ -1,70 +1,46 @@
 #include <stdlib.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <limits.h>
 #include <strings.h>
 
-#define	JEMALLOC_VERSION "4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c"
+#define	JEMALLOC_VERSION "4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc"
 #define	JEMALLOC_VERSION_MAJOR 4
-#define	JEMALLOC_VERSION_MINOR 0
-#define	JEMALLOC_VERSION_BUGFIX 3
+#define	JEMALLOC_VERSION_MINOR 4
+#define	JEMALLOC_VERSION_BUGFIX 0
 #define	JEMALLOC_VERSION_NREV 0
-#define	JEMALLOC_VERSION_GID "e9192eacf8935e29fc62fddc2701f7942b1cc02c"
+#define	JEMALLOC_VERSION_GID "f1f76357313e7dcad7262f17a48ff0a2e005fcdc"
 
-#  define MALLOCX_LG_ALIGN(la)	(la)
+#  define MALLOCX_LG_ALIGN(la)	((int)(la))
 #  if LG_SIZEOF_PTR == 2
-#    define MALLOCX_ALIGN(a)	(ffs(a)-1)
+#    define MALLOCX_ALIGN(a)	((int)(ffs((int)(a))-1))
 #  else
 #    define MALLOCX_ALIGN(a)						\
-	 ((a < (size_t)INT_MAX) ? ffs(a)-1 : ffs(a>>32)+31)
+       ((int)(((size_t)(a) < (size_t)INT_MAX) ? ffs((int)(a))-1 :	\
+       ffs((int)(((size_t)(a))>>32))+31))
 #  endif
 #  define MALLOCX_ZERO	((int)0x40)
 /*
  * Bias tcache index bits so that 0 encodes "automatic tcache management", and 1
  * encodes MALLOCX_TCACHE_NONE.
  */
 #  define MALLOCX_TCACHE(tc)	((int)(((tc)+2) << 8))
 #  define MALLOCX_TCACHE_NONE	MALLOCX_TCACHE(-1)
 /*
  * Bias arena index bits so that 0 encodes "use an automatically chosen arena".
  */
-#  define MALLOCX_ARENA(a)	((int)(((a)+1) << 20))
+#  define MALLOCX_ARENA(a)	((((int)(a))+1) << 20)
 
 #if defined(__cplusplus) && defined(JEMALLOC_USE_CXX_THROW)
 #  define JEMALLOC_CXX_THROW throw()
 #else
 #  define JEMALLOC_CXX_THROW
 #endif
 
-#ifdef JEMALLOC_HAVE_ATTR
-#  define JEMALLOC_ATTR(s) __attribute__((s))
-#  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
-#  ifdef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
-#    define JEMALLOC_ALLOC_SIZE(s) JEMALLOC_ATTR(alloc_size(s))
-#    define JEMALLOC_ALLOC_SIZE2(s1, s2) JEMALLOC_ATTR(alloc_size(s1, s2))
-#  else
-#    define JEMALLOC_ALLOC_SIZE(s)
-#    define JEMALLOC_ALLOC_SIZE2(s1, s2)
-#  endif
-#  ifndef JEMALLOC_EXPORT
-#    define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
-#  endif
-#  ifdef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
-#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(gnu_printf, s, i))
-#  elif defined(JEMALLOC_HAVE_ATTR_FORMAT_PRINTF)
-#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(printf, s, i))
-#  else
-#    define JEMALLOC_FORMAT_PRINTF(s, i)
-#  endif
-#  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
-#  define JEMALLOC_NOTHROW JEMALLOC_ATTR(nothrow)
-#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
-#  define JEMALLOC_RESTRICT_RETURN
-#  define JEMALLOC_ALLOCATOR
-#elif _MSC_VER
+#if _MSC_VER
 #  define JEMALLOC_ATTR(s)
 #  define JEMALLOC_ALIGNED(s) __declspec(align(s))
 #  define JEMALLOC_ALLOC_SIZE(s)
 #  define JEMALLOC_ALLOC_SIZE2(s1, s2)
 #  ifndef JEMALLOC_EXPORT
 #    ifdef DLLEXPORT
@@ -84,12 +60,37 @@
 #  define JEMALLOC_RESTRICT_RETURN __declspec(restrict)
 #  if _MSC_VER >= 1900 && !defined(__EDG__)
 #    define JEMALLOC_ALLOCATOR __declspec(allocator)
 #  else
 #    define JEMALLOC_ALLOCATOR
 #  endif
+#elif defined(JEMALLOC_HAVE_ATTR)
+#  define JEMALLOC_ATTR(s) __attribute__((s))
+#  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
+#  ifdef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
+#    define JEMALLOC_ALLOC_SIZE(s) JEMALLOC_ATTR(alloc_size(s))
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2) JEMALLOC_ATTR(alloc_size(s1, s2))
+#  else
+#    define JEMALLOC_ALLOC_SIZE(s)
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  endif
+#  ifndef JEMALLOC_EXPORT
+#    define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
+#  endif
+#  ifdef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(gnu_printf, s, i))
+#  elif defined(JEMALLOC_HAVE_ATTR_FORMAT_PRINTF)
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(printf, s, i))
+#  else
+#    define JEMALLOC_FORMAT_PRINTF(s, i)
+#  endif
+#  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
+#  define JEMALLOC_NOTHROW JEMALLOC_ATTR(nothrow)
+#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  define JEMALLOC_RESTRICT_RETURN
+#  define JEMALLOC_ALLOCATOR
 #else
 #  define JEMALLOC_ATTR(s)
 #  define JEMALLOC_ALIGNED(s)
 #  define JEMALLOC_ALLOC_SIZE(s)
 #  define JEMALLOC_ALLOC_SIZE2(s1, s2)
 #  define JEMALLOC_EXPORT
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in	2017-01-31 23:32:23.000000000 +0800
@@ -8,63 +8,39 @@
 #define	JEMALLOC_VERSION_MAJOR @jemalloc_version_major@
 #define	JEMALLOC_VERSION_MINOR @jemalloc_version_minor@
 #define	JEMALLOC_VERSION_BUGFIX @jemalloc_version_bugfix@
 #define	JEMALLOC_VERSION_NREV @jemalloc_version_nrev@
 #define	JEMALLOC_VERSION_GID "@jemalloc_version_gid@"
 
-#  define MALLOCX_LG_ALIGN(la)	(la)
+#  define MALLOCX_LG_ALIGN(la)	((int)(la))
 #  if LG_SIZEOF_PTR == 2
-#    define MALLOCX_ALIGN(a)	(ffs(a)-1)
+#    define MALLOCX_ALIGN(a)	((int)(ffs((int)(a))-1))
 #  else
 #    define MALLOCX_ALIGN(a)						\
-	 ((a < (size_t)INT_MAX) ? ffs(a)-1 : ffs(a>>32)+31)
+       ((int)(((size_t)(a) < (size_t)INT_MAX) ? ffs((int)(a))-1 :	\
+       ffs((int)(((size_t)(a))>>32))+31))
 #  endif
 #  define MALLOCX_ZERO	((int)0x40)
 /*
  * Bias tcache index bits so that 0 encodes "automatic tcache management", and 1
  * encodes MALLOCX_TCACHE_NONE.
  */
 #  define MALLOCX_TCACHE(tc)	((int)(((tc)+2) << 8))
 #  define MALLOCX_TCACHE_NONE	MALLOCX_TCACHE(-1)
 /*
  * Bias arena index bits so that 0 encodes "use an automatically chosen arena".
  */
-#  define MALLOCX_ARENA(a)	((int)(((a)+1) << 20))
+#  define MALLOCX_ARENA(a)	((((int)(a))+1) << 20)
 
 #if defined(__cplusplus) && defined(JEMALLOC_USE_CXX_THROW)
 #  define JEMALLOC_CXX_THROW throw()
 #else
 #  define JEMALLOC_CXX_THROW
 #endif
 
-#ifdef JEMALLOC_HAVE_ATTR
-#  define JEMALLOC_ATTR(s) __attribute__((s))
-#  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
-#  ifdef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
-#    define JEMALLOC_ALLOC_SIZE(s) JEMALLOC_ATTR(alloc_size(s))
-#    define JEMALLOC_ALLOC_SIZE2(s1, s2) JEMALLOC_ATTR(alloc_size(s1, s2))
-#  else
-#    define JEMALLOC_ALLOC_SIZE(s)
-#    define JEMALLOC_ALLOC_SIZE2(s1, s2)
-#  endif
-#  ifndef JEMALLOC_EXPORT
-#    define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
-#  endif
-#  ifdef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
-#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(gnu_printf, s, i))
-#  elif defined(JEMALLOC_HAVE_ATTR_FORMAT_PRINTF)
-#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(printf, s, i))
-#  else
-#    define JEMALLOC_FORMAT_PRINTF(s, i)
-#  endif
-#  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
-#  define JEMALLOC_NOTHROW JEMALLOC_ATTR(nothrow)
-#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
-#  define JEMALLOC_RESTRICT_RETURN
-#  define JEMALLOC_ALLOCATOR
-#elif _MSC_VER
+#if _MSC_VER
 #  define JEMALLOC_ATTR(s)
 #  define JEMALLOC_ALIGNED(s) __declspec(align(s))
 #  define JEMALLOC_ALLOC_SIZE(s)
 #  define JEMALLOC_ALLOC_SIZE2(s1, s2)
 #  ifndef JEMALLOC_EXPORT
 #    ifdef DLLEXPORT
@@ -84,12 +60,37 @@
 #  define JEMALLOC_RESTRICT_RETURN __declspec(restrict)
 #  if _MSC_VER >= 1900 && !defined(__EDG__)
 #    define JEMALLOC_ALLOCATOR __declspec(allocator)
 #  else
 #    define JEMALLOC_ALLOCATOR
 #  endif
+#elif defined(JEMALLOC_HAVE_ATTR)
+#  define JEMALLOC_ATTR(s) __attribute__((s))
+#  define JEMALLOC_ALIGNED(s) JEMALLOC_ATTR(aligned(s))
+#  ifdef JEMALLOC_HAVE_ATTR_ALLOC_SIZE
+#    define JEMALLOC_ALLOC_SIZE(s) JEMALLOC_ATTR(alloc_size(s))
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2) JEMALLOC_ATTR(alloc_size(s1, s2))
+#  else
+#    define JEMALLOC_ALLOC_SIZE(s)
+#    define JEMALLOC_ALLOC_SIZE2(s1, s2)
+#  endif
+#  ifndef JEMALLOC_EXPORT
+#    define JEMALLOC_EXPORT JEMALLOC_ATTR(visibility("default"))
+#  endif
+#  ifdef JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(gnu_printf, s, i))
+#  elif defined(JEMALLOC_HAVE_ATTR_FORMAT_PRINTF)
+#    define JEMALLOC_FORMAT_PRINTF(s, i) JEMALLOC_ATTR(format(printf, s, i))
+#  else
+#    define JEMALLOC_FORMAT_PRINTF(s, i)
+#  endif
+#  define JEMALLOC_NOINLINE JEMALLOC_ATTR(noinline)
+#  define JEMALLOC_NOTHROW JEMALLOC_ATTR(nothrow)
+#  define JEMALLOC_SECTION(s) JEMALLOC_ATTR(section(s))
+#  define JEMALLOC_RESTRICT_RETURN
+#  define JEMALLOC_ALLOCATOR
 #else
 #  define JEMALLOC_ATTR(s)
 #  define JEMALLOC_ALIGNED(s)
 #  define JEMALLOC_ALLOC_SIZE(s)
 #  define JEMALLOC_ALLOC_SIZE2(s1, s2)
 #  define JEMALLOC_EXPORT
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/msvc_compat/strings.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/msvc_compat/strings.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/msvc_compat/strings.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/msvc_compat/strings.h	2017-01-31 23:32:23.000000000 +0800
@@ -18,12 +18,42 @@
 static __forceinline int ffs(int x)
 {
 
 	return (ffsl(x));
 }
 
+#  ifdef  _M_X64
+#    pragma intrinsic(_BitScanForward64)
+#  endif
+
+static __forceinline int ffsll(unsigned __int64 x)
+{
+	unsigned long i;
+#ifdef  _M_X64
+	if (_BitScanForward64(&i, x))
+		return (i + 1);
+	return (0);
+#else
+// Fallback for 32-bit build where 64-bit version not available
+// assuming little endian
+	union {
+		unsigned __int64 ll;
+		unsigned   long l[2];
+	} s;
+
+	s.ll = x;
+
+	if (_BitScanForward(&i, s.l[0]))
+		return (i + 1);
+	else if(_BitScanForward(&i, s.l[1]))
+		return (i + 33);
+	return (0);
+#endif
+}
+
 #else
+#  define ffsll(x) __builtin_ffsll(x)
 #  define ffsl(x) __builtin_ffsl(x)
 #  define ffs(x) __builtin_ffs(x)
 #endif
 
 #endif /* strings_h */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/msvc_compat/windows_extra.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/msvc_compat/windows_extra.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/include/msvc_compat/windows_extra.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/include/msvc_compat/windows_extra.h	2017-01-31 23:32:23.000000000 +0800
@@ -1,26 +1,6 @@
 #ifndef MSVC_COMPAT_WINDOWS_EXTRA_H
 #define	MSVC_COMPAT_WINDOWS_EXTRA_H
 
-#ifndef ENOENT
-#  define ENOENT ERROR_PATH_NOT_FOUND
-#endif
-#ifndef EINVAL
-#  define EINVAL ERROR_BAD_ARGUMENTS
-#endif
-#ifndef EAGAIN
-#  define EAGAIN ERROR_OUTOFMEMORY
-#endif
-#ifndef EPERM
-#  define EPERM  ERROR_WRITE_FAULT
-#endif
-#ifndef EFAULT
-#  define EFAULT ERROR_INVALID_ADDRESS
-#endif
-#ifndef ENOMEM
-#  define ENOMEM ERROR_NOT_ENOUGH_MEMORY
-#endif
-#ifndef ERANGE
-#  define ERANGE ERROR_INVALID_DATA
-#endif
+#include <errno.h>
 
 #endif /* MSVC_COMPAT_WINDOWS_EXTRA_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/INSTALL	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/INSTALL	2017-01-31 23:32:23.000000000 +0800
@@ -32,12 +32,16 @@
 
         ./configure --prefix=/usr/local
 
     will cause files to be installed into /usr/local/include, /usr/local/lib,
     and /usr/local/man.
 
+--with-version=<major>.<minor>.<bugfix>-<nrev>-g<gid>
+    Use the specified version string rather than trying to generate one (if in
+    a git repository) or use existing the VERSION file (if present).
+
 --with-rpath=<colon-separated-rpath>
     Embed one or more library paths, so that libjemalloc can find the libraries
     it is linked to.  This works only on ELF-based systems.
 
 --with-mangling=<map>
     Mangle public symbols specified in <map> which is a comma-separated list of
@@ -81,12 +85,20 @@
 
 --with-install-suffix=<suffix>
     Append <suffix> to the base name of all installed files, such that multiple
     versions of jemalloc can coexist in the same installation directory.  For
     example, libjemalloc.so.0 becomes libjemalloc<suffix>.so.0.
 
+--with-malloc-conf=<malloc_conf>
+    Embed <malloc_conf> as a run-time options string that is processed prior to
+    the malloc_conf global variable, the /etc/malloc.conf symlink, and the
+    MALLOC_CONF environment variable.  For example, to change the default chunk
+    size to 256 KiB:
+
+      --with-malloc-conf=lg_chunk:18
+
 --disable-cc-silence
     Disable code that silences non-useful compiler warnings.  This is mainly
     useful during development when auditing the set of warnings that are being
     silenced.
 
 --enable-debug
@@ -191,12 +203,17 @@
     large allocations are page-aligned as an implementation artifact, which can
     severely harm CPU cache utilization.  However, the cache-oblivious layout
     comes at the cost of one extra page per large allocation, which in the
     most extreme case increases physical memory usage for the 16 KiB size class
     to 20 KiB.
 
+--disable-syscall
+    Disable use of syscall(2) rather than {open,read,write,close}(2).  This is
+    intended as a workaround for systems that place security limitations on
+    syscall(2).
+
 --with-xslroot=<path>
     Specify where to find DocBook XSL stylesheets when building the
     documentation.
 
 --with-lg-page=<lg-page>
     Specify the base 2 log of the system page size.  This option is only useful
@@ -312,12 +329,21 @@
 LDFLAGS="?"
     Pass these flags when linking.
 
 PATH="?"
     'configure' uses this to find programs.
 
+In some cases it may be necessary to work around configuration results that do
+not match reality.  For example, Linux 4.5 added support for the MADV_FREE flag
+to madvise(2), which can cause problems if building on a host with MADV_FREE
+support and deploying to a target without.  To work around this, use a cache
+file to override the relevant configuration variable defined in configure.ac,
+e.g.:
+
+    echo "je_cv_madv_free=no" > config.cache && ./configure -C
+
 === Advanced compilation =======================================================
 
 To build only parts of jemalloc, use the following targets:
 
     build_lib_shared
     build_lib_static
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc: install-sh
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/jemalloc.pc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/jemalloc.pc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/jemalloc.pc	2017-09-27 23:00:17.366936202 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/jemalloc.pc	2017-09-27 23:01:52.354932720 +0800
@@ -3,10 +3,10 @@
 libdir=${exec_prefix}/lib
 includedir=${prefix}/include
 install_suffix=
 
 Name: jemalloc
 Description: A general purpose malloc(3) implementation that emphasizes fragmentation avoidance and scalable concurrency support.
-URL: http://www.canonware.com/jemalloc
-Version: 4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c
+URL: http://jemalloc.net/
+Version: 4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc
 Cflags: -I${includedir}
 Libs: -L${libdir} -ljemalloc${install_suffix}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/jemalloc.pc.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/jemalloc.pc.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/jemalloc.pc.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/jemalloc.pc.in	2017-01-31 23:32:23.000000000 +0800
@@ -3,10 +3,10 @@
 libdir=@libdir@
 includedir=@includedir@
 install_suffix=@install_suffix@
 
 Name: jemalloc
 Description: A general purpose malloc(3) implementation that emphasizes fragmentation avoidance and scalable concurrency support.
-URL: http://www.canonware.com/jemalloc
+URL: http://jemalloc.net/
 Version: @jemalloc_version@
 Cflags: -I${includedir}
 Libs: -L${libdir} -ljemalloc${install_suffix}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/lib/libjemalloc.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/lib/libjemalloc.a differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/Makefile	2017-09-27 23:00:17.362936202 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/Makefile	2017-09-27 23:01:52.346932721 +0800
@@ -16,22 +16,22 @@
 INCLUDEDIR := $(DESTDIR)/usr/local/include
 LIBDIR := $(DESTDIR)/usr/local/lib
 DATADIR := $(DESTDIR)/usr/local/share
 MANDIR := $(DESTDIR)/usr/local/share/man
 srcroot := 
 objroot := 
-abs_srcroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/
-abs_objroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/
+abs_srcroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/
+abs_objroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/
 
 # Build parameters.
 CPPFLAGS :=  -D_GNU_SOURCE -D_REENTRANT -I$(srcroot)include -I$(objroot)include
-CFLAGS := -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden
+EXTRA_CFLAGS := 
+CFLAGS := -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden $(EXTRA_CFLAGS)
 LDFLAGS := 
 EXTRA_LDFLAGS := 
-LIBS :=  -lpthread
-TESTLIBS := 
+LIBS := -lm  -lpthread
 RPATH_EXTRA := 
 SO := so
 IMPORTLIB := so
 O := o
 A := a
 EXE := 
@@ -50,21 +50,25 @@
 enable_autogen := 0
 enable_code_coverage := 0
 enable_prof := 0
 enable_valgrind := 0
 enable_zone_allocator := 
 MALLOC_CONF := JE_MALLOC_CONF
+link_whole_archive := 0
 DSO_LDFLAGS = -shared -Wl,-soname,$(@F)
 SOREV = so.2
 PIC_CFLAGS = -fPIC -DPIC
 CTARGET = -o $@
 LDTARGET = -o $@
+TEST_LD_MODE = 
 MKLIB = 
 AR = ar
 ARFLAGS = crus
 CC_MM = 1
+LM := -lm
+INSTALL = /usr/bin/install -c
 
 ifeq (macho, $(ABI))
 TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH="$(objroot)lib"
 else
 ifeq (pecoff, $(ABI))
 TEST_LIBRARY_PATH := PATH="$(PATH):$(objroot)lib"
@@ -75,21 +79,40 @@
 
 LIBJEMALLOC := $(LIBPREFIX)jemalloc$(install_suffix)
 
 # Lists of files.
 BINS := $(objroot)bin/jemalloc-config $(objroot)bin/jemalloc.sh $(objroot)bin/jeprof
 C_HDRS := $(objroot)include/jemalloc/jemalloc$(install_suffix).h
-C_SRCS := $(srcroot)src/jemalloc.c $(srcroot)src/arena.c \
-	$(srcroot)src/atomic.c $(srcroot)src/base.c $(srcroot)src/bitmap.c \
-	$(srcroot)src/chunk.c $(srcroot)src/chunk_dss.c \
-	$(srcroot)src/chunk_mmap.c $(srcroot)src/ckh.c $(srcroot)src/ctl.c \
-	$(srcroot)src/extent.c $(srcroot)src/hash.c $(srcroot)src/huge.c \
-	$(srcroot)src/mb.c $(srcroot)src/mutex.c $(srcroot)src/pages.c \
-	$(srcroot)src/prof.c $(srcroot)src/quarantine.c $(srcroot)src/rtree.c \
-	$(srcroot)src/stats.c $(srcroot)src/tcache.c $(srcroot)src/util.c \
-	$(srcroot)src/tsd.c
+C_SRCS := $(srcroot)src/jemalloc.c \
+	$(srcroot)src/arena.c \
+	$(srcroot)src/atomic.c \
+	$(srcroot)src/base.c \
+	$(srcroot)src/bitmap.c \
+	$(srcroot)src/chunk.c \
+	$(srcroot)src/chunk_dss.c \
+	$(srcroot)src/chunk_mmap.c \
+	$(srcroot)src/ckh.c \
+	$(srcroot)src/ctl.c \
+	$(srcroot)src/extent.c \
+	$(srcroot)src/hash.c \
+	$(srcroot)src/huge.c \
+	$(srcroot)src/mb.c \
+	$(srcroot)src/mutex.c \
+	$(srcroot)src/nstime.c \
+	$(srcroot)src/pages.c \
+	$(srcroot)src/prng.c \
+	$(srcroot)src/prof.c \
+	$(srcroot)src/quarantine.c \
+	$(srcroot)src/rtree.c \
+	$(srcroot)src/stats.c \
+	$(srcroot)src/spin.c \
+	$(srcroot)src/tcache.c \
+	$(srcroot)src/ticker.c \
+	$(srcroot)src/tsd.c \
+	$(srcroot)src/util.c \
+	$(srcroot)src/witness.c
 ifeq ($(enable_valgrind), 1)
 C_SRCS += $(srcroot)src/valgrind.c
 endif
 ifeq ($(enable_zone_allocator), 1)
 C_SRCS += $(srcroot)src/zone.c
 endif
@@ -102,52 +125,75 @@
 STATIC_LIBS += $(objroot)lib/$(LIBJEMALLOC)_s.$(A)
 endif
 DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SOREV)
 ifneq ($(SOREV),$(SO))
 DSOS += $(objroot)lib/$(LIBJEMALLOC).$(SO)
 endif
+ifeq (1, $(link_whole_archive))
+LJEMALLOC := -Wl,--whole-archive -L$(objroot)lib -l$(LIBJEMALLOC) -Wl,--no-whole-archive
+else
+LJEMALLOC := $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
+endif
 PC := $(objroot)jemalloc.pc
 MAN3 := $(objroot)doc/jemalloc$(install_suffix).3
 DOCS_XML := $(objroot)doc/jemalloc$(install_suffix).xml
 DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(objroot)%.html)
 DOCS_MAN3 := $(DOCS_XML:$(objroot)%.xml=$(objroot)%.3)
 DOCS := $(DOCS_HTML) $(DOCS_MAN3)
 C_TESTLIB_SRCS := $(srcroot)test/src/btalloc.c $(srcroot)test/src/btalloc_0.c \
 	$(srcroot)test/src/btalloc_1.c $(srcroot)test/src/math.c \
 	$(srcroot)test/src/mtx.c $(srcroot)test/src/mq.c \
 	$(srcroot)test/src/SFMT.c $(srcroot)test/src/test.c \
 	$(srcroot)test/src/thd.c $(srcroot)test/src/timer.c
-C_UTIL_INTEGRATION_SRCS := $(srcroot)src/util.c
-TESTS_UNIT := $(srcroot)test/unit/atomic.c \
+ifeq (1, $(link_whole_archive))
+C_UTIL_INTEGRATION_SRCS :=
+else
+C_UTIL_INTEGRATION_SRCS := $(srcroot)src/nstime.c $(srcroot)src/util.c
+endif
+TESTS_UNIT := \
+	$(srcroot)test/unit/a0.c \
+	$(srcroot)test/unit/arena_reset.c \
+	$(srcroot)test/unit/atomic.c \
 	$(srcroot)test/unit/bitmap.c \
 	$(srcroot)test/unit/ckh.c \
+	$(srcroot)test/unit/decay.c \
+	$(srcroot)test/unit/fork.c \
 	$(srcroot)test/unit/hash.c \
 	$(srcroot)test/unit/junk.c \
 	$(srcroot)test/unit/junk_alloc.c \
 	$(srcroot)test/unit/junk_free.c \
 	$(srcroot)test/unit/lg_chunk.c \
 	$(srcroot)test/unit/mallctl.c \
 	$(srcroot)test/unit/math.c \
 	$(srcroot)test/unit/mq.c \
 	$(srcroot)test/unit/mtx.c \
+	$(srcroot)test/unit/pack.c \
+	$(srcroot)test/unit/pages.c \
+	$(srcroot)test/unit/ph.c \
+	$(srcroot)test/unit/prng.c \
 	$(srcroot)test/unit/prof_accum.c \
 	$(srcroot)test/unit/prof_active.c \
 	$(srcroot)test/unit/prof_gdump.c \
 	$(srcroot)test/unit/prof_idump.c \
 	$(srcroot)test/unit/prof_reset.c \
 	$(srcroot)test/unit/prof_thread_name.c \
 	$(srcroot)test/unit/ql.c \
 	$(srcroot)test/unit/qr.c \
 	$(srcroot)test/unit/quarantine.c \
 	$(srcroot)test/unit/rb.c \
 	$(srcroot)test/unit/rtree.c \
+	$(srcroot)test/unit/run_quantize.c \
 	$(srcroot)test/unit/SFMT.c \
 	$(srcroot)test/unit/size_classes.c \
+	$(srcroot)test/unit/smoothstep.c \
 	$(srcroot)test/unit/stats.c \
+	$(srcroot)test/unit/ticker.c \
+	$(srcroot)test/unit/nstime.c \
 	$(srcroot)test/unit/tsd.c \
 	$(srcroot)test/unit/util.c \
+	$(srcroot)test/unit/witness.c \
 	$(srcroot)test/unit/zero.c
 TESTS_INTEGRATION := $(srcroot)test/integration/aligned_alloc.c \
 	$(srcroot)test/integration/allocated.c \
 	$(srcroot)test/integration/sdallocx.c \
 	$(srcroot)test/integration/mallocx.c \
 	$(srcroot)test/integration/MALLOCX_ARENA.c \
@@ -263,75 +309,75 @@
 $(STATIC_LIBS):
 	@mkdir -p $(@D)
 	$(AR) $(ARFLAGS) $@ $+
 
 $(objroot)test/unit/%$(EXE): $(objroot)test/unit/%.$(O) $(TESTS_UNIT_LINK_OBJS) $(C_JET_OBJS) $(C_TESTLIB_UNIT_OBJS)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
+	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LDFLAGS) $(filter-out -lm,$(LIBS)) $(LM) $(EXTRA_LDFLAGS)
 
 $(objroot)test/integration/%$(EXE): $(objroot)test/integration/%.$(O) $(C_TESTLIB_INTEGRATION_OBJS) $(C_UTIL_INTEGRATION_OBJS) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(filter -lpthread,$(LIBS))) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
+	$(CC) $(TEST_LD_MODE) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LJEMALLOC) $(LDFLAGS) $(filter-out -lm,$(filter -lrt -lpthread,$(LIBS))) $(LM) $(EXTRA_LDFLAGS)
 
 $(objroot)test/stress/%$(EXE): $(objroot)test/stress/%.$(O) $(C_JET_OBJS) $(C_TESTLIB_STRESS_OBJS) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
+	$(CC) $(TEST_LD_MODE) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(LIBS)) $(LM) $(EXTRA_LDFLAGS)
 
 build_lib_shared: $(DSOS)
 build_lib_static: $(STATIC_LIBS)
 build_lib: build_lib_shared build_lib_static
 
 install_bin:
-	install -d $(BINDIR)
+	$(INSTALL) -d $(BINDIR)
 	@for b in $(BINS); do \
-	echo "install -m 755 $$b $(BINDIR)"; \
-	install -m 755 $$b $(BINDIR); \
+	echo "$(INSTALL) -m 755 $$b $(BINDIR)"; \
+	$(INSTALL) -m 755 $$b $(BINDIR); \
 done
 
 install_include:
-	install -d $(INCLUDEDIR)/jemalloc
+	$(INSTALL) -d $(INCLUDEDIR)/jemalloc
 	@for h in $(C_HDRS); do \
-	echo "install -m 644 $$h $(INCLUDEDIR)/jemalloc"; \
-	install -m 644 $$h $(INCLUDEDIR)/jemalloc; \
+	echo "$(INSTALL) -m 644 $$h $(INCLUDEDIR)/jemalloc"; \
+	$(INSTALL) -m 644 $$h $(INCLUDEDIR)/jemalloc; \
 done
 
 install_lib_shared: $(DSOS)
-	install -d $(LIBDIR)
-	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SOREV) $(LIBDIR)
+	$(INSTALL) -d $(LIBDIR)
+	$(INSTALL) -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SOREV) $(LIBDIR)
 ifneq ($(SOREV),$(SO))
 	ln -sf $(LIBJEMALLOC).$(SOREV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
 endif
 
 install_lib_static: $(STATIC_LIBS)
-	install -d $(LIBDIR)
+	$(INSTALL) -d $(LIBDIR)
 	@for l in $(STATIC_LIBS); do \
-	echo "install -m 755 $$l $(LIBDIR)"; \
-	install -m 755 $$l $(LIBDIR); \
+	echo "$(INSTALL) -m 755 $$l $(LIBDIR)"; \
+	$(INSTALL) -m 755 $$l $(LIBDIR); \
 done
 
 install_lib_pc: $(PC)
-	install -d $(LIBDIR)/pkgconfig
+	$(INSTALL) -d $(LIBDIR)/pkgconfig
 	@for l in $(PC); do \
-	echo "install -m 644 $$l $(LIBDIR)/pkgconfig"; \
-	install -m 644 $$l $(LIBDIR)/pkgconfig; \
+	echo "$(INSTALL) -m 644 $$l $(LIBDIR)/pkgconfig"; \
+	$(INSTALL) -m 644 $$l $(LIBDIR)/pkgconfig; \
 done
 
 install_lib: install_lib_shared install_lib_static install_lib_pc
 
 install_doc_html:
-	install -d $(DATADIR)/doc/jemalloc$(install_suffix)
+	$(INSTALL) -d $(DATADIR)/doc/jemalloc$(install_suffix)
 	@for d in $(DOCS_HTML); do \
-	echo "install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix)"; \
-	install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix); \
+	echo "$(INSTALL) -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix)"; \
+	$(INSTALL) -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix); \
 done
 
 install_doc_man:
-	install -d $(MANDIR)/man3
+	$(INSTALL) -d $(MANDIR)/man3
 	@for d in $(DOCS_MAN3); do \
-	echo "install -m 644 $$d $(MANDIR)/man3"; \
-	install -m 644 $$d $(MANDIR)/man3; \
+	echo "$(INSTALL) -m 644 $$d $(MANDIR)/man3"; \
+	$(INSTALL) -m 644 $$d $(MANDIR)/man3; \
 done
 
 install_doc: install_doc_html install_doc_man
 
 install: install_bin install_include install_lib install_doc
 
@@ -346,24 +392,28 @@
 	@mkdir -p $(objroot)test/integration
 stress_dir:
 	@mkdir -p $(objroot)test/stress
 check_dir: check_unit_dir check_integration_dir
 
 check_unit: tests_unit check_unit_dir
-	$(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="purge:ratio" $(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="purge:decay" $(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%)
 check_integration_prof: tests_integration check_integration_dir
 ifeq ($(enable_prof), 1)
 	$(MALLOC_CONF)="prof:true" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 	$(MALLOC_CONF)="prof:true,prof_active:false" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 endif
+check_integration_decay: tests_integration check_integration_dir
+	$(MALLOC_CONF)="purge:decay,decay_time:-1" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="purge:decay,decay_time:0" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="purge:decay" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 check_integration: tests_integration check_integration_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 stress: tests_stress stress_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_STRESS:$(srcroot)%.c=$(objroot)%)
-check: tests check_dir check_integration_prof
-	$(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%) $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+check: check_unit check_integration check_integration_decay check_integration_prof
 
 ifeq ($(enable_code_coverage), 1)
 coverage_unit: check_unit
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src jet $(C_JET_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/src unit $(C_TESTLIB_UNIT_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/unit unit $(TESTS_UNIT_OBJS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/Makefile.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/Makefile.in	2017-01-31 23:32:23.000000000 +0800
@@ -21,17 +21,17 @@
 objroot := @objroot@
 abs_srcroot := @abs_srcroot@
 abs_objroot := @abs_objroot@
 
 # Build parameters.
 CPPFLAGS := @CPPFLAGS@ -I$(srcroot)include -I$(objroot)include
-CFLAGS := @CFLAGS@
+EXTRA_CFLAGS := @EXTRA_CFLAGS@
+CFLAGS := @CFLAGS@ $(EXTRA_CFLAGS)
 LDFLAGS := @LDFLAGS@
 EXTRA_LDFLAGS := @EXTRA_LDFLAGS@
 LIBS := @LIBS@
-TESTLIBS := @TESTLIBS@
 RPATH_EXTRA := @RPATH_EXTRA@
 SO := @so@
 IMPORTLIB := @importlib@
 O := @o@
 A := @a@
 EXE := @exe@
@@ -50,21 +50,25 @@
 enable_autogen := @enable_autogen@
 enable_code_coverage := @enable_code_coverage@
 enable_prof := @enable_prof@
 enable_valgrind := @enable_valgrind@
 enable_zone_allocator := @enable_zone_allocator@
 MALLOC_CONF := @JEMALLOC_CPREFIX@MALLOC_CONF
+link_whole_archive := @link_whole_archive@
 DSO_LDFLAGS = @DSO_LDFLAGS@
 SOREV = @SOREV@
 PIC_CFLAGS = @PIC_CFLAGS@
 CTARGET = @CTARGET@
 LDTARGET = @LDTARGET@
+TEST_LD_MODE = @TEST_LD_MODE@
 MKLIB = @MKLIB@
 AR = @AR@
 ARFLAGS = @ARFLAGS@
 CC_MM = @CC_MM@
+LM := @LM@
+INSTALL = @INSTALL@
 
 ifeq (macho, $(ABI))
 TEST_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH="$(objroot)lib"
 else
 ifeq (pecoff, $(ABI))
 TEST_LIBRARY_PATH := PATH="$(PATH):$(objroot)lib"
@@ -75,21 +79,40 @@
 
 LIBJEMALLOC := $(LIBPREFIX)jemalloc$(install_suffix)
 
 # Lists of files.
 BINS := $(objroot)bin/jemalloc-config $(objroot)bin/jemalloc.sh $(objroot)bin/jeprof
 C_HDRS := $(objroot)include/jemalloc/jemalloc$(install_suffix).h
-C_SRCS := $(srcroot)src/jemalloc.c $(srcroot)src/arena.c \
-	$(srcroot)src/atomic.c $(srcroot)src/base.c $(srcroot)src/bitmap.c \
-	$(srcroot)src/chunk.c $(srcroot)src/chunk_dss.c \
-	$(srcroot)src/chunk_mmap.c $(srcroot)src/ckh.c $(srcroot)src/ctl.c \
-	$(srcroot)src/extent.c $(srcroot)src/hash.c $(srcroot)src/huge.c \
-	$(srcroot)src/mb.c $(srcroot)src/mutex.c $(srcroot)src/pages.c \
-	$(srcroot)src/prof.c $(srcroot)src/quarantine.c $(srcroot)src/rtree.c \
-	$(srcroot)src/stats.c $(srcroot)src/tcache.c $(srcroot)src/util.c \
-	$(srcroot)src/tsd.c
+C_SRCS := $(srcroot)src/jemalloc.c \
+	$(srcroot)src/arena.c \
+	$(srcroot)src/atomic.c \
+	$(srcroot)src/base.c \
+	$(srcroot)src/bitmap.c \
+	$(srcroot)src/chunk.c \
+	$(srcroot)src/chunk_dss.c \
+	$(srcroot)src/chunk_mmap.c \
+	$(srcroot)src/ckh.c \
+	$(srcroot)src/ctl.c \
+	$(srcroot)src/extent.c \
+	$(srcroot)src/hash.c \
+	$(srcroot)src/huge.c \
+	$(srcroot)src/mb.c \
+	$(srcroot)src/mutex.c \
+	$(srcroot)src/nstime.c \
+	$(srcroot)src/pages.c \
+	$(srcroot)src/prng.c \
+	$(srcroot)src/prof.c \
+	$(srcroot)src/quarantine.c \
+	$(srcroot)src/rtree.c \
+	$(srcroot)src/stats.c \
+	$(srcroot)src/spin.c \
+	$(srcroot)src/tcache.c \
+	$(srcroot)src/ticker.c \
+	$(srcroot)src/tsd.c \
+	$(srcroot)src/util.c \
+	$(srcroot)src/witness.c
 ifeq ($(enable_valgrind), 1)
 C_SRCS += $(srcroot)src/valgrind.c
 endif
 ifeq ($(enable_zone_allocator), 1)
 C_SRCS += $(srcroot)src/zone.c
 endif
@@ -102,52 +125,75 @@
 STATIC_LIBS += $(objroot)lib/$(LIBJEMALLOC)_s.$(A)
 endif
 DSOS := $(objroot)lib/$(LIBJEMALLOC).$(SOREV)
 ifneq ($(SOREV),$(SO))
 DSOS += $(objroot)lib/$(LIBJEMALLOC).$(SO)
 endif
+ifeq (1, $(link_whole_archive))
+LJEMALLOC := -Wl,--whole-archive -L$(objroot)lib -l$(LIBJEMALLOC) -Wl,--no-whole-archive
+else
+LJEMALLOC := $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
+endif
 PC := $(objroot)jemalloc.pc
 MAN3 := $(objroot)doc/jemalloc$(install_suffix).3
 DOCS_XML := $(objroot)doc/jemalloc$(install_suffix).xml
 DOCS_HTML := $(DOCS_XML:$(objroot)%.xml=$(objroot)%.html)
 DOCS_MAN3 := $(DOCS_XML:$(objroot)%.xml=$(objroot)%.3)
 DOCS := $(DOCS_HTML) $(DOCS_MAN3)
 C_TESTLIB_SRCS := $(srcroot)test/src/btalloc.c $(srcroot)test/src/btalloc_0.c \
 	$(srcroot)test/src/btalloc_1.c $(srcroot)test/src/math.c \
 	$(srcroot)test/src/mtx.c $(srcroot)test/src/mq.c \
 	$(srcroot)test/src/SFMT.c $(srcroot)test/src/test.c \
 	$(srcroot)test/src/thd.c $(srcroot)test/src/timer.c
-C_UTIL_INTEGRATION_SRCS := $(srcroot)src/util.c
-TESTS_UNIT := $(srcroot)test/unit/atomic.c \
+ifeq (1, $(link_whole_archive))
+C_UTIL_INTEGRATION_SRCS :=
+else
+C_UTIL_INTEGRATION_SRCS := $(srcroot)src/nstime.c $(srcroot)src/util.c
+endif
+TESTS_UNIT := \
+	$(srcroot)test/unit/a0.c \
+	$(srcroot)test/unit/arena_reset.c \
+	$(srcroot)test/unit/atomic.c \
 	$(srcroot)test/unit/bitmap.c \
 	$(srcroot)test/unit/ckh.c \
+	$(srcroot)test/unit/decay.c \
+	$(srcroot)test/unit/fork.c \
 	$(srcroot)test/unit/hash.c \
 	$(srcroot)test/unit/junk.c \
 	$(srcroot)test/unit/junk_alloc.c \
 	$(srcroot)test/unit/junk_free.c \
 	$(srcroot)test/unit/lg_chunk.c \
 	$(srcroot)test/unit/mallctl.c \
 	$(srcroot)test/unit/math.c \
 	$(srcroot)test/unit/mq.c \
 	$(srcroot)test/unit/mtx.c \
+	$(srcroot)test/unit/pack.c \
+	$(srcroot)test/unit/pages.c \
+	$(srcroot)test/unit/ph.c \
+	$(srcroot)test/unit/prng.c \
 	$(srcroot)test/unit/prof_accum.c \
 	$(srcroot)test/unit/prof_active.c \
 	$(srcroot)test/unit/prof_gdump.c \
 	$(srcroot)test/unit/prof_idump.c \
 	$(srcroot)test/unit/prof_reset.c \
 	$(srcroot)test/unit/prof_thread_name.c \
 	$(srcroot)test/unit/ql.c \
 	$(srcroot)test/unit/qr.c \
 	$(srcroot)test/unit/quarantine.c \
 	$(srcroot)test/unit/rb.c \
 	$(srcroot)test/unit/rtree.c \
+	$(srcroot)test/unit/run_quantize.c \
 	$(srcroot)test/unit/SFMT.c \
 	$(srcroot)test/unit/size_classes.c \
+	$(srcroot)test/unit/smoothstep.c \
 	$(srcroot)test/unit/stats.c \
+	$(srcroot)test/unit/ticker.c \
+	$(srcroot)test/unit/nstime.c \
 	$(srcroot)test/unit/tsd.c \
 	$(srcroot)test/unit/util.c \
+	$(srcroot)test/unit/witness.c \
 	$(srcroot)test/unit/zero.c
 TESTS_INTEGRATION := $(srcroot)test/integration/aligned_alloc.c \
 	$(srcroot)test/integration/allocated.c \
 	$(srcroot)test/integration/sdallocx.c \
 	$(srcroot)test/integration/mallocx.c \
 	$(srcroot)test/integration/MALLOCX_ARENA.c \
@@ -263,75 +309,75 @@
 $(STATIC_LIBS):
 	@mkdir -p $(@D)
 	$(AR) $(ARFLAGS)@AROUT@ $+
 
 $(objroot)test/unit/%$(EXE): $(objroot)test/unit/%.$(O) $(TESTS_UNIT_LINK_OBJS) $(C_JET_OBJS) $(C_TESTLIB_UNIT_OBJS)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
+	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LDFLAGS) $(filter-out -lm,$(LIBS)) $(LM) $(EXTRA_LDFLAGS)
 
 $(objroot)test/integration/%$(EXE): $(objroot)test/integration/%.$(O) $(C_TESTLIB_INTEGRATION_OBJS) $(C_UTIL_INTEGRATION_OBJS) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(filter -lpthread,$(LIBS))) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
+	$(CC) $(TEST_LD_MODE) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(LJEMALLOC) $(LDFLAGS) $(filter-out -lm,$(filter -lrt -lpthread,$(LIBS))) $(LM) $(EXTRA_LDFLAGS)
 
 $(objroot)test/stress/%$(EXE): $(objroot)test/stress/%.$(O) $(C_JET_OBJS) $(C_TESTLIB_STRESS_OBJS) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB)
 	@mkdir -p $(@D)
-	$(CC) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(LIBS)) -lm $(TESTLIBS) $(EXTRA_LDFLAGS)
+	$(CC) $(TEST_LD_MODE) $(LDTARGET) $(filter %.$(O),$^) $(call RPATH,$(objroot)lib) $(objroot)lib/$(LIBJEMALLOC).$(IMPORTLIB) $(LDFLAGS) $(filter-out -lm,$(LIBS)) $(LM) $(EXTRA_LDFLAGS)
 
 build_lib_shared: $(DSOS)
 build_lib_static: $(STATIC_LIBS)
 build_lib: build_lib_shared build_lib_static
 
 install_bin:
-	install -d $(BINDIR)
+	$(INSTALL) -d $(BINDIR)
 	@for b in $(BINS); do \
-	echo "install -m 755 $$b $(BINDIR)"; \
-	install -m 755 $$b $(BINDIR); \
+	echo "$(INSTALL) -m 755 $$b $(BINDIR)"; \
+	$(INSTALL) -m 755 $$b $(BINDIR); \
 done
 
 install_include:
-	install -d $(INCLUDEDIR)/jemalloc
+	$(INSTALL) -d $(INCLUDEDIR)/jemalloc
 	@for h in $(C_HDRS); do \
-	echo "install -m 644 $$h $(INCLUDEDIR)/jemalloc"; \
-	install -m 644 $$h $(INCLUDEDIR)/jemalloc; \
+	echo "$(INSTALL) -m 644 $$h $(INCLUDEDIR)/jemalloc"; \
+	$(INSTALL) -m 644 $$h $(INCLUDEDIR)/jemalloc; \
 done
 
 install_lib_shared: $(DSOS)
-	install -d $(LIBDIR)
-	install -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SOREV) $(LIBDIR)
+	$(INSTALL) -d $(LIBDIR)
+	$(INSTALL) -m 755 $(objroot)lib/$(LIBJEMALLOC).$(SOREV) $(LIBDIR)
 ifneq ($(SOREV),$(SO))
 	ln -sf $(LIBJEMALLOC).$(SOREV) $(LIBDIR)/$(LIBJEMALLOC).$(SO)
 endif
 
 install_lib_static: $(STATIC_LIBS)
-	install -d $(LIBDIR)
+	$(INSTALL) -d $(LIBDIR)
 	@for l in $(STATIC_LIBS); do \
-	echo "install -m 755 $$l $(LIBDIR)"; \
-	install -m 755 $$l $(LIBDIR); \
+	echo "$(INSTALL) -m 755 $$l $(LIBDIR)"; \
+	$(INSTALL) -m 755 $$l $(LIBDIR); \
 done
 
 install_lib_pc: $(PC)
-	install -d $(LIBDIR)/pkgconfig
+	$(INSTALL) -d $(LIBDIR)/pkgconfig
 	@for l in $(PC); do \
-	echo "install -m 644 $$l $(LIBDIR)/pkgconfig"; \
-	install -m 644 $$l $(LIBDIR)/pkgconfig; \
+	echo "$(INSTALL) -m 644 $$l $(LIBDIR)/pkgconfig"; \
+	$(INSTALL) -m 644 $$l $(LIBDIR)/pkgconfig; \
 done
 
 install_lib: install_lib_shared install_lib_static install_lib_pc
 
 install_doc_html:
-	install -d $(DATADIR)/doc/jemalloc$(install_suffix)
+	$(INSTALL) -d $(DATADIR)/doc/jemalloc$(install_suffix)
 	@for d in $(DOCS_HTML); do \
-	echo "install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix)"; \
-	install -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix); \
+	echo "$(INSTALL) -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix)"; \
+	$(INSTALL) -m 644 $$d $(DATADIR)/doc/jemalloc$(install_suffix); \
 done
 
 install_doc_man:
-	install -d $(MANDIR)/man3
+	$(INSTALL) -d $(MANDIR)/man3
 	@for d in $(DOCS_MAN3); do \
-	echo "install -m 644 $$d $(MANDIR)/man3"; \
-	install -m 644 $$d $(MANDIR)/man3; \
+	echo "$(INSTALL) -m 644 $$d $(MANDIR)/man3"; \
+	$(INSTALL) -m 644 $$d $(MANDIR)/man3; \
 done
 
 install_doc: install_doc_html install_doc_man
 
 install: install_bin install_include install_lib install_doc
 
@@ -346,24 +392,28 @@
 	@mkdir -p $(objroot)test/integration
 stress_dir:
 	@mkdir -p $(objroot)test/stress
 check_dir: check_unit_dir check_integration_dir
 
 check_unit: tests_unit check_unit_dir
-	$(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="purge:ratio" $(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="purge:decay" $(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%)
 check_integration_prof: tests_integration check_integration_dir
 ifeq ($(enable_prof), 1)
 	$(MALLOC_CONF)="prof:true" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 	$(MALLOC_CONF)="prof:true,prof_active:false" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 endif
+check_integration_decay: tests_integration check_integration_dir
+	$(MALLOC_CONF)="purge:decay,decay_time:-1" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="purge:decay,decay_time:0" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+	$(MALLOC_CONF)="purge:decay" $(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 check_integration: tests_integration check_integration_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
 stress: tests_stress stress_dir
 	$(SHELL) $(objroot)test/test.sh $(TESTS_STRESS:$(srcroot)%.c=$(objroot)%)
-check: tests check_dir check_integration_prof
-	$(SHELL) $(objroot)test/test.sh $(TESTS_UNIT:$(srcroot)%.c=$(objroot)%) $(TESTS_INTEGRATION:$(srcroot)%.c=$(objroot)%)
+check: check_unit check_integration check_integration_decay check_integration_prof
 
 ifeq ($(enable_code_coverage), 1)
 coverage_unit: check_unit
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)src jet $(C_JET_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/src unit $(C_TESTLIB_UNIT_OBJS)
 	$(SHELL) $(srcroot)coverage.sh $(srcroot)test/unit unit $(TESTS_UNIT_OBJS)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc: msvc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/README	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/README	2017-01-31 23:32:23.000000000 +0800
@@ -14,7 +14,7 @@
 
 The INSTALL file contains information on how to configure, build, and install
 jemalloc.
 
 The ChangeLog file contains a brief summary of changes for each release.
 
-URL: http://www.canonware.com/jemalloc/
+URL: http://jemalloc.net/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,237 +1,224 @@
 #define	JEMALLOC_ARENA_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 /* Data. */
 
+purge_mode_t	opt_purge = PURGE_DEFAULT;
+const char	*purge_mode_names[] = {
+	"ratio",
+	"decay",
+	"N/A"
+};
 ssize_t		opt_lg_dirty_mult = LG_DIRTY_MULT_DEFAULT;
 static ssize_t	lg_dirty_mult_default;
+ssize_t		opt_decay_time = DECAY_TIME_DEFAULT;
+static ssize_t	decay_time_default;
+
 arena_bin_info_t	arena_bin_info[NBINS];
 
 size_t		map_bias;
 size_t		map_misc_offset;
 size_t		arena_maxrun; /* Max run size for arenas. */
 size_t		large_maxclass; /* Max large size class. */
-static size_t	small_maxrun; /* Max run size used for small size classes. */
-static bool	*small_run_tab; /* Valid small run page multiples. */
 unsigned	nlclasses; /* Number of large size classes. */
 unsigned	nhclasses; /* Number of huge size classes. */
 
 /******************************************************************************/
 /*
  * Function prototypes for static functions that are referenced prior to
  * definition.
  */
 
-static void	arena_purge(arena_t *arena, bool all);
-static void	arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty,
-    bool cleaned, bool decommitted);
-static void	arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk,
-    arena_run_t *run, arena_bin_t *bin);
-static void	arena_bin_lower_run(arena_t *arena, arena_chunk_t *chunk,
-    arena_run_t *run, arena_bin_t *bin);
+static void	arena_chunk_dalloc(tsdn_t *tsdn, arena_t *arena,
+    arena_chunk_t *chunk);
+static void	arena_purge_to_limit(tsdn_t *tsdn, arena_t *arena,
+    size_t ndirty_limit);
+static void	arena_run_dalloc(tsdn_t *tsdn, arena_t *arena, arena_run_t *run,
+    bool dirty, bool cleaned, bool decommitted);
+static void	arena_dalloc_bin_run(tsdn_t *tsdn, arena_t *arena,
+    arena_chunk_t *chunk, arena_run_t *run, arena_bin_t *bin);
+static void	arena_bin_lower_run(arena_t *arena, arena_run_t *run,
+    arena_bin_t *bin);
 
 /******************************************************************************/
 
-#define	CHUNK_MAP_KEY		((uintptr_t)0x1U)
-
-JEMALLOC_INLINE_C arena_chunk_map_misc_t *
-arena_miscelm_key_create(size_t size)
+JEMALLOC_INLINE_C size_t
+arena_miscelm_size_get(const arena_chunk_map_misc_t *miscelm)
 {
+	arena_chunk_t *chunk;
+	size_t pageind, mapbits;
 
-	return ((arena_chunk_map_misc_t *)(arena_mapbits_size_encode(size) |
-	    CHUNK_MAP_KEY));
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(miscelm);
+	pageind = arena_miscelm_to_pageind(miscelm);
+	mapbits = arena_mapbits_get(chunk, pageind);
+	return (arena_mapbits_size_decode(mapbits));
 }
 
-JEMALLOC_INLINE_C bool
-arena_miscelm_is_key(const arena_chunk_map_misc_t *miscelm)
+JEMALLOC_INLINE_C const extent_node_t *
+arena_miscelm_extent_get(const arena_chunk_map_misc_t *miscelm)
 {
+	arena_chunk_t *chunk;
 
-	return (((uintptr_t)miscelm & CHUNK_MAP_KEY) != 0);
+	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(miscelm);
+	return (&chunk->node);
 }
 
-#undef CHUNK_MAP_KEY
-
-JEMALLOC_INLINE_C size_t
-arena_miscelm_key_size_get(const arena_chunk_map_misc_t *miscelm)
+JEMALLOC_INLINE_C int
+arena_sn_comp(const arena_chunk_map_misc_t *a, const arena_chunk_map_misc_t *b)
 {
+	size_t a_sn, b_sn;
 
-	assert(arena_miscelm_is_key(miscelm));
-
-	return (arena_mapbits_size_decode((uintptr_t)miscelm));
-}
-
-JEMALLOC_INLINE_C size_t
-arena_miscelm_size_get(arena_chunk_map_misc_t *miscelm)
-{
-	arena_chunk_t *chunk;
-	size_t pageind, mapbits;
+	assert(a != NULL);
+	assert(b != NULL);
 
-	assert(!arena_miscelm_is_key(miscelm));
+	a_sn = extent_node_sn_get(arena_miscelm_extent_get(a));
+	b_sn = extent_node_sn_get(arena_miscelm_extent_get(b));
 
-	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(miscelm);
-	pageind = arena_miscelm_to_pageind(miscelm);
-	mapbits = arena_mapbits_get(chunk, pageind);
-	return (arena_mapbits_size_decode(mapbits));
+	return ((a_sn > b_sn) - (a_sn < b_sn));
 }
 
 JEMALLOC_INLINE_C int
-arena_run_comp(arena_chunk_map_misc_t *a, arena_chunk_map_misc_t *b)
+arena_ad_comp(const arena_chunk_map_misc_t *a,
+    const arena_chunk_map_misc_t *b)
 {
 	uintptr_t a_miscelm = (uintptr_t)a;
 	uintptr_t b_miscelm = (uintptr_t)b;
 
 	assert(a != NULL);
 	assert(b != NULL);
 
 	return ((a_miscelm > b_miscelm) - (a_miscelm < b_miscelm));
 }
 
-/* Generate red-black tree functions. */
-rb_gen(static UNUSED, arena_run_tree_, arena_run_tree_t, arena_chunk_map_misc_t,
-    rb_link, arena_run_comp)
-
-static size_t
-run_quantize(size_t size)
+JEMALLOC_INLINE_C int
+arena_snad_comp(const arena_chunk_map_misc_t *a,
+    const arena_chunk_map_misc_t *b)
 {
-	size_t qsize;
+	int ret;
 
-	assert(size != 0);
-	assert(size == PAGE_CEILING(size));
+	assert(a != NULL);
+	assert(b != NULL);
 
-	/* Don't change sizes that are valid small run sizes. */
-	if (size <= small_maxrun && small_run_tab[size >> LG_PAGE])
-		return (size);
+	ret = arena_sn_comp(a, b);
+	if (ret != 0)
+		return (ret);
 
-	/*
-	 * Round down to the nearest run size that can actually be requested
-	 * during normal large allocation.  Add large_pad so that cache index
-	 * randomization can offset the allocation from the page boundary.
-	 */
-	qsize = index2size(size2index(size - large_pad + 1) - 1) + large_pad;
-	if (qsize <= SMALL_MAXCLASS + large_pad)
-		return (run_quantize(size - large_pad));
-	assert(qsize <= size);
-	return (qsize);
+	ret = arena_ad_comp(a, b);
+	return (ret);
 }
 
+/* Generate pairing heap functions. */
+ph_gen(static UNUSED, arena_run_heap_, arena_run_heap_t, arena_chunk_map_misc_t,
+    ph_link, arena_snad_comp)
+
+#ifdef JEMALLOC_JET
+#undef run_quantize_floor
+#define	run_quantize_floor JEMALLOC_N(n_run_quantize_floor)
+#endif
 static size_t
-run_quantize_next(size_t size)
+run_quantize_floor(size_t size)
 {
-	size_t large_run_size_next;
+	size_t ret;
+	pszind_t pind;
+
+	assert(size > 0);
+	assert(size <= HUGE_MAXCLASS);
+	assert((size & PAGE_MASK) == 0);
 
 	assert(size != 0);
 	assert(size == PAGE_CEILING(size));
 
-	/*
-	 * Return the next quantized size greater than the input size.
-	 * Quantized sizes comprise the union of run sizes that back small
-	 * region runs, and run sizes that back large regions with no explicit
-	 * alignment constraints.
-	 */
-
-	if (size > SMALL_MAXCLASS) {
-		large_run_size_next = PAGE_CEILING(index2size(size2index(size -
-		    large_pad) + 1) + large_pad);
-	} else
-		large_run_size_next = SIZE_T_MAX;
-	if (size >= small_maxrun)
-		return (large_run_size_next);
-
-	while (true) {
-		size += PAGE;
-		assert(size <= small_maxrun);
-		if (small_run_tab[size >> LG_PAGE]) {
-			if (large_run_size_next < size)
-				return (large_run_size_next);
-			return (size);
-		}
+	pind = psz2ind(size - large_pad + 1);
+	if (pind == 0) {
+		/*
+		 * Avoid underflow.  This short-circuit would also do the right
+		 * thing for all sizes in the range for which there are
+		 * PAGE-spaced size classes, but it's simplest to just handle
+		 * the one case that would cause erroneous results.
+		 */
+		return (size);
 	}
+	ret = pind2sz(pind - 1) + large_pad;
+	assert(ret <= size);
+	return (ret);
 }
+#ifdef JEMALLOC_JET
+#undef run_quantize_floor
+#define	run_quantize_floor JEMALLOC_N(run_quantize_floor)
+run_quantize_t *run_quantize_floor = JEMALLOC_N(n_run_quantize_floor);
+#endif
 
+#ifdef JEMALLOC_JET
+#undef run_quantize_ceil
+#define	run_quantize_ceil JEMALLOC_N(n_run_quantize_ceil)
+#endif
 static size_t
-run_quantize_first(size_t size)
+run_quantize_ceil(size_t size)
 {
-	size_t qsize = run_quantize(size);
+	size_t ret;
+
+	assert(size > 0);
+	assert(size <= HUGE_MAXCLASS);
+	assert((size & PAGE_MASK) == 0);
 
-	if (qsize < size) {
+	ret = run_quantize_floor(size);
+	if (ret < size) {
 		/*
 		 * Skip a quantization that may have an adequately large run,
 		 * because under-sized runs may be mixed in.  This only happens
 		 * when an unusual size is requested, i.e. for aligned
 		 * allocation, and is just one of several places where linear
 		 * search would potentially find sufficiently aligned available
 		 * memory somewhere lower.
 		 */
-		qsize = run_quantize_next(size);
+		ret = pind2sz(psz2ind(ret - large_pad + 1)) + large_pad;
 	}
-	return (qsize);
-}
-
-JEMALLOC_INLINE_C int
-arena_avail_comp(arena_chunk_map_misc_t *a, arena_chunk_map_misc_t *b)
-{
-	int ret;
-	uintptr_t a_miscelm = (uintptr_t)a;
-	size_t a_qsize = run_quantize(arena_miscelm_is_key(a) ?
-	    arena_miscelm_key_size_get(a) : arena_miscelm_size_get(a));
-	size_t b_qsize = run_quantize(arena_miscelm_size_get(b));
-
-	/*
-	 * Compare based on quantized size rather than size, in order to sort
-	 * equally useful runs only by address.
-	 */
-	ret = (a_qsize > b_qsize) - (a_qsize < b_qsize);
-	if (ret == 0) {
-		if (!arena_miscelm_is_key(a)) {
-			uintptr_t b_miscelm = (uintptr_t)b;
-
-			ret = (a_miscelm > b_miscelm) - (a_miscelm < b_miscelm);
-		} else {
-			/*
-			 * Treat keys as if they are lower than anything else.
-			 */
-			ret = -1;
-		}
-	}
-
 	return (ret);
 }
-
-/* Generate red-black tree functions. */
-rb_gen(static UNUSED, arena_avail_tree_, arena_avail_tree_t,
-    arena_chunk_map_misc_t, rb_link, arena_avail_comp)
+#ifdef JEMALLOC_JET
+#undef run_quantize_ceil
+#define	run_quantize_ceil JEMALLOC_N(run_quantize_ceil)
+run_quantize_t *run_quantize_ceil = JEMALLOC_N(n_run_quantize_ceil);
+#endif
 
 static void
 arena_avail_insert(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
     size_t npages)
 {
-
+	pszind_t pind = psz2ind(run_quantize_floor(arena_miscelm_size_get(
+	    arena_miscelm_get_const(chunk, pageind))));
 	assert(npages == (arena_mapbits_unallocated_size_get(chunk, pageind) >>
 	    LG_PAGE));
-	arena_avail_tree_insert(&arena->runs_avail, arena_miscelm_get(chunk,
-	    pageind));
+	assert((npages << LG_PAGE) < chunksize);
+	assert(pind2sz(pind) <= chunksize);
+	arena_run_heap_insert(&arena->runs_avail[pind],
+	    arena_miscelm_get_mutable(chunk, pageind));
 }
 
 static void
 arena_avail_remove(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
     size_t npages)
 {
-
+	pszind_t pind = psz2ind(run_quantize_floor(arena_miscelm_size_get(
+	    arena_miscelm_get_const(chunk, pageind))));
 	assert(npages == (arena_mapbits_unallocated_size_get(chunk, pageind) >>
 	    LG_PAGE));
-	arena_avail_tree_remove(&arena->runs_avail, arena_miscelm_get(chunk,
-	    pageind));
+	assert((npages << LG_PAGE) < chunksize);
+	assert(pind2sz(pind) <= chunksize);
+	arena_run_heap_remove(&arena->runs_avail[pind],
+	    arena_miscelm_get_mutable(chunk, pageind));
 }
 
 static void
 arena_run_dirty_insert(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
     size_t npages)
 {
-	arena_chunk_map_misc_t *miscelm = arena_miscelm_get(chunk, pageind);
+	arena_chunk_map_misc_t *miscelm = arena_miscelm_get_mutable(chunk,
+	    pageind);
 
 	assert(npages == (arena_mapbits_unallocated_size_get(chunk, pageind) >>
 	    LG_PAGE));
 	assert(arena_mapbits_dirty_get(chunk, pageind) == CHUNK_MAP_DIRTY);
 	assert(arena_mapbits_dirty_get(chunk, pageind+npages-1) ==
 	    CHUNK_MAP_DIRTY);
@@ -242,13 +229,14 @@
 }
 
 static void
 arena_run_dirty_remove(arena_t *arena, arena_chunk_t *chunk, size_t pageind,
     size_t npages)
 {
-	arena_chunk_map_misc_t *miscelm = arena_miscelm_get(chunk, pageind);
+	arena_chunk_map_misc_t *miscelm = arena_miscelm_get_mutable(chunk,
+	    pageind);
 
 	assert(npages == (arena_mapbits_unallocated_size_get(chunk, pageind) >>
 	    LG_PAGE));
 	assert(arena_mapbits_dirty_get(chunk, pageind) == CHUNK_MAP_DIRTY);
 	assert(arena_mapbits_dirty_get(chunk, pageind+npages-1) ==
 	    CHUNK_MAP_DIRTY);
@@ -289,20 +277,20 @@
 }
 
 JEMALLOC_INLINE_C void *
 arena_run_reg_alloc(arena_run_t *run, arena_bin_info_t *bin_info)
 {
 	void *ret;
-	unsigned regind;
+	size_t regind;
 	arena_chunk_map_misc_t *miscelm;
 	void *rpages;
 
 	assert(run->nfree > 0);
 	assert(!bitmap_full(run->bitmap, &bin_info->bitmap_info));
 
-	regind = bitmap_sfu(run->bitmap, &bin_info->bitmap_info);
+	regind = (unsigned)bitmap_sfu(run->bitmap, &bin_info->bitmap_info);
 	miscelm = arena_run_to_miscelm(run);
 	rpages = arena_miscelm_to_rpages(miscelm);
 	ret = (void *)((uintptr_t)rpages + (uintptr_t)bin_info->reg0_offset +
 	    (uintptr_t)(bin_info->reg_interval * regind));
 	run->nfree--;
 	return (ret);
@@ -313,13 +301,13 @@
 {
 	arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
 	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 	size_t mapbits = arena_mapbits_get(chunk, pageind);
 	szind_t binind = arena_ptr_small_binind_get(ptr, mapbits);
 	arena_bin_info_t *bin_info = &arena_bin_info[binind];
-	unsigned regind = arena_run_regind(run, bin_info, ptr);
+	size_t regind = arena_run_regind(run, bin_info, ptr);
 
 	assert(run->nfree < bin_info->nregs);
 	/* Freeing an interior pointer can cause assertion failure. */
 	assert(((uintptr_t)ptr -
 	    ((uintptr_t)arena_miscelm_to_rpages(arena_run_to_miscelm(run)) +
 	    (uintptr_t)bin_info->reg0_offset)) %
@@ -361,22 +349,36 @@
 	arena_run_page_mark_zeroed(chunk, run_ind);
 	for (i = 0; i < PAGE / sizeof(size_t); i++)
 		assert(p[i] == 0);
 }
 
 static void
-arena_cactive_update(arena_t *arena, size_t add_pages, size_t sub_pages)
+arena_nactive_add(arena_t *arena, size_t add_pages)
 {
 
 	if (config_stats) {
-		ssize_t cactive_diff = CHUNK_CEILING((arena->nactive + add_pages
-		    - sub_pages) << LG_PAGE) - CHUNK_CEILING(arena->nactive <<
+		size_t cactive_add = CHUNK_CEILING((arena->nactive +
+		    add_pages) << LG_PAGE) - CHUNK_CEILING(arena->nactive <<
 		    LG_PAGE);
-		if (cactive_diff != 0)
-			stats_cactive_add(cactive_diff);
+		if (cactive_add != 0)
+			stats_cactive_add(cactive_add);
 	}
+	arena->nactive += add_pages;
+}
+
+static void
+arena_nactive_sub(arena_t *arena, size_t sub_pages)
+{
+
+	if (config_stats) {
+		size_t cactive_sub = CHUNK_CEILING(arena->nactive << LG_PAGE) -
+		    CHUNK_CEILING((arena->nactive - sub_pages) << LG_PAGE);
+		if (cactive_sub != 0)
+			stats_cactive_sub(cactive_sub);
+	}
+	arena->nactive -= sub_pages;
 }
 
 static void
 arena_run_split_remove(arena_t *arena, arena_chunk_t *chunk, size_t run_ind,
     size_t flag_dirty, size_t flag_decommitted, size_t need_pages)
 {
@@ -391,14 +393,13 @@
 	assert(need_pages <= total_pages);
 	rem_pages = total_pages - need_pages;
 
 	arena_avail_remove(arena, chunk, run_ind, total_pages);
 	if (flag_dirty != 0)
 		arena_run_dirty_remove(arena, chunk, run_ind, total_pages);
-	arena_cactive_update(arena, need_pages, 0);
-	arena->nactive += need_pages;
+	arena_nactive_add(arena, need_pages);
 
 	/* Keep track of trailing unused pages for later use. */
 	if (rem_pages > 0) {
 		size_t flags = flag_dirty | flag_decommitted;
 		size_t flag_unzeroed_mask = (flags == 0) ?  CHUNK_MAP_UNZEROED :
 		    0;
@@ -564,130 +565,137 @@
 	    arena_mapbits_dirty_get(chunk, chunk_npages-1));
 
 	return (chunk);
 }
 
 static bool
-arena_chunk_register(arena_t *arena, arena_chunk_t *chunk, bool zero)
+arena_chunk_register(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    size_t sn, bool zero)
 {
 
 	/*
 	 * The extent node notion of "committed" doesn't directly apply to
 	 * arena chunks.  Arbitrarily mark them as committed.  The commit state
 	 * of runs is tracked individually, and upon chunk deallocation the
 	 * entire chunk is in a consistent commit state.
 	 */
-	extent_node_init(&chunk->node, arena, chunk, chunksize, zero, true);
+	extent_node_init(&chunk->node, arena, chunk, chunksize, sn, zero, true);
 	extent_node_achunk_set(&chunk->node, true);
-	return (chunk_register(chunk, &chunk->node));
+	return (chunk_register(tsdn, chunk, &chunk->node));
 }
 
 static arena_chunk_t *
-arena_chunk_alloc_internal_hard(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    bool *zero, bool *commit)
+arena_chunk_alloc_internal_hard(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, bool *zero, bool *commit)
 {
 	arena_chunk_t *chunk;
+	size_t sn;
 
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 
-	chunk = (arena_chunk_t *)chunk_alloc_wrapper(arena, chunk_hooks, NULL,
-	    chunksize, chunksize, zero, commit);
+	chunk = (arena_chunk_t *)chunk_alloc_wrapper(tsdn, arena, chunk_hooks,
+	    NULL, chunksize, chunksize, &sn, zero, commit);
 	if (chunk != NULL && !*commit) {
 		/* Commit header. */
 		if (chunk_hooks->commit(chunk, chunksize, 0, map_bias <<
 		    LG_PAGE, arena->ind)) {
-			chunk_dalloc_wrapper(arena, chunk_hooks,
-			    (void *)chunk, chunksize, *commit);
+			chunk_dalloc_wrapper(tsdn, arena, chunk_hooks,
+			    (void *)chunk, chunksize, sn, *zero, *commit);
 			chunk = NULL;
 		}
 	}
-	if (chunk != NULL && arena_chunk_register(arena, chunk, *zero)) {
+	if (chunk != NULL && arena_chunk_register(tsdn, arena, chunk, sn,
+	    *zero)) {
 		if (!*commit) {
 			/* Undo commit of header. */
 			chunk_hooks->decommit(chunk, chunksize, 0, map_bias <<
 			    LG_PAGE, arena->ind);
 		}
-		chunk_dalloc_wrapper(arena, chunk_hooks, (void *)chunk,
-		    chunksize, *commit);
+		chunk_dalloc_wrapper(tsdn, arena, chunk_hooks, (void *)chunk,
+		    chunksize, sn, *zero, *commit);
 		chunk = NULL;
 	}
 
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	return (chunk);
 }
 
 static arena_chunk_t *
-arena_chunk_alloc_internal(arena_t *arena, bool *zero, bool *commit)
+arena_chunk_alloc_internal(tsdn_t *tsdn, arena_t *arena, bool *zero,
+    bool *commit)
 {
 	arena_chunk_t *chunk;
 	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
+	size_t sn;
 
-	chunk = chunk_alloc_cache(arena, &chunk_hooks, NULL, chunksize,
-	    chunksize, zero, true);
+	chunk = chunk_alloc_cache(tsdn, arena, &chunk_hooks, NULL, chunksize,
+	    chunksize, &sn, zero, commit, true);
 	if (chunk != NULL) {
-		if (arena_chunk_register(arena, chunk, *zero)) {
-			chunk_dalloc_cache(arena, &chunk_hooks, chunk,
-			    chunksize, true);
+		if (arena_chunk_register(tsdn, arena, chunk, sn, *zero)) {
+			chunk_dalloc_cache(tsdn, arena, &chunk_hooks, chunk,
+			    chunksize, sn, true);
 			return (NULL);
 		}
-		*commit = true;
 	}
 	if (chunk == NULL) {
-		chunk = arena_chunk_alloc_internal_hard(arena, &chunk_hooks,
-		    zero, commit);
+		chunk = arena_chunk_alloc_internal_hard(tsdn, arena,
+		    &chunk_hooks, zero, commit);
 	}
 
 	if (config_stats && chunk != NULL) {
 		arena->stats.mapped += chunksize;
 		arena->stats.metadata_mapped += (map_bias << LG_PAGE);
 	}
 
 	return (chunk);
 }
 
 static arena_chunk_t *
-arena_chunk_init_hard(arena_t *arena)
+arena_chunk_init_hard(tsdn_t *tsdn, arena_t *arena)
 {
 	arena_chunk_t *chunk;
 	bool zero, commit;
 	size_t flag_unzeroed, flag_decommitted, i;
 
 	assert(arena->spare == NULL);
 
 	zero = false;
 	commit = false;
-	chunk = arena_chunk_alloc_internal(arena, &zero, &commit);
+	chunk = arena_chunk_alloc_internal(tsdn, arena, &zero, &commit);
 	if (chunk == NULL)
 		return (NULL);
 
+	chunk->hugepage = true;
+
 	/*
 	 * Initialize the map to contain one maximal free untouched run.  Mark
-	 * the pages as zeroed if chunk_alloc() returned a zeroed or decommitted
-	 * chunk.
+	 * the pages as zeroed if arena_chunk_alloc_internal() returned a zeroed
+	 * or decommitted chunk.
 	 */
 	flag_unzeroed = (zero || !commit) ? 0 : CHUNK_MAP_UNZEROED;
 	flag_decommitted = commit ? 0 : CHUNK_MAP_DECOMMITTED;
 	arena_mapbits_unallocated_set(chunk, map_bias, arena_maxrun,
 	    flag_unzeroed | flag_decommitted);
 	/*
 	 * There is no need to initialize the internal page map entries unless
 	 * the chunk is not zeroed.
 	 */
 	if (!zero) {
 		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(
-		    (void *)arena_bitselm_get(chunk, map_bias+1),
-		    (size_t)((uintptr_t) arena_bitselm_get(chunk,
-		    chunk_npages-1) - (uintptr_t)arena_bitselm_get(chunk,
-		    map_bias+1)));
+		    (void *)arena_bitselm_get_const(chunk, map_bias+1),
+		    (size_t)((uintptr_t)arena_bitselm_get_const(chunk,
+		    chunk_npages-1) -
+		    (uintptr_t)arena_bitselm_get_const(chunk, map_bias+1)));
 		for (i = map_bias+1; i < chunk_npages-1; i++)
 			arena_mapbits_internal_set(chunk, i, flag_unzeroed);
 	} else {
 		JEMALLOC_VALGRIND_MAKE_MEM_DEFINED((void
-		    *)arena_bitselm_get(chunk, map_bias+1), (size_t)((uintptr_t)
-		    arena_bitselm_get(chunk, chunk_npages-1) -
-		    (uintptr_t)arena_bitselm_get(chunk, map_bias+1)));
+		    *)arena_bitselm_get_const(chunk, map_bias+1),
+		    (size_t)((uintptr_t)arena_bitselm_get_const(chunk,
+		    chunk_npages-1) -
+		    (uintptr_t)arena_bitselm_get_const(chunk, map_bias+1)));
 		if (config_debug) {
 			for (i = map_bias+1; i < chunk_npages-1; i++) {
 				assert(arena_mapbits_unzeroed_get(chunk, i) ==
 				    flag_unzeroed);
 			}
 		}
@@ -696,88 +704,110 @@
 	    flag_unzeroed);
 
 	return (chunk);
 }
 
 static arena_chunk_t *
-arena_chunk_alloc(arena_t *arena)
+arena_chunk_alloc(tsdn_t *tsdn, arena_t *arena)
 {
 	arena_chunk_t *chunk;
 
 	if (arena->spare != NULL)
 		chunk = arena_chunk_init_spare(arena);
 	else {
-		chunk = arena_chunk_init_hard(arena);
+		chunk = arena_chunk_init_hard(tsdn, arena);
 		if (chunk == NULL)
 			return (NULL);
 	}
 
-	/* Insert the run into the runs_avail tree. */
+	ql_elm_new(&chunk->node, ql_link);
+	ql_tail_insert(&arena->achunks, &chunk->node, ql_link);
 	arena_avail_insert(arena, chunk, map_bias, chunk_npages-map_bias);
 
 	return (chunk);
 }
 
 static void
-arena_chunk_dalloc(arena_t *arena, arena_chunk_t *chunk)
+arena_chunk_discard(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk)
+{
+	size_t sn, hugepage;
+	bool committed;
+	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
+
+	chunk_deregister(chunk, &chunk->node);
+
+	sn = extent_node_sn_get(&chunk->node);
+	hugepage = chunk->hugepage;
+	committed = (arena_mapbits_decommitted_get(chunk, map_bias) == 0);
+	if (!committed) {
+		/*
+		 * Decommit the header.  Mark the chunk as decommitted even if
+		 * header decommit fails, since treating a partially committed
+		 * chunk as committed has a high potential for causing later
+		 * access of decommitted memory.
+		 */
+		chunk_hooks = chunk_hooks_get(tsdn, arena);
+		chunk_hooks.decommit(chunk, chunksize, 0, map_bias << LG_PAGE,
+		    arena->ind);
+	}
+	if (!hugepage) {
+		/*
+		 * Convert chunk back to the default state, so that all
+		 * subsequent chunk allocations start out with chunks that can
+		 * be backed by transparent huge pages.
+		 */
+		pages_huge(chunk, chunksize);
+	}
+
+	chunk_dalloc_cache(tsdn, arena, &chunk_hooks, (void *)chunk, chunksize,
+	    sn, committed);
+
+	if (config_stats) {
+		arena->stats.mapped -= chunksize;
+		arena->stats.metadata_mapped -= (map_bias << LG_PAGE);
+	}
+}
+
+static void
+arena_spare_discard(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *spare)
 {
 
+	assert(arena->spare != spare);
+
+	if (arena_mapbits_dirty_get(spare, map_bias) != 0) {
+		arena_run_dirty_remove(arena, spare, map_bias,
+		    chunk_npages-map_bias);
+	}
+
+	arena_chunk_discard(tsdn, arena, spare);
+}
+
+static void
+arena_chunk_dalloc(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk)
+{
+	arena_chunk_t *spare;
+
 	assert(arena_mapbits_allocated_get(chunk, map_bias) == 0);
 	assert(arena_mapbits_allocated_get(chunk, chunk_npages-1) == 0);
 	assert(arena_mapbits_unallocated_size_get(chunk, map_bias) ==
 	    arena_maxrun);
 	assert(arena_mapbits_unallocated_size_get(chunk, chunk_npages-1) ==
 	    arena_maxrun);
 	assert(arena_mapbits_dirty_get(chunk, map_bias) ==
 	    arena_mapbits_dirty_get(chunk, chunk_npages-1));
 	assert(arena_mapbits_decommitted_get(chunk, map_bias) ==
 	    arena_mapbits_decommitted_get(chunk, chunk_npages-1));
 
-	/*
-	 * Remove run from the runs_avail tree, so that the arena does not use
-	 * it.
-	 */
+	/* Remove run from runs_avail, so that the arena does not use it. */
 	arena_avail_remove(arena, chunk, map_bias, chunk_npages-map_bias);
 
-	if (arena->spare != NULL) {
-		arena_chunk_t *spare = arena->spare;
-		chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
-		bool committed;
-
-		arena->spare = chunk;
-		if (arena_mapbits_dirty_get(spare, map_bias) != 0) {
-			arena_run_dirty_remove(arena, spare, map_bias,
-			    chunk_npages-map_bias);
-		}
-
-		chunk_deregister(spare, &spare->node);
-
-		committed = (arena_mapbits_decommitted_get(spare, map_bias) ==
-		    0);
-		if (!committed) {
-			/*
-			 * Decommit the header.  Mark the chunk as decommitted
-			 * even if header decommit fails, since treating a
-			 * partially committed chunk as committed has a high
-			 * potential for causing later access of decommitted
-			 * memory.
-			 */
-			chunk_hooks = chunk_hooks_get(arena);
-			chunk_hooks.decommit(spare, chunksize, 0, map_bias <<
-			    LG_PAGE, arena->ind);
-		}
-
-		chunk_dalloc_cache(arena, &chunk_hooks, (void *)spare,
-		    chunksize, committed);
-
-		if (config_stats) {
-			arena->stats.mapped -= chunksize;
-			arena->stats.metadata_mapped -= (map_bias << LG_PAGE);
-		}
-	} else
-		arena->spare = chunk;
+	ql_remove(&arena->achunks, &chunk->node, ql_link);
+	spare = arena->spare;
+	arena->spare = chunk;
+	if (spare != NULL)
+		arena_spare_discard(tsdn, arena, spare);
 }
 
 static void
 arena_huge_malloc_stats_update(arena_t *arena, size_t usize)
 {
 	szind_t index = size2index(usize) - nlclasses - NBINS;
@@ -814,12 +844,23 @@
 	arena->stats.allocated_huge -= usize;
 	arena->stats.hstats[index].ndalloc++;
 	arena->stats.hstats[index].curhchunks--;
 }
 
 static void
+arena_huge_reset_stats_cancel(arena_t *arena, size_t usize)
+{
+	szind_t index = size2index(usize) - nlclasses - NBINS;
+
+	cassert(config_stats);
+
+	arena->stats.ndalloc_huge++;
+	arena->stats.hstats[index].ndalloc--;
+}
+
+static void
 arena_huge_dalloc_stats_update_undo(arena_t *arena, size_t usize)
 {
 	szind_t index = size2index(usize) - nlclasses - NBINS;
 
 	cassert(config_stats);
 
@@ -844,258 +885,255 @@
 
 	arena_huge_dalloc_stats_update_undo(arena, oldsize);
 	arena_huge_malloc_stats_update_undo(arena, usize);
 }
 
 extent_node_t *
-arena_node_alloc(arena_t *arena)
+arena_node_alloc(tsdn_t *tsdn, arena_t *arena)
 {
 	extent_node_t *node;
 
-	malloc_mutex_lock(&arena->node_cache_mtx);
+	malloc_mutex_lock(tsdn, &arena->node_cache_mtx);
 	node = ql_last(&arena->node_cache, ql_link);
 	if (node == NULL) {
-		malloc_mutex_unlock(&arena->node_cache_mtx);
-		return (base_alloc(sizeof(extent_node_t)));
+		malloc_mutex_unlock(tsdn, &arena->node_cache_mtx);
+		return (base_alloc(tsdn, sizeof(extent_node_t)));
 	}
 	ql_tail_remove(&arena->node_cache, extent_node_t, ql_link);
-	malloc_mutex_unlock(&arena->node_cache_mtx);
+	malloc_mutex_unlock(tsdn, &arena->node_cache_mtx);
 	return (node);
 }
 
 void
-arena_node_dalloc(arena_t *arena, extent_node_t *node)
+arena_node_dalloc(tsdn_t *tsdn, arena_t *arena, extent_node_t *node)
 {
 
-	malloc_mutex_lock(&arena->node_cache_mtx);
+	malloc_mutex_lock(tsdn, &arena->node_cache_mtx);
 	ql_elm_new(node, ql_link);
 	ql_tail_insert(&arena->node_cache, node, ql_link);
-	malloc_mutex_unlock(&arena->node_cache_mtx);
+	malloc_mutex_unlock(tsdn, &arena->node_cache_mtx);
 }
 
 static void *
-arena_chunk_alloc_huge_hard(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    size_t usize, size_t alignment, bool *zero, size_t csize)
+arena_chunk_alloc_huge_hard(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, size_t usize, size_t alignment, size_t *sn,
+    bool *zero, size_t csize)
 {
 	void *ret;
 	bool commit = true;
 
-	ret = chunk_alloc_wrapper(arena, chunk_hooks, NULL, csize, alignment,
-	    zero, &commit);
+	ret = chunk_alloc_wrapper(tsdn, arena, chunk_hooks, NULL, csize,
+	    alignment, sn, zero, &commit);
 	if (ret == NULL) {
 		/* Revert optimistic stats updates. */
-		malloc_mutex_lock(&arena->lock);
+		malloc_mutex_lock(tsdn, &arena->lock);
 		if (config_stats) {
 			arena_huge_malloc_stats_update_undo(arena, usize);
 			arena->stats.mapped -= usize;
 		}
-		arena->nactive -= (usize >> LG_PAGE);
-		malloc_mutex_unlock(&arena->lock);
+		arena_nactive_sub(arena, usize >> LG_PAGE);
+		malloc_mutex_unlock(tsdn, &arena->lock);
 	}
 
 	return (ret);
 }
 
 void *
-arena_chunk_alloc_huge(arena_t *arena, size_t usize, size_t alignment,
-    bool *zero)
+arena_chunk_alloc_huge(tsdn_t *tsdn, arena_t *arena, size_t usize,
+    size_t alignment, size_t *sn, bool *zero)
 {
 	void *ret;
 	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
 	size_t csize = CHUNK_CEILING(usize);
+	bool commit = true;
 
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 
 	/* Optimistically update stats. */
 	if (config_stats) {
 		arena_huge_malloc_stats_update(arena, usize);
 		arena->stats.mapped += usize;
 	}
-	arena->nactive += (usize >> LG_PAGE);
+	arena_nactive_add(arena, usize >> LG_PAGE);
 
-	ret = chunk_alloc_cache(arena, &chunk_hooks, NULL, csize, alignment,
-	    zero, true);
-	malloc_mutex_unlock(&arena->lock);
+	ret = chunk_alloc_cache(tsdn, arena, &chunk_hooks, NULL, csize,
+	    alignment, sn, zero, &commit, true);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 	if (ret == NULL) {
-		ret = arena_chunk_alloc_huge_hard(arena, &chunk_hooks, usize,
-		    alignment, zero, csize);
+		ret = arena_chunk_alloc_huge_hard(tsdn, arena, &chunk_hooks,
+		    usize, alignment, sn, zero, csize);
 	}
 
-	if (config_stats && ret != NULL)
-		stats_cactive_add(usize);
 	return (ret);
 }
 
 void
-arena_chunk_dalloc_huge(arena_t *arena, void *chunk, size_t usize)
+arena_chunk_dalloc_huge(tsdn_t *tsdn, arena_t *arena, void *chunk, size_t usize,
+    size_t sn)
 {
 	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
 	size_t csize;
 
 	csize = CHUNK_CEILING(usize);
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	if (config_stats) {
 		arena_huge_dalloc_stats_update(arena, usize);
 		arena->stats.mapped -= usize;
-		stats_cactive_sub(usize);
 	}
-	arena->nactive -= (usize >> LG_PAGE);
+	arena_nactive_sub(arena, usize >> LG_PAGE);
 
-	chunk_dalloc_cache(arena, &chunk_hooks, chunk, csize, true);
-	malloc_mutex_unlock(&arena->lock);
+	chunk_dalloc_cache(tsdn, arena, &chunk_hooks, chunk, csize, sn, true);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 }
 
 void
-arena_chunk_ralloc_huge_similar(arena_t *arena, void *chunk, size_t oldsize,
-    size_t usize)
+arena_chunk_ralloc_huge_similar(tsdn_t *tsdn, arena_t *arena, void *chunk,
+    size_t oldsize, size_t usize)
 {
 
 	assert(CHUNK_CEILING(oldsize) == CHUNK_CEILING(usize));
 	assert(oldsize != usize);
 
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	if (config_stats)
 		arena_huge_ralloc_stats_update(arena, oldsize, usize);
-	if (oldsize < usize) {
-		size_t udiff = usize - oldsize;
-		arena->nactive += udiff >> LG_PAGE;
-		if (config_stats)
-			stats_cactive_add(udiff);
-	} else {
-		size_t udiff = oldsize - usize;
-		arena->nactive -= udiff >> LG_PAGE;
-		if (config_stats)
-			stats_cactive_sub(udiff);
-	}
-	malloc_mutex_unlock(&arena->lock);
+	if (oldsize < usize)
+		arena_nactive_add(arena, (usize - oldsize) >> LG_PAGE);
+	else
+		arena_nactive_sub(arena, (oldsize - usize) >> LG_PAGE);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 }
 
 void
-arena_chunk_ralloc_huge_shrink(arena_t *arena, void *chunk, size_t oldsize,
-    size_t usize)
+arena_chunk_ralloc_huge_shrink(tsdn_t *tsdn, arena_t *arena, void *chunk,
+    size_t oldsize, size_t usize, size_t sn)
 {
 	size_t udiff = oldsize - usize;
 	size_t cdiff = CHUNK_CEILING(oldsize) - CHUNK_CEILING(usize);
 
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	if (config_stats) {
 		arena_huge_ralloc_stats_update(arena, oldsize, usize);
-		if (cdiff != 0) {
+		if (cdiff != 0)
 			arena->stats.mapped -= cdiff;
-			stats_cactive_sub(udiff);
-		}
 	}
-	arena->nactive -= udiff >> LG_PAGE;
+	arena_nactive_sub(arena, udiff >> LG_PAGE);
 
 	if (cdiff != 0) {
 		chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
 		void *nchunk = (void *)((uintptr_t)chunk +
 		    CHUNK_CEILING(usize));
 
-		chunk_dalloc_cache(arena, &chunk_hooks, nchunk, cdiff, true);
+		chunk_dalloc_cache(tsdn, arena, &chunk_hooks, nchunk, cdiff,
+		    sn, true);
 	}
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 }
 
 static bool
-arena_chunk_ralloc_huge_expand_hard(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    void *chunk, size_t oldsize, size_t usize, bool *zero, void *nchunk,
-    size_t udiff, size_t cdiff)
+arena_chunk_ralloc_huge_expand_hard(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, void *chunk, size_t oldsize, size_t usize,
+    size_t *sn, bool *zero, void *nchunk, size_t udiff, size_t cdiff)
 {
 	bool err;
 	bool commit = true;
 
-	err = (chunk_alloc_wrapper(arena, chunk_hooks, nchunk, cdiff, chunksize,
-	    zero, &commit) == NULL);
+	err = (chunk_alloc_wrapper(tsdn, arena, chunk_hooks, nchunk, cdiff,
+	    chunksize, sn, zero, &commit) == NULL);
 	if (err) {
 		/* Revert optimistic stats updates. */
-		malloc_mutex_lock(&arena->lock);
+		malloc_mutex_lock(tsdn, &arena->lock);
 		if (config_stats) {
 			arena_huge_ralloc_stats_update_undo(arena, oldsize,
 			    usize);
 			arena->stats.mapped -= cdiff;
 		}
-		arena->nactive -= (udiff >> LG_PAGE);
-		malloc_mutex_unlock(&arena->lock);
+		arena_nactive_sub(arena, udiff >> LG_PAGE);
+		malloc_mutex_unlock(tsdn, &arena->lock);
 	} else if (chunk_hooks->merge(chunk, CHUNK_CEILING(oldsize), nchunk,
 	    cdiff, true, arena->ind)) {
-		chunk_dalloc_arena(arena, chunk_hooks, nchunk, cdiff, *zero,
-		    true);
+		chunk_dalloc_wrapper(tsdn, arena, chunk_hooks, nchunk, cdiff,
+		    *sn, *zero, true);
 		err = true;
 	}
 	return (err);
 }
 
 bool
-arena_chunk_ralloc_huge_expand(arena_t *arena, void *chunk, size_t oldsize,
-    size_t usize, bool *zero)
+arena_chunk_ralloc_huge_expand(tsdn_t *tsdn, arena_t *arena, void *chunk,
+    size_t oldsize, size_t usize, bool *zero)
 {
 	bool err;
-	chunk_hooks_t chunk_hooks = chunk_hooks_get(arena);
+	chunk_hooks_t chunk_hooks = chunk_hooks_get(tsdn, arena);
 	void *nchunk = (void *)((uintptr_t)chunk + CHUNK_CEILING(oldsize));
 	size_t udiff = usize - oldsize;
 	size_t cdiff = CHUNK_CEILING(usize) - CHUNK_CEILING(oldsize);
+	size_t sn;
+	bool commit = true;
 
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 
 	/* Optimistically update stats. */
 	if (config_stats) {
 		arena_huge_ralloc_stats_update(arena, oldsize, usize);
 		arena->stats.mapped += cdiff;
 	}
-	arena->nactive += (udiff >> LG_PAGE);
+	arena_nactive_add(arena, udiff >> LG_PAGE);
 
-	err = (chunk_alloc_cache(arena, &arena->chunk_hooks, nchunk, cdiff,
-	    chunksize, zero, true) == NULL);
-	malloc_mutex_unlock(&arena->lock);
+	err = (chunk_alloc_cache(tsdn, arena, &chunk_hooks, nchunk, cdiff,
+	    chunksize, &sn, zero, &commit, true) == NULL);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 	if (err) {
-		err = arena_chunk_ralloc_huge_expand_hard(arena, &chunk_hooks,
-		    chunk, oldsize, usize, zero, nchunk, udiff,
-		    cdiff);
+		err = arena_chunk_ralloc_huge_expand_hard(tsdn, arena,
+		    &chunk_hooks, chunk, oldsize, usize, &sn, zero, nchunk,
+		    udiff, cdiff);
 	} else if (chunk_hooks.merge(chunk, CHUNK_CEILING(oldsize), nchunk,
 	    cdiff, true, arena->ind)) {
-		chunk_dalloc_arena(arena, &chunk_hooks, nchunk, cdiff, *zero,
-		    true);
+		chunk_dalloc_wrapper(tsdn, arena, &chunk_hooks, nchunk, cdiff,
+		    sn, *zero, true);
 		err = true;
 	}
 
-	if (config_stats && !err)
-		stats_cactive_add(udiff);
 	return (err);
 }
 
 /*
  * Do first-best-fit run selection, i.e. select the lowest run that best fits.
- * Run sizes are quantized, so not all candidate runs are necessarily exactly
- * the same size.
+ * Run sizes are indexed, so not all candidate runs are necessarily exactly the
+ * same size.
  */
 static arena_run_t *
 arena_run_first_best_fit(arena_t *arena, size_t size)
 {
-	size_t search_size = run_quantize_first(size);
-	arena_chunk_map_misc_t *key = arena_miscelm_key_create(search_size);
-	arena_chunk_map_misc_t *miscelm =
-	    arena_avail_tree_nsearch(&arena->runs_avail, key);
-	if (miscelm == NULL)
-		return (NULL);
-	return (&miscelm->run);
+	pszind_t pind, i;
+
+	pind = psz2ind(run_quantize_ceil(size));
+
+	for (i = pind; pind2sz(i) <= chunksize; i++) {
+		arena_chunk_map_misc_t *miscelm = arena_run_heap_first(
+		    &arena->runs_avail[i]);
+		if (miscelm != NULL)
+			return (&miscelm->run);
+	}
+
+	return (NULL);
 }
 
 static arena_run_t *
 arena_run_alloc_large_helper(arena_t *arena, size_t size, bool zero)
 {
-	arena_run_t *run = arena_run_first_best_fit(arena, s2u(size));
+	arena_run_t *run = arena_run_first_best_fit(arena, size);
 	if (run != NULL) {
 		if (arena_run_split_large(arena, run, size, zero))
 			run = NULL;
 	}
 	return (run);
 }
 
 static arena_run_t *
-arena_run_alloc_large(arena_t *arena, size_t size, bool zero)
+arena_run_alloc_large(tsdn_t *tsdn, arena_t *arena, size_t size, bool zero)
 {
 	arena_chunk_t *chunk;
 	arena_run_t *run;
 
 	assert(size <= arena_maxrun);
 	assert(size == PAGE_CEILING(size));
@@ -1105,15 +1143,15 @@
 	if (run != NULL)
 		return (run);
 
 	/*
 	 * No usable runs.  Create a new chunk from which to allocate the run.
 	 */
-	chunk = arena_chunk_alloc(arena);
+	chunk = arena_chunk_alloc(tsdn, arena);
 	if (chunk != NULL) {
-		run = &arena_miscelm_get(chunk, map_bias)->run;
+		run = &arena_miscelm_get_mutable(chunk, map_bias)->run;
 		if (arena_run_split_large(arena, run, size, zero))
 			run = NULL;
 		return (run);
 	}
 
 	/*
@@ -1133,13 +1171,13 @@
 			run = NULL;
 	}
 	return (run);
 }
 
 static arena_run_t *
-arena_run_alloc_small(arena_t *arena, size_t size, szind_t binind)
+arena_run_alloc_small(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t binind)
 {
 	arena_chunk_t *chunk;
 	arena_run_t *run;
 
 	assert(size <= arena_maxrun);
 	assert(size == PAGE_CEILING(size));
@@ -1150,15 +1188,15 @@
 	if (run != NULL)
 		return (run);
 
 	/*
 	 * No usable runs.  Create a new chunk from which to allocate the run.
 	 */
-	chunk = arena_chunk_alloc(arena);
+	chunk = arena_chunk_alloc(tsdn, arena);
 	if (chunk != NULL) {
-		run = &arena_miscelm_get(chunk, map_bias)->run;
+		run = &arena_miscelm_get_mutable(chunk, map_bias)->run;
 		if (arena_run_split_small(arena, run, size, binind))
 			run = NULL;
 		return (run);
 	}
 
 	/*
@@ -1175,48 +1213,245 @@
 
 	return (lg_dirty_mult >= -1 && lg_dirty_mult < (ssize_t)(sizeof(size_t)
 	    << 3));
 }
 
 ssize_t
-arena_lg_dirty_mult_get(arena_t *arena)
+arena_lg_dirty_mult_get(tsdn_t *tsdn, arena_t *arena)
 {
 	ssize_t lg_dirty_mult;
 
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	lg_dirty_mult = arena->lg_dirty_mult;
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 
 	return (lg_dirty_mult);
 }
 
 bool
-arena_lg_dirty_mult_set(arena_t *arena, ssize_t lg_dirty_mult)
+arena_lg_dirty_mult_set(tsdn_t *tsdn, arena_t *arena, ssize_t lg_dirty_mult)
 {
 
 	if (!arena_lg_dirty_mult_valid(lg_dirty_mult))
 		return (true);
 
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	arena->lg_dirty_mult = lg_dirty_mult;
-	arena_maybe_purge(arena);
-	malloc_mutex_unlock(&arena->lock);
+	arena_maybe_purge(tsdn, arena);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 
 	return (false);
 }
 
-void
-arena_maybe_purge(arena_t *arena)
+static void
+arena_decay_deadline_init(arena_t *arena)
+{
+
+	assert(opt_purge == purge_mode_decay);
+
+	/*
+	 * Generate a new deadline that is uniformly random within the next
+	 * epoch after the current one.
+	 */
+	nstime_copy(&arena->decay.deadline, &arena->decay.epoch);
+	nstime_add(&arena->decay.deadline, &arena->decay.interval);
+	if (arena->decay.time > 0) {
+		nstime_t jitter;
+
+		nstime_init(&jitter, prng_range_u64(&arena->decay.jitter_state,
+		    nstime_ns(&arena->decay.interval)));
+		nstime_add(&arena->decay.deadline, &jitter);
+	}
+}
+
+static bool
+arena_decay_deadline_reached(const arena_t *arena, const nstime_t *time)
+{
+
+	assert(opt_purge == purge_mode_decay);
+
+	return (nstime_compare(&arena->decay.deadline, time) <= 0);
+}
+
+static size_t
+arena_decay_backlog_npages_limit(const arena_t *arena)
+{
+	static const uint64_t h_steps[] = {
+#define	STEP(step, h, x, y) \
+		h,
+		SMOOTHSTEP
+#undef STEP
+	};
+	uint64_t sum;
+	size_t npages_limit_backlog;
+	unsigned i;
+
+	assert(opt_purge == purge_mode_decay);
+
+	/*
+	 * For each element of decay_backlog, multiply by the corresponding
+	 * fixed-point smoothstep decay factor.  Sum the products, then divide
+	 * to round down to the nearest whole number of pages.
+	 */
+	sum = 0;
+	for (i = 0; i < SMOOTHSTEP_NSTEPS; i++)
+		sum += arena->decay.backlog[i] * h_steps[i];
+	npages_limit_backlog = (size_t)(sum >> SMOOTHSTEP_BFP);
+
+	return (npages_limit_backlog);
+}
+
+static void
+arena_decay_backlog_update_last(arena_t *arena)
+{
+	size_t ndirty_delta = (arena->ndirty > arena->decay.ndirty) ?
+	    arena->ndirty - arena->decay.ndirty : 0;
+	arena->decay.backlog[SMOOTHSTEP_NSTEPS-1] = ndirty_delta;
+}
+
+static void
+arena_decay_backlog_update(arena_t *arena, uint64_t nadvance_u64)
+{
+
+	if (nadvance_u64 >= SMOOTHSTEP_NSTEPS) {
+		memset(arena->decay.backlog, 0, (SMOOTHSTEP_NSTEPS-1) *
+		    sizeof(size_t));
+	} else {
+		size_t nadvance_z = (size_t)nadvance_u64;
+
+		assert((uint64_t)nadvance_z == nadvance_u64);
+
+		memmove(arena->decay.backlog, &arena->decay.backlog[nadvance_z],
+		    (SMOOTHSTEP_NSTEPS - nadvance_z) * sizeof(size_t));
+		if (nadvance_z > 1) {
+			memset(&arena->decay.backlog[SMOOTHSTEP_NSTEPS -
+			    nadvance_z], 0, (nadvance_z-1) * sizeof(size_t));
+		}
+	}
+
+	arena_decay_backlog_update_last(arena);
+}
+
+static void
+arena_decay_epoch_advance_helper(arena_t *arena, const nstime_t *time)
+{
+	uint64_t nadvance_u64;
+	nstime_t delta;
+
+	assert(opt_purge == purge_mode_decay);
+	assert(arena_decay_deadline_reached(arena, time));
+
+	nstime_copy(&delta, time);
+	nstime_subtract(&delta, &arena->decay.epoch);
+	nadvance_u64 = nstime_divide(&delta, &arena->decay.interval);
+	assert(nadvance_u64 > 0);
+
+	/* Add nadvance_u64 decay intervals to epoch. */
+	nstime_copy(&delta, &arena->decay.interval);
+	nstime_imultiply(&delta, nadvance_u64);
+	nstime_add(&arena->decay.epoch, &delta);
+
+	/* Set a new deadline. */
+	arena_decay_deadline_init(arena);
+
+	/* Update the backlog. */
+	arena_decay_backlog_update(arena, nadvance_u64);
+}
+
+static void
+arena_decay_epoch_advance_purge(tsdn_t *tsdn, arena_t *arena)
+{
+	size_t ndirty_limit = arena_decay_backlog_npages_limit(arena);
+
+	if (arena->ndirty > ndirty_limit)
+		arena_purge_to_limit(tsdn, arena, ndirty_limit);
+	arena->decay.ndirty = arena->ndirty;
+}
+
+static void
+arena_decay_epoch_advance(tsdn_t *tsdn, arena_t *arena, const nstime_t *time)
+{
+
+	arena_decay_epoch_advance_helper(arena, time);
+	arena_decay_epoch_advance_purge(tsdn, arena);
+}
+
+static void
+arena_decay_init(arena_t *arena, ssize_t decay_time)
+{
+
+	arena->decay.time = decay_time;
+	if (decay_time > 0) {
+		nstime_init2(&arena->decay.interval, decay_time, 0);
+		nstime_idivide(&arena->decay.interval, SMOOTHSTEP_NSTEPS);
+	}
+
+	nstime_init(&arena->decay.epoch, 0);
+	nstime_update(&arena->decay.epoch);
+	arena->decay.jitter_state = (uint64_t)(uintptr_t)arena;
+	arena_decay_deadline_init(arena);
+	arena->decay.ndirty = arena->ndirty;
+	memset(arena->decay.backlog, 0, SMOOTHSTEP_NSTEPS * sizeof(size_t));
+}
+
+static bool
+arena_decay_time_valid(ssize_t decay_time)
 {
 
+	if (decay_time < -1)
+		return (false);
+	if (decay_time == -1 || (uint64_t)decay_time <= NSTIME_SEC_MAX)
+		return (true);
+	return (false);
+}
+
+ssize_t
+arena_decay_time_get(tsdn_t *tsdn, arena_t *arena)
+{
+	ssize_t decay_time;
+
+	malloc_mutex_lock(tsdn, &arena->lock);
+	decay_time = arena->decay.time;
+	malloc_mutex_unlock(tsdn, &arena->lock);
+
+	return (decay_time);
+}
+
+bool
+arena_decay_time_set(tsdn_t *tsdn, arena_t *arena, ssize_t decay_time)
+{
+
+	if (!arena_decay_time_valid(decay_time))
+		return (true);
+
+	malloc_mutex_lock(tsdn, &arena->lock);
+	/*
+	 * Restart decay backlog from scratch, which may cause many dirty pages
+	 * to be immediately purged.  It would conceptually be possible to map
+	 * the old backlog onto the new backlog, but there is no justification
+	 * for such complexity since decay_time changes are intended to be
+	 * infrequent, either between the {-1, 0, >0} states, or a one-time
+	 * arbitrary change during initial arena configuration.
+	 */
+	arena_decay_init(arena, decay_time);
+	arena_maybe_purge(tsdn, arena);
+	malloc_mutex_unlock(tsdn, &arena->lock);
+
+	return (false);
+}
+
+static void
+arena_maybe_purge_ratio(tsdn_t *tsdn, arena_t *arena)
+{
+
+	assert(opt_purge == purge_mode_ratio);
+
 	/* Don't purge if the option is disabled. */
 	if (arena->lg_dirty_mult < 0)
 		return;
-	/* Don't recursively purge. */
-	if (arena->purging)
-		return;
+
 	/*
 	 * Iterate, since preventing recursive purging could otherwise leave too
 	 * many dirty pages.
 	 */
 	while (true) {
 		size_t threshold = (arena->nactive >> arena->lg_dirty_mult);
@@ -1225,16 +1460,74 @@
 		/*
 		 * Don't purge unless the number of purgeable pages exceeds the
 		 * threshold.
 		 */
 		if (arena->ndirty <= threshold)
 			return;
-		arena_purge(arena, false);
+		arena_purge_to_limit(tsdn, arena, threshold);
 	}
 }
 
+static void
+arena_maybe_purge_decay(tsdn_t *tsdn, arena_t *arena)
+{
+	nstime_t time;
+
+	assert(opt_purge == purge_mode_decay);
+
+	/* Purge all or nothing if the option is disabled. */
+	if (arena->decay.time <= 0) {
+		if (arena->decay.time == 0)
+			arena_purge_to_limit(tsdn, arena, 0);
+		return;
+	}
+
+	nstime_init(&time, 0);
+	nstime_update(&time);
+	if (unlikely(!nstime_monotonic() && nstime_compare(&arena->decay.epoch,
+	    &time) > 0)) {
+		/*
+		 * Time went backwards.  Move the epoch back in time and
+		 * generate a new deadline, with the expectation that time
+		 * typically flows forward for long enough periods of time that
+		 * epochs complete.  Unfortunately, this strategy is susceptible
+		 * to clock jitter triggering premature epoch advances, but
+		 * clock jitter estimation and compensation isn't feasible here
+		 * because calls into this code are event-driven.
+		 */
+		nstime_copy(&arena->decay.epoch, &time);
+		arena_decay_deadline_init(arena);
+	} else {
+		/* Verify that time does not go backwards. */
+		assert(nstime_compare(&arena->decay.epoch, &time) <= 0);
+	}
+
+	/*
+	 * If the deadline has been reached, advance to the current epoch and
+	 * purge to the new limit if necessary.  Note that dirty pages created
+	 * during the current epoch are not subject to purge until a future
+	 * epoch, so as a result purging only happens during epoch advances.
+	 */
+	if (arena_decay_deadline_reached(arena, &time))
+		arena_decay_epoch_advance(tsdn, arena, &time);
+}
+
+void
+arena_maybe_purge(tsdn_t *tsdn, arena_t *arena)
+{
+
+	/* Don't recursively purge. */
+	if (arena->purging)
+		return;
+
+	if (opt_purge == purge_mode_ratio)
+		arena_maybe_purge_ratio(tsdn, arena);
+	else
+		arena_maybe_purge_decay(tsdn, arena);
+}
+
 static size_t
 arena_dirty_count(arena_t *arena)
 {
 	size_t ndirty = 0;
 	arena_runs_dirty_link_t *rdelm;
 	extent_node_t *chunkselm;
@@ -1251,103 +1544,94 @@
 			arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(
 			    rdelm);
 			arena_chunk_map_misc_t *miscelm =
 			    arena_rd_to_miscelm(rdelm);
 			size_t pageind = arena_miscelm_to_pageind(miscelm);
 			assert(arena_mapbits_allocated_get(chunk, pageind) ==
-			    0);
-			assert(arena_mapbits_large_get(chunk, pageind) == 0);
-			assert(arena_mapbits_dirty_get(chunk, pageind) != 0);
-			npages = arena_mapbits_unallocated_size_get(chunk,
-			    pageind) >> LG_PAGE;
-		}
-		ndirty += npages;
-	}
-
-	return (ndirty);
-}
-
-static size_t
-arena_compute_npurge(arena_t *arena, bool all)
-{
-	size_t npurge;
-
-	/*
-	 * Compute the minimum number of pages that this thread should try to
-	 * purge.
-	 */
-	if (!all) {
-		size_t threshold = (arena->nactive >> arena->lg_dirty_mult);
-		threshold = threshold < chunk_npages ? chunk_npages : threshold;
-
-		npurge = arena->ndirty - threshold;
-	} else
-		npurge = arena->ndirty;
+			    0);
+			assert(arena_mapbits_large_get(chunk, pageind) == 0);
+			assert(arena_mapbits_dirty_get(chunk, pageind) != 0);
+			npages = arena_mapbits_unallocated_size_get(chunk,
+			    pageind) >> LG_PAGE;
+		}
+		ndirty += npages;
+	}
 
-	return (npurge);
+	return (ndirty);
 }
 
 static size_t
-arena_stash_dirty(arena_t *arena, chunk_hooks_t *chunk_hooks, bool all,
-    size_t npurge, arena_runs_dirty_link_t *purge_runs_sentinel,
+arena_stash_dirty(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
+    size_t ndirty_limit, arena_runs_dirty_link_t *purge_runs_sentinel,
     extent_node_t *purge_chunks_sentinel)
 {
 	arena_runs_dirty_link_t *rdelm, *rdelm_next;
 	extent_node_t *chunkselm;
 	size_t nstashed = 0;
 
-	/* Stash at least npurge pages. */
+	/* Stash runs/chunks according to ndirty_limit. */
 	for (rdelm = qr_next(&arena->runs_dirty, rd_link),
 	    chunkselm = qr_next(&arena->chunks_cache, cc_link);
 	    rdelm != &arena->runs_dirty; rdelm = rdelm_next) {
 		size_t npages;
 		rdelm_next = qr_next(rdelm, rd_link);
 
 		if (rdelm == &chunkselm->rd) {
 			extent_node_t *chunkselm_next;
-			bool zero;
+			size_t sn;
+			bool zero, commit;
 			UNUSED void *chunk;
 
+			npages = extent_node_size_get(chunkselm) >> LG_PAGE;
+			if (opt_purge == purge_mode_decay && arena->ndirty -
+			    (nstashed + npages) < ndirty_limit)
+				break;
+
 			chunkselm_next = qr_next(chunkselm, cc_link);
 			/*
 			 * Allocate.  chunkselm remains valid due to the
 			 * dalloc_node=false argument to chunk_alloc_cache().
 			 */
 			zero = false;
-			chunk = chunk_alloc_cache(arena, chunk_hooks,
+			commit = false;
+			chunk = chunk_alloc_cache(tsdn, arena, chunk_hooks,
 			    extent_node_addr_get(chunkselm),
-			    extent_node_size_get(chunkselm), chunksize, &zero,
-			    false);
+			    extent_node_size_get(chunkselm), chunksize, &sn,
+			    &zero, &commit, false);
 			assert(chunk == extent_node_addr_get(chunkselm));
 			assert(zero == extent_node_zeroed_get(chunkselm));
 			extent_node_dirty_insert(chunkselm, purge_runs_sentinel,
 			    purge_chunks_sentinel);
-			npages = extent_node_size_get(chunkselm) >> LG_PAGE;
+			assert(npages == (extent_node_size_get(chunkselm) >>
+			    LG_PAGE));
 			chunkselm = chunkselm_next;
 		} else {
 			arena_chunk_t *chunk =
 			    (arena_chunk_t *)CHUNK_ADDR2BASE(rdelm);
 			arena_chunk_map_misc_t *miscelm =
 			    arena_rd_to_miscelm(rdelm);
 			size_t pageind = arena_miscelm_to_pageind(miscelm);
 			arena_run_t *run = &miscelm->run;
 			size_t run_size =
 			    arena_mapbits_unallocated_size_get(chunk, pageind);
 
 			npages = run_size >> LG_PAGE;
+			if (opt_purge == purge_mode_decay && arena->ndirty -
+			    (nstashed + npages) < ndirty_limit)
+				break;
 
 			assert(pageind + npages <= chunk_npages);
 			assert(arena_mapbits_dirty_get(chunk, pageind) ==
 			    arena_mapbits_dirty_get(chunk, pageind+npages-1));
 
 			/*
 			 * If purging the spare chunk's run, make it available
 			 * prior to allocation.
 			 */
 			if (chunk == arena->spare)
-				arena_chunk_alloc(arena);
+				arena_chunk_alloc(tsdn, arena);
 
 			/* Temporarily allocate the free dirty run. */
 			arena_run_split_large(arena, run, run_size, false);
 			/* Stash. */
 			if (false)
 				qr_new(rdelm, rd_link); /* Redundant. */
@@ -1356,33 +1640,34 @@
 				assert(qr_prev(rdelm, rd_link) == rdelm);
 			}
 			qr_meld(purge_runs_sentinel, rdelm, rd_link);
 		}
 
 		nstashed += npages;
-		if (!all && nstashed >= npurge)
+		if (opt_purge == purge_mode_ratio && arena->ndirty - nstashed <=
+		    ndirty_limit)
 			break;
 	}
 
 	return (nstashed);
 }
 
 static size_t
-arena_purge_stashed(arena_t *arena, chunk_hooks_t *chunk_hooks,
+arena_purge_stashed(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
     arena_runs_dirty_link_t *purge_runs_sentinel,
     extent_node_t *purge_chunks_sentinel)
 {
 	size_t npurged, nmadvise;
 	arena_runs_dirty_link_t *rdelm;
 	extent_node_t *chunkselm;
 
 	if (config_stats)
 		nmadvise = 0;
 	npurged = 0;
 
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 	for (rdelm = qr_next(purge_runs_sentinel, rd_link),
 	    chunkselm = qr_next(purge_chunks_sentinel, cc_link);
 	    rdelm != purge_runs_sentinel; rdelm = qr_next(rdelm, rd_link)) {
 		size_t npages;
 
 		if (rdelm == &chunkselm->rd) {
@@ -1405,23 +1690,34 @@
 			arena_chunk_map_misc_t *miscelm =
 			    arena_rd_to_miscelm(rdelm);
 			pageind = arena_miscelm_to_pageind(miscelm);
 			run_size = arena_mapbits_large_size_get(chunk, pageind);
 			npages = run_size >> LG_PAGE;
 
+			/*
+			 * If this is the first run purged within chunk, mark
+			 * the chunk as non-huge.  This will prevent all use of
+			 * transparent huge pages for this chunk until the chunk
+			 * as a whole is deallocated.
+			 */
+			if (chunk->hugepage) {
+				pages_nohuge(chunk, chunksize);
+				chunk->hugepage = false;
+			}
+
 			assert(pageind + npages <= chunk_npages);
 			assert(!arena_mapbits_decommitted_get(chunk, pageind));
 			assert(!arena_mapbits_decommitted_get(chunk,
 			    pageind+npages-1));
 			decommitted = !chunk_hooks->decommit(chunk, chunksize,
 			    pageind << LG_PAGE, npages << LG_PAGE, arena->ind);
 			if (decommitted) {
 				flag_unzeroed = 0;
 				flags = CHUNK_MAP_DECOMMITTED;
 			} else {
-				flag_unzeroed = chunk_purge_wrapper(arena,
+				flag_unzeroed = chunk_purge_wrapper(tsdn, arena,
 				    chunk_hooks, chunk, chunksize, pageind <<
 				    LG_PAGE, run_size) ? CHUNK_MAP_UNZEROED : 0;
 				flags = flag_unzeroed;
 			}
 			arena_mapbits_large_set(chunk, pageind+npages-1, 0,
 			    flags);
@@ -1446,24 +1742,24 @@
 		}
 
 		npurged += npages;
 		if (config_stats)
 			nmadvise++;
 	}
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 
 	if (config_stats) {
 		arena->stats.nmadvise += nmadvise;
 		arena->stats.purged += npurged;
 	}
 
 	return (npurged);
 }
 
 static void
-arena_unstash_purged(arena_t *arena, chunk_hooks_t *chunk_hooks,
+arena_unstash_purged(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
     arena_runs_dirty_link_t *purge_runs_sentinel,
     extent_node_t *purge_chunks_sentinel)
 {
 	arena_runs_dirty_link_t *rdelm, *rdelm_next;
 	extent_node_t *chunkselm;
 
@@ -1474,39 +1770,50 @@
 		rdelm_next = qr_next(rdelm, rd_link);
 		if (rdelm == &chunkselm->rd) {
 			extent_node_t *chunkselm_next = qr_next(chunkselm,
 			    cc_link);
 			void *addr = extent_node_addr_get(chunkselm);
 			size_t size = extent_node_size_get(chunkselm);
+			size_t sn = extent_node_sn_get(chunkselm);
 			bool zeroed = extent_node_zeroed_get(chunkselm);
 			bool committed = extent_node_committed_get(chunkselm);
 			extent_node_dirty_remove(chunkselm);
-			arena_node_dalloc(arena, chunkselm);
+			arena_node_dalloc(tsdn, arena, chunkselm);
 			chunkselm = chunkselm_next;
-			chunk_dalloc_arena(arena, chunk_hooks, addr, size,
-			    zeroed, committed);
+			chunk_dalloc_wrapper(tsdn, arena, chunk_hooks, addr,
+			    size, sn, zeroed, committed);
 		} else {
 			arena_chunk_t *chunk =
 			    (arena_chunk_t *)CHUNK_ADDR2BASE(rdelm);
 			arena_chunk_map_misc_t *miscelm =
 			    arena_rd_to_miscelm(rdelm);
 			size_t pageind = arena_miscelm_to_pageind(miscelm);
 			bool decommitted = (arena_mapbits_decommitted_get(chunk,
 			    pageind) != 0);
 			arena_run_t *run = &miscelm->run;
 			qr_remove(rdelm, rd_link);
-			arena_run_dalloc(arena, run, false, true, decommitted);
+			arena_run_dalloc(tsdn, arena, run, false, true,
+			    decommitted);
 		}
 	}
 }
 
+/*
+ * NB: ndirty_limit is interpreted differently depending on opt_purge:
+ *   - purge_mode_ratio: Purge as few dirty run/chunks as possible to reach the
+ *                       desired state:
+ *                       (arena->ndirty <= ndirty_limit)
+ *   - purge_mode_decay: Purge as many dirty runs/chunks as possible without
+ *                       violating the invariant:
+ *                       (arena->ndirty >= ndirty_limit)
+ */
 static void
-arena_purge(arena_t *arena, bool all)
+arena_purge_to_limit(tsdn_t *tsdn, arena_t *arena, size_t ndirty_limit)
 {
-	chunk_hooks_t chunk_hooks = chunk_hooks_get(arena);
-	size_t npurge, npurgeable, npurged;
+	chunk_hooks_t chunk_hooks = chunk_hooks_get(tsdn, arena);
+	size_t npurge, npurged;
 	arena_runs_dirty_link_t purge_runs_sentinel;
 	extent_node_t purge_chunks_sentinel;
 
 	arena->purging = true;
 
 	/*
@@ -1514,40 +1821,189 @@
 	 * because overhead grows nonlinearly as memory usage increases.
 	 */
 	if (false && config_debug) {
 		size_t ndirty = arena_dirty_count(arena);
 		assert(ndirty == arena->ndirty);
 	}
-	assert((arena->nactive >> arena->lg_dirty_mult) < arena->ndirty || all);
-
-	if (config_stats)
-		arena->stats.npurge++;
+	assert(opt_purge != purge_mode_ratio || (arena->nactive >>
+	    arena->lg_dirty_mult) < arena->ndirty || ndirty_limit == 0);
 
-	npurge = arena_compute_npurge(arena, all);
 	qr_new(&purge_runs_sentinel, rd_link);
 	extent_node_dirty_linkage_init(&purge_chunks_sentinel);
 
-	npurgeable = arena_stash_dirty(arena, &chunk_hooks, all, npurge,
+	npurge = arena_stash_dirty(tsdn, arena, &chunk_hooks, ndirty_limit,
 	    &purge_runs_sentinel, &purge_chunks_sentinel);
-	assert(npurgeable >= npurge);
-	npurged = arena_purge_stashed(arena, &chunk_hooks, &purge_runs_sentinel,
-	    &purge_chunks_sentinel);
-	assert(npurged == npurgeable);
-	arena_unstash_purged(arena, &chunk_hooks, &purge_runs_sentinel,
+	if (npurge == 0)
+		goto label_return;
+	npurged = arena_purge_stashed(tsdn, arena, &chunk_hooks,
+	    &purge_runs_sentinel, &purge_chunks_sentinel);
+	assert(npurged == npurge);
+	arena_unstash_purged(tsdn, arena, &chunk_hooks, &purge_runs_sentinel,
 	    &purge_chunks_sentinel);
 
+	if (config_stats)
+		arena->stats.npurge++;
+
+label_return:
 	arena->purging = false;
 }
 
 void
-arena_purge_all(arena_t *arena)
+arena_purge(tsdn_t *tsdn, arena_t *arena, bool all)
+{
+
+	malloc_mutex_lock(tsdn, &arena->lock);
+	if (all)
+		arena_purge_to_limit(tsdn, arena, 0);
+	else
+		arena_maybe_purge(tsdn, arena);
+	malloc_mutex_unlock(tsdn, &arena->lock);
+}
+
+static void
+arena_achunk_prof_reset(tsd_t *tsd, arena_t *arena, arena_chunk_t *chunk)
+{
+	size_t pageind, npages;
+
+	cassert(config_prof);
+	assert(opt_prof);
+
+	/*
+	 * Iterate over the allocated runs and remove profiled allocations from
+	 * the sample set.
+	 */
+	for (pageind = map_bias; pageind < chunk_npages; pageind += npages) {
+		if (arena_mapbits_allocated_get(chunk, pageind) != 0) {
+			if (arena_mapbits_large_get(chunk, pageind) != 0) {
+				void *ptr = (void *)((uintptr_t)chunk + (pageind
+				    << LG_PAGE));
+				size_t usize = isalloc(tsd_tsdn(tsd), ptr,
+				    config_prof);
+
+				prof_free(tsd, ptr, usize);
+				npages = arena_mapbits_large_size_get(chunk,
+				    pageind) >> LG_PAGE;
+			} else {
+				/* Skip small run. */
+				size_t binind = arena_mapbits_binind_get(chunk,
+				    pageind);
+				arena_bin_info_t *bin_info =
+				    &arena_bin_info[binind];
+				npages = bin_info->run_size >> LG_PAGE;
+			}
+		} else {
+			/* Skip unallocated run. */
+			npages = arena_mapbits_unallocated_size_get(chunk,
+			    pageind) >> LG_PAGE;
+		}
+		assert(pageind + npages <= chunk_npages);
+	}
+}
+
+void
+arena_reset(tsd_t *tsd, arena_t *arena)
 {
+	unsigned i;
+	extent_node_t *node;
+
+	/*
+	 * Locking in this function is unintuitive.  The caller guarantees that
+	 * no concurrent operations are happening in this arena, but there are
+	 * still reasons that some locking is necessary:
+	 *
+	 * - Some of the functions in the transitive closure of calls assume
+	 *   appropriate locks are held, and in some cases these locks are
+	 *   temporarily dropped to avoid lock order reversal or deadlock due to
+	 *   reentry.
+	 * - mallctl("epoch", ...) may concurrently refresh stats.  While
+	 *   strictly speaking this is a "concurrent operation", disallowing
+	 *   stats refreshes would impose an inconvenient burden.
+	 */
+
+	/* Remove large allocations from prof sample set. */
+	if (config_prof && opt_prof) {
+		ql_foreach(node, &arena->achunks, ql_link) {
+			arena_achunk_prof_reset(tsd, arena,
+			    extent_node_addr_get(node));
+		}
+	}
+
+	/* Reset curruns for large size classes. */
+	if (config_stats) {
+		for (i = 0; i < nlclasses; i++)
+			arena->stats.lstats[i].curruns = 0;
+	}
+
+	/* Huge allocations. */
+	malloc_mutex_lock(tsd_tsdn(tsd), &arena->huge_mtx);
+	for (node = ql_last(&arena->huge, ql_link); node != NULL; node =
+	    ql_last(&arena->huge, ql_link)) {
+		void *ptr = extent_node_addr_get(node);
+		size_t usize;
+
+		malloc_mutex_unlock(tsd_tsdn(tsd), &arena->huge_mtx);
+		if (config_stats || (config_prof && opt_prof))
+			usize = isalloc(tsd_tsdn(tsd), ptr, config_prof);
+		/* Remove huge allocation from prof sample set. */
+		if (config_prof && opt_prof)
+			prof_free(tsd, ptr, usize);
+		huge_dalloc(tsd_tsdn(tsd), ptr);
+		malloc_mutex_lock(tsd_tsdn(tsd), &arena->huge_mtx);
+		/* Cancel out unwanted effects on stats. */
+		if (config_stats)
+			arena_huge_reset_stats_cancel(arena, usize);
+	}
+	malloc_mutex_unlock(tsd_tsdn(tsd), &arena->huge_mtx);
+
+	malloc_mutex_lock(tsd_tsdn(tsd), &arena->lock);
 
-	malloc_mutex_lock(&arena->lock);
-	arena_purge(arena, true);
-	malloc_mutex_unlock(&arena->lock);
+	/* Bins. */
+	for (i = 0; i < NBINS; i++) {
+		arena_bin_t *bin = &arena->bins[i];
+		malloc_mutex_lock(tsd_tsdn(tsd), &bin->lock);
+		bin->runcur = NULL;
+		arena_run_heap_new(&bin->runs);
+		if (config_stats) {
+			bin->stats.curregs = 0;
+			bin->stats.curruns = 0;
+		}
+		malloc_mutex_unlock(tsd_tsdn(tsd), &bin->lock);
+	}
+
+	/*
+	 * Re-initialize runs_dirty such that the chunks_cache and runs_dirty
+	 * chains directly correspond.
+	 */
+	qr_new(&arena->runs_dirty, rd_link);
+	for (node = qr_next(&arena->chunks_cache, cc_link);
+	    node != &arena->chunks_cache; node = qr_next(node, cc_link)) {
+		qr_new(&node->rd, rd_link);
+		qr_meld(&arena->runs_dirty, &node->rd, rd_link);
+	}
+
+	/* Arena chunks. */
+	for (node = ql_last(&arena->achunks, ql_link); node != NULL; node =
+	    ql_last(&arena->achunks, ql_link)) {
+		ql_remove(&arena->achunks, node, ql_link);
+		arena_chunk_discard(tsd_tsdn(tsd), arena,
+		    extent_node_addr_get(node));
+	}
+
+	/* Spare. */
+	if (arena->spare != NULL) {
+		arena_chunk_discard(tsd_tsdn(tsd), arena, arena->spare);
+		arena->spare = NULL;
+	}
+
+	assert(!arena->purging);
+	arena->nactive = 0;
+
+	for (i = 0; i < NPSIZES; i++)
+		arena_run_heap_new(&arena->runs_avail[i]);
+
+	malloc_mutex_unlock(tsd_tsdn(tsd), &arena->lock);
 }
 
 static void
 arena_run_coalesce(arena_t *arena, arena_chunk_t *chunk, size_t *p_size,
     size_t *p_run_ind, size_t *p_run_pages, size_t flag_dirty,
     size_t flag_decommitted)
@@ -1657,41 +2113,28 @@
 		size = bin_info->run_size;
 	}
 
 	return (size);
 }
 
-static bool
-arena_run_decommit(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run)
-{
-	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
-	size_t run_ind = arena_miscelm_to_pageind(miscelm);
-	size_t offset = run_ind << LG_PAGE;
-	size_t length = arena_run_size_get(arena, chunk, run, run_ind);
-
-	return (arena->chunk_hooks.decommit(chunk, chunksize, offset, length,
-	    arena->ind));
-}
-
 static void
-arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty, bool cleaned,
-    bool decommitted)
+arena_run_dalloc(tsdn_t *tsdn, arena_t *arena, arena_run_t *run, bool dirty,
+    bool cleaned, bool decommitted)
 {
 	arena_chunk_t *chunk;
 	arena_chunk_map_misc_t *miscelm;
 	size_t size, run_ind, run_pages, flag_dirty, flag_decommitted;
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
 	miscelm = arena_run_to_miscelm(run);
 	run_ind = arena_miscelm_to_pageind(miscelm);
 	assert(run_ind >= map_bias);
 	assert(run_ind < chunk_npages);
 	size = arena_run_size_get(arena, chunk, run, run_ind);
 	run_pages = (size >> LG_PAGE);
-	arena_cactive_update(arena, 0, run_pages);
-	arena->nactive -= run_pages;
+	arena_nactive_sub(arena, run_pages);
 
 	/*
 	 * The run is dirty if the caller claims to have dirtied it, as well as
 	 * if it was already dirty before being allocated and the caller
 	 * doesn't claim to have cleaned it.
 	 */
@@ -1732,38 +2175,29 @@
 		arena_run_dirty_insert(arena, chunk, run_ind, run_pages);
 
 	/* Deallocate chunk if it is now completely unused. */
 	if (size == arena_maxrun) {
 		assert(run_ind == map_bias);
 		assert(run_pages == (arena_maxrun >> LG_PAGE));
-		arena_chunk_dalloc(arena, chunk);
+		arena_chunk_dalloc(tsdn, arena, chunk);
 	}
 
 	/*
 	 * It is okay to do dirty page processing here even if the chunk was
 	 * deallocated above, since in that case it is the spare.  Waiting
 	 * until after possible chunk deallocation to do dirty processing
 	 * allows for an old spare to be fully deallocated, thus decreasing the
 	 * chances of spuriously crossing the dirty page purging threshold.
 	 */
 	if (dirty)
-		arena_maybe_purge(arena);
-}
-
-static void
-arena_run_dalloc_decommit(arena_t *arena, arena_chunk_t *chunk,
-    arena_run_t *run)
-{
-	bool committed = arena_run_decommit(arena, chunk, run);
-
-	arena_run_dalloc(arena, run, committed, false, !committed);
+		arena_maybe_purge(tsdn, arena);
 }
 
 static void
-arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
-    size_t oldsize, size_t newsize)
+arena_run_trim_head(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    arena_run_t *run, size_t oldsize, size_t newsize)
 {
 	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
 	size_t pageind = arena_miscelm_to_pageind(miscelm);
 	size_t head_npages = (oldsize - newsize) >> LG_PAGE;
 	size_t flag_dirty = arena_mapbits_dirty_get(chunk, pageind);
 	size_t flag_decommitted = arena_mapbits_decommitted_get(chunk, pageind);
@@ -1792,18 +2226,19 @@
 		    pageind+head_npages+tail_npages-1) == flag_dirty);
 	}
 	arena_mapbits_large_set(chunk, pageind+head_npages, newsize,
 	    flag_dirty | (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk,
 	    pageind+head_npages)));
 
-	arena_run_dalloc(arena, run, false, false, (flag_decommitted != 0));
+	arena_run_dalloc(tsdn, arena, run, false, false, (flag_decommitted !=
+	    0));
 }
 
 static void
-arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
-    size_t oldsize, size_t newsize, bool dirty)
+arena_run_trim_tail(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    arena_run_t *run, size_t oldsize, size_t newsize, bool dirty)
 {
 	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
 	size_t pageind = arena_miscelm_to_pageind(miscelm);
 	size_t head_npages = newsize >> LG_PAGE;
 	size_t flag_dirty = arena_mapbits_dirty_get(chunk, pageind);
 	size_t flag_decommitted = arena_mapbits_decommitted_get(chunk, pageind);
@@ -1834,62 +2269,42 @@
 		    pageind+head_npages+tail_npages-1) == flag_dirty);
 	}
 	arena_mapbits_large_set(chunk, pageind+head_npages, oldsize-newsize,
 	    flag_dirty | (flag_unzeroed_mask & arena_mapbits_unzeroed_get(chunk,
 	    pageind+head_npages)));
 
-	tail_miscelm = arena_miscelm_get(chunk, pageind + head_npages);
+	tail_miscelm = arena_miscelm_get_mutable(chunk, pageind + head_npages);
 	tail_run = &tail_miscelm->run;
-	arena_run_dalloc(arena, tail_run, dirty, false, (flag_decommitted !=
-	    0));
-}
-
-static arena_run_t *
-arena_bin_runs_first(arena_bin_t *bin)
-{
-	arena_chunk_map_misc_t *miscelm = arena_run_tree_first(&bin->runs);
-	if (miscelm != NULL)
-		return (&miscelm->run);
-
-	return (NULL);
+	arena_run_dalloc(tsdn, arena, tail_run, dirty, false, (flag_decommitted
+	    != 0));
 }
 
 static void
 arena_bin_runs_insert(arena_bin_t *bin, arena_run_t *run)
 {
 	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
 
-	assert(arena_run_tree_search(&bin->runs, miscelm) == NULL);
-
-	arena_run_tree_insert(&bin->runs, miscelm);
-}
-
-static void
-arena_bin_runs_remove(arena_bin_t *bin, arena_run_t *run)
-{
-	arena_chunk_map_misc_t *miscelm = arena_run_to_miscelm(run);
-
-	assert(arena_run_tree_search(&bin->runs, miscelm) != NULL);
-
-	arena_run_tree_remove(&bin->runs, miscelm);
+	arena_run_heap_insert(&bin->runs, miscelm);
 }
 
 static arena_run_t *
 arena_bin_nonfull_run_tryget(arena_bin_t *bin)
 {
-	arena_run_t *run = arena_bin_runs_first(bin);
-	if (run != NULL) {
-		arena_bin_runs_remove(bin, run);
-		if (config_stats)
-			bin->stats.reruns++;
-	}
-	return (run);
+	arena_chunk_map_misc_t *miscelm;
+
+	miscelm = arena_run_heap_remove_first(&bin->runs);
+	if (miscelm == NULL)
+		return (NULL);
+	if (config_stats)
+		bin->stats.reruns++;
+
+	return (&miscelm->run);
 }
 
 static arena_run_t *
-arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin)
+arena_bin_nonfull_run_get(tsdn_t *tsdn, arena_t *arena, arena_bin_t *bin)
 {
 	arena_run_t *run;
 	szind_t binind;
 	arena_bin_info_t *bin_info;
 
 	/* Look for a usable run. */
@@ -1899,25 +2314,25 @@
 	/* No existing runs have any space available. */
 
 	binind = arena_bin_index(arena, bin);
 	bin_info = &arena_bin_info[binind];
 
 	/* Allocate a new run. */
-	malloc_mutex_unlock(&bin->lock);
+	malloc_mutex_unlock(tsdn, &bin->lock);
 	/******************************/
-	malloc_mutex_lock(&arena->lock);
-	run = arena_run_alloc_small(arena, bin_info->run_size, binind);
+	malloc_mutex_lock(tsdn, &arena->lock);
+	run = arena_run_alloc_small(tsdn, arena, bin_info->run_size, binind);
 	if (run != NULL) {
 		/* Initialize run internals. */
 		run->binind = binind;
 		run->nfree = bin_info->nregs;
 		bitmap_init(run->bitmap, &bin_info->bitmap_info);
 	}
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 	/********************************/
-	malloc_mutex_lock(&bin->lock);
+	malloc_mutex_lock(tsdn, &bin->lock);
 	if (run != NULL) {
 		if (config_stats) {
 			bin->stats.nruns++;
 			bin->stats.curruns++;
 		}
 		return (run);
@@ -1934,22 +2349,22 @@
 
 	return (NULL);
 }
 
 /* Re-fill bin->runcur, then call arena_run_reg_alloc(). */
 static void *
-arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin)
+arena_bin_malloc_hard(tsdn_t *tsdn, arena_t *arena, arena_bin_t *bin)
 {
 	szind_t binind;
 	arena_bin_info_t *bin_info;
 	arena_run_t *run;
 
 	binind = arena_bin_index(arena, bin);
 	bin_info = &arena_bin_info[binind];
 	bin->runcur = NULL;
-	run = arena_bin_nonfull_run_get(arena, bin);
+	run = arena_bin_nonfull_run_get(tsdn, arena, bin);
 	if (bin->runcur != NULL && bin->runcur->nfree > 0) {
 		/*
 		 * Another thread updated runcur while this one ran without the
 		 * bin lock in arena_bin_nonfull_run_get().
 		 */
 		void *ret;
@@ -1964,16 +2379,17 @@
 			 * Therefore it is unsafe to make any assumptions about
 			 * how run has previously been used, and
 			 * arena_bin_lower_run() must be called, as if a region
 			 * were just deallocated from the run.
 			 */
 			chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
-			if (run->nfree == bin_info->nregs)
-				arena_dalloc_bin_run(arena, chunk, run, bin);
-			else
-				arena_bin_lower_run(arena, chunk, run, bin);
+			if (run->nfree == bin_info->nregs) {
+				arena_dalloc_bin_run(tsdn, arena, chunk, run,
+				    bin);
+			} else
+				arena_bin_lower_run(arena, run, bin);
 		}
 		return (ret);
 	}
 
 	if (run == NULL)
 		return (NULL);
@@ -1983,82 +2399,83 @@
 	assert(bin->runcur->nfree > 0);
 
 	return (arena_run_reg_alloc(bin->runcur, bin_info));
 }
 
 void
-arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, szind_t binind,
-    uint64_t prof_accumbytes)
+arena_tcache_fill_small(tsdn_t *tsdn, arena_t *arena, tcache_bin_t *tbin,
+    szind_t binind, uint64_t prof_accumbytes)
 {
 	unsigned i, nfill;
 	arena_bin_t *bin;
 
 	assert(tbin->ncached == 0);
 
-	if (config_prof && arena_prof_accum(arena, prof_accumbytes))
-		prof_idump();
+	if (config_prof && arena_prof_accum(tsdn, arena, prof_accumbytes))
+		prof_idump(tsdn);
 	bin = &arena->bins[binind];
-	malloc_mutex_lock(&bin->lock);
+	malloc_mutex_lock(tsdn, &bin->lock);
 	for (i = 0, nfill = (tcache_bin_info[binind].ncached_max >>
 	    tbin->lg_fill_div); i < nfill; i++) {
 		arena_run_t *run;
 		void *ptr;
 		if ((run = bin->runcur) != NULL && run->nfree > 0)
 			ptr = arena_run_reg_alloc(run, &arena_bin_info[binind]);
 		else
-			ptr = arena_bin_malloc_hard(arena, bin);
+			ptr = arena_bin_malloc_hard(tsdn, arena, bin);
 		if (ptr == NULL) {
 			/*
 			 * OOM.  tbin->avail isn't yet filled down to its first
 			 * element, so the successful allocations (if any) must
-			 * be moved to the base of tbin->avail before bailing
-			 * out.
+			 * be moved just before tbin->avail before bailing out.
 			 */
 			if (i > 0) {
-				memmove(tbin->avail, &tbin->avail[nfill - i],
+				memmove(tbin->avail - i, tbin->avail - nfill,
 				    i * sizeof(void *));
 			}
 			break;
 		}
 		if (config_fill && unlikely(opt_junk_alloc)) {
 			arena_alloc_junk_small(ptr, &arena_bin_info[binind],
 			    true);
 		}
 		/* Insert such that low regions get used first. */
-		tbin->avail[nfill - 1 - i] = ptr;
+		*(tbin->avail - nfill + i) = ptr;
 	}
 	if (config_stats) {
 		bin->stats.nmalloc += i;
 		bin->stats.nrequests += tbin->tstats.nrequests;
 		bin->stats.curregs += i;
 		bin->stats.nfills++;
 		tbin->tstats.nrequests = 0;
 	}
-	malloc_mutex_unlock(&bin->lock);
+	malloc_mutex_unlock(tsdn, &bin->lock);
 	tbin->ncached = i;
+	arena_decay_tick(tsdn, arena);
 }
 
 void
 arena_alloc_junk_small(void *ptr, arena_bin_info_t *bin_info, bool zero)
 {
 
+	size_t redzone_size = bin_info->redzone_size;
+
 	if (zero) {
-		size_t redzone_size = bin_info->redzone_size;
-		memset((void *)((uintptr_t)ptr - redzone_size), 0xa5,
-		    redzone_size);
-		memset((void *)((uintptr_t)ptr + bin_info->reg_size), 0xa5,
-		    redzone_size);
+		memset((void *)((uintptr_t)ptr - redzone_size),
+		    JEMALLOC_ALLOC_JUNK, redzone_size);
+		memset((void *)((uintptr_t)ptr + bin_info->reg_size),
+		    JEMALLOC_ALLOC_JUNK, redzone_size);
 	} else {
-		memset((void *)((uintptr_t)ptr - bin_info->redzone_size), 0xa5,
-		    bin_info->reg_interval);
+		memset((void *)((uintptr_t)ptr - redzone_size),
+		    JEMALLOC_ALLOC_JUNK, bin_info->reg_interval);
 	}
 }
 
 #ifdef JEMALLOC_JET
 #undef arena_redzone_corruption
-#define	arena_redzone_corruption JEMALLOC_N(arena_redzone_corruption_impl)
+#define	arena_redzone_corruption JEMALLOC_N(n_arena_redzone_corruption)
 #endif
 static void
 arena_redzone_corruption(void *ptr, size_t usize, bool after,
     size_t offset, uint8_t byte)
 {
 
@@ -2067,13 +2484,13 @@
 	    after ? "after" : "before", ptr, usize, byte);
 }
 #ifdef JEMALLOC_JET
 #undef arena_redzone_corruption
 #define	arena_redzone_corruption JEMALLOC_N(arena_redzone_corruption)
 arena_redzone_corruption_t *arena_redzone_corruption =
-    JEMALLOC_N(arena_redzone_corruption_impl);
+    JEMALLOC_N(n_arena_redzone_corruption);
 #endif
 
 static void
 arena_redzones_validate(void *ptr, arena_bin_info_t *bin_info, bool reset)
 {
 	bool error = false;
@@ -2082,54 +2499,54 @@
 		size_t size = bin_info->reg_size;
 		size_t redzone_size = bin_info->redzone_size;
 		size_t i;
 
 		for (i = 1; i <= redzone_size; i++) {
 			uint8_t *byte = (uint8_t *)((uintptr_t)ptr - i);
-			if (*byte != 0xa5) {
+			if (*byte != JEMALLOC_ALLOC_JUNK) {
 				error = true;
 				arena_redzone_corruption(ptr, size, false, i,
 				    *byte);
 				if (reset)
-					*byte = 0xa5;
+					*byte = JEMALLOC_ALLOC_JUNK;
 			}
 		}
 		for (i = 0; i < redzone_size; i++) {
 			uint8_t *byte = (uint8_t *)((uintptr_t)ptr + size + i);
-			if (*byte != 0xa5) {
+			if (*byte != JEMALLOC_ALLOC_JUNK) {
 				error = true;
 				arena_redzone_corruption(ptr, size, true, i,
 				    *byte);
 				if (reset)
-					*byte = 0xa5;
+					*byte = JEMALLOC_ALLOC_JUNK;
 			}
 		}
 	}
 
 	if (opt_abort && error)
 		abort();
 }
 
 #ifdef JEMALLOC_JET
 #undef arena_dalloc_junk_small
-#define	arena_dalloc_junk_small JEMALLOC_N(arena_dalloc_junk_small_impl)
+#define	arena_dalloc_junk_small JEMALLOC_N(n_arena_dalloc_junk_small)
 #endif
 void
 arena_dalloc_junk_small(void *ptr, arena_bin_info_t *bin_info)
 {
 	size_t redzone_size = bin_info->redzone_size;
 
 	arena_redzones_validate(ptr, bin_info, false);
-	memset((void *)((uintptr_t)ptr - redzone_size), 0x5a,
+	memset((void *)((uintptr_t)ptr - redzone_size), JEMALLOC_FREE_JUNK,
 	    bin_info->reg_interval);
 }
 #ifdef JEMALLOC_JET
 #undef arena_dalloc_junk_small
 #define	arena_dalloc_junk_small JEMALLOC_N(arena_dalloc_junk_small)
 arena_dalloc_junk_small_t *arena_dalloc_junk_small =
-    JEMALLOC_N(arena_dalloc_junk_small_impl);
+    JEMALLOC_N(n_arena_dalloc_junk_small);
 #endif
 
 void
 arena_quarantine_junk_small(void *ptr, size_t usize)
 {
 	szind_t binind;
@@ -2141,154 +2558,175 @@
 
 	binind = size2index(usize);
 	bin_info = &arena_bin_info[binind];
 	arena_redzones_validate(ptr, bin_info, true);
 }
 
-void *
-arena_malloc_small(arena_t *arena, size_t size, bool zero)
+static void *
+arena_malloc_small(tsdn_t *tsdn, arena_t *arena, szind_t binind, bool zero)
 {
 	void *ret;
 	arena_bin_t *bin;
+	size_t usize;
 	arena_run_t *run;
-	szind_t binind;
 
-	binind = size2index(size);
 	assert(binind < NBINS);
 	bin = &arena->bins[binind];
-	size = index2size(binind);
+	usize = index2size(binind);
 
-	malloc_mutex_lock(&bin->lock);
+	malloc_mutex_lock(tsdn, &bin->lock);
 	if ((run = bin->runcur) != NULL && run->nfree > 0)
 		ret = arena_run_reg_alloc(run, &arena_bin_info[binind]);
 	else
-		ret = arena_bin_malloc_hard(arena, bin);
+		ret = arena_bin_malloc_hard(tsdn, arena, bin);
 
 	if (ret == NULL) {
-		malloc_mutex_unlock(&bin->lock);
+		malloc_mutex_unlock(tsdn, &bin->lock);
 		return (NULL);
 	}
 
 	if (config_stats) {
 		bin->stats.nmalloc++;
 		bin->stats.nrequests++;
 		bin->stats.curregs++;
 	}
-	malloc_mutex_unlock(&bin->lock);
-	if (config_prof && !isthreaded && arena_prof_accum(arena, size))
-		prof_idump();
+	malloc_mutex_unlock(tsdn, &bin->lock);
+	if (config_prof && !isthreaded && arena_prof_accum(tsdn, arena, usize))
+		prof_idump(tsdn);
 
 	if (!zero) {
 		if (config_fill) {
 			if (unlikely(opt_junk_alloc)) {
 				arena_alloc_junk_small(ret,
 				    &arena_bin_info[binind], false);
 			} else if (unlikely(opt_zero))
-				memset(ret, 0, size);
+				memset(ret, 0, usize);
 		}
-		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, usize);
 	} else {
 		if (config_fill && unlikely(opt_junk_alloc)) {
 			arena_alloc_junk_small(ret, &arena_bin_info[binind],
 			    true);
 		}
-		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
-		memset(ret, 0, size);
+		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, usize);
+		memset(ret, 0, usize);
 	}
 
+	arena_decay_tick(tsdn, arena);
 	return (ret);
 }
 
 void *
-arena_malloc_large(arena_t *arena, size_t size, bool zero)
+arena_malloc_large(tsdn_t *tsdn, arena_t *arena, szind_t binind, bool zero)
 {
 	void *ret;
 	size_t usize;
 	uintptr_t random_offset;
 	arena_run_t *run;
 	arena_chunk_map_misc_t *miscelm;
-	UNUSED bool idump;
+	UNUSED bool idump JEMALLOC_CC_SILENCE_INIT(false);
 
 	/* Large allocation. */
-	usize = s2u(size);
-	malloc_mutex_lock(&arena->lock);
+	usize = index2size(binind);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	if (config_cache_oblivious) {
 		uint64_t r;
 
 		/*
 		 * Compute a uniformly distributed offset within the first page
 		 * that is a multiple of the cacheline size, e.g. [0 .. 63) * 64
 		 * for 4 KiB pages and 64-byte cachelines.
 		 */
-		prng64(r, LG_PAGE - LG_CACHELINE, arena->offset_state,
-		    UINT64_C(6364136223846793009),
-		    UINT64_C(1442695040888963409));
+		r = prng_lg_range_zu(&arena->offset_state, LG_PAGE -
+		    LG_CACHELINE, false);
 		random_offset = ((uintptr_t)r) << LG_CACHELINE;
 	} else
 		random_offset = 0;
-	run = arena_run_alloc_large(arena, usize + large_pad, zero);
+	run = arena_run_alloc_large(tsdn, arena, usize + large_pad, zero);
 	if (run == NULL) {
-		malloc_mutex_unlock(&arena->lock);
+		malloc_mutex_unlock(tsdn, &arena->lock);
 		return (NULL);
 	}
 	miscelm = arena_run_to_miscelm(run);
 	ret = (void *)((uintptr_t)arena_miscelm_to_rpages(miscelm) +
 	    random_offset);
 	if (config_stats) {
-		szind_t index = size2index(usize) - NBINS;
+		szind_t index = binind - NBINS;
 
 		arena->stats.nmalloc_large++;
 		arena->stats.nrequests_large++;
 		arena->stats.allocated_large += usize;
 		arena->stats.lstats[index].nmalloc++;
 		arena->stats.lstats[index].nrequests++;
 		arena->stats.lstats[index].curruns++;
 	}
 	if (config_prof)
 		idump = arena_prof_accum_locked(arena, usize);
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 	if (config_prof && idump)
-		prof_idump();
+		prof_idump(tsdn);
 
 	if (!zero) {
 		if (config_fill) {
 			if (unlikely(opt_junk_alloc))
-				memset(ret, 0xa5, usize);
+				memset(ret, JEMALLOC_ALLOC_JUNK, usize);
 			else if (unlikely(opt_zero))
 				memset(ret, 0, usize);
 		}
 	}
 
+	arena_decay_tick(tsdn, arena);
 	return (ret);
 }
 
+void *
+arena_malloc_hard(tsdn_t *tsdn, arena_t *arena, size_t size, szind_t ind,
+    bool zero)
+{
+
+	assert(!tsdn_null(tsdn) || arena != NULL);
+
+	if (likely(!tsdn_null(tsdn)))
+		arena = arena_choose(tsdn_tsd(tsdn), arena);
+	if (unlikely(arena == NULL))
+		return (NULL);
+
+	if (likely(size <= SMALL_MAXCLASS))
+		return (arena_malloc_small(tsdn, arena, ind, zero));
+	if (likely(size <= large_maxclass))
+		return (arena_malloc_large(tsdn, arena, ind, zero));
+	return (huge_malloc(tsdn, arena, index2size(ind), zero));
+}
+
 /* Only handles large allocations that require more than page alignment. */
 static void *
-arena_palloc_large(tsd_t *tsd, arena_t *arena, size_t usize, size_t alignment,
+arena_palloc_large(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
     bool zero)
 {
 	void *ret;
 	size_t alloc_size, leadsize, trailsize;
 	arena_run_t *run;
 	arena_chunk_t *chunk;
 	arena_chunk_map_misc_t *miscelm;
 	void *rpages;
 
+	assert(!tsdn_null(tsdn) || arena != NULL);
 	assert(usize == PAGE_CEILING(usize));
 
-	arena = arena_choose(tsd, arena);
+	if (likely(!tsdn_null(tsdn)))
+		arena = arena_choose(tsdn_tsd(tsdn), arena);
 	if (unlikely(arena == NULL))
 		return (NULL);
 
 	alignment = PAGE_CEILING(alignment);
 	alloc_size = usize + large_pad + alignment - PAGE;
 
-	malloc_mutex_lock(&arena->lock);
-	run = arena_run_alloc_large(arena, alloc_size, false);
+	malloc_mutex_lock(tsdn, &arena->lock);
+	run = arena_run_alloc_large(tsdn, arena, alloc_size, false);
 	if (run == NULL) {
-		malloc_mutex_unlock(&arena->lock);
+		malloc_mutex_unlock(tsdn, &arena->lock);
 		return (NULL);
 	}
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
 	miscelm = arena_run_to_miscelm(run);
 	rpages = arena_miscelm_to_rpages(miscelm);
 
@@ -2297,34 +2735,34 @@
 	assert(alloc_size >= leadsize + usize);
 	trailsize = alloc_size - leadsize - usize - large_pad;
 	if (leadsize != 0) {
 		arena_chunk_map_misc_t *head_miscelm = miscelm;
 		arena_run_t *head_run = run;
 
-		miscelm = arena_miscelm_get(chunk,
+		miscelm = arena_miscelm_get_mutable(chunk,
 		    arena_miscelm_to_pageind(head_miscelm) + (leadsize >>
 		    LG_PAGE));
 		run = &miscelm->run;
 
-		arena_run_trim_head(arena, chunk, head_run, alloc_size,
+		arena_run_trim_head(tsdn, arena, chunk, head_run, alloc_size,
 		    alloc_size - leadsize);
 	}
 	if (trailsize != 0) {
-		arena_run_trim_tail(arena, chunk, run, usize + large_pad +
+		arena_run_trim_tail(tsdn, arena, chunk, run, usize + large_pad +
 		    trailsize, usize + large_pad, false);
 	}
 	if (arena_run_init_large(arena, run, usize + large_pad, zero)) {
 		size_t run_ind =
 		    arena_miscelm_to_pageind(arena_run_to_miscelm(run));
 		bool dirty = (arena_mapbits_dirty_get(chunk, run_ind) != 0);
 		bool decommitted = (arena_mapbits_decommitted_get(chunk,
 		    run_ind) != 0);
 
 		assert(decommitted); /* Cause of OOM. */
-		arena_run_dalloc(arena, run, dirty, false, decommitted);
-		malloc_mutex_unlock(&arena->lock);
+		arena_run_dalloc(tsdn, arena, run, dirty, false, decommitted);
+		malloc_mutex_unlock(tsdn, &arena->lock);
 		return (NULL);
 	}
 	ret = arena_miscelm_to_rpages(miscelm);
 
 	if (config_stats) {
 		szind_t index = size2index(usize) - NBINS;
@@ -2333,79 +2771,81 @@
 		arena->stats.nrequests_large++;
 		arena->stats.allocated_large += usize;
 		arena->stats.lstats[index].nmalloc++;
 		arena->stats.lstats[index].nrequests++;
 		arena->stats.lstats[index].curruns++;
 	}
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 
 	if (config_fill && !zero) {
 		if (unlikely(opt_junk_alloc))
-			memset(ret, 0xa5, usize);
+			memset(ret, JEMALLOC_ALLOC_JUNK, usize);
 		else if (unlikely(opt_zero))
 			memset(ret, 0, usize);
 	}
+	arena_decay_tick(tsdn, arena);
 	return (ret);
 }
 
 void *
-arena_palloc(tsd_t *tsd, arena_t *arena, size_t usize, size_t alignment,
+arena_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
     bool zero, tcache_t *tcache)
 {
 	void *ret;
 
 	if (usize <= SMALL_MAXCLASS && (alignment < PAGE || (alignment == PAGE
 	    && (usize & PAGE_MASK) == 0))) {
 		/* Small; alignment doesn't require special run placement. */
-		ret = arena_malloc(tsd, arena, usize, zero, tcache);
+		ret = arena_malloc(tsdn, arena, usize, size2index(usize), zero,
+		    tcache, true);
 	} else if (usize <= large_maxclass && alignment <= PAGE) {
 		/*
 		 * Large; alignment doesn't require special run placement.
 		 * However, the cached pointer may be at a random offset from
 		 * the base of the run, so do some bit manipulation to retrieve
 		 * the base.
 		 */
-		ret = arena_malloc(tsd, arena, usize, zero, tcache);
+		ret = arena_malloc(tsdn, arena, usize, size2index(usize), zero,
+		    tcache, true);
 		if (config_cache_oblivious)
 			ret = (void *)((uintptr_t)ret & ~PAGE_MASK);
 	} else {
 		if (likely(usize <= large_maxclass)) {
-			ret = arena_palloc_large(tsd, arena, usize, alignment,
+			ret = arena_palloc_large(tsdn, arena, usize, alignment,
 			    zero);
 		} else if (likely(alignment <= chunksize))
-			ret = huge_malloc(tsd, arena, usize, zero, tcache);
+			ret = huge_malloc(tsdn, arena, usize, zero);
 		else {
-			ret = huge_palloc(tsd, arena, usize, alignment, zero,
-			    tcache);
+			ret = huge_palloc(tsdn, arena, usize, alignment, zero);
 		}
 	}
 	return (ret);
 }
 
 void
-arena_prof_promoted(const void *ptr, size_t size)
+arena_prof_promoted(tsdn_t *tsdn, const void *ptr, size_t size)
 {
 	arena_chunk_t *chunk;
 	size_t pageind;
 	szind_t binind;
 
 	cassert(config_prof);
 	assert(ptr != NULL);
 	assert(CHUNK_ADDR2BASE(ptr) != ptr);
-	assert(isalloc(ptr, false) == LARGE_MINCLASS);
-	assert(isalloc(ptr, true) == LARGE_MINCLASS);
+	assert(isalloc(tsdn, ptr, false) == LARGE_MINCLASS);
+	assert(isalloc(tsdn, ptr, true) == LARGE_MINCLASS);
 	assert(size <= SMALL_MAXCLASS);
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 	binind = size2index(size);
 	assert(binind < NBINS);
 	arena_mapbits_large_binind_set(chunk, pageind, binind);
 
-	assert(isalloc(ptr, false) == LARGE_MINCLASS);
-	assert(isalloc(ptr, true) == size);
+	assert(isalloc(tsdn, ptr, false) == LARGE_MINCLASS);
+	assert(isalloc(tsdn, ptr, true) == size);
 }
 
 static void
 arena_dissociate_bin_run(arena_chunk_t *chunk, arena_run_t *run,
     arena_bin_t *bin)
 {
@@ -2415,160 +2855,165 @@
 		bin->runcur = NULL;
 	else {
 		szind_t binind = arena_bin_index(extent_node_arena_get(
 		    &chunk->node), bin);
 		arena_bin_info_t *bin_info = &arena_bin_info[binind];
 
+		/*
+		 * The following block's conditional is necessary because if the
+		 * run only contains one region, then it never gets inserted
+		 * into the non-full runs tree.
+		 */
 		if (bin_info->nregs != 1) {
-			/*
-			 * This block's conditional is necessary because if the
-			 * run only contains one region, then it never gets
-			 * inserted into the non-full runs tree.
-			 */
-			arena_bin_runs_remove(bin, run);
+			arena_chunk_map_misc_t *miscelm =
+			    arena_run_to_miscelm(run);
+
+			arena_run_heap_remove(&bin->runs, miscelm);
 		}
 	}
 }
 
 static void
-arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
-    arena_bin_t *bin)
+arena_dalloc_bin_run(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    arena_run_t *run, arena_bin_t *bin)
 {
 
 	assert(run != bin->runcur);
-	assert(arena_run_tree_search(&bin->runs, arena_run_to_miscelm(run)) ==
-	    NULL);
 
-	malloc_mutex_unlock(&bin->lock);
+	malloc_mutex_unlock(tsdn, &bin->lock);
 	/******************************/
-	malloc_mutex_lock(&arena->lock);
-	arena_run_dalloc_decommit(arena, chunk, run);
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
+	arena_run_dalloc(tsdn, arena, run, true, false, false);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 	/****************************/
-	malloc_mutex_lock(&bin->lock);
+	malloc_mutex_lock(tsdn, &bin->lock);
 	if (config_stats)
 		bin->stats.curruns--;
 }
 
 static void
-arena_bin_lower_run(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
-    arena_bin_t *bin)
+arena_bin_lower_run(arena_t *arena, arena_run_t *run, arena_bin_t *bin)
 {
 
 	/*
-	 * Make sure that if bin->runcur is non-NULL, it refers to the lowest
-	 * non-full run.  It is okay to NULL runcur out rather than proactively
-	 * keeping it pointing at the lowest non-full run.
+	 * Make sure that if bin->runcur is non-NULL, it refers to the
+	 * oldest/lowest non-full run.  It is okay to NULL runcur out rather
+	 * than proactively keeping it pointing at the oldest/lowest non-full
+	 * run.
 	 */
-	if ((uintptr_t)run < (uintptr_t)bin->runcur) {
+	if (bin->runcur != NULL &&
+	    arena_snad_comp(arena_run_to_miscelm(bin->runcur),
+	    arena_run_to_miscelm(run)) > 0) {
 		/* Switch runcur. */
 		if (bin->runcur->nfree > 0)
 			arena_bin_runs_insert(bin, bin->runcur);
 		bin->runcur = run;
 		if (config_stats)
 			bin->stats.reruns++;
 	} else
 		arena_bin_runs_insert(bin, run);
 }
 
 static void
-arena_dalloc_bin_locked_impl(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    arena_chunk_map_bits_t *bitselm, bool junked)
+arena_dalloc_bin_locked_impl(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, arena_chunk_map_bits_t *bitselm, bool junked)
 {
 	size_t pageind, rpages_ind;
 	arena_run_t *run;
 	arena_bin_t *bin;
 	arena_bin_info_t *bin_info;
 	szind_t binind;
 
 	pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 	rpages_ind = pageind - arena_mapbits_small_runind_get(chunk, pageind);
-	run = &arena_miscelm_get(chunk, rpages_ind)->run;
+	run = &arena_miscelm_get_mutable(chunk, rpages_ind)->run;
 	binind = run->binind;
 	bin = &arena->bins[binind];
 	bin_info = &arena_bin_info[binind];
 
 	if (!junked && config_fill && unlikely(opt_junk_free))
 		arena_dalloc_junk_small(ptr, bin_info);
 
 	arena_run_reg_dalloc(run, ptr);
 	if (run->nfree == bin_info->nregs) {
 		arena_dissociate_bin_run(chunk, run, bin);
-		arena_dalloc_bin_run(arena, chunk, run, bin);
+		arena_dalloc_bin_run(tsdn, arena, chunk, run, bin);
 	} else if (run->nfree == 1 && run != bin->runcur)
-		arena_bin_lower_run(arena, chunk, run, bin);
+		arena_bin_lower_run(arena, run, bin);
 
 	if (config_stats) {
 		bin->stats.ndalloc++;
 		bin->stats.curregs--;
 	}
 }
 
 void
-arena_dalloc_bin_junked_locked(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    arena_chunk_map_bits_t *bitselm)
+arena_dalloc_bin_junked_locked(tsdn_t *tsdn, arena_t *arena,
+    arena_chunk_t *chunk, void *ptr, arena_chunk_map_bits_t *bitselm)
 {
 
-	arena_dalloc_bin_locked_impl(arena, chunk, ptr, bitselm, true);
+	arena_dalloc_bin_locked_impl(tsdn, arena, chunk, ptr, bitselm, true);
 }
 
 void
-arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
+arena_dalloc_bin(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk, void *ptr,
     size_t pageind, arena_chunk_map_bits_t *bitselm)
 {
 	arena_run_t *run;
 	arena_bin_t *bin;
 	size_t rpages_ind;
 
 	rpages_ind = pageind - arena_mapbits_small_runind_get(chunk, pageind);
-	run = &arena_miscelm_get(chunk, rpages_ind)->run;
+	run = &arena_miscelm_get_mutable(chunk, rpages_ind)->run;
 	bin = &arena->bins[run->binind];
-	malloc_mutex_lock(&bin->lock);
-	arena_dalloc_bin_locked_impl(arena, chunk, ptr, bitselm, false);
-	malloc_mutex_unlock(&bin->lock);
+	malloc_mutex_lock(tsdn, &bin->lock);
+	arena_dalloc_bin_locked_impl(tsdn, arena, chunk, ptr, bitselm, false);
+	malloc_mutex_unlock(tsdn, &bin->lock);
 }
 
 void
-arena_dalloc_small(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    size_t pageind)
+arena_dalloc_small(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, size_t pageind)
 {
 	arena_chunk_map_bits_t *bitselm;
 
 	if (config_debug) {
 		/* arena_ptr_small_binind_get() does extra sanity checking. */
 		assert(arena_ptr_small_binind_get(ptr, arena_mapbits_get(chunk,
 		    pageind)) != BININD_INVALID);
 	}
-	bitselm = arena_bitselm_get(chunk, pageind);
-	arena_dalloc_bin(arena, chunk, ptr, pageind, bitselm);
+	bitselm = arena_bitselm_get_mutable(chunk, pageind);
+	arena_dalloc_bin(tsdn, arena, chunk, ptr, pageind, bitselm);
+	arena_decay_tick(tsdn, arena);
 }
 
 #ifdef JEMALLOC_JET
 #undef arena_dalloc_junk_large
-#define	arena_dalloc_junk_large JEMALLOC_N(arena_dalloc_junk_large_impl)
+#define	arena_dalloc_junk_large JEMALLOC_N(n_arena_dalloc_junk_large)
 #endif
 void
 arena_dalloc_junk_large(void *ptr, size_t usize)
 {
 
 	if (config_fill && unlikely(opt_junk_free))
-		memset(ptr, 0x5a, usize);
+		memset(ptr, JEMALLOC_FREE_JUNK, usize);
 }
 #ifdef JEMALLOC_JET
 #undef arena_dalloc_junk_large
 #define	arena_dalloc_junk_large JEMALLOC_N(arena_dalloc_junk_large)
 arena_dalloc_junk_large_t *arena_dalloc_junk_large =
-    JEMALLOC_N(arena_dalloc_junk_large_impl);
+    JEMALLOC_N(n_arena_dalloc_junk_large);
 #endif
 
 static void
-arena_dalloc_large_locked_impl(arena_t *arena, arena_chunk_t *chunk,
-    void *ptr, bool junked)
+arena_dalloc_large_locked_impl(tsdn_t *tsdn, arena_t *arena,
+    arena_chunk_t *chunk, void *ptr, bool junked)
 {
 	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-	arena_chunk_map_misc_t *miscelm = arena_miscelm_get(chunk, pageind);
+	arena_chunk_map_misc_t *miscelm = arena_miscelm_get_mutable(chunk,
+	    pageind);
 	arena_run_t *run = &miscelm->run;
 
 	if (config_fill || config_stats) {
 		size_t usize = arena_mapbits_large_size_get(chunk, pageind) -
 		    large_pad;
 
@@ -2581,48 +3026,51 @@
 			arena->stats.allocated_large -= usize;
 			arena->stats.lstats[index].ndalloc++;
 			arena->stats.lstats[index].curruns--;
 		}
 	}
 
-	arena_run_dalloc_decommit(arena, chunk, run);
+	arena_run_dalloc(tsdn, arena, run, true, false, false);
 }
 
 void
-arena_dalloc_large_junked_locked(arena_t *arena, arena_chunk_t *chunk,
-    void *ptr)
+arena_dalloc_large_junked_locked(tsdn_t *tsdn, arena_t *arena,
+    arena_chunk_t *chunk, void *ptr)
 {
 
-	arena_dalloc_large_locked_impl(arena, chunk, ptr, true);
+	arena_dalloc_large_locked_impl(tsdn, arena, chunk, ptr, true);
 }
 
 void
-arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr)
+arena_dalloc_large(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    void *ptr)
 {
 
-	malloc_mutex_lock(&arena->lock);
-	arena_dalloc_large_locked_impl(arena, chunk, ptr, false);
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
+	arena_dalloc_large_locked_impl(tsdn, arena, chunk, ptr, false);
+	malloc_mutex_unlock(tsdn, &arena->lock);
+	arena_decay_tick(tsdn, arena);
 }
 
 static void
-arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    size_t oldsize, size_t size)
+arena_ralloc_large_shrink(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, size_t oldsize, size_t size)
 {
 	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
-	arena_chunk_map_misc_t *miscelm = arena_miscelm_get(chunk, pageind);
+	arena_chunk_map_misc_t *miscelm = arena_miscelm_get_mutable(chunk,
+	    pageind);
 	arena_run_t *run = &miscelm->run;
 
 	assert(size < oldsize);
 
 	/*
 	 * Shrink the run, and make trailing pages available for other
 	 * allocations.
 	 */
-	malloc_mutex_lock(&arena->lock);
-	arena_run_trim_tail(arena, chunk, run, oldsize + large_pad, size +
+	malloc_mutex_lock(tsdn, &arena->lock);
+	arena_run_trim_tail(tsdn, arena, chunk, run, oldsize + large_pad, size +
 	    large_pad, true);
 	if (config_stats) {
 		szind_t oldindex = size2index(oldsize) - NBINS;
 		szind_t index = size2index(size) - NBINS;
 
 		arena->stats.ndalloc_large++;
@@ -2634,28 +3082,28 @@
 		arena->stats.nrequests_large++;
 		arena->stats.allocated_large += size;
 		arena->stats.lstats[index].nmalloc++;
 		arena->stats.lstats[index].nrequests++;
 		arena->stats.lstats[index].curruns++;
 	}
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 }
 
 static bool
-arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr,
-    size_t oldsize, size_t usize_min, size_t usize_max, bool zero)
+arena_ralloc_large_grow(tsdn_t *tsdn, arena_t *arena, arena_chunk_t *chunk,
+    void *ptr, size_t oldsize, size_t usize_min, size_t usize_max, bool zero)
 {
 	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
 	size_t npages = (oldsize + large_pad) >> LG_PAGE;
 	size_t followsize;
 
 	assert(oldsize == arena_mapbits_large_size_get(chunk, pageind) -
 	    large_pad);
 
 	/* Try to extend the run. */
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	if (pageind+npages >= chunk_npages || arena_mapbits_allocated_get(chunk,
 	    pageind+npages) != 0)
 		goto label_fail;
 	followsize = arena_mapbits_unallocated_size_get(chunk, pageind+npages);
 	if (oldsize + followsize >= usize_min) {
 		/*
@@ -2672,24 +3120,30 @@
 		assert(usize >= usize_min);
 		assert(usize >= oldsize);
 		splitsize = usize - oldsize;
 		if (splitsize == 0)
 			goto label_fail;
 
-		run = &arena_miscelm_get(chunk, pageind+npages)->run;
+		run = &arena_miscelm_get_mutable(chunk, pageind+npages)->run;
 		if (arena_run_split_large(arena, run, splitsize, zero))
 			goto label_fail;
 
 		if (config_cache_oblivious && zero) {
 			/*
 			 * Zero the trailing bytes of the original allocation's
 			 * last page, since they are in an indeterminate state.
+			 * There will always be trailing bytes, because ptr's
+			 * offset from the beginning of the run is a multiple of
+			 * CACHELINE in [0 .. PAGE).
 			 */
-			assert(PAGE_CEILING(oldsize) == oldsize);
-			memset((void *)((uintptr_t)ptr + oldsize), 0,
-			    PAGE_CEILING((uintptr_t)ptr) - (uintptr_t)ptr);
+			void *zbase = (void *)((uintptr_t)ptr + oldsize);
+			void *zpast = PAGE_ADDR2BASE((void *)((uintptr_t)zbase +
+			    PAGE));
+			size_t nzero = (uintptr_t)zpast - (uintptr_t)zbase;
+			assert(nzero > 0);
+			memset(zbase, 0, nzero);
 		}
 
 		size = oldsize + splitsize;
 		npages = (size + large_pad) >> LG_PAGE;
 
 		/*
@@ -2723,46 +3177,46 @@
 			arena->stats.nrequests_large++;
 			arena->stats.allocated_large += size;
 			arena->stats.lstats[index].nmalloc++;
 			arena->stats.lstats[index].nrequests++;
 			arena->stats.lstats[index].curruns++;
 		}
-		malloc_mutex_unlock(&arena->lock);
+		malloc_mutex_unlock(tsdn, &arena->lock);
 		return (false);
 	}
 label_fail:
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 	return (true);
 }
 
 #ifdef JEMALLOC_JET
 #undef arena_ralloc_junk_large
-#define	arena_ralloc_junk_large JEMALLOC_N(arena_ralloc_junk_large_impl)
+#define	arena_ralloc_junk_large JEMALLOC_N(n_arena_ralloc_junk_large)
 #endif
 static void
 arena_ralloc_junk_large(void *ptr, size_t old_usize, size_t usize)
 {
 
 	if (config_fill && unlikely(opt_junk_free)) {
-		memset((void *)((uintptr_t)ptr + usize), 0x5a,
+		memset((void *)((uintptr_t)ptr + usize), JEMALLOC_FREE_JUNK,
 		    old_usize - usize);
 	}
 }
 #ifdef JEMALLOC_JET
 #undef arena_ralloc_junk_large
 #define	arena_ralloc_junk_large JEMALLOC_N(arena_ralloc_junk_large)
 arena_ralloc_junk_large_t *arena_ralloc_junk_large =
-    JEMALLOC_N(arena_ralloc_junk_large_impl);
+    JEMALLOC_N(n_arena_ralloc_junk_large);
 #endif
 
 /*
  * Try to resize a large allocation, in order to avoid copying.  This will
  * always fail if growing an object, and the following run is already in use.
  */
 static bool
-arena_ralloc_large(void *ptr, size_t oldsize, size_t usize_min,
+arena_ralloc_large(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t usize_min,
     size_t usize_max, bool zero)
 {
 	arena_chunk_t *chunk;
 	arena_t *arena;
 
 	if (oldsize == usize_max) {
@@ -2771,146 +3225,158 @@
 	}
 
 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 	arena = extent_node_arena_get(&chunk->node);
 
 	if (oldsize < usize_max) {
-		bool ret = arena_ralloc_large_grow(arena, chunk, ptr, oldsize,
-		    usize_min, usize_max, zero);
+		bool ret = arena_ralloc_large_grow(tsdn, arena, chunk, ptr,
+		    oldsize, usize_min, usize_max, zero);
 		if (config_fill && !ret && !zero) {
 			if (unlikely(opt_junk_alloc)) {
-				memset((void *)((uintptr_t)ptr + oldsize), 0xa5,
-				    isalloc(ptr, config_prof) - oldsize);
+				memset((void *)((uintptr_t)ptr + oldsize),
+				    JEMALLOC_ALLOC_JUNK,
+				    isalloc(tsdn, ptr, config_prof) - oldsize);
 			} else if (unlikely(opt_zero)) {
 				memset((void *)((uintptr_t)ptr + oldsize), 0,
-				    isalloc(ptr, config_prof) - oldsize);
+				    isalloc(tsdn, ptr, config_prof) - oldsize);
 			}
 		}
 		return (ret);
 	}
 
 	assert(oldsize > usize_max);
 	/* Fill before shrinking in order avoid a race. */
 	arena_ralloc_junk_large(ptr, oldsize, usize_max);
-	arena_ralloc_large_shrink(arena, chunk, ptr, oldsize, usize_max);
+	arena_ralloc_large_shrink(tsdn, arena, chunk, ptr, oldsize, usize_max);
 	return (false);
 }
 
 bool
-arena_ralloc_no_move(void *ptr, size_t oldsize, size_t size, size_t extra,
-    bool zero)
+arena_ralloc_no_move(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t size,
+    size_t extra, bool zero)
 {
 	size_t usize_min, usize_max;
 
+	/* Calls with non-zero extra had to clamp extra. */
+	assert(extra == 0 || size + extra <= HUGE_MAXCLASS);
+
+	if (unlikely(size > HUGE_MAXCLASS))
+		return (true);
+
 	usize_min = s2u(size);
 	usize_max = s2u(size + extra);
 	if (likely(oldsize <= large_maxclass && usize_min <= large_maxclass)) {
+		arena_chunk_t *chunk;
+
 		/*
 		 * Avoid moving the allocation if the size class can be left the
 		 * same.
 		 */
 		if (oldsize <= SMALL_MAXCLASS) {
 			assert(arena_bin_info[size2index(oldsize)].reg_size ==
 			    oldsize);
-			if ((usize_max <= SMALL_MAXCLASS &&
-			    size2index(usize_max) == size2index(oldsize)) ||
-			    (size <= oldsize && usize_max >= oldsize))
-				return (false);
+			if ((usize_max > SMALL_MAXCLASS ||
+			    size2index(usize_max) != size2index(oldsize)) &&
+			    (size > oldsize || usize_max < oldsize))
+				return (true);
 		} else {
-			if (usize_max > SMALL_MAXCLASS) {
-				if (!arena_ralloc_large(ptr, oldsize, usize_min,
-				    usize_max, zero))
-					return (false);
-			}
+			if (usize_max <= SMALL_MAXCLASS)
+				return (true);
+			if (arena_ralloc_large(tsdn, ptr, oldsize, usize_min,
+			    usize_max, zero))
+				return (true);
 		}
 
-		/* Reallocation would require a move. */
-		return (true);
+		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+		arena_decay_tick(tsdn, extent_node_arena_get(&chunk->node));
+		return (false);
 	} else {
-		return (huge_ralloc_no_move(ptr, oldsize, usize_min, usize_max,
-		    zero));
+		return (huge_ralloc_no_move(tsdn, ptr, oldsize, usize_min,
+		    usize_max, zero));
 	}
 }
 
 static void *
-arena_ralloc_move_helper(tsd_t *tsd, arena_t *arena, size_t usize,
+arena_ralloc_move_helper(tsdn_t *tsdn, arena_t *arena, size_t usize,
     size_t alignment, bool zero, tcache_t *tcache)
 {
 
 	if (alignment == 0)
-		return (arena_malloc(tsd, arena, usize, zero, tcache));
+		return (arena_malloc(tsdn, arena, usize, size2index(usize),
+		    zero, tcache, true));
 	usize = sa2u(usize, alignment);
-	if (usize == 0)
+	if (unlikely(usize == 0 || usize > HUGE_MAXCLASS))
 		return (NULL);
-	return (ipalloct(tsd, usize, alignment, zero, tcache, arena));
+	return (ipalloct(tsdn, usize, alignment, zero, tcache, arena));
 }
 
 void *
 arena_ralloc(tsd_t *tsd, arena_t *arena, void *ptr, size_t oldsize, size_t size,
     size_t alignment, bool zero, tcache_t *tcache)
 {
 	void *ret;
 	size_t usize;
 
 	usize = s2u(size);
-	if (usize == 0)
+	if (unlikely(usize == 0 || size > HUGE_MAXCLASS))
 		return (NULL);
 
 	if (likely(usize <= large_maxclass)) {
 		size_t copysize;
 
 		/* Try to avoid moving the allocation. */
-		if (!arena_ralloc_no_move(ptr, oldsize, usize, 0, zero))
+		if (!arena_ralloc_no_move(tsd_tsdn(tsd), ptr, oldsize, usize, 0,
+		    zero))
 			return (ptr);
 
 		/*
 		 * size and oldsize are different enough that we need to move
 		 * the object.  In that case, fall back to allocating new space
 		 * and copying.
 		 */
-		ret = arena_ralloc_move_helper(tsd, arena, usize, alignment,
-		    zero, tcache);
+		ret = arena_ralloc_move_helper(tsd_tsdn(tsd), arena, usize,
+		    alignment, zero, tcache);
 		if (ret == NULL)
 			return (NULL);
 
 		/*
 		 * Junk/zero-filling were already done by
 		 * ipalloc()/arena_malloc().
 		 */
 
 		copysize = (usize < oldsize) ? usize : oldsize;
 		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, copysize);
 		memcpy(ret, ptr, copysize);
-		isqalloc(tsd, ptr, oldsize, tcache);
+		isqalloc(tsd, ptr, oldsize, tcache, true);
 	} else {
 		ret = huge_ralloc(tsd, arena, ptr, oldsize, usize, alignment,
 		    zero, tcache);
 	}
 	return (ret);
 }
 
 dss_prec_t
-arena_dss_prec_get(arena_t *arena)
+arena_dss_prec_get(tsdn_t *tsdn, arena_t *arena)
 {
 	dss_prec_t ret;
 
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	ret = arena->dss_prec;
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 	return (ret);
 }
 
 bool
-arena_dss_prec_set(arena_t *arena, dss_prec_t dss_prec)
+arena_dss_prec_set(tsdn_t *tsdn, arena_t *arena, dss_prec_t dss_prec)
 {
 
 	if (!have_dss)
 		return (dss_prec != dss_prec_disabled);
-	malloc_mutex_lock(&arena->lock);
+	malloc_mutex_lock(tsdn, &arena->lock);
 	arena->dss_prec = dss_prec;
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 	return (false);
 }
 
 ssize_t
 arena_lg_dirty_mult_default_get(void)
 {
@@ -2919,33 +3385,82 @@
 }
 
 bool
 arena_lg_dirty_mult_default_set(ssize_t lg_dirty_mult)
 {
 
+	if (opt_purge != purge_mode_ratio)
+		return (true);
 	if (!arena_lg_dirty_mult_valid(lg_dirty_mult))
 		return (true);
 	atomic_write_z((size_t *)&lg_dirty_mult_default, (size_t)lg_dirty_mult);
 	return (false);
 }
 
+ssize_t
+arena_decay_time_default_get(void)
+{
+
+	return ((ssize_t)atomic_read_z((size_t *)&decay_time_default));
+}
+
+bool
+arena_decay_time_default_set(ssize_t decay_time)
+{
+
+	if (opt_purge != purge_mode_decay)
+		return (true);
+	if (!arena_decay_time_valid(decay_time))
+		return (true);
+	atomic_write_z((size_t *)&decay_time_default, (size_t)decay_time);
+	return (false);
+}
+
+static void
+arena_basic_stats_merge_locked(arena_t *arena, unsigned *nthreads,
+    const char **dss, ssize_t *lg_dirty_mult, ssize_t *decay_time,
+    size_t *nactive, size_t *ndirty)
+{
+
+	*nthreads += arena_nthreads_get(arena, false);
+	*dss = dss_prec_names[arena->dss_prec];
+	*lg_dirty_mult = arena->lg_dirty_mult;
+	*decay_time = arena->decay.time;
+	*nactive += arena->nactive;
+	*ndirty += arena->ndirty;
+}
+
+void
+arena_basic_stats_merge(tsdn_t *tsdn, arena_t *arena, unsigned *nthreads,
+    const char **dss, ssize_t *lg_dirty_mult, ssize_t *decay_time,
+    size_t *nactive, size_t *ndirty)
+{
+
+	malloc_mutex_lock(tsdn, &arena->lock);
+	arena_basic_stats_merge_locked(arena, nthreads, dss, lg_dirty_mult,
+	    decay_time, nactive, ndirty);
+	malloc_mutex_unlock(tsdn, &arena->lock);
+}
+
 void
-arena_stats_merge(arena_t *arena, const char **dss, ssize_t *lg_dirty_mult,
+arena_stats_merge(tsdn_t *tsdn, arena_t *arena, unsigned *nthreads,
+    const char **dss, ssize_t *lg_dirty_mult, ssize_t *decay_time,
     size_t *nactive, size_t *ndirty, arena_stats_t *astats,
     malloc_bin_stats_t *bstats, malloc_large_stats_t *lstats,
     malloc_huge_stats_t *hstats)
 {
 	unsigned i;
 
-	malloc_mutex_lock(&arena->lock);
-	*dss = dss_prec_names[arena->dss_prec];
-	*lg_dirty_mult = arena->lg_dirty_mult;
-	*nactive += arena->nactive;
-	*ndirty += arena->ndirty;
+	cassert(config_stats);
+
+	malloc_mutex_lock(tsdn, &arena->lock);
+	arena_basic_stats_merge_locked(arena, nthreads, dss, lg_dirty_mult,
+	    decay_time, nactive, ndirty);
 
 	astats->mapped += arena->stats.mapped;
+	astats->retained += arena->stats.retained;
 	astats->npurge += arena->stats.npurge;
 	astats->nmadvise += arena->stats.nmadvise;
 	astats->purged += arena->stats.purged;
 	astats->metadata_mapped += arena->stats.metadata_mapped;
 	astats->metadata_allocated += arena_metadata_allocated_get(arena);
 	astats->allocated_large += arena->stats.allocated_large;
@@ -2965,56 +3480,84 @@
 
 	for (i = 0; i < nhclasses; i++) {
 		hstats[i].nmalloc += arena->stats.hstats[i].nmalloc;
 		hstats[i].ndalloc += arena->stats.hstats[i].ndalloc;
 		hstats[i].curhchunks += arena->stats.hstats[i].curhchunks;
 	}
-	malloc_mutex_unlock(&arena->lock);
+	malloc_mutex_unlock(tsdn, &arena->lock);
 
 	for (i = 0; i < NBINS; i++) {
 		arena_bin_t *bin = &arena->bins[i];
 
-		malloc_mutex_lock(&bin->lock);
+		malloc_mutex_lock(tsdn, &bin->lock);
 		bstats[i].nmalloc += bin->stats.nmalloc;
 		bstats[i].ndalloc += bin->stats.ndalloc;
 		bstats[i].nrequests += bin->stats.nrequests;
 		bstats[i].curregs += bin->stats.curregs;
 		if (config_tcache) {
 			bstats[i].nfills += bin->stats.nfills;
 			bstats[i].nflushes += bin->stats.nflushes;
 		}
 		bstats[i].nruns += bin->stats.nruns;
 		bstats[i].reruns += bin->stats.reruns;
 		bstats[i].curruns += bin->stats.curruns;
-		malloc_mutex_unlock(&bin->lock);
+		malloc_mutex_unlock(tsdn, &bin->lock);
 	}
 }
 
+unsigned
+arena_nthreads_get(arena_t *arena, bool internal)
+{
+
+	return (atomic_read_u(&arena->nthreads[internal]));
+}
+
+void
+arena_nthreads_inc(arena_t *arena, bool internal)
+{
+
+	atomic_add_u(&arena->nthreads[internal], 1);
+}
+
+void
+arena_nthreads_dec(arena_t *arena, bool internal)
+{
+
+	atomic_sub_u(&arena->nthreads[internal], 1);
+}
+
+size_t
+arena_extent_sn_next(arena_t *arena)
+{
+
+	return (atomic_add_z(&arena->extent_sn_next, 1) - 1);
+}
+
 arena_t *
-arena_new(unsigned ind)
+arena_new(tsdn_t *tsdn, unsigned ind)
 {
 	arena_t *arena;
 	unsigned i;
-	arena_bin_t *bin;
 
 	/*
 	 * Allocate arena, arena->lstats, and arena->hstats contiguously, mainly
 	 * because there is no way to clean up if base_alloc() OOMs.
 	 */
 	if (config_stats) {
-		arena = (arena_t *)base_alloc(CACHELINE_CEILING(sizeof(arena_t))
-		    + QUANTUM_CEILING(nlclasses * sizeof(malloc_large_stats_t) +
-		    nhclasses) * sizeof(malloc_huge_stats_t));
+		arena = (arena_t *)base_alloc(tsdn,
+		    CACHELINE_CEILING(sizeof(arena_t)) +
+		    QUANTUM_CEILING((nlclasses * sizeof(malloc_large_stats_t)))
+		    + (nhclasses * sizeof(malloc_huge_stats_t)));
 	} else
-		arena = (arena_t *)base_alloc(sizeof(arena_t));
+		arena = (arena_t *)base_alloc(tsdn, sizeof(arena_t));
 	if (arena == NULL)
 		return (NULL);
 
 	arena->ind = ind;
-	arena->nthreads = 0;
-	if (malloc_mutex_init(&arena->lock))
+	arena->nthreads[0] = arena->nthreads[1] = 0;
+	if (malloc_mutex_init(&arena->lock, "arena", WITNESS_RANK_ARENA))
 		return (NULL);
 
 	if (config_stats) {
 		memset(&arena->stats, 0, sizeof(arena_stats_t));
 		arena->stats.lstats = (malloc_large_stats_t *)((uintptr_t)arena
 		    + CACHELINE_CEILING(sizeof(arena_t)));
@@ -3038,51 +3581,64 @@
 		 * the likelihood of lockstep non-uniform cache index
 		 * utilization among identical concurrent processes, but at the
 		 * cost of test repeatability.  For debug builds, instead use a
 		 * deterministic seed.
 		 */
 		arena->offset_state = config_debug ? ind :
-		    (uint64_t)(uintptr_t)arena;
+		    (size_t)(uintptr_t)arena;
 	}
 
 	arena->dss_prec = chunk_dss_prec_get();
 
+	ql_new(&arena->achunks);
+
+	arena->extent_sn_next = 0;
+
 	arena->spare = NULL;
 
 	arena->lg_dirty_mult = arena_lg_dirty_mult_default_get();
 	arena->purging = false;
 	arena->nactive = 0;
 	arena->ndirty = 0;
 
-	arena_avail_tree_new(&arena->runs_avail);
+	for (i = 0; i < NPSIZES; i++)
+		arena_run_heap_new(&arena->runs_avail[i]);
+
 	qr_new(&arena->runs_dirty, rd_link);
 	qr_new(&arena->chunks_cache, cc_link);
 
+	if (opt_purge == purge_mode_decay)
+		arena_decay_init(arena, arena_decay_time_default_get());
+
 	ql_new(&arena->huge);
-	if (malloc_mutex_init(&arena->huge_mtx))
+	if (malloc_mutex_init(&arena->huge_mtx, "arena_huge",
+	    WITNESS_RANK_ARENA_HUGE))
 		return (NULL);
 
-	extent_tree_szad_new(&arena->chunks_szad_cached);
+	extent_tree_szsnad_new(&arena->chunks_szsnad_cached);
 	extent_tree_ad_new(&arena->chunks_ad_cached);
-	extent_tree_szad_new(&arena->chunks_szad_retained);
+	extent_tree_szsnad_new(&arena->chunks_szsnad_retained);
 	extent_tree_ad_new(&arena->chunks_ad_retained);
-	if (malloc_mutex_init(&arena->chunks_mtx))
+	if (malloc_mutex_init(&arena->chunks_mtx, "arena_chunks",
+	    WITNESS_RANK_ARENA_CHUNKS))
 		return (NULL);
 	ql_new(&arena->node_cache);
-	if (malloc_mutex_init(&arena->node_cache_mtx))
+	if (malloc_mutex_init(&arena->node_cache_mtx, "arena_node_cache",
+	    WITNESS_RANK_ARENA_NODE_CACHE))
 		return (NULL);
 
 	arena->chunk_hooks = chunk_hooks_default;
 
 	/* Initialize bins. */
 	for (i = 0; i < NBINS; i++) {
-		bin = &arena->bins[i];
-		if (malloc_mutex_init(&bin->lock))
+		arena_bin_t *bin = &arena->bins[i];
+		if (malloc_mutex_init(&bin->lock, "arena_bin",
+		    WITNESS_RANK_ARENA_BIN))
 			return (NULL);
 		bin->runcur = NULL;
-		arena_run_tree_new(&bin->runs);
+		arena_run_heap_new(&bin->runs);
 		if (config_stats)
 			memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
 	}
 
 	return (arena);
 }
@@ -3108,14 +3664,13 @@
 	 * redzone size.  Add padding to the end of the run if it is needed to
 	 * align the regions.  The padding allows each redzone to be half the
 	 * minimum alignment; without the padding, each redzone would have to
 	 * be twice as large in order to maintain alignment.
 	 */
 	if (config_fill && unlikely(opt_redzone)) {
-		size_t align_min = ZU(1) << (jemalloc_ffs(bin_info->reg_size) -
-		    1);
+		size_t align_min = ZU(1) << (ffs_zu(bin_info->reg_size) - 1);
 		if (align_min <= REDZONE_MINSIZE) {
 			bin_info->redzone_size = REDZONE_MINSIZE;
 			pad_size = 0;
 		} else {
 			bin_info->redzone_size = align_min >> 1;
 			pad_size = bin_info->redzone_size;
@@ -3129,58 +3684,56 @@
 
 	/*
 	 * Compute run size under ideal conditions (no redzones, no limit on run
 	 * size).
 	 */
 	try_run_size = PAGE;
-	try_nregs = try_run_size / bin_info->reg_size;
+	try_nregs = (uint32_t)(try_run_size / bin_info->reg_size);
 	do {
 		perfect_run_size = try_run_size;
 		perfect_nregs = try_nregs;
 
 		try_run_size += PAGE;
-		try_nregs = try_run_size / bin_info->reg_size;
+		try_nregs = (uint32_t)(try_run_size / bin_info->reg_size);
 	} while (perfect_run_size != perfect_nregs * bin_info->reg_size);
 	assert(perfect_nregs <= RUN_MAXREGS);
 
 	actual_run_size = perfect_run_size;
-	actual_nregs = (actual_run_size - pad_size) / bin_info->reg_interval;
+	actual_nregs = (uint32_t)((actual_run_size - pad_size) /
+	    bin_info->reg_interval);
 
 	/*
 	 * Redzones can require enough padding that not even a single region can
 	 * fit within the number of pages that would normally be dedicated to a
 	 * run for this size class.  Increase the run size until at least one
 	 * region fits.
 	 */
 	while (actual_nregs == 0) {
 		assert(config_fill && unlikely(opt_redzone));
 
 		actual_run_size += PAGE;
-		actual_nregs = (actual_run_size - pad_size) /
-		    bin_info->reg_interval;
+		actual_nregs = (uint32_t)((actual_run_size - pad_size) /
+		    bin_info->reg_interval);
 	}
 
 	/*
 	 * Make sure that the run will fit within an arena chunk.
 	 */
 	while (actual_run_size > arena_maxrun) {
 		actual_run_size -= PAGE;
-		actual_nregs = (actual_run_size - pad_size) /
-		    bin_info->reg_interval;
+		actual_nregs = (uint32_t)((actual_run_size - pad_size) /
+		    bin_info->reg_interval);
 	}
 	assert(actual_nregs > 0);
 	assert(actual_run_size == s2u(actual_run_size));
 
 	/* Copy final settings. */
 	bin_info->run_size = actual_run_size;
 	bin_info->nregs = actual_nregs;
-	bin_info->reg0_offset = actual_run_size - (actual_nregs *
-	    bin_info->reg_interval) - pad_size + bin_info->redzone_size;
-
-	if (actual_run_size > small_maxrun)
-		small_maxrun = actual_run_size;
+	bin_info->reg0_offset = (uint32_t)(actual_run_size - (actual_nregs *
+	    bin_info->reg_interval) - pad_size + bin_info->redzone_size);
 
 	assert(bin_info->reg0_offset - bin_info->redzone_size + (bin_info->nregs
 	    * bin_info->reg_interval) + pad_size == bin_info->run_size);
 }
 
 static void
@@ -3191,52 +3744,27 @@
 #define	BIN_INFO_INIT_bin_yes(index, size)				\
 	bin_info = &arena_bin_info[index];				\
 	bin_info->reg_size = size;					\
 	bin_info_run_size_calc(bin_info);				\
 	bitmap_info_init(&bin_info->bitmap_info, bin_info->nregs);
 #define	BIN_INFO_INIT_bin_no(index, size)
-#define	SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup)	\
+#define	SC(index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup)	\
 	BIN_INFO_INIT_bin_##bin(index, (ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta))
 	SIZE_CLASSES
 #undef BIN_INFO_INIT_bin_yes
 #undef BIN_INFO_INIT_bin_no
 #undef SC
 }
 
-static bool
-small_run_size_init(void)
-{
-
-	assert(small_maxrun != 0);
-
-	small_run_tab = (bool *)base_alloc(sizeof(bool) * (small_maxrun >>
-	    LG_PAGE));
-	if (small_run_tab == NULL)
-		return (true);
-
-#define	TAB_INIT_bin_yes(index, size) {					\
-		arena_bin_info_t *bin_info = &arena_bin_info[index];	\
-		small_run_tab[bin_info->run_size >> LG_PAGE] = true;	\
-	}
-#define	TAB_INIT_bin_no(index, size)
-#define	SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup)	\
-	TAB_INIT_bin_##bin(index, (ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta))
-	SIZE_CLASSES
-#undef TAB_INIT_bin_yes
-#undef TAB_INIT_bin_no
-#undef SC
-
-	return (false);
-}
-
-bool
+void
 arena_boot(void)
 {
 	unsigned i;
 
 	arena_lg_dirty_mult_default_set(opt_lg_dirty_mult);
+	arena_decay_time_default_set(opt_decay_time);
 
 	/*
 	 * Compute the header size such that it is large enough to contain the
 	 * page map.  The page map is biased to omit entries for the header
 	 * itself, so some iteration is necessary to compute the map bias.
 	 *
@@ -3272,47 +3800,64 @@
 	}
 	assert(large_maxclass > 0);
 	nlclasses = size2index(large_maxclass) - size2index(SMALL_MAXCLASS);
 	nhclasses = NSIZES - nlclasses - NBINS;
 
 	bin_info_init();
-	return (small_run_size_init());
 }
 
 void
-arena_prefork(arena_t *arena)
+arena_prefork0(tsdn_t *tsdn, arena_t *arena)
+{
+
+	malloc_mutex_prefork(tsdn, &arena->lock);
+}
+
+void
+arena_prefork1(tsdn_t *tsdn, arena_t *arena)
+{
+
+	malloc_mutex_prefork(tsdn, &arena->chunks_mtx);
+}
+
+void
+arena_prefork2(tsdn_t *tsdn, arena_t *arena)
+{
+
+	malloc_mutex_prefork(tsdn, &arena->node_cache_mtx);
+}
+
+void
+arena_prefork3(tsdn_t *tsdn, arena_t *arena)
 {
 	unsigned i;
 
-	malloc_mutex_prefork(&arena->lock);
-	malloc_mutex_prefork(&arena->huge_mtx);
-	malloc_mutex_prefork(&arena->chunks_mtx);
-	malloc_mutex_prefork(&arena->node_cache_mtx);
 	for (i = 0; i < NBINS; i++)
-		malloc_mutex_prefork(&arena->bins[i].lock);
+		malloc_mutex_prefork(tsdn, &arena->bins[i].lock);
+	malloc_mutex_prefork(tsdn, &arena->huge_mtx);
 }
 
 void
-arena_postfork_parent(arena_t *arena)
+arena_postfork_parent(tsdn_t *tsdn, arena_t *arena)
 {
 	unsigned i;
 
+	malloc_mutex_postfork_parent(tsdn, &arena->huge_mtx);
 	for (i = 0; i < NBINS; i++)
-		malloc_mutex_postfork_parent(&arena->bins[i].lock);
-	malloc_mutex_postfork_parent(&arena->node_cache_mtx);
-	malloc_mutex_postfork_parent(&arena->chunks_mtx);
-	malloc_mutex_postfork_parent(&arena->huge_mtx);
-	malloc_mutex_postfork_parent(&arena->lock);
+		malloc_mutex_postfork_parent(tsdn, &arena->bins[i].lock);
+	malloc_mutex_postfork_parent(tsdn, &arena->node_cache_mtx);
+	malloc_mutex_postfork_parent(tsdn, &arena->chunks_mtx);
+	malloc_mutex_postfork_parent(tsdn, &arena->lock);
 }
 
 void
-arena_postfork_child(arena_t *arena)
+arena_postfork_child(tsdn_t *tsdn, arena_t *arena)
 {
 	unsigned i;
 
+	malloc_mutex_postfork_child(tsdn, &arena->huge_mtx);
 	for (i = 0; i < NBINS; i++)
-		malloc_mutex_postfork_child(&arena->bins[i].lock);
-	malloc_mutex_postfork_child(&arena->node_cache_mtx);
-	malloc_mutex_postfork_child(&arena->chunks_mtx);
-	malloc_mutex_postfork_child(&arena->huge_mtx);
-	malloc_mutex_postfork_child(&arena->lock);
+		malloc_mutex_postfork_child(tsdn, &arena->bins[i].lock);
+	malloc_mutex_postfork_child(tsdn, &arena->node_cache_mtx);
+	malloc_mutex_postfork_child(tsdn, &arena->chunks_mtx);
+	malloc_mutex_postfork_child(tsdn, &arena->lock);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.d	2017-09-27 23:00:20.562936085 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.d	2017-09-27 23:01:55.990932587 +0800
@@ -1,18 +1,21 @@
 src/arena.o: src/arena.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.d	2017-09-27 23:00:20.654936081 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.d	2017-09-27 23:01:56.094932583 +0800
@@ -1,18 +1,21 @@
 src/atomic.o: src/atomic.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.c	2017-01-31 23:32:23.000000000 +0800
@@ -2,84 +2,95 @@
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 /* Data. */
 
 static malloc_mutex_t	base_mtx;
-static extent_tree_t	base_avail_szad;
+static size_t		base_extent_sn_next;
+static extent_tree_t	base_avail_szsnad;
 static extent_node_t	*base_nodes;
 static size_t		base_allocated;
 static size_t		base_resident;
 static size_t		base_mapped;
 
 /******************************************************************************/
 
-/* base_mtx must be held. */
 static extent_node_t *
-base_node_try_alloc(void)
+base_node_try_alloc(tsdn_t *tsdn)
 {
 	extent_node_t *node;
 
+	malloc_mutex_assert_owner(tsdn, &base_mtx);
+
 	if (base_nodes == NULL)
 		return (NULL);
 	node = base_nodes;
 	base_nodes = *(extent_node_t **)node;
 	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, sizeof(extent_node_t));
 	return (node);
 }
 
-/* base_mtx must be held. */
 static void
-base_node_dalloc(extent_node_t *node)
+base_node_dalloc(tsdn_t *tsdn, extent_node_t *node)
 {
 
+	malloc_mutex_assert_owner(tsdn, &base_mtx);
+
 	JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(node, sizeof(extent_node_t));
 	*(extent_node_t **)node = base_nodes;
 	base_nodes = node;
 }
 
-/* base_mtx must be held. */
+static void
+base_extent_node_init(extent_node_t *node, void *addr, size_t size)
+{
+	size_t sn = atomic_add_z(&base_extent_sn_next, 1) - 1;
+
+	extent_node_init(node, NULL, addr, size, sn, true, true);
+}
+
 static extent_node_t *
-base_chunk_alloc(size_t minsize)
+base_chunk_alloc(tsdn_t *tsdn, size_t minsize)
 {
 	extent_node_t *node;
 	size_t csize, nsize;
 	void *addr;
 
+	malloc_mutex_assert_owner(tsdn, &base_mtx);
 	assert(minsize != 0);
-	node = base_node_try_alloc();
+	node = base_node_try_alloc(tsdn);
 	/* Allocate enough space to also carve a node out if necessary. */
 	nsize = (node == NULL) ? CACHELINE_CEILING(sizeof(extent_node_t)) : 0;
 	csize = CHUNK_CEILING(minsize + nsize);
 	addr = chunk_alloc_base(csize);
 	if (addr == NULL) {
 		if (node != NULL)
-			base_node_dalloc(node);
+			base_node_dalloc(tsdn, node);
 		return (NULL);
 	}
 	base_mapped += csize;
 	if (node == NULL) {
 		node = (extent_node_t *)addr;
 		addr = (void *)((uintptr_t)addr + nsize);
 		csize -= nsize;
 		if (config_stats) {
 			base_allocated += nsize;
 			base_resident += PAGE_CEILING(nsize);
 		}
 	}
-	extent_node_init(node, NULL, addr, csize, true, true);
+	base_extent_node_init(node, addr, csize);
 	return (node);
 }
 
 /*
  * base_alloc() guarantees demand-zeroed memory, in order to make multi-page
  * sparse data structures such as radix tree nodes efficient with respect to
  * physical memory usage.
  */
 void *
-base_alloc(size_t size)
+base_alloc(tsdn_t *tsdn, size_t size)
 {
 	void *ret;
 	size_t csize, usize;
 	extent_node_t *node;
 	extent_node_t key;
 
@@ -87,88 +98,90 @@
 	 * Round size up to nearest multiple of the cacheline size, so that
 	 * there is no chance of false cache line sharing.
 	 */
 	csize = CACHELINE_CEILING(size);
 
 	usize = s2u(csize);
-	extent_node_init(&key, NULL, NULL, usize, false, false);
-	malloc_mutex_lock(&base_mtx);
-	node = extent_tree_szad_nsearch(&base_avail_szad, &key);
+	extent_node_init(&key, NULL, NULL, usize, 0, false, false);
+	malloc_mutex_lock(tsdn, &base_mtx);
+	node = extent_tree_szsnad_nsearch(&base_avail_szsnad, &key);
 	if (node != NULL) {
 		/* Use existing space. */
-		extent_tree_szad_remove(&base_avail_szad, node);
+		extent_tree_szsnad_remove(&base_avail_szsnad, node);
 	} else {
 		/* Try to allocate more space. */
-		node = base_chunk_alloc(csize);
+		node = base_chunk_alloc(tsdn, csize);
 	}
 	if (node == NULL) {
 		ret = NULL;
 		goto label_return;
 	}
 
 	ret = extent_node_addr_get(node);
 	if (extent_node_size_get(node) > csize) {
 		extent_node_addr_set(node, (void *)((uintptr_t)ret + csize));
 		extent_node_size_set(node, extent_node_size_get(node) - csize);
-		extent_tree_szad_insert(&base_avail_szad, node);
+		extent_tree_szsnad_insert(&base_avail_szsnad, node);
 	} else
-		base_node_dalloc(node);
+		base_node_dalloc(tsdn, node);
 	if (config_stats) {
 		base_allocated += csize;
 		/*
 		 * Add one PAGE to base_resident for every page boundary that is
 		 * crossed by the new allocation.
 		 */
 		base_resident += PAGE_CEILING((uintptr_t)ret + csize) -
 		    PAGE_CEILING((uintptr_t)ret);
 	}
 	JEMALLOC_VALGRIND_MAKE_MEM_DEFINED(ret, csize);
 label_return:
-	malloc_mutex_unlock(&base_mtx);
+	malloc_mutex_unlock(tsdn, &base_mtx);
 	return (ret);
 }
 
 void
-base_stats_get(size_t *allocated, size_t *resident, size_t *mapped)
+base_stats_get(tsdn_t *tsdn, size_t *allocated, size_t *resident,
+    size_t *mapped)
 {
 
-	malloc_mutex_lock(&base_mtx);
+	malloc_mutex_lock(tsdn, &base_mtx);
 	assert(base_allocated <= base_resident);
 	assert(base_resident <= base_mapped);
 	*allocated = base_allocated;
 	*resident = base_resident;
 	*mapped = base_mapped;
-	malloc_mutex_unlock(&base_mtx);
+	malloc_mutex_unlock(tsdn, &base_mtx);
 }
 
 bool
 base_boot(void)
 {
 
-	if (malloc_mutex_init(&base_mtx))
+	if (malloc_mutex_init(&base_mtx, "base", WITNESS_RANK_BASE))
 		return (true);
-	extent_tree_szad_new(&base_avail_szad);
+	base_extent_sn_next = 0;
+	extent_tree_szsnad_new(&base_avail_szsnad);
 	base_nodes = NULL;
 
 	return (false);
 }
 
 void
-base_prefork(void)
+base_prefork(tsdn_t *tsdn)
 {
 
-	malloc_mutex_prefork(&base_mtx);
+	malloc_mutex_prefork(tsdn, &base_mtx);
 }
 
 void
-base_postfork_parent(void)
+base_postfork_parent(tsdn_t *tsdn)
 {
 
-	malloc_mutex_postfork_parent(&base_mtx);
+	malloc_mutex_postfork_parent(tsdn, &base_mtx);
 }
 
 void
-base_postfork_child(void)
+base_postfork_child(tsdn_t *tsdn)
 {
 
-	malloc_mutex_postfork_child(&base_mtx);
+	malloc_mutex_postfork_child(tsdn, &base_mtx);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.d	2017-09-27 23:00:20.774936077 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.d	2017-09-27 23:01:56.226932579 +0800
@@ -1,18 +1,21 @@
 src/base.o: src/base.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,11 +1,13 @@
 #define	JEMALLOC_BITMAP_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 
+#ifdef USE_TREE
+
 void
 bitmap_info_init(bitmap_info_t *binfo, size_t nbits)
 {
 	unsigned i;
 	size_t group_count;
 
@@ -29,26 +31,17 @@
 	    + group_count;
 	assert(binfo->levels[i].group_offset <= BITMAP_GROUPS_MAX);
 	binfo->nlevels = i;
 	binfo->nbits = nbits;
 }
 
-size_t
+static size_t
 bitmap_info_ngroups(const bitmap_info_t *binfo)
 {
 
-	return (binfo->levels[binfo->nlevels].group_offset << LG_SIZEOF_BITMAP);
-}
-
-size_t
-bitmap_size(size_t nbits)
-{
-	bitmap_info_t binfo;
-
-	bitmap_info_init(&binfo, nbits);
-	return (bitmap_info_ngroups(&binfo));
+	return (binfo->levels[binfo->nlevels].group_offset);
 }
 
 void
 bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo)
 {
 	size_t extra;
@@ -58,14 +51,13 @@
 	 * Bits are actually inverted with regard to the external bitmap
 	 * interface, so the bitmap starts out with all 1 bits, except for
 	 * trailing unused bits (if any).  Note that each group uses bit 0 to
 	 * correspond to the first logical bit in the group, so extra bits
 	 * are the most significant bits of the last group.
 	 */
-	memset(bitmap, 0xffU, binfo->levels[binfo->nlevels].group_offset <<
-	    LG_SIZEOF_BITMAP);
+	memset(bitmap, 0xffU, bitmap_size(binfo));
 	extra = (BITMAP_GROUP_NBITS - (binfo->nbits & BITMAP_GROUP_NBITS_MASK))
 	    & BITMAP_GROUP_NBITS_MASK;
 	if (extra != 0)
 		bitmap[binfo->levels[1].group_offset - 1] >>= extra;
 	for (i = 1; i < binfo->nlevels; i++) {
 		size_t group_count = binfo->levels[i].group_offset -
@@ -73,6 +65,47 @@
 		extra = (BITMAP_GROUP_NBITS - (group_count &
 		    BITMAP_GROUP_NBITS_MASK)) & BITMAP_GROUP_NBITS_MASK;
 		if (extra != 0)
 			bitmap[binfo->levels[i+1].group_offset - 1] >>= extra;
 	}
 }
+
+#else /* USE_TREE */
+
+void
+bitmap_info_init(bitmap_info_t *binfo, size_t nbits)
+{
+
+	assert(nbits > 0);
+	assert(nbits <= (ZU(1) << LG_BITMAP_MAXBITS));
+
+	binfo->ngroups = BITMAP_BITS2GROUPS(nbits);
+	binfo->nbits = nbits;
+}
+
+static size_t
+bitmap_info_ngroups(const bitmap_info_t *binfo)
+{
+
+	return (binfo->ngroups);
+}
+
+void
+bitmap_init(bitmap_t *bitmap, const bitmap_info_t *binfo)
+{
+	size_t extra;
+
+	memset(bitmap, 0xffU, bitmap_size(binfo));
+	extra = (BITMAP_GROUP_NBITS - (binfo->nbits & BITMAP_GROUP_NBITS_MASK))
+	    & BITMAP_GROUP_NBITS_MASK;
+	if (extra != 0)
+		bitmap[binfo->ngroups - 1] >>= extra;
+}
+
+#endif /* USE_TREE */
+
+size_t
+bitmap_size(const bitmap_info_t *binfo)
+{
+
+	return (bitmap_info_ngroups(binfo) << LG_SIZEOF_BITMAP);
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.d	2017-09-27 23:00:20.890936073 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.d	2017-09-27 23:01:56.338932574 +0800
@@ -1,18 +1,21 @@
 src/bitmap.o: src/bitmap.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.c	2017-01-31 23:32:23.000000000 +0800
@@ -46,43 +46,44 @@
 /******************************************************************************/
 /*
  * Function prototypes for static functions that are referenced prior to
  * definition.
  */
 
-static void	chunk_record(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    extent_tree_t *chunks_szad, extent_tree_t *chunks_ad, bool cache,
-    void *chunk, size_t size, bool zeroed, bool committed);
+static void	chunk_record(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, extent_tree_t *chunks_szsnad,
+    extent_tree_t *chunks_ad, bool cache, void *chunk, size_t size, size_t sn,
+    bool zeroed, bool committed);
 
 /******************************************************************************/
 
 static chunk_hooks_t
 chunk_hooks_get_locked(arena_t *arena)
 {
 
 	return (arena->chunk_hooks);
 }
 
 chunk_hooks_t
-chunk_hooks_get(arena_t *arena)
+chunk_hooks_get(tsdn_t *tsdn, arena_t *arena)
 {
 	chunk_hooks_t chunk_hooks;
 
-	malloc_mutex_lock(&arena->chunks_mtx);
+	malloc_mutex_lock(tsdn, &arena->chunks_mtx);
 	chunk_hooks = chunk_hooks_get_locked(arena);
-	malloc_mutex_unlock(&arena->chunks_mtx);
+	malloc_mutex_unlock(tsdn, &arena->chunks_mtx);
 
 	return (chunk_hooks);
 }
 
 chunk_hooks_t
-chunk_hooks_set(arena_t *arena, const chunk_hooks_t *chunk_hooks)
+chunk_hooks_set(tsdn_t *tsdn, arena_t *arena, const chunk_hooks_t *chunk_hooks)
 {
 	chunk_hooks_t old_chunk_hooks;
 
-	malloc_mutex_lock(&arena->chunks_mtx);
+	malloc_mutex_lock(tsdn, &arena->chunks_mtx);
 	old_chunk_hooks = arena->chunk_hooks;
 	/*
 	 * Copy each field atomically so that it is impossible for readers to
 	 * see partially updated pointers.  There are places where readers only
 	 * need one hook function pointer (therefore no need to copy the
 	 * entirety of arena->chunk_hooks), and stale reads do not affect
@@ -101,48 +102,49 @@
 	ATOMIC_COPY_HOOK(commit);
 	ATOMIC_COPY_HOOK(decommit);
 	ATOMIC_COPY_HOOK(purge);
 	ATOMIC_COPY_HOOK(split);
 	ATOMIC_COPY_HOOK(merge);
 #undef ATOMIC_COPY_HOOK
-	malloc_mutex_unlock(&arena->chunks_mtx);
+	malloc_mutex_unlock(tsdn, &arena->chunks_mtx);
 
 	return (old_chunk_hooks);
 }
 
 static void
-chunk_hooks_assure_initialized_impl(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    bool locked)
+chunk_hooks_assure_initialized_impl(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks, bool locked)
 {
 	static const chunk_hooks_t uninitialized_hooks =
 	    CHUNK_HOOKS_INITIALIZER;
 
 	if (memcmp(chunk_hooks, &uninitialized_hooks, sizeof(chunk_hooks_t)) ==
 	    0) {
 		*chunk_hooks = locked ? chunk_hooks_get_locked(arena) :
-		    chunk_hooks_get(arena);
+		    chunk_hooks_get(tsdn, arena);
 	}
 }
 
 static void
-chunk_hooks_assure_initialized_locked(arena_t *arena,
+chunk_hooks_assure_initialized_locked(tsdn_t *tsdn, arena_t *arena,
     chunk_hooks_t *chunk_hooks)
 {
 
-	chunk_hooks_assure_initialized_impl(arena, chunk_hooks, true);
+	chunk_hooks_assure_initialized_impl(tsdn, arena, chunk_hooks, true);
 }
 
 static void
-chunk_hooks_assure_initialized(arena_t *arena, chunk_hooks_t *chunk_hooks)
+chunk_hooks_assure_initialized(tsdn_t *tsdn, arena_t *arena,
+    chunk_hooks_t *chunk_hooks)
 {
 
-	chunk_hooks_assure_initialized_impl(arena, chunk_hooks, false);
+	chunk_hooks_assure_initialized_impl(tsdn, arena, chunk_hooks, false);
 }
 
 bool
-chunk_register(const void *chunk, const extent_node_t *node)
+chunk_register(tsdn_t *tsdn, const void *chunk, const extent_node_t *node)
 {
 
 	assert(extent_node_addr_get(node) == chunk);
 
 	if (rtree_set(&chunks_rtree, (uintptr_t)chunk, node))
 		return (true);
@@ -156,13 +158,13 @@
 			 * Don't refresh cur, because it may have decreased
 			 * since this thread lost the highchunks update race.
 			 */
 			high = atomic_read_z(&highchunks);
 		}
 		if (cur > high && prof_gdump_get_unlocked())
-			prof_gdump();
+			prof_gdump(tsdn);
 	}
 
 	return (false);
 }
 
 void
@@ -178,192 +180,186 @@
 		assert(atomic_read_z(&curchunks) >= nsub);
 		atomic_sub_z(&curchunks, nsub);
 	}
 }
 
 /*
- * Do first-best-fit chunk selection, i.e. select the lowest chunk that best
- * fits.
+ * Do first-best-fit chunk selection, i.e. select the oldest/lowest chunk that
+ * best fits.
  */
 static extent_node_t *
-chunk_first_best_fit(arena_t *arena, extent_tree_t *chunks_szad,
-    extent_tree_t *chunks_ad, size_t size)
+chunk_first_best_fit(arena_t *arena, extent_tree_t *chunks_szsnad, size_t size)
 {
 	extent_node_t key;
 
 	assert(size == CHUNK_CEILING(size));
 
-	extent_node_init(&key, arena, NULL, size, false, false);
-	return (extent_tree_szad_nsearch(chunks_szad, &key));
+	extent_node_init(&key, arena, NULL, size, 0, false, false);
+	return (extent_tree_szsnad_nsearch(chunks_szsnad, &key));
 }
 
 static void *
-chunk_recycle(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    extent_tree_t *chunks_szad, extent_tree_t *chunks_ad, bool cache,
-    void *new_addr, size_t size, size_t alignment, bool *zero, bool *commit,
-    bool dalloc_node)
+chunk_recycle(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
+    extent_tree_t *chunks_szsnad, extent_tree_t *chunks_ad, bool cache,
+    void *new_addr, size_t size, size_t alignment, size_t *sn, bool *zero,
+    bool *commit, bool dalloc_node)
 {
 	void *ret;
 	extent_node_t *node;
 	size_t alloc_size, leadsize, trailsize;
 	bool zeroed, committed;
 
+	assert(CHUNK_CEILING(size) == size);
+	assert(alignment > 0);
 	assert(new_addr == NULL || alignment == chunksize);
+	assert(CHUNK_ADDR2BASE(new_addr) == new_addr);
 	/*
 	 * Cached chunks use the node linkage embedded in their headers, in
 	 * which case dalloc_node is true, and new_addr is non-NULL because
 	 * we're operating on a specific chunk.
 	 */
 	assert(dalloc_node || new_addr != NULL);
 
-	alloc_size = CHUNK_CEILING(s2u(size + alignment - chunksize));
+	alloc_size = size + CHUNK_CEILING(alignment) - chunksize;
 	/* Beware size_t wrap-around. */
 	if (alloc_size < size)
 		return (NULL);
-	malloc_mutex_lock(&arena->chunks_mtx);
-	chunk_hooks_assure_initialized_locked(arena, chunk_hooks);
+	malloc_mutex_lock(tsdn, &arena->chunks_mtx);
+	chunk_hooks_assure_initialized_locked(tsdn, arena, chunk_hooks);
 	if (new_addr != NULL) {
 		extent_node_t key;
-		extent_node_init(&key, arena, new_addr, alloc_size, false,
+		extent_node_init(&key, arena, new_addr, alloc_size, 0, false,
 		    false);
 		node = extent_tree_ad_search(chunks_ad, &key);
 	} else {
-		node = chunk_first_best_fit(arena, chunks_szad, chunks_ad,
-		    alloc_size);
+		node = chunk_first_best_fit(arena, chunks_szsnad, alloc_size);
 	}
 	if (node == NULL || (new_addr != NULL && extent_node_size_get(node) <
 	    size)) {
-		malloc_mutex_unlock(&arena->chunks_mtx);
+		malloc_mutex_unlock(tsdn, &arena->chunks_mtx);
 		return (NULL);
 	}
 	leadsize = ALIGNMENT_CEILING((uintptr_t)extent_node_addr_get(node),
 	    alignment) - (uintptr_t)extent_node_addr_get(node);
 	assert(new_addr == NULL || leadsize == 0);
 	assert(extent_node_size_get(node) >= leadsize + size);
 	trailsize = extent_node_size_get(node) - leadsize - size;
 	ret = (void *)((uintptr_t)extent_node_addr_get(node) + leadsize);
+	*sn = extent_node_sn_get(node);
 	zeroed = extent_node_zeroed_get(node);
 	if (zeroed)
 		*zero = true;
 	committed = extent_node_committed_get(node);
 	if (committed)
 		*commit = true;
 	/* Split the lead. */
 	if (leadsize != 0 &&
 	    chunk_hooks->split(extent_node_addr_get(node),
 	    extent_node_size_get(node), leadsize, size, false, arena->ind)) {
-		malloc_mutex_unlock(&arena->chunks_mtx);
+		malloc_mutex_unlock(tsdn, &arena->chunks_mtx);
 		return (NULL);
 	}
 	/* Remove node from the tree. */
-	extent_tree_szad_remove(chunks_szad, node);
+	extent_tree_szsnad_remove(chunks_szsnad, node);
 	extent_tree_ad_remove(chunks_ad, node);
 	arena_chunk_cache_maybe_remove(arena, node, cache);
 	if (leadsize != 0) {
 		/* Insert the leading space as a smaller chunk. */
 		extent_node_size_set(node, leadsize);
-		extent_tree_szad_insert(chunks_szad, node);
+		extent_tree_szsnad_insert(chunks_szsnad, node);
 		extent_tree_ad_insert(chunks_ad, node);
 		arena_chunk_cache_maybe_insert(arena, node, cache);
 		node = NULL;
 	}
 	if (trailsize != 0) {
 		/* Split the trail. */
 		if (chunk_hooks->split(ret, size + trailsize, size,
 		    trailsize, false, arena->ind)) {
 			if (dalloc_node && node != NULL)
-				arena_node_dalloc(arena, node);
-			malloc_mutex_unlock(&arena->chunks_mtx);
-			chunk_record(arena, chunk_hooks, chunks_szad, chunks_ad,
-			    cache, ret, size + trailsize, zeroed, committed);
+				arena_node_dalloc(tsdn, arena, node);
+			malloc_mutex_unlock(tsdn, &arena->chunks_mtx);
+			chunk_record(tsdn, arena, chunk_hooks, chunks_szsnad,
+			    chunks_ad, cache, ret, size + trailsize, *sn,
+			    zeroed, committed);
 			return (NULL);
 		}
 		/* Insert the trailing space as a smaller chunk. */
 		if (node == NULL) {
-			node = arena_node_alloc(arena);
+			node = arena_node_alloc(tsdn, arena);
 			if (node == NULL) {
-				malloc_mutex_unlock(&arena->chunks_mtx);
-				chunk_record(arena, chunk_hooks, chunks_szad,
-				    chunks_ad, cache, ret, size + trailsize,
-				    zeroed, committed);
+				malloc_mutex_unlock(tsdn, &arena->chunks_mtx);
+				chunk_record(tsdn, arena, chunk_hooks,
+				    chunks_szsnad, chunks_ad, cache, ret, size
+				    + trailsize, *sn, zeroed, committed);
 				return (NULL);
 			}
 		}
 		extent_node_init(node, arena, (void *)((uintptr_t)(ret) + size),
-		    trailsize, zeroed, committed);
-		extent_tree_szad_insert(chunks_szad, node);
+		    trailsize, *sn, zeroed, committed);
+		extent_tree_szsnad_insert(chunks_szsnad, node);
 		extent_tree_ad_insert(chunks_ad, node);
 		arena_chunk_cache_maybe_insert(arena, node, cache);
 		node = NULL;
 	}
 	if (!committed && chunk_hooks->commit(ret, size, 0, size, arena->ind)) {
-		malloc_mutex_unlock(&arena->chunks_mtx);
-		chunk_record(arena, chunk_hooks, chunks_szad, chunks_ad, cache,
-		    ret, size, zeroed, committed);
+		malloc_mutex_unlock(tsdn, &arena->chunks_mtx);
+		chunk_record(tsdn, arena, chunk_hooks, chunks_szsnad, chunks_ad,
+		    cache, ret, size, *sn, zeroed, committed);
 		return (NULL);
 	}
-	malloc_mutex_unlock(&arena->chunks_mtx);
+	malloc_mutex_unlock(tsdn, &arena->chunks_mtx);
 
 	assert(dalloc_node || node != NULL);
 	if (dalloc_node && node != NULL)
-		arena_node_dalloc(arena, node);
+		arena_node_dalloc(tsdn, arena, node);
 	if (*zero) {
 		if (!zeroed)
 			memset(ret, 0, size);
 		else if (config_debug) {
 			size_t i;
 			size_t *p = (size_t *)(uintptr_t)ret;
 
-			JEMALLOC_VALGRIND_MAKE_MEM_DEFINED(ret, size);
 			for (i = 0; i < size / sizeof(size_t); i++)
 				assert(p[i] == 0);
 		}
+		if (config_valgrind)
+			JEMALLOC_VALGRIND_MAKE_MEM_DEFINED(ret, size);
 	}
 	return (ret);
 }
 
 /*
  * If the caller specifies (!*zero), it is still possible to receive zeroed
  * memory, in which case *zero is toggled to true.  arena_chunk_alloc() takes
  * advantage of this to avoid demanding zeroed chunks, but taking advantage of
  * them if they are returned.
  */
 static void *
-chunk_alloc_core(arena_t *arena, void *new_addr, size_t size, size_t alignment,
-    bool *zero, bool *commit, dss_prec_t dss_prec)
+chunk_alloc_core(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
+    size_t alignment, bool *zero, bool *commit, dss_prec_t dss_prec)
 {
 	void *ret;
-	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
 
 	assert(size != 0);
 	assert((size & chunksize_mask) == 0);
 	assert(alignment != 0);
 	assert((alignment & chunksize_mask) == 0);
 
-	/* Retained. */
-	if ((ret = chunk_recycle(arena, &chunk_hooks,
-	    &arena->chunks_szad_retained, &arena->chunks_ad_retained, false,
-	    new_addr, size, alignment, zero, commit, true)) != NULL)
-		return (ret);
-
 	/* "primary" dss. */
 	if (have_dss && dss_prec == dss_prec_primary && (ret =
-	    chunk_alloc_dss(arena, new_addr, size, alignment, zero, commit)) !=
-	    NULL)
-		return (ret);
-	/*
-	 * mmap.  Requesting an address is not implemented for
-	 * chunk_alloc_mmap(), so only call it if (new_addr == NULL).
-	 */
-	if (new_addr == NULL && (ret = chunk_alloc_mmap(size, alignment, zero,
+	    chunk_alloc_dss(tsdn, arena, new_addr, size, alignment, zero,
 	    commit)) != NULL)
 		return (ret);
+	/* mmap. */
+	if ((ret = chunk_alloc_mmap(new_addr, size, alignment, zero, commit)) !=
+	    NULL)
+		return (ret);
 	/* "secondary" dss. */
 	if (have_dss && dss_prec == dss_prec_secondary && (ret =
-	    chunk_alloc_dss(arena, new_addr, size, alignment, zero, commit)) !=
-	    NULL)
+	    chunk_alloc_dss(tsdn, arena, new_addr, size, alignment, zero,
+	    commit)) != NULL)
 		return (ret);
 
 	/* All strategies for allocation failed. */
 	return (NULL);
 }
 
@@ -377,152 +373,202 @@
 	 * Directly call chunk_alloc_mmap() rather than chunk_alloc_core()
 	 * because it's critical that chunk_alloc_base() return untouched
 	 * demand-zeroed virtual memory.
 	 */
 	zero = true;
 	commit = true;
-	ret = chunk_alloc_mmap(size, chunksize, &zero, &commit);
+	ret = chunk_alloc_mmap(NULL, size, chunksize, &zero, &commit);
 	if (ret == NULL)
 		return (NULL);
 	if (config_valgrind)
 		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
 
 	return (ret);
 }
 
 void *
-chunk_alloc_cache(arena_t *arena, chunk_hooks_t *chunk_hooks, void *new_addr,
-    size_t size, size_t alignment, bool *zero, bool dalloc_node)
+chunk_alloc_cache(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *new_addr, size_t size, size_t alignment, size_t *sn, bool *zero,
+    bool *commit, bool dalloc_node)
 {
 	void *ret;
-	bool commit;
 
 	assert(size != 0);
 	assert((size & chunksize_mask) == 0);
 	assert(alignment != 0);
 	assert((alignment & chunksize_mask) == 0);
 
-	commit = true;
-	ret = chunk_recycle(arena, chunk_hooks, &arena->chunks_szad_cached,
-	    &arena->chunks_ad_cached, true, new_addr, size, alignment, zero,
-	    &commit, dalloc_node);
+	ret = chunk_recycle(tsdn, arena, chunk_hooks,
+	    &arena->chunks_szsnad_cached, &arena->chunks_ad_cached, true,
+	    new_addr, size, alignment, sn, zero, commit, dalloc_node);
 	if (ret == NULL)
 		return (NULL);
-	assert(commit);
 	if (config_valgrind)
 		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
 	return (ret);
 }
 
 static arena_t *
-chunk_arena_get(unsigned arena_ind)
+chunk_arena_get(tsdn_t *tsdn, unsigned arena_ind)
 {
 	arena_t *arena;
 
-	/* Dodge tsd for a0 in order to avoid bootstrapping issues. */
-	arena = (arena_ind == 0) ? a0get() : arena_get(tsd_fetch(), arena_ind,
-	     false, true);
+	arena = arena_get(tsdn, arena_ind, false);
 	/*
 	 * The arena we're allocating on behalf of must have been initialized
 	 * already.
 	 */
 	assert(arena != NULL);
 	return (arena);
 }
 
 static void *
-chunk_alloc_default(void *new_addr, size_t size, size_t alignment, bool *zero,
-    bool *commit, unsigned arena_ind)
+chunk_alloc_default_impl(tsdn_t *tsdn, arena_t *arena, void *new_addr,
+    size_t size, size_t alignment, bool *zero, bool *commit)
 {
 	void *ret;
-	arena_t *arena;
 
-	arena = chunk_arena_get(arena_ind);
-	ret = chunk_alloc_core(arena, new_addr, size, alignment, zero,
+	ret = chunk_alloc_core(tsdn, arena, new_addr, size, alignment, zero,
 	    commit, arena->dss_prec);
 	if (ret == NULL)
 		return (NULL);
 	if (config_valgrind)
 		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, size);
 
 	return (ret);
 }
 
+static void *
+chunk_alloc_default(void *new_addr, size_t size, size_t alignment, bool *zero,
+    bool *commit, unsigned arena_ind)
+{
+	tsdn_t *tsdn;
+	arena_t *arena;
+
+	tsdn = tsdn_fetch();
+	arena = chunk_arena_get(tsdn, arena_ind);
+
+	return (chunk_alloc_default_impl(tsdn, arena, new_addr, size, alignment,
+	    zero, commit));
+}
+
+static void *
+chunk_alloc_retained(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *new_addr, size_t size, size_t alignment, size_t *sn, bool *zero,
+    bool *commit)
+{
+	void *ret;
+
+	assert(size != 0);
+	assert((size & chunksize_mask) == 0);
+	assert(alignment != 0);
+	assert((alignment & chunksize_mask) == 0);
+
+	ret = chunk_recycle(tsdn, arena, chunk_hooks,
+	    &arena->chunks_szsnad_retained, &arena->chunks_ad_retained, false,
+	    new_addr, size, alignment, sn, zero, commit, true);
+
+	if (config_stats && ret != NULL)
+		arena->stats.retained -= size;
+
+	return (ret);
+}
+
 void *
-chunk_alloc_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks, void *new_addr,
-    size_t size, size_t alignment, bool *zero, bool *commit)
+chunk_alloc_wrapper(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *new_addr, size_t size, size_t alignment, size_t *sn, bool *zero,
+    bool *commit)
 {
 	void *ret;
 
-	chunk_hooks_assure_initialized(arena, chunk_hooks);
-	ret = chunk_hooks->alloc(new_addr, size, alignment, zero, commit,
-	    arena->ind);
-	if (ret == NULL)
-		return (NULL);
-	if (config_valgrind && chunk_hooks->alloc != chunk_alloc_default)
-		JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, chunksize);
+	chunk_hooks_assure_initialized(tsdn, arena, chunk_hooks);
+
+	ret = chunk_alloc_retained(tsdn, arena, chunk_hooks, new_addr, size,
+	    alignment, sn, zero, commit);
+	if (ret == NULL) {
+		if (chunk_hooks->alloc == chunk_alloc_default) {
+			/* Call directly to propagate tsdn. */
+			ret = chunk_alloc_default_impl(tsdn, arena, new_addr,
+			    size, alignment, zero, commit);
+		} else {
+			ret = chunk_hooks->alloc(new_addr, size, alignment,
+			    zero, commit, arena->ind);
+		}
+
+		if (ret == NULL)
+			return (NULL);
+
+		*sn = arena_extent_sn_next(arena);
+
+		if (config_valgrind && chunk_hooks->alloc !=
+		    chunk_alloc_default)
+			JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(ret, chunksize);
+	}
+
 	return (ret);
 }
 
 static void
-chunk_record(arena_t *arena, chunk_hooks_t *chunk_hooks,
-    extent_tree_t *chunks_szad, extent_tree_t *chunks_ad, bool cache,
-    void *chunk, size_t size, bool zeroed, bool committed)
+chunk_record(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
+    extent_tree_t *chunks_szsnad, extent_tree_t *chunks_ad, bool cache,
+    void *chunk, size_t size, size_t sn, bool zeroed, bool committed)
 {
 	bool unzeroed;
 	extent_node_t *node, *prev;
 	extent_node_t key;
 
 	assert(!cache || !zeroed);
 	unzeroed = cache || !zeroed;
 	JEMALLOC_VALGRIND_MAKE_MEM_NOACCESS(chunk, size);
 
-	malloc_mutex_lock(&arena->chunks_mtx);
-	chunk_hooks_assure_initialized_locked(arena, chunk_hooks);
-	extent_node_init(&key, arena, (void *)((uintptr_t)chunk + size), 0,
+	malloc_mutex_lock(tsdn, &arena->chunks_mtx);
+	chunk_hooks_assure_initialized_locked(tsdn, arena, chunk_hooks);
+	extent_node_init(&key, arena, (void *)((uintptr_t)chunk + size), 0, 0,
 	    false, false);
 	node = extent_tree_ad_nsearch(chunks_ad, &key);
 	/* Try to coalesce forward. */
 	if (node != NULL && extent_node_addr_get(node) ==
 	    extent_node_addr_get(&key) && extent_node_committed_get(node) ==
 	    committed && !chunk_hooks->merge(chunk, size,
 	    extent_node_addr_get(node), extent_node_size_get(node), false,
 	    arena->ind)) {
 		/*
 		 * Coalesce chunk with the following address range.  This does
 		 * not change the position within chunks_ad, so only
-		 * remove/insert from/into chunks_szad.
+		 * remove/insert from/into chunks_szsnad.
 		 */
-		extent_tree_szad_remove(chunks_szad, node);
+		extent_tree_szsnad_remove(chunks_szsnad, node);
 		arena_chunk_cache_maybe_remove(arena, node, cache);
 		extent_node_addr_set(node, chunk);
 		extent_node_size_set(node, size + extent_node_size_get(node));
+		if (sn < extent_node_sn_get(node))
+			extent_node_sn_set(node, sn);
 		extent_node_zeroed_set(node, extent_node_zeroed_get(node) &&
 		    !unzeroed);
-		extent_tree_szad_insert(chunks_szad, node);
+		extent_tree_szsnad_insert(chunks_szsnad, node);
 		arena_chunk_cache_maybe_insert(arena, node, cache);
 	} else {
 		/* Coalescing forward failed, so insert a new node. */
-		node = arena_node_alloc(arena);
+		node = arena_node_alloc(tsdn, arena);
 		if (node == NULL) {
 			/*
 			 * Node allocation failed, which is an exceedingly
 			 * unlikely failure.  Leak chunk after making sure its
 			 * pages have already been purged, so that this is only
 			 * a virtual memory leak.
 			 */
 			if (cache) {
-				chunk_purge_wrapper(arena, chunk_hooks, chunk,
-				    size, 0, size);
+				chunk_purge_wrapper(tsdn, arena, chunk_hooks,
+				    chunk, size, 0, size);
 			}
 			goto label_return;
 		}
-		extent_node_init(node, arena, chunk, size, !unzeroed,
+		extent_node_init(node, arena, chunk, size, sn, !unzeroed,
 		    committed);
 		extent_tree_ad_insert(chunks_ad, node);
-		extent_tree_szad_insert(chunks_szad, node);
+		extent_tree_szsnad_insert(chunks_szsnad, node);
 		arena_chunk_cache_maybe_insert(arena, node, cache);
 	}
 
 	/* Try to coalesce backward. */
 	prev = extent_tree_ad_prev(chunks_ad, node);
 	if (prev != NULL && (void *)((uintptr_t)extent_node_addr_get(prev) +
@@ -530,93 +576,103 @@
 	    extent_node_committed_get(prev) == committed &&
 	    !chunk_hooks->merge(extent_node_addr_get(prev),
 	    extent_node_size_get(prev), chunk, size, false, arena->ind)) {
 		/*
 		 * Coalesce chunk with the previous address range.  This does
 		 * not change the position within chunks_ad, so only
-		 * remove/insert node from/into chunks_szad.
+		 * remove/insert node from/into chunks_szsnad.
 		 */
-		extent_tree_szad_remove(chunks_szad, prev);
+		extent_tree_szsnad_remove(chunks_szsnad, prev);
 		extent_tree_ad_remove(chunks_ad, prev);
 		arena_chunk_cache_maybe_remove(arena, prev, cache);
-		extent_tree_szad_remove(chunks_szad, node);
+		extent_tree_szsnad_remove(chunks_szsnad, node);
 		arena_chunk_cache_maybe_remove(arena, node, cache);
 		extent_node_addr_set(node, extent_node_addr_get(prev));
 		extent_node_size_set(node, extent_node_size_get(prev) +
 		    extent_node_size_get(node));
+		if (extent_node_sn_get(prev) < extent_node_sn_get(node))
+			extent_node_sn_set(node, extent_node_sn_get(prev));
 		extent_node_zeroed_set(node, extent_node_zeroed_get(prev) &&
 		    extent_node_zeroed_get(node));
-		extent_tree_szad_insert(chunks_szad, node);
+		extent_tree_szsnad_insert(chunks_szsnad, node);
 		arena_chunk_cache_maybe_insert(arena, node, cache);
 
-		arena_node_dalloc(arena, prev);
+		arena_node_dalloc(tsdn, arena, prev);
 	}
 
 label_return:
-	malloc_mutex_unlock(&arena->chunks_mtx);
+	malloc_mutex_unlock(tsdn, &arena->chunks_mtx);
 }
 
 void
-chunk_dalloc_cache(arena_t *arena, chunk_hooks_t *chunk_hooks, void *chunk,
-    size_t size, bool committed)
+chunk_dalloc_cache(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *chunk, size_t size, size_t sn, bool committed)
 {
 
 	assert(chunk != NULL);
 	assert(CHUNK_ADDR2BASE(chunk) == chunk);
 	assert(size != 0);
 	assert((size & chunksize_mask) == 0);
 
-	chunk_record(arena, chunk_hooks, &arena->chunks_szad_cached,
-	    &arena->chunks_ad_cached, true, chunk, size, false, committed);
-	arena_maybe_purge(arena);
+	chunk_record(tsdn, arena, chunk_hooks, &arena->chunks_szsnad_cached,
+	    &arena->chunks_ad_cached, true, chunk, size, sn, false,
+	    committed);
+	arena_maybe_purge(tsdn, arena);
+}
+
+static bool
+chunk_dalloc_default_impl(void *chunk, size_t size)
+{
+
+	if (!have_dss || !chunk_in_dss(chunk))
+		return (chunk_dalloc_mmap(chunk, size));
+	return (true);
+}
+
+static bool
+chunk_dalloc_default(void *chunk, size_t size, bool committed,
+    unsigned arena_ind)
+{
+
+	return (chunk_dalloc_default_impl(chunk, size));
 }
 
 void
-chunk_dalloc_arena(arena_t *arena, chunk_hooks_t *chunk_hooks, void *chunk,
-    size_t size, bool zeroed, bool committed)
+chunk_dalloc_wrapper(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *chunk, size_t size, size_t sn, bool zeroed, bool committed)
 {
+	bool err;
 
 	assert(chunk != NULL);
 	assert(CHUNK_ADDR2BASE(chunk) == chunk);
 	assert(size != 0);
 	assert((size & chunksize_mask) == 0);
 
-	chunk_hooks_assure_initialized(arena, chunk_hooks);
+	chunk_hooks_assure_initialized(tsdn, arena, chunk_hooks);
 	/* Try to deallocate. */
-	if (!chunk_hooks->dalloc(chunk, size, committed, arena->ind))
+	if (chunk_hooks->dalloc == chunk_dalloc_default) {
+		/* Call directly to propagate tsdn. */
+		err = chunk_dalloc_default_impl(chunk, size);
+	} else
+		err = chunk_hooks->dalloc(chunk, size, committed, arena->ind);
+
+	if (!err)
 		return;
 	/* Try to decommit; purge if that fails. */
 	if (committed) {
 		committed = chunk_hooks->decommit(chunk, size, 0, size,
 		    arena->ind);
 	}
 	zeroed = !committed || !chunk_hooks->purge(chunk, size, 0, size,
 	    arena->ind);
-	chunk_record(arena, chunk_hooks, &arena->chunks_szad_retained,
-	    &arena->chunks_ad_retained, false, chunk, size, zeroed, committed);
-}
-
-static bool
-chunk_dalloc_default(void *chunk, size_t size, bool committed,
-    unsigned arena_ind)
-{
+	chunk_record(tsdn, arena, chunk_hooks, &arena->chunks_szsnad_retained,
+	    &arena->chunks_ad_retained, false, chunk, size, sn, zeroed,
+	    committed);
 
-	if (!have_dss || !chunk_in_dss(chunk))
-		return (chunk_dalloc_mmap(chunk, size));
-	return (true);
-}
-
-void
-chunk_dalloc_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks, void *chunk,
-    size_t size, bool committed)
-{
-
-	chunk_hooks_assure_initialized(arena, chunk_hooks);
-	chunk_hooks->dalloc(chunk, size, committed, arena->ind);
-	if (config_valgrind && chunk_hooks->dalloc != chunk_dalloc_default)
-		JEMALLOC_VALGRIND_MAKE_MEM_NOACCESS(chunk, size);
+	if (config_stats)
+		arena->stats.retained += size;
 }
 
 static bool
 chunk_commit_default(void *chunk, size_t size, size_t offset, size_t length,
     unsigned arena_ind)
 {
@@ -631,41 +687,33 @@
 {
 
 	return (pages_decommit((void *)((uintptr_t)chunk + (uintptr_t)offset),
 	    length));
 }
 
-bool
-chunk_purge_arena(arena_t *arena, void *chunk, size_t offset, size_t length)
+static bool
+chunk_purge_default(void *chunk, size_t size, size_t offset, size_t length,
+    unsigned arena_ind)
 {
 
 	assert(chunk != NULL);
 	assert(CHUNK_ADDR2BASE(chunk) == chunk);
 	assert((offset & PAGE_MASK) == 0);
 	assert(length != 0);
 	assert((length & PAGE_MASK) == 0);
 
 	return (pages_purge((void *)((uintptr_t)chunk + (uintptr_t)offset),
 	    length));
 }
 
-static bool
-chunk_purge_default(void *chunk, size_t size, size_t offset, size_t length,
-    unsigned arena_ind)
-{
-
-	return (chunk_purge_arena(chunk_arena_get(arena_ind), chunk, offset,
-	    length));
-}
-
 bool
-chunk_purge_wrapper(arena_t *arena, chunk_hooks_t *chunk_hooks, void *chunk,
-    size_t size, size_t offset, size_t length)
+chunk_purge_wrapper(tsdn_t *tsdn, arena_t *arena, chunk_hooks_t *chunk_hooks,
+    void *chunk, size_t size, size_t offset, size_t length)
 {
 
-	chunk_hooks_assure_initialized(arena, chunk_hooks);
+	chunk_hooks_assure_initialized(tsdn, arena, chunk_hooks);
 	return (chunk_hooks->purge(chunk, size, offset, length, arena->ind));
 }
 
 static bool
 chunk_split_default(void *chunk, size_t size, size_t size_a, size_t size_b,
     bool committed, unsigned arena_ind)
@@ -674,29 +722,36 @@
 	if (!maps_coalesce)
 		return (true);
 	return (false);
 }
 
 static bool
-chunk_merge_default(void *chunk_a, size_t size_a, void *chunk_b, size_t size_b,
-    bool committed, unsigned arena_ind)
+chunk_merge_default_impl(void *chunk_a, void *chunk_b)
 {
 
 	if (!maps_coalesce)
 		return (true);
-	if (have_dss && chunk_in_dss(chunk_a) != chunk_in_dss(chunk_b))
+	if (have_dss && !chunk_dss_mergeable(chunk_a, chunk_b))
 		return (true);
 
 	return (false);
 }
 
+static bool
+chunk_merge_default(void *chunk_a, size_t size_a, void *chunk_b, size_t size_b,
+    bool committed, unsigned arena_ind)
+{
+
+	return (chunk_merge_default_impl(chunk_a, chunk_b));
+}
+
 static rtree_node_elm_t *
 chunks_rtree_node_alloc(size_t nelms)
 {
 
-	return ((rtree_node_elm_t *)base_alloc(nelms *
+	return ((rtree_node_elm_t *)base_alloc(TSDN_NULL, nelms *
 	    sizeof(rtree_node_elm_t)));
 }
 
 bool
 chunk_boot(void)
 {
@@ -713,13 +768,13 @@
 
 	/*
 	 * Configure chunksize (if not set) to match granularity (usually 64K),
 	 * so pages_map will always take fast path.
 	 */
 	if (!opt_lg_chunk) {
-		opt_lg_chunk = jemalloc_ffs((int)info.dwAllocationGranularity)
+		opt_lg_chunk = ffs_u((unsigned)info.dwAllocationGranularity)
 		    - 1;
 	}
 #else
 	if (!opt_lg_chunk)
 		opt_lg_chunk = LG_CHUNK_DEFAULT;
 #endif
@@ -727,35 +782,14 @@
 	/* Set variables according to the value of opt_lg_chunk. */
 	chunksize = (ZU(1) << opt_lg_chunk);
 	assert(chunksize >= PAGE);
 	chunksize_mask = chunksize - 1;
 	chunk_npages = (chunksize >> LG_PAGE);
 
-	if (have_dss && chunk_dss_boot())
-		return (true);
-	if (rtree_new(&chunks_rtree, (ZU(1) << (LG_SIZEOF_PTR+3)) -
-	    opt_lg_chunk, chunks_rtree_node_alloc, NULL))
+	if (have_dss)
+		chunk_dss_boot();
+	if (rtree_new(&chunks_rtree, (unsigned)((ZU(1) << (LG_SIZEOF_PTR+3)) -
+	    opt_lg_chunk), chunks_rtree_node_alloc, NULL))
 		return (true);
 
 	return (false);
 }
-
-void
-chunk_prefork(void)
-{
-
-	chunk_dss_prefork();
-}
-
-void
-chunk_postfork_parent(void)
-{
-
-	chunk_dss_postfork_parent();
-}
-
-void
-chunk_postfork_child(void)
-{
-
-	chunk_dss_postfork_child();
-}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.d	2017-09-27 23:00:21.186936062 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.d	2017-09-27 23:01:56.654932563 +0800
@@ -1,18 +1,21 @@
 src/chunk.o: src/chunk.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.c	2017-01-31 23:32:23.000000000 +0800
@@ -7,26 +7,25 @@
 	"disabled",
 	"primary",
 	"secondary",
 	"N/A"
 };
 
-/* Current dss precedence default, used when creating new arenas. */
-static dss_prec_t	dss_prec_default = DSS_PREC_DEFAULT;
-
 /*
- * Protects sbrk() calls.  This avoids malloc races among threads, though it
- * does not protect against races with threads that call sbrk() directly.
+ * Current dss precedence default, used when creating new arenas.  NB: This is
+ * stored as unsigned rather than dss_prec_t because in principle there's no
+ * guarantee that sizeof(dss_prec_t) is the same as sizeof(unsigned), and we use
+ * atomic operations to synchronize the setting.
  */
-static malloc_mutex_t	dss_mtx;
+static unsigned		dss_prec_default = (unsigned)DSS_PREC_DEFAULT;
 
 /* Base address of the DSS. */
 static void		*dss_base;
-/* Current end of the DSS, or ((void *)-1) if the DSS is exhausted. */
-static void		*dss_prev;
-/* Current upper limit on DSS addresses. */
+/* Atomic boolean indicating whether the DSS is exhausted. */
+static unsigned		dss_exhausted;
+/* Atomic current upper limit on DSS addresses. */
 static void		*dss_max;
 
 /******************************************************************************/
 
 static void *
 chunk_dss_sbrk(intptr_t increment)
@@ -44,67 +43,88 @@
 chunk_dss_prec_get(void)
 {
 	dss_prec_t ret;
 
 	if (!have_dss)
 		return (dss_prec_disabled);
-	malloc_mutex_lock(&dss_mtx);
-	ret = dss_prec_default;
-	malloc_mutex_unlock(&dss_mtx);
+	ret = (dss_prec_t)atomic_read_u(&dss_prec_default);
 	return (ret);
 }
 
 bool
 chunk_dss_prec_set(dss_prec_t dss_prec)
 {
 
 	if (!have_dss)
 		return (dss_prec != dss_prec_disabled);
-	malloc_mutex_lock(&dss_mtx);
-	dss_prec_default = dss_prec;
-	malloc_mutex_unlock(&dss_mtx);
+	atomic_write_u(&dss_prec_default, (unsigned)dss_prec);
 	return (false);
 }
 
+static void *
+chunk_dss_max_update(void *new_addr)
+{
+	void *max_cur;
+	spin_t spinner;
+
+	/*
+	 * Get the current end of the DSS as max_cur and assure that dss_max is
+	 * up to date.
+	 */
+	spin_init(&spinner);
+	while (true) {
+		void *max_prev = atomic_read_p(&dss_max);
+
+		max_cur = chunk_dss_sbrk(0);
+		if ((uintptr_t)max_prev > (uintptr_t)max_cur) {
+			/*
+			 * Another thread optimistically updated dss_max.  Wait
+			 * for it to finish.
+			 */
+			spin_adaptive(&spinner);
+			continue;
+		}
+		if (!atomic_cas_p(&dss_max, max_prev, max_cur))
+			break;
+	}
+	/* Fixed new_addr can only be supported if it is at the edge of DSS. */
+	if (new_addr != NULL && max_cur != new_addr)
+		return (NULL);
+
+	return (max_cur);
+}
+
 void *
-chunk_alloc_dss(arena_t *arena, void *new_addr, size_t size, size_t alignment,
-    bool *zero, bool *commit)
+chunk_alloc_dss(tsdn_t *tsdn, arena_t *arena, void *new_addr, size_t size,
+    size_t alignment, bool *zero, bool *commit)
 {
 	cassert(have_dss);
 	assert(size > 0 && (size & chunksize_mask) == 0);
 	assert(alignment > 0 && (alignment & chunksize_mask) == 0);
 
 	/*
 	 * sbrk() uses a signed increment argument, so take care not to
 	 * interpret a huge allocation request as a negative increment.
 	 */
 	if ((intptr_t)size < 0)
 		return (NULL);
 
-	malloc_mutex_lock(&dss_mtx);
-	if (dss_prev != (void *)-1) {
-
+	if (!atomic_read_u(&dss_exhausted)) {
 		/*
 		 * The loop is necessary to recover from races with other
 		 * threads that are using the DSS for something other than
 		 * malloc.
 		 */
-		do {
-			void *ret, *cpad, *dss_next;
+		while (true) {
+			void *ret, *cpad, *max_cur, *dss_next, *dss_prev;
 			size_t gap_size, cpad_size;
 			intptr_t incr;
-			/* Avoid an unnecessary system call. */
-			if (new_addr != NULL && dss_max != new_addr)
-				break;
-
-			/* Get the current end of the DSS. */
-			dss_max = chunk_dss_sbrk(0);
-
-			/* Make sure the earlier condition still holds. */
-			if (new_addr != NULL && dss_max != new_addr)
-				break;
+
+			max_cur = chunk_dss_max_update(new_addr);
+			if (max_cur == NULL)
+				goto label_oom;
 
 			/*
 			 * Calculate how much padding is necessary to
 			 * chunk-align the end of the DSS.
 			 */
 			gap_size = (chunksize - CHUNK_ADDR2OFFSET(dss_max)) &
@@ -117,98 +137,102 @@
 			cpad = (void *)((uintptr_t)dss_max + gap_size);
 			ret = (void *)ALIGNMENT_CEILING((uintptr_t)dss_max,
 			    alignment);
 			cpad_size = (uintptr_t)ret - (uintptr_t)cpad;
 			dss_next = (void *)((uintptr_t)ret + size);
 			if ((uintptr_t)ret < (uintptr_t)dss_max ||
-			    (uintptr_t)dss_next < (uintptr_t)dss_max) {
-				/* Wrap-around. */
-				malloc_mutex_unlock(&dss_mtx);
-				return (NULL);
-			}
+			    (uintptr_t)dss_next < (uintptr_t)dss_max)
+				goto label_oom; /* Wrap-around. */
 			incr = gap_size + cpad_size + size;
+
+			/*
+			 * Optimistically update dss_max, and roll back below if
+			 * sbrk() fails.  No other thread will try to extend the
+			 * DSS while dss_max is greater than the current DSS
+			 * max reported by sbrk(0).
+			 */
+			if (atomic_cas_p(&dss_max, max_cur, dss_next))
+				continue;
+
+			/* Try to allocate. */
 			dss_prev = chunk_dss_sbrk(incr);
-			if (dss_prev == dss_max) {
+			if (dss_prev == max_cur) {
 				/* Success. */
-				dss_max = dss_next;
-				malloc_mutex_unlock(&dss_mtx);
 				if (cpad_size != 0) {
 					chunk_hooks_t chunk_hooks =
 					    CHUNK_HOOKS_INITIALIZER;
-					chunk_dalloc_wrapper(arena,
+					chunk_dalloc_wrapper(tsdn, arena,
 					    &chunk_hooks, cpad, cpad_size,
+					    arena_extent_sn_next(arena), false,
 					    true);
 				}
 				if (*zero) {
 					JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED(
 					    ret, size);
 					memset(ret, 0, size);
 				}
 				if (!*commit)
 					*commit = pages_decommit(ret, size);
 				return (ret);
 			}
-		} while (dss_prev != (void *)-1);
-	}
-	malloc_mutex_unlock(&dss_mtx);
 
+			/*
+			 * Failure, whether due to OOM or a race with a raw
+			 * sbrk() call from outside the allocator.  Try to roll
+			 * back optimistic dss_max update; if rollback fails,
+			 * it's due to another caller of this function having
+			 * succeeded since this invocation started, in which
+			 * case rollback is not necessary.
+			 */
+			atomic_cas_p(&dss_max, dss_next, max_cur);
+			if (dss_prev == (void *)-1) {
+				/* OOM. */
+				atomic_write_u(&dss_exhausted, (unsigned)true);
+				goto label_oom;
+			}
+		}
+	}
+label_oom:
 	return (NULL);
 }
 
-bool
-chunk_in_dss(void *chunk)
+static bool
+chunk_in_dss_helper(void *chunk, void *max)
 {
-	bool ret;
 
-	cassert(have_dss);
-
-	malloc_mutex_lock(&dss_mtx);
-	if ((uintptr_t)chunk >= (uintptr_t)dss_base
-	    && (uintptr_t)chunk < (uintptr_t)dss_max)
-		ret = true;
-	else
-		ret = false;
-	malloc_mutex_unlock(&dss_mtx);
-
-	return (ret);
+	return ((uintptr_t)chunk >= (uintptr_t)dss_base && (uintptr_t)chunk <
+	    (uintptr_t)max);
 }
 
 bool
-chunk_dss_boot(void)
+chunk_in_dss(void *chunk)
 {
 
 	cassert(have_dss);
 
-	if (malloc_mutex_init(&dss_mtx))
-		return (true);
-	dss_base = chunk_dss_sbrk(0);
-	dss_prev = dss_base;
-	dss_max = dss_base;
-
-	return (false);
+	return (chunk_in_dss_helper(chunk, atomic_read_p(&dss_max)));
 }
 
-void
-chunk_dss_prefork(void)
+bool
+chunk_dss_mergeable(void *chunk_a, void *chunk_b)
 {
+	void *max;
 
-	if (have_dss)
-		malloc_mutex_prefork(&dss_mtx);
-}
-
-void
-chunk_dss_postfork_parent(void)
-{
+	cassert(have_dss);
 
-	if (have_dss)
-		malloc_mutex_postfork_parent(&dss_mtx);
+	max = atomic_read_p(&dss_max);
+	return (chunk_in_dss_helper(chunk_a, max) ==
+	    chunk_in_dss_helper(chunk_b, max));
 }
 
 void
-chunk_dss_postfork_child(void)
+chunk_dss_boot(void)
 {
 
-	if (have_dss)
-		malloc_mutex_postfork_child(&dss_mtx);
+	cassert(have_dss);
+
+	dss_base = chunk_dss_sbrk(0);
+	dss_exhausted = (unsigned)(dss_base == (void *)-1);
+	dss_max = dss_base;
 }
 
 /******************************************************************************/
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.d	2017-09-27 23:00:21.306936057 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.d	2017-09-27 23:01:56.782932558 +0800
@@ -1,19 +1,22 @@
 src/chunk_dss.o: src/chunk_dss.c \
  include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.c	2017-01-31 23:32:23.000000000 +0800
@@ -13,29 +13,28 @@
 	/* Beware size_t wrap-around. */
 	if (alloc_size < size)
 		return (NULL);
 	do {
 		void *pages;
 		size_t leadsize;
-		pages = pages_map(NULL, alloc_size);
+		pages = pages_map(NULL, alloc_size, commit);
 		if (pages == NULL)
 			return (NULL);
 		leadsize = ALIGNMENT_CEILING((uintptr_t)pages, alignment) -
 		    (uintptr_t)pages;
-		ret = pages_trim(pages, alloc_size, leadsize, size);
+		ret = pages_trim(pages, alloc_size, leadsize, size, commit);
 	} while (ret == NULL);
 
 	assert(ret != NULL);
 	*zero = true;
-	if (!*commit)
-		*commit = pages_decommit(ret, size);
 	return (ret);
 }
 
 void *
-chunk_alloc_mmap(size_t size, size_t alignment, bool *zero, bool *commit)
+chunk_alloc_mmap(void *new_addr, size_t size, size_t alignment, bool *zero,
+    bool *commit)
 {
 	void *ret;
 	size_t offset;
 
 	/*
 	 * Ideally, there would be a way to specify alignment to mmap() (like
@@ -50,25 +49,24 @@
 	 * approach works most of the time.
 	 */
 
 	assert(alignment != 0);
 	assert((alignment & chunksize_mask) == 0);
 
-	ret = pages_map(NULL, size);
-	if (ret == NULL)
-		return (NULL);
+	ret = pages_map(new_addr, size, commit);
+	if (ret == NULL || ret == new_addr)
+		return (ret);
+	assert(new_addr == NULL);
 	offset = ALIGNMENT_ADDR2OFFSET(ret, alignment);
 	if (offset != 0) {
 		pages_unmap(ret, size);
 		return (chunk_alloc_mmap_slow(size, alignment, zero, commit));
 	}
 
 	assert(ret != NULL);
 	*zero = true;
-	if (!*commit)
-		*commit = pages_decommit(ret, size);
 	return (ret);
 }
 
 bool
 chunk_dalloc_mmap(void *chunk, size_t size)
 {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.d	2017-09-27 23:00:21.410936053 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.d	2017-09-27 23:01:56.894932554 +0800
@@ -1,19 +1,22 @@
 src/chunk_mmap.o: src/chunk_mmap.c \
  include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.c	2017-01-31 23:32:23.000000000 +0800
@@ -96,13 +96,14 @@
 	unsigned offset, i;
 
 	/*
 	 * Cycle through the cells in the bucket, starting at a random position.
 	 * The randomness avoids worst-case search overhead as buckets fill up.
 	 */
-	prng32(offset, LG_CKH_BUCKET_CELLS, ckh->prng_state, CKH_A, CKH_C);
+	offset = (unsigned)prng_lg_range_u64(&ckh->prng_state,
+	    LG_CKH_BUCKET_CELLS);
 	for (i = 0; i < (ZU(1) << LG_CKH_BUCKET_CELLS); i++) {
 		cell = &ckh->tab[(bucket << LG_CKH_BUCKET_CELLS) +
 		    ((i + offset) & ((ZU(1) << LG_CKH_BUCKET_CELLS) - 1))];
 		if (cell->key == NULL) {
 			cell->key = key;
 			cell->data = data;
@@ -138,13 +139,14 @@
 		 * critical to correct function, because without (eventually)
 		 * evicting all items within a bucket during iteration, it
 		 * would be possible to get stuck in an infinite loop if there
 		 * were an item for which both hashes indicated the same
 		 * bucket.
 		 */
-		prng32(i, LG_CKH_BUCKET_CELLS, ckh->prng_state, CKH_A, CKH_C);
+		i = (unsigned)prng_lg_range_u64(&ckh->prng_state,
+		    LG_CKH_BUCKET_CELLS);
 		cell = &ckh->tab[(bucket << LG_CKH_BUCKET_CELLS) + i];
 		assert(cell->key != NULL);
 
 		/* Swap cell->{key,data} and {key,data} (evict). */
 		tkey = cell->key; tdata = cell->data;
 		cell->key = key; cell->data = data;
@@ -244,14 +246,13 @@
 
 static bool
 ckh_grow(tsd_t *tsd, ckh_t *ckh)
 {
 	bool ret;
 	ckhc_t *tab, *ttab;
-	size_t lg_curcells;
-	unsigned lg_prevbuckets;
+	unsigned lg_prevbuckets, lg_curcells;
 
 #ifdef CKH_COUNT
 	ckh->ngrows++;
 #endif
 
 	/*
@@ -263,35 +264,35 @@
 	lg_curcells = ckh->lg_curbuckets + LG_CKH_BUCKET_CELLS;
 	while (true) {
 		size_t usize;
 
 		lg_curcells++;
 		usize = sa2u(sizeof(ckhc_t) << lg_curcells, CACHELINE);
-		if (usize == 0) {
+		if (unlikely(usize == 0 || usize > HUGE_MAXCLASS)) {
 			ret = true;
 			goto label_return;
 		}
-		tab = (ckhc_t *)ipallocztm(tsd, usize, CACHELINE, true, NULL,
-		    true, NULL);
+		tab = (ckhc_t *)ipallocztm(tsd_tsdn(tsd), usize, CACHELINE,
+		    true, NULL, true, arena_ichoose(tsd, NULL));
 		if (tab == NULL) {
 			ret = true;
 			goto label_return;
 		}
 		/* Swap in new table. */
 		ttab = ckh->tab;
 		ckh->tab = tab;
 		tab = ttab;
 		ckh->lg_curbuckets = lg_curcells - LG_CKH_BUCKET_CELLS;
 
 		if (!ckh_rebuild(ckh, tab)) {
-			idalloctm(tsd, tab, tcache_get(tsd, false), true);
+			idalloctm(tsd_tsdn(tsd), tab, NULL, true, true);
 			break;
 		}
 
 		/* Rebuilding failed, so back out partially rebuilt table. */
-		idalloctm(tsd, ckh->tab, tcache_get(tsd, false), true);
+		idalloctm(tsd_tsdn(tsd), ckh->tab, NULL, true, true);
 		ckh->tab = tab;
 		ckh->lg_curbuckets = lg_prevbuckets;
 	}
 
 	ret = false;
 label_return:
@@ -299,26 +300,26 @@
 }
 
 static void
 ckh_shrink(tsd_t *tsd, ckh_t *ckh)
 {
 	ckhc_t *tab, *ttab;
-	size_t lg_curcells, usize;
-	unsigned lg_prevbuckets;
+	size_t usize;
+	unsigned lg_prevbuckets, lg_curcells;
 
 	/*
 	 * It is possible (though unlikely, given well behaved hashes) that the
 	 * table rebuild will fail.
 	 */
 	lg_prevbuckets = ckh->lg_curbuckets;
 	lg_curcells = ckh->lg_curbuckets + LG_CKH_BUCKET_CELLS - 1;
 	usize = sa2u(sizeof(ckhc_t) << lg_curcells, CACHELINE);
-	if (usize == 0)
+	if (unlikely(usize == 0 || usize > HUGE_MAXCLASS))
 		return;
-	tab = (ckhc_t *)ipallocztm(tsd, usize, CACHELINE, true, NULL, true,
-	    NULL);
+	tab = (ckhc_t *)ipallocztm(tsd_tsdn(tsd), usize, CACHELINE, true, NULL,
+	    true, arena_ichoose(tsd, NULL));
 	if (tab == NULL) {
 		/*
 		 * An OOM error isn't worth propagating, since it doesn't
 		 * prevent this or future operations from proceeding.
 		 */
 		return;
@@ -327,21 +328,21 @@
 	ttab = ckh->tab;
 	ckh->tab = tab;
 	tab = ttab;
 	ckh->lg_curbuckets = lg_curcells - LG_CKH_BUCKET_CELLS;
 
 	if (!ckh_rebuild(ckh, tab)) {
-		idalloctm(tsd, tab, tcache_get(tsd, false), true);
+		idalloctm(tsd_tsdn(tsd), tab, NULL, true, true);
 #ifdef CKH_COUNT
 		ckh->nshrinks++;
 #endif
 		return;
 	}
 
 	/* Rebuilding failed, so back out partially rebuilt table. */
-	idalloctm(tsd, ckh->tab, tcache_get(tsd, false), true);
+	idalloctm(tsd_tsdn(tsd), ckh->tab, NULL, true, true);
 	ckh->tab = tab;
 	ckh->lg_curbuckets = lg_prevbuckets;
 #ifdef CKH_COUNT
 	ckh->nshrinkfails++;
 #endif
 }
@@ -384,18 +385,18 @@
 	ckh->lg_minbuckets = lg_mincells - LG_CKH_BUCKET_CELLS;
 	ckh->lg_curbuckets = lg_mincells - LG_CKH_BUCKET_CELLS;
 	ckh->hash = hash;
 	ckh->keycomp = keycomp;
 
 	usize = sa2u(sizeof(ckhc_t) << lg_mincells, CACHELINE);
-	if (usize == 0) {
+	if (unlikely(usize == 0 || usize > HUGE_MAXCLASS)) {
 		ret = true;
 		goto label_return;
 	}
-	ckh->tab = (ckhc_t *)ipallocztm(tsd, usize, CACHELINE, true, NULL, true,
-	    NULL);
+	ckh->tab = (ckhc_t *)ipallocztm(tsd_tsdn(tsd), usize, CACHELINE, true,
+	    NULL, true, arena_ichoose(tsd, NULL));
 	if (ckh->tab == NULL) {
 		ret = true;
 		goto label_return;
 	}
 
 	ret = false;
@@ -418,15 +419,15 @@
 	    (unsigned long long)ckh->nshrinks,
 	    (unsigned long long)ckh->nshrinkfails,
 	    (unsigned long long)ckh->ninserts,
 	    (unsigned long long)ckh->nrelocs);
 #endif
 
-	idalloctm(tsd, ckh->tab, tcache_get(tsd, false), true);
+	idalloctm(tsd_tsdn(tsd), ckh->tab, NULL, true, true);
 	if (config_debug)
-		memset(ckh, 0x5a, sizeof(ckh_t));
+		memset(ckh, JEMALLOC_FREE_JUNK, sizeof(ckh_t));
 }
 
 size_t
 ckh_count(ckh_t *ckh)
 {
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.d	2017-09-27 23:00:21.830936038 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.d	2017-09-27 23:01:57.286932540 +0800
@@ -1,18 +1,21 @@
 src/ckh.o: src/ckh.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.c	2017-01-31 23:32:23.000000000 +0800
@@ -21,13 +21,13 @@
 {
 
 	return ((node->named) ? (const ctl_named_node_t *)node : NULL);
 }
 
 JEMALLOC_INLINE_C const ctl_named_node_t *
-ctl_named_children(const ctl_named_node_t *node, int index)
+ctl_named_children(const ctl_named_node_t *node, size_t index)
 {
 	const ctl_named_node_t *children = ctl_named_node(node->children);
 
 	return (children ? &children[index] : NULL);
 }
 
@@ -39,31 +39,31 @@
 }
 
 /******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
 #define	CTL_PROTO(n)							\
-static int	n##_ctl(const size_t *mib, size_t miblen, void *oldp,	\
-    size_t *oldlenp, void *newp, size_t newlen);
+static int	n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,	\
+    void *oldp, size_t *oldlenp, void *newp, size_t newlen);
 
 #define	INDEX_PROTO(n)							\
-static const ctl_named_node_t	*n##_index(const size_t *mib,		\
-    size_t miblen, size_t i);
+static const ctl_named_node_t	*n##_index(tsdn_t *tsdn,		\
+    const size_t *mib, size_t miblen, size_t i);
 
 static bool	ctl_arena_init(ctl_arena_stats_t *astats);
 static void	ctl_arena_clear(ctl_arena_stats_t *astats);
-static void	ctl_arena_stats_amerge(ctl_arena_stats_t *cstats,
+static void	ctl_arena_stats_amerge(tsdn_t *tsdn, ctl_arena_stats_t *cstats,
     arena_t *arena);
 static void	ctl_arena_stats_smerge(ctl_arena_stats_t *sstats,
     ctl_arena_stats_t *astats);
-static void	ctl_arena_refresh(arena_t *arena, unsigned i);
-static bool	ctl_grow(void);
-static void	ctl_refresh(void);
-static bool	ctl_init(void);
-static int	ctl_lookup(const char *name, ctl_node_t const **nodesp,
-    size_t *mibp, size_t *depthp);
+static void	ctl_arena_refresh(tsdn_t *tsdn, arena_t *arena, unsigned i);
+static bool	ctl_grow(tsdn_t *tsdn);
+static void	ctl_refresh(tsdn_t *tsdn);
+static bool	ctl_init(tsdn_t *tsdn);
+static int	ctl_lookup(tsdn_t *tsdn, const char *name,
+    ctl_node_t const **nodesp, size_t *mibp, size_t *depthp);
 
 CTL_PROTO(version)
 CTL_PROTO(epoch)
 CTL_PROTO(thread_tcache_enabled)
 CTL_PROTO(thread_tcache_flush)
 CTL_PROTO(thread_prof_name)
@@ -74,12 +74,13 @@
 CTL_PROTO(thread_deallocated)
 CTL_PROTO(thread_deallocatedp)
 CTL_PROTO(config_cache_oblivious)
 CTL_PROTO(config_debug)
 CTL_PROTO(config_fill)
 CTL_PROTO(config_lazy_lock)
+CTL_PROTO(config_malloc_conf)
 CTL_PROTO(config_munmap)
 CTL_PROTO(config_prof)
 CTL_PROTO(config_prof_libgcc)
 CTL_PROTO(config_prof_libunwind)
 CTL_PROTO(config_stats)
 CTL_PROTO(config_tcache)
@@ -88,13 +89,15 @@
 CTL_PROTO(config_valgrind)
 CTL_PROTO(config_xmalloc)
 CTL_PROTO(opt_abort)
 CTL_PROTO(opt_dss)
 CTL_PROTO(opt_lg_chunk)
 CTL_PROTO(opt_narenas)
+CTL_PROTO(opt_purge)
 CTL_PROTO(opt_lg_dirty_mult)
+CTL_PROTO(opt_decay_time)
 CTL_PROTO(opt_stats_print)
 CTL_PROTO(opt_junk)
 CTL_PROTO(opt_zero)
 CTL_PROTO(opt_quarantine)
 CTL_PROTO(opt_redzone)
 CTL_PROTO(opt_utrace)
@@ -111,16 +114,19 @@
 CTL_PROTO(opt_prof_final)
 CTL_PROTO(opt_prof_leak)
 CTL_PROTO(opt_prof_accum)
 CTL_PROTO(tcache_create)
 CTL_PROTO(tcache_flush)
 CTL_PROTO(tcache_destroy)
+static void	arena_i_purge(tsdn_t *tsdn, unsigned arena_ind, bool all);
 CTL_PROTO(arena_i_purge)
-static void	arena_purge(unsigned arena_ind);
+CTL_PROTO(arena_i_decay)
+CTL_PROTO(arena_i_reset)
 CTL_PROTO(arena_i_dss)
 CTL_PROTO(arena_i_lg_dirty_mult)
+CTL_PROTO(arena_i_decay_time)
 CTL_PROTO(arena_i_chunk_hooks)
 INDEX_PROTO(arena_i)
 CTL_PROTO(arenas_bin_i_size)
 CTL_PROTO(arenas_bin_i_nregs)
 CTL_PROTO(arenas_bin_i_run_size)
 INDEX_PROTO(arenas_bin_i)
@@ -128,12 +134,13 @@
 INDEX_PROTO(arenas_lrun_i)
 CTL_PROTO(arenas_hchunk_i_size)
 INDEX_PROTO(arenas_hchunk_i)
 CTL_PROTO(arenas_narenas)
 CTL_PROTO(arenas_initialized)
 CTL_PROTO(arenas_lg_dirty_mult)
+CTL_PROTO(arenas_decay_time)
 CTL_PROTO(arenas_quantum)
 CTL_PROTO(arenas_page)
 CTL_PROTO(arenas_tcache_max)
 CTL_PROTO(arenas_nbins)
 CTL_PROTO(arenas_nhbins)
 CTL_PROTO(arenas_nlruns)
@@ -178,27 +185,30 @@
 CTL_PROTO(stats_arenas_i_hchunks_j_nrequests)
 CTL_PROTO(stats_arenas_i_hchunks_j_curhchunks)
 INDEX_PROTO(stats_arenas_i_hchunks_j)
 CTL_PROTO(stats_arenas_i_nthreads)
 CTL_PROTO(stats_arenas_i_dss)
 CTL_PROTO(stats_arenas_i_lg_dirty_mult)
+CTL_PROTO(stats_arenas_i_decay_time)
 CTL_PROTO(stats_arenas_i_pactive)
 CTL_PROTO(stats_arenas_i_pdirty)
 CTL_PROTO(stats_arenas_i_mapped)
+CTL_PROTO(stats_arenas_i_retained)
 CTL_PROTO(stats_arenas_i_npurge)
 CTL_PROTO(stats_arenas_i_nmadvise)
 CTL_PROTO(stats_arenas_i_purged)
 CTL_PROTO(stats_arenas_i_metadata_mapped)
 CTL_PROTO(stats_arenas_i_metadata_allocated)
 INDEX_PROTO(stats_arenas_i)
 CTL_PROTO(stats_cactive)
 CTL_PROTO(stats_allocated)
 CTL_PROTO(stats_active)
 CTL_PROTO(stats_metadata)
 CTL_PROTO(stats_resident)
 CTL_PROTO(stats_mapped)
+CTL_PROTO(stats_retained)
 
 /******************************************************************************/
 /* mallctl tree. */
 
 /* Maximum tree depth. */
 #define	CTL_MAX_DEPTH	6
@@ -238,12 +248,13 @@
 
 static const ctl_named_node_t	config_node[] = {
 	{NAME("cache_oblivious"), CTL(config_cache_oblivious)},
 	{NAME("debug"),		CTL(config_debug)},
 	{NAME("fill"),		CTL(config_fill)},
 	{NAME("lazy_lock"),	CTL(config_lazy_lock)},
+	{NAME("malloc_conf"),	CTL(config_malloc_conf)},
 	{NAME("munmap"),	CTL(config_munmap)},
 	{NAME("prof"),		CTL(config_prof)},
 	{NAME("prof_libgcc"),	CTL(config_prof_libgcc)},
 	{NAME("prof_libunwind"), CTL(config_prof_libunwind)},
 	{NAME("stats"),		CTL(config_stats)},
 	{NAME("tcache"),	CTL(config_tcache)},
@@ -255,13 +266,15 @@
 
 static const ctl_named_node_t opt_node[] = {
 	{NAME("abort"),		CTL(opt_abort)},
 	{NAME("dss"),		CTL(opt_dss)},
 	{NAME("lg_chunk"),	CTL(opt_lg_chunk)},
 	{NAME("narenas"),	CTL(opt_narenas)},
+	{NAME("purge"),		CTL(opt_purge)},
 	{NAME("lg_dirty_mult"),	CTL(opt_lg_dirty_mult)},
+	{NAME("decay_time"),	CTL(opt_decay_time)},
 	{NAME("stats_print"),	CTL(opt_stats_print)},
 	{NAME("junk"),		CTL(opt_junk)},
 	{NAME("zero"),		CTL(opt_zero)},
 	{NAME("quarantine"),	CTL(opt_quarantine)},
 	{NAME("redzone"),	CTL(opt_redzone)},
 	{NAME("utrace"),	CTL(opt_utrace)},
@@ -285,14 +298,17 @@
 	{NAME("flush"),		CTL(tcache_flush)},
 	{NAME("destroy"),	CTL(tcache_destroy)}
 };
 
 static const ctl_named_node_t arena_i_node[] = {
 	{NAME("purge"),		CTL(arena_i_purge)},
+	{NAME("decay"),		CTL(arena_i_decay)},
+	{NAME("reset"),		CTL(arena_i_reset)},
 	{NAME("dss"),		CTL(arena_i_dss)},
 	{NAME("lg_dirty_mult"),	CTL(arena_i_lg_dirty_mult)},
+	{NAME("decay_time"),	CTL(arena_i_decay_time)},
 	{NAME("chunk_hooks"),	CTL(arena_i_chunk_hooks)}
 };
 static const ctl_named_node_t super_arena_i_node[] = {
 	{NAME(""),		CHILD(named, arena_i)}
 };
 
@@ -336,12 +352,13 @@
 };
 
 static const ctl_named_node_t arenas_node[] = {
 	{NAME("narenas"),	CTL(arenas_narenas)},
 	{NAME("initialized"),	CTL(arenas_initialized)},
 	{NAME("lg_dirty_mult"),	CTL(arenas_lg_dirty_mult)},
+	{NAME("decay_time"),	CTL(arenas_decay_time)},
 	{NAME("quantum"),	CTL(arenas_quantum)},
 	{NAME("page"),		CTL(arenas_page)},
 	{NAME("tcache_max"),	CTL(arenas_tcache_max)},
 	{NAME("nbins"),		CTL(arenas_nbins)},
 	{NAME("nhbins"),	CTL(arenas_nhbins)},
 	{NAME("bin"),		CHILD(indexed, arenas_bin)},
@@ -436,15 +453,17 @@
 };
 
 static const ctl_named_node_t stats_arenas_i_node[] = {
 	{NAME("nthreads"),	CTL(stats_arenas_i_nthreads)},
 	{NAME("dss"),		CTL(stats_arenas_i_dss)},
 	{NAME("lg_dirty_mult"),	CTL(stats_arenas_i_lg_dirty_mult)},
+	{NAME("decay_time"),	CTL(stats_arenas_i_decay_time)},
 	{NAME("pactive"),	CTL(stats_arenas_i_pactive)},
 	{NAME("pdirty"),	CTL(stats_arenas_i_pdirty)},
 	{NAME("mapped"),	CTL(stats_arenas_i_mapped)},
+	{NAME("retained"),	CTL(stats_arenas_i_retained)},
 	{NAME("npurge"),	CTL(stats_arenas_i_npurge)},
 	{NAME("nmadvise"),	CTL(stats_arenas_i_nmadvise)},
 	{NAME("purged"),	CTL(stats_arenas_i_purged)},
 	{NAME("metadata"),	CHILD(named, stats_arenas_i_metadata)},
 	{NAME("small"),		CHILD(named, stats_arenas_i_small)},
 	{NAME("large"),		CHILD(named, stats_arenas_i_large)},
@@ -465,12 +484,13 @@
 	{NAME("cactive"),	CTL(stats_cactive)},
 	{NAME("allocated"),	CTL(stats_allocated)},
 	{NAME("active"),	CTL(stats_active)},
 	{NAME("metadata"),	CTL(stats_metadata)},
 	{NAME("resident"),	CTL(stats_resident)},
 	{NAME("mapped"),	CTL(stats_mapped)},
+	{NAME("retained"),	CTL(stats_retained)},
 	{NAME("arenas"),	CHILD(indexed, stats_arenas)}
 };
 
 static const ctl_named_node_t	root_node[] = {
 	{NAME("version"),	CTL(version)},
 	{NAME("epoch"),		CTL(epoch)},
@@ -516,14 +536,16 @@
 }
 
 static void
 ctl_arena_clear(ctl_arena_stats_t *astats)
 {
 
+	astats->nthreads = 0;
 	astats->dss = dss_prec_names[dss_prec_limit];
 	astats->lg_dirty_mult = -1;
+	astats->decay_time = -1;
 	astats->pactive = 0;
 	astats->pdirty = 0;
 	if (config_stats) {
 		memset(&astats->astats, 0, sizeof(arena_stats_t));
 		astats->allocated_small = 0;
 		astats->nmalloc_small = 0;
@@ -535,117 +557,126 @@
 		memset(astats->hstats, 0, nhclasses *
 		    sizeof(malloc_huge_stats_t));
 	}
 }
 
 static void
-ctl_arena_stats_amerge(ctl_arena_stats_t *cstats, arena_t *arena)
+ctl_arena_stats_amerge(tsdn_t *tsdn, ctl_arena_stats_t *cstats, arena_t *arena)
 {
 	unsigned i;
 
-	arena_stats_merge(arena, &cstats->dss, &cstats->lg_dirty_mult,
-	    &cstats->pactive, &cstats->pdirty, &cstats->astats, cstats->bstats,
-	    cstats->lstats, cstats->hstats);
-
-	for (i = 0; i < NBINS; i++) {
-		cstats->allocated_small += cstats->bstats[i].curregs *
-		    index2size(i);
-		cstats->nmalloc_small += cstats->bstats[i].nmalloc;
-		cstats->ndalloc_small += cstats->bstats[i].ndalloc;
-		cstats->nrequests_small += cstats->bstats[i].nrequests;
+	if (config_stats) {
+		arena_stats_merge(tsdn, arena, &cstats->nthreads, &cstats->dss,
+		    &cstats->lg_dirty_mult, &cstats->decay_time,
+		    &cstats->pactive, &cstats->pdirty, &cstats->astats,
+		    cstats->bstats, cstats->lstats, cstats->hstats);
+
+		for (i = 0; i < NBINS; i++) {
+			cstats->allocated_small += cstats->bstats[i].curregs *
+			    index2size(i);
+			cstats->nmalloc_small += cstats->bstats[i].nmalloc;
+			cstats->ndalloc_small += cstats->bstats[i].ndalloc;
+			cstats->nrequests_small += cstats->bstats[i].nrequests;
+		}
+	} else {
+		arena_basic_stats_merge(tsdn, arena, &cstats->nthreads,
+		    &cstats->dss, &cstats->lg_dirty_mult, &cstats->decay_time,
+		    &cstats->pactive, &cstats->pdirty);
 	}
 }
 
 static void
 ctl_arena_stats_smerge(ctl_arena_stats_t *sstats, ctl_arena_stats_t *astats)
 {
 	unsigned i;
 
+	sstats->nthreads += astats->nthreads;
 	sstats->pactive += astats->pactive;
 	sstats->pdirty += astats->pdirty;
 
-	sstats->astats.mapped += astats->astats.mapped;
-	sstats->astats.npurge += astats->astats.npurge;
-	sstats->astats.nmadvise += astats->astats.nmadvise;
-	sstats->astats.purged += astats->astats.purged;
-
-	sstats->astats.metadata_mapped += astats->astats.metadata_mapped;
-	sstats->astats.metadata_allocated += astats->astats.metadata_allocated;
-
-	sstats->allocated_small += astats->allocated_small;
-	sstats->nmalloc_small += astats->nmalloc_small;
-	sstats->ndalloc_small += astats->ndalloc_small;
-	sstats->nrequests_small += astats->nrequests_small;
-
-	sstats->astats.allocated_large += astats->astats.allocated_large;
-	sstats->astats.nmalloc_large += astats->astats.nmalloc_large;
-	sstats->astats.ndalloc_large += astats->astats.ndalloc_large;
-	sstats->astats.nrequests_large += astats->astats.nrequests_large;
-
-	sstats->astats.allocated_huge += astats->astats.allocated_huge;
-	sstats->astats.nmalloc_huge += astats->astats.nmalloc_huge;
-	sstats->astats.ndalloc_huge += astats->astats.ndalloc_huge;
-
-	for (i = 0; i < NBINS; i++) {
-		sstats->bstats[i].nmalloc += astats->bstats[i].nmalloc;
-		sstats->bstats[i].ndalloc += astats->bstats[i].ndalloc;
-		sstats->bstats[i].nrequests += astats->bstats[i].nrequests;
-		sstats->bstats[i].curregs += astats->bstats[i].curregs;
-		if (config_tcache) {
-			sstats->bstats[i].nfills += astats->bstats[i].nfills;
-			sstats->bstats[i].nflushes +=
-			    astats->bstats[i].nflushes;
-		}
-		sstats->bstats[i].nruns += astats->bstats[i].nruns;
-		sstats->bstats[i].reruns += astats->bstats[i].reruns;
-		sstats->bstats[i].curruns += astats->bstats[i].curruns;
-	}
-
-	for (i = 0; i < nlclasses; i++) {
-		sstats->lstats[i].nmalloc += astats->lstats[i].nmalloc;
-		sstats->lstats[i].ndalloc += astats->lstats[i].ndalloc;
-		sstats->lstats[i].nrequests += astats->lstats[i].nrequests;
-		sstats->lstats[i].curruns += astats->lstats[i].curruns;
-	}
-
-	for (i = 0; i < nhclasses; i++) {
-		sstats->hstats[i].nmalloc += astats->hstats[i].nmalloc;
-		sstats->hstats[i].ndalloc += astats->hstats[i].ndalloc;
-		sstats->hstats[i].curhchunks += astats->hstats[i].curhchunks;
+	if (config_stats) {
+		sstats->astats.mapped += astats->astats.mapped;
+		sstats->astats.retained += astats->astats.retained;
+		sstats->astats.npurge += astats->astats.npurge;
+		sstats->astats.nmadvise += astats->astats.nmadvise;
+		sstats->astats.purged += astats->astats.purged;
+
+		sstats->astats.metadata_mapped +=
+		    astats->astats.metadata_mapped;
+		sstats->astats.metadata_allocated +=
+		    astats->astats.metadata_allocated;
+
+		sstats->allocated_small += astats->allocated_small;
+		sstats->nmalloc_small += astats->nmalloc_small;
+		sstats->ndalloc_small += astats->ndalloc_small;
+		sstats->nrequests_small += astats->nrequests_small;
+
+		sstats->astats.allocated_large +=
+		    astats->astats.allocated_large;
+		sstats->astats.nmalloc_large += astats->astats.nmalloc_large;
+		sstats->astats.ndalloc_large += astats->astats.ndalloc_large;
+		sstats->astats.nrequests_large +=
+		    astats->astats.nrequests_large;
+
+		sstats->astats.allocated_huge += astats->astats.allocated_huge;
+		sstats->astats.nmalloc_huge += astats->astats.nmalloc_huge;
+		sstats->astats.ndalloc_huge += astats->astats.ndalloc_huge;
+
+		for (i = 0; i < NBINS; i++) {
+			sstats->bstats[i].nmalloc += astats->bstats[i].nmalloc;
+			sstats->bstats[i].ndalloc += astats->bstats[i].ndalloc;
+			sstats->bstats[i].nrequests +=
+			    astats->bstats[i].nrequests;
+			sstats->bstats[i].curregs += astats->bstats[i].curregs;
+			if (config_tcache) {
+				sstats->bstats[i].nfills +=
+				    astats->bstats[i].nfills;
+				sstats->bstats[i].nflushes +=
+				    astats->bstats[i].nflushes;
+			}
+			sstats->bstats[i].nruns += astats->bstats[i].nruns;
+			sstats->bstats[i].reruns += astats->bstats[i].reruns;
+			sstats->bstats[i].curruns += astats->bstats[i].curruns;
+		}
+
+		for (i = 0; i < nlclasses; i++) {
+			sstats->lstats[i].nmalloc += astats->lstats[i].nmalloc;
+			sstats->lstats[i].ndalloc += astats->lstats[i].ndalloc;
+			sstats->lstats[i].nrequests +=
+			    astats->lstats[i].nrequests;
+			sstats->lstats[i].curruns += astats->lstats[i].curruns;
+		}
+
+		for (i = 0; i < nhclasses; i++) {
+			sstats->hstats[i].nmalloc += astats->hstats[i].nmalloc;
+			sstats->hstats[i].ndalloc += astats->hstats[i].ndalloc;
+			sstats->hstats[i].curhchunks +=
+			    astats->hstats[i].curhchunks;
+		}
 	}
 }
 
 static void
-ctl_arena_refresh(arena_t *arena, unsigned i)
+ctl_arena_refresh(tsdn_t *tsdn, arena_t *arena, unsigned i)
 {
 	ctl_arena_stats_t *astats = &ctl_stats.arenas[i];
 	ctl_arena_stats_t *sstats = &ctl_stats.arenas[ctl_stats.narenas];
 
 	ctl_arena_clear(astats);
-
-	sstats->nthreads += astats->nthreads;
-	if (config_stats) {
-		ctl_arena_stats_amerge(astats, arena);
-		/* Merge into sum stats as well. */
-		ctl_arena_stats_smerge(sstats, astats);
-	} else {
-		astats->pactive += arena->nactive;
-		astats->pdirty += arena->ndirty;
-		/* Merge into sum stats as well. */
-		sstats->pactive += arena->nactive;
-		sstats->pdirty += arena->ndirty;
-	}
+	ctl_arena_stats_amerge(tsdn, astats, arena);
+	/* Merge into sum stats as well. */
+	ctl_arena_stats_smerge(sstats, astats);
 }
 
 static bool
-ctl_grow(void)
+ctl_grow(tsdn_t *tsdn)
 {
 	ctl_arena_stats_t *astats;
 
 	/* Initialize new arena. */
-	if (arena_init(ctl_stats.narenas) == NULL)
+	if (arena_init(tsdn, ctl_stats.narenas) == NULL)
 		return (true);
 
 	/* Allocate extended arena stats. */
 	astats = (ctl_arena_stats_t *)a0malloc((ctl_stats.narenas + 2) *
 	    sizeof(ctl_arena_stats_t));
 	if (astats == NULL)
@@ -674,53 +705,38 @@
 	ctl_stats.narenas++;
 
 	return (false);
 }
 
 static void
-ctl_refresh(void)
+ctl_refresh(tsdn_t *tsdn)
 {
-	tsd_t *tsd;
 	unsigned i;
-	bool refreshed;
 	VARIABLE_ARRAY(arena_t *, tarenas, ctl_stats.narenas);
 
 	/*
 	 * Clear sum stats, since they will be merged into by
 	 * ctl_arena_refresh().
 	 */
-	ctl_stats.arenas[ctl_stats.narenas].nthreads = 0;
 	ctl_arena_clear(&ctl_stats.arenas[ctl_stats.narenas]);
 
-	tsd = tsd_fetch();
-	for (i = 0, refreshed = false; i < ctl_stats.narenas; i++) {
-		tarenas[i] = arena_get(tsd, i, false, false);
-		if (tarenas[i] == NULL && !refreshed) {
-			tarenas[i] = arena_get(tsd, i, false, true);
-			refreshed = true;
-		}
-	}
-
-	for (i = 0; i < ctl_stats.narenas; i++) {
-		if (tarenas[i] != NULL)
-			ctl_stats.arenas[i].nthreads = arena_nbound(i);
-		else
-			ctl_stats.arenas[i].nthreads = 0;
-	}
+	for (i = 0; i < ctl_stats.narenas; i++)
+		tarenas[i] = arena_get(tsdn, i, false);
 
 	for (i = 0; i < ctl_stats.narenas; i++) {
 		bool initialized = (tarenas[i] != NULL);
 
 		ctl_stats.arenas[i].initialized = initialized;
 		if (initialized)
-			ctl_arena_refresh(tarenas[i], i);
+			ctl_arena_refresh(tsdn, tarenas[i], i);
 	}
 
 	if (config_stats) {
 		size_t base_allocated, base_resident, base_mapped;
-		base_stats_get(&base_allocated, &base_resident, &base_mapped);
+		base_stats_get(tsdn, &base_allocated, &base_resident,
+		    &base_mapped);
 		ctl_stats.allocated =
 		    ctl_stats.arenas[ctl_stats.narenas].allocated_small +
 		    ctl_stats.arenas[ctl_stats.narenas].astats.allocated_large +
 		    ctl_stats.arenas[ctl_stats.narenas].astats.allocated_huge;
 		ctl_stats.active =
 		    (ctl_stats.arenas[ctl_stats.narenas].pactive << LG_PAGE);
@@ -731,23 +747,25 @@
 		ctl_stats.resident = base_resident +
 		    ctl_stats.arenas[ctl_stats.narenas].astats.metadata_mapped +
 		    ((ctl_stats.arenas[ctl_stats.narenas].pactive +
 		    ctl_stats.arenas[ctl_stats.narenas].pdirty) << LG_PAGE);
 		ctl_stats.mapped = base_mapped +
 		    ctl_stats.arenas[ctl_stats.narenas].astats.mapped;
+		ctl_stats.retained =
+		    ctl_stats.arenas[ctl_stats.narenas].astats.retained;
 	}
 
 	ctl_epoch++;
 }
 
 static bool
-ctl_init(void)
+ctl_init(tsdn_t *tsdn)
 {
 	bool ret;
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsdn, &ctl_mtx);
 	if (!ctl_initialized) {
 		/*
 		 * Allocate space for one extra arena stats element, which
 		 * contains summed stats across all arenas.
 		 */
 		ctl_stats.narenas = narenas_total_get();
@@ -783,25 +801,25 @@
 				}
 			}
 		}
 		ctl_stats.arenas[ctl_stats.narenas].initialized = true;
 
 		ctl_epoch = 0;
-		ctl_refresh();
+		ctl_refresh(tsdn);
 		ctl_initialized = true;
 	}
 
 	ret = false;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsdn, &ctl_mtx);
 	return (ret);
 }
 
 static int
-ctl_lookup(const char *name, ctl_node_t const **nodesp, size_t *mibp,
-    size_t *depthp)
+ctl_lookup(tsdn_t *tsdn, const char *name, ctl_node_t const **nodesp,
+    size_t *mibp, size_t *depthp)
 {
 	int ret;
 	const char *elm, *tdot, *dot;
 	size_t elen, i, j;
 	const ctl_named_node_t *node;
 
@@ -847,13 +865,13 @@
 			if (index == UINTMAX_MAX || index > SIZE_T_MAX) {
 				ret = ENOENT;
 				goto label_return;
 			}
 
 			inode = ctl_indexed_node(node->children);
-			node = inode->index(mibp, *depthp, (size_t)index);
+			node = inode->index(tsdn, mibp, *depthp, (size_t)index);
 			if (node == NULL) {
 				ret = ENOENT;
 				goto label_return;
 			}
 
 			if (nodesp != NULL)
@@ -891,99 +909,99 @@
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 int
-ctl_byname(const char *name, void *oldp, size_t *oldlenp, void *newp,
-    size_t newlen)
+ctl_byname(tsd_t *tsd, const char *name, void *oldp, size_t *oldlenp,
+    void *newp, size_t newlen)
 {
 	int ret;
 	size_t depth;
 	ctl_node_t const *nodes[CTL_MAX_DEPTH];
 	size_t mib[CTL_MAX_DEPTH];
 	const ctl_named_node_t *node;
 
-	if (!ctl_initialized && ctl_init()) {
+	if (!ctl_initialized && ctl_init(tsd_tsdn(tsd))) {
 		ret = EAGAIN;
 		goto label_return;
 	}
 
 	depth = CTL_MAX_DEPTH;
-	ret = ctl_lookup(name, nodes, mib, &depth);
+	ret = ctl_lookup(tsd_tsdn(tsd), name, nodes, mib, &depth);
 	if (ret != 0)
 		goto label_return;
 
 	node = ctl_named_node(nodes[depth-1]);
 	if (node != NULL && node->ctl)
-		ret = node->ctl(mib, depth, oldp, oldlenp, newp, newlen);
+		ret = node->ctl(tsd, mib, depth, oldp, oldlenp, newp, newlen);
 	else {
 		/* The name refers to a partial path through the ctl tree. */
 		ret = ENOENT;
 	}
 
 label_return:
 	return(ret);
 }
 
 int
-ctl_nametomib(const char *name, size_t *mibp, size_t *miblenp)
+ctl_nametomib(tsdn_t *tsdn, const char *name, size_t *mibp, size_t *miblenp)
 {
 	int ret;
 
-	if (!ctl_initialized && ctl_init()) {
+	if (!ctl_initialized && ctl_init(tsdn)) {
 		ret = EAGAIN;
 		goto label_return;
 	}
 
-	ret = ctl_lookup(name, NULL, mibp, miblenp);
+	ret = ctl_lookup(tsdn, name, NULL, mibp, miblenp);
 label_return:
 	return(ret);
 }
 
 int
-ctl_bymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+ctl_bymib(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	const ctl_named_node_t *node;
 	size_t i;
 
-	if (!ctl_initialized && ctl_init()) {
+	if (!ctl_initialized && ctl_init(tsd_tsdn(tsd))) {
 		ret = EAGAIN;
 		goto label_return;
 	}
 
 	/* Iterate down the tree. */
 	node = super_root_node;
 	for (i = 0; i < miblen; i++) {
 		assert(node);
 		assert(node->nchildren > 0);
 		if (ctl_named_node(node->children) != NULL) {
 			/* Children are named. */
-			if (node->nchildren <= mib[i]) {
+			if (node->nchildren <= (unsigned)mib[i]) {
 				ret = ENOENT;
 				goto label_return;
 			}
 			node = ctl_named_children(node, mib[i]);
 		} else {
 			const ctl_indexed_node_t *inode;
 
 			/* Indexed element. */
 			inode = ctl_indexed_node(node->children);
-			node = inode->index(mib, miblen, mib[i]);
+			node = inode->index(tsd_tsdn(tsd), mib, miblen, mib[i]);
 			if (node == NULL) {
 				ret = ENOENT;
 				goto label_return;
 			}
 		}
 	}
 
 	/* Call the ctl function. */
 	if (node && node->ctl)
-		ret = node->ctl(mib, miblen, oldp, oldlenp, newp, newlen);
+		ret = node->ctl(tsd, mib, miblen, oldp, oldlenp, newp, newlen);
 	else {
 		/* Partial MIB. */
 		ret = ENOENT;
 	}
 
 label_return:
@@ -991,39 +1009,39 @@
 }
 
 bool
 ctl_boot(void)
 {
 
-	if (malloc_mutex_init(&ctl_mtx))
+	if (malloc_mutex_init(&ctl_mtx, "ctl", WITNESS_RANK_CTL))
 		return (true);
 
 	ctl_initialized = false;
 
 	return (false);
 }
 
 void
-ctl_prefork(void)
+ctl_prefork(tsdn_t *tsdn)
 {
 
-	malloc_mutex_prefork(&ctl_mtx);
+	malloc_mutex_prefork(tsdn, &ctl_mtx);
 }
 
 void
-ctl_postfork_parent(void)
+ctl_postfork_parent(tsdn_t *tsdn)
 {
 
-	malloc_mutex_postfork_parent(&ctl_mtx);
+	malloc_mutex_postfork_parent(tsdn, &ctl_mtx);
 }
 
 void
-ctl_postfork_child(void)
+ctl_postfork_child(tsdn_t *tsdn)
 {
 
-	malloc_mutex_postfork_child(&ctl_mtx);
+	malloc_mutex_postfork_child(tsdn, &ctl_mtx);
 }
 
 /******************************************************************************/
 /* *_ctl() functions. */
 
 #define	READONLY()	do {						\
@@ -1074,81 +1092,81 @@
 /*
  * There's a lot of code duplication in the following macros due to limitations
  * in how nested cpp macros are expanded.
  */
 #define	CTL_RO_CLGEN(c, l, n, v, t)					\
 static int								\
-n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
-    void *newp, size_t newlen)						\
+n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
+    size_t *oldlenp, void *newp, size_t newlen)				\
 {									\
 	int ret;							\
 	t oldval;							\
 									\
 	if (!(c))							\
 		return (ENOENT);					\
 	if (l)								\
-		malloc_mutex_lock(&ctl_mtx);				\
+		malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);		\
 	READONLY();							\
 	oldval = (v);							\
 	READ(oldval, t);						\
 									\
 	ret = 0;							\
 label_return:								\
 	if (l)								\
-		malloc_mutex_unlock(&ctl_mtx);				\
+		malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);		\
 	return (ret);							\
 }
 
 #define	CTL_RO_CGEN(c, n, v, t)						\
 static int								\
-n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
-    void *newp, size_t newlen)						\
+n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
+    size_t *oldlenp, void *newp, size_t newlen)				\
 {									\
 	int ret;							\
 	t oldval;							\
 									\
 	if (!(c))							\
 		return (ENOENT);					\
-	malloc_mutex_lock(&ctl_mtx);					\
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);			\
 	READONLY();							\
 	oldval = (v);							\
 	READ(oldval, t);						\
 									\
 	ret = 0;							\
 label_return:								\
-	malloc_mutex_unlock(&ctl_mtx);					\
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);			\
 	return (ret);							\
 }
 
 #define	CTL_RO_GEN(n, v, t)						\
 static int								\
-n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
-    void *newp, size_t newlen)						\
+n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
+    size_t *oldlenp, void *newp, size_t newlen)				\
 {									\
 	int ret;							\
 	t oldval;							\
 									\
-	malloc_mutex_lock(&ctl_mtx);					\
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);			\
 	READONLY();							\
 	oldval = (v);							\
 	READ(oldval, t);						\
 									\
 	ret = 0;							\
 label_return:								\
-	malloc_mutex_unlock(&ctl_mtx);					\
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);			\
 	return (ret);							\
 }
 
 /*
  * ctl_mtx is not acquired, under the assumption that no pertinent data will
  * mutate during the call.
  */
 #define	CTL_RO_NL_CGEN(c, n, v, t)					\
 static int								\
-n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
-    void *newp, size_t newlen)						\
+n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
+    size_t *oldlenp, void *newp, size_t newlen)				\
 {									\
 	int ret;							\
 	t oldval;							\
 									\
 	if (!(c))							\
 		return (ENOENT);					\
@@ -1160,14 +1178,14 @@
 label_return:								\
 	return (ret);							\
 }
 
 #define	CTL_RO_NL_GEN(n, v, t)						\
 static int								\
-n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
-    void *newp, size_t newlen)						\
+n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
+    size_t *oldlenp, void *newp, size_t newlen)				\
 {									\
 	int ret;							\
 	t oldval;							\
 									\
 	READONLY();							\
 	oldval = (v);							\
@@ -1177,95 +1195,96 @@
 label_return:								\
 	return (ret);							\
 }
 
 #define	CTL_TSD_RO_NL_CGEN(c, n, m, t)					\
 static int								\
-n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
-    void *newp, size_t newlen)						\
+n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
+    size_t *oldlenp, void *newp, size_t newlen)				\
 {									\
 	int ret;							\
 	t oldval;							\
-	tsd_t *tsd;							\
 									\
 	if (!(c))							\
 		return (ENOENT);					\
 	READONLY();							\
-	tsd = tsd_fetch();						\
 	oldval = (m(tsd));						\
 	READ(oldval, t);						\
 									\
 	ret = 0;							\
 label_return:								\
 	return (ret);							\
 }
 
-#define	CTL_RO_BOOL_CONFIG_GEN(n)					\
+#define	CTL_RO_CONFIG_GEN(n, t)						\
 static int								\
-n##_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,	\
-    void *newp, size_t newlen)						\
+n##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,	\
+    size_t *oldlenp, void *newp, size_t newlen)				\
 {									\
 	int ret;							\
-	bool oldval;							\
+	t oldval;							\
 									\
 	READONLY();							\
 	oldval = n;							\
-	READ(oldval, bool);						\
+	READ(oldval, t);						\
 									\
 	ret = 0;							\
 label_return:								\
 	return (ret);							\
 }
 
 /******************************************************************************/
 
 CTL_RO_NL_GEN(version, JEMALLOC_VERSION, const char *)
 
 static int
-epoch_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+epoch_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	UNUSED uint64_t newval;
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);
 	WRITE(newval, uint64_t);
 	if (newp != NULL)
-		ctl_refresh();
+		ctl_refresh(tsd_tsdn(tsd));
 	READ(ctl_epoch, uint64_t);
 
 	ret = 0;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);
 	return (ret);
 }
 
 /******************************************************************************/
 
-CTL_RO_BOOL_CONFIG_GEN(config_cache_oblivious)
-CTL_RO_BOOL_CONFIG_GEN(config_debug)
-CTL_RO_BOOL_CONFIG_GEN(config_fill)
-CTL_RO_BOOL_CONFIG_GEN(config_lazy_lock)
-CTL_RO_BOOL_CONFIG_GEN(config_munmap)
-CTL_RO_BOOL_CONFIG_GEN(config_prof)
-CTL_RO_BOOL_CONFIG_GEN(config_prof_libgcc)
-CTL_RO_BOOL_CONFIG_GEN(config_prof_libunwind)
-CTL_RO_BOOL_CONFIG_GEN(config_stats)
-CTL_RO_BOOL_CONFIG_GEN(config_tcache)
-CTL_RO_BOOL_CONFIG_GEN(config_tls)
-CTL_RO_BOOL_CONFIG_GEN(config_utrace)
-CTL_RO_BOOL_CONFIG_GEN(config_valgrind)
-CTL_RO_BOOL_CONFIG_GEN(config_xmalloc)
+CTL_RO_CONFIG_GEN(config_cache_oblivious, bool)
+CTL_RO_CONFIG_GEN(config_debug, bool)
+CTL_RO_CONFIG_GEN(config_fill, bool)
+CTL_RO_CONFIG_GEN(config_lazy_lock, bool)
+CTL_RO_CONFIG_GEN(config_malloc_conf, const char *)
+CTL_RO_CONFIG_GEN(config_munmap, bool)
+CTL_RO_CONFIG_GEN(config_prof, bool)
+CTL_RO_CONFIG_GEN(config_prof_libgcc, bool)
+CTL_RO_CONFIG_GEN(config_prof_libunwind, bool)
+CTL_RO_CONFIG_GEN(config_stats, bool)
+CTL_RO_CONFIG_GEN(config_tcache, bool)
+CTL_RO_CONFIG_GEN(config_tls, bool)
+CTL_RO_CONFIG_GEN(config_utrace, bool)
+CTL_RO_CONFIG_GEN(config_valgrind, bool)
+CTL_RO_CONFIG_GEN(config_xmalloc, bool)
 
 /******************************************************************************/
 
 CTL_RO_NL_GEN(opt_abort, opt_abort, bool)
 CTL_RO_NL_GEN(opt_dss, opt_dss, const char *)
 CTL_RO_NL_GEN(opt_lg_chunk, opt_lg_chunk, size_t)
-CTL_RO_NL_GEN(opt_narenas, opt_narenas, size_t)
+CTL_RO_NL_GEN(opt_narenas, opt_narenas, unsigned)
+CTL_RO_NL_GEN(opt_purge, purge_mode_names[opt_purge], const char *)
 CTL_RO_NL_GEN(opt_lg_dirty_mult, opt_lg_dirty_mult, ssize_t)
+CTL_RO_NL_GEN(opt_decay_time, opt_decay_time, ssize_t)
 CTL_RO_NL_GEN(opt_stats_print, opt_stats_print, bool)
 CTL_RO_NL_CGEN(config_fill, opt_junk, opt_junk, const char *)
 CTL_RO_NL_CGEN(config_fill, opt_quarantine, opt_quarantine, size_t)
 CTL_RO_NL_CGEN(config_fill, opt_redzone, opt_redzone, bool)
 CTL_RO_NL_CGEN(config_fill, opt_zero, opt_zero, bool)
 CTL_RO_NL_CGEN(config_utrace, opt_utrace, opt_utrace, bool)
@@ -1284,26 +1303,24 @@
 CTL_RO_NL_CGEN(config_prof, opt_prof_final, opt_prof_final, bool)
 CTL_RO_NL_CGEN(config_prof, opt_prof_leak, opt_prof_leak, bool)
 
 /******************************************************************************/
 
 static int
-thread_arena_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+thread_arena_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
-	tsd_t *tsd;
 	arena_t *oldarena;
 	unsigned newind, oldind;
 
-	tsd = tsd_fetch();
 	oldarena = arena_choose(tsd, NULL);
 	if (oldarena == NULL)
 		return (EAGAIN);
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);
 	newind = oldind = oldarena->ind;
 	WRITE(newind, unsigned);
 	READ(oldind, unsigned);
 	if (newind != oldind) {
 		arena_t *newarena;
 
@@ -1311,31 +1328,31 @@
 			/* New arena index is out of range. */
 			ret = EFAULT;
 			goto label_return;
 		}
 
 		/* Initialize arena if necessary. */
-		newarena = arena_get(tsd, newind, true, true);
+		newarena = arena_get(tsd_tsdn(tsd), newind, true);
 		if (newarena == NULL) {
 			ret = EAGAIN;
 			goto label_return;
 		}
 		/* Set new arena/tcache associations. */
 		arena_migrate(tsd, oldind, newind);
 		if (config_tcache) {
 			tcache_t *tcache = tsd_tcache_get(tsd);
 			if (tcache != NULL) {
-				tcache_arena_reassociate(tcache, oldarena,
-				    newarena);
+				tcache_arena_reassociate(tsd_tsdn(tsd), tcache,
+				    oldarena, newarena);
 			}
 		}
 	}
 
 	ret = 0;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);
 	return (ret);
 }
 
 CTL_TSD_RO_NL_CGEN(config_stats, thread_allocated, tsd_thread_allocated_get,
     uint64_t)
 CTL_TSD_RO_NL_CGEN(config_stats, thread_allocatedp, tsd_thread_allocatedp_get,
@@ -1343,14 +1360,14 @@
 CTL_TSD_RO_NL_CGEN(config_stats, thread_deallocated, tsd_thread_deallocated_get,
     uint64_t)
 CTL_TSD_RO_NL_CGEN(config_stats, thread_deallocatedp,
     tsd_thread_deallocatedp_get, uint64_t *)
 
 static int
-thread_tcache_enabled_ctl(const size_t *mib, size_t miblen, void *oldp,
-    size_t *oldlenp, void *newp, size_t newlen)
+thread_tcache_enabled_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,
+    void *oldp, size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	bool oldval;
 
 	if (!config_tcache)
 		return (ENOENT);
@@ -1368,14 +1385,14 @@
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-thread_tcache_flush_ctl(const size_t *mib, size_t miblen, void *oldp,
-    size_t *oldlenp, void *newp, size_t newlen)
+thread_tcache_flush_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,
+    void *oldp, size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 
 	if (!config_tcache)
 		return (ENOENT);
 
@@ -1387,62 +1404,58 @@
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-thread_prof_name_ctl(const size_t *mib, size_t miblen, void *oldp,
+thread_prof_name_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
     size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 
 	if (!config_prof)
 		return (ENOENT);
 
 	READ_XOR_WRITE();
 
 	if (newp != NULL) {
-		tsd_t *tsd;
-
 		if (newlen != sizeof(const char *)) {
 			ret = EINVAL;
 			goto label_return;
 		}
 
-		tsd = tsd_fetch();
-
 		if ((ret = prof_thread_name_set(tsd, *(const char **)newp)) !=
 		    0)
 			goto label_return;
 	} else {
-		const char *oldname = prof_thread_name_get();
+		const char *oldname = prof_thread_name_get(tsd);
 		READ(oldname, const char *);
 	}
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-thread_prof_active_ctl(const size_t *mib, size_t miblen, void *oldp,
+thread_prof_active_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
     size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	bool oldval;
 
 	if (!config_prof)
 		return (ENOENT);
 
-	oldval = prof_thread_active_get();
+	oldval = prof_thread_active_get(tsd);
 	if (newp != NULL) {
 		if (newlen != sizeof(bool)) {
 			ret = EINVAL;
 			goto label_return;
 		}
-		if (prof_thread_active_set(*(bool *)newp)) {
+		if (prof_thread_active_set(tsd, *(bool *)newp)) {
 			ret = EAGAIN;
 			goto label_return;
 		}
 	}
 	READ(oldval, bool);
 
@@ -1451,51 +1464,45 @@
 	return (ret);
 }
 
 /******************************************************************************/
 
 static int
-tcache_create_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+tcache_create_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
-	tsd_t *tsd;
 	unsigned tcache_ind;
 
 	if (!config_tcache)
 		return (ENOENT);
 
-	tsd = tsd_fetch();
-
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);
 	READONLY();
 	if (tcaches_create(tsd, &tcache_ind)) {
 		ret = EFAULT;
 		goto label_return;
 	}
 	READ(tcache_ind, unsigned);
 
 	ret = 0;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);
 	return (ret);
 }
 
 static int
-tcache_flush_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+tcache_flush_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
-	tsd_t *tsd;
 	unsigned tcache_ind;
 
 	if (!config_tcache)
 		return (ENOENT);
 
-	tsd = tsd_fetch();
-
 	WRITEONLY();
 	tcache_ind = UINT_MAX;
 	WRITE(tcache_ind, unsigned);
 	if (tcache_ind == UINT_MAX) {
 		ret = EFAULT;
 		goto label_return;
@@ -1505,24 +1512,21 @@
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-tcache_destroy_ctl(const size_t *mib, size_t miblen, void *oldp,
+tcache_destroy_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
     size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
-	tsd_t *tsd;
 	unsigned tcache_ind;
 
 	if (!config_tcache)
 		return (ENOENT);
 
-	tsd = tsd_fetch();
-
 	WRITEONLY();
 	tcache_ind = UINT_MAX;
 	WRITE(tcache_ind, unsigned);
 	if (tcache_ind == UINT_MAX) {
 		ret = EFAULT;
 		goto label_return;
@@ -1533,71 +1537,128 @@
 label_return:
 	return (ret);
 }
 
 /******************************************************************************/
 
-/* ctl_mutex must be held during execution of this function. */
 static void
-arena_purge(unsigned arena_ind)
+arena_i_purge(tsdn_t *tsdn, unsigned arena_ind, bool all)
 {
-	tsd_t *tsd;
-	unsigned i;
-	bool refreshed;
-	VARIABLE_ARRAY(arena_t *, tarenas, ctl_stats.narenas);
 
-	tsd = tsd_fetch();
-	for (i = 0, refreshed = false; i < ctl_stats.narenas; i++) {
-		tarenas[i] = arena_get(tsd, i, false, false);
-		if (tarenas[i] == NULL && !refreshed) {
-			tarenas[i] = arena_get(tsd, i, false, true);
-			refreshed = true;
-		}
-	}
+	malloc_mutex_lock(tsdn, &ctl_mtx);
+	{
+		unsigned narenas = ctl_stats.narenas;
+
+		if (arena_ind == narenas) {
+			unsigned i;
+			VARIABLE_ARRAY(arena_t *, tarenas, narenas);
+
+			for (i = 0; i < narenas; i++)
+				tarenas[i] = arena_get(tsdn, i, false);
+
+			/*
+			 * No further need to hold ctl_mtx, since narenas and
+			 * tarenas contain everything needed below.
+			 */
+			malloc_mutex_unlock(tsdn, &ctl_mtx);
+
+			for (i = 0; i < narenas; i++) {
+				if (tarenas[i] != NULL)
+					arena_purge(tsdn, tarenas[i], all);
+			}
+		} else {
+			arena_t *tarena;
+
+			assert(arena_ind < narenas);
+
+			tarena = arena_get(tsdn, arena_ind, false);
 
-	if (arena_ind == ctl_stats.narenas) {
-		unsigned i;
-		for (i = 0; i < ctl_stats.narenas; i++) {
-			if (tarenas[i] != NULL)
-				arena_purge_all(tarenas[i]);
+			/* No further need to hold ctl_mtx. */
+			malloc_mutex_unlock(tsdn, &ctl_mtx);
+
+			if (tarena != NULL)
+				arena_purge(tsdn, tarena, all);
 		}
-	} else {
-		assert(arena_ind < ctl_stats.narenas);
-		if (tarenas[arena_ind] != NULL)
-			arena_purge_all(tarenas[arena_ind]);
 	}
 }
 
 static int
-arena_i_purge_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+arena_i_purge_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 
 	READONLY();
 	WRITEONLY();
-	malloc_mutex_lock(&ctl_mtx);
-	arena_purge(mib[1]);
-	malloc_mutex_unlock(&ctl_mtx);
+	arena_i_purge(tsd_tsdn(tsd), (unsigned)mib[1], true);
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-arena_i_dss_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+arena_i_decay_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+
+	READONLY();
+	WRITEONLY();
+	arena_i_purge(tsd_tsdn(tsd), (unsigned)mib[1], false);
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
+static int
+arena_i_reset_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+	unsigned arena_ind;
+	arena_t *arena;
+
+	READONLY();
+	WRITEONLY();
+
+	if ((config_valgrind && unlikely(in_valgrind)) || (config_fill &&
+	    unlikely(opt_quarantine))) {
+		ret = EFAULT;
+		goto label_return;
+	}
+
+	arena_ind = (unsigned)mib[1];
+	if (config_debug) {
+		malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);
+		assert(arena_ind < ctl_stats.narenas);
+		malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);
+	}
+	assert(arena_ind >= opt_narenas);
+
+	arena = arena_get(tsd_tsdn(tsd), arena_ind, false);
+
+	arena_reset(tsd, arena);
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
+static int
+arena_i_dss_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	const char *dss = NULL;
-	unsigned arena_ind = mib[1];
+	unsigned arena_ind = (unsigned)mib[1];
 	dss_prec_t dss_prec_old = dss_prec_limit;
 	dss_prec_t dss_prec = dss_prec_limit;
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);
 	WRITE(dss, const char *);
 	if (dss != NULL) {
 		int i;
 		bool match = false;
 
 		for (i = 0; i < dss_prec_limit; i++) {
@@ -1612,19 +1673,19 @@
 			ret = EINVAL;
 			goto label_return;
 		}
 	}
 
 	if (arena_ind < ctl_stats.narenas) {
-		arena_t *arena = arena_get(tsd_fetch(), arena_ind, false, true);
+		arena_t *arena = arena_get(tsd_tsdn(tsd), arena_ind, false);
 		if (arena == NULL || (dss_prec != dss_prec_limit &&
-		    arena_dss_prec_set(arena, dss_prec))) {
+		    arena_dss_prec_set(tsd_tsdn(tsd), arena, dss_prec))) {
 			ret = EFAULT;
 			goto label_return;
 		}
-		dss_prec_old = arena_dss_prec_get(arena);
+		dss_prec_old = arena_dss_prec_get(tsd_tsdn(tsd), arena);
 	} else {
 		if (dss_prec != dss_prec_limit &&
 		    chunk_dss_prec_set(dss_prec)) {
 			ret = EFAULT;
 			goto label_return;
 		}
@@ -1633,151 +1694,188 @@
 
 	dss = dss_prec_names[dss_prec_old];
 	READ(dss, const char *);
 
 	ret = 0;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);
 	return (ret);
 }
 
 static int
-arena_i_lg_dirty_mult_ctl(const size_t *mib, size_t miblen, void *oldp,
-    size_t *oldlenp, void *newp, size_t newlen)
+arena_i_lg_dirty_mult_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,
+    void *oldp, size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
-	unsigned arena_ind = mib[1];
+	unsigned arena_ind = (unsigned)mib[1];
 	arena_t *arena;
 
-	arena = arena_get(tsd_fetch(), arena_ind, false, true);
+	arena = arena_get(tsd_tsdn(tsd), arena_ind, false);
 	if (arena == NULL) {
 		ret = EFAULT;
 		goto label_return;
 	}
 
 	if (oldp != NULL && oldlenp != NULL) {
-		size_t oldval = arena_lg_dirty_mult_get(arena);
+		size_t oldval = arena_lg_dirty_mult_get(tsd_tsdn(tsd), arena);
 		READ(oldval, ssize_t);
 	}
 	if (newp != NULL) {
 		if (newlen != sizeof(ssize_t)) {
 			ret = EINVAL;
 			goto label_return;
 		}
-		if (arena_lg_dirty_mult_set(arena, *(ssize_t *)newp)) {
+		if (arena_lg_dirty_mult_set(tsd_tsdn(tsd), arena,
+		    *(ssize_t *)newp)) {
 			ret = EFAULT;
 			goto label_return;
 		}
 	}
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-arena_i_chunk_hooks_ctl(const size_t *mib, size_t miblen, void *oldp,
+arena_i_decay_time_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
     size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
-	unsigned arena_ind = mib[1];
+	unsigned arena_ind = (unsigned)mib[1];
+	arena_t *arena;
+
+	arena = arena_get(tsd_tsdn(tsd), arena_ind, false);
+	if (arena == NULL) {
+		ret = EFAULT;
+		goto label_return;
+	}
+
+	if (oldp != NULL && oldlenp != NULL) {
+		size_t oldval = arena_decay_time_get(tsd_tsdn(tsd), arena);
+		READ(oldval, ssize_t);
+	}
+	if (newp != NULL) {
+		if (newlen != sizeof(ssize_t)) {
+			ret = EINVAL;
+			goto label_return;
+		}
+		if (arena_decay_time_set(tsd_tsdn(tsd), arena,
+		    *(ssize_t *)newp)) {
+			ret = EFAULT;
+			goto label_return;
+		}
+	}
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
+static int
+arena_i_chunk_hooks_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,
+    void *oldp, size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+	unsigned arena_ind = (unsigned)mib[1];
 	arena_t *arena;
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);
 	if (arena_ind < narenas_total_get() && (arena =
-	    arena_get(tsd_fetch(), arena_ind, false, true)) != NULL) {
+	    arena_get(tsd_tsdn(tsd), arena_ind, false)) != NULL) {
 		if (newp != NULL) {
 			chunk_hooks_t old_chunk_hooks, new_chunk_hooks;
 			WRITE(new_chunk_hooks, chunk_hooks_t);
-			old_chunk_hooks = chunk_hooks_set(arena,
+			old_chunk_hooks = chunk_hooks_set(tsd_tsdn(tsd), arena,
 			    &new_chunk_hooks);
 			READ(old_chunk_hooks, chunk_hooks_t);
 		} else {
-			chunk_hooks_t old_chunk_hooks = chunk_hooks_get(arena);
+			chunk_hooks_t old_chunk_hooks =
+			    chunk_hooks_get(tsd_tsdn(tsd), arena);
 			READ(old_chunk_hooks, chunk_hooks_t);
 		}
 	} else {
 		ret = EFAULT;
 		goto label_return;
 	}
 	ret = 0;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);
 	return (ret);
 }
 
 static const ctl_named_node_t *
-arena_i_index(const size_t *mib, size_t miblen, size_t i)
+arena_i_index(tsdn_t *tsdn, const size_t *mib, size_t miblen, size_t i)
 {
-	const ctl_named_node_t * ret;
+	const ctl_named_node_t *ret;
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsdn, &ctl_mtx);
 	if (i > ctl_stats.narenas) {
 		ret = NULL;
 		goto label_return;
 	}
 
 	ret = super_arena_i_node;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsdn, &ctl_mtx);
 	return (ret);
 }
 
 /******************************************************************************/
 
 static int
-arenas_narenas_ctl(const size_t *mib, size_t miblen, void *oldp,
+arenas_narenas_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
     size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	unsigned narenas;
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);
 	READONLY();
 	if (*oldlenp != sizeof(unsigned)) {
 		ret = EINVAL;
 		goto label_return;
 	}
 	narenas = ctl_stats.narenas;
 	READ(narenas, unsigned);
 
 	ret = 0;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);
 	return (ret);
 }
 
 static int
-arenas_initialized_ctl(const size_t *mib, size_t miblen, void *oldp,
+arenas_initialized_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
     size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	unsigned nread, i;
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);
 	READONLY();
 	if (*oldlenp != ctl_stats.narenas * sizeof(bool)) {
 		ret = EINVAL;
 		nread = (*oldlenp < ctl_stats.narenas * sizeof(bool))
-		    ? (*oldlenp / sizeof(bool)) : ctl_stats.narenas;
+		    ? (unsigned)(*oldlenp / sizeof(bool)) : ctl_stats.narenas;
 	} else {
 		ret = 0;
 		nread = ctl_stats.narenas;
 	}
 
 	for (i = 0; i < nread; i++)
 		((bool *)oldp)[i] = ctl_stats.arenas[i].initialized;
 
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);
 	return (ret);
 }
 
 static int
-arenas_lg_dirty_mult_ctl(const size_t *mib, size_t miblen, void *oldp,
-    size_t *oldlenp, void *newp, size_t newlen)
+arenas_lg_dirty_mult_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,
+    void *oldp, size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 
 	if (oldp != NULL && oldlenp != NULL) {
 		size_t oldval = arena_lg_dirty_mult_default_get();
 		READ(oldval, ssize_t);
@@ -1795,191 +1893,216 @@
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
+static int
+arenas_decay_time_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
+{
+	int ret;
+
+	if (oldp != NULL && oldlenp != NULL) {
+		size_t oldval = arena_decay_time_default_get();
+		READ(oldval, ssize_t);
+	}
+	if (newp != NULL) {
+		if (newlen != sizeof(ssize_t)) {
+			ret = EINVAL;
+			goto label_return;
+		}
+		if (arena_decay_time_default_set(*(ssize_t *)newp)) {
+			ret = EFAULT;
+			goto label_return;
+		}
+	}
+
+	ret = 0;
+label_return:
+	return (ret);
+}
+
 CTL_RO_NL_GEN(arenas_quantum, QUANTUM, size_t)
 CTL_RO_NL_GEN(arenas_page, PAGE, size_t)
 CTL_RO_NL_CGEN(config_tcache, arenas_tcache_max, tcache_maxclass, size_t)
 CTL_RO_NL_GEN(arenas_nbins, NBINS, unsigned)
 CTL_RO_NL_CGEN(config_tcache, arenas_nhbins, nhbins, unsigned)
 CTL_RO_NL_GEN(arenas_bin_i_size, arena_bin_info[mib[2]].reg_size, size_t)
 CTL_RO_NL_GEN(arenas_bin_i_nregs, arena_bin_info[mib[2]].nregs, uint32_t)
 CTL_RO_NL_GEN(arenas_bin_i_run_size, arena_bin_info[mib[2]].run_size, size_t)
 static const ctl_named_node_t *
-arenas_bin_i_index(const size_t *mib, size_t miblen, size_t i)
+arenas_bin_i_index(tsdn_t *tsdn, const size_t *mib, size_t miblen, size_t i)
 {
 
 	if (i > NBINS)
 		return (NULL);
 	return (super_arenas_bin_i_node);
 }
 
 CTL_RO_NL_GEN(arenas_nlruns, nlclasses, unsigned)
-CTL_RO_NL_GEN(arenas_lrun_i_size, index2size(NBINS+mib[2]), size_t)
+CTL_RO_NL_GEN(arenas_lrun_i_size, index2size(NBINS+(szind_t)mib[2]), size_t)
 static const ctl_named_node_t *
-arenas_lrun_i_index(const size_t *mib, size_t miblen, size_t i)
+arenas_lrun_i_index(tsdn_t *tsdn, const size_t *mib, size_t miblen, size_t i)
 {
 
 	if (i > nlclasses)
 		return (NULL);
 	return (super_arenas_lrun_i_node);
 }
 
 CTL_RO_NL_GEN(arenas_nhchunks, nhclasses, unsigned)
-CTL_RO_NL_GEN(arenas_hchunk_i_size, index2size(NBINS+nlclasses+mib[2]), size_t)
+CTL_RO_NL_GEN(arenas_hchunk_i_size, index2size(NBINS+nlclasses+(szind_t)mib[2]),
+    size_t)
 static const ctl_named_node_t *
-arenas_hchunk_i_index(const size_t *mib, size_t miblen, size_t i)
+arenas_hchunk_i_index(tsdn_t *tsdn, const size_t *mib, size_t miblen, size_t i)
 {
 
 	if (i > nhclasses)
 		return (NULL);
 	return (super_arenas_hchunk_i_node);
 }
 
 static int
-arenas_extend_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+arenas_extend_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	unsigned narenas;
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);
 	READONLY();
-	if (ctl_grow()) {
+	if (ctl_grow(tsd_tsdn(tsd))) {
 		ret = EAGAIN;
 		goto label_return;
 	}
 	narenas = ctl_stats.narenas - 1;
 	READ(narenas, unsigned);
 
 	ret = 0;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);
 	return (ret);
 }
 
 /******************************************************************************/
 
 static int
-prof_thread_active_init_ctl(const size_t *mib, size_t miblen, void *oldp,
-    size_t *oldlenp, void *newp, size_t newlen)
+prof_thread_active_init_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,
+    void *oldp, size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	bool oldval;
 
 	if (!config_prof)
 		return (ENOENT);
 
 	if (newp != NULL) {
 		if (newlen != sizeof(bool)) {
 			ret = EINVAL;
 			goto label_return;
 		}
-		oldval = prof_thread_active_init_set(*(bool *)newp);
+		oldval = prof_thread_active_init_set(tsd_tsdn(tsd),
+		    *(bool *)newp);
 	} else
-		oldval = prof_thread_active_init_get();
+		oldval = prof_thread_active_init_get(tsd_tsdn(tsd));
 	READ(oldval, bool);
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-prof_active_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+prof_active_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	bool oldval;
 
 	if (!config_prof)
 		return (ENOENT);
 
 	if (newp != NULL) {
 		if (newlen != sizeof(bool)) {
 			ret = EINVAL;
 			goto label_return;
 		}
-		oldval = prof_active_set(*(bool *)newp);
+		oldval = prof_active_set(tsd_tsdn(tsd), *(bool *)newp);
 	} else
-		oldval = prof_active_get();
+		oldval = prof_active_get(tsd_tsdn(tsd));
 	READ(oldval, bool);
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-prof_dump_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+prof_dump_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	const char *filename = NULL;
 
 	if (!config_prof)
 		return (ENOENT);
 
 	WRITEONLY();
 	WRITE(filename, const char *);
 
-	if (prof_mdump(filename)) {
+	if (prof_mdump(tsd, filename)) {
 		ret = EFAULT;
 		goto label_return;
 	}
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-prof_gdump_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+prof_gdump_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	bool oldval;
 
 	if (!config_prof)
 		return (ENOENT);
 
 	if (newp != NULL) {
 		if (newlen != sizeof(bool)) {
 			ret = EINVAL;
 			goto label_return;
 		}
-		oldval = prof_gdump_set(*(bool *)newp);
+		oldval = prof_gdump_set(tsd_tsdn(tsd), *(bool *)newp);
 	} else
-		oldval = prof_gdump_get();
+		oldval = prof_gdump_get(tsd_tsdn(tsd));
 	READ(oldval, bool);
 
 	ret = 0;
 label_return:
 	return (ret);
 }
 
 static int
-prof_reset_ctl(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
-    void *newp, size_t newlen)
+prof_reset_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,
+    size_t *oldlenp, void *newp, size_t newlen)
 {
 	int ret;
 	size_t lg_sample = lg_prof_sample;
-	tsd_t *tsd;
 
 	if (!config_prof)
 		return (ENOENT);
 
 	WRITEONLY();
 	WRITE(lg_sample, size_t);
 	if (lg_sample >= (sizeof(uint64_t) << 3))
 		lg_sample = (sizeof(uint64_t) << 3) - 1;
 
-	tsd = tsd_fetch();
-
 	prof_reset(tsd, lg_sample);
 
 	ret = 0;
 label_return:
 	return (ret);
 }
@@ -1992,21 +2115,26 @@
 CTL_RO_CGEN(config_stats, stats_cactive, &stats_cactive, size_t *)
 CTL_RO_CGEN(config_stats, stats_allocated, ctl_stats.allocated, size_t)
 CTL_RO_CGEN(config_stats, stats_active, ctl_stats.active, size_t)
 CTL_RO_CGEN(config_stats, stats_metadata, ctl_stats.metadata, size_t)
 CTL_RO_CGEN(config_stats, stats_resident, ctl_stats.resident, size_t)
 CTL_RO_CGEN(config_stats, stats_mapped, ctl_stats.mapped, size_t)
+CTL_RO_CGEN(config_stats, stats_retained, ctl_stats.retained, size_t)
 
 CTL_RO_GEN(stats_arenas_i_dss, ctl_stats.arenas[mib[2]].dss, const char *)
 CTL_RO_GEN(stats_arenas_i_lg_dirty_mult, ctl_stats.arenas[mib[2]].lg_dirty_mult,
     ssize_t)
+CTL_RO_GEN(stats_arenas_i_decay_time, ctl_stats.arenas[mib[2]].decay_time,
+    ssize_t)
 CTL_RO_GEN(stats_arenas_i_nthreads, ctl_stats.arenas[mib[2]].nthreads, unsigned)
 CTL_RO_GEN(stats_arenas_i_pactive, ctl_stats.arenas[mib[2]].pactive, size_t)
 CTL_RO_GEN(stats_arenas_i_pdirty, ctl_stats.arenas[mib[2]].pdirty, size_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_mapped,
     ctl_stats.arenas[mib[2]].astats.mapped, size_t)
+CTL_RO_CGEN(config_stats, stats_arenas_i_retained,
+    ctl_stats.arenas[mib[2]].astats.retained, size_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_npurge,
     ctl_stats.arenas[mib[2]].astats.npurge, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_nmadvise,
     ctl_stats.arenas[mib[2]].astats.nmadvise, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_purged,
     ctl_stats.arenas[mib[2]].astats.purged, uint64_t)
@@ -2057,13 +2185,14 @@
 CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nreruns,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].reruns, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_curruns,
     ctl_stats.arenas[mib[2]].bstats[mib[4]].curruns, size_t)
 
 static const ctl_named_node_t *
-stats_arenas_i_bins_j_index(const size_t *mib, size_t miblen, size_t j)
+stats_arenas_i_bins_j_index(tsdn_t *tsdn, const size_t *mib, size_t miblen,
+    size_t j)
 {
 
 	if (j > NBINS)
 		return (NULL);
 	return (super_stats_arenas_i_bins_j_node);
 }
@@ -2075,13 +2204,14 @@
 CTL_RO_CGEN(config_stats, stats_arenas_i_lruns_j_nrequests,
     ctl_stats.arenas[mib[2]].lstats[mib[4]].nrequests, uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_lruns_j_curruns,
     ctl_stats.arenas[mib[2]].lstats[mib[4]].curruns, size_t)
 
 static const ctl_named_node_t *
-stats_arenas_i_lruns_j_index(const size_t *mib, size_t miblen, size_t j)
+stats_arenas_i_lruns_j_index(tsdn_t *tsdn, const size_t *mib, size_t miblen,
+    size_t j)
 {
 
 	if (j > nlclasses)
 		return (NULL);
 	return (super_stats_arenas_i_lruns_j_node);
 }
@@ -2094,30 +2224,31 @@
     ctl_stats.arenas[mib[2]].hstats[mib[4]].nmalloc, /* Intentional. */
     uint64_t)
 CTL_RO_CGEN(config_stats, stats_arenas_i_hchunks_j_curhchunks,
     ctl_stats.arenas[mib[2]].hstats[mib[4]].curhchunks, size_t)
 
 static const ctl_named_node_t *
-stats_arenas_i_hchunks_j_index(const size_t *mib, size_t miblen, size_t j)
+stats_arenas_i_hchunks_j_index(tsdn_t *tsdn, const size_t *mib, size_t miblen,
+    size_t j)
 {
 
 	if (j > nhclasses)
 		return (NULL);
 	return (super_stats_arenas_i_hchunks_j_node);
 }
 
 static const ctl_named_node_t *
-stats_arenas_i_index(const size_t *mib, size_t miblen, size_t i)
+stats_arenas_i_index(tsdn_t *tsdn, const size_t *mib, size_t miblen, size_t i)
 {
 	const ctl_named_node_t * ret;
 
-	malloc_mutex_lock(&ctl_mtx);
+	malloc_mutex_lock(tsdn, &ctl_mtx);
 	if (i > ctl_stats.narenas || !ctl_stats.arenas[i].initialized) {
 		ret = NULL;
 		goto label_return;
 	}
 
 	ret = super_stats_arenas_i_node;
 label_return:
-	malloc_mutex_unlock(&ctl_mtx);
+	malloc_mutex_unlock(tsdn, &ctl_mtx);
 	return (ret);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.d	2017-09-27 23:00:22.786936003 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.d	2017-09-27 23:01:58.234932505 +0800
@@ -1,18 +1,21 @@
 src/ctl.o: src/ctl.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,53 +1,77 @@
 #define	JEMALLOC_EXTENT_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 
+/*
+ * Round down to the nearest chunk size that can actually be requested during
+ * normal huge allocation.
+ */
 JEMALLOC_INLINE_C size_t
 extent_quantize(size_t size)
 {
+	size_t ret;
+	szind_t ind;
 
-	/*
-	 * Round down to the nearest chunk size that can actually be requested
-	 * during normal huge allocation.
-	 */
-	return (index2size(size2index(size + 1) - 1));
+	assert(size > 0);
+
+	ind = size2index(size + 1);
+	if (ind == 0) {
+		/* Avoid underflow. */
+		return (index2size(0));
+	}
+	ret = index2size(ind - 1);
+	assert(ret <= size);
+	return (ret);
 }
 
 JEMALLOC_INLINE_C int
-extent_szad_comp(extent_node_t *a, extent_node_t *b)
+extent_sz_comp(const extent_node_t *a, const extent_node_t *b)
 {
-	int ret;
 	size_t a_qsize = extent_quantize(extent_node_size_get(a));
 	size_t b_qsize = extent_quantize(extent_node_size_get(b));
 
-	/*
-	 * Compare based on quantized size rather than size, in order to sort
-	 * equally useful extents only by address.
-	 */
-	ret = (a_qsize > b_qsize) - (a_qsize < b_qsize);
-	if (ret == 0) {
-		uintptr_t a_addr = (uintptr_t)extent_node_addr_get(a);
-		uintptr_t b_addr = (uintptr_t)extent_node_addr_get(b);
+	return ((a_qsize > b_qsize) - (a_qsize < b_qsize));
+}
 
-		ret = (a_addr > b_addr) - (a_addr < b_addr);
-	}
+JEMALLOC_INLINE_C int
+extent_sn_comp(const extent_node_t *a, const extent_node_t *b)
+{
+	size_t a_sn = extent_node_sn_get(a);
+	size_t b_sn = extent_node_sn_get(b);
 
-	return (ret);
+	return ((a_sn > b_sn) - (a_sn < b_sn));
 }
 
-/* Generate red-black tree functions. */
-rb_gen(, extent_tree_szad_, extent_tree_t, extent_node_t, szad_link,
-    extent_szad_comp)
-
 JEMALLOC_INLINE_C int
-extent_ad_comp(extent_node_t *a, extent_node_t *b)
+extent_ad_comp(const extent_node_t *a, const extent_node_t *b)
 {
 	uintptr_t a_addr = (uintptr_t)extent_node_addr_get(a);
 	uintptr_t b_addr = (uintptr_t)extent_node_addr_get(b);
 
 	return ((a_addr > b_addr) - (a_addr < b_addr));
 }
 
+JEMALLOC_INLINE_C int
+extent_szsnad_comp(const extent_node_t *a, const extent_node_t *b)
+{
+	int ret;
+
+	ret = extent_sz_comp(a, b);
+	if (ret != 0)
+		return (ret);
+
+	ret = extent_sn_comp(a, b);
+	if (ret != 0)
+		return (ret);
+
+	ret = extent_ad_comp(a, b);
+	return (ret);
+}
+
+/* Generate red-black tree functions. */
+rb_gen(, extent_tree_szsnad_, extent_tree_t, extent_node_t, szsnad_link,
+    extent_szsnad_comp)
+
 /* Generate red-black tree functions. */
 rb_gen(, extent_tree_ad_, extent_tree_t, extent_node_t, ad_link, extent_ad_comp)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.d	2017-09-27 23:00:23.266935985 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.d	2017-09-27 23:01:58.798932484 +0800
@@ -1,18 +1,21 @@
 src/extent.o: src/extent.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.d	2017-09-27 23:00:23.362935982 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.d	2017-09-27 23:01:58.898932481 +0800
@@ -1,18 +1,21 @@
 src/hash.o: src/hash.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.c	2017-01-31 23:32:23.000000000 +0800
@@ -12,96 +12,107 @@
 	assert(!extent_node_achunk_get(node));
 
 	return (node);
 }
 
 static bool
-huge_node_set(const void *ptr, extent_node_t *node)
+huge_node_set(tsdn_t *tsdn, const void *ptr, extent_node_t *node)
 {
 
 	assert(extent_node_addr_get(node) == ptr);
 	assert(!extent_node_achunk_get(node));
-	return (chunk_register(ptr, node));
+	return (chunk_register(tsdn, ptr, node));
+}
+
+static void
+huge_node_reset(tsdn_t *tsdn, const void *ptr, extent_node_t *node)
+{
+	bool err;
+
+	err = huge_node_set(tsdn, ptr, node);
+	assert(!err);
 }
 
 static void
 huge_node_unset(const void *ptr, const extent_node_t *node)
 {
 
 	chunk_deregister(ptr, node);
 }
 
 void *
-huge_malloc(tsd_t *tsd, arena_t *arena, size_t size, bool zero,
-    tcache_t *tcache)
+huge_malloc(tsdn_t *tsdn, arena_t *arena, size_t usize, bool zero)
 {
-	size_t usize;
 
-	usize = s2u(size);
-	if (usize == 0) {
-		/* size_t overflow. */
-		return (NULL);
-	}
+	assert(usize == s2u(usize));
 
-	return (huge_palloc(tsd, arena, usize, chunksize, zero, tcache));
+	return (huge_palloc(tsdn, arena, usize, chunksize, zero));
 }
 
 void *
-huge_palloc(tsd_t *tsd, arena_t *arena, size_t size, size_t alignment,
-    bool zero, tcache_t *tcache)
+huge_palloc(tsdn_t *tsdn, arena_t *arena, size_t usize, size_t alignment,
+    bool zero)
 {
 	void *ret;
-	size_t usize;
+	size_t ausize;
+	arena_t *iarena;
 	extent_node_t *node;
+	size_t sn;
 	bool is_zeroed;
 
 	/* Allocate one or more contiguous chunks for this request. */
 
-	usize = sa2u(size, alignment);
-	if (unlikely(usize == 0))
+	assert(!tsdn_null(tsdn) || arena != NULL);
+
+	ausize = sa2u(usize, alignment);
+	if (unlikely(ausize == 0 || ausize > HUGE_MAXCLASS))
 		return (NULL);
-	assert(usize >= chunksize);
+	assert(ausize >= chunksize);
 
 	/* Allocate an extent node with which to track the chunk. */
-	node = ipallocztm(tsd, CACHELINE_CEILING(sizeof(extent_node_t)),
-	    CACHELINE, false, tcache, true, arena);
+	iarena = (!tsdn_null(tsdn)) ? arena_ichoose(tsdn_tsd(tsdn), NULL) :
+	    a0get();
+	node = ipallocztm(tsdn, CACHELINE_CEILING(sizeof(extent_node_t)),
+	    CACHELINE, false, NULL, true, iarena);
 	if (node == NULL)
 		return (NULL);
 
 	/*
 	 * Copy zero into is_zeroed and pass the copy to chunk_alloc(), so that
 	 * it is possible to make correct junk/zero fill decisions below.
 	 */
 	is_zeroed = zero;
-	arena = arena_choose(tsd, arena);
-	if (unlikely(arena == NULL) || (ret = arena_chunk_alloc_huge(arena,
-	    size, alignment, &is_zeroed)) == NULL) {
-		idalloctm(tsd, node, tcache, true);
+	if (likely(!tsdn_null(tsdn)))
+		arena = arena_choose(tsdn_tsd(tsdn), arena);
+	if (unlikely(arena == NULL) || (ret = arena_chunk_alloc_huge(tsdn,
+	    arena, usize, alignment, &sn, &is_zeroed)) == NULL) {
+		idalloctm(tsdn, node, NULL, true, true);
 		return (NULL);
 	}
 
-	extent_node_init(node, arena, ret, size, is_zeroed, true);
+	extent_node_init(node, arena, ret, usize, sn, is_zeroed, true);
 
-	if (huge_node_set(ret, node)) {
-		arena_chunk_dalloc_huge(arena, ret, size);
-		idalloctm(tsd, node, tcache, true);
+	if (huge_node_set(tsdn, ret, node)) {
+		arena_chunk_dalloc_huge(tsdn, arena, ret, usize, sn);
+		idalloctm(tsdn, node, NULL, true, true);
 		return (NULL);
 	}
 
 	/* Insert node into huge. */
-	malloc_mutex_lock(&arena->huge_mtx);
+	malloc_mutex_lock(tsdn, &arena->huge_mtx);
 	ql_elm_new(node, ql_link);
 	ql_tail_insert(&arena->huge, node, ql_link);
-	malloc_mutex_unlock(&arena->huge_mtx);
+	malloc_mutex_unlock(tsdn, &arena->huge_mtx);
 
 	if (zero || (config_fill && unlikely(opt_zero))) {
 		if (!is_zeroed)
-			memset(ret, 0, size);
+			memset(ret, 0, usize);
 	} else if (config_fill && unlikely(opt_junk_alloc))
-		memset(ret, 0xa5, size);
+		memset(ret, JEMALLOC_ALLOC_JUNK, usize);
 
+	arena_decay_tick(tsdn, arena);
 	return (ret);
 }
 
 #ifdef JEMALLOC_JET
 #undef huge_dalloc_junk
 #define	huge_dalloc_junk JEMALLOC_N(huge_dalloc_junk_impl)
@@ -113,24 +124,24 @@
 	if (config_fill && have_dss && unlikely(opt_junk_free)) {
 		/*
 		 * Only bother junk filling if the chunk isn't about to be
 		 * unmapped.
 		 */
 		if (!config_munmap || (have_dss && chunk_in_dss(ptr)))
-			memset(ptr, 0x5a, usize);
+			memset(ptr, JEMALLOC_FREE_JUNK, usize);
 	}
 }
 #ifdef JEMALLOC_JET
 #undef huge_dalloc_junk
 #define	huge_dalloc_junk JEMALLOC_N(huge_dalloc_junk)
 huge_dalloc_junk_t *huge_dalloc_junk = JEMALLOC_N(huge_dalloc_junk_impl);
 #endif
 
 static void
-huge_ralloc_no_move_similar(void *ptr, size_t oldsize, size_t usize_min,
-    size_t usize_max, bool zero)
+huge_ralloc_no_move_similar(tsdn_t *tsdn, void *ptr, size_t oldsize,
+    size_t usize_min, size_t usize_max, bool zero)
 {
 	size_t usize, usize_next;
 	extent_node_t *node;
 	arena_t *arena;
 	chunk_hooks_t chunk_hooks = CHUNK_HOOKS_INITIALIZER;
 	bool pre_zeroed, post_zeroed;
@@ -148,58 +159,63 @@
 	pre_zeroed = extent_node_zeroed_get(node);
 
 	/* Fill if necessary (shrinking). */
 	if (oldsize > usize) {
 		size_t sdiff = oldsize - usize;
 		if (config_fill && unlikely(opt_junk_free)) {
-			memset((void *)((uintptr_t)ptr + usize), 0x5a, sdiff);
+			memset((void *)((uintptr_t)ptr + usize),
+			    JEMALLOC_FREE_JUNK, sdiff);
 			post_zeroed = false;
 		} else {
-			post_zeroed = !chunk_purge_wrapper(arena, &chunk_hooks,
-			    ptr, CHUNK_CEILING(oldsize), usize, sdiff);
+			post_zeroed = !chunk_purge_wrapper(tsdn, arena,
+			    &chunk_hooks, ptr, CHUNK_CEILING(oldsize), usize,
+			    sdiff);
 		}
 	} else
 		post_zeroed = pre_zeroed;
 
-	malloc_mutex_lock(&arena->huge_mtx);
+	malloc_mutex_lock(tsdn, &arena->huge_mtx);
 	/* Update the size of the huge allocation. */
+	huge_node_unset(ptr, node);
 	assert(extent_node_size_get(node) != usize);
 	extent_node_size_set(node, usize);
+	huge_node_reset(tsdn, ptr, node);
 	/* Update zeroed. */
 	extent_node_zeroed_set(node, post_zeroed);
-	malloc_mutex_unlock(&arena->huge_mtx);
+	malloc_mutex_unlock(tsdn, &arena->huge_mtx);
 
-	arena_chunk_ralloc_huge_similar(arena, ptr, oldsize, usize);
+	arena_chunk_ralloc_huge_similar(tsdn, arena, ptr, oldsize, usize);
 
 	/* Fill if necessary (growing). */
 	if (oldsize < usize) {
 		if (zero || (config_fill && unlikely(opt_zero))) {
 			if (!pre_zeroed) {
 				memset((void *)((uintptr_t)ptr + oldsize), 0,
 				    usize - oldsize);
 			}
 		} else if (config_fill && unlikely(opt_junk_alloc)) {
-			memset((void *)((uintptr_t)ptr + oldsize), 0xa5, usize -
-			    oldsize);
+			memset((void *)((uintptr_t)ptr + oldsize),
+			    JEMALLOC_ALLOC_JUNK, usize - oldsize);
 		}
 	}
 }
 
 static bool
-huge_ralloc_no_move_shrink(void *ptr, size_t oldsize, size_t usize)
+huge_ralloc_no_move_shrink(tsdn_t *tsdn, void *ptr, size_t oldsize,
+    size_t usize)
 {
 	extent_node_t *node;
 	arena_t *arena;
 	chunk_hooks_t chunk_hooks;
 	size_t cdiff;
 	bool pre_zeroed, post_zeroed;
 
 	node = huge_node_get(ptr);
 	arena = extent_node_arena_get(node);
 	pre_zeroed = extent_node_zeroed_get(node);
-	chunk_hooks = chunk_hooks_get(arena);
+	chunk_hooks = chunk_hooks_get(tsdn, arena);
 
 	assert(oldsize > usize);
 
 	/* Split excess chunks. */
 	cdiff = CHUNK_CEILING(oldsize) - CHUNK_CEILING(usize);
 	if (cdiff != 0 && chunk_hooks.split(ptr, CHUNK_CEILING(oldsize),
@@ -210,226 +226,252 @@
 		size_t sdiff = oldsize - usize;
 		if (config_fill && unlikely(opt_junk_free)) {
 			huge_dalloc_junk((void *)((uintptr_t)ptr + usize),
 			    sdiff);
 			post_zeroed = false;
 		} else {
-			post_zeroed = !chunk_purge_wrapper(arena, &chunk_hooks,
-			    CHUNK_ADDR2BASE((uintptr_t)ptr + usize),
-			    CHUNK_CEILING(oldsize),
+			post_zeroed = !chunk_purge_wrapper(tsdn, arena,
+			    &chunk_hooks, CHUNK_ADDR2BASE((uintptr_t)ptr +
+			    usize), CHUNK_CEILING(oldsize),
 			    CHUNK_ADDR2OFFSET((uintptr_t)ptr + usize), sdiff);
 		}
 	} else
 		post_zeroed = pre_zeroed;
 
-	malloc_mutex_lock(&arena->huge_mtx);
+	malloc_mutex_lock(tsdn, &arena->huge_mtx);
 	/* Update the size of the huge allocation. */
+	huge_node_unset(ptr, node);
 	extent_node_size_set(node, usize);
+	huge_node_reset(tsdn, ptr, node);
 	/* Update zeroed. */
 	extent_node_zeroed_set(node, post_zeroed);
-	malloc_mutex_unlock(&arena->huge_mtx);
+	malloc_mutex_unlock(tsdn, &arena->huge_mtx);
 
 	/* Zap the excess chunks. */
-	arena_chunk_ralloc_huge_shrink(arena, ptr, oldsize, usize);
+	arena_chunk_ralloc_huge_shrink(tsdn, arena, ptr, oldsize, usize,
+	    extent_node_sn_get(node));
 
 	return (false);
 }
 
 static bool
-huge_ralloc_no_move_expand(void *ptr, size_t oldsize, size_t usize, bool zero) {
+huge_ralloc_no_move_expand(tsdn_t *tsdn, void *ptr, size_t oldsize,
+    size_t usize, bool zero) {
 	extent_node_t *node;
 	arena_t *arena;
 	bool is_zeroed_subchunk, is_zeroed_chunk;
 
 	node = huge_node_get(ptr);
 	arena = extent_node_arena_get(node);
-	malloc_mutex_lock(&arena->huge_mtx);
+	malloc_mutex_lock(tsdn, &arena->huge_mtx);
 	is_zeroed_subchunk = extent_node_zeroed_get(node);
-	malloc_mutex_unlock(&arena->huge_mtx);
+	malloc_mutex_unlock(tsdn, &arena->huge_mtx);
 
 	/*
-	 * Copy zero into is_zeroed_chunk and pass the copy to chunk_alloc(), so
-	 * that it is possible to make correct junk/zero fill decisions below.
+	 * Use is_zeroed_chunk to detect whether the trailing memory is zeroed,
+	 * update extent's zeroed field, and zero as necessary.
 	 */
-	is_zeroed_chunk = zero;
-
-	if (arena_chunk_ralloc_huge_expand(arena, ptr, oldsize, usize,
+	is_zeroed_chunk = false;
+	if (arena_chunk_ralloc_huge_expand(tsdn, arena, ptr, oldsize, usize,
 	     &is_zeroed_chunk))
 		return (true);
 
-	malloc_mutex_lock(&arena->huge_mtx);
-	/* Update the size of the huge allocation. */
+	malloc_mutex_lock(tsdn, &arena->huge_mtx);
+	huge_node_unset(ptr, node);
 	extent_node_size_set(node, usize);
-	malloc_mutex_unlock(&arena->huge_mtx);
+	extent_node_zeroed_set(node, extent_node_zeroed_get(node) &&
+	    is_zeroed_chunk);
+	huge_node_reset(tsdn, ptr, node);
+	malloc_mutex_unlock(tsdn, &arena->huge_mtx);
 
 	if (zero || (config_fill && unlikely(opt_zero))) {
 		if (!is_zeroed_subchunk) {
 			memset((void *)((uintptr_t)ptr + oldsize), 0,
 			    CHUNK_CEILING(oldsize) - oldsize);
 		}
 		if (!is_zeroed_chunk) {
 			memset((void *)((uintptr_t)ptr +
 			    CHUNK_CEILING(oldsize)), 0, usize -
 			    CHUNK_CEILING(oldsize));
 		}
 	} else if (config_fill && unlikely(opt_junk_alloc)) {
-		memset((void *)((uintptr_t)ptr + oldsize), 0xa5, usize -
-		    oldsize);
+		memset((void *)((uintptr_t)ptr + oldsize), JEMALLOC_ALLOC_JUNK,
+		    usize - oldsize);
 	}
 
 	return (false);
 }
 
 bool
-huge_ralloc_no_move(void *ptr, size_t oldsize, size_t usize_min,
+huge_ralloc_no_move(tsdn_t *tsdn, void *ptr, size_t oldsize, size_t usize_min,
     size_t usize_max, bool zero)
 {
 
 	assert(s2u(oldsize) == oldsize);
+	/* The following should have been caught by callers. */
+	assert(usize_min > 0 && usize_max <= HUGE_MAXCLASS);
 
 	/* Both allocations must be huge to avoid a move. */
 	if (oldsize < chunksize || usize_max < chunksize)
 		return (true);
 
 	if (CHUNK_CEILING(usize_max) > CHUNK_CEILING(oldsize)) {
 		/* Attempt to expand the allocation in-place. */
-		if (!huge_ralloc_no_move_expand(ptr, oldsize, usize_max, zero))
+		if (!huge_ralloc_no_move_expand(tsdn, ptr, oldsize, usize_max,
+		    zero)) {
+			arena_decay_tick(tsdn, huge_aalloc(ptr));
 			return (false);
+		}
 		/* Try again, this time with usize_min. */
 		if (usize_min < usize_max && CHUNK_CEILING(usize_min) >
-		    CHUNK_CEILING(oldsize) && huge_ralloc_no_move_expand(ptr,
-		    oldsize, usize_min, zero))
+		    CHUNK_CEILING(oldsize) && huge_ralloc_no_move_expand(tsdn,
+		    ptr, oldsize, usize_min, zero)) {
+			arena_decay_tick(tsdn, huge_aalloc(ptr));
 			return (false);
+		}
 	}
 
 	/*
 	 * Avoid moving the allocation if the existing chunk size accommodates
 	 * the new size.
 	 */
 	if (CHUNK_CEILING(oldsize) >= CHUNK_CEILING(usize_min)
 	    && CHUNK_CEILING(oldsize) <= CHUNK_CEILING(usize_max)) {
-		huge_ralloc_no_move_similar(ptr, oldsize, usize_min, usize_max,
-		    zero);
+		huge_ralloc_no_move_similar(tsdn, ptr, oldsize, usize_min,
+		    usize_max, zero);
+		arena_decay_tick(tsdn, huge_aalloc(ptr));
 		return (false);
 	}
 
 	/* Attempt to shrink the allocation in-place. */
-	if (CHUNK_CEILING(oldsize) > CHUNK_CEILING(usize_max))
-		return (huge_ralloc_no_move_shrink(ptr, oldsize, usize_max));
+	if (CHUNK_CEILING(oldsize) > CHUNK_CEILING(usize_max)) {
+		if (!huge_ralloc_no_move_shrink(tsdn, ptr, oldsize,
+		    usize_max)) {
+			arena_decay_tick(tsdn, huge_aalloc(ptr));
+			return (false);
+		}
+	}
 	return (true);
 }
 
 static void *
-huge_ralloc_move_helper(tsd_t *tsd, arena_t *arena, size_t usize,
-    size_t alignment, bool zero, tcache_t *tcache)
+huge_ralloc_move_helper(tsdn_t *tsdn, arena_t *arena, size_t usize,
+    size_t alignment, bool zero)
 {
 
 	if (alignment <= chunksize)
-		return (huge_malloc(tsd, arena, usize, zero, tcache));
-	return (huge_palloc(tsd, arena, usize, alignment, zero, tcache));
+		return (huge_malloc(tsdn, arena, usize, zero));
+	return (huge_palloc(tsdn, arena, usize, alignment, zero));
 }
 
 void *
-huge_ralloc(tsd_t *tsd, arena_t *arena, void *ptr, size_t oldsize, size_t usize,
-    size_t alignment, bool zero, tcache_t *tcache)
+huge_ralloc(tsd_t *tsd, arena_t *arena, void *ptr, size_t oldsize,
+    size_t usize, size_t alignment, bool zero, tcache_t *tcache)
 {
 	void *ret;
 	size_t copysize;
 
+	/* The following should have been caught by callers. */
+	assert(usize > 0 && usize <= HUGE_MAXCLASS);
+
 	/* Try to avoid moving the allocation. */
-	if (!huge_ralloc_no_move(ptr, oldsize, usize, usize, zero))
+	if (!huge_ralloc_no_move(tsd_tsdn(tsd), ptr, oldsize, usize, usize,
+	    zero))
 		return (ptr);
 
 	/*
 	 * usize and oldsize are different enough that we need to use a
 	 * different size class.  In that case, fall back to allocating new
 	 * space and copying.
 	 */
-	ret = huge_ralloc_move_helper(tsd, arena, usize, alignment, zero,
-	    tcache);
+	ret = huge_ralloc_move_helper(tsd_tsdn(tsd), arena, usize, alignment,
+	    zero);
 	if (ret == NULL)
 		return (NULL);
 
 	copysize = (usize < oldsize) ? usize : oldsize;
 	memcpy(ret, ptr, copysize);
-	isqalloc(tsd, ptr, oldsize, tcache);
+	isqalloc(tsd, ptr, oldsize, tcache, true);
 	return (ret);
 }
 
 void
-huge_dalloc(tsd_t *tsd, void *ptr, tcache_t *tcache)
+huge_dalloc(tsdn_t *tsdn, void *ptr)
 {
 	extent_node_t *node;
 	arena_t *arena;
 
 	node = huge_node_get(ptr);
 	arena = extent_node_arena_get(node);
 	huge_node_unset(ptr, node);
-	malloc_mutex_lock(&arena->huge_mtx);
+	malloc_mutex_lock(tsdn, &arena->huge_mtx);
 	ql_remove(&arena->huge, node, ql_link);
-	malloc_mutex_unlock(&arena->huge_mtx);
+	malloc_mutex_unlock(tsdn, &arena->huge_mtx);
 
 	huge_dalloc_junk(extent_node_addr_get(node),
 	    extent_node_size_get(node));
-	arena_chunk_dalloc_huge(extent_node_arena_get(node),
-	    extent_node_addr_get(node), extent_node_size_get(node));
-	idalloctm(tsd, node, tcache, true);
+	arena_chunk_dalloc_huge(tsdn, extent_node_arena_get(node),
+	    extent_node_addr_get(node), extent_node_size_get(node),
+	    extent_node_sn_get(node));
+	idalloctm(tsdn, node, NULL, true, true);
+
+	arena_decay_tick(tsdn, arena);
 }
 
 arena_t *
 huge_aalloc(const void *ptr)
 {
 
 	return (extent_node_arena_get(huge_node_get(ptr)));
 }
 
 size_t
-huge_salloc(const void *ptr)
+huge_salloc(tsdn_t *tsdn, const void *ptr)
 {
 	size_t size;
 	extent_node_t *node;
 	arena_t *arena;
 
 	node = huge_node_get(ptr);
 	arena = extent_node_arena_get(node);
-	malloc_mutex_lock(&arena->huge_mtx);
+	malloc_mutex_lock(tsdn, &arena->huge_mtx);
 	size = extent_node_size_get(node);
-	malloc_mutex_unlock(&arena->huge_mtx);
+	malloc_mutex_unlock(tsdn, &arena->huge_mtx);
 
 	return (size);
 }
 
 prof_tctx_t *
-huge_prof_tctx_get(const void *ptr)
+huge_prof_tctx_get(tsdn_t *tsdn, const void *ptr)
 {
 	prof_tctx_t *tctx;
 	extent_node_t *node;
 	arena_t *arena;
 
 	node = huge_node_get(ptr);
 	arena = extent_node_arena_get(node);
-	malloc_mutex_lock(&arena->huge_mtx);
+	malloc_mutex_lock(tsdn, &arena->huge_mtx);
 	tctx = extent_node_prof_tctx_get(node);
-	malloc_mutex_unlock(&arena->huge_mtx);
+	malloc_mutex_unlock(tsdn, &arena->huge_mtx);
 
 	return (tctx);
 }
 
 void
-huge_prof_tctx_set(const void *ptr, prof_tctx_t *tctx)
+huge_prof_tctx_set(tsdn_t *tsdn, const void *ptr, prof_tctx_t *tctx)
 {
 	extent_node_t *node;
 	arena_t *arena;
 
 	node = huge_node_get(ptr);
 	arena = extent_node_arena_get(node);
-	malloc_mutex_lock(&arena->huge_mtx);
+	malloc_mutex_lock(tsdn, &arena->huge_mtx);
 	extent_node_prof_tctx_set(node, tctx);
-	malloc_mutex_unlock(&arena->huge_mtx);
+	malloc_mutex_unlock(tsdn, &arena->huge_mtx);
 }
 
 void
-huge_prof_tctx_reset(const void *ptr)
+huge_prof_tctx_reset(tsdn_t *tsdn, const void *ptr)
 {
 
-	huge_prof_tctx_set(ptr, (prof_tctx_t *)(uintptr_t)1U);
+	huge_prof_tctx_set(tsdn, ptr, (prof_tctx_t *)(uintptr_t)1U);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.d	2017-09-27 23:00:23.786935966 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.d	2017-09-27 23:01:59.362932464 +0800
@@ -1,18 +1,21 @@
 src/huge.o: src/huge.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.c	2017-01-31 23:32:23.000000000 +0800
@@ -2,13 +2,17 @@
 #include "jemalloc/internal/jemalloc_internal.h"
 
 /******************************************************************************/
 /* Data. */
 
 /* Runtime configuration options. */
-const char	*je_malloc_conf JEMALLOC_ATTR(weak);
+const char	*je_malloc_conf
+#ifndef _WIN32
+    JEMALLOC_ATTR(weak)
+#endif
+    ;
 bool	opt_abort =
 #ifdef JEMALLOC_DEBUG
     true
 #else
     false
 #endif
@@ -37,45 +41,73 @@
 
 size_t	opt_quarantine = ZU(0);
 bool	opt_redzone = false;
 bool	opt_utrace = false;
 bool	opt_xmalloc = false;
 bool	opt_zero = false;
-size_t	opt_narenas = 0;
+unsigned	opt_narenas = 0;
 
 /* Initialized to true if the process is running inside Valgrind. */
 bool	in_valgrind;
 
 unsigned	ncpus;
 
-/* Protects arenas initialization (arenas, narenas_total). */
+/* Protects arenas initialization. */
 static malloc_mutex_t	arenas_lock;
 /*
  * Arenas that are used to service external requests.  Not all elements of the
  * arenas array are necessarily used; arenas are created lazily as needed.
  *
  * arenas[0..narenas_auto) are used for automatic multiplexing of threads and
  * arenas.  arenas[narenas_auto..narenas_total) are only used if the application
  * takes some action to create them and allocate from them.
  */
-static arena_t		**arenas;
-static unsigned		narenas_total;
+arena_t			**arenas;
+static unsigned		narenas_total; /* Use narenas_total_*(). */
 static arena_t		*a0; /* arenas[0]; read-only after initialization. */
-static unsigned		narenas_auto; /* Read-only after initialization. */
+unsigned		narenas_auto; /* Read-only after initialization. */
 
 typedef enum {
 	malloc_init_uninitialized	= 3,
 	malloc_init_a0_initialized	= 2,
 	malloc_init_recursible		= 1,
 	malloc_init_initialized		= 0 /* Common case --> jnz. */
 } malloc_init_t;
 static malloc_init_t	malloc_init_state = malloc_init_uninitialized;
 
+/* False should be the common case.  Set to true to trigger initialization. */
+static bool	malloc_slow = true;
+
+/* When malloc_slow is true, set the corresponding bits for sanity check. */
+enum {
+	flag_opt_junk_alloc	= (1U),
+	flag_opt_junk_free	= (1U << 1),
+	flag_opt_quarantine	= (1U << 2),
+	flag_opt_zero		= (1U << 3),
+	flag_opt_utrace		= (1U << 4),
+	flag_in_valgrind	= (1U << 5),
+	flag_opt_xmalloc	= (1U << 6)
+};
+static uint8_t	malloc_slow_flags;
+
+JEMALLOC_ALIGNED(CACHELINE)
+const size_t	pind2sz_tab[NPSIZES] = {
+#define	PSZ_yes(lg_grp, ndelta, lg_delta)				\
+	(((ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta))),
+#define	PSZ_no(lg_grp, ndelta, lg_delta)
+#define	SC(index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup)	\
+	PSZ_##psz(lg_grp, ndelta, lg_delta)
+	SIZE_CLASSES
+#undef PSZ_yes
+#undef PSZ_no
+#undef SC
+};
+
 JEMALLOC_ALIGNED(CACHELINE)
 const size_t	index2size_tab[NSIZES] = {
-#define	SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup) \
+#define	SC(index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup)	\
 	((ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta)),
 	SIZE_CLASSES
 #undef SC
 };
 
 JEMALLOC_ALIGNED(CACHELINE)
@@ -141,13 +173,13 @@
 #define	S2B_10(i)	S2B_9(i) S2B_9(i)
 #endif
 #if LG_TINY_MIN < 11
 #define	S2B_11(i)	S2B_10(i) S2B_10(i)
 #endif
 #define	S2B_no(i)
-#define	SC(index, lg_grp, lg_delta, ndelta, bin, lg_delta_lookup) \
+#define	SC(index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup)	\
 	S2B_##lg_delta_lookup(index)
 	SIZE_CLASSES
 #undef S2B_3
 #undef S2B_4
 #undef S2B_5
 #undef S2B_6
@@ -192,13 +224,13 @@
 	 * lock. So we force an initialization of the lock in
 	 * malloc_init_hard as well. We don't try to care about atomicity
 	 * of the accessed to the init_lock_initialized boolean, since it
 	 * really only matters early in the process creation, before any
 	 * separate thread normally starts doing anything. */
 	if (!init_lock_initialized)
-		malloc_mutex_init(&init_lock);
+		malloc_mutex_init(&init_lock, "init", WITNESS_RANK_INIT);
 	init_lock_initialized = true;
 }
 
 #ifdef _MSC_VER
 #  pragma section(".CRT$XCU", read)
 JEMALLOC_SECTION(".CRT$XCU") JEMALLOC_ATTR(used)
@@ -287,39 +319,39 @@
 	malloc_thread_init();
 
 	return (false);
 }
 
 /*
- * The a0*() functions are used instead of i[mcd]alloc() in situations that
+ * The a0*() functions are used instead of i{d,}alloc() in situations that
  * cannot tolerate TLS variable access.
  */
 
-arena_t *
-a0get(void)
-{
-
-	assert(a0 != NULL);
-	return (a0);
-}
-
 static void *
 a0ialloc(size_t size, bool zero, bool is_metadata)
 {
 
 	if (unlikely(malloc_init_a0()))
 		return (NULL);
 
-	return (iallocztm(NULL, size, zero, false, is_metadata, a0get()));
+	return (iallocztm(TSDN_NULL, size, size2index(size), zero, NULL,
+	    is_metadata, arena_get(TSDN_NULL, 0, true), true));
 }
 
 static void
 a0idalloc(void *ptr, bool is_metadata)
 {
 
-	idalloctm(NULL, ptr, false, is_metadata);
+	idalloctm(TSDN_NULL, ptr, false, is_metadata, true);
+}
+
+arena_t *
+a0get(void)
+{
+
+	return (a0);
 }
 
 void *
 a0malloc(size_t size)
 {
 
@@ -370,230 +402,234 @@
 	if (unlikely(ptr == NULL))
 		return;
 
 	a0idalloc(ptr, false);
 }
 
+static void
+arena_set(unsigned ind, arena_t *arena)
+{
+
+	atomic_write_p((void **)&arenas[ind], arena);
+}
+
+static void
+narenas_total_set(unsigned narenas)
+{
+
+	atomic_write_u(&narenas_total, narenas);
+}
+
+static void
+narenas_total_inc(void)
+{
+
+	atomic_add_u(&narenas_total, 1);
+}
+
+unsigned
+narenas_total_get(void)
+{
+
+	return (atomic_read_u(&narenas_total));
+}
+
 /* Create a new arena and insert it into the arenas array at index ind. */
 static arena_t *
-arena_init_locked(unsigned ind)
+arena_init_locked(tsdn_t *tsdn, unsigned ind)
 {
 	arena_t *arena;
 
-	/* Expand arenas if necessary. */
-	assert(ind <= narenas_total);
+	assert(ind <= narenas_total_get());
 	if (ind > MALLOCX_ARENA_MAX)
 		return (NULL);
-	if (ind == narenas_total) {
-		unsigned narenas_new = narenas_total + 1;
-		arena_t **arenas_new =
-		    (arena_t **)a0malloc(CACHELINE_CEILING(narenas_new *
-		    sizeof(arena_t *)));
-		if (arenas_new == NULL)
-			return (NULL);
-		memcpy(arenas_new, arenas, narenas_total * sizeof(arena_t *));
-		arenas_new[ind] = NULL;
-		/*
-		 * Deallocate only if arenas came from a0malloc() (not
-		 * base_alloc()).
-		 */
-		if (narenas_total != narenas_auto)
-			a0dalloc(arenas);
-		arenas = arenas_new;
-		narenas_total = narenas_new;
-	}
+	if (ind == narenas_total_get())
+		narenas_total_inc();
 
 	/*
 	 * Another thread may have already initialized arenas[ind] if it's an
 	 * auto arena.
 	 */
-	arena = arenas[ind];
+	arena = arena_get(tsdn, ind, false);
 	if (arena != NULL) {
 		assert(ind < narenas_auto);
 		return (arena);
 	}
 
 	/* Actually initialize the arena. */
-	arena = arenas[ind] = arena_new(ind);
+	arena = arena_new(tsdn, ind);
+	arena_set(ind, arena);
 	return (arena);
 }
 
 arena_t *
-arena_init(unsigned ind)
+arena_init(tsdn_t *tsdn, unsigned ind)
 {
 	arena_t *arena;
 
-	malloc_mutex_lock(&arenas_lock);
-	arena = arena_init_locked(ind);
-	malloc_mutex_unlock(&arenas_lock);
+	malloc_mutex_lock(tsdn, &arenas_lock);
+	arena = arena_init_locked(tsdn, ind);
+	malloc_mutex_unlock(tsdn, &arenas_lock);
 	return (arena);
 }
 
-unsigned
-narenas_total_get(void)
-{
-	unsigned narenas;
-
-	malloc_mutex_lock(&arenas_lock);
-	narenas = narenas_total;
-	malloc_mutex_unlock(&arenas_lock);
-
-	return (narenas);
-}
-
 static void
-arena_bind_locked(tsd_t *tsd, unsigned ind)
+arena_bind(tsd_t *tsd, unsigned ind, bool internal)
 {
 	arena_t *arena;
 
-	arena = arenas[ind];
-	arena->nthreads++;
-
-	if (tsd_nominal(tsd))
-		tsd_arena_set(tsd, arena);
-}
+	if (!tsd_nominal(tsd))
+		return;
 
-static void
-arena_bind(tsd_t *tsd, unsigned ind)
-{
+	arena = arena_get(tsd_tsdn(tsd), ind, false);
+	arena_nthreads_inc(arena, internal);
 
-	malloc_mutex_lock(&arenas_lock);
-	arena_bind_locked(tsd, ind);
-	malloc_mutex_unlock(&arenas_lock);
+	if (internal)
+		tsd_iarena_set(tsd, arena);
+	else
+		tsd_arena_set(tsd, arena);
 }
 
 void
 arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind)
 {
 	arena_t *oldarena, *newarena;
 
-	malloc_mutex_lock(&arenas_lock);
-	oldarena = arenas[oldind];
-	newarena = arenas[newind];
-	oldarena->nthreads--;
-	newarena->nthreads++;
-	malloc_mutex_unlock(&arenas_lock);
+	oldarena = arena_get(tsd_tsdn(tsd), oldind, false);
+	newarena = arena_get(tsd_tsdn(tsd), newind, false);
+	arena_nthreads_dec(oldarena, false);
+	arena_nthreads_inc(newarena, false);
 	tsd_arena_set(tsd, newarena);
 }
 
-unsigned
-arena_nbound(unsigned ind)
-{
-	unsigned nthreads;
-
-	malloc_mutex_lock(&arenas_lock);
-	nthreads = arenas[ind]->nthreads;
-	malloc_mutex_unlock(&arenas_lock);
-	return (nthreads);
-}
-
 static void
-arena_unbind(tsd_t *tsd, unsigned ind)
+arena_unbind(tsd_t *tsd, unsigned ind, bool internal)
 {
 	arena_t *arena;
 
-	malloc_mutex_lock(&arenas_lock);
-	arena = arenas[ind];
-	arena->nthreads--;
-	malloc_mutex_unlock(&arenas_lock);
-	tsd_arena_set(tsd, NULL);
+	arena = arena_get(tsd_tsdn(tsd), ind, false);
+	arena_nthreads_dec(arena, internal);
+	if (internal)
+		tsd_iarena_set(tsd, NULL);
+	else
+		tsd_arena_set(tsd, NULL);
 }
 
-arena_t *
-arena_get_hard(tsd_t *tsd, unsigned ind, bool init_if_missing)
+arena_tdata_t *
+arena_tdata_get_hard(tsd_t *tsd, unsigned ind)
 {
-	arena_t *arena;
-	arena_t **arenas_cache = tsd_arenas_cache_get(tsd);
-	unsigned narenas_cache = tsd_narenas_cache_get(tsd);
+	arena_tdata_t *tdata, *arenas_tdata_old;
+	arena_tdata_t *arenas_tdata = tsd_arenas_tdata_get(tsd);
+	unsigned narenas_tdata_old, i;
+	unsigned narenas_tdata = tsd_narenas_tdata_get(tsd);
 	unsigned narenas_actual = narenas_total_get();
 
-	/* Deallocate old cache if it's too small. */
-	if (arenas_cache != NULL && narenas_cache < narenas_actual) {
-		a0dalloc(arenas_cache);
-		arenas_cache = NULL;
-		narenas_cache = 0;
-		tsd_arenas_cache_set(tsd, arenas_cache);
-		tsd_narenas_cache_set(tsd, narenas_cache);
-	}
-
-	/* Allocate cache if it's missing. */
-	if (arenas_cache == NULL) {
-		bool *arenas_cache_bypassp = tsd_arenas_cache_bypassp_get(tsd);
-		assert(ind < narenas_actual || !init_if_missing);
-		narenas_cache = (ind < narenas_actual) ? narenas_actual : ind+1;
-
-		if (tsd_nominal(tsd) && !*arenas_cache_bypassp) {
-			*arenas_cache_bypassp = true;
-			arenas_cache = (arena_t **)a0malloc(sizeof(arena_t *) *
-			    narenas_cache);
-			*arenas_cache_bypassp = false;
+	/*
+	 * Dissociate old tdata array (and set up for deallocation upon return)
+	 * if it's too small.
+	 */
+	if (arenas_tdata != NULL && narenas_tdata < narenas_actual) {
+		arenas_tdata_old = arenas_tdata;
+		narenas_tdata_old = narenas_tdata;
+		arenas_tdata = NULL;
+		narenas_tdata = 0;
+		tsd_arenas_tdata_set(tsd, arenas_tdata);
+		tsd_narenas_tdata_set(tsd, narenas_tdata);
+	} else {
+		arenas_tdata_old = NULL;
+		narenas_tdata_old = 0;
+	}
+
+	/* Allocate tdata array if it's missing. */
+	if (arenas_tdata == NULL) {
+		bool *arenas_tdata_bypassp = tsd_arenas_tdata_bypassp_get(tsd);
+		narenas_tdata = (ind < narenas_actual) ? narenas_actual : ind+1;
+
+		if (tsd_nominal(tsd) && !*arenas_tdata_bypassp) {
+			*arenas_tdata_bypassp = true;
+			arenas_tdata = (arena_tdata_t *)a0malloc(
+			    sizeof(arena_tdata_t) * narenas_tdata);
+			*arenas_tdata_bypassp = false;
 		}
-		if (arenas_cache == NULL) {
-			/*
-			 * This function must always tell the truth, even if
-			 * it's slow, so don't let OOM, thread cleanup (note
-			 * tsd_nominal check), nor recursive allocation
-			 * avoidance (note arenas_cache_bypass check) get in the
-			 * way.
-			 */
-			if (ind >= narenas_actual)
-				return (NULL);
-			malloc_mutex_lock(&arenas_lock);
-			arena = arenas[ind];
-			malloc_mutex_unlock(&arenas_lock);
-			return (arena);
-		}
-		assert(tsd_nominal(tsd) && !*arenas_cache_bypassp);
-		tsd_arenas_cache_set(tsd, arenas_cache);
-		tsd_narenas_cache_set(tsd, narenas_cache);
+		if (arenas_tdata == NULL) {
+			tdata = NULL;
+			goto label_return;
+		}
+		assert(tsd_nominal(tsd) && !*arenas_tdata_bypassp);
+		tsd_arenas_tdata_set(tsd, arenas_tdata);
+		tsd_narenas_tdata_set(tsd, narenas_tdata);
 	}
 
 	/*
-	 * Copy to cache.  It's possible that the actual number of arenas has
-	 * increased since narenas_total_get() was called above, but that causes
-	 * no correctness issues unless two threads concurrently execute the
-	 * arenas.extend mallctl, which we trust mallctl synchronization to
+	 * Copy to tdata array.  It's possible that the actual number of arenas
+	 * has increased since narenas_total_get() was called above, but that
+	 * causes no correctness issues unless two threads concurrently execute
+	 * the arenas.extend mallctl, which we trust mallctl synchronization to
 	 * prevent.
 	 */
-	malloc_mutex_lock(&arenas_lock);
-	memcpy(arenas_cache, arenas, sizeof(arena_t *) * narenas_actual);
-	malloc_mutex_unlock(&arenas_lock);
-	if (narenas_cache > narenas_actual) {
-		memset(&arenas_cache[narenas_actual], 0, sizeof(arena_t *) *
-		    (narenas_cache - narenas_actual));
+
+	/* Copy/initialize tickers. */
+	for (i = 0; i < narenas_actual; i++) {
+		if (i < narenas_tdata_old) {
+			ticker_copy(&arenas_tdata[i].decay_ticker,
+			    &arenas_tdata_old[i].decay_ticker);
+		} else {
+			ticker_init(&arenas_tdata[i].decay_ticker,
+			    DECAY_NTICKS_PER_UPDATE);
+		}
+	}
+	if (narenas_tdata > narenas_actual) {
+		memset(&arenas_tdata[narenas_actual], 0, sizeof(arena_tdata_t)
+		    * (narenas_tdata - narenas_actual));
 	}
 
-	/* Read the refreshed cache, and init the arena if necessary. */
-	arena = arenas_cache[ind];
-	if (init_if_missing && arena == NULL)
-		arena = arenas_cache[ind] = arena_init(ind);
-	return (arena);
+	/* Read the refreshed tdata array. */
+	tdata = &arenas_tdata[ind];
+label_return:
+	if (arenas_tdata_old != NULL)
+		a0dalloc(arenas_tdata_old);
+	return (tdata);
 }
 
 /* Slow path, called only by arena_choose(). */
 arena_t *
-arena_choose_hard(tsd_t *tsd)
+arena_choose_hard(tsd_t *tsd, bool internal)
 {
-	arena_t *ret;
+	arena_t *ret JEMALLOC_CC_SILENCE_INIT(NULL);
 
 	if (narenas_auto > 1) {
-		unsigned i, choose, first_null;
+		unsigned i, j, choose[2], first_null;
+
+		/*
+		 * Determine binding for both non-internal and internal
+		 * allocation.
+		 *
+		 *   choose[0]: For application allocation.
+		 *   choose[1]: For internal metadata allocation.
+		 */
+
+		for (j = 0; j < 2; j++)
+			choose[j] = 0;
 
-		choose = 0;
 		first_null = narenas_auto;
-		malloc_mutex_lock(&arenas_lock);
-		assert(a0get() != NULL);
+		malloc_mutex_lock(tsd_tsdn(tsd), &arenas_lock);
+		assert(arena_get(tsd_tsdn(tsd), 0, false) != NULL);
 		for (i = 1; i < narenas_auto; i++) {
-			if (arenas[i] != NULL) {
+			if (arena_get(tsd_tsdn(tsd), i, false) != NULL) {
 				/*
 				 * Choose the first arena that has the lowest
 				 * number of threads assigned to it.
 				 */
-				if (arenas[i]->nthreads <
-				    arenas[choose]->nthreads)
-					choose = i;
+				for (j = 0; j < 2; j++) {
+					if (arena_nthreads_get(arena_get(
+					    tsd_tsdn(tsd), i, false), !!j) <
+					    arena_nthreads_get(arena_get(
+					    tsd_tsdn(tsd), choose[j], false),
+					    !!j))
+						choose[j] = i;
+				}
 			} else if (first_null == narenas_auto) {
 				/*
 				 * Record the index of the first uninitialized
 				 * arena, in case all extant arenas are in use.
 				 *
 				 * NB: It is possible for there to be
@@ -602,33 +638,46 @@
 				 * "thread.arena" mallctl.
 				 */
 				first_null = i;
 			}
 		}
 
-		if (arenas[choose]->nthreads == 0
-		    || first_null == narenas_auto) {
-			/*
-			 * Use an unloaded arena, or the least loaded arena if
-			 * all arenas are already initialized.
-			 */
-			ret = arenas[choose];
-		} else {
-			/* Initialize a new arena. */
-			choose = first_null;
-			ret = arena_init_locked(choose);
-			if (ret == NULL) {
-				malloc_mutex_unlock(&arenas_lock);
-				return (NULL);
+		for (j = 0; j < 2; j++) {
+			if (arena_nthreads_get(arena_get(tsd_tsdn(tsd),
+			    choose[j], false), !!j) == 0 || first_null ==
+			    narenas_auto) {
+				/*
+				 * Use an unloaded arena, or the least loaded
+				 * arena if all arenas are already initialized.
+				 */
+				if (!!j == internal) {
+					ret = arena_get(tsd_tsdn(tsd),
+					    choose[j], false);
+				}
+			} else {
+				arena_t *arena;
+
+				/* Initialize a new arena. */
+				choose[j] = first_null;
+				arena = arena_init_locked(tsd_tsdn(tsd),
+				    choose[j]);
+				if (arena == NULL) {
+					malloc_mutex_unlock(tsd_tsdn(tsd),
+					    &arenas_lock);
+					return (NULL);
+				}
+				if (!!j == internal)
+					ret = arena;
 			}
+			arena_bind(tsd, choose[j], !!j);
 		}
-		arena_bind_locked(tsd, choose);
-		malloc_mutex_unlock(&arenas_lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), &arenas_lock);
 	} else {
-		ret = a0get();
-		arena_bind(tsd, 0);
+		ret = arena_get(tsd_tsdn(tsd), 0, false);
+		arena_bind(tsd, 0, false);
+		arena_bind(tsd, 0, true);
 	}
 
 	return (ret);
 }
 
 void
@@ -643,77 +692,93 @@
 {
 
 	/* Do nothing. */
 }
 
 void
+iarena_cleanup(tsd_t *tsd)
+{
+	arena_t *iarena;
+
+	iarena = tsd_iarena_get(tsd);
+	if (iarena != NULL)
+		arena_unbind(tsd, iarena->ind, true);
+}
+
+void
 arena_cleanup(tsd_t *tsd)
 {
 	arena_t *arena;
 
 	arena = tsd_arena_get(tsd);
 	if (arena != NULL)
-		arena_unbind(tsd, arena->ind);
+		arena_unbind(tsd, arena->ind, false);
 }
 
 void
-arenas_cache_cleanup(tsd_t *tsd)
+arenas_tdata_cleanup(tsd_t *tsd)
 {
-	arena_t **arenas_cache;
+	arena_tdata_t *arenas_tdata;
+
+	/* Prevent tsd->arenas_tdata from being (re)created. */
+	*tsd_arenas_tdata_bypassp_get(tsd) = true;
 
-	arenas_cache = tsd_arenas_cache_get(tsd);
-	if (arenas_cache != NULL) {
-		tsd_arenas_cache_set(tsd, NULL);
-		a0dalloc(arenas_cache);
+	arenas_tdata = tsd_arenas_tdata_get(tsd);
+	if (arenas_tdata != NULL) {
+		tsd_arenas_tdata_set(tsd, NULL);
+		a0dalloc(arenas_tdata);
 	}
 }
 
 void
-narenas_cache_cleanup(tsd_t *tsd)
+narenas_tdata_cleanup(tsd_t *tsd)
 {
 
 	/* Do nothing. */
 }
 
 void
-arenas_cache_bypass_cleanup(tsd_t *tsd)
+arenas_tdata_bypass_cleanup(tsd_t *tsd)
 {
 
 	/* Do nothing. */
 }
 
 static void
 stats_print_atexit(void)
 {
 
 	if (config_tcache && config_stats) {
+		tsdn_t *tsdn;
 		unsigned narenas, i;
 
+		tsdn = tsdn_fetch();
+
 		/*
 		 * Merge stats from extant threads.  This is racy, since
 		 * individual threads do not lock when recording tcache stats
 		 * events.  As a consequence, the final stats may be slightly
 		 * out of date by the time they are reported, if other threads
 		 * continue to allocate.
 		 */
 		for (i = 0, narenas = narenas_total_get(); i < narenas; i++) {
-			arena_t *arena = arenas[i];
+			arena_t *arena = arena_get(tsdn, i, false);
 			if (arena != NULL) {
 				tcache_t *tcache;
 
 				/*
 				 * tcache_stats_merge() locks bins, so if any
 				 * code is introduced that acquires both arena
 				 * and bin locks in the opposite order,
 				 * deadlocks may result.
 				 */
-				malloc_mutex_lock(&arena->lock);
+				malloc_mutex_lock(tsdn, &arena->lock);
 				ql_foreach(tcache, &arena->tcache_ql, link) {
-					tcache_stats_merge(tcache, arena);
+					tcache_stats_merge(tsdn, tcache, arena);
 				}
-				malloc_mutex_unlock(&arena->lock);
+				malloc_mutex_unlock(tsdn, &arena->lock);
 			}
 		}
 	}
 	je_malloc_stats_print(NULL, NULL, NULL);
 }
 
@@ -744,12 +809,26 @@
 	long result;
 
 #ifdef _WIN32
 	SYSTEM_INFO si;
 	GetSystemInfo(&si);
 	result = si.dwNumberOfProcessors;
+#elif defined(JEMALLOC_GLIBC_MALLOC_HOOK) && defined(CPU_COUNT)
+	/*
+	 * glibc >= 2.6 has the CPU_COUNT macro.
+	 *
+	 * glibc's sysconf() uses isspace().  glibc allocates for the first time
+	 * *before* setting up the isspace tables.  Therefore we need a
+	 * different method to get the number of CPUs.
+	 */
+	{
+		cpu_set_t set;
+
+		pthread_getaffinity_np(pthread_self(), sizeof(set), &set);
+		result = CPU_COUNT(&set);
+	}
 #else
 	result = sysconf(_SC_NPROCESSORS_ONLN);
 #endif
 	return ((result == -1) ? 1 : (unsigned)result);
 }
 
@@ -836,12 +915,32 @@
 
 	malloc_printf("<jemalloc>: %s: %.*s:%.*s\n", msg, (int)klen, k,
 	    (int)vlen, v);
 }
 
 static void
+malloc_slow_flag_init(void)
+{
+	/*
+	 * Combine the runtime options into malloc_slow for fast path.  Called
+	 * after processing all the options.
+	 */
+	malloc_slow_flags |= (opt_junk_alloc ? flag_opt_junk_alloc : 0)
+	    | (opt_junk_free ? flag_opt_junk_free : 0)
+	    | (opt_quarantine ? flag_opt_quarantine : 0)
+	    | (opt_zero ? flag_opt_zero : 0)
+	    | (opt_utrace ? flag_opt_utrace : 0)
+	    | (opt_xmalloc ? flag_opt_xmalloc : 0);
+
+	if (config_valgrind)
+		malloc_slow_flags |= (in_valgrind ? flag_in_valgrind : 0);
+
+	malloc_slow = (malloc_slow_flags != 0);
+}
+
+static void
 malloc_conf_init(void)
 {
 	unsigned i;
 	char buf[PATH_MAX + 1];
 	const char *opts, *k, *v;
 	size_t klen, vlen;
@@ -861,30 +960,33 @@
 			opt_redzone = true;
 		}
 		if (config_tcache && unlikely(in_valgrind))
 			opt_tcache = false;
 	}
 
-	for (i = 0; i < 3; i++) {
+	for (i = 0; i < 4; i++) {
 		/* Get runtime configuration. */
 		switch (i) {
 		case 0:
+			opts = config_malloc_conf;
+			break;
+		case 1:
 			if (je_malloc_conf != NULL) {
 				/*
 				 * Use options that were compiled into the
 				 * program.
 				 */
 				opts = je_malloc_conf;
 			} else {
 				/* No configuration specified. */
 				buf[0] = '\0';
 				opts = buf;
 			}
 			break;
-		case 1: {
-			int linklen = 0;
+		case 2: {
+			ssize_t linklen = 0;
 #ifndef _WIN32
 			int saved_errno = errno;
 			const char *linkname =
 #  ifdef JEMALLOC_PREFIX
 			    "/etc/"JEMALLOC_PREFIX"malloc.conf"
 #  else
@@ -904,13 +1006,13 @@
 				set_errno(saved_errno);
 			}
 #endif
 			buf[linklen] = '\0';
 			opts = buf;
 			break;
-		} case 2: {
+		} case 3: {
 			const char *envname =
 #ifdef JEMALLOC_PREFIX
 			    JEMALLOC_CPREFIX"MALLOC_CONF"
 #else
 			    "MALLOC_CONF"
 #endif
@@ -951,43 +1053,58 @@
 					    "Invalid conf value",	\
 					    k, klen, v, vlen);		\
 				}					\
 				if (cont)				\
 					continue;			\
 			}
-#define	CONF_HANDLE_SIZE_T(o, n, min, max, clip)			\
+#define	CONF_MIN_no(um, min)	false
+#define	CONF_MIN_yes(um, min)	((um) < (min))
+#define	CONF_MAX_no(um, max)	false
+#define	CONF_MAX_yes(um, max)	((um) > (max))
+#define	CONF_HANDLE_T_U(t, o, n, min, max, check_min, check_max, clip)	\
 			if (CONF_MATCH(n)) {				\
 				uintmax_t um;				\
 				char *end;				\
 									\
 				set_errno(0);				\
 				um = malloc_strtoumax(v, &end, 0);	\
 				if (get_errno() != 0 || (uintptr_t)end -\
 				    (uintptr_t)v != vlen) {		\
 					malloc_conf_error(		\
 					    "Invalid conf value",	\
 					    k, klen, v, vlen);		\
 				} else if (clip) {			\
-					if ((min) != 0 && um < (min))	\
-						o = (min);		\
-					else if (um > (max))		\
-						o = (max);		\
+					if (CONF_MIN_##check_min(um,	\
+					    (min)))			\
+						o = (t)(min);		\
+					else if (CONF_MAX_##check_max(	\
+					    um, (max)))			\
+						o = (t)(max);		\
 					else				\
-						o = um;			\
+						o = (t)um;		\
 				} else {				\
-					if (((min) != 0 && um < (min))	\
-					    || um > (max)) {		\
+					if (CONF_MIN_##check_min(um,	\
+					    (min)) ||			\
+					    CONF_MAX_##check_max(um,	\
+					    (max))) {			\
 						malloc_conf_error(	\
 						    "Out-of-range "	\
 						    "conf value",	\
 						    k, klen, v, vlen);	\
 					} else				\
-						o = um;			\
+						o = (t)um;		\
 				}					\
 				continue;				\
 			}
+#define	CONF_HANDLE_UNSIGNED(o, n, min, max, check_min, check_max,	\
+    clip)								\
+			CONF_HANDLE_T_U(unsigned, o, n, min, max,	\
+			    check_min, check_max, clip)
+#define	CONF_HANDLE_SIZE_T(o, n, min, max, check_min, check_max, clip)	\
+			CONF_HANDLE_T_U(size_t, o, n, min, max,		\
+			    check_min, check_max, clip)
 #define	CONF_HANDLE_SSIZE_T(o, n, min, max)				\
 			if (CONF_MATCH(n)) {				\
 				long l;					\
 				char *end;				\
 									\
 				set_errno(0);				\
@@ -1024,13 +1141,13 @@
 			 * redzones.  In order to simplify options processing,
 			 * use a conservative bound that accommodates all these
 			 * constraints.
 			 */
 			CONF_HANDLE_SIZE_T(opt_lg_chunk, "lg_chunk", LG_PAGE +
 			    LG_SIZE_CLASS_GROUP + (config_fill ? 2 : 1),
-			    (sizeof(size_t) << 3) - 1, true)
+			    (sizeof(size_t) << 3) - 1, yes, yes, true)
 			if (strncmp("dss", k, klen) == 0) {
 				int i;
 				bool match = false;
 				for (i = 0; i < dss_prec_limit; i++) {
 					if (strncmp(dss_prec_names[i], v, vlen)
 					    == 0) {
@@ -1049,44 +1166,85 @@
 				if (!match) {
 					malloc_conf_error("Invalid conf value",
 					    k, klen, v, vlen);
 				}
 				continue;
 			}
-			CONF_HANDLE_SIZE_T(opt_narenas, "narenas", 1,
-			    SIZE_T_MAX, false)
+			CONF_HANDLE_UNSIGNED(opt_narenas, "narenas", 1,
+			    UINT_MAX, yes, no, false)
+			if (strncmp("purge", k, klen) == 0) {
+				int i;
+				bool match = false;
+				for (i = 0; i < purge_mode_limit; i++) {
+					if (strncmp(purge_mode_names[i], v,
+					    vlen) == 0) {
+						opt_purge = (purge_mode_t)i;
+						match = true;
+						break;
+					}
+				}
+				if (!match) {
+					malloc_conf_error("Invalid conf value",
+					    k, klen, v, vlen);
+				}
+				continue;
+			}
 			CONF_HANDLE_SSIZE_T(opt_lg_dirty_mult, "lg_dirty_mult",
 			    -1, (sizeof(size_t) << 3) - 1)
+			CONF_HANDLE_SSIZE_T(opt_decay_time, "decay_time", -1,
+			    NSTIME_SEC_MAX);
 			CONF_HANDLE_BOOL(opt_stats_print, "stats_print", true)
 			if (config_fill) {
 				if (CONF_MATCH("junk")) {
 					if (CONF_MATCH_VALUE("true")) {
-						opt_junk = "true";
-						opt_junk_alloc = opt_junk_free =
-						    true;
+						if (config_valgrind &&
+						    unlikely(in_valgrind)) {
+							malloc_conf_error(
+							"Deallocation-time "
+							"junk filling cannot "
+							"be enabled while "
+							"running inside "
+							"Valgrind", k, klen, v,
+							vlen);
+						} else {
+							opt_junk = "true";
+							opt_junk_alloc = true;
+							opt_junk_free = true;
+						}
 					} else if (CONF_MATCH_VALUE("false")) {
 						opt_junk = "false";
 						opt_junk_alloc = opt_junk_free =
 						    false;
 					} else if (CONF_MATCH_VALUE("alloc")) {
 						opt_junk = "alloc";
 						opt_junk_alloc = true;
 						opt_junk_free = false;
 					} else if (CONF_MATCH_VALUE("free")) {
-						opt_junk = "free";
-						opt_junk_alloc = false;
-						opt_junk_free = true;
+						if (config_valgrind &&
+						    unlikely(in_valgrind)) {
+							malloc_conf_error(
+							"Deallocation-time "
+							"junk filling cannot "
+							"be enabled while "
+							"running inside "
+							"Valgrind", k, klen, v,
+							vlen);
+						} else {
+							opt_junk = "free";
+							opt_junk_alloc = false;
+							opt_junk_free = true;
+						}
 					} else {
 						malloc_conf_error(
 						    "Invalid conf value", k,
 						    klen, v, vlen);
 					}
 					continue;
 				}
 				CONF_HANDLE_SIZE_T(opt_quarantine, "quarantine",
-				    0, SIZE_T_MAX, false)
+				    0, SIZE_T_MAX, no, no, false)
 				CONF_HANDLE_BOOL(opt_redzone, "redzone", true)
 				CONF_HANDLE_BOOL(opt_zero, "zero", true)
 			}
 			if (config_utrace) {
 				CONF_HANDLE_BOOL(opt_utrace, "utrace", true)
 			}
@@ -1117,14 +1275,14 @@
 				    "prof_prefix", "jeprof")
 				CONF_HANDLE_BOOL(opt_prof_active, "prof_active",
 				    true)
 				CONF_HANDLE_BOOL(opt_prof_thread_active_init,
 				    "prof_thread_active_init", true)
 				CONF_HANDLE_SIZE_T(opt_lg_prof_sample,
-				    "lg_prof_sample", 0,
-				    (sizeof(uint64_t) << 3) - 1, true)
+				    "lg_prof_sample", 0, (sizeof(uint64_t) << 3)
+				    - 1, no, yes, true)
 				CONF_HANDLE_BOOL(opt_prof_accum, "prof_accum",
 				    true)
 				CONF_HANDLE_SSIZE_T(opt_lg_prof_interval,
 				    "lg_prof_interval", -1,
 				    (sizeof(uint64_t) << 3) - 1)
 				CONF_HANDLE_BOOL(opt_prof_gdump, "prof_gdump",
@@ -1134,21 +1292,27 @@
 				CONF_HANDLE_BOOL(opt_prof_leak, "prof_leak",
 				    true)
 			}
 			malloc_conf_error("Invalid conf pair", k, klen, v,
 			    vlen);
 #undef CONF_MATCH
+#undef CONF_MATCH_VALUE
 #undef CONF_HANDLE_BOOL
+#undef CONF_MIN_no
+#undef CONF_MIN_yes
+#undef CONF_MAX_no
+#undef CONF_MAX_yes
+#undef CONF_HANDLE_T_U
+#undef CONF_HANDLE_UNSIGNED
 #undef CONF_HANDLE_SIZE_T
 #undef CONF_HANDLE_SSIZE_T
 #undef CONF_HANDLE_CHAR_P
 		}
 	}
 }
 
-/* init_lock must be held. */
 static bool
 malloc_init_hard_needed(void)
 {
 
 	if (malloc_initialized() || (IS_INITIALIZER && malloc_init_state ==
 	    malloc_init_recursible)) {
@@ -1158,27 +1322,29 @@
 		 * thread, and it is recursively allocating.
 		 */
 		return (false);
 	}
 #ifdef JEMALLOC_THREADED_INIT
 	if (malloc_initializer != NO_INITIALIZER && !IS_INITIALIZER) {
+		spin_t spinner;
+
 		/* Busy-wait until the initializing thread completes. */
+		spin_init(&spinner);
 		do {
-			malloc_mutex_unlock(&init_lock);
-			CPU_SPINWAIT;
-			malloc_mutex_lock(&init_lock);
+			malloc_mutex_unlock(TSDN_NULL, &init_lock);
+			spin_adaptive(&spinner);
+			malloc_mutex_lock(TSDN_NULL, &init_lock);
 		} while (!malloc_initialized());
 		return (false);
 	}
 #endif
 	return (true);
 }
 
-/* init_lock must be held. */
 static bool
-malloc_init_hard_a0_locked(void)
+malloc_init_hard_a0_locked()
 {
 
 	malloc_initializer = INITIALIZER;
 
 	if (config_prof)
 		prof_boot0();
@@ -1188,40 +1354,43 @@
 		if (atexit(stats_print_atexit) != 0) {
 			malloc_write("<jemalloc>: Error in atexit()\n");
 			if (opt_abort)
 				abort();
 		}
 	}
+	pages_boot();
 	if (base_boot())
 		return (true);
 	if (chunk_boot())
 		return (true);
 	if (ctl_boot())
 		return (true);
 	if (config_prof)
 		prof_boot1();
-	if (arena_boot())
-		return (true);
-	if (config_tcache && tcache_boot())
+	arena_boot();
+	if (config_tcache && tcache_boot(TSDN_NULL))
 		return (true);
-	if (malloc_mutex_init(&arenas_lock))
+	if (malloc_mutex_init(&arenas_lock, "arenas", WITNESS_RANK_ARENAS))
 		return (true);
 	/*
 	 * Create enough scaffolding to allow recursive allocation in
 	 * malloc_ncpus().
 	 */
-	narenas_total = narenas_auto = 1;
+	narenas_auto = 1;
+	narenas_total_set(narenas_auto);
 	arenas = &a0;
 	memset(arenas, 0, sizeof(arena_t *) * narenas_auto);
 	/*
 	 * Initialize one arena here.  The rest are lazily created in
 	 * arena_choose_hard().
 	 */
-	if (arena_init(0) == NULL)
+	if (arena_init(TSDN_NULL, 0) == NULL)
 		return (true);
+
 	malloc_init_state = malloc_init_a0_initialized;
+
 	return (false);
 }
 
 static bool
 malloc_init_hard_a0(void)
 {
@@ -1224,51 +1393,48 @@
 
 static bool
 malloc_init_hard_a0(void)
 {
 	bool ret;
 
-	malloc_mutex_lock(&init_lock);
+	malloc_mutex_lock(TSDN_NULL, &init_lock);
 	ret = malloc_init_hard_a0_locked();
-	malloc_mutex_unlock(&init_lock);
+	malloc_mutex_unlock(TSDN_NULL, &init_lock);
 	return (ret);
 }
 
-/*
- * Initialize data structures which may trigger recursive allocation.
- *
- * init_lock must be held.
- */
-static void
+/* Initialize data structures which may trigger recursive allocation. */
+static bool
 malloc_init_hard_recursible(void)
 {
 
 	malloc_init_state = malloc_init_recursible;
-	malloc_mutex_unlock(&init_lock);
 
 	ncpus = malloc_ncpus();
 
-#if (!defined(JEMALLOC_MUTEX_INIT_CB) && !defined(JEMALLOC_ZONE) \
-    && !defined(_WIN32) && !defined(__native_client__))
-	/* LinuxThreads's pthread_atfork() allocates. */
+#if (defined(JEMALLOC_HAVE_PTHREAD_ATFORK) && !defined(JEMALLOC_MUTEX_INIT_CB) \
+    && !defined(JEMALLOC_ZONE) && !defined(_WIN32) && \
+    !defined(__native_client__))
+	/* LinuxThreads' pthread_atfork() allocates. */
 	if (pthread_atfork(jemalloc_prefork, jemalloc_postfork_parent,
 	    jemalloc_postfork_child) != 0) {
 		malloc_write("<jemalloc>: Error in pthread_atfork()\n");
 		if (opt_abort)
 			abort();
+		return (true);
 	}
 #endif
-	malloc_mutex_lock(&init_lock);
+
+	return (false);
 }
 
-/* init_lock must be held. */
 static bool
-malloc_init_hard_finish(void)
+malloc_init_hard_finish(tsdn_t *tsdn)
 {
 
-	if (mutex_boot())
+	if (malloc_mutex_boot())
 		return (true);
 
 	if (opt_narenas == 0) {
 		/*
 		 * For SMP systems, create more than one arena per CPU by
 		 * default.
@@ -1277,74 +1443,75 @@
 			opt_narenas = ncpus << 2;
 		else
 			opt_narenas = 1;
 	}
 	narenas_auto = opt_narenas;
 	/*
-	 * Make sure that the arenas array can be allocated.  In practice, this
-	 * limit is enough to allow the allocator to function, but the ctl
-	 * machinery will fail to allocate memory at far lower limits.
+	 * Limit the number of arenas to the indexing range of MALLOCX_ARENA().
 	 */
-	if (narenas_auto > chunksize / sizeof(arena_t *)) {
-		narenas_auto = chunksize / sizeof(arena_t *);
+	if (narenas_auto > MALLOCX_ARENA_MAX) {
+		narenas_auto = MALLOCX_ARENA_MAX;
 		malloc_printf("<jemalloc>: Reducing narenas to limit (%d)\n",
 		    narenas_auto);
 	}
-	narenas_total = narenas_auto;
+	narenas_total_set(narenas_auto);
 
 	/* Allocate and initialize arenas. */
-	arenas = (arena_t **)base_alloc(sizeof(arena_t *) * narenas_total);
+	arenas = (arena_t **)base_alloc(tsdn, sizeof(arena_t *) *
+	    (MALLOCX_ARENA_MAX+1));
 	if (arenas == NULL)
 		return (true);
-	/*
-	 * Zero the array.  In practice, this should always be pre-zeroed,
-	 * since it was just mmap()ed, but let's be sure.
-	 */
-	memset(arenas, 0, sizeof(arena_t *) * narenas_total);
 	/* Copy the pointer to the one arena that was already initialized. */
-	arenas[0] = a0;
+	arena_set(0, a0);
 
 	malloc_init_state = malloc_init_initialized;
+	malloc_slow_flag_init();
+
 	return (false);
 }
 
 static bool
 malloc_init_hard(void)
 {
+	tsd_t *tsd;
 
 #if defined(_WIN32) && _WIN32_WINNT < 0x0600
 	_init_init_lock();
 #endif
-	malloc_mutex_lock(&init_lock);
+	malloc_mutex_lock(TSDN_NULL, &init_lock);
 	if (!malloc_init_hard_needed()) {
-		malloc_mutex_unlock(&init_lock);
+		malloc_mutex_unlock(TSDN_NULL, &init_lock);
 		return (false);
 	}
 
 	if (malloc_init_state != malloc_init_a0_initialized &&
 	    malloc_init_hard_a0_locked()) {
-		malloc_mutex_unlock(&init_lock);
+		malloc_mutex_unlock(TSDN_NULL, &init_lock);
 		return (true);
 	}
-	if (malloc_tsd_boot0()) {
-		malloc_mutex_unlock(&init_lock);
+
+	malloc_mutex_unlock(TSDN_NULL, &init_lock);
+	/* Recursive allocation relies on functional tsd. */
+	tsd = malloc_tsd_boot0();
+	if (tsd == NULL)
 		return (true);
-	}
-	if (config_prof && prof_boot2()) {
-		malloc_mutex_unlock(&init_lock);
+	if (malloc_init_hard_recursible())
 		return (true);
-	}
+	malloc_mutex_lock(tsd_tsdn(tsd), &init_lock);
 
-	malloc_init_hard_recursible();
+	if (config_prof && prof_boot2(tsd)) {
+		malloc_mutex_unlock(tsd_tsdn(tsd), &init_lock);
+		return (true);
+	}
 
-	if (malloc_init_hard_finish()) {
-		malloc_mutex_unlock(&init_lock);
+	if (malloc_init_hard_finish(tsd_tsdn(tsd))) {
+		malloc_mutex_unlock(tsd_tsdn(tsd), &init_lock);
 		return (true);
 	}
 
-	malloc_mutex_unlock(&init_lock);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &init_lock);
 	malloc_tsd_boot1();
 	return (false);
 }
 
 /*
  * End initialization functions.
@@ -1352,96 +1519,134 @@
 /******************************************************************************/
 /*
  * Begin malloc(3)-compatible functions.
  */
 
 static void *
-imalloc_prof_sample(tsd_t *tsd, size_t usize, prof_tctx_t *tctx)
+ialloc_prof_sample(tsd_t *tsd, size_t usize, szind_t ind, bool zero,
+    prof_tctx_t *tctx, bool slow_path)
 {
 	void *p;
 
 	if (tctx == NULL)
 		return (NULL);
 	if (usize <= SMALL_MAXCLASS) {
-		p = imalloc(tsd, LARGE_MINCLASS);
+		szind_t ind_large = size2index(LARGE_MINCLASS);
+		p = ialloc(tsd, LARGE_MINCLASS, ind_large, zero, slow_path);
 		if (p == NULL)
 			return (NULL);
-		arena_prof_promoted(p, usize);
+		arena_prof_promoted(tsd_tsdn(tsd), p, usize);
 	} else
-		p = imalloc(tsd, usize);
+		p = ialloc(tsd, usize, ind, zero, slow_path);
 
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE_C void *
-imalloc_prof(tsd_t *tsd, size_t usize)
+ialloc_prof(tsd_t *tsd, size_t usize, szind_t ind, bool zero, bool slow_path)
 {
 	void *p;
 	prof_tctx_t *tctx;
 
 	tctx = prof_alloc_prep(tsd, usize, prof_active_get_unlocked(), true);
 	if (unlikely((uintptr_t)tctx != (uintptr_t)1U))
-		p = imalloc_prof_sample(tsd, usize, tctx);
+		p = ialloc_prof_sample(tsd, usize, ind, zero, tctx, slow_path);
 	else
-		p = imalloc(tsd, usize);
+		p = ialloc(tsd, usize, ind, zero, slow_path);
 	if (unlikely(p == NULL)) {
 		prof_alloc_rollback(tsd, tctx, true);
 		return (NULL);
 	}
-	prof_malloc(p, usize, tctx);
+	prof_malloc(tsd_tsdn(tsd), p, usize, tctx);
 
 	return (p);
 }
 
+/*
+ * ialloc_body() is inlined so that fast and slow paths are generated separately
+ * with statically known slow_path.
+ *
+ * This function guarantees that *tsdn is non-NULL on success.
+ */
 JEMALLOC_ALWAYS_INLINE_C void *
-imalloc_body(size_t size, tsd_t **tsd, size_t *usize)
+ialloc_body(size_t size, bool zero, tsdn_t **tsdn, size_t *usize,
+    bool slow_path)
 {
+	tsd_t *tsd;
+	szind_t ind;
 
-	if (unlikely(malloc_init()))
+	if (slow_path && unlikely(malloc_init())) {
+		*tsdn = NULL;
 		return (NULL);
-	*tsd = tsd_fetch();
+	}
 
-	if (config_prof && opt_prof) {
-		*usize = s2u(size);
-		if (unlikely(*usize == 0))
-			return (NULL);
-		return (imalloc_prof(*tsd, *usize));
+	tsd = tsd_fetch();
+	*tsdn = tsd_tsdn(tsd);
+	witness_assert_lockless(tsd_tsdn(tsd));
+
+	ind = size2index(size);
+	if (unlikely(ind >= NSIZES))
+		return (NULL);
+
+	if (config_stats || (config_prof && opt_prof) || (slow_path &&
+	    config_valgrind && unlikely(in_valgrind))) {
+		*usize = index2size(ind);
+		assert(*usize > 0 && *usize <= HUGE_MAXCLASS);
 	}
 
-	if (config_stats || (config_valgrind && unlikely(in_valgrind)))
-		*usize = s2u(size);
-	return (imalloc(*tsd, size));
+	if (config_prof && opt_prof)
+		return (ialloc_prof(tsd, *usize, ind, zero, slow_path));
+
+	return (ialloc(tsd, size, ind, zero, slow_path));
+}
+
+JEMALLOC_ALWAYS_INLINE_C void
+ialloc_post_check(void *ret, tsdn_t *tsdn, size_t usize, const char *func,
+    bool update_errno, bool slow_path)
+{
+
+	assert(!tsdn_null(tsdn) || ret == NULL);
+
+	if (unlikely(ret == NULL)) {
+		if (slow_path && config_xmalloc && unlikely(opt_xmalloc)) {
+			malloc_printf("<jemalloc>: Error in %s(): out of "
+			    "memory\n", func);
+			abort();
+		}
+		if (update_errno)
+			set_errno(ENOMEM);
+	}
+	if (config_stats && likely(ret != NULL)) {
+		assert(usize == isalloc(tsdn, ret, config_prof));
+		*tsd_thread_allocatedp_get(tsdn_tsd(tsdn)) += usize;
+	}
+	witness_assert_lockless(tsdn);
 }
 
 JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
 void JEMALLOC_NOTHROW *
 JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
 je_malloc(size_t size)
 {
 	void *ret;
-	tsd_t *tsd;
+	tsdn_t *tsdn;
 	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
 
 	if (size == 0)
 		size = 1;
 
-	ret = imalloc_body(size, &tsd, &usize);
-	if (unlikely(ret == NULL)) {
-		if (config_xmalloc && unlikely(opt_xmalloc)) {
-			malloc_write("<jemalloc>: Error in malloc(): "
-			    "out of memory\n");
-			abort();
-		}
-		set_errno(ENOMEM);
-	}
-	if (config_stats && likely(ret != NULL)) {
-		assert(usize == isalloc(ret, config_prof));
-		*tsd_thread_allocatedp_get(tsd) += usize;
+	if (likely(!malloc_slow)) {
+		ret = ialloc_body(size, false, &tsdn, &usize, false);
+		ialloc_post_check(ret, tsdn, usize, "malloc", true, false);
+	} else {
+		ret = ialloc_body(size, false, &tsdn, &usize, true);
+		ialloc_post_check(ret, tsdn, usize, "malloc", true, true);
+		UTRACE(0, size, ret);
+		JEMALLOC_VALGRIND_MALLOC(ret != NULL, tsdn, ret, usize, false);
 	}
-	UTRACE(0, size, ret);
-	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, usize, false);
+
 	return (ret);
 }
 
 static void *
 imemalign_prof_sample(tsd_t *tsd, size_t alignment, size_t usize,
     prof_tctx_t *tctx)
@@ -1452,13 +1657,13 @@
 		return (NULL);
 	if (usize <= SMALL_MAXCLASS) {
 		assert(sa2u(LARGE_MINCLASS, alignment) == LARGE_MINCLASS);
 		p = ipalloc(tsd, LARGE_MINCLASS, alignment, false);
 		if (p == NULL)
 			return (NULL);
-		arena_prof_promoted(p, usize);
+		arena_prof_promoted(tsd_tsdn(tsd), p, usize);
 	} else
 		p = ipalloc(tsd, usize, alignment, false);
 
 	return (p);
 }
 
@@ -1474,13 +1679,13 @@
 	else
 		p = ipalloc(tsd, usize, alignment, false);
 	if (unlikely(p == NULL)) {
 		prof_alloc_rollback(tsd, tctx, true);
 		return (NULL);
 	}
-	prof_malloc(p, usize, tctx);
+	prof_malloc(tsd_tsdn(tsd), p, usize, tctx);
 
 	return (p);
 }
 
 JEMALLOC_ATTR(nonnull(1))
 static int
@@ -1491,16 +1696,18 @@
 	size_t usize;
 	void *result;
 
 	assert(min_alignment != 0);
 
 	if (unlikely(malloc_init())) {
+		tsd = NULL;
 		result = NULL;
 		goto label_oom;
 	}
 	tsd = tsd_fetch();
+	witness_assert_lockless(tsd_tsdn(tsd));
 	if (size == 0)
 		size = 1;
 
 	/* Make sure that alignment is a large enough power of 2. */
 	if (unlikely(((alignment - 1) & alignment) != 0
 	    || (alignment < min_alignment))) {
@@ -1512,13 +1719,13 @@
 		result = NULL;
 		ret = EINVAL;
 		goto label_return;
 	}
 
 	usize = sa2u(size, alignment);
-	if (unlikely(usize == 0)) {
+	if (unlikely(usize == 0 || usize > HUGE_MAXCLASS)) {
 		result = NULL;
 		goto label_oom;
 	}
 
 	if (config_prof && opt_prof)
 		result = imemalign_prof(tsd, alignment, usize);
@@ -1529,35 +1736,40 @@
 	assert(((uintptr_t)result & (alignment - 1)) == ZU(0));
 
 	*memptr = result;
 	ret = 0;
 label_return:
 	if (config_stats && likely(result != NULL)) {
-		assert(usize == isalloc(result, config_prof));
+		assert(usize == isalloc(tsd_tsdn(tsd), result, config_prof));
 		*tsd_thread_allocatedp_get(tsd) += usize;
 	}
 	UTRACE(0, size, result);
+	JEMALLOC_VALGRIND_MALLOC(result != NULL, tsd_tsdn(tsd), result, usize,
+	    false);
+	witness_assert_lockless(tsd_tsdn(tsd));
 	return (ret);
 label_oom:
 	assert(result == NULL);
 	if (config_xmalloc && unlikely(opt_xmalloc)) {
 		malloc_write("<jemalloc>: Error allocating aligned memory: "
 		    "out of memory\n");
 		abort();
 	}
 	ret = ENOMEM;
+	witness_assert_lockless(tsd_tsdn(tsd));
 	goto label_return;
 }
 
 JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 JEMALLOC_ATTR(nonnull(1))
 je_posix_memalign(void **memptr, size_t alignment, size_t size)
 {
-	int ret = imemalign(memptr, alignment, size, sizeof(void *));
-	JEMALLOC_VALGRIND_MALLOC(ret == 0, *memptr, isalloc(*memptr,
-	    config_prof), false);
+	int ret;
+
+	ret = imemalign(memptr, alignment, size, sizeof(void *));
+
 	return (ret);
 }
 
 JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
 void JEMALLOC_NOTHROW *
 JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(2)
@@ -1567,120 +1779,51 @@
 	int err;
 
 	if (unlikely((err = imemalign(&ret, alignment, size, 1)) != 0)) {
 		ret = NULL;
 		set_errno(err);
 	}
-	JEMALLOC_VALGRIND_MALLOC(err == 0, ret, isalloc(ret, config_prof),
-	    false);
-	return (ret);
-}
-
-static void *
-icalloc_prof_sample(tsd_t *tsd, size_t usize, prof_tctx_t *tctx)
-{
-	void *p;
-
-	if (tctx == NULL)
-		return (NULL);
-	if (usize <= SMALL_MAXCLASS) {
-		p = icalloc(tsd, LARGE_MINCLASS);
-		if (p == NULL)
-			return (NULL);
-		arena_prof_promoted(p, usize);
-	} else
-		p = icalloc(tsd, usize);
-
-	return (p);
-}
-
-JEMALLOC_ALWAYS_INLINE_C void *
-icalloc_prof(tsd_t *tsd, size_t usize)
-{
-	void *p;
-	prof_tctx_t *tctx;
-
-	tctx = prof_alloc_prep(tsd, usize, prof_active_get_unlocked(), true);
-	if (unlikely((uintptr_t)tctx != (uintptr_t)1U))
-		p = icalloc_prof_sample(tsd, usize, tctx);
-	else
-		p = icalloc(tsd, usize);
-	if (unlikely(p == NULL)) {
-		prof_alloc_rollback(tsd, tctx, true);
-		return (NULL);
-	}
-	prof_malloc(p, usize, tctx);
 
-	return (p);
+	return (ret);
 }
 
 JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
 void JEMALLOC_NOTHROW *
 JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2)
 je_calloc(size_t num, size_t size)
 {
 	void *ret;
-	tsd_t *tsd;
+	tsdn_t *tsdn;
 	size_t num_size;
 	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
 
-	if (unlikely(malloc_init())) {
-		num_size = 0;
-		ret = NULL;
-		goto label_return;
-	}
-	tsd = tsd_fetch();
-
 	num_size = num * size;
 	if (unlikely(num_size == 0)) {
 		if (num == 0 || size == 0)
 			num_size = 1;
-		else {
-			ret = NULL;
-			goto label_return;
-		}
+		else
+			num_size = HUGE_MAXCLASS + 1; /* Trigger OOM. */
 	/*
 	 * Try to avoid division here.  We know that it isn't possible to
 	 * overflow during multiplication if neither operand uses any of the
 	 * most significant half of the bits in a size_t.
 	 */
 	} else if (unlikely(((num | size) & (SIZE_T_MAX << (sizeof(size_t) <<
-	    2))) && (num_size / size != num))) {
-		/* size_t overflow. */
-		ret = NULL;
-		goto label_return;
-	}
+	    2))) && (num_size / size != num)))
+		num_size = HUGE_MAXCLASS + 1; /* size_t overflow. */
 
-	if (config_prof && opt_prof) {
-		usize = s2u(num_size);
-		if (unlikely(usize == 0)) {
-			ret = NULL;
-			goto label_return;
-		}
-		ret = icalloc_prof(tsd, usize);
+	if (likely(!malloc_slow)) {
+		ret = ialloc_body(num_size, true, &tsdn, &usize, false);
+		ialloc_post_check(ret, tsdn, usize, "calloc", true, false);
 	} else {
-		if (config_stats || (config_valgrind && unlikely(in_valgrind)))
-			usize = s2u(num_size);
-		ret = icalloc(tsd, num_size);
+		ret = ialloc_body(num_size, true, &tsdn, &usize, true);
+		ialloc_post_check(ret, tsdn, usize, "calloc", true, true);
+		UTRACE(0, num_size, ret);
+		JEMALLOC_VALGRIND_MALLOC(ret != NULL, tsdn, ret, usize, true);
 	}
 
-label_return:
-	if (unlikely(ret == NULL)) {
-		if (config_xmalloc && unlikely(opt_xmalloc)) {
-			malloc_write("<jemalloc>: Error in calloc(): out of "
-			    "memory\n");
-			abort();
-		}
-		set_errno(ENOMEM);
-	}
-	if (config_stats && likely(ret != NULL)) {
-		assert(usize == isalloc(ret, config_prof));
-		*tsd_thread_allocatedp_get(tsd) += usize;
-	}
-	UTRACE(0, num_size, ret);
-	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, usize, true);
 	return (ret);
 }
 
 static void *
 irealloc_prof_sample(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
     prof_tctx_t *tctx)
@@ -1690,13 +1833,13 @@
 	if (tctx == NULL)
 		return (NULL);
 	if (usize <= SMALL_MAXCLASS) {
 		p = iralloc(tsd, old_ptr, old_usize, LARGE_MINCLASS, 0, false);
 		if (p == NULL)
 			return (NULL);
-		arena_prof_promoted(p, usize);
+		arena_prof_promoted(tsd_tsdn(tsd), p, usize);
 	} else
 		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false);
 
 	return (p);
 }
 
@@ -1705,13 +1848,13 @@
 {
 	void *p;
 	bool prof_active;
 	prof_tctx_t *old_tctx, *tctx;
 
 	prof_active = prof_active_get_unlocked();
-	old_tctx = prof_tctx_get(old_ptr);
+	old_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr);
 	tctx = prof_alloc_prep(tsd, usize, prof_active, true);
 	if (unlikely((uintptr_t)tctx != (uintptr_t)1U))
 		p = irealloc_prof_sample(tsd, old_ptr, old_usize, usize, tctx);
 	else
 		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false);
 	if (unlikely(p == NULL)) {
@@ -1722,124 +1865,155 @@
 	    old_tctx);
 
 	return (p);
 }
 
 JEMALLOC_INLINE_C void
-ifree(tsd_t *tsd, void *ptr, tcache_t *tcache)
+ifree(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path)
 {
 	size_t usize;
 	UNUSED size_t rzsize JEMALLOC_CC_SILENCE_INIT(0);
 
+	witness_assert_lockless(tsd_tsdn(tsd));
+
 	assert(ptr != NULL);
 	assert(malloc_initialized() || IS_INITIALIZER);
 
 	if (config_prof && opt_prof) {
-		usize = isalloc(ptr, config_prof);
+		usize = isalloc(tsd_tsdn(tsd), ptr, config_prof);
 		prof_free(tsd, ptr, usize);
 	} else if (config_stats || config_valgrind)
-		usize = isalloc(ptr, config_prof);
+		usize = isalloc(tsd_tsdn(tsd), ptr, config_prof);
 	if (config_stats)
 		*tsd_thread_deallocatedp_get(tsd) += usize;
-	if (config_valgrind && unlikely(in_valgrind))
-		rzsize = p2rz(ptr);
-	iqalloc(tsd, ptr, tcache);
-	JEMALLOC_VALGRIND_FREE(ptr, rzsize);
+
+	if (likely(!slow_path))
+		iqalloc(tsd, ptr, tcache, false);
+	else {
+		if (config_valgrind && unlikely(in_valgrind))
+			rzsize = p2rz(tsd_tsdn(tsd), ptr);
+		iqalloc(tsd, ptr, tcache, true);
+		JEMALLOC_VALGRIND_FREE(ptr, rzsize);
+	}
 }
 
 JEMALLOC_INLINE_C void
-isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache)
+isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache, bool slow_path)
 {
 	UNUSED size_t rzsize JEMALLOC_CC_SILENCE_INIT(0);
 
+	witness_assert_lockless(tsd_tsdn(tsd));
+
 	assert(ptr != NULL);
 	assert(malloc_initialized() || IS_INITIALIZER);
 
 	if (config_prof && opt_prof)
 		prof_free(tsd, ptr, usize);
 	if (config_stats)
 		*tsd_thread_deallocatedp_get(tsd) += usize;
 	if (config_valgrind && unlikely(in_valgrind))
-		rzsize = p2rz(ptr);
-	isqalloc(tsd, ptr, usize, tcache);
+		rzsize = p2rz(tsd_tsdn(tsd), ptr);
+	isqalloc(tsd, ptr, usize, tcache, slow_path);
 	JEMALLOC_VALGRIND_FREE(ptr, rzsize);
 }
 
 JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
 void JEMALLOC_NOTHROW *
 JEMALLOC_ALLOC_SIZE(2)
 je_realloc(void *ptr, size_t size)
 {
 	void *ret;
-	tsd_t *tsd JEMALLOC_CC_SILENCE_INIT(NULL);
+	tsdn_t *tsdn JEMALLOC_CC_SILENCE_INIT(NULL);
 	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
 	size_t old_usize = 0;
 	UNUSED size_t old_rzsize JEMALLOC_CC_SILENCE_INIT(0);
 
 	if (unlikely(size == 0)) {
 		if (ptr != NULL) {
+			tsd_t *tsd;
+
 			/* realloc(ptr, 0) is equivalent to free(ptr). */
 			UTRACE(ptr, 0, 0);
 			tsd = tsd_fetch();
-			ifree(tsd, ptr, tcache_get(tsd, false));
+			ifree(tsd, ptr, tcache_get(tsd, false), true);
 			return (NULL);
 		}
 		size = 1;
 	}
 
 	if (likely(ptr != NULL)) {
+		tsd_t *tsd;
+
 		assert(malloc_initialized() || IS_INITIALIZER);
 		malloc_thread_init();
 		tsd = tsd_fetch();
 
-		old_usize = isalloc(ptr, config_prof);
-		if (config_valgrind && unlikely(in_valgrind))
-			old_rzsize = config_prof ? p2rz(ptr) : u2rz(old_usize);
+		witness_assert_lockless(tsd_tsdn(tsd));
+
+		old_usize = isalloc(tsd_tsdn(tsd), ptr, config_prof);
+		if (config_valgrind && unlikely(in_valgrind)) {
+			old_rzsize = config_prof ? p2rz(tsd_tsdn(tsd), ptr) :
+			    u2rz(old_usize);
+		}
 
 		if (config_prof && opt_prof) {
 			usize = s2u(size);
-			ret = unlikely(usize == 0) ? NULL : irealloc_prof(tsd,
-			    ptr, old_usize, usize);
+			ret = unlikely(usize == 0 || usize > HUGE_MAXCLASS) ?
+			    NULL : irealloc_prof(tsd, ptr, old_usize, usize);
 		} else {
 			if (config_stats || (config_valgrind &&
 			    unlikely(in_valgrind)))
 				usize = s2u(size);
 			ret = iralloc(tsd, ptr, old_usize, size, 0, false);
 		}
+		tsdn = tsd_tsdn(tsd);
 	} else {
 		/* realloc(NULL, size) is equivalent to malloc(size). */
-		ret = imalloc_body(size, &tsd, &usize);
+		if (likely(!malloc_slow))
+			ret = ialloc_body(size, false, &tsdn, &usize, false);
+		else
+			ret = ialloc_body(size, false, &tsdn, &usize, true);
+		assert(!tsdn_null(tsdn) || ret == NULL);
 	}
 
 	if (unlikely(ret == NULL)) {
 		if (config_xmalloc && unlikely(opt_xmalloc)) {
 			malloc_write("<jemalloc>: Error in realloc(): "
 			    "out of memory\n");
 			abort();
 		}
 		set_errno(ENOMEM);
 	}
 	if (config_stats && likely(ret != NULL)) {
-		assert(usize == isalloc(ret, config_prof));
+		tsd_t *tsd;
+
+		assert(usize == isalloc(tsdn, ret, config_prof));
+		tsd = tsdn_tsd(tsdn);
 		*tsd_thread_allocatedp_get(tsd) += usize;
 		*tsd_thread_deallocatedp_get(tsd) += old_usize;
 	}
 	UTRACE(ptr, size, ret);
-	JEMALLOC_VALGRIND_REALLOC(true, ret, usize, true, ptr, old_usize,
-	    old_rzsize, true, false);
+	JEMALLOC_VALGRIND_REALLOC(maybe, tsdn, ret, usize, maybe, ptr,
+	    old_usize, old_rzsize, maybe, false);
+	witness_assert_lockless(tsdn);
 	return (ret);
 }
 
 JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_free(void *ptr)
 {
 
 	UTRACE(ptr, 0, 0);
 	if (likely(ptr != NULL)) {
 		tsd_t *tsd = tsd_fetch();
-		ifree(tsd, ptr, tcache_get(tsd, false));
+		witness_assert_lockless(tsd_tsdn(tsd));
+		if (likely(!malloc_slow))
+			ifree(tsd, ptr, tcache_get(tsd, false), false);
+		else
+			ifree(tsd, ptr, tcache_get(tsd, false), true);
+		witness_assert_lockless(tsd_tsdn(tsd));
 	}
 }
 
 /*
  * End malloc(3)-compatible functions.
  */
@@ -1854,13 +2028,12 @@
 JEMALLOC_ATTR(malloc)
 je_memalign(size_t alignment, size_t size)
 {
 	void *ret JEMALLOC_CC_SILENCE_INIT(NULL);
 	if (unlikely(imemalign(&ret, alignment, size, 1) != 0))
 		ret = NULL;
-	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, size, false);
 	return (ret);
 }
 #endif
 
 #ifdef JEMALLOC_OVERRIDE_VALLOC
 JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
@@ -1868,13 +2041,12 @@
 JEMALLOC_ATTR(malloc)
 je_valloc(size_t size)
 {
 	void *ret JEMALLOC_CC_SILENCE_INIT(NULL);
 	if (unlikely(imemalign(&ret, PAGE, size, 1) != 0))
 		ret = NULL;
-	JEMALLOC_VALGRIND_MALLOC(ret != NULL, ret, size, false);
 	return (ret);
 }
 #endif
 
 /*
  * is_malloc(je_malloc) is some macro magic to detect if jemalloc_defs.h has
@@ -1898,194 +2070,227 @@
 JEMALLOC_EXPORT void *(*__malloc_hook)(size_t size) = je_malloc;
 JEMALLOC_EXPORT void *(*__realloc_hook)(void *ptr, size_t size) = je_realloc;
 # ifdef JEMALLOC_GLIBC_MEMALIGN_HOOK
 JEMALLOC_EXPORT void *(*__memalign_hook)(size_t alignment, size_t size) =
     je_memalign;
 # endif
+
+#ifdef CPU_COUNT
+/*
+ * To enable static linking with glibc, the libc specific malloc interface must
+ * be implemented also, so none of glibc's malloc.o functions are added to the
+ * link.
+ */
+#define	ALIAS(je_fn)	__attribute__((alias (#je_fn), used))
+/* To force macro expansion of je_ prefix before stringification. */
+#define	PREALIAS(je_fn)  ALIAS(je_fn)
+void	*__libc_malloc(size_t size) PREALIAS(je_malloc);
+void	__libc_free(void* ptr) PREALIAS(je_free);
+void	*__libc_realloc(void* ptr, size_t size) PREALIAS(je_realloc);
+void	*__libc_calloc(size_t n, size_t size) PREALIAS(je_calloc);
+void	*__libc_memalign(size_t align, size_t s) PREALIAS(je_memalign);
+void	*__libc_valloc(size_t size) PREALIAS(je_valloc);
+int	__posix_memalign(void** r, size_t a, size_t s)
+    PREALIAS(je_posix_memalign);
+#undef PREALIAS
+#undef ALIAS
+
+#endif
+
 #endif
 
 /*
  * End non-standard override functions.
  */
 /******************************************************************************/
 /*
  * Begin non-standard functions.
  */
 
 JEMALLOC_ALWAYS_INLINE_C bool
-imallocx_flags_decode_hard(tsd_t *tsd, size_t size, int flags, size_t *usize,
+imallocx_flags_decode(tsd_t *tsd, size_t size, int flags, size_t *usize,
     size_t *alignment, bool *zero, tcache_t **tcache, arena_t **arena)
 {
 
 	if ((flags & MALLOCX_LG_ALIGN_MASK) == 0) {
 		*alignment = 0;
 		*usize = s2u(size);
 	} else {
 		*alignment = MALLOCX_ALIGN_GET_SPECIFIED(flags);
 		*usize = sa2u(size, *alignment);
 	}
-	assert(*usize != 0);
+	if (unlikely(*usize == 0 || *usize > HUGE_MAXCLASS))
+		return (true);
 	*zero = MALLOCX_ZERO_GET(flags);
 	if ((flags & MALLOCX_TCACHE_MASK) != 0) {
 		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE)
 			*tcache = NULL;
 		else
 			*tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
 	} else
 		*tcache = tcache_get(tsd, true);
 	if ((flags & MALLOCX_ARENA_MASK) != 0) {
 		unsigned arena_ind = MALLOCX_ARENA_GET(flags);
-		*arena = arena_get(tsd, arena_ind, true, true);
+		*arena = arena_get(tsd_tsdn(tsd), arena_ind, true);
 		if (unlikely(*arena == NULL))
 			return (true);
 	} else
 		*arena = NULL;
 	return (false);
 }
 
-JEMALLOC_ALWAYS_INLINE_C bool
-imallocx_flags_decode(tsd_t *tsd, size_t size, int flags, size_t *usize,
-    size_t *alignment, bool *zero, tcache_t **tcache, arena_t **arena)
-{
-
-	if (likely(flags == 0)) {
-		*usize = s2u(size);
-		assert(*usize != 0);
-		*alignment = 0;
-		*zero = false;
-		*tcache = tcache_get(tsd, true);
-		*arena = NULL;
-		return (false);
-	} else {
-		return (imallocx_flags_decode_hard(tsd, size, flags, usize,
-		    alignment, zero, tcache, arena));
-	}
-}
-
 JEMALLOC_ALWAYS_INLINE_C void *
-imallocx_flags(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
-    tcache_t *tcache, arena_t *arena)
+imallocx_flags(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, arena_t *arena, bool slow_path)
 {
+	szind_t ind;
 
 	if (unlikely(alignment != 0))
-		return (ipalloct(tsd, usize, alignment, zero, tcache, arena));
-	if (unlikely(zero))
-		return (icalloct(tsd, usize, tcache, arena));
-	return (imalloct(tsd, usize, tcache, arena));
+		return (ipalloct(tsdn, usize, alignment, zero, tcache, arena));
+	ind = size2index(usize);
+	assert(ind < NSIZES);
+	return (iallocztm(tsdn, usize, ind, zero, tcache, false, arena,
+	    slow_path));
 }
 
 static void *
-imallocx_prof_sample(tsd_t *tsd, size_t usize, size_t alignment, bool zero,
-    tcache_t *tcache, arena_t *arena)
+imallocx_prof_sample(tsdn_t *tsdn, size_t usize, size_t alignment, bool zero,
+    tcache_t *tcache, arena_t *arena, bool slow_path)
 {
 	void *p;
 
 	if (usize <= SMALL_MAXCLASS) {
 		assert(((alignment == 0) ? s2u(LARGE_MINCLASS) :
 		    sa2u(LARGE_MINCLASS, alignment)) == LARGE_MINCLASS);
-		p = imallocx_flags(tsd, LARGE_MINCLASS, alignment, zero, tcache,
-		    arena);
+		p = imallocx_flags(tsdn, LARGE_MINCLASS, alignment, zero,
+		    tcache, arena, slow_path);
 		if (p == NULL)
 			return (NULL);
-		arena_prof_promoted(p, usize);
-	} else
-		p = imallocx_flags(tsd, usize, alignment, zero, tcache, arena);
+		arena_prof_promoted(tsdn, p, usize);
+	} else {
+		p = imallocx_flags(tsdn, usize, alignment, zero, tcache, arena,
+		    slow_path);
+	}
 
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE_C void *
-imallocx_prof(tsd_t *tsd, size_t size, int flags, size_t *usize)
+imallocx_prof(tsd_t *tsd, size_t size, int flags, size_t *usize, bool slow_path)
 {
 	void *p;
 	size_t alignment;
 	bool zero;
 	tcache_t *tcache;
 	arena_t *arena;
 	prof_tctx_t *tctx;
 
 	if (unlikely(imallocx_flags_decode(tsd, size, flags, usize, &alignment,
 	    &zero, &tcache, &arena)))
 		return (NULL);
 	tctx = prof_alloc_prep(tsd, *usize, prof_active_get_unlocked(), true);
-	if (likely((uintptr_t)tctx == (uintptr_t)1U))
-		p = imallocx_flags(tsd, *usize, alignment, zero, tcache, arena);
-	else if ((uintptr_t)tctx > (uintptr_t)1U) {
-		p = imallocx_prof_sample(tsd, *usize, alignment, zero, tcache,
-		    arena);
+	if (likely((uintptr_t)tctx == (uintptr_t)1U)) {
+		p = imallocx_flags(tsd_tsdn(tsd), *usize, alignment, zero,
+		    tcache, arena, slow_path);
+	} else if ((uintptr_t)tctx > (uintptr_t)1U) {
+		p = imallocx_prof_sample(tsd_tsdn(tsd), *usize, alignment, zero,
+		    tcache, arena, slow_path);
 	} else
 		p = NULL;
 	if (unlikely(p == NULL)) {
 		prof_alloc_rollback(tsd, tctx, true);
 		return (NULL);
 	}
-	prof_malloc(p, *usize, tctx);
+	prof_malloc(tsd_tsdn(tsd), p, *usize, tctx);
 
 	assert(alignment == 0 || ((uintptr_t)p & (alignment - 1)) == ZU(0));
 	return (p);
 }
 
 JEMALLOC_ALWAYS_INLINE_C void *
-imallocx_no_prof(tsd_t *tsd, size_t size, int flags, size_t *usize)
+imallocx_no_prof(tsd_t *tsd, size_t size, int flags, size_t *usize,
+    bool slow_path)
 {
 	void *p;
 	size_t alignment;
 	bool zero;
 	tcache_t *tcache;
 	arena_t *arena;
 
-	if (likely(flags == 0)) {
-		if (config_stats || (config_valgrind && unlikely(in_valgrind)))
-			*usize = s2u(size);
-		return (imalloc(tsd, size));
-	}
-
-	if (unlikely(imallocx_flags_decode_hard(tsd, size, flags, usize,
-	    &alignment, &zero, &tcache, &arena)))
+	if (unlikely(imallocx_flags_decode(tsd, size, flags, usize, &alignment,
+	    &zero, &tcache, &arena)))
 		return (NULL);
-	p = imallocx_flags(tsd, *usize, alignment, zero, tcache, arena);
+	p = imallocx_flags(tsd_tsdn(tsd), *usize, alignment, zero, tcache,
+	    arena, slow_path);
 	assert(alignment == 0 || ((uintptr_t)p & (alignment - 1)) == ZU(0));
 	return (p);
 }
 
+/* This function guarantees that *tsdn is non-NULL on success. */
+JEMALLOC_ALWAYS_INLINE_C void *
+imallocx_body(size_t size, int flags, tsdn_t **tsdn, size_t *usize,
+    bool slow_path)
+{
+	tsd_t *tsd;
+
+	if (slow_path && unlikely(malloc_init())) {
+		*tsdn = NULL;
+		return (NULL);
+	}
+
+	tsd = tsd_fetch();
+	*tsdn = tsd_tsdn(tsd);
+	witness_assert_lockless(tsd_tsdn(tsd));
+
+	if (likely(flags == 0)) {
+		szind_t ind = size2index(size);
+		if (unlikely(ind >= NSIZES))
+			return (NULL);
+		if (config_stats || (config_prof && opt_prof) || (slow_path &&
+		    config_valgrind && unlikely(in_valgrind))) {
+			*usize = index2size(ind);
+			assert(*usize > 0 && *usize <= HUGE_MAXCLASS);
+		}
+
+		if (config_prof && opt_prof) {
+			return (ialloc_prof(tsd, *usize, ind, false,
+			    slow_path));
+		}
+
+		return (ialloc(tsd, size, ind, false, slow_path));
+	}
+
+	if (config_prof && opt_prof)
+		return (imallocx_prof(tsd, size, flags, usize, slow_path));
+
+	return (imallocx_no_prof(tsd, size, flags, usize, slow_path));
+}
+
 JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
 void JEMALLOC_NOTHROW *
 JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
 je_mallocx(size_t size, int flags)
 {
-	tsd_t *tsd;
+	tsdn_t *tsdn;
 	void *p;
 	size_t usize;
 
 	assert(size != 0);
 
-	if (unlikely(malloc_init()))
-		goto label_oom;
-	tsd = tsd_fetch();
-
-	if (config_prof && opt_prof)
-		p = imallocx_prof(tsd, size, flags, &usize);
-	else
-		p = imallocx_no_prof(tsd, size, flags, &usize);
-	if (unlikely(p == NULL))
-		goto label_oom;
-
-	if (config_stats) {
-		assert(usize == isalloc(p, config_prof));
-		*tsd_thread_allocatedp_get(tsd) += usize;
+	if (likely(!malloc_slow)) {
+		p = imallocx_body(size, flags, &tsdn, &usize, false);
+		ialloc_post_check(p, tsdn, usize, "mallocx", false, false);
+	} else {
+		p = imallocx_body(size, flags, &tsdn, &usize, true);
+		ialloc_post_check(p, tsdn, usize, "mallocx", false, true);
+		UTRACE(0, size, p);
+		JEMALLOC_VALGRIND_MALLOC(p != NULL, tsdn, p, usize,
+		    MALLOCX_ZERO_GET(flags));
 	}
-	UTRACE(0, size, p);
-	JEMALLOC_VALGRIND_MALLOC(true, p, usize, MALLOCX_ZERO_GET(flags));
+
 	return (p);
-label_oom:
-	if (config_xmalloc && unlikely(opt_xmalloc)) {
-		malloc_write("<jemalloc>: Error in mallocx(): out of memory\n");
-		abort();
-	}
-	UTRACE(0, size, 0);
-	return (NULL);
 }
 
 static void *
 irallocx_prof_sample(tsd_t *tsd, void *old_ptr, size_t old_usize,
     size_t usize, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena,
     prof_tctx_t *tctx)
@@ -2096,13 +2301,13 @@
 		return (NULL);
 	if (usize <= SMALL_MAXCLASS) {
 		p = iralloct(tsd, old_ptr, old_usize, LARGE_MINCLASS, alignment,
 		    zero, tcache, arena);
 		if (p == NULL)
 			return (NULL);
-		arena_prof_promoted(p, usize);
+		arena_prof_promoted(tsd_tsdn(tsd), p, usize);
 	} else {
 		p = iralloct(tsd, old_ptr, old_usize, usize, alignment, zero,
 		    tcache, arena);
 	}
 
 	return (p);
@@ -2115,38 +2320,38 @@
 {
 	void *p;
 	bool prof_active;
 	prof_tctx_t *old_tctx, *tctx;
 
 	prof_active = prof_active_get_unlocked();
-	old_tctx = prof_tctx_get(old_ptr);
-	tctx = prof_alloc_prep(tsd, *usize, prof_active, true);
+	old_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr);
+	tctx = prof_alloc_prep(tsd, *usize, prof_active, false);
 	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
 		p = irallocx_prof_sample(tsd, old_ptr, old_usize, *usize,
 		    alignment, zero, tcache, arena, tctx);
 	} else {
 		p = iralloct(tsd, old_ptr, old_usize, size, alignment, zero,
 		    tcache, arena);
 	}
 	if (unlikely(p == NULL)) {
-		prof_alloc_rollback(tsd, tctx, true);
+		prof_alloc_rollback(tsd, tctx, false);
 		return (NULL);
 	}
 
 	if (p == old_ptr && alignment != 0) {
 		/*
 		 * The allocation did not move, so it is possible that the size
 		 * class is smaller than would guarantee the requested
 		 * alignment, and that the alignment constraint was
 		 * serendipitously satisfied.  Additionally, old_usize may not
 		 * be the same as the current usize because of in-place large
 		 * reallocation.  Therefore, query the actual value of usize.
 		 */
-		*usize = isalloc(p, config_prof);
+		*usize = isalloc(tsd_tsdn(tsd), p, config_prof);
 	}
-	prof_realloc(tsd, p, *usize, tctx, prof_active, true, old_ptr,
+	prof_realloc(tsd, p, *usize, tctx, prof_active, false, old_ptr,
 	    old_usize, old_tctx);
 
 	return (p);
 }
 
 JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
@@ -2166,16 +2371,17 @@
 
 	assert(ptr != NULL);
 	assert(size != 0);
 	assert(malloc_initialized() || IS_INITIALIZER);
 	malloc_thread_init();
 	tsd = tsd_fetch();
+	witness_assert_lockless(tsd_tsdn(tsd));
 
 	if (unlikely((flags & MALLOCX_ARENA_MASK) != 0)) {
 		unsigned arena_ind = MALLOCX_ARENA_GET(flags);
-		arena = arena_get(tsd, arena_ind, true, true);
+		arena = arena_get(tsd_tsdn(tsd), arena_ind, true);
 		if (unlikely(arena == NULL))
 			goto label_oom;
 	} else
 		arena = NULL;
 
 	if (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {
@@ -2183,72 +2389,76 @@
 			tcache = NULL;
 		else
 			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
 	} else
 		tcache = tcache_get(tsd, true);
 
-	old_usize = isalloc(ptr, config_prof);
+	old_usize = isalloc(tsd_tsdn(tsd), ptr, config_prof);
 	if (config_valgrind && unlikely(in_valgrind))
 		old_rzsize = u2rz(old_usize);
 
 	if (config_prof && opt_prof) {
 		usize = (alignment == 0) ? s2u(size) : sa2u(size, alignment);
-		assert(usize != 0);
+		if (unlikely(usize == 0 || usize > HUGE_MAXCLASS))
+			goto label_oom;
 		p = irallocx_prof(tsd, ptr, old_usize, size, alignment, &usize,
 		    zero, tcache, arena);
 		if (unlikely(p == NULL))
 			goto label_oom;
 	} else {
 		p = iralloct(tsd, ptr, old_usize, size, alignment, zero,
 		     tcache, arena);
 		if (unlikely(p == NULL))
 			goto label_oom;
 		if (config_stats || (config_valgrind && unlikely(in_valgrind)))
-			usize = isalloc(p, config_prof);
+			usize = isalloc(tsd_tsdn(tsd), p, config_prof);
 	}
 	assert(alignment == 0 || ((uintptr_t)p & (alignment - 1)) == ZU(0));
 
 	if (config_stats) {
 		*tsd_thread_allocatedp_get(tsd) += usize;
 		*tsd_thread_deallocatedp_get(tsd) += old_usize;
 	}
 	UTRACE(ptr, size, p);
-	JEMALLOC_VALGRIND_REALLOC(true, p, usize, false, ptr, old_usize,
-	    old_rzsize, false, zero);
+	JEMALLOC_VALGRIND_REALLOC(maybe, tsd_tsdn(tsd), p, usize, no, ptr,
+	    old_usize, old_rzsize, no, zero);
+	witness_assert_lockless(tsd_tsdn(tsd));
 	return (p);
 label_oom:
 	if (config_xmalloc && unlikely(opt_xmalloc)) {
 		malloc_write("<jemalloc>: Error in rallocx(): out of memory\n");
 		abort();
 	}
 	UTRACE(ptr, size, 0);
+	witness_assert_lockless(tsd_tsdn(tsd));
 	return (NULL);
 }
 
 JEMALLOC_ALWAYS_INLINE_C size_t
-ixallocx_helper(void *ptr, size_t old_usize, size_t size, size_t extra,
-    size_t alignment, bool zero)
+ixallocx_helper(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
+    size_t extra, size_t alignment, bool zero)
 {
 	size_t usize;
 
-	if (ixalloc(ptr, old_usize, size, extra, alignment, zero))
+	if (ixalloc(tsdn, ptr, old_usize, size, extra, alignment, zero))
 		return (old_usize);
-	usize = isalloc(ptr, config_prof);
+	usize = isalloc(tsdn, ptr, config_prof);
 
 	return (usize);
 }
 
 static size_t
-ixallocx_prof_sample(void *ptr, size_t old_usize, size_t size, size_t extra,
-    size_t alignment, bool zero, prof_tctx_t *tctx)
+ixallocx_prof_sample(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
+    size_t extra, size_t alignment, bool zero, prof_tctx_t *tctx)
 {
 	size_t usize;
 
 	if (tctx == NULL)
 		return (old_usize);
-	usize = ixallocx_helper(ptr, old_usize, size, extra, alignment, zero);
+	usize = ixallocx_helper(tsdn, ptr, old_usize, size, extra, alignment,
+	    zero);
 
 	return (usize);
 }
 
 JEMALLOC_ALWAYS_INLINE_C size_t
 ixallocx_prof(tsd_t *tsd, void *ptr, size_t old_usize, size_t size,
@@ -2256,29 +2466,42 @@
 {
 	size_t usize_max, usize;
 	bool prof_active;
 	prof_tctx_t *old_tctx, *tctx;
 
 	prof_active = prof_active_get_unlocked();
-	old_tctx = prof_tctx_get(ptr);
+	old_tctx = prof_tctx_get(tsd_tsdn(tsd), ptr);
 	/*
 	 * usize isn't knowable before ixalloc() returns when extra is non-zero.
 	 * Therefore, compute its maximum possible value and use that in
 	 * prof_alloc_prep() to decide whether to capture a backtrace.
 	 * prof_realloc() will use the actual usize to decide whether to sample.
 	 */
-	usize_max = (alignment == 0) ? s2u(size+extra) : sa2u(size+extra,
-	    alignment);
-	assert(usize_max != 0);
+	if (alignment == 0) {
+		usize_max = s2u(size+extra);
+		assert(usize_max > 0 && usize_max <= HUGE_MAXCLASS);
+	} else {
+		usize_max = sa2u(size+extra, alignment);
+		if (unlikely(usize_max == 0 || usize_max > HUGE_MAXCLASS)) {
+			/*
+			 * usize_max is out of range, and chances are that
+			 * allocation will fail, but use the maximum possible
+			 * value and carry on with prof_alloc_prep(), just in
+			 * case allocation succeeds.
+			 */
+			usize_max = HUGE_MAXCLASS;
+		}
+	}
 	tctx = prof_alloc_prep(tsd, usize_max, prof_active, false);
+
 	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
-		usize = ixallocx_prof_sample(ptr, old_usize, size, extra,
-		    alignment, zero, tctx);
+		usize = ixallocx_prof_sample(tsd_tsdn(tsd), ptr, old_usize,
+		    size, extra, alignment, zero, tctx);
 	} else {
-		usize = ixallocx_helper(ptr, old_usize, size, extra, alignment,
-		    zero);
+		usize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,
+		    extra, alignment, zero);
 	}
 	if (usize == old_usize) {
 		prof_alloc_rollback(tsd, tctx, false);
 		return (usize);
 	}
 	prof_realloc(tsd, ptr, usize, tctx, prof_active, false, ptr, old_usize,
@@ -2299,63 +2522,76 @@
 	assert(ptr != NULL);
 	assert(size != 0);
 	assert(SIZE_T_MAX - size >= extra);
 	assert(malloc_initialized() || IS_INITIALIZER);
 	malloc_thread_init();
 	tsd = tsd_fetch();
+	witness_assert_lockless(tsd_tsdn(tsd));
 
-	old_usize = isalloc(ptr, config_prof);
+	old_usize = isalloc(tsd_tsdn(tsd), ptr, config_prof);
 
-	/* Clamp extra if necessary to avoid (size + extra) overflow. */
-	if (unlikely(size + extra > HUGE_MAXCLASS)) {
-		/* Check for size overflow. */
-		if (unlikely(size > HUGE_MAXCLASS)) {
-			usize = old_usize;
-			goto label_not_resized;
-		}
-		extra = HUGE_MAXCLASS - size;
+	/*
+	 * The API explicitly absolves itself of protecting against (size +
+	 * extra) numerical overflow, but we may need to clamp extra to avoid
+	 * exceeding HUGE_MAXCLASS.
+	 *
+	 * Ordinarily, size limit checking is handled deeper down, but here we
+	 * have to check as part of (size + extra) clamping, since we need the
+	 * clamped value in the above helper functions.
+	 */
+	if (unlikely(size > HUGE_MAXCLASS)) {
+		usize = old_usize;
+		goto label_not_resized;
 	}
+	if (unlikely(HUGE_MAXCLASS - size < extra))
+		extra = HUGE_MAXCLASS - size;
 
 	if (config_valgrind && unlikely(in_valgrind))
 		old_rzsize = u2rz(old_usize);
 
 	if (config_prof && opt_prof) {
 		usize = ixallocx_prof(tsd, ptr, old_usize, size, extra,
 		    alignment, zero);
 	} else {
-		usize = ixallocx_helper(ptr, old_usize, size, extra, alignment,
-		    zero);
+		usize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,
+		    extra, alignment, zero);
 	}
 	if (unlikely(usize == old_usize))
 		goto label_not_resized;
 
 	if (config_stats) {
 		*tsd_thread_allocatedp_get(tsd) += usize;
 		*tsd_thread_deallocatedp_get(tsd) += old_usize;
 	}
-	JEMALLOC_VALGRIND_REALLOC(false, ptr, usize, false, ptr, old_usize,
-	    old_rzsize, false, zero);
+	JEMALLOC_VALGRIND_REALLOC(no, tsd_tsdn(tsd), ptr, usize, no, ptr,
+	    old_usize, old_rzsize, no, zero);
 label_not_resized:
 	UTRACE(ptr, size, ptr);
+	witness_assert_lockless(tsd_tsdn(tsd));
 	return (usize);
 }
 
 JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
 JEMALLOC_ATTR(pure)
 je_sallocx(const void *ptr, int flags)
 {
 	size_t usize;
+	tsdn_t *tsdn;
 
 	assert(malloc_initialized() || IS_INITIALIZER);
 	malloc_thread_init();
 
+	tsdn = tsdn_fetch();
+	witness_assert_lockless(tsdn);
+
 	if (config_ivsalloc)
-		usize = ivsalloc(ptr, config_prof);
+		usize = ivsalloc(tsdn, ptr, config_prof);
 	else
-		usize = isalloc(ptr, config_prof);
+		usize = isalloc(tsdn, ptr, config_prof);
 
+	witness_assert_lockless(tsdn);
 	return (usize);
 }
 
 JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_dallocx(void *ptr, int flags)
 {
@@ -2363,128 +2599,177 @@
 	tcache_t *tcache;
 
 	assert(ptr != NULL);
 	assert(malloc_initialized() || IS_INITIALIZER);
 
 	tsd = tsd_fetch();
+	witness_assert_lockless(tsd_tsdn(tsd));
 	if (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {
 		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE)
 			tcache = NULL;
 		else
 			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
 	} else
 		tcache = tcache_get(tsd, false);
 
 	UTRACE(ptr, 0, 0);
-	ifree(tsd_fetch(), ptr, tcache);
+	if (likely(!malloc_slow))
+		ifree(tsd, ptr, tcache, false);
+	else
+		ifree(tsd, ptr, tcache, true);
+	witness_assert_lockless(tsd_tsdn(tsd));
 }
 
 JEMALLOC_ALWAYS_INLINE_C size_t
-inallocx(size_t size, int flags)
+inallocx(tsdn_t *tsdn, size_t size, int flags)
 {
 	size_t usize;
 
+	witness_assert_lockless(tsdn);
+
 	if (likely((flags & MALLOCX_LG_ALIGN_MASK) == 0))
 		usize = s2u(size);
 	else
 		usize = sa2u(size, MALLOCX_ALIGN_GET_SPECIFIED(flags));
-	assert(usize != 0);
+	witness_assert_lockless(tsdn);
 	return (usize);
 }
 
 JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_sdallocx(void *ptr, size_t size, int flags)
 {
 	tsd_t *tsd;
 	tcache_t *tcache;
 	size_t usize;
 
 	assert(ptr != NULL);
 	assert(malloc_initialized() || IS_INITIALIZER);
-	usize = inallocx(size, flags);
-	assert(usize == isalloc(ptr, config_prof));
-
 	tsd = tsd_fetch();
+	usize = inallocx(tsd_tsdn(tsd), size, flags);
+	assert(usize == isalloc(tsd_tsdn(tsd), ptr, config_prof));
+
+	witness_assert_lockless(tsd_tsdn(tsd));
 	if (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {
 		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE)
 			tcache = NULL;
 		else
 			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
 	} else
 		tcache = tcache_get(tsd, false);
 
 	UTRACE(ptr, 0, 0);
-	isfree(tsd, ptr, usize, tcache);
+	if (likely(!malloc_slow))
+		isfree(tsd, ptr, usize, tcache, false);
+	else
+		isfree(tsd, ptr, usize, tcache, true);
+	witness_assert_lockless(tsd_tsdn(tsd));
 }
 
 JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
 JEMALLOC_ATTR(pure)
 je_nallocx(size_t size, int flags)
 {
+	size_t usize;
+	tsdn_t *tsdn;
 
 	assert(size != 0);
 
 	if (unlikely(malloc_init()))
 		return (0);
 
-	return (inallocx(size, flags));
+	tsdn = tsdn_fetch();
+	witness_assert_lockless(tsdn);
+
+	usize = inallocx(tsdn, size, flags);
+	if (unlikely(usize > HUGE_MAXCLASS))
+		return (0);
+
+	witness_assert_lockless(tsdn);
+	return (usize);
 }
 
 JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
     size_t newlen)
 {
+	int ret;
+	tsd_t *tsd;
 
 	if (unlikely(malloc_init()))
 		return (EAGAIN);
 
-	return (ctl_byname(name, oldp, oldlenp, newp, newlen));
+	tsd = tsd_fetch();
+	witness_assert_lockless(tsd_tsdn(tsd));
+	ret = ctl_byname(tsd, name, oldp, oldlenp, newp, newlen);
+	witness_assert_lockless(tsd_tsdn(tsd));
+	return (ret);
 }
 
 JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp)
 {
+	int ret;
+	tsdn_t *tsdn;
 
 	if (unlikely(malloc_init()))
 		return (EAGAIN);
 
-	return (ctl_nametomib(name, mibp, miblenp));
+	tsdn = tsdn_fetch();
+	witness_assert_lockless(tsdn);
+	ret = ctl_nametomib(tsdn, name, mibp, miblenp);
+	witness_assert_lockless(tsdn);
+	return (ret);
 }
 
 JEMALLOC_EXPORT int JEMALLOC_NOTHROW
 je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
   void *newp, size_t newlen)
 {
+	int ret;
+	tsd_t *tsd;
 
 	if (unlikely(malloc_init()))
 		return (EAGAIN);
 
-	return (ctl_bymib(mib, miblen, oldp, oldlenp, newp, newlen));
+	tsd = tsd_fetch();
+	witness_assert_lockless(tsd_tsdn(tsd));
+	ret = ctl_bymib(tsd, mib, miblen, oldp, oldlenp, newp, newlen);
+	witness_assert_lockless(tsd_tsdn(tsd));
+	return (ret);
 }
 
 JEMALLOC_EXPORT void JEMALLOC_NOTHROW
 je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
     const char *opts)
 {
+	tsdn_t *tsdn;
 
+	tsdn = tsdn_fetch();
+	witness_assert_lockless(tsdn);
 	stats_print(write_cb, cbopaque, opts);
+	witness_assert_lockless(tsdn);
 }
 
 JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
 je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr)
 {
 	size_t ret;
+	tsdn_t *tsdn;
 
 	assert(malloc_initialized() || IS_INITIALIZER);
 	malloc_thread_init();
 
+	tsdn = tsdn_fetch();
+	witness_assert_lockless(tsdn);
+
 	if (config_ivsalloc)
-		ret = ivsalloc(ptr, config_prof);
+		ret = ivsalloc(tsdn, ptr, config_prof);
 	else
-		ret = (ptr == NULL) ? 0 : isalloc(ptr, config_prof);
+		ret = (ptr == NULL) ? 0 : isalloc(tsdn, ptr, config_prof);
 
+	witness_assert_lockless(tsdn);
 	return (ret);
 }
 
 /*
  * End non-standard functions.
  */
@@ -2504,90 +2789,161 @@
  * initialization using pthread_atfork(), but of course that does no good if
  * the allocator isn't fully initialized at fork time.  The following library
  * constructor is a partial solution to this problem.  It may still be possible
  * to trigger the deadlock described above, but doing so would involve forking
  * via a library constructor that runs before jemalloc's runs.
  */
+#ifndef JEMALLOC_JET
 JEMALLOC_ATTR(constructor)
 static void
 jemalloc_constructor(void)
 {
 
 	malloc_init();
 }
+#endif
 
 #ifndef JEMALLOC_MUTEX_INIT_CB
 void
 jemalloc_prefork(void)
 #else
 JEMALLOC_EXPORT void
 _malloc_prefork(void)
 #endif
 {
-	unsigned i;
+	tsd_t *tsd;
+	unsigned i, j, narenas;
+	arena_t *arena;
 
 #ifdef JEMALLOC_MUTEX_INIT_CB
 	if (!malloc_initialized())
 		return;
 #endif
 	assert(malloc_initialized());
 
+	tsd = tsd_fetch();
+
+	narenas = narenas_total_get();
+
+	witness_prefork(tsd);
 	/* Acquire all mutexes in a safe order. */
-	ctl_prefork();
-	prof_prefork();
-	malloc_mutex_prefork(&arenas_lock);
-	for (i = 0; i < narenas_total; i++) {
-		if (arenas[i] != NULL)
-			arena_prefork(arenas[i]);
+	ctl_prefork(tsd_tsdn(tsd));
+	malloc_mutex_prefork(tsd_tsdn(tsd), &arenas_lock);
+	prof_prefork0(tsd_tsdn(tsd));
+	for (i = 0; i < 3; i++) {
+		for (j = 0; j < narenas; j++) {
+			if ((arena = arena_get(tsd_tsdn(tsd), j, false)) !=
+			    NULL) {
+				switch (i) {
+				case 0:
+					arena_prefork0(tsd_tsdn(tsd), arena);
+					break;
+				case 1:
+					arena_prefork1(tsd_tsdn(tsd), arena);
+					break;
+				case 2:
+					arena_prefork2(tsd_tsdn(tsd), arena);
+					break;
+				default: not_reached();
+				}
+			}
+		}
+	}
+	base_prefork(tsd_tsdn(tsd));
+	for (i = 0; i < narenas; i++) {
+		if ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL)
+			arena_prefork3(tsd_tsdn(tsd), arena);
 	}
-	chunk_prefork();
-	base_prefork();
+	prof_prefork1(tsd_tsdn(tsd));
 }
 
 #ifndef JEMALLOC_MUTEX_INIT_CB
 void
 jemalloc_postfork_parent(void)
 #else
 JEMALLOC_EXPORT void
 _malloc_postfork(void)
 #endif
 {
-	unsigned i;
+	tsd_t *tsd;
+	unsigned i, narenas;
 
 #ifdef JEMALLOC_MUTEX_INIT_CB
 	if (!malloc_initialized())
 		return;
 #endif
 	assert(malloc_initialized());
 
+	tsd = tsd_fetch();
+
+	witness_postfork_parent(tsd);
 	/* Release all mutexes, now that fork() has completed. */
-	base_postfork_parent();
-	chunk_postfork_parent();
-	for (i = 0; i < narenas_total; i++) {
-		if (arenas[i] != NULL)
-			arena_postfork_parent(arenas[i]);
-	}
-	malloc_mutex_postfork_parent(&arenas_lock);
-	prof_postfork_parent();
-	ctl_postfork_parent();
+	base_postfork_parent(tsd_tsdn(tsd));
+	for (i = 0, narenas = narenas_total_get(); i < narenas; i++) {
+		arena_t *arena;
+
+		if ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL)
+			arena_postfork_parent(tsd_tsdn(tsd), arena);
+	}
+	prof_postfork_parent(tsd_tsdn(tsd));
+	malloc_mutex_postfork_parent(tsd_tsdn(tsd), &arenas_lock);
+	ctl_postfork_parent(tsd_tsdn(tsd));
 }
 
 void
 jemalloc_postfork_child(void)
 {
-	unsigned i;
+	tsd_t *tsd;
+	unsigned i, narenas;
 
 	assert(malloc_initialized());
 
+	tsd = tsd_fetch();
+
+	witness_postfork_child(tsd);
 	/* Release all mutexes, now that fork() has completed. */
-	base_postfork_child();
-	chunk_postfork_child();
-	for (i = 0; i < narenas_total; i++) {
-		if (arenas[i] != NULL)
-			arena_postfork_child(arenas[i]);
-	}
-	malloc_mutex_postfork_child(&arenas_lock);
-	prof_postfork_child();
-	ctl_postfork_child();
+	base_postfork_child(tsd_tsdn(tsd));
+	for (i = 0, narenas = narenas_total_get(); i < narenas; i++) {
+		arena_t *arena;
+
+		if ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL)
+			arena_postfork_child(tsd_tsdn(tsd), arena);
+	}
+	prof_postfork_child(tsd_tsdn(tsd));
+	malloc_mutex_postfork_child(tsd_tsdn(tsd), &arenas_lock);
+	ctl_postfork_child(tsd_tsdn(tsd));
 }
 
 /******************************************************************************/
+
+/* Helps the application decide if a pointer is worth re-allocating in order to reduce fragmentation.
+ * returns 0 if the allocation is in the currently active run,
+ * or when it is not causing any frag issue (large or huge bin)
+ * returns the bin utilization and run utilization both in fixed point 16:16.
+ * If the application decides to re-allocate it should use MALLOCX_TCACHE_NONE when doing so. */
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW
+je_get_defrag_hint(void* ptr, int *bin_util, int *run_util) {
+    int defrag = 0;
+    arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+    if (likely(chunk != ptr)) { /* indication that this is not a HUGE alloc */
+        size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
+        size_t mapbits = arena_mapbits_get(chunk, pageind);
+        if (likely((mapbits & CHUNK_MAP_LARGE) == 0)) { /* indication that this is not a LARGE alloc */
+            arena_t *arena = extent_node_arena_get(&chunk->node);
+            size_t rpages_ind = pageind - arena_mapbits_small_runind_get(chunk, pageind);
+            arena_run_t *run = &arena_miscelm_get_mutable(chunk, rpages_ind)->run;
+            arena_bin_t *bin = &arena->bins[run->binind];
+            tsd_t *tsd = tsd_fetch();
+            malloc_mutex_lock(tsd_tsdn(tsd), &bin->lock);
+            /* runs that are in the same chunk in as the current chunk, are likely to be the next currun */
+            if (chunk != (arena_chunk_t *)CHUNK_ADDR2BASE(bin->runcur)) {
+                arena_bin_info_t *bin_info = &arena_bin_info[run->binind];
+                size_t availregs = bin_info->nregs * bin->stats.curruns;
+                *bin_util = (bin->stats.curregs<<16) / availregs;
+                *run_util = ((bin_info->nregs - run->nfree)<<16) / bin_info->nregs;
+                defrag = 1;
+            }
+	    malloc_mutex_unlock(tsd_tsdn(tsd), &bin->lock);
+        }
+    }
+    return defrag;
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.d	2017-09-27 23:00:18.734936152 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.d	2017-09-27 23:01:54.022932659 +0800
@@ -1,19 +1,22 @@
 src/jemalloc.o: src/jemalloc.c \
  include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.d	2017-09-27 23:00:23.882935963 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.d	2017-09-27 23:01:59.466932460 +0800
@@ -1,18 +1,21 @@
 src/mb.o: src/mb.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.c	2017-01-31 23:32:23.000000000 +0800
@@ -66,23 +66,25 @@
 #ifdef JEMALLOC_MUTEX_INIT_CB
 JEMALLOC_EXPORT int	_pthread_mutex_init_calloc_cb(pthread_mutex_t *mutex,
     void *(calloc_cb)(size_t, size_t));
 #endif
 
 bool
-malloc_mutex_init(malloc_mutex_t *mutex)
+malloc_mutex_init(malloc_mutex_t *mutex, const char *name, witness_rank_t rank)
 {
 
 #ifdef _WIN32
 #  if _WIN32_WINNT >= 0x0600
 	InitializeSRWLock(&mutex->lock);
 #  else
 	if (!InitializeCriticalSectionAndSpinCount(&mutex->lock,
 	    _CRT_SPINCOUNT))
 		return (true);
 #  endif
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
+	mutex->lock = OS_UNFAIR_LOCK_INIT;
 #elif (defined(JEMALLOC_OSSPIN))
 	mutex->lock = 0;
 #elif (defined(JEMALLOC_MUTEX_INIT_CB))
 	if (postpone_init) {
 		mutex->postponed_next = postponed_mutexes;
 		postponed_mutexes = mutex;
@@ -100,47 +102,50 @@
 	if (pthread_mutex_init(&mutex->lock, &attr) != 0) {
 		pthread_mutexattr_destroy(&attr);
 		return (true);
 	}
 	pthread_mutexattr_destroy(&attr);
 #endif
+	if (config_debug)
+		witness_init(&mutex->witness, name, rank, NULL);
 	return (false);
 }
 
 void
-malloc_mutex_prefork(malloc_mutex_t *mutex)
+malloc_mutex_prefork(tsdn_t *tsdn, malloc_mutex_t *mutex)
 {
 
-	malloc_mutex_lock(mutex);
+	malloc_mutex_lock(tsdn, mutex);
 }
 
 void
-malloc_mutex_postfork_parent(malloc_mutex_t *mutex)
+malloc_mutex_postfork_parent(tsdn_t *tsdn, malloc_mutex_t *mutex)
 {
 
-	malloc_mutex_unlock(mutex);
+	malloc_mutex_unlock(tsdn, mutex);
 }
 
 void
-malloc_mutex_postfork_child(malloc_mutex_t *mutex)
+malloc_mutex_postfork_child(tsdn_t *tsdn, malloc_mutex_t *mutex)
 {
 
 #ifdef JEMALLOC_MUTEX_INIT_CB
-	malloc_mutex_unlock(mutex);
+	malloc_mutex_unlock(tsdn, mutex);
 #else
-	if (malloc_mutex_init(mutex)) {
+	if (malloc_mutex_init(mutex, mutex->witness.name,
+	    mutex->witness.rank)) {
 		malloc_printf("<jemalloc>: Error re-initializing mutex in "
 		    "child\n");
 		if (opt_abort)
 			abort();
 	}
 #endif
 }
 
 bool
-mutex_boot(void)
+malloc_mutex_boot(void)
 {
 
 #ifdef JEMALLOC_MUTEX_INIT_CB
 	postpone_init = false;
 	while (postponed_mutexes != NULL) {
 		if (_pthread_mutex_init_calloc_cb(&postponed_mutexes->lock,
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.d	2017-09-27 23:00:23.986935959 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.d	2017-09-27 23:01:59.578932456 +0800
@@ -1,18 +1,21 @@
 src/mutex.o: src/mutex.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: nstime.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: nstime.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: nstime.d
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: nstime.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,32 +1,52 @@
 #define	JEMALLOC_PAGES_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
+#ifdef JEMALLOC_SYSCTL_VM_OVERCOMMIT
+#include <sys/sysctl.h>
+#endif
+
+/******************************************************************************/
+/* Data. */
+
+#ifndef _WIN32
+#  define PAGES_PROT_COMMIT (PROT_READ | PROT_WRITE)
+#  define PAGES_PROT_DECOMMIT (PROT_NONE)
+static int	mmap_flags;
+#endif
+static bool	os_overcommits;
+
 /******************************************************************************/
 
 void *
-pages_map(void *addr, size_t size)
+pages_map(void *addr, size_t size, bool *commit)
 {
 	void *ret;
 
 	assert(size != 0);
 
+	if (os_overcommits)
+		*commit = true;
+
 #ifdef _WIN32
 	/*
 	 * If VirtualAlloc can't allocate at the given address when one is
 	 * given, it fails and returns NULL.
 	 */
-	ret = VirtualAlloc(addr, size, MEM_COMMIT | MEM_RESERVE,
+	ret = VirtualAlloc(addr, size, MEM_RESERVE | (*commit ? MEM_COMMIT : 0),
 	    PAGE_READWRITE);
 #else
 	/*
 	 * We don't use MAP_FIXED here, because it can cause the *replacement*
 	 * of existing mappings, and we only want to create new mappings.
 	 */
-	ret = mmap(addr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON,
-	    -1, 0);
+	{
+		int prot = *commit ? PAGES_PROT_COMMIT : PAGES_PROT_DECOMMIT;
+
+		ret = mmap(addr, size, prot, mmap_flags, -1, 0);
+	}
 	assert(ret != NULL);
 
 	if (ret == MAP_FAILED)
 		ret = NULL;
 	else if (addr != NULL && ret != addr) {
 		/*
@@ -64,23 +84,24 @@
 		if (opt_abort)
 			abort();
 	}
 }
 
 void *
-pages_trim(void *addr, size_t alloc_size, size_t leadsize, size_t size)
+pages_trim(void *addr, size_t alloc_size, size_t leadsize, size_t size,
+    bool *commit)
 {
 	void *ret = (void *)((uintptr_t)addr + leadsize);
 
 	assert(alloc_size >= leadsize + size);
 #ifdef _WIN32
 	{
 		void *new_addr;
 
 		pages_unmap(addr, alloc_size);
-		new_addr = pages_map(ret, size);
+		new_addr = pages_map(ret, size, commit);
 		if (new_addr == ret)
 			return (ret);
 		if (new_addr)
 			pages_unmap(new_addr, size);
 		return (NULL);
 	}
@@ -98,23 +119,23 @@
 }
 
 static bool
 pages_commit_impl(void *addr, size_t size, bool commit)
 {
 
-#ifndef _WIN32
-	/*
-	 * The following decommit/commit implementation is functional, but
-	 * always disabled because it doesn't add value beyong improved
-	 * debugging (at the cost of extra system calls) on systems that
-	 * overcommit.
-	 */
-	if (false) {
-		int prot = commit ? (PROT_READ | PROT_WRITE) : PROT_NONE;
-		void *result = mmap(addr, size, prot, MAP_PRIVATE | MAP_ANON |
-		    MAP_FIXED, -1, 0);
+	if (os_overcommits)
+		return (true);
+
+#ifdef _WIN32
+	return (commit ? (addr != VirtualAlloc(addr, size, MEM_COMMIT,
+	    PAGE_READWRITE)) : (!VirtualFree(addr, size, MEM_DECOMMIT)));
+#else
+	{
+		int prot = commit ? PAGES_PROT_COMMIT : PAGES_PROT_DECOMMIT;
+		void *result = mmap(addr, size, prot, mmap_flags | MAP_FIXED,
+		    -1, 0);
 		if (result == MAP_FAILED)
 			return (true);
 		if (result != addr) {
 			/*
 			 * We succeeded in mapping memory, but not in the right
 			 * place.
@@ -122,13 +143,12 @@
 			pages_unmap(result, size);
 			return (true);
 		}
 		return (false);
 	}
 #endif
-	return (true);
 }
 
 bool
 pages_commit(void *addr, size_t size)
 {
 
@@ -147,27 +167,136 @@
 {
 	bool unzeroed;
 
 #ifdef _WIN32
 	VirtualAlloc(addr, size, MEM_RESET, PAGE_READWRITE);
 	unzeroed = true;
-#elif defined(JEMALLOC_HAVE_MADVISE)
-#  ifdef JEMALLOC_PURGE_MADVISE_DONTNEED
-#    define JEMALLOC_MADV_PURGE MADV_DONTNEED
-#    define JEMALLOC_MADV_ZEROS true
-#  elif defined(JEMALLOC_PURGE_MADVISE_FREE)
+#elif (defined(JEMALLOC_PURGE_MADVISE_FREE) || \
+    defined(JEMALLOC_PURGE_MADVISE_DONTNEED))
+#  if defined(JEMALLOC_PURGE_MADVISE_FREE)
 #    define JEMALLOC_MADV_PURGE MADV_FREE
 #    define JEMALLOC_MADV_ZEROS false
+#  elif defined(JEMALLOC_PURGE_MADVISE_DONTNEED)
+#    define JEMALLOC_MADV_PURGE MADV_DONTNEED
+#    define JEMALLOC_MADV_ZEROS true
 #  else
-#    error "No madvise(2) flag defined for purging unused dirty pages."
+#    error No madvise(2) flag defined for purging unused dirty pages
 #  endif
 	int err = madvise(addr, size, JEMALLOC_MADV_PURGE);
 	unzeroed = (!JEMALLOC_MADV_ZEROS || err != 0);
 #  undef JEMALLOC_MADV_PURGE
 #  undef JEMALLOC_MADV_ZEROS
 #else
 	/* Last resort no-op. */
 	unzeroed = true;
 #endif
 	return (unzeroed);
 }
 
+bool
+pages_huge(void *addr, size_t size)
+{
+
+	assert(PAGE_ADDR2BASE(addr) == addr);
+	assert(PAGE_CEILING(size) == size);
+
+#ifdef JEMALLOC_THP
+	return (madvise(addr, size, MADV_HUGEPAGE) != 0);
+#else
+	return (false);
+#endif
+}
+
+bool
+pages_nohuge(void *addr, size_t size)
+{
+
+	assert(PAGE_ADDR2BASE(addr) == addr);
+	assert(PAGE_CEILING(size) == size);
+
+#ifdef JEMALLOC_THP
+	return (madvise(addr, size, MADV_NOHUGEPAGE) != 0);
+#else
+	return (false);
+#endif
+}
+
+#ifdef JEMALLOC_SYSCTL_VM_OVERCOMMIT
+static bool
+os_overcommits_sysctl(void)
+{
+	int vm_overcommit;
+	size_t sz;
+
+	sz = sizeof(vm_overcommit);
+	if (sysctlbyname("vm.overcommit", &vm_overcommit, &sz, NULL, 0) != 0)
+		return (false); /* Error. */
+
+	return ((vm_overcommit & 0x3) == 0);
+}
+#endif
+
+#ifdef JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY
+/*
+ * Use syscall(2) rather than {open,read,close}(2) when possible to avoid
+ * reentry during bootstrapping if another library has interposed system call
+ * wrappers.
+ */
+static bool
+os_overcommits_proc(void)
+{
+	int fd;
+	char buf[1];
+	ssize_t nread;
+
+#if defined(JEMALLOC_USE_SYSCALL) && defined(SYS_open)
+	fd = (int)syscall(SYS_open, "/proc/sys/vm/overcommit_memory", O_RDONLY);
+#else
+	fd = open("/proc/sys/vm/overcommit_memory", O_RDONLY);
+#endif
+	if (fd == -1)
+		return (false); /* Error. */
+
+#if defined(JEMALLOC_USE_SYSCALL) && defined(SYS_read)
+	nread = (ssize_t)syscall(SYS_read, fd, &buf, sizeof(buf));
+#else
+	nread = read(fd, &buf, sizeof(buf));
+#endif
+
+#if defined(JEMALLOC_USE_SYSCALL) && defined(SYS_close)
+	syscall(SYS_close, fd);
+#else
+	close(fd);
+#endif
+
+	if (nread < 1)
+		return (false); /* Error. */
+	/*
+	 * /proc/sys/vm/overcommit_memory meanings:
+	 * 0: Heuristic overcommit.
+	 * 1: Always overcommit.
+	 * 2: Never overcommit.
+	 */
+	return (buf[0] == '0' || buf[0] == '1');
+}
+#endif
+
+void
+pages_boot(void)
+{
+
+#ifndef _WIN32
+	mmap_flags = MAP_PRIVATE | MAP_ANON;
+#endif
+
+#ifdef JEMALLOC_SYSCTL_VM_OVERCOMMIT
+	os_overcommits = os_overcommits_sysctl();
+#elif defined(JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY)
+	os_overcommits = os_overcommits_proc();
+#  ifdef MAP_NORESERVE
+	if (os_overcommits)
+		mmap_flags |= MAP_NORESERVE;
+#  endif
+#else
+	os_overcommits = false;
+#endif
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.d	2017-09-27 23:00:24.098935955 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.d	2017-09-27 23:01:59.838932446 +0800
@@ -1,18 +1,21 @@
 src/pages.o: src/pages.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: prng.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: prng.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: prng.d
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: prng.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.c	2017-01-31 23:32:23.000000000 +0800
@@ -106,31 +106,31 @@
 #ifdef JEMALLOC_PROF
     PROF_DUMP_BUFSIZE
 #else
     1
 #endif
 ];
-static unsigned		prof_dump_buf_end;
+static size_t		prof_dump_buf_end;
 static int		prof_dump_fd;
 
 /* Do not dump any profiles until bootstrapping is complete. */
 static bool		prof_booted = false;
 
 /******************************************************************************/
 /*
  * Function prototypes for static functions that are referenced prior to
  * definition.
  */
 
-static bool	prof_tctx_should_destroy(prof_tctx_t *tctx);
+static bool	prof_tctx_should_destroy(tsdn_t *tsdn, prof_tctx_t *tctx);
 static void	prof_tctx_destroy(tsd_t *tsd, prof_tctx_t *tctx);
-static bool	prof_tdata_should_destroy(prof_tdata_t *tdata,
+static bool	prof_tdata_should_destroy(tsdn_t *tsdn, prof_tdata_t *tdata,
     bool even_if_attached);
 static void	prof_tdata_destroy(tsd_t *tsd, prof_tdata_t *tdata,
     bool even_if_attached);
-static char	*prof_thread_name_alloc(tsd_t *tsd, const char *thread_name);
+static char	*prof_thread_name_alloc(tsdn_t *tsdn, const char *thread_name);
 
 /******************************************************************************/
 /* Red-black trees. */
 
 JEMALLOC_INLINE_C int
 prof_tctx_comp(const prof_tctx_t *a, const prof_tctx_t *b)
@@ -210,52 +210,53 @@
 		tdata = prof_tdata_get(tsd, true);
 		if (tdata != NULL)
 			prof_sample_threshold_update(tdata);
 	}
 
 	if ((uintptr_t)tctx > (uintptr_t)1U) {
-		malloc_mutex_lock(tctx->tdata->lock);
+		malloc_mutex_lock(tsd_tsdn(tsd), tctx->tdata->lock);
 		tctx->prepared = false;
-		if (prof_tctx_should_destroy(tctx))
+		if (prof_tctx_should_destroy(tsd_tsdn(tsd), tctx))
 			prof_tctx_destroy(tsd, tctx);
 		else
-			malloc_mutex_unlock(tctx->tdata->lock);
+			malloc_mutex_unlock(tsd_tsdn(tsd), tctx->tdata->lock);
 	}
 }
 
 void
-prof_malloc_sample_object(const void *ptr, size_t usize, prof_tctx_t *tctx)
+prof_malloc_sample_object(tsdn_t *tsdn, const void *ptr, size_t usize,
+    prof_tctx_t *tctx)
 {
 
-	prof_tctx_set(ptr, usize, tctx);
+	prof_tctx_set(tsdn, ptr, usize, tctx);
 
-	malloc_mutex_lock(tctx->tdata->lock);
+	malloc_mutex_lock(tsdn, tctx->tdata->lock);
 	tctx->cnts.curobjs++;
 	tctx->cnts.curbytes += usize;
 	if (opt_prof_accum) {
 		tctx->cnts.accumobjs++;
 		tctx->cnts.accumbytes += usize;
 	}
 	tctx->prepared = false;
-	malloc_mutex_unlock(tctx->tdata->lock);
+	malloc_mutex_unlock(tsdn, tctx->tdata->lock);
 }
 
 void
 prof_free_sampled_object(tsd_t *tsd, size_t usize, prof_tctx_t *tctx)
 {
 
-	malloc_mutex_lock(tctx->tdata->lock);
+	malloc_mutex_lock(tsd_tsdn(tsd), tctx->tdata->lock);
 	assert(tctx->cnts.curobjs > 0);
 	assert(tctx->cnts.curbytes >= usize);
 	tctx->cnts.curobjs--;
 	tctx->cnts.curbytes -= usize;
 
-	if (prof_tctx_should_destroy(tctx))
+	if (prof_tctx_should_destroy(tsd_tsdn(tsd), tctx))
 		prof_tctx_destroy(tsd, tctx);
 	else
-		malloc_mutex_unlock(tctx->tdata->lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), tctx->tdata->lock);
 }
 
 void
 bt_init(prof_bt_t *bt, void **vec)
 {
 
@@ -274,38 +275,38 @@
 
 	if (tdata != NULL) {
 		assert(!tdata->enq);
 		tdata->enq = true;
 	}
 
-	malloc_mutex_lock(&bt2gctx_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &bt2gctx_mtx);
 }
 
 JEMALLOC_INLINE_C void
 prof_leave(tsd_t *tsd, prof_tdata_t *tdata)
 {
 
 	cassert(config_prof);
 	assert(tdata == prof_tdata_get(tsd, false));
 
-	malloc_mutex_unlock(&bt2gctx_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &bt2gctx_mtx);
 
 	if (tdata != NULL) {
 		bool idump, gdump;
 
 		assert(tdata->enq);
 		tdata->enq = false;
 		idump = tdata->enq_idump;
 		tdata->enq_idump = false;
 		gdump = tdata->enq_gdump;
 		tdata->enq_gdump = false;
 
 		if (idump)
-			prof_idump();
+			prof_idump(tsd_tsdn(tsd));
 		if (gdump)
-			prof_gdump();
+			prof_gdump(tsd_tsdn(tsd));
 	}
 }
 
 #ifdef JEMALLOC_PROF_LIBUNWIND
 void
 prof_backtrace(prof_bt_t *bt)
@@ -543,20 +544,21 @@
 {
 
 	return (&tdata_locks[thr_uid % PROF_NTDATA_LOCKS]);
 }
 
 static prof_gctx_t *
-prof_gctx_create(tsd_t *tsd, prof_bt_t *bt)
+prof_gctx_create(tsdn_t *tsdn, prof_bt_t *bt)
 {
 	/*
 	 * Create a single allocation that has space for vec of length bt->len.
 	 */
-	prof_gctx_t *gctx = (prof_gctx_t *)iallocztm(tsd, offsetof(prof_gctx_t,
-	    vec) + (bt->len * sizeof(void *)), false, tcache_get(tsd, true),
-	    true, NULL);
+	size_t size = offsetof(prof_gctx_t, vec) + (bt->len * sizeof(void *));
+	prof_gctx_t *gctx = (prof_gctx_t *)iallocztm(tsdn, size,
+	    size2index(size), false, NULL, true, arena_get(TSDN_NULL, 0, true),
+	    true);
 	if (gctx == NULL)
 		return (NULL);
 	gctx->lock = prof_gctx_mutex_choose();
 	/*
 	 * Set nlimbo to 1, in order to avoid a race condition with
 	 * prof_tctx_destroy()/prof_gctx_try_destroy().
@@ -582,38 +584,39 @@
 	 * it.  prof_lookup() increments gctx->nlimbo in order to avoid a race
 	 * condition with this function, as does prof_tctx_destroy() in order to
 	 * avoid a race between the main body of prof_tctx_destroy() and entry
 	 * into this function.
 	 */
 	prof_enter(tsd, tdata_self);
-	malloc_mutex_lock(gctx->lock);
+	malloc_mutex_lock(tsd_tsdn(tsd), gctx->lock);
 	assert(gctx->nlimbo != 0);
 	if (tctx_tree_empty(&gctx->tctxs) && gctx->nlimbo == 1) {
 		/* Remove gctx from bt2gctx. */
 		if (ckh_remove(tsd, &bt2gctx, &gctx->bt, NULL, NULL))
 			not_reached();
 		prof_leave(tsd, tdata_self);
 		/* Destroy gctx. */
-		malloc_mutex_unlock(gctx->lock);
-		idalloctm(tsd, gctx, tcache_get(tsd, false), true);
+		malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
+		idalloctm(tsd_tsdn(tsd), gctx, NULL, true, true);
 	} else {
 		/*
 		 * Compensate for increment in prof_tctx_destroy() or
 		 * prof_lookup().
 		 */
 		gctx->nlimbo--;
-		malloc_mutex_unlock(gctx->lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 		prof_leave(tsd, tdata_self);
 	}
 }
 
-/* tctx->tdata->lock must be held. */
 static bool
-prof_tctx_should_destroy(prof_tctx_t *tctx)
+prof_tctx_should_destroy(tsdn_t *tsdn, prof_tctx_t *tctx)
 {
 
+	malloc_mutex_assert_owner(tsdn, tctx->tdata->lock);
+
 	if (opt_prof_accum)
 		return (false);
 	if (tctx->cnts.curobjs != 0)
 		return (false);
 	if (tctx->prepared)
 		return (false);
@@ -630,31 +633,32 @@
 		return (false);
 	if (gctx->nlimbo != 0)
 		return (false);
 	return (true);
 }
 
-/* tctx->tdata->lock is held upon entry, and released before return. */
 static void
 prof_tctx_destroy(tsd_t *tsd, prof_tctx_t *tctx)
 {
 	prof_tdata_t *tdata = tctx->tdata;
 	prof_gctx_t *gctx = tctx->gctx;
 	bool destroy_tdata, destroy_tctx, destroy_gctx;
 
+	malloc_mutex_assert_owner(tsd_tsdn(tsd), tctx->tdata->lock);
+
 	assert(tctx->cnts.curobjs == 0);
 	assert(tctx->cnts.curbytes == 0);
 	assert(!opt_prof_accum);
 	assert(tctx->cnts.accumobjs == 0);
 	assert(tctx->cnts.accumbytes == 0);
 
 	ckh_remove(tsd, &tdata->bt2tctx, &gctx->bt, NULL, NULL);
-	destroy_tdata = prof_tdata_should_destroy(tdata, false);
-	malloc_mutex_unlock(tdata->lock);
+	destroy_tdata = prof_tdata_should_destroy(tsd_tsdn(tsd), tdata, false);
+	malloc_mutex_unlock(tsd_tsdn(tsd), tdata->lock);
 
-	malloc_mutex_lock(gctx->lock);
+	malloc_mutex_lock(tsd_tsdn(tsd), gctx->lock);
 	switch (tctx->state) {
 	case prof_tctx_state_nominal:
 		tctx_tree_remove(&gctx->tctxs, tctx);
 		destroy_tctx = true;
 		if (prof_gctx_should_destroy(gctx)) {
 			/*
@@ -688,23 +692,25 @@
 		break;
 	default:
 		not_reached();
 		destroy_tctx = false;
 		destroy_gctx = false;
 	}
-	malloc_mutex_unlock(gctx->lock);
+	malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 	if (destroy_gctx) {
 		prof_gctx_try_destroy(tsd, prof_tdata_get(tsd, false), gctx,
 		    tdata);
 	}
 
+	malloc_mutex_assert_not_owner(tsd_tsdn(tsd), tctx->tdata->lock);
+
 	if (destroy_tdata)
 		prof_tdata_destroy(tsd, tdata, false);
 
 	if (destroy_tctx)
-		idalloctm(tsd, tctx, tcache_get(tsd, false), true);
+		idalloctm(tsd_tsdn(tsd), tctx, NULL, true, true);
 }
 
 static bool
 prof_lookup_global(tsd_t *tsd, prof_bt_t *bt, prof_tdata_t *tdata,
     void **p_btkey, prof_gctx_t **p_gctx, bool *p_new_gctx)
 {
@@ -718,33 +724,33 @@
 	} btkey;
 	bool new_gctx;
 
 	prof_enter(tsd, tdata);
 	if (ckh_search(&bt2gctx, bt, &btkey.v, &gctx.v)) {
 		/* bt has never been seen before.  Insert it. */
-		gctx.p = prof_gctx_create(tsd, bt);
+		gctx.p = prof_gctx_create(tsd_tsdn(tsd), bt);
 		if (gctx.v == NULL) {
 			prof_leave(tsd, tdata);
 			return (true);
 		}
 		btkey.p = &gctx.p->bt;
 		if (ckh_insert(tsd, &bt2gctx, btkey.v, gctx.v)) {
 			/* OOM. */
 			prof_leave(tsd, tdata);
-			idalloctm(tsd, gctx.v, tcache_get(tsd, false), true);
+			idalloctm(tsd_tsdn(tsd), gctx.v, NULL, true, true);
 			return (true);
 		}
 		new_gctx = true;
 	} else {
 		/*
 		 * Increment nlimbo, in order to avoid a race condition with
 		 * prof_tctx_destroy()/prof_gctx_try_destroy().
 		 */
-		malloc_mutex_lock(gctx.p->lock);
+		malloc_mutex_lock(tsd_tsdn(tsd), gctx.p->lock);
 		gctx.p->nlimbo++;
-		malloc_mutex_unlock(gctx.p->lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), gctx.p->lock);
 		new_gctx = false;
 	}
 	prof_leave(tsd, tdata);
 
 	*p_btkey = btkey.v;
 	*p_gctx = gctx.p;
@@ -765,19 +771,18 @@
 	cassert(config_prof);
 
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL)
 		return (NULL);
 
-	malloc_mutex_lock(tdata->lock);
+	malloc_mutex_lock(tsd_tsdn(tsd), tdata->lock);
 	not_found = ckh_search(&tdata->bt2tctx, bt, NULL, &ret.v);
 	if (!not_found) /* Note double negative! */
 		ret.p->prepared = true;
-	malloc_mutex_unlock(tdata->lock);
+	malloc_mutex_unlock(tsd_tsdn(tsd), tdata->lock);
 	if (not_found) {
-		tcache_t *tcache;
 		void *btkey;
 		prof_gctx_t *gctx;
 		bool new_gctx, error;
 
 		/*
 		 * This thread's cache lacks bt.  Look for it in the global
@@ -785,15 +790,15 @@
 		 */
 		if (prof_lookup_global(tsd, bt, tdata, &btkey, &gctx,
 		    &new_gctx))
 			return (NULL);
 
 		/* Link a prof_tctx_t into gctx for this thread. */
-		tcache = tcache_get(tsd, true);
-		ret.v = iallocztm(tsd, sizeof(prof_tctx_t), false, tcache, true,
-		    NULL);
+		ret.v = iallocztm(tsd_tsdn(tsd), sizeof(prof_tctx_t),
+		    size2index(sizeof(prof_tctx_t)), false, NULL, true,
+		    arena_ichoose(tsd, NULL), true);
 		if (ret.p == NULL) {
 			if (new_gctx)
 				prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
 			return (NULL);
 		}
 		ret.p->tdata = tdata;
@@ -801,47 +806,47 @@
 		ret.p->thr_discrim = tdata->thr_discrim;
 		memset(&ret.p->cnts, 0, sizeof(prof_cnt_t));
 		ret.p->gctx = gctx;
 		ret.p->tctx_uid = tdata->tctx_uid_next++;
 		ret.p->prepared = true;
 		ret.p->state = prof_tctx_state_initializing;
-		malloc_mutex_lock(tdata->lock);
+		malloc_mutex_lock(tsd_tsdn(tsd), tdata->lock);
 		error = ckh_insert(tsd, &tdata->bt2tctx, btkey, ret.v);
-		malloc_mutex_unlock(tdata->lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), tdata->lock);
 		if (error) {
 			if (new_gctx)
 				prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
-			idalloctm(tsd, ret.v, tcache, true);
+			idalloctm(tsd_tsdn(tsd), ret.v, NULL, true, true);
 			return (NULL);
 		}
-		malloc_mutex_lock(gctx->lock);
+		malloc_mutex_lock(tsd_tsdn(tsd), gctx->lock);
 		ret.p->state = prof_tctx_state_nominal;
 		tctx_tree_insert(&gctx->tctxs, ret.p);
 		gctx->nlimbo--;
-		malloc_mutex_unlock(gctx->lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 	}
 
 	return (ret.p);
 }
 
+/*
+ * The bodies of this function and prof_leakcheck() are compiled out unless heap
+ * profiling is enabled, so that it is possible to compile jemalloc with
+ * floating point support completely disabled.  Avoiding floating point code is
+ * important on memory-constrained systems, but it also enables a workaround for
+ * versions of glibc that don't properly save/restore floating point registers
+ * during dynamic lazy symbol loading (which internally calls into whatever
+ * malloc implementation happens to be integrated into the application).  Note
+ * that some compilers (e.g.  gcc 4.8) may use floating point registers for fast
+ * memory moves, so jemalloc must be compiled with such optimizations disabled
+ * (e.g.
+ * -mno-sse) in order for the workaround to be complete.
+ */
 void
 prof_sample_threshold_update(prof_tdata_t *tdata)
 {
-	/*
-	 * The body of this function is compiled out unless heap profiling is
-	 * enabled, so that it is possible to compile jemalloc with floating
-	 * point support completely disabled.  Avoiding floating point code is
-	 * important on memory-constrained systems, but it also enables a
-	 * workaround for versions of glibc that don't properly save/restore
-	 * floating point registers during dynamic lazy symbol loading (which
-	 * internally calls into whatever malloc implementation happens to be
-	 * integrated into the application).  Note that some compilers (e.g.
-	 * gcc 4.8) may use floating point registers for fast memory moves, so
-	 * jemalloc must be compiled with such optimizations disabled (e.g.
-	 * -mno-sse) in order for the workaround to be complete.
-	 */
 #ifdef JEMALLOC_PROF
 	uint64_t r;
 	double u;
 
 	if (!config_prof)
 		return;
@@ -866,14 +871,13 @@
 	 *   Non-Uniform Random Variate Generation
 	 *   Luc Devroye
 	 *   Springer-Verlag, New York, 1986
 	 *   pp 500
 	 *   (http://luc.devroye.org/rnbookindex.html)
 	 */
-	prng64(r, 53, tdata->prng_state, UINT64_C(6364136223846793005),
-	    UINT64_C(1442695040888963407));
+	r = prng_lg_range_u64(&tdata->prng_state, 53);
 	u = (double)r * (1.0/9007199254740992.0L);
 	tdata->bytes_until_sample = (uint64_t)(log(u) /
 	    log(1.0 - (1.0 / (double)((uint64_t)1U << lg_prof_sample))))
 	    + (uint64_t)1U;
 #endif
 }
@@ -890,17 +894,19 @@
 }
 
 size_t
 prof_tdata_count(void)
 {
 	size_t tdata_count = 0;
+	tsdn_t *tsdn;
 
-	malloc_mutex_lock(&tdatas_mtx);
+	tsdn = tsdn_fetch();
+	malloc_mutex_lock(tsdn, &tdatas_mtx);
 	tdata_tree_iter(&tdatas, NULL, prof_tdata_count_iter,
 	    (void *)&tdata_count);
-	malloc_mutex_unlock(&tdatas_mtx);
+	malloc_mutex_unlock(tsdn, &tdatas_mtx);
 
 	return (tdata_count);
 }
 #endif
 
 #ifdef JEMALLOC_JET
@@ -913,15 +919,15 @@
 
 	tsd = tsd_fetch();
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL)
 		return (0);
 
-	malloc_mutex_lock(&bt2gctx_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &bt2gctx_mtx);
 	bt_count = ckh_count(&bt2gctx);
-	malloc_mutex_unlock(&bt2gctx_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &bt2gctx_mtx);
 
 	return (bt_count);
 }
 #endif
 
 #ifdef JEMALLOC_JET
@@ -985,13 +991,13 @@
 	return (ret);
 }
 
 static bool
 prof_dump_write(bool propagate_err, const char *s)
 {
-	unsigned i, slen, n;
+	size_t i, slen, n;
 
 	cassert(config_prof);
 
 	i = 0;
 	slen = strlen(s);
 	while (i < slen) {
@@ -1028,26 +1034,27 @@
 	va_end(ap);
 	ret = prof_dump_write(propagate_err, buf);
 
 	return (ret);
 }
 
-/* tctx->tdata->lock is held. */
 static void
-prof_tctx_merge_tdata(prof_tctx_t *tctx, prof_tdata_t *tdata)
+prof_tctx_merge_tdata(tsdn_t *tsdn, prof_tctx_t *tctx, prof_tdata_t *tdata)
 {
 
-	malloc_mutex_lock(tctx->gctx->lock);
+	malloc_mutex_assert_owner(tsdn, tctx->tdata->lock);
+
+	malloc_mutex_lock(tsdn, tctx->gctx->lock);
 
 	switch (tctx->state) {
 	case prof_tctx_state_initializing:
-		malloc_mutex_unlock(tctx->gctx->lock);
+		malloc_mutex_unlock(tsdn, tctx->gctx->lock);
 		return;
 	case prof_tctx_state_nominal:
 		tctx->state = prof_tctx_state_dumping;
-		malloc_mutex_unlock(tctx->gctx->lock);
+		malloc_mutex_unlock(tsdn, tctx->gctx->lock);
 
 		memcpy(&tctx->dump_cnts, &tctx->cnts, sizeof(prof_cnt_t));
 
 		tdata->cnt_summed.curobjs += tctx->dump_cnts.curobjs;
 		tdata->cnt_summed.curbytes += tctx->dump_cnts.curbytes;
 		if (opt_prof_accum) {
@@ -1060,77 +1067,89 @@
 	case prof_tctx_state_dumping:
 	case prof_tctx_state_purgatory:
 		not_reached();
 	}
 }
 
-/* gctx->lock is held. */
 static void
-prof_tctx_merge_gctx(prof_tctx_t *tctx, prof_gctx_t *gctx)
+prof_tctx_merge_gctx(tsdn_t *tsdn, prof_tctx_t *tctx, prof_gctx_t *gctx)
 {
 
+	malloc_mutex_assert_owner(tsdn, gctx->lock);
+
 	gctx->cnt_summed.curobjs += tctx->dump_cnts.curobjs;
 	gctx->cnt_summed.curbytes += tctx->dump_cnts.curbytes;
 	if (opt_prof_accum) {
 		gctx->cnt_summed.accumobjs += tctx->dump_cnts.accumobjs;
 		gctx->cnt_summed.accumbytes += tctx->dump_cnts.accumbytes;
 	}
 }
 
-/* tctx->gctx is held. */
 static prof_tctx_t *
 prof_tctx_merge_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg)
 {
+	tsdn_t *tsdn = (tsdn_t *)arg;
+
+	malloc_mutex_assert_owner(tsdn, tctx->gctx->lock);
 
 	switch (tctx->state) {
 	case prof_tctx_state_nominal:
 		/* New since dumping started; ignore. */
 		break;
 	case prof_tctx_state_dumping:
 	case prof_tctx_state_purgatory:
-		prof_tctx_merge_gctx(tctx, tctx->gctx);
+		prof_tctx_merge_gctx(tsdn, tctx, tctx->gctx);
 		break;
 	default:
 		not_reached();
 	}
 
 	return (NULL);
 }
 
-/* gctx->lock is held. */
+struct prof_tctx_dump_iter_arg_s {
+	tsdn_t	*tsdn;
+	bool	propagate_err;
+};
+
 static prof_tctx_t *
-prof_tctx_dump_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg)
+prof_tctx_dump_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *opaque)
 {
-	bool propagate_err = *(bool *)arg;
+	struct prof_tctx_dump_iter_arg_s *arg =
+	    (struct prof_tctx_dump_iter_arg_s *)opaque;
+
+	malloc_mutex_assert_owner(arg->tsdn, tctx->gctx->lock);
 
 	switch (tctx->state) {
 	case prof_tctx_state_initializing:
 	case prof_tctx_state_nominal:
 		/* Not captured by this dump. */
 		break;
 	case prof_tctx_state_dumping:
 	case prof_tctx_state_purgatory:
-		if (prof_dump_printf(propagate_err,
+		if (prof_dump_printf(arg->propagate_err,
 		    "  t%"FMTu64": %"FMTu64": %"FMTu64" [%"FMTu64": "
 		    "%"FMTu64"]\n", tctx->thr_uid, tctx->dump_cnts.curobjs,
 		    tctx->dump_cnts.curbytes, tctx->dump_cnts.accumobjs,
 		    tctx->dump_cnts.accumbytes))
 			return (tctx);
 		break;
 	default:
 		not_reached();
 	}
 	return (NULL);
 }
 
-/* tctx->gctx is held. */
 static prof_tctx_t *
 prof_tctx_finish_iter(prof_tctx_tree_t *tctxs, prof_tctx_t *tctx, void *arg)
 {
+	tsdn_t *tsdn = (tsdn_t *)arg;
 	prof_tctx_t *ret;
 
+	malloc_mutex_assert_owner(tsdn, tctx->gctx->lock);
+
 	switch (tctx->state) {
 	case prof_tctx_state_nominal:
 		/* New since dumping started; ignore. */
 		break;
 	case prof_tctx_state_dumping:
 		tctx->state = prof_tctx_state_nominal;
@@ -1145,42 +1164,49 @@
 	ret = NULL;
 label_return:
 	return (ret);
 }
 
 static void
-prof_dump_gctx_prep(prof_gctx_t *gctx, prof_gctx_tree_t *gctxs)
+prof_dump_gctx_prep(tsdn_t *tsdn, prof_gctx_t *gctx, prof_gctx_tree_t *gctxs)
 {
 
 	cassert(config_prof);
 
-	malloc_mutex_lock(gctx->lock);
+	malloc_mutex_lock(tsdn, gctx->lock);
 
 	/*
 	 * Increment nlimbo so that gctx won't go away before dump.
 	 * Additionally, link gctx into the dump list so that it is included in
 	 * prof_dump()'s second pass.
 	 */
 	gctx->nlimbo++;
 	gctx_tree_insert(gctxs, gctx);
 
 	memset(&gctx->cnt_summed, 0, sizeof(prof_cnt_t));
 
-	malloc_mutex_unlock(gctx->lock);
+	malloc_mutex_unlock(tsdn, gctx->lock);
 }
 
+struct prof_gctx_merge_iter_arg_s {
+	tsdn_t	*tsdn;
+	size_t	leak_ngctx;
+};
+
 static prof_gctx_t *
-prof_gctx_merge_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *arg)
+prof_gctx_merge_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *opaque)
 {
-	size_t *leak_ngctx = (size_t *)arg;
+	struct prof_gctx_merge_iter_arg_s *arg =
+	    (struct prof_gctx_merge_iter_arg_s *)opaque;
 
-	malloc_mutex_lock(gctx->lock);
-	tctx_tree_iter(&gctx->tctxs, NULL, prof_tctx_merge_iter, NULL);
+	malloc_mutex_lock(arg->tsdn, gctx->lock);
+	tctx_tree_iter(&gctx->tctxs, NULL, prof_tctx_merge_iter,
+	    (void *)arg->tsdn);
 	if (gctx->cnt_summed.curobjs != 0)
-		(*leak_ngctx)++;
-	malloc_mutex_unlock(gctx->lock);
+		arg->leak_ngctx++;
+	malloc_mutex_unlock(arg->tsdn, gctx->lock);
 
 	return (NULL);
 }
 
 static void
 prof_gctx_finish(tsd_t *tsd, prof_gctx_tree_t *gctxs)
@@ -1193,70 +1219,78 @@
 	 * decrement gctx->nlimbo and unlock gctx, another thread can
 	 * concurrently destroy it, which will corrupt the tree.  Therefore,
 	 * tear down the tree one node at a time during iteration.
 	 */
 	while ((gctx = gctx_tree_first(gctxs)) != NULL) {
 		gctx_tree_remove(gctxs, gctx);
-		malloc_mutex_lock(gctx->lock);
+		malloc_mutex_lock(tsd_tsdn(tsd), gctx->lock);
 		{
 			prof_tctx_t *next;
 
 			next = NULL;
 			do {
 				prof_tctx_t *to_destroy =
 				    tctx_tree_iter(&gctx->tctxs, next,
-				    prof_tctx_finish_iter, NULL);
+				    prof_tctx_finish_iter,
+				    (void *)tsd_tsdn(tsd));
 				if (to_destroy != NULL) {
 					next = tctx_tree_next(&gctx->tctxs,
 					    to_destroy);
 					tctx_tree_remove(&gctx->tctxs,
 					    to_destroy);
-					idalloctm(tsd, to_destroy,
-					    tcache_get(tsd, false), true);
+					idalloctm(tsd_tsdn(tsd), to_destroy,
+					    NULL, true, true);
 				} else
 					next = NULL;
 			} while (next != NULL);
 		}
 		gctx->nlimbo--;
 		if (prof_gctx_should_destroy(gctx)) {
 			gctx->nlimbo++;
-			malloc_mutex_unlock(gctx->lock);
+			malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 			prof_gctx_try_destroy(tsd, tdata, gctx, tdata);
 		} else
-			malloc_mutex_unlock(gctx->lock);
+			malloc_mutex_unlock(tsd_tsdn(tsd), gctx->lock);
 	}
 }
 
+struct prof_tdata_merge_iter_arg_s {
+	tsdn_t		*tsdn;
+	prof_cnt_t	cnt_all;
+};
+
 static prof_tdata_t *
-prof_tdata_merge_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata, void *arg)
+prof_tdata_merge_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata,
+    void *opaque)
 {
-	prof_cnt_t *cnt_all = (prof_cnt_t *)arg;
+	struct prof_tdata_merge_iter_arg_s *arg =
+	    (struct prof_tdata_merge_iter_arg_s *)opaque;
 
-	malloc_mutex_lock(tdata->lock);
+	malloc_mutex_lock(arg->tsdn, tdata->lock);
 	if (!tdata->expired) {
 		size_t tabind;
 		union {
 			prof_tctx_t	*p;
 			void		*v;
 		} tctx;
 
 		tdata->dumping = true;
 		memset(&tdata->cnt_summed, 0, sizeof(prof_cnt_t));
 		for (tabind = 0; !ckh_iter(&tdata->bt2tctx, &tabind, NULL,
 		    &tctx.v);)
-			prof_tctx_merge_tdata(tctx.p, tdata);
+			prof_tctx_merge_tdata(arg->tsdn, tctx.p, tdata);
 
-		cnt_all->curobjs += tdata->cnt_summed.curobjs;
-		cnt_all->curbytes += tdata->cnt_summed.curbytes;
+		arg->cnt_all.curobjs += tdata->cnt_summed.curobjs;
+		arg->cnt_all.curbytes += tdata->cnt_summed.curbytes;
 		if (opt_prof_accum) {
-			cnt_all->accumobjs += tdata->cnt_summed.accumobjs;
-			cnt_all->accumbytes += tdata->cnt_summed.accumbytes;
+			arg->cnt_all.accumobjs += tdata->cnt_summed.accumobjs;
+			arg->cnt_all.accumbytes += tdata->cnt_summed.accumbytes;
 		}
 	} else
 		tdata->dumping = false;
-	malloc_mutex_unlock(tdata->lock);
+	malloc_mutex_unlock(arg->tsdn, tdata->lock);
 
 	return (NULL);
 }
 
 static prof_tdata_t *
 prof_tdata_dump_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata, void *arg)
@@ -1279,44 +1313,45 @@
 
 #ifdef JEMALLOC_JET
 #undef prof_dump_header
 #define	prof_dump_header JEMALLOC_N(prof_dump_header_impl)
 #endif
 static bool
-prof_dump_header(bool propagate_err, const prof_cnt_t *cnt_all)
+prof_dump_header(tsdn_t *tsdn, bool propagate_err, const prof_cnt_t *cnt_all)
 {
 	bool ret;
 
 	if (prof_dump_printf(propagate_err,
 	    "heap_v2/%"FMTu64"\n"
 	    "  t*: %"FMTu64": %"FMTu64" [%"FMTu64": %"FMTu64"]\n",
 	    ((uint64_t)1U << lg_prof_sample), cnt_all->curobjs,
 	    cnt_all->curbytes, cnt_all->accumobjs, cnt_all->accumbytes))
 		return (true);
 
-	malloc_mutex_lock(&tdatas_mtx);
+	malloc_mutex_lock(tsdn, &tdatas_mtx);
 	ret = (tdata_tree_iter(&tdatas, NULL, prof_tdata_dump_iter,
 	    (void *)&propagate_err) != NULL);
-	malloc_mutex_unlock(&tdatas_mtx);
+	malloc_mutex_unlock(tsdn, &tdatas_mtx);
 	return (ret);
 }
 #ifdef JEMALLOC_JET
 #undef prof_dump_header
 #define	prof_dump_header JEMALLOC_N(prof_dump_header)
 prof_dump_header_t *prof_dump_header = JEMALLOC_N(prof_dump_header_impl);
 #endif
 
-/* gctx->lock is held. */
 static bool
-prof_dump_gctx(bool propagate_err, prof_gctx_t *gctx, const prof_bt_t *bt,
-    prof_gctx_tree_t *gctxs)
+prof_dump_gctx(tsdn_t *tsdn, bool propagate_err, prof_gctx_t *gctx,
+    const prof_bt_t *bt, prof_gctx_tree_t *gctxs)
 {
 	bool ret;
 	unsigned i;
+	struct prof_tctx_dump_iter_arg_s prof_tctx_dump_iter_arg;
 
 	cassert(config_prof);
+	malloc_mutex_assert_owner(tsdn, gctx->lock);
 
 	/* Avoid dumping such gctx's that have no useful data. */
 	if ((!opt_prof_accum && gctx->cnt_summed.curobjs == 0) ||
 	    (opt_prof_accum && gctx->cnt_summed.accumobjs == 0)) {
 		assert(gctx->cnt_summed.curobjs == 0);
 		assert(gctx->cnt_summed.curbytes == 0);
@@ -1344,23 +1379,26 @@
 	    gctx->cnt_summed.curobjs, gctx->cnt_summed.curbytes,
 	    gctx->cnt_summed.accumobjs, gctx->cnt_summed.accumbytes)) {
 		ret = true;
 		goto label_return;
 	}
 
+	prof_tctx_dump_iter_arg.tsdn = tsdn;
+	prof_tctx_dump_iter_arg.propagate_err = propagate_err;
 	if (tctx_tree_iter(&gctx->tctxs, NULL, prof_tctx_dump_iter,
-	    (void *)&propagate_err) != NULL) {
+	    (void *)&prof_tctx_dump_iter_arg) != NULL) {
 		ret = true;
 		goto label_return;
 	}
 
 	ret = false;
 label_return:
 	return (ret);
 }
 
+#ifndef _WIN32
 JEMALLOC_FORMAT_PRINTF(1, 2)
 static int
 prof_open_maps(const char *format, ...)
 {
 	int mfd;
 	va_list ap;
@@ -1370,25 +1408,39 @@
 	malloc_vsnprintf(filename, sizeof(filename), format, ap);
 	va_end(ap);
 	mfd = open(filename, O_RDONLY);
 
 	return (mfd);
 }
+#endif
+
+static int
+prof_getpid(void)
+{
+
+#ifdef _WIN32
+	return (GetCurrentProcessId());
+#else
+	return (getpid());
+#endif
+}
 
 static bool
 prof_dump_maps(bool propagate_err)
 {
 	bool ret;
 	int mfd;
 
 	cassert(config_prof);
 #ifdef __FreeBSD__
 	mfd = prof_open_maps("/proc/curproc/map");
+#elif defined(_WIN32)
+	mfd = -1; // Not implemented
 #else
 	{
-		int pid = getpid();
+		int pid = prof_getpid();
 
 		mfd = prof_open_maps("/proc/%d/task/%d/maps", pid, pid);
 		if (mfd == -1)
 			mfd = prof_open_maps("/proc/%d/maps", pid);
 	}
 #endif
@@ -1423,125 +1475,161 @@
 label_return:
 	if (mfd != -1)
 		close(mfd);
 	return (ret);
 }
 
+/*
+ * See prof_sample_threshold_update() comment for why the body of this function
+ * is conditionally compiled.
+ */
 static void
 prof_leakcheck(const prof_cnt_t *cnt_all, size_t leak_ngctx,
     const char *filename)
 {
 
+#ifdef JEMALLOC_PROF
+	/*
+	 * Scaling is equivalent AdjustSamples() in jeprof, but the result may
+	 * differ slightly from what jeprof reports, because here we scale the
+	 * summary values, whereas jeprof scales each context individually and
+	 * reports the sums of the scaled values.
+	 */
 	if (cnt_all->curbytes != 0) {
-		malloc_printf("<jemalloc>: Leak summary: %"FMTu64" byte%s, %"
-		    FMTu64" object%s, %zu context%s\n",
-		    cnt_all->curbytes, (cnt_all->curbytes != 1) ? "s" : "",
-		    cnt_all->curobjs, (cnt_all->curobjs != 1) ? "s" : "",
-		    leak_ngctx, (leak_ngctx != 1) ? "s" : "");
+		double sample_period = (double)((uint64_t)1 << lg_prof_sample);
+		double ratio = (((double)cnt_all->curbytes) /
+		    (double)cnt_all->curobjs) / sample_period;
+		double scale_factor = 1.0 / (1.0 - exp(-ratio));
+		uint64_t curbytes = (uint64_t)round(((double)cnt_all->curbytes)
+		    * scale_factor);
+		uint64_t curobjs = (uint64_t)round(((double)cnt_all->curobjs) *
+		    scale_factor);
+
+		malloc_printf("<jemalloc>: Leak approximation summary: ~%"FMTu64
+		    " byte%s, ~%"FMTu64" object%s, >= %zu context%s\n",
+		    curbytes, (curbytes != 1) ? "s" : "", curobjs, (curobjs !=
+		    1) ? "s" : "", leak_ngctx, (leak_ngctx != 1) ? "s" : "");
 		malloc_printf(
 		    "<jemalloc>: Run jeprof on \"%s\" for leak detail\n",
 		    filename);
 	}
+#endif
 }
 
+struct prof_gctx_dump_iter_arg_s {
+	tsdn_t	*tsdn;
+	bool	propagate_err;
+};
+
 static prof_gctx_t *
-prof_gctx_dump_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *arg)
+prof_gctx_dump_iter(prof_gctx_tree_t *gctxs, prof_gctx_t *gctx, void *opaque)
 {
 	prof_gctx_t *ret;
-	bool propagate_err = *(bool *)arg;
+	struct prof_gctx_dump_iter_arg_s *arg =
+	    (struct prof_gctx_dump_iter_arg_s *)opaque;
 
-	malloc_mutex_lock(gctx->lock);
+	malloc_mutex_lock(arg->tsdn, gctx->lock);
 
-	if (prof_dump_gctx(propagate_err, gctx, &gctx->bt, gctxs)) {
+	if (prof_dump_gctx(arg->tsdn, arg->propagate_err, gctx, &gctx->bt,
+	    gctxs)) {
 		ret = gctx;
 		goto label_return;
 	}
 
 	ret = NULL;
 label_return:
-	malloc_mutex_unlock(gctx->lock);
+	malloc_mutex_unlock(arg->tsdn, gctx->lock);
 	return (ret);
 }
 
 static bool
 prof_dump(tsd_t *tsd, bool propagate_err, const char *filename, bool leakcheck)
 {
 	prof_tdata_t *tdata;
-	prof_cnt_t cnt_all;
+	struct prof_tdata_merge_iter_arg_s prof_tdata_merge_iter_arg;
 	size_t tabind;
 	union {
 		prof_gctx_t	*p;
 		void		*v;
 	} gctx;
-	size_t leak_ngctx;
+	struct prof_gctx_merge_iter_arg_s prof_gctx_merge_iter_arg;
+	struct prof_gctx_dump_iter_arg_s prof_gctx_dump_iter_arg;
 	prof_gctx_tree_t gctxs;
 
 	cassert(config_prof);
 
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL)
 		return (true);
 
-	malloc_mutex_lock(&prof_dump_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &prof_dump_mtx);
 	prof_enter(tsd, tdata);
 
 	/*
 	 * Put gctx's in limbo and clear their counters in preparation for
 	 * summing.
 	 */
 	gctx_tree_new(&gctxs);
 	for (tabind = 0; !ckh_iter(&bt2gctx, &tabind, NULL, &gctx.v);)
-		prof_dump_gctx_prep(gctx.p, &gctxs);
+		prof_dump_gctx_prep(tsd_tsdn(tsd), gctx.p, &gctxs);
 
 	/*
 	 * Iterate over tdatas, and for the non-expired ones snapshot their tctx
 	 * stats and merge them into the associated gctx's.
 	 */
-	memset(&cnt_all, 0, sizeof(prof_cnt_t));
-	malloc_mutex_lock(&tdatas_mtx);
-	tdata_tree_iter(&tdatas, NULL, prof_tdata_merge_iter, (void *)&cnt_all);
-	malloc_mutex_unlock(&tdatas_mtx);
+	prof_tdata_merge_iter_arg.tsdn = tsd_tsdn(tsd);
+	memset(&prof_tdata_merge_iter_arg.cnt_all, 0, sizeof(prof_cnt_t));
+	malloc_mutex_lock(tsd_tsdn(tsd), &tdatas_mtx);
+	tdata_tree_iter(&tdatas, NULL, prof_tdata_merge_iter,
+	    (void *)&prof_tdata_merge_iter_arg);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
 
 	/* Merge tctx stats into gctx's. */
-	leak_ngctx = 0;
-	gctx_tree_iter(&gctxs, NULL, prof_gctx_merge_iter, (void *)&leak_ngctx);
+	prof_gctx_merge_iter_arg.tsdn = tsd_tsdn(tsd);
+	prof_gctx_merge_iter_arg.leak_ngctx = 0;
+	gctx_tree_iter(&gctxs, NULL, prof_gctx_merge_iter,
+	    (void *)&prof_gctx_merge_iter_arg);
 
 	prof_leave(tsd, tdata);
 
 	/* Create dump file. */
 	if ((prof_dump_fd = prof_dump_open(propagate_err, filename)) == -1)
 		goto label_open_close_error;
 
 	/* Dump profile header. */
-	if (prof_dump_header(propagate_err, &cnt_all))
+	if (prof_dump_header(tsd_tsdn(tsd), propagate_err,
+	    &prof_tdata_merge_iter_arg.cnt_all))
 		goto label_write_error;
 
 	/* Dump per gctx profile stats. */
+	prof_gctx_dump_iter_arg.tsdn = tsd_tsdn(tsd);
+	prof_gctx_dump_iter_arg.propagate_err = propagate_err;
 	if (gctx_tree_iter(&gctxs, NULL, prof_gctx_dump_iter,
-	    (void *)&propagate_err) != NULL)
+	    (void *)&prof_gctx_dump_iter_arg) != NULL)
 		goto label_write_error;
 
 	/* Dump /proc/<pid>/maps if possible. */
 	if (prof_dump_maps(propagate_err))
 		goto label_write_error;
 
 	if (prof_dump_close(propagate_err))
 		goto label_open_close_error;
 
 	prof_gctx_finish(tsd, &gctxs);
-	malloc_mutex_unlock(&prof_dump_mtx);
-
-	if (leakcheck)
-		prof_leakcheck(&cnt_all, leak_ngctx, filename);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_mtx);
 
+	if (leakcheck) {
+		prof_leakcheck(&prof_tdata_merge_iter_arg.cnt_all,
+		    prof_gctx_merge_iter_arg.leak_ngctx, filename);
+	}
 	return (false);
 label_write_error:
 	prof_dump_close(propagate_err);
 label_open_close_error:
 	prof_gctx_finish(tsd, &gctxs);
-	malloc_mutex_unlock(&prof_dump_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_mtx);
 	return (true);
 }
 
 #define	DUMP_FILENAME_BUFSIZE	(PATH_MAX + 1)
 #define	VSEQ_INVALID		UINT64_C(0xffffffffffffffff)
 static void
@@ -1551,18 +1639,18 @@
 	cassert(config_prof);
 
 	if (vseq != VSEQ_INVALID) {
 	        /* "<prefix>.<pid>.<seq>.v<vseq>.heap" */
 		malloc_snprintf(filename, DUMP_FILENAME_BUFSIZE,
 		    "%s.%d.%"FMTu64".%c%"FMTu64".heap",
-		    opt_prof_prefix, (int)getpid(), prof_dump_seq, v, vseq);
+		    opt_prof_prefix, prof_getpid(), prof_dump_seq, v, vseq);
 	} else {
 	        /* "<prefix>.<pid>.<seq>.<v>.heap" */
 		malloc_snprintf(filename, DUMP_FILENAME_BUFSIZE,
 		    "%s.%d.%"FMTu64".%c.heap",
-		    opt_prof_prefix, (int)getpid(), prof_dump_seq, v);
+		    opt_prof_prefix, prof_getpid(), prof_dump_seq, v);
 	}
 	prof_dump_seq++;
 }
 
 static void
 prof_fdump(void)
@@ -1575,97 +1663,95 @@
 	assert(opt_prof_prefix[0] != '\0');
 
 	if (!prof_booted)
 		return;
 	tsd = tsd_fetch();
 
-	malloc_mutex_lock(&prof_dump_seq_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 	prof_dump_filename(filename, 'f', VSEQ_INVALID);
-	malloc_mutex_unlock(&prof_dump_seq_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 	prof_dump(tsd, false, filename, opt_prof_leak);
 }
 
 void
-prof_idump(void)
+prof_idump(tsdn_t *tsdn)
 {
 	tsd_t *tsd;
 	prof_tdata_t *tdata;
 
 	cassert(config_prof);
 
-	if (!prof_booted)
+	if (!prof_booted || tsdn_null(tsdn))
 		return;
-	tsd = tsd_fetch();
+	tsd = tsdn_tsd(tsdn);
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL)
 		return;
 	if (tdata->enq) {
 		tdata->enq_idump = true;
 		return;
 	}
 
 	if (opt_prof_prefix[0] != '\0') {
 		char filename[PATH_MAX + 1];
-		malloc_mutex_lock(&prof_dump_seq_mtx);
+		malloc_mutex_lock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 		prof_dump_filename(filename, 'i', prof_dump_iseq);
 		prof_dump_iseq++;
-		malloc_mutex_unlock(&prof_dump_seq_mtx);
+		malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 		prof_dump(tsd, false, filename, false);
 	}
 }
 
 bool
-prof_mdump(const char *filename)
+prof_mdump(tsd_t *tsd, const char *filename)
 {
-	tsd_t *tsd;
 	char filename_buf[DUMP_FILENAME_BUFSIZE];
 
 	cassert(config_prof);
 
 	if (!opt_prof || !prof_booted)
 		return (true);
-	tsd = tsd_fetch();
 
 	if (filename == NULL) {
 		/* No filename specified, so automatically generate one. */
 		if (opt_prof_prefix[0] == '\0')
 			return (true);
-		malloc_mutex_lock(&prof_dump_seq_mtx);
+		malloc_mutex_lock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 		prof_dump_filename(filename_buf, 'm', prof_dump_mseq);
 		prof_dump_mseq++;
-		malloc_mutex_unlock(&prof_dump_seq_mtx);
+		malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_seq_mtx);
 		filename = filename_buf;
 	}
 	return (prof_dump(tsd, true, filename, false));
 }
 
 void
-prof_gdump(void)
+prof_gdump(tsdn_t *tsdn)
 {
 	tsd_t *tsd;
 	prof_tdata_t *tdata;
 
 	cassert(config_prof);
 
-	if (!prof_booted)
+	if (!prof_booted || tsdn_null(tsdn))
 		return;
-	tsd = tsd_fetch();
+	tsd = tsdn_tsd(tsdn);
 	tdata = prof_tdata_get(tsd, false);
 	if (tdata == NULL)
 		return;
 	if (tdata->enq) {
 		tdata->enq_gdump = true;
 		return;
 	}
 
 	if (opt_prof_prefix[0] != '\0') {
 		char filename[DUMP_FILENAME_BUFSIZE];
-		malloc_mutex_lock(&prof_dump_seq_mtx);
+		malloc_mutex_lock(tsdn, &prof_dump_seq_mtx);
 		prof_dump_filename(filename, 'u', prof_dump_useq);
 		prof_dump_useq++;
-		malloc_mutex_unlock(&prof_dump_seq_mtx);
+		malloc_mutex_unlock(tsdn, &prof_dump_seq_mtx);
 		prof_dump(tsd, false, filename, false);
 	}
 }
 
 static void
 prof_bt_hash(const void *key, size_t r_hash[2])
@@ -1688,51 +1774,50 @@
 	if (bt1->len != bt2->len)
 		return (false);
 	return (memcmp(bt1->vec, bt2->vec, bt1->len * sizeof(void *)) == 0);
 }
 
 JEMALLOC_INLINE_C uint64_t
-prof_thr_uid_alloc(void)
+prof_thr_uid_alloc(tsdn_t *tsdn)
 {
 	uint64_t thr_uid;
 
-	malloc_mutex_lock(&next_thr_uid_mtx);
+	malloc_mutex_lock(tsdn, &next_thr_uid_mtx);
 	thr_uid = next_thr_uid;
 	next_thr_uid++;
-	malloc_mutex_unlock(&next_thr_uid_mtx);
+	malloc_mutex_unlock(tsdn, &next_thr_uid_mtx);
 
 	return (thr_uid);
 }
 
 static prof_tdata_t *
 prof_tdata_init_impl(tsd_t *tsd, uint64_t thr_uid, uint64_t thr_discrim,
     char *thread_name, bool active)
 {
 	prof_tdata_t *tdata;
-	tcache_t *tcache;
 
 	cassert(config_prof);
 
 	/* Initialize an empty cache for this thread. */
-	tcache = tcache_get(tsd, true);
-	tdata = (prof_tdata_t *)iallocztm(tsd, sizeof(prof_tdata_t), false,
-	    tcache, true, NULL);
+	tdata = (prof_tdata_t *)iallocztm(tsd_tsdn(tsd), sizeof(prof_tdata_t),
+	    size2index(sizeof(prof_tdata_t)), false, NULL, true,
+	    arena_get(TSDN_NULL, 0, true), true);
 	if (tdata == NULL)
 		return (NULL);
 
 	tdata->lock = prof_tdata_mutex_choose(thr_uid);
 	tdata->thr_uid = thr_uid;
 	tdata->thr_discrim = thr_discrim;
 	tdata->thread_name = thread_name;
 	tdata->attached = true;
 	tdata->expired = false;
 	tdata->tctx_uid_next = 0;
 
-	if (ckh_new(tsd, &tdata->bt2tctx, PROF_CKH_MINITEMS,
-	    prof_bt_hash, prof_bt_keycomp)) {
-		idalloctm(tsd, tdata, tcache, true);
+	if (ckh_new(tsd, &tdata->bt2tctx, PROF_CKH_MINITEMS, prof_bt_hash,
+	    prof_bt_keycomp)) {
+		idalloctm(tsd_tsdn(tsd), tdata, NULL, true, true);
 		return (NULL);
 	}
 
 	tdata->prng_state = (uint64_t)(uintptr_t)tdata;
 	prof_sample_threshold_update(tdata);
 
@@ -1740,152 +1825,161 @@
 	tdata->enq_idump = false;
 	tdata->enq_gdump = false;
 
 	tdata->dumping = false;
 	tdata->active = active;
 
-	malloc_mutex_lock(&tdatas_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &tdatas_mtx);
 	tdata_tree_insert(&tdatas, tdata);
-	malloc_mutex_unlock(&tdatas_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
 
 	return (tdata);
 }
 
 prof_tdata_t *
 prof_tdata_init(tsd_t *tsd)
 {
 
-	return (prof_tdata_init_impl(tsd, prof_thr_uid_alloc(), 0, NULL,
-	    prof_thread_active_init_get()));
+	return (prof_tdata_init_impl(tsd, prof_thr_uid_alloc(tsd_tsdn(tsd)), 0,
+	    NULL, prof_thread_active_init_get(tsd_tsdn(tsd))));
 }
 
-/* tdata->lock must be held. */
 static bool
-prof_tdata_should_destroy(prof_tdata_t *tdata, bool even_if_attached)
+prof_tdata_should_destroy_unlocked(prof_tdata_t *tdata, bool even_if_attached)
 {
 
 	if (tdata->attached && !even_if_attached)
 		return (false);
 	if (ckh_count(&tdata->bt2tctx) != 0)
 		return (false);
 	return (true);
 }
 
-/* tdatas_mtx must be held. */
+static bool
+prof_tdata_should_destroy(tsdn_t *tsdn, prof_tdata_t *tdata,
+    bool even_if_attached)
+{
+
+	malloc_mutex_assert_owner(tsdn, tdata->lock);
+
+	return (prof_tdata_should_destroy_unlocked(tdata, even_if_attached));
+}
+
 static void
 prof_tdata_destroy_locked(tsd_t *tsd, prof_tdata_t *tdata,
     bool even_if_attached)
 {
-	tcache_t *tcache;
 
-	assert(prof_tdata_should_destroy(tdata, even_if_attached));
-	assert(tsd_prof_tdata_get(tsd) != tdata);
+	malloc_mutex_assert_owner(tsd_tsdn(tsd), &tdatas_mtx);
 
 	tdata_tree_remove(&tdatas, tdata);
 
-	tcache = tcache_get(tsd, false);
+	assert(prof_tdata_should_destroy_unlocked(tdata, even_if_attached));
+
 	if (tdata->thread_name != NULL)
-		idalloctm(tsd, tdata->thread_name, tcache, true);
+		idalloctm(tsd_tsdn(tsd), tdata->thread_name, NULL, true, true);
 	ckh_delete(tsd, &tdata->bt2tctx);
-	idalloctm(tsd, tdata, tcache, true);
+	idalloctm(tsd_tsdn(tsd), tdata, NULL, true, true);
 }
 
 static void
 prof_tdata_destroy(tsd_t *tsd, prof_tdata_t *tdata, bool even_if_attached)
 {
 
-	malloc_mutex_lock(&tdatas_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &tdatas_mtx);
 	prof_tdata_destroy_locked(tsd, tdata, even_if_attached);
-	malloc_mutex_unlock(&tdatas_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
 }
 
 static void
 prof_tdata_detach(tsd_t *tsd, prof_tdata_t *tdata)
 {
 	bool destroy_tdata;
 
-	malloc_mutex_lock(tdata->lock);
+	malloc_mutex_lock(tsd_tsdn(tsd), tdata->lock);
 	if (tdata->attached) {
-		destroy_tdata = prof_tdata_should_destroy(tdata, true);
+		destroy_tdata = prof_tdata_should_destroy(tsd_tsdn(tsd), tdata,
+		    true);
 		/*
 		 * Only detach if !destroy_tdata, because detaching would allow
 		 * another thread to win the race to destroy tdata.
 		 */
 		if (!destroy_tdata)
 			tdata->attached = false;
 		tsd_prof_tdata_set(tsd, NULL);
 	} else
 		destroy_tdata = false;
-	malloc_mutex_unlock(tdata->lock);
+	malloc_mutex_unlock(tsd_tsdn(tsd), tdata->lock);
 	if (destroy_tdata)
 		prof_tdata_destroy(tsd, tdata, true);
 }
 
 prof_tdata_t *
 prof_tdata_reinit(tsd_t *tsd, prof_tdata_t *tdata)
 {
 	uint64_t thr_uid = tdata->thr_uid;
 	uint64_t thr_discrim = tdata->thr_discrim + 1;
 	char *thread_name = (tdata->thread_name != NULL) ?
-	    prof_thread_name_alloc(tsd, tdata->thread_name) : NULL;
+	    prof_thread_name_alloc(tsd_tsdn(tsd), tdata->thread_name) : NULL;
 	bool active = tdata->active;
 
 	prof_tdata_detach(tsd, tdata);
 	return (prof_tdata_init_impl(tsd, thr_uid, thr_discrim, thread_name,
 	    active));
 }
 
 static bool
-prof_tdata_expire(prof_tdata_t *tdata)
+prof_tdata_expire(tsdn_t *tsdn, prof_tdata_t *tdata)
 {
 	bool destroy_tdata;
 
-	malloc_mutex_lock(tdata->lock);
+	malloc_mutex_lock(tsdn, tdata->lock);
 	if (!tdata->expired) {
 		tdata->expired = true;
 		destroy_tdata = tdata->attached ? false :
-		    prof_tdata_should_destroy(tdata, false);
+		    prof_tdata_should_destroy(tsdn, tdata, false);
 	} else
 		destroy_tdata = false;
-	malloc_mutex_unlock(tdata->lock);
+	malloc_mutex_unlock(tsdn, tdata->lock);
 
 	return (destroy_tdata);
 }
 
 static prof_tdata_t *
 prof_tdata_reset_iter(prof_tdata_tree_t *tdatas, prof_tdata_t *tdata, void *arg)
 {
+	tsdn_t *tsdn = (tsdn_t *)arg;
 
-	return (prof_tdata_expire(tdata) ? tdata : NULL);
+	return (prof_tdata_expire(tsdn, tdata) ? tdata : NULL);
 }
 
 void
 prof_reset(tsd_t *tsd, size_t lg_sample)
 {
 	prof_tdata_t *next;
 
 	assert(lg_sample < (sizeof(uint64_t) << 3));
 
-	malloc_mutex_lock(&prof_dump_mtx);
-	malloc_mutex_lock(&tdatas_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &prof_dump_mtx);
+	malloc_mutex_lock(tsd_tsdn(tsd), &tdatas_mtx);
 
 	lg_prof_sample = lg_sample;
 
 	next = NULL;
 	do {
 		prof_tdata_t *to_destroy = tdata_tree_iter(&tdatas, next,
-		    prof_tdata_reset_iter, NULL);
+		    prof_tdata_reset_iter, (void *)tsd);
 		if (to_destroy != NULL) {
 			next = tdata_tree_next(&tdatas, to_destroy);
 			prof_tdata_destroy_locked(tsd, to_destroy, false);
 		} else
 			next = NULL;
 	} while (next != NULL);
 
-	malloc_mutex_unlock(&tdatas_mtx);
-	malloc_mutex_unlock(&prof_dump_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &tdatas_mtx);
+	malloc_mutex_unlock(tsd_tsdn(tsd), &prof_dump_mtx);
 }
 
 void
 prof_tdata_cleanup(tsd_t *tsd)
 {
 	prof_tdata_t *tdata;
@@ -1896,61 +1990,60 @@
 	tdata = tsd_prof_tdata_get(tsd);
 	if (tdata != NULL)
 		prof_tdata_detach(tsd, tdata);
 }
 
 bool
-prof_active_get(void)
+prof_active_get(tsdn_t *tsdn)
 {
 	bool prof_active_current;
 
-	malloc_mutex_lock(&prof_active_mtx);
+	malloc_mutex_lock(tsdn, &prof_active_mtx);
 	prof_active_current = prof_active;
-	malloc_mutex_unlock(&prof_active_mtx);
+	malloc_mutex_unlock(tsdn, &prof_active_mtx);
 	return (prof_active_current);
 }
 
 bool
-prof_active_set(bool active)
+prof_active_set(tsdn_t *tsdn, bool active)
 {
 	bool prof_active_old;
 
-	malloc_mutex_lock(&prof_active_mtx);
+	malloc_mutex_lock(tsdn, &prof_active_mtx);
 	prof_active_old = prof_active;
 	prof_active = active;
-	malloc_mutex_unlock(&prof_active_mtx);
+	malloc_mutex_unlock(tsdn, &prof_active_mtx);
 	return (prof_active_old);
 }
 
 const char *
-prof_thread_name_get(void)
+prof_thread_name_get(tsd_t *tsd)
 {
-	tsd_t *tsd;
 	prof_tdata_t *tdata;
 
-	tsd = tsd_fetch();
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL)
 		return ("");
 	return (tdata->thread_name != NULL ? tdata->thread_name : "");
 }
 
 static char *
-prof_thread_name_alloc(tsd_t *tsd, const char *thread_name)
+prof_thread_name_alloc(tsdn_t *tsdn, const char *thread_name)
 {
 	char *ret;
 	size_t size;
 
 	if (thread_name == NULL)
 		return (NULL);
 
 	size = strlen(thread_name) + 1;
 	if (size == 1)
 		return ("");
 
-	ret = iallocztm(tsd, size, false, tcache_get(tsd, true), true, NULL);
+	ret = iallocztm(tsdn, size, size2index(size), false, NULL, true,
+	    arena_get(TSDN_NULL, 0, true), true);
 	if (ret == NULL)
 		return (NULL);
 	memcpy(ret, thread_name, size);
 	return (ret);
 }
 
@@ -1971,96 +2064,91 @@
 	for (i = 0; thread_name[i] != '\0'; i++) {
 		char c = thread_name[i];
 		if (!isgraph(c) && !isblank(c))
 			return (EFAULT);
 	}
 
-	s = prof_thread_name_alloc(tsd, thread_name);
+	s = prof_thread_name_alloc(tsd_tsdn(tsd), thread_name);
 	if (s == NULL)
 		return (EAGAIN);
 
 	if (tdata->thread_name != NULL) {
-		idalloctm(tsd, tdata->thread_name, tcache_get(tsd, false),
-		    true);
+		idalloctm(tsd_tsdn(tsd), tdata->thread_name, NULL, true, true);
 		tdata->thread_name = NULL;
 	}
 	if (strlen(s) > 0)
 		tdata->thread_name = s;
 	return (0);
 }
 
 bool
-prof_thread_active_get(void)
+prof_thread_active_get(tsd_t *tsd)
 {
-	tsd_t *tsd;
 	prof_tdata_t *tdata;
 
-	tsd = tsd_fetch();
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL)
 		return (false);
 	return (tdata->active);
 }
 
 bool
-prof_thread_active_set(bool active)
+prof_thread_active_set(tsd_t *tsd, bool active)
 {
-	tsd_t *tsd;
 	prof_tdata_t *tdata;
 
-	tsd = tsd_fetch();
 	tdata = prof_tdata_get(tsd, true);
 	if (tdata == NULL)
 		return (true);
 	tdata->active = active;
 	return (false);
 }
 
 bool
-prof_thread_active_init_get(void)
+prof_thread_active_init_get(tsdn_t *tsdn)
 {
 	bool active_init;
 
-	malloc_mutex_lock(&prof_thread_active_init_mtx);
+	malloc_mutex_lock(tsdn, &prof_thread_active_init_mtx);
 	active_init = prof_thread_active_init;
-	malloc_mutex_unlock(&prof_thread_active_init_mtx);
+	malloc_mutex_unlock(tsdn, &prof_thread_active_init_mtx);
 	return (active_init);
 }
 
 bool
-prof_thread_active_init_set(bool active_init)
+prof_thread_active_init_set(tsdn_t *tsdn, bool active_init)
 {
 	bool active_init_old;
 
-	malloc_mutex_lock(&prof_thread_active_init_mtx);
+	malloc_mutex_lock(tsdn, &prof_thread_active_init_mtx);
 	active_init_old = prof_thread_active_init;
 	prof_thread_active_init = active_init;
-	malloc_mutex_unlock(&prof_thread_active_init_mtx);
+	malloc_mutex_unlock(tsdn, &prof_thread_active_init_mtx);
 	return (active_init_old);
 }
 
 bool
-prof_gdump_get(void)
+prof_gdump_get(tsdn_t *tsdn)
 {
 	bool prof_gdump_current;
 
-	malloc_mutex_lock(&prof_gdump_mtx);
+	malloc_mutex_lock(tsdn, &prof_gdump_mtx);
 	prof_gdump_current = prof_gdump_val;
-	malloc_mutex_unlock(&prof_gdump_mtx);
+	malloc_mutex_unlock(tsdn, &prof_gdump_mtx);
 	return (prof_gdump_current);
 }
 
 bool
-prof_gdump_set(bool gdump)
+prof_gdump_set(tsdn_t *tsdn, bool gdump)
 {
 	bool prof_gdump_old;
 
-	malloc_mutex_lock(&prof_gdump_mtx);
+	malloc_mutex_lock(tsdn, &prof_gdump_mtx);
 	prof_gdump_old = prof_gdump_val;
 	prof_gdump_val = gdump;
-	malloc_mutex_unlock(&prof_gdump_mtx);
+	malloc_mutex_unlock(tsdn, &prof_gdump_mtx);
 	return (prof_gdump_old);
 }
 
 void
 prof_boot0(void)
 {
@@ -2095,77 +2183,86 @@
 			    opt_lg_prof_interval);
 		}
 	}
 }
 
 bool
-prof_boot2(void)
+prof_boot2(tsd_t *tsd)
 {
 
 	cassert(config_prof);
 
 	if (opt_prof) {
-		tsd_t *tsd;
 		unsigned i;
 
 		lg_prof_sample = opt_lg_prof_sample;
 
 		prof_active = opt_prof_active;
-		if (malloc_mutex_init(&prof_active_mtx))
+		if (malloc_mutex_init(&prof_active_mtx, "prof_active",
+		    WITNESS_RANK_PROF_ACTIVE))
 			return (true);
 
 		prof_gdump_val = opt_prof_gdump;
-		if (malloc_mutex_init(&prof_gdump_mtx))
+		if (malloc_mutex_init(&prof_gdump_mtx, "prof_gdump",
+		    WITNESS_RANK_PROF_GDUMP))
 			return (true);
 
 		prof_thread_active_init = opt_prof_thread_active_init;
-		if (malloc_mutex_init(&prof_thread_active_init_mtx))
+		if (malloc_mutex_init(&prof_thread_active_init_mtx,
+		    "prof_thread_active_init",
+		    WITNESS_RANK_PROF_THREAD_ACTIVE_INIT))
 			return (true);
 
-		tsd = tsd_fetch();
 		if (ckh_new(tsd, &bt2gctx, PROF_CKH_MINITEMS, prof_bt_hash,
 		    prof_bt_keycomp))
 			return (true);
-		if (malloc_mutex_init(&bt2gctx_mtx))
+		if (malloc_mutex_init(&bt2gctx_mtx, "prof_bt2gctx",
+		    WITNESS_RANK_PROF_BT2GCTX))
 			return (true);
 
 		tdata_tree_new(&tdatas);
-		if (malloc_mutex_init(&tdatas_mtx))
+		if (malloc_mutex_init(&tdatas_mtx, "prof_tdatas",
+		    WITNESS_RANK_PROF_TDATAS))
 			return (true);
 
 		next_thr_uid = 0;
-		if (malloc_mutex_init(&next_thr_uid_mtx))
+		if (malloc_mutex_init(&next_thr_uid_mtx, "prof_next_thr_uid",
+		    WITNESS_RANK_PROF_NEXT_THR_UID))
 			return (true);
 
-		if (malloc_mutex_init(&prof_dump_seq_mtx))
+		if (malloc_mutex_init(&prof_dump_seq_mtx, "prof_dump_seq",
+		    WITNESS_RANK_PROF_DUMP_SEQ))
 			return (true);
-		if (malloc_mutex_init(&prof_dump_mtx))
+		if (malloc_mutex_init(&prof_dump_mtx, "prof_dump",
+		    WITNESS_RANK_PROF_DUMP))
 			return (true);
 
 		if (opt_prof_final && opt_prof_prefix[0] != '\0' &&
 		    atexit(prof_fdump) != 0) {
 			malloc_write("<jemalloc>: Error in atexit()\n");
 			if (opt_abort)
 				abort();
 		}
 
-		gctx_locks = (malloc_mutex_t *)base_alloc(PROF_NCTX_LOCKS *
-		    sizeof(malloc_mutex_t));
+		gctx_locks = (malloc_mutex_t *)base_alloc(tsd_tsdn(tsd),
+		    PROF_NCTX_LOCKS * sizeof(malloc_mutex_t));
 		if (gctx_locks == NULL)
 			return (true);
 		for (i = 0; i < PROF_NCTX_LOCKS; i++) {
-			if (malloc_mutex_init(&gctx_locks[i]))
+			if (malloc_mutex_init(&gctx_locks[i], "prof_gctx",
+			    WITNESS_RANK_PROF_GCTX))
 				return (true);
 		}
 
-		tdata_locks = (malloc_mutex_t *)base_alloc(PROF_NTDATA_LOCKS *
-		    sizeof(malloc_mutex_t));
+		tdata_locks = (malloc_mutex_t *)base_alloc(tsd_tsdn(tsd),
+		    PROF_NTDATA_LOCKS * sizeof(malloc_mutex_t));
 		if (tdata_locks == NULL)
 			return (true);
 		for (i = 0; i < PROF_NTDATA_LOCKS; i++) {
-			if (malloc_mutex_init(&tdata_locks[i]))
+			if (malloc_mutex_init(&tdata_locks[i], "prof_tdata",
+			    WITNESS_RANK_PROF_TDATA))
 				return (true);
 		}
 	}
 
 #ifdef JEMALLOC_PROF_LIBGCC
 	/*
@@ -2178,60 +2275,81 @@
 	prof_booted = true;
 
 	return (false);
 }
 
 void
-prof_prefork(void)
+prof_prefork0(tsdn_t *tsdn)
 {
 
 	if (opt_prof) {
 		unsigned i;
 
-		malloc_mutex_prefork(&tdatas_mtx);
-		malloc_mutex_prefork(&bt2gctx_mtx);
-		malloc_mutex_prefork(&next_thr_uid_mtx);
-		malloc_mutex_prefork(&prof_dump_seq_mtx);
-		for (i = 0; i < PROF_NCTX_LOCKS; i++)
-			malloc_mutex_prefork(&gctx_locks[i]);
+		malloc_mutex_prefork(tsdn, &prof_dump_mtx);
+		malloc_mutex_prefork(tsdn, &bt2gctx_mtx);
+		malloc_mutex_prefork(tsdn, &tdatas_mtx);
 		for (i = 0; i < PROF_NTDATA_LOCKS; i++)
-			malloc_mutex_prefork(&tdata_locks[i]);
+			malloc_mutex_prefork(tsdn, &tdata_locks[i]);
+		for (i = 0; i < PROF_NCTX_LOCKS; i++)
+			malloc_mutex_prefork(tsdn, &gctx_locks[i]);
 	}
 }
 
 void
-prof_postfork_parent(void)
+prof_prefork1(tsdn_t *tsdn)
+{
+
+	if (opt_prof) {
+		malloc_mutex_prefork(tsdn, &prof_active_mtx);
+		malloc_mutex_prefork(tsdn, &prof_dump_seq_mtx);
+		malloc_mutex_prefork(tsdn, &prof_gdump_mtx);
+		malloc_mutex_prefork(tsdn, &next_thr_uid_mtx);
+		malloc_mutex_prefork(tsdn, &prof_thread_active_init_mtx);
+	}
+}
+
+void
+prof_postfork_parent(tsdn_t *tsdn)
 {
 
 	if (opt_prof) {
 		unsigned i;
 
-		for (i = 0; i < PROF_NTDATA_LOCKS; i++)
-			malloc_mutex_postfork_parent(&tdata_locks[i]);
+		malloc_mutex_postfork_parent(tsdn,
+		    &prof_thread_active_init_mtx);
+		malloc_mutex_postfork_parent(tsdn, &next_thr_uid_mtx);
+		malloc_mutex_postfork_parent(tsdn, &prof_gdump_mtx);
+		malloc_mutex_postfork_parent(tsdn, &prof_dump_seq_mtx);
+		malloc_mutex_postfork_parent(tsdn, &prof_active_mtx);
 		for (i = 0; i < PROF_NCTX_LOCKS; i++)
-			malloc_mutex_postfork_parent(&gctx_locks[i]);
-		malloc_mutex_postfork_parent(&prof_dump_seq_mtx);
-		malloc_mutex_postfork_parent(&next_thr_uid_mtx);
-		malloc_mutex_postfork_parent(&bt2gctx_mtx);
-		malloc_mutex_postfork_parent(&tdatas_mtx);
+			malloc_mutex_postfork_parent(tsdn, &gctx_locks[i]);
+		for (i = 0; i < PROF_NTDATA_LOCKS; i++)
+			malloc_mutex_postfork_parent(tsdn, &tdata_locks[i]);
+		malloc_mutex_postfork_parent(tsdn, &tdatas_mtx);
+		malloc_mutex_postfork_parent(tsdn, &bt2gctx_mtx);
+		malloc_mutex_postfork_parent(tsdn, &prof_dump_mtx);
 	}
 }
 
 void
-prof_postfork_child(void)
+prof_postfork_child(tsdn_t *tsdn)
 {
 
 	if (opt_prof) {
 		unsigned i;
 
-		for (i = 0; i < PROF_NTDATA_LOCKS; i++)
-			malloc_mutex_postfork_child(&tdata_locks[i]);
+		malloc_mutex_postfork_child(tsdn, &prof_thread_active_init_mtx);
+		malloc_mutex_postfork_child(tsdn, &next_thr_uid_mtx);
+		malloc_mutex_postfork_child(tsdn, &prof_gdump_mtx);
+		malloc_mutex_postfork_child(tsdn, &prof_dump_seq_mtx);
+		malloc_mutex_postfork_child(tsdn, &prof_active_mtx);
 		for (i = 0; i < PROF_NCTX_LOCKS; i++)
-			malloc_mutex_postfork_child(&gctx_locks[i]);
-		malloc_mutex_postfork_child(&prof_dump_seq_mtx);
-		malloc_mutex_postfork_child(&next_thr_uid_mtx);
-		malloc_mutex_postfork_child(&bt2gctx_mtx);
-		malloc_mutex_postfork_child(&tdatas_mtx);
+			malloc_mutex_postfork_child(tsdn, &gctx_locks[i]);
+		for (i = 0; i < PROF_NTDATA_LOCKS; i++)
+			malloc_mutex_postfork_child(tsdn, &tdata_locks[i]);
+		malloc_mutex_postfork_child(tsdn, &tdatas_mtx);
+		malloc_mutex_postfork_child(tsdn, &bt2gctx_mtx);
+		malloc_mutex_postfork_child(tsdn, &prof_dump_mtx);
 	}
 }
 
 /******************************************************************************/
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.d	2017-09-27 23:00:24.478935941 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.d	2017-09-27 23:02:00.310932429 +0800
@@ -1,18 +1,21 @@
 src/prof.o: src/prof.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.c	2017-01-31 23:32:23.000000000 +0800
@@ -10,28 +10,28 @@
 #define	QUARANTINE_STATE_MAX		QUARANTINE_STATE_PURGATORY
 
 /******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
 static quarantine_t	*quarantine_grow(tsd_t *tsd, quarantine_t *quarantine);
-static void	quarantine_drain_one(tsd_t *tsd, quarantine_t *quarantine);
-static void	quarantine_drain(tsd_t *tsd, quarantine_t *quarantine,
+static void	quarantine_drain_one(tsdn_t *tsdn, quarantine_t *quarantine);
+static void	quarantine_drain(tsdn_t *tsdn, quarantine_t *quarantine,
     size_t upper_bound);
 
 /******************************************************************************/
 
 static quarantine_t *
-quarantine_init(tsd_t *tsd, size_t lg_maxobjs)
+quarantine_init(tsdn_t *tsdn, size_t lg_maxobjs)
 {
 	quarantine_t *quarantine;
+	size_t size;
 
-	assert(tsd_nominal(tsd));
-
-	quarantine = (quarantine_t *)iallocztm(tsd, offsetof(quarantine_t, objs)
-	    + ((ZU(1) << lg_maxobjs) * sizeof(quarantine_obj_t)), false,
-	    tcache_get(tsd, true), true, NULL);
+	size = offsetof(quarantine_t, objs) + ((ZU(1) << lg_maxobjs) *
+	    sizeof(quarantine_obj_t));
+	quarantine = (quarantine_t *)iallocztm(tsdn, size, size2index(size),
+	    false, NULL, true, arena_get(TSDN_NULL, 0, true), true);
 	if (quarantine == NULL)
 		return (NULL);
 	quarantine->curbytes = 0;
 	quarantine->curobjs = 0;
 	quarantine->first = 0;
 	quarantine->lg_maxobjs = lg_maxobjs;
@@ -44,31 +44,31 @@
 {
 	quarantine_t *quarantine;
 
 	if (!tsd_nominal(tsd))
 		return;
 
-	quarantine = quarantine_init(tsd, LG_MAXOBJS_INIT);
+	quarantine = quarantine_init(tsd_tsdn(tsd), LG_MAXOBJS_INIT);
 	/*
 	 * Check again whether quarantine has been initialized, because
 	 * quarantine_init() may have triggered recursive initialization.
 	 */
 	if (tsd_quarantine_get(tsd) == NULL)
 		tsd_quarantine_set(tsd, quarantine);
 	else
-		idalloctm(tsd, quarantine, tcache_get(tsd, false), true);
+		idalloctm(tsd_tsdn(tsd), quarantine, NULL, true, true);
 }
 
 static quarantine_t *
 quarantine_grow(tsd_t *tsd, quarantine_t *quarantine)
 {
 	quarantine_t *ret;
 
-	ret = quarantine_init(tsd, quarantine->lg_maxobjs + 1);
+	ret = quarantine_init(tsd_tsdn(tsd), quarantine->lg_maxobjs + 1);
 	if (ret == NULL) {
-		quarantine_drain_one(tsd, quarantine);
+		quarantine_drain_one(tsd_tsdn(tsd), quarantine);
 		return (quarantine);
 	}
 
 	ret->curbytes = quarantine->curbytes;
 	ret->curobjs = quarantine->curobjs;
 	if (quarantine->first + quarantine->curobjs <= (ZU(1) <<
@@ -84,59 +84,59 @@
 
 		memcpy(ret->objs, &quarantine->objs[quarantine->first], ncopy_a
 		    * sizeof(quarantine_obj_t));
 		memcpy(&ret->objs[ncopy_a], quarantine->objs, ncopy_b *
 		    sizeof(quarantine_obj_t));
 	}
-	idalloctm(tsd, quarantine, tcache_get(tsd, false), true);
+	idalloctm(tsd_tsdn(tsd), quarantine, NULL, true, true);
 
 	tsd_quarantine_set(tsd, ret);
 	return (ret);
 }
 
 static void
-quarantine_drain_one(tsd_t *tsd, quarantine_t *quarantine)
+quarantine_drain_one(tsdn_t *tsdn, quarantine_t *quarantine)
 {
 	quarantine_obj_t *obj = &quarantine->objs[quarantine->first];
-	assert(obj->usize == isalloc(obj->ptr, config_prof));
-	idalloctm(tsd, obj->ptr, NULL, false);
+	assert(obj->usize == isalloc(tsdn, obj->ptr, config_prof));
+	idalloctm(tsdn, obj->ptr, NULL, false, true);
 	quarantine->curbytes -= obj->usize;
 	quarantine->curobjs--;
 	quarantine->first = (quarantine->first + 1) & ((ZU(1) <<
 	    quarantine->lg_maxobjs) - 1);
 }
 
 static void
-quarantine_drain(tsd_t *tsd, quarantine_t *quarantine, size_t upper_bound)
+quarantine_drain(tsdn_t *tsdn, quarantine_t *quarantine, size_t upper_bound)
 {
 
 	while (quarantine->curbytes > upper_bound && quarantine->curobjs > 0)
-		quarantine_drain_one(tsd, quarantine);
+		quarantine_drain_one(tsdn, quarantine);
 }
 
 void
 quarantine(tsd_t *tsd, void *ptr)
 {
 	quarantine_t *quarantine;
-	size_t usize = isalloc(ptr, config_prof);
+	size_t usize = isalloc(tsd_tsdn(tsd), ptr, config_prof);
 
 	cassert(config_fill);
 	assert(opt_quarantine);
 
 	if ((quarantine = tsd_quarantine_get(tsd)) == NULL) {
-		idalloctm(tsd, ptr, NULL, false);
+		idalloctm(tsd_tsdn(tsd), ptr, NULL, false, true);
 		return;
 	}
 	/*
 	 * Drain one or more objects if the quarantine size limit would be
 	 * exceeded by appending ptr.
 	 */
 	if (quarantine->curbytes + usize > opt_quarantine) {
 		size_t upper_bound = (opt_quarantine >= usize) ? opt_quarantine
 		    - usize : 0;
-		quarantine_drain(tsd, quarantine, upper_bound);
+		quarantine_drain(tsd_tsdn(tsd), quarantine, upper_bound);
 	}
 	/* Grow the quarantine ring buffer if it's full. */
 	if (quarantine->curobjs == (ZU(1) << quarantine->lg_maxobjs))
 		quarantine = quarantine_grow(tsd, quarantine);
 	/* quarantine_grow() must free a slot if it fails to grow. */
 	assert(quarantine->curobjs < (ZU(1) << quarantine->lg_maxobjs));
@@ -155,17 +155,17 @@
 			 * operation.
 			 */
 			if ((!config_valgrind || likely(!in_valgrind))
 			    && usize <= SMALL_MAXCLASS)
 				arena_quarantine_junk_small(ptr, usize);
 			else
-				memset(ptr, 0x5a, usize);
+				memset(ptr, JEMALLOC_FREE_JUNK, usize);
 		}
 	} else {
 		assert(quarantine->curbytes == 0);
-		idalloctm(tsd, ptr, NULL, false);
+		idalloctm(tsd_tsdn(tsd), ptr, NULL, false, true);
 	}
 }
 
 void
 quarantine_cleanup(tsd_t *tsd)
 {
@@ -173,11 +173,11 @@
 
 	if (!config_fill)
 		return;
 
 	quarantine = tsd_quarantine_get(tsd);
 	if (quarantine != NULL) {
-		quarantine_drain(tsd, quarantine, 0);
-		idalloctm(tsd, quarantine, tcache_get(tsd, false), true);
+		quarantine_drain(tsd_tsdn(tsd), quarantine, 0);
+		idalloctm(tsd_tsdn(tsd), quarantine, NULL, true, true);
 		tsd_quarantine_set(tsd, NULL);
 	}
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.d	2017-09-27 23:00:24.730935932 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.d	2017-09-27 23:02:00.522932421 +0800
@@ -1,19 +1,22 @@
 src/quarantine.o: src/quarantine.c \
  include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.c	2017-01-31 23:32:23.000000000 +0800
@@ -12,12 +12,14 @@
 bool
 rtree_new(rtree_t *rtree, unsigned bits, rtree_node_alloc_t *alloc,
     rtree_node_dalloc_t *dalloc)
 {
 	unsigned bits_in_leaf, height, i;
 
+	assert(RTREE_HEIGHT_MAX == ((ZU(1) << (LG_SIZEOF_PTR+3)) /
+	    RTREE_BITS_PER_LEVEL));
 	assert(bits > 0 && bits <= (sizeof(uintptr_t) << 3));
 
 	bits_in_leaf = (bits % RTREE_BITS_PER_LEVEL) == 0 ? RTREE_BITS_PER_LEVEL
 	    : (bits % RTREE_BITS_PER_LEVEL);
 	if (bits > bits_in_leaf) {
 		height = 1 + (bits - bits_in_leaf) / RTREE_BITS_PER_LEVEL;
@@ -91,18 +93,21 @@
 static rtree_node_elm_t *
 rtree_node_init(rtree_t *rtree, unsigned level, rtree_node_elm_t **elmp)
 {
 	rtree_node_elm_t *node;
 
 	if (atomic_cas_p((void **)elmp, NULL, RTREE_NODE_INITIALIZING)) {
+		spin_t spinner;
+
 		/*
 		 * Another thread is already in the process of initializing.
 		 * Spin-wait until initialization is complete.
 		 */
+		spin_init(&spinner);
 		do {
-			CPU_SPINWAIT;
+			spin_adaptive(&spinner);
 			node = atomic_read_p((void **)elmp);
 		} while (node == RTREE_NODE_INITIALIZING);
 	} else {
 		node = rtree->alloc(ZU(1) << rtree->levels[level].bits);
 		if (node == NULL)
 			return (NULL);
@@ -120,8 +125,8 @@
 }
 
 rtree_node_elm_t *
 rtree_child_read_hard(rtree_t *rtree, rtree_node_elm_t *elm, unsigned level)
 {
 
-	return (rtree_node_init(rtree, level, &elm->child));
+	return (rtree_node_init(rtree, level+1, &elm->child));
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.d	2017-09-27 23:00:24.890935926 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.d	2017-09-27 23:02:00.698932415 +0800
@@ -1,18 +1,21 @@
 src/rtree.o: src/rtree.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: spin.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: spin.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: spin.d
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: spin.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,120 +1,141 @@
 #define	JEMALLOC_STATS_C_
 #include "jemalloc/internal/jemalloc_internal.h"
 
 #define	CTL_GET(n, v, t) do {						\
 	size_t sz = sizeof(t);						\
-	xmallctl(n, v, &sz, NULL, 0);					\
+	xmallctl(n, (void *)v, &sz, NULL, 0);				\
 } while (0)
 
 #define	CTL_M2_GET(n, i, v, t) do {					\
 	size_t mib[6];							\
 	size_t miblen = sizeof(mib) / sizeof(size_t);			\
 	size_t sz = sizeof(t);						\
 	xmallctlnametomib(n, mib, &miblen);				\
 	mib[2] = (i);							\
-	xmallctlbymib(mib, miblen, v, &sz, NULL, 0);			\
+	xmallctlbymib(mib, miblen, (void *)v, &sz, NULL, 0);		\
 } while (0)
 
 #define	CTL_M2_M4_GET(n, i, j, v, t) do {				\
 	size_t mib[6];							\
 	size_t miblen = sizeof(mib) / sizeof(size_t);			\
 	size_t sz = sizeof(t);						\
 	xmallctlnametomib(n, mib, &miblen);				\
 	mib[2] = (i);							\
 	mib[4] = (j);							\
-	xmallctlbymib(mib, miblen, v, &sz, NULL, 0);			\
+	xmallctlbymib(mib, miblen, (void *)v, &sz, NULL, 0);		\
 } while (0)
 
 /******************************************************************************/
 /* Data. */
 
 bool	opt_stats_print = false;
 
 size_t	stats_cactive = 0;
 
 /******************************************************************************/
-/* Function prototypes for non-inline static functions. */
-
-static void	stats_arena_bins_print(void (*write_cb)(void *, const char *),
-    void *cbopaque, unsigned i);
-static void	stats_arena_lruns_print(void (*write_cb)(void *, const char *),
-    void *cbopaque, unsigned i);
-static void	stats_arena_hchunks_print(
-    void (*write_cb)(void *, const char *), void *cbopaque, unsigned i);
-static void	stats_arena_print(void (*write_cb)(void *, const char *),
-    void *cbopaque, unsigned i, bool bins, bool large, bool huge);
-
-/******************************************************************************/
 
 static void
 stats_arena_bins_print(void (*write_cb)(void *, const char *), void *cbopaque,
-    unsigned i)
+    bool json, bool large, bool huge, unsigned i)
 {
 	size_t page;
-	bool config_tcache, in_gap;
+	bool config_tcache, in_gap, in_gap_prev;
 	unsigned nbins, j;
 
 	CTL_GET("arenas.page", &page, size_t);
 
-	CTL_GET("config.tcache", &config_tcache, bool);
-	if (config_tcache) {
+	CTL_GET("arenas.nbins", &nbins, unsigned);
+	if (json) {
 		malloc_cprintf(write_cb, cbopaque,
-		    "bins:           size ind    allocated      nmalloc"
-		    "      ndalloc    nrequests      curregs      curruns regs"
-		    " pgs  util       nfills     nflushes      newruns"
-		    "       reruns\n");
+		    "\t\t\t\t\"bins\": [\n");
 	} else {
-		malloc_cprintf(write_cb, cbopaque,
-		    "bins:           size ind    allocated      nmalloc"
-		    "      ndalloc    nrequests      curregs      curruns regs"
-		    " pgs  util      newruns       reruns\n");
+		CTL_GET("config.tcache", &config_tcache, bool);
+		if (config_tcache) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "bins:           size ind    allocated      nmalloc"
+			    "      ndalloc    nrequests      curregs"
+			    "      curruns regs pgs  util       nfills"
+			    "     nflushes      newruns       reruns\n");
+		} else {
+			malloc_cprintf(write_cb, cbopaque,
+			    "bins:           size ind    allocated      nmalloc"
+			    "      ndalloc    nrequests      curregs"
+			    "      curruns regs pgs  util      newruns"
+			    "       reruns\n");
+		}
 	}
-	CTL_GET("arenas.nbins", &nbins, unsigned);
 	for (j = 0, in_gap = false; j < nbins; j++) {
 		uint64_t nruns;
+		size_t reg_size, run_size, curregs;
+		size_t curruns;
+		uint32_t nregs;
+		uint64_t nmalloc, ndalloc, nrequests, nfills, nflushes;
+		uint64_t nreruns;
 
 		CTL_M2_M4_GET("stats.arenas.0.bins.0.nruns", i, j, &nruns,
 		    uint64_t);
-		if (nruns == 0)
-			in_gap = true;
-		else {
-			size_t reg_size, run_size, curregs, availregs, milli;
-			size_t curruns;
-			uint32_t nregs;
-			uint64_t nmalloc, ndalloc, nrequests, nfills, nflushes;
-			uint64_t reruns;
-			char util[6]; /* "x.yyy". */
+		in_gap_prev = in_gap;
+		in_gap = (nruns == 0);
 
-			if (in_gap) {
-				malloc_cprintf(write_cb, cbopaque,
-				    "                     ---\n");
-				in_gap = false;
-			}
-			CTL_M2_GET("arenas.bin.0.size", j, &reg_size, size_t);
-			CTL_M2_GET("arenas.bin.0.nregs", j, &nregs, uint32_t);
-			CTL_M2_GET("arenas.bin.0.run_size", j, &run_size,
-			    size_t);
-			CTL_M2_M4_GET("stats.arenas.0.bins.0.nmalloc", i, j,
-			    &nmalloc, uint64_t);
-			CTL_M2_M4_GET("stats.arenas.0.bins.0.ndalloc", i, j,
-			    &ndalloc, uint64_t);
-			CTL_M2_M4_GET("stats.arenas.0.bins.0.curregs", i, j,
-			    &curregs, size_t);
-			CTL_M2_M4_GET("stats.arenas.0.bins.0.nrequests", i, j,
-			    &nrequests, uint64_t);
+		if (!json && in_gap_prev && !in_gap) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "                     ---\n");
+		}
+
+		CTL_M2_GET("arenas.bin.0.size", j, &reg_size, size_t);
+		CTL_M2_GET("arenas.bin.0.nregs", j, &nregs, uint32_t);
+		CTL_M2_GET("arenas.bin.0.run_size", j, &run_size, size_t);
+
+		CTL_M2_M4_GET("stats.arenas.0.bins.0.nmalloc", i, j, &nmalloc,
+		    uint64_t);
+		CTL_M2_M4_GET("stats.arenas.0.bins.0.ndalloc", i, j, &ndalloc,
+		    uint64_t);
+		CTL_M2_M4_GET("stats.arenas.0.bins.0.curregs", i, j, &curregs,
+		    size_t);
+		CTL_M2_M4_GET("stats.arenas.0.bins.0.nrequests", i, j,
+		    &nrequests, uint64_t);
+		if (config_tcache) {
+			CTL_M2_M4_GET("stats.arenas.0.bins.0.nfills", i, j,
+			    &nfills, uint64_t);
+			CTL_M2_M4_GET("stats.arenas.0.bins.0.nflushes", i, j,
+			    &nflushes, uint64_t);
+		}
+		CTL_M2_M4_GET("stats.arenas.0.bins.0.nreruns", i, j, &nreruns,
+		    uint64_t);
+		CTL_M2_M4_GET("stats.arenas.0.bins.0.curruns", i, j, &curruns,
+		    size_t);
+
+		if (json) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t\t{\n"
+			    "\t\t\t\t\t\t\"nmalloc\": %"FMTu64",\n"
+			    "\t\t\t\t\t\t\"ndalloc\": %"FMTu64",\n"
+			    "\t\t\t\t\t\t\"curregs\": %zu,\n"
+			    "\t\t\t\t\t\t\"nrequests\": %"FMTu64",\n",
+			    nmalloc,
+			    ndalloc,
+			    curregs,
+			    nrequests);
 			if (config_tcache) {
-				CTL_M2_M4_GET("stats.arenas.0.bins.0.nfills", i,
-				    j, &nfills, uint64_t);
-				CTL_M2_M4_GET("stats.arenas.0.bins.0.nflushes",
-				    i, j, &nflushes, uint64_t);
+				malloc_cprintf(write_cb, cbopaque,
+				    "\t\t\t\t\t\t\"nfills\": %"FMTu64",\n"
+				    "\t\t\t\t\t\t\"nflushes\": %"FMTu64",\n",
+				    nfills,
+				    nflushes);
 			}
-			CTL_M2_M4_GET("stats.arenas.0.bins.0.nreruns", i, j,
-			    &reruns, uint64_t);
-			CTL_M2_M4_GET("stats.arenas.0.bins.0.curruns", i, j,
-			    &curruns, size_t);
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t\t\t\"nreruns\": %"FMTu64",\n"
+			    "\t\t\t\t\t\t\"curruns\": %zu\n"
+			    "\t\t\t\t\t}%s\n",
+			    nreruns,
+			    curruns,
+			    (j + 1 < nbins) ? "," : "");
+		} else if (!in_gap) {
+			size_t availregs, milli;
+			char util[6]; /* "x.yyy". */
 
 			availregs = nregs * curruns;
 			milli = (availregs != 0) ? (1000 * curregs) / availregs
 			    : 1000;
 			assert(milli <= 1000);
 			if (milli < 10) {
@@ -135,506 +156,999 @@
 				    " %12"FMTu64" %12"FMTu64" %12zu"
 				    " %12zu %4u %3zu %-5s %12"FMTu64
 				    " %12"FMTu64" %12"FMTu64" %12"FMTu64"\n",
 				    reg_size, j, curregs * reg_size, nmalloc,
 				    ndalloc, nrequests, curregs, curruns, nregs,
 				    run_size / page, util, nfills, nflushes,
-				    nruns, reruns);
+				    nruns, nreruns);
 			} else {
 				malloc_cprintf(write_cb, cbopaque,
 				    "%20zu %3u %12zu %12"FMTu64
 				    " %12"FMTu64" %12"FMTu64" %12zu"
 				    " %12zu %4u %3zu %-5s %12"FMTu64
 				    " %12"FMTu64"\n",
 				    reg_size, j, curregs * reg_size, nmalloc,
 				    ndalloc, nrequests, curregs, curruns, nregs,
-				    run_size / page, util, nruns, reruns);
+				    run_size / page, util, nruns, nreruns);
 			}
 		}
 	}
-	if (in_gap) {
+	if (json) {
 		malloc_cprintf(write_cb, cbopaque,
-		    "                     ---\n");
+		    "\t\t\t\t]%s\n", (large || huge) ? "," : "");
+	} else {
+		if (in_gap) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "                     ---\n");
+		}
 	}
 }
 
 static void
 stats_arena_lruns_print(void (*write_cb)(void *, const char *), void *cbopaque,
-    unsigned i)
+    bool json, bool huge, unsigned i)
 {
 	unsigned nbins, nlruns, j;
-	bool in_gap;
+	bool in_gap, in_gap_prev;
 
-	malloc_cprintf(write_cb, cbopaque,
-	    "large:          size ind    allocated      nmalloc      ndalloc"
-	    "    nrequests      curruns\n");
 	CTL_GET("arenas.nbins", &nbins, unsigned);
 	CTL_GET("arenas.nlruns", &nlruns, unsigned);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"lruns\": [\n");
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "large:          size ind    allocated      nmalloc"
+		    "      ndalloc    nrequests      curruns\n");
+	}
 	for (j = 0, in_gap = false; j < nlruns; j++) {
 		uint64_t nmalloc, ndalloc, nrequests;
 		size_t run_size, curruns;
 
 		CTL_M2_M4_GET("stats.arenas.0.lruns.0.nmalloc", i, j, &nmalloc,
 		    uint64_t);
 		CTL_M2_M4_GET("stats.arenas.0.lruns.0.ndalloc", i, j, &ndalloc,
 		    uint64_t);
 		CTL_M2_M4_GET("stats.arenas.0.lruns.0.nrequests", i, j,
 		    &nrequests, uint64_t);
-		if (nrequests == 0)
-			in_gap = true;
-		else {
-			CTL_M2_GET("arenas.lrun.0.size", j, &run_size, size_t);
-			CTL_M2_M4_GET("stats.arenas.0.lruns.0.curruns", i, j,
-			    &curruns, size_t);
-			if (in_gap) {
-				malloc_cprintf(write_cb, cbopaque,
-				    "                     ---\n");
-				in_gap = false;
-			}
+		in_gap_prev = in_gap;
+		in_gap = (nrequests == 0);
+
+		if (!json && in_gap_prev && !in_gap) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "                     ---\n");
+		}
+
+		CTL_M2_GET("arenas.lrun.0.size", j, &run_size, size_t);
+		CTL_M2_M4_GET("stats.arenas.0.lruns.0.curruns", i, j, &curruns,
+		    size_t);
+		if (json) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t\t{\n"
+			    "\t\t\t\t\t\t\"curruns\": %zu\n"
+			    "\t\t\t\t\t}%s\n",
+			    curruns,
+			    (j + 1 < nlruns) ? "," : "");
+		} else if (!in_gap) {
 			malloc_cprintf(write_cb, cbopaque,
 			    "%20zu %3u %12zu %12"FMTu64" %12"FMTu64
 			    " %12"FMTu64" %12zu\n",
 			    run_size, nbins + j, curruns * run_size, nmalloc,
 			    ndalloc, nrequests, curruns);
 		}
 	}
-	if (in_gap) {
+	if (json) {
 		malloc_cprintf(write_cb, cbopaque,
-		    "                     ---\n");
+		    "\t\t\t\t]%s\n", huge ? "," : "");
+	} else {
+		if (in_gap) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "                     ---\n");
+		}
 	}
 }
 
 static void
 stats_arena_hchunks_print(void (*write_cb)(void *, const char *),
-    void *cbopaque, unsigned i)
+    void *cbopaque, bool json, unsigned i)
 {
 	unsigned nbins, nlruns, nhchunks, j;
-	bool in_gap;
+	bool in_gap, in_gap_prev;
 
-	malloc_cprintf(write_cb, cbopaque,
-	    "huge:           size ind    allocated      nmalloc      ndalloc"
-	    "    nrequests   curhchunks\n");
 	CTL_GET("arenas.nbins", &nbins, unsigned);
 	CTL_GET("arenas.nlruns", &nlruns, unsigned);
 	CTL_GET("arenas.nhchunks", &nhchunks, unsigned);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"hchunks\": [\n");
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "huge:           size ind    allocated      nmalloc"
+		    "      ndalloc    nrequests   curhchunks\n");
+	}
 	for (j = 0, in_gap = false; j < nhchunks; j++) {
 		uint64_t nmalloc, ndalloc, nrequests;
 		size_t hchunk_size, curhchunks;
 
 		CTL_M2_M4_GET("stats.arenas.0.hchunks.0.nmalloc", i, j,
 		    &nmalloc, uint64_t);
 		CTL_M2_M4_GET("stats.arenas.0.hchunks.0.ndalloc", i, j,
 		    &ndalloc, uint64_t);
 		CTL_M2_M4_GET("stats.arenas.0.hchunks.0.nrequests", i, j,
 		    &nrequests, uint64_t);
-		if (nrequests == 0)
-			in_gap = true;
-		else {
-			CTL_M2_GET("arenas.hchunk.0.size", j, &hchunk_size,
-			    size_t);
-			CTL_M2_M4_GET("stats.arenas.0.hchunks.0.curhchunks", i,
-			    j, &curhchunks, size_t);
-			if (in_gap) {
-				malloc_cprintf(write_cb, cbopaque,
-				    "                     ---\n");
-				in_gap = false;
-			}
+		in_gap_prev = in_gap;
+		in_gap = (nrequests == 0);
+
+		if (!json && in_gap_prev && !in_gap) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "                     ---\n");
+		}
+
+		CTL_M2_GET("arenas.hchunk.0.size", j, &hchunk_size, size_t);
+		CTL_M2_M4_GET("stats.arenas.0.hchunks.0.curhchunks", i, j,
+		    &curhchunks, size_t);
+		if (json) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t\t{\n"
+			    "\t\t\t\t\t\t\"curhchunks\": %zu\n"
+			    "\t\t\t\t\t}%s\n",
+			    curhchunks,
+			    (j + 1 < nhchunks) ? "," : "");
+		} else if (!in_gap) {
 			malloc_cprintf(write_cb, cbopaque,
 			    "%20zu %3u %12zu %12"FMTu64" %12"FMTu64
 			    " %12"FMTu64" %12zu\n",
 			    hchunk_size, nbins + nlruns + j,
 			    curhchunks * hchunk_size, nmalloc, ndalloc,
 			    nrequests, curhchunks);
 		}
 	}
-	if (in_gap) {
+	if (json) {
 		malloc_cprintf(write_cb, cbopaque,
-		    "                     ---\n");
+		    "\t\t\t\t]\n");
+	} else {
+		if (in_gap) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "                     ---\n");
+		}
 	}
 }
 
 static void
 stats_arena_print(void (*write_cb)(void *, const char *), void *cbopaque,
-    unsigned i, bool bins, bool large, bool huge)
+    bool json, unsigned i, bool bins, bool large, bool huge)
 {
 	unsigned nthreads;
 	const char *dss;
-	ssize_t lg_dirty_mult;
-	size_t page, pactive, pdirty, mapped;
+	ssize_t lg_dirty_mult, decay_time;
+	size_t page, pactive, pdirty, mapped, retained;
 	size_t metadata_mapped, metadata_allocated;
 	uint64_t npurge, nmadvise, purged;
 	size_t small_allocated;
 	uint64_t small_nmalloc, small_ndalloc, small_nrequests;
 	size_t large_allocated;
 	uint64_t large_nmalloc, large_ndalloc, large_nrequests;
 	size_t huge_allocated;
 	uint64_t huge_nmalloc, huge_ndalloc, huge_nrequests;
 
 	CTL_GET("arenas.page", &page, size_t);
 
 	CTL_M2_GET("stats.arenas.0.nthreads", i, &nthreads, unsigned);
-	malloc_cprintf(write_cb, cbopaque,
-	    "assigned threads: %u\n", nthreads);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"nthreads\": %u,\n", nthreads);
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "assigned threads: %u\n", nthreads);
+	}
+
 	CTL_M2_GET("stats.arenas.0.dss", i, &dss, const char *);
-	malloc_cprintf(write_cb, cbopaque, "dss allocation precedence: %s\n",
-	    dss);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"dss\": \"%s\",\n", dss);
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "dss allocation precedence: %s\n", dss);
+	}
+
 	CTL_M2_GET("stats.arenas.0.lg_dirty_mult", i, &lg_dirty_mult, ssize_t);
-	if (lg_dirty_mult >= 0) {
+	if (json) {
 		malloc_cprintf(write_cb, cbopaque,
-		    "min active:dirty page ratio: %u:1\n",
-		    (1U << lg_dirty_mult));
+		    "\t\t\t\t\"lg_dirty_mult\": %zd,\n", lg_dirty_mult);
 	} else {
+		if (opt_purge == purge_mode_ratio) {
+			if (lg_dirty_mult >= 0) {
+				malloc_cprintf(write_cb, cbopaque,
+				    "min active:dirty page ratio: %u:1\n",
+				    (1U << lg_dirty_mult));
+			} else {
+				malloc_cprintf(write_cb, cbopaque,
+				    "min active:dirty page ratio: N/A\n");
+			}
+		}
+	}
+
+	CTL_M2_GET("stats.arenas.0.decay_time", i, &decay_time, ssize_t);
+	if (json) {
 		malloc_cprintf(write_cb, cbopaque,
-		    "min active:dirty page ratio: N/A\n");
+		    "\t\t\t\t\"decay_time\": %zd,\n", decay_time);
+	} else {
+		if (opt_purge == purge_mode_decay) {
+			if (decay_time >= 0) {
+				malloc_cprintf(write_cb, cbopaque,
+				    "decay time: %zd\n", decay_time);
+			} else {
+				malloc_cprintf(write_cb, cbopaque,
+				    "decay time: N/A\n");
+			}
+		}
 	}
+
 	CTL_M2_GET("stats.arenas.0.pactive", i, &pactive, size_t);
 	CTL_M2_GET("stats.arenas.0.pdirty", i, &pdirty, size_t);
 	CTL_M2_GET("stats.arenas.0.npurge", i, &npurge, uint64_t);
 	CTL_M2_GET("stats.arenas.0.nmadvise", i, &nmadvise, uint64_t);
 	CTL_M2_GET("stats.arenas.0.purged", i, &purged, uint64_t);
-	malloc_cprintf(write_cb, cbopaque,
-	    "dirty pages: %zu:%zu active:dirty, %"FMTu64" sweep%s, %"FMTu64
-	    " madvise%s, %"FMTu64" purged\n", pactive, pdirty, npurge, npurge ==
-	    1 ? "" : "s", nmadvise, nmadvise == 1 ? "" : "s", purged);
-
-	malloc_cprintf(write_cb, cbopaque,
-	    "                            allocated      nmalloc      ndalloc"
-	    "    nrequests\n");
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"pactive\": %zu,\n", pactive);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"pdirty\": %zu,\n", pdirty);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"npurge\": %"FMTu64",\n", npurge);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"nmadvise\": %"FMTu64",\n", nmadvise);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"purged\": %"FMTu64",\n", purged);
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "purging: dirty: %zu, sweeps: %"FMTu64", madvises: %"FMTu64
+		    ", purged: %"FMTu64"\n", pdirty, npurge, nmadvise, purged);
+	}
+
 	CTL_M2_GET("stats.arenas.0.small.allocated", i, &small_allocated,
 	    size_t);
 	CTL_M2_GET("stats.arenas.0.small.nmalloc", i, &small_nmalloc, uint64_t);
 	CTL_M2_GET("stats.arenas.0.small.ndalloc", i, &small_ndalloc, uint64_t);
 	CTL_M2_GET("stats.arenas.0.small.nrequests", i, &small_nrequests,
 	    uint64_t);
-	malloc_cprintf(write_cb, cbopaque,
-	    "small:                   %12zu %12"FMTu64" %12"FMTu64
-	    " %12"FMTu64"\n",
-	    small_allocated, small_nmalloc, small_ndalloc, small_nrequests);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"small\": {\n");
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"allocated\": %zu,\n", small_allocated);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"nmalloc\": %"FMTu64",\n", small_nmalloc);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"ndalloc\": %"FMTu64",\n", small_ndalloc);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"nrequests\": %"FMTu64"\n", small_nrequests);
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t},\n");
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "                            allocated      nmalloc"
+		    "      ndalloc    nrequests\n");
+		malloc_cprintf(write_cb, cbopaque,
+		    "small:                   %12zu %12"FMTu64" %12"FMTu64
+		    " %12"FMTu64"\n",
+		    small_allocated, small_nmalloc, small_ndalloc,
+		    small_nrequests);
+	}
+
 	CTL_M2_GET("stats.arenas.0.large.allocated", i, &large_allocated,
 	    size_t);
 	CTL_M2_GET("stats.arenas.0.large.nmalloc", i, &large_nmalloc, uint64_t);
 	CTL_M2_GET("stats.arenas.0.large.ndalloc", i, &large_ndalloc, uint64_t);
 	CTL_M2_GET("stats.arenas.0.large.nrequests", i, &large_nrequests,
 	    uint64_t);
-	malloc_cprintf(write_cb, cbopaque,
-	    "large:                   %12zu %12"FMTu64" %12"FMTu64
-	    " %12"FMTu64"\n",
-	    large_allocated, large_nmalloc, large_ndalloc, large_nrequests);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"large\": {\n");
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"allocated\": %zu,\n", large_allocated);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"nmalloc\": %"FMTu64",\n", large_nmalloc);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"ndalloc\": %"FMTu64",\n", large_ndalloc);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"nrequests\": %"FMTu64"\n", large_nrequests);
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t},\n");
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "large:                   %12zu %12"FMTu64" %12"FMTu64
+		    " %12"FMTu64"\n",
+		    large_allocated, large_nmalloc, large_ndalloc,
+		    large_nrequests);
+	}
+
 	CTL_M2_GET("stats.arenas.0.huge.allocated", i, &huge_allocated, size_t);
 	CTL_M2_GET("stats.arenas.0.huge.nmalloc", i, &huge_nmalloc, uint64_t);
 	CTL_M2_GET("stats.arenas.0.huge.ndalloc", i, &huge_ndalloc, uint64_t);
 	CTL_M2_GET("stats.arenas.0.huge.nrequests", i, &huge_nrequests,
 	    uint64_t);
-	malloc_cprintf(write_cb, cbopaque,
-	    "huge:                    %12zu %12"FMTu64" %12"FMTu64
-	    " %12"FMTu64"\n",
-	    huge_allocated, huge_nmalloc, huge_ndalloc, huge_nrequests);
-	malloc_cprintf(write_cb, cbopaque,
-	    "total:                   %12zu %12"FMTu64" %12"FMTu64
-	    " %12"FMTu64"\n",
-	    small_allocated + large_allocated + huge_allocated,
-	    small_nmalloc + large_nmalloc + huge_nmalloc,
-	    small_ndalloc + large_ndalloc + huge_ndalloc,
-	    small_nrequests + large_nrequests + huge_nrequests);
-	malloc_cprintf(write_cb, cbopaque,
-	    "active:                  %12zu\n", pactive * page);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"huge\": {\n");
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"allocated\": %zu,\n", huge_allocated);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"nmalloc\": %"FMTu64",\n", huge_nmalloc);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"ndalloc\": %"FMTu64",\n", huge_ndalloc);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"nrequests\": %"FMTu64"\n", huge_nrequests);
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t},\n");
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "huge:                    %12zu %12"FMTu64" %12"FMTu64
+		    " %12"FMTu64"\n",
+		    huge_allocated, huge_nmalloc, huge_ndalloc, huge_nrequests);
+		malloc_cprintf(write_cb, cbopaque,
+		    "total:                   %12zu %12"FMTu64" %12"FMTu64
+		    " %12"FMTu64"\n",
+		    small_allocated + large_allocated + huge_allocated,
+		    small_nmalloc + large_nmalloc + huge_nmalloc,
+		    small_ndalloc + large_ndalloc + huge_ndalloc,
+		    small_nrequests + large_nrequests + huge_nrequests);
+	}
+	if (!json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "active:                  %12zu\n", pactive * page);
+	}
+
 	CTL_M2_GET("stats.arenas.0.mapped", i, &mapped, size_t);
-	malloc_cprintf(write_cb, cbopaque,
-	    "mapped:                  %12zu\n", mapped);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"mapped\": %zu,\n", mapped);
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "mapped:                  %12zu\n", mapped);
+	}
+
+	CTL_M2_GET("stats.arenas.0.retained", i, &retained, size_t);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"retained\": %zu,\n", retained);
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "retained:                %12zu\n", retained);
+	}
+
 	CTL_M2_GET("stats.arenas.0.metadata.mapped", i, &metadata_mapped,
 	    size_t);
 	CTL_M2_GET("stats.arenas.0.metadata.allocated", i, &metadata_allocated,
 	    size_t);
-	malloc_cprintf(write_cb, cbopaque,
-	    "metadata: mapped: %zu, allocated: %zu\n",
-	    metadata_mapped, metadata_allocated);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\"metadata\": {\n");
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"mapped\": %zu,\n", metadata_mapped);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t\t\"allocated\": %zu\n", metadata_allocated);
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\t},\n");
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "metadata: mapped: %zu, allocated: %zu\n",
+		    metadata_mapped, metadata_allocated);
+	}
 
-	if (bins)
-		stats_arena_bins_print(write_cb, cbopaque, i);
+	if (bins) {
+		stats_arena_bins_print(write_cb, cbopaque, json, large, huge,
+		    i);
+	}
 	if (large)
-		stats_arena_lruns_print(write_cb, cbopaque, i);
+		stats_arena_lruns_print(write_cb, cbopaque, json, huge, i);
 	if (huge)
-		stats_arena_hchunks_print(write_cb, cbopaque, i);
+		stats_arena_hchunks_print(write_cb, cbopaque, json, i);
 }
 
-void
-stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
-    const char *opts)
+static void
+stats_general_print(void (*write_cb)(void *, const char *), void *cbopaque,
+    bool json, bool merged, bool unmerged)
 {
-	int err;
-	uint64_t epoch;
-	size_t u64sz;
-	bool general = true;
-	bool merged = true;
-	bool unmerged = true;
-	bool bins = true;
-	bool large = true;
-	bool huge = true;
+	const char *cpv;
+	bool bv;
+	unsigned uv;
+	uint32_t u32v;
+	uint64_t u64v;
+	ssize_t ssv;
+	size_t sv, bsz, usz, ssz, sssz, cpsz;
+
+	bsz = sizeof(bool);
+	usz = sizeof(unsigned);
+	ssz = sizeof(size_t);
+	sssz = sizeof(ssize_t);
+	cpsz = sizeof(const char *);
 
-	/*
-	 * Refresh stats, in case mallctl() was called by the application.
-	 *
-	 * Check for OOM here, since refreshing the ctl cache can trigger
-	 * allocation.  In practice, none of the subsequent mallctl()-related
-	 * calls in this function will cause OOM if this one succeeds.
-	 * */
-	epoch = 1;
-	u64sz = sizeof(uint64_t);
-	err = je_mallctl("epoch", &epoch, &u64sz, &epoch, sizeof(uint64_t));
-	if (err != 0) {
-		if (err == EAGAIN) {
-			malloc_write("<jemalloc>: Memory allocation failure in "
-			    "mallctl(\"epoch\", ...)\n");
-			return;
-		}
-		malloc_write("<jemalloc>: Failure in mallctl(\"epoch\", "
-		    "...)\n");
-		abort();
-	}
+	CTL_GET("version", &cpv, const char *);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		"\t\t\"version\": \"%s\",\n", cpv);
+	} else
+		malloc_cprintf(write_cb, cbopaque, "Version: %s\n", cpv);
 
-	if (opts != NULL) {
-		unsigned i;
+	/* config. */
+#define	CONFIG_WRITE_BOOL_JSON(n, c)					\
+	if (json) {							\
+		CTL_GET("config."#n, &bv, bool);			\
+		malloc_cprintf(write_cb, cbopaque,			\
+		    "\t\t\t\""#n"\": %s%s\n", bv ? "true" : "false",	\
+		    (c));						\
+	}
 
-		for (i = 0; opts[i] != '\0'; i++) {
-			switch (opts[i]) {
-			case 'g':
-				general = false;
-				break;
-			case 'm':
-				merged = false;
-				break;
-			case 'a':
-				unmerged = false;
-				break;
-			case 'b':
-				bins = false;
-				break;
-			case 'l':
-				large = false;
-				break;
-			case 'h':
-				huge = false;
-				break;
-			default:;
-			}
-		}
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\"config\": {\n");
 	}
 
-	malloc_cprintf(write_cb, cbopaque,
-	    "___ Begin jemalloc statistics ___\n");
-	if (general) {
-		const char *cpv;
-		bool bv;
-		unsigned uv;
-		ssize_t ssv;
-		size_t sv, bsz, ssz, sssz, cpsz;
-
-		bsz = sizeof(bool);
-		ssz = sizeof(size_t);
-		sssz = sizeof(ssize_t);
-		cpsz = sizeof(const char *);
+	CONFIG_WRITE_BOOL_JSON(cache_oblivious, ",")
 
-		CTL_GET("version", &cpv, const char *);
-		malloc_cprintf(write_cb, cbopaque, "Version: %s\n", cpv);
-		CTL_GET("config.debug", &bv, bool);
+	CTL_GET("config.debug", &bv, bool);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"debug\": %s,\n", bv ? "true" : "false");
+	} else {
 		malloc_cprintf(write_cb, cbopaque, "Assertions %s\n",
 		    bv ? "enabled" : "disabled");
+	}
+
+	CONFIG_WRITE_BOOL_JSON(fill, ",")
+	CONFIG_WRITE_BOOL_JSON(lazy_lock, ",")
+
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"malloc_conf\": \"%s\",\n",
+		    config_malloc_conf);
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "config.malloc_conf: \"%s\"\n", config_malloc_conf);
+	}
+
+	CONFIG_WRITE_BOOL_JSON(munmap, ",")
+	CONFIG_WRITE_BOOL_JSON(prof, ",")
+	CONFIG_WRITE_BOOL_JSON(prof_libgcc, ",")
+	CONFIG_WRITE_BOOL_JSON(prof_libunwind, ",")
+	CONFIG_WRITE_BOOL_JSON(stats, ",")
+	CONFIG_WRITE_BOOL_JSON(tcache, ",")
+	CONFIG_WRITE_BOOL_JSON(tls, ",")
+	CONFIG_WRITE_BOOL_JSON(utrace, ",")
+	CONFIG_WRITE_BOOL_JSON(valgrind, ",")
+	CONFIG_WRITE_BOOL_JSON(xmalloc, "")
 
-#define	OPT_WRITE_BOOL(n)						\
-		if (je_mallctl("opt."#n, &bv, &bsz, NULL, 0) == 0) {	\
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t},\n");
+	}
+#undef CONFIG_WRITE_BOOL_JSON
+
+	/* opt. */
+#define	OPT_WRITE_BOOL(n, c)						\
+	if (je_mallctl("opt."#n, (void *)&bv, &bsz, NULL, 0) == 0) {	\
+		if (json) {						\
+			malloc_cprintf(write_cb, cbopaque,		\
+			    "\t\t\t\""#n"\": %s%s\n", bv ? "true" :	\
+			    "false", (c));				\
+		} else {						\
 			malloc_cprintf(write_cb, cbopaque,		\
 			    "  opt."#n": %s\n", bv ? "true" : "false");	\
-		}
-#define	OPT_WRITE_BOOL_MUTABLE(n, m) {					\
-		bool bv2;						\
-		if (je_mallctl("opt."#n, &bv, &bsz, NULL, 0) == 0 &&	\
-		    je_mallctl(#m, &bv2, &bsz, NULL, 0) == 0) {		\
+		}							\
+	}
+#define	OPT_WRITE_BOOL_MUTABLE(n, m, c) {				\
+	bool bv2;							\
+	if (je_mallctl("opt."#n, (void *)&bv, &bsz, NULL, 0) == 0 &&	\
+	    je_mallctl(#m, &bv2, (void *)&bsz, NULL, 0) == 0) {		\
+		if (json) {						\
+			malloc_cprintf(write_cb, cbopaque,		\
+			    "\t\t\t\""#n"\": %s%s\n", bv ? "true" :	\
+			    "false", (c));				\
+		} else {						\
 			malloc_cprintf(write_cb, cbopaque,		\
 			    "  opt."#n": %s ("#m": %s)\n", bv ? "true"	\
 			    : "false", bv2 ? "true" : "false");		\
 		}							\
+	}								\
 }
-#define	OPT_WRITE_SIZE_T(n)						\
-		if (je_mallctl("opt."#n, &sv, &ssz, NULL, 0) == 0) {	\
+#define	OPT_WRITE_UNSIGNED(n, c)					\
+	if (je_mallctl("opt."#n, (void *)&uv, &usz, NULL, 0) == 0) {	\
+		if (json) {						\
+			malloc_cprintf(write_cb, cbopaque,		\
+			    "\t\t\t\""#n"\": %u%s\n", uv, (c));		\
+		} else {						\
+			malloc_cprintf(write_cb, cbopaque,		\
+			"  opt."#n": %u\n", uv);			\
+		}							\
+	}
+#define	OPT_WRITE_SIZE_T(n, c)						\
+	if (je_mallctl("opt."#n, (void *)&sv, &ssz, NULL, 0) == 0) {	\
+		if (json) {						\
+			malloc_cprintf(write_cb, cbopaque,		\
+			    "\t\t\t\""#n"\": %zu%s\n", sv, (c));	\
+		} else {						\
 			malloc_cprintf(write_cb, cbopaque,		\
 			"  opt."#n": %zu\n", sv);			\
-		}
-#define	OPT_WRITE_SSIZE_T(n)						\
-		if (je_mallctl("opt."#n, &ssv, &sssz, NULL, 0) == 0) {	\
+		}							\
+	}
+#define	OPT_WRITE_SSIZE_T(n, c)						\
+	if (je_mallctl("opt."#n, (void *)&ssv, &sssz, NULL, 0) == 0) {	\
+		if (json) {						\
+			malloc_cprintf(write_cb, cbopaque,		\
+			    "\t\t\t\""#n"\": %zd%s\n", ssv, (c));	\
+		} else {						\
 			malloc_cprintf(write_cb, cbopaque,		\
 			    "  opt."#n": %zd\n", ssv);			\
-		}
-#define	OPT_WRITE_SSIZE_T_MUTABLE(n, m) {				\
-		ssize_t ssv2;						\
-		if (je_mallctl("opt."#n, &ssv, &sssz, NULL, 0) == 0 &&	\
-		    je_mallctl(#m, &ssv2, &sssz, NULL, 0) == 0) {	\
+		}							\
+	}
+#define	OPT_WRITE_SSIZE_T_MUTABLE(n, m, c) {				\
+	ssize_t ssv2;							\
+	if (je_mallctl("opt."#n, (void *)&ssv, &sssz, NULL, 0) == 0 &&	\
+	    je_mallctl(#m, (void *)&ssv2, &sssz, NULL, 0) == 0) {	\
+		if (json) {						\
+			malloc_cprintf(write_cb, cbopaque,		\
+			    "\t\t\t\""#n"\": %zd%s\n", ssv, (c));	\
+		} else {						\
 			malloc_cprintf(write_cb, cbopaque,		\
 			    "  opt."#n": %zd ("#m": %zd)\n",		\
 			    ssv, ssv2);					\
 		}							\
+	}								\
 }
-#define	OPT_WRITE_CHAR_P(n)						\
-		if (je_mallctl("opt."#n, &cpv, &cpsz, NULL, 0) == 0) {	\
+#define	OPT_WRITE_CHAR_P(n, c)						\
+	if (je_mallctl("opt."#n, (void *)&cpv, &cpsz, NULL, 0) == 0) {	\
+		if (json) {						\
+			malloc_cprintf(write_cb, cbopaque,		\
+			    "\t\t\t\""#n"\": \"%s\"%s\n", cpv, (c));	\
+		} else {						\
 			malloc_cprintf(write_cb, cbopaque,		\
 			    "  opt."#n": \"%s\"\n", cpv);		\
-		}
+		}							\
+	}
 
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\"opt\": {\n");
+	} else {
 		malloc_cprintf(write_cb, cbopaque,
 		    "Run-time option settings:\n");
-		OPT_WRITE_BOOL(abort)
-		OPT_WRITE_SIZE_T(lg_chunk)
-		OPT_WRITE_CHAR_P(dss)
-		OPT_WRITE_SIZE_T(narenas)
-		OPT_WRITE_SSIZE_T_MUTABLE(lg_dirty_mult, arenas.lg_dirty_mult)
-		OPT_WRITE_BOOL(stats_print)
-		OPT_WRITE_CHAR_P(junk)
-		OPT_WRITE_SIZE_T(quarantine)
-		OPT_WRITE_BOOL(redzone)
-		OPT_WRITE_BOOL(zero)
-		OPT_WRITE_BOOL(utrace)
-		OPT_WRITE_BOOL(valgrind)
-		OPT_WRITE_BOOL(xmalloc)
-		OPT_WRITE_BOOL(tcache)
-		OPT_WRITE_SSIZE_T(lg_tcache_max)
-		OPT_WRITE_BOOL(prof)
-		OPT_WRITE_CHAR_P(prof_prefix)
-		OPT_WRITE_BOOL_MUTABLE(prof_active, prof.active)
-		OPT_WRITE_BOOL_MUTABLE(prof_thread_active_init,
-		    prof.thread_active_init)
-		OPT_WRITE_SSIZE_T(lg_prof_sample)
-		OPT_WRITE_BOOL(prof_accum)
-		OPT_WRITE_SSIZE_T(lg_prof_interval)
-		OPT_WRITE_BOOL(prof_gdump)
-		OPT_WRITE_BOOL(prof_final)
-		OPT_WRITE_BOOL(prof_leak)
+	}
+	OPT_WRITE_BOOL(abort, ",")
+	OPT_WRITE_SIZE_T(lg_chunk, ",")
+	OPT_WRITE_CHAR_P(dss, ",")
+	OPT_WRITE_UNSIGNED(narenas, ",")
+	OPT_WRITE_CHAR_P(purge, ",")
+	if (json || opt_purge == purge_mode_ratio) {
+		OPT_WRITE_SSIZE_T_MUTABLE(lg_dirty_mult,
+		    arenas.lg_dirty_mult, ",")
+	}
+	if (json || opt_purge == purge_mode_decay) {
+		OPT_WRITE_SSIZE_T_MUTABLE(decay_time, arenas.decay_time, ",")
+	}
+	OPT_WRITE_CHAR_P(junk, ",")
+	OPT_WRITE_SIZE_T(quarantine, ",")
+	OPT_WRITE_BOOL(redzone, ",")
+	OPT_WRITE_BOOL(zero, ",")
+	OPT_WRITE_BOOL(utrace, ",")
+	OPT_WRITE_BOOL(xmalloc, ",")
+	OPT_WRITE_BOOL(tcache, ",")
+	OPT_WRITE_SSIZE_T(lg_tcache_max, ",")
+	OPT_WRITE_BOOL(prof, ",")
+	OPT_WRITE_CHAR_P(prof_prefix, ",")
+	OPT_WRITE_BOOL_MUTABLE(prof_active, prof.active, ",")
+	OPT_WRITE_BOOL_MUTABLE(prof_thread_active_init, prof.thread_active_init,
+	    ",")
+	OPT_WRITE_SSIZE_T_MUTABLE(lg_prof_sample, prof.lg_sample, ",")
+	OPT_WRITE_BOOL(prof_accum, ",")
+	OPT_WRITE_SSIZE_T(lg_prof_interval, ",")
+	OPT_WRITE_BOOL(prof_gdump, ",")
+	OPT_WRITE_BOOL(prof_final, ",")
+	OPT_WRITE_BOOL(prof_leak, ",")
+	/*
+	 * stats_print is always emitted, so as long as stats_print comes last
+	 * it's safe to unconditionally omit the comma here (rather than having
+	 * to conditionally omit it elsewhere depending on configuration).
+	 */
+	OPT_WRITE_BOOL(stats_print, "")
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t},\n");
+	}
 
 #undef OPT_WRITE_BOOL
 #undef OPT_WRITE_BOOL_MUTABLE
 #undef OPT_WRITE_SIZE_T
 #undef OPT_WRITE_SSIZE_T
 #undef OPT_WRITE_CHAR_P
 
-		malloc_cprintf(write_cb, cbopaque, "CPUs: %u\n", ncpus);
+	/* arenas. */
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\"arenas\": {\n");
+	}
 
-		CTL_GET("arenas.narenas", &uv, unsigned);
+	CTL_GET("arenas.narenas", &uv, unsigned);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"narenas\": %u,\n", uv);
+	} else
 		malloc_cprintf(write_cb, cbopaque, "Arenas: %u\n", uv);
 
-		malloc_cprintf(write_cb, cbopaque, "Pointer size: %zu\n",
-		    sizeof(void *));
+	CTL_GET("arenas.lg_dirty_mult", &ssv, ssize_t);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"lg_dirty_mult\": %zd,\n", ssv);
+	} else if (opt_purge == purge_mode_ratio) {
+		if (ssv >= 0) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "Min active:dirty page ratio per arena: "
+			    "%u:1\n", (1U << ssv));
+		} else {
+			malloc_cprintf(write_cb, cbopaque,
+			    "Min active:dirty page ratio per arena: "
+			    "N/A\n");
+		}
+	}
+	CTL_GET("arenas.decay_time", &ssv, ssize_t);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"decay_time\": %zd,\n", ssv);
+	} else if (opt_purge == purge_mode_decay) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "Unused dirty page decay time: %zd%s\n",
+		    ssv, (ssv < 0) ? " (no decay)" : "");
+	}
 
-		CTL_GET("arenas.quantum", &sv, size_t);
-		malloc_cprintf(write_cb, cbopaque, "Quantum size: %zu\n",
-		    sv);
+	CTL_GET("arenas.quantum", &sv, size_t);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"quantum\": %zu,\n", sv);
+	} else
+		malloc_cprintf(write_cb, cbopaque, "Quantum size: %zu\n", sv);
 
-		CTL_GET("arenas.page", &sv, size_t);
+	CTL_GET("arenas.page", &sv, size_t);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"page\": %zu,\n", sv);
+	} else
 		malloc_cprintf(write_cb, cbopaque, "Page size: %zu\n", sv);
 
-		CTL_GET("arenas.lg_dirty_mult", &ssv, ssize_t);
-		if (ssv >= 0) {
+	if (je_mallctl("arenas.tcache_max", (void *)&sv, &ssz, NULL, 0) == 0) {
+		if (json) {
 			malloc_cprintf(write_cb, cbopaque,
-			    "Min active:dirty page ratio per arena: %u:1\n",
-			    (1U << ssv));
+			    "\t\t\t\"tcache_max\": %zu,\n", sv);
 		} else {
 			malloc_cprintf(write_cb, cbopaque,
-			    "Min active:dirty page ratio per arena: N/A\n");
+			    "Maximum thread-cached size class: %zu\n", sv);
 		}
-		if (je_mallctl("arenas.tcache_max", &sv, &ssz, NULL, 0) == 0) {
+	}
+
+	if (json) {
+		unsigned nbins, nlruns, nhchunks, i;
+
+		CTL_GET("arenas.nbins", &nbins, unsigned);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"nbins\": %u,\n", nbins);
+
+		CTL_GET("arenas.nhbins", &uv, unsigned);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"nhbins\": %u,\n", uv);
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"bin\": [\n");
+		for (i = 0; i < nbins; i++) {
 			malloc_cprintf(write_cb, cbopaque,
-			    "Maximum thread-cached size class: %zu\n", sv);
+			    "\t\t\t\t{\n");
+
+			CTL_M2_GET("arenas.bin.0.size", i, &sv, size_t);
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t\t\"size\": %zu,\n", sv);
+
+			CTL_M2_GET("arenas.bin.0.nregs", i, &u32v, uint32_t);
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t\t\"nregs\": %"FMTu32",\n", u32v);
+
+			CTL_M2_GET("arenas.bin.0.run_size", i, &sv, size_t);
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t\t\"run_size\": %zu\n", sv);
+
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t}%s\n", (i + 1 < nbins) ? "," : "");
 		}
-		if (je_mallctl("opt.prof", &bv, &bsz, NULL, 0) == 0 && bv) {
-			CTL_GET("prof.lg_sample", &sv, size_t);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t],\n");
+
+		CTL_GET("arenas.nlruns", &nlruns, unsigned);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"nlruns\": %u,\n", nlruns);
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"lrun\": [\n");
+		for (i = 0; i < nlruns; i++) {
 			malloc_cprintf(write_cb, cbopaque,
-			    "Average profile sample interval: %"FMTu64
-			    " (2^%zu)\n", (((uint64_t)1U) << sv), sv);
+			    "\t\t\t\t{\n");
 
-			CTL_GET("opt.lg_prof_interval", &ssv, ssize_t);
-			if (ssv >= 0) {
-				malloc_cprintf(write_cb, cbopaque,
-				    "Average profile dump interval: %"FMTu64
-				    " (2^%zd)\n",
-				    (((uint64_t)1U) << ssv), ssv);
-			} else {
-				malloc_cprintf(write_cb, cbopaque,
-				    "Average profile dump interval: N/A\n");
-			}
+			CTL_M2_GET("arenas.lrun.0.size", i, &sv, size_t);
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t\t\"size\": %zu\n", sv);
+
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t}%s\n", (i + 1 < nlruns) ? "," : "");
 		}
-		CTL_GET("opt.lg_chunk", &sv, size_t);
 		malloc_cprintf(write_cb, cbopaque,
-		    "Chunk size: %zu (2^%zu)\n", (ZU(1) << sv), sv);
+		    "\t\t\t],\n");
+
+		CTL_GET("arenas.nhchunks", &nhchunks, unsigned);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"nhchunks\": %u,\n", nhchunks);
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"hchunk\": [\n");
+		for (i = 0; i < nhchunks; i++) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t{\n");
+
+			CTL_M2_GET("arenas.hchunk.0.size", i, &sv, size_t);
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t\t\"size\": %zu\n", sv);
+
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\t\t}%s\n", (i + 1 < nhchunks) ? "," : "");
+		}
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t]\n");
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t},\n");
 	}
 
-	if (config_stats) {
-		size_t *cactive;
-		size_t allocated, active, metadata, resident, mapped;
+	/* prof. */
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\"prof\": {\n");
+
+		CTL_GET("prof.thread_active_init", &bv, bool);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"thread_active_init\": %s,\n", bv ? "true" :
+		    "false");
 
-		CTL_GET("stats.cactive", &cactive, size_t *);
-		CTL_GET("stats.allocated", &allocated, size_t);
-		CTL_GET("stats.active", &active, size_t);
-		CTL_GET("stats.metadata", &metadata, size_t);
-		CTL_GET("stats.resident", &resident, size_t);
-		CTL_GET("stats.mapped", &mapped, size_t);
+		CTL_GET("prof.active", &bv, bool);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"active\": %s,\n", bv ? "true" : "false");
+
+		CTL_GET("prof.gdump", &bv, bool);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"gdump\": %s,\n", bv ? "true" : "false");
+
+		CTL_GET("prof.interval", &u64v, uint64_t);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"interval\": %"FMTu64",\n", u64v);
+
+		CTL_GET("prof.lg_sample", &ssv, ssize_t);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"lg_sample\": %zd\n", ssv);
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t}%s\n", (config_stats || merged || unmerged) ? "," :
+		    "");
+	}
+}
+
+static void
+stats_print_helper(void (*write_cb)(void *, const char *), void *cbopaque,
+    bool json, bool merged, bool unmerged, bool bins, bool large, bool huge)
+{
+	size_t *cactive;
+	size_t allocated, active, metadata, resident, mapped, retained;
+
+	CTL_GET("stats.cactive", &cactive, size_t *);
+	CTL_GET("stats.allocated", &allocated, size_t);
+	CTL_GET("stats.active", &active, size_t);
+	CTL_GET("stats.metadata", &metadata, size_t);
+	CTL_GET("stats.resident", &resident, size_t);
+	CTL_GET("stats.mapped", &mapped, size_t);
+	CTL_GET("stats.retained", &retained, size_t);
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\"stats\": {\n");
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"cactive\": %zu,\n", atomic_read_z(cactive));
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"allocated\": %zu,\n", allocated);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"active\": %zu,\n", active);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"metadata\": %zu,\n", metadata);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"resident\": %zu,\n", resident);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"mapped\": %zu,\n", mapped);
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t\t\"retained\": %zu\n", retained);
+
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t\t}%s\n", (merged || unmerged) ? "," : "");
+	} else {
 		malloc_cprintf(write_cb, cbopaque,
 		    "Allocated: %zu, active: %zu, metadata: %zu,"
-		    " resident: %zu, mapped: %zu\n",
-		    allocated, active, metadata, resident, mapped);
+		    " resident: %zu, mapped: %zu, retained: %zu\n",
+		    allocated, active, metadata, resident, mapped, retained);
 		malloc_cprintf(write_cb, cbopaque,
 		    "Current active ceiling: %zu\n",
 		    atomic_read_z(cactive));
+	}
 
-		if (merged) {
-			unsigned narenas;
+	if (merged || unmerged) {
+		unsigned narenas;
 
-			CTL_GET("arenas.narenas", &narenas, unsigned);
-			{
-				VARIABLE_ARRAY(bool, initialized, narenas);
-				size_t isz;
-				unsigned i, ninitialized;
-
-				isz = sizeof(bool) * narenas;
-				xmallctl("arenas.initialized", initialized,
-				    &isz, NULL, 0);
-				for (i = ninitialized = 0; i < narenas; i++) {
-					if (initialized[i])
-						ninitialized++;
-				}
+		if (json) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t\"stats.arenas\": {\n");
+		}
 
-				if (ninitialized > 1 || !unmerged) {
-					/* Print merged arena stats. */
+		CTL_GET("arenas.narenas", &narenas, unsigned);
+		{
+			VARIABLE_ARRAY(bool, initialized, narenas);
+			size_t isz;
+			unsigned i, j, ninitialized;
+
+			isz = sizeof(bool) * narenas;
+			xmallctl("arenas.initialized", (void *)initialized,
+			    &isz, NULL, 0);
+			for (i = ninitialized = 0; i < narenas; i++) {
+				if (initialized[i])
+					ninitialized++;
+			}
+
+			/* Merged stats. */
+			if (merged && (ninitialized > 1 || !unmerged)) {
+				/* Print merged arena stats. */
+				if (json) {
+					malloc_cprintf(write_cb, cbopaque,
+					    "\t\t\t\"merged\": {\n");
+				} else {
 					malloc_cprintf(write_cb, cbopaque,
 					    "\nMerged arenas stats:\n");
+				}
+				stats_arena_print(write_cb, cbopaque, json,
+				    narenas, bins, large, huge);
+				if (json) {
+					malloc_cprintf(write_cb, cbopaque,
+					    "\t\t\t}%s\n", (ninitialized > 1) ?
+					    "," : "");
+				}
+			}
+
+			/* Unmerged stats. */
+			for (i = j = 0; i < narenas; i++) {
+				if (initialized[i]) {
+					if (json) {
+						j++;
+						malloc_cprintf(write_cb,
+						    cbopaque,
+						    "\t\t\t\"%u\": {\n", i);
+					} else {
+						malloc_cprintf(write_cb,
+						    cbopaque, "\narenas[%u]:\n",
+						    i);
+					}
 					stats_arena_print(write_cb, cbopaque,
-					    narenas, bins, large, huge);
+					    json, i, bins, large, huge);
+					if (json) {
+						malloc_cprintf(write_cb,
+						    cbopaque,
+						    "\t\t\t}%s\n", (j <
+						    ninitialized) ? "," : "");
+					}
 				}
 			}
 		}
 
-		if (unmerged) {
-			unsigned narenas;
+		if (json) {
+			malloc_cprintf(write_cb, cbopaque,
+			    "\t\t}\n");
+		}
+	}
+}
 
-			/* Print stats for each arena. */
+void
+stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
+    const char *opts)
+{
+	int err;
+	uint64_t epoch;
+	size_t u64sz;
+	bool json = false;
+	bool general = true;
+	bool merged = true;
+	bool unmerged = true;
+	bool bins = true;
+	bool large = true;
+	bool huge = true;
+
+	/*
+	 * Refresh stats, in case mallctl() was called by the application.
+	 *
+	 * Check for OOM here, since refreshing the ctl cache can trigger
+	 * allocation.  In practice, none of the subsequent mallctl()-related
+	 * calls in this function will cause OOM if this one succeeds.
+	 * */
+	epoch = 1;
+	u64sz = sizeof(uint64_t);
+	err = je_mallctl("epoch", (void *)&epoch, &u64sz, (void *)&epoch,
+	    sizeof(uint64_t));
+	if (err != 0) {
+		if (err == EAGAIN) {
+			malloc_write("<jemalloc>: Memory allocation failure in "
+			    "mallctl(\"epoch\", ...)\n");
+			return;
+		}
+		malloc_write("<jemalloc>: Failure in mallctl(\"epoch\", "
+		    "...)\n");
+		abort();
+	}
 
-			CTL_GET("arenas.narenas", &narenas, unsigned);
-			{
-				VARIABLE_ARRAY(bool, initialized, narenas);
-				size_t isz;
-				unsigned i;
-
-				isz = sizeof(bool) * narenas;
-				xmallctl("arenas.initialized", initialized,
-				    &isz, NULL, 0);
+	if (opts != NULL) {
+		unsigned i;
 
-				for (i = 0; i < narenas; i++) {
-					if (initialized[i]) {
-						malloc_cprintf(write_cb,
-						    cbopaque,
-						    "\narenas[%u]:\n", i);
-						stats_arena_print(write_cb,
-						    cbopaque, i, bins, large,
-						    huge);
-					}
-				}
+		for (i = 0; opts[i] != '\0'; i++) {
+			switch (opts[i]) {
+			case 'J':
+				json = true;
+				break;
+			case 'g':
+				general = false;
+				break;
+			case 'm':
+				merged = false;
+				break;
+			case 'a':
+				unmerged = false;
+				break;
+			case 'b':
+				bins = false;
+				break;
+			case 'l':
+				large = false;
+				break;
+			case 'h':
+				huge = false;
+				break;
+			default:;
 			}
 		}
 	}
-	malloc_cprintf(write_cb, cbopaque, "--- End jemalloc statistics ---\n");
+
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "{\n"
+		    "\t\"jemalloc\": {\n");
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "___ Begin jemalloc statistics ___\n");
+	}
+
+	if (general)
+		stats_general_print(write_cb, cbopaque, json, merged, unmerged);
+	if (config_stats) {
+		stats_print_helper(write_cb, cbopaque, json, merged, unmerged,
+		    bins, large, huge);
+	}
+	if (json) {
+		malloc_cprintf(write_cb, cbopaque,
+		    "\t}\n"
+		    "}\n");
+	} else {
+		malloc_cprintf(write_cb, cbopaque,
+		    "--- End jemalloc statistics ---\n");
+	}
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.d	2017-09-27 23:00:25.162935916 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.d	2017-09-27 23:02:01.118932399 +0800
@@ -1,18 +1,21 @@
 src/stats.o: src/stats.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.c	2017-01-31 23:32:23.000000000 +0800
@@ -7,29 +7,30 @@
 bool	opt_tcache = true;
 ssize_t	opt_lg_tcache_max = LG_TCACHE_MAXCLASS_DEFAULT;
 
 tcache_bin_info_t	*tcache_bin_info;
 static unsigned		stack_nelms; /* Total stack elms per tcache. */
 
-size_t			nhbins;
+unsigned		nhbins;
 size_t			tcache_maxclass;
 
 tcaches_t		*tcaches;
 
 /* Index of first element within tcaches that has never been used. */
 static unsigned		tcaches_past;
 
 /* Head of singly linked list tracking available tcaches elements. */
 static tcaches_t	*tcaches_avail;
 
 /******************************************************************************/
 
-size_t	tcache_salloc(const void *ptr)
+size_t
+tcache_salloc(tsdn_t *tsdn, const void *ptr)
 {
 
-	return (arena_salloc(ptr, false));
+	return (arena_salloc(tsdn, ptr, false));
 }
 
 void
 tcache_event_hard(tsd_t *tsd, tcache_t *tcache)
 {
 	szind_t binind = tcache->next_gc_bin;
@@ -64,26 +65,25 @@
 	}
 	tbin->low_water = tbin->ncached;
 
 	tcache->next_gc_bin++;
 	if (tcache->next_gc_bin == nhbins)
 		tcache->next_gc_bin = 0;
-	tcache->ev_cnt = 0;
 }
 
 void *
-tcache_alloc_small_hard(tsd_t *tsd, arena_t *arena, tcache_t *tcache,
-    tcache_bin_t *tbin, szind_t binind)
+tcache_alloc_small_hard(tsdn_t *tsdn, arena_t *arena, tcache_t *tcache,
+    tcache_bin_t *tbin, szind_t binind, bool *tcache_success)
 {
 	void *ret;
 
-	arena_tcache_fill_small(arena, tbin, binind, config_prof ?
+	arena_tcache_fill_small(tsdn, arena, tbin, binind, config_prof ?
 	    tcache->prof_accumbytes : 0);
 	if (config_prof)
 		tcache->prof_accumbytes = 0;
-	ret = tcache_alloc_easy(tbin);
+	ret = tcache_alloc_easy(tbin, tcache_success);
 
 	return (ret);
 }
 
 void
 tcache_bin_flush_small(tsd_t *tsd, tcache_t *tcache, tcache_bin_t *tbin,
@@ -99,70 +99,72 @@
 
 	arena = arena_choose(tsd, NULL);
 	assert(arena != NULL);
 	for (nflush = tbin->ncached - rem; nflush > 0; nflush = ndeferred) {
 		/* Lock the arena bin associated with the first object. */
 		arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(
-		    tbin->avail[0]);
+		    *(tbin->avail - 1));
 		arena_t *bin_arena = extent_node_arena_get(&chunk->node);
 		arena_bin_t *bin = &bin_arena->bins[binind];
 
 		if (config_prof && bin_arena == arena) {
-			if (arena_prof_accum(arena, tcache->prof_accumbytes))
-				prof_idump();
+			if (arena_prof_accum(tsd_tsdn(tsd), arena,
+			    tcache->prof_accumbytes))
+				prof_idump(tsd_tsdn(tsd));
 			tcache->prof_accumbytes = 0;
 		}
 
-		malloc_mutex_lock(&bin->lock);
+		malloc_mutex_lock(tsd_tsdn(tsd), &bin->lock);
 		if (config_stats && bin_arena == arena) {
 			assert(!merged_stats);
 			merged_stats = true;
 			bin->stats.nflushes++;
 			bin->stats.nrequests += tbin->tstats.nrequests;
 			tbin->tstats.nrequests = 0;
 		}
 		ndeferred = 0;
 		for (i = 0; i < nflush; i++) {
-			ptr = tbin->avail[i];
+			ptr = *(tbin->avail - 1 - i);
 			assert(ptr != NULL);
 			chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 			if (extent_node_arena_get(&chunk->node) == bin_arena) {
 				size_t pageind = ((uintptr_t)ptr -
 				    (uintptr_t)chunk) >> LG_PAGE;
 				arena_chunk_map_bits_t *bitselm =
-				    arena_bitselm_get(chunk, pageind);
-				arena_dalloc_bin_junked_locked(bin_arena, chunk,
-				    ptr, bitselm);
+				    arena_bitselm_get_mutable(chunk, pageind);
+				arena_dalloc_bin_junked_locked(tsd_tsdn(tsd),
+				    bin_arena, chunk, ptr, bitselm);
 			} else {
 				/*
 				 * This object was allocated via a different
 				 * arena bin than the one that is currently
 				 * locked.  Stash the object, so that it can be
 				 * handled in a future pass.
 				 */
-				tbin->avail[ndeferred] = ptr;
+				*(tbin->avail - 1 - ndeferred) = ptr;
 				ndeferred++;
 			}
 		}
-		malloc_mutex_unlock(&bin->lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), &bin->lock);
+		arena_decay_ticks(tsd_tsdn(tsd), bin_arena, nflush - ndeferred);
 	}
 	if (config_stats && !merged_stats) {
 		/*
 		 * The flush loop didn't happen to flush to this thread's
 		 * arena, so the stats didn't get merged.  Manually do so now.
 		 */
 		arena_bin_t *bin = &arena->bins[binind];
-		malloc_mutex_lock(&bin->lock);
+		malloc_mutex_lock(tsd_tsdn(tsd), &bin->lock);
 		bin->stats.nflushes++;
 		bin->stats.nrequests += tbin->tstats.nrequests;
 		tbin->tstats.nrequests = 0;
-		malloc_mutex_unlock(&bin->lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), &bin->lock);
 	}
 
-	memmove(tbin->avail, &tbin->avail[tbin->ncached - rem],
-	    rem * sizeof(void *));
+	memmove(tbin->avail - rem, tbin->avail - tbin->ncached, rem *
+	    sizeof(void *));
 	tbin->ncached = rem;
 	if ((int)tbin->ncached < tbin->low_water)
 		tbin->low_water = tbin->ncached;
 }
 
 void
@@ -179,19 +181,19 @@
 
 	arena = arena_choose(tsd, NULL);
 	assert(arena != NULL);
 	for (nflush = tbin->ncached - rem; nflush > 0; nflush = ndeferred) {
 		/* Lock the arena associated with the first object. */
 		arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(
-		    tbin->avail[0]);
+		    *(tbin->avail - 1));
 		arena_t *locked_arena = extent_node_arena_get(&chunk->node);
 		UNUSED bool idump;
 
 		if (config_prof)
 			idump = false;
-		malloc_mutex_lock(&locked_arena->lock);
+		malloc_mutex_lock(tsd_tsdn(tsd), &locked_arena->lock);
 		if ((config_prof || config_stats) && locked_arena == arena) {
 			if (config_prof) {
 				idump = arena_prof_accum_locked(arena,
 				    tcache->prof_accumbytes);
 				tcache->prof_accumbytes = 0;
 			}
@@ -203,99 +205,102 @@
 				    tbin->tstats.nrequests;
 				tbin->tstats.nrequests = 0;
 			}
 		}
 		ndeferred = 0;
 		for (i = 0; i < nflush; i++) {
-			ptr = tbin->avail[i];
+			ptr = *(tbin->avail - 1 - i);
 			assert(ptr != NULL);
 			chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
 			if (extent_node_arena_get(&chunk->node) ==
 			    locked_arena) {
-				arena_dalloc_large_junked_locked(locked_arena,
-				    chunk, ptr);
+				arena_dalloc_large_junked_locked(tsd_tsdn(tsd),
+				    locked_arena, chunk, ptr);
 			} else {
 				/*
 				 * This object was allocated via a different
 				 * arena than the one that is currently locked.
 				 * Stash the object, so that it can be handled
 				 * in a future pass.
 				 */
-				tbin->avail[ndeferred] = ptr;
+				*(tbin->avail - 1 - ndeferred) = ptr;
 				ndeferred++;
 			}
 		}
-		malloc_mutex_unlock(&locked_arena->lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), &locked_arena->lock);
 		if (config_prof && idump)
-			prof_idump();
+			prof_idump(tsd_tsdn(tsd));
+		arena_decay_ticks(tsd_tsdn(tsd), locked_arena, nflush -
+		    ndeferred);
 	}
 	if (config_stats && !merged_stats) {
 		/*
 		 * The flush loop didn't happen to flush to this thread's
 		 * arena, so the stats didn't get merged.  Manually do so now.
 		 */
-		malloc_mutex_lock(&arena->lock);
+		malloc_mutex_lock(tsd_tsdn(tsd), &arena->lock);
 		arena->stats.nrequests_large += tbin->tstats.nrequests;
 		arena->stats.lstats[binind - NBINS].nrequests +=
 		    tbin->tstats.nrequests;
 		tbin->tstats.nrequests = 0;
-		malloc_mutex_unlock(&arena->lock);
+		malloc_mutex_unlock(tsd_tsdn(tsd), &arena->lock);
 	}
 
-	memmove(tbin->avail, &tbin->avail[tbin->ncached - rem],
-	    rem * sizeof(void *));
+	memmove(tbin->avail - rem, tbin->avail - tbin->ncached, rem *
+	    sizeof(void *));
 	tbin->ncached = rem;
 	if ((int)tbin->ncached < tbin->low_water)
 		tbin->low_water = tbin->ncached;
 }
 
-void
-tcache_arena_associate(tcache_t *tcache, arena_t *arena)
+static void
+tcache_arena_associate(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena)
 {
 
 	if (config_stats) {
 		/* Link into list of extant tcaches. */
-		malloc_mutex_lock(&arena->lock);
+		malloc_mutex_lock(tsdn, &arena->lock);
 		ql_elm_new(tcache, link);
 		ql_tail_insert(&arena->tcache_ql, tcache, link);
-		malloc_mutex_unlock(&arena->lock);
+		malloc_mutex_unlock(tsdn, &arena->lock);
 	}
 }
 
-void
-tcache_arena_reassociate(tcache_t *tcache, arena_t *oldarena, arena_t *newarena)
-{
-
-	tcache_arena_dissociate(tcache, oldarena);
-	tcache_arena_associate(tcache, newarena);
-}
-
-void
-tcache_arena_dissociate(tcache_t *tcache, arena_t *arena)
+static void
+tcache_arena_dissociate(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena)
 {
 
 	if (config_stats) {
 		/* Unlink from list of extant tcaches. */
-		malloc_mutex_lock(&arena->lock);
+		malloc_mutex_lock(tsdn, &arena->lock);
 		if (config_debug) {
 			bool in_ql = false;
 			tcache_t *iter;
 			ql_foreach(iter, &arena->tcache_ql, link) {
 				if (iter == tcache) {
 					in_ql = true;
 					break;
 				}
 			}
 			assert(in_ql);
 		}
 		ql_remove(&arena->tcache_ql, tcache, link);
-		tcache_stats_merge(tcache, arena);
-		malloc_mutex_unlock(&arena->lock);
+		tcache_stats_merge(tsdn, tcache, arena);
+		malloc_mutex_unlock(tsdn, &arena->lock);
 	}
 }
 
+void
+tcache_arena_reassociate(tsdn_t *tsdn, tcache_t *tcache, arena_t *oldarena,
+    arena_t *newarena)
+{
+
+	tcache_arena_dissociate(tsdn, tcache, oldarena);
+	tcache_arena_associate(tsdn, tcache, newarena);
+}
+
 tcache_t *
 tcache_get_hard(tsd_t *tsd)
 {
 	arena_t *arena;
 
 	if (!tcache_enabled_get()) {
@@ -303,17 +308,17 @@
 			tcache_enabled_set(false); /* Memoize. */
 		return (NULL);
 	}
 	arena = arena_choose(tsd, NULL);
 	if (unlikely(arena == NULL))
 		return (NULL);
-	return (tcache_create(tsd, arena));
+	return (tcache_create(tsd_tsdn(tsd), arena));
 }
 
 tcache_t *
-tcache_create(tsd_t *tsd, arena_t *arena)
+tcache_create(tsdn_t *tsdn, arena_t *arena)
 {
 	tcache_t *tcache;
 	size_t size, stack_offset;
 	unsigned i;
 
 	size = offsetof(tcache_t, tbins) + (sizeof(tcache_bin_t) * nhbins);
@@ -321,68 +326,76 @@
 	size = PTR_CEILING(size);
 	stack_offset = size;
 	size += stack_nelms * sizeof(void *);
 	/* Avoid false cacheline sharing. */
 	size = sa2u(size, CACHELINE);
 
-	tcache = ipallocztm(tsd, size, CACHELINE, true, false, true, a0get());
+	tcache = ipallocztm(tsdn, size, CACHELINE, true, NULL, true,
+	    arena_get(TSDN_NULL, 0, true));
 	if (tcache == NULL)
 		return (NULL);
 
-	tcache_arena_associate(tcache, arena);
+	tcache_arena_associate(tsdn, tcache, arena);
+
+	ticker_init(&tcache->gc_ticker, TCACHE_GC_INCR);
 
 	assert((TCACHE_NSLOTS_SMALL_MAX & 1U) == 0);
 	for (i = 0; i < nhbins; i++) {
 		tcache->tbins[i].lg_fill_div = 1;
+		stack_offset += tcache_bin_info[i].ncached_max * sizeof(void *);
+		/*
+		 * avail points past the available space.  Allocations will
+		 * access the slots toward higher addresses (for the benefit of
+		 * prefetch).
+		 */
 		tcache->tbins[i].avail = (void **)((uintptr_t)tcache +
 		    (uintptr_t)stack_offset);
-		stack_offset += tcache_bin_info[i].ncached_max * sizeof(void *);
 	}
 
 	return (tcache);
 }
 
 static void
 tcache_destroy(tsd_t *tsd, tcache_t *tcache)
 {
 	arena_t *arena;
 	unsigned i;
 
 	arena = arena_choose(tsd, NULL);
-	tcache_arena_dissociate(tcache, arena);
+	tcache_arena_dissociate(tsd_tsdn(tsd), tcache, arena);
 
 	for (i = 0; i < NBINS; i++) {
 		tcache_bin_t *tbin = &tcache->tbins[i];
 		tcache_bin_flush_small(tsd, tcache, tbin, i, 0);
 
 		if (config_stats && tbin->tstats.nrequests != 0) {
 			arena_bin_t *bin = &arena->bins[i];
-			malloc_mutex_lock(&bin->lock);
+			malloc_mutex_lock(tsd_tsdn(tsd), &bin->lock);
 			bin->stats.nrequests += tbin->tstats.nrequests;
-			malloc_mutex_unlock(&bin->lock);
+			malloc_mutex_unlock(tsd_tsdn(tsd), &bin->lock);
 		}
 	}
 
 	for (; i < nhbins; i++) {
 		tcache_bin_t *tbin = &tcache->tbins[i];
 		tcache_bin_flush_large(tsd, tbin, i, 0, tcache);
 
 		if (config_stats && tbin->tstats.nrequests != 0) {
-			malloc_mutex_lock(&arena->lock);
+			malloc_mutex_lock(tsd_tsdn(tsd), &arena->lock);
 			arena->stats.nrequests_large += tbin->tstats.nrequests;
 			arena->stats.lstats[i - NBINS].nrequests +=
 			    tbin->tstats.nrequests;
-			malloc_mutex_unlock(&arena->lock);
+			malloc_mutex_unlock(tsd_tsdn(tsd), &arena->lock);
 		}
 	}
 
 	if (config_prof && tcache->prof_accumbytes > 0 &&
-	    arena_prof_accum(arena, tcache->prof_accumbytes))
-		prof_idump();
+	    arena_prof_accum(tsd_tsdn(tsd), arena, tcache->prof_accumbytes))
+		prof_idump(tsd_tsdn(tsd));
 
-	idalloctm(tsd, tcache, false, true);
+	idalloctm(tsd_tsdn(tsd), tcache, NULL, true, true);
 }
 
 void
 tcache_cleanup(tsd_t *tsd)
 {
 	tcache_t *tcache;
@@ -400,27 +413,28 @@
 tcache_enabled_cleanup(tsd_t *tsd)
 {
 
 	/* Do nothing. */
 }
 
-/* Caller must own arena->lock. */
 void
-tcache_stats_merge(tcache_t *tcache, arena_t *arena)
+tcache_stats_merge(tsdn_t *tsdn, tcache_t *tcache, arena_t *arena)
 {
 	unsigned i;
 
 	cassert(config_stats);
 
+	malloc_mutex_assert_owner(tsdn, &arena->lock);
+
 	/* Merge and reset tcache stats. */
 	for (i = 0; i < NBINS; i++) {
 		arena_bin_t *bin = &arena->bins[i];
 		tcache_bin_t *tbin = &tcache->tbins[i];
-		malloc_mutex_lock(&bin->lock);
+		malloc_mutex_lock(tsdn, &bin->lock);
 		bin->stats.nrequests += tbin->tstats.nrequests;
-		malloc_mutex_unlock(&bin->lock);
+		malloc_mutex_unlock(tsdn, &bin->lock);
 		tbin->tstats.nrequests = 0;
 	}
 
 	for (; i < nhbins; i++) {
 		malloc_large_stats_t *lstats = &arena->stats.lstats[i - NBINS];
 		tcache_bin_t *tbin = &tcache->tbins[i];
@@ -430,33 +444,37 @@
 	}
 }
 
 bool
 tcaches_create(tsd_t *tsd, unsigned *r_ind)
 {
+	arena_t *arena;
 	tcache_t *tcache;
 	tcaches_t *elm;
 
 	if (tcaches == NULL) {
-		tcaches = base_alloc(sizeof(tcache_t *) *
+		tcaches = base_alloc(tsd_tsdn(tsd), sizeof(tcache_t *) *
 		    (MALLOCX_TCACHE_MAX+1));
 		if (tcaches == NULL)
 			return (true);
 	}
 
 	if (tcaches_avail == NULL && tcaches_past > MALLOCX_TCACHE_MAX)
 		return (true);
-	tcache = tcache_create(tsd, a0get());
+	arena = arena_ichoose(tsd, NULL);
+	if (unlikely(arena == NULL))
+		return (true);
+	tcache = tcache_create(tsd_tsdn(tsd), arena);
 	if (tcache == NULL)
 		return (true);
 
 	if (tcaches_avail != NULL) {
 		elm = tcaches_avail;
 		tcaches_avail = tcaches_avail->next;
 		elm->tcache = tcache;
-		*r_ind = elm - tcaches;
+		*r_ind = (unsigned)(elm - tcaches);
 	} else {
 		elm = &tcaches[tcaches_past];
 		elm->tcache = tcache;
 		*r_ind = tcaches_past;
 		tcaches_past++;
 	}
@@ -488,31 +506,31 @@
 	tcaches_elm_flush(tsd, elm);
 	elm->next = tcaches_avail;
 	tcaches_avail = elm;
 }
 
 bool
-tcache_boot(void)
+tcache_boot(tsdn_t *tsdn)
 {
 	unsigned i;
 
 	/*
 	 * If necessary, clamp opt_lg_tcache_max, now that large_maxclass is
 	 * known.
 	 */
-	if (opt_lg_tcache_max < 0 || (1U << opt_lg_tcache_max) < SMALL_MAXCLASS)
+	if (opt_lg_tcache_max < 0 || (ZU(1) << opt_lg_tcache_max) < SMALL_MAXCLASS)
 		tcache_maxclass = SMALL_MAXCLASS;
-	else if ((1U << opt_lg_tcache_max) > large_maxclass)
+	else if ((ZU(1) << opt_lg_tcache_max) > large_maxclass)
 		tcache_maxclass = large_maxclass;
 	else
-		tcache_maxclass = (1U << opt_lg_tcache_max);
+		tcache_maxclass = (ZU(1) << opt_lg_tcache_max);
 
 	nhbins = size2index(tcache_maxclass) + 1;
 
 	/* Initialize tcache_bin_info. */
-	tcache_bin_info = (tcache_bin_info_t *)base_alloc(nhbins *
+	tcache_bin_info = (tcache_bin_info_t *)base_alloc(tsdn, nhbins *
 	    sizeof(tcache_bin_info_t));
 	if (tcache_bin_info == NULL)
 		return (true);
 	stack_nelms = 0;
 	for (i = 0; i < NBINS; i++) {
 		if ((arena_bin_info[i].nregs << 1) <= TCACHE_NSLOTS_SMALL_MIN) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.d	2017-09-27 23:00:25.486935904 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.d	2017-09-27 23:02:01.610932381 +0800
@@ -1,18 +1,21 @@
 src/tcache.o: src/tcache.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: ticker.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: ticker.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: ticker.d
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: ticker.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.c	2017-01-31 23:32:23.000000000 +0800
@@ -103,29 +103,31 @@
 		break;
 	default:
 		not_reached();
 	}
 }
 
-bool
+tsd_t *
 malloc_tsd_boot0(void)
 {
+	tsd_t *tsd;
 
 	ncleanups = 0;
 	if (tsd_boot0())
-		return (true);
-	*tsd_arenas_cache_bypassp_get(tsd_fetch()) = true;
-	return (false);
+		return (NULL);
+	tsd = tsd_fetch();
+	*tsd_arenas_tdata_bypassp_get(tsd) = true;
+	return (tsd);
 }
 
 void
 malloc_tsd_boot1(void)
 {
 
 	tsd_boot1();
-	*tsd_arenas_cache_bypassp_get(tsd_fetch()) = false;
+	*tsd_arenas_tdata_bypassp_get(tsd_fetch()) = false;
 }
 
 #ifdef _WIN32
 static BOOL WINAPI
 _tls_callback(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 {
@@ -145,49 +147,51 @@
 	return (true);
 }
 
 #ifdef _MSC_VER
 #  ifdef _M_IX86
 #    pragma comment(linker, "/INCLUDE:__tls_used")
+#    pragma comment(linker, "/INCLUDE:_tls_callback")
 #  else
 #    pragma comment(linker, "/INCLUDE:_tls_used")
+#    pragma comment(linker, "/INCLUDE:tls_callback")
 #  endif
 #  pragma section(".CRT$XLY",long,read)
 #endif
 JEMALLOC_SECTION(".CRT$XLY") JEMALLOC_ATTR(used)
-static BOOL	(WINAPI *const tls_callback)(HINSTANCE hinstDLL,
+BOOL	(WINAPI *const tls_callback)(HINSTANCE hinstDLL,
     DWORD fdwReason, LPVOID lpvReserved) = _tls_callback;
 #endif
 
 #if (!defined(JEMALLOC_MALLOC_THREAD_CLEANUP) && !defined(JEMALLOC_TLS) && \
     !defined(_WIN32))
 void *
 tsd_init_check_recursion(tsd_init_head_t *head, tsd_init_block_t *block)
 {
 	pthread_t self = pthread_self();
 	tsd_init_block_t *iter;
 
 	/* Check whether this thread has already inserted into the list. */
-	malloc_mutex_lock(&head->lock);
+	malloc_mutex_lock(TSDN_NULL, &head->lock);
 	ql_foreach(iter, &head->blocks, link) {
 		if (iter->thread == self) {
-			malloc_mutex_unlock(&head->lock);
+			malloc_mutex_unlock(TSDN_NULL, &head->lock);
 			return (iter->data);
 		}
 	}
 	/* Insert block into list. */
 	ql_elm_new(block, link);
 	block->thread = self;
 	ql_tail_insert(&head->blocks, block, link);
-	malloc_mutex_unlock(&head->lock);
+	malloc_mutex_unlock(TSDN_NULL, &head->lock);
 	return (NULL);
 }
 
 void
 tsd_init_finish(tsd_init_head_t *head, tsd_init_block_t *block)
 {
 
-	malloc_mutex_lock(&head->lock);
+	malloc_mutex_lock(TSDN_NULL, &head->lock);
 	ql_remove(&head->blocks, block, link);
-	malloc_mutex_unlock(&head->lock);
+	malloc_mutex_unlock(TSDN_NULL, &head->lock);
 }
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.d	2017-09-27 23:00:25.998935885 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.d	2017-09-27 23:02:01.842932373 +0800
@@ -1,18 +1,21 @@
 src/tsd.o: src/tsd.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,18 +1,23 @@
+/*
+ * Define simple versions of assertion macros that won't recurse in case
+ * of assertion failures in malloc_*printf().
+ */
 #define	assert(e) do {							\
 	if (config_debug && !(e)) {					\
 		malloc_write("<jemalloc>: Failed assertion\n");		\
 		abort();						\
 	}								\
 } while (0)
 
 #define	not_reached() do {						\
 	if (config_debug) {						\
 		malloc_write("<jemalloc>: Unreachable code reached\n");	\
 		abort();						\
 	}								\
+	unreachable();							\
 } while (0)
 
 #define	not_implemented() do {						\
 	if (config_debug) {						\
 		malloc_write("<jemalloc>: Not implemented\n");		\
 		abort();						\
@@ -41,21 +46,25 @@
 
 /* malloc_message() setup. */
 static void
 wrtmessage(void *cbopaque, const char *s)
 {
 
-#ifdef SYS_write
+#if defined(JEMALLOC_USE_SYSCALL) && defined(SYS_write)
 	/*
 	 * Use syscall(2) rather than write(2) when possible in order to avoid
 	 * the possibility of memory allocation within libc.  This is necessary
 	 * on FreeBSD; most operating systems do not have this problem though.
+	 *
+	 * syscall() returns long or int, depending on platform, so capture the
+	 * unused result in the widest plausible type to avoid compiler
+	 * warnings.
 	 */
-	UNUSED int result = syscall(SYS_write, STDERR_FILENO, s, strlen(s));
+	UNUSED long result = syscall(SYS_write, STDERR_FILENO, s, strlen(s));
 #else
-	UNUSED int result = write(STDERR_FILENO, s, strlen(s));
+	UNUSED ssize_t result = write(STDERR_FILENO, s, strlen(s));
 #endif
 }
 
 JEMALLOC_EXPORT void	(*je_malloc_message)(void *, const char *s);
 
 /*
@@ -79,13 +88,13 @@
 int
 buferror(int err, char *buf, size_t buflen)
 {
 
 #ifdef _WIN32
 	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err, 0,
-	    (LPSTR)buf, buflen, NULL);
+	    (LPSTR)buf, (DWORD)buflen, NULL);
 	return (0);
 #elif defined(__GLIBC__) && defined(_GNU_SOURCE)
 	char *b = strerror_r(err, buf, buflen);
 	if (b != buf) {
 		strncpy(buf, b, buflen);
 		buf[buflen-1] = '\0';
@@ -188,13 +197,13 @@
 			ret = UINTMAX_MAX;
 			goto label_return;
 		}
 		p++;
 	}
 	if (neg)
-		ret = -ret;
+		ret = (uintmax_t)(-((intmax_t)ret));
 
 	if (p == ns) {
 		/* No conversion performed. */
 		set_errno(EINVAL);
 		ret = UINTMAX_MAX;
 		goto label_return;
@@ -303,16 +312,15 @@
 		(*slen_p) += 2;
 		memcpy(s, uppercase ? "0X" : "0x", 2);
 	}
 	return (s);
 }
 
-int
+size_t
 malloc_vsnprintf(char *str, size_t size, const char *format, va_list ap)
 {
-	int ret;
 	size_t i;
 	const char *f;
 
 #define	APPEND_C(c) do {						\
 	if (i < size)							\
 		str[i] = (c);						\
@@ -397,12 +405,14 @@
 			bool left_justify = false;
 			bool plus_space = false;
 			bool plus_plus = false;
 			int prec = -1;
 			int width = -1;
 			unsigned char len = '?';
+			char *s;
+			size_t slen;
 
 			f++;
 			/* Flags. */
 			while (true) {
 				switch (*f) {
 				case '#':
@@ -487,14 +497,12 @@
 				f++;
 				break;
 			default: break;
 			}
 			/* Conversion specifier. */
 			switch (*f) {
-				char *s;
-				size_t slen;
 			case '%':
 				/* %% */
 				APPEND_C(*f);
 				f++;
 				break;
 			case 'd': case 'i': {
@@ -574,26 +582,25 @@
 	}
 	label_out:
 	if (i < size)
 		str[i] = '\0';
 	else
 		str[size - 1] = '\0';
-	ret = i;
 
 #undef APPEND_C
 #undef APPEND_S
 #undef APPEND_PADDED_S
 #undef GET_ARG_NUMERIC
-	return (ret);
+	return (i);
 }
 
 JEMALLOC_FORMAT_PRINTF(3, 4)
-int
+size_t
 malloc_snprintf(char *str, size_t size, const char *format, ...)
 {
-	int ret;
+	size_t ret;
 	va_list ap;
 
 	va_start(ap, format);
 	ret = malloc_vsnprintf(str, size, format, ap);
 	va_end(ap);
 
@@ -645,6 +652,15 @@
 	va_list ap;
 
 	va_start(ap, format);
 	malloc_vcprintf(NULL, NULL, format, ap);
 	va_end(ap);
 }
+
+/*
+ * Restore normal assertion macros, in order to make it possible to compile all
+ * C files as a single concatenation.
+ */
+#undef assert
+#undef not_reached
+#undef not_implemented
+#include "jemalloc/internal/assert.h"
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.d /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.d
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.d	2017-09-27 23:00:25.882935890 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.d	2017-09-27 23:02:02.246932358 +0800
@@ -1,18 +1,21 @@
 src/util.o: src/util.c include/jemalloc/internal/jemalloc_internal.h \
  include/jemalloc/internal/jemalloc_internal_defs.h \
  include/jemalloc/internal/jemalloc_internal_decls.h \
  include/jemalloc/internal/../jemalloc.h \
  include/jemalloc/internal/private_namespace.h \
- include/jemalloc/internal/rb.h include/jemalloc/internal/qr.h \
- include/jemalloc/internal/ql.h \
+ include/jemalloc/internal/ph.h include/jemalloc/internal/rb.h \
+ include/jemalloc/internal/qr.h include/jemalloc/internal/ql.h \
  include/jemalloc/internal/jemalloc_internal_macros.h \
- include/jemalloc/internal/valgrind.h include/jemalloc/internal/util.h \
- include/jemalloc/internal/atomic.h include/jemalloc/internal/prng.h \
+ include/jemalloc/internal/nstime.h include/jemalloc/internal/valgrind.h \
+ include/jemalloc/internal/util.h include/jemalloc/internal/assert.h \
+ include/jemalloc/internal/atomic.h include/jemalloc/internal/spin.h \
+ include/jemalloc/internal/prng.h include/jemalloc/internal/ticker.h \
  include/jemalloc/internal/ckh.h include/jemalloc/internal/size_classes.h \
- include/jemalloc/internal/stats.h include/jemalloc/internal/ctl.h \
+ include/jemalloc/internal/smoothstep.h include/jemalloc/internal/stats.h \
+ include/jemalloc/internal/ctl.h include/jemalloc/internal/witness.h \
  include/jemalloc/internal/mutex.h include/jemalloc/internal/tsd.h \
  include/jemalloc/internal/mb.h include/jemalloc/internal/extent.h \
  include/jemalloc/internal/arena.h include/jemalloc/internal/bitmap.h \
  include/jemalloc/internal/base.h include/jemalloc/internal/rtree.h \
  include/jemalloc/internal/pages.h include/jemalloc/internal/chunk.h \
  include/jemalloc/internal/chunk_dss.h \
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: witness.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: witness.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: witness.d
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src: witness.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/zone.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/zone.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/zone.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/zone.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,23 +1,24 @@
 #include "jemalloc/internal/jemalloc_internal.h"
 #ifndef JEMALLOC_ZONE
 #  error "This source file is for zones on Darwin (OS X)."
 #endif
 
 /*
- * The malloc_default_purgeable_zone function is only available on >= 10.6.
+ * The malloc_default_purgeable_zone() function is only available on >= 10.6.
  * We need to check whether it is present at runtime, thus the weak_import.
  */
 extern malloc_zone_t *malloc_default_purgeable_zone(void)
 JEMALLOC_ATTR(weak_import);
 
 /******************************************************************************/
 /* Data. */
 
-static malloc_zone_t zone;
-static struct malloc_introspection_t zone_introspect;
+static malloc_zone_t *default_zone, *purgeable_zone;
+static malloc_zone_t jemalloc_zone;
+static struct malloc_introspection_t jemalloc_zone_introspect;
 
 /******************************************************************************/
 /* Function prototypes for non-inline static functions. */
 
 static size_t	zone_size(malloc_zone_t *zone, void *ptr);
 static void	*zone_malloc(malloc_zone_t *zone, size_t size);
@@ -53,13 +54,13 @@
 	 * we knew that all pointers were owned by *some* zone, we could split
 	 * our zone into two parts, and use one as the default allocator and
 	 * the other as the default deallocator/reallocator.  Since that will
 	 * not work in practice, we must check all pointers to assure that they
 	 * reside within a mapped chunk before determining size.
 	 */
-	return (ivsalloc(ptr, config_prof));
+	return (ivsalloc(tsdn_fetch(), ptr, config_prof));
 }
 
 static void *
 zone_malloc(malloc_zone_t *zone, size_t size)
 {
 
@@ -84,25 +85,25 @@
 }
 
 static void
 zone_free(malloc_zone_t *zone, void *ptr)
 {
 
-	if (ivsalloc(ptr, config_prof) != 0) {
+	if (ivsalloc(tsdn_fetch(), ptr, config_prof) != 0) {
 		je_free(ptr);
 		return;
 	}
 
 	free(ptr);
 }
 
 static void *
 zone_realloc(malloc_zone_t *zone, void *ptr, size_t size)
 {
 
-	if (ivsalloc(ptr, config_prof) != 0)
+	if (ivsalloc(tsdn_fetch(), ptr, config_prof) != 0)
 		return (je_realloc(ptr, size));
 
 	return (realloc(ptr, size));
 }
 
 #if (JEMALLOC_ZONE_VERSION >= 5)
@@ -118,15 +119,17 @@
 #endif
 
 #if (JEMALLOC_ZONE_VERSION >= 6)
 static void
 zone_free_definite_size(malloc_zone_t *zone, void *ptr, size_t size)
 {
+	size_t alloc_size;
 
-	if (ivsalloc(ptr, config_prof) != 0) {
-		assert(ivsalloc(ptr, config_prof) == size);
+	alloc_size = ivsalloc(tsdn_fetch(), ptr, config_prof);
+	if (alloc_size != 0) {
+		assert(alloc_size == size);
 		je_free(ptr);
 		return;
 	}
 
 	free(ptr);
 }
@@ -159,95 +162,109 @@
 }
 
 static void
 zone_force_unlock(malloc_zone_t *zone)
 {
 
+	/*
+	 * Call jemalloc_postfork_child() rather than
+	 * jemalloc_postfork_parent(), because this function is executed by both
+	 * parent and child.  The parent can tolerate having state
+	 * reinitialized, but the child cannot unlock mutexes that were locked
+	 * by the parent.
+	 */
 	if (isthreaded)
-		jemalloc_postfork_parent();
+		jemalloc_postfork_child();
 }
 
-JEMALLOC_ATTR(constructor)
-void
-register_zone(void)
+static void
+zone_init(void)
 {
 
-	/*
-	 * If something else replaced the system default zone allocator, don't
-	 * register jemalloc's.
-	 */
-	malloc_zone_t *default_zone = malloc_default_zone();
-	malloc_zone_t *purgeable_zone = NULL;
-	if (!default_zone->zone_name ||
-	    strcmp(default_zone->zone_name, "DefaultMallocZone") != 0) {
-		return;
-	}
-
-	zone.size = (void *)zone_size;
-	zone.malloc = (void *)zone_malloc;
-	zone.calloc = (void *)zone_calloc;
-	zone.valloc = (void *)zone_valloc;
-	zone.free = (void *)zone_free;
-	zone.realloc = (void *)zone_realloc;
-	zone.destroy = (void *)zone_destroy;
-	zone.zone_name = "jemalloc_zone";
-	zone.batch_malloc = NULL;
-	zone.batch_free = NULL;
-	zone.introspect = &zone_introspect;
-	zone.version = JEMALLOC_ZONE_VERSION;
+	jemalloc_zone.size = (void *)zone_size;
+	jemalloc_zone.malloc = (void *)zone_malloc;
+	jemalloc_zone.calloc = (void *)zone_calloc;
+	jemalloc_zone.valloc = (void *)zone_valloc;
+	jemalloc_zone.free = (void *)zone_free;
+	jemalloc_zone.realloc = (void *)zone_realloc;
+	jemalloc_zone.destroy = (void *)zone_destroy;
+	jemalloc_zone.zone_name = "jemalloc_zone";
+	jemalloc_zone.batch_malloc = NULL;
+	jemalloc_zone.batch_free = NULL;
+	jemalloc_zone.introspect = &jemalloc_zone_introspect;
+	jemalloc_zone.version = JEMALLOC_ZONE_VERSION;
 #if (JEMALLOC_ZONE_VERSION >= 5)
-	zone.memalign = zone_memalign;
+	jemalloc_zone.memalign = zone_memalign;
 #endif
 #if (JEMALLOC_ZONE_VERSION >= 6)
-	zone.free_definite_size = zone_free_definite_size;
+	jemalloc_zone.free_definite_size = zone_free_definite_size;
 #endif
 #if (JEMALLOC_ZONE_VERSION >= 8)
-	zone.pressure_relief = NULL;
+	jemalloc_zone.pressure_relief = NULL;
 #endif
 
-	zone_introspect.enumerator = NULL;
-	zone_introspect.good_size = (void *)zone_good_size;
-	zone_introspect.check = NULL;
-	zone_introspect.print = NULL;
-	zone_introspect.log = NULL;
-	zone_introspect.force_lock = (void *)zone_force_lock;
-	zone_introspect.force_unlock = (void *)zone_force_unlock;
-	zone_introspect.statistics = NULL;
+	jemalloc_zone_introspect.enumerator = NULL;
+	jemalloc_zone_introspect.good_size = (void *)zone_good_size;
+	jemalloc_zone_introspect.check = NULL;
+	jemalloc_zone_introspect.print = NULL;
+	jemalloc_zone_introspect.log = NULL;
+	jemalloc_zone_introspect.force_lock = (void *)zone_force_lock;
+	jemalloc_zone_introspect.force_unlock = (void *)zone_force_unlock;
+	jemalloc_zone_introspect.statistics = NULL;
 #if (JEMALLOC_ZONE_VERSION >= 6)
-	zone_introspect.zone_locked = NULL;
+	jemalloc_zone_introspect.zone_locked = NULL;
 #endif
 #if (JEMALLOC_ZONE_VERSION >= 7)
-	zone_introspect.enable_discharge_checking = NULL;
-	zone_introspect.disable_discharge_checking = NULL;
-	zone_introspect.discharge = NULL;
-#ifdef __BLOCKS__
-	zone_introspect.enumerate_discharged_pointers = NULL;
-#else
-	zone_introspect.enumerate_unavailable_without_blocks = NULL;
-#endif
+	jemalloc_zone_introspect.enable_discharge_checking = NULL;
+	jemalloc_zone_introspect.disable_discharge_checking = NULL;
+	jemalloc_zone_introspect.discharge = NULL;
+#  ifdef __BLOCKS__
+	jemalloc_zone_introspect.enumerate_discharged_pointers = NULL;
+#  else
+	jemalloc_zone_introspect.enumerate_unavailable_without_blocks = NULL;
+#  endif
 #endif
+}
+
+static malloc_zone_t *
+zone_default_get(void)
+{
+	malloc_zone_t **zones = NULL;
+	unsigned int num_zones = 0;
 
 	/*
-	 * The default purgeable zone is created lazily by OSX's libc.  It uses
-	 * the default zone when it is created for "small" allocations
-	 * (< 15 KiB), but assumes the default zone is a scalable_zone.  This
-	 * obviously fails when the default zone is the jemalloc zone, so
-	 * malloc_default_purgeable_zone is called beforehand so that the
-	 * default purgeable zone is created when the default zone is still
-	 * a scalable_zone.  As purgeable zones only exist on >= 10.6, we need
-	 * to check for the existence of malloc_default_purgeable_zone() at
-	 * run time.
+	 * On OSX 10.12, malloc_default_zone returns a special zone that is not
+	 * present in the list of registered zones. That zone uses a "lite zone"
+	 * if one is present (apparently enabled when malloc stack logging is
+	 * enabled), or the first registered zone otherwise. In practice this
+	 * means unless malloc stack logging is enabled, the first registered
+	 * zone is the default.  So get the list of zones to get the first one,
+	 * instead of relying on malloc_default_zone.
 	 */
-	if (malloc_default_purgeable_zone != NULL)
-		purgeable_zone = malloc_default_purgeable_zone();
+	if (KERN_SUCCESS != malloc_get_all_zones(0, NULL,
+	    (vm_address_t**)&zones, &num_zones)) {
+		/*
+		 * Reset the value in case the failure happened after it was
+		 * set.
+		 */
+		num_zones = 0;
+	}
 
-	/* Register the custom zone.  At this point it won't be the default. */
-	malloc_zone_register(&zone);
+	if (num_zones)
+		return (zones[0]);
+
+	return (malloc_default_zone());
+}
+
+/* As written, this function can only promote jemalloc_zone. */
+static void
+zone_promote(void)
+{
+	malloc_zone_t *zone;
 
 	do {
-		default_zone = malloc_default_zone();
 		/*
 		 * Unregister and reregister the default zone.  On OSX >= 10.6,
 		 * unregistering takes the last registered zone and places it
 		 * at the location of the specified zone.  Unregistering the
 		 * default zone thus makes the last registered one the default.
 		 * On OSX < 10.6, unregistering shifts all registered zones.
@@ -263,12 +281,50 @@
 		 * after the default zone.  On OSX < 10.6, there is no purgeable
 		 * zone, so this does nothing.  On OSX >= 10.6, unregistering
 		 * replaces the purgeable zone with the last registered zone
 		 * above, i.e. the default zone.  Registering it again then puts
 		 * it at the end, obviously after the default zone.
 		 */
-		if (purgeable_zone) {
+		if (purgeable_zone != NULL) {
 			malloc_zone_unregister(purgeable_zone);
 			malloc_zone_register(purgeable_zone);
 		}
-	} while (malloc_default_zone() != &zone);
+
+		zone = zone_default_get();
+	} while (zone != &jemalloc_zone);
+}
+
+JEMALLOC_ATTR(constructor)
+void
+zone_register(void)
+{
+
+	/*
+	 * If something else replaced the system default zone allocator, don't
+	 * register jemalloc's.
+	 */
+	default_zone = zone_default_get();
+	if (!default_zone->zone_name || strcmp(default_zone->zone_name,
+	    "DefaultMallocZone") != 0)
+		return;
+
+	/*
+	 * The default purgeable zone is created lazily by OSX's libc.  It uses
+	 * the default zone when it is created for "small" allocations
+	 * (< 15 KiB), but assumes the default zone is a scalable_zone.  This
+	 * obviously fails when the default zone is the jemalloc zone, so
+	 * malloc_default_purgeable_zone() is called beforehand so that the
+	 * default purgeable zone is created when the default zone is still
+	 * a scalable_zone.  As purgeable zones only exist on >= 10.6, we need
+	 * to check for the existence of malloc_default_purgeable_zone() at
+	 * run time.
+	 */
+	purgeable_zone = (malloc_default_purgeable_zone == NULL) ? NULL :
+	    malloc_default_purgeable_zone();
+
+	/* Register the custom zone.  At this point it won't be the default. */
+	zone_init();
+	malloc_zone_register(&jemalloc_zone);
+
+	/* Promote the custom zone to be default. */
+	zone_promote();
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/jemalloc_test.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/jemalloc_test.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/jemalloc_test.h	2017-09-27 23:00:17.466936198 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/jemalloc_test.h	2017-09-27 23:01:52.454932717 +0800
@@ -8,54 +8,20 @@
 #include <errno.h>
 #include <math.h>
 #include <string.h>
 #ifdef _WIN32
 #  include "msvc_compat/strings.h"
 #endif
-#include <sys/time.h>
 
 #ifdef _WIN32
 #  include <windows.h>
 #  include "msvc_compat/windows_extra.h"
 #else
 #  include <pthread.h>
 #endif
 
-/******************************************************************************/
-/*
- * Define always-enabled assertion macros, so that test assertions execute even
- * if assertions are disabled in the library code.  These definitions must
- * exist prior to including "jemalloc/internal/util.h".
- */
-#define	assert(e) do {							\
-	if (!(e)) {							\
-		malloc_printf(						\
-		    "<jemalloc>: %s:%d: Failed assertion: \"%s\"\n",	\
-		    __FILE__, __LINE__, #e);				\
-		abort();						\
-	}								\
-} while (0)
-
-#define	not_reached() do {						\
-	malloc_printf(							\
-	    "<jemalloc>: %s:%d: Unreachable code reached\n",		\
-	    __FILE__, __LINE__);					\
-	abort();							\
-} while (0)
-
-#define	not_implemented() do {						\
-	malloc_printf("<jemalloc>: %s:%d: Not implemented\n",		\
-	    __FILE__, __LINE__);					\
-	abort();							\
-} while (0)
-
-#define	assert_not_implemented(e) do {					\
-	if (!(e))							\
-		not_implemented();					\
-} while (0)
-
 #include "test/jemalloc_test_defs.h"
 
 #ifdef JEMALLOC_OSSPIN
 #  include <libkern/OSAtomic.h>
 #endif
 
@@ -84,19 +50,28 @@
 #elif defined(JEMALLOC_INTEGRATION_TEST)
 #  define JEMALLOC_MANGLE
 #  include "jemalloc/jemalloc.h"
 #  include "jemalloc/internal/jemalloc_internal_defs.h"
 #  include "jemalloc/internal/jemalloc_internal_macros.h"
 
+static const bool config_debug =
+#ifdef JEMALLOC_DEBUG
+    true
+#else
+    false
+#endif
+    ;
+
 #  define JEMALLOC_N(n) je_##n
 #  include "jemalloc/internal/private_namespace.h"
 
 #  define JEMALLOC_H_TYPES
 #  define JEMALLOC_H_STRUCTS
 #  define JEMALLOC_H_EXTERNS
 #  define JEMALLOC_H_INLINES
+#  include "jemalloc/internal/nstime.h"
 #  include "jemalloc/internal/util.h"
 #  include "jemalloc/internal/qr.h"
 #  include "jemalloc/internal/ql.h"
 #  undef JEMALLOC_H_TYPES
 #  undef JEMALLOC_H_STRUCTS
 #  undef JEMALLOC_H_EXTERNS
@@ -146,6 +121,43 @@
 #include "test/mq.h"
 #include "test/test.h"
 #include "test/timer.h"
 #include "test/thd.h"
 #define	MEXP 19937
 #include "test/SFMT.h"
+
+/******************************************************************************/
+/*
+ * Define always-enabled assertion macros, so that test assertions execute even
+ * if assertions are disabled in the library code.
+ */
+#undef assert
+#undef not_reached
+#undef not_implemented
+#undef assert_not_implemented
+
+#define	assert(e) do {							\
+	if (!(e)) {							\
+		malloc_printf(						\
+		    "<jemalloc>: %s:%d: Failed assertion: \"%s\"\n",	\
+		    __FILE__, __LINE__, #e);				\
+		abort();						\
+	}								\
+} while (0)
+
+#define	not_reached() do {						\
+	malloc_printf(							\
+	    "<jemalloc>: %s:%d: Unreachable code reached\n",		\
+	    __FILE__, __LINE__);					\
+	abort();							\
+} while (0)
+
+#define	not_implemented() do {						\
+	malloc_printf("<jemalloc>: %s:%d: Not implemented\n",		\
+	    __FILE__, __LINE__);					\
+	abort();							\
+} while (0)
+
+#define	assert_not_implemented(e) do {					\
+	if (!(e))							\
+		not_implemented();					\
+} while (0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/jemalloc_test.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/jemalloc_test.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/jemalloc_test.h.in	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/jemalloc_test.h.in	2017-01-31 23:32:23.000000000 +0800
@@ -8,54 +8,20 @@
 #include <errno.h>
 #include <math.h>
 #include <string.h>
 #ifdef _WIN32
 #  include "msvc_compat/strings.h"
 #endif
-#include <sys/time.h>
 
 #ifdef _WIN32
 #  include <windows.h>
 #  include "msvc_compat/windows_extra.h"
 #else
 #  include <pthread.h>
 #endif
 
-/******************************************************************************/
-/*
- * Define always-enabled assertion macros, so that test assertions execute even
- * if assertions are disabled in the library code.  These definitions must
- * exist prior to including "jemalloc/internal/util.h".
- */
-#define	assert(e) do {							\
-	if (!(e)) {							\
-		malloc_printf(						\
-		    "<jemalloc>: %s:%d: Failed assertion: \"%s\"\n",	\
-		    __FILE__, __LINE__, #e);				\
-		abort();						\
-	}								\
-} while (0)
-
-#define	not_reached() do {						\
-	malloc_printf(							\
-	    "<jemalloc>: %s:%d: Unreachable code reached\n",		\
-	    __FILE__, __LINE__);					\
-	abort();							\
-} while (0)
-
-#define	not_implemented() do {						\
-	malloc_printf("<jemalloc>: %s:%d: Not implemented\n",		\
-	    __FILE__, __LINE__);					\
-	abort();							\
-} while (0)
-
-#define	assert_not_implemented(e) do {					\
-	if (!(e))							\
-		not_implemented();					\
-} while (0)
-
 #include "test/jemalloc_test_defs.h"
 
 #ifdef JEMALLOC_OSSPIN
 #  include <libkern/OSAtomic.h>
 #endif
 
@@ -84,19 +50,28 @@
 #elif defined(JEMALLOC_INTEGRATION_TEST)
 #  define JEMALLOC_MANGLE
 #  include "jemalloc/jemalloc@install_suffix@.h"
 #  include "jemalloc/internal/jemalloc_internal_defs.h"
 #  include "jemalloc/internal/jemalloc_internal_macros.h"
 
+static const bool config_debug =
+#ifdef JEMALLOC_DEBUG
+    true
+#else
+    false
+#endif
+    ;
+
 #  define JEMALLOC_N(n) @private_namespace@##n
 #  include "jemalloc/internal/private_namespace.h"
 
 #  define JEMALLOC_H_TYPES
 #  define JEMALLOC_H_STRUCTS
 #  define JEMALLOC_H_EXTERNS
 #  define JEMALLOC_H_INLINES
+#  include "jemalloc/internal/nstime.h"
 #  include "jemalloc/internal/util.h"
 #  include "jemalloc/internal/qr.h"
 #  include "jemalloc/internal/ql.h"
 #  undef JEMALLOC_H_TYPES
 #  undef JEMALLOC_H_STRUCTS
 #  undef JEMALLOC_H_EXTERNS
@@ -146,6 +121,43 @@
 #include "test/mq.h"
 #include "test/test.h"
 #include "test/timer.h"
 #include "test/thd.h"
 #define	MEXP 19937
 #include "test/SFMT.h"
+
+/******************************************************************************/
+/*
+ * Define always-enabled assertion macros, so that test assertions execute even
+ * if assertions are disabled in the library code.
+ */
+#undef assert
+#undef not_reached
+#undef not_implemented
+#undef assert_not_implemented
+
+#define	assert(e) do {							\
+	if (!(e)) {							\
+		malloc_printf(						\
+		    "<jemalloc>: %s:%d: Failed assertion: \"%s\"\n",	\
+		    __FILE__, __LINE__, #e);				\
+		abort();						\
+	}								\
+} while (0)
+
+#define	not_reached() do {						\
+	malloc_printf(							\
+	    "<jemalloc>: %s:%d: Unreachable code reached\n",		\
+	    __FILE__, __LINE__);					\
+	abort();							\
+} while (0)
+
+#define	not_implemented() do {						\
+	malloc_printf("<jemalloc>: %s:%d: Not implemented\n",		\
+	    __FILE__, __LINE__);					\
+	abort();							\
+} while (0)
+
+#define	assert_not_implemented(e) do {					\
+	if (!(e))							\
+		not_implemented();					\
+} while (0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/mtx.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/mtx.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/mtx.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/mtx.h	2017-01-31 23:32:23.000000000 +0800
@@ -5,12 +5,14 @@
  * in tests.
  */
 
 typedef struct {
 #ifdef _WIN32
 	CRITICAL_SECTION	lock;
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
+	os_unfair_lock		lock;
 #elif (defined(JEMALLOC_OSSPIN))
 	OSSpinLock		lock;
 #else
 	pthread_mutex_t		lock;
 #endif
 } mtx_t;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/test.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/test.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/test.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/test.h	2017-01-31 23:32:23.000000000 +0800
@@ -308,12 +308,15 @@
 	p_test_fini();							\
 }
 
 #define	test(...)							\
 	p_test(__VA_ARGS__, NULL)
 
+#define	test_no_malloc_init(...)					\
+	p_test_no_malloc_init(__VA_ARGS__, NULL)
+
 #define	test_skip_if(e) do {						\
 	if (e) {							\
 		test_skip("%s:%s:%d: Test skipped: (%s)",		\
 		    __func__, __FILE__, __LINE__, #e);			\
 		goto label_test_end;					\
 	}								\
@@ -321,9 +324,10 @@
 
 void	test_skip(const char *format, ...) JEMALLOC_FORMAT_PRINTF(1, 2);
 void	test_fail(const char *format, ...) JEMALLOC_FORMAT_PRINTF(1, 2);
 
 /* For private use by macros. */
 test_status_t	p_test(test_t *t, ...);
+test_status_t	p_test_no_malloc_init(test_t *t, ...);
 void	p_test_init(const char *name);
 void	p_test_fini(void);
 void	p_test_fail(const char *prefix, const char *message);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/timer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/timer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/include/test/timer.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/include/test/timer.h	2017-01-31 23:32:23.000000000 +0800
@@ -1,26 +1,11 @@
 /* Simple timer, for use in benchmark reporting. */
 
-#include <unistd.h>
-#include <sys/time.h>
-
-#define JEMALLOC_CLOCK_GETTIME defined(_POSIX_MONOTONIC_CLOCK) \
-    && _POSIX_MONOTONIC_CLOCK >= 0
-
 typedef struct {
-#ifdef _WIN32
-	FILETIME ft0;
-	FILETIME ft1;
-#elif JEMALLOC_CLOCK_GETTIME
-	struct timespec ts0;
-	struct timespec ts1;
-	int clock_id;
-#else
-	struct timeval tv0;
-	struct timeval tv1;
-#endif
+	nstime_t t0;
+	nstime_t t1;
 } timedelta_t;
 
 void	timer_start(timedelta_t *timer);
 void	timer_stop(timedelta_t *timer);
 uint64_t	timer_usec(const timedelta_t *timer);
 void	timer_ratio(timedelta_t *a, timedelta_t *b, char *buf, size_t buflen);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/aligned_alloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/aligned_alloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/aligned_alloc.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/aligned_alloc.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,12 +1,23 @@
 #include "test/jemalloc_test.h"
 
 #define	CHUNK 0x400000
-/* #define MAXALIGN ((size_t)UINT64_C(0x80000000000)) */
-#define	MAXALIGN ((size_t)0x2000000LU)
-#define	NITER 4
+#define	MAXALIGN (((size_t)1) << 23)
+
+/*
+ * On systems which can't merge extents, tests that call this function generate
+ * a lot of dirty memory very quickly.  Purging between cycles mitigates
+ * potential OOM on e.g. 32-bit Windows.
+ */
+static void
+purge(void)
+{
+
+	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
+	    "Unexpected mallctl error");
+}
 
 TEST_BEGIN(test_alignment_errors)
 {
 	size_t alignment;
 	void *p;
 
@@ -71,12 +82,13 @@
 	    alignment, size);
 }
 TEST_END
 
 TEST_BEGIN(test_alignment_and_size)
 {
+#define	NITER 4
 	size_t alignment, size, total;
 	unsigned i;
 	void *ps[NITER];
 
 	for (i = 0; i < NITER; i++)
 		ps[i] = NULL;
@@ -107,13 +119,15 @@
 				if (ps[i] != NULL) {
 					free(ps[i]);
 					ps[i] = NULL;
 				}
 			}
 		}
+		purge();
 	}
+#undef NITER
 }
 TEST_END
 
 int
 main(void)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/allocated.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/allocated.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/allocated.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/allocated.c	2017-01-31 23:32:23.000000000 +0800
@@ -15,38 +15,39 @@
 	void *p;
 	uint64_t a0, a1, d0, d1;
 	uint64_t *ap0, *ap1, *dp0, *dp1;
 	size_t sz, usize;
 
 	sz = sizeof(a0);
-	if ((err = mallctl("thread.allocated", &a0, &sz, NULL, 0))) {
+	if ((err = mallctl("thread.allocated", (void *)&a0, &sz, NULL, 0))) {
 		if (err == ENOENT)
 			goto label_ENOENT;
 		test_fail("%s(): Error in mallctl(): %s", __func__,
 		    strerror(err));
 	}
 	sz = sizeof(ap0);
-	if ((err = mallctl("thread.allocatedp", &ap0, &sz, NULL, 0))) {
+	if ((err = mallctl("thread.allocatedp", (void *)&ap0, &sz, NULL, 0))) {
 		if (err == ENOENT)
 			goto label_ENOENT;
 		test_fail("%s(): Error in mallctl(): %s", __func__,
 		    strerror(err));
 	}
 	assert_u64_eq(*ap0, a0,
 	    "\"thread.allocatedp\" should provide a pointer to internal "
 	    "storage");
 
 	sz = sizeof(d0);
-	if ((err = mallctl("thread.deallocated", &d0, &sz, NULL, 0))) {
+	if ((err = mallctl("thread.deallocated", (void *)&d0, &sz, NULL, 0))) {
 		if (err == ENOENT)
 			goto label_ENOENT;
 		test_fail("%s(): Error in mallctl(): %s", __func__,
 		    strerror(err));
 	}
 	sz = sizeof(dp0);
-	if ((err = mallctl("thread.deallocatedp", &dp0, &sz, NULL, 0))) {
+	if ((err = mallctl("thread.deallocatedp", (void *)&dp0, &sz, NULL,
+	    0))) {
 		if (err == ENOENT)
 			goto label_ENOENT;
 		test_fail("%s(): Error in mallctl(): %s", __func__,
 		    strerror(err));
 	}
 	assert_u64_eq(*dp0, d0,
@@ -54,15 +55,15 @@
 	    "storage");
 
 	p = malloc(1);
 	assert_ptr_not_null(p, "Unexpected malloc() error");
 
 	sz = sizeof(a1);
-	mallctl("thread.allocated", &a1, &sz, NULL, 0);
+	mallctl("thread.allocated", (void *)&a1, &sz, NULL, 0);
 	sz = sizeof(ap1);
-	mallctl("thread.allocatedp", &ap1, &sz, NULL, 0);
+	mallctl("thread.allocatedp", (void *)&ap1, &sz, NULL, 0);
 	assert_u64_eq(*ap1, a1,
 	    "Dereferenced \"thread.allocatedp\" value should equal "
 	    "\"thread.allocated\" value");
 	assert_ptr_eq(ap0, ap1,
 	    "Pointer returned by \"thread.allocatedp\" should not change");
 
@@ -71,15 +72,15 @@
 	    "Allocated memory counter should increase by at least the amount "
 	    "explicitly allocated");
 
 	free(p);
 
 	sz = sizeof(d1);
-	mallctl("thread.deallocated", &d1, &sz, NULL, 0);
+	mallctl("thread.deallocated", (void *)&d1, &sz, NULL, 0);
 	sz = sizeof(dp1);
-	mallctl("thread.deallocatedp", &dp1, &sz, NULL, 0);
+	mallctl("thread.deallocatedp", (void *)&dp1, &sz, NULL, 0);
 	assert_u64_eq(*dp1, d1,
 	    "Dereferenced \"thread.deallocatedp\" value should equal "
 	    "\"thread.deallocated\" value");
 	assert_ptr_eq(dp0, dp1,
 	    "Pointer returned by \"thread.deallocatedp\" should not change");
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/chunk.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/chunk.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/chunk.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/chunk.c	2017-01-31 23:32:23.000000000 +0800
@@ -118,28 +118,42 @@
 }
 
 TEST_BEGIN(test_chunk)
 {
 	void *p;
 	size_t old_size, new_size, large0, large1, huge0, huge1, huge2, sz;
+	unsigned arena_ind;
+	int flags;
+	size_t hooks_mib[3], purge_mib[3];
+	size_t hooks_miblen, purge_miblen;
 	chunk_hooks_t new_hooks = {
 		chunk_alloc,
 		chunk_dalloc,
 		chunk_commit,
 		chunk_decommit,
 		chunk_purge,
 		chunk_split,
 		chunk_merge
 	};
 	bool xallocx_success_a, xallocx_success_b, xallocx_success_c;
 
+	sz = sizeof(unsigned);
+	assert_d_eq(mallctl("arenas.extend", (void *)&arena_ind, &sz, NULL, 0),
+	    0, "Unexpected mallctl() failure");
+	flags = MALLOCX_ARENA(arena_ind) | MALLOCX_TCACHE_NONE;
+
 	/* Install custom chunk hooks. */
+	hooks_miblen = sizeof(hooks_mib)/sizeof(size_t);
+	assert_d_eq(mallctlnametomib("arena.0.chunk_hooks", hooks_mib,
+	    &hooks_miblen), 0, "Unexpected mallctlnametomib() failure");
+	hooks_mib[1] = (size_t)arena_ind;
 	old_size = sizeof(chunk_hooks_t);
 	new_size = sizeof(chunk_hooks_t);
-	assert_d_eq(mallctl("arena.0.chunk_hooks", &old_hooks, &old_size,
-	    &new_hooks, new_size), 0, "Unexpected chunk_hooks error");
+	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, (void *)&old_hooks,
+	    &old_size, (void *)&new_hooks, new_size), 0,
+	    "Unexpected chunk_hooks error");
 	orig_hooks = old_hooks;
 	assert_ptr_ne(old_hooks.alloc, chunk_alloc, "Unexpected alloc error");
 	assert_ptr_ne(old_hooks.dalloc, chunk_dalloc,
 	    "Unexpected dalloc error");
 	assert_ptr_ne(old_hooks.commit, chunk_commit,
 	    "Unexpected commit error");
@@ -148,112 +162,116 @@
 	assert_ptr_ne(old_hooks.purge, chunk_purge, "Unexpected purge error");
 	assert_ptr_ne(old_hooks.split, chunk_split, "Unexpected split error");
 	assert_ptr_ne(old_hooks.merge, chunk_merge, "Unexpected merge error");
 
 	/* Get large size classes. */
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("arenas.lrun.0.size", &large0, &sz, NULL, 0), 0,
-	    "Unexpected arenas.lrun.0.size failure");
-	assert_d_eq(mallctl("arenas.lrun.1.size", &large1, &sz, NULL, 0), 0,
-	    "Unexpected arenas.lrun.1.size failure");
+	assert_d_eq(mallctl("arenas.lrun.0.size", (void *)&large0, &sz, NULL,
+	    0), 0, "Unexpected arenas.lrun.0.size failure");
+	assert_d_eq(mallctl("arenas.lrun.1.size", (void *)&large1, &sz, NULL,
+	    0), 0, "Unexpected arenas.lrun.1.size failure");
 
 	/* Get huge size classes. */
-	assert_d_eq(mallctl("arenas.hchunk.0.size", &huge0, &sz, NULL, 0), 0,
-	    "Unexpected arenas.hchunk.0.size failure");
-	assert_d_eq(mallctl("arenas.hchunk.1.size", &huge1, &sz, NULL, 0), 0,
-	    "Unexpected arenas.hchunk.1.size failure");
-	assert_d_eq(mallctl("arenas.hchunk.2.size", &huge2, &sz, NULL, 0), 0,
-	    "Unexpected arenas.hchunk.2.size failure");
+	assert_d_eq(mallctl("arenas.hchunk.0.size", (void *)&huge0, &sz, NULL,
+	    0), 0, "Unexpected arenas.hchunk.0.size failure");
+	assert_d_eq(mallctl("arenas.hchunk.1.size", (void *)&huge1, &sz, NULL,
+	    0), 0, "Unexpected arenas.hchunk.1.size failure");
+	assert_d_eq(mallctl("arenas.hchunk.2.size", (void *)&huge2, &sz, NULL,
+	    0), 0, "Unexpected arenas.hchunk.2.size failure");
 
 	/* Test dalloc/decommit/purge cascade. */
+	purge_miblen = sizeof(purge_mib)/sizeof(size_t);
+	assert_d_eq(mallctlnametomib("arena.0.purge", purge_mib, &purge_miblen),
+	    0, "Unexpected mallctlnametomib() failure");
+	purge_mib[1] = (size_t)arena_ind;
 	do_dalloc = false;
 	do_decommit = false;
-	p = mallocx(huge0 * 2, 0);
+	p = mallocx(huge0 * 2, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 	did_dalloc = false;
 	did_decommit = false;
 	did_purge = false;
 	did_split = false;
-	xallocx_success_a = (xallocx(p, huge0, 0, 0) == huge0);
-	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
-	    "Unexpected arena.0.purge error");
+	xallocx_success_a = (xallocx(p, huge0, 0, flags) == huge0);
+	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
+	    0, "Unexpected arena.%u.purge error", arena_ind);
 	if (xallocx_success_a) {
 		assert_true(did_dalloc, "Expected dalloc");
 		assert_false(did_decommit, "Unexpected decommit");
 		assert_true(did_purge, "Expected purge");
 	}
 	assert_true(did_split, "Expected split");
-	dallocx(p, 0);
+	dallocx(p, flags);
 	do_dalloc = true;
 
 	/* Test decommit/commit and observe split/merge. */
 	do_dalloc = false;
 	do_decommit = true;
-	p = mallocx(huge0 * 2, 0);
+	p = mallocx(huge0 * 2, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 	did_decommit = false;
 	did_commit = false;
 	did_split = false;
 	did_merge = false;
-	xallocx_success_b = (xallocx(p, huge0, 0, 0) == huge0);
-	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
-	    "Unexpected arena.0.purge error");
+	xallocx_success_b = (xallocx(p, huge0, 0, flags) == huge0);
+	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
+	    0, "Unexpected arena.%u.purge error", arena_ind);
 	if (xallocx_success_b)
 		assert_true(did_split, "Expected split");
-	xallocx_success_c = (xallocx(p, huge0 * 2, 0, 0) == huge0 * 2);
+	xallocx_success_c = (xallocx(p, huge0 * 2, 0, flags) == huge0 * 2);
 	assert_b_eq(did_decommit, did_commit, "Expected decommit/commit match");
 	if (xallocx_success_b && xallocx_success_c)
 		assert_true(did_merge, "Expected merge");
-	dallocx(p, 0);
+	dallocx(p, flags);
 	do_dalloc = true;
 	do_decommit = false;
 
 	/* Test purge for partial-chunk huge allocations. */
 	if (huge0 * 2 > huge2) {
 		/*
 		 * There are at least four size classes per doubling, so a
 		 * successful xallocx() from size=huge2 to size=huge1 is
 		 * guaranteed to leave trailing purgeable memory.
 		 */
-		p = mallocx(huge2, 0);
+		p = mallocx(huge2, flags);
 		assert_ptr_not_null(p, "Unexpected mallocx() error");
 		did_purge = false;
-		assert_zu_eq(xallocx(p, huge1, 0, 0), huge1,
+		assert_zu_eq(xallocx(p, huge1, 0, flags), huge1,
 		    "Unexpected xallocx() failure");
 		assert_true(did_purge, "Expected purge");
-		dallocx(p, 0);
+		dallocx(p, flags);
 	}
 
 	/* Test decommit for large allocations. */
 	do_decommit = true;
-	p = mallocx(large1, 0);
+	p = mallocx(large1, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
-	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
-	    "Unexpected arena.0.purge error");
+	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
+	    0, "Unexpected arena.%u.purge error", arena_ind);
 	did_decommit = false;
-	assert_zu_eq(xallocx(p, large0, 0, 0), large0,
+	assert_zu_eq(xallocx(p, large0, 0, flags), large0,
 	    "Unexpected xallocx() failure");
-	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
-	    "Unexpected arena.0.purge error");
+	assert_d_eq(mallctlbymib(purge_mib, purge_miblen, NULL, NULL, NULL, 0),
+	    0, "Unexpected arena.%u.purge error", arena_ind);
 	did_commit = false;
-	assert_zu_eq(xallocx(p, large1, 0, 0), large1,
+	assert_zu_eq(xallocx(p, large1, 0, flags), large1,
 	    "Unexpected xallocx() failure");
 	assert_b_eq(did_decommit, did_commit, "Expected decommit/commit match");
-	dallocx(p, 0);
+	dallocx(p, flags);
 	do_decommit = false;
 
 	/* Make sure non-huge allocation succeeds. */
-	p = mallocx(42, 0);
+	p = mallocx(42, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
-	dallocx(p, 0);
+	dallocx(p, flags);
 
 	/* Restore chunk hooks. */
-	assert_d_eq(mallctl("arena.0.chunk_hooks", NULL, NULL, &old_hooks,
-	    new_size), 0, "Unexpected chunk_hooks error");
-	assert_d_eq(mallctl("arena.0.chunk_hooks", &old_hooks, &old_size,
-	    NULL, 0), 0, "Unexpected chunk_hooks error");
+	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, NULL, NULL,
+	    (void *)&old_hooks, new_size), 0, "Unexpected chunk_hooks error");
+	assert_d_eq(mallctlbymib(hooks_mib, hooks_miblen, (void *)&old_hooks,
+	    &old_size, NULL, 0), 0, "Unexpected chunk_hooks error");
 	assert_ptr_eq(old_hooks.alloc, orig_hooks.alloc,
 	    "Unexpected alloc error");
 	assert_ptr_eq(old_hooks.dalloc, orig_hooks.dalloc,
 	    "Unexpected dalloc error");
 	assert_ptr_eq(old_hooks.commit, orig_hooks.commit,
 	    "Unexpected commit error");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/MALLOCX_ARENA.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/MALLOCX_ARENA.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/MALLOCX_ARENA.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/MALLOCX_ARENA.c	2017-01-31 23:32:23.000000000 +0800
@@ -16,14 +16,14 @@
 	unsigned thread_ind = (unsigned)(uintptr_t)arg;
 	unsigned arena_ind;
 	void *p;
 	size_t sz;
 
 	sz = sizeof(arena_ind);
-	assert_d_eq(mallctl("arenas.extend", &arena_ind, &sz, NULL, 0), 0,
-	    "Error in arenas.extend");
+	assert_d_eq(mallctl("arenas.extend", (void *)&arena_ind, &sz, NULL, 0),
+	    0, "Error in arenas.extend");
 
 	if (thread_ind % 4 != 3) {
 		size_t mib[3];
 		size_t miblen = sizeof(mib) / sizeof(size_t);
 		const char *dss_precs[] = {"disabled", "primary", "secondary"};
 		unsigned prec_ind = thread_ind %
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/mallocx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/mallocx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/mallocx.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/mallocx.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,16 +1,20 @@
 #include "test/jemalloc_test.h"
 
+#ifdef JEMALLOC_FILL
+const char *malloc_conf = "junk:false";
+#endif
+
 static unsigned
 get_nsizes_impl(const char *cmd)
 {
 	unsigned ret;
 	size_t z;
 
 	z = sizeof(unsigned);
-	assert_d_eq(mallctl(cmd, &ret, &z, NULL, 0), 0,
+	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
 	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
 
 	return (ret);
 }
 
 static unsigned
@@ -30,95 +34,141 @@
 
 	z = sizeof(size_t);
 	assert_d_eq(mallctlnametomib(cmd, mib, &miblen),
 	    0, "Unexpected mallctlnametomib(\"%s\", ...) failure", cmd);
 	mib[2] = ind;
 	z = sizeof(size_t);
-	assert_d_eq(mallctlbymib(mib, miblen, &ret, &z, NULL, 0),
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
 	return (ret);
 }
 
 static size_t
 get_huge_size(size_t ind)
 {
 
 	return (get_size_impl("arenas.hchunk.0.size", ind));
 }
 
-TEST_BEGIN(test_oom)
+/*
+ * On systems which can't merge extents, tests that call this function generate
+ * a lot of dirty memory very quickly.  Purging between cycles mitigates
+ * potential OOM on e.g. 32-bit Windows.
+ */
+static void
+purge(void)
 {
-	size_t hugemax, size, alignment;
+
+	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
+	    "Unexpected mallctl error");
+}
+
+TEST_BEGIN(test_overflow)
+{
+	size_t hugemax;
 
 	hugemax = get_huge_size(get_nhuge()-1);
 
+	assert_ptr_null(mallocx(hugemax+1, 0),
+	    "Expected OOM for mallocx(size=%#zx, 0)", hugemax+1);
+
+	assert_ptr_null(mallocx(ZU(PTRDIFF_MAX)+1, 0),
+	    "Expected OOM for mallocx(size=%#zx, 0)", ZU(PTRDIFF_MAX)+1);
+
+	assert_ptr_null(mallocx(SIZE_T_MAX, 0),
+	    "Expected OOM for mallocx(size=%#zx, 0)", SIZE_T_MAX);
+
+	assert_ptr_null(mallocx(1, MALLOCX_ALIGN(ZU(PTRDIFF_MAX)+1)),
+	    "Expected OOM for mallocx(size=1, MALLOCX_ALIGN(%#zx))",
+	    ZU(PTRDIFF_MAX)+1);
+}
+TEST_END
+
+TEST_BEGIN(test_oom)
+{
+	size_t hugemax;
+	bool oom;
+	void *ptrs[3];
+	unsigned i;
+
 	/*
-	 * It should be impossible to allocate two objects that each consume
-	 * more than half the virtual address space.
+	 * It should be impossible to allocate three objects that each consume
+	 * nearly half the virtual address space.
 	 */
-	{
-		void *p;
-
-		p = mallocx(hugemax, 0);
-		if (p != NULL) {
-			assert_ptr_null(mallocx(hugemax, 0),
-			    "Expected OOM for mallocx(size=%#zx, 0)", hugemax);
-			dallocx(p, 0);
-		}
+	hugemax = get_huge_size(get_nhuge()-1);
+	oom = false;
+	for (i = 0; i < sizeof(ptrs) / sizeof(void *); i++) {
+		ptrs[i] = mallocx(hugemax, 0);
+		if (ptrs[i] == NULL)
+			oom = true;
+	}
+	assert_true(oom,
+	    "Expected OOM during series of calls to mallocx(size=%zu, 0)",
+	    hugemax);
+	for (i = 0; i < sizeof(ptrs) / sizeof(void *); i++) {
+		if (ptrs[i] != NULL)
+			dallocx(ptrs[i], 0);
 	}
+	purge();
 
 #if LG_SIZEOF_PTR == 3
-	size      = ZU(0x8000000000000000);
-	alignment = ZU(0x8000000000000000);
+	assert_ptr_null(mallocx(0x8000000000000000ULL,
+	    MALLOCX_ALIGN(0x8000000000000000ULL)),
+	    "Expected OOM for mallocx()");
+	assert_ptr_null(mallocx(0x8000000000000000ULL,
+	    MALLOCX_ALIGN(0x80000000)),
+	    "Expected OOM for mallocx()");
 #else
-	size      = ZU(0x80000000);
-	alignment = ZU(0x80000000);
+	assert_ptr_null(mallocx(0x80000000UL, MALLOCX_ALIGN(0x80000000UL)),
+	    "Expected OOM for mallocx()");
 #endif
-	assert_ptr_null(mallocx(size, MALLOCX_ALIGN(alignment)),
-	    "Expected OOM for mallocx(size=%#zx, MALLOCX_ALIGN(%#zx)", size,
-	    alignment);
 }
 TEST_END
 
 TEST_BEGIN(test_basic)
 {
-#define	MAXSZ (((size_t)1) << 26)
+#define	MAXSZ (((size_t)1) << 23)
 	size_t sz;
 
 	for (sz = 1; sz < MAXSZ; sz = nallocx(sz, 0) + 1) {
 		size_t nsz, rsz;
 		void *p;
 		nsz = nallocx(sz, 0);
 		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
 		p = mallocx(sz, 0);
-		assert_ptr_not_null(p, "Unexpected mallocx() error");
+		assert_ptr_not_null(p,
+		    "Unexpected mallocx(size=%zx, flags=0) error", sz);
 		rsz = sallocx(p, 0);
 		assert_zu_ge(rsz, sz, "Real size smaller than expected");
 		assert_zu_eq(nsz, rsz, "nallocx()/sallocx() size mismatch");
 		dallocx(p, 0);
 
 		p = mallocx(sz, 0);
-		assert_ptr_not_null(p, "Unexpected mallocx() error");
+		assert_ptr_not_null(p,
+		    "Unexpected mallocx(size=%zx, flags=0) error", sz);
 		dallocx(p, 0);
 
 		nsz = nallocx(sz, MALLOCX_ZERO);
 		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
 		p = mallocx(sz, MALLOCX_ZERO);
-		assert_ptr_not_null(p, "Unexpected mallocx() error");
+		assert_ptr_not_null(p,
+		    "Unexpected mallocx(size=%zx, flags=MALLOCX_ZERO) error",
+		    nsz);
 		rsz = sallocx(p, 0);
 		assert_zu_eq(nsz, rsz, "nallocx()/sallocx() rsize mismatch");
 		dallocx(p, 0);
+		purge();
 	}
 #undef MAXSZ
 }
 TEST_END
 
 TEST_BEGIN(test_alignment_and_size)
 {
-#define	MAXALIGN (((size_t)1) << 25)
+#define	MAXALIGN (((size_t)1) << 23)
 #define	NITER 4
 	size_t nsz, rsz, sz, alignment, total;
 	unsigned i;
 	void *ps[NITER];
 
 	for (i = 0; i < NITER; i++)
@@ -162,21 +212,23 @@
 				if (ps[i] != NULL) {
 					dallocx(ps[i], 0);
 					ps[i] = NULL;
 				}
 			}
 		}
+		purge();
 	}
 #undef MAXALIGN
 #undef NITER
 }
 TEST_END
 
 int
 main(void)
 {
 
 	return (test(
+	    test_overflow,
 	    test_oom,
 	    test_basic,
 	    test_alignment_and_size));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/overflow.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/overflow.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/overflow.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/overflow.c	2017-01-31 23:32:23.000000000 +0800
@@ -5,23 +5,23 @@
 	unsigned nhchunks;
 	size_t mib[4];
 	size_t sz, miblen, max_size_class;
 	void *p;
 
 	sz = sizeof(unsigned);
-	assert_d_eq(mallctl("arenas.nhchunks", &nhchunks, &sz, NULL, 0), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("arenas.nhchunks", (void *)&nhchunks, &sz, NULL, 0),
+	    0, "Unexpected mallctl() error");
 
 	miblen = sizeof(mib) / sizeof(size_t);
 	assert_d_eq(mallctlnametomib("arenas.hchunk.0.size", mib, &miblen), 0,
 	    "Unexpected mallctlnametomib() error");
 	mib[2] = nhchunks - 1;
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctlbymib(mib, miblen, &max_size_class, &sz, NULL, 0), 0,
-	    "Unexpected mallctlbymib() error");
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&max_size_class, &sz,
+	    NULL, 0), 0, "Unexpected mallctlbymib() error");
 
 	assert_ptr_null(malloc(max_size_class + 1),
 	    "Expected OOM due to over-sized allocation request");
 	assert_ptr_null(malloc(SIZE_T_MAX),
 	    "Expected OOM due to over-sized allocation request");
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/posix_memalign.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/posix_memalign.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/posix_memalign.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/posix_memalign.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,12 +1,23 @@
 #include "test/jemalloc_test.h"
 
 #define	CHUNK 0x400000
-/* #define MAXALIGN ((size_t)UINT64_C(0x80000000000)) */
-#define	MAXALIGN ((size_t)0x2000000LU)
-#define	NITER 4
+#define	MAXALIGN (((size_t)1) << 23)
+
+/*
+ * On systems which can't merge extents, tests that call this function generate
+ * a lot of dirty memory very quickly.  Purging between cycles mitigates
+ * potential OOM on e.g. 32-bit Windows.
+ */
+static void
+purge(void)
+{
+
+	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
+	    "Unexpected mallctl error");
+}
 
 TEST_BEGIN(test_alignment_errors)
 {
 	size_t alignment;
 	void *p;
 
@@ -63,12 +74,13 @@
 	    alignment, size);
 }
 TEST_END
 
 TEST_BEGIN(test_alignment_and_size)
 {
+#define	NITER 4
 	size_t alignment, size, total;
 	unsigned i;
 	int err;
 	void *ps[NITER];
 
 	for (i = 0; i < NITER; i++)
@@ -101,13 +113,15 @@
 				if (ps[i] != NULL) {
 					free(ps[i]);
 					ps[i] = NULL;
 				}
 			}
 		}
+		purge();
 	}
+#undef NITER
 }
 TEST_END
 
 int
 main(void)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/rallocx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/rallocx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/rallocx.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/rallocx.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,8 +1,54 @@
 #include "test/jemalloc_test.h"
 
+static unsigned
+get_nsizes_impl(const char *cmd)
+{
+	unsigned ret;
+	size_t z;
+
+	z = sizeof(unsigned);
+	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
+	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
+
+	return (ret);
+}
+
+static unsigned
+get_nhuge(void)
+{
+
+	return (get_nsizes_impl("arenas.nhchunks"));
+}
+
+static size_t
+get_size_impl(const char *cmd, size_t ind)
+{
+	size_t ret;
+	size_t z;
+	size_t mib[4];
+	size_t miblen = 4;
+
+	z = sizeof(size_t);
+	assert_d_eq(mallctlnametomib(cmd, mib, &miblen),
+	    0, "Unexpected mallctlnametomib(\"%s\", ...) failure", cmd);
+	mib[2] = ind;
+	z = sizeof(size_t);
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
+	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
+
+	return (ret);
+}
+
+static size_t
+get_huge_size(size_t ind)
+{
+
+	return (get_size_impl("arenas.hchunk.0.size", ind));
+}
+
 TEST_BEGIN(test_grow_and_shrink)
 {
 	void *p, *q;
 	size_t tsz;
 #define	NCYCLES 3
 	unsigned i, j;
@@ -135,28 +181,28 @@
 }
 TEST_END
 
 TEST_BEGIN(test_lg_align_and_zero)
 {
 	void *p, *q;
-	size_t lg_align, sz;
+	unsigned lg_align;
+	size_t sz;
 #define	MAX_LG_ALIGN 25
 #define	MAX_VALIDATE (ZU(1) << 22)
 
-	lg_align = ZU(0);
+	lg_align = 0;
 	p = mallocx(1, MALLOCX_LG_ALIGN(lg_align)|MALLOCX_ZERO);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 
 	for (lg_align++; lg_align <= MAX_LG_ALIGN; lg_align++) {
 		q = rallocx(p, 1, MALLOCX_LG_ALIGN(lg_align)|MALLOCX_ZERO);
 		assert_ptr_not_null(q,
-		    "Unexpected rallocx() error for lg_align=%zu", lg_align);
+		    "Unexpected rallocx() error for lg_align=%u", lg_align);
 		assert_ptr_null(
 		    (void *)((uintptr_t)q & ((ZU(1) << lg_align)-1)),
-		    "%p inadequately aligned for lg_align=%zu",
-		    q, lg_align);
+		    "%p inadequately aligned for lg_align=%u", q, lg_align);
 		sz = sallocx(q, 0);
 		if ((sz << 1) <= MAX_VALIDATE) {
 			assert_false(validate_fill(q, 0, 0, sz),
 			    "Expected zeroed memory");
 		} else {
 			assert_false(validate_fill(q, 0, 0, MAX_VALIDATE),
@@ -170,16 +216,44 @@
 	dallocx(p, 0);
 #undef MAX_VALIDATE
 #undef MAX_LG_ALIGN
 }
 TEST_END
 
+TEST_BEGIN(test_overflow)
+{
+	size_t hugemax;
+	void *p;
+
+	hugemax = get_huge_size(get_nhuge()-1);
+
+	p = mallocx(1, 0);
+	assert_ptr_not_null(p, "Unexpected mallocx() failure");
+
+	assert_ptr_null(rallocx(p, hugemax+1, 0),
+	    "Expected OOM for rallocx(p, size=%#zx, 0)", hugemax+1);
+
+	assert_ptr_null(rallocx(p, ZU(PTRDIFF_MAX)+1, 0),
+	    "Expected OOM for rallocx(p, size=%#zx, 0)", ZU(PTRDIFF_MAX)+1);
+
+	assert_ptr_null(rallocx(p, SIZE_T_MAX, 0),
+	    "Expected OOM for rallocx(p, size=%#zx, 0)", SIZE_T_MAX);
+
+	assert_ptr_null(rallocx(p, 1, MALLOCX_ALIGN(ZU(PTRDIFF_MAX)+1)),
+	    "Expected OOM for rallocx(p, size=1, MALLOCX_ALIGN(%#zx))",
+	    ZU(PTRDIFF_MAX)+1);
+
+	dallocx(p, 0);
+}
+TEST_END
+
 int
 main(void)
 {
 
 	return (test(
 	    test_grow_and_shrink,
 	    test_zero,
 	    test_align,
-	    test_lg_align_and_zero));
+	    test_lg_align_and_zero,
+	    test_overflow));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/sdallocx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/sdallocx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/sdallocx.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/sdallocx.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,10 +1,10 @@
 #include "test/jemalloc_test.h"
 
-#define	MAXALIGN (((size_t)1) << 25)
-#define	NITER 4
+#define	MAXALIGN (((size_t)1) << 22)
+#define	NITER 3
 
 TEST_BEGIN(test_basic)
 {
 	void *ptr = mallocx(64, 0);
 	sdallocx(ptr, 64, 0);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/thread_arena.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/thread_arena.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/thread_arena.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/thread_arena.c	2017-01-31 23:32:23.000000000 +0800
@@ -13,22 +13,23 @@
 
 	p = malloc(1);
 	assert_ptr_not_null(p, "Error in malloc()");
 	free(p);
 
 	size = sizeof(arena_ind);
-	if ((err = mallctl("thread.arena", &arena_ind, &size, &main_arena_ind,
-	    sizeof(main_arena_ind)))) {
+	if ((err = mallctl("thread.arena", (void *)&arena_ind, &size,
+	    (void *)&main_arena_ind, sizeof(main_arena_ind)))) {
 		char buf[BUFERROR_BUF];
 
 		buferror(err, buf, sizeof(buf));
 		test_fail("Error in mallctl(): %s", buf);
 	}
 
 	size = sizeof(arena_ind);
-	if ((err = mallctl("thread.arena", &arena_ind, &size, NULL, 0))) {
+	if ((err = mallctl("thread.arena", (void *)&arena_ind, &size, NULL,
+	    0))) {
 		char buf[BUFERROR_BUF];
 
 		buferror(err, buf, sizeof(buf));
 		test_fail("Error in mallctl(): %s", buf);
 	}
 	assert_u_eq(arena_ind, main_arena_ind,
@@ -47,13 +48,14 @@
 	unsigned i;
 
 	p = malloc(1);
 	assert_ptr_not_null(p, "Error in malloc()");
 
 	size = sizeof(arena_ind);
-	if ((err = mallctl("thread.arena", &arena_ind, &size, NULL, 0))) {
+	if ((err = mallctl("thread.arena", (void *)&arena_ind, &size, NULL,
+	    0))) {
 		char buf[BUFERROR_BUF];
 
 		buferror(err, buf, sizeof(buf));
 		test_fail("Error in mallctl(): %s", buf);
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/thread_tcache_enabled.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/thread_tcache_enabled.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/thread_tcache_enabled.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/thread_tcache_enabled.c	2017-01-31 23:32:23.000000000 +0800
@@ -13,70 +13,71 @@
 {
 	int err;
 	size_t sz;
 	bool e0, e1;
 
 	sz = sizeof(bool);
-	if ((err = mallctl("thread.tcache.enabled", &e0, &sz, NULL, 0))) {
+	if ((err = mallctl("thread.tcache.enabled", (void *)&e0, &sz, NULL,
+	    0))) {
 		if (err == ENOENT) {
 			assert_false(config_tcache,
 			    "ENOENT should only be returned if tcache is "
 			    "disabled");
 		}
 		goto label_ENOENT;
 	}
 
 	if (e0) {
 		e1 = false;
-		assert_d_eq(mallctl("thread.tcache.enabled", &e0, &sz, &e1, sz),
-		    0, "Unexpected mallctl() error");
+		assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz,
+		    (void *)&e1, sz), 0, "Unexpected mallctl() error");
 		assert_true(e0, "tcache should be enabled");
 	}
 
 	e1 = true;
-	assert_d_eq(mallctl("thread.tcache.enabled", &e0, &sz, &e1, sz), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz,
+	    (void *)&e1, sz), 0, "Unexpected mallctl() error");
 	assert_false(e0, "tcache should be disabled");
 
 	e1 = true;
-	assert_d_eq(mallctl("thread.tcache.enabled", &e0, &sz, &e1, sz), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz,
+	    (void *)&e1, sz), 0, "Unexpected mallctl() error");
 	assert_true(e0, "tcache should be enabled");
 
 	e1 = false;
-	assert_d_eq(mallctl("thread.tcache.enabled", &e0, &sz, &e1, sz), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz,
+	    (void *)&e1, sz), 0, "Unexpected mallctl() error");
 	assert_true(e0, "tcache should be enabled");
 
 	e1 = false;
-	assert_d_eq(mallctl("thread.tcache.enabled", &e0, &sz, &e1, sz), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz,
+	    (void *)&e1, sz), 0, "Unexpected mallctl() error");
 	assert_false(e0, "tcache should be disabled");
 
 	free(malloc(1));
 	e1 = true;
-	assert_d_eq(mallctl("thread.tcache.enabled", &e0, &sz, &e1, sz), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz,
+	    (void *)&e1, sz), 0, "Unexpected mallctl() error");
 	assert_false(e0, "tcache should be disabled");
 
 	free(malloc(1));
 	e1 = true;
-	assert_d_eq(mallctl("thread.tcache.enabled", &e0, &sz, &e1, sz), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz,
+	    (void *)&e1, sz), 0, "Unexpected mallctl() error");
 	assert_true(e0, "tcache should be enabled");
 
 	free(malloc(1));
 	e1 = false;
-	assert_d_eq(mallctl("thread.tcache.enabled", &e0, &sz, &e1, sz), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz,
+	    (void *)&e1, sz), 0, "Unexpected mallctl() error");
 	assert_true(e0, "tcache should be enabled");
 
 	free(malloc(1));
 	e1 = false;
-	assert_d_eq(mallctl("thread.tcache.enabled", &e0, &sz, &e1, sz), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("thread.tcache.enabled", (void *)&e0, &sz,
+	    (void *)&e1, sz), 0, "Unexpected mallctl() error");
 	assert_false(e0, "tcache should be disabled");
 
 	free(malloc(1));
 	return (NULL);
 label_ENOENT:
 	test_skip("\"thread.tcache.enabled\" mallctl not available");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/xallocx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/xallocx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/integration/xallocx.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/integration/xallocx.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,8 +1,31 @@
 #include "test/jemalloc_test.h"
 
+#ifdef JEMALLOC_FILL
+const char *malloc_conf = "junk:false";
+#endif
+
+/*
+ * Use a separate arena for xallocx() extension/contraction tests so that
+ * internal allocation e.g. by heap profiling can't interpose allocations where
+ * xallocx() would ordinarily be able to extend.
+ */
+static unsigned
+arena_ind(void)
+{
+	static unsigned ind = 0;
+
+	if (ind == 0) {
+		size_t sz = sizeof(ind);
+		assert_d_eq(mallctl("arenas.extend", (void *)&ind, &sz, NULL,
+		    0), 0, "Unexpected mallctl failure creating arena");
+	}
+
+	return (ind);
+}
+
 TEST_BEGIN(test_same_size)
 {
 	void *p;
 	size_t sz, tsz;
 
 	p = mallocx(42, 0);
@@ -52,13 +75,13 @@
 get_nsizes_impl(const char *cmd)
 {
 	unsigned ret;
 	size_t z;
 
 	z = sizeof(unsigned);
-	assert_d_eq(mallctl(cmd, &ret, &z, NULL, 0), 0,
+	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
 	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
 
 	return (ret);
 }
 
 static unsigned
@@ -92,13 +115,13 @@
 
 	z = sizeof(size_t);
 	assert_d_eq(mallctlnametomib(cmd, mib, &miblen),
 	    0, "Unexpected mallctlnametomib(\"%s\", ...) failure", cmd);
 	mib[2] = ind;
 	z = sizeof(size_t);
-	assert_d_eq(mallctlbymib(mib, miblen, &ret, &z, NULL, 0),
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
 	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
 
 	return (ret);
 }
 
 static size_t
@@ -215,138 +238,140 @@
 	dallocx(p, 0);
 }
 TEST_END
 
 TEST_BEGIN(test_extra_large)
 {
+	int flags = MALLOCX_ARENA(arena_ind());
 	size_t smallmax, large0, large1, large2, huge0, hugemax;
 	void *p;
 
 	/* Get size classes. */
 	smallmax = get_small_size(get_nsmall()-1);
 	large0 = get_large_size(0);
 	large1 = get_large_size(1);
 	large2 = get_large_size(2);
 	huge0 = get_huge_size(0);
 	hugemax = get_huge_size(get_nhuge()-1);
 
-	p = mallocx(large2, 0);
+	p = mallocx(large2, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 
-	assert_zu_eq(xallocx(p, large2, 0, 0), large2,
+	assert_zu_eq(xallocx(p, large2, 0, flags), large2,
 	    "Unexpected xallocx() behavior");
 	/* Test size decrease with zero extra. */
-	assert_zu_eq(xallocx(p, large0, 0, 0), large0,
+	assert_zu_eq(xallocx(p, large0, 0, flags), large0,
 	    "Unexpected xallocx() behavior");
-	assert_zu_eq(xallocx(p, smallmax, 0, 0), large0,
+	assert_zu_eq(xallocx(p, smallmax, 0, flags), large0,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_eq(xallocx(p, large2, 0, 0), large2,
+	assert_zu_eq(xallocx(p, large2, 0, flags), large2,
 	    "Unexpected xallocx() behavior");
 	/* Test size decrease with non-zero extra. */
-	assert_zu_eq(xallocx(p, large0, large2 - large0, 0), large2,
+	assert_zu_eq(xallocx(p, large0, large2 - large0, flags), large2,
 	    "Unexpected xallocx() behavior");
-	assert_zu_eq(xallocx(p, large1, large2 - large1, 0), large2,
+	assert_zu_eq(xallocx(p, large1, large2 - large1, flags), large2,
 	    "Unexpected xallocx() behavior");
-	assert_zu_eq(xallocx(p, large0, large1 - large0, 0), large1,
+	assert_zu_eq(xallocx(p, large0, large1 - large0, flags), large1,
 	    "Unexpected xallocx() behavior");
-	assert_zu_eq(xallocx(p, smallmax, large0 - smallmax, 0), large0,
+	assert_zu_eq(xallocx(p, smallmax, large0 - smallmax, flags), large0,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_eq(xallocx(p, large0, 0, 0), large0,
+	assert_zu_eq(xallocx(p, large0, 0, flags), large0,
 	    "Unexpected xallocx() behavior");
 	/* Test size increase with zero extra. */
-	assert_zu_eq(xallocx(p, large2, 0, 0), large2,
+	assert_zu_eq(xallocx(p, large2, 0, flags), large2,
 	    "Unexpected xallocx() behavior");
-	assert_zu_eq(xallocx(p, huge0, 0, 0), large2,
+	assert_zu_eq(xallocx(p, huge0, 0, flags), large2,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_eq(xallocx(p, large0, 0, 0), large0,
+	assert_zu_eq(xallocx(p, large0, 0, flags), large0,
 	    "Unexpected xallocx() behavior");
 	/* Test size increase with non-zero extra. */
-	assert_zu_lt(xallocx(p, large0, huge0 - large0, 0), huge0,
+	assert_zu_lt(xallocx(p, large0, huge0 - large0, flags), huge0,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_eq(xallocx(p, large0, 0, 0), large0,
+	assert_zu_eq(xallocx(p, large0, 0, flags), large0,
 	    "Unexpected xallocx() behavior");
 	/* Test size increase with non-zero extra. */
-	assert_zu_eq(xallocx(p, large0, large2 - large0, 0), large2,
+	assert_zu_eq(xallocx(p, large0, large2 - large0, flags), large2,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_eq(xallocx(p, large2, 0, 0), large2,
+	assert_zu_eq(xallocx(p, large2, 0, flags), large2,
 	    "Unexpected xallocx() behavior");
 	/* Test size+extra overflow. */
-	assert_zu_lt(xallocx(p, large2, hugemax - large2 + 1, 0), huge0,
+	assert_zu_lt(xallocx(p, large2, hugemax - large2 + 1, flags), huge0,
 	    "Unexpected xallocx() behavior");
 
-	dallocx(p, 0);
+	dallocx(p, flags);
 }
 TEST_END
 
 TEST_BEGIN(test_extra_huge)
 {
-	size_t largemax, huge0, huge1, huge2, hugemax;
+	int flags = MALLOCX_ARENA(arena_ind());
+	size_t largemax, huge1, huge2, huge3, hugemax;
 	void *p;
 
 	/* Get size classes. */
 	largemax = get_large_size(get_nlarge()-1);
-	huge0 = get_huge_size(0);
 	huge1 = get_huge_size(1);
 	huge2 = get_huge_size(2);
+	huge3 = get_huge_size(3);
 	hugemax = get_huge_size(get_nhuge()-1);
 
-	p = mallocx(huge2, 0);
+	p = mallocx(huge3, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 
-	assert_zu_eq(xallocx(p, huge2, 0, 0), huge2,
+	assert_zu_eq(xallocx(p, huge3, 0, flags), huge3,
 	    "Unexpected xallocx() behavior");
 	/* Test size decrease with zero extra. */
-	assert_zu_ge(xallocx(p, huge0, 0, 0), huge0,
+	assert_zu_ge(xallocx(p, huge1, 0, flags), huge1,
 	    "Unexpected xallocx() behavior");
-	assert_zu_ge(xallocx(p, largemax, 0, 0), huge0,
+	assert_zu_ge(xallocx(p, largemax, 0, flags), huge1,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_eq(xallocx(p, huge2, 0, 0), huge2,
+	assert_zu_eq(xallocx(p, huge3, 0, flags), huge3,
 	    "Unexpected xallocx() behavior");
 	/* Test size decrease with non-zero extra. */
-	assert_zu_eq(xallocx(p, huge0, huge2 - huge0, 0), huge2,
+	assert_zu_eq(xallocx(p, huge1, huge3 - huge1, flags), huge3,
 	    "Unexpected xallocx() behavior");
-	assert_zu_eq(xallocx(p, huge1, huge2 - huge1, 0), huge2,
+	assert_zu_eq(xallocx(p, huge2, huge3 - huge2, flags), huge3,
 	    "Unexpected xallocx() behavior");
-	assert_zu_eq(xallocx(p, huge0, huge1 - huge0, 0), huge1,
+	assert_zu_eq(xallocx(p, huge1, huge2 - huge1, flags), huge2,
 	    "Unexpected xallocx() behavior");
-	assert_zu_ge(xallocx(p, largemax, huge0 - largemax, 0), huge0,
+	assert_zu_ge(xallocx(p, largemax, huge1 - largemax, flags), huge1,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_ge(xallocx(p, huge0, 0, 0), huge0,
+	assert_zu_ge(xallocx(p, huge1, 0, flags), huge1,
 	    "Unexpected xallocx() behavior");
 	/* Test size increase with zero extra. */
-	assert_zu_le(xallocx(p, huge2, 0, 0), huge2,
+	assert_zu_le(xallocx(p, huge3, 0, flags), huge3,
 	    "Unexpected xallocx() behavior");
-	assert_zu_le(xallocx(p, hugemax+1, 0, 0), huge2,
+	assert_zu_le(xallocx(p, hugemax+1, 0, flags), huge3,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_ge(xallocx(p, huge0, 0, 0), huge0,
+	assert_zu_ge(xallocx(p, huge1, 0, flags), huge1,
 	    "Unexpected xallocx() behavior");
 	/* Test size increase with non-zero extra. */
-	assert_zu_le(xallocx(p, huge0, SIZE_T_MAX - huge0, 0), hugemax,
+	assert_zu_le(xallocx(p, huge1, SIZE_T_MAX - huge1, flags), hugemax,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_ge(xallocx(p, huge0, 0, 0), huge0,
+	assert_zu_ge(xallocx(p, huge1, 0, flags), huge1,
 	    "Unexpected xallocx() behavior");
 	/* Test size increase with non-zero extra. */
-	assert_zu_le(xallocx(p, huge0, huge2 - huge0, 0), huge2,
+	assert_zu_le(xallocx(p, huge1, huge3 - huge1, flags), huge3,
 	    "Unexpected xallocx() behavior");
 
-	assert_zu_eq(xallocx(p, huge2, 0, 0), huge2,
+	assert_zu_eq(xallocx(p, huge3, 0, flags), huge3,
 	    "Unexpected xallocx() behavior");
 	/* Test size+extra overflow. */
-	assert_zu_le(xallocx(p, huge2, hugemax - huge2 + 1, 0), hugemax,
+	assert_zu_le(xallocx(p, huge3, hugemax - huge3 + 1, flags), hugemax,
 	    "Unexpected xallocx() behavior");
 
-	dallocx(p, 0);
+	dallocx(p, flags);
 }
 TEST_END
 
 static void
 print_filled_extents(const void *p, uint8_t c, size_t len)
 {
@@ -385,18 +410,19 @@
 	return (err);
 }
 
 static void
 test_zero(size_t szmin, size_t szmax)
 {
+	int flags = MALLOCX_ARENA(arena_ind()) | MALLOCX_ZERO;
 	size_t sz, nsz;
 	void *p;
 #define	FILL_BYTE 0x7aU
 
 	sz = szmax;
-	p = mallocx(sz, MALLOCX_ZERO);
+	p = mallocx(sz, flags);
 	assert_ptr_not_null(p, "Unexpected mallocx() error");
 	assert_false(validate_fill(p, 0x00, 0, sz), "Memory not filled: sz=%zu",
 	    sz);
 
 	/*
 	 * Fill with non-zero so that non-debug builds are more likely to detect
@@ -405,31 +431,31 @@
 	memset(p, FILL_BYTE, sz);
 	assert_false(validate_fill(p, FILL_BYTE, 0, sz),
 	    "Memory not filled: sz=%zu", sz);
 
 	/* Shrink in place so that we can expect growing in place to succeed. */
 	sz = szmin;
-	assert_zu_eq(xallocx(p, sz, 0, MALLOCX_ZERO), sz,
+	assert_zu_eq(xallocx(p, sz, 0, flags), sz,
 	    "Unexpected xallocx() error");
 	assert_false(validate_fill(p, FILL_BYTE, 0, sz),
 	    "Memory not filled: sz=%zu", sz);
 
 	for (sz = szmin; sz < szmax; sz = nsz) {
-		nsz = nallocx(sz+1, MALLOCX_ZERO);
-		assert_zu_eq(xallocx(p, sz+1, 0, MALLOCX_ZERO), nsz,
+		nsz = nallocx(sz+1, flags);
+		assert_zu_eq(xallocx(p, sz+1, 0, flags), nsz,
 		    "Unexpected xallocx() failure");
 		assert_false(validate_fill(p, FILL_BYTE, 0, sz),
 		    "Memory not filled: sz=%zu", sz);
 		assert_false(validate_fill(p, 0x00, sz, nsz-sz),
 		    "Memory not filled: sz=%zu, nsz-sz=%zu", sz, nsz-sz);
 		memset((void *)((uintptr_t)p + sz), FILL_BYTE, nsz-sz);
 		assert_false(validate_fill(p, FILL_BYTE, 0, nsz),
 		    "Memory not filled: nsz=%zu", nsz);
 	}
 
-	dallocx(p, 0);
+	dallocx(p, flags);
 }
 
 TEST_BEGIN(test_zero_large)
 {
 	size_t large0, largemax;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/src/mtx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/src/mtx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/src/mtx.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/src/mtx.c	2017-01-31 23:32:23.000000000 +0800
@@ -8,12 +8,14 @@
 mtx_init(mtx_t *mtx)
 {
 
 #ifdef _WIN32
 	if (!InitializeCriticalSectionAndSpinCount(&mtx->lock, _CRT_SPINCOUNT))
 		return (true);
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
+	mtx->lock = OS_UNFAIR_LOCK_INIT;
 #elif (defined(JEMALLOC_OSSPIN))
 	mtx->lock = 0;
 #else
 	pthread_mutexattr_t attr;
 
 	if (pthread_mutexattr_init(&attr) != 0)
@@ -30,24 +32,27 @@
 
 void
 mtx_fini(mtx_t *mtx)
 {
 
 #ifdef _WIN32
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
 #elif (defined(JEMALLOC_OSSPIN))
 #else
 	pthread_mutex_destroy(&mtx->lock);
 #endif
 }
 
 void
 mtx_lock(mtx_t *mtx)
 {
 
 #ifdef _WIN32
 	EnterCriticalSection(&mtx->lock);
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
+	os_unfair_lock_lock(&mtx->lock);
 #elif (defined(JEMALLOC_OSSPIN))
 	OSSpinLockLock(&mtx->lock);
 #else
 	pthread_mutex_lock(&mtx->lock);
 #endif
 }
@@ -55,12 +60,14 @@
 void
 mtx_unlock(mtx_t *mtx)
 {
 
 #ifdef _WIN32
 	LeaveCriticalSection(&mtx->lock);
+#elif (defined(JEMALLOC_OS_UNFAIR_LOCK))
+	os_unfair_lock_unlock(&mtx->lock);
 #elif (defined(JEMALLOC_OSSPIN))
 	OSSpinLockUnlock(&mtx->lock);
 #else
 	pthread_mutex_unlock(&mtx->lock);
 #endif
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/src/test.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/src/test.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/src/test.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/src/test.c	2017-01-31 23:32:23.000000000 +0800
@@ -57,50 +57,76 @@
 {
 
 	test_counts[test_status]++;
 	malloc_printf("%s: %s\n", test_name, test_status_string(test_status));
 }
 
-test_status_t
-p_test(test_t *t, ...)
+static test_status_t
+p_test_impl(bool do_malloc_init, test_t *t, va_list ap)
 {
 	test_status_t ret;
-	va_list ap;
 
-	/*
-	 * Make sure initialization occurs prior to running tests.  Tests are
-	 * special because they may use internal facilities prior to triggering
-	 * initialization as a side effect of calling into the public API.  This
-	 * is a final safety that works even if jemalloc_constructor() doesn't
-	 * run, as for MSVC builds.
-	 */
-	if (nallocx(1, 0) == 0) {
-		malloc_printf("Initialization error");
-		return (test_status_fail);
+	if (do_malloc_init) {
+		/*
+		 * Make sure initialization occurs prior to running tests.
+		 * Tests are special because they may use internal facilities
+		 * prior to triggering initialization as a side effect of
+		 * calling into the public API.
+		 */
+		if (nallocx(1, 0) == 0) {
+			malloc_printf("Initialization error");
+			return (test_status_fail);
+		}
 	}
 
 	ret = test_status_pass;
-	va_start(ap, t);
 	for (; t != NULL; t = va_arg(ap, test_t *)) {
 		t();
 		if (test_status > ret)
 			ret = test_status;
 	}
-	va_end(ap);
 
 	malloc_printf("--- %s: %u/%u, %s: %u/%u, %s: %u/%u ---\n",
 	    test_status_string(test_status_pass),
 	    test_counts[test_status_pass], test_count,
 	    test_status_string(test_status_skip),
 	    test_counts[test_status_skip], test_count,
 	    test_status_string(test_status_fail),
 	    test_counts[test_status_fail], test_count);
 
 	return (ret);
 }
 
+test_status_t
+p_test(test_t *t, ...)
+{
+	test_status_t ret;
+	va_list ap;
+
+	ret = test_status_pass;
+	va_start(ap, t);
+	ret = p_test_impl(true, t, ap);
+	va_end(ap);
+
+	return (ret);
+}
+
+test_status_t
+p_test_no_malloc_init(test_t *t, ...)
+{
+	test_status_t ret;
+	va_list ap;
+
+	ret = test_status_pass;
+	va_start(ap, t);
+	ret = p_test_impl(false, t, ap);
+	va_end(ap);
+
+	return (ret);
+}
+
 void
 p_test_fail(const char *prefix, const char *message)
 {
 
 	malloc_cprintf(NULL, NULL, "%s%s\n", prefix, message);
 	test_status = test_status_fail;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/src/timer.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/src/timer.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/src/timer.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/src/timer.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,67 +1,42 @@
 #include "test/jemalloc_test.h"
 
 void
 timer_start(timedelta_t *timer)
 {
 
-#ifdef _WIN32
-	GetSystemTimeAsFileTime(&timer->ft0);
-#elif JEMALLOC_CLOCK_GETTIME
-	if (sysconf(_SC_MONOTONIC_CLOCK) <= 0)
-		timer->clock_id = CLOCK_REALTIME;
-	else
-		timer->clock_id = CLOCK_MONOTONIC;
-	clock_gettime(timer->clock_id, &timer->ts0);
-#else
-	gettimeofday(&timer->tv0, NULL);
-#endif
+	nstime_init(&timer->t0, 0);
+	nstime_update(&timer->t0);
 }
 
 void
 timer_stop(timedelta_t *timer)
 {
 
-#ifdef _WIN32
-	GetSystemTimeAsFileTime(&timer->ft0);
-#elif JEMALLOC_CLOCK_GETTIME
-	clock_gettime(timer->clock_id, &timer->ts1);
-#else
-	gettimeofday(&timer->tv1, NULL);
-#endif
+	nstime_copy(&timer->t1, &timer->t0);
+	nstime_update(&timer->t1);
 }
 
 uint64_t
 timer_usec(const timedelta_t *timer)
 {
+	nstime_t delta;
 
-#ifdef _WIN32
-	uint64_t t0, t1;
-	t0 = (((uint64_t)timer->ft0.dwHighDateTime) << 32) |
-	    timer->ft0.dwLowDateTime;
-	t1 = (((uint64_t)timer->ft1.dwHighDateTime) << 32) |
-	    timer->ft1.dwLowDateTime;
-	return ((t1 - t0) / 10);
-#elif JEMALLOC_CLOCK_GETTIME
-	return (((timer->ts1.tv_sec - timer->ts0.tv_sec) * 1000000) +
-	    (timer->ts1.tv_nsec - timer->ts0.tv_nsec) / 1000);
-#else
-	return (((timer->tv1.tv_sec - timer->tv0.tv_sec) * 1000000) +
-	    timer->tv1.tv_usec - timer->tv0.tv_usec);
-#endif
+	nstime_copy(&delta, &timer->t1);
+	nstime_subtract(&delta, &timer->t0);
+	return (nstime_ns(&delta) / 1000);
 }
 
 void
 timer_ratio(timedelta_t *a, timedelta_t *b, char *buf, size_t buflen)
 {
 	uint64_t t0 = timer_usec(a);
 	uint64_t t1 = timer_usec(b);
 	uint64_t mult;
-	unsigned i = 0;
-	unsigned j;
-	int n;
+	size_t i = 0;
+	size_t j, n;
 
 	/* Whole. */
 	n = malloc_snprintf(&buf[i], buflen-i, "%"FMTu64, t0 / t1);
 	i += n;
 	if (i >= buflen)
 		return;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/stress/microbench.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/stress/microbench.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/stress/microbench.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/stress/microbench.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,10 +1,11 @@
 #include "test/jemalloc_test.h"
 
 JEMALLOC_INLINE_C void
-time_func(timedelta_t *timer, uint64_t nwarmup, uint64_t niter, void (*func)(void))
+time_func(timedelta_t *timer, uint64_t nwarmup, uint64_t niter,
+    void (*func)(void))
 {
 	uint64_t i;
 
 	for (i = 0; i < nwarmup; i++)
 		func();
 	timer_start(timer);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/test.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/test.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/test.sh	2017-09-27 23:00:17.458936198 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/test.sh	2017-09-27 23:01:52.438932717 +0800
@@ -21,13 +21,13 @@
 fail_count=0
 for t in $@; do
   if [ $pass_count -ne 0 -o $skip_count -ne 0 -o $fail_count != 0 ] ; then
     echo
   fi
   echo "=== ${t} ==="
-  ${t} /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/
+  ${t} /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/
   result_code=$?
   case ${result_code} in
     ${pass_code})
       pass_count=$((pass_count+1))
       ;;
     ${skip_code})
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: a0.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: arena_reset.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/bitmap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/bitmap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/bitmap.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/bitmap.c	2017-01-31 23:32:23.000000000 +0800
@@ -3,13 +3,17 @@
 TEST_BEGIN(test_bitmap_size)
 {
 	size_t i, prev_size;
 
 	prev_size = 0;
 	for (i = 1; i <= BITMAP_MAXBITS; i++) {
-		size_t size = bitmap_size(i);
+		bitmap_info_t binfo;
+		size_t size;
+
+		bitmap_info_init(&binfo, i);
+		size = bitmap_size(&binfo);
 		assert_true(size >= prev_size,
 		    "Bitmap size is smaller than expected");
 		prev_size = size;
 	}
 }
 TEST_END
@@ -20,14 +24,14 @@
 
 	for (i = 1; i <= BITMAP_MAXBITS; i++) {
 		bitmap_info_t binfo;
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t *bitmap = (bitmap_t *)malloc(sizeof(bitmap_t) *
-				bitmap_info_ngroups(&binfo));
+			bitmap_t *bitmap = (bitmap_t *)malloc(
+			    bitmap_size(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++) {
 				assert_false(bitmap_get(bitmap, &binfo, j),
 				    "Bit should be unset");
 			}
@@ -43,14 +47,14 @@
 
 	for (i = 1; i <= BITMAP_MAXBITS; i++) {
 		bitmap_info_t binfo;
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t *bitmap = (bitmap_t *)malloc(sizeof(bitmap_t) *
-				bitmap_info_ngroups(&binfo));
+			bitmap_t *bitmap = (bitmap_t *)malloc(
+			    bitmap_size(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert_true(bitmap_full(bitmap, &binfo),
 			    "All bits should be set");
@@ -66,14 +70,14 @@
 
 	for (i = 1; i <= BITMAP_MAXBITS; i++) {
 		bitmap_info_t binfo;
 		bitmap_info_init(&binfo, i);
 		{
 			size_t j;
-			bitmap_t *bitmap = (bitmap_t *)malloc(sizeof(bitmap_t) *
-				bitmap_info_ngroups(&binfo));
+			bitmap_t *bitmap = (bitmap_t *)malloc(
+			    bitmap_size(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			for (j = 0; j < i; j++)
 				bitmap_set(bitmap, &binfo, j);
 			assert_true(bitmap_full(bitmap, &binfo),
 			    "All bits should be set");
@@ -94,15 +98,15 @@
 	size_t i;
 
 	for (i = 1; i <= BITMAP_MAXBITS; i++) {
 		bitmap_info_t binfo;
 		bitmap_info_init(&binfo, i);
 		{
-			ssize_t j;
-			bitmap_t *bitmap = (bitmap_t *)malloc(sizeof(bitmap_t) *
-				bitmap_info_ngroups(&binfo));
+			size_t j;
+			bitmap_t *bitmap = (bitmap_t *)malloc(
+			    bitmap_size(&binfo));
 			bitmap_init(bitmap, &binfo);
 
 			/* Iteratively set bits starting at the beginning. */
 			for (j = 0; j < i; j++) {
 				assert_zd_eq(bitmap_sfu(bitmap, &binfo), j,
 				    "First unset bit should be just after "
@@ -112,13 +116,13 @@
 			    "All bits should be set");
 
 			/*
 			 * Iteratively unset bits starting at the end, and
 			 * verify that bitmap_sfu() reaches the unset bits.
 			 */
-			for (j = i - 1; j >= 0; j--) {
+			for (j = i - 1; j < i; j--) { /* (i..0] */
 				bitmap_unset(bitmap, &binfo, j);
 				assert_zd_eq(bitmap_sfu(bitmap, &binfo), j,
 				    "First unset bit should the bit previously "
 				    "unset");
 				bitmap_unset(bitmap, &binfo, j);
 			}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/ckh.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/ckh.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/ckh.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/ckh.c	2017-01-31 23:32:23.000000000 +0800
@@ -4,14 +4,14 @@
 {
 	tsd_t *tsd;
 	ckh_t ckh;
 
 	tsd = tsd_fetch();
 
-	assert_false(ckh_new(tsd, &ckh, 2, ckh_string_hash, ckh_string_keycomp),
-	    "Unexpected ckh_new() error");
+	assert_false(ckh_new(tsd, &ckh, 2, ckh_string_hash,
+	    ckh_string_keycomp), "Unexpected ckh_new() error");
 	ckh_delete(tsd, &ckh);
 
 	assert_false(ckh_new(tsd, &ckh, 3, ckh_pointer_hash,
 	    ckh_pointer_keycomp), "Unexpected ckh_new() error");
 	ckh_delete(tsd, &ckh);
 }
@@ -29,14 +29,14 @@
 	};
 	const char *missing = "A string not in the hash table.";
 	size_t i;
 
 	tsd = tsd_fetch();
 
-	assert_false(ckh_new(tsd, &ckh, 2, ckh_string_hash, ckh_string_keycomp),
-	    "Unexpected ckh_new() error");
+	assert_false(ckh_new(tsd, &ckh, 2, ckh_string_hash,
+	    ckh_string_keycomp), "Unexpected ckh_new() error");
 	assert_zu_eq(ckh_count(&ckh), 0,
 	    "ckh_count() should return %zu, but it returned %zu", ZU(0),
 	    ckh_count(&ckh));
 
 	/* Insert. */
 	for (i = 0; i < sizeof(strs)/sizeof(const char *); i++) {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: decay.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: fork.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/hash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/hash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/hash.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/hash.c	2017-01-31 23:32:23.000000000 +0800
@@ -32,13 +32,13 @@
 typedef enum {
 	hash_variant_x86_32,
 	hash_variant_x86_128,
 	hash_variant_x64_128
 } hash_variant_t;
 
-static size_t
+static int
 hash_variant_bits(hash_variant_t variant)
 {
 
 	switch (variant) {
 	case hash_variant_x86_32: return (32);
 	case hash_variant_x86_128: return (128);
@@ -56,25 +56,26 @@
 	case hash_variant_x86_128: return ("hash_x86_128");
 	case hash_variant_x64_128: return ("hash_x64_128");
 	default: not_reached();
 	}
 }
 
+#define	KEY_SIZE	256
 static void
-hash_variant_verify(hash_variant_t variant)
+hash_variant_verify_key(hash_variant_t variant, uint8_t *key)
 {
-	const size_t hashbytes = hash_variant_bits(variant) / 8;
-	uint8_t key[256];
-	VARIABLE_ARRAY(uint8_t, hashes, hashbytes * 256);
+	const int hashbytes = hash_variant_bits(variant) / 8;
+	const int hashes_size = hashbytes * 256;
+	VARIABLE_ARRAY(uint8_t, hashes, hashes_size);
 	VARIABLE_ARRAY(uint8_t, final, hashbytes);
 	unsigned i;
 	uint32_t computed, expected;
 
-	memset(key, 0, sizeof(key));
-	memset(hashes, 0, sizeof(hashes));
-	memset(final, 0, sizeof(final));
+	memset(key, 0, KEY_SIZE);
+	memset(hashes, 0, hashes_size);
+	memset(final, 0, hashbytes);
 
 	/*
 	 * Hash keys of the form {0}, {0,1}, {0,1,2}, ..., {0,1,...,255} as the
 	 * seed.
 	 */
 	for (i = 0; i < 256; i++) {
@@ -99,23 +100,23 @@
 		}
 	}
 
 	/* Hash the result array. */
 	switch (variant) {
 	case hash_variant_x86_32: {
-		uint32_t out = hash_x86_32(hashes, hashbytes*256, 0);
+		uint32_t out = hash_x86_32(hashes, hashes_size, 0);
 		memcpy(final, &out, sizeof(out));
 		break;
 	} case hash_variant_x86_128: {
 		uint64_t out[2];
-		hash_x86_128(hashes, hashbytes*256, 0, out);
+		hash_x86_128(hashes, hashes_size, 0, out);
 		memcpy(final, out, sizeof(out));
 		break;
 	} case hash_variant_x64_128: {
 		uint64_t out[2];
-		hash_x64_128(hashes, hashbytes*256, 0, out);
+		hash_x64_128(hashes, hashes_size, 0, out);
 		memcpy(final, out, sizeof(out));
 		break;
 	} default: not_reached();
 	}
 
 	computed = (final[0] << 0) | (final[1] << 8) | (final[2] << 16) |
@@ -136,12 +137,25 @@
 
 	assert_u32_eq(computed, expected,
 	    "Hash mismatch for %s(): expected %#x but got %#x",
 	    hash_variant_string(variant), expected, computed);
 }
 
+static void
+hash_variant_verify(hash_variant_t variant)
+{
+#define	MAX_ALIGN	16
+	uint8_t key[KEY_SIZE + (MAX_ALIGN - 1)];
+	unsigned i;
+
+	for (i = 0; i < MAX_ALIGN; i++)
+		hash_variant_verify_key(variant, &key[i]);
+#undef MAX_ALIGN
+}
+#undef KEY_SIZE
+
 TEST_BEGIN(test_hash_x86_32)
 {
 
 	hash_variant_verify(hash_variant_x86_32);
 }
 TEST_END
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/junk.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/junk.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/junk.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/junk.c	2017-01-31 23:32:23.000000000 +0800
@@ -26,13 +26,13 @@
 arena_dalloc_junk_small_intercept(void *ptr, arena_bin_info_t *bin_info)
 {
 	size_t i;
 
 	arena_dalloc_junk_small_orig(ptr, bin_info);
 	for (i = 0; i < bin_info->reg_size; i++) {
-		assert_c_eq(((char *)ptr)[i], 0x5a,
+		assert_u_eq(((uint8_t *)ptr)[i], JEMALLOC_FREE_JUNK,
 		    "Missing junk fill for byte %zu/%zu of deallocated region",
 		    i, bin_info->reg_size);
 	}
 	if (ptr == watch_for_junking)
 		saw_junking = true;
 }
@@ -41,13 +41,13 @@
 arena_dalloc_junk_large_intercept(void *ptr, size_t usize)
 {
 	size_t i;
 
 	arena_dalloc_junk_large_orig(ptr, usize);
 	for (i = 0; i < usize; i++) {
-		assert_c_eq(((char *)ptr)[i], 0x5a,
+		assert_u_eq(((uint8_t *)ptr)[i], JEMALLOC_FREE_JUNK,
 		    "Missing junk fill for byte %zu/%zu of deallocated region",
 		    i, usize);
 	}
 	if (ptr == watch_for_junking)
 		saw_junking = true;
 }
@@ -66,51 +66,51 @@
 		saw_junking = true;
 }
 
 static void
 test_junk(size_t sz_min, size_t sz_max)
 {
-	char *s;
+	uint8_t *s;
 	size_t sz_prev, sz, i;
 
 	if (opt_junk_free) {
 		arena_dalloc_junk_small_orig = arena_dalloc_junk_small;
 		arena_dalloc_junk_small = arena_dalloc_junk_small_intercept;
 		arena_dalloc_junk_large_orig = arena_dalloc_junk_large;
 		arena_dalloc_junk_large = arena_dalloc_junk_large_intercept;
 		huge_dalloc_junk_orig = huge_dalloc_junk;
 		huge_dalloc_junk = huge_dalloc_junk_intercept;
 	}
 
 	sz_prev = 0;
-	s = (char *)mallocx(sz_min, 0);
+	s = (uint8_t *)mallocx(sz_min, 0);
 	assert_ptr_not_null((void *)s, "Unexpected mallocx() failure");
 
 	for (sz = sallocx(s, 0); sz <= sz_max;
 	    sz_prev = sz, sz = sallocx(s, 0)) {
 		if (sz_prev > 0) {
-			assert_c_eq(s[0], 'a',
+			assert_u_eq(s[0], 'a',
 			    "Previously allocated byte %zu/%zu is corrupted",
 			    ZU(0), sz_prev);
-			assert_c_eq(s[sz_prev-1], 'a',
+			assert_u_eq(s[sz_prev-1], 'a',
 			    "Previously allocated byte %zu/%zu is corrupted",
 			    sz_prev-1, sz_prev);
 		}
 
 		for (i = sz_prev; i < sz; i++) {
 			if (opt_junk_alloc) {
-				assert_c_eq(s[i], 0xa5,
+				assert_u_eq(s[i], JEMALLOC_ALLOC_JUNK,
 				    "Newly allocated byte %zu/%zu isn't "
 				    "junk-filled", i, sz);
 			}
 			s[i] = 'a';
 		}
 
 		if (xallocx(s, sz+1, 0, 0) == sz) {
 			watch_junking(s);
-			s = (char *)rallocx(s, sz+1, 0);
+			s = (uint8_t *)rallocx(s, sz+1, 0);
 			assert_ptr_not_null((void *)s,
 			    "Unexpected rallocx() failure");
 			assert_true(!opt_junk_free || saw_junking,
 			    "Expected region of size %zu to be junk-filled",
 			    sz);
 		}
@@ -241,13 +241,12 @@
 TEST_END
 
 int
 main(void)
 {
 
-	assert(!config_fill || opt_junk_alloc || opt_junk_free);
 	return (test(
 	    test_junk_small,
 	    test_junk_large,
 	    test_junk_huge,
 	    test_junk_large_ralloc_shrink,
 	    test_junk_redzone));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/mallctl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/mallctl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/mallctl.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/mallctl.c	2017-01-31 23:32:23.000000000 +0800
@@ -9,22 +9,24 @@
 	    "mallctl() should return ENOENT for non-existent names");
 
 	assert_d_eq(mallctl("version", NULL, NULL, "0.0.0", strlen("0.0.0")),
 	    EPERM, "mallctl() should return EPERM on attempt to write "
 	    "read-only value");
 
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)-1),
-	    EINVAL, "mallctl() should return EINVAL for input size mismatch");
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)+1),
-	    EINVAL, "mallctl() should return EINVAL for input size mismatch");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch,
+	    sizeof(epoch)-1), EINVAL,
+	    "mallctl() should return EINVAL for input size mismatch");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch,
+	    sizeof(epoch)+1), EINVAL,
+	    "mallctl() should return EINVAL for input size mismatch");
 
 	sz = sizeof(epoch)-1;
-	assert_d_eq(mallctl("epoch", &epoch, &sz, NULL, 0), EINVAL,
+	assert_d_eq(mallctl("epoch", (void *)&epoch, &sz, NULL, 0), EINVAL,
 	    "mallctl() should return EINVAL for output size mismatch");
 	sz = sizeof(epoch)+1;
-	assert_d_eq(mallctl("epoch", &epoch, &sz, NULL, 0), EINVAL,
+	assert_d_eq(mallctl("epoch", (void *)&epoch, &sz, NULL, 0), EINVAL,
 	    "mallctl() should return EINVAL for output size mismatch");
 }
 TEST_END
 
 TEST_BEGIN(test_mallctlnametomib_errors)
 {
@@ -53,24 +55,26 @@
 	    "attempt to write read-only value");
 
 	miblen = sizeof(mib)/sizeof(size_t);
 	assert_d_eq(mallctlnametomib("epoch", mib, &miblen), 0,
 	    "Unexpected mallctlnametomib() failure");
 
-	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &epoch,
+	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, (void *)&epoch,
 	    sizeof(epoch)-1), EINVAL,
 	    "mallctlbymib() should return EINVAL for input size mismatch");
-	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, &epoch,
+	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, (void *)&epoch,
 	    sizeof(epoch)+1), EINVAL,
 	    "mallctlbymib() should return EINVAL for input size mismatch");
 
 	sz = sizeof(epoch)-1;
-	assert_d_eq(mallctlbymib(mib, miblen, &epoch, &sz, NULL, 0), EINVAL,
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&epoch, &sz, NULL, 0),
+	    EINVAL,
 	    "mallctlbymib() should return EINVAL for output size mismatch");
 	sz = sizeof(epoch)+1;
-	assert_d_eq(mallctlbymib(mib, miblen, &epoch, &sz, NULL, 0), EINVAL,
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&epoch, &sz, NULL, 0),
+	    EINVAL,
 	    "mallctlbymib() should return EINVAL for output size mismatch");
 }
 TEST_END
 
 TEST_BEGIN(test_mallctl_read_write)
 {
@@ -80,24 +84,25 @@
 	/* Blind. */
 	assert_d_eq(mallctl("epoch", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl() failure");
 	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
 
 	/* Read. */
-	assert_d_eq(mallctl("epoch", &old_epoch, &sz, NULL, 0), 0,
+	assert_d_eq(mallctl("epoch", (void *)&old_epoch, &sz, NULL, 0), 0,
 	    "Unexpected mallctl() failure");
 	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
 
 	/* Write. */
-	assert_d_eq(mallctl("epoch", NULL, NULL, &new_epoch, sizeof(new_epoch)),
-	    0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&new_epoch,
+	    sizeof(new_epoch)), 0, "Unexpected mallctl() failure");
 	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
 
 	/* Read+write. */
-	assert_d_eq(mallctl("epoch", &old_epoch, &sz, &new_epoch,
-	    sizeof(new_epoch)), 0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", (void *)&old_epoch, &sz,
+	    (void *)&new_epoch, sizeof(new_epoch)), 0,
+	    "Unexpected mallctl() failure");
 	assert_zu_eq(sz, sizeof(old_epoch), "Unexpected output size");
 }
 TEST_END
 
 TEST_BEGIN(test_mallctlnametomib_short_mib)
 {
@@ -114,35 +119,36 @@
 }
 TEST_END
 
 TEST_BEGIN(test_mallctl_config)
 {
 
-#define	TEST_MALLCTL_CONFIG(config) do {				\
-	bool oldval;							\
+#define	TEST_MALLCTL_CONFIG(config, t) do {				\
+	t oldval;							\
 	size_t sz = sizeof(oldval);					\
-	assert_d_eq(mallctl("config."#config, &oldval, &sz, NULL, 0),	\
-	    0, "Unexpected mallctl() failure");				\
+	assert_d_eq(mallctl("config."#config, (void *)&oldval, &sz,	\
+	    NULL, 0), 0, "Unexpected mallctl() failure");		\
 	assert_b_eq(oldval, config_##config, "Incorrect config value");	\
 	assert_zu_eq(sz, sizeof(oldval), "Unexpected output size");	\
 } while (0)
 
-	TEST_MALLCTL_CONFIG(cache_oblivious);
-	TEST_MALLCTL_CONFIG(debug);
-	TEST_MALLCTL_CONFIG(fill);
-	TEST_MALLCTL_CONFIG(lazy_lock);
-	TEST_MALLCTL_CONFIG(munmap);
-	TEST_MALLCTL_CONFIG(prof);
-	TEST_MALLCTL_CONFIG(prof_libgcc);
-	TEST_MALLCTL_CONFIG(prof_libunwind);
-	TEST_MALLCTL_CONFIG(stats);
-	TEST_MALLCTL_CONFIG(tcache);
-	TEST_MALLCTL_CONFIG(tls);
-	TEST_MALLCTL_CONFIG(utrace);
-	TEST_MALLCTL_CONFIG(valgrind);
-	TEST_MALLCTL_CONFIG(xmalloc);
+	TEST_MALLCTL_CONFIG(cache_oblivious, bool);
+	TEST_MALLCTL_CONFIG(debug, bool);
+	TEST_MALLCTL_CONFIG(fill, bool);
+	TEST_MALLCTL_CONFIG(lazy_lock, bool);
+	TEST_MALLCTL_CONFIG(malloc_conf, const char *);
+	TEST_MALLCTL_CONFIG(munmap, bool);
+	TEST_MALLCTL_CONFIG(prof, bool);
+	TEST_MALLCTL_CONFIG(prof_libgcc, bool);
+	TEST_MALLCTL_CONFIG(prof_libunwind, bool);
+	TEST_MALLCTL_CONFIG(stats, bool);
+	TEST_MALLCTL_CONFIG(tcache, bool);
+	TEST_MALLCTL_CONFIG(tls, bool);
+	TEST_MALLCTL_CONFIG(utrace, bool);
+	TEST_MALLCTL_CONFIG(valgrind, bool);
+	TEST_MALLCTL_CONFIG(xmalloc, bool);
 
 #undef TEST_MALLCTL_CONFIG
 }
 TEST_END
 
 TEST_BEGIN(test_mallctl_opt)
@@ -150,23 +156,26 @@
 	bool config_always = true;
 
 #define	TEST_MALLCTL_OPT(t, opt, config) do {				\
 	t oldval;							\
 	size_t sz = sizeof(oldval);					\
 	int expected = config_##config ? 0 : ENOENT;			\
-	int result = mallctl("opt."#opt, &oldval, &sz, NULL, 0);	\
+	int result = mallctl("opt."#opt, (void *)&oldval, &sz, NULL,	\
+	    0);								\
 	assert_d_eq(result, expected,					\
 	    "Unexpected mallctl() result for opt."#opt);		\
 	assert_zu_eq(sz, sizeof(oldval), "Unexpected output size");	\
 } while (0)
 
 	TEST_MALLCTL_OPT(bool, abort, always);
 	TEST_MALLCTL_OPT(size_t, lg_chunk, always);
 	TEST_MALLCTL_OPT(const char *, dss, always);
-	TEST_MALLCTL_OPT(size_t, narenas, always);
+	TEST_MALLCTL_OPT(unsigned, narenas, always);
+	TEST_MALLCTL_OPT(const char *, purge, always);
 	TEST_MALLCTL_OPT(ssize_t, lg_dirty_mult, always);
+	TEST_MALLCTL_OPT(ssize_t, decay_time, always);
 	TEST_MALLCTL_OPT(bool, stats_print, always);
 	TEST_MALLCTL_OPT(const char *, junk, fill);
 	TEST_MALLCTL_OPT(size_t, quarantine, fill);
 	TEST_MALLCTL_OPT(bool, redzone, fill);
 	TEST_MALLCTL_OPT(bool, zero, fill);
 	TEST_MALLCTL_OPT(bool, utrace, utrace);
@@ -191,25 +200,25 @@
 {
 	unsigned nbins, i;
 	size_t mib[4];
 	size_t len, miblen;
 
 	len = sizeof(nbins);
-	assert_d_eq(mallctl("arenas.nbins", &nbins, &len, NULL, 0), 0,
+	assert_d_eq(mallctl("arenas.nbins", (void *)&nbins, &len, NULL, 0), 0,
 	    "Unexpected mallctl() failure");
 
 	miblen = 4;
 	assert_d_eq(mallctlnametomib("arenas.bin.0.size", mib, &miblen), 0,
 	    "Unexpected mallctlnametomib() failure");
 	for (i = 0; i < nbins; i++) {
 		size_t bin_size;
 
 		mib[2] = i;
 		len = sizeof(bin_size);
-		assert_d_eq(mallctlbymib(mib, miblen, &bin_size, &len, NULL, 0),
-		    0, "Unexpected mallctlbymib() failure");
+		assert_d_eq(mallctlbymib(mib, miblen, (void *)&bin_size, &len,
+		    NULL, 0), 0, "Unexpected mallctlbymib() failure");
 		/* Do something with bin_size... */
 	}
 }
 TEST_END
 
 TEST_BEGIN(test_tcache_none)
@@ -252,31 +261,31 @@
 	psz = 42;
 	qsz = nallocx(psz, 0) + 1;
 
 	/* Create tcaches. */
 	for (i = 0; i < NTCACHES; i++) {
 		sz = sizeof(unsigned);
-		assert_d_eq(mallctl("tcache.create", &tis[i], &sz, NULL, 0), 0,
-		    "Unexpected mallctl() failure, i=%u", i);
+		assert_d_eq(mallctl("tcache.create", (void *)&tis[i], &sz, NULL,
+		    0), 0, "Unexpected mallctl() failure, i=%u", i);
 	}
 
 	/* Exercise tcache ID recycling. */
 	for (i = 0; i < NTCACHES; i++) {
-		assert_d_eq(mallctl("tcache.destroy", NULL, NULL, &tis[i],
-		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
-		    i);
+		assert_d_eq(mallctl("tcache.destroy", NULL, NULL,
+		    (void *)&tis[i], sizeof(unsigned)), 0,
+		    "Unexpected mallctl() failure, i=%u", i);
 	}
 	for (i = 0; i < NTCACHES; i++) {
 		sz = sizeof(unsigned);
-		assert_d_eq(mallctl("tcache.create", &tis[i], &sz, NULL, 0), 0,
-		    "Unexpected mallctl() failure, i=%u", i);
+		assert_d_eq(mallctl("tcache.create", (void *)&tis[i], &sz, NULL,
+		    0), 0, "Unexpected mallctl() failure, i=%u", i);
 	}
 
 	/* Flush empty tcaches. */
 	for (i = 0; i < NTCACHES; i++) {
-		assert_d_eq(mallctl("tcache.flush", NULL, NULL, &tis[i],
+		assert_d_eq(mallctl("tcache.flush", NULL, NULL, (void *)&tis[i],
 		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
 		    i);
 	}
 
 	/* Cache some allocations. */
 	for (i = 0; i < NTCACHES; i++) {
@@ -315,194 +324,291 @@
 	}
 	for (i = 0; i < NTCACHES; i++)
 		dallocx(qs[i], MALLOCX_TCACHE(tis[i]));
 
 	/* Flush some non-empty tcaches. */
 	for (i = 0; i < NTCACHES/2; i++) {
-		assert_d_eq(mallctl("tcache.flush", NULL, NULL, &tis[i],
+		assert_d_eq(mallctl("tcache.flush", NULL, NULL, (void *)&tis[i],
 		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
 		    i);
 	}
 
 	/* Destroy tcaches. */
 	for (i = 0; i < NTCACHES; i++) {
-		assert_d_eq(mallctl("tcache.destroy", NULL, NULL, &tis[i],
-		    sizeof(unsigned)), 0, "Unexpected mallctl() failure, i=%u",
-		    i);
+		assert_d_eq(mallctl("tcache.destroy", NULL, NULL,
+		    (void *)&tis[i], sizeof(unsigned)), 0,
+		    "Unexpected mallctl() failure, i=%u", i);
 	}
 }
 TEST_END
 
 TEST_BEGIN(test_thread_arena)
 {
 	unsigned arena_old, arena_new, narenas;
 	size_t sz = sizeof(unsigned);
 
-	assert_d_eq(mallctl("arenas.narenas", &narenas, &sz, NULL, 0), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas, &sz, NULL, 0),
+	    0, "Unexpected mallctl() failure");
 	assert_u_eq(narenas, opt_narenas, "Number of arenas incorrect");
 	arena_new = narenas - 1;
-	assert_d_eq(mallctl("thread.arena", &arena_old, &sz, &arena_new,
-	    sizeof(unsigned)), 0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("thread.arena", (void *)&arena_old, &sz,
+	    (void *)&arena_new, sizeof(unsigned)), 0,
+	    "Unexpected mallctl() failure");
 	arena_new = 0;
-	assert_d_eq(mallctl("thread.arena", &arena_old, &sz, &arena_new,
-	    sizeof(unsigned)), 0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("thread.arena", (void *)&arena_old, &sz,
+	    (void *)&arena_new, sizeof(unsigned)), 0,
+	    "Unexpected mallctl() failure");
 }
 TEST_END
 
 TEST_BEGIN(test_arena_i_lg_dirty_mult)
 {
 	ssize_t lg_dirty_mult, orig_lg_dirty_mult, prev_lg_dirty_mult;
 	size_t sz = sizeof(ssize_t);
 
-	assert_d_eq(mallctl("arena.0.lg_dirty_mult", &orig_lg_dirty_mult, &sz,
-	    NULL, 0), 0, "Unexpected mallctl() failure");
+	test_skip_if(opt_purge != purge_mode_ratio);
+
+	assert_d_eq(mallctl("arena.0.lg_dirty_mult",
+	    (void *)&orig_lg_dirty_mult, &sz, NULL, 0), 0,
+	    "Unexpected mallctl() failure");
 
 	lg_dirty_mult = -2;
 	assert_d_eq(mallctl("arena.0.lg_dirty_mult", NULL, NULL,
-	    &lg_dirty_mult, sizeof(ssize_t)), EFAULT,
+	    (void *)&lg_dirty_mult, sizeof(ssize_t)), EFAULT,
 	    "Unexpected mallctl() success");
 
 	lg_dirty_mult = (sizeof(size_t) << 3);
 	assert_d_eq(mallctl("arena.0.lg_dirty_mult", NULL, NULL,
-	    &lg_dirty_mult, sizeof(ssize_t)), EFAULT,
+	    (void *)&lg_dirty_mult, sizeof(ssize_t)), EFAULT,
 	    "Unexpected mallctl() success");
 
 	for (prev_lg_dirty_mult = orig_lg_dirty_mult, lg_dirty_mult = -1;
 	    lg_dirty_mult < (ssize_t)(sizeof(size_t) << 3); prev_lg_dirty_mult
 	    = lg_dirty_mult, lg_dirty_mult++) {
 		ssize_t old_lg_dirty_mult;
 
-		assert_d_eq(mallctl("arena.0.lg_dirty_mult", &old_lg_dirty_mult,
-		    &sz, &lg_dirty_mult, sizeof(ssize_t)), 0,
-		    "Unexpected mallctl() failure");
+		assert_d_eq(mallctl("arena.0.lg_dirty_mult",
+		    (void *)&old_lg_dirty_mult, &sz, (void *)&lg_dirty_mult,
+		    sizeof(ssize_t)), 0, "Unexpected mallctl() failure");
 		assert_zd_eq(old_lg_dirty_mult, prev_lg_dirty_mult,
 		    "Unexpected old arena.0.lg_dirty_mult");
 	}
 }
 TEST_END
 
+TEST_BEGIN(test_arena_i_decay_time)
+{
+	ssize_t decay_time, orig_decay_time, prev_decay_time;
+	size_t sz = sizeof(ssize_t);
+
+	test_skip_if(opt_purge != purge_mode_decay);
+
+	assert_d_eq(mallctl("arena.0.decay_time", (void *)&orig_decay_time, &sz,
+	    NULL, 0), 0, "Unexpected mallctl() failure");
+
+	decay_time = -2;
+	assert_d_eq(mallctl("arena.0.decay_time", NULL, NULL,
+	    (void *)&decay_time, sizeof(ssize_t)), EFAULT,
+	    "Unexpected mallctl() success");
+
+	decay_time = 0x7fffffff;
+	assert_d_eq(mallctl("arena.0.decay_time", NULL, NULL,
+	    (void *)&decay_time, sizeof(ssize_t)), 0,
+	    "Unexpected mallctl() failure");
+
+	for (prev_decay_time = decay_time, decay_time = -1;
+	    decay_time < 20; prev_decay_time = decay_time, decay_time++) {
+		ssize_t old_decay_time;
+
+		assert_d_eq(mallctl("arena.0.decay_time", (void *)&old_decay_time,
+		    &sz, (void *)&decay_time, sizeof(ssize_t)), 0,
+		    "Unexpected mallctl() failure");
+		assert_zd_eq(old_decay_time, prev_decay_time,
+		    "Unexpected old arena.0.decay_time");
+	}
+}
+TEST_END
+
 TEST_BEGIN(test_arena_i_purge)
 {
 	unsigned narenas;
 	size_t sz = sizeof(unsigned);
 	size_t mib[3];
 	size_t miblen = 3;
 
 	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl() failure");
 
-	assert_d_eq(mallctl("arenas.narenas", &narenas, &sz, NULL, 0), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas, &sz, NULL, 0),
+	    0, "Unexpected mallctl() failure");
 	assert_d_eq(mallctlnametomib("arena.0.purge", mib, &miblen), 0,
 	    "Unexpected mallctlnametomib() failure");
 	mib[1] = narenas;
 	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctlbymib() failure");
 }
 TEST_END
 
+TEST_BEGIN(test_arena_i_decay)
+{
+	unsigned narenas;
+	size_t sz = sizeof(unsigned);
+	size_t mib[3];
+	size_t miblen = 3;
+
+	assert_d_eq(mallctl("arena.0.decay", NULL, NULL, NULL, 0), 0,
+	    "Unexpected mallctl() failure");
+
+	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas, &sz, NULL, 0),
+	    0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctlnametomib("arena.0.decay", mib, &miblen), 0,
+	    "Unexpected mallctlnametomib() failure");
+	mib[1] = narenas;
+	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
+	    "Unexpected mallctlbymib() failure");
+}
+TEST_END
+
 TEST_BEGIN(test_arena_i_dss)
 {
 	const char *dss_prec_old, *dss_prec_new;
 	size_t sz = sizeof(dss_prec_old);
 	size_t mib[3];
 	size_t miblen;
 
 	miblen = sizeof(mib)/sizeof(size_t);
 	assert_d_eq(mallctlnametomib("arena.0.dss", mib, &miblen), 0,
 	    "Unexpected mallctlnametomib() error");
 
 	dss_prec_new = "disabled";
-	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_old, &sz, &dss_prec_new,
-	    sizeof(dss_prec_new)), 0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_old, &sz,
+	    (void *)&dss_prec_new, sizeof(dss_prec_new)), 0,
+	    "Unexpected mallctl() failure");
 	assert_str_ne(dss_prec_old, "primary",
 	    "Unexpected default for dss precedence");
 
-	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_new, &sz, &dss_prec_old,
-	    sizeof(dss_prec_old)), 0, "Unexpected mallctl() failure");
-
-	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_old, &sz, NULL, 0), 0,
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_new, &sz,
+	    (void *)&dss_prec_old, sizeof(dss_prec_old)), 0,
 	    "Unexpected mallctl() failure");
+
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_old, &sz, NULL,
+	    0), 0, "Unexpected mallctl() failure");
 	assert_str_ne(dss_prec_old, "primary",
 	    "Unexpected value for dss precedence");
 
 	mib[1] = narenas_total_get();
 	dss_prec_new = "disabled";
-	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_old, &sz, &dss_prec_new,
-	    sizeof(dss_prec_new)), 0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_old, &sz,
+	    (void *)&dss_prec_new, sizeof(dss_prec_new)), 0,
+	    "Unexpected mallctl() failure");
 	assert_str_ne(dss_prec_old, "primary",
 	    "Unexpected default for dss precedence");
 
-	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_new, &sz, &dss_prec_old,
-	    sizeof(dss_prec_new)), 0, "Unexpected mallctl() failure");
-
-	assert_d_eq(mallctlbymib(mib, miblen, &dss_prec_old, &sz, NULL, 0), 0,
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_new, &sz,
+	    (void *)&dss_prec_old, sizeof(dss_prec_new)), 0,
 	    "Unexpected mallctl() failure");
+
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&dss_prec_old, &sz, NULL,
+	    0), 0, "Unexpected mallctl() failure");
 	assert_str_ne(dss_prec_old, "primary",
 	    "Unexpected value for dss precedence");
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_initialized)
 {
 	unsigned narenas;
 	size_t sz = sizeof(narenas);
 
-	assert_d_eq(mallctl("arenas.narenas", &narenas, &sz, NULL, 0), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas, &sz, NULL, 0),
+	    0, "Unexpected mallctl() failure");
 	{
 		VARIABLE_ARRAY(bool, initialized, narenas);
 
 		sz = narenas * sizeof(bool);
-		assert_d_eq(mallctl("arenas.initialized", initialized, &sz,
-		    NULL, 0), 0, "Unexpected mallctl() failure");
+		assert_d_eq(mallctl("arenas.initialized", (void *)initialized,
+		    &sz, NULL, 0), 0, "Unexpected mallctl() failure");
 	}
 }
 TEST_END
 
 TEST_BEGIN(test_arenas_lg_dirty_mult)
 {
 	ssize_t lg_dirty_mult, orig_lg_dirty_mult, prev_lg_dirty_mult;
 	size_t sz = sizeof(ssize_t);
 
-	assert_d_eq(mallctl("arenas.lg_dirty_mult", &orig_lg_dirty_mult, &sz,
-	    NULL, 0), 0, "Unexpected mallctl() failure");
+	test_skip_if(opt_purge != purge_mode_ratio);
+
+	assert_d_eq(mallctl("arenas.lg_dirty_mult", (void *)&orig_lg_dirty_mult,
+	    &sz, NULL, 0), 0, "Unexpected mallctl() failure");
 
 	lg_dirty_mult = -2;
 	assert_d_eq(mallctl("arenas.lg_dirty_mult", NULL, NULL,
-	    &lg_dirty_mult, sizeof(ssize_t)), EFAULT,
+	    (void *)&lg_dirty_mult, sizeof(ssize_t)), EFAULT,
 	    "Unexpected mallctl() success");
 
 	lg_dirty_mult = (sizeof(size_t) << 3);
 	assert_d_eq(mallctl("arenas.lg_dirty_mult", NULL, NULL,
-	    &lg_dirty_mult, sizeof(ssize_t)), EFAULT,
+	    (void *)&lg_dirty_mult, sizeof(ssize_t)), EFAULT,
 	    "Unexpected mallctl() success");
 
 	for (prev_lg_dirty_mult = orig_lg_dirty_mult, lg_dirty_mult = -1;
 	    lg_dirty_mult < (ssize_t)(sizeof(size_t) << 3); prev_lg_dirty_mult =
 	    lg_dirty_mult, lg_dirty_mult++) {
 		ssize_t old_lg_dirty_mult;
 
-		assert_d_eq(mallctl("arenas.lg_dirty_mult", &old_lg_dirty_mult,
-		    &sz, &lg_dirty_mult, sizeof(ssize_t)), 0,
-		    "Unexpected mallctl() failure");
+		assert_d_eq(mallctl("arenas.lg_dirty_mult",
+		    (void *)&old_lg_dirty_mult, &sz, (void *)&lg_dirty_mult,
+		    sizeof(ssize_t)), 0, "Unexpected mallctl() failure");
 		assert_zd_eq(old_lg_dirty_mult, prev_lg_dirty_mult,
 		    "Unexpected old arenas.lg_dirty_mult");
 	}
 }
 TEST_END
 
+TEST_BEGIN(test_arenas_decay_time)
+{
+	ssize_t decay_time, orig_decay_time, prev_decay_time;
+	size_t sz = sizeof(ssize_t);
+
+	test_skip_if(opt_purge != purge_mode_decay);
+
+	assert_d_eq(mallctl("arenas.decay_time", (void *)&orig_decay_time, &sz,
+	    NULL, 0), 0, "Unexpected mallctl() failure");
+
+	decay_time = -2;
+	assert_d_eq(mallctl("arenas.decay_time", NULL, NULL,
+	    (void *)&decay_time, sizeof(ssize_t)), EFAULT,
+	    "Unexpected mallctl() success");
+
+	decay_time = 0x7fffffff;
+	assert_d_eq(mallctl("arenas.decay_time", NULL, NULL,
+	    (void *)&decay_time, sizeof(ssize_t)), 0,
+	    "Expected mallctl() failure");
+
+	for (prev_decay_time = decay_time, decay_time = -1;
+	    decay_time < 20; prev_decay_time = decay_time, decay_time++) {
+		ssize_t old_decay_time;
+
+		assert_d_eq(mallctl("arenas.decay_time",
+		    (void *)&old_decay_time, &sz, (void *)&decay_time,
+		    sizeof(ssize_t)), 0, "Unexpected mallctl() failure");
+		assert_zd_eq(old_decay_time, prev_decay_time,
+		    "Unexpected old arenas.decay_time");
+	}
+}
+TEST_END
+
 TEST_BEGIN(test_arenas_constants)
 {
 
 #define	TEST_ARENAS_CONSTANT(t, name, expected) do {			\
 	t name;								\
 	size_t sz = sizeof(t);						\
-	assert_d_eq(mallctl("arenas."#name, &name, &sz, NULL, 0), 0,	\
-	    "Unexpected mallctl() failure");				\
+	assert_d_eq(mallctl("arenas."#name, (void *)&name, &sz, NULL,	\
+	    0), 0, "Unexpected mallctl() failure");			\
 	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
 } while (0)
 
 	TEST_ARENAS_CONSTANT(size_t, quantum, QUANTUM);
 	TEST_ARENAS_CONSTANT(size_t, page, PAGE);
 	TEST_ARENAS_CONSTANT(unsigned, nbins, NBINS);
@@ -516,14 +622,14 @@
 TEST_BEGIN(test_arenas_bin_constants)
 {
 
 #define	TEST_ARENAS_BIN_CONSTANT(t, name, expected) do {		\
 	t name;								\
 	size_t sz = sizeof(t);						\
-	assert_d_eq(mallctl("arenas.bin.0."#name, &name, &sz, NULL, 0),	\
-	    0, "Unexpected mallctl() failure");				\
+	assert_d_eq(mallctl("arenas.bin.0."#name, (void *)&name, &sz,	\
+	    NULL, 0), 0, "Unexpected mallctl() failure");		\
 	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
 } while (0)
 
 	TEST_ARENAS_BIN_CONSTANT(size_t, size, arena_bin_info[0].reg_size);
 	TEST_ARENAS_BIN_CONSTANT(uint32_t, nregs, arena_bin_info[0].nregs);
 	TEST_ARENAS_BIN_CONSTANT(size_t, run_size, arena_bin_info[0].run_size);
@@ -535,14 +641,14 @@
 TEST_BEGIN(test_arenas_lrun_constants)
 {
 
 #define	TEST_ARENAS_LRUN_CONSTANT(t, name, expected) do {		\
 	t name;								\
 	size_t sz = sizeof(t);						\
-	assert_d_eq(mallctl("arenas.lrun.0."#name, &name, &sz, NULL,	\
-	    0), 0, "Unexpected mallctl() failure");			\
+	assert_d_eq(mallctl("arenas.lrun.0."#name, (void *)&name, &sz,	\
+	    NULL, 0), 0, "Unexpected mallctl() failure");		\
 	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
 } while (0)
 
 	TEST_ARENAS_LRUN_CONSTANT(size_t, size, LARGE_MINCLASS);
 
 #undef TEST_ARENAS_LRUN_CONSTANT
@@ -552,14 +658,14 @@
 TEST_BEGIN(test_arenas_hchunk_constants)
 {
 
 #define	TEST_ARENAS_HCHUNK_CONSTANT(t, name, expected) do {		\
 	t name;								\
 	size_t sz = sizeof(t);						\
-	assert_d_eq(mallctl("arenas.hchunk.0."#name, &name, &sz, NULL,	\
-	    0), 0, "Unexpected mallctl() failure");			\
+	assert_d_eq(mallctl("arenas.hchunk.0."#name, (void *)&name,	\
+	    &sz, NULL, 0), 0, "Unexpected mallctl() failure");		\
 	assert_zu_eq(name, expected, "Incorrect "#name" size");		\
 } while (0)
 
 	TEST_ARENAS_HCHUNK_CONSTANT(size_t, size, chunksize);
 
 #undef TEST_ARENAS_HCHUNK_CONSTANT
@@ -568,18 +674,18 @@
 
 TEST_BEGIN(test_arenas_extend)
 {
 	unsigned narenas_before, arena, narenas_after;
 	size_t sz = sizeof(unsigned);
 
-	assert_d_eq(mallctl("arenas.narenas", &narenas_before, &sz, NULL, 0), 0,
-	    "Unexpected mallctl() failure");
-	assert_d_eq(mallctl("arenas.extend", &arena, &sz, NULL, 0), 0,
-	    "Unexpected mallctl() failure");
-	assert_d_eq(mallctl("arenas.narenas", &narenas_after, &sz, NULL, 0), 0,
+	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas_before, &sz,
+	    NULL, 0), 0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("arenas.extend", (void *)&arena, &sz, NULL, 0), 0,
 	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("arenas.narenas", (void *)&narenas_after, &sz, NULL,
+	    0), 0, "Unexpected mallctl() failure");
 
 	assert_u_eq(narenas_before+1, narenas_after,
 	    "Unexpected number of arenas before versus after extension");
 	assert_u_eq(arena, narenas_after-1, "Unexpected arena index");
 }
 TEST_END
@@ -587,18 +693,20 @@
 TEST_BEGIN(test_stats_arenas)
 {
 
 #define	TEST_STATS_ARENAS(t, name) do {					\
 	t name;								\
 	size_t sz = sizeof(t);						\
-	assert_d_eq(mallctl("stats.arenas.0."#name, &name, &sz, NULL,	\
-	    0), 0, "Unexpected mallctl() failure");			\
+	assert_d_eq(mallctl("stats.arenas.0."#name, (void *)&name, &sz,	\
+	    NULL, 0), 0, "Unexpected mallctl() failure");		\
 } while (0)
 
-	TEST_STATS_ARENAS(const char *, dss);
 	TEST_STATS_ARENAS(unsigned, nthreads);
+	TEST_STATS_ARENAS(const char *, dss);
+	TEST_STATS_ARENAS(ssize_t, lg_dirty_mult);
+	TEST_STATS_ARENAS(ssize_t, decay_time);
 	TEST_STATS_ARENAS(size_t, pactive);
 	TEST_STATS_ARENAS(size_t, pdirty);
 
 #undef TEST_STATS_ARENAS
 }
 TEST_END
@@ -617,16 +725,19 @@
 	    test_mallctl_opt,
 	    test_manpage_example,
 	    test_tcache_none,
 	    test_tcache,
 	    test_thread_arena,
 	    test_arena_i_lg_dirty_mult,
+	    test_arena_i_decay_time,
 	    test_arena_i_purge,
+	    test_arena_i_decay,
 	    test_arena_i_dss,
 	    test_arenas_initialized,
 	    test_arenas_lg_dirty_mult,
+	    test_arenas_decay_time,
 	    test_arenas_constants,
 	    test_arenas_bin_constants,
 	    test_arenas_lrun_constants,
 	    test_arenas_hchunk_constants,
 	    test_arenas_extend,
 	    test_stats_arenas));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/math.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/math.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/math.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/math.c	2017-01-31 23:32:23.000000000 +0800
@@ -2,12 +2,16 @@
 
 #define	MAX_REL_ERR 1.0e-9
 #define	MAX_ABS_ERR 1.0e-9
 
 #include <float.h>
 
+#ifdef __PGI
+#undef INFINITY
+#endif
+
 #ifndef INFINITY
 #define	INFINITY (DBL_MAX + DBL_MAX)
 #endif
 
 static bool
 double_eq_rel(double a, double b, double max_rel_err, double max_abs_err)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: nstime.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: pack.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: pages.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: ph.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: prng.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_accum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_accum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_accum.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_accum.c	2017-01-31 23:32:23.000000000 +0800
@@ -65,14 +65,15 @@
 	unsigned thd_args[NTHREADS];
 	unsigned i;
 
 	test_skip_if(!config_prof);
 
 	active = true;
-	assert_d_eq(mallctl("prof.active", NULL, NULL, &active, sizeof(active)),
-	    0, "Unexpected mallctl failure while activating profiling");
+	assert_d_eq(mallctl("prof.active", NULL, NULL, (void *)&active,
+	    sizeof(active)), 0,
+	    "Unexpected mallctl failure while activating profiling");
 
 	prof_dump_open = prof_dump_open_intercept;
 
 	for (i = 0; i < NTHREADS; i++) {
 		thd_args[i] = i;
 		thd_create(&thds[i], thd_start, (void *)&thd_args[i]);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_active.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_active.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_active.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_active.c	2017-01-31 23:32:23.000000000 +0800
@@ -9,13 +9,13 @@
 mallctl_bool_get(const char *name, bool expected, const char *func, int line)
 {
 	bool old;
 	size_t sz;
 
 	sz = sizeof(old);
-	assert_d_eq(mallctl(name, &old, &sz, NULL, 0), 0,
+	assert_d_eq(mallctl(name, (void *)&old, &sz, NULL, 0), 0,
 	    "%s():%d: Unexpected mallctl failure reading %s", func, line, name);
 	assert_b_eq(old, expected, "%s():%d: Unexpected %s value", func, line,
 	    name);
 }
 
 static void
@@ -23,13 +23,14 @@
     const char *func, int line)
 {
 	bool old;
 	size_t sz;
 
 	sz = sizeof(old);
-	assert_d_eq(mallctl(name, &old, &sz, &val_new, sizeof(val_new)), 0,
+	assert_d_eq(mallctl(name, (void *)&old, &sz, (void *)&val_new,
+	    sizeof(val_new)), 0,
 	    "%s():%d: Unexpected mallctl failure reading/writing %s", func,
 	    line, name);
 	assert_b_eq(old, old_expected, "%s():%d: Unexpected %s value", func,
 	    line, name);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_gdump.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_gdump.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_gdump.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_gdump.c	2017-01-31 23:32:23.000000000 +0800
@@ -25,14 +25,15 @@
 	void *p, *q, *r, *s;
 	size_t sz;
 
 	test_skip_if(!config_prof);
 
 	active = true;
-	assert_d_eq(mallctl("prof.active", NULL, NULL, &active, sizeof(active)),
-	    0, "Unexpected mallctl failure while activating profiling");
+	assert_d_eq(mallctl("prof.active", NULL, NULL, (void *)&active,
+	    sizeof(active)), 0,
+	    "Unexpected mallctl failure while activating profiling");
 
 	prof_dump_open = prof_dump_open_intercept;
 
 	did_prof_dump_open = false;
 	p = mallocx(chunksize, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
@@ -42,25 +43,25 @@
 	q = mallocx(chunksize, 0);
 	assert_ptr_not_null(q, "Unexpected mallocx() failure");
 	assert_true(did_prof_dump_open, "Expected a profile dump");
 
 	gdump = false;
 	sz = sizeof(gdump_old);
-	assert_d_eq(mallctl("prof.gdump", &gdump_old, &sz, &gdump,
-	    sizeof(gdump)), 0,
+	assert_d_eq(mallctl("prof.gdump", (void *)&gdump_old, &sz,
+	    (void *)&gdump, sizeof(gdump)), 0,
 	    "Unexpected mallctl failure while disabling prof.gdump");
 	assert(gdump_old);
 	did_prof_dump_open = false;
 	r = mallocx(chunksize, 0);
 	assert_ptr_not_null(q, "Unexpected mallocx() failure");
 	assert_false(did_prof_dump_open, "Unexpected profile dump");
 
 	gdump = true;
 	sz = sizeof(gdump_old);
-	assert_d_eq(mallctl("prof.gdump", &gdump_old, &sz, &gdump,
-	    sizeof(gdump)), 0,
+	assert_d_eq(mallctl("prof.gdump", (void *)&gdump_old, &sz,
+	    (void *)&gdump, sizeof(gdump)), 0,
 	    "Unexpected mallctl failure while enabling prof.gdump");
 	assert(!gdump_old);
 	did_prof_dump_open = false;
 	s = mallocx(chunksize, 0);
 	assert_ptr_not_null(q, "Unexpected mallocx() failure");
 	assert_true(did_prof_dump_open, "Expected a profile dump");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_idump.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_idump.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_idump.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_idump.c	2017-01-31 23:32:23.000000000 +0800
@@ -26,14 +26,15 @@
 	bool active;
 	void *p;
 
 	test_skip_if(!config_prof);
 
 	active = true;
-	assert_d_eq(mallctl("prof.active", NULL, NULL, &active, sizeof(active)),
-	    0, "Unexpected mallctl failure while activating profiling");
+	assert_d_eq(mallctl("prof.active", NULL, NULL, (void *)&active,
+	    sizeof(active)), 0,
+	    "Unexpected mallctl failure while activating profiling");
 
 	prof_dump_open = prof_dump_open_intercept;
 
 	did_prof_dump_open = false;
 	p = mallocx(1, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_reset.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_reset.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_reset.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_reset.c	2017-01-31 23:32:23.000000000 +0800
@@ -17,32 +17,33 @@
 }
 
 static void
 set_prof_active(bool active)
 {
 
-	assert_d_eq(mallctl("prof.active", NULL, NULL, &active, sizeof(active)),
-	    0, "Unexpected mallctl failure");
+	assert_d_eq(mallctl("prof.active", NULL, NULL, (void *)&active,
+	    sizeof(active)), 0, "Unexpected mallctl failure");
 }
 
 static size_t
 get_lg_prof_sample(void)
 {
 	size_t lg_prof_sample;
 	size_t sz = sizeof(size_t);
 
-	assert_d_eq(mallctl("prof.lg_sample", &lg_prof_sample, &sz, NULL, 0), 0,
+	assert_d_eq(mallctl("prof.lg_sample", (void *)&lg_prof_sample, &sz,
+	    NULL, 0), 0,
 	    "Unexpected mallctl failure while reading profiling sample rate");
 	return (lg_prof_sample);
 }
 
 static void
 do_prof_reset(size_t lg_prof_sample)
 {
 	assert_d_eq(mallctl("prof.reset", NULL, NULL,
-	    &lg_prof_sample, sizeof(size_t)), 0,
+	    (void *)&lg_prof_sample, sizeof(size_t)), 0,
 	    "Unexpected mallctl failure while resetting profile data");
 	assert_zu_eq(lg_prof_sample, get_lg_prof_sample(),
 	    "Expected profile sample rate change");
 }
 
 TEST_BEGIN(test_prof_reset_basic)
@@ -51,14 +52,14 @@
 	size_t sz;
 	unsigned i;
 
 	test_skip_if(!config_prof);
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("opt.lg_prof_sample", &lg_prof_sample_orig, &sz,
-	    NULL, 0), 0,
+	assert_d_eq(mallctl("opt.lg_prof_sample", (void *)&lg_prof_sample_orig,
+	    &sz, NULL, 0), 0,
 	    "Unexpected mallctl failure while reading profiling sample rate");
 	assert_zu_eq(lg_prof_sample_orig, 0,
 	    "Unexpected profiling sample rate");
 	lg_prof_sample = get_lg_prof_sample();
 	assert_zu_eq(lg_prof_sample_orig, lg_prof_sample,
 	    "Unexpected disagreement between \"opt.lg_prof_sample\" and "
@@ -91,13 +92,14 @@
 }
 TEST_END
 
 bool prof_dump_header_intercepted = false;
 prof_cnt_t cnt_all_copy = {0, 0, 0, 0};
 static bool
-prof_dump_header_intercept(bool propagate_err, const prof_cnt_t *cnt_all)
+prof_dump_header_intercept(tsdn_t *tsdn, bool propagate_err,
+    const prof_cnt_t *cnt_all)
 {
 
 	prof_dump_header_intercepted = true;
 	memcpy(&cnt_all_copy, cnt_all, sizeof(prof_cnt_t));
 
 	return (false);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_thread_name.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_thread_name.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/prof_thread_name.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/prof_thread_name.c	2017-01-31 23:32:23.000000000 +0800
@@ -9,28 +9,29 @@
     int line)
 {
 	const char *thread_name_old;
 	size_t sz;
 
 	sz = sizeof(thread_name_old);
-	assert_d_eq(mallctl("thread.prof.name", &thread_name_old, &sz, NULL, 0),
-	    0, "%s():%d: Unexpected mallctl failure reading thread.prof.name",
+	assert_d_eq(mallctl("thread.prof.name", (void *)&thread_name_old, &sz,
+	    NULL, 0), 0,
+	    "%s():%d: Unexpected mallctl failure reading thread.prof.name",
 	    func, line);
 	assert_str_eq(thread_name_old, thread_name_expected,
 	    "%s():%d: Unexpected thread.prof.name value", func, line);
 }
 #define	mallctl_thread_name_get(a)					\
 	mallctl_thread_name_get_impl(a, __func__, __LINE__)
 
 static void
 mallctl_thread_name_set_impl(const char *thread_name, const char *func,
     int line)
 {
 
-	assert_d_eq(mallctl("thread.prof.name", NULL, NULL, &thread_name,
-	    sizeof(thread_name)), 0,
+	assert_d_eq(mallctl("thread.prof.name", NULL, NULL,
+	    (void *)&thread_name, sizeof(thread_name)), 0,
 	    "%s():%d: Unexpected mallctl failure reading thread.prof.name",
 	    func, line);
 	mallctl_thread_name_get_impl(thread_name, func, line);
 }
 #define	mallctl_thread_name_set(a)					\
 	mallctl_thread_name_set_impl(a, __func__, __LINE__)
@@ -43,32 +44,33 @@
 
 	mallctl_thread_name_get("");
 	mallctl_thread_name_set("hi there");
 
 	/* NULL input shouldn't be allowed. */
 	thread_name = NULL;
-	assert_d_eq(mallctl("thread.prof.name", NULL, NULL, &thread_name,
-	    sizeof(thread_name)), EFAULT,
+	assert_d_eq(mallctl("thread.prof.name", NULL, NULL,
+	    (void *)&thread_name, sizeof(thread_name)), EFAULT,
 	    "Unexpected mallctl result writing \"%s\" to thread.prof.name",
 	    thread_name);
 
 	/* '\n' shouldn't be allowed. */
 	thread_name = "hi\nthere";
-	assert_d_eq(mallctl("thread.prof.name", NULL, NULL, &thread_name,
-	    sizeof(thread_name)), EFAULT,
+	assert_d_eq(mallctl("thread.prof.name", NULL, NULL,
+	    (void *)&thread_name, sizeof(thread_name)), EFAULT,
 	    "Unexpected mallctl result writing \"%s\" to thread.prof.name",
 	    thread_name);
 
 	/* Simultaneous read/write shouldn't be allowed. */
 	{
 		const char *thread_name_old;
 		size_t sz;
 
 		sz = sizeof(thread_name_old);
-		assert_d_eq(mallctl("thread.prof.name", &thread_name_old, &sz,
-		    &thread_name, sizeof(thread_name)), EPERM,
+		assert_d_eq(mallctl("thread.prof.name",
+		    (void *)&thread_name_old, &sz, (void *)&thread_name,
+		    sizeof(thread_name)), EPERM,
 		    "Unexpected mallctl result writing \"%s\" to "
 		    "thread.prof.name", thread_name);
 	}
 
 	mallctl_thread_name_set("");
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/rb.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/rb.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/rb.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/rb.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,12 +1,12 @@
 #include "test/jemalloc_test.h"
 
 #define	rbtn_black_height(a_type, a_field, a_rbt, r_height) do {	\
     a_type *rbp_bh_t;							\
     for (rbp_bh_t = (a_rbt)->rbt_root, (r_height) = 0;			\
-      rbp_bh_t != &(a_rbt)->rbt_nil;					\
+	 rbp_bh_t != NULL;						\
       rbp_bh_t = rbtn_left_get(a_type, a_field, rbp_bh_t)) {		\
 	if (!rbtn_red_get(a_type, a_field, rbp_bh_t)) {			\
 	    (r_height)++;						\
 	}								\
     }									\
 } while (0)
@@ -18,13 +18,13 @@
 	uint32_t magic;
 	rb_node(node_t) link;
 	uint64_t key;
 };
 
 static int
-node_cmp(node_t *a, node_t *b) {
+node_cmp(const node_t *a, const node_t *b) {
 	int ret;
 
 	assert_u32_eq(a->magic, NODE_MAGIC, "Bad magic");
 	assert_u32_eq(b->magic, NODE_MAGIC, "Bad magic");
 
 	ret = (a->key > b->key) - (a->key < b->key);
@@ -65,44 +65,49 @@
 	key.magic = NODE_MAGIC;
 	assert_ptr_null(tree_psearch(&tree, &key), "Unexpected node");
 }
 TEST_END
 
 static unsigned
-tree_recurse(node_t *node, unsigned black_height, unsigned black_depth,
-    node_t *nil)
+tree_recurse(node_t *node, unsigned black_height, unsigned black_depth)
 {
 	unsigned ret = 0;
-	node_t *left_node = rbtn_left_get(node_t, link, node);
-	node_t *right_node = rbtn_right_get(node_t, link, node);
+	node_t *left_node;
+	node_t *right_node;
+
+	if (node == NULL)
+		return (ret);
+
+	left_node = rbtn_left_get(node_t, link, node);
+	right_node = rbtn_right_get(node_t, link, node);
 
 	if (!rbtn_red_get(node_t, link, node))
 		black_depth++;
 
 	/* Red nodes must be interleaved with black nodes. */
 	if (rbtn_red_get(node_t, link, node)) {
-		assert_false(rbtn_red_get(node_t, link, left_node),
-		    "Node should be black");
-		assert_false(rbtn_red_get(node_t, link, right_node),
-		    "Node should be black");
+		if (left_node != NULL)
+			assert_false(rbtn_red_get(node_t, link, left_node),
+				"Node should be black");
+		if (right_node != NULL)
+			assert_false(rbtn_red_get(node_t, link, right_node),
+			    "Node should be black");
 	}
 
-	if (node == nil)
-		return (ret);
 	/* Self. */
 	assert_u32_eq(node->magic, NODE_MAGIC, "Bad magic");
 
 	/* Left subtree. */
-	if (left_node != nil)
-		ret += tree_recurse(left_node, black_height, black_depth, nil);
+	if (left_node != NULL)
+		ret += tree_recurse(left_node, black_height, black_depth);
 	else
 		ret += (black_depth != black_height);
 
 	/* Right subtree. */
-	if (right_node != nil)
-		ret += tree_recurse(right_node, black_height, black_depth, nil);
+	if (right_node != NULL)
+		ret += tree_recurse(right_node, black_height, black_depth);
 	else
 		ret += (black_depth != black_height);
 
 	return (ret);
 }
 
@@ -178,14 +183,13 @@
 		    "Key ordering error");
 	}
 
 	node->magic = 0;
 
 	rbtn_black_height(node_t, link, tree, black_height);
-	imbalances = tree_recurse(tree->rbt_root, black_height, 0,
-	    &(tree->rbt_nil));
+	imbalances = tree_recurse(tree->rbt_root, black_height, 0);
 	assert_u_eq(imbalances, 0, "Tree is unbalanced");
 	assert_u_eq(tree_iterate(tree), nnodes-1,
 	    "Unexpected node iteration count");
 	assert_u_eq(tree_iterate_reverse(tree), nnodes-1,
 	    "Unexpected node iteration count");
 }
@@ -209,12 +213,21 @@
 
 	node_remove(tree, node, *nnodes);
 
 	return (ret);
 }
 
+static void
+destroy_cb(node_t *node, void *data)
+{
+	unsigned *nnodes = (unsigned *)data;
+
+	assert_u_gt(*nnodes, 0, "Destruction removed too many nodes");
+	(*nnodes)--;
+}
+
 TEST_BEGIN(test_rb_random)
 {
 #define	NNODES 25
 #define	NBAGS 250
 #define	SEED 42
 	sfmt_t *sfmt;
@@ -241,26 +254,25 @@
 				bag[j] = gen_rand64_range(sfmt, NNODES);
 		}
 
 		for (j = 1; j <= NNODES; j++) {
 			/* Initialize tree and nodes. */
 			tree_new(&tree);
-			tree.rbt_nil.magic = 0;
 			for (k = 0; k < j; k++) {
 				nodes[k].magic = NODE_MAGIC;
 				nodes[k].key = bag[k];
 			}
 
 			/* Insert nodes. */
 			for (k = 0; k < j; k++) {
 				tree_insert(&tree, &nodes[k]);
 
 				rbtn_black_height(node_t, link, &tree,
 				    black_height);
 				imbalances = tree_recurse(tree.rbt_root,
-				    black_height, 0, &(tree.rbt_nil));
+				    black_height, 0);
 				assert_u_eq(imbalances, 0,
 				    "Tree is unbalanced");
 
 				assert_u_eq(tree_iterate(&tree), k+1,
 				    "Unexpected node iteration count");
 				assert_u_eq(tree_iterate_reverse(&tree), k+1,
@@ -275,13 +287,13 @@
 
 				tree_next(&tree, &nodes[k]);
 				tree_prev(&tree, &nodes[k]);
 			}
 
 			/* Remove nodes. */
-			switch (i % 4) {
+			switch (i % 5) {
 			case 0:
 				for (k = 0; k < j; k++)
 					node_remove(&tree, &nodes[k], j - k);
 				break;
 			case 1:
 				for (k = j; k > 0; k--)
@@ -311,12 +323,18 @@
 					    (void *)&nnodes);
 					nnodes--;
 				} while (start != NULL);
 				assert_u_eq(nnodes, 0,
 				    "Removal terminated early");
 				break;
+			} case 4: {
+				unsigned nnodes = j;
+				tree_destroy(&tree, destroy_cb, &nnodes);
+				assert_u_eq(nnodes, 0,
+				    "Destruction terminated early");
+				break;
 			} default:
 				not_reached();
 			}
 		}
 	}
 	fini_gen_rand(sfmt);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: run_quantize.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/size_classes.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/size_classes.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/size_classes.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/size_classes.c	2017-01-31 23:32:23.000000000 +0800
@@ -5,23 +5,23 @@
 {
 	unsigned nhchunks;
 	size_t mib[4];
 	size_t sz, miblen, max_size_class;
 
 	sz = sizeof(unsigned);
-	assert_d_eq(mallctl("arenas.nhchunks", &nhchunks, &sz, NULL, 0), 0,
-	    "Unexpected mallctl() error");
+	assert_d_eq(mallctl("arenas.nhchunks", (void *)&nhchunks, &sz, NULL, 0),
+	    0, "Unexpected mallctl() error");
 
 	miblen = sizeof(mib) / sizeof(size_t);
 	assert_d_eq(mallctlnametomib("arenas.hchunk.0.size", mib, &miblen), 0,
 	    "Unexpected mallctlnametomib() error");
 	mib[2] = nhchunks - 1;
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctlbymib(mib, miblen, &max_size_class, &sz, NULL, 0), 0,
-	    "Unexpected mallctlbymib() error");
+	assert_d_eq(mallctlbymib(mib, miblen, (void *)&max_size_class, &sz,
+	    NULL, 0), 0, "Unexpected mallctlbymib() error");
 
 	return (max_size_class);
 }
 
 TEST_BEGIN(test_size_classes)
 {
@@ -77,13 +77,108 @@
 	    "s2u() does not round up to size class");
 	assert_zu_eq(size_class, s2u(size_class),
 	    "s2u() does not compute same size class");
 }
 TEST_END
 
+TEST_BEGIN(test_psize_classes)
+{
+	size_t size_class, max_size_class;
+	pszind_t pind, max_pind;
+
+	max_size_class = get_max_size_class();
+	max_pind = psz2ind(max_size_class);
+
+	for (pind = 0, size_class = pind2sz(pind); pind < max_pind ||
+	    size_class < max_size_class; pind++, size_class =
+	    pind2sz(pind)) {
+		assert_true(pind < max_pind,
+		    "Loop conditionals should be equivalent; pind=%u, "
+		    "size_class=%zu (%#zx)", pind, size_class, size_class);
+		assert_true(size_class < max_size_class,
+		    "Loop conditionals should be equivalent; pind=%u, "
+		    "size_class=%zu (%#zx)", pind, size_class, size_class);
+
+		assert_u_eq(pind, psz2ind(size_class),
+		    "psz2ind() does not reverse pind2sz(): pind=%u -->"
+		    " size_class=%zu --> pind=%u --> size_class=%zu", pind,
+		    size_class, psz2ind(size_class),
+		    pind2sz(psz2ind(size_class)));
+		assert_zu_eq(size_class, pind2sz(psz2ind(size_class)),
+		    "pind2sz() does not reverse psz2ind(): pind=%u -->"
+		    " size_class=%zu --> pind=%u --> size_class=%zu", pind,
+		    size_class, psz2ind(size_class),
+		    pind2sz(psz2ind(size_class)));
+
+		assert_u_eq(pind+1, psz2ind(size_class+1),
+		    "Next size_class does not round up properly");
+
+		assert_zu_eq(size_class, (pind > 0) ?
+		    psz2u(pind2sz(pind-1)+1) : psz2u(1),
+		    "psz2u() does not round up to size class");
+		assert_zu_eq(size_class, psz2u(size_class-1),
+		    "psz2u() does not round up to size class");
+		assert_zu_eq(size_class, psz2u(size_class),
+		    "psz2u() does not compute same size class");
+		assert_zu_eq(psz2u(size_class+1), pind2sz(pind+1),
+		    "psz2u() does not round up to next size class");
+	}
+
+	assert_u_eq(pind, psz2ind(pind2sz(pind)),
+	    "psz2ind() does not reverse pind2sz()");
+	assert_zu_eq(max_size_class, pind2sz(psz2ind(max_size_class)),
+	    "pind2sz() does not reverse psz2ind()");
+
+	assert_zu_eq(size_class, psz2u(pind2sz(pind-1)+1),
+	    "psz2u() does not round up to size class");
+	assert_zu_eq(size_class, psz2u(size_class-1),
+	    "psz2u() does not round up to size class");
+	assert_zu_eq(size_class, psz2u(size_class),
+	    "psz2u() does not compute same size class");
+}
+TEST_END
+
+TEST_BEGIN(test_overflow)
+{
+	size_t max_size_class;
+
+	max_size_class = get_max_size_class();
+
+	assert_u_eq(size2index(max_size_class+1), NSIZES,
+	    "size2index() should return NSIZES on overflow");
+	assert_u_eq(size2index(ZU(PTRDIFF_MAX)+1), NSIZES,
+	    "size2index() should return NSIZES on overflow");
+	assert_u_eq(size2index(SIZE_T_MAX), NSIZES,
+	    "size2index() should return NSIZES on overflow");
+
+	assert_zu_eq(s2u(max_size_class+1), 0,
+	    "s2u() should return 0 for unsupported size");
+	assert_zu_eq(s2u(ZU(PTRDIFF_MAX)+1), 0,
+	    "s2u() should return 0 for unsupported size");
+	assert_zu_eq(s2u(SIZE_T_MAX), 0,
+	    "s2u() should return 0 on overflow");
+
+	assert_u_eq(psz2ind(max_size_class+1), NPSIZES,
+	    "psz2ind() should return NPSIZES on overflow");
+	assert_u_eq(psz2ind(ZU(PTRDIFF_MAX)+1), NPSIZES,
+	    "psz2ind() should return NPSIZES on overflow");
+	assert_u_eq(psz2ind(SIZE_T_MAX), NPSIZES,
+	    "psz2ind() should return NPSIZES on overflow");
+
+	assert_zu_eq(psz2u(max_size_class+1), 0,
+	    "psz2u() should return 0 for unsupported size");
+	assert_zu_eq(psz2u(ZU(PTRDIFF_MAX)+1), 0,
+	    "psz2u() should return 0 for unsupported size");
+	assert_zu_eq(psz2u(SIZE_T_MAX), 0,
+	    "psz2u() should return 0 on overflow");
+}
+TEST_END
+
 int
 main(void)
 {
 
 	return (test(
-	    test_size_classes));
+	    test_size_classes,
+	    test_psize_classes,
+	    test_overflow));
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: smoothstep.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/stats.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/stats.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/stats.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/stats.c	2017-01-31 23:32:23.000000000 +0800
@@ -4,24 +4,24 @@
 {
 	size_t *cactive;
 	size_t sz, allocated, active, resident, mapped;
 	int expected = config_stats ? 0 : ENOENT;
 
 	sz = sizeof(cactive);
-	assert_d_eq(mallctl("stats.cactive", &cactive, &sz, NULL, 0), expected,
-	    "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.cactive", (void *)&cactive, &sz, NULL, 0),
+	    expected, "Unexpected mallctl() result");
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.allocated", &allocated, &sz, NULL, 0),
+	assert_d_eq(mallctl("stats.allocated", (void *)&allocated, &sz, NULL,
+	    0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.active", (void *)&active, &sz, NULL, 0),
 	    expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.active", &active, &sz, NULL, 0), expected,
-	    "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.resident", &resident, &sz, NULL, 0),
+	assert_d_eq(mallctl("stats.resident", (void *)&resident, &sz, NULL, 0),
+	    expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.mapped", (void *)&mapped, &sz, NULL, 0),
 	    expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.mapped", &mapped, &sz, NULL, 0), expected,
-	    "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_zu_le(active, *cactive,
 		    "active should be no larger than cactive");
 		assert_zu_le(allocated, active,
 		    "allocated should be no larger than active");
@@ -42,25 +42,25 @@
 	size_t sz;
 	int expected = config_stats ? 0 : ENOENT;
 
 	p = mallocx(large_maxclass+1, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
+	    0, "Unexpected mallctl() failure");
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.huge.allocated", &allocated, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.allocated", (void *)&allocated,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.arenas.0.huge.nmalloc", &nmalloc, &sz, NULL,
-	    0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.huge.ndalloc", &ndalloc, &sz, NULL,
-	    0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.huge.nrequests", &nrequests, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.nmalloc", (void *)&nmalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.ndalloc", (void *)&ndalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.nrequests", (void *)&nrequests,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_zu_gt(allocated, 0,
 		    "allocated should be greater than zero");
 		assert_u64_ge(nmalloc, ndalloc,
 		    "nmalloc should be at least as large as ndalloc");
@@ -80,49 +80,49 @@
 	size_t sz;
 	int expected = config_stats ? 0 : ENOENT;
 	size_t mapped;
 	uint64_t npurge, nmadvise, purged;
 
 	arena = 0;
-	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
-	    0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("thread.arena", NULL, NULL, (void *)&arena,
+	    sizeof(arena)), 0, "Unexpected mallctl() failure");
 
 	little = mallocx(SMALL_MAXCLASS, 0);
 	assert_ptr_not_null(little, "Unexpected mallocx() failure");
 	large = mallocx(large_maxclass, 0);
 	assert_ptr_not_null(large, "Unexpected mallocx() failure");
 	huge = mallocx(chunksize, 0);
 	assert_ptr_not_null(huge, "Unexpected mallocx() failure");
 
+	dallocx(little, 0);
+	dallocx(large, 0);
+	dallocx(huge, 0);
+
 	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
 	    "Unexpected mallctl() failure");
 
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
+	    0, "Unexpected mallctl() failure");
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.mapped", &mapped, &sz, NULL, 0),
-	    expected, "Unexepected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.mapped", (void *)&mapped, &sz, NULL,
+	    0), expected, "Unexepected mallctl() result");
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.arenas.0.npurge", &npurge, &sz, NULL, 0),
-	    expected, "Unexepected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.nmadvise", &nmadvise, &sz, NULL, 0),
-	    expected, "Unexepected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.purged", &purged, &sz, NULL, 0),
-	    expected, "Unexepected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.npurge", (void *)&npurge, &sz, NULL,
+	    0), expected, "Unexepected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.nmadvise", (void *)&nmadvise, &sz,
+	    NULL, 0), expected, "Unexepected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.purged", (void *)&purged, &sz, NULL,
+	    0), expected, "Unexepected mallctl() result");
 
 	if (config_stats) {
 		assert_u64_gt(npurge, 0,
 		    "At least one purge should have occurred");
 		assert_u64_le(nmadvise, purged,
 		    "nmadvise should be no greater than purged");
 	}
-
-	dallocx(little, 0);
-	dallocx(large, 0);
-	dallocx(huge, 0);
 }
 TEST_END
 
 void *
 thd_start(void *arg)
 {
@@ -147,34 +147,36 @@
 	uint64_t epoch, nmalloc, ndalloc, nrequests;
 	int expected = config_stats ? 0 : ENOENT;
 
 	no_lazy_lock(); /* Lazy locking would dodge tcache testing. */
 
 	arena = 0;
-	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
-	    0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("thread.arena", NULL, NULL, (void *)&arena,
+	    sizeof(arena)), 0, "Unexpected mallctl() failure");
 
 	p = mallocx(SMALL_MAXCLASS, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
 	assert_d_eq(mallctl("thread.tcache.flush", NULL, NULL, NULL, 0),
 	    config_tcache ? 0 : ENOENT, "Unexpected mallctl() result");
 
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
+	    0, "Unexpected mallctl() failure");
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.small.allocated", &allocated, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.small.allocated",
+	    (void *)&allocated, &sz, NULL, 0), expected,
+	    "Unexpected mallctl() result");
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.arenas.0.small.nmalloc", &nmalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.small.ndalloc", &ndalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.small.nrequests", &nrequests, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.small.nmalloc", (void *)&nmalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.small.ndalloc", (void *)&ndalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.small.nrequests",
+	    (void *)&nrequests, &sz, NULL, 0), expected,
+	    "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_zu_gt(allocated, 0,
 		    "allocated should be greater than zero");
 		assert_u64_gt(nmalloc, 0,
 		    "nmalloc should be no greater than zero");
@@ -194,40 +196,42 @@
 	void *p;
 	size_t sz, allocated;
 	uint64_t epoch, nmalloc, ndalloc, nrequests;
 	int expected = config_stats ? 0 : ENOENT;
 
 	arena = 0;
-	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
-	    0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("thread.arena", NULL, NULL, (void *)&arena,
+	    sizeof(arena)), 0, "Unexpected mallctl() failure");
 
 	p = mallocx(large_maxclass, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
+	    0, "Unexpected mallctl() failure");
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.large.allocated", &allocated, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.large.allocated",
+	    (void *)&allocated, &sz, NULL, 0), expected,
+	    "Unexpected mallctl() result");
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.arenas.0.large.nmalloc", &nmalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.large.ndalloc", &ndalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.large.nrequests", &nrequests, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.large.nmalloc", (void *)&nmalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.large.ndalloc", (void *)&ndalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.large.nrequests",
+	    (void *)&nrequests, &sz, NULL, 0), expected,
+	    "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_zu_gt(allocated, 0,
 		    "allocated should be greater than zero");
-		assert_zu_gt(nmalloc, 0,
+		assert_u64_gt(nmalloc, 0,
 		    "nmalloc should be greater than zero");
-		assert_zu_ge(nmalloc, ndalloc,
+		assert_u64_ge(nmalloc, ndalloc,
 		    "nmalloc should be at least as large as ndalloc");
-		assert_zu_gt(nrequests, 0,
+		assert_u64_gt(nrequests, 0,
 		    "nrequests should be greater than zero");
 	}
 
 	dallocx(p, 0);
 }
 TEST_END
@@ -238,36 +242,36 @@
 	void *p;
 	size_t sz, allocated;
 	uint64_t epoch, nmalloc, ndalloc;
 	int expected = config_stats ? 0 : ENOENT;
 
 	arena = 0;
-	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
-	    0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("thread.arena", NULL, NULL, (void *)&arena,
+	    sizeof(arena)), 0, "Unexpected mallctl() failure");
 
 	p = mallocx(chunksize, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
+	    0, "Unexpected mallctl() failure");
 
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.huge.allocated", &allocated, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.allocated", (void *)&allocated,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.arenas.0.huge.nmalloc", &nmalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.huge.ndalloc", &ndalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.nmalloc", (void *)&nmalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.huge.ndalloc", (void *)&ndalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_zu_gt(allocated, 0,
 		    "allocated should be greater than zero");
-		assert_zu_gt(nmalloc, 0,
+		assert_u64_gt(nmalloc, 0,
 		    "nmalloc should be greater than zero");
-		assert_zu_ge(nmalloc, ndalloc,
+		assert_u64_ge(nmalloc, ndalloc,
 		    "nmalloc should be at least as large as ndalloc");
 	}
 
 	dallocx(p, 0);
 }
 TEST_END
@@ -279,50 +283,51 @@
 	size_t sz, curruns, curregs;
 	uint64_t epoch, nmalloc, ndalloc, nrequests, nfills, nflushes;
 	uint64_t nruns, nreruns;
 	int expected = config_stats ? 0 : ENOENT;
 
 	arena = 0;
-	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
-	    0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("thread.arena", NULL, NULL, (void *)&arena,
+	    sizeof(arena)), 0, "Unexpected mallctl() failure");
 
 	p = mallocx(arena_bin_info[0].reg_size, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
 	assert_d_eq(mallctl("thread.tcache.flush", NULL, NULL, NULL, 0),
 	    config_tcache ? 0 : ENOENT, "Unexpected mallctl() result");
 
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
+	    0, "Unexpected mallctl() failure");
 
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.nmalloc", &nmalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.ndalloc", &ndalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.nrequests", &nrequests, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.nmalloc", (void *)&nmalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.ndalloc", (void *)&ndalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.nrequests",
+	    (void *)&nrequests, &sz, NULL, 0), expected,
+	    "Unexpected mallctl() result");
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.curregs", &curregs, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.curregs", (void *)&curregs,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
 
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.nfills", &nfills, &sz,
-	    NULL, 0), config_tcache ? expected : ENOENT,
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.nfills", (void *)&nfills,
+	    &sz, NULL, 0), config_tcache ? expected : ENOENT,
 	    "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.nflushes", &nflushes, &sz,
-	    NULL, 0), config_tcache ? expected : ENOENT,
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.nflushes", (void *)&nflushes,
+	    &sz, NULL, 0), config_tcache ? expected : ENOENT,
 	    "Unexpected mallctl() result");
 
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.nruns", &nruns, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.nreruns", &nreruns, &sz,
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.nruns", (void *)&nruns, &sz,
 	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.nreruns", (void *)&nreruns,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.bins.0.curruns", &curruns, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.bins.0.curruns", (void *)&curruns,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_u64_gt(nmalloc, 0,
 		    "nmalloc should be greater than zero");
 		assert_u64_ge(nmalloc, ndalloc,
 		    "nmalloc should be at least as large as ndalloc");
@@ -352,31 +357,32 @@
 	void *p;
 	uint64_t epoch, nmalloc, ndalloc, nrequests;
 	size_t curruns, sz;
 	int expected = config_stats ? 0 : ENOENT;
 
 	arena = 0;
-	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
-	    0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("thread.arena", NULL, NULL, (void *)&arena,
+	    sizeof(arena)), 0, "Unexpected mallctl() failure");
 
 	p = mallocx(LARGE_MINCLASS, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
+	    0, "Unexpected mallctl() failure");
 
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.arenas.0.lruns.0.nmalloc", &nmalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.lruns.0.ndalloc", &ndalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.lruns.0.nrequests", &nrequests, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.lruns.0.nmalloc", (void *)&nmalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.lruns.0.ndalloc", (void *)&ndalloc,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.lruns.0.nrequests",
+	    (void *)&nrequests, &sz, NULL, 0), expected,
+	    "Unexpected mallctl() result");
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.lruns.0.curruns", &curruns, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.lruns.0.curruns", (void *)&curruns,
+	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_u64_gt(nmalloc, 0,
 		    "nmalloc should be greater than zero");
 		assert_u64_ge(nmalloc, ndalloc,
 		    "nmalloc should be at least as large as ndalloc");
@@ -396,29 +402,32 @@
 	void *p;
 	uint64_t epoch, nmalloc, ndalloc;
 	size_t curhchunks, sz;
 	int expected = config_stats ? 0 : ENOENT;
 
 	arena = 0;
-	assert_d_eq(mallctl("thread.arena", NULL, NULL, &arena, sizeof(arena)),
-	    0, "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("thread.arena", NULL, NULL, (void *)&arena,
+	    sizeof(arena)), 0, "Unexpected mallctl() failure");
 
 	p = mallocx(chunksize, 0);
 	assert_ptr_not_null(p, "Unexpected mallocx() failure");
 
-	assert_d_eq(mallctl("epoch", NULL, NULL, &epoch, sizeof(epoch)), 0,
-	    "Unexpected mallctl() failure");
+	assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch, sizeof(epoch)),
+	    0, "Unexpected mallctl() failure");
 
 	sz = sizeof(uint64_t);
-	assert_d_eq(mallctl("stats.arenas.0.hchunks.0.nmalloc", &nmalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
-	assert_d_eq(mallctl("stats.arenas.0.hchunks.0.ndalloc", &ndalloc, &sz,
-	    NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.hchunks.0.nmalloc",
+	    (void *)&nmalloc, &sz, NULL, 0), expected,
+	    "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.hchunks.0.ndalloc",
+	    (void *)&ndalloc, &sz, NULL, 0), expected,
+	    "Unexpected mallctl() result");
 	sz = sizeof(size_t);
-	assert_d_eq(mallctl("stats.arenas.0.hchunks.0.curhchunks", &curhchunks,
-	    &sz, NULL, 0), expected, "Unexpected mallctl() result");
+	assert_d_eq(mallctl("stats.arenas.0.hchunks.0.curhchunks",
+	    (void *)&curhchunks, &sz, NULL, 0), expected,
+	    "Unexpected mallctl() result");
 
 	if (config_stats) {
 		assert_u64_gt(nmalloc, 0,
 		    "nmalloc should be greater than zero");
 		assert_u64_ge(nmalloc, ndalloc,
 		    "nmalloc should be at least as large as ndalloc");
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: ticker.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/tsd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/tsd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/tsd.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/tsd.c	2017-01-31 23:32:23.000000000 +0800
@@ -55,34 +55,34 @@
 static void *
 thd_start(void *arg)
 {
 	data_t d = (data_t)(uintptr_t)arg;
 	void *p;
 
-	assert_x_eq(*data_tsd_get(), DATA_INIT,
+	assert_x_eq(*data_tsd_get(true), DATA_INIT,
 	    "Initial tsd get should return initialization value");
 
 	p = malloc(1);
 	assert_ptr_not_null(p, "Unexpected malloc() failure");
 
 	data_tsd_set(&d);
-	assert_x_eq(*data_tsd_get(), d,
+	assert_x_eq(*data_tsd_get(true), d,
 	    "After tsd set, tsd get should return value that was set");
 
 	d = 0;
-	assert_x_eq(*data_tsd_get(), (data_t)(uintptr_t)arg,
+	assert_x_eq(*data_tsd_get(true), (data_t)(uintptr_t)arg,
 	    "Resetting local data should have no effect on tsd");
 
 	free(p);
 	return (NULL);
 }
 
 TEST_BEGIN(test_tsd_main_thread)
 {
 
-	thd_start((void *) 0xa5f3e329);
+	thd_start((void *)(uintptr_t)0xa5f3e329);
 }
 TEST_END
 
 TEST_BEGIN(test_tsd_sub_thread)
 {
 	thd_t thd;
@@ -96,12 +96,17 @@
 TEST_END
 
 int
 main(void)
 {
 
+	/* Core tsd bootstrapping must happen prior to data_tsd_boot(). */
+	if (nallocx(1, 0) == 0) {
+		malloc_printf("Initialization error");
+		return (test_status_fail);
+	}
 	data_tsd_boot();
 
 	return (test(
 	    test_tsd_main_thread,
 	    test_tsd_sub_thread));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/util.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/util.c	2017-01-31 23:32:23.000000000 +0800
@@ -1,36 +1,57 @@
 #include "test/jemalloc_test.h"
 
-TEST_BEGIN(test_pow2_ceil)
+#define	TEST_POW2_CEIL(t, suf, pri) do {				\
+	unsigned i, pow2;						\
+	t x;								\
+									\
+	assert_##suf##_eq(pow2_ceil_##suf(0), 0, "Unexpected result");	\
+									\
+	for (i = 0; i < sizeof(t) * 8; i++) {				\
+		assert_##suf##_eq(pow2_ceil_##suf(((t)1) << i), ((t)1)	\
+		    << i, "Unexpected result");				\
+	}								\
+									\
+	for (i = 2; i < sizeof(t) * 8; i++) {				\
+		assert_##suf##_eq(pow2_ceil_##suf((((t)1) << i) - 1),	\
+		    ((t)1) << i, "Unexpected result");			\
+	}								\
+									\
+	for (i = 0; i < sizeof(t) * 8 - 1; i++) {			\
+		assert_##suf##_eq(pow2_ceil_##suf((((t)1) << i) + 1),	\
+		    ((t)1) << (i+1), "Unexpected result");		\
+	}								\
+									\
+	for (pow2 = 1; pow2 < 25; pow2++) {				\
+		for (x = (((t)1) << (pow2-1)) + 1; x <= ((t)1) << pow2;	\
+		    x++) {						\
+			assert_##suf##_eq(pow2_ceil_##suf(x),		\
+			    ((t)1) << pow2,				\
+			    "Unexpected result, x=%"pri, x);		\
+		}							\
+	}								\
+} while (0)
+
+TEST_BEGIN(test_pow2_ceil_u64)
 {
-	unsigned i, pow2;
-	size_t x;
 
-	assert_zu_eq(pow2_ceil(0), 0, "Unexpected result");
+	TEST_POW2_CEIL(uint64_t, u64, FMTu64);
+}
+TEST_END
 
-	for (i = 0; i < sizeof(size_t) * 8; i++) {
-		assert_zu_eq(pow2_ceil(ZU(1) << i), ZU(1) << i,
-		    "Unexpected result");
-	}
+TEST_BEGIN(test_pow2_ceil_u32)
+{
 
-	for (i = 2; i < sizeof(size_t) * 8; i++) {
-		assert_zu_eq(pow2_ceil((ZU(1) << i) - 1), ZU(1) << i,
-		    "Unexpected result");
-	}
+	TEST_POW2_CEIL(uint32_t, u32, FMTu32);
+}
+TEST_END
 
-	for (i = 0; i < sizeof(size_t) * 8 - 1; i++) {
-		assert_zu_eq(pow2_ceil((ZU(1) << i) + 1), ZU(1) << (i+1),
-		    "Unexpected result");
-	}
+TEST_BEGIN(test_pow2_ceil_zu)
+{
 
-	for (pow2 = 1; pow2 < 25; pow2++) {
-		for (x = (ZU(1) << (pow2-1)) + 1; x <= ZU(1) << pow2; x++) {
-			assert_zu_eq(pow2_ceil(x), ZU(1) << pow2,
-			    "Unexpected result, x=%zu", x);
-		}
-	}
+	TEST_POW2_CEIL(size_t, zu, "zu");
 }
 TEST_END
 
 TEST_BEGIN(test_malloc_strtoumax_no_endptr)
 {
 	int err;
@@ -51,31 +72,32 @@
 		int expected_errno;
 		const char *expected_errno_name;
 		uintmax_t expected_x;
 	};
 #define	ERR(e)		e, #e
 #define	KUMAX(x)	((uintmax_t)x##ULL)
+#define	KSMAX(x)	((uintmax_t)(intmax_t)x##LL)
 	struct test_s tests[] = {
 		{"0",		"0",	-1,	ERR(EINVAL),	UINTMAX_MAX},
 		{"0",		"0",	1,	ERR(EINVAL),	UINTMAX_MAX},
 		{"0",		"0",	37,	ERR(EINVAL),	UINTMAX_MAX},
 
 		{"",		"",	0,	ERR(EINVAL),	UINTMAX_MAX},
 		{"+",		"+",	0,	ERR(EINVAL),	UINTMAX_MAX},
 		{"++3",		"++3",	0,	ERR(EINVAL),	UINTMAX_MAX},
 		{"-",		"-",	0,	ERR(EINVAL),	UINTMAX_MAX},
 
 		{"42",		"",	0,	ERR(0),		KUMAX(42)},
 		{"+42",		"",	0,	ERR(0),		KUMAX(42)},
-		{"-42",		"",	0,	ERR(0),		KUMAX(-42)},
+		{"-42",		"",	0,	ERR(0),		KSMAX(-42)},
 		{"042",		"",	0,	ERR(0),		KUMAX(042)},
 		{"+042",	"",	0,	ERR(0),		KUMAX(042)},
-		{"-042",	"",	0,	ERR(0),		KUMAX(-042)},
+		{"-042",	"",	0,	ERR(0),		KSMAX(-042)},
 		{"0x42",	"",	0,	ERR(0),		KUMAX(0x42)},
 		{"+0x42",	"",	0,	ERR(0),		KUMAX(0x42)},
-		{"-0x42",	"",	0,	ERR(0),		KUMAX(-0x42)},
+		{"-0x42",	"",	0,	ERR(0),		KSMAX(-0x42)},
 
 		{"0",		"",	0,	ERR(0),		KUMAX(0)},
 		{"1",		"",	0,	ERR(0),		KUMAX(1)},
 
 		{"42",		"",	0,	ERR(0),		KUMAX(42)},
 		{" 42",		"",	0,	ERR(0),		KUMAX(42)},
@@ -106,12 +128,13 @@
 		{"0XFG",	"G",	16,	ERR(0),		KUMAX(15)},
 		{"z_",		"_",	36,	ERR(0),		KUMAX(35)},
 		{"Z_",		"_",	36,	ERR(0),		KUMAX(35)}
 	};
 #undef ERR
 #undef KUMAX
+#undef KSMAX
 	unsigned i;
 
 	for (i = 0; i < sizeof(tests)/sizeof(struct test_s); i++) {
 		struct test_s *test = &tests[i];
 		int err;
 		uintmax_t result;
@@ -136,20 +159,20 @@
 TEST_END
 
 TEST_BEGIN(test_malloc_snprintf_truncated)
 {
 #define	BUFLEN	15
 	char buf[BUFLEN];
-	int result;
+	size_t result;
 	size_t len;
 #define TEST(expected_str_untruncated, ...) do {			\
 	result = malloc_snprintf(buf, len, __VA_ARGS__);		\
 	assert_d_eq(strncmp(buf, expected_str_untruncated, len-1), 0,	\
 	    "Unexpected string inequality (\"%s\" vs \"%s\")",		\
-	    buf, expected_str_untruncated);		\
-	assert_d_eq(result, strlen(expected_str_untruncated),		\
+	    buf, expected_str_untruncated);				\
+	assert_zu_eq(result, strlen(expected_str_untruncated),		\
 	    "Unexpected result");					\
 } while (0)
 
 	for (len = 1; len < BUFLEN; len++) {
 		TEST("012346789",	"012346789");
 		TEST("a0123b",		"a%sb", "0123");
@@ -169,17 +192,17 @@
 TEST_END
 
 TEST_BEGIN(test_malloc_snprintf)
 {
 #define	BUFLEN	128
 	char buf[BUFLEN];
-	int result;
+	size_t result;
 #define	TEST(expected_str, ...) do {					\
 	result = malloc_snprintf(buf, sizeof(buf), __VA_ARGS__);	\
 	assert_str_eq(buf, expected_str, "Unexpected output");		\
-	assert_d_eq(result, strlen(expected_str), "Unexpected result");	\
+	assert_zu_eq(result, strlen(expected_str), "Unexpected result");\
 } while (0)
 
 	TEST("hello", "hello");
 
 	TEST("50%, 100%", "50%%, %d%%", 100);
 
@@ -283,12 +306,14 @@
 
 int
 main(void)
 {
 
 	return (test(
-	    test_pow2_ceil,
+	    test_pow2_ceil_u64,
+	    test_pow2_ceil_u32,
+	    test_pow2_ceil_zu,
 	    test_malloc_strtoumax_no_endptr,
 	    test_malloc_strtoumax,
 	    test_malloc_snprintf_truncated,
 	    test_malloc_snprintf));
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit: witness.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/zero.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/zero.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/test/unit/zero.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/test/unit/zero.c	2017-01-31 23:32:23.000000000 +0800
@@ -5,45 +5,47 @@
     "abort:false,junk:false,zero:true,redzone:false,quarantine:0";
 #endif
 
 static void
 test_zero(size_t sz_min, size_t sz_max)
 {
-	char *s;
+	uint8_t *s;
 	size_t sz_prev, sz, i;
+#define	MAGIC	((uint8_t)0x61)
 
 	sz_prev = 0;
-	s = (char *)mallocx(sz_min, 0);
+	s = (uint8_t *)mallocx(sz_min, 0);
 	assert_ptr_not_null((void *)s, "Unexpected mallocx() failure");
 
 	for (sz = sallocx(s, 0); sz <= sz_max;
 	    sz_prev = sz, sz = sallocx(s, 0)) {
 		if (sz_prev > 0) {
-			assert_c_eq(s[0], 'a',
+			assert_u_eq(s[0], MAGIC,
 			    "Previously allocated byte %zu/%zu is corrupted",
 			    ZU(0), sz_prev);
-			assert_c_eq(s[sz_prev-1], 'a',
+			assert_u_eq(s[sz_prev-1], MAGIC,
 			    "Previously allocated byte %zu/%zu is corrupted",
 			    sz_prev-1, sz_prev);
 		}
 
 		for (i = sz_prev; i < sz; i++) {
-			assert_c_eq(s[i], 0x0,
+			assert_u_eq(s[i], 0x0,
 			    "Newly allocated byte %zu/%zu isn't zero-filled",
 			    i, sz);
-			s[i] = 'a';
+			s[i] = MAGIC;
 		}
 
 		if (xallocx(s, sz+1, 0, 0) == sz) {
-			s = (char *)rallocx(s, sz+1, 0);
+			s = (uint8_t *)rallocx(s, sz+1, 0);
 			assert_ptr_not_null((void *)s,
 			    "Unexpected rallocx() failure");
 		}
 	}
 
 	dallocx(s, 0);
+#undef MAGIC
 }
 
 TEST_BEGIN(test_zero_small)
 {
 
 	test_skip_if(!config_fill);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc: .travis.yml
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/VERSION /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/VERSION
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/VERSION	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/VERSION	2017-01-31 23:32:23.000000000 +0800
@@ -1 +1 @@
-4.0.3-0-ge9192eacf8935e29fc62fddc2701f7942b1cc02c
+4.4.0-0-gf1f76357313e7dcad7262f17a48ff0a2e005fcdc
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/linenoise/linenoise.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/linenoise/linenoise.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/linenoise/linenoise.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/linenoise/linenoise.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/fpconv.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/fpconv.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lapi.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lapi.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lauxlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lauxlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lbaselib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lbaselib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lcode.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lcode.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldblib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldblib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldebug.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldebug.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldo.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldo.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldump.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldump.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lfunc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lfunc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lgc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lgc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/liblua.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/liblua.a differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/linit.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/linit.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/liolib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/liolib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/llex.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/llex.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmathlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmathlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmem.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmem.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loadlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loadlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lobject.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lobject.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lopcodes.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lopcodes.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loslib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loslib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lparser.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lparser.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstate.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstate.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstring.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstring.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstrlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstrlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltable.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltable.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltablib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltablib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltm.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltm.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_bit.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_bit.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/luac.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/luac.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cjson.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cjson.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cmsgpack.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cmsgpack.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_struct.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_struct.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lundump.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lundump.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lvm.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lvm.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lzio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lzio.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/print.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/print.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/strbuf.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/strbuf.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/adlist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/adlist.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/adlist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/adlist.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ae.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ae.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ae.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ae.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/anet.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/anet.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/anet.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/anet.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/aof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/aof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/aof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/aof.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bio.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bitops.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bitops.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bitops.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bitops.c	2017-01-31 23:32:23.000000000 +0800
@@ -904,13 +904,13 @@
     robj *o;
     size_t bitoffset;
     int j, numops = 0, changes = 0;
     struct bitfieldOp *ops = NULL; /* Array of ops to execute at end. */
     int owtype = BFOVERFLOW_WRAP; /* Overflow type. */
     int readonly = 1;
-    long higest_write_offset = 0;
+    size_t higest_write_offset = 0;
 
     for (j = 2; j < c->argc; j++) {
         int remargs = c->argc-j-1; /* Remaining args other than current. */
         char *subcmd = c->argv[j]->ptr; /* Current command name. */
         int opcode; /* Current operation code. */
         long long i64 = 0;  /* Signed SET value. */
@@ -954,13 +954,14 @@
             zfree(ops);
             return;
         }
 
         if (opcode != BITFIELDOP_GET) {
             readonly = 0;
-            higest_write_offset = bitoffset + bits - 1;
+            if (higest_write_offset < bitoffset + bits - 1)
+                higest_write_offset = bitoffset + bits - 1;
             /* INCRBY and SET require another argument. */
             if (getLongLongFromObjectOrReply(c,c->argv[j+3],&i64,NULL) != C_OK){
                 zfree(ops);
                 return;
             }
         }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bitops.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bitops.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bitops.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bitops.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/blocked.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/blocked.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/blocked.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/blocked.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/build_ir.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/build_ir.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/build_ir.sh	2017-09-27 23:00:38.094935442 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/build_ir.sh	2017-09-27 23:02:14.518931908 +0800
@@ -11,642 +11,667 @@
 	then
 		succ=`expr $succ + 1`;
 	fi
 	total=`expr $total + 1`;
 }
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/net.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/net.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/net.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/net.c.bc
 check
-echo "1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/net.c to bc" >&2
+echo "1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/net.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/hiredis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/hiredis.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/hiredis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/hiredis.c.bc
 check
-echo "2 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/hiredis.c to bc" >&2
+echo "2 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/hiredis.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/sds.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/sds.c.bc
 check
-echo "3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/sds.c to bc" >&2
+echo "3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/sds.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/async.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/async.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/async.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/async.c.bc
 check
-echo "4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/async.c to bc" >&2
+echo "4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/async.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/linenoise
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/linenoise/linenoise.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/linenoise/linenoise.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/linenoise
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/linenoise/linenoise.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/linenoise/linenoise.c.bc
 check
-echo "5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/linenoise/linenoise.c to bc" >&2
+echo "5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/linenoise/linenoise.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lapi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lapi.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lapi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lapi.c.bc
 check
-echo "6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lapi.c to bc" >&2
+echo "6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lapi.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lcode.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lcode.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lcode.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lcode.c.bc
 check
-echo "7 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lcode.c to bc" >&2
+echo "7 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lcode.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldebug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldebug.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldebug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldebug.c.bc
 check
-echo "8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldebug.c to bc" >&2
+echo "8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldebug.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldo.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldo.c.bc
 check
-echo "9 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldo.c to bc" >&2
+echo "9 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldo.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldump.c.bc
 check
-echo "10 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldump.c to bc" >&2
+echo "10 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldump.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lfunc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lfunc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lfunc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lfunc.c.bc
 check
-echo "11 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lfunc.c to bc" >&2
+echo "11 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lfunc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lgc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lgc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lgc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lgc.c.bc
 check
-echo "12 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lgc.c to bc" >&2
+echo "12 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lgc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/llex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/llex.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/llex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/llex.c.bc
 check
-echo "13 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/llex.c to bc" >&2
+echo "13 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/llex.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmem.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmem.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmem.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmem.c.bc
 check
-echo "14 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmem.c to bc" >&2
+echo "14 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmem.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lobject.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lobject.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lobject.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lobject.c.bc
 check
-echo "15 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lobject.c to bc" >&2
+echo "15 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lobject.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lopcodes.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lopcodes.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lopcodes.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lopcodes.c.bc
 check
-echo "16 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lopcodes.c to bc" >&2
+echo "16 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lopcodes.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lparser.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lparser.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lparser.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lparser.c.bc
 check
-echo "17 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lparser.c to bc" >&2
+echo "17 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lparser.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstate.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstate.c.bc
 check
-echo "18 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstate.c to bc" >&2
+echo "18 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstate.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstring.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstring.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstring.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstring.c.bc
 check
-echo "19 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstring.c to bc" >&2
+echo "19 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstring.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltable.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltable.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltable.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltable.c.bc
 check
-echo "20 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltable.c to bc" >&2
+echo "20 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltable.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltm.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltm.c.bc
 check
-echo "21 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltm.c to bc" >&2
+echo "21 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltm.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lundump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lundump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lundump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lundump.c.bc
 check
-echo "22 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lundump.c to bc" >&2
+echo "22 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lundump.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lvm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lvm.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lvm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lvm.c.bc
 check
-echo "23 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lvm.c to bc" >&2
+echo "23 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lvm.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lzio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lzio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lzio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lzio.c.bc
 check
-echo "24 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lzio.c to bc" >&2
+echo "24 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lzio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/strbuf.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/strbuf.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/strbuf.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/strbuf.c.bc
 check
-echo "25 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/strbuf.c to bc" >&2
+echo "25 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/strbuf.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/fpconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/fpconv.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/fpconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/fpconv.c.bc
 check
-echo "26 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/fpconv.c to bc" >&2
+echo "26 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/fpconv.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lauxlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lauxlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lauxlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lauxlib.c.bc
 check
-echo "27 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lauxlib.c to bc" >&2
+echo "27 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lauxlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lbaselib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lbaselib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lbaselib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lbaselib.c.bc
 check
-echo "28 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lbaselib.c to bc" >&2
+echo "28 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lbaselib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldblib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldblib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldblib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldblib.c.bc
 check
-echo "29 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldblib.c to bc" >&2
+echo "29 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldblib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/liolib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/liolib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/liolib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/liolib.c.bc
 check
-echo "30 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/liolib.c to bc" >&2
+echo "30 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/liolib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmathlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmathlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmathlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmathlib.c.bc
 check
-echo "31 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmathlib.c to bc" >&2
+echo "31 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmathlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loslib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loslib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loslib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loslib.c.bc
 check
-echo "32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loslib.c to bc" >&2
+echo "32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loslib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltablib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltablib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltablib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltablib.c.bc
 check
-echo "33 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltablib.c to bc" >&2
+echo "33 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltablib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstrlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstrlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstrlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstrlib.c.bc
 check
-echo "34 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstrlib.c to bc" >&2
+echo "34 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstrlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loadlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loadlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loadlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loadlib.c.bc
 check
-echo "35 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loadlib.c to bc" >&2
+echo "35 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loadlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/linit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/linit.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/linit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/linit.c.bc
 check
-echo "36 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/linit.c to bc" >&2
+echo "36 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/linit.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cjson.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cjson.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cjson.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cjson.c.bc
 check
-echo "37 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cjson.c to bc" >&2
+echo "37 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cjson.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_struct.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_struct.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_struct.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_struct.c.bc
 check
-echo "38 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_struct.c to bc" >&2
+echo "38 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_struct.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cmsgpack.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cmsgpack.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cmsgpack.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cmsgpack.c.bc
 check
-echo "39 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cmsgpack.c to bc" >&2
+echo "39 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cmsgpack.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_bit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_bit.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_bit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_bit.c.bc
 check
-echo "40 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_bit.c to bc" >&2
+echo "40 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_bit.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua.c.bc
 check
-echo "41 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua.c to bc" >&2
+echo "41 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/luac.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/luac.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/luac.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/luac.c.bc
 check
-echo "42 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/luac.c to bc" >&2
+echo "42 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/luac.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/print.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/print.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/print.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/print.c.bc
 check
-echo "43 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/print.c to bc" >&2
+echo "43 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/print.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash.c.bc
 check
-echo "44 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash.c to bc" >&2
+echo "44 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash_helper.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash_helper.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash_helper.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash_helper.c.bc
 check
-echo "45 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash_helper.c to bc" >&2
+echo "45 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash_helper.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c.bc
 check
-echo "46 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c to bc" >&2
+echo "46 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -c /tmp/cgZYFmPA/dummy.c -o /tmp/cgZYFmPA/dummy.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -c /tmp/cgobnqBZ/dummy.c -o /tmp/cgobnqBZ/dummy.c.bc
 check
-echo "47 /tmp/cgZYFmPA/dummy.c to bc" >&2
+echo "47 /tmp/cgobnqBZ/dummy.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.c.bc
 check
-echo "48 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.c to bc" >&2
+echo "48 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.c.bc
 check
-echo "49 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.c to bc" >&2
+echo "49 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.c.bc
 check
-echo "50 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.c to bc" >&2
+echo "50 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.c.bc
 check
-echo "51 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.c to bc" >&2
+echo "51 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.c.bc
 check
-echo "52 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.c to bc" >&2
+echo "52 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.c.bc
 check
-echo "53 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.c to bc" >&2
+echo "53 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.c.bc
 check
-echo "54 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.c to bc" >&2
+echo "54 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.c.bc
 check
-echo "55 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.c to bc" >&2
+echo "55 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.c.bc
 check
-echo "56 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.c to bc" >&2
+echo "56 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.c.bc
 check
-echo "57 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.c to bc" >&2
+echo "57 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.c.bc
 check
-echo "58 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.c to bc" >&2
+echo "58 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.c.bc
 check
-echo "59 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.c to bc" >&2
+echo "59 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.c.bc
 check
-echo "60 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.c to bc" >&2
+echo "60 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.c.bc
 check
-echo "61 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.c to bc" >&2
+echo "61 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.c.bc
 check
-echo "62 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.c to bc" >&2
+echo "62 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/nstime.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/nstime.c.bc
 check
-echo "63 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.c to bc" >&2
+echo "63 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/nstime.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.c.bc
 check
-echo "64 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.c to bc" >&2
+echo "64 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prng.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prng.c.bc
 check
-echo "65 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.c to bc" >&2
+echo "65 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prng.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.c.bc
 check
-echo "66 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.c to bc" >&2
+echo "66 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.c.bc
 check
-echo "67 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.c to bc" >&2
+echo "67 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.c.bc
 check
-echo "68 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.c to bc" >&2
+echo "68 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.c.bc
 check
-echo "69 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.c to bc" >&2
+echo "69 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/spin.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/spin.c.bc
 check
-echo "70 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.c to bc" >&2
+echo "70 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/spin.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/adlist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/adlist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.c.bc
 check
-echo "71 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/adlist.c to bc" >&2
+echo "71 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/quicklist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/quicklist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ticker.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ticker.c.bc
 check
-echo "72 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/quicklist.c to bc" >&2
+echo "72 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ticker.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ae.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ae.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.c.bc
 check
-echo "73 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ae.c to bc" >&2
+echo "73 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/anet.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/anet.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.c.bc
 check
-echo "74 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/anet.c to bc" >&2
+echo "74 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/dict.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/dict.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/witness.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/witness.c.bc
 check
-echo "75 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/dict.c to bc" >&2
+echo "75 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/witness.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/adlist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/adlist.c.bc
 check
-echo "76 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.c to bc" >&2
+echo "76 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/adlist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sds.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/quicklist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/quicklist.c.bc
 check
-echo "77 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sds.c to bc" >&2
+echo "77 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/quicklist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zmalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zmalloc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ae.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ae.c.bc
 check
-echo "78 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zmalloc.c to bc" >&2
+echo "78 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ae.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_c.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_c.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/anet.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/anet.c.bc
 check
-echo "79 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_c.c to bc" >&2
+echo "79 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/anet.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_d.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_d.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/dict.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/dict.c.bc
 check
-echo "80 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_d.c to bc" >&2
+echo "80 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/dict.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pqsort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pqsort.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.c.bc
 check
-echo "81 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pqsort.c to bc" >&2
+echo "81 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zipmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zipmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sds.c.bc
 check
-echo "82 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zipmap.c to bc" >&2
+echo "82 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sds.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sha1.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sha1.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zmalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zmalloc.c.bc
 check
-echo "83 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sha1.c to bc" >&2
+echo "83 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zmalloc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ziplist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ziplist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_c.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_c.c.bc
 check
-echo "84 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ziplist.c to bc" >&2
+echo "84 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_c.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/release.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/release.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_d.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_d.c.bc
 check
-echo "85 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/release.c to bc" >&2
+echo "85 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_d.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/networking.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/networking.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pqsort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pqsort.c.bc
 check
-echo "86 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/networking.c to bc" >&2
+echo "86 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pqsort.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/util.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zipmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zipmap.c.bc
 check
-echo "87 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/util.c to bc" >&2
+echo "87 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zipmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/object.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/object.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sha1.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sha1.c.bc
 check
-echo "88 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/object.c to bc" >&2
+echo "88 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sha1.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/db.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/db.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ziplist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ziplist.c.bc
 check
-echo "89 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/db.c to bc" >&2
+echo "89 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ziplist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/replication.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/replication.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/release.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/release.c.bc
 check
-echo "90 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/replication.c to bc" >&2
+echo "90 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/release.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rdb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/networking.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/networking.c.bc
 check
-echo "91 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rdb.c to bc" >&2
+echo "91 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/networking.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_string.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_string.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/util.c.bc
 check
-echo "92 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_string.c to bc" >&2
+echo "92 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/util.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_list.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_list.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/object.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/object.c.bc
 check
-echo "93 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_list.c to bc" >&2
+echo "93 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/object.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_set.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_set.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/db.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/db.c.bc
 check
-echo "94 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_set.c to bc" >&2
+echo "94 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/db.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_zset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_zset.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/replication.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/replication.c.bc
 check
-echo "95 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_zset.c to bc" >&2
+echo "95 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/replication.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_hash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rdb.c.bc
 check
-echo "96 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_hash.c to bc" >&2
+echo "96 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rdb.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/config.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/config.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_string.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_string.c.bc
 check
-echo "97 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/config.c to bc" >&2
+echo "97 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_string.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/aof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_list.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_list.c.bc
 check
-echo "98 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/aof.c to bc" >&2
+echo "98 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_list.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pubsub.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pubsub.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_set.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_set.c.bc
 check
-echo "99 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pubsub.c to bc" >&2
+echo "99 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_set.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/multi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/multi.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_zset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_zset.c.bc
 check
-echo "100 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/multi.c to bc" >&2
+echo "100 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_zset.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/debug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/debug.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_hash.c.bc
 check
-echo "101 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/debug.c to bc" >&2
+echo "101 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_hash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sort.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/config.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/config.c.bc
 check
-echo "102 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sort.c to bc" >&2
+echo "102 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/config.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/intset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/intset.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/aof.c.bc
 check
-echo "103 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/intset.c to bc" >&2
+echo "103 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/aof.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/syncio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/syncio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pubsub.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pubsub.c.bc
 check
-echo "104 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/syncio.c to bc" >&2
+echo "104 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pubsub.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/cluster.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/cluster.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/multi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/multi.c.bc
 check
-echo "105 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/cluster.c to bc" >&2
+echo "105 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/multi.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc16.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc16.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/debug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/debug.c.bc
 check
-echo "106 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc16.c to bc" >&2
+echo "106 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/debug.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/endianconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/endianconv.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sort.c.bc
 check
-echo "107 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/endianconv.c to bc" >&2
+echo "107 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sort.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/slowlog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/slowlog.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/intset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/intset.c.bc
 check
-echo "108 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/slowlog.c to bc" >&2
+echo "108 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/intset.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/scripting.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/scripting.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/syncio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/syncio.c.bc
 check
-echo "109 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/scripting.c to bc" >&2
+echo "109 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/syncio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/cluster.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/cluster.c.bc
 check
-echo "110 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bio.c to bc" >&2
+echo "110 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/cluster.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc16.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc16.c.bc
 check
-echo "111 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rio.c to bc" >&2
+echo "111 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc16.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rand.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rand.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/endianconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/endianconv.c.bc
 check
-echo "112 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rand.c to bc" >&2
+echo "112 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/endianconv.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/memtest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/memtest.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/slowlog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/slowlog.c.bc
 check
-echo "113 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/memtest.c to bc" >&2
+echo "113 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/slowlog.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc64.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc64.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/scripting.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/scripting.c.bc
 check
-echo "114 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc64.c to bc" >&2
+echo "114 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/scripting.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bitops.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bitops.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bio.c.bc
 check
-echo "115 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bitops.c to bc" >&2
+echo "115 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sentinel.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sentinel.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rio.c.bc
 check
-echo "116 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sentinel.c to bc" >&2
+echo "116 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/notify.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/notify.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rand.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rand.c.bc
 check
-echo "117 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/notify.c to bc" >&2
+echo "117 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rand.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/setproctitle.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/setproctitle.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/memtest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/memtest.c.bc
 check
-echo "118 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/setproctitle.c to bc" >&2
+echo "118 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/memtest.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/blocked.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/blocked.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc64.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc64.c.bc
 check
-echo "119 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/blocked.c to bc" >&2
+echo "119 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc64.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/hyperloglog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/hyperloglog.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bitops.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bitops.c.bc
 check
-echo "120 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/hyperloglog.c to bc" >&2
+echo "120 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bitops.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/latency.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/latency.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sentinel.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sentinel.c.bc
 check
-echo "121 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/latency.c to bc" >&2
+echo "121 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sentinel.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sparkline.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sparkline.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/notify.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/notify.c.bc
 check
-echo "122 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sparkline.c to bc" >&2
+echo "122 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/notify.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-rdb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/setproctitle.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/setproctitle.c.bc
 check
-echo "123 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-rdb.c to bc" >&2
+echo "123 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/setproctitle.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/geo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/geo.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/blocked.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/blocked.c.bc
 check
-echo "124 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/geo.c to bc" >&2
+echo "124 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/blocked.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/hyperloglog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/hyperloglog.c.bc
 check
-echo "125 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli.c to bc" >&2
+echo "125 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/hyperloglog.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-benchmark.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-benchmark.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/latency.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/latency.c.bc
 check
-echo "126 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-benchmark.c to bc" >&2
+echo "126 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/latency.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-aof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sparkline.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sparkline.c.bc
 check
-echo "127 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-aof.c to bc" >&2
+echo "127 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sparkline.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-rdb.c.bc
+check
+echo "128 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-rdb.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/geo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/geo.c.bc
+check
+echo "129 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/geo.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli.c.bc
+check
+echo "130 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-benchmark.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-benchmark.c.bc
+check
+echo "131 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-benchmark.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-aof.c.bc
+check
+echo "132 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-aof.c to bc" >&2
 echo "Total ir $total" >&2
 echo "Succ ir $succ" >&2
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/cluster.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/cluster.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/cluster.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/cluster.c	2017-01-31 23:32:23.000000000 +0800
@@ -126,13 +126,13 @@
         clusterNode *n, *master;
         char *p, *s;
 
         /* Skip blank lines, they can be created either by users manually
          * editing nodes.conf or by the config writing process if stopped
          * before the truncate() call. */
-        if (line[0] == '\n') continue;
+        if (line[0] == '\n' || line[0] == '\0') continue;
 
         /* Split the line into arguments for processing. */
         argv = sdssplitargs(line,&argc);
         if (argv == NULL) goto fmterr;
 
         /* Handle the special "vars" line. Don't pretend it is the last
@@ -4649,13 +4649,12 @@
  * MIGRATE host port "" dbid timeout [COPY | REPLACE] KEYS key1 key2 ... keyN */
 void migrateCommand(client *c) {
     migrateCachedSocket *cs;
     int copy, replace, j;
     long timeout;
     long dbid;
-    long long ttl, expireat;
     robj **ov = NULL; /* Objects to migrate. */
     robj **kv = NULL; /* Key names. */
     robj **newargv = NULL; /* Used to rewrite the command as DEL ... keys ... */
     rio cmd, payload;
     int may_retry = 1;
     int write_error = 0;
@@ -4664,13 +4663,12 @@
     int first_key = 3; /* Argument index of the first key. */
     int num_keys = 1;  /* By default only migrate the 'key' argument. */
 
     /* Initialization */
     copy = 0;
     replace = 0;
-    ttl = 0;
 
     /* Parse additional options */
     for (j = 6; j < c->argc; j++) {
         if (!strcasecmp(c->argv[j]->ptr,"copy")) {
             copy = 1;
         } else if (!strcasecmp(c->argv[j]->ptr,"replace")) {
@@ -4740,13 +4738,15 @@
         serverAssertWithInfo(c,NULL,rioWriteBulkString(&cmd,"SELECT",6));
         serverAssertWithInfo(c,NULL,rioWriteBulkLongLong(&cmd,dbid));
     }
 
     /* Create RESTORE payload and generate the protocol to call the command. */
     for (j = 0; j < num_keys; j++) {
-        expireat = getExpire(c->db,kv[j]);
+        long long ttl = 0;
+        long long expireat = getExpire(c->db,kv[j]);
+
         if (expireat != -1) {
             ttl = expireat-mstime();
             if (ttl < 1) ttl = 1;
         }
         serverAssertWithInfo(c,NULL,rioWriteBulkCount(&cmd,'*',replace ? 5 : 4));
         if (server.cluster_enabled)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/cluster.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/cluster.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/cluster.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/cluster.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/compile_commands.json /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/compile_commands.json
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/compile_commands.json	2017-09-27 23:00:38.086935442 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/compile_commands.json	2017-09-27 23:02:14.510931908 +0800
@@ -1,1351 +1,1525 @@
 [
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb net.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/net.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/net.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb hiredis.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/hiredis.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/hiredis.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb sds.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/sds.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/sds.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb async.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/async.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/async.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/linenoise",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/linenoise",
   "command": "cc -Wall -Os -g -c linenoise.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/linenoise/linenoise.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/linenoise/linenoise.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lapi.o lapi.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lapi.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lapi.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lcode.o lcode.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lcode.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lcode.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldebug.o ldebug.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldebug.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldebug.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldo.o ldo.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldo.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldo.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldump.o ldump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldump.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldump.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lfunc.o lfunc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lfunc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lfunc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lgc.o lgc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lgc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lgc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o llex.o llex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/llex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/llex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lmem.o lmem.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmem.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmem.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lobject.o lobject.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lobject.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lobject.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lopcodes.o lopcodes.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lopcodes.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lopcodes.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lparser.o lparser.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lparser.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lparser.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lstate.o lstate.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstate.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstate.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lstring.o lstring.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstring.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstring.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ltable.o ltable.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltable.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltable.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ltm.o ltm.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltm.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltm.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lundump.o lundump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lundump.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lundump.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lvm.o lvm.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lvm.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lvm.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lzio.o lzio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lzio.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lzio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o strbuf.o strbuf.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/strbuf.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/strbuf.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o fpconv.o fpconv.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/fpconv.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/fpconv.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lauxlib.o lauxlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lauxlib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lauxlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lbaselib.o lbaselib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lbaselib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lbaselib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldblib.o ldblib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldblib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldblib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o liolib.o liolib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/liolib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/liolib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lmathlib.o lmathlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmathlib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmathlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o loslib.o loslib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loslib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loslib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ltablib.o ltablib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltablib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltablib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lstrlib.o lstrlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstrlib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstrlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o loadlib.o loadlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loadlib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loadlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o linit.o linit.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/linit.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/linit.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_cjson.o lua_cjson.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cjson.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cjson.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_struct.o lua_struct.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_struct.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_struct.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_cmsgpack.o lua_cmsgpack.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cmsgpack.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cmsgpack.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_bit.o lua_bit.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_bit.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_bit.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua.o lua.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o luac.o luac.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/luac.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/luac.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o print.o print.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/print.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/print.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int",
   "command": "cc -Wall -O2 -g -c geohash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int",
   "command": "cc -Wall -O2 -g -c geohash_helper.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash_helper.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash_helper.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -g conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "cc -c -o /tmp/cgZYFmPA/dummy.o /tmp/cgZYFmPA/dummy.c",
-  "file": "/tmp/cgZYFmPA/dummy.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "cc -c -o /tmp/cgobnqBZ/dummy.o /tmp/cgobnqBZ/dummy.c",
+  "file": "/tmp/cgobnqBZ/dummy.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "cc -E /tmp/cgZYFmPA/dummy.c",
-  "file": "/tmp/cgZYFmPA/dummy.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "cc -E /tmp/cgobnqBZ/dummy.c",
+  "file": "/tmp/cgobnqBZ/dummy.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -E -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -herror_on_warning -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -herror_on_warning -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -herror_on_warning -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -herror_on_warning -D_GNU_SOURCE conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -E -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lpthread -lm",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE -D_REENTRANT conftest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lm -lpthread",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/jemalloc.o src/jemalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/jemalloc.o -o src/jemalloc.d src/jemalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/arena.o src/arena.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/arena.o -o src/arena.d src/arena.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/atomic.o src/atomic.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/atomic.o -o src/atomic.d src/atomic.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/base.o src/base.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/base.o -o src/base.d src/base.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/bitmap.o src/bitmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/bitmap.o -o src/bitmap.d src/bitmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk.o src/chunk.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk.o -o src/chunk.d src/chunk.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk_dss.o src/chunk_dss.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk_dss.o -o src/chunk_dss.d src/chunk_dss.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk_mmap.o src/chunk_mmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk_mmap.o -o src/chunk_mmap.d src/chunk_mmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ckh.o src/ckh.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/ckh.o -o src/ckh.d src/ckh.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ctl.o src/ctl.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/ctl.o -o src/ctl.d src/ctl.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/extent.o src/extent.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/extent.o -o src/extent.d src/extent.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/hash.o src/hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/hash.o -o src/hash.d src/hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/huge.o src/huge.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/huge.o -o src/huge.d src/huge.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mb.o src/mb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/mb.o -o src/mb.d src/mb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mutex.o src/mutex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/mutex.o -o src/mutex.d src/mutex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/nstime.o src/nstime.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/nstime.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/nstime.o -o src/nstime.d src/nstime.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/nstime.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/pages.o src/pages.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/pages.o -o src/pages.d src/pages.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/prng.o src/prng.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prng.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/prng.o -o src/prng.d src/prng.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prng.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/prof.o src/prof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/prof.o -o src/prof.d src/prof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/quarantine.o src/quarantine.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/quarantine.o -o src/quarantine.d src/quarantine.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/rtree.o src/rtree.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/rtree.o -o src/rtree.d src/rtree.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/stats.o src/stats.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/stats.o -o src/stats.d src/stats.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/spin.o src/spin.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/spin.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/spin.o -o src/spin.d src/spin.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/spin.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tcache.o src/tcache.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/tcache.o -o src/tcache.d src/tcache.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/util.o src/util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ticker.o src/ticker.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ticker.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
-  "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/util.o -o src/util.d src/util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/ticker.o -o src/ticker.d src/ticker.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ticker.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tsd.o src/tsd.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/tsd.o -o src/tsd.d src/tsd.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/util.o src/util.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/util.o -o src/util.d src/util.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/witness.o src/witness.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/witness.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc",
+  "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/witness.o -o src/witness.d src/witness.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/witness.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c adlist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/adlist.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/adlist.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c quicklist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/quicklist.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/quicklist.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ae.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ae.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ae.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c anet.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/anet.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/anet.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c dict.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/dict.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/dict.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c server.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sds.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sds.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sds.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zmalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zmalloc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zmalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_c.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_c.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_c.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_d.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_d.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_d.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pqsort.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pqsort.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pqsort.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zipmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zipmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zipmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sha1.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sha1.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sha1.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ziplist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ziplist.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ziplist.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c release.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/release.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/release.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c networking.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/networking.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/networking.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/util.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c object.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/object.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/object.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c db.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/db.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/db.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c replication.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/replication.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/replication.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rdb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rdb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rdb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_string.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_string.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_string.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_list.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_list.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_list.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_set.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_set.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_set.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_zset.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_zset.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_zset.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_hash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c config.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/config.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/config.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c aof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/aof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/aof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pubsub.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pubsub.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pubsub.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c multi.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/multi.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/multi.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c debug.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/debug.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/debug.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sort.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sort.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sort.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c intset.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/intset.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/intset.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c syncio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/syncio.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/syncio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c cluster.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/cluster.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/cluster.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc16.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc16.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc16.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c endianconv.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/endianconv.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/endianconv.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c slowlog.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/slowlog.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/slowlog.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c scripting.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/scripting.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/scripting.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bio.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rio.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rand.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rand.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rand.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c memtest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/memtest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/memtest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc64.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc64.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc64.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bitops.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bitops.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bitops.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sentinel.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sentinel.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sentinel.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c notify.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/notify.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/notify.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c setproctitle.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/setproctitle.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/setproctitle.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c blocked.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/blocked.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/blocked.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c hyperloglog.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/hyperloglog.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/hyperloglog.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c latency.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/latency.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/latency.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sparkline.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sparkline.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sparkline.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-rdb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-rdb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-rdb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c geo.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/geo.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/geo.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-cli.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-benchmark.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-benchmark.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-benchmark.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src",
   "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-aof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-aof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-aof.c"
 }
 ]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/compiled_files.def /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/compiled_files.def
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/compiled_files.def	2017-09-27 23:00:38.094935442 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/compiled_files.def	2017-09-27 23:02:14.518931908 +0800
@@ -1,127 +1,132 @@
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/net.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/hiredis.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/sds.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/hiredis/async.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/linenoise/linenoise.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lapi.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lcode.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldebug.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldo.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lfunc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lgc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/llex.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmem.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lobject.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lopcodes.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lparser.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstate.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstring.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltable.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltm.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lundump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lvm.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lzio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/strbuf.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/fpconv.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lauxlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lbaselib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ldblib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/liolib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lmathlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loslib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/ltablib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lstrlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/loadlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/linit.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cjson.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_struct.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_cmsgpack.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua_bit.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/lua.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/luac.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/lua/src/print.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/geohash-int/geohash_helper.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/conftest.c
-/tmp/cgZYFmPA/dummy.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/jemalloc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/arena.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/atomic.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/base.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/bitmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_dss.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/chunk_mmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ckh.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/ctl.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/extent.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/hash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/huge.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/mutex.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/pages.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/prof.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/quarantine.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/rtree.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/stats.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tcache.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/util.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/deps/jemalloc/src/tsd.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/adlist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/quicklist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ae.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/anet.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/dict.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sds.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zmalloc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_c.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_d.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pqsort.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zipmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sha1.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ziplist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/release.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/networking.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/util.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/object.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/db.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/replication.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rdb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_string.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_list.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_set.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_zset.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_hash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/config.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/aof.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pubsub.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/multi.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/debug.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sort.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/intset.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/syncio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/cluster.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc16.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/endianconv.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/slowlog.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/scripting.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rand.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/memtest.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc64.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/bitops.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sentinel.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/notify.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/setproctitle.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/blocked.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/hyperloglog.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/latency.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sparkline.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-rdb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/geo.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-benchmark.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-aof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/net.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/hiredis.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/sds.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/hiredis/async.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/linenoise/linenoise.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lapi.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lcode.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldebug.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldo.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldump.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lfunc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lgc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/llex.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmem.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lobject.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lopcodes.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lparser.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstate.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstring.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltable.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltm.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lundump.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lvm.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lzio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/strbuf.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/fpconv.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lauxlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lbaselib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ldblib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/liolib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lmathlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loslib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/ltablib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lstrlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/loadlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/linit.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cjson.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_struct.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_cmsgpack.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua_bit.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/lua.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/luac.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/lua/src/print.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/geohash-int/geohash_helper.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/conftest.c
+/tmp/cgobnqBZ/dummy.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/jemalloc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/arena.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/atomic.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/base.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/bitmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_dss.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/chunk_mmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ckh.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ctl.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/extent.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/hash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/huge.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/mutex.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/nstime.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/pages.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prng.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/prof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/quarantine.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/rtree.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/stats.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/spin.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tcache.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/ticker.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/tsd.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/util.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/deps/jemalloc/src/witness.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/adlist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/quicklist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ae.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/anet.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/dict.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sds.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zmalloc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_c.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_d.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pqsort.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zipmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sha1.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ziplist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/release.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/networking.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/util.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/object.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/db.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/replication.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rdb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_string.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_list.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_set.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_zset.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_hash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/config.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/aof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pubsub.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/multi.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/debug.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sort.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/intset.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/syncio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/cluster.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc16.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/endianconv.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/slowlog.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/scripting.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rand.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/memtest.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc64.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/bitops.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sentinel.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/notify.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/setproctitle.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/blocked.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/hyperloglog.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/latency.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sparkline.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-rdb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/geo.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-benchmark.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-aof.c
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/config.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/config.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/config.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/config.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc16.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc16.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc16.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc16.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc64.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc64.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/crc64.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/crc64.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/db.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/db.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/db.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/db.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/debug.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/debug.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/debug.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/debug.c	2017-01-31 23:32:23.000000000 +0800
@@ -123,13 +123,13 @@
     memset(final,0,20); /* Start with a clean result */
 
     for (j = 0; j < server.dbnum; j++) {
         redisDb *db = server.db+j;
 
         if (dictSize(db->dict) == 0) continue;
-        di = dictGetIterator(db->dict);
+        di = dictGetSafeIterator(db->dict);
 
         /* hash the DB id, so the same dataset moved in a different
          * DB will lead to a different digest */
         aux = htonl(j);
         mixDigest(final,&aux,sizeof(aux));
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/debug.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/debug.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/debug.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/debug.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/dict.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/dict.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/dict.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/dict.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/endianconv.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/endianconv.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/endianconv.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/endianconv.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/geo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/geo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/geo.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/geo.c	2017-01-31 23:32:23.000000000 +0800
@@ -325,12 +325,13 @@
 }
 
 /* Search all eight neighbors + self geohash box */
 int membersOfAllNeighbors(robj *zobj, GeoHashRadius n, double lon, double lat, double radius, geoArray *ga) {
     GeoHashBits neighbors[9];
     unsigned int i, count = 0, last_processed = 0;
+    int debugmsg = 0;
 
     neighbors[0] = n.hash;
     neighbors[1] = n.neighbors.north;
     neighbors[2] = n.neighbors.south;
     neighbors[3] = n.neighbors.east;
     neighbors[4] = n.neighbors.west;
@@ -339,23 +340,45 @@
     neighbors[7] = n.neighbors.south_east;
     neighbors[8] = n.neighbors.south_west;
 
     /* For each neighbor (*and* our own hashbox), get all the matching
      * members and add them to the potential result list. */
     for (i = 0; i < sizeof(neighbors) / sizeof(*neighbors); i++) {
-        if (HASHISZERO(neighbors[i]))
+        if (HASHISZERO(neighbors[i])) {
+            if (debugmsg) D("neighbors[%d] is zero",i);
             continue;
+        }
+
+        /* Debugging info. */
+        if (debugmsg) {
+            GeoHashRange long_range, lat_range;
+            geohashGetCoordRange(&long_range,&lat_range);
+            GeoHashArea myarea = {{0,0},{0,0},{0,0}};
+            geohashDecode(long_range, lat_range, neighbors[i], &myarea);
+
+            /* Dump center square. */
+            D("neighbors[%d]:\n",i);
+            D("area.longitude.min: %f\n", myarea.longitude.min);
+            D("area.longitude.max: %f\n", myarea.longitude.max);
+            D("area.latitude.min: %f\n", myarea.latitude.min);
+            D("area.latitude.max: %f\n", myarea.latitude.max);
+            D("\n");
+        }
 
         /* When a huge Radius (in the 5000 km range or more) is used,
          * adjacent neighbors can be the same, leading to duplicated
          * elements. Skip every range which is the same as the one
          * processed previously. */
         if (last_processed &&
             neighbors[i].bits == neighbors[last_processed].bits &&
             neighbors[i].step == neighbors[last_processed].step)
+        {
+            if (debugmsg)
+                D("Skipping processing of %d, same as previous\n",i);
             continue;
+        }
         count += membersOfGeoHashBox(zobj, neighbors[i], ga, lon, lat, radius);
         last_processed = i;
     }
     return count;
 }
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/geo.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/geo.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/geo.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/geo.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/hyperloglog.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/hyperloglog.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/hyperloglog.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/hyperloglog.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/intset.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/intset.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/intset.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/intset.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/latency.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/latency.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/latency.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/latency.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_c.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_c.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_c.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_c.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_d.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_d.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/lzf_d.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/lzf_d.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/memtest.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/memtest.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/memtest.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/memtest.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/multi.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/multi.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/multi.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/multi.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/networking.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/networking.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/networking.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/networking.c	2017-01-31 23:32:23.000000000 +0800
@@ -1266,14 +1266,16 @@
 
         /* Immediately abort if the client is in the middle of something. */
         if (c->flags & CLIENT_BLOCKED) break;
 
         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
          * written to the client. Make sure to not let the reply grow after
-         * this flag has been set (i.e. don't process more commands). */
-        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;
+         * this flag has been set (i.e. don't process more commands).
+         *
+         * The same applies for clients we want to terminate ASAP. */
+        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
 
         /* Determine request type when unknown. */
         if (!c->reqtype) {
             if (c->querybuf[0] == '*') {
                 c->reqtype = PROTO_REQ_MULTIBULK;
             } else {
@@ -1634,12 +1636,32 @@
         addReply(c,shared.ok);
     } else {
         addReplyError(c, "Syntax error, try CLIENT (LIST | KILL | GETNAME | SETNAME | PAUSE | REPLY)");
     }
 }
 
+/* This callback is bound to POST and "Host:" command names. Those are not
+ * really commands, but are used in security attacks in order to talk to
+ * Redis instances via HTTP, with a technique called "cross protocol scripting"
+ * which exploits the fact that services like Redis will discard invalid
+ * HTTP headers and will process what follows.
+ *
+ * As a protection against this attack, Redis will terminate the connection
+ * when a POST or "Host:" header is seen, and will log the event from
+ * time to time (to avoid creating a DOS as a result of too many logs). */
+void securityWarningCommand(client *c) {
+    static time_t logged_time;
+    time_t now = time(NULL);
+
+    if (labs(now-logged_time) > 60) {
+        serverLog(LL_WARNING,"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.");
+        logged_time = now;
+    }
+    freeClientAsync(c);
+}
+
 /* Rewrite the command vector of the client. All the new objects ref count
  * is incremented. The old command vector is freed, and the old objects
  * ref count is decremented. */
 void rewriteClientCommandVector(client *c, int argc, ...) {
     va_list ap;
     int j;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/networking.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/networking.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/networking.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/networking.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/notify.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/notify.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/notify.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/notify.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/object.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/object.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/object.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/object.c	2017-01-31 23:32:23.000000000 +0800
@@ -238,17 +238,15 @@
     if (o->encoding == OBJ_ENCODING_RAW) {
         sdsfree(o->ptr);
     }
 }
 
 void freeListObject(robj *o) {
-    switch (o->encoding) {
-    case OBJ_ENCODING_QUICKLIST:
+    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
         quicklistRelease(o->ptr);
-        break;
-    default:
+    } else {
         serverPanic("Unknown list encoding type");
     }
 }
 
 void freeSetObject(robj *o) {
     switch (o->encoding) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/object.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/object.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/object.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/object.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pqsort.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pqsort.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pqsort.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pqsort.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pubsub.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pubsub.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/pubsub.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/pubsub.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/quicklist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/quicklist.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/quicklist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/quicklist.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rand.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rand.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rand.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rand.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rdb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rdb.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rdb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rdb.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-benchmark and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-benchmark differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-benchmark.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-benchmark.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-benchmark.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-benchmark.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-aof and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-aof differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-aof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-aof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-aof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-aof.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-rdb and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-rdb differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-rdb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-rdb.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-check-rdb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-check-rdb.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli.c	2017-01-31 23:32:23.000000000 +0800
@@ -272,12 +272,16 @@
     if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;
 
     /* Scan the array reported by COMMAND and fill only the entries that
      * don't already match what we have. */
     for (size_t j = 0; j < reply->elements; j++) {
         redisReply *entry = reply->element[j];
+        if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||
+            entry->element[0]->type != REDIS_REPLY_STRING ||
+            entry->element[1]->type != REDIS_REPLY_INTEGER ||
+            entry->element[3]->type != REDIS_REPLY_INTEGER) return;
         char *cmdname = entry->element[0]->str;
         int i;
 
         for (i = 0; i < helpEntriesLen; i++) {
             helpEntry *he = helpEntries+i;
             if (!strcasecmp(he->argv[0],cmdname))
@@ -1252,23 +1256,29 @@
             int argc;
 
             argv = sdssplitargs(buf,&argc);
             if (argc > 0) cliSetPreferences(argv,argc,0);
             sdsfreesplitres(argv,argc);
         }
+        fclose(fp);
     }
     sdsfree(rcfile);
 }
 
 static void repl(void) {
     sds historyfile = NULL;
     int history = 0;
     char *line;
     int argc;
     sds *argv;
 
+    /* Initialize the help and, if possible, use the COMMAND command in order
+     * to retrieve missing entries. */
+    cliInitHelp();
+    cliIntegrateHelp();
+
     config.interactive = 1;
     linenoiseSetMultiLine(1);
     linenoiseSetCompletionCallback(completionCallback);
     linenoiseSetHintsCallback(hintsCallback);
     linenoiseSetFreeHintsCallback(freeHintsCallback);
 
@@ -2593,17 +2603,12 @@
     config.mb_delim = sdsnew("\n");
 
     firstarg = parseOptions(argc,argv);
     argc -= firstarg;
     argv += firstarg;
 
-    /* Initialize the help and, if possible, use the COMMAND command in order
-     * to retrieve missing entries. */
-    cliInitHelp();
-    cliIntegrateHelp();
-
     /* Latency mode */
     if (config.latency_mode) {
         if (cliConnect(0) == REDIS_ERR) exit(1);
         latencyMode();
     }
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-cli.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-cli.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-sentinel and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-sentinel differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/redis-server and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/redis-server differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/release.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/release.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/release.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/release.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/release.h	2017-09-27 23:00:10.406936457 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/release.h	2017-09-27 23:01:45.090932987 +0800
@@ -1,3 +1,3 @@
 #define REDIS_GIT_SHA1 "00000000"
 #define REDIS_GIT_DIRTY "0"
-#define REDIS_BUILD_ID "sarah-Erazer-X310-1506524410"
+#define REDIS_BUILD_ID "sarah-Erazer-X310-1506524505"
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/release.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/release.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/replication.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/replication.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/replication.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/replication.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rio.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/rio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/rio.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/scripting.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/scripting.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/scripting.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/scripting.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sds.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sds.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sds.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sds.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sentinel.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sentinel.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sentinel.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sentinel.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.c	2017-01-31 23:32:23.000000000 +0800
@@ -291,12 +291,14 @@
     {"geodist",geodistCommand,-4,"r",0,NULL,1,1,1,0,0},
     {"pfselftest",pfselftestCommand,1,"a",0,NULL,0,0,0,0,0},
     {"pfadd",pfaddCommand,-2,"wmF",0,NULL,1,1,1,0,0},
     {"pfcount",pfcountCommand,-2,"r",0,NULL,1,-1,1,0,0},
     {"pfmerge",pfmergeCommand,-2,"wm",0,NULL,1,-1,1,0,0},
     {"pfdebug",pfdebugCommand,-3,"w",0,NULL,0,0,0,0,0},
+    {"post",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
+    {"host:",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
     {"latency",latencyCommand,-2,"aslt",0,NULL,0,0,0,0,0}
 };
 
 struct evictionPoolEntry *evictionPoolAlloc(void);
 
 /*============================ Utility functions ============================ */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.h	2017-01-31 23:32:23.000000000 +0800
@@ -1642,12 +1642,13 @@
 void pfselftestCommand(client *c);
 void pfaddCommand(client *c);
 void pfcountCommand(client *c);
 void pfmergeCommand(client *c);
 void pfdebugCommand(client *c);
 void latencyCommand(client *c);
+void securityWarningCommand(client *c);
 
 #if defined(__GNUC__)
 void *calloc(size_t count, size_t size) __attribute__ ((deprecated));
 void free(void *ptr) __attribute__ ((deprecated));
 void *malloc(size_t size) __attribute__ ((deprecated));
 void *realloc(void *ptr, size_t size) __attribute__ ((deprecated));
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/server.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/server.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/setproctitle.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/setproctitle.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/setproctitle.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/setproctitle.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sha1.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sha1.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sha1.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sha1.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/slowlog.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/slowlog.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/slowlog.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/slowlog.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sort.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sort.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sort.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sort.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sparkline.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sparkline.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/sparkline.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/sparkline.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/syncio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/syncio.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/syncio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/syncio.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_hash.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_hash.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_hash.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_hash.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_list.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_list.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_list.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_list.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_set.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_set.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_set.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_set.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_string.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_string.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_string.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_string.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_zset.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_zset.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_zset.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_zset.c	2017-01-31 23:32:23.000000000 +0800
@@ -1244,13 +1244,13 @@
     int xx = (flags & ZADD_XX) != 0;
     int ch = (flags & ZADD_CH) != 0;
 
     /* After the options, we expect to have an even number of args, since
      * we expect any number of score-element pairs. */
     elements = c->argc-scoreidx;
-    if (elements % 2) {
+    if (elements % 2 || !elements) {
         addReply(c,shared.syntaxerr);
         return;
     }
     elements /= 2; /* Now this holds the number of score-element pairs. */
 
     /* Check for incompatible options. */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_zset.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_zset.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/t_zset.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/t_zset.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/util.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/util.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/util.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/util.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/version.h	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/version.h	2017-01-31 23:32:23.000000000 +0800
@@ -1 +1 @@
-#define REDIS_VERSION "3.2.5"
+#define REDIS_VERSION "3.2.7"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ziplist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ziplist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ziplist.c	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ziplist.c	2017-01-31 23:32:23.000000000 +0800
@@ -177,13 +177,13 @@
     if ((encoding) < ZIP_STR_MASK) (encoding) &= ZIP_STR_MASK; \
 } while(0)
 
 void ziplistRepr(unsigned char *zl);
 
 /* Return bytes needed to store integer encoded by 'encoding' */
-static unsigned int zipIntSize(unsigned char encoding) {
+unsigned int zipIntSize(unsigned char encoding) {
     switch(encoding) {
     case ZIP_INT_8B:  return 1;
     case ZIP_INT_16B: return 2;
     case ZIP_INT_24B: return 3;
     case ZIP_INT_32B: return 4;
     case ZIP_INT_64B: return 8;
@@ -192,13 +192,13 @@
     assert(NULL);
     return 0;
 }
 
 /* Encode the length 'rawlen' writing it in 'p'. If p is NULL it just returns
  * the amount of bytes required to encode such a length. */
-static unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
+unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
     unsigned char len = 1, buf[5];
 
     if (ZIP_IS_STR(encoding)) {
         /* Although encoding is given it may not be set for strings,
          * so we determine it here using the raw length. */
         if (rawlen <= 0x3f) {
@@ -256,13 +256,13 @@
         (len) = zipIntSize(encoding);                                          \
     }                                                                          \
 } while(0);
 
 /* Encode the length of the previous entry and write it to "p". Return the
  * number of bytes needed to encode this length if "p" is NULL. */
-static unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) {
+unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) {
     if (p == NULL) {
         return (len < ZIP_BIGLEN) ? 1 : sizeof(len)+1;
     } else {
         if (len < ZIP_BIGLEN) {
             p[0] = len;
             return 1;
@@ -274,13 +274,13 @@
         }
     }
 }
 
 /* Encode the length of the previous entry and write it to "p". This only
  * uses the larger encoding (required in __ziplistCascadeUpdate). */
-static void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len) {
+void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len) {
     if (p == NULL) return;
     p[0] = ZIP_BIGLEN;
     memcpy(p+1,&len,sizeof(len));
     memrev32ifbe(p+1);
 }
 
@@ -306,29 +306,29 @@
         memrev32ifbe(&prevlen);                                                \
     }                                                                          \
 } while(0);
 
 /* Return the difference in number of bytes needed to store the length of the
  * previous element 'len', in the entry pointed to by 'p'. */
-static int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
+int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
     unsigned int prevlensize;
     ZIP_DECODE_PREVLENSIZE(p, prevlensize);
     return zipPrevEncodeLength(NULL, len) - prevlensize;
 }
 
 /* Return the total number of bytes used by the entry pointed to by 'p'. */
-static unsigned int zipRawEntryLength(unsigned char *p) {
+unsigned int zipRawEntryLength(unsigned char *p) {
     unsigned int prevlensize, encoding, lensize, len;
     ZIP_DECODE_PREVLENSIZE(p, prevlensize);
     ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
     return prevlensize + lensize + len;
 }
 
 /* Check if string pointed to by 'entry' can be encoded as an integer.
  * Stores the integer value in 'v' and its encoding in 'encoding'. */
-static int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {
+int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {
     long long value;
 
     if (entrylen >= 32 || entrylen == 0) return 0;
     if (string2ll((char*)entry,entrylen,&value)) {
         /* Great, the string can be encoded. Check what's the smallest
          * of our encoding types that can hold this value. */
@@ -349,13 +349,13 @@
         return 1;
     }
     return 0;
 }
 
 /* Store integer 'value' at 'p', encoded as 'encoding' */
-static void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {
+void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {
     int16_t i16;
     int32_t i32;
     int64_t i64;
     if (encoding == ZIP_INT_8B) {
         ((int8_t*)p)[0] = (int8_t)value;
     } else if (encoding == ZIP_INT_16B) {
@@ -379,13 +379,13 @@
     } else {
         assert(NULL);
     }
 }
 
 /* Read integer encoded as 'encoding' from 'p' */
-static int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {
+int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {
     int16_t i16;
     int32_t i32;
     int64_t i64, ret = 0;
     if (encoding == ZIP_INT_8B) {
         ret = ((int8_t*)p)[0];
     } else if (encoding == ZIP_INT_16B) {
@@ -411,13 +411,13 @@
         assert(NULL);
     }
     return ret;
 }
 
 /* Return a struct with all information about an entry. */
-static void zipEntry(unsigned char *p, zlentry *e) {
+void zipEntry(unsigned char *p, zlentry *e) {
 
     ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
     ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
     e->headersize = e->prevrawlensize + e->lensize;
     e->p = p;
 }
@@ -431,13 +431,13 @@
     ZIPLIST_LENGTH(zl) = 0;
     zl[bytes-1] = ZIP_END;
     return zl;
 }
 
 /* Resize the ziplist. */
-static unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {
+unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {
     zl = zrealloc(zl,len);
     ZIPLIST_BYTES(zl) = intrev32ifbe(len);
     zl[len-1] = ZIP_END;
     return zl;
 }
 
@@ -458,13 +458,13 @@
  * first grown and then shrunk again after consecutive inserts. Rather, the
  * field is allowed to stay larger than necessary, because a large prevlen
  * field implies the ziplist is holding large entries anyway.
  *
  * The pointer "p" points to the first entry that does NOT need to be
  * updated, i.e. consecutive fields MAY need an update. */
-static unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
+unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
     size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
     size_t offset, noffset, extra;
     unsigned char *np;
     zlentry cur, next;
 
     while (p[0] != ZIP_END) {
@@ -520,13 +520,13 @@
         }
     }
     return zl;
 }
 
 /* Delete "num" entries, starting at "p". Returns pointer to the ziplist. */
-static unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
+unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
     unsigned int i, totlen, deleted = 0;
     size_t offset;
     int nextdiff = 0;
     zlentry first, tail;
 
     zipEntry(p, &first);
@@ -580,13 +580,13 @@
             zl = __ziplistCascadeUpdate(zl,p);
     }
     return zl;
 }
 
 /* Insert item at "p". */
-static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
+unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
     size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
     unsigned int prevlensize, prevlen = 0;
     size_t offset;
     int nextdiff = 0;
     unsigned char encoding = 0;
     long long value = 123456789; /* initialized to avoid warning. Using a value
@@ -618,26 +618,34 @@
     reqlen += zipPrevEncodeLength(NULL,prevlen);
     reqlen += zipEncodeLength(NULL,encoding,slen);
 
     /* When the insert position is not equal to the tail, we need to
      * make sure that the next entry can hold this entry's length in
      * its prevlen field. */
+    int forcelarge = 0;
     nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;
+    if (nextdiff == -4 && reqlen < 4) {
+        nextdiff = 0;
+        forcelarge = 1;
+    }
 
     /* Store offset because a realloc may change the address of zl. */
     offset = p-zl;
     zl = ziplistResize(zl,curlen+reqlen+nextdiff);
     p = zl+offset;
 
     /* Apply memory move when necessary and update tail offset. */
     if (p[0] != ZIP_END) {
         /* Subtract one because of the ZIP_END bytes */
         memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);
 
         /* Encode this entry's raw length in the next entry. */
-        zipPrevEncodeLength(p+reqlen,reqlen);
+        if (forcelarge)
+            zipPrevEncodeLengthForceLarge(p+reqlen,reqlen);
+        else
+            zipPrevEncodeLength(p+reqlen,reqlen);
 
         /* Update offset for tail */
         ZIPLIST_TAIL_OFFSET(zl) =
             intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);
 
         /* When the tail contains more than one entry, we need to take
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ziplist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ziplist.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/ziplist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/ziplist.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zipmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zipmap.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zipmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zipmap.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zmalloc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zmalloc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/src/zmalloc.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/src/zmalloc.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/tests/unit/bitfield.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/tests/unit/bitfield.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/tests/unit/bitfield.tcl	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/tests/unit/bitfield.tcl	2017-01-31 23:32:23.000000000 +0800
@@ -186,7 +186,16 @@
     }
 
     test {BITFIELD regression for #3221} {
         r set bits 1
         r bitfield bits get u1 0
     } {0}
+
+    test {BITFIELD regression for #3564} {
+        for {set j 0} {$j < 10} {incr j} {
+            r del mystring
+            set res [r BITFIELD mystring SET i8 0 10 SET i8 64 10 INCRBY i8 10 99900]
+            assert {$res eq {0 0 60}}
+        }
+        r del mystring
+    }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/tests/unit/geo.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/tests/unit/geo.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.5/tests/unit/geo.tcl	2016-10-26 15:17:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.7/tests/unit/geo.tcl	2017-01-31 23:32:23.000000000 +0800
@@ -218,24 +218,32 @@
         assert {[r zcard points2] == 1}
         set res [r zrange points2 0 -1 withscores]
         assert {[lindex $res 0] eq "Catania"}
     }
 
     test {GEOADD + GEORANGE randomized test} {
-        set attempt 20
+        set attempt 30
         while {[incr attempt -1]} {
             set rv [lindex $regression_vectors $rv_idx]
             incr rv_idx
 
             unset -nocomplain debuginfo
-            set srand_seed [randomInt 1000000]
+            set srand_seed [clock milliseconds]
             if {$rv ne {}} {set srand_seed [lindex $rv 0]}
             lappend debuginfo "srand_seed is $srand_seed"
             expr {srand($srand_seed)} ; # If you need a reproducible run
             r del mypoints
-            set radius_km [expr {[randomInt 200]+10}]
+
+            if {[randomInt 10] == 0} {
+                # From time to time use very big radiuses
+                set radius_km [expr {[randomInt 50000]+10}]
+            } else {
+                # Normally use a few - ~200km radiuses to stress
+                # test the code the most in edge cases.
+                set radius_km [expr {[randomInt 200]+10}]
+            }
             if {$rv ne {}} {set radius_km [lindex $rv 1]}
             set radius_m [expr {$radius_km*1000}]
             geo_random_point search_lon search_lat
             if {$rv ne {}} {
                 set search_lon [lindex $rv 2]
                 set search_lat [lindex $rv 3]
