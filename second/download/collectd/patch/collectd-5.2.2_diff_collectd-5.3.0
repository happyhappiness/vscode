diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/AUTHORS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/AUTHORS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/AUTHORS	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/AUTHORS	2013-04-10 10:14:19.000000000 +0800
@@ -88,12 +88,15 @@
 Jason Pepas <cell at ices.utexas.edu>
  - nfs plugin.
 
 Jérôme Renard <jerome.renard at gmail.com>
  - varnish plugin.
 
+Kris Nielander <nielander at fox-it.com>
+ - tail_csv plugin.
+
 Luboš Staněk <kolektor at atlas.cz>
  - sensors plugin improvements.
  - Time and effort to find a nasty bug in the ntpd-plugin.
 
 Luke Herberling <collectd at c-ware.com>
  - powerdns plugin.
@@ -162,12 +165,16 @@
  - Some bugfixes in the exec plugin.
  - Notifications in the ipmi plugin.
 
 Phoenix Kayo <kayo.k11.4 at gmail.com>
  - pinba plugin.
 
+Pierre-Yves Ritschard <pyr at spootnik.org>
+ - Write-Riemann plugin.
+ - Write-Graphite plugin: Notification support.
+
 Piotr Hosowicz <the55 at wp.pl>
  - SMF manifest for collectd.
 
 Richard W. M. Jones <rjones at redhat.com>
  - libvirt plugin.
  - uuid plugin.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/ChangeLog /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/ChangeLog
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/ChangeLog	2013-04-09 09:13:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/ChangeLog	2013-04-10 10:14:25.000000000 +0800
@@ -1,6 +1,45 @@
+2013-04-09, Version 5.3.0
+	* collectd: The "Include" statements can now be limited to include
+	  only matching files in a directory. Thanks to Sebastian Harl for his
+	  patch.
+	* collectd: Dispatches / writes are now handled by a thread pool. This
+	  improves reliability and throughput for instances configured to act
+	  as a "server". Thanks to Sebastian Harl and Dan Fandrich for
+	  reviewing this change and fixing bugs.
+	* aggregation plugin: Selection of value lists is now possible using
+	  regular expressions. Parts of the identifier of the resulting metric
+	  can now be set via the configuration file.
+	* apcups plugin: The "ReportSeconds" option has been implemented.
+	* curl* plugins: Support for POST requests and custom request headers
+	  has been added. Thanks to Dan Fandrich for his patch.
+	* curl_xml plugin: Support for XML namespaces has been added. Thanks
+	  to Dan Fandrich for his patch.
+	* dbi plugin: Support for numeric options has been added. The
+	  "Host" option has been added. Thanks to Daniel Hilst for his patch.
+	* disk plugin: Support for systems with >256 has been fixed. Thanks to
+	  Greg Mason for his patch.
+	* libvirt plugin: Support for memory allocation has been added. Thanks
+	  to Johan Wirén for his patch.
+	* netapp plugin: Support for "SnapVault", "VFiler" and deduplication /
+	  compression and quota metrics. Thanks to Sebastian Harl for his
+	  patches and teamix GmbH for sponsoring this work.
+	* postgresql plugin: The reconnection logic has been improved. Thanks
+	  to Sebastian Harl for his patches.
+	* rrdtool, rrdcached plugins: The "CreateFilesAsync" option has been
+	  implemented. When enabled, new RRD files will be created
+	  asynchronously, which improved throughput of "server" instances.
+	  Many thanks to Yves Mettier for all his input and code.
+	* tail_csv plugin: This new plugins allows to read metrics from CSV
+	  files, such as Snort's statistics file. Thanks to Kris Nielander for
+	  his patch.
+	* write_mongodb plugin: Authentication options have been added.
+	* write_riemann plugin: This new plugin allows sending metrics to
+	  Riemann, a stream processing and alerting tool. Big thanks to
+	  Pierre-Yves Ritschard for his work.
+
 2013-04-08, Version 5.2.2
 	* Build system: A bad interaction between the Java detection code and
 	  libltdl has been fixed. Thanks to Dave Cottlehuber for his patch.
 	  Installation of the Perl bindings has been improved / fixed. Thanks
 	  to Sebastian Harl for his patch.
 	* collectd: Fixed read callback scheduling at startup.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/configure	2013-04-09 09:14:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/configure	2013-04-10 23:41:42.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.67 for collectd 5.2.2.
+# Generated by GNU Autoconf 2.67 for collectd 5.3.0.
 #
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
 # Foundation, Inc.
 #
@@ -699,14 +699,14 @@
 MFLAGS=
 MAKEFLAGS=
 
 # Identity of this package.
 PACKAGE_NAME='collectd'
 PACKAGE_TARNAME='collectd'
-PACKAGE_VERSION='5.2.2'
-PACKAGE_STRING='collectd 5.2.2'
+PACKAGE_VERSION='5.3.0'
+PACKAGE_STRING='collectd 5.3.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
 ac_unique_file="src/collectd.c"
 # Factoring default headers for most tests.
 ac_includes_default="\
@@ -766,16 +766,18 @@
 LOAD_PLUGIN_LOGFILE
 LOAD_PLUGIN_SYSLOG
 BUILD_PLUGIN_ZFS_ARC_FALSE
 BUILD_PLUGIN_ZFS_ARC_TRUE
 BUILD_PLUGIN_XMMS_FALSE
 BUILD_PLUGIN_XMMS_TRUE
-BUILD_PLUGIN_WRITE_MONGODB_FALSE
-BUILD_PLUGIN_WRITE_MONGODB_TRUE
+BUILD_PLUGIN_WRITE_RIEMANN_FALSE
+BUILD_PLUGIN_WRITE_RIEMANN_TRUE
 BUILD_PLUGIN_WRITE_REDIS_FALSE
 BUILD_PLUGIN_WRITE_REDIS_TRUE
+BUILD_PLUGIN_WRITE_MONGODB_FALSE
+BUILD_PLUGIN_WRITE_MONGODB_TRUE
 BUILD_PLUGIN_WRITE_HTTP_FALSE
 BUILD_PLUGIN_WRITE_HTTP_TRUE
 BUILD_PLUGIN_WRITE_GRAPHITE_FALSE
 BUILD_PLUGIN_WRITE_GRAPHITE_TRUE
 BUILD_PLUGIN_WIRELESS_FALSE
 BUILD_PLUGIN_WIRELESS_TRUE
@@ -814,12 +816,14 @@
 BUILD_PLUGIN_TARGET_REPLACE_FALSE
 BUILD_PLUGIN_TARGET_REPLACE_TRUE
 BUILD_PLUGIN_TARGET_NOTIFICATION_FALSE
 BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE
 BUILD_PLUGIN_TAPE_FALSE
 BUILD_PLUGIN_TAPE_TRUE
+BUILD_PLUGIN_TAIL_CSV_FALSE
+BUILD_PLUGIN_TAIL_CSV_TRUE
 BUILD_PLUGIN_TAIL_FALSE
 BUILD_PLUGIN_TAIL_TRUE
 BUILD_PLUGIN_TABLE_FALSE
 BUILD_PLUGIN_TABLE_TRUE
 BUILD_PLUGIN_SYSLOG_FALSE
 BUILD_PLUGIN_SYSLOG_TRUE
@@ -1450,12 +1454,13 @@
 enable_serial
 enable_snmp
 enable_swap
 enable_syslog
 enable_table
 enable_tail
+enable_tail_csv
 enable_tape
 enable_target_notification
 enable_target_replace
 enable_target_scale
 enable_target_set
 enable_target_v5upgrade
@@ -1472,14 +1477,15 @@
 enable_varnish
 enable_vmem
 enable_vserver
 enable_wireless
 enable_write_graphite
 enable_write_http
-enable_write_redis
 enable_write_mongodb
+enable_write_redis
+enable_write_riemann
 enable_xmms
 enable_zfs_arc
 with_perl_bindings
 '
       ac_precious_vars='build_alias
 host_alias
@@ -2040,13 +2046,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures collectd 5.2.2 to adapt to many kinds of systems.
+\`configure' configures collectd 5.3.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -2110,13 +2116,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of collectd 5.2.2:";;
+     short | recursive ) echo "Configuration of collectd 5.3.0:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
@@ -2224,12 +2230,13 @@
   --enable-serial         serial port traffic
   --enable-snmp           SNMP querying plugin
   --enable-swap           Swap usage statistics
   --enable-syslog         Syslog logging plugin
   --enable-table          Parsing of tabular data
   --enable-tail           Parsing of logfiles
+  --enable-tail_csv       Parsing of CSV files
   --enable-tape           Tape drive statistics
   --enable-target_notification
                           The notification target
   --enable-target_replace The replace target
   --enable-target_scale   The scale target
   --enable-target_set     The set target
@@ -2248,14 +2255,15 @@
   --enable-varnish        Varnish cache statistics
   --enable-vmem           Virtual memory statistics
   --enable-vserver        Linux VServer statistics
   --enable-wireless       Wireless statistics
   --enable-write_graphite Graphite / Carbon output plugin
   --enable-write_http     HTTP output plugin
-  --enable-write_redis    Redis output plugin
   --enable-write_mongodb  MongoDB output plugin
+  --enable-write_redis    Redis output plugin
+  --enable-write_riemann  Riemann output plugin
   --enable-xmms           XMMS statistics
   --enable-zfs_arc        ZFS ARC statistics
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
@@ -2426,13 +2434,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-collectd configure 5.2.2
+collectd configure 5.3.0
 generated by GNU Autoconf 2.67
 
 Copyright (C) 2010 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -2948,13 +2956,13 @@
 
 } # ac_fn_c_check_member
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by collectd $as_me 5.2.2, which was
+It was created by collectd $as_me 5.3.0, which was
 generated by GNU Autoconf 2.67.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 exec 5>>config.log
@@ -4809,19 +4817,19 @@
 $as_echo_n "checking the name lister ($NM) interface... " >&6; }
 if test "${lt_cv_nm_interface+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   lt_cv_nm_interface="BSD nm"
   echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:4815: $ac_compile\"" >&5)
+  (eval echo "\"\$as_me:4823: $ac_compile\"" >&5)
   (eval "$ac_compile" 2>conftest.err)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:4818: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval echo "\"\$as_me:4826: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
   (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
   cat conftest.err >&5
-  (eval echo "\"\$as_me:4821: output\"" >&5)
+  (eval echo "\"\$as_me:4829: output\"" >&5)
   cat conftest.out >&5
   if $GREP 'External.*some_variable' conftest.out > /dev/null; then
     lt_cv_nm_interface="MS dumpbin"
   fi
   rm -f conftest*
 fi
@@ -6021,13 +6029,13 @@
     esac
   fi
   rm -rf conftest*
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 6027 "configure"' > conftest.$ac_ext
+  echo '#line 6035 "configure"' > conftest.$ac_ext
   if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; then
     if test "$lt_cv_prog_gnu_ld" = yes; then
@@ -7545,17 +7553,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7551: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7559: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7555: \$? = $ac_status" >&5
+   echo "$as_me:7563: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
      $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
      $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
      if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
@@ -7884,17 +7892,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7890: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7898: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7894: \$? = $ac_status" >&5
+   echo "$as_me:7902: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
      $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
      $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
      if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
@@ -7989,17 +7997,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7995: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8003: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:7999: \$? = $ac_status" >&5
+   echo "$as_me:8007: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
      $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
@@ -8044,17 +8052,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8050: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8058: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8054: \$? = $ac_status" >&5
+   echo "$as_me:8062: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
      $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
@@ -10428,13 +10436,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10434 "configure"
+#line 10442 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -10524,13 +10532,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self_static=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10530 "configure"
+#line 10538 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -11196,13 +11204,13 @@
 	  if test "$cross_compiling" = yes; then :
   libltdl_cv_need_uscore=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11202 "configure"
+#line 11210 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -12306,13 +12314,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='collectd'
- VERSION='5.2.2'
+ VERSION='5.3.0'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -14007,12 +14015,30 @@
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
+for ac_header in google/protobuf-c/protobuf-c.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "google/protobuf-c/protobuf-c.h" "ac_cv_header_google_protobuf_c_protobuf_c_h" "$ac_includes_default"
+if test "x$ac_cv_header_google_protobuf_c_protobuf_c_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GOOGLE_PROTOBUF_C_PROTOBUF_C_H 1
+_ACEOF
+ have_protobuf_c_h="yes"
+else
+  have_protobuf_c_h="no"
+fi
+
+done
+
+if test "x$have_protoc_c" = "xyes" && test "x$have_protobuf_c_h" != "xyes"
+then
+	have_protoc_c="no (unable to find <google/protobuf-c/protobuf-c.h>)"
+fi
  if test "x$have_protoc_c" = "xyes"; then
   HAVE_PROTOC_C_TRUE=
   HAVE_PROTOC_C_FALSE='#'
 else
   HAVE_PROTOC_C_TRUE='#'
   HAVE_PROTOC_C_FALSE=
@@ -14542,13 +14568,13 @@
 
 $as_echo "#define HAVE_STDBOOL_H 1" >>confdefs.h
 
 fi
 
 
-for ac_header in stdio.h errno.h math.h stdarg.h syslog.h fcntl.h signal.h assert.h sys/types.h sys/socket.h sys/select.h poll.h netdb.h arpa/inet.h sys/resource.h sys/param.h kstat.h regex.h sys/ioctl.h endian.h sys/isa_defs.h
+for ac_header in stdio.h errno.h math.h stdarg.h syslog.h fcntl.h signal.h assert.h sys/types.h sys/socket.h sys/select.h poll.h netdb.h arpa/inet.h sys/resource.h sys/param.h kstat.h regex.h sys/ioctl.h endian.h sys/isa_defs.h fnmatch.h libgen.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
 if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
@@ -14830,13 +14856,36 @@
 _ACEOF
 
 fi
 
 done
 
+	# For the battery plugin
+	for ac_header in IOKit/ps/IOPowerSources.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "IOKit/ps/IOPowerSources.h" "ac_cv_header_IOKit_ps_IOPowerSources_h" "
+#if HAVE_IOKIT_IOKITLIB_H
+#  include <IOKit/IOKitLib.h>
+#endif
+#if HAVE_IOKIT_IOTYPES_H
+#  include <IOKit/IOTypes.h>
+#endif
+
+"
+if test "x$ac_cv_header_IOKit_ps_IOPowerSources_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_IOKIT_PS_IOPOWERSOURCES_H 1
+_ACEOF
+
+fi
+
+done
+
+
 fi
+
 for ac_header in sys/sysctl.h
 do :
   ac_fn_c_check_header_compile "$LINENO" "sys/sysctl.h" "ac_cv_header_sys_sysctl_h" "
 #if HAVE_SYS_TYPES_H
 #  include <sys/types.h>
 #endif
@@ -14874,19 +14923,18 @@
 else
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 # For hddtemp module
-for ac_header in linux/major.h libgen.h
+for ac_header in linux/major.h
 do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  ac_fn_c_check_header_mongrel "$LINENO" "linux/major.h" "ac_cv_header_linux_major_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_major_h" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define HAVE_LINUX_MAJOR_H 1
 _ACEOF
 
 fi
 
 done
 
@@ -14914,34 +14962,12 @@
 done
 
 else
 	have_linux_raid_md_u_h="no"
 fi
 
-# For the battery plugin
-for ac_header in IOKit/ps/IOPowerSources.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "IOKit/ps/IOPowerSources.h" "ac_cv_header_IOKit_ps_IOPowerSources_h" "
-#if HAVE_IOKIT_IOKITLIB_H
-#  include <IOKit/IOKitLib.h>
-#endif
-#if HAVE_IOKIT_IOTYPES_H
-#  include <IOKit/IOTypes.h>
-#endif
-
-"
-if test "x$ac_cv_header_IOKit_ps_IOPowerSources_h" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_IOKIT_PS_IOPOWERSOURCES_H 1
-_ACEOF
-
-fi
-
-done
-
-
 # For the swap module
 have_linux_wireless_h="no"
 if test "x$ac_system" = "xLinux"
 then
   for ac_header in linux/wireless.h
 do :
@@ -19350,12 +19376,14 @@
     LIBGCRYPT_LIBS=""
     with_libgcrypt="no (version 1.2.0+ required)"
   fi
 
 
 
+		GCRYPT_CPPFLAGS="$LIBGCRYPT_CPPFLAGS $LIBGCRYPT_CFLAGS"
+		GCRYPT_LIBS="$LIBGCRYPT_LIBS"
 	fi
 fi
 
 CPPFLAGS="$SAVE_CPPFLAGS"
 LDFLAGS="$SAVE_LDFLAGS"
 
@@ -29936,12 +29964,72 @@
     enable_tail="$enable_plugin"
 
 
 
     enable_plugin="no"
     force="no"
+    # Check whether --enable-tail_csv was given.
+if test "${enable_tail_csv+set}" = set; then :
+  enableval=$enable_tail_csv;
+     if test "x$enableval" = "xyes"
+     then
+	     enable_plugin="yes"
+     else if test "x$enableval" = "xforce"
+     then
+	     enable_plugin="yes"
+	     force="yes"
+     else
+	     enable_plugin="no (disabled on command line)"
+     fi; fi
+
+else
+
+	 if test "x$enable_all_plugins" = "xauto"
+	 then
+	     if test "xyes" = "xyes"
+	     then
+		     enable_plugin="yes"
+	     else
+		     enable_plugin="no"
+	     fi
+	 else
+	     enable_plugin="$enable_all_plugins"
+	 fi
+
+fi
+
+    if test "x$enable_plugin" = "xyes"
+    then
+	    if test "xyes" = "xyes" || test "x$force" = "xyes"
+	    then
+
+$as_echo "#define HAVE_PLUGIN_TAIL_CSV 1" >>confdefs.h
+
+		    if test "xyes" != "xyes"
+		    then
+			    dependency_warning="yes"
+		    fi
+	    else # User passed "yes" but dependency checking yielded "no" => Dependency problem.
+		    dependency_error="yes"
+		    enable_plugin="no (dependency error)"
+	    fi
+    fi
+     if test "x$enable_plugin" = "xyes"; then
+  BUILD_PLUGIN_TAIL_CSV_TRUE=
+  BUILD_PLUGIN_TAIL_CSV_FALSE='#'
+else
+  BUILD_PLUGIN_TAIL_CSV_TRUE='#'
+  BUILD_PLUGIN_TAIL_CSV_FALSE=
+fi
+
+    enable_tail_csv="$enable_plugin"
+
+
+
+    enable_plugin="no"
+    force="no"
     # Check whether --enable-tape was given.
 if test "${enable_tape+set}" = set; then :
   enableval=$enable_tape;
      if test "x$enableval" = "xyes"
      then
 	     enable_plugin="yes"
@@ -31256,12 +31344,72 @@
     enable_write_http="$enable_plugin"
 
 
 
     enable_plugin="no"
     force="no"
+    # Check whether --enable-write_mongodb was given.
+if test "${enable_write_mongodb+set}" = set; then :
+  enableval=$enable_write_mongodb;
+     if test "x$enableval" = "xyes"
+     then
+	     enable_plugin="yes"
+     else if test "x$enableval" = "xforce"
+     then
+	     enable_plugin="yes"
+	     force="yes"
+     else
+	     enable_plugin="no (disabled on command line)"
+     fi; fi
+
+else
+
+	 if test "x$enable_all_plugins" = "xauto"
+	 then
+	     if test "x$with_libmongoc" = "xyes"
+	     then
+		     enable_plugin="yes"
+	     else
+		     enable_plugin="no"
+	     fi
+	 else
+	     enable_plugin="$enable_all_plugins"
+	 fi
+
+fi
+
+    if test "x$enable_plugin" = "xyes"
+    then
+	    if test "x$with_libmongoc" = "xyes" || test "x$force" = "xyes"
+	    then
+
+$as_echo "#define HAVE_PLUGIN_WRITE_MONGODB 1" >>confdefs.h
+
+		    if test "x$with_libmongoc" != "xyes"
+		    then
+			    dependency_warning="yes"
+		    fi
+	    else # User passed "yes" but dependency checking yielded "no" => Dependency problem.
+		    dependency_error="yes"
+		    enable_plugin="no (dependency error)"
+	    fi
+    fi
+     if test "x$enable_plugin" = "xyes"; then
+  BUILD_PLUGIN_WRITE_MONGODB_TRUE=
+  BUILD_PLUGIN_WRITE_MONGODB_FALSE='#'
+else
+  BUILD_PLUGIN_WRITE_MONGODB_TRUE='#'
+  BUILD_PLUGIN_WRITE_MONGODB_FALSE=
+fi
+
+    enable_write_mongodb="$enable_plugin"
+
+
+
+    enable_plugin="no"
+    force="no"
     # Check whether --enable-write_redis was given.
 if test "${enable_write_redis+set}" = set; then :
   enableval=$enable_write_redis;
      if test "x$enableval" = "xyes"
      then
 	     enable_plugin="yes"
@@ -31316,15 +31464,15 @@
     enable_write_redis="$enable_plugin"
 
 
 
     enable_plugin="no"
     force="no"
-    # Check whether --enable-write_mongodb was given.
-if test "${enable_write_mongodb+set}" = set; then :
-  enableval=$enable_write_mongodb;
+    # Check whether --enable-write_riemann was given.
+if test "${enable_write_riemann+set}" = set; then :
+  enableval=$enable_write_riemann;
      if test "x$enableval" = "xyes"
      then
 	     enable_plugin="yes"
      else if test "x$enableval" = "xforce"
      then
 	     enable_plugin="yes"
@@ -31334,13 +31482,13 @@
      fi; fi
 
 else
 
 	 if test "x$enable_all_plugins" = "xauto"
 	 then
-	     if test "x$with_libmongoc" = "xyes"
+	     if test "x$have_protoc_c" = "xyes"
 	     then
 		     enable_plugin="yes"
 	     else
 		     enable_plugin="no"
 	     fi
 	 else
@@ -31348,35 +31496,35 @@
 	 fi
 
 fi
 
     if test "x$enable_plugin" = "xyes"
     then
-	    if test "x$with_libmongoc" = "xyes" || test "x$force" = "xyes"
+	    if test "x$have_protoc_c" = "xyes" || test "x$force" = "xyes"
 	    then
 
-$as_echo "#define HAVE_PLUGIN_WRITE_MONGODB 1" >>confdefs.h
+$as_echo "#define HAVE_PLUGIN_WRITE_RIEMANN 1" >>confdefs.h
 
-		    if test "x$with_libmongoc" != "xyes"
+		    if test "x$have_protoc_c" != "xyes"
 		    then
 			    dependency_warning="yes"
 		    fi
 	    else # User passed "yes" but dependency checking yielded "no" => Dependency problem.
 		    dependency_error="yes"
 		    enable_plugin="no (dependency error)"
 	    fi
     fi
      if test "x$enable_plugin" = "xyes"; then
-  BUILD_PLUGIN_WRITE_MONGODB_TRUE=
-  BUILD_PLUGIN_WRITE_MONGODB_FALSE='#'
+  BUILD_PLUGIN_WRITE_RIEMANN_TRUE=
+  BUILD_PLUGIN_WRITE_RIEMANN_FALSE='#'
 else
-  BUILD_PLUGIN_WRITE_MONGODB_TRUE='#'
-  BUILD_PLUGIN_WRITE_MONGODB_FALSE=
+  BUILD_PLUGIN_WRITE_RIEMANN_TRUE='#'
+  BUILD_PLUGIN_WRITE_RIEMANN_FALSE=
 fi
 
-    enable_write_mongodb="$enable_plugin"
+    enable_write_riemann="$enable_plugin"
 
 
 
     enable_plugin="no"
     force="no"
     # Check whether --enable-xmms was given.
@@ -32319,12 +32467,16 @@
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_TAIL_TRUE}" && test -z "${BUILD_PLUGIN_TAIL_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_TAIL\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${BUILD_PLUGIN_TAIL_CSV_TRUE}" && test -z "${BUILD_PLUGIN_TAIL_CSV_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_PLUGIN_TAIL_CSV\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${BUILD_PLUGIN_TAPE_TRUE}" && test -z "${BUILD_PLUGIN_TAPE_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_TAPE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE}" && test -z "${BUILD_PLUGIN_TARGET_NOTIFICATION_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_TARGET_NOTIFICATION\" was never defined.
@@ -32407,18 +32559,22 @@
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_WRITE_HTTP_TRUE}" && test -z "${BUILD_PLUGIN_WRITE_HTTP_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_WRITE_HTTP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${BUILD_PLUGIN_WRITE_MONGODB_TRUE}" && test -z "${BUILD_PLUGIN_WRITE_MONGODB_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_PLUGIN_WRITE_MONGODB\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${BUILD_PLUGIN_WRITE_REDIS_TRUE}" && test -z "${BUILD_PLUGIN_WRITE_REDIS_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_WRITE_REDIS\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
-if test -z "${BUILD_PLUGIN_WRITE_MONGODB_TRUE}" && test -z "${BUILD_PLUGIN_WRITE_MONGODB_FALSE}"; then
-  as_fn_error $? "conditional \"BUILD_PLUGIN_WRITE_MONGODB\" was never defined.
+if test -z "${BUILD_PLUGIN_WRITE_RIEMANN_TRUE}" && test -z "${BUILD_PLUGIN_WRITE_RIEMANN_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_PLUGIN_WRITE_RIEMANN\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_XMMS_TRUE}" && test -z "${BUILD_PLUGIN_XMMS_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_XMMS\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
@@ -32831,13 +32987,13 @@
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # Save the log message, to keep $0 and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by collectd $as_me 5.2.2, which was
+This file was extended by collectd $as_me 5.3.0, which was
 generated by GNU Autoconf 2.67.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -32897,13 +33053,13 @@
 Report bugs to the package provider."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-collectd config.status 5.2.2
+collectd config.status 5.3.0
 configured by $0, generated by GNU Autoconf 2.67,
   with options \\"\$ac_cs_config\\"
 
 Copyright (C) 2010 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
@@ -34964,12 +35120,13 @@
     serial  . . . . . . . $enable_serial
     snmp  . . . . . . . . $enable_snmp
     swap  . . . . . . . . $enable_swap
     syslog  . . . . . . . $enable_syslog
     table . . . . . . . . $enable_table
     tail  . . . . . . . . $enable_tail
+    tail_csv  . . . . . . $enable_tail_csv
     tape  . . . . . . . . $enable_tape
     target_notification . $enable_target_notification
     target_replace  . . . $enable_target_replace
     target_scale  . . . . $enable_target_scale
     target_set  . . . . . $enable_target_set
     target_v5upgrade  . . $enable_target_v5upgrade
@@ -34986,14 +35143,15 @@
     varnish . . . . . . . $enable_varnish
     vmem  . . . . . . . . $enable_vmem
     vserver . . . . . . . $enable_vserver
     wireless  . . . . . . $enable_wireless
     write_graphite  . . . $enable_write_graphite
     write_http  . . . . . $enable_write_http
-    write_redis . . . . . $enable_write_redis
     write_mongodb . . . . $enable_write_mongodb
+    write_redis . . . . . $enable_write_redis
+    write_riemann . . . . $enable_write_riemann
     xmms  . . . . . . . . $enable_xmms
     zfs_arc . . . . . . . $enable_zfs_arc
 
 EOF
 
 if test "x$dependency_error" = "xyes"; then
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/configure.in	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/configure.in	2013-04-10 23:05:10.000000000 +0800
@@ -46,12 +46,19 @@
 AC_PROG_LIBTOOL
 AC_PROG_LEX
 AC_PROG_YACC
 PKG_PROG_PKG_CONFIG
 
 AC_CHECK_PROG([have_protoc_c], [protoc-c], [yes], [no])
+AC_CHECK_HEADERS([google/protobuf-c/protobuf-c.h],
+                 [have_protobuf_c_h="yes"],
+                 [have_protobuf_c_h="no"])
+if test "x$have_protoc_c" = "xyes" && test "x$have_protobuf_c_h" != "xyes"
+then
+	have_protoc_c="no (unable to find <google/protobuf-c/protobuf-c.h>)"
+fi
 AM_CONDITIONAL(HAVE_PROTOC_C, test "x$have_protoc_c" = "xyes")
 
 AC_MSG_CHECKING([for kernel type ($host_os)])
 case $host_os in
 	*linux*)
 	AC_DEFINE([KERNEL_LINUX], 1, [True if program is to be compiled for a Linux kernel])
@@ -125,13 +132,13 @@
 #
 AC_HEADER_STDC
 AC_HEADER_SYS_WAIT
 AC_HEADER_DIRENT
 AC_HEADER_STDBOOL
 
-AC_CHECK_HEADERS(stdio.h errno.h math.h stdarg.h syslog.h fcntl.h signal.h assert.h sys/types.h sys/socket.h sys/select.h poll.h netdb.h arpa/inet.h sys/resource.h sys/param.h kstat.h regex.h sys/ioctl.h endian.h sys/isa_defs.h)
+AC_CHECK_HEADERS(stdio.h errno.h math.h stdarg.h syslog.h fcntl.h signal.h assert.h sys/types.h sys/socket.h sys/select.h poll.h netdb.h arpa/inet.h sys/resource.h sys/param.h kstat.h regex.h sys/ioctl.h endian.h sys/isa_defs.h fnmatch.h libgen.h)
 
 # For ping library
 AC_CHECK_HEADERS(netinet/in_systm.h, [], [],
 [#if HAVE_STDINT_H
 # include <stdint.h>
 #endif
@@ -267,13 +274,25 @@
 # For cpu modules
 AC_CHECK_HEADERS(sys/dkstat.h)
 if test "x$ac_system" = "xDarwin"
 then
 	AC_CHECK_HEADERS(mach/mach_init.h mach/host_priv.h mach/mach_error.h mach/mach_host.h mach/mach_port.h mach/mach_types.h mach/message.h mach/processor_set.h mach/processor.h mach/processor_info.h mach/task.h mach/thread_act.h mach/vm_region.h mach/vm_map.h mach/vm_prot.h mach/vm_statistics.h mach/kern_return.h)
 	AC_CHECK_HEADERS(CoreFoundation/CoreFoundation.h IOKit/IOKitLib.h IOKit/IOTypes.h IOKit/ps/IOPSKeys.h IOKit/IOBSD.h IOKit/storage/IOBlockStorageDriver.h)
+	# For the battery plugin
+	AC_CHECK_HEADERS(IOKit/ps/IOPowerSources.h, [], [],
+[
+#if HAVE_IOKIT_IOKITLIB_H
+#  include <IOKit/IOKitLib.h>
+#endif
+#if HAVE_IOKIT_IOTYPES_H
+#  include <IOKit/IOTypes.h>
+#endif
+])
+
 fi
+
 AC_CHECK_HEADERS(sys/sysctl.h, [], [],
 [
 #if HAVE_SYS_TYPES_H
 #  include <sys/types.h>
 #endif
 #if HAVE_SYS_PARAM_H
@@ -295,13 +314,13 @@
 	fi
 else
 	AC_MSG_RESULT([no])
 fi
 
 # For hddtemp module
-AC_CHECK_HEADERS(linux/major.h libgen.h)
+AC_CHECK_HEADERS(linux/major.h)
 
 # For md module (Linux only)
 if test "x$ac_system" = "xLinux"
 then
 	AC_CHECK_HEADERS(linux/raid/md_u.h,
 			 [have_linux_raid_md_u_h="yes"],
@@ -312,23 +331,12 @@
 #include <linux/types.h>
 ])
 else
 	have_linux_raid_md_u_h="no"
 fi
 
-# For the battery plugin
-AC_CHECK_HEADERS(IOKit/ps/IOPowerSources.h, [], [],
-[
-#if HAVE_IOKIT_IOKITLIB_H
-#  include <IOKit/IOKitLib.h>
-#endif
-#if HAVE_IOKIT_IOTYPES_H
-#  include <IOKit/IOTypes.h>
-#endif
-])
-
 # For the swap module
 have_linux_wireless_h="no"
 if test "x$ac_system" = "xLinux"
 then
   AC_CHECK_HEADERS(linux/wireless.h,
 		   [have_linux_wireless_h="yes"],
@@ -1833,12 +1841,14 @@
 	AC_CHECK_LIB(gcrypt, gcry_md_hash_buffer,
 		[with_libgcrypt="yes"],
 		[with_libgcrypt="no (symbol gcry_md_hash_buffer not found)"])
 
 	if test "$with_libgcrypt" != "no"; then
 		AM_PATH_LIBGCRYPT(1:1.2.0,,with_libgcrypt="no (version 1.2.0+ required)")
+		GCRYPT_CPPFLAGS="$LIBGCRYPT_CPPFLAGS $LIBGCRYPT_CFLAGS"
+		GCRYPT_LIBS="$LIBGCRYPT_LIBS"
 	fi
 fi
 
 CPPFLAGS="$SAVE_CPPFLAGS"
 LDFLAGS="$SAVE_LDFLAGS"
 
@@ -4961,12 +4971,13 @@
 AC_PLUGIN([serial],      [$plugin_serial],     [serial port traffic])
 AC_PLUGIN([snmp],        [$with_libnetsnmp],   [SNMP querying plugin])
 AC_PLUGIN([swap],        [$plugin_swap],       [Swap usage statistics])
 AC_PLUGIN([syslog],      [$have_syslog],       [Syslog logging plugin])
 AC_PLUGIN([table],       [yes],                [Parsing of tabular data])
 AC_PLUGIN([tail],        [yes],                [Parsing of logfiles])
+AC_PLUGIN([tail_csv],    [yes],                [Parsing of CSV files])
 AC_PLUGIN([tape],        [$plugin_tape],       [Tape drive statistics])
 AC_PLUGIN([target_notification], [yes],        [The notification target])
 AC_PLUGIN([target_replace], [yes],             [The replace target])
 AC_PLUGIN([target_scale],[yes],                [The scale target])
 AC_PLUGIN([target_set],  [yes],                [The set target])
 AC_PLUGIN([target_v5upgrade], [yes],           [The v5upgrade target])
@@ -4983,14 +4994,15 @@
 AC_PLUGIN([varnish],     [$with_libvarnish],   [Varnish cache statistics])
 AC_PLUGIN([vmem],        [$plugin_vmem],       [Virtual memory statistics])
 AC_PLUGIN([vserver],     [$plugin_vserver],    [Linux VServer statistics])
 AC_PLUGIN([wireless],    [$plugin_wireless],   [Wireless statistics])
 AC_PLUGIN([write_graphite], [yes],             [Graphite / Carbon output plugin])
 AC_PLUGIN([write_http],  [$with_libcurl],      [HTTP output plugin])
-AC_PLUGIN([write_redis], [$with_libcredis],    [Redis output plugin])
 AC_PLUGIN([write_mongodb], [$with_libmongoc],  [MongoDB output plugin])
+AC_PLUGIN([write_redis], [$with_libcredis],    [Redis output plugin])
+AC_PLUGIN([write_riemann], [$have_protoc_c],   [Riemann output plugin])
 AC_PLUGIN([xmms],        [$with_libxmms],      [XMMS statistics])
 AC_PLUGIN([zfs_arc],     [$plugin_zfs_arc],    [ZFS ARC statistics])
 
 dnl Default configuration file
 # Load either syslog or logfile
 LOAD_PLUGIN_SYSLOG=""
@@ -5293,12 +5305,13 @@
     serial  . . . . . . . $enable_serial
     snmp  . . . . . . . . $enable_snmp
     swap  . . . . . . . . $enable_swap
     syslog  . . . . . . . $enable_syslog
     table . . . . . . . . $enable_table
     tail  . . . . . . . . $enable_tail
+    tail_csv  . . . . . . $enable_tail_csv
     tape  . . . . . . . . $enable_tape
     target_notification . $enable_target_notification
     target_replace  . . . $enable_target_replace
     target_scale  . . . . $enable_target_scale
     target_set  . . . . . $enable_target_set
     target_v5upgrade  . . $enable_target_v5upgrade
@@ -5315,14 +5328,15 @@
     varnish . . . . . . . $enable_varnish
     vmem  . . . . . . . . $enable_vmem
     vserver . . . . . . . $enable_vserver
     wireless  . . . . . . $enable_wireless
     write_graphite  . . . $enable_write_graphite
     write_http  . . . . . $enable_write_http
-    write_redis . . . . . $enable_write_redis
     write_mongodb . . . . $enable_write_mongodb
+    write_redis . . . . . $enable_write_redis
+    write_riemann . . . . $enable_write_riemann
     xmms  . . . . . . . . $enable_xmms
     zfs_arc . . . . . . . $enable_zfs_arc
 
 EOF
 
 if test "x$dependency_error" = "xyes"; then
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/contrib/redhat/collectd.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/contrib/redhat/collectd.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/contrib/redhat/collectd.spec	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/contrib/redhat/collectd.spec	2013-04-10 23:05:10.000000000 +0800
@@ -68,12 +68,13 @@
 %define with_serial 0%{!?_without_serial:1}
 %define with_snmp 0%{!?_without_snmp:1}
 %define with_swap 0%{!?_without_swap:1}
 %define with_syslog 0%{!?_without_syslog:1}
 %define with_table 0%{!?_without_table:1}
 %define with_tail 0%{!?_without_tail:1}
+%define with_tail_csv 0%{!?_without_tail_csv:1}
 %define with_tcpconns 0%{!?_without_tcpconns:1}
 %define with_teamspeak2 0%{!?_without_teamspeak2:1}
 %define with_ted 0%{!?_without_ted:1}
 %define with_thermal 0%{!?_without_thermal:1}
 %define with_threshold 0%{!?_without_threshold:1}
 %define with_unixsock 0%{!?_without_unixsock:1}
@@ -83,12 +84,13 @@
 %define with_varnish 0%{!?_without_varnish:1}
 %define with_vmem 0%{!?_without_vmem:1}
 %define with_vserver 0%{!?_without_vserver:1}
 %define with_wireless 0%{!?_without_wireless:1}
 %define with_write_graphite 0%{!?_without_write_graphite:1}
 %define with_write_http 0%{!?_without_write_http:1}
+%define with_write_riemann 0%{!?_without_write_riemann:1}
 
 # disabled plugins
 %define with_apple_sensors 0%{!?_without_apple_sensors:0}
 %define with_lpar 0%{!?_without_lpar:0}
 %define with_modbus 0%{!?_without_modbus:0}
 %define with_netapp 0%{!?_without_netapp:0}
@@ -105,16 +107,16 @@
 %define with_write_redis 0%{!?_without_write_redis:0}
 %define with_xmms 0%{!?_without_xmms:0}
 %define with_zfs_arc 0%{!?_without_zfs_arc:0}
 
 Summary:	Statistics collection daemon for filling RRD files
 Name:		collectd
-Version:	5.2.0
-Release:	3%{?dist}
+Version:	5.3.0
+Release:	1%{?dist}
 URL:		http://collectd.org
-Source:		http://collectd.org/files/%{name}-%{version}.tar.gz
+Source:		http://collectd.org/files/%{name}-%{version}.tar.bz2
 License:	GPLv2
 Group:		System Environment/Daemons
 BuildRoot:	%{_tmppath}/%{name}-%{version}-root
 BuildRequires:	libgcrypt-devel
 Vendor:		collectd development team <collectd@verplant.org>
 
@@ -506,12 +508,22 @@
 Requires:	%{name}%{?_isa} = %{version}-%{release}
 BuildRequires:	credis-devel
 %description write_redis
 The Write Redis plugin stores values in Redis, a “data structures server”.
 %endif
 
+%if %{with_write_riemann}
+%package write_riemann
+Summary:	riemann plugin for collectd
+Group:		System Environment/Daemons
+Requires:	%{name}%{?_isa} = %{version}-%{release}
+BuildRequires:	protobuf-c-devel
+%description write_riemann
+The riemann plugin submits values to Riemann, an event stream processor.
+%endif
+
 %package collection3
 Summary:	Web-based viewer for collectd
 Group:		System Environment/Daemons
 Requires:	%{name}%{?_isa} = %{version}-%{release}
 Requires: httpd
 %description collection3
@@ -1038,12 +1049,18 @@
 %if %{with_tail}
 %define _with_tail --enable-tail
 %else
 %define _with_tail --disable-tail
 %endif
 
+%if %{with_tail_csv}
+%define _with_tail_csv --enable-tail_csv
+%else
+%define _with_tail_csv --disable-tail_csv
+%endif
+
 %if %{with_tape}
 %define _with_tape --enable-tape
 %else
 %define _with_tape --disable-tape
 %endif
 
@@ -1152,12 +1169,18 @@
 %if %{with_write_redis}
 %define _with_write_redis --enable-write_redis
 %else
 %define _with_write_redis --disable-write_redis --without-libcredis
 %endif
 
+%if %{with_write_riemann}
+%define _with_write_riemann --enable-write_riemann
+%else
+%define _with_write_riemann --disable-write_riemann
+%endif
+
 %if %{with_xmms}
 %define _with_xmms --enable-xmms
 %else
 %define _with_xmms --disable-xmms
 %endif
 
@@ -1268,12 +1291,13 @@
 	%{?_with_protocols} \
 	%{?_with_serial} \
 	%{?_with_swap} \
 	%{?_with_syslog} \
 	%{?_with_table} \
 	%{?_with_tail} \
+	%{?_with_tail_csv} \
 	%{?_with_tcpconns} \
 	%{?_with_teamspeak2} \
 	%{?_with_ted} \
 	%{?_with_thermal} \
 	%{?_with_threshold} \
 	%{?_with_unixsock} \
@@ -1281,13 +1305,14 @@
 	%{?_with_users} \
 	%{?_with_uuid} \
 	%{?_with_vmem} \
 	%{?_with_vserver} \
 	%{?_with_wireless}\
 	%{?_with_write_graphite} \
-	%{?_with_write_http}
+	%{?_with_write_http} \
+	%{?_with_write_riemann}
 
 
 %{__make} %{?_smp_mflags}
 
 
 %install
@@ -1372,12 +1397,13 @@
 %{_datadir}/collectd/
 %{_sharedstatedir}/collectd
 %{_mandir}/man1/collectd-nagios.1*
 %{_mandir}/man1/collectd.1*
 %{_mandir}/man1/collectdctl.1*
 %{_mandir}/man1/collectdmon.1*
+%{_mandir}/man1/collectd-tg.1*
 %{_mandir}/man5/collectd-email.5*
 %{_mandir}/man5/collectd-exec.5*
 %{_mandir}/man5/collectd-threshold.5*
 %{_mandir}/man5/collectd-unixsock.5*
 %{_mandir}/man5/collectd.conf.5*
 %{_mandir}/man5/types.db.5*
@@ -1511,12 +1537,15 @@
 %if %{with_table}
 %{_libdir}/%{name}/table.so
 %endif
 %if %{with_tail}
 %{_libdir}/%{name}/tail.so
 %endif
+%if %{with_tail_csv}
+%{_libdir}/%{name}/tail_csv.so
+%endif
 %if %{with_tcpconns}
 %{_libdir}/%{name}/tcpconns.so
 %endif
 %if %{with_teamspeak2}
 %{_libdir}/%{name}/teamspeak2.so
 %endif
@@ -1764,24 +1793,35 @@
 
 %if %{with_write_redis}
 %files write_redis
 %{_libdir}/%{name}/write_redis.so
 %endif
 
+%if %{with_write_riemann}
+%files write_riemann
+%{_libdir}/%{name}/write_riemann.so
+%endif
+
 %files collection3
 %{_localstatedir}/www/collection3
 %{_sysconfdir}/httpd/conf.d/collection3.conf
 
 %files php-collection
 %{_localstatedir}/www/php-collection
 %{_sysconfdir}/httpd/conf.d/php-collection.conf
 
 %files contrib
 %doc contrib/
 
 %changelog
+* Wed Apr 10 2013 Marc Fournier <marc.fournier@camptocamp.com> 5.3.0-1
+- New upstream version
+- Enabled write_riemann plugin
+- Enabled tail_csv plugin
+- Installed collectd-tc manpage
+
 * Thu Jan 11 2013 Marc Fournier <marc.fournier@camptocamp.com> 5.2.0-3
 - remove dependency on libstatgrab, which isn't required on linux
 
 * Thu Jan 03 2013 Marc Fournier <marc.fournier@camptocamp.com> 5.2.0-2
 - collection3 and php-collection viewers are now in separate packages
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/README	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/README	2013-04-10 10:14:19.000000000 +0800
@@ -130,13 +130,13 @@
 
     - lpar
       Detailed CPU statistics of the “Logical Partitions” virtualization
       technique built into IBM's POWER processors.
 
     - libvirt
-      CPU, disk and network I/O statistics from virtual machines.
+      CPU, memory, disk and network I/O statistics from virtual machines.
 
     - madwifi
       Queries very detailed usage statistics from wireless LAN adapters and
       interfaces that use the Atheros chipset and the MadWifi driver.
 
     - mbmon
@@ -281,12 +281,16 @@
       Parse table-like structured files.
 
     - tail
       Follows (tails) logfiles, parses them by lines and submits matched
       values.
 
+    - tail_csv
+      Follows (tails) files in CSV format, parses each line and submits
+      extracted values.
+
     - tape
       Bytes and operations read and written on tape devices. Solaris only.
 
     - tcpconns
       Number of TCP connections to specific local and remote ports.
 
@@ -376,15 +380,21 @@
 
     - write_http
       Sends the values collected by collectd to a web-server using HTTP POST
       requests. The transmitted data is either in a form understood by the
       Exec plugin or formatted in JSON.
 
+    - write_mongodb
+      Sends data to MongoDB, a NoSQL database.
+
     - write_redis
       Sends the values to a Redis key-value database server.
 
+    - write_riemann
+      Sends data to Riemann, a stream processing and monitoring system.
+
   * Logging is, as everything in collectd, provided by plugins. The following
     plugins keep up informed about what's going on:
 
     - logfile
       Writes logmessages to a file or STDOUT/STDERR.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/aggregation.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/aggregation.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/aggregation.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/aggregation.c	2013-04-09 23:18:59.000000000 +0800
@@ -22,24 +22,37 @@
  *
  * Authors:
  *   Florian Forster <octo at collectd.org>
  **/
 
 #include "collectd.h"
+
+#include <pthread.h>
+
 #include "plugin.h"
 #include "common.h"
 #include "configfile.h"
 #include "meta_data.h"
 #include "utils_cache.h" /* for uc_get_rate() */
+#include "utils_subst.h"
 #include "utils_vl_lookup.h"
 
-#include <pthread.h>
+#define AGG_MATCHES_ALL(str) (strcmp ("/.*/", str) == 0)
+#define AGG_FUNC_PLACEHOLDER "%{aggregation}"
 
 struct aggregation_s /* {{{ */
 {
   identifier_t ident;
+  unsigned int group_by;
+
+  unsigned int regex_fields;
+
+  char *set_host;
+  char *set_plugin;
+  char *set_plugin_instance;
+  char *set_type_instance;
 
   _Bool calc_num;
   _Bool calc_sum;
   _Bool calc_average;
   _Bool calc_min;
   _Bool calc_max;
@@ -75,12 +88,29 @@
 
 static lookup_t *lookup = NULL;
 
 static pthread_mutex_t agg_instance_list_lock = PTHREAD_MUTEX_INITIALIZER;
 static agg_instance_t *agg_instance_list_head = NULL;
 
+static _Bool agg_is_regex (char const *str) /* {{{ */
+{
+  size_t len;
+
+  if (str == NULL)
+    return (0);
+
+  len = strlen (str);
+  if (len < 3)
+    return (0);
+
+  if ((str[0] == '/') && (str[len - 1] == '/'))
+    return (1);
+  else
+    return (0);
+} /* }}} _Bool agg_is_regex */
+
 static void agg_destroy (aggregation_t *agg) /* {{{ */
 {
   sfree (agg);
 } /* }}} void agg_destroy */
 
 /* Frees all dynamically allocated memory within the instance. */
@@ -113,12 +143,98 @@
   memset (inst, 0, sizeof (*inst));
   inst->ds_type = -1;
   inst->min = NAN;
   inst->max = NAN;
 } /* }}} void agg_instance_destroy */
 
+static int agg_instance_create_name (agg_instance_t *inst, /* {{{ */
+    value_list_t const *vl, aggregation_t const *agg)
+{
+#define COPY_FIELD(buffer, buffer_size, field, group_mask, all_value) do { \
+  if (agg->set_ ## field != NULL) \
+    sstrncpy (buffer, agg->set_ ## field, buffer_size); \
+  else if ((agg->regex_fields & group_mask) \
+      && (agg->group_by & group_mask)) \
+    sstrncpy (buffer, vl->field, buffer_size); \
+  else if ((agg->regex_fields & group_mask) \
+      && (AGG_MATCHES_ALL (agg->ident.field))) \
+    sstrncpy (buffer, all_value, buffer_size); \
+  else \
+    sstrncpy (buffer, agg->ident.field, buffer_size); \
+} while (0)
+
+  /* Host */
+  COPY_FIELD (inst->ident.host, sizeof (inst->ident.host),
+      host, LU_GROUP_BY_HOST, "global");
+
+  /* Plugin */
+  if (agg->set_plugin != NULL)
+    sstrncpy (inst->ident.plugin, agg->set_plugin,
+        sizeof (inst->ident.plugin));
+  else
+    sstrncpy (inst->ident.plugin, "aggregation", sizeof (inst->ident.plugin));
+
+  /* Plugin instance */
+  if (agg->set_plugin_instance != NULL)
+    sstrncpy (inst->ident.plugin_instance, agg->set_plugin_instance,
+        sizeof (inst->ident.plugin_instance));
+  else
+  {
+    char tmp_plugin[DATA_MAX_NAME_LEN];
+    char tmp_plugin_instance[DATA_MAX_NAME_LEN] = "";
+
+    if ((agg->regex_fields & LU_GROUP_BY_PLUGIN)
+        && (agg->group_by & LU_GROUP_BY_PLUGIN))
+      sstrncpy (tmp_plugin, vl->plugin, sizeof (tmp_plugin));
+    else if ((agg->regex_fields & LU_GROUP_BY_PLUGIN)
+        && (AGG_MATCHES_ALL (agg->ident.plugin)))
+      sstrncpy (tmp_plugin, "", sizeof (tmp_plugin));
+    else
+      sstrncpy (tmp_plugin, agg->ident.plugin, sizeof (tmp_plugin));
+
+    if ((agg->regex_fields & LU_GROUP_BY_PLUGIN_INSTANCE)
+        && (agg->group_by & LU_GROUP_BY_PLUGIN_INSTANCE))
+      sstrncpy (tmp_plugin_instance, vl->plugin_instance,
+          sizeof (tmp_plugin_instance));
+    else if ((agg->regex_fields & LU_GROUP_BY_PLUGIN_INSTANCE)
+        && (AGG_MATCHES_ALL (agg->ident.plugin_instance)))
+      sstrncpy (tmp_plugin_instance, "", sizeof (tmp_plugin_instance));
+    else
+      sstrncpy (tmp_plugin_instance, agg->ident.plugin_instance,
+          sizeof (tmp_plugin_instance));
+
+    if ((strcmp ("", tmp_plugin) == 0)
+        && (strcmp ("", tmp_plugin_instance) == 0))
+      sstrncpy (inst->ident.plugin_instance, AGG_FUNC_PLACEHOLDER,
+          sizeof (inst->ident.plugin_instance));
+    else if (strcmp ("", tmp_plugin) != 0)
+      ssnprintf (inst->ident.plugin_instance,
+          sizeof (inst->ident.plugin_instance),
+          "%s-%s", tmp_plugin, AGG_FUNC_PLACEHOLDER);
+    else if (strcmp ("", tmp_plugin_instance) != 0)
+      ssnprintf (inst->ident.plugin_instance,
+          sizeof (inst->ident.plugin_instance),
+          "%s-%s", tmp_plugin_instance, AGG_FUNC_PLACEHOLDER);
+    else
+      ssnprintf (inst->ident.plugin_instance,
+          sizeof (inst->ident.plugin_instance),
+          "%s-%s-%s", tmp_plugin, tmp_plugin_instance, AGG_FUNC_PLACEHOLDER);
+  }
+
+  /* Type */
+  sstrncpy (inst->ident.type, agg->ident.type, sizeof (inst->ident.type));
+
+  /* Type instance */
+  COPY_FIELD (inst->ident.type_instance, sizeof (inst->ident.type_instance),
+      type_instance, LU_GROUP_BY_TYPE_INSTANCE, "");
+
+#undef COPY_FIELD
+
+  return (0);
+} /* }}} int agg_instance_create_name */
+
 /* Create a new aggregation instance. */
 static agg_instance_t *agg_instance_create (data_set_t const *ds, /* {{{ */
     value_list_t const *vl, aggregation_t *agg)
 {
   agg_instance_t *inst;
 
@@ -132,25 +248,13 @@
   }
   memset (inst, 0, sizeof (*inst));
   pthread_mutex_init (&inst->lock, /* attr = */ NULL);
 
   inst->ds_type = ds->ds[0].type;
 
-#define COPY_FIELD(fld) do { \
-  sstrncpy (inst->ident.fld, \
-      LU_IS_ANY (agg->ident.fld) ? vl->fld : agg->ident.fld, \
-      sizeof (inst->ident.fld)); \
-} while (0)
-
-  COPY_FIELD (host);
-  COPY_FIELD (plugin);
-  COPY_FIELD (plugin_instance);
-  COPY_FIELD (type);
-  COPY_FIELD (type_instance);
-
-#undef COPY_FIELD
+  agg_instance_create_name (inst, vl, agg);
 
   inst->min = NAN;
   inst->max = NAN;
 
 #define INIT_STATE(field) do { \
   inst->state_ ## field = NULL; \
@@ -237,14 +341,14 @@
   value_list_t *vl, char const *pi_prefix, cdtime_t t)
 {
   value_t v;
   int status;
 
   if (pi_prefix[0] != 0)
-    ssnprintf (vl->plugin_instance, sizeof (vl->plugin_instance), "%s-%s",
-        pi_prefix, func);
+    subst_string (vl->plugin_instance, sizeof (vl->plugin_instance),
+        pi_prefix, AGG_FUNC_PLACEHOLDER, func);
   else
     sstrncpy (vl->plugin_instance, func, sizeof (vl->plugin_instance));
 
   memset (&v, 0, sizeof (v));
   status = rate_to_value (&v, rate, state, inst->ds_type, t);
   if (status != 0)
@@ -260,24 +364,23 @@
     return (-1);
   }
 
   vl->values = &v;
   vl->values_len = 1;
 
-  plugin_dispatch_values_secure (vl);
+  plugin_dispatch_values (vl);
 
   vl->values = NULL;
   vl->values_len = 0;
 
   return (0);
 } /* }}} int agg_instance_read_func */
 
 static int agg_instance_read (agg_instance_t *inst, cdtime_t t) /* {{{ */
 {
   value_list_t vl = VALUE_LIST_INIT;
-  char pi_prefix[DATA_MAX_NAME_LEN];
 
   /* Pre-set all the fields in the value list that will not change per
    * aggregation type (sum, average, ...). The struct will be re-used and must
    * therefore be dispatched using the "secure" function. */
 
   vl.time = t;
@@ -288,45 +391,22 @@
   {
     ERROR ("aggregation plugin: meta_data_create failed.");
     return (-1);
   }
   meta_data_add_boolean (vl.meta, "aggregation:created", 1);
 
-  if (LU_IS_ALL (inst->ident.host))
-    sstrncpy (vl.host, "global", sizeof (vl.host));
-  else
-    sstrncpy (vl.host, inst->ident.host, sizeof (vl.host));
-
-  sstrncpy (vl.plugin, "aggregation", sizeof (vl.plugin));
-
-  if (LU_IS_ALL (inst->ident.plugin))
-  {
-    if (LU_IS_ALL (inst->ident.plugin_instance))
-      sstrncpy (pi_prefix, "", sizeof (pi_prefix));
-    else
-      sstrncpy (pi_prefix, inst->ident.plugin_instance, sizeof (pi_prefix));
-  }
-  else
-  {
-    if (LU_IS_ALL (inst->ident.plugin_instance))
-      sstrncpy (pi_prefix, inst->ident.plugin, sizeof (pi_prefix));
-    else
-      ssnprintf (pi_prefix, sizeof (pi_prefix),
-          "%s-%s", inst->ident.plugin, inst->ident.plugin_instance);
-  }
-
+  sstrncpy (vl.host, inst->ident.host, sizeof (vl.host));
+  sstrncpy (vl.plugin, inst->ident.plugin, sizeof (vl.plugin));
   sstrncpy (vl.type, inst->ident.type, sizeof (vl.type));
-
-  if (!LU_IS_ALL (inst->ident.type_instance))
-    sstrncpy (vl.type_instance, inst->ident.type_instance,
-        sizeof (vl.type_instance));
+  sstrncpy (vl.type_instance, inst->ident.type_instance,
+      sizeof (vl.type_instance));
 
 #define READ_FUNC(func, rate) do { \
   if (inst->state_ ## func != NULL) { \
     agg_instance_read_func (inst, #func, rate, \
-        inst->state_ ## func, &vl, pi_prefix, t); \
+        inst->state_ ## func, &vl, inst->ident.plugin_instance, t); \
   } \
 } while (0)
 
   pthread_mutex_lock (&inst->lock);
 
   READ_FUNC (num, (gauge_t) inst->num);
@@ -421,20 +501,19 @@
       continue;
     }
 
     value = ci->values[i].value.string;
 
     if (strcasecmp ("Host", value) == 0)
-      sstrncpy (agg->ident.host, LU_ANY, sizeof (agg->ident.host));
+      agg->group_by |= LU_GROUP_BY_HOST;
     else if (strcasecmp ("Plugin", value) == 0)
-      sstrncpy (agg->ident.plugin, LU_ANY, sizeof (agg->ident.plugin));
+      agg->group_by |= LU_GROUP_BY_PLUGIN;
     else if (strcasecmp ("PluginInstance", value) == 0)
-      sstrncpy (agg->ident.plugin_instance, LU_ANY,
-          sizeof (agg->ident.plugin_instance));
+      agg->group_by |= LU_GROUP_BY_PLUGIN_INSTANCE;
     else if (strcasecmp ("TypeInstance", value) == 0)
-      sstrncpy (agg->ident.type_instance, LU_ANY, sizeof (agg->ident.type_instance));
+      agg->group_by |= LU_GROUP_BY_TYPE_INSTANCE;
     else if (strcasecmp ("Type", value) == 0)
       ERROR ("aggregation plugin: Grouping by type is not supported.");
     else
       WARNING ("aggregation plugin: The \"%s\" argument to the \"GroupBy\" "
           "option is invalid and will be ignored.", value);
   } /* for (ci->values) */
@@ -454,18 +533,18 @@
   {
     ERROR ("aggregation plugin: malloc failed.");
     return (-1);
   }
   memset (agg, 0, sizeof (*agg));
 
-  sstrncpy (agg->ident.host, LU_ALL, sizeof (agg->ident.host));
-  sstrncpy (agg->ident.plugin, LU_ALL, sizeof (agg->ident.plugin));
-  sstrncpy (agg->ident.plugin_instance, LU_ALL,
+  sstrncpy (agg->ident.host, "/.*/", sizeof (agg->ident.host));
+  sstrncpy (agg->ident.plugin, "/.*/", sizeof (agg->ident.plugin));
+  sstrncpy (agg->ident.plugin_instance, "/.*/",
       sizeof (agg->ident.plugin_instance));
-  sstrncpy (agg->ident.type, LU_ALL, sizeof (agg->ident.type));
-  sstrncpy (agg->ident.type_instance, LU_ALL,
+  sstrncpy (agg->ident.type, "/.*/", sizeof (agg->ident.type));
+  sstrncpy (agg->ident.type_instance, "/.*/",
       sizeof (agg->ident.type_instance));
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *child = ci->children + i;
 
@@ -481,12 +560,20 @@
     else if (strcasecmp ("Type", child->key) == 0)
       cf_util_get_string_buffer (child, agg->ident.type,
           sizeof (agg->ident.type));
     else if (strcasecmp ("TypeInstance", child->key) == 0)
       cf_util_get_string_buffer (child, agg->ident.type_instance,
           sizeof (agg->ident.type_instance));
+    else if (strcasecmp ("SetHost", child->key) == 0)
+      cf_util_get_string (child, &agg->set_host);
+    else if (strcasecmp ("SetPlugin", child->key) == 0)
+      cf_util_get_string (child, &agg->set_plugin);
+    else if (strcasecmp ("SetPluginInstance", child->key) == 0)
+      cf_util_get_string (child, &agg->set_plugin_instance);
+    else if (strcasecmp ("SetTypeInstance", child->key) == 0)
+      cf_util_get_string (child, &agg->set_type_instance);
     else if (strcasecmp ("GroupBy", child->key) == 0)
       agg_config_handle_group_by (child, agg);
     else if (strcasecmp ("CalculateNum", child->key) == 0)
       cf_util_get_boolean (child, &agg->calc_num);
     else if (strcasecmp ("CalculateSum", child->key) == 0)
       cf_util_get_boolean (child, &agg->calc_sum);
@@ -500,41 +587,61 @@
       cf_util_get_boolean (child, &agg->calc_stddev);
     else
       WARNING ("aggregation plugin: The \"%s\" key is not allowed inside "
           "<Aggregation /> blocks and will be ignored.", child->key);
   }
 
+  if (agg_is_regex (agg->ident.host))
+    agg->regex_fields |= LU_GROUP_BY_HOST;
+  if (agg_is_regex (agg->ident.plugin))
+    agg->regex_fields |= LU_GROUP_BY_PLUGIN;
+  if (agg_is_regex (agg->ident.plugin_instance))
+    agg->regex_fields |= LU_GROUP_BY_PLUGIN_INSTANCE;
+  if (agg_is_regex (agg->ident.type_instance))
+    agg->regex_fields |= LU_GROUP_BY_TYPE_INSTANCE;
+
   /* Sanity checking */
   is_valid = 1;
-  if (LU_IS_ALL (agg->ident.type)) /* {{{ */
+  if (strcmp ("/.*/", agg->ident.type) == 0) /* {{{ */
   {
     ERROR ("aggregation plugin: It appears you did not specify the required "
         "\"Type\" option in this aggregation. "
         "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
         "Type \"%s\", TypeInstance \"%s\")",
         agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
         agg->ident.type, agg->ident.type_instance);
     is_valid = 0;
   }
   else if (strchr (agg->ident.type, '/') != NULL)
   {
     ERROR ("aggregation plugin: The \"Type\" may not contain the '/' "
-        "character. Especially, it may not be a wildcard. The current "
+        "character. Especially, it may not be a regex. The current "
         "value is \"%s\".", agg->ident.type);
     is_valid = 0;
   } /* }}} */
 
-  if (!LU_IS_ALL (agg->ident.host) /* {{{ */
-      && !LU_IS_ALL (agg->ident.plugin)
-      && !LU_IS_ALL (agg->ident.plugin_instance)
-      && !LU_IS_ALL (agg->ident.type_instance))
+  /* Check that there is at least one regex field without a grouping. {{{ */
+  if ((agg->regex_fields & ~agg->group_by) == 0)
   {
     ERROR ("aggregation plugin: An aggregation must contain at least one "
         "wildcard. This is achieved by leaving at least one of the \"Host\", "
         "\"Plugin\", \"PluginInstance\" and \"TypeInstance\" options blank "
-        "and not grouping by that field. "
+        "or using a regular expression and not grouping by that field. "
+        "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
+        "Type \"%s\", TypeInstance \"%s\")",
+        agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
+        agg->ident.type, agg->ident.type_instance);
+    is_valid = 0;
+  } /* }}} */
+
+  /* Check that all grouping fields are regular expressions. {{{ */
+  if (agg->group_by & ~agg->regex_fields)
+  {
+    ERROR ("aggregation plugin: Only wildcard fields (fields for which a "
+        "regular expression is configured or which are left blank) can be "
+        "specified in the \"GroupBy\" option. "
         "(Host \"%s\", Plugin \"%s\", PluginInstance \"%s\", "
         "Type \"%s\", TypeInstance \"%s\")",
         agg->ident.host, agg->ident.plugin, agg->ident.plugin_instance,
         agg->ident.type, agg->ident.type_instance);
     is_valid = 0;
   } /* }}} */
@@ -554,13 +661,13 @@
   if (!is_valid) /* {{{ */
   {
     sfree (agg);
     return (-1);
   } /* }}} */
 
-  status = lookup_add (lookup, &agg->ident, agg);
+  status = lookup_add (lookup, &agg->ident, agg->group_by, agg);
   if (status != 0)
   {
     ERROR ("aggregation plugin: lookup_add failed with status %i.", status);
     sfree (agg);
     return (-1);
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/apcups.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/apcups.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/apcups.c	2013-04-09 09:03:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/apcups.c	2013-04-09 23:18:59.000000000 +0800
@@ -67,26 +67,28 @@
 /*
  * Private variables
  */
 /* Default values for contacting daemon */
 static char *conf_host = NULL;
 static int   conf_port = NISPORT;
+/* Defaults to false for backwards compatibility. */
+static _Bool conf_report_seconds = 0;
 
 static int global_sockfd = -1;
 
 static int count_retries = 0;
 static int count_iterations = 0;
 static _Bool close_socket = 0;
 
 static const char *config_keys[] =
 {
 	"Host",
 	"Port",
-	NULL
+	"ReportSeconds"
 };
-static int config_keys_num = 2;
+static int config_keys_num = STATIC_ARRAY_SIZE (config_keys);
 
 static int net_shutdown (int *fd)
 {
 	uint16_t packet_size = 0;
 
 	if ((fd == NULL) || (*fd < 0))
@@ -357,13 +359,19 @@
 				apcups_detail->bcharge = value;
 			else if (strcmp ("OUTPUTV", key) == 0)
 				apcups_detail->outputv = value;
 			else if (strcmp ("LINEFREQ", key) == 0)
 				apcups_detail->linefreq = value;
 			else if (strcmp ("TIMELEFT", key) == 0)
+			{
+				/* Convert minutes to seconds if requested by
+				 * the user. */
+				if (conf_report_seconds)
+					value *= 60.0;
 				apcups_detail->timeleft = value;
+			}
 
 			tokptr = strtok_r (NULL, ":", &toksaveptr);
 		} /* while (tokptr != NULL) */
 	}
 	status = errno; /* save errno, net_shutdown() may re-set it. */
 
@@ -400,12 +408,19 @@
 		{
 			WARNING ("apcups plugin: Invalid port: %i", port_tmp);
 			return (1);
 		}
 		conf_port = port_tmp;
 	}
+	else if (strcasecmp (key, "ReportSeconds") == 0)
+	{
+		if (IS_TRUE (value))
+			conf_report_seconds = 1;
+		else
+			conf_report_seconds = 0;
+	}
 	else
 	{
 		return (-1);
 	}
 	return (0);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/collectd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/collectd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/collectd.conf.5	2013-04-09 09:15:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/collectd.conf.5	2013-04-10 10:16:26.000000000 +0800
@@ -121,13 +121,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD.CONF 5"
-.TH COLLECTD.CONF 5 "2013-04-09" "5.2.2" "collectd"
+.TH COLLECTD.CONF 5 "2013-04-10" "5.3.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd.conf \- Configuration for the system statistics collection daemon \fBcollectd\fR
@@ -231,24 +231,35 @@
 Sets a plugin-specific interval for collecting metrics. This overrides the
 global \fBInterval\fR setting. If a plugin provides own support for specifying an
 interval, that setting will take precedence.
 .RE
 .RS 4
 .RE
-.IP "\fBInclude\fR \fIPath\fR" 4
-.IX Item "Include Path"
+.IP "\fBInclude\fR \fIPath\fR [\fIpattern\fR]" 4
+.IX Item "Include Path [pattern]"
 If \fIPath\fR points to a file, includes that file. If \fIPath\fR points to a
 directory, recursively includes all files within that directory and its
 subdirectories. If the \f(CW\*(C`wordexp\*(C'\fR function is available on your system,
 shell-like wildcards are expanded before files are included. This means you can
 use statements like the following:
 .Sp
 .Vb 1
 \&  Include "/etc/collectd.d/*.conf"
 .Ve
 .Sp
+If the \f(CW\*(C`fnmatch\*(C'\fR function is available on your system, a shell-like wildcard
+\&\fIpattern\fR may be specified to filter which files to include. This may be used
+in combination with recursively including a directory to easily be able to
+arbitrarily mix configuration files and other documents (e.g. \s-1README\s0 files).
+The following statement is similar to the example above but includes all files
+matching \f(CW\*(C`*.conf\*(C'\fR in any subdirectory of \f(CW\*(C`/etc/collectd.d\*(C'\fR:
+.Sp
+.Vb 1
+\&  Include "/etc/collectd.d" "*.conf"
+.Ve
+.Sp
 If more than one files are included by a single \fBInclude\fR option, the files
 will be included in lexicographical order (as defined by the \f(CW\*(C`strcmp\*(C'\fR
 function). Thus, you can e.\ g. use numbered prefixes to specify the
 order in which the files are loaded.
 .Sp
 To prevent loops and shooting yourself in the foot in interesting ways the
@@ -290,14 +301,19 @@
 the \fIThreshold\fR configuration to dispatch notifications about missing values,
 see \fIcollectd\-threshold\fR\|(5) for details.
 .IP "\fBReadThreads\fR \fINum\fR" 4
 .IX Item "ReadThreads Num"
 Number of threads to start for reading plugins. The default value is \fB5\fR, but
 you may want to increase this if you have more than five plugins that take a
-long time to read. Mostly those are plugin that do network-IO. Setting this to
-a value higher than the number of plugins you've loaded is totally useless.
+long time to read. Mostly those are plugins that do network-IO. Setting this to
+a value higher than the number of registered read callbacks is not recommended.
+.IP "\fBWriteThreads\fR \fINum\fR" 4
+.IX Item "WriteThreads Num"
+Number of threads to start for dispatching value lists to write plugins. The
+default value is \fB5\fR, but you may want to increase this if you have more than
+five plugins that may take relatively long to write to.
 .IP "\fBHostname\fR \fIName\fR" 4
 .IX Item "Hostname Name"
 Sets the hostname that identifies a host. If you omit this setting, the
 hostname will be determined using the \fIgethostname\fR\|(2) system call.
 .IP "\fBFQDNLookup\fR \fBtrue|false\fR" 4
 .IX Item "FQDNLookup true|false"
@@ -407,16 +423,74 @@
 .IX Item "Type Type"
 .IP "\fBTypeInstance\fR \fITypeInstance\fR" 4
 .IX Item "TypeInstance TypeInstance"
 .PD
 Selects the value lists to be added to this aggregation. \fBType\fR must be a
 valid data set name, see \fItypes.db\fR\|(5) for details.
+.Sp
+If the string starts with and ends with a slash (\f(CW\*(C`/\*(C'\fR), the string is
+interpreted as a \fIregular expression\fR. The regex flavor used are \s-1POSIX\s0
+extended regular expressions as described in \fIregex\fR\|(7). Example usage:
+.Sp
+.Vb 1
+\& Host "/^db[0\-9]\e\e.example\e\e.com$/"
+.Ve
 .IP "\fBGroupBy\fR \fBHost\fR|\fBPlugin\fR|\fBPluginInstance\fR|\fBTypeInstance\fR" 4
 .IX Item "GroupBy Host|Plugin|PluginInstance|TypeInstance"
 Group valued by the specified field. The \fBGroupBy\fR option may be repeated to
 group by multiple fields.
+.IP "\fBSetHost\fR \fIHost\fR" 4
+.IX Item "SetHost Host"
+.PD 0
+.IP "\fBSetPlugin\fR \fIPlugin\fR" 4
+.IX Item "SetPlugin Plugin"
+.IP "\fBSetPluginInstance\fR \fIPluginInstance\fR" 4
+.IX Item "SetPluginInstance PluginInstance"
+.IP "\fBSetTypeInstance\fR \fITypeInstance\fR" 4
+.IX Item "SetTypeInstance TypeInstance"
+.PD
+Sets the appropriate part of the identifier to the provided string.
+.Sp
+The \fIPluginInstance\fR should include the placeholder \f(CW\*(C`%{aggregation}\*(C'\fR which
+will be replaced with the aggregation function, e.g. \*(L"average\*(R". Not including
+the placeholder will result in duplication warnings and/or messed up values if
+more than one aggregation function are enabled.
+.Sp
+The following example calculates the average usage of all \*(L"even\*(R" CPUs:
+.Sp
+.Vb 5
+\& <Plugin "aggregation">
+\&   <Aggregation>
+\&     Plugin "cpu"
+\&     PluginInstance "/[0,2,4,6,8]$/"
+\&     Type "cpu"
+\&     
+\&     SetPlugin "cpu"
+\&     SetPluginInstance "even\-%{aggregation}"
+\&     
+\&     GroupBy "Host"
+\&     GroupBy "TypeInstance"
+\&     
+\&     CalculateAverage true
+\&   </Aggregation>
+\& </Plugin>
+.Ve
+.Sp
+This will create the files:
+.RS 4
+.IP "\(bu" 4
+foo.example.com/cpu\-even\-average/cpu\-idle
+.IP "\(bu" 4
+foo.example.com/cpu\-even\-average/cpu\-system
+.IP "\(bu" 4
+foo.example.com/cpu\-even\-average/cpu\-user
+.IP "\(bu" 4
+\&...
+.RE
+.RS 4
+.RE
 .IP "\fBCalculateNum\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "CalculateNum true|false"
 .PD 0
 .IP "\fBCalculateSum\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "CalculateSum true|false"
 .IP "\fBCalculateAverage\fR \fBtrue\fR|\fBfalse\fR" 4
@@ -656,12 +730,17 @@
 Hostname of the host running \fBapcupsd\fR. Defaults to \fBlocalhost\fR. Please note
 that IPv6 support has been disabled unless someone can confirm or decline that
 \&\fBapcupsd\fR can handle it.
 .IP "\fBPort\fR \fIPort\fR" 4
 .IX Item "Port Port"
 TCP-Port to connect to. Defaults to \fB3551\fR.
+.IP "\fBReportSeconds\fR \fBtrue|false\fR" 4
+.IX Item "ReportSeconds true|false"
+If set to \fBtrue\fR, the time reported in the \f(CW\*(C`timeleft\*(C'\fR metric will be
+converted to seconds. This is the recommended setting. If set to \fBfalse\fR, the
+default for backwards compatibility, the time will be reported in minutes.
 .ie n .SS "Plugin ""ascent"""
 .el .SS "Plugin \f(CWascent\fP"
 .IX Subsection "Plugin ascent"
 This plugin collects information about an Ascent server, a free server for the
 \&\*(L"World of Warcraft\*(R" game. This plugin gathers the information by fetching the
 \&\s-1XML\s0 status page using \f(CW\*(C`libcurl\*(C'\fR and parses it using \f(CW\*(C`libxml2\*(C'\fR.
@@ -911,12 +990,23 @@
 \&\s-1SSL\s0 enabled server. Enabled by default.
 .IP "\fBCACert\fR \fIfile\fR" 4
 .IX Item "CACert file"
 File that holds one or more \s-1SSL\s0 certificates. If you want to use \s-1HTTPS\s0 you will
 possibly need this option. What \s-1CA\s0 certificates come bundled with \f(CW\*(C`libcurl\*(C'\fR
 and are checked by default depends on the distribution you use.
+.IP "\fBHeader\fR \fIHeader\fR" 4
+.IX Item "Header Header"
+A \s-1HTTP\s0 header to add to the request. Multiple headers are added if this option
+is specified more than once.
+.IP "\fBPost\fR \fIBody\fR" 4
+.IX Item "Post Body"
+Specifies that the \s-1HTTP\s0 operation should be a \s-1POST\s0 instead of a \s-1GET\s0. The
+complete data to be posted is given as the argument.  This option will usually
+need to be accompanied by a \fBHeader\fR option to set an appropriate
+\&\f(CW\*(C`Content\-Type\*(C'\fR for the post body (e.g. to
+\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR).
 .IP "\fBMeasureResponseTime\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "MeasureResponseTime true|false"
 Measure response time for the request. If this setting is enabled, \fBMatch\fR
 blocks (see below) are optional. Disabled by default.
 .IP "\fB<Match>\fR" 4
 .IX Item "<Match>"
@@ -963,34 +1053,16 @@
 \&\fI*\fR\ wildcard, the values for all keys will be collectd.
 .PP
 The following options are valid within \fB\s-1URL\s0\fR blocks:
 .IP "\fBInstance\fR \fIInstance\fR" 4
 .IX Item "Instance Instance"
 Sets the plugin instance to \fIInstance\fR.
-.IP "\fBUser\fR \fIName\fR" 4
-.IX Item "User Name"
-Username to use if authorization is required to read the page.
-.IP "\fBPassword\fR \fIPassword\fR" 4
-.IX Item "Password Password"
-Password to use if authorization is required to read the page.
-.IP "\fBVerifyPeer\fR \fBtrue\fR|\fBfalse\fR" 4
-.IX Item "VerifyPeer true|false"
-Enable or disable peer \s-1SSL\s0 certificate verification. See
-<http://curl.haxx.se/docs/sslcerts.html> for details. Enabled by default.
-.IP "\fBVerifyHost\fR \fBtrue\fR|\fBfalse\fR" 4
-.IX Item "VerifyHost true|false"
-Enable or disable peer host name verification. If enabled, the plugin checks if
-the \f(CW\*(C`Common Name\*(C'\fR or a \f(CW\*(C`Subject Alternate Name\*(C'\fR field of the \s-1SSL\s0 certificate
-matches the host name provided by the \fB\s-1URL\s0\fR option. If this identity check
-fails, the connection is aborted. Obviously, only works when connecting to a
-\&\s-1SSL\s0 enabled server. Enabled by default.
-.IP "\fBCACert\fR \fIfile\fR" 4
-.IX Item "CACert file"
-File that holds one or more \s-1SSL\s0 certificates. If you want to use \s-1HTTPS\s0 you will
-possibly need this option. What \s-1CA\s0 certificates come bundled with \f(CW\*(C`libcurl\*(C'\fR
-and are checked by default depends on the distribution you use.
+.IP "\fBUser\fR \fIName\fR =item \fBPassword\fR \fIPassword\fR =item \fBVerifyPeer\fR \fBtrue\fR|\fBfalse\fR =item \fBVerifyHost\fR \fBtrue\fR|\fBfalse\fR =item \fBCACert\fR \fIfile\fR =item \fBHeader\fR \fIHeader\fR =item \fBPost\fR \fIBody\fR" 4
+.IX Item "User Name =item Password Password =item VerifyPeer true|false =item VerifyHost true|false =item CACert file =item Header Header =item Post Body"
+These options behave exactly equivalent to the appropriate options of the
+\&\fIcURL\fR plugin. Please see there for a detailed description.
 .PP
 The following options are valid within \fBKey\fR blocks:
 .IP "\fBType\fR \fIType\fR" 4
 .IX Item "Type Type"
 Sets the type used to dispatch the values to the daemon. Detailed information
 about types and their configuration can be found in \fItypes.db\fR\|(5). This
@@ -1042,16 +1114,43 @@
 Use \fIName\fR as the host name when submitting values. Defaults to the global
 host name setting.
 .IP "\fBInstance\fR \fIInstance\fR" 4
 .IX Item "Instance Instance"
 Use \fIInstance\fR as the plugin instance when submitting values. Defaults to an
 empty string (no plugin instance).
-.IP "\fBUser\fR \fIUser\fR =item \fBPassword\fR \fIPassword\fR =item \fBVerifyPeer\fR \fBtrue\fR|\fBfalse\fR =item \fBVerifyHost\fR \fBtrue\fR|\fBfalse\fR =item \fBCACert\fR \fI\s-1CA\s0 Cert File\fR" 4
-.IX Item "User User =item Password Password =item VerifyPeer true|false =item VerifyHost true|false =item CACert CA Cert File"
+.IP "\fBNamespace\fR \fIPrefix\fR \fI\s-1URL\s0\fR" 4
+.IX Item "Namespace Prefix URL"
+If an XPath expression references namespaces, they must be specified
+with this option. \fIPrefix\fR is the \*(L"namespace prefix\*(R" used in the \s-1XML\s0 document.
+\&\fI\s-1URL\s0\fR is the \*(L"namespace name\*(R", an \s-1URI\s0 reference uniquely identifying the
+namespace. The option can be repeated to register multiple namespaces.
+.Sp
+Examples:
+.Sp
+.Vb 2
+\&  Namespace "s" "http://schemas.xmlsoap.org/soap/envelope/"
+\&  Namespace "m" "http://www.w3.org/1998/Math/MathML"
+.Ve
+.IP "\fBUser\fR \fIUser\fR" 4
+.IX Item "User User"
+.PD 0
+.IP "\fBPassword\fR \fIPassword\fR" 4
+.IX Item "Password Password"
+.IP "\fBVerifyPeer\fR \fBtrue\fR|\fBfalse\fR" 4
+.IX Item "VerifyPeer true|false"
+.IP "\fBVerifyHost\fR \fBtrue\fR|\fBfalse\fR" 4
+.IX Item "VerifyHost true|false"
+.IP "\fBCACert\fR \fI\s-1CA\s0 Cert File\fR" 4
+.IX Item "CACert CA Cert File"
+.IP "\fBHeader\fR \fIHeader\fR" 4
+.IX Item "Header Header"
+.IP "\fBPost\fR \fIBody\fR" 4
+.IX Item "Post Body"
+.PD
 These options behave exactly equivalent to the appropriate options of the
-\&\fIcURL\fR and \fIcURL-JSON\fR plugins. Please see there for a detailed description.
+\&\fIcURL plugin\fR. Please see there for a detailed description.
 .IP "<\fBXPath\fR \fIXPath-expression\fR>" 4
 .IX Item "<XPath XPath-expression>"
 Within each \fB\s-1URL\s0\fR block, there must be one or more \fBXPath\fR blocks. Each
 \&\fBXPath\fR block specifies how to get one type of information. The string
 argument must be a valid XPath expression which returns a list of \*(L"base
 elements\*(R". One value is dispatched for each \*(L"base element\*(R".
@@ -1300,28 +1399,46 @@
 .IX Item "DriverOption Key Value"
 Sets driver-specific options. What option a driver supports can be found in the
 documentation for each driver, somewhere at
 <http://libdbi\-drivers.sourceforge.net/>. However, the options \*(L"host\*(R",
 \&\*(L"username\*(R", \*(L"password\*(R", and \*(L"dbname\*(R" seem to be de\ facto standards.
 .Sp
+DBDs can register two types of options: String options and numeric options. The
+plugin will use the \f(CW\*(C`dbi_conn_set_option\*(C'\fR function when the configuration
+provides a string and the \f(CW\*(C`dbi_conn_require_option_numeric\*(C'\fR function when the
+configuration provides a number. So these two lines will actually result in
+different calls being used:
+.Sp
+.Vb 2
+\&  DriverOption "Port" 1234      # numeric
+\&  DriverOption "Port" "1234"    # string
+.Ve
+.Sp
 Unfortunately, drivers are not too keen to report errors when an unknown option
 is passed to them, so invalid settings here may go unnoticed. This is not the
 plugin's fault, it will report errors if it gets them from the library\ /
 the driver. If a driver complains about an option, the plugin will dump a
-complete list of all options understood by that driver to the log.
+complete list of all options understood by that driver to the log. There is no
+way to programatically find out if an option expects a string or a numeric
+argument, so you will have to refer to the appropriate \s-1DBD\s0's documentation to
+find this out. Sorry.
 .IP "\fBSelectDB\fR \fIDatabase\fR" 4
 .IX Item "SelectDB Database"
 In some cases, the database name you connect with is not the database name you
 want to use for querying data. If this option is set, the plugin will \*(L"select\*(R"
 (switch to) that database after the connection is established.
 .IP "\fBQuery\fR \fIQueryName\fR" 4
 .IX Item "Query QueryName"
 Associates the query named \fIQueryName\fR with this database connection. The
 query needs to be defined \fIbefore\fR this statement, i.\ e. all query
 blocks you want to refer to must be placed above the database block you want to
 refer to them from.
+.IP "\fBHost\fR \fIHostname\fR" 4
+.IX Item "Host Hostname"
+Sets the \fBhost\fR field of \fIvalue lists\fR to \fIHostname\fR when dispatching
+values. Defaults to the global hostname setting.
 .ie n .SS "Plugin ""df"""
 .el .SS "Plugin \f(CWdf\fP"
 .IX Subsection "Plugin df"
 .IP "\fBDevice\fR \fIDevice\fR" 4
 .IX Item "Device Device"
 Select partitions based on the devicename.
@@ -2276,28 +2393,62 @@
 \&      IgnoreSelectedCapacity false
 \&      GetSnapshot "vol1"
 \&      GetSnapshot "vol3"
 \&      IgnoreSelectedSnapshot false
 \&    </VolumeUsage>
 \&    
+\&    <Quota>
+\&      Interval 60
+\&    </Quota>
+\&    
+\&    <Snapvault>
+\&      Interval 30
+\&    </Snapvault>
+\&    
 \&    <System>
 \&      Interval 30
 \&      GetCPULoad     true
 \&      GetInterfaces  true
 \&      GetDiskOps     true
 \&      GetDiskIO      true
 \&    </System>
+\&
+\&    <VFiler vfilerA>
+\&      Interval 60
+\&
+\&      SnapVault true
+\&      # ...
+\&    </VFiler>
 \&   </Host>
 \& </Plugin>
 .Ve
 .PP
 The netapp plugin accepts the following configuration options:
 .IP "\fBHost\fR \fIName\fR" 4
 .IX Item "Host Name"
 A host block defines one NetApp filer. It will appear in collectd with the name
-you specify here which does not have to be its real name nor its hostname.
+you specify here which does not have to be its real name nor its hostname (see
+the \fBAddress\fR option below).
+.IP "\fBVFiler\fR \fIName\fR" 4
+.IX Item "VFiler Name"
+A \fBVFiler\fR block may only be used inside a host block. It accepts all the
+same options as the \fBHost\fR block (except for cascaded \fBVFiler\fR blocks) and
+will execute all NetApp \s-1API\s0 commands in the context of the specified
+VFiler(R). It will appear in collectd with the name you specify here which
+does not have to be its real name. The VFiler name may be specified using the
+\&\fBVFilerName\fR option. If this is not specified, it will default to the name
+you specify here.
+.Sp
+The VFiler block inherits all connection related settings from the surrounding
+\&\fBHost\fR block (which appear before the \fBVFiler\fR block) but they may be
+overwritten inside the \fBVFiler\fR block.
+.Sp
+This feature is useful, for example, when using a VFiler as SnapVault target
+(supported since OnTap 8.1). In that case, the SnapVault statistics are not
+available in the host filer (vfiler0) but only in the respective VFiler
+context.
 .IP "\fBProtocol\fR \fBhttpd\fR|\fBhttp\fR" 4
 .IX Item "Protocol httpd|http"
 The protocol collectd will use to query this host.
 .Sp
 Optional
 .Sp
@@ -2332,12 +2483,24 @@
 .PD
 The username and password to use to login to the NetApp.
 .Sp
 Mandatory
 .Sp
 Type: string
+.IP "\fBVFilerName\fR \fIName\fR" 4
+.IX Item "VFilerName Name"
+The name of the VFiler in which context to execute \s-1API\s0 commands. If not
+specified, the name provided to the \fBVFiler\fR block will be used instead.
+.Sp
+Optional
+.Sp
+Type: string
+.Sp
+Default: name of the \fBVFiler\fR block
+.Sp
+\&\fBNote:\fR This option may only be used inside \fBVFiler\fR blocks.
 .IP "\fBInterval\fR \fIInterval\fR" 4
 .IX Item "Interval Interval"
 \&\fB\s-1TODO\s0\fR
 .PP
 The following options decide what kind of data will be collected. You can
 either use them as a block and fine tune various parameters inside this block,
@@ -2625,12 +2788,38 @@
 .IP "\fBIgnoreSelectedSnapshot\fR" 4
 .IX Item "IgnoreSelectedSnapshot"
 Specify whether to collect only the volumes selected by the \fBGetSnapshot\fR
 option or to ignore those volumes. \fBIgnoreSelectedSnapshot\fR defaults to
 \&\fBfalse\fR. However, if no \fBGetSnapshot\fR option is specified at all, all
 capacities will be selected anyway.
+.PP
+\fIThe Quota block\fR
+.IX Subsection "The Quota block"
+.PP
+This will collect (tree) quota statistics (used disk space and number of used
+files). This mechanism is useful to get usage information for single qtrees.
+In case the quotas are not used for any other purpose, an entry similar to the
+following in \f(CW\*(C`/etc/quotas\*(C'\fR would be sufficient:
+.PP
+.Vb 1
+\&  /vol/volA/some_qtree tree \- \- \- \- \-
+.Ve
+.PP
+After adding the entry, issue \f(CW\*(C`quota on \-w volA\*(C'\fR on the NetApp filer.
+.IP "\fBInterval\fR \fISeconds\fR" 4
+.IX Item "Interval Seconds"
+Collect SnapVault(R) statistics every \fISeconds\fR seconds.
+.PP
+\fIThe SnapVault block\fR
+.IX Subsection "The SnapVault block"
+.PP
+This will collect statistics about the time and traffic of SnapVault(R)
+transfers.
+.IP "\fBInterval\fR \fISeconds\fR" 4
+.IX Item "Interval Seconds"
+Collect SnapVault(R) statistics every \fISeconds\fR seconds.
 .ie n .SS "Plugin ""netlink"""
 .el .SS "Plugin \f(CWnetlink\fP"
 .IX Subsection "Plugin netlink"
 The \f(CW\*(C`netlink\*(C'\fR plugin uses a netlink socket to query the Linux kernel about
 statistics of various interface and routing aspects.
 .IP "\fBInterface\fR \fIInterface\fR" 4
@@ -4106,12 +4295,21 @@
 Use of an absolute path is recommended.
 .IP "\fBCreateFiles\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "CreateFiles true|false"
 Enables or disables the creation of \s-1RRD\s0 files. If the daemon is not running
 locally, or \fBDataDir\fR is set to a relative path, this will not work as
 expected. Default is \fBtrue\fR.
+.IP "\fBCreateFilesAsync\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "CreateFilesAsync false|true"
+When enabled, new \s-1RRD\s0 files are enabled asynchronously, using a separate thread
+that runs in the background. This prevents writes to block, which is a problem
+especially when many hundreds of files need to be created at once. However,
+since the purpose of creating the files asynchronously is \fInot\fR to block until
+the file is available, values before the file is available will be discarded.
+When disabled (the default) files are created synchronously, blocking for a
+short while, while the file is being written.
 .IP "\fBStepSize\fR \fISeconds\fR" 4
 .IX Item "StepSize Seconds"
 \&\fBForce\fR the stepsize of newly created RRD-files. Ideally (and per default)
 this setting is unset and the stepsize is set to the interval in which the data
 is collected. Do not use this option unless you absolutely have to for some
 reason. Setting this option may cause problems with the \f(CW\*(C`snmp plugin\*(C'\fR, the
@@ -4154,14 +4352,23 @@
 You can use the settings \fBStepSize\fR, \fBHeartBeat\fR, \fBRRARows\fR, and \fB\s-1XFF\s0\fR to
 fine-tune your RRD-files. Please read \fIrrdcreate\fR\|(1) if you encounter problems
 using these settings. If you don't want to dive into the depths of RRDtool, you
 can safely ignore these settings.
 .IP "\fBDataDir\fR \fIDirectory\fR" 4
 .IX Item "DataDir Directory"
-Set the directory to store RRD-files under. Per default RRD-files are generated
-beneath the daemon's working directory, i.\ e. the \fBBaseDir\fR.
+Set the directory to store \s-1RRD\s0 files under. By default \s-1RRD\s0 files are generated
+beneath the daemon's working directory, i.e. the \fBBaseDir\fR.
+.IP "\fBCreateFilesAsync\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "CreateFilesAsync false|true"
+When enabled, new \s-1RRD\s0 files are enabled asynchronously, using a separate thread
+that runs in the background. This prevents writes to block, which is a problem
+especially when many hundreds of files need to be created at once. However,
+since the purpose of creating the files asynchronously is \fInot\fR to block until
+the file is available, values before the file is available will be discarded.
+When disabled (the default) files are created synchronously, blocking for a
+short while, while the file is being written.
 .IP "\fBStepSize\fR \fISeconds\fR" 4
 .IX Item "StepSize Seconds"
 \&\fBForce\fR the stepsize of newly created RRD-files. Ideally (and per default)
 this setting is unset and the stepsize is set to the interval in which the data
 is collected. Do not use this option unless you absolutely have to for some
 reason. Setting this option may cause problems with the \f(CW\*(C`snmp plugin\*(C'\fR, the
@@ -4173,13 +4380,13 @@
 the interval in which data is collected. Do not set this option unless you have
 a very good reason to do so.
 .IP "\fBRRARows\fR \fINumRows\fR" 4
 .IX Item "RRARows NumRows"
 The \f(CW\*(C`rrdtool plugin\*(C'\fR calculates the number of PDPs per \s-1CDP\s0 based on the
 \&\fBStepSize\fR, this setting and a timespan. This plugin creates RRD-files with
-three times five RRAs, i. e. five RRAs with the CFs \fB\s-1MIN\s0\fR, \fB\s-1AVERAGE\s0\fR, and
+three times five RRAs, i.e. five RRAs with the CFs \fB\s-1MIN\s0\fR, \fB\s-1AVERAGE\s0\fR, and
 \&\fB\s-1MAX\s0\fR. The five RRAs are optimized for graphs covering one hour, one day, one
 week, one month, and one year.
 .Sp
 So for each timespan, it calculates how many PDPs need to be consolidated into
 one \s-1CDP\s0 by calculating:
   number of PDPs = timespan / (stepsize * rrarows)
@@ -4526,12 +4733,92 @@
 .IX Item "Type Type"
 Sets the type used to dispatch this value. Detailed information about types and
 their configuration can be found in \fItypes.db\fR\|(5).
 .IP "\fBInstance\fR \fITypeInstance\fR" 4
 .IX Item "Instance TypeInstance"
 This optional setting sets the type instance to use.
+.ie n .SS "Plugin ""tail_csv"""
+.el .SS "Plugin \f(CWtail_csv\fP"
+.IX Subsection "Plugin tail_csv"
+The \fItail_csv plugin\fR reads files in the \s-1CSV\s0 format, e.g. the statistics file
+written by \fISnort\fR.
+.PP
+\&\fBSynopsis:\fR
+.PP
+.Vb 12
+\& <Plugin "tail_csv">
+\&   <Metric "snort\-dropped">
+\&       Type "percent"
+\&       Instance "dropped"
+\&       Index 1
+\&   </Metric>
+\&   <File "/var/log/snort/snort.stats">
+\&       Instance "snort\-eth0"
+\&       Interval 600
+\&       Collect "snort\-dropped"
+\&   </File>
+\& </Plugin>
+.Ve
+.PP
+The configuration consists of one or more \fBMetric\fR blocks that define an index
+into the line of the \s-1CSV\s0 file and how this value is mapped to \fIcollectd's\fR
+internal representation. These are followed by one or more \fBInstance\fR blocks
+which configure which file to read, in which interval and which metrics to
+extract.
+.IP "<\fBMetric\fR \fIName\fR>" 4
+.IX Item "<Metric Name>"
+The \fBMetric\fR block configures a new metric to be extracted from the statistics
+file and how it is mapped on \fIcollectd's\fR data model. The string \fIName\fR is
+only used inside the \fBInstance\fR blocks to refer to this block, so you can use
+one \fBMetric\fR block for multiple \s-1CSV\s0 files.
+.RS 4
+.IP "\fBType\fR \fIType\fR" 4
+.IX Item "Type Type"
+Configures which \fIType\fR to use when dispatching this metric. Types are defined
+in the \fItypes.db\fR\|(5) file, see the appropriate manual page for more
+information on specifying types. Only types with a single \fIdata source\fR are
+supported by the \fItail_csv plugin\fR. The information whether the value is an
+absolute value (i.e. a \f(CW\*(C`GAUGE\*(C'\fR) or a rate (i.e. a \f(CW\*(C`DERIVE\*(C'\fR) is taken from the
+\&\fIType's\fR definition.
+.IP "\fBInstance\fR \fITypeInstance\fR" 4
+.IX Item "Instance TypeInstance"
+If set, \fITypeInstance\fR is used to populate the type instance field of the
+created value lists. Otherwise, no type instance is used.
+.IP "\fBValueFrom\fR \fIIndex\fR" 4
+.IX Item "ValueFrom Index"
+Configure to read the value from the field with the zero-based index \fIIndex\fR.
+If the value is parsed as signed integer, unsigned integer or double depends on
+the \fBType\fR setting, see above.
+.RE
+.RS 4
+.RE
+.IP "<\fBFile\fR \fIPath\fR>" 4
+.IX Item "<File Path>"
+Each \fBFile\fR block represents one \s-1CSV\s0 file to read. There must be at least one
+\&\fIFile\fR block but there can be multiple if you have multiple \s-1CSV\s0 files.
+.RS 4
+.IP "\fBInstance\fR \fIPluginInstance\fR" 4
+.IX Item "Instance PluginInstance"
+Sets the \fIplugin instance\fR used when dispatching the values.
+.IP "\fBCollect\fR \fIMetric\fR" 4
+.IX Item "Collect Metric"
+Specifies which \fIMetric\fR to collect. This option must be specified at least
+once, and you can use this option multiple times to specify more than one
+metric to be extracted from this statistic file.
+.IP "\fBInterval\fR \fISeconds\fR" 4
+.IX Item "Interval Seconds"
+Configures the interval in which to read values from this instance / file.
+Defaults to the plugin's default interval.
+.IP "\fBTimeFrom\fR \fIIndex\fR" 4
+.IX Item "TimeFrom Index"
+Rather than using the local time when dispatching a value, read the timestamp
+from the field with the zero-based index \fIIndex\fR. The value is interpreted as
+seconds since epoch. The value is parsed as a double and may be factional.
+.RE
+.RS 4
+.RE
 .ie n .SS "Plugin ""teamspeak2"""
 .el .SS "Plugin \f(CWteamspeak2\fP"
 .IX Subsection "Plugin teamspeak2"
 The \f(CW\*(C`teamspeak2 plugin\*(C'\fR connects to the query port of a teamspeak2 server and
 polls interesting global and virtual server data. The plugin can query only one
 physical server but unlimited virtual servers. You can use the following
@@ -4786,19 +5073,22 @@
 minimize the number of network packets.
 .PP
 Synopsis:
 .PP
 .Vb 7
 \& <Plugin write_graphite>
-\&   <Carbon>
+\&   <Node "example">
 \&     Host "localhost"
 \&     Port "2003"
 \&     Prefix "collectd"
-\&   </Carbon>
+\&   </Node>
 \& </Plugin>
 .Ve
+.PP
+The configuration consists of one or more <\fBNode\fR\ \fIName\fR>
+blocks. Inside the \fBNode\fR blocks, the following options are recognized:
 .IP "\fBHost\fR \fIAddress\fR" 4
 .IX Item "Host Address"
 Hostname or address to connect to. Defaults to \f(CW\*(C`localhost\*(C'\fR.
 .IP "\fBPort\fR \fIService\fR" 4
 .IX Item "Port Service"
 Service name or port number to connect to. Defaults to \f(CW2003\fR.
@@ -4866,12 +5156,23 @@
 Setting this option to zero means no timeout, which is the default.
 .IP "\fBStoreRates\fR \fBfalse\fR|\fBtrue\fR" 4
 .IX Item "StoreRates false|true"
 If set to \fBtrue\fR (the default), convert counter values to rates. If set to
 \&\fBfalse\fR counter values are stored as is, i.e. as an increasing integer
 number.
+.IP "\fBDatabase\fR \fIDatabase\fR" 4
+.IX Item "Database Database"
+.PD 0
+.IP "\fBUser\fR \fIUser\fR" 4
+.IX Item "User User"
+.IP "\fBPassword\fR \fIPassword\fR" 4
+.IX Item "Password Password"
+.PD
+Sets the information used when authenticating to a \fIMongoDB\fR database. The
+fields are optional (in which case no authentication is attempted), but if you
+want to use authentication all three fields must be set.
 .ie n .SS "Plugin ""write_http"""
 .el .SS "Plugin \f(CWwrite_http\fP"
 .IX Subsection "Plugin write_http"
 This output plugin submits values to an http server by \s-1POST\s0 them using the
 \&\s-1PUTVAL\s0 plain-text protocol. Each destination you want to post data to needs to
 have one \fB\s-1URL\s0\fR block, within which the destination can be configured further,
@@ -4921,12 +5222,74 @@
 Defaults to \fBCommand\fR.
 .IP "\fBStoreRates\fR \fBtrue|false\fR" 4
 .IX Item "StoreRates true|false"
 If set to \fBtrue\fR, convert counter values to rates. If set to \fBfalse\fR (the
 default) counter values are stored as is, i.\ e. as an increasing integer
 number.
+.ie n .SS "Plugin ""write_riemann"""
+.el .SS "Plugin \f(CWwrite_riemann\fP"
+.IX Subsection "Plugin write_riemann"
+The \fIwrite_riemann plugin\fR will send values to \fIRiemann\fR, a powerfull stream
+aggregation and monitoring system. The plugin sends \fIProtobuf\fR encoded data to
+\&\fIRiemann\fR using \s-1UDP\s0 packets.
+.PP
+Synopsis:
+.PP
+.Vb 11
+\& <Plugin "write_riemann">
+\&   <Node "example">
+\&     Host "localhost"
+\&     Port "5555"
+\&     Protocol UDP
+\&     StoreRates true
+\&     AlwaysAppendDS false
+\&     Delay 10
+\&   </Node>
+\&   Tag "foobar"
+\& </Plugin>
+.Ve
+.PP
+The following options are understood by the \fIwrite_riemann plugin\fR:
+.IP "<\fBNode\fR \fIName\fR>" 4
+.IX Item "<Node Name>"
+The plugin's configuration consists of one or more \fBNode\fR blocks. Each block
+is given a unique \fIName\fR and specifies one connection to an instance of
+\&\fIRiemann\fR. Indise the \fBNode\fR block, the following per-connection options are
+understood:
+.RS 4
+.IP "\fBHost\fR \fIAddress\fR" 4
+.IX Item "Host Address"
+Hostname or address to connect to. Defaults to \f(CW\*(C`localhost\*(C'\fR.
+.IP "\fBPort\fR \fIService\fR" 4
+.IX Item "Port Service"
+Service name or port number to connect to. Defaults to \f(CW5555\fR.
+.IP "\fBProtocol\fR \fB\s-1UDP\s0\fR|\fB\s-1TCP\s0\fR" 4
+.IX Item "Protocol UDP|TCP"
+Specify the protocol to use when communicating with \fIRiemann\fR. Defaults to
+\&\fB\s-1UDP\s0\fR.
+.IP "\fBStoreRates\fR \fBtrue\fR|\fBfalse\fR" 4
+.IX Item "StoreRates true|false"
+If set to \fBtrue\fR (the default), convert counter values to rates. If set to
+\&\fBfalse\fR counter values are stored as is, i.e. as an increasing integer number.
+.Sp
+This will be reflected in the \f(CW\*(C`ds_type\*(C'\fR tag: If \fBStoreRates\fR is enabled,
+converted values will have \*(L"rate\*(R" appended to the data source type, e.g.
+\&\f(CW\*(C`ds_type:derive:rate\*(C'\fR.
+.IP "\fBAlwaysAppendDS\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "AlwaysAppendDS false|true"
+If set the \fBtrue\fR, append the name of the \fIData Source\fR (\s-1DS\s0) to the
+\&\*(L"service\*(R", i.e. the field that, together with the \*(L"host\*(R" field, uniquely
+identifies a metric in \fIRiemann\fR. If set to \fBfalse\fR (the default), this is
+only done when there is more than one \s-1DS\s0.
+.RE
+.RS 4
+.RE
+.IP "\fBTag\fR \fIString\fR" 4
+.IX Item "Tag String"
+Add the given string as an additional tag to the metric being sent to
+\&\fIRiemann\fR.
 .SH "THRESHOLD CONFIGURATION"
 .IX Header "THRESHOLD CONFIGURATION"
 Starting with version \f(CW4.3.0\fR collectd has support for \fBmonitoring\fR. By that
 we mean that the values are not only stored or sent somewhere, but that they
 are judged and, if a problem is recognized, acted upon. The only action
 collectd takes itself is to generate and dispatch a \*(L"notification\*(R". Plugins can
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/collectd.conf.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/collectd.conf.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/collectd.conf.in	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/collectd.conf.in	2013-04-10 10:14:19.000000000 +0800
@@ -25,12 +25,13 @@
 #   </LoadPlugin>                                                            #
 #----------------------------------------------------------------------------#
 #Interval     10
 
 #Timeout      2
 #ReadThreads  5
+#WriteThreads 5
 
 ##############################################################################
 # Logging                                                                    #
 #----------------------------------------------------------------------------#
 # Plugins which provide logging functions should be loaded first, so log     #
 # messages generated when loading or configuring other plugins can be        #
@@ -140,12 +141,13 @@
 #@BUILD_PLUGIN_SENSORS_TRUE@LoadPlugin sensors
 #@BUILD_PLUGIN_SERIAL_TRUE@LoadPlugin serial
 #@BUILD_PLUGIN_SNMP_TRUE@LoadPlugin snmp
 #@BUILD_PLUGIN_SWAP_TRUE@LoadPlugin swap
 #@BUILD_PLUGIN_TABLE_TRUE@LoadPlugin table
 #@BUILD_PLUGIN_TAIL_TRUE@LoadPlugin tail
+#@BUILD_PLUGIN_TAIL_CSV_TRUE@LoadPlugin tail_csv
 #@BUILD_PLUGIN_TAPE_TRUE@LoadPlugin tape
 #@BUILD_PLUGIN_TCPCONNS_TRUE@LoadPlugin tcpconns
 #@BUILD_PLUGIN_TEAMSPEAK2_TRUE@LoadPlugin teamspeak2
 #@BUILD_PLUGIN_TED_TRUE@LoadPlugin ted
 #@BUILD_PLUGIN_THERMAL_TRUE@LoadPlugin thermal
 #@BUILD_PLUGIN_TOKYOTYRANT_TRUE@LoadPlugin tokyotyrant
@@ -156,14 +158,15 @@
 #@BUILD_PLUGIN_VARNISH_TRUE@LoadPlugin varnish
 #@BUILD_PLUGIN_VMEM_TRUE@LoadPlugin vmem
 #@BUILD_PLUGIN_VSERVER_TRUE@LoadPlugin vserver
 #@BUILD_PLUGIN_WIRELESS_TRUE@LoadPlugin wireless
 #@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@LoadPlugin write_graphite
 #@BUILD_PLUGIN_WRITE_HTTP_TRUE@LoadPlugin write_http
-#@BUILD_PLUGIN_WRITE_REDIS_TRUE@LoadPlugin write_redis
 #@BUILD_PLUGIN_WRITE_MONGODB_TRUE@LoadPlugin write_mongodb
+#@BUILD_PLUGIN_WRITE_REDIS_TRUE@LoadPlugin write_redis
+#@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@LoadPlugin write_riemann
 #@BUILD_PLUGIN_XMMS_TRUE@LoadPlugin xmms
 #@BUILD_PLUGIN_ZFS_ARC_TRUE@LoadPlugin zfs_arc
 
 ##############################################################################
 # Plugin configuration                                                       #
 #----------------------------------------------------------------------------#
@@ -214,12 +217,13 @@
 #  </Instance>
 #</Plugin>
 
 #<Plugin apcups>
 #	Host "localhost"
 #	Port "3551"
+#	ReportSeconds true
 #</Plugin>
 
 #<Plugin ascent>
 #	URL "http://localhost/ascent/status/"
 #	User "www-user"
 #	Password "secret"
@@ -331,12 +335,13 @@
 #		DriverOption "username" "collectd"
 #		DriverOption "password" "AeXohy0O"
 #		DriverOption "dbname" "custdb0"
 #		#SelectDB "custdb0"
 #		Query "num_of_customers"
 #		#Query "..."
+#		#Host "..."
 #	</Database>
 #</Plugin>
 
 #<Plugin df>
 #	Device "/dev/hda1"
 #	Device "192.168.0.2:/mnt/nfs"
@@ -847,19 +852,22 @@
 #</Plugin>
 
 #<Plugin rrdcached>
 #	DaemonAddress "unix:/tmp/rrdcached.sock"
 #	DataDir "@localstatedir@/lib/@PACKAGE_NAME@/rrd"
 #	CreateFiles true
+#	CreateFilesAsync false
 #	CollectStatistics true
 #</Plugin>
 
 #<Plugin rrdtool>
 #	DataDir "@localstatedir@/lib/@PACKAGE_NAME@/rrd"
+#	CreateFilesAsync false
 #	CacheTimeout 120
 #	CacheFlush   900
+#	WritesPerSecond 50
 #</Plugin>
 
 #<Plugin sensors>
 #	SensorConfigFile "/etc/sensors.conf"
 #	Sensor "it8712-isa-0290/temperature-temp1"
 #	Sensor "it8712-isa-0290/fanspeed-fan3"
@@ -949,12 +957,39 @@
 #      Type "counter"
 #      Instance "local_user"
 #    </Match>
 #  </File>
 #</Plugin>
 
+#<Plugin "tail_csv">
+#   <Metric "dropped">
+#       Type "percent"
+#       Instance "dropped"
+#       ValueFrom 1
+#   </Metric>
+#   <Metric "mbps">
+#       Type "bytes"
+#       Instance "wire-realtime"
+#       ValueFrom 2
+#   </Metric>
+#   <Metric "alerts">
+#       Type "alerts_per_second"
+#       ValueFrom 3
+#   </Metric>
+#   <Metric "kpps">
+#       Type "kpackets_wire_per_sec.realtime"
+#       ValueFrom 4
+#   </Metric>
+#   <File "/var/log/snort/snort.stats">
+#       Instance "snort-eth0"
+#       Interval 600
+#       Collect "dropped" "mbps" "alerts" "kpps"
+#       TimeFrom 0
+#   </File>
+#</Plugin>
+
 #<Plugin tcpconns>
 #	ListeningPorts false
 #	LocalPort "25"
 #	RemotePort "25"
 #</Plugin>
 
@@ -1014,21 +1049,21 @@
 
 #<Plugin vmem>
 #	Verbose false
 #</Plugin>
 
 #<Plugin write_graphite>
-#  <Carbon>
+#  <Node "example">
 #    Host "localhost"
 #    Port "2003"
 #    Prefix "collectd"
 #    Postfix "collectd"
-#    StoreRates false
+#    StoreRates true
 #    AlwaysAppendDS false
 #    EscapeCharacter "_"
-#  </Carbon>
+#  </Node>
 #</Plugin>
 
 #<Plugin write_http>
 #	<URL "http://example.com/collectd-post">
 #		User "collectd"
 #		Password "weCh3ik0"
@@ -1037,27 +1072,41 @@
 #		CACert "/etc/ssl/ca.crt"
 #		Format "Command"
 #		StoreRates false
 #	</URL>
 #</Plugin>
 
+#<Plugin write_mongodb>
+#	<Node "example">
+#		Host "localhost"
+#		Port "27017"
+#		Timeout 1000
+#		StoreRates false
+#		Database "auth_db"
+#		User "auth_user"
+#		Password "auth_passwd"
+#	</Node>
+#</Plugin>
+
 #<Plugin write_redis>
 #	<Node "example">
 #		Host "localhost"
 #		Port "6379"
 #		Timeout 1000
 #	</Node>
 #</Plugin>
 
-#<Plugin write_mongodb>
+#<Plugin write_riemann>
 #	<Node "example">
 #		Host "localhost"
-#		Port "27017"
-#		Timeout 1000
-#		StoreRates false
+#		Port 5555
+#		Protocol UDP
+#		StoreRates true
+#		AlwaysAppendDS false
 #	</Node>
+#	Tag "foobar"
 #</Plugin>
 
 ##############################################################################
 # Filter configuration                                                       #
 #----------------------------------------------------------------------------#
 # The following configures collectd's filtering mechanism. Before changing   #
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/collectd.conf.pod /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/collectd.conf.pod
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/collectd.conf.pod	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/collectd.conf.pod	2013-04-10 10:14:19.000000000 +0800
@@ -106,22 +106,31 @@
 Sets a plugin-specific interval for collecting metrics. This overrides the
 global B<Interval> setting. If a plugin provides own support for specifying an
 interval, that setting will take precedence.
 
 =back
 
-=item B<Include> I<Path>
+=item B<Include> I<Path> [I<pattern>]
 
 If I<Path> points to a file, includes that file. If I<Path> points to a
 directory, recursively includes all files within that directory and its
 subdirectories. If the C<wordexp> function is available on your system,
 shell-like wildcards are expanded before files are included. This means you can
 use statements like the following:
 
   Include "/etc/collectd.d/*.conf"
 
+If the C<fnmatch> function is available on your system, a shell-like wildcard
+I<pattern> may be specified to filter which files to include. This may be used
+in combination with recursively including a directory to easily be able to
+arbitrarily mix configuration files and other documents (e.g. README files).
+The following statement is similar to the example above but includes all files
+matching C<*.conf> in any subdirectory of C</etc/collectd.d>:
+
+  Include "/etc/collectd.d" "*.conf"
+
 If more than one files are included by a single B<Include> option, the files
 will be included in lexicographical order (as defined by the C<strcmp>
 function). Thus, you can e.E<nbsp>g. use numbered prefixes to specify the
 order in which the files are loaded.
 
 To prevent loops and shooting yourself in the foot in interesting ways the
@@ -169,14 +178,20 @@
 see L<collectd-threshold(5)> for details.
 
 =item B<ReadThreads> I<Num>
 
 Number of threads to start for reading plugins. The default value is B<5>, but
 you may want to increase this if you have more than five plugins that take a
-long time to read. Mostly those are plugin that do network-IO. Setting this to
-a value higher than the number of plugins you've loaded is totally useless.
+long time to read. Mostly those are plugins that do network-IO. Setting this to
+a value higher than the number of registered read callbacks is not recommended.
+
+=item B<WriteThreads> I<Num>
+
+Number of threads to start for dispatching value lists to write plugins. The
+default value is B<5>, but you may want to increase this if you have more than
+five plugins that may take relatively long to write to.
 
 =item B<Hostname> I<Name>
 
 Sets the hostname that identifies a host. If you omit this setting, the
 hostname will be determined using the L<gethostname(2)> system call.
 
@@ -294,17 +309,78 @@
 
 =item B<TypeInstance> I<TypeInstance>
 
 Selects the value lists to be added to this aggregation. B<Type> must be a
 valid data set name, see L<types.db(5)> for details.
 
+If the string starts with and ends with a slash (C</>), the string is
+interpreted as a I<regular expression>. The regex flavor used are POSIX
+extended regular expressions as described in L<regex(7)>. Example usage:
+
+ Host "/^db[0-9]\\.example\\.com$/"
+
 =item B<GroupBy> B<Host>|B<Plugin>|B<PluginInstance>|B<TypeInstance>
 
 Group valued by the specified field. The B<GroupBy> option may be repeated to
 group by multiple fields.
 
+=item B<SetHost> I<Host>
+
+=item B<SetPlugin> I<Plugin>
+
+=item B<SetPluginInstance> I<PluginInstance>
+
+=item B<SetTypeInstance> I<TypeInstance>
+
+Sets the appropriate part of the identifier to the provided string.
+
+The I<PluginInstance> should include the placeholder C<%{aggregation}> which
+will be replaced with the aggregation function, e.g. "average". Not including
+the placeholder will result in duplication warnings and/or messed up values if
+more than one aggregation function are enabled.
+
+The following example calculates the average usage of all "even" CPUs:
+
+ <Plugin "aggregation">
+   <Aggregation>
+     Plugin "cpu"
+     PluginInstance "/[0,2,4,6,8]$/"
+     Type "cpu"
+     
+     SetPlugin "cpu"
+     SetPluginInstance "even-%{aggregation}"
+     
+     GroupBy "Host"
+     GroupBy "TypeInstance"
+     
+     CalculateAverage true
+   </Aggregation>
+ </Plugin>
+
+This will create the files:
+
+=over 4
+
+=item
+
+foo.example.com/cpu-even-average/cpu-idle
+
+=item
+
+foo.example.com/cpu-even-average/cpu-system
+
+=item
+
+foo.example.com/cpu-even-average/cpu-user
+
+=item
+
+...
+
+=back
+
 =item B<CalculateNum> B<true>|B<false>
 
 =item B<CalculateSum> B<true>|B<false>
 
 =item B<CalculateAverage> B<true>|B<false>
 
@@ -568,12 +644,18 @@
 B<apcupsd> can handle it.
 
 =item B<Port> I<Port>
 
 TCP-Port to connect to. Defaults to B<3551>.
 
+=item B<ReportSeconds> B<true|false>
+
+If set to B<true>, the time reported in the C<timeleft> metric will be
+converted to seconds. This is the recommended setting. If set to B<false>, the
+default for backwards compatibility, the time will be reported in minutes.
+
 =back
 
 =head2 Plugin C<ascent>
 
 This plugin collects information about an Ascent server, a free server for the
 "World of Warcraft" game. This plugin gathers the information by fetching the
@@ -859,12 +941,25 @@
 =item B<CACert> I<file>
 
 File that holds one or more SSL certificates. If you want to use HTTPS you will
 possibly need this option. What CA certificates come bundled with C<libcurl>
 and are checked by default depends on the distribution you use.
 
+=item B<Header> I<Header>
+
+A HTTP header to add to the request. Multiple headers are added if this option
+is specified more than once.
+
+=item B<Post> I<Body>
+
+Specifies that the HTTP operation should be a POST instead of a GET. The
+complete data to be posted is given as the argument.  This option will usually
+need to be accompanied by a B<Header> option to set an appropriate
+C<Content-Type> for the post body (e.g. to
+C<application/x-www-form-urlencoded>).
+
 =item B<MeasureResponseTime> B<true>|B<false>
 
 Measure response time for the request. If this setting is enabled, B<Match>
 blocks (see below) are optional. Disabled by default.
 
 =item B<E<lt>MatchE<gt>>
@@ -917,37 +1012,21 @@
 
 =item B<Instance> I<Instance>
 
 Sets the plugin instance to I<Instance>.
 
 =item B<User> I<Name>
-
-Username to use if authorization is required to read the page.
-
 =item B<Password> I<Password>
-
-Password to use if authorization is required to read the page.
-
 =item B<VerifyPeer> B<true>|B<false>
-
-Enable or disable peer SSL certificate verification. See
-L<http://curl.haxx.se/docs/sslcerts.html> for details. Enabled by default.
-
 =item B<VerifyHost> B<true>|B<false>
-
-Enable or disable peer host name verification. If enabled, the plugin checks if
-the C<Common Name> or a C<Subject Alternate Name> field of the SSL certificate
-matches the host name provided by the B<URL> option. If this identity check
-fails, the connection is aborted. Obviously, only works when connecting to a
-SSL enabled server. Enabled by default.
-
 =item B<CACert> I<file>
+=item B<Header> I<Header>
+=item B<Post> I<Body>
 
-File that holds one or more SSL certificates. If you want to use HTTPS you will
-possibly need this option. What CA certificates come bundled with C<libcurl>
-and are checked by default depends on the distribution you use.
+These options behave exactly equivalent to the appropriate options of the
+I<cURL> plugin. Please see there for a detailed description.
 
 =back
 
 The following options are valid within B<Key> blocks:
 
 =over 4
@@ -1010,20 +1089,40 @@
 
 =item B<Instance> I<Instance>
 
 Use I<Instance> as the plugin instance when submitting values. Defaults to an
 empty string (no plugin instance).
 
+=item B<Namespace> I<Prefix> I<URL>
+
+If an XPath expression references namespaces, they must be specified
+with this option. I<Prefix> is the "namespace prefix" used in the XML document.
+I<URL> is the "namespace name", an URI reference uniquely identifying the
+namespace. The option can be repeated to register multiple namespaces.
+
+Examples:
+
+  Namespace "s" "http://schemas.xmlsoap.org/soap/envelope/"
+  Namespace "m" "http://www.w3.org/1998/Math/MathML"
+
 =item B<User> I<User>
+
 =item B<Password> I<Password>
+
 =item B<VerifyPeer> B<true>|B<false>
+
 =item B<VerifyHost> B<true>|B<false>
+
 =item B<CACert> I<CA Cert File>
 
+=item B<Header> I<Header>
+
+=item B<Post> I<Body>
+
 These options behave exactly equivalent to the appropriate options of the
-I<cURL> and I<cURL-JSON> plugins. Please see there for a detailed description.
+I<cURL plugin>. Please see there for a detailed description.
 
 =item E<lt>B<XPath> I<XPath-expression>E<gt>
 
 Within each B<URL> block, there must be one or more B<XPath> blocks. Each
 B<XPath> block specifies how to get one type of information. The string
 argument must be a valid XPath expression which returns a list of "base
@@ -1281,17 +1380,29 @@
 
 Sets driver-specific options. What option a driver supports can be found in the
 documentation for each driver, somewhere at
 L<http://libdbi-drivers.sourceforge.net/>. However, the options "host",
 "username", "password", and "dbname" seem to be deE<nbsp>facto standards.
 
+DBDs can register two types of options: String options and numeric options. The
+plugin will use the C<dbi_conn_set_option> function when the configuration
+provides a string and the C<dbi_conn_require_option_numeric> function when the
+configuration provides a number. So these two lines will actually result in
+different calls being used:
+
+  DriverOption "Port" 1234      # numeric
+  DriverOption "Port" "1234"    # string
+
 Unfortunately, drivers are not too keen to report errors when an unknown option
 is passed to them, so invalid settings here may go unnoticed. This is not the
 plugin's fault, it will report errors if it gets them from the libraryE<nbsp>/
 the driver. If a driver complains about an option, the plugin will dump a
-complete list of all options understood by that driver to the log.
+complete list of all options understood by that driver to the log. There is no
+way to programatically find out if an option expects a string or a numeric
+argument, so you will have to refer to the appropriate DBD's documentation to
+find this out. Sorry.
 
 =item B<SelectDB> I<Database>
 
 In some cases, the database name you connect with is not the database name you
 want to use for querying data. If this option is set, the plugin will "select"
 (switch to) that database after the connection is established.
@@ -1300,12 +1411,17 @@
 
 Associates the query named I<QueryName> with this database connection. The
 query needs to be defined I<before> this statement, i.E<nbsp>e. all query
 blocks you want to refer to must be placed above the database block you want to
 refer to them from.
 
+=item B<Host> I<Hostname>
+
+Sets the B<host> field of I<value lists> to I<Hostname> when dispatching
+values. Defaults to the global hostname setting.
+
 =back
 
 =head2 Plugin C<df>
 
 =over 4
 
@@ -2414,30 +2530,65 @@
       IgnoreSelectedCapacity false
       GetSnapshot "vol1"
       GetSnapshot "vol3"
       IgnoreSelectedSnapshot false
     </VolumeUsage>
     
+    <Quota>
+      Interval 60
+    </Quota>
+    
+    <Snapvault>
+      Interval 30
+    </Snapvault>
+    
     <System>
       Interval 30
       GetCPULoad     true
       GetInterfaces  true
       GetDiskOps     true
       GetDiskIO      true
     </System>
+
+    <VFiler vfilerA>
+      Interval 60
+
+      SnapVault true
+      # ...
+    </VFiler>
    </Host>
  </Plugin>
 
 The netapp plugin accepts the following configuration options:
 
 =over 4
 
 =item B<Host> I<Name>
 
 A host block defines one NetApp filer. It will appear in collectd with the name
-you specify here which does not have to be its real name nor its hostname.
+you specify here which does not have to be its real name nor its hostname (see
+the B<Address> option below).
+
+=item B<VFiler> I<Name>
+
+A B<VFiler> block may only be used inside a host block. It accepts all the
+same options as the B<Host> block (except for cascaded B<VFiler> blocks) and
+will execute all NetApp API commands in the context of the specified
+VFiler(R). It will appear in collectd with the name you specify here which
+does not have to be its real name. The VFiler name may be specified using the
+B<VFilerName> option. If this is not specified, it will default to the name
+you specify here.
+
+The VFiler block inherits all connection related settings from the surrounding
+B<Host> block (which appear before the B<VFiler> block) but they may be
+overwritten inside the B<VFiler> block.
+
+This feature is useful, for example, when using a VFiler as SnapVault target
+(supported since OnTap 8.1). In that case, the SnapVault statistics are not
+available in the host filer (vfiler0) but only in the respective VFiler
+context.
 
 =item B<Protocol> B<httpd>|B<http>
 
 The protocol collectd will use to query this host.
 
 Optional
@@ -2475,12 +2626,25 @@
 The username and password to use to login to the NetApp.
 
 Mandatory
 
 Type: string
 
+=item B<VFilerName> I<Name>
+
+The name of the VFiler in which context to execute API commands. If not
+specified, the name provided to the B<VFiler> block will be used instead.
+
+Optional
+
+Type: string
+
+Default: name of the B<VFiler> block
+
+B<Note:> This option may only be used inside B<VFiler> blocks.
+
 =item B<Interval> I<Interval>
 
 B<TODO>
 
 =back
 
@@ -2805,12 +2969,44 @@
 option or to ignore those volumes. B<IgnoreSelectedSnapshot> defaults to
 B<false>. However, if no B<GetSnapshot> option is specified at all, all
 capacities will be selected anyway.
 
 =back
 
+=head3 The Quota block
+
+This will collect (tree) quota statistics (used disk space and number of used
+files). This mechanism is useful to get usage information for single qtrees.
+In case the quotas are not used for any other purpose, an entry similar to the
+following in C</etc/quotas> would be sufficient:
+
+  /vol/volA/some_qtree tree - - - - -
+
+After adding the entry, issue C<quota on -w volA> on the NetApp filer.
+
+=over 4
+
+=item B<Interval> I<Seconds>
+
+Collect SnapVault(R) statistics every I<Seconds> seconds.
+
+=back
+
+=head3 The SnapVault block
+
+This will collect statistics about the time and traffic of SnapVault(R)
+transfers.
+
+=over 4
+
+=item B<Interval> I<Seconds>
+
+Collect SnapVault(R) statistics every I<Seconds> seconds.
+
+=back
+
 =head2 Plugin C<netlink>
 
 The C<netlink> plugin uses a netlink socket to query the Linux kernel about
 statistics of various interface and routing aspects.
 
 =over 4
@@ -4462,12 +4658,22 @@
 =item B<CreateFiles> B<true>|B<false>
 
 Enables or disables the creation of RRD files. If the daemon is not running
 locally, or B<DataDir> is set to a relative path, this will not work as
 expected. Default is B<true>.
 
+=item B<CreateFilesAsync> B<false>|B<true>
+
+When enabled, new RRD files are enabled asynchronously, using a separate thread
+that runs in the background. This prevents writes to block, which is a problem
+especially when many hundreds of files need to be created at once. However,
+since the purpose of creating the files asynchronously is I<not> to block until
+the file is available, values before the file is available will be discarded.
+When disabled (the default) files are created synchronously, blocking for a
+short while, while the file is being written.
+
 =item B<StepSize> I<Seconds>
 
 B<Force> the stepsize of newly created RRD-files. Ideally (and per default)
 this setting is unset and the stepsize is set to the interval in which the data
 is collected. Do not use this option unless you absolutely have to for some
 reason. Setting this option may cause problems with the C<snmp plugin>, the
@@ -4519,14 +4725,24 @@
 can safely ignore these settings.
 
 =over 4
 
 =item B<DataDir> I<Directory>
 
-Set the directory to store RRD-files under. Per default RRD-files are generated
-beneath the daemon's working directory, i.E<nbsp>e. the B<BaseDir>.
+Set the directory to store RRD files under. By default RRD files are generated
+beneath the daemon's working directory, i.e. the B<BaseDir>.
+
+=item B<CreateFilesAsync> B<false>|B<true>
+
+When enabled, new RRD files are enabled asynchronously, using a separate thread
+that runs in the background. This prevents writes to block, which is a problem
+especially when many hundreds of files need to be created at once. However,
+since the purpose of creating the files asynchronously is I<not> to block until
+the file is available, values before the file is available will be discarded.
+When disabled (the default) files are created synchronously, blocking for a
+short while, while the file is being written.
 
 =item B<StepSize> I<Seconds>
 
 B<Force> the stepsize of newly created RRD-files. Ideally (and per default)
 this setting is unset and the stepsize is set to the interval in which the data
 is collected. Do not use this option unless you absolutely have to for some
@@ -4541,13 +4757,13 @@
 a very good reason to do so.
 
 =item B<RRARows> I<NumRows>
 
 The C<rrdtool plugin> calculates the number of PDPs per CDP based on the
 B<StepSize>, this setting and a timespan. This plugin creates RRD-files with
-three times five RRAs, i. e. five RRAs with the CFs B<MIN>, B<AVERAGE>, and
+three times five RRAs, i.e. five RRAs with the CFs B<MIN>, B<AVERAGE>, and
 B<MAX>. The five RRAs are optimized for graphs covering one hour, one day, one
 week, one month, and one year.
 
 So for each timespan, it calculates how many PDPs need to be consolidated into
 one CDP by calculating:
   number of PDPs = timespan / (stepsize * rrarows)
@@ -4937,12 +5153,103 @@
 =item B<Instance> I<TypeInstance>
 
 This optional setting sets the type instance to use.
 
 =back
 
+=head2 Plugin C<tail_csv>
+
+The I<tail_csv plugin> reads files in the CSV format, e.g. the statistics file
+written by I<Snort>.
+
+B<Synopsis:>
+
+ <Plugin "tail_csv">
+   <Metric "snort-dropped">
+       Type "percent"
+       Instance "dropped"
+       Index 1
+   </Metric>
+   <File "/var/log/snort/snort.stats">
+       Instance "snort-eth0"
+       Interval 600
+       Collect "snort-dropped"
+   </File>
+ </Plugin>
+
+The configuration consists of one or more B<Metric> blocks that define an index
+into the line of the CSV file and how this value is mapped to I<collectd's>
+internal representation. These are followed by one or more B<Instance> blocks
+which configure which file to read, in which interval and which metrics to
+extract.
+
+=over 4
+
+=item E<lt>B<Metric> I<Name>E<gt>
+
+The B<Metric> block configures a new metric to be extracted from the statistics
+file and how it is mapped on I<collectd's> data model. The string I<Name> is
+only used inside the B<Instance> blocks to refer to this block, so you can use
+one B<Metric> block for multiple CSV files.
+
+=over 4
+
+=item B<Type> I<Type>
+
+Configures which I<Type> to use when dispatching this metric. Types are defined
+in the L<types.db(5)> file, see the appropriate manual page for more
+information on specifying types. Only types with a single I<data source> are
+supported by the I<tail_csv plugin>. The information whether the value is an
+absolute value (i.e. a C<GAUGE>) or a rate (i.e. a C<DERIVE>) is taken from the
+I<Type's> definition.
+
+=item B<Instance> I<TypeInstance>
+
+If set, I<TypeInstance> is used to populate the type instance field of the
+created value lists. Otherwise, no type instance is used.
+
+=item B<ValueFrom> I<Index>
+
+Configure to read the value from the field with the zero-based index I<Index>.
+If the value is parsed as signed integer, unsigned integer or double depends on
+the B<Type> setting, see above.
+
+=back
+
+=item E<lt>B<File> I<Path>E<gt>
+
+Each B<File> block represents one CSV file to read. There must be at least one
+I<File> block but there can be multiple if you have multiple CSV files.
+
+=over 4
+
+=item B<Instance> I<PluginInstance>
+
+Sets the I<plugin instance> used when dispatching the values.
+
+=item B<Collect> I<Metric>
+
+Specifies which I<Metric> to collect. This option must be specified at least
+once, and you can use this option multiple times to specify more than one
+metric to be extracted from this statistic file.
+
+=item B<Interval> I<Seconds>
+
+Configures the interval in which to read values from this instance / file.
+Defaults to the plugin's default interval.
+
+=item B<TimeFrom> I<Index>
+
+Rather than using the local time when dispatching a value, read the timestamp
+from the field with the zero-based index I<Index>. The value is interpreted as
+seconds since epoch. The value is parsed as a double and may be factional.
+
+=back
+
+=back
+
 =head2 Plugin C<teamspeak2>
 
 The C<teamspeak2 plugin> connects to the query port of a teamspeak2 server and
 polls interesting global and virtual server data. The plugin can query only one
 physical server but unlimited virtual servers. You can use the following
 options to configure it:
@@ -5270,19 +5577,22 @@
 portE<nbsp>2003). The data will be sent in blocks of at most 1428 bytes to
 minimize the number of network packets.
 
 Synopsis:
 
  <Plugin write_graphite>
-   <Carbon>
+   <Node "example">
      Host "localhost"
      Port "2003"
      Prefix "collectd"
-   </Carbon>
+   </Node>
  </Plugin>
 
+The configuration consists of one or more E<lt>B<Node>E<nbsp>I<Name>E<gt>
+blocks. Inside the B<Node> blocks, the following options are recognized:
+
 =over 4
 
 =item B<Host> I<Address>
 
 Hostname or address to connect to. Defaults to C<localhost>.
 
@@ -5366,12 +5676,22 @@
 =item B<StoreRates> B<false>|B<true>
 
 If set to B<true> (the default), convert counter values to rates. If set to
 B<false> counter values are stored as is, i.e. as an increasing integer
 number.
 
+=item B<Database> I<Database>
+
+=item B<User> I<User>
+
+=item B<Password> I<Password>
+
+Sets the information used when authenticating to a I<MongoDB> database. The
+fields are optional (in which case no authentication is attempted), but if you
+want to use authentication all three fields must be set.
+
 =back
 
 =head2 Plugin C<write_http>
 
 This output plugin submits values to an http server by POST them using the
 PUTVAL plain-text protocol. Each destination you want to post data to needs to
@@ -5432,12 +5752,83 @@
 If set to B<true>, convert counter values to rates. If set to B<false> (the
 default) counter values are stored as is, i.E<nbsp>e. as an increasing integer
 number.
 
 =back
 
+=head2 Plugin C<write_riemann>
+
+The I<write_riemann plugin> will send values to I<Riemann>, a powerfull stream
+aggregation and monitoring system. The plugin sends I<Protobuf> encoded data to
+I<Riemann> using UDP packets.
+
+Synopsis:
+
+ <Plugin "write_riemann">
+   <Node "example">
+     Host "localhost"
+     Port "5555"
+     Protocol UDP
+     StoreRates true
+     AlwaysAppendDS false
+     Delay 10
+   </Node>
+   Tag "foobar"
+ </Plugin>
+
+The following options are understood by the I<write_riemann plugin>:
+
+=over 4
+
+=item E<lt>B<Node> I<Name>E<gt>
+
+The plugin's configuration consists of one or more B<Node> blocks. Each block
+is given a unique I<Name> and specifies one connection to an instance of
+I<Riemann>. Indise the B<Node> block, the following per-connection options are
+understood:
+
+=over 4
+
+=item B<Host> I<Address>
+
+Hostname or address to connect to. Defaults to C<localhost>.
+
+=item B<Port> I<Service>
+
+Service name or port number to connect to. Defaults to C<5555>.
+
+=item B<Protocol> B<UDP>|B<TCP>
+
+Specify the protocol to use when communicating with I<Riemann>. Defaults to
+B<UDP>.
+
+=item B<StoreRates> B<true>|B<false>
+
+If set to B<true> (the default), convert counter values to rates. If set to
+B<false> counter values are stored as is, i.e. as an increasing integer number.
+
+This will be reflected in the C<ds_type> tag: If B<StoreRates> is enabled,
+converted values will have "rate" appended to the data source type, e.g.
+C<ds_type:derive:rate>.
+
+=item B<AlwaysAppendDS> B<false>|B<true>
+
+If set the B<true>, append the name of the I<Data Source> (DS) to the
+"service", i.e. the field that, together with the "host" field, uniquely
+identifies a metric in I<Riemann>. If set to B<false> (the default), this is
+only done when there is more than one DS.
+
+=back
+
+=item B<Tag> I<String>
+
+Add the given string as an additional tag to the metric being sent to
+I<Riemann>.
+
+=back
+
 =head1 THRESHOLD CONFIGURATION
 
 Starting with version C<4.3.0> collectd has support for B<monitoring>. By that
 we mean that the values are not only stored or sent somewhere, but that they
 are judged and, if a problem is recognized, acted upon. The only action
 collectd takes itself is to generate and dispatch a "notification". Plugins can
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/collectd.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/collectd.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/collectd.h	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/collectd.h	2013-04-09 23:18:59.000000000 +0800
@@ -259,14 +259,12 @@
 #endif
 
 #ifndef COLLECTD_DEFAULT_INTERVAL
 # define COLLECTD_DEFAULT_INTERVAL 10.0
 #endif
 
-#define STATIC_ARRAY_LEN(array) (sizeof (array) / sizeof ((array)[0]))
-
 /* Remove GNU specific __attribute__ settings when using another compiler */
 #if !__GNUC__
 # define __attribute__(x) /**/
 #endif
 
 #if defined(COLLECT_DEBUG) && COLLECT_DEBUG && defined(__GNUC__) && __GNUC__
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/common.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/common.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/common.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/common.c	2013-04-09 23:18:59.000000000 +0800
@@ -358,12 +358,28 @@
 
 		memmove (buf + i + 1, buf + i + 2, buf_len - i - 2);
 	}
 	return (0);
 } /* int strunescape */
 
+size_t strstripnewline (char *buffer)
+{
+	size_t buffer_len = strlen (buffer);
+
+	while (buffer_len > 0)
+	{
+		if ((buffer[buffer_len - 1] != '\n')
+				&& (buffer[buffer_len - 1] != '\r'))
+			break;
+		buffer[buffer_len] = 0;
+		buffer_len--;
+	}
+
+	return (buffer_len);
+} /* size_t strstripnewline */
+
 int escape_slashes (char *buf, int buf_len)
 {
 	int i;
 
 	if (strcmp (buf, "/") == 0)
 	{
@@ -1393,6 +1409,38 @@
 	if ((endptr == string) || (errno != 0))
 		return (-1);
 
 	*ret_value = tmp;
 	return (0);
 } /* }}} int strtoderive */
+
+int strarray_add (char ***ret_array, size_t *ret_array_len, char const *str) /* {{{ */
+{
+	char **array;
+	size_t array_len = *ret_array_len;
+
+	if (str == NULL)
+		return (EINVAL);
+
+	array = realloc (*ret_array,
+            (array_len + 1) * sizeof (*array));
+	if (array == NULL)
+		return (ENOMEM);
+	*ret_array = array;
+
+	array[array_len] = strdup (str);
+	if (array[array_len] == NULL)
+		return (ENOMEM);
+
+	array_len++;
+        *ret_array_len = array_len;
+	return (0);
+} /* }}} int strarray_add */
+
+void strarray_free (char **array, size_t array_len) /* {{{ */
+{
+	size_t i;
+
+	for (i = 0; i < array_len; i++)
+		sfree (array[i]);
+	sfree (array);
+} /* }}} void strarray_free */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/common.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/common.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/common.h	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/common.h	2013-04-09 23:18:59.000000000 +0800
@@ -205,12 +205,19 @@
  *
  * RETURN VALUE
  *   Returns zero upon success, a value less than zero else.
  */
 int strunescape (char *buf, size_t buf_len);
 
+/**
+ * Removed trailing newline characters (CR and LF) from buffer, which must be
+ * null terminated. Returns the length of the resulting string.
+ */
+__attribute__((nonnull (1)))
+size_t strstripnewline (char *buffer);
+
 /*
  * NAME
  *   timeval_cmp
  *
  * DESCRIPTION
  *   Compare the two time values `tv0' and `tv1' and store the absolut value
@@ -314,7 +321,10 @@
 int service_name_to_port_number (const char *service_name);
 
 /** Parse a string to a derive_t value. Returns zero on success or non-zero on
  * failure. If failure is returned, ret_value is not touched. */
 int strtoderive (const char *string, derive_t *ret_value);
 
+int strarray_add (char ***ret_array, size_t *ret_array_len, char const *str);
+void strarray_free (char **array, size_t array_len);
+
 #endif /* COMMON_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/configfile.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/configfile.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/configfile.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/configfile.c	2013-04-09 23:18:59.000000000 +0800
@@ -32,12 +32,20 @@
 #include "filter_chain.h"
 
 #if HAVE_WORDEXP_H
 # include <wordexp.h>
 #endif /* HAVE_WORDEXP_H */
 
+#if HAVE_FNMATCH_H
+# include <fnmatch.h>
+#endif /* HAVE_FNMATCH_H */
+
+#if HAVE_LIBGEN_H
+# include <libgen.h>
+#endif /* HAVE_LIBGEN_H */
+
 #define ESCAPE_NULL(str) ((str) == NULL ? "(null)" : (str))
 
 /*
  * Private types
  */
 typedef struct cf_callback
@@ -87,27 +95,28 @@
 static cf_value_map_t cf_value_map[] =
 {
 	{"TypesDB",    dispatch_value_typesdb},
 	{"PluginDir",  dispatch_value_plugindir},
 	{"LoadPlugin", dispatch_loadplugin}
 };
-static int cf_value_map_num = STATIC_ARRAY_LEN (cf_value_map);
+static int cf_value_map_num = STATIC_ARRAY_SIZE (cf_value_map);
 
 static cf_global_option_t cf_global_options[] =
 {
 	{"BaseDir",     NULL, PKGLOCALSTATEDIR},
 	{"PIDFile",     NULL, PIDFILE},
 	{"Hostname",    NULL, NULL},
 	{"FQDNLookup",  NULL, "true"},
 	{"Interval",    NULL, NULL},
 	{"ReadThreads", NULL, "5"},
+	{"WriteThreads", NULL, "5"},
 	{"Timeout",     NULL, "2"},
 	{"PreCacheChain",  NULL, "PreCache"},
 	{"PostCacheChain", NULL, "PostCache"}
 };
-static int cf_global_options_num = STATIC_ARRAY_LEN (cf_global_options);
+static int cf_global_options_num = STATIC_ARRAY_SIZE (cf_global_options);
 
 static int cf_default_typesdb = 1;
 
 /*
  * Functions to handle register/unregister, search, and other plugin related
  * stuff
@@ -532,26 +541,27 @@
 	dst->children_num += src->children_num;
 
 	return (0);
 } /* int cf_ci_append_children */
 
 #define CF_MAX_DEPTH 8
-static oconfig_item_t *cf_read_generic (const char *path, int depth);
+static oconfig_item_t *cf_read_generic (const char *path,
+		const char *pattern, int depth);
 
 static int cf_include_all (oconfig_item_t *root, int depth)
 {
 	int i;
 
 	for (i = 0; i < root->children_num; i++)
 	{
 		oconfig_item_t *new;
 		oconfig_item_t *old;
 
-		/* Ignore all blocks, including `Include' blocks. */
-		if (root->children[i].children_num != 0)
-			continue;
+		char *pattern = NULL;
+
+		int j;
 
 		if (strcasecmp (root->children[i].key, "Include") != 0)
 			continue;
 
 		old = root->children + i;
 
@@ -559,13 +569,26 @@
 				|| (old->values[0].type != OCONFIG_TYPE_STRING))
 		{
 			ERROR ("configfile: `Include' needs exactly one string argument.");
 			continue;
 		}
 
-		new = cf_read_generic (old->values[0].value.string, depth + 1);
+		for (j = 0; j < old->children_num; ++j)
+		{
+			oconfig_item_t *child = old->children + j;
+
+			if (strcasecmp (child->key, "Filter") == 0)
+				cf_util_get_string (child, &pattern);
+			else
+				ERROR ("configfile: Option `%s' not allowed in <Include> block.",
+						child->key);
+		}
+
+		new = cf_read_generic (old->values[0].value.string, pattern, depth + 1);
+		sfree (pattern);
+
 		if (new == NULL)
 			continue;
 
 		/* Now replace the i'th child in `root' with `new'. */
 		cf_ci_replace_child (root, new, i);
 
@@ -576,18 +599,40 @@
 		sfree (new);
 	} /* for (i = 0; i < root->children_num; i++) */
 
 	return (0);
 } /* int cf_include_all */
 
-static oconfig_item_t *cf_read_file (const char *file, int depth)
+static oconfig_item_t *cf_read_file (const char *file,
+		const char *pattern, int depth)
 {
 	oconfig_item_t *root;
 
 	assert (depth < CF_MAX_DEPTH);
 
+	if (pattern != NULL) {
+#if HAVE_FNMATCH_H && HAVE_LIBGEN_H
+		char *tmp = sstrdup (file);
+		char *filename = basename (tmp);
+
+		if ((filename != NULL) && (fnmatch (pattern, filename, 0) != 0)) {
+			DEBUG ("configfile: Not including `%s' because it "
+					"does not match pattern `%s'.",
+					filename, pattern);
+			free (tmp);
+			return (NULL);
+		}
+
+		free (tmp);
+#else
+		ERROR ("configfile: Cannot apply pattern filter '%s' "
+				"to file '%s': functions basename() and / or "
+				"fnmatch() not available.", pattern, file);
+#endif /* HAVE_FNMATCH_H && HAVE_LIBGEN_H */
+	}
+
 	root = oconfig_parse_file (file);
 	if (root == NULL)
 	{
 		ERROR ("configfile: Cannot read file `%s'.", file);
 		return (NULL);
 	}
@@ -599,13 +644,14 @@
 
 static int cf_compare_string (const void *p1, const void *p2)
 {
 	return strcmp (*(const char **) p1, *(const char **) p2);
 }
 
-static oconfig_item_t *cf_read_dir (const char *dir, int depth)
+static oconfig_item_t *cf_read_dir (const char *dir,
+		const char *pattern, int depth)
 {
 	oconfig_item_t *root = NULL;
 	DIR *dh;
 	struct dirent *de;
 	char **filenames = NULL;
 	int filenames_num = 0;
@@ -674,13 +720,13 @@
 
 	for (i = 0; i < filenames_num; ++i)
 	{
 		oconfig_item_t *temp;
 		char *name = filenames[i];
 
-		temp = cf_read_generic (name, depth);
+		temp = cf_read_generic (name, pattern, depth);
 		if (temp == NULL)
 		{
 			/* An error should already have been reported. */
 			sfree (name);
 			continue;
 		}
@@ -705,13 +751,14 @@
  * There are two versions of this function: If `wordexp' exists shell wildcards
  * will be expanded and the function will include all matches found. If
  * `wordexp' (or, more precisely, it's header file) is not available the
  * simpler function is used which does not do any such expansion.
  */
 #if HAVE_WORDEXP_H
-static oconfig_item_t *cf_read_generic (const char *path, int depth)
+static oconfig_item_t *cf_read_generic (const char *path,
+		const char *pattern, int depth)
 {
 	oconfig_item_t *root = NULL;
 	int status;
 	const char *path_ptr;
 	wordexp_t we;
 	size_t i;
@@ -758,15 +805,15 @@
 					path_ptr,
 					sstrerror (errno, errbuf, sizeof (errbuf)));
 			continue;
 		}
 
 		if (S_ISREG (statbuf.st_mode))
-			temp = cf_read_file (path_ptr, depth);
+			temp = cf_read_file (path_ptr, pattern, depth);
 		else if (S_ISDIR (statbuf.st_mode))
-			temp = cf_read_dir (path_ptr, depth);
+			temp = cf_read_dir (path_ptr, pattern, depth);
 		else
 		{
 			WARNING ("configfile: %s is neither a file nor a "
 					"directory.", path);
 			continue;
 		}
@@ -791,13 +838,14 @@
 
 	return (root);
 } /* oconfig_item_t *cf_read_generic */
 /* #endif HAVE_WORDEXP_H */
 
 #else /* if !HAVE_WORDEXP_H */
-static oconfig_item_t *cf_read_generic (const char *path, int depth)
+static oconfig_item_t *cf_read_generic (const char *path,
+		const char *pattern, int depth)
 {
 	struct stat statbuf;
 	int status;
 
 	if (depth >= CF_MAX_DEPTH)
 	{
@@ -814,15 +862,15 @@
 				path,
 				sstrerror (errno, errbuf, sizeof (errbuf)));
 		return (NULL);
 	}
 
 	if (S_ISREG (statbuf.st_mode))
-		return (cf_read_file (path, depth));
+		return (cf_read_file (path, pattern, depth));
 	else if (S_ISDIR (statbuf.st_mode))
-		return (cf_read_dir (path, depth));
+		return (cf_read_dir (path, pattern, depth));
 
 	ERROR ("configfile: %s is neither a file nor a directory.", path);
 	return (NULL);
 } /* oconfig_item_t *cf_read_generic */
 #endif /* !HAVE_WORDEXP_H */
 
@@ -990,13 +1038,13 @@
 
 int cf_read (char *filename)
 {
 	oconfig_item_t *conf;
 	int i;
 
-	conf = cf_read_generic (filename, 0 /* depth */);
+	conf = cf_read_generic (filename, /* pattern = */ NULL, /* depth = */ 0);
 	if (conf == NULL)
 	{
 		ERROR ("Unable to read config file %s.", filename);
 		return (-1);
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/config.h.in	2013-04-09 09:15:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/config.h.in	2013-04-10 23:42:56.000000000 +0800
@@ -130,12 +130,15 @@
 /* Define to 1 if the system has the type `error_t'. */
 #undef HAVE_ERROR_T
 
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
+/* Define to 1 if you have the <fnmatch.h> header file. */
+#undef HAVE_FNMATCH_H
+
 /* Define to 1 if you have the <fshelp.h> header file. */
 #undef HAVE_FSHELP_H
 
 /* Define to 1 if you have the <fs_info.h> header file. */
 #undef HAVE_FS_INFO_H
 
@@ -181,12 +184,16 @@
 /* Define to 1 if you have the `getvfsstat' function. */
 #undef HAVE_GETVFSSTAT
 
 /* Define to 1 if you have the <gm_protocol.h> header file. */
 #undef HAVE_GM_PROTOCOL_H
 
+/* Define to 1 if you have the <google/protobuf-c/protobuf-c.h> header file.
+   */
+#undef HAVE_GOOGLE_PROTOBUF_C_PROTOBUF_C_H
+
 /* Define to 1 if you have the <grp.h> header file. */
 #undef HAVE_GRP_H
 
 /* Define to 1 if you have the `host_statistics' function. */
 #undef HAVE_HOST_STATISTICS
 
@@ -853,12 +860,15 @@
 /* Define to 1 if the table plugin is enabled. */
 #undef HAVE_PLUGIN_TABLE
 
 /* Define to 1 if the tail plugin is enabled. */
 #undef HAVE_PLUGIN_TAIL
 
+/* Define to 1 if the tail_csv plugin is enabled. */
+#undef HAVE_PLUGIN_TAIL_CSV
+
 /* Define to 1 if the tape plugin is enabled. */
 #undef HAVE_PLUGIN_TAPE
 
 /* Define to 1 if the target_notification plugin is enabled. */
 #undef HAVE_PLUGIN_TARGET_NOTIFICATION
 
@@ -925,12 +935,15 @@
 /* Define to 1 if the write_mongodb plugin is enabled. */
 #undef HAVE_PLUGIN_WRITE_MONGODB
 
 /* Define to 1 if the write_redis plugin is enabled. */
 #undef HAVE_PLUGIN_WRITE_REDIS
 
+/* Define to 1 if the write_riemann plugin is enabled. */
+#undef HAVE_PLUGIN_WRITE_RIEMANN
+
 /* Define to 1 if the xmms plugin is enabled. */
 #undef HAVE_PLUGIN_XMMS
 
 /* Define to 1 if the zfs_arc plugin is enabled. */
 #undef HAVE_PLUGIN_ZFS_ARC
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/curl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/curl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/curl.c	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/curl.c	2013-04-09 23:18:59.000000000 +0800
@@ -57,12 +57,14 @@
   char *user;
   char *pass;
   char *credentials;
   int   verify_peer;
   int   verify_host;
   char *cacert;
+  struct curl_slist *headers;
+  char *post_body;
   int   response_time;
 
   CURL *curl;
   char curl_errbuf[CURL_ERROR_SIZE];
   char *buffer;
   size_t buffer_size;
@@ -145,12 +147,14 @@
 
   sfree (wp->url);
   sfree (wp->user);
   sfree (wp->pass);
   sfree (wp->credentials);
   sfree (wp->cacert);
+  sfree (wp->post_body);
+  curl_slist_free_all (wp->headers);
 
   sfree (wp->buffer);
 
   cc_web_match_free (wp->matches);
   cc_web_page_free (wp->next);
   sfree (wp);
@@ -170,12 +174,29 @@
   if (*dest == NULL)
     return (-1);
 
   return (0);
 } /* }}} int cc_config_add_string */
 
+static int cc_config_append_string (const char *name, struct curl_slist **dest, /* {{{ */
+    oconfig_item_t *ci)
+{
+  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING))
+  {
+    WARNING ("curl plugin: `%s' needs exactly one string argument.", name);
+    return (-1);
+  }
+
+  *dest = curl_slist_append(*dest, ci->values[0].value.string);
+  if (*dest == NULL)
+    return (-1);
+
+  return (0);
+} /* }}} int cc_config_append_string */
+
+
 static int cc_config_set_boolean (const char *name, int *dest, /* {{{ */
     oconfig_item_t *ci)
 {
   if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_BOOLEAN))
   {
     WARNING ("curl plugin: `%s' needs exactly one boolean argument.", name);
@@ -402,12 +423,16 @@
 
   curl_easy_setopt (wp->curl, CURLOPT_SSL_VERIFYPEER, (long) wp->verify_peer);
   curl_easy_setopt (wp->curl, CURLOPT_SSL_VERIFYHOST,
       wp->verify_host ? 2L : 0L);
   if (wp->cacert != NULL)
     curl_easy_setopt (wp->curl, CURLOPT_CAINFO, wp->cacert);
+  if (wp->headers != NULL)
+    curl_easy_setopt (wp->curl, CURLOPT_HTTPHEADER, wp->headers);
+  if (wp->post_body != NULL)
+    curl_easy_setopt (wp->curl, CURLOPT_POSTFIELDS, wp->post_body);
 
   return (0);
 } /* }}} int cc_page_init_curl */
 
 static int cc_config_add_page (oconfig_item_t *ci) /* {{{ */
 {
@@ -463,12 +488,16 @@
       status = cc_config_set_boolean (child->key, &page->response_time, child);
     else if (strcasecmp ("CACert", child->key) == 0)
       status = cc_config_add_string ("CACert", &page->cacert, child);
     else if (strcasecmp ("Match", child->key) == 0)
       /* Be liberal with failing matches => don't set `status'. */
       cc_config_add_match (page, child);
+    else if (strcasecmp ("Header", child->key) == 0)
+      status = cc_config_append_string ("Header", &page->headers, child);
+    else if (strcasecmp ("Post", child->key) == 0)
+      status = cc_config_add_string ("Post", &page->post_body, child);
     else
     {
       WARNING ("curl plugin: Option `%s' not allowed here.", child->key);
       status = -1;
     }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/curl_json.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/curl_json.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/curl_json.c	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/curl_json.c	2013-04-09 23:18:59.000000000 +0800
@@ -64,12 +64,14 @@
   char *user;
   char *pass;
   char *credentials;
   _Bool verify_peer;
   _Bool verify_host;
   char *cacert;
+  struct curl_slist *headers;
+  char *post_body;
 
   CURL *curl;
   char curl_errbuf[CURL_ERROR_SIZE];
 
   yajl_handle yajl;
   c_avl_tree_t *tree;
@@ -364,23 +366,41 @@
 
   sfree (db->url);
   sfree (db->user);
   sfree (db->pass);
   sfree (db->credentials);
   sfree (db->cacert);
+  sfree (db->post_body);
+  curl_slist_free_all (db->headers);
 
   sfree (db);
 } /* }}} void cj_free */
 
 /* Configuration handling functions {{{ */
 
 static c_avl_tree_t *cj_avl_create(void)
 {
   return c_avl_create ((int (*) (const void *, const void *)) strcmp);
 }
 
+static int cj_config_append_string (const char *name, struct curl_slist **dest, /* {{{ */
+    oconfig_item_t *ci)
+{
+  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING))
+  {
+    WARNING ("curl_json plugin: `%s' needs exactly one string argument.", name);
+    return (-1);
+  }
+
+  *dest = curl_slist_append(*dest, ci->values[0].value.string);
+  if (*dest == NULL)
+    return (-1);
+
+  return (0);
+} /* }}} int cj_config_append_string */
+
 static int cj_config_add_key (cj_t *db, /* {{{ */
                                    oconfig_item_t *ci)
 {
   cj_key_t *key;
   int status;
   int i;
@@ -544,12 +564,16 @@
 
   curl_easy_setopt (db->curl, CURLOPT_SSL_VERIFYPEER, (long) db->verify_peer);
   curl_easy_setopt (db->curl, CURLOPT_SSL_VERIFYHOST,
                     db->verify_host ? 2L : 0L);
   if (db->cacert != NULL)
     curl_easy_setopt (db->curl, CURLOPT_CAINFO, db->cacert);
+  if (db->headers != NULL)
+    curl_easy_setopt (db->curl, CURLOPT_HTTPHEADER, db->headers);
+  if (db->post_body != NULL)
+    curl_easy_setopt (db->curl, CURLOPT_POSTFIELDS, db->post_body);
 
   return (0);
 } /* }}} int cj_init_curl */
 
 static int cj_config_add_url (oconfig_item_t *ci) /* {{{ */
 {
@@ -605,12 +629,16 @@
     else if (strcasecmp ("VerifyPeer", child->key) == 0)
       status = cf_util_get_boolean (child, &db->verify_peer);
     else if (strcasecmp ("VerifyHost", child->key) == 0)
       status = cf_util_get_boolean (child, &db->verify_host);
     else if (strcasecmp ("CACert", child->key) == 0)
       status = cf_util_get_string (child, &db->cacert);
+    else if (strcasecmp ("Header", child->key) == 0)
+      status = cj_config_append_string ("Header", &db->headers, child);
+    else if (strcasecmp ("Post", child->key) == 0)
+      status = cf_util_get_string (child, &db->post_body);
     else if (strcasecmp ("Key", child->key) == 0)
       status = cj_config_add_key (db, child);
     else
     {
       WARNING ("curl_json plugin: Option `%s' not allowed here.", child->key);
       status = -1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/curl_xml.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/curl_xml.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/curl_xml.c	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/curl_xml.c	2013-04-09 23:18:59.000000000 +0800
@@ -25,12 +25,13 @@
 #include "configfile.h"
 #include "utils_llist.h"
 
 #include <libxml/parser.h>
 #include <libxml/tree.h>
 #include <libxml/xpath.h>
+#include <libxml/xpathInternals.h>
 
 #include <curl/curl.h>
 
 #define CX_DEFAULT_HOST "localhost"
 
 /*
@@ -55,24 +56,37 @@
   int is_table;
   unsigned long magic;
 };
 typedef struct cx_xpath_s cx_xpath_t;
 /* }}} */
 
+struct cx_namespace_s /* {{{ */
+{
+  char *prefix;
+  char *url;
+};
+typedef struct cx_namespace_s cx_namespace_t;
+/* }}} */
+
 struct cx_s /* {{{ */
 {
   char *instance;
   char *host;
 
   char *url;
   char *user;
   char *pass;
   char *credentials;
   _Bool verify_peer;
   _Bool verify_host;
   char *cacert;
+  char *post_body;
+  struct curl_slist *headers;
+
+  cx_namespace_t *namespaces;
+  size_t namespaces_num;
 
   CURL *curl;
   char curl_errbuf[CURL_ERROR_SIZE];
   char *buffer;
   size_t buffer_size;
   size_t buffer_fill;
@@ -157,12 +171,13 @@
   list = NULL;
 } /* }}} void cx_list_free */
 
 static void cx_free (void *arg) /* {{{ */
 {
   cx_t *db;
+  size_t i;
 
   DEBUG ("curl_xml plugin: cx_free (arg = %p);", arg);
 
   db = (cx_t *) arg;
 
   if (db == NULL)
@@ -181,16 +196,41 @@
 
   sfree (db->url);
   sfree (db->user);
   sfree (db->pass);
   sfree (db->credentials);
   sfree (db->cacert);
+  sfree (db->post_body);
+  curl_slist_free_all (db->headers);
+
+  for (i = 0; i < db->namespaces_num; i++)
+  {
+    sfree (db->namespaces[i].prefix);
+    sfree (db->namespaces[i].url);
+  }
+  sfree (db->namespaces);
 
   sfree (db);
 } /* }}} void cx_free */
 
+static int cx_config_append_string (const char *name, struct curl_slist **dest, /* {{{ */
+    oconfig_item_t *ci)
+{
+  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING))
+  {
+    WARNING ("curl_xml plugin: `%s' needs exactly one string argument.", name);
+    return (-1);
+  }
+
+  *dest = curl_slist_append(*dest, ci->values[0].value.string);
+  if (*dest == NULL)
+    return (-1);
+
+  return (0);
+} /* }}} int cx_config_append_string */
+
 static int cx_check_type (const data_set_t *ds, cx_xpath_t *xpath) /* {{{ */
 {
   if (!ds)
   {
     WARNING ("curl_xml plugin: DataSet `%s' not defined.", xpath->type);
     return (-1);
@@ -222,13 +262,14 @@
 
   return xpath_obj;
 } /* }}} cx_evaluate_xpath */
 
 static int cx_if_not_text_node (xmlNodePtr node) /* {{{ */
 {
-  if (node->type == XML_TEXT_NODE || node->type == XML_ATTRIBUTE_NODE)
+  if (node->type == XML_TEXT_NODE || node->type == XML_ATTRIBUTE_NODE ||
+      node->type == XML_ELEMENT_NODE)
     return (0);
 
   WARNING ("curl_xml plugin: "
            "Node \"%s\" doesn't seem to be a text node. Skipping...", node->name);
   return -1;
 } /* }}} cx_if_not_text_node */
@@ -339,13 +380,13 @@
   xmlXPathObjectPtr instance_node_obj = NULL;
   xmlNodeSetPtr instance_node = NULL;
 
   memset (vl->type_instance, 0, sizeof (vl->type_instance));
 
   /* If the base xpath returns more than one block, the result is assumed to be
-   * a table. The `Instnce' option is not optional in this case. Check for the
+   * a table. The `Instance' option is not optional in this case. Check for the
    * condition and inform the user. */
   if (is_table && (vl->type_instance == NULL))
   {
     WARNING ("curl_xml plugin: "
         "Base-XPath %s is a table (more than one result was returned), "
         "but no instance-XPath has been defined.",
@@ -517,12 +558,13 @@
 
 static int cx_parse_stats_xml(xmlChar* xml, cx_t *db) /* {{{ */
 {
   int status;
   xmlDocPtr doc;
   xmlXPathContextPtr xpath_ctx;
+  size_t i;
 
   /* Load the XML */
   doc = xmlParseDoc(xml);
   if (doc == NULL)
   {
     ERROR ("curl_xml plugin: Failed to parse the xml document  - %s", xml);
@@ -534,12 +576,28 @@
   {
     ERROR ("curl_xml plugin: Failed to create the xml context");
     xmlFreeDoc(doc);
     return (-1);
   }
 
+  for (i = 0; i < db->namespaces_num; i++)
+  {
+    cx_namespace_t const *ns = db->namespaces + i;
+    status = xmlXPathRegisterNs (xpath_ctx,
+        BAD_CAST ns->prefix, BAD_CAST ns->url);
+    if (status != 0)
+    {
+      ERROR ("curl_xml plugin: "
+          "unable to register NS with prefix=\"%s\" and href=\"%s\"\n",
+          ns->prefix, ns->url);
+      xmlXPathFreeContext(xpath_ctx);
+      xmlFreeDoc (doc);
+      return (status);
+    }
+  }
+
   status = cx_handle_parsed_xml (doc, xpath_ctx, db);
   /* Cleanup */
   xmlXPathFreeContext(xpath_ctx);
   xmlFreeDoc(doc);
   return status;
 } /* }}} cx_parse_stats_xml */
@@ -723,12 +781,52 @@
     llist_append (db->list, le);
   }
 
   return (status);
 } /* }}} int cx_config_add_xpath */
 
+static int cx_config_add_namespace (cx_t *db, /* {{{ */
+    oconfig_item_t *ci)
+{
+  cx_namespace_t *ns;
+
+  if ((ci->values_num != 2)
+      || (ci->values[0].type != OCONFIG_TYPE_STRING)
+      || (ci->values[1].type != OCONFIG_TYPE_STRING))
+  {
+    WARNING ("curl_xml plugin: The `Namespace' option "
+             "needs exactly two string arguments.");
+    return (EINVAL);
+  }
+
+  ns = realloc (db->namespaces, sizeof (*db->namespaces)
+      * (db->namespaces_num + 1));
+  if (ns == NULL)
+  {
+    ERROR ("curl_xml plugin: realloc failed.");
+    return (ENOMEM);
+  }
+  db->namespaces = ns;
+  ns = db->namespaces + db->namespaces_num;
+  memset (ns, 0, sizeof (*ns));
+
+  ns->prefix = strdup (ci->values[0].value.string);
+  ns->url = strdup (ci->values[1].value.string);
+
+  if ((ns->prefix == NULL) || (ns->url == NULL))
+  {
+    sfree (ns->prefix);
+    sfree (ns->url);
+    ERROR ("curl_xml plugin: strdup failed.");
+    return (ENOMEM);
+  }
+
+  db->namespaces_num++;
+  return (0);
+} /* }}} int cx_config_add_namespace */
+
 /* Initialize db->curl */
 static int cx_init_curl (cx_t *db) /* {{{ */
 {
   db->curl = curl_easy_init ();
   if (db->curl == NULL)
   {
@@ -766,12 +864,16 @@
 
   curl_easy_setopt (db->curl, CURLOPT_SSL_VERIFYPEER, db->verify_peer ? 1L : 0L);
   curl_easy_setopt (db->curl, CURLOPT_SSL_VERIFYHOST,
                     db->verify_host ? 2L : 0L);
   if (db->cacert != NULL)
     curl_easy_setopt (db->curl, CURLOPT_CAINFO, db->cacert);
+  if (db->headers != NULL)
+    curl_easy_setopt (db->curl, CURLOPT_HTTPHEADER, db->headers);
+  if (db->post_body != NULL)
+    curl_easy_setopt (db->curl, CURLOPT_POSTFIELDS, db->post_body);
 
   return (0);
 } /* }}} int cx_init_curl */
 
 static int cx_config_add_url (oconfig_item_t *ci) /* {{{ */
 {
@@ -829,12 +931,18 @@
     else if (strcasecmp ("VerifyHost", child->key) == 0)
       status = cf_util_get_boolean (child, &db->verify_host);
     else if (strcasecmp ("CACert", child->key) == 0)
       status = cf_util_get_string (child, &db->cacert);
     else if (strcasecmp ("xpath", child->key) == 0)
       status = cx_config_add_xpath (db, child);
+    else if (strcasecmp ("Header", child->key) == 0)
+      status = cx_config_append_string ("Header", &db->headers, child);
+    else if (strcasecmp ("Post", child->key) == 0)
+      status = cf_util_get_string (child, &db->post_body);
+    else if (strcasecmp ("Namespace", child->key) == 0)
+      status = cx_config_add_namespace (db, child);
     else
     {
       WARNING ("curl_xml plugin: Option `%s' not allowed here.", child->key);
       status = -1;
     }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/dbi.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/dbi.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/dbi.c	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/dbi.c	2013-04-09 23:18:59.000000000 +0800
@@ -1,9 +1,9 @@
 /**
  * collectd - src/dbi.c
- * Copyright (C) 2008,2009  Florian octo Forster
+ * Copyright (C) 2008-2013  Florian octo Forster
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; only version 2 of the License is applicable.
  *
  * This program is distributed in the hope that it will be useful, but
@@ -13,13 +13,13 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
  *
  * Authors:
- *   Florian octo Forster <octo at verplant.org>
+ *   Florian octo Forster <octo at collectd.org>
  **/
 
 #include "collectd.h"
 #include "common.h"
 #include "plugin.h"
 #include "configfile.h"
@@ -30,22 +30,28 @@
 /*
  * Data types
  */
 struct cdbi_driver_option_s /* {{{ */
 {
   char *key;
-  char *value;
+  union
+  {
+    char *string;
+    int numeric;
+  } value;
+  _Bool is_numeric;
 };
 typedef struct cdbi_driver_option_s cdbi_driver_option_t; /* }}} */
 
 struct cdbi_database_s /* {{{ */
 {
   char *name;
   char *select_db;
 
   char *driver;
+  char *host;
   cdbi_driver_option_t *driver_options;
   size_t driver_options_num;
 
   udb_query_preparation_area_t **q_prep_areas;
   udb_query_t **queries;
   size_t        queries_num;
@@ -156,13 +162,14 @@
   sfree (db->name);
   sfree (db->driver);
 
   for (i = 0; i < db->driver_options_num; i++)
   {
     sfree (db->driver_options[i].key);
-    sfree (db->driver_options[i].value);
+    if (!db->driver_options[i].is_numeric)
+      sfree (db->driver_options[i].value.string);
   }
   sfree (db->driver_options);
 
   if (db->q_prep_areas)
     for (i = 0; i < db->queries_num; ++i)
       udb_query_delete_preparation_area (db->q_prep_areas[i]);
@@ -197,16 +204,17 @@
     oconfig_item_t *ci)
 {
   cdbi_driver_option_t *option;
 
   if ((ci->values_num != 2)
       || (ci->values[0].type != OCONFIG_TYPE_STRING)
-      || (ci->values[1].type != OCONFIG_TYPE_STRING))
+      || ((ci->values[1].type != OCONFIG_TYPE_STRING)
+        && (ci->values[1].type != OCONFIG_TYPE_NUMBER)))
   {
     WARNING ("dbi plugin: The `DriverOption' config option "
-        "needs exactly two string arguments.");
+        "needs exactly two arguments.");
     return (-1);
   }
 
   option = (cdbi_driver_option_t *) realloc (db->driver_options,
       sizeof (*option) * (db->driver_options_num + 1));
   if (option == NULL)
@@ -214,26 +222,36 @@
     ERROR ("dbi plugin: realloc failed");
     return (-1);
   }
 
   db->driver_options = option;
   option = db->driver_options + db->driver_options_num;
+  memset (option, 0, sizeof (*option));
 
   option->key = strdup (ci->values[0].value.string);
   if (option->key == NULL)
   {
     ERROR ("dbi plugin: strdup failed.");
     return (-1);
   }
 
-  option->value = strdup (ci->values[1].value.string);
-  if (option->value == NULL)
+  if (ci->values[1].type == OCONFIG_TYPE_STRING)
   {
-    ERROR ("dbi plugin: strdup failed.");
-    sfree (option->key);
-    return (-1);
+    option->value.string = strdup (ci->values[1].value.string);
+    if (option->value.string == NULL)
+    {
+      ERROR ("dbi plugin: strdup failed.");
+      sfree (option->key);
+      return (-1);
+    }
+  }
+  else
+  {
+    assert (ci->values[1].type == OCONFIG_TYPE_NUMBER);
+    option->value.numeric = (int) (ci->values[1].value.number + .5);
+    option->is_numeric = 1;
   }
 
   db->driver_options_num++;
   return (0);
 } /* }}} int cdbi_config_add_database_driver_option */
 
@@ -277,12 +295,14 @@
       status = cdbi_config_add_database_driver_option (db, child);
     else if (strcasecmp ("SelectDB", child->key) == 0)
       status = cf_util_get_string (child, &db->select_db);
     else if (strcasecmp ("Query", child->key) == 0)
       status = udb_query_pick_from_list (child, queries, queries_num,
           &db->queries, &db->queries_num);
+    else if (strcasecmp ("Host", child->key) == 0)
+      status = cf_util_get_string (child, &db->host);
     else
     {
       WARNING ("dbi plugin: Option `%s' not allowed here.", child->key);
       status = -1;
     }
 
@@ -534,13 +554,13 @@
       BAIL_OUT (-1);
     }
 
     sstrncpy (column_names[i], column_name, DATA_MAX_NAME_LEN);
   } /* }}} for (i = 0; i < column_num; i++) */
 
-  udb_query_prepare_result (q, prep_area, hostname_g,
+  udb_query_prepare_result (q, prep_area, (db->host ? db->host : hostname_g),
       /* plugin = */ "dbi", db->name,
       column_names, column_num, /* interval = */ 0);
 
   /* 0 = error; 1 = success; */
   status = dbi_result_first_row (res); /* {{{ */
   if (status != 1)
@@ -658,30 +678,44 @@
    * interface, the error handling is kind of long. If an invalid option is
    * encountered, it will get a list of options understood by the driver and
    * report that as `INFO'. This way, users hopefully don't have too much
    * trouble finding out how to configure the plugin correctly.. */
   for (i = 0; i < db->driver_options_num; i++)
   {
-    DEBUG ("dbi plugin: cdbi_connect_database (%s): "
-        "key = %s; value = %s;",
-        db->name,
-        db->driver_options[i].key,
-        db->driver_options[i].value);
+    if (db->driver_options[i].is_numeric)
+    {
+      status = dbi_conn_set_option_numeric (connection,
+          db->driver_options[i].key, db->driver_options[i].value.numeric);
+      if (status != 0)
+      {
+        char errbuf[1024];
+        ERROR ("dbi plugin: cdbi_connect_database (%s): "
+            "dbi_conn_set_option_numeric (\"%s\", %i) failed: %s.",
+            db->name,
+            db->driver_options[i].key, db->driver_options[i].value.numeric,
+            cdbi_strerror (connection, errbuf, sizeof (errbuf)));
+      }
+    }
+    else
+    {
+      status = dbi_conn_set_option (connection,
+          db->driver_options[i].key, db->driver_options[i].value.string);
+      if (status != 0)
+      {
+        char errbuf[1024];
+        ERROR ("dbi plugin: cdbi_connect_database (%s): "
+            "dbi_conn_set_option (\"%s\", \"%s\") failed: %s.",
+            db->name,
+            db->driver_options[i].key, db->driver_options[i].value.string,
+            cdbi_strerror (connection, errbuf, sizeof (errbuf)));
+      }
+    }
 
-    status = dbi_conn_set_option (connection,
-        db->driver_options[i].key, db->driver_options[i].value);
     if (status != 0)
     {
-      char errbuf[1024];
-      const char *opt;
-
-      ERROR ("dbi plugin: cdbi_connect_database (%s): "
-          "dbi_conn_set_option (%s, %s) failed: %s.",
-          db->name,
-          db->driver_options[i].key, db->driver_options[i].value,
-          cdbi_strerror (connection, errbuf, sizeof (errbuf)));
+      char const *opt;
 
       INFO ("dbi plugin: This is a list of all options understood "
           "by the `%s' driver:", db->driver);
       for (opt = dbi_conn_get_option_list (connection, NULL);
           opt != NULL;
           opt = dbi_conn_get_option_list (connection, opt))
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/disk.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/disk.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/disk.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/disk.c	2013-04-09 23:18:59.000000000 +0800
@@ -106,13 +106,13 @@
 } diskstats_t;
 
 static diskstats_t *disklist;
 /* #endif KERNEL_LINUX */
 
 #elif HAVE_LIBKSTAT
-#define MAX_NUMDISK 256
+#define MAX_NUMDISK 1024
 extern kstat_ctl_t *kc;
 static kstat_t *ksp[MAX_NUMDISK];
 static int numdisk = 0;
 /* #endif HAVE_LIBKSTAT */
 
 #elif defined(HAVE_LIBSTATGRAB)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/libcollectdclient/collectd/lcc_features.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/libcollectdclient/collectd/lcc_features.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/libcollectdclient/collectd/lcc_features.h	2013-04-09 09:14:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/libcollectdclient/collectd/lcc_features.h	2013-04-10 23:42:19.000000000 +0800
@@ -35,18 +35,18 @@
 # define LCC_END_DECLS
 #endif
 
 #define LCC_API_VERSION 0
 
 #define LCC_VERSION_MAJOR 5
-#define LCC_VERSION_MINOR 2
-#define LCC_VERSION_PATCH 2
+#define LCC_VERSION_MINOR 3
+#define LCC_VERSION_PATCH 0
 
 #define LCC_VERSION_EXTRA ""
 
-#define LCC_VERSION_STRING "5.2.2"
+#define LCC_VERSION_STRING "5.3.0"
 
 #define LCC_VERSION_ENCODE(major, minor, patch) \
 	((major) * 10000 + (minor) * 100 + (patch))
 
 #define LCC_VERSION \
 	LCC_VERSION_ENCODE(LCC_VERSION_MAJOR, LCC_VERSION_MINOR, LCC_VERSION_PATCH)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/libvirt.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/libvirt.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/libvirt.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/libvirt.c	2013-04-09 23:18:59.000000000 +0800
@@ -175,12 +175,31 @@
     }
 
     vl->host[sizeof (vl->host) - 1] = '\0';
 } /* void init_value_list */
 
 static void
+memory_submit (gauge_t memory, virDomainPtr dom)
+{
+    value_t values[1];
+    value_list_t vl = VALUE_LIST_INIT;
+
+    init_value_list (&vl, dom);
+
+    values[0].gauge = memory;
+
+    vl.values = values;
+    vl.values_len = 1;
+
+    sstrncpy (vl.type, "memory", sizeof (vl.type));
+    sstrncpy (vl.type_instance, "total", sizeof (vl.type_instance));
+
+    plugin_dispatch_values (&vl);
+}
+
+static void
 cpu_submit (unsigned long long cpu_time,
             virDomainPtr dom, const char *type)
 {
     value_t values[1];
     value_list_t vl = VALUE_LIST_INIT;
 
@@ -404,13 +423,13 @@
     for (i = 0; i < nr_interface_devices; ++i)
         fprintf (stderr, "interface device %d %s:%s\n",
                  i, virDomainGetName (interface_devices[i].dom),
                  interface_devices[i].path);
 #endif
 
-    /* Get CPU usage, VCPU usage for each domain. */
+    /* Get CPU usage, memory, VCPU usage for each domain. */
     for (i = 0; i < nr_domains; ++i) {
         virDomainInfo info;
         virVcpuInfoPtr vinfo = NULL;
         int status;
         int j;
 
@@ -420,12 +439,13 @@
             ERROR ("libvirt plugin: virDomainGetInfo failed with status %i.",
                     status);
             continue;
         }
 
         cpu_submit (info.cpuTime, domains[i], "virt_cpu_total");
+        memory_submit ((gauge_t) info.memory * 1024, domains[i]);
 
         vinfo = malloc (info.nrVirtCpu * sizeof (vinfo[0]));
         if (vinfo == NULL) {
             ERROR ("libvirt plugin: malloc failed.");
             continue;
         }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/Makefile.am	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/Makefile.am	2013-04-10 23:34:36.000000000 +0800
@@ -30,12 +30,13 @@
 		   utils_cache.c utils_cache.h \
 		   utils_complain.c utils_complain.h \
 		   utils_heap.c utils_heap.h \
 		   utils_ignorelist.c utils_ignorelist.h \
 		   utils_llist.c utils_llist.h \
 		   utils_parse_option.c utils_parse_option.h \
+		   utils_random.c utils_random.h \
 		   utils_tail_match.c utils_tail_match.h \
 		   utils_match.c utils_match.h \
 		   utils_subst.c utils_subst.h \
 		   utils_tail.c utils_tail.h \
 		   utils_time.c utils_time.h \
 		   types_list.c types_list.h
@@ -132,13 +133,13 @@
 collectd_tg_DEPENDENCIES = libcollectdclient/libcollectdclient.la
 
 
 pkglib_LTLIBRARIES = 
 
 BUILT_SOURCES = 
-CLEANFILES = 
+CLEANFILES =
 
 if BUILD_PLUGIN_AGGREGATION
 pkglib_LTLIBRARIES += aggregation.la
 aggregation_la_SOURCES = aggregation.c \
                          utils_vl_lookup.c utils_vl_lookup.h
 aggregation_la_LDFLAGS = -module -avoid-version
@@ -900,16 +901,15 @@
 pf_la_LDFLAGS = -module -avoid-version
 collectd_LDADD += "-dlopen" pf.la
 collectd_DEPENDENCIES += pf.la
 endif
 
 if BUILD_PLUGIN_PINBA
-BUILT_SOURCES += pinba.pb-c.c pinba.pb-c.h
-CLEANFILES += pinba.pb-c.c pinba.pb-c.h
 pkglib_LTLIBRARIES += pinba.la
 pinba_la_SOURCES = pinba.c
+nodist_pinba_la_SOURCES = pinba.pb-c.c pinba.pb-c.h
 pinba_la_LDFLAGS = -module -avoid-version
 pinba_la_LIBADD = -lprotobuf-c
 collectd_LDADD += "-dlopen" pinba.la
 collectd_DEPENDENCIES += pinba.la
 endif
 
@@ -1100,12 +1100,20 @@
 tail_la_SOURCES = tail.c
 tail_la_LDFLAGS = -module -avoid-version
 collectd_LDADD += "-dlopen" tail.la
 collectd_DEPENDENCIES += tail.la
 endif
 
+if BUILD_PLUGIN_TAIL_CSV
+pkglib_LTLIBRARIES += tail_csv.la
+tail_csv_la_SOURCES = tail_csv.c
+tail_csv_la_LDFLAGS = -module -avoid-version
+collectd_LDADD += "-dlopen" tail_csv.la
+collectd_DEPENDENCIES += tail_csv.la
+endif
+
 if BUILD_PLUGIN_TAPE
 pkglib_LTLIBRARIES += tape.la
 tape_la_SOURCES = tape.c
 tape_la_LDFLAGS = -module -avoid-version
 tape_la_LIBADD = -lkstat -ldevinfo
 collectd_LDADD += "-dlopen" tape.la
@@ -1339,12 +1347,22 @@
 write_redis_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBCREDIS_CPPFLAGS)
 write_redis_la_LIBADD = -lcredis
 collectd_LDADD += "-dlopen" write_redis.la
 collectd_DEPENDENCIES += write_redis.la
 endif
 
+if BUILD_PLUGIN_WRITE_RIEMANN
+pkglib_LTLIBRARIES += write_riemann.la
+write_riemann_la_SOURCES = write_riemann.c
+nodist_write_riemann_la_SOURCES = riemann.pb-c.c riemann.pb-c.h
+write_riemann_la_LDFLAGS = -module -avoid-version
+write_riemann_la_LIBADD = -lprotobuf-c
+collectd_LDADD += "-dlopen" write_riemann.la
+collectd_DEPENDENCIES += write_riemann.la
+endif
+
 if BUILD_PLUGIN_XMMS
 pkglib_LTLIBRARIES += xmms.la
 xmms_la_SOURCES = xmms.c
 xmms_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBXMMS_CFLAGS)
 xmms_la_LDFLAGS = -module -avoid-version
 xmms_la_LIBADD = $(BUILD_WITH_LIBXMMS_LIBS)
@@ -1379,13 +1397,13 @@
 		collectd-threshold.5 \
 		collectd-unixsock.5 \
 		types.db.5
 
 #collectd_1_SOURCES = collectd.pod
 
-EXTRA_DIST = types.db pinba.proto
+EXTRA_DIST = types.db
 
 EXTRA_DIST +=   collectd.conf.pod \
 		collectd-email.pod \
 		collectd-exec.pod \
 		collectdctl.pod \
 		collectd-java.pod \
@@ -1414,14 +1432,32 @@
 		>.pod2man.tmp.$$$$ 2>/dev/null && mv -f .pod2man.tmp.$$$$ $@ || true
 	@if grep '\<POD ERRORS\>' $@ >/dev/null 2>&1; \
 	then \
 		echo "$@ has some POD errors!"; false; \
 	fi
 
+# Protocol buffer for the "pinba" plugin.
+EXTRA_DIST += pinba.proto
+if HAVE_PROTOC_C
+CLEANFILES += pinba.pb-c.c pinba.pb-c.h
+BUILT_SOURCES += pinba.pb-c.c pinba.pb-c.h
+
 pinba.pb-c.c pinba.pb-c.h: pinba.proto
 	protoc-c -I$(srcdir) --c_out . $(srcdir)/pinba.proto
+endif
+
+# Protocol buffer for the "write_riemann" plugin.
+EXTRA_DIST += riemann.proto
+if HAVE_PROTOC_C
+CLEANFILES += riemann.pb-c.c riemann.pb-c.h
+
+BUILT_SOURCES += riemann.pb-c.c riemann.pb-c.h
+
+riemann.pb-c.c riemann.pb-c.h: riemann.proto
+	protoc-c -I$(srcdir) --c_out . $(srcdir)/riemann.proto
+endif
 
 install-exec-hook:
 	$(mkinstalldirs) $(DESTDIR)$(sysconfdir)
 	if test -e $(DESTDIR)$(sysconfdir)/collectd.conf; \
 	then \
 		$(INSTALL) -m 0640 collectd.conf $(DESTDIR)$(sysconfdir)/collectd.conf.pkg-orig; \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/Makefile.in	2013-04-09 09:14:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/Makefile.in	2013-04-10 23:41:39.000000000 +0800
@@ -315,166 +315,174 @@
 @BUILD_PLUGIN_PERL_TRUE@@HAVE_BROKEN_PERL_LOAD_MODULE_TRUE@am__append_268 = -Wno-nonnull
 @BUILD_PLUGIN_PERL_TRUE@am__append_269 = "-dlopen" perl.la
 @BUILD_PLUGIN_PERL_TRUE@am__append_270 = perl.la
 @BUILD_PLUGIN_PF_TRUE@am__append_271 = pf.la
 @BUILD_PLUGIN_PF_TRUE@am__append_272 = "-dlopen" pf.la
 @BUILD_PLUGIN_PF_TRUE@am__append_273 = pf.la
-@BUILD_PLUGIN_PINBA_TRUE@am__append_274 = pinba.pb-c.c pinba.pb-c.h
-@BUILD_PLUGIN_PINBA_TRUE@am__append_275 = pinba.pb-c.c pinba.pb-c.h
+@BUILD_PLUGIN_PINBA_TRUE@am__append_274 = pinba.la
+@BUILD_PLUGIN_PINBA_TRUE@am__append_275 = "-dlopen" pinba.la
 @BUILD_PLUGIN_PINBA_TRUE@am__append_276 = pinba.la
-@BUILD_PLUGIN_PINBA_TRUE@am__append_277 = "-dlopen" pinba.la
-@BUILD_PLUGIN_PINBA_TRUE@am__append_278 = pinba.la
+@BUILD_PLUGIN_PING_TRUE@am__append_277 = ping.la
+@BUILD_PLUGIN_PING_TRUE@am__append_278 = "-dlopen" ping.la
 @BUILD_PLUGIN_PING_TRUE@am__append_279 = ping.la
-@BUILD_PLUGIN_PING_TRUE@am__append_280 = "-dlopen" ping.la
-@BUILD_PLUGIN_PING_TRUE@am__append_281 = ping.la
+@BUILD_PLUGIN_POSTGRESQL_TRUE@am__append_280 = postgresql.la
+@BUILD_PLUGIN_POSTGRESQL_TRUE@am__append_281 = "-dlopen" postgresql.la
 @BUILD_PLUGIN_POSTGRESQL_TRUE@am__append_282 = postgresql.la
-@BUILD_PLUGIN_POSTGRESQL_TRUE@am__append_283 = "-dlopen" postgresql.la
-@BUILD_PLUGIN_POSTGRESQL_TRUE@am__append_284 = postgresql.la
+@BUILD_PLUGIN_POWERDNS_TRUE@am__append_283 = powerdns.la
+@BUILD_PLUGIN_POWERDNS_TRUE@am__append_284 = "-dlopen" powerdns.la
 @BUILD_PLUGIN_POWERDNS_TRUE@am__append_285 = powerdns.la
-@BUILD_PLUGIN_POWERDNS_TRUE@am__append_286 = "-dlopen" powerdns.la
-@BUILD_PLUGIN_POWERDNS_TRUE@am__append_287 = powerdns.la
-@BUILD_PLUGIN_PYTHON_TRUE@am__append_288 = python.la
-@BUILD_PLUGIN_PYTHON_TRUE@@COMPILER_IS_GCC_TRUE@am__append_289 = -fno-strict-aliasing -Wno-strict-aliasing
-@BUILD_PLUGIN_PYTHON_TRUE@am__append_290 = "-dlopen" python.la
-@BUILD_PLUGIN_PYTHON_TRUE@am__append_291 = python.la
+@BUILD_PLUGIN_PYTHON_TRUE@am__append_286 = python.la
+@BUILD_PLUGIN_PYTHON_TRUE@@COMPILER_IS_GCC_TRUE@am__append_287 = -fno-strict-aliasing -Wno-strict-aliasing
+@BUILD_PLUGIN_PYTHON_TRUE@am__append_288 = "-dlopen" python.la
+@BUILD_PLUGIN_PYTHON_TRUE@am__append_289 = python.la
+@BUILD_PLUGIN_PROCESSES_TRUE@am__append_290 = processes.la
+@BUILD_PLUGIN_PROCESSES_TRUE@am__append_291 = "-dlopen" processes.la
 @BUILD_PLUGIN_PROCESSES_TRUE@am__append_292 = processes.la
-@BUILD_PLUGIN_PROCESSES_TRUE@am__append_293 = "-dlopen" processes.la
-@BUILD_PLUGIN_PROCESSES_TRUE@am__append_294 = processes.la
-@BUILD_PLUGIN_PROCESSES_TRUE@@BUILD_WITH_LIBKVM_GETPROCS_TRUE@am__append_295 = -lkvm
+@BUILD_PLUGIN_PROCESSES_TRUE@@BUILD_WITH_LIBKVM_GETPROCS_TRUE@am__append_293 = -lkvm
+@BUILD_PLUGIN_PROTOCOLS_TRUE@am__append_294 = protocols.la
+@BUILD_PLUGIN_PROTOCOLS_TRUE@am__append_295 = "-dlopen" protocols.la
 @BUILD_PLUGIN_PROTOCOLS_TRUE@am__append_296 = protocols.la
-@BUILD_PLUGIN_PROTOCOLS_TRUE@am__append_297 = "-dlopen" protocols.la
-@BUILD_PLUGIN_PROTOCOLS_TRUE@am__append_298 = protocols.la
+@BUILD_PLUGIN_REDIS_TRUE@am__append_297 = redis.la
+@BUILD_PLUGIN_REDIS_TRUE@am__append_298 = "-dlopen" redis.la
 @BUILD_PLUGIN_REDIS_TRUE@am__append_299 = redis.la
-@BUILD_PLUGIN_REDIS_TRUE@am__append_300 = "-dlopen" redis.la
-@BUILD_PLUGIN_REDIS_TRUE@am__append_301 = redis.la
+@BUILD_PLUGIN_ROUTEROS_TRUE@am__append_300 = routeros.la
+@BUILD_PLUGIN_ROUTEROS_TRUE@am__append_301 = "-dlopen" routeros.la
 @BUILD_PLUGIN_ROUTEROS_TRUE@am__append_302 = routeros.la
-@BUILD_PLUGIN_ROUTEROS_TRUE@am__append_303 = "-dlopen" routeros.la
-@BUILD_PLUGIN_ROUTEROS_TRUE@am__append_304 = routeros.la
+@BUILD_PLUGIN_RRDCACHED_TRUE@am__append_303 = rrdcached.la
+@BUILD_PLUGIN_RRDCACHED_TRUE@am__append_304 = "-dlopen" rrdcached.la
 @BUILD_PLUGIN_RRDCACHED_TRUE@am__append_305 = rrdcached.la
-@BUILD_PLUGIN_RRDCACHED_TRUE@am__append_306 = "-dlopen" rrdcached.la
-@BUILD_PLUGIN_RRDCACHED_TRUE@am__append_307 = rrdcached.la
+@BUILD_PLUGIN_RRDTOOL_TRUE@am__append_306 = rrdtool.la
+@BUILD_PLUGIN_RRDTOOL_TRUE@am__append_307 = "-dlopen" rrdtool.la
 @BUILD_PLUGIN_RRDTOOL_TRUE@am__append_308 = rrdtool.la
-@BUILD_PLUGIN_RRDTOOL_TRUE@am__append_309 = "-dlopen" rrdtool.la
-@BUILD_PLUGIN_RRDTOOL_TRUE@am__append_310 = rrdtool.la
+@BUILD_PLUGIN_SENSORS_TRUE@am__append_309 = sensors.la
+@BUILD_PLUGIN_SENSORS_TRUE@am__append_310 = "-dlopen" sensors.la
 @BUILD_PLUGIN_SENSORS_TRUE@am__append_311 = sensors.la
-@BUILD_PLUGIN_SENSORS_TRUE@am__append_312 = "-dlopen" sensors.la
-@BUILD_PLUGIN_SENSORS_TRUE@am__append_313 = sensors.la
+@BUILD_PLUGIN_SERIAL_TRUE@am__append_312 = serial.la
+@BUILD_PLUGIN_SERIAL_TRUE@am__append_313 = "-dlopen" serial.la
 @BUILD_PLUGIN_SERIAL_TRUE@am__append_314 = serial.la
-@BUILD_PLUGIN_SERIAL_TRUE@am__append_315 = "-dlopen" serial.la
-@BUILD_PLUGIN_SERIAL_TRUE@am__append_316 = serial.la
-@BUILD_PLUGIN_SNMP_TRUE@am__append_317 = snmp.la
-@BUILD_PLUGIN_SNMP_TRUE@@BUILD_WITH_LIBNETSNMP_TRUE@am__append_318 = $(BUILD_WITH_LIBSNMP_CFLAGS)
-@BUILD_PLUGIN_SNMP_TRUE@@BUILD_WITH_LIBNETSNMP_TRUE@am__append_319 = $(BUILD_WITH_LIBSNMP_LIBS)
-@BUILD_PLUGIN_SNMP_TRUE@@BUILD_WITH_LIBPTHREAD_TRUE@am__append_320 = -lpthread
-@BUILD_PLUGIN_SNMP_TRUE@am__append_321 = "-dlopen" snmp.la
-@BUILD_PLUGIN_SNMP_TRUE@am__append_322 = snmp.la
+@BUILD_PLUGIN_SNMP_TRUE@am__append_315 = snmp.la
+@BUILD_PLUGIN_SNMP_TRUE@@BUILD_WITH_LIBNETSNMP_TRUE@am__append_316 = $(BUILD_WITH_LIBSNMP_CFLAGS)
+@BUILD_PLUGIN_SNMP_TRUE@@BUILD_WITH_LIBNETSNMP_TRUE@am__append_317 = $(BUILD_WITH_LIBSNMP_LIBS)
+@BUILD_PLUGIN_SNMP_TRUE@@BUILD_WITH_LIBPTHREAD_TRUE@am__append_318 = -lpthread
+@BUILD_PLUGIN_SNMP_TRUE@am__append_319 = "-dlopen" snmp.la
+@BUILD_PLUGIN_SNMP_TRUE@am__append_320 = snmp.la
+@BUILD_PLUGIN_SWAP_TRUE@am__append_321 = swap.la
+@BUILD_PLUGIN_SWAP_TRUE@am__append_322 = "-dlopen" swap.la
 @BUILD_PLUGIN_SWAP_TRUE@am__append_323 = swap.la
-@BUILD_PLUGIN_SWAP_TRUE@am__append_324 = "-dlopen" swap.la
-@BUILD_PLUGIN_SWAP_TRUE@am__append_325 = swap.la
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_326 = -lkstat
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBDEVINFO_TRUE@am__append_327 = -ldevinfo
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBKVM_GETSWAPINFO_TRUE@am__append_328 = -lkvm
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_329 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_330 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_331 = -lperfstat
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_324 = -lkstat
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBDEVINFO_TRUE@am__append_325 = -ldevinfo
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBKVM_GETSWAPINFO_TRUE@am__append_326 = -lkvm
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_327 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_328 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_329 = -lperfstat
+@BUILD_PLUGIN_SYSLOG_TRUE@am__append_330 = syslog.la
+@BUILD_PLUGIN_SYSLOG_TRUE@am__append_331 = "-dlopen" syslog.la
 @BUILD_PLUGIN_SYSLOG_TRUE@am__append_332 = syslog.la
-@BUILD_PLUGIN_SYSLOG_TRUE@am__append_333 = "-dlopen" syslog.la
-@BUILD_PLUGIN_SYSLOG_TRUE@am__append_334 = syslog.la
+@BUILD_PLUGIN_TABLE_TRUE@am__append_333 = table.la
+@BUILD_PLUGIN_TABLE_TRUE@am__append_334 = "-dlopen" table.la
 @BUILD_PLUGIN_TABLE_TRUE@am__append_335 = table.la
-@BUILD_PLUGIN_TABLE_TRUE@am__append_336 = "-dlopen" table.la
-@BUILD_PLUGIN_TABLE_TRUE@am__append_337 = table.la
+@BUILD_PLUGIN_TAIL_TRUE@am__append_336 = tail.la
+@BUILD_PLUGIN_TAIL_TRUE@am__append_337 = "-dlopen" tail.la
 @BUILD_PLUGIN_TAIL_TRUE@am__append_338 = tail.la
-@BUILD_PLUGIN_TAIL_TRUE@am__append_339 = "-dlopen" tail.la
-@BUILD_PLUGIN_TAIL_TRUE@am__append_340 = tail.la
-@BUILD_PLUGIN_TAPE_TRUE@am__append_341 = tape.la
-@BUILD_PLUGIN_TAPE_TRUE@am__append_342 = "-dlopen" tape.la
-@BUILD_PLUGIN_TAPE_TRUE@am__append_343 = tape.la
-@BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@am__append_344 = target_notification.la
-@BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@am__append_345 = "-dlopen" target_notification.la
-@BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@am__append_346 = target_notification.la
-@BUILD_PLUGIN_TARGET_REPLACE_TRUE@am__append_347 = target_replace.la
-@BUILD_PLUGIN_TARGET_REPLACE_TRUE@am__append_348 = "-dlopen" target_replace.la
-@BUILD_PLUGIN_TARGET_REPLACE_TRUE@am__append_349 = target_replace.la
-@BUILD_PLUGIN_TARGET_SCALE_TRUE@am__append_350 = target_scale.la
-@BUILD_PLUGIN_TARGET_SCALE_TRUE@am__append_351 = "-dlopen" target_scale.la
-@BUILD_PLUGIN_TARGET_SCALE_TRUE@am__append_352 = target_scale.la
-@BUILD_PLUGIN_TARGET_SET_TRUE@am__append_353 = target_set.la
-@BUILD_PLUGIN_TARGET_SET_TRUE@am__append_354 = "-dlopen" target_set.la
-@BUILD_PLUGIN_TARGET_SET_TRUE@am__append_355 = target_set.la
-@BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@am__append_356 = target_v5upgrade.la
-@BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@am__append_357 = "-dlopen" target_v5upgrade.la
-@BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@am__append_358 = target_v5upgrade.la
-@BUILD_PLUGIN_TCPCONNS_TRUE@am__append_359 = tcpconns.la
-@BUILD_PLUGIN_TCPCONNS_TRUE@am__append_360 = "-dlopen" tcpconns.la
-@BUILD_PLUGIN_TCPCONNS_TRUE@am__append_361 = tcpconns.la
-@BUILD_PLUGIN_TCPCONNS_TRUE@@BUILD_WITH_LIBKVM_NLIST_TRUE@am__append_362 = -lkvm
-@BUILD_PLUGIN_TEAMSPEAK2_TRUE@am__append_363 = teamspeak2.la
-@BUILD_PLUGIN_TEAMSPEAK2_TRUE@am__append_364 = "-dlopen" teamspeak2.la
-@BUILD_PLUGIN_TEAMSPEAK2_TRUE@am__append_365 = teamspeak2.la
-@BUILD_PLUGIN_TED_TRUE@am__append_366 = ted.la
-@BUILD_PLUGIN_TED_TRUE@am__append_367 = "-dlopen" ted.la
-@BUILD_PLUGIN_TED_TRUE@am__append_368 = ted.la
-@BUILD_PLUGIN_THERMAL_TRUE@am__append_369 = thermal.la
-@BUILD_PLUGIN_THERMAL_TRUE@am__append_370 = "-dlopen" thermal.la
-@BUILD_PLUGIN_THERMAL_TRUE@am__append_371 = thermal.la
-@BUILD_PLUGIN_THRESHOLD_TRUE@am__append_372 = threshold.la
-@BUILD_PLUGIN_THRESHOLD_TRUE@am__append_373 = "-dlopen" threshold.la
-@BUILD_PLUGIN_THRESHOLD_TRUE@am__append_374 = threshold.la
-@BUILD_PLUGIN_TOKYOTYRANT_TRUE@am__append_375 = tokyotyrant.la
-@BUILD_PLUGIN_TOKYOTYRANT_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_376 = -lsocket
-@BUILD_PLUGIN_TOKYOTYRANT_TRUE@am__append_377 = "-dlopen" tokyotyrant.la
-@BUILD_PLUGIN_TOKYOTYRANT_TRUE@am__append_378 = tokyotyrant.la
-@BUILD_PLUGIN_UNIXSOCK_TRUE@am__append_379 = unixsock.la
-@BUILD_PLUGIN_UNIXSOCK_TRUE@am__append_380 = "-dlopen" unixsock.la
-@BUILD_PLUGIN_UNIXSOCK_TRUE@am__append_381 = unixsock.la
-@BUILD_PLUGIN_UPTIME_TRUE@am__append_382 = uptime.la
-@BUILD_PLUGIN_UPTIME_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_383 = -lkstat
-@BUILD_PLUGIN_UPTIME_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_384 = -lperfstat
-@BUILD_PLUGIN_UPTIME_TRUE@am__append_385 = "-dlopen" uptime.la
-@BUILD_PLUGIN_UPTIME_TRUE@am__append_386 = uptime.la
-@BUILD_PLUGIN_USERS_TRUE@am__append_387 = users.la
-@BUILD_PLUGIN_USERS_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_388 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
-@BUILD_PLUGIN_USERS_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_389 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
-@BUILD_PLUGIN_USERS_TRUE@am__append_390 = "-dlopen" users.la
-@BUILD_PLUGIN_USERS_TRUE@am__append_391 = users.la
-@BUILD_PLUGIN_UUID_TRUE@am__append_392 = uuid.la
-@BUILD_PLUGIN_UUID_TRUE@am__append_393 = "-dlopen" uuid.la
-@BUILD_PLUGIN_UUID_TRUE@am__append_394 = uuid.la
-@BUILD_PLUGIN_VARNISH_TRUE@am__append_395 = varnish.la
-@BUILD_PLUGIN_VARNISH_TRUE@am__append_396 = "-dlopen" varnish.la
-@BUILD_PLUGIN_VARNISH_TRUE@am__append_397 = varnish.la
-@BUILD_PLUGIN_VMEM_TRUE@am__append_398 = vmem.la
-@BUILD_PLUGIN_VMEM_TRUE@am__append_399 = "-dlopen" vmem.la
-@BUILD_PLUGIN_VMEM_TRUE@am__append_400 = vmem.la
-@BUILD_PLUGIN_VSERVER_TRUE@am__append_401 = vserver.la
-@BUILD_PLUGIN_VSERVER_TRUE@am__append_402 = "-dlopen" vserver.la
-@BUILD_PLUGIN_VSERVER_TRUE@am__append_403 = vserver.la
-@BUILD_PLUGIN_WIRELESS_TRUE@am__append_404 = wireless.la
-@BUILD_PLUGIN_WIRELESS_TRUE@am__append_405 = "-dlopen" wireless.la
-@BUILD_PLUGIN_WIRELESS_TRUE@am__append_406 = wireless.la
-@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am__append_407 = write_graphite.la
-@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am__append_408 = "-dlopen" write_graphite.la
-@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am__append_409 = write_graphite.la
-@BUILD_PLUGIN_WRITE_HTTP_TRUE@am__append_410 = write_http.la
-@BUILD_PLUGIN_WRITE_HTTP_TRUE@am__append_411 = "-dlopen" write_http.la
-@BUILD_PLUGIN_WRITE_HTTP_TRUE@@BUILD_WITH_LIBCURL_TRUE@am__append_412 = $(BUILD_WITH_LIBCURL_CFLAGS)
-@BUILD_PLUGIN_WRITE_HTTP_TRUE@@BUILD_WITH_LIBCURL_TRUE@am__append_413 = $(BUILD_WITH_LIBCURL_LIBS)
-@BUILD_PLUGIN_WRITE_HTTP_TRUE@am__append_414 = write_http.la
-@BUILD_PLUGIN_WRITE_MONGODB_TRUE@am__append_415 = write_mongodb.la
-@BUILD_PLUGIN_WRITE_MONGODB_TRUE@am__append_416 = "-dlopen" write_mongodb.la
-@BUILD_PLUGIN_WRITE_MONGODB_TRUE@am__append_417 = write_mongodb.la
-@BUILD_PLUGIN_WRITE_REDIS_TRUE@am__append_418 = write_redis.la
-@BUILD_PLUGIN_WRITE_REDIS_TRUE@am__append_419 = "-dlopen" write_redis.la
-@BUILD_PLUGIN_WRITE_REDIS_TRUE@am__append_420 = write_redis.la
-@BUILD_PLUGIN_XMMS_TRUE@am__append_421 = xmms.la
-@BUILD_PLUGIN_XMMS_TRUE@am__append_422 = "-dlopen" xmms.la
-@BUILD_PLUGIN_XMMS_TRUE@am__append_423 = xmms.la
-@BUILD_PLUGIN_ZFS_ARC_TRUE@am__append_424 = zfs_arc.la
-@BUILD_PLUGIN_ZFS_ARC_TRUE@am__append_425 = "-dlopen" zfs_arc.la
-@BUILD_PLUGIN_ZFS_ARC_TRUE@am__append_426 = zfs_arc.la
-@BUILD_FEATURE_DEBUG_TRUE@am__append_427 = utils_vl_lookup_test
+@BUILD_PLUGIN_TAIL_CSV_TRUE@am__append_339 = tail_csv.la
+@BUILD_PLUGIN_TAIL_CSV_TRUE@am__append_340 = "-dlopen" tail_csv.la
+@BUILD_PLUGIN_TAIL_CSV_TRUE@am__append_341 = tail_csv.la
+@BUILD_PLUGIN_TAPE_TRUE@am__append_342 = tape.la
+@BUILD_PLUGIN_TAPE_TRUE@am__append_343 = "-dlopen" tape.la
+@BUILD_PLUGIN_TAPE_TRUE@am__append_344 = tape.la
+@BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@am__append_345 = target_notification.la
+@BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@am__append_346 = "-dlopen" target_notification.la
+@BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@am__append_347 = target_notification.la
+@BUILD_PLUGIN_TARGET_REPLACE_TRUE@am__append_348 = target_replace.la
+@BUILD_PLUGIN_TARGET_REPLACE_TRUE@am__append_349 = "-dlopen" target_replace.la
+@BUILD_PLUGIN_TARGET_REPLACE_TRUE@am__append_350 = target_replace.la
+@BUILD_PLUGIN_TARGET_SCALE_TRUE@am__append_351 = target_scale.la
+@BUILD_PLUGIN_TARGET_SCALE_TRUE@am__append_352 = "-dlopen" target_scale.la
+@BUILD_PLUGIN_TARGET_SCALE_TRUE@am__append_353 = target_scale.la
+@BUILD_PLUGIN_TARGET_SET_TRUE@am__append_354 = target_set.la
+@BUILD_PLUGIN_TARGET_SET_TRUE@am__append_355 = "-dlopen" target_set.la
+@BUILD_PLUGIN_TARGET_SET_TRUE@am__append_356 = target_set.la
+@BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@am__append_357 = target_v5upgrade.la
+@BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@am__append_358 = "-dlopen" target_v5upgrade.la
+@BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@am__append_359 = target_v5upgrade.la
+@BUILD_PLUGIN_TCPCONNS_TRUE@am__append_360 = tcpconns.la
+@BUILD_PLUGIN_TCPCONNS_TRUE@am__append_361 = "-dlopen" tcpconns.la
+@BUILD_PLUGIN_TCPCONNS_TRUE@am__append_362 = tcpconns.la
+@BUILD_PLUGIN_TCPCONNS_TRUE@@BUILD_WITH_LIBKVM_NLIST_TRUE@am__append_363 = -lkvm
+@BUILD_PLUGIN_TEAMSPEAK2_TRUE@am__append_364 = teamspeak2.la
+@BUILD_PLUGIN_TEAMSPEAK2_TRUE@am__append_365 = "-dlopen" teamspeak2.la
+@BUILD_PLUGIN_TEAMSPEAK2_TRUE@am__append_366 = teamspeak2.la
+@BUILD_PLUGIN_TED_TRUE@am__append_367 = ted.la
+@BUILD_PLUGIN_TED_TRUE@am__append_368 = "-dlopen" ted.la
+@BUILD_PLUGIN_TED_TRUE@am__append_369 = ted.la
+@BUILD_PLUGIN_THERMAL_TRUE@am__append_370 = thermal.la
+@BUILD_PLUGIN_THERMAL_TRUE@am__append_371 = "-dlopen" thermal.la
+@BUILD_PLUGIN_THERMAL_TRUE@am__append_372 = thermal.la
+@BUILD_PLUGIN_THRESHOLD_TRUE@am__append_373 = threshold.la
+@BUILD_PLUGIN_THRESHOLD_TRUE@am__append_374 = "-dlopen" threshold.la
+@BUILD_PLUGIN_THRESHOLD_TRUE@am__append_375 = threshold.la
+@BUILD_PLUGIN_TOKYOTYRANT_TRUE@am__append_376 = tokyotyrant.la
+@BUILD_PLUGIN_TOKYOTYRANT_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_377 = -lsocket
+@BUILD_PLUGIN_TOKYOTYRANT_TRUE@am__append_378 = "-dlopen" tokyotyrant.la
+@BUILD_PLUGIN_TOKYOTYRANT_TRUE@am__append_379 = tokyotyrant.la
+@BUILD_PLUGIN_UNIXSOCK_TRUE@am__append_380 = unixsock.la
+@BUILD_PLUGIN_UNIXSOCK_TRUE@am__append_381 = "-dlopen" unixsock.la
+@BUILD_PLUGIN_UNIXSOCK_TRUE@am__append_382 = unixsock.la
+@BUILD_PLUGIN_UPTIME_TRUE@am__append_383 = uptime.la
+@BUILD_PLUGIN_UPTIME_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_384 = -lkstat
+@BUILD_PLUGIN_UPTIME_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_385 = -lperfstat
+@BUILD_PLUGIN_UPTIME_TRUE@am__append_386 = "-dlopen" uptime.la
+@BUILD_PLUGIN_UPTIME_TRUE@am__append_387 = uptime.la
+@BUILD_PLUGIN_USERS_TRUE@am__append_388 = users.la
+@BUILD_PLUGIN_USERS_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_389 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
+@BUILD_PLUGIN_USERS_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_390 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
+@BUILD_PLUGIN_USERS_TRUE@am__append_391 = "-dlopen" users.la
+@BUILD_PLUGIN_USERS_TRUE@am__append_392 = users.la
+@BUILD_PLUGIN_UUID_TRUE@am__append_393 = uuid.la
+@BUILD_PLUGIN_UUID_TRUE@am__append_394 = "-dlopen" uuid.la
+@BUILD_PLUGIN_UUID_TRUE@am__append_395 = uuid.la
+@BUILD_PLUGIN_VARNISH_TRUE@am__append_396 = varnish.la
+@BUILD_PLUGIN_VARNISH_TRUE@am__append_397 = "-dlopen" varnish.la
+@BUILD_PLUGIN_VARNISH_TRUE@am__append_398 = varnish.la
+@BUILD_PLUGIN_VMEM_TRUE@am__append_399 = vmem.la
+@BUILD_PLUGIN_VMEM_TRUE@am__append_400 = "-dlopen" vmem.la
+@BUILD_PLUGIN_VMEM_TRUE@am__append_401 = vmem.la
+@BUILD_PLUGIN_VSERVER_TRUE@am__append_402 = vserver.la
+@BUILD_PLUGIN_VSERVER_TRUE@am__append_403 = "-dlopen" vserver.la
+@BUILD_PLUGIN_VSERVER_TRUE@am__append_404 = vserver.la
+@BUILD_PLUGIN_WIRELESS_TRUE@am__append_405 = wireless.la
+@BUILD_PLUGIN_WIRELESS_TRUE@am__append_406 = "-dlopen" wireless.la
+@BUILD_PLUGIN_WIRELESS_TRUE@am__append_407 = wireless.la
+@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am__append_408 = write_graphite.la
+@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am__append_409 = "-dlopen" write_graphite.la
+@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am__append_410 = write_graphite.la
+@BUILD_PLUGIN_WRITE_HTTP_TRUE@am__append_411 = write_http.la
+@BUILD_PLUGIN_WRITE_HTTP_TRUE@am__append_412 = "-dlopen" write_http.la
+@BUILD_PLUGIN_WRITE_HTTP_TRUE@@BUILD_WITH_LIBCURL_TRUE@am__append_413 = $(BUILD_WITH_LIBCURL_CFLAGS)
+@BUILD_PLUGIN_WRITE_HTTP_TRUE@@BUILD_WITH_LIBCURL_TRUE@am__append_414 = $(BUILD_WITH_LIBCURL_LIBS)
+@BUILD_PLUGIN_WRITE_HTTP_TRUE@am__append_415 = write_http.la
+@BUILD_PLUGIN_WRITE_MONGODB_TRUE@am__append_416 = write_mongodb.la
+@BUILD_PLUGIN_WRITE_MONGODB_TRUE@am__append_417 = "-dlopen" write_mongodb.la
+@BUILD_PLUGIN_WRITE_MONGODB_TRUE@am__append_418 = write_mongodb.la
+@BUILD_PLUGIN_WRITE_REDIS_TRUE@am__append_419 = write_redis.la
+@BUILD_PLUGIN_WRITE_REDIS_TRUE@am__append_420 = "-dlopen" write_redis.la
+@BUILD_PLUGIN_WRITE_REDIS_TRUE@am__append_421 = write_redis.la
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am__append_422 = write_riemann.la
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am__append_423 = "-dlopen" write_riemann.la
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am__append_424 = write_riemann.la
+@BUILD_PLUGIN_XMMS_TRUE@am__append_425 = xmms.la
+@BUILD_PLUGIN_XMMS_TRUE@am__append_426 = "-dlopen" xmms.la
+@BUILD_PLUGIN_XMMS_TRUE@am__append_427 = xmms.la
+@BUILD_PLUGIN_ZFS_ARC_TRUE@am__append_428 = zfs_arc.la
+@BUILD_PLUGIN_ZFS_ARC_TRUE@am__append_429 = "-dlopen" zfs_arc.la
+@BUILD_PLUGIN_ZFS_ARC_TRUE@am__append_430 = zfs_arc.la
+@HAVE_PROTOC_C_TRUE@am__append_431 = pinba.pb-c.c pinba.pb-c.h \
+@HAVE_PROTOC_C_TRUE@	riemann.pb-c.c riemann.pb-c.h
+@HAVE_PROTOC_C_TRUE@am__append_432 = pinba.pb-c.c pinba.pb-c.h \
+@HAVE_PROTOC_C_TRUE@	riemann.pb-c.c riemann.pb-c.h
+@BUILD_FEATURE_DEBUG_TRUE@am__append_433 = utils_vl_lookup_test
 subdir = src
 DIST_COMMON = $(dist_man_MANS) $(srcdir)/Makefile.am \
 	$(srcdir)/Makefile.in $(srcdir)/collectd.conf.in \
 	$(srcdir)/config.h.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.in
@@ -1164,13 +1172,14 @@
 	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(pf_la_LDFLAGS) \
 	$(LDFLAGS) -o $@
 @BUILD_PLUGIN_PF_TRUE@am_pf_la_rpath = -rpath $(pkglibdir)
 pinba_la_DEPENDENCIES =
 am__pinba_la_SOURCES_DIST = pinba.c
 @BUILD_PLUGIN_PINBA_TRUE@am_pinba_la_OBJECTS = pinba.lo
-pinba_la_OBJECTS = $(am_pinba_la_OBJECTS)
+@BUILD_PLUGIN_PINBA_TRUE@nodist_pinba_la_OBJECTS = pinba.pb-c.lo
+pinba_la_OBJECTS = $(am_pinba_la_OBJECTS) $(nodist_pinba_la_OBJECTS)
 pinba_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(pinba_la_LDFLAGS) \
 	$(LDFLAGS) -o $@
 @BUILD_PLUGIN_PINBA_TRUE@am_pinba_la_rpath = -rpath $(pkglibdir)
 ping_la_DEPENDENCIES =
 am__ping_la_SOURCES_DIST = ping.c
@@ -1333,12 +1342,20 @@
 @BUILD_PLUGIN_TAIL_TRUE@am_tail_la_OBJECTS = tail.lo
 tail_la_OBJECTS = $(am_tail_la_OBJECTS)
 tail_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(tail_la_LDFLAGS) \
 	$(LDFLAGS) -o $@
 @BUILD_PLUGIN_TAIL_TRUE@am_tail_la_rpath = -rpath $(pkglibdir)
+tail_csv_la_LIBADD =
+am__tail_csv_la_SOURCES_DIST = tail_csv.c
+@BUILD_PLUGIN_TAIL_CSV_TRUE@am_tail_csv_la_OBJECTS = tail_csv.lo
+tail_csv_la_OBJECTS = $(am_tail_csv_la_OBJECTS)
+tail_csv_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(tail_csv_la_LDFLAGS) $(LDFLAGS) -o $@
+@BUILD_PLUGIN_TAIL_CSV_TRUE@am_tail_csv_la_rpath = -rpath $(pkglibdir)
 tape_la_DEPENDENCIES =
 am__tape_la_SOURCES_DIST = tape.c
 @BUILD_PLUGIN_TAPE_TRUE@am_tape_la_OBJECTS = tape.lo
 tape_la_OBJECTS = $(am_tape_la_OBJECTS)
 tape_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(tape_la_LDFLAGS) \
@@ -1572,12 +1589,25 @@
 write_redis_la_OBJECTS = $(am_write_redis_la_OBJECTS)
 write_redis_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(write_redis_la_CFLAGS) \
 	$(CFLAGS) $(write_redis_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@am_write_redis_la_rpath = -rpath \
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@	$(pkglibdir)
+write_riemann_la_DEPENDENCIES =
+am__write_riemann_la_SOURCES_DIST = write_riemann.c
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am_write_riemann_la_OBJECTS =  \
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@	write_riemann.lo
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@nodist_write_riemann_la_OBJECTS =  \
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@	riemann.pb-c.lo
+write_riemann_la_OBJECTS = $(am_write_riemann_la_OBJECTS) \
+	$(nodist_write_riemann_la_OBJECTS)
+write_riemann_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(write_riemann_la_LDFLAGS) $(LDFLAGS) -o $@
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am_write_riemann_la_rpath = -rpath \
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@	$(pkglibdir)
 @BUILD_PLUGIN_XMMS_TRUE@xmms_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
 am__xmms_la_SOURCES_DIST = xmms.c
 @BUILD_PLUGIN_XMMS_TRUE@am_xmms_la_OBJECTS = xmms_la-xmms.lo
 xmms_la_OBJECTS = $(am_xmms_la_OBJECTS)
 xmms_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CCLD) $(xmms_la_CFLAGS) $(CFLAGS) \
@@ -1602,12 +1632,13 @@
 	collectd-utils_cache.$(OBJEXT) \
 	collectd-utils_complain.$(OBJEXT) \
 	collectd-utils_heap.$(OBJEXT) \
 	collectd-utils_ignorelist.$(OBJEXT) \
 	collectd-utils_llist.$(OBJEXT) \
 	collectd-utils_parse_option.$(OBJEXT) \
+	collectd-utils_random.$(OBJEXT) \
 	collectd-utils_tail_match.$(OBJEXT) \
 	collectd-utils_match.$(OBJEXT) collectd-utils_subst.$(OBJEXT) \
 	collectd-utils_tail.$(OBJEXT) collectd-utils_time.$(OBJEXT) \
 	collectd-types_list.$(OBJEXT)
 collectd_OBJECTS = $(am_collectd_OBJECTS)
 @BUILD_WITH_LIBSTATGRAB_TRUE@am__DEPENDENCIES_17 =  \
@@ -1679,32 +1710,34 @@
 	$(netapp_la_SOURCES) $(netlink_la_SOURCES) \
 	$(network_la_SOURCES) $(nfs_la_SOURCES) $(nginx_la_SOURCES) \
 	$(notify_desktop_la_SOURCES) $(notify_email_la_SOURCES) \
 	$(ntpd_la_SOURCES) $(numa_la_SOURCES) $(nut_la_SOURCES) \
 	$(olsrd_la_SOURCES) $(onewire_la_SOURCES) \
 	$(openvpn_la_SOURCES) $(oracle_la_SOURCES) $(perl_la_SOURCES) \
-	$(pf_la_SOURCES) $(pinba_la_SOURCES) $(ping_la_SOURCES) \
+	$(pf_la_SOURCES) $(pinba_la_SOURCES) \
+	$(nodist_pinba_la_SOURCES) $(ping_la_SOURCES) \
 	$(postgresql_la_SOURCES) $(powerdns_la_SOURCES) \
 	$(processes_la_SOURCES) $(protocols_la_SOURCES) \
 	$(python_la_SOURCES) $(redis_la_SOURCES) \
 	$(routeros_la_SOURCES) $(rrdcached_la_SOURCES) \
 	$(rrdtool_la_SOURCES) $(sensors_la_SOURCES) \
 	$(serial_la_SOURCES) $(snmp_la_SOURCES) $(swap_la_SOURCES) \
 	$(syslog_la_SOURCES) $(table_la_SOURCES) $(tail_la_SOURCES) \
-	$(tape_la_SOURCES) $(target_notification_la_SOURCES) \
-	$(target_replace_la_SOURCES) $(target_scale_la_SOURCES) \
-	$(target_set_la_SOURCES) $(target_v5upgrade_la_SOURCES) \
-	$(tcpconns_la_SOURCES) $(teamspeak2_la_SOURCES) \
-	$(ted_la_SOURCES) $(thermal_la_SOURCES) \
-	$(threshold_la_SOURCES) $(tokyotyrant_la_SOURCES) \
-	$(unixsock_la_SOURCES) $(uptime_la_SOURCES) \
-	$(users_la_SOURCES) $(uuid_la_SOURCES) $(varnish_la_SOURCES) \
-	$(vmem_la_SOURCES) $(vserver_la_SOURCES) \
+	$(tail_csv_la_SOURCES) $(tape_la_SOURCES) \
+	$(target_notification_la_SOURCES) $(target_replace_la_SOURCES) \
+	$(target_scale_la_SOURCES) $(target_set_la_SOURCES) \
+	$(target_v5upgrade_la_SOURCES) $(tcpconns_la_SOURCES) \
+	$(teamspeak2_la_SOURCES) $(ted_la_SOURCES) \
+	$(thermal_la_SOURCES) $(threshold_la_SOURCES) \
+	$(tokyotyrant_la_SOURCES) $(unixsock_la_SOURCES) \
+	$(uptime_la_SOURCES) $(users_la_SOURCES) $(uuid_la_SOURCES) \
+	$(varnish_la_SOURCES) $(vmem_la_SOURCES) $(vserver_la_SOURCES) \
 	$(wireless_la_SOURCES) $(write_graphite_la_SOURCES) \
 	$(write_http_la_SOURCES) $(write_mongodb_la_SOURCES) \
-	$(write_redis_la_SOURCES) $(xmms_la_SOURCES) \
+	$(write_redis_la_SOURCES) $(write_riemann_la_SOURCES) \
+	$(nodist_write_riemann_la_SOURCES) $(xmms_la_SOURCES) \
 	$(zfs_arc_la_SOURCES) $(collectd_SOURCES) \
 	$(collectd_nagios_SOURCES) $(collectd_tg_SOURCES) \
 	$(collectdctl_SOURCES) $(collectdmon_SOURCES) \
 	$(utils_vl_lookup_test_SOURCES)
 DIST_SOURCES = $(am__aggregation_la_SOURCES_DIST) \
 	$(am__amqp_la_SOURCES_DIST) $(am__apache_la_SOURCES_DIST) \
@@ -1756,13 +1789,13 @@
 	$(am__redis_la_SOURCES_DIST) $(am__routeros_la_SOURCES_DIST) \
 	$(am__rrdcached_la_SOURCES_DIST) \
 	$(am__rrdtool_la_SOURCES_DIST) $(am__sensors_la_SOURCES_DIST) \
 	$(am__serial_la_SOURCES_DIST) $(am__snmp_la_SOURCES_DIST) \
 	$(am__swap_la_SOURCES_DIST) $(am__syslog_la_SOURCES_DIST) \
 	$(am__table_la_SOURCES_DIST) $(am__tail_la_SOURCES_DIST) \
-	$(am__tape_la_SOURCES_DIST) \
+	$(am__tail_csv_la_SOURCES_DIST) $(am__tape_la_SOURCES_DIST) \
 	$(am__target_notification_la_SOURCES_DIST) \
 	$(am__target_replace_la_SOURCES_DIST) \
 	$(am__target_scale_la_SOURCES_DIST) \
 	$(am__target_set_la_SOURCES_DIST) \
 	$(am__target_v5upgrade_la_SOURCES_DIST) \
 	$(am__tcpconns_la_SOURCES_DIST) \
@@ -1774,16 +1807,18 @@
 	$(am__users_la_SOURCES_DIST) $(am__uuid_la_SOURCES_DIST) \
 	$(am__varnish_la_SOURCES_DIST) $(am__vmem_la_SOURCES_DIST) \
 	$(am__vserver_la_SOURCES_DIST) $(am__wireless_la_SOURCES_DIST) \
 	$(am__write_graphite_la_SOURCES_DIST) \
 	$(am__write_http_la_SOURCES_DIST) \
 	$(am__write_mongodb_la_SOURCES_DIST) \
-	$(am__write_redis_la_SOURCES_DIST) $(am__xmms_la_SOURCES_DIST) \
-	$(am__zfs_arc_la_SOURCES_DIST) $(collectd_SOURCES) \
-	$(collectd_nagios_SOURCES) $(collectd_tg_SOURCES) \
-	$(collectdctl_SOURCES) $(collectdmon_SOURCES) \
+	$(am__write_redis_la_SOURCES_DIST) \
+	$(am__write_riemann_la_SOURCES_DIST) \
+	$(am__xmms_la_SOURCES_DIST) $(am__zfs_arc_la_SOURCES_DIST) \
+	$(collectd_SOURCES) $(collectd_nagios_SOURCES) \
+	$(collectd_tg_SOURCES) $(collectdctl_SOURCES) \
+	$(collectdmon_SOURCES) \
 	$(am__utils_vl_lookup_test_SOURCES_DIST)
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
 	install-dvi-recursive install-exec-recursive \
 	install-html-recursive install-info-recursive \
 	install-pdf-recursive install-ps-recursive install-recursive \
@@ -2085,12 +2120,13 @@
 		   utils_cache.c utils_cache.h \
 		   utils_complain.c utils_complain.h \
 		   utils_heap.c utils_heap.h \
 		   utils_ignorelist.c utils_ignorelist.h \
 		   utils_llist.c utils_llist.h \
 		   utils_parse_option.c utils_parse_option.h \
+		   utils_random.c utils_random.h \
 		   utils_tail_match.c utils_tail_match.h \
 		   utils_match.c utils_match.h \
 		   utils_subst.c utils_subst.h \
 		   utils_tail.c utils_tail.h \
 		   utils_time.c utils_time.h \
 		   types_list.c types_list.h
@@ -2121,27 +2157,28 @@
 	$(am__append_210) $(am__append_215) $(am__append_218) \
 	$(am__append_225) $(am__append_228) $(am__append_231) \
 	$(am__append_236) $(am__append_239) $(am__append_242) \
 	$(am__append_246) $(am__append_249) $(am__append_252) \
 	$(am__append_256) $(am__append_259) $(am__append_262) \
 	$(am__append_265) $(am__append_269) $(am__append_272) \
-	$(am__append_277) $(am__append_280) $(am__append_283) \
-	$(am__append_286) $(am__append_290) $(am__append_293) \
-	$(am__append_297) $(am__append_300) $(am__append_303) \
-	$(am__append_306) $(am__append_309) $(am__append_312) \
-	$(am__append_315) $(am__append_321) $(am__append_324) \
-	$(am__append_333) $(am__append_336) $(am__append_339) \
-	$(am__append_342) $(am__append_345) $(am__append_348) \
-	$(am__append_351) $(am__append_354) $(am__append_357) \
-	$(am__append_360) $(am__append_364) $(am__append_367) \
-	$(am__append_370) $(am__append_373) $(am__append_377) \
-	$(am__append_380) $(am__append_385) $(am__append_390) \
-	$(am__append_393) $(am__append_396) $(am__append_399) \
-	$(am__append_402) $(am__append_405) $(am__append_408) \
-	$(am__append_411) $(am__append_416) $(am__append_419) \
-	$(am__append_422) $(am__append_425)
+	$(am__append_275) $(am__append_278) $(am__append_281) \
+	$(am__append_284) $(am__append_288) $(am__append_291) \
+	$(am__append_295) $(am__append_298) $(am__append_301) \
+	$(am__append_304) $(am__append_307) $(am__append_310) \
+	$(am__append_313) $(am__append_319) $(am__append_322) \
+	$(am__append_331) $(am__append_334) $(am__append_337) \
+	$(am__append_340) $(am__append_343) $(am__append_346) \
+	$(am__append_349) $(am__append_352) $(am__append_355) \
+	$(am__append_358) $(am__append_361) $(am__append_365) \
+	$(am__append_368) $(am__append_371) $(am__append_374) \
+	$(am__append_378) $(am__append_381) $(am__append_386) \
+	$(am__append_391) $(am__append_394) $(am__append_397) \
+	$(am__append_400) $(am__append_403) $(am__append_406) \
+	$(am__append_409) $(am__append_412) $(am__append_417) \
+	$(am__append_420) $(am__append_423) $(am__append_426) \
+	$(am__append_429)
 collectd_DEPENDENCIES = $(am__append_14) $(am__append_25) \
 	$(am__append_28) $(am__append_33) $(am__append_37) \
 	$(am__append_40) $(am__append_43) $(am__append_47) \
 	$(am__append_50) $(am__append_53) $(am__append_57) \
 	$(am__append_65) $(am__append_68) $(am__append_71) \
 	$(am__append_76) $(am__append_81) $(am__append_84) \
@@ -2159,27 +2196,28 @@
 	$(am__append_208) $(am__append_213) $(am__append_216) \
 	$(am__append_219) $(am__append_226) $(am__append_229) \
 	$(am__append_232) $(am__append_237) $(am__append_240) \
 	$(am__append_243) $(am__append_247) $(am__append_250) \
 	$(am__append_253) $(am__append_257) $(am__append_260) \
 	$(am__append_263) $(am__append_266) $(am__append_270) \
-	$(am__append_273) $(am__append_278) $(am__append_281) \
-	$(am__append_284) $(am__append_287) $(am__append_291) \
-	$(am__append_294) $(am__append_298) $(am__append_301) \
-	$(am__append_304) $(am__append_307) $(am__append_310) \
-	$(am__append_313) $(am__append_316) $(am__append_322) \
-	$(am__append_325) $(am__append_334) $(am__append_337) \
-	$(am__append_340) $(am__append_343) $(am__append_346) \
-	$(am__append_349) $(am__append_352) $(am__append_355) \
-	$(am__append_358) $(am__append_361) $(am__append_365) \
-	$(am__append_368) $(am__append_371) $(am__append_374) \
-	$(am__append_378) $(am__append_381) $(am__append_386) \
-	$(am__append_391) $(am__append_394) $(am__append_397) \
-	$(am__append_400) $(am__append_403) $(am__append_406) \
-	$(am__append_409) $(am__append_414) $(am__append_417) \
-	$(am__append_420) $(am__append_423) $(am__append_426)
+	$(am__append_273) $(am__append_276) $(am__append_279) \
+	$(am__append_282) $(am__append_285) $(am__append_289) \
+	$(am__append_292) $(am__append_296) $(am__append_299) \
+	$(am__append_302) $(am__append_305) $(am__append_308) \
+	$(am__append_311) $(am__append_314) $(am__append_320) \
+	$(am__append_323) $(am__append_332) $(am__append_335) \
+	$(am__append_338) $(am__append_341) $(am__append_344) \
+	$(am__append_347) $(am__append_350) $(am__append_353) \
+	$(am__append_356) $(am__append_359) $(am__append_362) \
+	$(am__append_366) $(am__append_369) $(am__append_372) \
+	$(am__append_375) $(am__append_379) $(am__append_382) \
+	$(am__append_387) $(am__append_392) $(am__append_395) \
+	$(am__append_398) $(am__append_401) $(am__append_404) \
+	$(am__append_407) $(am__append_410) $(am__append_415) \
+	$(am__append_418) $(am__append_421) $(am__append_424) \
+	$(am__append_427) $(am__append_430)
 collectdmon_SOURCES = collectdmon.c
 collectdmon_CPPFLAGS = $(AM_CPPFLAGS)
 collectd_nagios_SOURCES = collectd-nagios.c
 collectd_nagios_CPPFLAGS = $(AM_CPPFLAGS) -I$(top_builddir)/src/libcollectdclient/collectd
 collectd_nagios_LDADD = $(am__append_16) $(am__append_17) \
 	libcollectdclient/libcollectdclient.la
@@ -2216,29 +2254,30 @@
 	$(am__append_209) $(am__append_214) $(am__append_217) \
 	$(am__append_220) $(am__append_227) $(am__append_230) \
 	$(am__append_233) $(am__append_238) $(am__append_241) \
 	$(am__append_244) $(am__append_248) $(am__append_251) \
 	$(am__append_254) $(am__append_258) $(am__append_261) \
 	$(am__append_264) $(am__append_267) $(am__append_271) \
-	$(am__append_276) $(am__append_279) $(am__append_282) \
-	$(am__append_285) $(am__append_288) $(am__append_292) \
-	$(am__append_296) $(am__append_299) $(am__append_302) \
-	$(am__append_305) $(am__append_308) $(am__append_311) \
-	$(am__append_314) $(am__append_317) $(am__append_323) \
-	$(am__append_332) $(am__append_335) $(am__append_338) \
-	$(am__append_341) $(am__append_344) $(am__append_347) \
-	$(am__append_350) $(am__append_353) $(am__append_356) \
-	$(am__append_359) $(am__append_363) $(am__append_366) \
-	$(am__append_369) $(am__append_372) $(am__append_375) \
-	$(am__append_379) $(am__append_382) $(am__append_387) \
-	$(am__append_392) $(am__append_395) $(am__append_398) \
-	$(am__append_401) $(am__append_404) $(am__append_407) \
-	$(am__append_410) $(am__append_415) $(am__append_418) \
-	$(am__append_421) $(am__append_424)
-BUILT_SOURCES = $(am__append_274) $(dist_man_MANS)
-CLEANFILES = $(am__append_275)
+	$(am__append_274) $(am__append_277) $(am__append_280) \
+	$(am__append_283) $(am__append_286) $(am__append_290) \
+	$(am__append_294) $(am__append_297) $(am__append_300) \
+	$(am__append_303) $(am__append_306) $(am__append_309) \
+	$(am__append_312) $(am__append_315) $(am__append_321) \
+	$(am__append_330) $(am__append_333) $(am__append_336) \
+	$(am__append_339) $(am__append_342) $(am__append_345) \
+	$(am__append_348) $(am__append_351) $(am__append_354) \
+	$(am__append_357) $(am__append_360) $(am__append_364) \
+	$(am__append_367) $(am__append_370) $(am__append_373) \
+	$(am__append_376) $(am__append_380) $(am__append_383) \
+	$(am__append_388) $(am__append_393) $(am__append_396) \
+	$(am__append_399) $(am__append_402) $(am__append_405) \
+	$(am__append_408) $(am__append_411) $(am__append_416) \
+	$(am__append_419) $(am__append_422) $(am__append_425) \
+	$(am__append_428)
+BUILT_SOURCES = $(dist_man_MANS) $(am__append_432)
+CLEANFILES = $(am__append_431)
 @BUILD_PLUGIN_AGGREGATION_TRUE@aggregation_la_SOURCES = aggregation.c \
 @BUILD_PLUGIN_AGGREGATION_TRUE@                         utils_vl_lookup.c utils_vl_lookup.h
 
 @BUILD_PLUGIN_AGGREGATION_TRUE@aggregation_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_AGGREGATION_TRUE@aggregation_la_LIBADD = 
 @BUILD_PLUGIN_AMQP_TRUE@amqp_la_SOURCES = amqp.c \
@@ -2504,12 +2543,13 @@
 @BUILD_PLUGIN_PERL_TRUE@perl_la_LDFLAGS = -module -avoid-version \
 @BUILD_PLUGIN_PERL_TRUE@		$(PERL_LDFLAGS)
 
 @BUILD_PLUGIN_PF_TRUE@pf_la_SOURCES = pf.c
 @BUILD_PLUGIN_PF_TRUE@pf_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_PINBA_TRUE@pinba_la_SOURCES = pinba.c
+@BUILD_PLUGIN_PINBA_TRUE@nodist_pinba_la_SOURCES = pinba.pb-c.c pinba.pb-c.h
 @BUILD_PLUGIN_PINBA_TRUE@pinba_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_PINBA_TRUE@pinba_la_LIBADD = -lprotobuf-c
 @BUILD_PLUGIN_PING_TRUE@ping_la_SOURCES = ping.c
 @BUILD_PLUGIN_PING_TRUE@ping_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBOPING_CPPFLAGS)
 @BUILD_PLUGIN_PING_TRUE@ping_la_LDFLAGS = -module -avoid-version $(BUILD_WITH_LIBOPING_LDFLAGS)
 @BUILD_PLUGIN_PING_TRUE@ping_la_LIBADD = -loping -lm
@@ -2523,18 +2563,18 @@
 @BUILD_PLUGIN_POSTGRESQL_TRUE@postgresql_la_LIBADD = -lpq
 @BUILD_PLUGIN_POWERDNS_TRUE@powerdns_la_SOURCES = powerdns.c
 @BUILD_PLUGIN_POWERDNS_TRUE@powerdns_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_SOURCES = python.c pyconfig.c pyvalues.c cpython.h
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_PYTHON_CPPFLAGS)
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_CFLAGS = $(AM_CFLAGS) \
-@BUILD_PLUGIN_PYTHON_TRUE@	$(am__append_289)
+@BUILD_PLUGIN_PYTHON_TRUE@	$(am__append_287)
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_LDFLAGS = -module -avoid-version $(BUILD_WITH_PYTHON_LDFLAGS)
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_LIBADD = $(BUILD_WITH_PYTHON_LIBS)
 @BUILD_PLUGIN_PROCESSES_TRUE@processes_la_SOURCES = processes.c
 @BUILD_PLUGIN_PROCESSES_TRUE@processes_la_LDFLAGS = -module -avoid-version
-@BUILD_PLUGIN_PROCESSES_TRUE@processes_la_LIBADD = $(am__append_295)
+@BUILD_PLUGIN_PROCESSES_TRUE@processes_la_LIBADD = $(am__append_293)
 @BUILD_PLUGIN_PROTOCOLS_TRUE@protocols_la_SOURCES = protocols.c
 @BUILD_PLUGIN_PROTOCOLS_TRUE@protocols_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_SOURCES = redis.c
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_LDFLAGS = -module -avoid-version $(BUILD_WITH_LIBCREDIS_LDFLAGS)
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBCREDIS_CPPFLAGS)
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_LIBADD = -lcredis
@@ -2556,28 +2596,30 @@
 @BUILD_PLUGIN_SENSORS_TRUE@sensors_la_LIBADD = -lsensors
 @BUILD_PLUGIN_SERIAL_TRUE@serial_la_SOURCES = serial.c
 @BUILD_PLUGIN_SERIAL_TRUE@serial_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_SOURCES = snmp.c
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_CFLAGS = $(AM_CFLAGS) \
+@BUILD_PLUGIN_SNMP_TRUE@	$(am__append_316)
+@BUILD_PLUGIN_SNMP_TRUE@snmp_la_LIBADD = $(am__append_317) \
 @BUILD_PLUGIN_SNMP_TRUE@	$(am__append_318)
-@BUILD_PLUGIN_SNMP_TRUE@snmp_la_LIBADD = $(am__append_319) \
-@BUILD_PLUGIN_SNMP_TRUE@	$(am__append_320)
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_SOURCES = swap.c
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_CFLAGS = $(AM_CFLAGS) \
-@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_329)
+@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_327)
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_LDFLAGS = -module -avoid-version
-@BUILD_PLUGIN_SWAP_TRUE@swap_la_LIBADD = $(am__append_326) \
-@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_327) $(am__append_328) \
-@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_330) $(am__append_331)
+@BUILD_PLUGIN_SWAP_TRUE@swap_la_LIBADD = $(am__append_324) \
+@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_325) $(am__append_326) \
+@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_328) $(am__append_329)
 @BUILD_PLUGIN_SYSLOG_TRUE@syslog_la_SOURCES = syslog.c
 @BUILD_PLUGIN_SYSLOG_TRUE@syslog_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_TABLE_TRUE@table_la_SOURCES = table.c
 @BUILD_PLUGIN_TABLE_TRUE@table_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_TAIL_TRUE@tail_la_SOURCES = tail.c
 @BUILD_PLUGIN_TAIL_TRUE@tail_la_LDFLAGS = -module -avoid-version
+@BUILD_PLUGIN_TAIL_CSV_TRUE@tail_csv_la_SOURCES = tail_csv.c
+@BUILD_PLUGIN_TAIL_CSV_TRUE@tail_csv_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_TAPE_TRUE@tape_la_SOURCES = tape.c
 @BUILD_PLUGIN_TAPE_TRUE@tape_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_TAPE_TRUE@tape_la_LIBADD = -lkstat -ldevinfo
 @BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@target_notification_la_SOURCES = target_notification.c
 @BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@target_notification_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_TARGET_REPLACE_TRUE@target_replace_la_SOURCES = target_replace.c
@@ -2587,45 +2629,45 @@
 @BUILD_PLUGIN_TARGET_SET_TRUE@target_set_la_SOURCES = target_set.c
 @BUILD_PLUGIN_TARGET_SET_TRUE@target_set_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@target_v5upgrade_la_SOURCES = target_v5upgrade.c
 @BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@target_v5upgrade_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_SOURCES = tcpconns.c
 @BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_LDFLAGS = -module -avoid-version
-@BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_LIBADD = $(am__append_362)
+@BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_LIBADD = $(am__append_363)
 @BUILD_PLUGIN_TEAMSPEAK2_TRUE@teamspeak2_la_SOURCES = teamspeak2.c
 @BUILD_PLUGIN_TEAMSPEAK2_TRUE@teamspeak2_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_TED_TRUE@ted_la_SOURCES = ted.c
 @BUILD_PLUGIN_TED_TRUE@ted_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_THERMAL_TRUE@thermal_la_SOURCES = thermal.c
 @BUILD_PLUGIN_THERMAL_TRUE@thermal_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_THRESHOLD_TRUE@threshold_la_SOURCES = threshold.c
 @BUILD_PLUGIN_THRESHOLD_TRUE@threshold_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_SOURCES = tokyotyrant.c
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBTOKYOTYRANT_CPPFLAGS)
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_LDFLAGS = -module -avoid-version $(BUILD_WITH_LIBTOKYOTYRANT_LDFLAGS)
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_LIBADD = $(BUILD_WITH_LIBTOKYOTYRANT_LIBS) \
-@BUILD_PLUGIN_TOKYOTYRANT_TRUE@	$(am__append_376)
+@BUILD_PLUGIN_TOKYOTYRANT_TRUE@	$(am__append_377)
 @BUILD_PLUGIN_UNIXSOCK_TRUE@unixsock_la_SOURCES = unixsock.c \
 @BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_flush.h utils_cmd_flush.c \
 @BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_getval.h utils_cmd_getval.c \
 @BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_listval.h utils_cmd_listval.c \
 @BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_putval.h utils_cmd_putval.c \
 @BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_putnotif.h utils_cmd_putnotif.c
 
 @BUILD_PLUGIN_UNIXSOCK_TRUE@unixsock_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_UNIXSOCK_TRUE@unixsock_la_LIBADD = -lpthread
 @BUILD_PLUGIN_UPTIME_TRUE@uptime_la_SOURCES = uptime.c
 @BUILD_PLUGIN_UPTIME_TRUE@uptime_la_CFLAGS = $(AM_CFLAGS)
 @BUILD_PLUGIN_UPTIME_TRUE@uptime_la_LDFLAGS = -module -avoid-version
-@BUILD_PLUGIN_UPTIME_TRUE@uptime_la_LIBADD = $(am__append_383) \
-@BUILD_PLUGIN_UPTIME_TRUE@	$(am__append_384)
+@BUILD_PLUGIN_UPTIME_TRUE@uptime_la_LIBADD = $(am__append_384) \
+@BUILD_PLUGIN_UPTIME_TRUE@	$(am__append_385)
 @BUILD_PLUGIN_USERS_TRUE@users_la_SOURCES = users.c
 @BUILD_PLUGIN_USERS_TRUE@users_la_CFLAGS = $(AM_CFLAGS) \
-@BUILD_PLUGIN_USERS_TRUE@	$(am__append_388)
+@BUILD_PLUGIN_USERS_TRUE@	$(am__append_389)
 @BUILD_PLUGIN_USERS_TRUE@users_la_LDFLAGS = -module -avoid-version
-@BUILD_PLUGIN_USERS_TRUE@users_la_LIBADD = $(am__append_389)
+@BUILD_PLUGIN_USERS_TRUE@users_la_LIBADD = $(am__append_390)
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_SOURCES = uuid.c
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBHAL_CFLAGS)
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_LIBADD = $(BUILD_WITH_LIBHAL_LIBS)
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_VARNISH_TRUE@varnish_la_SOURCES = varnish.c
 @BUILD_PLUGIN_VARNISH_TRUE@varnish_la_LDFLAGS = -module -avoid-version
@@ -2644,23 +2686,27 @@
 @BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@write_graphite_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@write_http_la_SOURCES = write_http.c \
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@			utils_format_json.c utils_format_json.h
 
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@write_http_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@write_http_la_CFLAGS = $(AM_CFLAGS) \
-@BUILD_PLUGIN_WRITE_HTTP_TRUE@	$(am__append_412)
-@BUILD_PLUGIN_WRITE_HTTP_TRUE@write_http_la_LIBADD =  \
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@	$(am__append_413)
+@BUILD_PLUGIN_WRITE_HTTP_TRUE@write_http_la_LIBADD =  \
+@BUILD_PLUGIN_WRITE_HTTP_TRUE@	$(am__append_414)
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@write_mongodb_la_SOURCES = write_mongodb.c
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@write_mongodb_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBMONGOC_CPPFLAGS)
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@write_mongodb_la_LDFLAGS = -module -avoid-version $(BUILD_WITH_LIBMONGOC_LDFLAGS)
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@write_mongodb_la_LIBADD = -lmongoc
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@write_redis_la_SOURCES = write_redis.c
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@write_redis_la_LDFLAGS = -module -avoid-version $(BUILD_WITH_LIBCREDIS_LDFLAGS)
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@write_redis_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBCREDIS_CPPFLAGS)
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@write_redis_la_LIBADD = -lcredis
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@write_riemann_la_SOURCES = write_riemann.c
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@nodist_write_riemann_la_SOURCES = riemann.pb-c.c riemann.pb-c.h
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@write_riemann_la_LDFLAGS = -module -avoid-version
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@write_riemann_la_LIBADD = -lprotobuf-c
 @BUILD_PLUGIN_XMMS_TRUE@xmms_la_SOURCES = xmms.c
 @BUILD_PLUGIN_XMMS_TRUE@xmms_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBXMMS_CFLAGS)
 @BUILD_PLUGIN_XMMS_TRUE@xmms_la_LDFLAGS = -module -avoid-version
 @BUILD_PLUGIN_XMMS_TRUE@xmms_la_LIBADD = $(BUILD_WITH_LIBXMMS_LIBS)
 @BUILD_PLUGIN_ZFS_ARC_TRUE@zfs_arc_la_SOURCES = zfs_arc.c
 @BUILD_PLUGIN_ZFS_ARC_TRUE@zfs_arc_la_CFLAGS = $(AM_CFLAGS)
@@ -2681,18 +2727,22 @@
 		collectd-threshold.5 \
 		collectd-unixsock.5 \
 		types.db.5
 
 
 #collectd_1_SOURCES = collectd.pod
-EXTRA_DIST = types.db pinba.proto collectd.conf.pod collectd-email.pod \
+
+# Protocol buffer for the "pinba" plugin.
+
+# Protocol buffer for the "write_riemann" plugin.
+EXTRA_DIST = types.db collectd.conf.pod collectd-email.pod \
 	collectd-exec.pod collectdctl.pod collectd-java.pod \
 	collectdmon.pod collectd-nagios.pod collectd-perl.pod \
 	collectd-python.pod collectd.pod collectd-snmp.pod \
 	collectd-tg.pod collectd-threshold.pod collectd-unixsock.pod \
-	postgresql_default.conf types.db.pod
+	postgresql_default.conf types.db.pod pinba.proto riemann.proto
 @BUILD_FEATURE_DEBUG_TRUE@utils_vl_lookup_test_SOURCES = utils_vl_lookup_test.c \
 @BUILD_FEATURE_DEBUG_TRUE@                               utils_vl_lookup.h utils_vl_lookup.c \
 @BUILD_FEATURE_DEBUG_TRUE@                               utils_avltree.c utils_avltree.h \
 @BUILD_FEATURE_DEBUG_TRUE@                               common.h
 
 @BUILD_FEATURE_DEBUG_TRUE@utils_vl_lookup_test_CPPFLAGS = $(AM_CPPFLAGS) $(LTDLINCL) -DBUILD_TEST=1
@@ -2953,12 +3003,14 @@
 syslog.la: $(syslog_la_OBJECTS) $(syslog_la_DEPENDENCIES) 
 	$(syslog_la_LINK) $(am_syslog_la_rpath) $(syslog_la_OBJECTS) $(syslog_la_LIBADD) $(LIBS)
 table.la: $(table_la_OBJECTS) $(table_la_DEPENDENCIES) 
 	$(table_la_LINK) $(am_table_la_rpath) $(table_la_OBJECTS) $(table_la_LIBADD) $(LIBS)
 tail.la: $(tail_la_OBJECTS) $(tail_la_DEPENDENCIES) 
 	$(tail_la_LINK) $(am_tail_la_rpath) $(tail_la_OBJECTS) $(tail_la_LIBADD) $(LIBS)
+tail_csv.la: $(tail_csv_la_OBJECTS) $(tail_csv_la_DEPENDENCIES) 
+	$(tail_csv_la_LINK) $(am_tail_csv_la_rpath) $(tail_csv_la_OBJECTS) $(tail_csv_la_LIBADD) $(LIBS)
 tape.la: $(tape_la_OBJECTS) $(tape_la_DEPENDENCIES) 
 	$(tape_la_LINK) $(am_tape_la_rpath) $(tape_la_OBJECTS) $(tape_la_LIBADD) $(LIBS)
 target_notification.la: $(target_notification_la_OBJECTS) $(target_notification_la_DEPENDENCIES) 
 	$(target_notification_la_LINK) $(am_target_notification_la_rpath) $(target_notification_la_OBJECTS) $(target_notification_la_LIBADD) $(LIBS)
 target_replace.la: $(target_replace_la_OBJECTS) $(target_replace_la_DEPENDENCIES) 
 	$(target_replace_la_LINK) $(am_target_replace_la_rpath) $(target_replace_la_OBJECTS) $(target_replace_la_LIBADD) $(LIBS)
@@ -3001,12 +3053,14 @@
 write_http.la: $(write_http_la_OBJECTS) $(write_http_la_DEPENDENCIES) 
 	$(write_http_la_LINK) $(am_write_http_la_rpath) $(write_http_la_OBJECTS) $(write_http_la_LIBADD) $(LIBS)
 write_mongodb.la: $(write_mongodb_la_OBJECTS) $(write_mongodb_la_DEPENDENCIES) 
 	$(write_mongodb_la_LINK) $(am_write_mongodb_la_rpath) $(write_mongodb_la_OBJECTS) $(write_mongodb_la_LIBADD) $(LIBS)
 write_redis.la: $(write_redis_la_OBJECTS) $(write_redis_la_DEPENDENCIES) 
 	$(write_redis_la_LINK) $(am_write_redis_la_rpath) $(write_redis_la_OBJECTS) $(write_redis_la_LIBADD) $(LIBS)
+write_riemann.la: $(write_riemann_la_OBJECTS) $(write_riemann_la_DEPENDENCIES) 
+	$(write_riemann_la_LINK) $(am_write_riemann_la_rpath) $(write_riemann_la_OBJECTS) $(write_riemann_la_LIBADD) $(LIBS)
 xmms.la: $(xmms_la_OBJECTS) $(xmms_la_DEPENDENCIES) 
 	$(xmms_la_LINK) $(am_xmms_la_rpath) $(xmms_la_OBJECTS) $(xmms_la_LIBADD) $(LIBS)
 zfs_arc.la: $(zfs_arc_la_OBJECTS) $(zfs_arc_la_DEPENDENCIES) 
 	$(zfs_arc_la_LINK) $(am_zfs_arc_la_rpath) $(zfs_arc_la_OBJECTS) $(zfs_arc_la_LIBADD) $(LIBS)
 install-binPROGRAMS: $(bin_PROGRAMS)
 	@$(NORMAL_INSTALL)
@@ -3142,12 +3196,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_complain.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_heap.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_ignorelist.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_llist.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_match.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_parse_option.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_random.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_subst.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_tail.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_tail_match.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_time.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd_nagios-collectd-nagios.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd_tg-collectd-tg.Po@am__quote@
@@ -3215,34 +3270,37 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openvpn_la-openvpn.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oracle_la-oracle.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oracle_la-utils_db_query.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/perl_la-perl.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pf.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pinba.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pinba.pb-c.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ping_la-ping.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/postgresql_la-postgresql.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/postgresql_la-utils_db_query.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/powerdns.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/processes.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/protocols.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/python_la-pyconfig.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/python_la-python.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/python_la-pyvalues.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/redis_la-redis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/riemann.pb-c.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/routeros_la-routeros.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rrdcached_la-rrdcached.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rrdcached_la-utils_rrdcreate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rrdtool_la-rrdtool.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rrdtool_la-utils_rrdcreate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sensors_la-sensors.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/serial.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_la-snmp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/swap_la-swap.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/syslog.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/table.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tail.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tail_csv.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tape.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target_notification.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target_replace.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target_scale.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target_set.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target_v5upgrade.Plo@am__quote@
@@ -3275,12 +3333,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wireless.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_graphite.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_http_la-utils_format_json.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_http_la-write_http.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_mongodb_la-write_mongodb.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_redis_la-write_redis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_riemann.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xmms_la-xmms.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/zfs_arc_la-zfs_arc.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
@@ -3929,12 +3988,26 @@
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_parse_option.obj -MD -MP -MF $(DEPDIR)/collectd-utils_parse_option.Tpo -c -o collectd-utils_parse_option.obj `if test -f 'utils_parse_option.c'; then $(CYGPATH_W) 'utils_parse_option.c'; else $(CYGPATH_W) '$(srcdir)/utils_parse_option.c'; fi`
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/collectd-utils_parse_option.Tpo $(DEPDIR)/collectd-utils_parse_option.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='utils_parse_option.c' object='collectd-utils_parse_option.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_parse_option.obj `if test -f 'utils_parse_option.c'; then $(CYGPATH_W) 'utils_parse_option.c'; else $(CYGPATH_W) '$(srcdir)/utils_parse_option.c'; fi`
 
+collectd-utils_random.o: utils_random.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_random.o -MD -MP -MF $(DEPDIR)/collectd-utils_random.Tpo -c -o collectd-utils_random.o `test -f 'utils_random.c' || echo '$(srcdir)/'`utils_random.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/collectd-utils_random.Tpo $(DEPDIR)/collectd-utils_random.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='utils_random.c' object='collectd-utils_random.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_random.o `test -f 'utils_random.c' || echo '$(srcdir)/'`utils_random.c
+
+collectd-utils_random.obj: utils_random.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_random.obj -MD -MP -MF $(DEPDIR)/collectd-utils_random.Tpo -c -o collectd-utils_random.obj `if test -f 'utils_random.c'; then $(CYGPATH_W) 'utils_random.c'; else $(CYGPATH_W) '$(srcdir)/utils_random.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/collectd-utils_random.Tpo $(DEPDIR)/collectd-utils_random.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='utils_random.c' object='collectd-utils_random.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_random.obj `if test -f 'utils_random.c'; then $(CYGPATH_W) 'utils_random.c'; else $(CYGPATH_W) '$(srcdir)/utils_random.c'; fi`
+
 collectd-utils_tail_match.o: utils_tail_match.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_tail_match.o -MD -MP -MF $(DEPDIR)/collectd-utils_tail_match.Tpo -c -o collectd-utils_tail_match.o `test -f 'utils_tail_match.c' || echo '$(srcdir)/'`utils_tail_match.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/collectd-utils_tail_match.Tpo $(DEPDIR)/collectd-utils_tail_match.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='utils_tail_match.c' object='collectd-utils_tail_match.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_tail_match.o `test -f 'utils_tail_match.c' || echo '$(srcdir)/'`utils_tail_match.c
@@ -4569,14 +4642,17 @@
 		>.pod2man.tmp.$$$$ 2>/dev/null && mv -f .pod2man.tmp.$$$$ $@ || true
 	@if grep '\<POD ERRORS\>' $@ >/dev/null 2>&1; \
 	then \
 		echo "$@ has some POD errors!"; false; \
 	fi
 
-pinba.pb-c.c pinba.pb-c.h: pinba.proto
-	protoc-c -I$(srcdir) --c_out . $(srcdir)/pinba.proto
+@HAVE_PROTOC_C_TRUE@pinba.pb-c.c pinba.pb-c.h: pinba.proto
+@HAVE_PROTOC_C_TRUE@	protoc-c -I$(srcdir) --c_out . $(srcdir)/pinba.proto
+
+@HAVE_PROTOC_C_TRUE@riemann.pb-c.c riemann.pb-c.h: riemann.proto
+@HAVE_PROTOC_C_TRUE@	protoc-c -I$(srcdir) --c_out . $(srcdir)/riemann.proto
 
 install-exec-hook:
 	$(mkinstalldirs) $(DESTDIR)$(sysconfdir)
 	if test -e $(DESTDIR)$(sysconfdir)/collectd.conf; \
 	then \
 		$(INSTALL) -m 0640 collectd.conf $(DESTDIR)$(sysconfdir)/collectd.conf.pkg-orig; \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/netapp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/netapp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/netapp.c	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/netapp.c	2013-04-09 23:18:59.000000000 +0800
@@ -1,9 +1,10 @@
 /**
  * collectd - src/netapp.c
  * Copyright (C) 2009,2010  Sven Trenkel
+ * Copyright (C) 2012-2013  teamix GmbH
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
  * to deal in the Software without restriction, including without limitation
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
@@ -18,13 +19,14 @@
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  *
  * Authors:
- *   Sven Trenkel <collectd at semidefinite.de>  
+ *   Sven Trenkel <collectd at semidefinite.de>
+ *   Sebastian 'tokkee' Harl <sh@teamix.net>
  **/
 
 #include "collectd.h"
 #include "common.h"
 #include "utils_ignorelist.h"
 
@@ -178,22 +180,24 @@
 /* }}} data_volume_perf_t */
 
 /*! Data types for volume usage statistics {{{
  *
  * \brief Configuration struct for volume usage data (free / used).
  */
-#define CFG_VOLUME_USAGE_DF             0x0002
-#define CFG_VOLUME_USAGE_SNAP           0x0004
-#define CFG_VOLUME_USAGE_ALL            0x0006
-#define HAVE_VOLUME_USAGE_NORM_FREE     0x0010
-#define HAVE_VOLUME_USAGE_NORM_USED     0x0020
-#define HAVE_VOLUME_USAGE_SNAP_RSVD     0x0040
-#define HAVE_VOLUME_USAGE_SNAP_USED     0x0080
-#define HAVE_VOLUME_USAGE_SIS_SAVED     0x0100
-#define HAVE_VOLUME_USAGE_ALL           0x01f0
-#define IS_VOLUME_USAGE_OFFLINE         0x0200
+#define CFG_VOLUME_USAGE_DF              0x0002
+#define CFG_VOLUME_USAGE_SNAP            0x0004
+#define CFG_VOLUME_USAGE_ALL             0x0006
+#define HAVE_VOLUME_USAGE_NORM_FREE      0x0010
+#define HAVE_VOLUME_USAGE_NORM_USED      0x0020
+#define HAVE_VOLUME_USAGE_SNAP_RSVD      0x0040
+#define HAVE_VOLUME_USAGE_SNAP_USED      0x0080
+#define HAVE_VOLUME_USAGE_SIS_SAVED      0x0100
+#define HAVE_VOLUME_USAGE_COMPRESS_SAVED 0x0200
+#define HAVE_VOLUME_USAGE_DEDUP_SAVED    0x0400
+#define HAVE_VOLUME_USAGE_ALL            0x07f0
+#define IS_VOLUME_USAGE_OFFLINE          0x0800
 struct data_volume_usage_s;
 typedef struct data_volume_usage_s data_volume_usage_t;
 struct data_volume_usage_s {
 	char *name;
 	uint32_t flags;
 
@@ -201,12 +205,14 @@
 
 	uint64_t norm_free;
 	uint64_t norm_used;
 	uint64_t snap_reserved;
 	uint64_t snap_used;
 	uint64_t sis_saved;
+	uint64_t compress_saved;
+	uint64_t dedup_saved;
 
 	data_volume_usage_t *next;
 };
 
 typedef struct {
 	cna_interval_t interval;
@@ -216,12 +222,32 @@
 	ignorelist_t *il_snapshot;
 
 	data_volume_usage_t *volumes;
 } cfg_volume_usage_t;
 /* }}} cfg_volume_usage_t */
 
+/*! Data types for quota statistics {{{
+ *
+ * \brief Persistent data for quota statistics
+ */
+typedef struct {
+	cna_interval_t interval;
+	na_elem_t *query;
+} cfg_quota_t;
+/* }}} cfg_quota_t */
+
+/*! Data types for SnapVault statistics {{{
+ *
+ * \brief Persistent data for SnapVault(R) statistics
+ */
+typedef struct {
+	cna_interval_t interval;
+	na_elem_t *query;
+} cfg_snapvault_t;
+/* }}} cfg_snapvault_t */
+
 /*! Data types for system statistics {{{
  *
  * \brief Persistent data for system performance counters
  */
 #define CFG_SYSTEM_CPU  0x01
 #define CFG_SYSTEM_NET  0x02
@@ -239,19 +265,22 @@
 	char *name;
 	na_server_transport_t protocol;
 	char *host;
 	int port;
 	char *username;
 	char *password;
+	char *vfiler;
 	cdtime_t interval;
 
 	na_server_t *srv;
 	cfg_wafl_t *cfg_wafl;
 	cfg_disk_t *cfg_disk;
 	cfg_volume_perf_t *cfg_volume_perf;
 	cfg_volume_usage_t *cfg_volume_usage;
+	cfg_quota_t *cfg_quota;
+	cfg_snapvault_t *cfg_snapvault;
 	cfg_system_t *cfg_system;
 
 	struct host_config_s *next;
 };
 
 /*
@@ -351,12 +380,34 @@
 	if (cvu->query != NULL)
 		na_elem_free (cvu->query);
 
 	sfree (cvu);
 } /* }}} void free_cfg_volume_usage */
 
+static void free_cfg_quota (cfg_quota_t *q) /* {{{ */
+{
+	if (q == NULL)
+		return;
+
+	if (q->query != NULL)
+		na_elem_free (q->query);
+
+	sfree (q);
+} /* }}} void free_cfg_quota */
+
+static void free_cfg_snapvault (cfg_snapvault_t *sv) /* {{{ */
+{
+	if (sv == NULL)
+		return;
+
+	if (sv->query != NULL)
+		na_elem_free (sv->query);
+
+	sfree (sv);
+} /* }}} void free_cfg_snapvault */
+
 static void free_cfg_system (cfg_system_t *cs) /* {{{ */
 {
 	if (cs == NULL)
 		return;
 
 	if (cs->query != NULL)
@@ -375,17 +426,20 @@
 	next = hc->next;
 
 	sfree (hc->name);
 	sfree (hc->host);
 	sfree (hc->username);
 	sfree (hc->password);
+	sfree (hc->vfiler);
 
 	free_cfg_disk (hc->cfg_disk);
 	free_cfg_wafl (hc->cfg_wafl);
 	free_cfg_volume_perf (hc->cfg_volume_perf);
 	free_cfg_volume_usage (hc->cfg_volume_usage);
+	free_cfg_quota (hc->cfg_quota);
+	free_cfg_snapvault (hc->cfg_snapvault);
 	free_cfg_system (hc->cfg_system);
 
 	if (hc->srv != NULL)
 		na_server_close (hc->srv);
 
 	sfree (hc);
@@ -1377,12 +1431,14 @@
 	{
 		char plugin_instance[DATA_MAX_NAME_LEN];
 
 		uint64_t norm_used = v->norm_used;
 		uint64_t norm_free = v->norm_free;
 		uint64_t sis_saved = v->sis_saved;
+		uint64_t compress_saved = v->compress_saved;
+		uint64_t dedup_saved = v->dedup_saved;
 		uint64_t snap_reserve_used = 0;
 		uint64_t snap_reserve_free = v->snap_reserved;
 		uint64_t snap_norm_used = v->snap_used;
 
 		ssnprintf (plugin_instance, sizeof (plugin_instance),
 				"volume-%s", v->name);
@@ -1421,12 +1477,22 @@
 
 		if (HAS_ALL_FLAGS (v->flags, HAVE_VOLUME_USAGE_SIS_SAVED))
 			submit_double (hostname, /* plugin instance = */ plugin_instance,
 					"df_complex", "sis_saved",
 					(double) sis_saved, /* timestamp = */ 0, interval);
 
+		if (HAS_ALL_FLAGS (v->flags, HAVE_VOLUME_USAGE_COMPRESS_SAVED))
+			submit_double (hostname, /* plugin instance = */ plugin_instance,
+					"df_complex", "compression_saved",
+					(double) compress_saved, /* timestamp = */ 0, interval);
+
+		if (HAS_ALL_FLAGS (v->flags, HAVE_VOLUME_USAGE_DEDUP_SAVED))
+			submit_double (hostname, /* plugin instance = */ plugin_instance,
+					"df_complex", "dedup_saved",
+					(double) dedup_saved, /* timestamp = */ 0, interval);
+
 		if (HAS_ALL_FLAGS (v->flags, HAVE_VOLUME_USAGE_NORM_USED))
 			submit_double (hostname, /* plugin instance = */ plugin_instance,
 					"df_complex", "used",
 					(double) norm_used, /* timestamp = */ 0, interval);
 
 		if (HAS_ALL_FLAGS (v->flags, HAVE_VOLUME_USAGE_SNAP_RSVD))
@@ -1529,12 +1595,107 @@
 	na_elem_free (data);
 	/* snap_used is in 1024 byte blocks */
 	v->snap_used = snap_used * 1024;
 	v->flags |= HAVE_VOLUME_USAGE_SNAP_USED;
 } /* }}} void cna_handle_volume_snap_usage */
 
+static void cna_handle_volume_sis_data (const host_config_t *host, /* {{{ */
+		data_volume_usage_t *v, na_elem_t *sis)
+{
+	const char *sis_state;
+	uint64_t sis_saved_reported;
+
+	if (na_elem_child(sis, "sis-info"))
+		sis = na_elem_child(sis, "sis-info");
+
+	sis_state = na_child_get_string(sis, "state");
+	if (sis_state == NULL)
+		return;
+
+	/* If SIS is not enabled, there's nothing left to do for this volume. */
+	if (strcmp ("enabled", sis_state) != 0)
+		return;
+
+	sis_saved_reported = na_child_get_uint64(sis, "size-saved", UINT64_MAX);
+	if (sis_saved_reported == UINT64_MAX)
+		return;
+
+	/* size-saved is actually a 32 bit number, so ... time for some guesswork. */
+	if ((sis_saved_reported >> 32) != 0) {
+		/* In case they ever fix this bug. */
+		v->sis_saved = sis_saved_reported;
+		v->flags |= HAVE_VOLUME_USAGE_SIS_SAVED;
+	} else { /* really hacky work-around code. {{{ */
+		uint64_t sis_saved_percent;
+		uint64_t sis_saved_guess;
+		uint64_t overflow_guess;
+		uint64_t guess1, guess2, guess3;
+
+		/* Check if we have v->norm_used. Without it, we cannot calculate
+		 * sis_saved_guess. */
+		if ((v->flags & HAVE_VOLUME_USAGE_NORM_USED) == 0)
+			return;
+
+		sis_saved_percent = na_child_get_uint64(sis, "percentage-saved", UINT64_MAX);
+		if (sis_saved_percent > 100)
+			return;
+
+		/* The "size-saved" value is a 32bit unsigned integer. This is a bug and
+		 * will hopefully be fixed in later versions. To work around the bug, try
+		 * to figure out how often the 32bit integer wrapped around by using the
+		 * "percentage-saved" value. Because the percentage is in the range
+		 * [0-100], this should work as long as the saved space does not exceed
+		 * 400 GBytes. */
+		/* percentage-saved = size-saved / (size-saved + size-used) */
+		if (sis_saved_percent < 100)
+			sis_saved_guess = v->norm_used * sis_saved_percent / (100 - sis_saved_percent);
+		else
+			sis_saved_guess = v->norm_used;
+
+		overflow_guess = sis_saved_guess >> 32;
+		guess1 = overflow_guess ? ((overflow_guess - 1) << 32) + sis_saved_reported : sis_saved_reported;
+		guess2 = (overflow_guess << 32) + sis_saved_reported;
+		guess3 = ((overflow_guess + 1) << 32) + sis_saved_reported;
+
+		if (sis_saved_guess < guess2) {
+			if ((sis_saved_guess - guess1) < (guess2 - sis_saved_guess))
+				v->sis_saved = guess1;
+			else
+				v->sis_saved = guess2;
+		} else {
+			if ((sis_saved_guess - guess2) < (guess3 - sis_saved_guess))
+				v->sis_saved = guess2;
+			else
+				v->sis_saved = guess3;
+		}
+		v->flags |= HAVE_VOLUME_USAGE_SIS_SAVED;
+	} /* }}} end of 32-bit workaround */
+} /* }}} void cna_handle_volume_sis_data */
+
+/* ONTAP >= 8.1 uses SIS for managing dedup and compression */
+static void cna_handle_volume_sis_saved (const host_config_t *host, /* {{{ */
+		data_volume_usage_t *v, na_elem_t *sis)
+{
+	uint64_t saved;
+
+	if (na_elem_child(sis, "sis-info"))
+		sis = na_elem_child(sis, "sis-info");
+
+	saved = na_child_get_uint64(sis, "compress-saved", UINT64_MAX);
+	if (saved != UINT64_MAX) {
+		v->compress_saved = saved;
+		v->flags |= HAVE_VOLUME_USAGE_COMPRESS_SAVED;
+	}
+
+	saved = na_child_get_uint64(sis, "dedup-saved", UINT64_MAX);
+	if (saved != UINT64_MAX) {
+		v->dedup_saved = saved;
+		v->flags |= HAVE_VOLUME_USAGE_DEDUP_SAVED;
+	}
+} /* }}} void cna_handle_volume_sis_saved */
+
 static int cna_handle_volume_usage_data (const host_config_t *host, /* {{{ */
 		cfg_volume_usage_t *cfg_volume, na_elem_t *data)
 {
 	na_elem_t *elem_volume;
 	na_elem_t *elem_volumes;
 	na_elem_iter_t iter_volume;
@@ -1556,14 +1717,12 @@
 		const char *volume_name, *state;
 
 		data_volume_usage_t *v;
 		uint64_t value;
 
 		na_elem_t *sis;
-		const char *sis_state;
-		uint64_t sis_saved_reported;
 
 		volume_name = na_child_get_string (elem_volume, "name");
 		if (volume_name == NULL)
 			continue;
 
 		state = na_child_get_string (elem_volume, "state");
@@ -1599,80 +1758,16 @@
 			/* 1 block == 1024 bytes  as per API docs */
 			v->snap_reserved = 1024 * value;
 			v->flags |= HAVE_VOLUME_USAGE_SNAP_RSVD;
 		}
 
 		sis = na_elem_child(elem_volume, "sis");
-		if (sis == NULL)
-			continue;
-
-		if (na_elem_child(sis, "sis-info"))
-			sis = na_elem_child(sis, "sis-info");
-		
-		sis_state = na_child_get_string(sis, "state");
-		if (sis_state == NULL)
-			continue;
-
-		/* If SIS is not enabled, there's nothing left to do for this volume. */
-		if (strcmp ("enabled", sis_state) != 0)
-			continue;
-
-		sis_saved_reported = na_child_get_uint64(sis, "size-saved", UINT64_MAX);
-		if (sis_saved_reported == UINT64_MAX)
-			continue;
-
-		/* size-saved is actually a 32 bit number, so ... time for some guesswork. */
-		if ((sis_saved_reported >> 32) != 0) {
-			/* In case they ever fix this bug. */
-			v->sis_saved = sis_saved_reported;
-			v->flags |= HAVE_VOLUME_USAGE_SIS_SAVED;
-		} else { /* really hacky work-around code. {{{ */
-			uint64_t sis_saved_percent;
-			uint64_t sis_saved_guess;
-			uint64_t overflow_guess;
-			uint64_t guess1, guess2, guess3;
-
-			/* Check if we have v->norm_used. Without it, we cannot calculate
-			 * sis_saved_guess. */
-			if ((v->flags & HAVE_VOLUME_USAGE_NORM_USED) == 0)
-				continue;
-
-			sis_saved_percent = na_child_get_uint64(sis, "percentage-saved", UINT64_MAX);
-			if (sis_saved_percent > 100)
-				continue;
-
-			/* The "size-saved" value is a 32bit unsigned integer. This is a bug and
-			 * will hopefully be fixed in later versions. To work around the bug, try
-			 * to figure out how often the 32bit integer wrapped around by using the
-			 * "percentage-saved" value. Because the percentage is in the range
-			 * [0-100], this should work as long as the saved space does not exceed
-			 * 400 GBytes. */
-			/* percentage-saved = size-saved / (size-saved + size-used) */
-			if (sis_saved_percent < 100)
-				sis_saved_guess = v->norm_used * sis_saved_percent / (100 - sis_saved_percent);
-			else
-				sis_saved_guess = v->norm_used;
-
-			overflow_guess = sis_saved_guess >> 32;
-			guess1 = overflow_guess ? ((overflow_guess - 1) << 32) + sis_saved_reported : sis_saved_reported;
-			guess2 = (overflow_guess << 32) + sis_saved_reported;
-			guess3 = ((overflow_guess + 1) << 32) + sis_saved_reported;
-
-			if (sis_saved_guess < guess2) {
-				if ((sis_saved_guess - guess1) < (guess2 - sis_saved_guess))
-					v->sis_saved = guess1;
-				else
-					v->sis_saved = guess2;
-			} else {
-				if ((sis_saved_guess - guess2) < (guess3 - sis_saved_guess))
-					v->sis_saved = guess2;
-				else
-					v->sis_saved = guess3;
-			}
-			v->flags |= HAVE_VOLUME_USAGE_SIS_SAVED;
-		} /* }}} end of 32-bit workaround */
+		if (sis != NULL) {
+			cna_handle_volume_sis_data (host, v, sis);
+			cna_handle_volume_sis_saved (host, v, sis);
+		}
 	} /* for (elem_volume) */
 
 	return (cna_submit_volume_usage_data (host->name, cfg_volume,
 				host->cfg_volume_usage->interval.interval));
 } /* }}} int cna_handle_volume_usage_data */
 
@@ -1732,12 +1827,298 @@
 		host->cfg_volume_usage->interval.last_read = now;
 
 	na_elem_free (data);
 	return (status);
 } /* }}} int cna_query_volume_usage */
 
+/* Data corresponding to <Quota /> */
+static int cna_handle_quota_data (const host_config_t *host, /* {{{ */
+		cfg_quota_t *cfg_quota, na_elem_t *data)
+{
+	na_elem_t *elem_quota;
+	na_elem_t *elem_quotas;
+	na_elem_iter_t iter_quota;
+
+	elem_quotas = na_elem_child (data, "quotas");
+	if (elem_quotas == NULL)
+	{
+		ERROR ("netapp plugin: cna_handle_quota_data: "
+				"na_elem_child (\"quotas\") failed "
+				"for host %s.", host->name);
+		return (-1);
+	}
+
+	iter_quota = na_child_iterator (elem_quotas);
+	for (elem_quota = na_iterator_next (&iter_quota);
+			elem_quota != NULL;
+			elem_quota = na_iterator_next (&iter_quota))
+	{
+		const char *quota_type, *volume_name, *tree_name;
+		uint64_t value;
+
+		char plugin_instance[DATA_MAX_NAME_LEN];
+
+		quota_type = na_child_get_string (elem_quota, "quota-type");
+		if (quota_type == NULL)
+			continue;
+
+		/* possible TODO: support other types as well */
+		if (strcmp (quota_type, "tree") != 0)
+			continue;
+
+		tree_name = na_child_get_string (elem_quota, "tree");
+		if ((tree_name == NULL) || (*tree_name == '\0'))
+			continue;
+
+		volume_name = na_child_get_string (elem_quota, "volume");
+		if (volume_name == NULL)
+			continue;
+
+		ssnprintf (plugin_instance, sizeof (plugin_instance),
+				"quota-%s-%s", volume_name, tree_name);
+
+		value = na_child_get_uint64 (elem_quota, "disk-used", UINT64_MAX);
+		if (value != UINT64_MAX) {
+			value *= 1024; /* disk-used reports kilobytes */
+			submit_double (host->name, plugin_instance,
+					/* type = */ "df_complex", /* type instance = */ NULL,
+					(double)value, /* timestamp = */ 0,
+					host->cfg_quota->interval.interval);
+		}
+
+		value = na_child_get_uint64 (elem_quota, "files-used", UINT64_MAX);
+		if (value != UINT64_MAX) {
+			submit_double (host->name, plugin_instance,
+					/* type = */ "files", /* type instance = */ NULL,
+					(double)value, /* timestamp = */ 0,
+					host->cfg_quota->interval.interval);
+		}
+	} /* for (elem_quota) */
+
+	return (0);
+} /* }}} int cna_handle_volume_usage_data */
+
+static int cna_setup_quota (cfg_quota_t *cq) /* {{{ */
+{
+	if (cq == NULL)
+		return (EINVAL);
+
+	if (cq->query != NULL)
+		return (0);
+
+	cq->query = na_elem_new ("quota-report");
+	if (cq->query == NULL)
+	{
+		ERROR ("netapp plugin: na_elem_new failed.");
+		return (-1);
+	}
+
+	return (0);
+} /* }}} int cna_setup_quota */
+
+static int cna_query_quota (host_config_t *host) /* {{{ */
+{
+	na_elem_t *data;
+	int status;
+	cdtime_t now;
+
+	if (host == NULL)
+		return (EINVAL);
+
+	/* If the user did not configure quota statistics, return without
+	 * doing anything. */
+	if (host->cfg_quota == NULL)
+		return (0);
+
+	now = cdtime ();
+	if ((host->cfg_quota->interval.interval + host->cfg_quota->interval.last_read) > now)
+		return (0);
+
+	status = cna_setup_quota (host->cfg_quota);
+	if (status != 0)
+		return (status);
+	assert (host->cfg_quota->query != NULL);
+
+	data = na_server_invoke_elem (host->srv, host->cfg_quota->query);
+	if (na_results_status (data) != NA_OK)
+	{
+		ERROR ("netapp plugin: cna_query_quota: na_server_invoke_elem failed for host %s: %s",
+				host->name, na_results_reason (data));
+		na_elem_free (data);
+		return (-1);
+	}
+
+	status = cna_handle_quota_data (host, host->cfg_quota, data);
+
+	if (status == 0)
+		host->cfg_quota->interval.last_read = now;
+
+	na_elem_free (data);
+	return (status);
+} /* }}} int cna_query_quota */
+
+/* Data corresponding to <SnapVault /> */
+static int cna_handle_snapvault_data (const char *hostname, /* {{{ */
+		cfg_snapvault_t *cfg_snapvault, na_elem_t *data, cdtime_t interval)
+{
+	na_elem_t *status;
+	na_elem_iter_t status_iter;
+
+	status = na_elem_child (data, "status-list");
+	if (! status) {
+		ERROR ("netapp plugin: SnapVault status record missing status-list");
+		return (0);
+	}
+
+	status_iter = na_child_iterator (status);
+	for (status = na_iterator_next (&status_iter);
+			status != NULL;
+			status = na_iterator_next (&status_iter))
+	{
+		const char *dest_sys, *dest_path, *src_sys, *src_path;
+		char plugin_instance[DATA_MAX_NAME_LEN];
+		uint64_t value;
+
+		dest_sys  = na_child_get_string (status, "destination-system");
+		dest_path = na_child_get_string (status, "destination-path");
+		src_sys   = na_child_get_string (status, "source-system");
+		src_path  = na_child_get_string (status, "source-path");
+
+		if ((! dest_sys) || (! dest_path) || (! src_sys) || (! src_path))
+			continue;
+
+		value = na_child_get_uint64 (status, "lag-time", UINT64_MAX);
+		if (value == UINT64_MAX) /* no successful baseline transfer yet */
+			continue;
+
+		/* possible TODO: make plugin instance configurable */
+		ssnprintf (plugin_instance, sizeof (plugin_instance),
+				"snapvault-%s", dest_path);
+		submit_double (hostname, plugin_instance, /* type = */ "delay", NULL,
+				(double)value, /* timestamp = */ 0, interval);
+
+		value = na_child_get_uint64 (status, "last-transfer-duration", UINT64_MAX);
+		if (value != UINT64_MAX)
+			submit_double (hostname, plugin_instance, /* type = */ "duration", "last_transfer",
+					(double)value, /* timestamp = */ 0, interval);
+
+		value = na_child_get_uint64 (status, "transfer-progress", UINT64_MAX);
+		if (value == UINT64_MAX)
+			value = na_child_get_uint64 (status, "last-transfer-size", UINT64_MAX);
+		if (value != UINT64_MAX) {
+			value *= 1024; /* this is kilobytes */
+			submit_derive (hostname, plugin_instance, /* type = */ "if_rx_octets", "transferred",
+					value, /* timestamp = */ 0, interval);
+		}
+	} /* for (status) */
+
+	return (0);
+} /* }}} int cna_handle_snapvault_data */
+
+static int cna_handle_snapvault_iter (host_config_t *host, /* {{{ */
+		na_elem_t *data)
+{
+	const char *tag;
+
+	uint32_t records_count;
+	uint32_t i;
+
+	records_count = na_child_get_uint32 (data, "records", UINT32_MAX);
+	if (records_count == UINT32_MAX)
+		return 0;
+
+	tag = na_child_get_string (data, "tag");
+	if (! tag)
+		return 0;
+
+	DEBUG ("netapp plugin: Iterating %u SV records (tag = %s)", records_count, tag);
+
+	for (i = 0; i < records_count; ++i) {
+		na_elem_t *elem;
+
+		elem = na_server_invoke (host->srv,
+				"snapvault-secondary-relationship-status-list-iter-next",
+				"maximum", "1", "tag", tag, NULL);
+
+		if (na_results_status (elem) != NA_OK)
+		{
+			ERROR ("netapp plugin: cna_handle_snapvault_iter: "
+					"na_server_invoke failed for host %s: %s",
+					host->name, na_results_reason (data));
+			na_elem_free (elem);
+			return (-1);
+		}
+
+		cna_handle_snapvault_data (host->name, host->cfg_snapvault, elem,
+				host->cfg_snapvault->interval.interval);
+		na_elem_free (elem);
+	}
+
+	na_elem_free (na_server_invoke (host->srv,
+			"snapvault-secondary-relationship-status-list-iter-end",
+			"tag", tag, NULL));
+	return (0);
+} /* }}} int cna_handle_snapvault_iter */
+
+static int cna_setup_snapvault (cfg_snapvault_t *sv) /* {{{ */
+{
+	if (sv == NULL)
+		return (EINVAL);
+
+	if (sv->query != NULL)
+		return (0);
+
+	sv->query = na_elem_new ("snapvault-secondary-relationship-status-list-iter-start");
+	if (sv->query == NULL)
+	{
+		ERROR ("netapp plugin: na_elem_new failed.");
+		return (-1);
+	}
+
+	return (0);
+} /* }}} int cna_setup_snapvault */
+
+static int cna_query_snapvault (host_config_t *host) /* {{{ */
+{
+	na_elem_t *data;
+	int status;
+	cdtime_t now;
+
+	if (host == NULL)
+		return EINVAL;
+
+	if (host->cfg_snapvault == NULL)
+		return 0;
+
+	now = cdtime ();
+	if ((host->cfg_snapvault->interval.interval + host->cfg_snapvault->interval.last_read) > now)
+		return (0);
+
+	status = cna_setup_snapvault (host->cfg_snapvault);
+	if (status != 0)
+		return (status);
+	assert (host->cfg_snapvault->query != NULL);
+
+	data = na_server_invoke_elem (host->srv, host->cfg_snapvault->query);
+	if (na_results_status (data) != NA_OK)
+	{
+		ERROR ("netapp plugin: cna_query_snapvault: na_server_invoke_elem failed for host %s: %s",
+				host->name, na_results_reason (data));
+		na_elem_free (data);
+		return (-1);
+	}
+
+	status = cna_handle_snapvault_iter (host, data);
+
+	if (status == 0)
+		host->cfg_snapvault->interval.last_read = now;
+
+	na_elem_free (data);
+	return (status);
+} /* }}} int cna_query_snapvault */
+
 /* Data corresponding to <System /> */
 static int cna_handle_system_data (const char *hostname, /* {{{ */
 		cfg_system_t *cfg_system, na_elem_t *data, int interval)
 {
 	na_elem_t *instances;
 	na_elem_t *counter;
@@ -2138,12 +2519,46 @@
 	if (ci->values[0].value.boolean)
 		ignorelist_set_invert (il, /* invert = */ 0);
 	else
 		ignorelist_set_invert (il, /* invert = */ 1);
 } /* }}} void cna_config_volume_usage_default */
 
+/* Corresponds to a <Quota /> block */
+static int cna_config_quota (host_config_t *host, oconfig_item_t *ci) /* {{{ */
+{
+	cfg_quota_t *cfg_quota;
+	int i;
+
+	if ((host == NULL) || (ci == NULL))
+		return (EINVAL);
+
+	if (host->cfg_quota == NULL)
+	{
+		cfg_quota = malloc (sizeof (*cfg_quota));
+		if (cfg_quota == NULL)
+			return (ENOMEM);
+		memset (cfg_quota, 0, sizeof (*cfg_quota));
+		cfg_quota->query = NULL;
+
+		host->cfg_quota = cfg_quota;
+	}
+	cfg_quota = host->cfg_quota;
+
+	for (i = 0; i < ci->children_num; ++i) {
+		oconfig_item_t *item = ci->children + i;
+
+		if (strcasecmp (item->key, "Interval") == 0)
+			cna_config_get_interval (item, &cfg_quota->interval);
+		else
+			WARNING ("netapp plugin: The option %s is not allowed within "
+					"`Quota' blocks.", item->key);
+	}
+
+	return (0);
+} /* }}} int cna_config_quota */
+
 /* Corresponds to a <Disks /> block */
 static int cna_config_disk(host_config_t *host, oconfig_item_t *ci) { /* {{{ */
 	cfg_disk_t *cfg_disk;
 	int i;
 
 	if ((host == NULL) || (ci == NULL))
@@ -2313,12 +2728,48 @@
 					"`VolumeUsage' blocks.", item->key);
 	}
 
 	return (0);
 } /* }}} int cna_config_volume_usage */
 
+/* Corresponds to a <SnapVault /> block */
+static int cna_config_snapvault (host_config_t *host, /* {{{ */
+		const oconfig_item_t *ci)
+{
+	cfg_snapvault_t *cfg_snapvault;
+	int i;
+
+	if ((host == NULL) || (ci == NULL))
+		return EINVAL;
+
+	if (host->cfg_snapvault == NULL)
+	{
+		cfg_snapvault = malloc (sizeof (*cfg_snapvault));
+		if (cfg_snapvault == NULL)
+			return ENOMEM;
+		memset (cfg_snapvault, 0, sizeof (*cfg_snapvault));
+		cfg_snapvault->query = NULL;
+
+		host->cfg_snapvault = cfg_snapvault;
+	}
+
+	cfg_snapvault = host->cfg_snapvault;
+
+	for (i = 0; i < ci->children_num; ++i) {
+		oconfig_item_t *item = ci->children + i;
+
+		if (strcasecmp (item->key, "Interval") == 0)
+			cna_config_get_interval (item, &cfg_snapvault->interval);
+		else
+			WARNING ("netapp plugin: The option %s is not allowed within "
+					"`SnapVault' blocks.", item->key);
+	}
+
+	return 0;
+} /* }}} int cna_config_snapvault */
+
 /* Corresponds to a <System /> block */
 static int cna_config_system (host_config_t *host, /* {{{ */
 		oconfig_item_t *ci)
 {
 	cfg_system_t *cfg_system;
 	int i;
@@ -2369,45 +2820,138 @@
 	}
 
 	return (0);
 } /* }}} int cna_config_system */
 
 /* Corresponds to a <Host /> block. */
-static host_config_t *cna_config_host (const oconfig_item_t *ci) /* {{{ */
+static host_config_t *cna_alloc_host (void) /* {{{ */
 {
-	oconfig_item_t *item;
 	host_config_t *host;
-	int status;
-	int i;
-	
-	if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING)) {
-		WARNING("netapp plugin: \"Host\" needs exactly one string argument. Ignoring host block.");
-		return 0;
-	}
 
 	host = malloc(sizeof(*host));
+	if (! host)
+		return (NULL);
 	memset (host, 0, sizeof (*host));
+
 	host->name = NULL;
 	host->protocol = NA_SERVER_TRANSPORT_HTTPS;
 	host->host = NULL;
 	host->username = NULL;
 	host->password = NULL;
+	host->vfiler = NULL;
 	host->srv = NULL;
 	host->cfg_wafl = NULL;
 	host->cfg_disk = NULL;
 	host->cfg_volume_perf = NULL;
 	host->cfg_volume_usage = NULL;
+	host->cfg_quota = NULL;
+	host->cfg_snapvault = NULL;
 	host->cfg_system = NULL;
 
-	status = cf_util_get_string (ci, &host->name);
-	if (status != 0)
-	{
-		sfree (host);
+	return (host);
+} /* }}} host_config_t *cna_alloc_host */
+
+static host_config_t *cna_shallow_clone_host (host_config_t *host) /* {{{ */
+{
+	host_config_t *clone;
+
+	if (host == NULL)
 		return (NULL);
+
+	clone = cna_alloc_host ();
+	if (clone == NULL)
+		return (NULL);
+
+	if (host->name != NULL) {
+		clone->name = strdup (host->name);
+		if (clone->name == NULL) {
+			free_host_config (clone);
+			return NULL;
+		}
 	}
 
+	clone->protocol = host->protocol;
+
+	if (host->host != NULL) {
+		clone->host = strdup (host->host);
+		if (clone->host == NULL) {
+			free_host_config (clone);
+			return NULL;
+		}
+	}
+
+	clone->port = host->port;
+
+	if (host->username != NULL) {
+		clone->username = strdup (host->username);
+		if (clone->username == NULL) {
+			free_host_config (clone);
+			return NULL;
+		}
+	}
+	if (host->password != NULL) {
+		clone->password = strdup (host->password);
+		if (clone->password == NULL) {
+			free_host_config (clone);
+			return NULL;
+		}
+	}
+
+	clone->interval = host->interval;
+
+	return (clone);
+} /* }}} host_config_t *cna_shallow_clone_host */
+
+static int cna_read (user_data_t *ud);
+
+static int cna_register_host (host_config_t *host) /* {{{ */
+{
+	char cb_name[256];
+	struct timespec interval;
+	user_data_t ud;
+
+	if (host->vfiler)
+		ssnprintf (cb_name, sizeof (cb_name), "netapp-%s-%s",
+				host->name, host->vfiler);
+	else
+		ssnprintf (cb_name, sizeof (cb_name), "netapp-%s", host->name);
+
+	CDTIME_T_TO_TIMESPEC (host->interval, &interval);
+
+	memset (&ud, 0, sizeof (ud));
+	ud.data = host;
+	ud.free_func = (void (*) (void *)) free_host_config;
+
+	plugin_register_complex_read (/* group = */ NULL, cb_name,
+			/* callback  = */ cna_read,
+			/* interval  = */ (host->interval > 0) ? &interval : NULL,
+			/* user data = */ &ud);
+
+	return (0);
+} /* }}} int cna_register_host */
+
+static int cna_config_host (host_config_t *host, /* {{{ */
+		const oconfig_item_t *ci)
+{
+	oconfig_item_t *item;
+	_Bool is_vfiler = 0;
+	int status;
+	int i;
+
+	if (! strcasecmp (ci->key, "VFiler"))
+		is_vfiler = 1;
+
+	if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING)) {
+		WARNING ("netapp plugin: \"%s\" needs exactly one string argument. Ignoring host block.", ci->key);
+		return (1);
+	}
+
+	status = cf_util_get_string (ci, &host->name);
+	if (status != 0)
+		return (1);
+
 	for (i = 0; i < ci->children_num; ++i) {
 		item = ci->children + i;
 
 		status = 0;
 
 		if (!strcasecmp(item->key, "Address")) {
@@ -2418,13 +2962,13 @@
 			tmp = cf_util_get_port_number (item);
 			if (tmp > 0)
 				host->port = tmp;
 		} else if (!strcasecmp(item->key, "Protocol")) {
 			if ((item->values_num != 1) || (item->values[0].type != OCONFIG_TYPE_STRING) || (strcasecmp(item->values[0].value.string, "http") && strcasecmp(item->values[0].value.string, "https"))) {
 				WARNING("netapp plugin: \"Protocol\" needs to be either \"http\" or \"https\". Ignoring host block \"%s\".", ci->values[0].value.string);
-				return 0;
+				return (1);
 			}
 			if (!strcasecmp(item->values[0].value.string, "http")) host->protocol = NA_SERVER_TRANSPORT_HTTP;
 			else host->protocol = NA_SERVER_TRANSPORT_HTTPS;
 		} else if (!strcasecmp(item->key, "User")) {
 			status = cf_util_get_string (item, &host->username);
 		} else if (!strcasecmp(item->key, "Password")) {
@@ -2436,26 +2980,50 @@
 		} else if (!strcasecmp(item->key, "Disks")) {
 			cna_config_disk(host, item);
 		} else if (!strcasecmp(item->key, "VolumePerf")) {
 			cna_config_volume_performance(host, item);
 		} else if (!strcasecmp(item->key, "VolumeUsage")) {
 			cna_config_volume_usage(host, item);
+		} else if (!strcasecmp(item->key, "Quota")) {
+			cna_config_quota(host, item);
+		} else if (!strcasecmp(item->key, "SnapVault")) {
+			cna_config_snapvault(host, item);
 		} else if (!strcasecmp(item->key, "System")) {
 			cna_config_system(host, item);
+		} else if ((!strcasecmp(item->key, "VFiler")) && (! is_vfiler)) {
+			host_config_t *vfiler;
+
+			vfiler = cna_shallow_clone_host (host);
+			if (! vfiler) {
+				ERROR ("netapp plugin: Failed to allocate host object for vfiler.");
+				continue;
+			}
+
+			if (cna_config_host (vfiler, item)) {
+				free_host_config (vfiler);
+				continue;
+			}
+
+			cna_register_host (vfiler);
+		} else if ((!strcasecmp(item->key, "VFilerName")) && is_vfiler) {
+			status = cf_util_get_string (item, &host->vfiler);
 		} else {
-			WARNING("netapp plugin: Ignoring unknown config option \"%s\" in host block \"%s\".",
-					item->key, ci->values[0].value.string);
+			WARNING ("netapp plugin: Ignoring unknown config option \"%s\" in %s block \"%s\".",
+					item->key, is_vfiler ? "vfiler" : "host", ci->values[0].value.string);
 		}
 
 		if (status != 0)
 			break;
 	}
 
 	if (host->host == NULL)
 		host->host = strdup (host->name);
 
+	if (is_vfiler && (! host->vfiler))
+		host->vfiler = strdup (host->name);
+
 	if (host->host == NULL)
 		status = -1;
 
 	if (host->port <= 0)
 		host->port = (host->protocol == NA_SERVER_TRANSPORT_HTTP) ? 80 : 443;
 
@@ -2463,48 +3031,61 @@
 		WARNING("netapp plugin: Please supply login information for host \"%s\". "
 				"Ignoring host block.", host->name);
 		status = -1;
 	}
 
 	if (status != 0)
-	{
-		free_host_config (host);
-		return (NULL);
-	}
+		return status;
 
-	return host;
+	return (0);
 } /* }}} host_config_t *cna_config_host */
 
 /*
  * Callbacks registered with the daemon
  *
  * Pretty standard stuff here.
  */
 static int cna_init_host (host_config_t *host) /* {{{ */
 {
+	/* Request version 1.1 of the ONTAP API */
+	int major_version = 1, minor_version = 1;
+
 	if (host == NULL)
 		return (EINVAL);
 
 	if (host->srv != NULL)
 		return (0);
 
-	/* Request version 1.1 of the ONTAP API */
-	host->srv = na_server_open(host->host,
-			/* major version = */ 1, /* minor version = */ 1); 
+	if (host->vfiler != NULL) /* Request version 1.7 of the ONTAP API */
+		minor_version = 7;
+
+	host->srv = na_server_open (host->host, major_version, minor_version);
 	if (host->srv == NULL) {
 		ERROR ("netapp plugin: na_server_open (%s) failed.", host->host);
 		return (-1);
 	}
 
 	na_server_set_transport_type(host->srv, host->protocol,
 			/* transportarg = */ NULL);
 	na_server_set_port(host->srv, host->port);
 	na_server_style(host->srv, NA_STYLE_LOGIN_PASSWORD);
 	na_server_adminuser(host->srv, host->username, host->password);
 	na_server_set_timeout(host->srv, 5 /* seconds */);
 
+	if (host->vfiler != NULL) {
+		if (! na_server_set_vfiler (host->srv, host->vfiler)) {
+			ERROR ("netapp plugin: Failed to connect to VFiler '%s' on host '%s'.",
+					host->vfiler, host->host);
+			return (-1);
+		}
+		else {
+			INFO ("netapp plugin: Connected to VFiler '%s' on host '%s'.",
+					host->vfiler, host->host);
+		}
+	}
+
 	return (0);
 } /* }}} int cna_init_host */
 
 static int cna_init (void) /* {{{ */
 {
 	char err[256];
@@ -2535,12 +3116,20 @@
 		return (status);
 
 	status = cna_query_volume_usage (host);
 	if (status != 0)
 		return (status);
 
+	status = cna_query_quota (host);
+	if (status != 0)
+		return (status);
+
+	status = cna_query_snapvault (host);
+	if (status != 0)
+		return (status);
+
 	status = cna_query_system (host);
 	if (status != 0)
 		return (status);
 
 	return 0;
 } /* }}} int cna_read_internal */
@@ -2576,33 +3165,25 @@
 	for (i = 0; i < ci->children_num; ++i) {
 		item = ci->children + i;
 
 		if (strcasecmp(item->key, "Host") == 0)
 		{
 			host_config_t *host;
-			char cb_name[256];
-			struct timespec interval;
-			user_data_t ud;
 
-			host = cna_config_host (item);
-			if (host == NULL)
+			host = cna_alloc_host ();
+			if (host == NULL) {
+				ERROR ("netapp plugin: Failed to allocate host object.");
 				continue;
+			}
 
-			ssnprintf (cb_name, sizeof (cb_name), "netapp-%s", host->name);
-
-			CDTIME_T_TO_TIMESPEC (host->interval, &interval);
+			if (cna_config_host (host, item) != 0) {
+				free_host_config (host);
+				continue;
+			}
 
-			memset (&ud, 0, sizeof (ud));
-			ud.data = host;
-			ud.free_func = (void (*) (void *)) free_host_config;
-
-			plugin_register_complex_read (/* group = */ NULL, cb_name,
-					/* callback  = */ cna_read, 
-					/* interval  = */ (host->interval > 0) ? &interval : NULL,
-					/* user data = */ &ud);
-			continue;
+			cna_register_host (host);
 		}
 		else /* if (item->key != "Host") */
 		{
 			WARNING("netapp plugin: Ignoring unknown config option \"%s\".", item->key);
 		}
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/network.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/network.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/network.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/network.c	2013-04-09 23:18:59.000000000 +0800
@@ -457,13 +457,13 @@
       meta_data_destroy (vl->meta);
       vl->meta = NULL;
       return (status);
     }
   }
 
-  plugin_dispatch_values_secure (vl);
+  plugin_dispatch_values (vl);
   stats_values_dispatched++;
 
   meta_data_destroy (vl->meta);
   vl->meta = NULL;
 
   return (0);
@@ -3333,49 +3333,49 @@
 	sstrncpy (vl.plugin, "network", sizeof (vl.plugin));
 
 	/* Octets received / sent */
 	vl.values[0].derive = (derive_t) copy_octets_rx;
 	vl.values[1].derive = (derive_t) copy_octets_tx;
 	sstrncpy (vl.type, "if_octets", sizeof (vl.type));
-	plugin_dispatch_values_secure (&vl);
+	plugin_dispatch_values (&vl);
 
 	/* Packets received / send */
 	vl.values[0].derive = (derive_t) copy_packets_rx;
 	vl.values[1].derive = (derive_t) copy_packets_tx;
 	sstrncpy (vl.type, "if_packets", sizeof (vl.type));
-	plugin_dispatch_values_secure (&vl);
+	plugin_dispatch_values (&vl);
 
 	/* Values (not) dispatched and (not) send */
 	sstrncpy (vl.type, "total_values", sizeof (vl.type));
 	vl.values_len = 1;
 
 	vl.values[0].derive = (derive_t) copy_values_dispatched;
 	sstrncpy (vl.type_instance, "dispatch-accepted",
 			sizeof (vl.type_instance));
-	plugin_dispatch_values_secure (&vl);
+	plugin_dispatch_values (&vl);
 
 	vl.values[0].derive = (derive_t) copy_values_not_dispatched;
 	sstrncpy (vl.type_instance, "dispatch-rejected",
 			sizeof (vl.type_instance));
-	plugin_dispatch_values_secure (&vl);
+	plugin_dispatch_values (&vl);
 
 	vl.values[0].derive = (derive_t) copy_values_sent;
 	sstrncpy (vl.type_instance, "send-accepted",
 			sizeof (vl.type_instance));
-	plugin_dispatch_values_secure (&vl);
+	plugin_dispatch_values (&vl);
 
 	vl.values[0].derive = (derive_t) copy_values_not_sent;
 	sstrncpy (vl.type_instance, "send-rejected",
 			sizeof (vl.type_instance));
-	plugin_dispatch_values_secure (&vl);
+	plugin_dispatch_values (&vl);
 
 	/* Receive queue length */
 	vl.values[0].gauge = (gauge_t) copy_receive_list_length;
 	sstrncpy (vl.type, "queue_length", sizeof (vl.type));
 	vl.type_instance[0] = 0;
-	plugin_dispatch_values_secure (&vl);
+	plugin_dispatch_values (&vl);
 
 	return (0);
 } /* }}} int network_stats_read */
 
 static int network_init (void)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/nfs.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/nfs.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/nfs.c	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/nfs.c	2013-04-09 23:18:59.000000000 +0800
@@ -244,13 +244,13 @@
 
 	for (i = 0; i < values_num; i++)
 	{
 		vl.values = values + i;
 		sstrncpy (vl.type_instance, type_instances[i],
 				sizeof (vl.type_instance));
-		plugin_dispatch_values_secure (&vl);
+		plugin_dispatch_values (&vl);
 	}
 } /* void nfs_procedures_submit */
 
 #if KERNEL_LINUX
 static int nfs_submit_fields (int nfs_version, const char *instance,
 		char **fields, size_t fields_num,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/plugin.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/plugin.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/plugin.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/plugin.c	2013-04-09 23:18:59.000000000 +0800
@@ -1,9 +1,9 @@
 /**
  * collectd - src/plugin.c
- * Copyright (C) 2005-2011  Florian octo Forster
+ * Copyright (C) 2005-2013  Florian octo Forster
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; only version 2 of the License is applicable.
  *
  * This program is distributed in the hope that it will be useful, but
@@ -18,28 +18,28 @@
  * Authors:
  *   Florian octo Forster <octo at collectd.org>
  *   Sebastian Harl <sh at tokkee.org>
  **/
 
 #include "collectd.h"
-#include "utils_complain.h"
-
-#include <ltdl.h>
-
-#if HAVE_PTHREAD_H
-# include <pthread.h>
-#endif
-
 #include "common.h"
 #include "plugin.h"
 #include "configfile.h"
+#include "filter_chain.h"
 #include "utils_avltree.h"
+#include "utils_cache.h"
+#include "utils_complain.h"
 #include "utils_llist.h"
 #include "utils_heap.h"
-#include "utils_cache.h"
-#include "filter_chain.h"
+#include "utils_time.h"
+
+#if HAVE_PTHREAD_H
+# include <pthread.h>
+#endif
+
+#include <ltdl.h>
 
 /*
  * Private structures
  */
 struct callback_func_s
 {
@@ -60,18 +60,27 @@
 #define rf_udata rf_super.cf_udata
 #define rf_ctx rf_super.cf_ctx
 	callback_func_t rf_super;
 	char rf_group[DATA_MAX_NAME_LEN];
 	char rf_name[DATA_MAX_NAME_LEN];
 	int rf_type;
-	struct timespec rf_interval;
-	struct timespec rf_effective_interval;
-	struct timespec rf_next_read;
+	cdtime_t rf_interval;
+	cdtime_t rf_effective_interval;
+	cdtime_t rf_next_read;
 };
 typedef struct read_func_s read_func_t;
 
+struct write_queue_s;
+typedef struct write_queue_s write_queue_t;
+struct write_queue_s
+{
+	value_list_t *vl;
+	plugin_ctx_t ctx;
+	write_queue_t *next;
+};
+
 /*
  * Private variables
  */
 static llist_t *list_init;
 static llist_t *list_write;
 static llist_t *list_flush;
@@ -92,18 +101,28 @@
 static int             read_loop = 1;
 static pthread_mutex_t read_lock = PTHREAD_MUTEX_INITIALIZER;
 static pthread_cond_t  read_cond = PTHREAD_COND_INITIALIZER;
 static pthread_t      *read_threads = NULL;
 static int             read_threads_num = 0;
 
+static write_queue_t  *write_queue_head;
+static write_queue_t  *write_queue_tail;
+static _Bool           write_loop = 1;
+static pthread_mutex_t write_lock = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t  write_cond = PTHREAD_COND_INITIALIZER;
+static pthread_t      *write_threads = NULL;
+static size_t          write_threads_num = 0;
+
 static pthread_key_t   plugin_ctx_key;
 static _Bool           plugin_ctx_key_initialized = 0;
 
 /*
  * Static functions
  */
+static int plugin_dispatch_values_internal (value_list_t *vl);
+
 static const char *plugin_get_dir (void)
 {
 	if (plugindir == NULL)
 		return (PLUGINDIR);
 	else
 		return (plugindir);
@@ -338,19 +357,12 @@
 
 	(*reg_handle) ();
 
 	return (0);
 }
 
-static _Bool timeout_reached(struct timespec timeout)
-{
-	struct timeval now;
-	gettimeofday(&now, NULL);
-	return (now.tv_sec >= timeout.tv_sec && now.tv_usec >= (timeout.tv_nsec / 1000));
-}
-
 static void *plugin_read_thread (void __attribute__((unused)) *args)
 {
 	while (read_loop != 0)
 	{
 		read_func_t *rf;
 		plugin_ctx_t old_ctx;
@@ -370,40 +382,41 @@
 			pthread_cond_wait (&read_cond, &read_lock);
                         pthread_mutex_unlock (&read_lock);
 			continue;
 		}
 		pthread_mutex_unlock (&read_lock);
 
-		if ((rf->rf_interval.tv_sec == 0) && (rf->rf_interval.tv_nsec == 0))
+		if (rf->rf_interval == 0)
 		{
 			/* this should not happen, because the interval is set
 			 * for each plugin when loading it
 			 * XXX: issue a warning? */
-			now = cdtime ();
-
-			CDTIME_T_TO_TIMESPEC (plugin_get_interval (), &rf->rf_interval);
-
+			rf->rf_interval = plugin_get_interval ();
 			rf->rf_effective_interval = rf->rf_interval;
 
-			CDTIME_T_TO_TIMESPEC (now, &rf->rf_next_read);
+			rf->rf_next_read = cdtime ();
 		}
 
 		/* sleep until this entry is due,
 		 * using pthread_cond_timedwait */
 		pthread_mutex_lock (&read_lock);
 		/* In pthread_cond_timedwait, spurious wakeups are possible
 		 * (and really happen, at least on NetBSD with > 1 CPU), thus
 		 * we need to re-evaluate the condition every time
 		 * pthread_cond_timedwait returns. */
 		rc = 0;
 		while ((read_loop != 0)
-				&& !timeout_reached(rf->rf_next_read)
+				&& (cdtime () < rf->rf_next_read)
 				&& rc == 0)
 		{
+			struct timespec ts = { 0 };
+
+			CDTIME_T_TO_TIMESPEC (rf->rf_next_read, &ts);
+
 			rc = pthread_cond_timedwait (&read_cond, &read_lock,
-				&rf->rf_next_read);
+				&ts);
 		}
 
 		/* Must hold `read_lock' when accessing `rf->rf_type'. */
 		rf_type = rf->rf_type;
 		pthread_mutex_unlock (&read_lock);
 
@@ -453,63 +466,51 @@
 		plugin_set_ctx (old_ctx);
 
 		/* If the function signals failure, we will increase the
 		 * intervals in which it will be called. */
 		if (status != 0)
 		{
-			rf->rf_effective_interval.tv_sec *= 2;
-			rf->rf_effective_interval.tv_nsec *= 2;
-			NORMALIZE_TIMESPEC (rf->rf_effective_interval);
-
-			if (rf->rf_effective_interval.tv_sec >= 86400)
-			{
-				rf->rf_effective_interval.tv_sec = 86400;
-				rf->rf_effective_interval.tv_nsec = 0;
-			}
+			rf->rf_effective_interval *= 2;
+			if (rf->rf_effective_interval > TIME_T_TO_CDTIME_T (86400))
+				rf->rf_effective_interval = TIME_T_TO_CDTIME_T (86400);
 
 			NOTICE ("read-function of plugin `%s' failed. "
-					"Will suspend it for %i seconds.",
+					"Will suspend it for %.3f seconds.",
 					rf->rf_name,
-					(int) rf->rf_effective_interval.tv_sec);
+					CDTIME_T_TO_DOUBLE (rf->rf_effective_interval));
 		}
 		else
 		{
 			/* Success: Restore the interval, if it was changed. */
 			rf->rf_effective_interval = rf->rf_interval;
 		}
 
 		/* update the ``next read due'' field */
 		now = cdtime ();
 
 		DEBUG ("plugin_read_thread: Effective interval of the "
-				"%s plugin is %i.%09i.",
+				"%s plugin is %.3f seconds.",
 				rf->rf_name,
-				(int) rf->rf_effective_interval.tv_sec,
-				(int) rf->rf_effective_interval.tv_nsec);
+				CDTIME_T_TO_DOUBLE (rf->rf_effective_interval));
 
 		/* Calculate the next (absolute) time at which this function
 		 * should be called. */
-		rf->rf_next_read.tv_sec = rf->rf_next_read.tv_sec
-			+ rf->rf_effective_interval.tv_sec;
-		rf->rf_next_read.tv_nsec = rf->rf_next_read.tv_nsec
-			+ rf->rf_effective_interval.tv_nsec;
-		NORMALIZE_TIMESPEC (rf->rf_next_read);
+		rf->rf_next_read += rf->rf_effective_interval;
 
 		/* Check, if `rf_next_read' is in the past. */
-		if (TIMESPEC_TO_CDTIME_T (&rf->rf_next_read) < now)
+		if (rf->rf_next_read < now)
 		{
 			/* `rf_next_read' is in the past. Insert `now'
 			 * so this value doesn't trail off into the
 			 * past too much. */
-			CDTIME_T_TO_TIMESPEC (now, &rf->rf_next_read);
+			rf->rf_next_read = now;
 		}
 
-		DEBUG ("plugin_read_thread: Next read of the %s plugin at %i.%09i.",
+		DEBUG ("plugin_read_thread: Next read of the %s plugin at %.3f.",
 				rf->rf_name,
-				(int) rf->rf_next_read.tv_sec,
-				(int) rf->rf_next_read.tv_nsec);
+				CDTIME_T_TO_DOUBLE (rf->rf_next_read));
 
 		/* Re-insert this read function into the heap again. */
 		c_heap_insert (read_heap, rf);
 	} /* while (read_loop) */
 
 	pthread_exit (NULL);
@@ -570,12 +571,250 @@
 		read_threads[i] = (pthread_t) 0;
 	}
 	sfree (read_threads);
 	read_threads_num = 0;
 } /* void stop_read_threads */
 
+static void plugin_value_list_free (value_list_t *vl) /* {{{ */
+{
+	if (vl == NULL)
+		return;
+
+	meta_data_destroy (vl->meta);
+	sfree (vl->values);
+	sfree (vl);
+} /* }}} void plugin_value_list_free */
+
+static value_list_t *plugin_value_list_clone (value_list_t const *vl_orig) /* {{{ */
+{
+	value_list_t *vl;
+
+	if (vl_orig == NULL)
+		return (NULL);
+
+	vl = malloc (sizeof (*vl));
+	if (vl == NULL)
+		return (NULL);
+	memcpy (vl, vl_orig, sizeof (*vl));
+
+	vl->values = calloc (vl_orig->values_len, sizeof (*vl->values));
+	if (vl->values == NULL)
+	{
+		plugin_value_list_free (vl);
+		return (NULL);
+	}
+	memcpy (vl->values, vl_orig->values,
+			vl_orig->values_len * sizeof (*vl->values));
+
+	vl->meta = meta_data_clone (vl->meta);
+	if ((vl_orig->meta != NULL) && (vl->meta == NULL))
+	{
+		plugin_value_list_free (vl);
+		return (NULL);
+	}
+
+	if (vl->time == 0)
+		vl->time = cdtime ();
+
+	/* Fill in the interval from the thread context, if it is zero. */
+	if (vl->interval == 0)
+	{
+		plugin_ctx_t ctx = plugin_get_ctx ();
+
+		if (ctx.interval != 0)
+			vl->interval = ctx.interval;
+		else
+		{
+			char name[6 * DATA_MAX_NAME_LEN];
+			FORMAT_VL (name, sizeof (name), vl);
+			ERROR ("plugin_value_list_clone: Unable to determine "
+					"interval from context for "
+					"value list \"%s\". "
+					"This indicates a broken plugin. "
+					"Please report this problem to the "
+					"collectd mailing list or at "
+					"<http://collectd.org/bugs/>.", name);
+			vl->interval = cf_get_default_interval ();
+		}
+	}
+
+	return (vl);
+} /* }}} value_list_t *plugin_value_list_clone */
+
+static int plugin_write_enqueue (value_list_t const *vl) /* {{{ */
+{
+	write_queue_t *q;
+
+	q = malloc (sizeof (*q));
+	if (q == NULL)
+		return (ENOMEM);
+	q->next = NULL;
+
+	q->vl = plugin_value_list_clone (vl);
+	if (q->vl == NULL)
+	{
+		sfree (q);
+		return (ENOMEM);
+	}
+
+	/* Store context of caller (read plugin); otherwise, it would not be
+	 * available to the write plugins when actually dispatching the
+	 * value-list later on. */
+	q->ctx = plugin_get_ctx ();
+
+	pthread_mutex_lock (&write_lock);
+
+	if (write_queue_tail == NULL)
+	{
+		write_queue_head = q;
+		write_queue_tail = q;
+	}
+	else
+	{
+		write_queue_tail->next = q;
+		write_queue_tail = q;
+	}
+
+	pthread_cond_signal (&write_cond);
+	pthread_mutex_unlock (&write_lock);
+
+	return (0);
+} /* }}} int plugin_write_enqueue */
+
+static value_list_t *plugin_write_dequeue (void) /* {{{ */
+{
+	write_queue_t *q;
+	value_list_t *vl;
+
+	pthread_mutex_lock (&write_lock);
+
+	while (write_loop && (write_queue_head == NULL))
+		pthread_cond_wait (&write_cond, &write_lock);
+
+	if (write_queue_head == NULL)
+	{
+		pthread_mutex_unlock (&write_lock);
+		return (NULL);
+	}
+
+	q = write_queue_head;
+	write_queue_head = q->next;
+	if (write_queue_head == NULL)
+		write_queue_tail = NULL;
+
+	pthread_mutex_unlock (&write_lock);
+
+	(void) plugin_set_ctx (q->ctx);
+
+	vl = q->vl;
+	sfree (q);
+	return (vl);
+} /* }}} value_list_t *plugin_write_dequeue */
+
+static void *plugin_write_thread (void __attribute__((unused)) *args) /* {{{ */
+{
+	while (write_loop)
+	{
+		value_list_t *vl = plugin_write_dequeue ();
+		if (vl == NULL)
+			continue;
+
+		plugin_dispatch_values_internal (vl);
+
+		plugin_value_list_free (vl);
+	}
+
+	pthread_exit (NULL);
+	return ((void *) 0);
+} /* }}} void *plugin_write_thread */
+
+static void start_write_threads (size_t num) /* {{{ */
+{
+	size_t i;
+
+	if (write_threads != NULL)
+		return;
+
+	write_threads = (pthread_t *) calloc (num, sizeof (pthread_t));
+	if (write_threads == NULL)
+	{
+		ERROR ("plugin: start_write_threads: calloc failed.");
+		return;
+	}
+
+	write_threads_num = 0;
+	for (i = 0; i < num; i++)
+	{
+		int status;
+
+		status = pthread_create (write_threads + write_threads_num,
+				/* attr = */ NULL,
+				plugin_write_thread,
+				/* arg = */ NULL);
+		if (status != 0)
+		{
+			char errbuf[1024];
+			ERROR ("plugin: start_write_threads: pthread_create failed "
+					"with status %i (%s).", status,
+					sstrerror (status, errbuf, sizeof (errbuf)));
+			return;
+		}
+
+		write_threads_num++;
+	} /* for (i) */
+} /* }}} void start_write_threads */
+
+static void stop_write_threads (void) /* {{{ */
+{
+	write_queue_t *q;
+	int i;
+
+	if (write_threads == NULL)
+		return;
+
+	INFO ("collectd: Stopping %zu write threads.", write_threads_num);
+
+	pthread_mutex_lock (&write_lock);
+	write_loop = 0;
+	DEBUG ("plugin: stop_write_threads: Signalling `write_cond'");
+	pthread_cond_broadcast (&write_cond);
+	pthread_mutex_unlock (&write_lock);
+
+	for (i = 0; i < write_threads_num; i++)
+	{
+		if (pthread_join (write_threads[i], NULL) != 0)
+		{
+			ERROR ("plugin: stop_write_threads: pthread_join failed.");
+		}
+		write_threads[i] = (pthread_t) 0;
+	}
+	sfree (write_threads);
+	write_threads_num = 0;
+
+	pthread_mutex_lock (&write_lock);
+	i = 0;
+	for (q = write_queue_head; q != NULL; )
+	{
+		write_queue_t *q1 = q;
+		plugin_value_list_free (q->vl);
+		q = q->next;
+		sfree (q1);
+		i++;
+	}
+	write_queue_head = NULL;
+	write_queue_tail = NULL;
+	pthread_mutex_unlock (&write_lock);
+
+	if (i > 0)
+	{
+		WARNING ("plugin: %i value list%s left after shutting down "
+				"the write threads.",
+				i, (i == 1) ? " was" : "s were");
+	}
+} /* }}} void stop_write_threads */
+
 /*
  * Public functions
  */
 void plugin_set_dir (const char *dir)
 {
 	if (plugindir != NULL)
@@ -601,31 +840,29 @@
 	int   typename_len;
 	int   ret;
 	struct stat    statbuf;
 	struct dirent *de;
 	int status;
 
-	DEBUG ("type = %s", type);
-
 	dir = plugin_get_dir ();
 	ret = 1;
 
 	/* `cpu' should not match `cpufreq'. To solve this we add `.so' to the
 	 * type when matching the filename */
 	status = ssnprintf (typename, sizeof (typename), "%s.so", type);
 	if ((status < 0) || ((size_t) status >= sizeof (typename)))
 	{
-		WARNING ("snprintf: truncated: `%s.so'", type);
+		WARNING ("plugin_load: Filename too long: \"%s.so\"", type);
 		return (-1);
 	}
 	typename_len = strlen (typename);
 
 	if ((dh = opendir (dir)) == NULL)
 	{
 		char errbuf[1024];
-		ERROR ("opendir (%s): %s", dir,
+		ERROR ("plugin_load: opendir (%s) failed: %s", dir,
 				sstrerror (errno, errbuf, sizeof (errbuf)));
 		return (-1);
 	}
 
 	while ((de = readdir (dh)) != NULL)
 	{
@@ -633,46 +870,52 @@
 			continue;
 
 		status = ssnprintf (filename, sizeof (filename),
 				"%s/%s", dir, de->d_name);
 		if ((status < 0) || ((size_t) status >= sizeof (filename)))
 		{
-			WARNING ("snprintf: truncated: `%s/%s'", dir, de->d_name);
+			WARNING ("plugin_load: Filename too long: \"%s/%s\"",
+					dir, de->d_name);
 			continue;
 		}
 
 		if (lstat (filename, &statbuf) == -1)
 		{
 			char errbuf[1024];
-			WARNING ("stat %s: %s", filename,
+			WARNING ("plugin_load: stat (\"%s\") failed: %s",
+					filename,
 					sstrerror (errno, errbuf, sizeof (errbuf)));
 			continue;
 		}
 		else if (!S_ISREG (statbuf.st_mode))
 		{
 			/* don't follow symlinks */
-			WARNING ("stat %s: not a regular file", filename);
+			WARNING ("plugin_load: %s is not a regular file.",
+				       	filename);
 			continue;
 		}
 
-		if (plugin_load_file (filename, flags) == 0)
+		status = plugin_load_file (filename, flags);
+		if (status == 0)
 		{
 			/* success */
 			ret = 0;
 			break;
 		}
 		else
 		{
-			fprintf (stderr, "Unable to load plugin %s.\n", type);
+			ERROR ("plugin_load: Load plugin \"%s\" failed with "
+					"status %i.", type, status);
 		}
 	}
 
 	closedir (dh);
 
-	if (filename[0] == '\0')
-		fprintf (stderr, "Could not find plugin %s.\n", type);
+	if (filename[0] == 0)
+		ERROR ("plugin_load: Could not find plugin \"%s\" in %s",
+				type, dir);
 
 	return (ret);
 }
 
 /*
  * The `register_*' functions follow
@@ -703,19 +946,15 @@
 	const read_func_t *rf0;
 	const read_func_t *rf1;
 
 	rf0 = arg0;
 	rf1 = arg1;
 
-	if (rf0->rf_next_read.tv_sec < rf1->rf_next_read.tv_sec)
-		return (-1);
-	else if (rf0->rf_next_read.tv_sec > rf1->rf_next_read.tv_sec)
-		return (1);
-	else if (rf0->rf_next_read.tv_nsec < rf1->rf_next_read.tv_nsec)
+	if (rf0->rf_next_read < rf1->rf_next_read)
 		return (-1);
-	else if (rf0->rf_next_read.tv_nsec > rf1->rf_next_read.tv_nsec)
+	else if (rf0->rf_next_read > rf1->rf_next_read)
 		return (1);
 	else
 		return (0);
 } /* int plugin_compare_read_func */
 
 /* Add a read function to both, the heap and a linked list. The linked list if
@@ -723,14 +962,14 @@
  * is used to determine which plugin to read next. */
 static int plugin_insert_read (read_func_t *rf)
 {
 	int status;
 	llentry_t *le;
 
-	cdtime_t now = cdtime ();
-	CDTIME_T_TO_TIMESPEC (now, &rf->rf_next_read);
+	rf->rf_next_read = cdtime ();
+	rf->rf_effective_interval = rf->rf_interval;
 
 	pthread_mutex_lock (&read_lock);
 
 	if (read_list == NULL)
 	{
 		read_list = llist_create ();
@@ -787,67 +1026,34 @@
 	/* Wake up all the read threads. */
 	pthread_cond_broadcast (&read_cond);
 	pthread_mutex_unlock (&read_lock);
 	return (0);
 } /* int plugin_insert_read */
 
-static int read_cb_wrapper (user_data_t *ud)
-{
-	int (*callback) (void);
-
-	if (ud == NULL)
-		return -1;
-
-	callback = ud->data;
-	return callback();
-} /* int read_cb_wrapper */
-
 int plugin_register_read (const char *name,
 		int (*callback) (void))
 {
 	read_func_t *rf;
-	plugin_ctx_t ctx = plugin_get_ctx ();
 	int status;
 
-	if (ctx.interval != 0) {
-		/* If ctx.interval is not zero (== use the plugin or global
-		 * interval), we need to use the "complex" read callback,
-		 * because only that allows to specify a different interval.
-		 * Wrap the callback using read_cb_wrapper(). */
-		struct timespec interval;
-		user_data_t user_data;
-
-		user_data.data = callback;
-		user_data.free_func = NULL;
-
-		CDTIME_T_TO_TIMESPEC (ctx.interval, &interval);
-		return plugin_register_complex_read (/* group = */ NULL,
-				name, read_cb_wrapper, &interval, &user_data);
-	}
-
-	DEBUG ("plugin_register_read: default_interval = %.3f",
-			CDTIME_T_TO_DOUBLE(plugin_get_interval ()));
-
 	rf = malloc (sizeof (*rf));
 	if (rf == NULL)
 	{
 		ERROR ("plugin_register_read: malloc failed.");
 		return (ENOMEM);
 	}
 
 	memset (rf, 0, sizeof (read_func_t));
 	rf->rf_callback = (void *) callback;
 	rf->rf_udata.data = NULL;
 	rf->rf_udata.free_func = NULL;
-	rf->rf_ctx = ctx;
+	rf->rf_ctx = plugin_get_ctx ();
 	rf->rf_group[0] = '\0';
 	sstrncpy (rf->rf_name, name, sizeof (rf->rf_name));
 	rf->rf_type = RF_SIMPLE;
-	rf->rf_interval.tv_sec = 0;
-	rf->rf_interval.tv_nsec = 0;
-	rf->rf_effective_interval = rf->rf_interval;
+	rf->rf_interval = plugin_get_interval ();
 
 	status = plugin_insert_read (rf);
 	if (status != 0)
 		sfree (rf);
 
 	return (status);
@@ -856,13 +1062,12 @@
 int plugin_register_complex_read (const char *group, const char *name,
 		plugin_read_cb callback,
 		const struct timespec *interval,
 		user_data_t *user_data)
 {
 	read_func_t *rf;
-	plugin_ctx_t ctx = plugin_get_ctx ();
 	int status;
 
 	rf = malloc (sizeof (*rf));
 	if (rf == NULL)
 	{
 		ERROR ("plugin_register_complex_read: malloc failed.");
@@ -875,37 +1080,28 @@
 		sstrncpy (rf->rf_group, group, sizeof (rf->rf_group));
 	else
 		rf->rf_group[0] = '\0';
 	sstrncpy (rf->rf_name, name, sizeof (rf->rf_name));
 	rf->rf_type = RF_COMPLEX;
 	if (interval != NULL)
-	{
-		rf->rf_interval = *interval;
-	}
-	else if (ctx.interval != 0)
-	{
-		CDTIME_T_TO_TIMESPEC (ctx.interval, &rf->rf_interval);
-	}
-	rf->rf_effective_interval = rf->rf_interval;
-
-	DEBUG ("plugin_register_read: interval = %i.%09i",
-			(int) rf->rf_interval.tv_sec,
-			(int) rf->rf_interval.tv_nsec);
+		rf->rf_interval = TIMESPEC_TO_CDTIME_T (interval);
+	else
+		rf->rf_interval = plugin_get_interval ();
 
 	/* Set user data */
 	if (user_data == NULL)
 	{
 		rf->rf_udata.data = NULL;
 		rf->rf_udata.free_func = NULL;
 	}
 	else
 	{
 		rf->rf_udata = *user_data;
 	}
 
-	rf->rf_ctx = ctx;
+	rf->rf_ctx = plugin_get_ctx ();
 
 	status = plugin_insert_read (rf);
 	if (status != 0)
 		sfree (rf);
 
 	return (status);
@@ -1166,12 +1362,21 @@
 	chain_name = global_option_get ("PreCacheChain");
 	pre_cache_chain = fc_chain_get_by_name (chain_name);
 
 	chain_name = global_option_get ("PostCacheChain");
 	post_cache_chain = fc_chain_get_by_name (chain_name);
 
+	{
+		char const *tmp = global_option_get ("WriteThreads");
+		int num = atoi (tmp);
+
+		if (num < 1)
+			num = 5;
+
+		start_write_threads ((size_t) num);
+	}
 
 	if ((list_init == NULL) && (read_heap == NULL))
 		return;
 
 	/* Calling all init callbacks before checking if read callbacks
 	 * are available allows the init callbacks to register the read
@@ -1435,12 +1640,14 @@
 
 		(*callback) ();
 
 		plugin_set_ctx (old_ctx);
 	}
 
+	stop_write_threads ();
+
 	/* Write plugins which use the `user_data' pointer usually need the
 	 * same data available to the flush callback. If this is the case, set
 	 * the free_function to NULL when registering the flush callback and to
 	 * the real free function when registering the write callback. This way
 	 * the data isn't freed twice. */
 	destroy_all_callbacks (&list_flush);
@@ -1490,13 +1697,13 @@
 
     le = le->next;
   }
   return (0);
 } /* int }}} plugin_dispatch_missing */
 
-int plugin_dispatch_values (value_list_t *vl)
+static int plugin_dispatch_values_internal (value_list_t *vl)
 {
 	int status;
 	static c_complain_t no_write_complaint = C_COMPLAIN_INIT_STATIC;
 
 	value_t *saved_values;
 	int      saved_values_len;
@@ -1541,35 +1748,16 @@
 		INFO ("plugin_dispatch_values: Dataset not found: %s "
 				"(from \"%s\"), check your types.db!",
 				vl->type, ident);
 		return (-1);
 	}
 
-	if (vl->time == 0)
-		vl->time = cdtime ();
-
-	if (vl->interval <= 0)
-	{
-		plugin_ctx_t ctx = plugin_get_ctx ();
-
-		if (ctx.interval != 0)
-			vl->interval = ctx.interval;
-		else
-		{
-			char name[6 * DATA_MAX_NAME_LEN];
-			FORMAT_VL (name, sizeof (name), vl);
-			ERROR ("plugin_dispatch_values: Unable to determine "
-					"interval from context for "
-					"value list \"%s\". "
-					"This indicates a broken plugin. "
-					"Please report this problem to the "
-					"collectd mailing list or at "
-					"<http://collectd.org/bugs/>.", name);
-			vl->interval = cf_get_default_interval ();
-		}
-	}
+	/* Assured by plugin_value_list_clone(). The time is determined at
+	 * _enqueue_ time. */
+	assert (vl->time != 0);
+	assert (vl->interval != 0);
 
 	DEBUG ("plugin_dispatch_values: time = %.3f; interval = %.3f; "
 			"host = %s; "
 			"plugin = %s; plugin_instance = %s; "
 			"type = %s; type_instance = %s;",
 			CDTIME_T_TO_DOUBLE (vl->time),
@@ -1684,59 +1872,30 @@
 	{
 		meta_data_destroy (vl->meta);
 		vl->meta = NULL;
 	}
 
 	return (0);
-} /* int plugin_dispatch_values */
+} /* int plugin_dispatch_values_internal */
 
-int plugin_dispatch_values_secure (const value_list_t *vl)
+int plugin_dispatch_values (value_list_t const *vl)
 {
-  value_list_t vl_copy;
-  int status;
-
-  if (vl == NULL)
-    return EINVAL;
-
-  memcpy (&vl_copy, vl, sizeof (vl_copy));
-
-  /* Write callbacks must not change the values and meta pointers, so we can
-   * savely skip copying those and make this more efficient. */
-  if ((pre_cache_chain == NULL) && (post_cache_chain == NULL))
-    return (plugin_dispatch_values (&vl_copy));
-
-  /* Set pointers to NULL, just to be on the save side. */
-  vl_copy.values = NULL;
-  vl_copy.meta = NULL;
-
-  vl_copy.values = malloc (sizeof (*vl_copy.values) * vl->values_len);
-  if (vl_copy.values == NULL)
-  {
-    ERROR ("plugin_dispatch_values_secure: malloc failed.");
-    return (ENOMEM);
-  }
-  memcpy (vl_copy.values, vl->values, sizeof (*vl_copy.values) * vl->values_len);
-
-  if (vl->meta != NULL)
-  {
-    vl_copy.meta = meta_data_clone (vl->meta);
-    if (vl_copy.meta == NULL)
-    {
-      ERROR ("plugin_dispatch_values_secure: meta_data_clone failed.");
-      free (vl_copy.values);
-      return (ENOMEM);
-    }
-  } /* if (vl->meta) */
-
-  status = plugin_dispatch_values (&vl_copy);
+	int status;
 
-  meta_data_destroy (vl_copy.meta);
-  free (vl_copy.values);
+	status = plugin_write_enqueue (vl);
+	if (status != 0)
+	{
+		char errbuf[1024];
+		ERROR ("plugin_dispatch_values: plugin_write_enqueue failed "
+				"with status %i (%s).", status,
+				sstrerror (status, errbuf, sizeof (errbuf)));
+		return (status);
+	}
 
-  return (status);
-} /* int plugin_dispatch_values_secure */
+	return (0);
+}
 
 int plugin_dispatch_notification (const notification_t *notif)
 {
 	llentry_t *le;
 	/* Possible TODO: Add flap detection here */
 
@@ -1854,12 +2013,18 @@
 } /* int parse_notif_severity */
 
 const data_set_t *plugin_get_ds (const char *name)
 {
 	data_set_t *ds;
 
+	if (data_sets == NULL)
+	{
+		ERROR ("plugin_get_ds: No data sets are defined yet.");
+		return (NULL);
+	}
+
 	if (c_avl_get (data_sets, name, (void *) &ds) != 0)
 	{
 		DEBUG ("No such dataset registered: %s", name);
 		return (NULL);
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/plugin.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/plugin.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/plugin.h	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/plugin.h	2013-04-09 23:18:59.000000000 +0800
@@ -323,14 +323,13 @@
  *  write-functions.
  *
  * ARGUMENTS
  *  `vl'        Value list of the values that have been read by a `read'
  *              function.
  */
-int plugin_dispatch_values (value_list_t *vl);
-int plugin_dispatch_values_secure (const value_list_t *vl);
+int plugin_dispatch_values (value_list_t const *vl);
 int plugin_dispatch_missing (const value_list_t *vl);
 
 int plugin_dispatch_notification (const notification_t *notif);
 
 void plugin_log (int level, const char *format, ...)
 	__attribute__ ((format(printf,2,3)));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/postgresql.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/postgresql.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/postgresql.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/postgresql.c	2013-04-09 23:18:59.000000000 +0800
@@ -378,15 +378,12 @@
 		if (0 == db->conn_complaint.interval)
 			db->conn_complaint.interval = 1;
 
 		c_psql_connect (db);
 	}
 
-	/* "ping" */
-	PQclear (PQexec (db->conn, "SELECT 42;"));
-
 	if (CONNECTION_OK != PQstatus (db->conn)) {
 		PQreset (db->conn);
 
 		/* trigger c_release() */
 		if (0 == db->conn_complaint.interval)
 			db->conn_complaint.interval = 1;
@@ -521,12 +518,18 @@
 	column_names = NULL;
 	column_values = NULL;
 
 	if (PGRES_TUPLES_OK != PQresultStatus (res)) {
 		pthread_mutex_lock (&db->db_lock);
 
+		if ((CONNECTION_OK != PQstatus (db->conn))
+				&& (0 == c_psql_check_connection (db))) {
+			PQclear (res);
+			return c_psql_exec_query (db, q, prep_area);
+		}
+
 		log_err ("Failed to execute SQL query: %s",
 				PQerrorMessage (db->conn));
 		log_info ("SQL query was: %s",
 				udb_query_get_statement (q));
 		PQclear (res);
 		return -1;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src: riemann.proto
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/rrdcached.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/rrdcached.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/rrdcached.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/rrdcached.c	2013-04-09 23:18:59.000000000 +0800
@@ -43,13 +43,15 @@
 	/* xff = */ 0.1,
 
 	/* timespans = */ NULL,
 	/* timespans_num = */ 0,
 
 	/* consolidation_functions = */ NULL,
-	/* consolidation_functions_num = */ 0
+	/* consolidation_functions_num = */ 0,
+
+	/* async = */ 0
 };
 
 /*
  * Prototypes.
  */
 static int rc_write (const data_set_t *ds, const value_list_t *vl,
@@ -247,12 +249,14 @@
       }
     }
     else if (strcasecmp ("DaemonAddress", key) == 0)
       status = cf_util_get_string (child, &daemon_address);
     else if (strcasecmp ("CreateFiles", key) == 0)
       status = cf_util_get_boolean (child, &config_create_files);
+    else if (strcasecmp ("CreateFilesAsync", key) == 0)
+      status = cf_util_get_boolean (child, &rrdcreate_config.async);
     else if (strcasecmp ("CollectStatistics", key) == 0)
       status = cf_util_get_boolean (child, &config_collect_stats);
     else if (strcasecmp ("StepSize", key) == 0)
     {
       int tmp = -1;
 
@@ -464,12 +468,14 @@
       if (status != 0)
       {
         ERROR ("rrdcached plugin: cu_rrd_create_file (%s) failed.",
             filename);
         return (-1);
       }
+      else if (rrdcreate_config.async)
+        return (0);
     }
   }
 
   status = rrdc_connect (daemon_address);
   if (status != 0)
   {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/rrdtool.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/rrdtool.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/rrdtool.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/rrdtool.c	2013-04-09 23:18:59.000000000 +0800
@@ -1,9 +1,9 @@
 /**
  * collectd - src/rrdtool.c
- * Copyright (C) 2006-2008  Florian octo Forster
+ * Copyright (C) 2006-2013  Florian octo Forster
  * Copyright (C) 2008-2008  Sebastian Harl
  * Copyright (C) 2009       Mariusz Gronczewski
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; only version 2 of the License is applicable.
@@ -15,21 +15,22 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
  *
  * Authors:
- *   Florian octo Forster <octo at verplant.org>
+ *   Florian octo Forster <octo at collectd.org>
  *   Sebastian Harl <sh at tokkee.org>
  *   Mariusz Gronczewski <xani666 at gmail.com>
  **/
 
 #include "collectd.h"
 #include "plugin.h"
 #include "common.h"
 #include "utils_avltree.h"
+#include "utils_random.h"
 #include "utils_rrdcreate.h"
 
 #include <rrd.h>
 
 #if HAVE_PTHREAD_H
 # include <pthread.h>
@@ -72,12 +73,13 @@
  * Private variables
  */
 static const char *config_keys[] =
 {
 	"CacheTimeout",
 	"CacheFlush",
+	"CreateFilesAsync",
 	"DataDir",
 	"StepSize",
 	"HeartBeat",
 	"RRARows",
 	"RRATimespan",
 	"XFF",
@@ -99,13 +101,15 @@
 	/* xff = */ 0.1,
 
 	/* timespans = */ NULL,
 	/* timespans_num = */ 0,
 
 	/* consolidation_functions = */ NULL,
-	/* consolidation_functions_num = */ 0
+	/* consolidation_functions_num = */ 0,
+
+	/* async = */ 0
 };
 
 /* XXX: If you need to lock both, cache_lock and queue_lock, at the same time,
  * ALWAYS lock `cache_lock' first! */
 static cdtime_t    cache_timeout = 0;
 static cdtime_t    cache_flush_timeout = 0;
@@ -649,43 +653,30 @@
 
   return (status);
 } /* int rrd_cache_flush_identifier */
 
 static int64_t rrd_get_random_variation (void)
 {
-  double dbl_timeout;
-  cdtime_t ctm_timeout;
-  double rand_fact;
-  _Bool negative;
-  int64_t ret;
+  long min;
+  long max;
 
   if (random_timeout <= 0)
     return (0);
 
   /* Assure that "cache_timeout + random_variation" is never negative. */
   if (random_timeout > cache_timeout)
   {
 	  INFO ("rrdtool plugin: Adjusting \"RandomTimeout\" to %.3f seconds.",
 			  CDTIME_T_TO_DOUBLE (cache_timeout));
 	  random_timeout = cache_timeout;
   }
 
-  /* This seems a bit complicated, but "random_timeout" is likely larger than
-   * RAND_MAX, so we can't simply use modulo here. */
-  dbl_timeout = CDTIME_T_TO_DOUBLE (random_timeout);
-  rand_fact = ((double) random ())
-    / ((double) RAND_MAX);
-  negative = (_Bool) (random () % 2);
-
-  ctm_timeout = DOUBLE_TO_CDTIME_T (dbl_timeout * rand_fact);
-
-  ret = (int64_t) ctm_timeout;
-  if (negative)
-    ret *= -1;
+  max = (long) (random_timeout / 2);
+  min = max - ((long) random_timeout);
 
-  return (ret);
+  return ((int64_t) cdrand_range (min, max));
 } /* int64_t rrd_get_random_variation */
 
 static int rrd_cache_insert (const char *filename,
 		const char *value, cdtime_t value_time)
 {
 	rrd_cache_t *rc = NULL;
@@ -907,12 +898,14 @@
 		if (errno == ENOENT)
 		{
 			status = cu_rrd_create_file (filename,
 					ds, vl, &rrdcreate_config);
 			if (status != 0)
 				return (-1);
+			else if (rrdcreate_config.async)
+				return (0);
 		}
 		else
 		{
 			char errbuf[1024];
 			ERROR ("stat(%s) failed: %s", filename,
 					sstrerror (errno, errbuf,
@@ -1005,12 +998,19 @@
 	else if (strcasecmp ("HeartBeat", key) == 0)
 	{
 		int temp = atoi (value);
 		if (temp > 0)
 			rrdcreate_config.heartbeat = temp;
 	}
+	else if (strcasecmp ("CreateFilesAsync", key) == 0)
+	{
+		if (IS_TRUE (value))
+			rrdcreate_config.async = 1;
+		else
+			rrdcreate_config.async = 0;
+	}
 	else if (strcasecmp ("RRARows", key) == 0)
 	{
 		int tmp = atoi (value);
 		if (tmp <= 0)
 		{
 			fprintf (stderr, "rrdtool: `RRARows' must "
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/snmp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/snmp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/snmp.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/snmp.c	2013-04-09 23:18:59.000000000 +0800
@@ -105,13 +105,13 @@
 
 /*
  * Private functions
  */
 static void csnmp_oid_init (oid_t *dst, oid const *src, size_t n)
 {
-  assert (n <= STATIC_ARRAY_LEN (dst->oid));
+  assert (n <= STATIC_ARRAY_SIZE (dst->oid));
   memcpy (dst->oid, src, sizeof (*src) * n);
   dst->oid_len = n;
 }
 
 static int csnmp_oid_compare (oid_t const *left, oid_t const *right)
 {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src: tail_csv.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/types.db /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/types.db
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/types.db	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/types.db	2013-04-09 23:18:59.000000000 +0800
@@ -49,12 +49,13 @@
 dns_request		value:DERIVE:0:U
 dns_resolver		value:DERIVE:0:U
 dns_response		value:DERIVE:0:U
 dns_transfer		value:DERIVE:0:U
 dns_update		value:DERIVE:0:U
 dns_zops		value:DERIVE:0:U
+duration		seconds:GAUGE:0:U
 email_check		value:GAUGE:0:U
 email_count		value:GAUGE:0:U
 email_size		value:GAUGE:0:U
 entropy			value:GAUGE:0:4294967295
 fanspeed		value:GAUGE:0:U
 file_size		value:GAUGE:0:U
@@ -73,13 +74,15 @@
 if_dropped		rx:DERIVE:0:U, tx:DERIVE:0:U
 if_errors		rx:DERIVE:0:U, tx:DERIVE:0:U
 if_multicast		value:DERIVE:0:U
 if_octets		rx:DERIVE:0:U, tx:DERIVE:0:U
 if_packets		rx:DERIVE:0:U, tx:DERIVE:0:U
 if_rx_errors		value:DERIVE:0:U
+if_rx_octets		value:DERIVE:0:U
 if_tx_errors		value:DERIVE:0:U
+if_tx_octets		value:DERIVE:0:U
 invocations		value:DERIVE:0:U
 io_octets		rx:DERIVE:0:U, tx:DERIVE:0:U
 io_packets		rx:DERIVE:0:U, tx:DERIVE:0:U
 ipt_bytes		value:DERIVE:0:U
 ipt_packets		value:DERIVE:0:U
 irq			value:DERIVE:0:U
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src: utils_random.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src: utils_random.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_rrdcreate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_rrdcreate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_rrdcreate.c	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_rrdcreate.c	2013-04-09 23:18:59.000000000 +0800
@@ -1,9 +1,9 @@
 /**
  * collectd - src/utils_rrdcreate.c
- * Copyright (C) 2006-2008  Florian octo Forster
+ * Copyright (C) 2006-2013  Florian octo Forster
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; only version 2 of the License is applicable.
  *
  * This program is distributed in the hope that it will be useful, but
@@ -13,22 +13,40 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
  *
  * Authors:
- *   Florian octo Forster <octo at verplant.org>
+ *   Florian octo Forster <octo at collectd.org>
  **/
 
 #include "collectd.h"
 #include "common.h"
 #include "utils_rrdcreate.h"
 
 #include <pthread.h>
 #include <rrd.h>
 
+struct srrd_create_args_s
+{
+  char *filename;
+  unsigned long pdp_step;
+  time_t last_up;
+  int argc;
+  char **argv;
+};
+typedef struct srrd_create_args_s srrd_create_args_t;
+
+struct async_create_file_s;
+typedef struct async_create_file_s async_create_file_t;
+struct async_create_file_s
+{
+  char *filename;
+  async_create_file_t *next;
+};
+
 /*
  * Private variables
  */
 static int rra_timespans[] =
 {
   3600,
@@ -48,12 +66,15 @@
 static int rra_types_num = STATIC_ARRAY_SIZE (rra_types);
 
 #if !defined(HAVE_THREADSAFE_LIBRRD) || !HAVE_THREADSAFE_LIBRRD
 static pthread_mutex_t librrd_lock = PTHREAD_MUTEX_INITIALIZER;
 #endif
 
+static async_create_file_t *async_creation_list = NULL;
+static pthread_mutex_t async_creation_lock = PTHREAD_MUTEX_INITIALIZER;
+
 /*
  * Private functions
  */
 static void rra_free (int rra_num, char **rra_def) /* {{{ */
 {
   int i;
@@ -62,12 +83,77 @@
   {
     sfree (rra_def[i]);
   }
   sfree (rra_def);
 } /* }}} void rra_free */
 
+static void srrd_create_args_destroy (srrd_create_args_t *args)
+{
+  if (args == NULL)
+    return;
+
+  sfree (args->filename);
+  if (args->argv != NULL)
+  {
+    int i;
+    for (i = 0; i < args->argc; i++)
+      sfree (args->argv[i]);
+    sfree (args->argv);
+  }
+} /* void srrd_create_args_destroy */
+
+static srrd_create_args_t *srrd_create_args_create (const char *filename,
+    unsigned long pdp_step, time_t last_up,
+    int argc, const char **argv)
+{
+  srrd_create_args_t *args;
+
+  args = malloc (sizeof (*args));
+  if (args == NULL)
+  {
+    ERROR ("srrd_create_args_create: malloc failed.");
+    return (NULL);
+  }
+  memset (args, 0, sizeof (*args));
+  args->filename = NULL;
+  args->pdp_step = pdp_step;
+  args->last_up = last_up;
+  args->argv = NULL;
+
+  args->filename = strdup (filename);
+  if (args->filename == NULL)
+  {
+    ERROR ("srrd_create_args_create: strdup failed.");
+    srrd_create_args_destroy (args);
+    return (NULL);
+  }
+
+  args->argv = calloc ((size_t) (argc + 1), sizeof (*args->argv));
+  if (args->argv == NULL)
+  {
+    ERROR ("srrd_create_args_create: calloc failed.");
+    srrd_create_args_destroy (args);
+    return (NULL);
+  }
+
+  for (args->argc = 0; args->argc < argc; args->argc++)
+  {
+    args->argv[args->argc] = strdup (argv[args->argc]);
+    if (args->argv[args->argc] == NULL)
+    {
+      ERROR ("srrd_create_args_create: strdup failed.");
+      srrd_create_args_destroy (args);
+      return (NULL);
+    }
+  }
+  assert (args->argc == argc);
+  args->argv[args->argc] = NULL;
+
+  return (args);
+} /* srrd_create_args_t *srrd_create_args_create */
+
 /* * * * * * * * * *
  * WARNING:  Magic *
  * * * * * * * * * */
 static int rra_get (char ***ret, const value_list_t *vl, /* {{{ */
     const rrdcreate_config_t *cfg)
 {
@@ -356,12 +442,203 @@
   sfree (new_argv);
 
   return (status);
 } /* }}} int srrd_create */
 #endif /* !HAVE_THREADSAFE_LIBRRD */
 
+static int lock_file (char const *filename) /* {{{ */
+{
+  async_create_file_t *ptr;
+  struct stat sb;
+  int status;
+
+  pthread_mutex_lock (&async_creation_lock);
+
+  for (ptr = async_creation_list; ptr != NULL; ptr = ptr->next)
+    if (strcmp (filename, ptr->filename) == 0)
+      break;
+
+  if (ptr != NULL)
+  {
+    pthread_mutex_unlock (&async_creation_lock);
+    return (EEXIST);
+  }
+
+  status = stat (filename, &sb);
+  if ((status == 0) || (errno != ENOENT))
+  {
+    pthread_mutex_unlock (&async_creation_lock);
+    return (EEXIST);
+  }
+
+  ptr = malloc (sizeof (*ptr));
+  if (ptr == NULL)
+  {
+    pthread_mutex_unlock (&async_creation_lock);
+    return (ENOMEM);
+  }
+
+  ptr->filename = strdup (filename);
+  if (ptr->filename == NULL)
+  {
+    pthread_mutex_unlock (&async_creation_lock);
+    sfree (ptr);
+    return (ENOMEM);
+  }
+
+  ptr->next = async_creation_list;
+  async_creation_list = ptr;
+
+  pthread_mutex_unlock (&async_creation_lock);
+
+  return (0);
+} /* }}} int lock_file */
+
+static int unlock_file (char const *filename) /* {{{ */
+{
+  async_create_file_t *this;
+  async_create_file_t *prev;
+
+
+  pthread_mutex_lock (&async_creation_lock);
+
+  prev = NULL;
+  for (this = async_creation_list; this != NULL; this = this->next)
+  {
+    if (strcmp (filename, this->filename) == 0)
+      break;
+    prev = this;
+  }
+
+  if (this == NULL)
+  {
+    pthread_mutex_unlock (&async_creation_lock);
+    return (ENOENT);
+  }
+
+  if (prev == NULL)
+  {
+    assert (this == async_creation_list);
+    async_creation_list = this->next;
+  }
+  else
+  {
+    assert (this == prev->next);
+    prev->next = this->next;
+  }
+  this->next = NULL;
+
+  pthread_mutex_unlock (&async_creation_lock);
+
+  sfree (this->filename);
+  sfree (this);
+
+  return (0);
+} /* }}} int unlock_file */
+
+static void *srrd_create_thread (void *targs) /* {{{ */
+{
+  srrd_create_args_t *args = targs;
+  char tmpfile[PATH_MAX];
+  int status;
+
+  status = lock_file (args->filename);
+  if (status != 0)
+  {
+    if (status == EEXIST)
+      NOTICE ("srrd_create_thread: File \"%s\" is already being created.",
+          args->filename);
+    else
+      ERROR ("srrd_create_thread: Unable to lock file \"%s\".",
+          args->filename);
+    srrd_create_args_destroy (args);
+    return (0);
+  }
+
+  ssnprintf (tmpfile, sizeof (tmpfile), "%s.async", args->filename);
+
+  status = srrd_create (tmpfile, args->pdp_step, args->last_up,
+      args->argc, (void *) args->argv);
+  if (status != 0)
+  {
+    WARNING ("srrd_create_thread: srrd_create (%s) returned status %i.",
+        args->filename, status);
+    unlink (tmpfile);
+    unlock_file (args->filename);
+    srrd_create_args_destroy (args);
+    return (0);
+  }
+
+  status = rename (tmpfile, args->filename);
+  if (status != 0)
+  {
+    char errbuf[1024];
+    ERROR ("srrd_create_thread: rename (\"%s\", \"%s\") failed: %s",
+        tmpfile, args->filename,
+        sstrerror (errno, errbuf, sizeof (errbuf)));
+    unlink (tmpfile);
+    unlock_file (args->filename);
+    srrd_create_args_destroy (args);
+    return (0);
+  }
+
+  DEBUG ("srrd_create_thread: Successfully created RRD file \"%s\".",
+      args->filename);
+
+  unlock_file (args->filename);
+  srrd_create_args_destroy (args);
+
+  return (0);
+} /* }}} void *srrd_create_thread */
+
+static int srrd_create_async (const char *filename, /* {{{ */
+    unsigned long pdp_step, time_t last_up,
+    int argc, const char **argv)
+{
+  srrd_create_args_t *args;
+  pthread_t thread;
+  pthread_attr_t attr;
+  int status;
+
+  DEBUG ("srrd_create_async: Creating \"%s\" in the background.", filename);
+
+  args = srrd_create_args_create (filename, pdp_step, last_up, argc, argv);
+  if (args == NULL)
+    return (-1);
+
+  status = pthread_attr_init (&attr);
+  if (status != 0)
+  {
+    srrd_create_args_destroy (args);
+    return (-1);
+  }
+
+  status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+  if (status != 0)
+  {
+    pthread_attr_destroy (&attr);
+    srrd_create_args_destroy (args);
+    return (-1);
+  }
+
+  status = pthread_create (&thread, &attr, srrd_create_thread, args);
+  if (status != 0)
+  {
+    char errbuf[1024];
+    ERROR ("srrd_create_async: pthread_create failed: %s",
+        sstrerror (status, errbuf, sizeof (errbuf)));
+    pthread_attr_destroy (&attr);
+    srrd_create_args_destroy (args);
+    return (status);
+  }
+
+  pthread_attr_destroy (&attr);
+  /* args is freed in srrd_create_thread(). */
+  return (0);
+} /* }}} int srrd_create_async */
+
 /*
  * Public functions
  */
 int cu_rrd_create_file (const char *filename, /* {{{ */
     const data_set_t *ds, const value_list_t *vl,
     const rrdcreate_config_t *cfg)
@@ -412,28 +689,40 @@
 
   if (cfg->stepsize > 0)
     stepsize = cfg->stepsize;
   else
     stepsize = (unsigned long) CDTIME_T_TO_TIME_T (vl->interval);
 
-  status = srrd_create (filename, stepsize, last_up,
-      argc, (const char **) argv);
-
-  free (argv);
-  ds_free (ds_num, ds_def);
-  rra_free (rra_num, rra_def);
-
-  if (status != 0)
+  if (cfg->async)
   {
-    WARNING ("cu_rrd_create_file: srrd_create (%s) returned status %i.",
-        filename, status);
+    status = srrd_create_async (filename, stepsize, last_up,
+        argc, (const char **) argv);
+    if (status != 0)
+      WARNING ("cu_rrd_create_file: srrd_create_async (%s) "
+          "returned status %i.",
+          filename, status);
   }
-  else
+  else /* synchronous */
   {
-    DEBUG ("cu_rrd_create_file: Successfully created RRD file \"%s\".",
-        filename);
+    status = srrd_create (filename, stepsize, last_up,
+        argc, (const char **) argv);
+
+    if (status != 0)
+    {
+      WARNING ("cu_rrd_create_file: srrd_create (%s) returned status %i.",
+          filename, status);
+    }
+    else
+    {
+      DEBUG ("cu_rrd_create_file: Successfully created RRD file \"%s\".",
+          filename);
+    }
   }
 
+  free (argv);
+  ds_free (ds_num, ds_def);
+  rra_free (rra_num, rra_def);
+
   return (status);
 } /* }}} int cu_rrd_create_file */
 
 /* vim: set sw=2 sts=2 et fdm=marker : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_rrdcreate.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_rrdcreate.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_rrdcreate.h	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_rrdcreate.h	2013-04-09 23:18:59.000000000 +0800
@@ -1,9 +1,9 @@
 /**
  * collectd - src/utils_rrdcreate.h
- * Copyright (C) 2008  Florian octo Forster
+ * Copyright (C) 2008-2013  Florian octo Forster
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; only version 2 of the License is applicable.
  *
  * This program is distributed in the hope that it will be useful, but
@@ -13,13 +13,13 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
  *
  * Authors:
- *   Florian octo Forster <octo at verplant.org>
+ *   Florian octo Forster <octo at collectd.org>
  **/
 
 #ifndef UTILS_RRDCREATE_H
 #define UTILS_RRDCREATE_H 1
 
 #include "plugin.h"
@@ -35,12 +35,14 @@
 
   int *timespans;
   size_t timespans_num;
 
   char **consolidation_functions;
   size_t consolidation_functions_num;
+
+  _Bool async;
 };
 typedef struct rrdcreate_config_s rrdcreate_config_t;
 
 int cu_rrd_create_file (const char *filename,
     const data_set_t *ds, const value_list_t *vl,
     const rrdcreate_config_t *cfg);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_vl_lookup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_vl_lookup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_vl_lookup.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_vl_lookup.c	2013-04-09 23:18:59.000000000 +0800
@@ -22,12 +22,15 @@
  *
  * Authors:
  *   Florian Forster <octo at collectd.org>
  **/
 
 #include "collectd.h"
+
+#include <regex.h>
+
 #include "common.h"
 #include "utils_vl_lookup.h"
 #include "utils_avltree.h"
 
 #if BUILD_TEST
 # define sstrncpy strncpy
@@ -38,12 +41,32 @@
 } while (0)
 #endif
 
 /*
  * Types
  */
+struct part_match_s
+{
+  char str[DATA_MAX_NAME_LEN];
+  regex_t regex;
+  _Bool is_regex;
+};
+typedef struct part_match_s part_match_t;
+
+struct identifier_match_s
+{
+  part_match_t host;
+  part_match_t plugin;
+  part_match_t plugin_instance;
+  part_match_t type;
+  part_match_t type_instance;
+
+  unsigned int group_by;
+};
+typedef struct identifier_match_s identifier_match_t;
+
 struct lookup_s
 {
   c_avl_tree_t *by_type_tree;
 
   lookup_class_callback_t cb_user_class;
   lookup_obj_callback_t cb_user_obj;
@@ -61,13 +84,13 @@
   user_obj_t *next;
 };
 
 struct user_class_s
 {
   void *user_class;
-  identifier_t ident;
+  identifier_match_t match;
   user_obj_t *user_obj_list; /* list of user_obj */
 };
 typedef struct user_class_s user_class_t;
 
 struct user_class_list_s;
 typedef struct user_class_list_s user_class_list_t;
@@ -84,12 +107,93 @@
 };
 typedef struct by_type_entry_s by_type_entry_t;
 
 /*
  * Private functions
  */
+static _Bool lu_part_matches (part_match_t const *match, /* {{{ */
+    char const *str)
+{
+  if (match->is_regex)
+  {
+    /* Short cut popular catch-all regex. */
+    if (strcmp (".*", match->str) == 0)
+      return (1);
+
+    int status = regexec (&match->regex, str,
+        /* nmatch = */ 0, /* pmatch = */ NULL,
+        /* flags = */ 0);
+    if (status == 0)
+      return (1);
+    else
+      return (0);
+  }
+  else if (strcmp (match->str, str) == 0)
+    return (1);
+  else
+    return (0);
+} /* }}} _Bool lu_part_matches */
+
+static int lu_copy_ident_to_match_part (part_match_t *match_part, /* {{{ */
+    char const *ident_part)
+{
+  size_t len = strlen (ident_part);
+  int status;
+
+  if ((len < 3) || (ident_part[0] != '/') || (ident_part[len - 1] != '/'))
+  {
+    sstrncpy (match_part->str, ident_part, sizeof (match_part->str));
+    match_part->is_regex = 0;
+    return (0);
+  }
+
+  /* Copy string without the leading slash. */
+  sstrncpy (match_part->str, ident_part + 1, sizeof (match_part->str));
+  assert (sizeof (match_part->str) > len);
+  /* strip trailing slash */
+  match_part->str[len - 2] = 0;
+  
+  status = regcomp (&match_part->regex, match_part->str,
+      /* flags = */ REG_EXTENDED);
+  if (status != 0)
+  {
+    char errbuf[1024];
+    regerror (status, &match_part->regex, errbuf, sizeof (errbuf));
+    ERROR ("utils_vl_lookup: Compiling regular expression \"%s\" failed: %s",
+        match_part->str, errbuf);
+    return (EINVAL);
+  }
+  match_part->is_regex = 1;
+  
+  return (0);
+} /* }}} int lu_copy_ident_to_match_part */
+
+static int lu_copy_ident_to_match (identifier_match_t *match, /* {{{ */
+    identifier_t const *ident, unsigned int group_by)
+{
+  memset (match, 0, sizeof (*match));
+
+  match->group_by = group_by;
+
+#define COPY_FIELD(field) do { \
+  int status = lu_copy_ident_to_match_part (&match->field, ident->field); \
+  if (status != 0) \
+    return (status); \
+} while (0)
+
+  COPY_FIELD (host);
+  COPY_FIELD (plugin);
+  COPY_FIELD (plugin_instance);
+  COPY_FIELD (type);
+  COPY_FIELD (type_instance);
+
+#undef COPY_FIELD
+
+  return (0);
+} /* }}} int lu_copy_ident_to_match */
+
 static void *lu_create_user_obj (lookup_t *obj, /* {{{ */
     data_set_t const *ds, value_list_t const *vl,
     user_class_t *user_class)
 {
   user_obj_t *user_obj;
 
@@ -107,27 +211,27 @@
   {
     sfree (user_obj);
     WARNING("utils_vl_lookup: User-provided constructor failed.");
     return (NULL);
   }
 
-  sstrncpy (user_obj->ident.host,
-    LU_IS_ALL (user_class->ident.host) ?  "/all/" : vl->host,
-    sizeof (user_obj->ident.host));
-  sstrncpy (user_obj->ident.plugin,
-    LU_IS_ALL (user_class->ident.plugin) ?  "/all/" : vl->plugin,
-    sizeof (user_obj->ident.plugin));
-  sstrncpy (user_obj->ident.plugin_instance,
-    LU_IS_ALL (user_class->ident.plugin_instance) ?  "/all/" : vl->plugin_instance,
-    sizeof (user_obj->ident.plugin_instance));
-  sstrncpy (user_obj->ident.type,
-    LU_IS_ALL (user_class->ident.type) ?  "/all/" : vl->type,
-    sizeof (user_obj->ident.type));
-  sstrncpy (user_obj->ident.type_instance,
-    LU_IS_ALL (user_class->ident.type_instance) ?  "/all/" : vl->type_instance,
-    sizeof (user_obj->ident.type_instance));
+#define COPY_FIELD(field, group_mask) do { \
+  if (user_class->match.field.is_regex \
+      && ((user_class->match.group_by & group_mask) == 0)) \
+    sstrncpy (user_obj->ident.field, "/.*/", sizeof (user_obj->ident.field)); \
+  else \
+    sstrncpy (user_obj->ident.field, vl->field, sizeof (user_obj->ident.field)); \
+} while (0)
+
+  COPY_FIELD (host, LU_GROUP_BY_HOST);
+  COPY_FIELD (plugin, LU_GROUP_BY_PLUGIN);
+  COPY_FIELD (plugin_instance, LU_GROUP_BY_PLUGIN_INSTANCE);
+  COPY_FIELD (type, 0);
+  COPY_FIELD (type_instance, LU_GROUP_BY_TYPE_INSTANCE);
+
+#undef COPY_FIELD
 
   if (user_class->user_obj_list == NULL)
   {
     user_class->user_obj_list = user_obj;
   }
   else
@@ -147,20 +251,27 @@
   user_obj_t *ptr;
 
   for (ptr = user_class->user_obj_list;
       ptr != NULL;
       ptr = ptr->next)
   {
-    if (!LU_IS_ALL (ptr->ident.host)
-        && (strcmp (ptr->ident.host, vl->host) != 0))
+    if (user_class->match.host.is_regex
+        && (user_class->match.group_by & LU_GROUP_BY_HOST)
+        && (strcmp (vl->host, ptr->ident.host) != 0))
+      continue;
+    if (user_class->match.plugin.is_regex
+        && (user_class->match.group_by & LU_GROUP_BY_PLUGIN)
+        && (strcmp (vl->plugin, ptr->ident.plugin) != 0))
       continue;
-    if (!LU_IS_ALL (ptr->ident.plugin_instance)
-        && (strcmp (ptr->ident.plugin_instance, vl->plugin_instance) != 0))
+    if (user_class->match.plugin_instance.is_regex
+        && (user_class->match.group_by & LU_GROUP_BY_PLUGIN_INSTANCE)
+        && (strcmp (vl->plugin_instance, ptr->ident.plugin_instance) != 0))
       continue;
-    if (!LU_IS_ALL (ptr->ident.type_instance)
-        && (strcmp (ptr->ident.type_instance, vl->type_instance) != 0))
+    if (user_class->match.type_instance.is_regex
+        && (user_class->match.group_by & LU_GROUP_BY_TYPE_INSTANCE)
+        && (strcmp (vl->type_instance, ptr->ident.type_instance) != 0))
       continue;
 
     return (ptr);
   }
 
   return (NULL);
@@ -170,27 +281,20 @@
     data_set_t const *ds, value_list_t const *vl,
     user_class_t *user_class)
 {
   user_obj_t *user_obj;
   int status;
 
-  assert (strcmp (vl->type, user_class->ident.type) == 0);
-  assert (LU_IS_WILDCARD (user_class->ident.plugin)
-      || (strcmp (vl->plugin, user_class->ident.plugin) == 0));
-
-  /* When we get here, type and plugin already match the user class. Now check
-   * the rest of the fields. */
-  if (!LU_IS_WILDCARD (user_class->ident.type_instance)
-      && (strcmp (vl->type_instance, user_class->ident.type_instance) != 0))
-    return (1);
-  if (!LU_IS_WILDCARD (user_class->ident.plugin_instance)
-      && (strcmp (vl->plugin_instance,
-          user_class->ident.plugin_instance) != 0))
-    return (1);
-  if (!LU_IS_WILDCARD (user_class->ident.host)
-      && (strcmp (vl->host, user_class->ident.host) != 0))
+  assert (strcmp (vl->type, user_class->match.type.str) == 0);
+  assert (user_class->match.plugin.is_regex
+      || (strcmp (vl->plugin, user_class->match.plugin.str)) == 0);
+
+  if (!lu_part_matches (&user_class->match.type_instance, vl->type_instance)
+      || !lu_part_matches (&user_class->match.plugin_instance, vl->plugin_instance)
+      || !lu_part_matches (&user_class->match.plugin, vl->plugin)
+      || !lu_part_matches (&user_class->match.host, vl->host))
     return (1);
 
   user_obj = lu_find_user_obj (user_class, vl);
   if (user_obj == NULL)
   {
     /* call lookup_class_callback_t() and insert into the list of user objects. */
@@ -289,20 +393,21 @@
   }
   
   return (by_type);
 } /* }}} by_type_entry_t *lu_search_by_type */
 
 static int lu_add_by_plugin (by_type_entry_t *by_type, /* {{{ */
-    identifier_t const *ident, user_class_list_t *user_class_list)
+    user_class_list_t *user_class_list)
 {
   user_class_list_t *ptr = NULL;
+  identifier_match_t const *match = &user_class_list->entry.match;
 
   /* Lookup user_class_list from the per-plugin structure. If this is the first
    * user_class to be added, the blocks return immediately. Otherwise they will
    * set "ptr" to non-NULL. */
-  if (LU_IS_WILDCARD (ident->plugin))
+  if (match->plugin.is_regex)
   {
     if (by_type->wildcard_plugin_list == NULL)
     {
       by_type->wildcard_plugin_list = user_class_list;
       return (0);
     }
@@ -311,17 +416,17 @@
   } /* if (plugin is wildcard) */
   else /* (plugin is not wildcard) */
   {
     int status;
 
     status = c_avl_get (by_type->by_plugin_tree,
-        ident->plugin, (void *) &ptr);
+        match->plugin.str, (void *) &ptr);
 
     if (status != 0) /* plugin not yet in tree */
     {
-      char *plugin_copy = strdup (ident->plugin);
+      char *plugin_copy = strdup (match->plugin.str);
 
       if (plugin_copy == NULL)
       {
         ERROR ("utils_vl_lookup: strdup failed.");
         sfree (user_class_list);
         return (ENOMEM);
@@ -475,13 +580,13 @@
   obj->by_type_tree = NULL;
 
   sfree (obj);
 } /* }}} void lookup_destroy */
 
 int lookup_add (lookup_t *obj, /* {{{ */
-    identifier_t const *ident, void *user_class)
+    identifier_t const *ident, unsigned int group_by, void *user_class)
 {
   by_type_entry_t *by_type = NULL;
   user_class_list_t *user_class_obj;
 
   by_type = lu_search_by_type (obj, ident->type, /* allocate = */ 1);
   if (by_type == NULL)
@@ -492,17 +597,17 @@
   {
     ERROR ("utils_vl_lookup: malloc failed.");
     return (ENOMEM);
   }
   memset (user_class_obj, 0, sizeof (*user_class_obj));
   user_class_obj->entry.user_class = user_class;
-  memmove (&user_class_obj->entry.ident, ident, sizeof (*ident));
+  lu_copy_ident_to_match (&user_class_obj->entry.match, ident, group_by);
   user_class_obj->entry.user_obj_list = NULL;
   user_class_obj->next = NULL;
 
-  return (lu_add_by_plugin (by_type, ident, user_class_obj));
+  return (lu_add_by_plugin (by_type, user_class_obj));
 } /* }}} int lookup_add */
 
 /* returns the number of successful calls to the callback function */
 int lookup_search (lookup_t *obj, /* {{{ */
     data_set_t const *ds, value_list_t const *vl)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_vl_lookup.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_vl_lookup.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_vl_lookup.h	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_vl_lookup.h	2013-04-09 23:18:59.000000000 +0800
@@ -60,31 +60,30 @@
   char plugin_instance[DATA_MAX_NAME_LEN];
   char type[DATA_MAX_NAME_LEN];
   char type_instance[DATA_MAX_NAME_LEN];
 };
 typedef struct identifier_s identifier_t;
 
-#define LU_ANY "/any/"
-#define LU_ALL "/all/"
-
-#define LU_IS_ANY(str) (strcmp (str, LU_ANY) == 0)
-#define LU_IS_ALL(str) (strcmp (str, LU_ALL) == 0)
-#define LU_IS_WILDCARD(str) (LU_IS_ANY(str) || LU_IS_ALL(str))
+#define LU_GROUP_BY_HOST            0x01
+#define LU_GROUP_BY_PLUGIN          0x02
+#define LU_GROUP_BY_PLUGIN_INSTANCE 0x04
+/* #define LU_GROUP_BY_TYPE            0x00 */
+#define LU_GROUP_BY_TYPE_INSTANCE   0x10
 
 /*
  * Functions
  */
 __attribute__((nonnull(1,2)))
 lookup_t *lookup_create (lookup_class_callback_t,
     lookup_obj_callback_t,
     lookup_free_class_callback_t,
     lookup_free_obj_callback_t);
 void lookup_destroy (lookup_t *obj);
 
 int lookup_add (lookup_t *obj,
-    identifier_t const *ident, void *user_class);
+    identifier_t const *ident, unsigned int group_by, void *user_class);
 
 /* TODO(octo): Pass lookup_obj_callback_t to lookup_search()? */
 int lookup_search (lookup_t *obj,
     data_set_t const *ds, value_list_t const *vl);
 
 #endif /* UTILS_VL_LOOKUP_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_vl_lookup_test.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_vl_lookup_test.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/utils_vl_lookup_test.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/utils_vl_lookup_test.c	2013-04-09 23:19:00.000000000 +0800
@@ -79,13 +79,14 @@
   return ((void *) obj);
 }
 
 static void checked_lookup_add (lookup_t *obj, /* {{{ */
     char const *host,
     char const *plugin, char const *plugin_instance,
-    char const *type, char const *type_instance)
+    char const *type, char const *type_instance,
+    unsigned int group_by)
 {
   identifier_t ident;
   void *user_class;
   int status;
 
   memset (&ident, 0, sizeof (ident));
@@ -95,13 +96,13 @@
   strncpy (ident.type, type, sizeof (ident.type));
   strncpy (ident.type_instance, type_instance, sizeof (ident.type_instance));
 
   user_class = malloc (sizeof (ident));
   memmove (user_class, &ident, sizeof (ident));
 
-  status = lookup_add (obj, &ident, user_class);
+  status = lookup_add (obj, &ident, group_by, user_class);
   assert (status == 0);
 } /* }}} void test_add */
 
 static int checked_lookup_search (lookup_t *obj,
     char const *host,
     char const *plugin, char const *plugin_instance,
@@ -140,13 +141,13 @@
 }
 
 static void testcase0 (void)
 {
   lookup_t *obj = checked_lookup_create ();
 
-  checked_lookup_add (obj, "/any/", "test", "", "test", "/all/");
+  checked_lookup_add (obj, "/.*/", "test", "", "test", "/.*/", LU_GROUP_BY_HOST);
   checked_lookup_search (obj, "host0", "test", "", "test", "0",
       /* expect new = */ 1);
   checked_lookup_search (obj, "host0", "test", "", "test", "1",
       /* expect new = */ 0);
   checked_lookup_search (obj, "host1", "test", "", "test", "0",
       /* expect new = */ 1);
@@ -157,13 +158,13 @@
 }
 
 static void testcase1 (void)
 {
   lookup_t *obj = checked_lookup_create ();
 
-  checked_lookup_add (obj, "/any/", "/all/", "/all/", "test", "/all/");
+  checked_lookup_add (obj, "/.*/", "/.*/", "/.*/", "test", "/.*/", LU_GROUP_BY_HOST);
   checked_lookup_search (obj, "host0", "plugin0", "", "test", "0",
       /* expect new = */ 1);
   checked_lookup_search (obj, "host0", "plugin0", "", "test", "1",
       /* expect new = */ 0);
   checked_lookup_search (obj, "host0", "plugin1", "", "test", "0",
       /* expect new = */ 0);
@@ -183,14 +184,14 @@
 
 static void testcase2 (void)
 {
   lookup_t *obj = checked_lookup_create ();
   int status;
 
-  checked_lookup_add (obj, "/any/", "plugin0", "", "test", "/all/");
-  checked_lookup_add (obj, "/any/", "/all/", "", "test", "ti0");
+  checked_lookup_add (obj, "/.*/", "plugin0", "", "test", "/.*/", LU_GROUP_BY_HOST);
+  checked_lookup_add (obj, "/.*/", "/.*/", "", "test", "ti0", LU_GROUP_BY_HOST);
 
   status = checked_lookup_search (obj, "host0", "plugin1", "", "test", "",
       /* expect new = */ 0);
   assert (status == 0);
   status = checked_lookup_search (obj, "host0", "plugin0", "", "test", "",
       /* expect new = */ 1);
@@ -202,13 +203,42 @@
       /* expect new = */ 0);
   assert (status == 2);
 
   lookup_destroy (obj);
 }
 
+static void testcase3 (void)
+{
+  lookup_t *obj = checked_lookup_create ();
+
+  checked_lookup_add (obj, "/^db[0-9]\\./", "cpu", "/.*/", "cpu", "/.*/",
+      LU_GROUP_BY_TYPE_INSTANCE);
+  checked_lookup_search (obj, "db0.example.com", "cpu", "0", "cpu", "user",
+      /* expect new = */ 1);
+  checked_lookup_search (obj, "db0.example.com", "cpu", "0", "cpu", "idle",
+      /* expect new = */ 1);
+  checked_lookup_search (obj, "db0.example.com", "cpu", "1", "cpu", "user",
+      /* expect new = */ 0);
+  checked_lookup_search (obj, "db0.example.com", "cpu", "1", "cpu", "idle",
+      /* expect new = */ 0);
+  checked_lookup_search (obj, "app0.example.com", "cpu", "0", "cpu", "user",
+      /* expect new = */ 0);
+  checked_lookup_search (obj, "app0.example.com", "cpu", "0", "cpu", "idle",
+      /* expect new = */ 0);
+  checked_lookup_search (obj, "db1.example.com", "cpu", "0", "cpu", "user",
+      /* expect new = */ 0);
+  checked_lookup_search (obj, "db1.example.com", "cpu", "0", "cpu", "idle",
+      /* expect new = */ 0);
+  checked_lookup_search (obj, "db1.example.com", "cpu", "0", "cpu", "system",
+      /* expect new = */ 1);
+
+  lookup_destroy (obj);
+}
+
 int main (int argc, char **argv) /* {{{ */
 {
   testcase0 ();
   testcase1 ();
   testcase2 ();
+  testcase3 ();
   return (EXIT_SUCCESS);
 } /* }}} int main */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/uuid.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/uuid.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/uuid.c	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/uuid.c	2013-04-09 23:19:00.000000000 +0800
@@ -33,17 +33,17 @@
 #endif
 
 #define UUID_RAW_LENGTH 16
 #define UUID_PRINTABLE_COMPACT_LENGTH  (UUID_RAW_LENGTH * 2)
 #define UUID_PRINTABLE_NORMAL_LENGTH  (UUID_PRINTABLE_COMPACT_LENGTH + 4)
 
-#define HANDLE_PREFIX "Handle"
-#define SYSINFO_PREFIX "System Information"
-#define ALT_SYSINFO_PREFIX "\tSystem Information"
-#define UUID_PREFIX "\tUUID:"
-#define ALT_UUID_PREFIX "\t\tUUID:"
+static char *uuidfile = NULL;
+
+static const char *config_keys[] = {
+    "UUIDFile"
+};
 
 static int
 looks_like_a_uuid (const char *uuid)
 {
     int len;
 
@@ -62,48 +62,34 @@
 }
 
 static char *
 uuid_parse_dmidecode(FILE *file)
 {
     char line[1024];
-    int inSysInfo = 0;
 
-    for (;;) {
-        if (!fgets(line, sizeof(line)/sizeof(char), file)) {
-            return NULL;
-        }
-        if (strncmp(line, HANDLE_PREFIX,
-                    (sizeof(HANDLE_PREFIX)/sizeof(char))-1) == 0) {
-            /*printf("Got handle %s\n", line);*/
-            inSysInfo = 0;
-        } else if (strncmp(line, SYSINFO_PREFIX,
-                           (sizeof(SYSINFO_PREFIX)/sizeof(char))-1) == 0) {
-            /*printf("Got system info %s\n", line);*/
-            inSysInfo = 1;
-        } else if (strncmp(line, ALT_SYSINFO_PREFIX,
-                           (sizeof(ALT_SYSINFO_PREFIX)/sizeof(char))-1) == 0) {
-            /*printf("Got alt system info %s\n", line);*/
-            inSysInfo = 1;
-        }
-        
-        if (inSysInfo) {
-            if (strncmp(line, UUID_PREFIX,
-                        (sizeof(UUID_PREFIX)/sizeof(char))-1) == 0) {
-                char *uuid = line + (sizeof(UUID_PREFIX)/sizeof(char));
-                /*printf("Got uuid [%s]\n", uuid);*/
-                if (looks_like_a_uuid (uuid))
-                    return strdup (uuid);
-            }
-            if (strncmp(line, ALT_UUID_PREFIX,
-                        (sizeof(ALT_UUID_PREFIX)/sizeof(char))-1) == 0) {
-                char *uuid = line + (sizeof(ALT_UUID_PREFIX)/sizeof(char));
-                /*printf("Got alt uuid [%s]\n", uuid);*/
-                if (looks_like_a_uuid (uuid))
-                    return strdup (uuid);
-            }
-        }
+    while (fgets (line, sizeof (line), file) != NULL)
+    {
+        char *fields[4];
+        int fields_num;
+
+        strstripnewline (line);
+
+        /* Look for a line reading:
+         *   UUID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
+         */
+        fields_num = strsplit (line, fields, STATIC_ARRAY_SIZE (fields));
+        if (fields_num != 2)
+            continue;
+
+        if (strcmp("UUID:", fields[0]) != 0)
+            continue;
+
+        if (!looks_like_a_uuid (fields[1]))
+            continue;
+
+        return strdup (fields[1]);
     }
     return NULL;
 }
 
 static char *
 uuid_get_from_dmidecode(void)
@@ -184,29 +170,28 @@
 #endif
 
 static char *
 uuid_get_from_file(const char *path)
 {
     FILE *file;
-    char uuid[UUID_PRINTABLE_NORMAL_LENGTH+1];
+    char uuid[UUID_PRINTABLE_NORMAL_LENGTH + 1] = "";
 
-    if (!(file = fopen(path, "r"))) {
+    file = fopen (path, "r");
+    if (file == NULL)
         return NULL;
-    }
 
     if (!fgets(uuid, sizeof(uuid), file)) {
         fclose(file);
         return NULL;
     }
     fclose(file);
+    strstripnewline (uuid);
 
     return strdup (uuid);
 }
 
-static char *uuidfile = NULL;
-
 static char *
 uuid_get_local(void)
 {
     char *uuid;
 
     /* Check /etc/uuid / UUIDFile before any other method. */
@@ -228,29 +213,25 @@
         return uuid;
     }
 
     return NULL;
 }
 
-static const char *config_keys[] = {
-    "UUIDFile",
-    NULL
-};
-#define NR_CONFIG_KEYS ((sizeof config_keys / sizeof config_keys[0]) - 1)
-
 static int
 uuid_config (const char *key, const char *value)
 {
     if (strcasecmp (key, "UUIDFile") == 0) {
-        if (uuidfile) {
-            ERROR ("UUIDFile given twice in configuration file");
-            return 1;
-        }
-        uuidfile = strdup (value);
-        return 0;
+        char *tmp = strdup (value);
+        if (tmp == NULL)
+            return -1;
+        sfree (uuidfile);
+        uuidfile = tmp;
+    } else {
+        return 1;
     }
+
     return 0;
 }
 
 static int
 uuid_init (void)
 {
@@ -265,15 +246,15 @@
     WARNING ("uuid: could not read UUID using any known method");
     return 0;
 }
 
 void module_register (void)
 {
-	plugin_register_config ("uuid", uuid_config,
-                            config_keys, NR_CONFIG_KEYS);
-	plugin_register_init ("uuid", uuid_init);
+    plugin_register_config ("uuid", uuid_config,
+            config_keys, STATIC_ARRAY_SIZE (config_keys));
+    plugin_register_init ("uuid", uuid_init);
 }
 
 /*
  * vim: set tabstop=4:
  * vim: set shiftwidth=4:
  * vim: set expandtab:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/write_graphite.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/write_graphite.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/write_graphite.c	2013-04-09 09:13:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/write_graphite.c	2013-04-09 23:19:00.000000000 +0800
@@ -77,12 +77,14 @@
  * Private variables
  */
 struct wg_callback
 {
     int      sock_fd;
 
+    char    *name;
+
     char    *node;
     char    *service;
     char    *prefix;
     char    *postfix;
     char     escape_char;
 
@@ -248,12 +250,13 @@
 
     wg_flush_nolock (/* timeout = */ 0, cb);
 
     close(cb->sock_fd);
     cb->sock_fd = -1;
 
+    sfree(cb->name);
     sfree(cb->node);
     sfree(cb->service);
     sfree(cb->prefix);
     sfree(cb->postfix);
 
     pthread_mutex_destroy (&cb->send_lock);
@@ -418,13 +421,13 @@
 
     *dest = buffer[0];
 
     return (0);
 }
 
-static int wg_config_carbon (oconfig_item_t *ci)
+static int wg_config_node (oconfig_item_t *ci)
 {
     struct wg_callback *cb;
     user_data_t user_data;
     char callback_name[DATA_MAX_NAME_LEN];
     int i;
 
@@ -433,19 +436,31 @@
     {
         ERROR ("write_graphite plugin: malloc failed.");
         return (-1);
     }
     memset (cb, 0, sizeof (*cb));
     cb->sock_fd = -1;
+    cb->name = NULL;
     cb->node = NULL;
     cb->service = NULL;
     cb->prefix = NULL;
     cb->postfix = NULL;
     cb->escape_char = WG_DEFAULT_ESCAPE;
     cb->format_flags = GRAPHITE_STORE_RATES;
 
+    /* FIXME: Legacy configuration syntax. */
+    if (strcasecmp ("Carbon", ci->key) != 0)
+    {
+        int status = cf_util_get_string (ci, &cb->name);
+        if (status != 0)
+        {
+            wg_callback_free (cb);
+            return (status);
+        }
+    }
+
     pthread_mutex_init (&cb->send_lock, /* attr = */ NULL);
     C_COMPLAIN_INIT (&cb->init_complaint);
 
     for (i = 0; i < ci->children_num; i++)
     {
         oconfig_item_t *child = ci->children + i;
@@ -473,15 +488,20 @@
         {
             ERROR ("write_graphite plugin: Invalid configuration "
                         "option: %s.", child->key);
         }
     }
 
-    ssnprintf (callback_name, sizeof (callback_name), "write_graphite/%s/%s",
-            cb->node != NULL ? cb->node : WG_DEFAULT_NODE,
-            cb->service != NULL ? cb->service : WG_DEFAULT_SERVICE);
+    /* FIXME: Legacy configuration syntax. */
+    if (cb->name == NULL)
+        ssnprintf (callback_name, sizeof (callback_name), "write_graphite/%s/%s",
+                cb->node != NULL ? cb->node : WG_DEFAULT_NODE,
+                cb->service != NULL ? cb->service : WG_DEFAULT_SERVICE);
+    else
+        ssnprintf (callback_name, sizeof (callback_name), "write_graphite/%s",
+                cb->name);
 
     memset (&user_data, 0, sizeof (user_data));
     user_data.data = cb;
     user_data.free_func = wg_callback_free;
     plugin_register_write (callback_name, wg_write, &user_data);
 
@@ -496,14 +516,17 @@
     int i;
 
     for (i = 0; i < ci->children_num; i++)
     {
         oconfig_item_t *child = ci->children + i;
 
-        if (strcasecmp ("Carbon", child->key) == 0)
-            wg_config_carbon (child);
+        if (strcasecmp ("Node", child->key) == 0)
+            wg_config_node (child);
+        /* FIXME: Remove this legacy mode in version 6. */
+        else if (strcasecmp ("Carbon", child->key) == 0)
+            wg_config_node (child);
         else
         {
             ERROR ("write_graphite plugin: Invalid configuration "
                     "option: %s.", child->key);
         }
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/write_mongodb.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/write_mongodb.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/src/write_mongodb.c	2013-04-09 09:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src/write_mongodb.c	2013-04-09 23:19:00.000000000 +0800
@@ -1,9 +1,9 @@
 /**
  * collectd - src/write_mongodb.c
- * Copyright (C) 2010-2012  Florian Forster
+ * Copyright (C) 2010-2013  Florian Forster
  * Copyright (C) 2010       Akkarit Sangpetch
  * Copyright (C) 2012       Chris Lundquist
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
  * to deal in the Software without restriction, including without limitation
@@ -20,13 +20,13 @@
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  *
  * Authors:
- *   Florian Forster <ff at octo.it>
+ *   Florian Forster <octo at collectd.org>
  *   Akkarit Sangpetch <asangpet at andrew.cmu.edu>
  *   Chris Lundquist <clundquist at bluebox.net>
  **/
 
 #include "collectd.h"
 #include "plugin.h"
@@ -48,12 +48,17 @@
   char name[DATA_MAX_NAME_LEN];
 
   char *host;
   int port;
   int timeout;
 
+  /* Authentication information */
+  char *db;
+  char *user;
+  char *passwd;
+
   _Bool store_rates;
 
   mongo conn[1];
   pthread_mutex_t lock;
 };
 typedef struct wm_node_s wm_node_t;
@@ -180,12 +185,29 @@
           (node->port != 0) ? node->port : MONGO_DEFAULT_PORT);
       mongo_destroy (node->conn);
       pthread_mutex_unlock (&node->lock);
       return (-1);
     }
 
+    if ((node->db != NULL) && (node->user != NULL) && (node->passwd != NULL))
+    {
+      status = mongo_cmd_authenticate (node->conn,
+          node->db, node->user, node->passwd);
+      if (status != MONGO_OK)
+      {
+        ERROR ("write_mongodb plugin: Authenticating to [%s]%i for database "
+            "\"%s\" as user \"%s\" failed.",
+          (node->host != NULL) ? node->host : "localhost",
+          (node->port != 0) ? node->port : MONGO_DEFAULT_PORT,
+          node->db, node->user);
+        mongo_destroy (node->conn);
+        pthread_mutex_unlock (&node->lock);
+        return (-1);
+      }
+    }
+
     if (node->timeout > 0) {
       status = mongo_set_op_timeout (node->conn, node->timeout);
       if (status != MONGO_OK) {
         WARNING ("write_mongodb plugin: mongo_set_op_timeout(%i) failed: %s",
             node->timeout, node->conn->errstr);
       }
@@ -200,19 +222,20 @@
     /* https://github.com/mongodb/mongo-c-driver/blob/master/HISTORY.md */
     status = mongo_insert (node->conn, collection_name, bson_record, NULL);
   #else
     status = mongo_insert (node->conn, collection_name, bson_record);
   #endif
 
-  if(status != MONGO_OK)
+  if (status != MONGO_OK)
   {
     ERROR ( "write_mongodb plugin: error inserting record: %d", node->conn->err);
     if (node->conn->err != MONGO_BSON_INVALID)
       ERROR ("write_mongodb plugin: %s", node->conn->errstr);
-    else if (bson_record->err)
-      ERROR ("write_mongodb plugin: %s", bson_record->errstr);
+    else
+      ERROR ("write_mongodb plugin: Invalid BSON structure, error = %#x",
+          (unsigned int) bson_record->err);
 
     /* Disconnect except on data errors. */
     if ((node->conn->err != MONGO_BSON_INVALID)
         && (node->conn->err != MONGO_BSON_NOT_FINISHED))
       mongo_destroy (node->conn);
   }
@@ -278,20 +301,40 @@
       }
     }
     else if (strcasecmp ("Timeout", child->key) == 0)
       status = cf_util_get_int (child, &node->timeout);
     else if (strcasecmp ("StoreRates", child->key) == 0)
       status = cf_util_get_boolean (child, &node->store_rates);
+    else if (strcasecmp ("Database", child->key) == 0)
+      status = cf_util_get_string (child, &node->db);
+    else if (strcasecmp ("User", child->key) == 0)
+      status = cf_util_get_string (child, &node->user);
+    else if (strcasecmp ("Password", child->key) == 0)
+      status = cf_util_get_string (child, &node->passwd);
     else
       WARNING ("write_mongodb plugin: Ignoring unknown config option \"%s\".",
           child->key);
 
     if (status != 0)
       break;
   } /* for (i = 0; i < ci->children_num; i++) */
 
+  if ((node->db != NULL) || (node->user != NULL) || (node->passwd != NULL))
+  {
+    if ((node->db == NULL) || (node->user == NULL) || (node->passwd == NULL))
+    {
+      WARNING ("write_mongodb plugin: Authentication requires the "
+          "\"Database\", \"User\" and \"Password\" options to be specified, "
+          "but at last one of them is missing. Authentication will NOT be "
+          "used.");
+      sfree (node->db);
+      sfree (node->user);
+      sfree (node->passwd);
+    }
+  }
+
   if (status == 0)
   {
     char cb_name[DATA_MAX_NAME_LEN];
     user_data_t ud;
 
     ssnprintf (cb_name, sizeof (cb_name), "write_mongodb/%s", node->name);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/src: write_riemann.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/version-gen.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/version-gen.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.2.2/version-gen.sh	2013-04-09 09:13:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.3.0/version-gen.sh	2013-04-10 10:14:25.000000000 +0800
@@ -1,9 +1,9 @@
 #!/usr/bin/env bash
 
-DEFAULT_VERSION="5.2.2.git"
+DEFAULT_VERSION="5.3.0.git"
 
 VERSION="`git describe 2> /dev/null | sed -e 's/^collectd-//'`"
 
 if test -z "$VERSION"; then
 	VERSION="$DEFAULT_VERSION"
 fi
