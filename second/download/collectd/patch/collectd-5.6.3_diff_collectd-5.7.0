diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/aclocal.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/aclocal.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/aclocal.m4	2017-10-06 15:04:16.002135868 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/aclocal.m4	2016-12-12 16:03:44.708224216 +0800
@@ -17,12 +17,9512 @@
 m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,
 [m4_warning([this file was generated for autoconf 2.69.
 You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
 To do so, use the procedure documented by the package, typically 'autoreconf'.])])
 
+# Portability macros for glibc argz.                    -*- Autoconf -*-
+#
+#   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+#   Written by Gary V. Vaughan <gary@gnu.org>
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 5 argz.m4
+
+AC_DEFUN([gl_FUNC_ARGZ],
+[gl_PREREQ_ARGZ
+
+AC_CHECK_HEADERS([argz.h], [], [], [AC_INCLUDES_DEFAULT])
+
+AC_CHECK_TYPES([error_t],
+  [],
+  [AC_DEFINE([error_t], [int],
+   [Define to a type to use for `error_t' if it is not otherwise available.])
+   AC_DEFINE([__error_t_defined], [1], [Define so that glibc/gnulib argp.h
+    does not typedef error_t.])],
+  [#if defined(HAVE_ARGZ_H)
+#  include <argz.h>
+#endif])
+
+ARGZ_H=
+AC_CHECK_FUNCS([argz_add argz_append argz_count argz_create_sep argz_insert \
+	argz_next argz_stringify], [], [ARGZ_H=argz.h; AC_LIBOBJ([argz])])
+
+dnl if have system argz functions, allow forced use of
+dnl libltdl-supplied implementation (and default to do so
+dnl on "known bad" systems). Could use a runtime check, but
+dnl (a) detecting malloc issues is notoriously unreliable
+dnl (b) only known system that declares argz functions,
+dnl     provides them, yet they are broken, is cygwin
+dnl     releases prior to 16-Mar-2007 (1.5.24 and earlier)
+dnl So, it's more straightforward simply to special case
+dnl this for known bad systems.
+AS_IF([test -z "$ARGZ_H"],
+    [AC_CACHE_CHECK(
+        [if argz actually works],
+        [lt_cv_sys_argz_works],
+        [[case $host_os in #(
+	 *cygwin*)
+	   lt_cv_sys_argz_works=no
+	   if test "$cross_compiling" != no; then
+	     lt_cv_sys_argz_works="guessing no"
+	   else
+	     lt_sed_extract_leading_digits='s/^\([0-9\.]*\).*/\1/'
+	     save_IFS=$IFS
+	     IFS=-.
+	     set x `uname -r | sed -e "$lt_sed_extract_leading_digits"`
+	     IFS=$save_IFS
+	     lt_os_major=${2-0}
+	     lt_os_minor=${3-0}
+	     lt_os_micro=${4-0}
+	     if test "$lt_os_major" -gt 1 \
+		|| { test "$lt_os_major" -eq 1 \
+		  && { test "$lt_os_minor" -gt 5 \
+		    || { test "$lt_os_minor" -eq 5 \
+		      && test "$lt_os_micro" -gt 24; }; }; }; then
+	       lt_cv_sys_argz_works=yes
+	     fi
+	   fi
+	   ;; #(
+	 *) lt_cv_sys_argz_works=yes ;;
+	 esac]])
+     AS_IF([test "$lt_cv_sys_argz_works" = yes],
+        [AC_DEFINE([HAVE_WORKING_ARGZ], 1,
+                   [This value is set to 1 to indicate that the system argz facility works])],
+        [ARGZ_H=argz.h
+        AC_LIBOBJ([argz])])])
+
+AC_SUBST([ARGZ_H])
+])
+
+# Prerequisites of lib/argz.c.
+AC_DEFUN([gl_PREREQ_ARGZ], [:])
+
+# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+#                 Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+m4_define([_LT_COPYING], [dnl
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+#                 Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+])
+
+# serial 57 LT_INIT
+
+
+# LT_PREREQ(VERSION)
+# ------------------
+# Complain and exit if this libtool version is less that VERSION.
+m4_defun([LT_PREREQ],
+[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,
+       [m4_default([$3],
+		   [m4_fatal([Libtool version $1 or higher is required],
+		             63)])],
+       [$2])])
+
+
+# _LT_CHECK_BUILDDIR
+# ------------------
+# Complain if the absolute build directory name contains unusual characters
+m4_defun([_LT_CHECK_BUILDDIR],
+[case `pwd` in
+  *\ * | *\	*)
+    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;
+esac
+])
+
+
+# LT_INIT([OPTIONS])
+# ------------------
+AC_DEFUN([LT_INIT],
+[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT
+AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl
+AC_BEFORE([$0], [LT_LANG])dnl
+AC_BEFORE([$0], [LT_OUTPUT])dnl
+AC_BEFORE([$0], [LTDL_INIT])dnl
+m4_require([_LT_CHECK_BUILDDIR])dnl
+
+dnl Autoconf doesn't catch unexpanded LT_ macros by default:
+m4_pattern_forbid([^_?LT_[A-Z_]+$])dnl
+m4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl
+dnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4
+dnl unless we require an AC_DEFUNed macro:
+AC_REQUIRE([LTOPTIONS_VERSION])dnl
+AC_REQUIRE([LTSUGAR_VERSION])dnl
+AC_REQUIRE([LTVERSION_VERSION])dnl
+AC_REQUIRE([LTOBSOLETE_VERSION])dnl
+m4_require([_LT_PROG_LTMAIN])dnl
+
+_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])
+
+dnl Parse OPTIONS
+_LT_SET_OPTIONS([$0], [$1])
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+AC_SUBST(LIBTOOL)dnl
+
+_LT_SETUP
+
+# Only expand once:
+m4_define([LT_INIT])
+])# LT_INIT
+
+# Old names:
+AU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])
+AU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PROG_LIBTOOL], [])
+dnl AC_DEFUN([AM_PROG_LIBTOOL], [])
+
+
+# _LT_CC_BASENAME(CC)
+# -------------------
+# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
+m4_defun([_LT_CC_BASENAME],
+[for cc_temp in $1""; do
+  case $cc_temp in
+    compile | *[[\\/]]compile | ccache | *[[\\/]]ccache ) ;;
+    distcc | *[[\\/]]distcc | purify | *[[\\/]]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+])
+
+
+# _LT_FILEUTILS_DEFAULTS
+# ----------------------
+# It is okay to use these file commands and assume they have been set
+# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.
+m4_defun([_LT_FILEUTILS_DEFAULTS],
+[: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+])# _LT_FILEUTILS_DEFAULTS
+
+
+# _LT_SETUP
+# ---------
+m4_defun([_LT_SETUP],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+AC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl
+AC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl
+
+_LT_DECL([], [PATH_SEPARATOR], [1], [The PATH separator for the build system])dnl
+dnl
+_LT_DECL([], [host_alias], [0], [The host system])dnl
+_LT_DECL([], [host], [0])dnl
+_LT_DECL([], [host_os], [0])dnl
+dnl
+_LT_DECL([], [build_alias], [0], [The build system])dnl
+_LT_DECL([], [build], [0])dnl
+_LT_DECL([], [build_os], [0])dnl
+dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+dnl
+AC_REQUIRE([AC_PROG_LN_S])dnl
+test -z "$LN_S" && LN_S="ln -s"
+_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl
+dnl
+AC_REQUIRE([LT_CMD_MAX_LEN])dnl
+_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally "o")])dnl
+_LT_DECL([], [exeext], [0], [Executable file suffix (normally "")])dnl
+dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_CHECK_SHELL_FEATURES])dnl
+m4_require([_LT_PATH_CONVERSION_FUNCTIONS])dnl
+m4_require([_LT_CMD_RELOAD])dnl
+m4_require([_LT_CHECK_MAGIC_METHOD])dnl
+m4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl
+m4_require([_LT_CMD_OLD_ARCHIVE])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+m4_require([_LT_WITH_SYSROOT])dnl
+
+_LT_CONFIG_LIBTOOL_INIT([
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+])
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+_LT_CHECK_OBJDIR
+
+m4_require([_LT_TAG_COMPILER])dnl
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+_LT_CC_BASENAME([$compiler])
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    _LT_PATH_MAGIC
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+LT_SUPPORTED_TAG([CC])
+_LT_LANG_C_CONFIG
+_LT_LANG_DEFAULT_CONFIG
+_LT_CONFIG_COMMANDS
+])# _LT_SETUP
+
+
+# _LT_PREPARE_SED_QUOTE_VARS
+# --------------------------
+# Define a few sed substitution that help us do robust quoting.
+m4_defun([_LT_PREPARE_SED_QUOTE_VARS],
+[# Backslashify metacharacters that are still active within
+# double-quoted strings.
+sed_quote_subst='s/\([["`$\\]]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\([["`\\]]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+])
+
+# _LT_PROG_LTMAIN
+# ---------------
+# Note that this code is called both from `configure', and `config.status'
+# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,
+# `config.status' has no value for ac_aux_dir unless we are using Automake,
+# so we pass a copy along to make sure it has a sensible value anyway.
+m4_defun([_LT_PROG_LTMAIN],
+[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl
+_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])
+ltmain="$ac_aux_dir/ltmain.sh"
+])# _LT_PROG_LTMAIN
+
+
+
+# So that we can recreate a full libtool script including additional
+# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS
+# in macros and then make a single call at the end using the `libtool'
+# label.
+
+
+# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])
+# ----------------------------------------
+# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL_INIT],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_INIT])
+
+
+# _LT_CONFIG_LIBTOOL([COMMANDS])
+# ------------------------------
+# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])
+
+
+# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])
+# -----------------------------------------------------
+m4_defun([_LT_CONFIG_SAVE_COMMANDS],
+[_LT_CONFIG_LIBTOOL([$1])
+_LT_CONFIG_LIBTOOL_INIT([$2])
+])
+
+
+# _LT_FORMAT_COMMENT([COMMENT])
+# -----------------------------
+# Add leading comment marks to the start of each line, and a trailing
+# full-stop to the whole comment if one is not present already.
+m4_define([_LT_FORMAT_COMMENT],
+[m4_ifval([$1], [
+m4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],
+              [['`$\]], [\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])
+)])
+
+
+
+
+
+# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])
+# -------------------------------------------------------------------
+# CONFIGNAME is the name given to the value in the libtool script.
+# VARNAME is the (base) name used in the configure script.
+# VALUE may be 0, 1 or 2 for a computed quote escaped value based on
+# VARNAME.  Any other value will be used directly.
+m4_define([_LT_DECL],
+[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],
+    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],
+	[m4_ifval([$1], [$1], [$2])])
+    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])
+    m4_ifval([$4],
+	[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])
+    lt_dict_add_subkey([lt_decl_dict], [$2],
+	[tagged?], [m4_ifval([$5], [yes], [no])])])
+])
+
+
+# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])
+# --------------------------------------------------------
+m4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])
+
+
+# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_tag_varnames],
+[_lt_decl_filter([tagged?], [yes], $@)])
+
+
+# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])
+# ---------------------------------------------------------
+m4_define([_lt_decl_filter],
+[m4_case([$#],
+  [0], [m4_fatal([$0: too few arguments: $#])],
+  [1], [m4_fatal([$0: too few arguments: $#: $1])],
+  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],
+  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],
+  [lt_dict_filter([lt_decl_dict], $@)])[]dnl
+])
+
+
+# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])
+# --------------------------------------------------
+m4_define([lt_decl_quote_varnames],
+[_lt_decl_filter([value], [1], $@)])
+
+
+# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_dquote_varnames],
+[_lt_decl_filter([value], [2], $@)])
+
+
+# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_varnames_tagged],
+[m4_assert([$# <= 2])dnl
+_$0(m4_quote(m4_default([$1], [[, ]])),
+    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),
+    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])
+m4_define([_lt_decl_varnames_tagged],
+[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])
+
+
+# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_all_varnames],
+[_$0(m4_quote(m4_default([$1], [[, ]])),
+     m4_if([$2], [],
+	   m4_quote(lt_decl_varnames),
+	m4_quote(m4_shift($@))))[]dnl
+])
+m4_define([_lt_decl_all_varnames],
+[lt_join($@, lt_decl_varnames_tagged([$1],
+			lt_decl_tag_varnames([[, ]], m4_shift($@))))dnl
+])
+
+
+# _LT_CONFIG_STATUS_DECLARE([VARNAME])
+# ------------------------------------
+# Quote a variable value, and forward it to `config.status' so that its
+# declaration there will have the same value as in `configure'.  VARNAME
+# must have a single quote delimited value for this to work.
+m4_define([_LT_CONFIG_STATUS_DECLARE],
+[$1='`$ECHO "$][$1" | $SED "$delay_single_quote_subst"`'])
+
+
+# _LT_CONFIG_STATUS_DECLARATIONS
+# ------------------------------
+# We delimit libtool config variables with single quotes, so when
+# we write them to config.status, we have to be sure to quote all
+# embedded single quotes properly.  In configure, this macro expands
+# each variable declared with _LT_DECL (and _LT_TAGDECL) into:
+#
+#    <var>='`$ECHO "$<var>" | $SED "$delay_single_quote_subst"`'
+m4_defun([_LT_CONFIG_STATUS_DECLARATIONS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),
+    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAGS
+# ----------------
+# Output comment and list of tags supported by the script
+m4_defun([_LT_LIBTOOL_TAGS],
+[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl
+available_tags="_LT_TAGS"dnl
+])
+
+
+# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])
+# -----------------------------------
+# Extract the dictionary values for VARNAME (optionally with TAG) and
+# expand to a commented shell variable setting:
+#
+#    # Some comment about what VAR is for.
+#    visible_name=$lt_internal_name
+m4_define([_LT_LIBTOOL_DECLARE],
+[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],
+					   [description])))[]dnl
+m4_pushdef([_libtool_name],
+    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl
+m4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),
+    [0], [_libtool_name=[$]$1],
+    [1], [_libtool_name=$lt_[]$1],
+    [2], [_libtool_name=$lt_[]$1],
+    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl
+m4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl
+])
+
+
+# _LT_LIBTOOL_CONFIG_VARS
+# -----------------------
+# Produce commented declarations of non-tagged libtool config variables
+# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'
+# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG
+# section) are produced by _LT_LIBTOOL_TAG_VARS.
+m4_defun([_LT_LIBTOOL_CONFIG_VARS],
+[m4_foreach([_lt_var],
+    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAG_VARS(TAG)
+# -------------------------
+m4_define([_LT_LIBTOOL_TAG_VARS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])
+
+
+# _LT_TAGVAR(VARNAME, [TAGNAME])
+# ------------------------------
+m4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])
+
+
+# _LT_CONFIG_COMMANDS
+# -------------------
+# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of
+# variables for single and double quote escaping we saved from calls
+# to _LT_DECL, we can put quote escaped variables declarations
+# into `config.status', and then the shell code to quote escape them in
+# for loops in `config.status'.  Finally, any additional code accumulated
+# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.
+m4_defun([_LT_CONFIG_COMMANDS],
+[AC_PROVIDE_IFELSE([LT_OUTPUT],
+	dnl If the libtool generation code has been placed in $CONFIG_LT,
+	dnl instead of duplicating it all over again into config.status,
+	dnl then we will have config.status run $CONFIG_LT later, so it
+	dnl needs to know what name is stored there:
+        [AC_CONFIG_COMMANDS([libtool],
+            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],
+    dnl If the libtool generation code is destined for config.status,
+    dnl expand the accumulated commands and init code now:
+    [AC_CONFIG_COMMANDS([libtool],
+        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])
+])#_LT_CONFIG_COMMANDS
+
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],
+[
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+_LT_CONFIG_STATUS_DECLARATIONS
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# A function that is used when there is no print builtin or printf.
+func_fallback_echo ()
+{
+  eval 'cat <<_LTECHO_EOF
+\$[]1
+_LTECHO_EOF'
+}
+
+# Quote evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_quote_varnames); do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_dquote_varnames); do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+_LT_OUTPUT_LIBTOOL_INIT
+])
+
+# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])
+# ------------------------------------
+# Generate a child script FILE with all initialization necessary to
+# reuse the environment learned by the parent script, and make the
+# file executable.  If COMMENT is supplied, it is inserted after the
+# `#!' sequence but before initialization text begins.  After this
+# macro, additional text can be appended to FILE to form the body of
+# the child script.  The macro ends with non-zero status if the
+# file could not be fully written (such as if the disk is full).
+m4_ifdef([AS_INIT_GENERATED],
+[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],
+[m4_defun([_LT_GENERATED_FILE_INIT],
+[m4_require([AS_PREPARE])]dnl
+[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl
+[lt_write_fail=0
+cat >$1 <<_ASEOF || lt_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+$2
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$1 <<\_ASEOF || lt_write_fail=1
+AS_SHELL_SANITIZE
+_AS_PREPARE
+exec AS_MESSAGE_FD>&1
+_ASEOF
+test $lt_write_fail = 0 && chmod +x $1[]dnl
+m4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT
+
+# LT_OUTPUT
+# ---------
+# This macro allows early generation of the libtool script (before
+# AC_OUTPUT is called), incase it is used in configure for compilation
+# tests.
+AC_DEFUN([LT_OUTPUT],
+[: ${CONFIG_LT=./config.lt}
+AC_MSG_NOTICE([creating $CONFIG_LT])
+_LT_GENERATED_FILE_INIT(["$CONFIG_LT"],
+[# Run this file to recreate a libtool stub with the current configuration.])
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+lt_cl_silent=false
+exec AS_MESSAGE_LOG_FD>>config.log
+{
+  echo
+  AS_BOX([Running $as_me.])
+} >&AS_MESSAGE_LOG_FD
+
+lt_cl_help="\
+\`$as_me' creates a local libtool stub from the current configuration,
+for use in further configure time tests before the real libtool is
+generated.
+
+Usage: $[0] [[OPTIONS]]
+
+  -h, --help      print this help, then exit
+  -V, --version   print version number, then exit
+  -q, --quiet     do not print progress messages
+  -d, --debug     don't remove temporary files
+
+Report bugs to <bug-libtool@gnu.org>."
+
+lt_cl_version="\
+m4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl
+m4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])
+configured by $[0], generated by m4_PACKAGE_STRING.
+
+Copyright (C) 2011 Free Software Foundation, Inc.
+This config.lt script is free software; the Free Software Foundation
+gives unlimited permision to copy, distribute and modify it."
+
+while test $[#] != 0
+do
+  case $[1] in
+    --version | --v* | -V )
+      echo "$lt_cl_version"; exit 0 ;;
+    --help | --h* | -h )
+      echo "$lt_cl_help"; exit 0 ;;
+    --debug | --d* | -d )
+      debug=: ;;
+    --quiet | --q* | --silent | --s* | -q )
+      lt_cl_silent=: ;;
+
+    -*) AC_MSG_ERROR([unrecognized option: $[1]
+Try \`$[0] --help' for more information.]) ;;
+
+    *) AC_MSG_ERROR([unrecognized argument: $[1]
+Try \`$[0] --help' for more information.]) ;;
+  esac
+  shift
+done
+
+if $lt_cl_silent; then
+  exec AS_MESSAGE_FD>/dev/null
+fi
+_LTEOF
+
+cat >>"$CONFIG_LT" <<_LTEOF
+_LT_OUTPUT_LIBTOOL_COMMANDS_INIT
+_LTEOF
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+AC_MSG_NOTICE([creating $ofile])
+_LT_OUTPUT_LIBTOOL_COMMANDS
+AS_EXIT(0)
+_LTEOF
+chmod +x "$CONFIG_LT"
+
+# configure is writing to config.log, but config.lt does its own redirection,
+# appending to config.log, which fails on DOS, as config.log is still kept
+# open by configure.  Here we exec the FD to /dev/null, effectively closing
+# config.log, so it can be properly (re)opened and appended to by config.lt.
+lt_cl_success=:
+test "$silent" = yes &&
+  lt_config_lt_args="$lt_config_lt_args --quiet"
+exec AS_MESSAGE_LOG_FD>/dev/null
+$SHELL "$CONFIG_LT" $lt_config_lt_args || lt_cl_success=false
+exec AS_MESSAGE_LOG_FD>>config.log
+$lt_cl_success || AS_EXIT(1)
+])# LT_OUTPUT
+
+
+# _LT_CONFIG(TAG)
+# ---------------
+# If TAG is the built-in tag, create an initial libtool script with a
+# default configuration from the untagged config vars.  Otherwise add code
+# to config.status for appending the configuration named by TAG from the
+# matching tagged config vars.
+m4_defun([_LT_CONFIG],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_CONFIG_SAVE_COMMANDS([
+  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl
+  m4_if(_LT_TAG, [C], [
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+_LT_COPYING
+_LT_LIBTOOL_TAGS
+
+# ### BEGIN LIBTOOL CONFIG
+_LT_LIBTOOL_CONFIG_VARS
+_LT_LIBTOOL_TAG_VARS
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+  _LT_PROG_LTMAIN
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '$q' "$ltmain" >> "$cfgfile" \
+     || (rm -f "$cfgfile"; exit 1)
+
+  _LT_PROG_REPLACE_SHELLFNS
+
+   mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+],
+[cat <<_LT_EOF >> "$ofile"
+
+dnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded
+dnl in a comment (ie after a #).
+# ### BEGIN LIBTOOL TAG CONFIG: $1
+_LT_LIBTOOL_TAG_VARS(_LT_TAG)
+# ### END LIBTOOL TAG CONFIG: $1
+_LT_EOF
+])dnl /m4_if
+],
+[m4_if([$1], [], [
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'], [])
+])dnl /_LT_CONFIG_SAVE_COMMANDS
+])# _LT_CONFIG
+
+
+# LT_SUPPORTED_TAG(TAG)
+# ---------------------
+# Trace this macro to discover what tags are supported by the libtool
+# --tag option, using:
+#    autoconf --trace 'LT_SUPPORTED_TAG:$1'
+AC_DEFUN([LT_SUPPORTED_TAG], [])
+
+
+# C support is built-in for now
+m4_define([_LT_LANG_C_enabled], [])
+m4_define([_LT_TAGS], [])
+
+
+# LT_LANG(LANG)
+# -------------
+# Enable libtool support for the given language if not already enabled.
+AC_DEFUN([LT_LANG],
+[AC_BEFORE([$0], [LT_OUTPUT])dnl
+m4_case([$1],
+  [C],			[_LT_LANG(C)],
+  [C++],		[_LT_LANG(CXX)],
+  [Go],			[_LT_LANG(GO)],
+  [Java],		[_LT_LANG(GCJ)],
+  [Fortran 77],		[_LT_LANG(F77)],
+  [Fortran],		[_LT_LANG(FC)],
+  [Windows Resource],	[_LT_LANG(RC)],
+  [m4_ifdef([_LT_LANG_]$1[_CONFIG],
+    [_LT_LANG($1)],
+    [m4_fatal([$0: unsupported language: "$1"])])])dnl
+])# LT_LANG
+
+
+# _LT_LANG(LANGNAME)
+# ------------------
+m4_defun([_LT_LANG],
+[m4_ifdef([_LT_LANG_]$1[_enabled], [],
+  [LT_SUPPORTED_TAG([$1])dnl
+  m4_append([_LT_TAGS], [$1 ])dnl
+  m4_define([_LT_LANG_]$1[_enabled], [])dnl
+  _LT_LANG_$1_CONFIG($1)])dnl
+])# _LT_LANG
+
+
+m4_ifndef([AC_PROG_GO], [
+# NOTE: This macro has been submitted for inclusion into   #
+#  GNU Autoconf as AC_PROG_GO.  When it is available in    #
+#  a released version of Autoconf we should remove this    #
+#  macro and use it instead.                               #
+m4_defun([AC_PROG_GO],
+[AC_LANG_PUSH(Go)dnl
+AC_ARG_VAR([GOC],     [Go compiler command])dnl
+AC_ARG_VAR([GOFLAGS], [Go compiler flags])dnl
+_AC_ARG_VAR_LDFLAGS()dnl
+AC_CHECK_TOOL(GOC, gccgo)
+if test -z "$GOC"; then
+  if test -n "$ac_tool_prefix"; then
+    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])
+  fi
+fi
+if test -z "$GOC"; then
+  AC_CHECK_PROG(GOC, gccgo, gccgo, false)
+fi
+])#m4_defun
+])#m4_ifndef
+
+
+# _LT_LANG_DEFAULT_CONFIG
+# -----------------------
+m4_defun([_LT_LANG_DEFAULT_CONFIG],
+[AC_PROVIDE_IFELSE([AC_PROG_CXX],
+  [LT_LANG(CXX)],
+  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_F77],
+  [LT_LANG(F77)],
+  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_FC],
+  [LT_LANG(FC)],
+  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])
+
+dnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal
+dnl pulling things in needlessly.
+AC_PROVIDE_IFELSE([AC_PROG_GCJ],
+  [LT_LANG(GCJ)],
+  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],
+    [LT_LANG(GCJ)],
+    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],
+      [LT_LANG(GCJ)],
+      [m4_ifdef([AC_PROG_GCJ],
+	[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([A][M_PROG_GCJ],
+	[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([LT_PROG_GCJ],
+	[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])
+
+AC_PROVIDE_IFELSE([AC_PROG_GO],
+  [LT_LANG(GO)],
+  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])
+
+AC_PROVIDE_IFELSE([LT_PROG_RC],
+  [LT_LANG(RC)],
+  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])
+])# _LT_LANG_DEFAULT_CONFIG
+
+# Obsolete macros:
+AU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])
+AU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])
+AU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])
+AU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])
+AU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_CXX], [])
+dnl AC_DEFUN([AC_LIBTOOL_F77], [])
+dnl AC_DEFUN([AC_LIBTOOL_FC], [])
+dnl AC_DEFUN([AC_LIBTOOL_GCJ], [])
+dnl AC_DEFUN([AC_LIBTOOL_RC], [])
+
+
+# _LT_TAG_COMPILER
+# ----------------
+m4_defun([_LT_TAG_COMPILER],
+[AC_REQUIRE([AC_PROG_CC])dnl
+
+_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl
+_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl
+_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl
+_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+])# _LT_TAG_COMPILER
+
+
+# _LT_COMPILER_BOILERPLATE
+# ------------------------
+# Check for compiler boilerplate output or warnings with
+# the simple compiler test code.
+m4_defun([_LT_COMPILER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+])# _LT_COMPILER_BOILERPLATE
+
+
+# _LT_LINKER_BOILERPLATE
+# ----------------------
+# Check for linker boilerplate output or warnings with
+# the simple link test code.
+m4_defun([_LT_LINKER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+])# _LT_LINKER_BOILERPLATE
+
+# _LT_REQUIRED_DARWIN_CHECKS
+# -------------------------
+m4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[
+  case $host_os in
+    rhapsody* | darwin*)
+    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])
+    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])
+    AC_CHECK_TOOL([LIPO], [lipo], [:])
+    AC_CHECK_TOOL([OTOOL], [otool], [:])
+    AC_CHECK_TOOL([OTOOL64], [otool64], [:])
+    _LT_DECL([], [DSYMUTIL], [1],
+      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])
+    _LT_DECL([], [NMEDIT], [1],
+      [Tool to change global to local symbols on Mac OS X])
+    _LT_DECL([], [LIPO], [1],
+      [Tool to manipulate fat objects and archives on Mac OS X])
+    _LT_DECL([], [OTOOL], [1],
+      [ldd/readelf like tool for Mach-O binaries on Mac OS X])
+    _LT_DECL([], [OTOOL64], [1],
+      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])
+
+    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],
+      [lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&AS_MESSAGE_LOG_FD
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	# If there is a non-empty error log, and "single_module"
+	# appears in it, assume the flag caused a linker warning
+        if test -s conftest.err && $GREP single_module conftest.err; then
+	  cat conftest.err >&AS_MESSAGE_LOG_FD
+	# Otherwise, if the output was created with a 0 exit code from
+	# the compiler, it worked.
+	elif test -f libconftest.dylib && test $_lt_result -eq 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&AS_MESSAGE_LOG_FD
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi])
+
+    AC_CACHE_CHECK([for -exported_symbols_list linker flag],
+      [lt_cv_ld_exported_symbols_list],
+      [lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+	[lt_cv_ld_exported_symbols_list=yes],
+	[lt_cv_ld_exported_symbols_list=no])
+	LDFLAGS="$save_LDFLAGS"
+    ])
+
+    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],
+      [lt_cv_ld_force_load=no
+      cat > conftest.c << _LT_EOF
+int forced_loaded() { return 2;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&AS_MESSAGE_LOG_FD
+      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD
+      echo "$AR cru libconftest.a conftest.o" >&AS_MESSAGE_LOG_FD
+      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD
+      echo "$RANLIB libconftest.a" >&AS_MESSAGE_LOG_FD
+      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD
+      cat > conftest.c << _LT_EOF
+int main() { return 0;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&AS_MESSAGE_LOG_FD
+      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
+      _lt_result=$?
+      if test -s conftest.err && $GREP force_load conftest.err; then
+	cat conftest.err >&AS_MESSAGE_LOG_FD
+      elif test -f conftest && test $_lt_result -eq 0 && $GREP forced_load conftest >/dev/null 2>&1 ; then
+	lt_cv_ld_force_load=yes
+      else
+	cat conftest.err >&AS_MESSAGE_LOG_FD
+      fi
+        rm -f conftest.err libconftest.a conftest conftest.c
+        rm -rf conftest.dSYM
+    ])
+    case $host_os in
+    rhapsody* | darwin1.[[012]])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[[012]]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+])
+
+
+# _LT_DARWIN_LINKER_FEATURES([TAG])
+# ---------------------------------
+# Checks for linker and compiler features on darwin
+m4_defun([_LT_DARWIN_LINKER_FEATURES],
+[
+  m4_require([_LT_REQUIRED_DARWIN_CHECKS])
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_automatic, $1)=yes
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  if test "$lt_cv_ld_force_load" = "yes"; then
+    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+    m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],
+                  [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])
+  else
+    _LT_TAGVAR(whole_archive_flag_spec, $1)=''
+  fi
+  _LT_TAGVAR(link_all_deplibs, $1)=yes
+  _LT_TAGVAR(allow_undefined_flag, $1)="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=func_echo_all
+    _LT_TAGVAR(archive_cmds, $1)="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    _LT_TAGVAR(module_cmds, $1)="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    _LT_TAGVAR(module_expsym_cmds, $1)="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+    m4_if([$1], [CXX],
+[   if test "$lt_cv_apple_cc_single_mod" != "yes"; then
+      _LT_TAGVAR(archive_cmds, $1)="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
+      _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+    fi
+],[])
+  else
+  _LT_TAGVAR(ld_shlibs, $1)=no
+  fi
+])
+
+# _LT_SYS_MODULE_PATH_AIX([TAGNAME])
+# ----------------------------------
+# Links a minimal program and checks the executable
+# for the system default hardcoded library path. In most cases,
+# this is /usr/lib:/lib, but when the MPI compilers are used
+# the location of the communication and MPI libs are included too.
+# If we don't find anything, use the default library path according
+# to the aix ld manual.
+# Store the results from the different compilers for each TAGNAME.
+# Allow to override them for all tags through lt_cv_aix_libpath.
+m4_defun([_LT_SYS_MODULE_PATH_AIX],
+[m4_require([_LT_DECL_SED])dnl
+if test "${lt_cv_aix_libpath+set}" = set; then
+  aix_libpath=$lt_cv_aix_libpath
+else
+  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],
+  [AC_LINK_IFELSE([AC_LANG_PROGRAM],[
+  lt_aix_libpath_sed='[
+      /Import File Strings/,/^$/ {
+	  /^0/ {
+	      s/^0  *\([^ ]*\) *$/\1/
+	      p
+	  }
+      }]'
+  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+  # Check for a 64-bit object if we didn't find anything.
+  if test -z "$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])"; then
+    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+  fi],[])
+  if test -z "$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])"; then
+    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])="/usr/lib:/lib"
+  fi
+  ])
+  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])
+fi
+])# _LT_SYS_MODULE_PATH_AIX
+
+
+# _LT_SHELL_INIT(ARG)
+# -------------------
+m4_define([_LT_SHELL_INIT],
+[m4_divert_text([M4SH-INIT], [$1
+])])# _LT_SHELL_INIT
+
+
+
+# _LT_PROG_ECHO_BACKSLASH
+# -----------------------
+# Find how we can fake an echo command that does not interpret backslash.
+# In particular, with Autoconf 2.60 or later we add some code to the start
+# of the generated configure script which will find a shell with a builtin
+# printf (which we can use as an echo command).
+m4_defun([_LT_PROG_ECHO_BACKSLASH],
+[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+
+AC_MSG_CHECKING([how to print strings])
+# Test print first, because it will be a builtin if present.
+if test "X`( print -r -- -n ) 2>/dev/null`" = X-n && \
+   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='print -r --'
+elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='printf %s\n'
+else
+  # Use this function as a fallback that always works.
+  func_fallback_echo ()
+  {
+    eval 'cat <<_LTECHO_EOF
+$[]1
+_LTECHO_EOF'
+  }
+  ECHO='func_fallback_echo'
+fi
+
+# func_echo_all arg...
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO "$*" 
+}
+
+case "$ECHO" in
+  printf*) AC_MSG_RESULT([printf]) ;;
+  print*) AC_MSG_RESULT([print -r]) ;;
+  *) AC_MSG_RESULT([cat]) ;;
+esac
+
+m4_ifdef([_AS_DETECT_SUGGESTED],
+[_AS_DETECT_SUGGESTED([
+  test -n "${ZSH_VERSION+set}${BASH_VERSION+set}" || (
+    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+    PATH=/empty FPATH=/empty; export PATH FPATH
+    test "X`printf %s $ECHO`" = "X$ECHO" \
+      || test "X`print -r -- $ECHO`" = "X$ECHO" )])])
+
+_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])
+_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])
+])# _LT_PROG_ECHO_BACKSLASH
+
+
+# _LT_WITH_SYSROOT
+# ----------------
+AC_DEFUN([_LT_WITH_SYSROOT],
+[AC_MSG_CHECKING([for sysroot])
+AC_ARG_WITH([sysroot],
+[  --with-sysroot[=DIR] Search for dependent libraries within DIR
+                        (or the compiler's sysroot if not specified).],
+[], [with_sysroot=no])
+
+dnl lt_sysroot will always be passed unquoted.  We quote it here
+dnl in case the user passed a directory name.
+lt_sysroot=
+case ${with_sysroot} in #(
+ yes)
+   if test "$GCC" = yes; then
+     lt_sysroot=`$CC --print-sysroot 2>/dev/null`
+   fi
+   ;; #(
+ /*)
+   lt_sysroot=`echo "$with_sysroot" | sed -e "$sed_quote_subst"`
+   ;; #(
+ no|'')
+   ;; #(
+ *)
+   AC_MSG_RESULT([${with_sysroot}])
+   AC_MSG_ERROR([The sysroot must be an absolute path.])
+   ;;
+esac
+
+ AC_MSG_RESULT([${lt_sysroot:-no}])
+_LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl
+[dependent libraries, and in which our libraries should be installed.])])
+
+# _LT_ENABLE_LOCK
+# ---------------
+m4_defun([_LT_ENABLE_LOCK],
+[AC_ARG_ENABLE([libtool-lock],
+  [AS_HELP_STRING([--disable-libtool-lock],
+    [avoid locking (might break parallel builds)])])
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '[#]line '$LINENO' "configure"' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    case `/usr/bin/file conftest.o` in
+	      *x86-64*)
+		LD="${LD-ld} -m elf32_x86_64"
+		;;
+	      *)
+		LD="${LD-ld} -m elf_i386"
+		;;
+	    esac
+	    ;;
+	  powerpc64le-*)
+	    LD="${LD-ld} -m elf32lppclinux"
+	    ;;
+	  powerpc64-*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  powerpcle-*)
+	    LD="${LD-ld} -m elf64lppc"
+	    ;;
+	  powerpc-*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,
+    [AC_LANG_PUSH(C)
+     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])
+     AC_LANG_POP])
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*)
+        case $host in
+        i?86-*-solaris*)
+          LD="${LD-ld} -m elf_x86_64"
+          ;;
+        sparc*-*-solaris*)
+          LD="${LD-ld} -m elf64_sparc"
+          ;;
+        esac
+        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.
+        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then
+          LD="${LD-ld}_sol2"
+        fi
+        ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+])# _LT_ENABLE_LOCK
+
+
+# _LT_PROG_AR
+# -----------
+m4_defun([_LT_PROG_AR],
+[AC_CHECK_TOOLS(AR, [ar], false)
+: ${AR=ar}
+: ${AR_FLAGS=cru}
+_LT_DECL([], [AR], [1], [The archiver])
+_LT_DECL([], [AR_FLAGS], [1], [Flags to create an archive])
+
+AC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],
+  [lt_cv_ar_at_file=no
+   AC_COMPILE_IFELSE([AC_LANG_PROGRAM],
+     [echo conftest.$ac_objext > conftest.lst
+      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'
+      AC_TRY_EVAL([lt_ar_try])
+      if test "$ac_status" -eq 0; then
+	# Ensure the archiver fails upon bogus file names.
+	rm -f conftest.$ac_objext libconftest.a
+	AC_TRY_EVAL([lt_ar_try])
+	if test "$ac_status" -ne 0; then
+          lt_cv_ar_at_file=@
+        fi
+      fi
+      rm -f conftest.* libconftest.a
+     ])
+  ])
+
+if test "x$lt_cv_ar_at_file" = xno; then
+  archiver_list_spec=
+else
+  archiver_list_spec=$lt_cv_ar_at_file
+fi
+_LT_DECL([], [archiver_list_spec], [1],
+  [How to feed a file listing to the archiver])
+])# _LT_PROG_AR
+
+
+# _LT_CMD_OLD_ARCHIVE
+# -------------------
+m4_defun([_LT_CMD_OLD_ARCHIVE],
+[_LT_PROG_AR
+
+AC_CHECK_TOOL(STRIP, strip, :)
+test -z "$STRIP" && STRIP=:
+_LT_DECL([], [STRIP], [1], [A symbol stripping program])
+
+AC_CHECK_TOOL(RANLIB, ranlib, :)
+test -z "$RANLIB" && RANLIB=:
+_LT_DECL([], [RANLIB], [1],
+    [Commands used to install an old-style archive])
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$tool_oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$tool_oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$tool_oldlib"
+fi
+
+case $host_os in
+  darwin*)
+    lock_old_archive_extraction=yes ;;
+  *)
+    lock_old_archive_extraction=no ;;
+esac
+_LT_DECL([], [old_postinstall_cmds], [2])
+_LT_DECL([], [old_postuninstall_cmds], [2])
+_LT_TAGDECL([], [old_archive_cmds], [2],
+    [Commands used to build an old-style archive])
+_LT_DECL([], [lock_old_archive_extraction], [0],
+    [Whether to use a lock for old archive extraction])
+])# _LT_CMD_OLD_ARCHIVE
+
+
+# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#		[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------------------
+# Check whether the given compiler option works
+AC_DEFUN([_LT_COMPILER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$3"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       $2=yes
+     fi
+   fi
+   $RM conftest*
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$5], , :, [$5])
+else
+    m4_if([$6], , :, [$6])
+fi
+])# _LT_COMPILER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])
+
+
+# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#                  [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------
+# Check whether the given linker option works
+AC_DEFUN([_LT_LINKER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $3"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&AS_MESSAGE_LOG_FD
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         $2=yes
+       fi
+     else
+       $2=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$4], , :, [$4])
+else
+    m4_if([$5], , :, [$5])
+fi
+])# _LT_LINKER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])
+
+
+# LT_CMD_MAX_LEN
+#---------------
+AC_DEFUN([LT_CMD_MAX_LEN],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+# find the maximum length of command line arguments
+AC_MSG_CHECKING([the maximum length of command line arguments])
+AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
+  i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  mint*)
+    # On MiNT this can take a long time and run out of memory.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  os2*)
+    # The test takes a long time on OS/2.
+    lt_cv_sys_max_cmd_len=8192
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[	 ]]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len" && \
+	test undefined != "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`env echo "$teststring$teststring" 2>/dev/null` \
+	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+])
+if test -n $lt_cv_sys_max_cmd_len ; then
+  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)
+else
+  AC_MSG_RESULT(none)
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+_LT_DECL([], [max_cmd_len], [0],
+    [What is the maximum length of a command?])
+])# LT_CMD_MAX_LEN
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])
+
+
+# _LT_HEADER_DLFCN
+# ----------------
+m4_defun([_LT_HEADER_DLFCN],
+[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl
+])# _LT_HEADER_DLFCN
+
+
+# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,
+#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)
+# ----------------------------------------------------------------
+m4_defun([_LT_TRY_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "$cross_compiling" = yes; then :
+  [$4]
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+[#line $LINENO "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+int fnord () __attribute__((visibility("default")));
+#endif
+
+int fnord () { return 42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}]
+_LT_EOF
+  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) $1 ;;
+      x$lt_dlneed_uscore) $2 ;;
+      x$lt_dlunknown|x*) $3 ;;
+    esac
+  else :
+    # compilation failed
+    $3
+  fi
+fi
+rm -fr conftest*
+])# _LT_TRY_DLOPEN_SELF
+
+
+# LT_SYS_DLOPEN_SELF
+# ------------------
+AC_DEFUN([LT_SYS_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],[
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ])
+    ;;
+
+  *)
+    AC_CHECK_FUNC([shl_load],
+	  [lt_cv_dlopen="shl_load"],
+      [AC_CHECK_LIB([dld], [shl_load],
+	    [lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"],
+	[AC_CHECK_FUNC([dlopen],
+	      [lt_cv_dlopen="dlopen"],
+	  [AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],
+	    [AC_CHECK_LIB([svld], [dlopen],
+		  [lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"],
+	      [AC_CHECK_LIB([dld], [dld_link],
+		    [lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"])
+	      ])
+	    ])
+	  ])
+	])
+      ])
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    AC_CACHE_CHECK([whether a program can dlopen itself],
+	  lt_cv_dlopen_self, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,
+	    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)
+    ])
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],
+	  lt_cv_dlopen_self_static, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,
+	    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)
+      ])
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+_LT_DECL([dlopen_support], [enable_dlopen], [0],
+	 [Whether dlopen is supported])
+_LT_DECL([dlopen_self], [enable_dlopen_self], [0],
+	 [Whether dlopen of programs is supported])
+_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],
+	 [Whether dlopen of statically linked programs is supported])
+])# LT_SYS_DLOPEN_SELF
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])
+
+
+# _LT_COMPILER_C_O([TAGNAME])
+# ---------------------------
+# Check to see if options -c and -o are simultaneously supported by compiler.
+# This macro does not hard code the compiler like AC_PROG_CC_C_O.
+m4_defun([_LT_COMPILER_C_O],
+[m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+     fi
+   fi
+   chmod u+w . 2>&AS_MESSAGE_LOG_FD
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+])
+_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],
+	[Does compiler simultaneously support -c and -o options?])
+])# _LT_COMPILER_C_O
+
+
+# _LT_COMPILER_FILE_LOCKS([TAGNAME])
+# ----------------------------------
+# Check to see if we can do hard links to lock some files if needed
+m4_defun([_LT_COMPILER_FILE_LOCKS],
+[m4_require([_LT_ENABLE_LOCK])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_COMPILER_C_O([$1])
+
+hard_links="nottested"
+if test "$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  AC_MSG_CHECKING([if we can lock with hard links])
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  AC_MSG_RESULT([$hard_links])
+  if test "$hard_links" = no; then
+    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])
+])# _LT_COMPILER_FILE_LOCKS
+
+
+# _LT_CHECK_OBJDIR
+# ----------------
+m4_defun([_LT_CHECK_OBJDIR],
+[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],
+[rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null])
+objdir=$lt_cv_objdir
+_LT_DECL([], [objdir], [0],
+         [The name of the directory that contains temporary libtool files])dnl
+m4_pattern_allow([LT_OBJDIR])dnl
+AC_DEFINE_UNQUOTED(LT_OBJDIR, "$lt_cv_objdir/",
+  [Define to the sub-directory in which libtool stores uninstalled libraries.])
+])# _LT_CHECK_OBJDIR
+
+
+# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])
+# --------------------------------------
+# Check hardcoding attributes.
+m4_defun([_LT_LINKER_HARDCODE_LIBPATH],
+[AC_MSG_CHECKING([how to hardcode library paths into programs])
+_LT_TAGVAR(hardcode_action, $1)=
+if test -n "$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)" ||
+   test -n "$_LT_TAGVAR(runpath_var, $1)" ||
+   test "X$_LT_TAGVAR(hardcode_automatic, $1)" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$_LT_TAGVAR(hardcode_direct, $1)" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, $1)" != no &&
+     test "$_LT_TAGVAR(hardcode_minus_L, $1)" != no; then
+    # Linking always hardcodes the temporary library directory.
+    _LT_TAGVAR(hardcode_action, $1)=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    _LT_TAGVAR(hardcode_action, $1)=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  _LT_TAGVAR(hardcode_action, $1)=unsupported
+fi
+AC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])
+
+if test "$_LT_TAGVAR(hardcode_action, $1)" = relink ||
+   test "$_LT_TAGVAR(inherit_rpath, $1)" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+_LT_TAGDECL([], [hardcode_action], [0],
+    [How to hardcode a shared library path into an executable])
+])# _LT_LINKER_HARDCODE_LIBPATH
+
+
+# _LT_CMD_STRIPLIB
+# ----------------
+m4_defun([_LT_CMD_STRIPLIB],
+[m4_require([_LT_DECL_EGREP])
+striplib=
+old_striplib=
+AC_MSG_CHECKING([whether stripping libraries is possible])
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  AC_MSG_RESULT([yes])
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      AC_MSG_RESULT([yes])
+    else
+      AC_MSG_RESULT([no])
+    fi
+    ;;
+  *)
+    AC_MSG_RESULT([no])
+    ;;
+  esac
+fi
+_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])
+_LT_DECL([], [striplib], [1])
+])# _LT_CMD_STRIPLIB
+
+
+# _LT_SYS_DYNAMIC_LINKER([TAG])
+# -----------------------------
+# PORTME Fill in your ld.so characteristics
+m4_defun([_LT_SYS_DYNAMIC_LINKER],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_OBJDUMP])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_CHECK_SHELL_FEATURES])dnl
+AC_MSG_CHECKING([dynamic linker characteristics])
+m4_if([$1],
+	[], [
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  case $host_os in
+    mingw* | cegcc*) lt_sed_strip_eq="s,=\([[A-Za-z]]:\),\1,g" ;;
+    *) lt_sed_strip_eq="s,=/,/,g" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
+  case $lt_search_path_spec in
+  *\;*)
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
+    ;;
+  *)
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
+    ;;
+  esac
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[[lt_foo]]++; }
+  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }
+}'`
+  # AWK program above erroneously prepends '/' to C:/dos/paths
+  # for these hosts.
+  case $host_os in
+    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
+      $SED 's,/\([[A-Za-z]]:\),\1,g'` ;;
+  esac
+  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi])
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[[4-9]]*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[[01]] | aix4.[[01]].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([[^/]]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[[45]]*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$cc_basename in
+  yes,*)
+    # gcc
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+m4_if([$1], [],[
+      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"])
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    dynamic_linker='Win32 ld.exe'
+    ;;
+
+  *,cl*)
+    # Native MSVC
+    libname_spec='$name'
+    soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+    library_names_spec='${libname}.dll.lib'
+
+    case $build_os in
+    mingw*)
+      sys_lib_search_path_spec=
+      lt_save_ifs=$IFS
+      IFS=';'
+      for lt_path in $LIB
+      do
+        IFS=$lt_save_ifs
+        # Let DOS variable expansion print the short 8.3 style file name.
+        lt_path=`cd "$lt_path" 2>/dev/null && cmd //C "for %i in (".") do @echo %~si"`
+        sys_lib_search_path_spec="$sys_lib_search_path_spec $lt_path"
+      done
+      IFS=$lt_save_ifs
+      # Convert to MSYS style.
+      sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | sed -e 's|\\\\|/|g' -e 's| \\([[a-zA-Z]]\\):| /\\1|g' -e 's|^ ||'`
+      ;;
+    cygwin*)
+      # Convert to unix form, then to dos form, then back to unix form
+      # but this time dos style (no spaces!) so that the unix form looks
+      # like /cygdrive/c/PROGRA~1:/cygdr...
+      sys_lib_search_path_spec=`cygpath --path --unix "$LIB"`
+      sys_lib_search_path_spec=`cygpath --path --dos "$sys_lib_search_path_spec" 2>/dev/null`
+      sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
+      ;;
+    *)
+      sys_lib_search_path_spec="$LIB"
+      if $ECHO "$sys_lib_search_path_spec" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then
+        # It is most probably a Windows format PATH.
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      # FIXME: find the short name or the path components, as spaces are
+      # common. (e.g. "Program Files" -> "PROGRA~1")
+      ;;
+    esac
+
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+    dynamic_linker='Win32 link.exe'
+    ;;
+
+  *)
+    # Assume MSVC wrapper
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    dynamic_linker='Win32 ld.exe'
+    ;;
+  esac
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+m4_if([$1], [],[
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"])
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[[23]].*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2.*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[[01]]* | freebsdelf3.[[01]]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \
+  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+haiku*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  dynamic_linker="$host_os runtime_loader"
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
+  postinstall_cmds='chmod 555 $lib'
+  # or fails outright, so override atomically:
+  install_override_mode=555
+  ;;
+
+interix[[3-9]]*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux # correct to gnu/linux during the next big refactor
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be glibc/ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+
+  # Some binutils ld are patched to set DT_RUNPATH
+  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],
+    [lt_cv_shlibpath_overrides_runpath=no
+    save_LDFLAGS=$LDFLAGS
+    save_libdir=$libdir
+    eval "libdir=/foo; wl=\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\"; \
+	 LDFLAGS=\"\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\""
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null],
+	 [lt_cv_shlibpath_overrides_runpath=yes])])
+    LDFLAGS=$save_LDFLAGS
+    libdir=$save_libdir
+    ])
+  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[[89]] | openbsd2.[[89]].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux # correct to gnu/linux during the next big refactor
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+AC_MSG_RESULT([$dynamic_linker])
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+_LT_DECL([], [variables_saved_for_relink], [1],
+    [Variables whose values should be saved in libtool wrapper scripts and
+    restored at link time])
+_LT_DECL([], [need_lib_prefix], [0],
+    [Do we need the "lib" prefix for modules?])
+_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])
+_LT_DECL([], [version_type], [0], [Library versioning type])
+_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])
+_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])
+_LT_DECL([], [shlibpath_overrides_runpath], [0],
+    [Is shlibpath searched before the hard-coded library search path?])
+_LT_DECL([], [libname_spec], [1], [Format of library name prefix])
+_LT_DECL([], [library_names_spec], [1],
+    [[List of archive names.  First name is the real one, the rest are links.
+    The last name is the one that the linker finds with -lNAME]])
+_LT_DECL([], [soname_spec], [1],
+    [[The coded name of the library, if different from the real name]])
+_LT_DECL([], [install_override_mode], [1],
+    [Permission mode override for installation of shared libraries])
+_LT_DECL([], [postinstall_cmds], [2],
+    [Command to use after installation of a shared archive])
+_LT_DECL([], [postuninstall_cmds], [2],
+    [Command to use after uninstallation of a shared archive])
+_LT_DECL([], [finish_cmds], [2],
+    [Commands used to finish a libtool library installation in a directory])
+_LT_DECL([], [finish_eval], [1],
+    [[As "finish_cmds", except a single script fragment to be evaled but
+    not shown]])
+_LT_DECL([], [hardcode_into_libs], [0],
+    [Whether we should hardcode library paths into libraries])
+_LT_DECL([], [sys_lib_search_path_spec], [2],
+    [Compile-time system search path for libraries])
+_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],
+    [Run-time system search path for libraries])
+])# _LT_SYS_DYNAMIC_LINKER
+
+
+# _LT_PATH_TOOL_PREFIX(TOOL)
+# --------------------------
+# find a file program which can recognize shared library
+AC_DEFUN([_LT_PATH_TOOL_PREFIX],
+[m4_require([_LT_DECL_EGREP])dnl
+AC_MSG_CHECKING([for $1])
+AC_CACHE_VAL(lt_cv_path_MAGIC_CMD,
+[case $MAGIC_CMD in
+[[\\/*] |  ?:[\\/]*])
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+dnl $ac_dummy forces splitting on constant user-supplied paths.
+dnl POSIX.2 word splitting is done only on the output of word expansions,
+dnl not every word.  This closes a longstanding sh security hole.
+  ac_dummy="m4_if([$2], , $PATH, [$2])"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$1; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/$1"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac])
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  AC_MSG_RESULT($MAGIC_CMD)
+else
+  AC_MSG_RESULT(no)
+fi
+_LT_DECL([], [MAGIC_CMD], [0],
+	 [Used to examine libraries when file_magic_cmd begins with "file"])dnl
+])# _LT_PATH_TOOL_PREFIX
+
+# Old name:
+AU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])
+
+
+# _LT_PATH_MAGIC
+# --------------
+# find a file program which can recognize a shared library
+m4_defun([_LT_PATH_MAGIC],
+[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)
+  else
+    MAGIC_CMD=:
+  fi
+fi
+])# _LT_PATH_MAGIC
+
+
+# LT_PATH_LD
+# ----------
+# find the pathname to the GNU or non-GNU linker
+AC_DEFUN([LT_PATH_LD],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_PROG_ECHO_BACKSLASH])dnl
+
+AC_ARG_WITH([gnu-ld],
+    [AS_HELP_STRING([--with-gnu-ld],
+	[assume the C compiler uses GNU ld @<:@default=no@:>@])],
+    [test "$withval" = no || with_gnu_ld=yes],
+    [with_gnu_ld=no])dnl
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by $CC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]]* | ?:[[\\/]]*)
+      re_direlt='/[[^/]][[^/]]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(lt_cv_path_LD,
+[if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+_LT_PATH_LD_GNU
+AC_SUBST([LD])
+
+_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])
+])# LT_PATH_LD
+
+# Old names:
+AU_ALIAS([AM_PROG_LD], [LT_PATH_LD])
+AU_ALIAS([AC_PROG_LD], [LT_PATH_LD])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_LD], [])
+dnl AC_DEFUN([AC_PROG_LD], [])
+
+
+# _LT_PATH_LD_GNU
+#- --------------
+m4_defun([_LT_PATH_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac])
+with_gnu_ld=$lt_cv_prog_gnu_ld
+])# _LT_PATH_LD_GNU
+
+
+# _LT_CMD_RELOAD
+# --------------
+# find reload flag for linker
+#   -- PORTME Some linkers may need a different reload flag.
+m4_defun([_LT_CMD_RELOAD],
+[AC_CACHE_CHECK([for $LD option to reload object files],
+  lt_cv_ld_reload_flag,
+  [lt_cv_ld_reload_flag='-r'])
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    if test "$GCC" != yes; then
+      reload_cmds=false
+    fi
+    ;;
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl
+_LT_TAGDECL([], [reload_cmds], [2])dnl
+])# _LT_CMD_RELOAD
+
+
+# _LT_CHECK_MAGIC_METHOD
+# ----------------------
+# how to check for library dependencies
+#  -- PORTME fill in with the dynamic library characteristics
+m4_defun([_LT_CHECK_MAGIC_METHOD],
+[m4_require([_LT_DECL_EGREP])
+m4_require([_LT_DECL_OBJDUMP])
+AC_CACHE_CHECK([how to recognize dependent libraries],
+lt_cv_deplibs_check_method,
+[lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[[4-9]]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[[45]]*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
+  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    # Keep this pattern in sync with the one in func_win32_libid.
+    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc*)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+haiku*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]']
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\.[[0-9]]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[[3-9]]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be glibc/ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd* | netbsdelf*-gnu)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+])
+
+file_magic_glob=
+want_nocaseglob=no
+if test "$build" = "$host"; then
+  case $host_os in
+  mingw* | pw32*)
+    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then
+      want_nocaseglob=yes
+    else
+      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e "s/\(..\)/s\/[[\1]]\/[[\1]]\/g;/g"`
+    fi
+    ;;
+  esac
+fi
+
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+_LT_DECL([], [deplibs_check_method], [1],
+    [Method to check whether dependent libraries are shared objects])
+_LT_DECL([], [file_magic_cmd], [1],
+    [Command to use when deplibs_check_method = "file_magic"])
+_LT_DECL([], [file_magic_glob], [1],
+    [How to find potential files when deplibs_check_method = "file_magic"])
+_LT_DECL([], [want_nocaseglob], [1],
+    [Find potential files using nocaseglob when deplibs_check_method = "file_magic"])
+])# _LT_CHECK_MAGIC_METHOD
+
+
+# LT_PATH_NM
+# ----------
+# find the pathname to a BSD- or MS-compatible name lister
+AC_DEFUN([LT_PATH_NM],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,
+[if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi])
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  if test -n "$DUMPBIN"; then :
+    # Let the user override the test.
+  else
+    AC_CHECK_TOOLS(DUMPBIN, [dumpbin "link -dump"], :)
+    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
+    *COFF*)
+      DUMPBIN="$DUMPBIN -symbols"
+      ;;
+    *)
+      DUMPBIN=:
+      ;;
+    esac
+  fi
+  AC_SUBST([DUMPBIN])
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+AC_SUBST([NM])
+_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl
+
+AC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],
+  [lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:$LINENO: output\"" >&AS_MESSAGE_LOG_FD)
+  cat conftest.out >&AS_MESSAGE_LOG_FD
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*])
+])# LT_PATH_NM
+
+# Old names:
+AU_ALIAS([AM_PROG_NM], [LT_PATH_NM])
+AU_ALIAS([AC_PROG_NM], [LT_PATH_NM])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_NM], [])
+dnl AC_DEFUN([AC_PROG_NM], [])
+
+# _LT_CHECK_SHAREDLIB_FROM_LINKLIB
+# --------------------------------
+# how to determine the name of the shared library
+# associated with a specific link library.
+#  -- PORTME fill in with the dynamic library characteristics
+m4_defun([_LT_CHECK_SHAREDLIB_FROM_LINKLIB],
+[m4_require([_LT_DECL_EGREP])
+m4_require([_LT_DECL_OBJDUMP])
+m4_require([_LT_DECL_DLLTOOL])
+AC_CACHE_CHECK([how to associate runtime and link libraries],
+lt_cv_sharedlib_from_linklib_cmd,
+[lt_cv_sharedlib_from_linklib_cmd='unknown'
+
+case $host_os in
+cygwin* | mingw* | pw32* | cegcc*)
+  # two different shell functions defined in ltmain.sh
+  # decide which to use based on capabilities of $DLLTOOL
+  case `$DLLTOOL --help 2>&1` in
+  *--identify-strict*)
+    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib
+    ;;
+  *)
+    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback
+    ;;
+  esac
+  ;;
+*)
+  # fallback: assume linklib IS sharedlib
+  lt_cv_sharedlib_from_linklib_cmd="$ECHO"
+  ;;
+esac
+])
+sharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd
+test -z "$sharedlib_from_linklib_cmd" && sharedlib_from_linklib_cmd=$ECHO
+
+_LT_DECL([], [sharedlib_from_linklib_cmd], [1],
+    [Command to associate shared and link libraries])
+])# _LT_CHECK_SHAREDLIB_FROM_LINKLIB
+
+
+# _LT_PATH_MANIFEST_TOOL
+# ----------------------
+# locate the manifest tool
+m4_defun([_LT_PATH_MANIFEST_TOOL],
+[AC_CHECK_TOOL(MANIFEST_TOOL, mt, :)
+test -z "$MANIFEST_TOOL" && MANIFEST_TOOL=mt
+AC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool],
+  [lt_cv_path_mainfest_tool=no
+  echo "$as_me:$LINENO: $MANIFEST_TOOL '-?'" >&AS_MESSAGE_LOG_FD
+  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  if $GREP 'Manifest Tool' conftest.out > /dev/null; then
+    lt_cv_path_mainfest_tool=yes
+  fi
+  rm -f conftest*])
+if test "x$lt_cv_path_mainfest_tool" != xyes; then
+  MANIFEST_TOOL=:
+fi
+_LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl
+])# _LT_PATH_MANIFEST_TOOL
+
+
+# LT_LIB_M
+# --------
+# check for math library
+AC_DEFUN([LT_LIB_M],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+LIBM=
+case $host in
+*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)
+  # These system don't have libm, or don't need it
+  ;;
+*-ncr-sysv4.3*)
+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM="-lmw")
+  AC_CHECK_LIB(m, cos, LIBM="$LIBM -lm")
+  ;;
+*)
+  AC_CHECK_LIB(m, cos, LIBM="-lm")
+  ;;
+esac
+AC_SUBST([LIBM])
+])# LT_LIB_M
+
+# Old name:
+AU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_CHECK_LIBM], [])
+
+
+# _LT_COMPILER_NO_RTTI([TAGNAME])
+# -------------------------------
+m4_defun([_LT_COMPILER_NO_RTTI],
+[m4_require([_LT_TAG_COMPILER])dnl
+
+_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+
+if test "$GCC" = yes; then
+  case $cc_basename in
+  nvcc*)
+    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;
+  *)
+    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;
+  esac
+
+  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],
+    lt_cv_prog_compiler_rtti_exceptions,
+    [-fno-rtti -fno-exceptions], [],
+    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)="$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions"])
+fi
+_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],
+	[Compiler flag to turn off builtin functions])
+])# _LT_COMPILER_NO_RTTI
+
+
+# _LT_CMD_GLOBAL_SYMBOLS
+# ----------------------
+m4_defun([_LT_CMD_GLOBAL_SYMBOLS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+AC_MSG_CHECKING([command to parse $NM output from $compiler object])
+AC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],
+[
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[[BCDEGRST]]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([[_A-Za-z]][[_A-Za-z0-9]]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[[BCDT]]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[[ABCDGISTW]]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[[ABCDEGRST]]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[[BCDEGRST]]'
+  ;;
+osf*)
+  symcode='[[BCDEGQRST]]'
+  ;;
+solaris*)
+  symcode='[[BDRT]]'
+  ;;
+sco3.2v5*)
+  symcode='[[DT]]'
+  ;;
+sysv4.2uw2*)
+  symcode='[[DT]]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[[ABDT]]'
+  ;;
+sysv4)
+  symcode='[[DFNSTU]]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[[ABCDGIRSTW]]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([[^ ]]*\)[[ ]]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([[^ ]]*\)[[ ]]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \(lib[[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK ['"\
+"     {last_section=section; section=\$ 3};"\
+"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx]"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[[	 ]]\($symcode$symcode*\)[[	 ]][[	 ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+  lt_cv_sys_global_symbol_pipe="$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'"
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if AC_TRY_EVAL(ac_compile); then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if AC_TRY_EVAL(NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */
+#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
+/* DATA imports from DLLs on WIN32 con't be const, because runtime
+   relocations are performed -- see ld's documentation on pseudo-relocs.  */
+# define LT@&t@_DLSYM_CONST
+#elif defined(__osf__)
+/* This system does not cope well with relocations in const data.  */
+# define LT@&t@_DLSYM_CONST
+#else
+# define LT@&t@_DLSYM_CONST const
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+LT@&t@_DLSYM_CONST struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[[]] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_globsym_save_LIBS=$LIBS
+	  lt_globsym_save_CFLAGS=$CFLAGS
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)"
+	  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS=$lt_globsym_save_LIBS
+	  CFLAGS=$lt_globsym_save_CFLAGS
+	else
+	  echo "cannot find nm_test_func in $nlist" >&AS_MESSAGE_LOG_FD
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&AS_MESSAGE_LOG_FD
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&AS_MESSAGE_LOG_FD
+    fi
+  else
+    echo "$progname: failed program was:" >&AS_MESSAGE_LOG_FD
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+])
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  AC_MSG_RESULT(failed)
+else
+  AC_MSG_RESULT(ok)
+fi
+
+# Response file support.
+if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+  nm_file_list_spec='@'
+elif $NM --help 2>/dev/null | grep '[[@]]FILE' >/dev/null; then
+  nm_file_list_spec='@'
+fi
+
+_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],
+    [Take the output of nm and produce a listing of raw symbols and C names])
+_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],
+    [Transform the output of nm in a proper C declaration])
+_LT_DECL([global_symbol_to_c_name_address],
+    [lt_cv_sys_global_symbol_to_c_name_address], [1],
+    [Transform the output of nm in a C name address pair])
+_LT_DECL([global_symbol_to_c_name_address_lib_prefix],
+    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],
+    [Transform the output of nm in a C name address pair when lib prefix is needed])
+_LT_DECL([], [nm_file_list_spec], [1],
+    [Specify filename containing input files for $NM])
+]) # _LT_CMD_GLOBAL_SYMBOLS
+
+
+# _LT_COMPILER_PIC([TAGNAME])
+# ---------------------------
+m4_defun([_LT_COMPILER_PIC],
+[m4_require([_LT_TAG_COMPILER])dnl
+_LT_TAGVAR(lt_prog_compiler_wl, $1)=
+_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+_LT_TAGVAR(lt_prog_compiler_static, $1)=
+
+m4_if([$1], [CXX], [
+  # C++ specific cases for pic, static, wl, etc.
+  if test "$GXX" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+    aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    mingw* | cygwin* | os2* | pw32* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+    *djgpp*)
+      # DJGPP does not support shared libraries at all
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+      ;;
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)=
+      ;;
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+    *qnx* | *nto*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+  else
+    case $host_os in
+      aix[[4-9]]*)
+	# All AIX code is PIC.
+	if test "$host_cpu" = ia64; then
+	  # AIX 5 now supports IA64 processor
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	else
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+	fi
+	;;
+      chorus*)
+	case $cc_basename in
+	cxch68*)
+	  # Green Hills C++ Compiler
+	  # _LT_TAGVAR(lt_prog_compiler_static, $1)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
+	  ;;
+	esac
+	;;
+      mingw* | cygwin* | os2* | pw32* | cegcc*)
+	# This hack is so that the source file can tell whether it is being
+	# built for inclusion in a dll (and should export symbols for example).
+	m4_if([$1], [GCJ], [],
+	  [_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+	;;
+      dgux*)
+	case $cc_basename in
+	  ec++*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  ghcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      freebsd* | dragonfly*)
+	# FreeBSD uses GNU C++
+	;;
+      hpux9* | hpux10* | hpux11*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    if test "$host_cpu" != ia64; then
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	    fi
+	    ;;
+	  aCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    case $host_cpu in
+	    hppa*64*|ia64*)
+	      # +Z the default
+	      ;;
+	    *)
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	      ;;
+	    esac
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      interix*)
+	# This is c89, which is MS Visual C++ (no shared libs)
+	# Anyone wants to do a port?
+	;;
+      irix5* | irix6* | nonstopux*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    # CC pic flag -KPIC is the default.
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+	case $cc_basename in
+	  KCC*)
+	    # KAI C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    ;;
+	  ecpc* )
+	    # old Intel C++ for x86_64 which still supported -KPIC.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  icpc* )
+	    # Intel C++, used to be incompatible with GCC.
+	    # ICC 10 doesn't accept -KPIC any more.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  pgCC* | pgcpp*)
+	    # Portland Group C++ compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  cxx*)
+	    # Compaq C++
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)
+	    # IBM XL 8.0, 9.0 on PPC and BlueGene
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+      lynxos*)
+	;;
+      m88k*)
+	;;
+      mvs*)
+	case $cc_basename in
+	  cxx*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      netbsd* | netbsdelf*-gnu)
+	;;
+      *qnx* | *nto*)
+        # QNX uses GNU C++, but need to define -shared option too, otherwise
+        # it will coredump.
+        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+        ;;
+      osf3* | osf4* | osf5*)
+	case $cc_basename in
+	  KCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    ;;
+	  RCC*)
+	    # Rational C++ 2.4.1
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  cxx*)
+	    # Digital/Compaq C++
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      psos*)
+	;;
+      solaris*)
+	case $cc_basename in
+	  CC* | sunCC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	    ;;
+	  gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sunos4*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.x
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  lcc*)
+	    # Lucid
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	esac
+	;;
+      tandem*)
+	case $cc_basename in
+	  NCC*)
+	    # NonStop-UX NCC 3.20
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      vxworks*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+	;;
+    esac
+  fi
+],
+[
+  if test "$GCC" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)=
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+
+    case $cc_basename in
+    nvcc*) # Cuda Compiler Driver 2.2
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '
+      if test -n "$_LT_TAGVAR(lt_prog_compiler_pic, $1)"; then
+        _LT_TAGVAR(lt_prog_compiler_pic, $1)="-Xcompiler $_LT_TAGVAR(lt_prog_compiler_pic, $1)"
+      fi
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      else
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC (with -KPIC) is the default.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'
+	;;
+      nagfor*)
+	# NAG Fortran compiler
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+        ;;
+      ccc*)
+        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+        # All Alpha code is PIC.
+        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+        ;;
+      xl* | bgxl* | bgf* | mpixl*)
+	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ Ceres\ Fortran* | *Sun*Fortran*\ [[1-7]].* | *Sun*Fortran*\ 8.[[0-3]]*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''
+	  ;;
+	*Sun\ F* | *Sun*Fortran*)
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	  ;;
+	*Sun\ C*)
+	  # Sun C 5.9
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	  ;;
+        *Intel*\ [[CF]]*Compiler*)
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	  ;;
+	*Portland\ Group*)
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # All OSF/1 code is PIC.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    rdos*)
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    unicos*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+    esac
+  fi
+])
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+    ;;
+  *)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)="$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])"
+    ;;
+esac
+
+AC_CACHE_CHECK([for $compiler option to produce PIC],
+  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)],
+  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_prog_compiler_pic, $1)])
+_LT_TAGVAR(lt_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$_LT_TAGVAR(lt_prog_compiler_pic, $1)"; then
+  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],
+    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],
+    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],
+    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in
+     "" | " "*) ;;
+     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=" $_LT_TAGVAR(lt_prog_compiler_pic, $1)" ;;
+     esac],
+    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])
+fi
+_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],
+	[Additional compiler flags for building library objects])
+
+_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],
+	[How to pass a linker flag through the compiler])
+#
+# Check to make sure the static flag actually works.
+#
+wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\"
+_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],
+  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),
+  $lt_tmp_static_flag,
+  [],
+  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])
+_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],
+	[Compiler flag to prevent dynamic linking])
+])# _LT_COMPILER_PIC
+
+
+# _LT_LINKER_SHLIBS([TAGNAME])
+# ----------------------------
+# See if the linker supports building shared libraries.
+m4_defun([_LT_LINKER_SHLIBS],
+[AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+m4_require([_LT_PATH_MANIFEST_TOOL])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+m4_if([$1], [CXX], [
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+  case $host_os in
+  aix[[4-9]]*)
+    # If we're using GNU nm, then we don't want the "-C" option.
+    # -C means demangle to AIX nm, but means don't demangle with GNU nm
+    # Also, AIX nm treats weak defined symbols like other global defined
+    # symbols, whereas GNU nm marks them as "W".
+    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    else
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    fi
+    ;;
+  pw32*)
+    _LT_TAGVAR(export_symbols_cmds, $1)="$ltdll_cmds"
+    ;;
+  cygwin* | mingw* | cegcc*)
+    case $cc_basename in
+    cl*)
+      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'
+      ;;
+    *)
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
+      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']
+      ;;
+    esac
+    ;;
+  linux* | k*bsd*-gnu | gnu*)
+    _LT_TAGVAR(link_all_deplibs, $1)=no
+    ;;
+  *)
+    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+    ;;
+  esac
+], [
+  runpath_var=
+  _LT_TAGVAR(allow_undefined_flag, $1)=
+  _LT_TAGVAR(always_export_symbols, $1)=no
+  _LT_TAGVAR(archive_cmds, $1)=
+  _LT_TAGVAR(archive_expsym_cmds, $1)=
+  _LT_TAGVAR(compiler_needs_object, $1)=no
+  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+  _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  _LT_TAGVAR(hardcode_automatic, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_direct_absolute, $1)=no
+  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+  _LT_TAGVAR(hardcode_minus_L, $1)=no
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  _LT_TAGVAR(inherit_rpath, $1)=no
+  _LT_TAGVAR(link_all_deplibs, $1)=unknown
+  _LT_TAGVAR(module_cmds, $1)=
+  _LT_TAGVAR(module_expsym_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_new_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=
+  _LT_TAGVAR(thread_safe_flag_spec, $1)=
+  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  _LT_TAGVAR(include_expsyms, $1)=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+dnl Note also adjust exclude_expsyms for C++ above.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  linux* | k*bsd*-gnu | gnu*)
+    _LT_TAGVAR(link_all_deplibs, $1)=no
+    ;;
+  esac
+
+  _LT_TAGVAR(ld_shlibs, $1)=yes
+
+  # On some targets, GNU ld is compatible enough with the native linker
+  # that we're better off using the native interface for both.
+  lt_use_gnu_ld_interface=no
+  if test "$with_gnu_ld" = yes; then
+    case $host_os in
+      aix*)
+	# The AIX port of GNU ld has always aspired to compatibility
+	# with the native linker.  However, as the warning in the GNU ld
+	# block says, versions before 2.19.5* couldn't really create working
+	# shared libraries, regardless of the interface used.
+	case `$LD -v 2>&1` in
+	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
+	  *\ \(GNU\ Binutils\)\ 2.[[2-9]]*) ;;
+	  *\ \(GNU\ Binutils\)\ [[3-9]]*) ;;
+	  *)
+	    lt_use_gnu_ld_interface=yes
+	    ;;
+	esac
+	;;
+      *)
+	lt_use_gnu_ld_interface=yes
+	;;
+    esac
+  fi
+
+  if test "$lt_use_gnu_ld_interface" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *GNU\ gold*) supports_anon_versioning=yes ;;
+      *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[[3-9]]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.19, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to install binutils
+*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
+*** You will then need to restart the configuration process.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+      # as there is no search path for DLLs.
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=no
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
+      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    haiku*)
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    interix[[3-9]]*)
+      _LT_TAGVAR(hardcode_direct, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      _LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=' $pic_flag'
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95* | pgfortran*)
+					# Portland Group f77 and f90 compilers
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+	  tmp_sharedflag='--shared' ;;
+	xl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	nvcc*)	# Cuda Compiler Driver 2.2
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(compiler_needs_object, $1)=yes
+	  ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(compiler_needs_object, $1)=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	_LT_TAGVAR(archive_cmds, $1)='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf* | bgf* | bgxlf* | mpixlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        _LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.1[[0-5]].*)
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+    esac
+
+    if test "$_LT_TAGVAR(ld_shlibs, $1)" = no; then
+      runpath_var=
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	_LT_TAGVAR(hardcode_direct, $1)=unsupported
+      fi
+      ;;
+
+    aix[[4-9]]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	# Also, AIX nm treats weak defined symbols like other global
+	# defined symbols, whereas GNU nm marks them as "W".
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      _LT_TAGVAR(archive_cmds, $1)=''
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[[012]]|aix4.[[012]].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+	_LT_TAGVAR(link_all_deplibs, $1)=no
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	_LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        _LT_SYS_MODULE_PATH_AIX([$1])
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	  _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 _LT_SYS_MODULE_PATH_AIX([$1])
+	 _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	  if test "$with_gnu_ld" = yes; then
+	    # We only use this code for GNU lds that support --whole-archive.
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	  else
+	    # Exported symbols can be pulled into shared objects from archives
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	  fi
+	  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[[45]]*)
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      case $cc_basename in
+      cl*)
+	# Native MSVC
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	_LT_TAGVAR(always_export_symbols, $1)=yes
+	_LT_TAGVAR(file_list_spec, $1)='@'
+	# Tell ltmain to make .lib files, not .a files.
+	libext=lib
+	# Tell ltmain to make .dll files, not .so files.
+	shrext_cmds=".dll"
+	# FIXME: Setting linknames here is a bad hack.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
+	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	    sed -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
+	  else
+	    sed -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
+	  fi~
+	  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
+	  linknames='
+	# The linker will not automatically build a static lib if we build a DLL.
+	# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
+	_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+	_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'
+	_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1,DATA/'\'' | $SED -e '\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\'' | sort | uniq > $export_symbols'
+	# Don't use ranlib
+	_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'
+	_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile="@OUTPUT@"~
+	  lt_tool_outputfile="@TOOL_OUTPUT@"~
+	  case $lt_outputfile in
+	    *.exe|*.EXE) ;;
+	    *)
+	      lt_outputfile="$lt_outputfile.exe"
+	      lt_tool_outputfile="$lt_tool_outputfile.exe"
+	      ;;
+	  esac~
+	  if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
+	    $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
+	    $RM "$lt_outputfile.manifest";
+	  fi'
+	;;
+      *)
+	# Assume MSVC wrapper
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	# Tell ltmain to make .lib files, not .a files.
+	libext=lib
+	# Tell ltmain to make .dll files, not .so files.
+	shrext_cmds=".dll"
+	# FIXME: Setting linknames here is a bad hack.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
+	# The linker will automatically build a .lib file if we build a DLL.
+	_LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
+	# FIXME: Should let the user specify the lib program.
+	_LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'
+	_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+	;;
+      esac
+      ;;
+
+    darwin* | rhapsody*)
+      _LT_DARWIN_LINKER_FEATURES($1)
+      ;;
+
+    dgux*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2.*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	_LT_TAGVAR(hardcode_minus_L, $1)=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	m4_if($1, [], [
+	  # Older versions of the 11.00 compiler do not understand -b yet
+	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
+	  _LT_LINKER_OPTION([if $CC understands -b],
+	    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],
+	    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],
+	    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],
+	  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  ;;
+	*)
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+	# This should be the same for all languages, so no per-tag cache variable.
+	AC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],
+	  [lt_cv_irix_exported_symbol],
+	  [save_LDFLAGS="$LDFLAGS"
+	   LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+	   AC_LINK_IFELSE(
+	     [AC_LANG_SOURCE(
+	        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],
+			      [C++], [[int foo (void) { return 0; }]],
+			      [Fortran 77], [[
+      subroutine foo
+      end]],
+			      [Fortran], [[
+      subroutine foo
+      end]])])],
+	      [lt_cv_irix_exported_symbol=yes],
+	      [lt_cv_irix_exported_symbol=no])
+           LDFLAGS="$save_LDFLAGS"])
+	if test "$lt_cv_irix_exported_symbol" = yes; then
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+	fi
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(inherit_rpath, $1)=yes
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)
+	     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	     ;;
+	   *)
+	     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    os2*)
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      case $host_os in
+      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+        ;;
+	motorola)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4.3*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	_LT_TAGVAR(ld_shlibs, $1)=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      _LT_TAGVAR(ld_shlibs, $1)=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+])
+AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld
+
+_LT_DECL([], [libext], [0], [Old archive suffix (normally "a")])dnl
+_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally ".so")])dnl
+_LT_DECL([], [extract_expsyms_cmds], [2],
+    [The commands to extract the exported symbol list from a shared archive])
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$_LT_TAGVAR(archive_cmds_need_lc, $1)" in
+x|xyes)
+  # Assume -lc should be added
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $_LT_TAGVAR(archive_cmds, $1) in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      AC_CACHE_CHECK([whether -lc should be explicitly linked in],
+	[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),
+	[$RM conftest*
+	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+	if AC_TRY_EVAL(ac_compile) 2>conftest.err; then
+	  soname=conftest
+	  lib=conftest
+	  libobjs=conftest.$ac_objext
+	  deplibs=
+	  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)
+	  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)
+	  compiler_flags=-v
+	  linker_flags=-v
+	  verstring=
+	  output_objdir=.
+	  libname=conftest
+	  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)
+	  _LT_TAGVAR(allow_undefined_flag, $1)=
+	  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1)
+	  then
+	    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	  else
+	    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	  fi
+	  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag
+	else
+	  cat conftest.err 1>&5
+	fi
+	$RM conftest*
+	])
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],
+    [Whether or not to add -lc for building shared libraries])
+_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],
+    [enable_shared_with_static_runtimes], [0],
+    [Whether or not to disallow shared libs when runtime libs are static])
+_LT_TAGDECL([], [export_dynamic_flag_spec], [1],
+    [Compiler flag to allow reflexive dlopens])
+_LT_TAGDECL([], [whole_archive_flag_spec], [1],
+    [Compiler flag to generate shared objects directly from archives])
+_LT_TAGDECL([], [compiler_needs_object], [1],
+    [Whether the compiler copes with passing no objects directly])
+_LT_TAGDECL([], [old_archive_from_new_cmds], [2],
+    [Create an old-style archive from a shared archive])
+_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],
+    [Create a temporary old-style archive to link instead of a shared archive])
+_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])
+_LT_TAGDECL([], [archive_expsym_cmds], [2])
+_LT_TAGDECL([], [module_cmds], [2],
+    [Commands used to build a loadable module if different from building
+    a shared archive.])
+_LT_TAGDECL([], [module_expsym_cmds], [2])
+_LT_TAGDECL([], [with_gnu_ld], [1],
+    [Whether we are building with GNU ld or not])
+_LT_TAGDECL([], [allow_undefined_flag], [1],
+    [Flag that allows shared libraries with undefined symbols to be built])
+_LT_TAGDECL([], [no_undefined_flag], [1],
+    [Flag that enforces no undefined symbols])
+_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],
+    [Flag to hardcode $libdir into a binary during linking.
+    This must work even if $libdir does not exist])
+_LT_TAGDECL([], [hardcode_libdir_separator], [1],
+    [Whether we need a single "-rpath" flag with a separated argument])
+_LT_TAGDECL([], [hardcode_direct], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary])
+_LT_TAGDECL([], [hardcode_direct_absolute], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary and the resulting library dependency is
+    "absolute", i.e impossible to change by setting ${shlibpath_var} if the
+    library is relocated])
+_LT_TAGDECL([], [hardcode_minus_L], [0],
+    [Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_shlibpath_var], [0],
+    [Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_automatic], [0],
+    [Set to "yes" if building a shared library automatically hardcodes DIR
+    into the library and all subsequent libraries and executables linked
+    against it])
+_LT_TAGDECL([], [inherit_rpath], [0],
+    [Set to yes if linker adds runtime paths of dependent libraries
+    to runtime path list])
+_LT_TAGDECL([], [link_all_deplibs], [0],
+    [Whether libtool must link a program against all its dependency libraries])
+_LT_TAGDECL([], [always_export_symbols], [0],
+    [Set to "yes" if exported symbols are required])
+_LT_TAGDECL([], [export_symbols_cmds], [2],
+    [The commands to list exported symbols])
+_LT_TAGDECL([], [exclude_expsyms], [1],
+    [Symbols that should not be listed in the preloaded symbols])
+_LT_TAGDECL([], [include_expsyms], [1],
+    [Symbols that must always be exported])
+_LT_TAGDECL([], [prelink_cmds], [2],
+    [Commands necessary for linking programs (against libraries) with templates])
+_LT_TAGDECL([], [postlink_cmds], [2],
+    [Commands necessary for finishing linking programs])
+_LT_TAGDECL([], [file_list_spec], [1],
+    [Specify filename containing input files])
+dnl FIXME: Not yet implemented
+dnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],
+dnl    [Compiler flag to generate thread safe objects])
+])# _LT_LINKER_SHLIBS
+
+
+# _LT_LANG_C_CONFIG([TAG])
+# ------------------------
+# Ensure that the configuration variables for a C compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_C_CONFIG],
+[m4_require([_LT_DECL_EGREP])dnl
+lt_save_CC="$CC"
+AC_LANG_PUSH(C)
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+_LT_TAG_COMPILER
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_SYS_DYNAMIC_LINKER($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+  LT_SYS_DLOPEN_SELF
+  _LT_CMD_STRIPLIB
+
+  # Report which library types will actually be built
+  AC_MSG_CHECKING([if libtool supports shared libraries])
+  AC_MSG_RESULT([$can_build_shared])
+
+  AC_MSG_CHECKING([whether to build shared libraries])
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[[4-9]]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  AC_MSG_RESULT([$enable_shared])
+
+  AC_MSG_CHECKING([whether to build static libraries])
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  AC_MSG_RESULT([$enable_static])
+
+  _LT_CONFIG($1)
+fi
+AC_LANG_POP
+CC="$lt_save_CC"
+])# _LT_LANG_C_CONFIG
+
+
+# _LT_LANG_CXX_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a C++ compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_CXX_CONFIG],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_PATH_MANIFEST_TOOL])dnl
+if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
+    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
+    (test "X$CXX" != "Xg++"))) ; then
+  AC_PROG_CXXCPP
+else
+  _lt_caught_CXX_error=yes
+fi
+
+AC_LANG_PUSH(C++)
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(compiler_needs_object, $1)=no
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for C++ test sources.
+ac_ext=cpp
+
+# Object file extension for compiled C++ test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the CXX compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_caught_CXX_error" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="int some_variable = 0;"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC=$CC
+  lt_save_CFLAGS=$CFLAGS
+  lt_save_LD=$LD
+  lt_save_GCC=$GCC
+  GCC=$GXX
+  lt_save_with_gnu_ld=$with_gnu_ld
+  lt_save_path_LD=$lt_cv_path_LD
+  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
+    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
+  else
+    $as_unset lt_cv_prog_gnu_ld
+  fi
+  if test -n "${lt_cv_path_LDCXX+set}"; then
+    lt_cv_path_LD=$lt_cv_path_LDCXX
+  else
+    $as_unset lt_cv_path_LD
+  fi
+  test -z "${LDCXX+set}" || LD=$LDCXX
+  CC=${CXX-"c++"}
+  CFLAGS=$CXXFLAGS
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    # We don't want -fno-exception when compiling C++ code, so set the
+    # no_builtin_flag separately
+    if test "$GXX" = yes; then
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'
+    else
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+    fi
+
+    if test "$GXX" = yes; then
+      # Set up default GNU C++ configuration
+
+      LT_PATH_LD
+
+      # Check if GNU C++ uses GNU ld as the underlying linker, since the
+      # archiving commands below assume that GNU ld is being used.
+      if test "$with_gnu_ld" = yes; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+        # If archive_cmds runs LD, not CC, wlarc should be empty
+        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
+        #     investigate it a little bit more. (MM)
+        wlarc='${wl}'
+
+        # ancient GNU ld didn't support --whole-archive et. al.
+        if eval "`$CC -print-prog-name=ld` --help 2>&1" |
+	  $GREP 'no-whole-archive' > /dev/null; then
+          _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+        else
+          _LT_TAGVAR(whole_archive_flag_spec, $1)=
+        fi
+      else
+        with_gnu_ld=no
+        wlarc=
+
+        # A generic and very simple default shared library creation
+        # command for GNU C++ for the case where it uses the native
+        # linker, instead of GNU ld.  If possible, this setting should
+        # overridden to take advantage of the native linker features on
+        # the platform it is being used on.
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+      fi
+
+      # Commands to make compiler produce verbose output that lists
+      # what "hidden" libraries, object files and flags are used when
+      # linking a shared library.
+      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+
+    else
+      GXX=no
+      with_gnu_ld=no
+      wlarc=
+    fi
+
+    # PORTME: fill in a description of your system's C++ link characteristics
+    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+    _LT_TAGVAR(ld_shlibs, $1)=yes
+    case $host_os in
+      aix3*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+      aix[[4-9]]*)
+        if test "$host_cpu" = ia64; then
+          # On IA64, the linker does run time linking by default, so we don't
+          # have to do anything special.
+          aix_use_runtimelinking=no
+          exp_sym_flag='-Bexport'
+          no_entry_flag=""
+        else
+          aix_use_runtimelinking=no
+
+          # Test if we are trying to use run time linking or normal
+          # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+          # need to do runtime linking.
+          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	    for ld_flag in $LDFLAGS; do
+	      case $ld_flag in
+	      *-brtl*)
+	        aix_use_runtimelinking=yes
+	        break
+	        ;;
+	      esac
+	    done
+	    ;;
+          esac
+
+          exp_sym_flag='-bexport'
+          no_entry_flag='-bnoentry'
+        fi
+
+        # When large executables or shared objects are built, AIX ld can
+        # have problems creating the table of contents.  If linking a library
+        # or program results in "error TOC overflow" add -mminimal-toc to
+        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+        _LT_TAGVAR(archive_cmds, $1)=''
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+        _LT_TAGVAR(link_all_deplibs, $1)=yes
+        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+        if test "$GXX" = yes; then
+          case $host_os in aix4.[[012]]|aix4.[[012]].*)
+          # We only want to do this on AIX 4.2 and lower, the check
+          # below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	    # We have reworked collect2
+	    :
+	  else
+	    # We have old collect2
+	    _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	    # It fails to find uninstalled libraries when the uninstalled
+	    # path is not listed in the libpath.  Setting hardcode_minus_L
+	    # to unsupported forces relinking
+	    _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+          esac
+          shared_flag='-shared'
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag="$shared_flag "'${wl}-G'
+	  fi
+        else
+          # not using gcc
+          if test "$host_cpu" = ia64; then
+	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	  # chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+          else
+	    if test "$aix_use_runtimelinking" = yes; then
+	      shared_flag='${wl}-G'
+	    else
+	      shared_flag='${wl}-bM:SRE'
+	    fi
+          fi
+        fi
+
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+        # It seems that -bexpall does not export symbols beginning with
+        # underscore (_), so it is better to generate a list of symbols to
+	# export.
+        _LT_TAGVAR(always_export_symbols, $1)=yes
+        if test "$aix_use_runtimelinking" = yes; then
+          # Warning - without using the other runtime loading flags (-brtl),
+          # -berok will link without error, but may produce a broken library.
+          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+          # Determine the default libpath from the value encoded in an empty
+          # executable.
+          _LT_SYS_MODULE_PATH_AIX([$1])
+          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+        else
+          if test "$host_cpu" = ia64; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	    _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+          else
+	    # Determine the default libpath from the value encoded in an
+	    # empty executable.
+	    _LT_SYS_MODULE_PATH_AIX([$1])
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	    # Warning - without using the other run time loading flags,
+	    # -berok will link without error, but may produce a broken library.
+	    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	    if test "$with_gnu_ld" = yes; then
+	      # We only use this code for GNU lds that support --whole-archive.
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    else
+	      # Exported symbols can be pulled into shared objects from archives
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	    fi
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	    # This is similar to how AIX traditionally builds its shared
+	    # libraries.
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+          fi
+        fi
+        ;;
+
+      beos*)
+	if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	  # support --undefined.  This deserves some investigation.  FIXME
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      chorus*)
+        case $cc_basename in
+          *)
+	  # FIXME: insert proper C++ library support
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	  ;;
+        esac
+        ;;
+
+      cygwin* | mingw* | pw32* | cegcc*)
+	case $GXX,$cc_basename in
+	,cl* | no,cl*)
+	  # Native MSVC
+	  # hardcode_libdir_flag_spec is actually meaningless, as there is
+	  # no search path for DLLs.
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '
+	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	  _LT_TAGVAR(always_export_symbols, $1)=yes
+	  _LT_TAGVAR(file_list_spec, $1)='@'
+	  # Tell ltmain to make .lib files, not .a files.
+	  libext=lib
+	  # Tell ltmain to make .dll files, not .so files.
+	  shrext_cmds=".dll"
+	  # FIXME: Setting linknames here is a bad hack.
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	      $SED -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
+	    else
+	      $SED -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
+	    fi~
+	    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
+	    linknames='
+	  # The linker will not automatically build a static lib if we build a DLL.
+	  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
+	  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+	  # Don't use ranlib
+	  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'
+	  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile="@OUTPUT@"~
+	    lt_tool_outputfile="@TOOL_OUTPUT@"~
+	    case $lt_outputfile in
+	      *.exe|*.EXE) ;;
+	      *)
+		lt_outputfile="$lt_outputfile.exe"
+		lt_tool_outputfile="$lt_tool_outputfile.exe"
+		;;
+	    esac~
+	    func_to_tool_file "$lt_outputfile"~
+	    if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
+	      $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
+	      $RM "$lt_outputfile.manifest";
+	    fi'
+	  ;;
+	*)
+	  # g++
+	  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+	  # as there is no search path for DLLs.
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
+	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	  _LT_TAGVAR(always_export_symbols, $1)=no
+	  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+
+	  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	    # If the export-symbols file already is a .def file (1st line
+	    # is EXPORTS), use it as is; otherwise, prepend...
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	      cp $export_symbols $output_objdir/$soname.def;
+	    else
+	      echo EXPORTS > $output_objdir/$soname.def;
+	      cat $export_symbols >> $output_objdir/$soname.def;
+	    fi~
+	    $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	  else
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	  fi
+	  ;;
+	esac
+	;;
+      darwin* | rhapsody*)
+        _LT_DARWIN_LINKER_FEATURES($1)
+	;;
+
+      dgux*)
+        case $cc_basename in
+          ec++*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          ghcx*)
+	    # Green Hills C++ Compiler
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      freebsd2.*)
+        # C++ shared libraries reported to be fairly broken before
+	# switch to ELF
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      freebsd-elf*)
+        _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+        ;;
+
+      freebsd* | dragonfly*)
+        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
+        # conventions
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+        ;;
+
+      haiku*)
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        _LT_TAGVAR(link_all_deplibs, $1)=yes
+        ;;
+
+      hpux9*)
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+				             # but as the default
+				             # location of the library.
+
+        case $cc_basename in
+          CC*)
+            # FIXME: insert proper C++ library support
+            _LT_TAGVAR(ld_shlibs, $1)=no
+            ;;
+          aCC*)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            # Commands to make compiler produce verbose output that lists
+            # what "hidden" libraries, object files and flags are used when
+            # linking a shared library.
+            #
+            # There doesn't appear to be a way to prevent this compiler from
+            # explicitly linking system object files so we need to strip them
+            # from the output so that they don't get included in the library
+            # dependencies.
+            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+            ;;
+          *)
+            if test "$GXX" = yes; then
+              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            else
+              # FIXME: insert proper C++ library support
+              _LT_TAGVAR(ld_shlibs, $1)=no
+            fi
+            ;;
+        esac
+        ;;
+
+      hpux10*|hpux11*)
+        if test $with_gnu_ld = no; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+          case $host_cpu in
+            hppa*64*|ia64*)
+              ;;
+            *)
+	      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+              ;;
+          esac
+        fi
+        case $host_cpu in
+          hppa*64*|ia64*)
+            _LT_TAGVAR(hardcode_direct, $1)=no
+            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+            ;;
+          *)
+            _LT_TAGVAR(hardcode_direct, $1)=yes
+            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+					         # but as the default
+					         # location of the library.
+            ;;
+        esac
+
+        case $cc_basename in
+          CC*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          aCC*)
+	    case $host_cpu in
+	      hppa*64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      ia64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      *)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	    esac
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test $with_gnu_ld = no; then
+	        case $host_cpu in
+	          hppa*64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          ia64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          *)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	        esac
+	      fi
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      interix[[3-9]]*)
+	_LT_TAGVAR(hardcode_direct, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+	# Instead, shared libraries are loaded at an image base (0x10000000 by
+	# default) and relocated if they conflict, which is a slow very memory
+	# consuming and fragmenting process.  To avoid this, we pick a random,
+	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	;;
+      irix5* | irix6*)
+        case $cc_basename in
+          CC*)
+	    # SGI C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test "$with_gnu_ld" = no; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	      else
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` -o $lib'
+	      fi
+	    fi
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+	    ;;
+        esac
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(inherit_rpath, $1)=yes
+        ;;
+
+      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'
+	    ;;
+	  icpc* | ecpc* )
+	    # Intel C++
+	    with_gnu_ld=yes
+	    # version 8.0 and above of icpc choke on multiply defined symbols
+	    # if we add $predep_objects and $postdep_objects, however 7.1 and
+	    # earlier do not add the objects themselves.
+	    case `$CC -V 2>&1` in
+	      *"Version 7."*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	      *)  # Version 8.0 or newer
+	        tmp_idyn=
+	        case $host_cpu in
+		  ia64*) tmp_idyn=' -i_dynamic';;
+		esac
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	    esac
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    ;;
+          pgCC* | pgcpp*)
+            # Portland Group C++ compiler
+	    case `$CC -V` in
+	    *pgCC\ [[1-5]].* | *pgcpp\ [[1-5]].*)
+	      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
+		compile_command="$compile_command `find $tpldir -name \*.o | sort | $NL2SP`"'
+	      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
+		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | sort | $NL2SP`~
+		$RANLIB $oldlib'
+	      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    *) # Version 6 and above use weak symbols
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+            ;;
+	  cxx*)
+	    # Compaq C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+
+	    runpath_var=LD_RUN_PATH
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
+	    ;;
+	  xl* | mpixl* | bgxl*)
+	    # IBM XL 8.0 on PPC, with GNU ld
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    if test "x$supports_anon_versioning" = xyes; then
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+		echo "local: *; };" >> $output_objdir/$libname.ver~
+		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	    fi
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	      _LT_TAGVAR(compiler_needs_object, $1)=yes
+
+	      # Not sure whether something based on
+	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
+	      # would be better.
+	      output_verbose_link_cmd='func_echo_all'
+
+	      # Archives containing C++ object files must be created using
+	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	      # necessary to make sure instantiated templates are included
+	      # in the archive.
+	      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+
+      lynxos*)
+        # FIXME: insert proper C++ library support
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      m88k*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      mvs*)
+        case $cc_basename in
+          cxx*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	  *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	esac
+	;;
+
+      netbsd*)
+        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
+	  wlarc=
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	fi
+	# Workaround some broken pre-1.5 toolchains
+	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
+	;;
+
+      *nto* | *qnx*)
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+	;;
+
+      openbsd2*)
+        # C++ shared libraries are fairly broken
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      openbsd*)
+	if test -f /usr/libexec/ld.so; then
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+	  fi
+	  output_verbose_link_cmd=func_echo_all
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      osf3* | osf4* | osf5*)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Archives containing C++ object files must be created using
+	    # the KAI C++ compiler.
+	    case $host in
+	      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;
+	      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;
+	    esac
+	    ;;
+          RCC*)
+	    # Rational C++ 2.4.1
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          cxx*)
+	    case $host in
+	      osf3*)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && func_echo_all "${wl}-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+		;;
+	      *)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
+	          echo "-hidden">> $lib.exp~
+	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~
+	          $RM $lib.exp'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+		;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    ;;
+	  *)
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	      case $host in
+	        osf3*)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	        *)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	      esac
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	      # Commands to make compiler produce verbose output that lists
+	      # what "hidden" libraries, object files and flags are used when
+	      # linking a shared library.
+	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      psos*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      sunos4*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.x
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          lcc*)
+	    # Lucid
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      solaris*)
+        case $cc_basename in
+          CC* | sunCC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes
+	    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	    case $host_os in
+	      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+	      *)
+		# The compiler driver will combine and reorder linker options,
+		# but understands `-z linker_flag'.
+	        # Supported since Solaris 2.6 (maybe 2.5.1?)
+		_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	        ;;
+	    esac
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+
+	    output_verbose_link_cmd='func_echo_all'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	    ;;
+          gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+
+	    # The C++ compiler must be used to create the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    # GNU C++ compiler with Solaris linker
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'
+	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+	      else
+	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	        # platform.
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+	      fi
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'
+	      case $host_os in
+		solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+		*)
+		  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+		  ;;
+	      esac
+	    fi
+	    ;;
+        esac
+        ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      case $cc_basename in
+        CC*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+      esac
+      ;;
+
+      sysv5* | sco3.2v5* | sco5v6*)
+	# Note: We can NOT use -z defs as we might desire, because we do not
+	# link with -lc, and that would cause any symbols used from libc to
+	# always be unresolved, which means just about no library would
+	# ever link correctly.  If we're not using GNU ld we use -z text
+	# though, which does catch some bad symbols but isn't as heavy-handed
+	# as -z defs.
+	_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+	_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+	_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+	_LT_TAGVAR(link_all_deplibs, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+	runpath_var='LD_RUN_PATH'
+
+	case $cc_basename in
+          CC*)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~
+	      '"$_LT_TAGVAR(old_archive_cmds, $1)"
+	    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~
+	      '"$_LT_TAGVAR(reload_cmds, $1)"
+	    ;;
+	  *)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	esac
+      ;;
+
+      tandem*)
+        case $cc_basename in
+          NCC*)
+	    # NonStop-UX NCC 3.20
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      vxworks*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      *)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+    esac
+
+    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+    test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+    _LT_TAGVAR(GCC, $1)="$GXX"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  CC=$lt_save_CC
+  CFLAGS=$lt_save_CFLAGS
+  LDCXX=$LD
+  LD=$lt_save_LD
+  GCC=$lt_save_GCC
+  with_gnu_ld=$lt_save_with_gnu_ld
+  lt_cv_path_LDCXX=$lt_cv_path_LD
+  lt_cv_path_LD=$lt_save_path_LD
+  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
+  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
+fi # test "$_lt_caught_CXX_error" != yes
+
+AC_LANG_POP
+])# _LT_LANG_CXX_CONFIG
+
+
+# _LT_FUNC_STRIPNAME_CNF
+# ----------------------
+# func_stripname_cnf prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+#
+# This function is identical to the (non-XSI) version of func_stripname,
+# except this one can be used by m4 code that may be executed by configure,
+# rather than the libtool script.
+m4_defun([_LT_FUNC_STRIPNAME_CNF],[dnl
+AC_REQUIRE([_LT_DECL_SED])
+AC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])
+func_stripname_cnf ()
+{
+  case ${2} in
+  .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
+  *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
+  esac
+} # func_stripname_cnf
+])# _LT_FUNC_STRIPNAME_CNF
+
+# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])
+# ---------------------------------
+# Figure out "hidden" library dependencies from verbose
+# compiler output when linking a shared library.
+# Parse the compiler output and extract the necessary
+# objects, libraries and library flags.
+m4_defun([_LT_SYS_HIDDEN_LIBDEPS],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+AC_REQUIRE([_LT_FUNC_STRIPNAME_CNF])dnl
+# Dependencies to place before and after the object being linked:
+_LT_TAGVAR(predep_objects, $1)=
+_LT_TAGVAR(postdep_objects, $1)=
+_LT_TAGVAR(predeps, $1)=
+_LT_TAGVAR(postdeps, $1)=
+_LT_TAGVAR(compiler_lib_search_path, $1)=
+
+dnl we can't use the lt_simple_compile_test_code here,
+dnl because it contains code intended for an executable,
+dnl not a library.  It's possible we should let each
+dnl tag define a new lt_????_link_test_code variable,
+dnl but it's only used here...
+m4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF
+int a;
+void foo (void) { a = 0; }
+_LT_EOF
+], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF
+class Foo
+{
+public:
+  Foo (void) { a = 0; }
+private:
+  int a;
+};
+_LT_EOF
+], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer*4 a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF
+public class foo {
+  private int a;
+  public void bar (void) {
+    a = 0;
+  }
+};
+_LT_EOF
+], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF
+package foo
+func foo() {
+}
+_LT_EOF
+])
+
+_lt_libdeps_save_CFLAGS=$CFLAGS
+case "$CC $CFLAGS " in #(
+*\ -flto*\ *) CFLAGS="$CFLAGS -fno-lto" ;;
+*\ -fwhopr*\ *) CFLAGS="$CFLAGS -fno-whopr" ;;
+*\ -fuse-linker-plugin*\ *) CFLAGS="$CFLAGS -fno-use-linker-plugin" ;;
+esac
+
+dnl Parse the compiler output and extract the necessary
+dnl objects, libraries and library flags.
+if AC_TRY_EVAL(ac_compile); then
+  # Parse the compiler output and extract the necessary
+  # objects, libraries and library flags.
+
+  # Sentinel used to keep track of whether or not we are before
+  # the conftest object file.
+  pre_test_object_deps_done=no
+
+  for p in `eval "$output_verbose_link_cmd"`; do
+    case ${prev}${p} in
+
+    -L* | -R* | -l*)
+       # Some compilers place space between "-{L,R}" and the path.
+       # Remove the space.
+       if test $p = "-L" ||
+          test $p = "-R"; then
+	 prev=$p
+	 continue
+       fi
+
+       # Expand the sysroot to ease extracting the directories later.
+       if test -z "$prev"; then
+         case $p in
+         -L*) func_stripname_cnf '-L' '' "$p"; prev=-L; p=$func_stripname_result ;;
+         -R*) func_stripname_cnf '-R' '' "$p"; prev=-R; p=$func_stripname_result ;;
+         -l*) func_stripname_cnf '-l' '' "$p"; prev=-l; p=$func_stripname_result ;;
+         esac
+       fi
+       case $p in
+       =*) func_stripname_cnf '=' '' "$p"; p=$lt_sysroot$func_stripname_result ;;
+       esac
+       if test "$pre_test_object_deps_done" = no; then
+	 case ${prev} in
+	 -L | -R)
+	   # Internal compiler library paths should come after those
+	   # provided the user.  The postdeps already come after the
+	   # user supplied libs so there is no need to process them.
+	   if test -z "$_LT_TAGVAR(compiler_lib_search_path, $1)"; then
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${prev}${p}"
+	   else
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}"
+	   fi
+	   ;;
+	 # The "-l" case would never come before the object being
+	 # linked, so don't bother handling this case.
+	 esac
+       else
+	 if test -z "$_LT_TAGVAR(postdeps, $1)"; then
+	   _LT_TAGVAR(postdeps, $1)="${prev}${p}"
+	 else
+	   _LT_TAGVAR(postdeps, $1)="${_LT_TAGVAR(postdeps, $1)} ${prev}${p}"
+	 fi
+       fi
+       prev=
+       ;;
+
+    *.lto.$objext) ;; # Ignore GCC LTO objects
+    *.$objext)
+       # This assumes that the test object file only shows up
+       # once in the compiler output.
+       if test "$p" = "conftest.$objext"; then
+	 pre_test_object_deps_done=yes
+	 continue
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 if test -z "$_LT_TAGVAR(predep_objects, $1)"; then
+	   _LT_TAGVAR(predep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(predep_objects, $1)="$_LT_TAGVAR(predep_objects, $1) $p"
+	 fi
+       else
+	 if test -z "$_LT_TAGVAR(postdep_objects, $1)"; then
+	   _LT_TAGVAR(postdep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(postdep_objects, $1)="$_LT_TAGVAR(postdep_objects, $1) $p"
+	 fi
+       fi
+       ;;
+
+    *) ;; # Ignore the rest.
+
+    esac
+  done
+
+  # Clean up.
+  rm -f a.out a.exe
+else
+  echo "libtool.m4: error: problem compiling $1 test program"
+fi
+
+$RM -f confest.$objext
+CFLAGS=$_lt_libdeps_save_CFLAGS
+
+# PORTME: override above test on systems where it is broken
+m4_if([$1], [CXX],
+[case $host_os in
+interix[[3-9]]*)
+  # Interix 3.5 installs completely hosed .la files for C++, so rather than
+  # hack all around it, let's just trust "g++" to DTRT.
+  _LT_TAGVAR(predep_objects,$1)=
+  _LT_TAGVAR(postdep_objects,$1)=
+  _LT_TAGVAR(postdeps,$1)=
+  ;;
+
+linux*)
+  case `$CC -V 2>&1 | sed 5q` in
+  *Sun\ C*)
+    # Sun C++ 5.9
+
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+
+solaris*)
+  case $cc_basename in
+  CC* | sunCC*)
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    # Adding this requires a known-good setup of shared libraries for
+    # Sun compiler versions before 5.6, else PIC objects from an old
+    # archive will be linked into the output, leading to subtle bugs.
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+esac
+])
+
+case " $_LT_TAGVAR(postdeps, $1) " in
+*" -lc "*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;
+esac
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=
+if test -n "${_LT_TAGVAR(compiler_lib_search_path, $1)}"; then
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo " ${_LT_TAGVAR(compiler_lib_search_path, $1)}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
+fi
+_LT_TAGDECL([], [compiler_lib_search_dirs], [1],
+    [The directories searched by this compiler when creating a shared library])
+_LT_TAGDECL([], [predep_objects], [1],
+    [Dependencies to place before and after the objects being linked to
+    create a shared library])
+_LT_TAGDECL([], [postdep_objects], [1])
+_LT_TAGDECL([], [predeps], [1])
+_LT_TAGDECL([], [postdeps], [1])
+_LT_TAGDECL([], [compiler_lib_search_path], [1],
+    [The library search path used internally by the compiler when linking
+    a shared library])
+])# _LT_SYS_HIDDEN_LIBDEPS
+
+
+# _LT_LANG_F77_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a Fortran 77 compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_F77_CONFIG],
+[AC_LANG_PUSH(Fortran 77)
+if test -z "$F77" || test "X$F77" = "Xno"; then
+  _lt_disable_F77=yes
+fi
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for f77 test sources.
+ac_ext=f
+
+# Object file extension for compiled f77 test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the F77 compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_F77" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  lt_save_CFLAGS=$CFLAGS
+  CC=${F77-"f77"}
+  CFLAGS=$FFLAGS
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+  GCC=$G77
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$G77"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC="$lt_save_CC"
+  CFLAGS="$lt_save_CFLAGS"
+fi # test "$_lt_disable_F77" != yes
+
+AC_LANG_POP
+])# _LT_LANG_F77_CONFIG
+
+
+# _LT_LANG_FC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for a Fortran compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_FC_CONFIG],
+[AC_LANG_PUSH(Fortran)
+
+if test -z "$FC" || test "X$FC" = "Xno"; then
+  _lt_disable_FC=yes
+fi
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for fc test sources.
+ac_ext=${ac_fc_srcext-f}
+
+# Object file extension for compiled fc test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the FC compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_FC" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  lt_save_CFLAGS=$CFLAGS
+  CC=${FC-"f95"}
+  CFLAGS=$FCFLAGS
+  compiler=$CC
+  GCC=$ac_cv_fc_compiler_gnu
+
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$ac_cv_fc_compiler_gnu"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC=$lt_save_CC
+  CFLAGS=$lt_save_CFLAGS
+fi # test "$_lt_disable_FC" != yes
+
+AC_LANG_POP
+])# _LT_LANG_FC_CONFIG
+
+
+# _LT_LANG_GCJ_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for the GNU Java Compiler compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_GCJ_CONFIG],
+[AC_REQUIRE([LT_PROG_GCJ])dnl
+AC_LANG_SAVE
+
+# Source file extension for Java test sources.
+ac_ext=java
+
+# Object file extension for compiled Java test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="class foo {}"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC=$CC
+lt_save_CFLAGS=$CFLAGS
+lt_save_GCC=$GCC
+GCC=yes
+CC=${GCJ-"gcj"}
+CFLAGS=$GCJFLAGS
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_TAGVAR(LD, $1)="$LD"
+_LT_CC_BASENAME([$compiler])
+
+# GCJ did not exist at the time GCC didn't implicitly link libc in.
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+
+  _LT_CONFIG($1)
+fi
+
+AC_LANG_RESTORE
+
+GCC=$lt_save_GCC
+CC=$lt_save_CC
+CFLAGS=$lt_save_CFLAGS
+])# _LT_LANG_GCJ_CONFIG
+
+
+# _LT_LANG_GO_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for the GNU Go compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_GO_CONFIG],
+[AC_REQUIRE([LT_PROG_GO])dnl
+AC_LANG_SAVE
+
+# Source file extension for Go test sources.
+ac_ext=go
+
+# Object file extension for compiled Go test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="package main; func main() { }"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='package main; func main() { }'
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC=$CC
+lt_save_CFLAGS=$CFLAGS
+lt_save_GCC=$GCC
+GCC=yes
+CC=${GOC-"gccgo"}
+CFLAGS=$GOFLAGS
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_TAGVAR(LD, $1)="$LD"
+_LT_CC_BASENAME([$compiler])
+
+# Go did not exist at the time GCC didn't implicitly link libc in.
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+
+  _LT_CONFIG($1)
+fi
+
+AC_LANG_RESTORE
+
+GCC=$lt_save_GCC
+CC=$lt_save_CC
+CFLAGS=$lt_save_CFLAGS
+])# _LT_LANG_GO_CONFIG
+
+
+# _LT_LANG_RC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for the Windows resource compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_RC_CONFIG],
+[AC_REQUIRE([LT_PROG_RC])dnl
+AC_LANG_SAVE
+
+# Source file extension for RC test sources.
+ac_ext=rc
+
+# Object file extension for compiled RC test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code='sample MENU { MENUITEM "&Soup", 100, CHECKED }'
+
+# Code to be used in simple link tests
+lt_simple_link_test_code="$lt_simple_compile_test_code"
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+lt_save_CFLAGS=$CFLAGS
+lt_save_GCC=$GCC
+GCC=
+CC=${RC-"windres"}
+CFLAGS=
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_CC_BASENAME([$compiler])
+_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+
+if test -n "$compiler"; then
+  :
+  _LT_CONFIG($1)
+fi
+
+GCC=$lt_save_GCC
+AC_LANG_RESTORE
+CC=$lt_save_CC
+CFLAGS=$lt_save_CFLAGS
+])# _LT_LANG_RC_CONFIG
+
+
+# LT_PROG_GCJ
+# -----------
+AC_DEFUN([LT_PROG_GCJ],
+[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],
+  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],
+    [AC_CHECK_TOOL(GCJ, gcj,)
+      test "x${GCJFLAGS+set}" = xset || GCJFLAGS="-g -O2"
+      AC_SUBST(GCJFLAGS)])])[]dnl
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_GCJ], [])
+
+
+# LT_PROG_GO
+# ----------
+AC_DEFUN([LT_PROG_GO],
+[AC_CHECK_TOOL(GOC, gccgo,)
+])
+
+
+# LT_PROG_RC
+# ----------
+AC_DEFUN([LT_PROG_RC],
+[AC_CHECK_TOOL(RC, windres,)
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_RC], [])
+
+
+# _LT_DECL_EGREP
+# --------------
+# If we don't have a new enough Autoconf to choose the best grep
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_EGREP],
+[AC_REQUIRE([AC_PROG_EGREP])dnl
+AC_REQUIRE([AC_PROG_FGREP])dnl
+test -z "$GREP" && GREP=grep
+_LT_DECL([], [GREP], [1], [A grep program that handles long lines])
+_LT_DECL([], [EGREP], [1], [An ERE matcher])
+_LT_DECL([], [FGREP], [1], [A literal string matcher])
+dnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too
+AC_SUBST([GREP])
+])
+
+
+# _LT_DECL_OBJDUMP
+# --------------
+# If we don't have a new enough Autoconf to choose the best objdump
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_OBJDUMP],
+[AC_CHECK_TOOL(OBJDUMP, objdump, false)
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])
+AC_SUBST([OBJDUMP])
+])
+
+# _LT_DECL_DLLTOOL
+# ----------------
+# Ensure DLLTOOL variable is set.
+m4_defun([_LT_DECL_DLLTOOL],
+[AC_CHECK_TOOL(DLLTOOL, dlltool, false)
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+_LT_DECL([], [DLLTOOL], [1], [DLL creation program])
+AC_SUBST([DLLTOOL])
+])
+
+# _LT_DECL_SED
+# ------------
+# Check for a fully-functional sed program, that truncates
+# as few characters as possible.  Prefer GNU sed if found.
+m4_defun([_LT_DECL_SED],
+[AC_PROG_SED
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+_LT_DECL([], [SED], [1], [A sed program that does not truncate output])
+_LT_DECL([], [Xsed], ["\$SED -e 1s/^X//"],
+    [Sed that helps us avoid accidentally triggering echo(1) options like -n])
+])# _LT_DECL_SED
+
+m4_ifndef([AC_PROG_SED], [
+# NOTE: This macro has been submitted for inclusion into   #
+#  GNU Autoconf as AC_PROG_SED.  When it is available in   #
+#  a released version of Autoconf we should remove this    #
+#  macro and use it instead.                               #
+
+m4_defun([AC_PROG_SED],
+[AC_MSG_CHECKING([for a sed that does not truncate output])
+AC_CACHE_VAL(lt_cv_path_SED,
+[# Loop through the user's path and test for sed and gsed.
+# Then use that list of sed's as ones to test for truncation.
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for lt_ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      if $as_executable_p "$as_dir/$lt_ac_prog$ac_exec_ext"; then
+        lt_ac_sed_list="$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext"
+      fi
+    done
+  done
+done
+IFS=$as_save_IFS
+lt_ac_max=0
+lt_ac_count=0
+# Add /usr/xpg4/bin/sed as it is typically found on Solaris
+# along with /bin/sed that truncates output.
+for lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do
+  test ! -f $lt_ac_sed && continue
+  cat /dev/null > conftest.in
+  lt_ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >conftest.in
+  # Check for GNU sed and select it if it is found.
+  if "$lt_ac_sed" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then
+    lt_cv_path_SED=$lt_ac_sed
+    break
+  fi
+  while true; do
+    cat conftest.in conftest.in >conftest.tmp
+    mv conftest.tmp conftest.in
+    cp conftest.in conftest.nl
+    echo >>conftest.nl
+    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break
+    cmp -s conftest.out conftest.nl || break
+    # 10000 chars as input seems more than enough
+    test $lt_ac_count -gt 10 && break
+    lt_ac_count=`expr $lt_ac_count + 1`
+    if test $lt_ac_count -gt $lt_ac_max; then
+      lt_ac_max=$lt_ac_count
+      lt_cv_path_SED=$lt_ac_sed
+    fi
+  done
+done
+])
+SED=$lt_cv_path_SED
+AC_SUBST([SED])
+AC_MSG_RESULT([$SED])
+])#AC_PROG_SED
+])#m4_ifndef
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_SED], [])
+
+
+# _LT_CHECK_SHELL_FEATURES
+# ------------------------
+# Find out whether the shell is Bourne or XSI compatible,
+# or has some other useful features.
+m4_defun([_LT_CHECK_SHELL_FEATURES],
+[AC_MSG_CHECKING([whether the shell understands some XSI constructs])
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,b/c, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+AC_MSG_RESULT([$xsi_shell])
+_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])
+
+AC_MSG_CHECKING([whether the shell understands "+="])
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$[1]+=\$[2]" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+AC_MSG_RESULT([$lt_shell_append])
+_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+_LT_DECL([], [lt_unset], [0], [whether the shell understands "unset"])dnl
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl
+_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl
+])# _LT_CHECK_SHELL_FEATURES
+
+
+# _LT_PROG_FUNCTION_REPLACE (FUNCNAME, REPLACEMENT-BODY)
+# ------------------------------------------------------
+# In `$cfgfile', look for function FUNCNAME delimited by `^FUNCNAME ()$' and
+# '^} FUNCNAME ', and replace its body with REPLACEMENT-BODY.
+m4_defun([_LT_PROG_FUNCTION_REPLACE],
+[dnl {
+sed -e '/^$1 ()$/,/^} # $1 /c\
+$1 ()\
+{\
+m4_bpatsubsts([$2], [$], [\\], [^\([	 ]\)], [\\\1])
+} # Extended-shell $1 implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+])
+
+
+# _LT_PROG_REPLACE_SHELLFNS
+# -------------------------
+# Replace existing portable implementations of several shell functions with
+# equivalent extended shell implementations where those features are available..
+m4_defun([_LT_PROG_REPLACE_SHELLFNS],
+[if test x"$xsi_shell" = xyes; then
+  _LT_PROG_FUNCTION_REPLACE([func_dirname], [dnl
+    case ${1} in
+      */*) func_dirname_result="${1%/*}${2}" ;;
+      *  ) func_dirname_result="${3}" ;;
+    esac])
+
+  _LT_PROG_FUNCTION_REPLACE([func_basename], [dnl
+    func_basename_result="${1##*/}"])
+
+  _LT_PROG_FUNCTION_REPLACE([func_dirname_and_basename], [dnl
+    case ${1} in
+      */*) func_dirname_result="${1%/*}${2}" ;;
+      *  ) func_dirname_result="${3}" ;;
+    esac
+    func_basename_result="${1##*/}"])
+
+  _LT_PROG_FUNCTION_REPLACE([func_stripname], [dnl
+    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+    # positional parameters, so assign one to ordinary parameter first.
+    func_stripname_result=${3}
+    func_stripname_result=${func_stripname_result#"${1}"}
+    func_stripname_result=${func_stripname_result%"${2}"}])
+
+  _LT_PROG_FUNCTION_REPLACE([func_split_long_opt], [dnl
+    func_split_long_opt_name=${1%%=*}
+    func_split_long_opt_arg=${1#*=}])
+
+  _LT_PROG_FUNCTION_REPLACE([func_split_short_opt], [dnl
+    func_split_short_opt_arg=${1#??}
+    func_split_short_opt_name=${1%"$func_split_short_opt_arg"}])
+
+  _LT_PROG_FUNCTION_REPLACE([func_lo2o], [dnl
+    case ${1} in
+      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+      *)    func_lo2o_result=${1} ;;
+    esac])
+
+  _LT_PROG_FUNCTION_REPLACE([func_xform], [    func_xform_result=${1%.*}.lo])
+
+  _LT_PROG_FUNCTION_REPLACE([func_arith], [    func_arith_result=$(( $[*] ))])
+
+  _LT_PROG_FUNCTION_REPLACE([func_len], [    func_len_result=${#1}])
+fi
+
+if test x"$lt_shell_append" = xyes; then
+  _LT_PROG_FUNCTION_REPLACE([func_append], [    eval "${1}+=\\${2}"])
+
+  _LT_PROG_FUNCTION_REPLACE([func_append_quoted], [dnl
+    func_quote_for_eval "${2}"
+dnl m4 expansion turns \\\\ into \\, and then the shell eval turns that into \
+    eval "${1}+=\\\\ \\$func_quote_for_eval_result"])
+
+  # Save a `func_append' function call where possible by direct use of '+='
+  sed -e 's%func_append \([[a-zA-Z_]]\{1,\}\) "%\1+="%g' $cfgfile > $cfgfile.tmp \
+    && mv -f "$cfgfile.tmp" "$cfgfile" \
+      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+  test 0 -eq $? || _lt_function_replace_fail=:
+else
+  # Save a `func_append' function call even when '+=' is not available
+  sed -e 's%func_append \([[a-zA-Z_]]\{1,\}\) "%\1="$\1%g' $cfgfile > $cfgfile.tmp \
+    && mv -f "$cfgfile.tmp" "$cfgfile" \
+      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+  test 0 -eq $? || _lt_function_replace_fail=:
+fi
+
+if test x"$_lt_function_replace_fail" = x":"; then
+  AC_MSG_WARN([Unable to substitute extended shell functions in $ofile])
+fi
+])
+
+# _LT_PATH_CONVERSION_FUNCTIONS
+# -----------------------------
+# Determine which file name conversion functions should be used by
+# func_to_host_file (and, implicitly, by func_to_host_path).  These are needed
+# for certain cross-compile configurations and native mingw.
+m4_defun([_LT_PATH_CONVERSION_FUNCTIONS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+AC_MSG_CHECKING([how to convert $build file names to $host format])
+AC_CACHE_VAL(lt_cv_to_host_file_cmd,
+[case $host in
+  *-*-mingw* )
+    case $build in
+      *-*-mingw* ) # actually msys
+        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32
+        ;;
+      *-*-cygwin* )
+        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32
+        ;;
+      * ) # otherwise, assume *nix
+        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32
+        ;;
+    esac
+    ;;
+  *-*-cygwin* )
+    case $build in
+      *-*-mingw* ) # actually msys
+        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin
+        ;;
+      *-*-cygwin* )
+        lt_cv_to_host_file_cmd=func_convert_file_noop
+        ;;
+      * ) # otherwise, assume *nix
+        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin
+        ;;
+    esac
+    ;;
+  * ) # unhandled hosts (and "normal" native builds)
+    lt_cv_to_host_file_cmd=func_convert_file_noop
+    ;;
+esac
+])
+to_host_file_cmd=$lt_cv_to_host_file_cmd
+AC_MSG_RESULT([$lt_cv_to_host_file_cmd])
+_LT_DECL([to_host_file_cmd], [lt_cv_to_host_file_cmd],
+         [0], [convert $build file names to $host format])dnl
+
+AC_MSG_CHECKING([how to convert $build file names to toolchain format])
+AC_CACHE_VAL(lt_cv_to_tool_file_cmd,
+[#assume ordinary cross tools, or native build.
+lt_cv_to_tool_file_cmd=func_convert_file_noop
+case $host in
+  *-*-mingw* )
+    case $build in
+      *-*-mingw* ) # actually msys
+        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32
+        ;;
+    esac
+    ;;
+esac
+])
+to_tool_file_cmd=$lt_cv_to_tool_file_cmd
+AC_MSG_RESULT([$lt_cv_to_tool_file_cmd])
+_LT_DECL([to_tool_file_cmd], [lt_cv_to_tool_file_cmd],
+         [0], [convert $build files to toolchain format])dnl
+])# _LT_PATH_CONVERSION_FUNCTIONS
+
+# ltdl.m4 - Configure ltdl for the target system. -*-Autoconf-*-
+#
+#   Copyright (C) 1999-2006, 2007, 2008, 2011 Free Software Foundation, Inc.
+#   Written by Thomas Tanner, 1999
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 18 LTDL_INIT
+
+# LT_CONFIG_LTDL_DIR(DIRECTORY, [LTDL-MODE])
+# ------------------------------------------
+# DIRECTORY contains the libltdl sources.  It is okay to call this
+# function multiple times, as long as the same DIRECTORY is always given.
+AC_DEFUN([LT_CONFIG_LTDL_DIR],
+[AC_BEFORE([$0], [LTDL_INIT])
+_$0($*)
+])# LT_CONFIG_LTDL_DIR
+
+# We break this out into a separate macro, so that we can call it safely
+# internally without being caught accidentally by the sed scan in libtoolize.
+m4_defun([_LT_CONFIG_LTDL_DIR],
+[dnl remove trailing slashes
+m4_pushdef([_ARG_DIR], m4_bpatsubst([$1], [/*$]))
+m4_case(_LTDL_DIR,
+	[], [dnl only set lt_ltdl_dir if _ARG_DIR is not simply `.'
+	     m4_if(_ARG_DIR, [.],
+	             [],
+		 [m4_define([_LTDL_DIR], _ARG_DIR)
+	          _LT_SHELL_INIT([lt_ltdl_dir=']_ARG_DIR['])])],
+    [m4_if(_ARG_DIR, _LTDL_DIR,
+	    [],
+	[m4_fatal([multiple libltdl directories: `]_LTDL_DIR[', `]_ARG_DIR['])])])
+m4_popdef([_ARG_DIR])
+])# _LT_CONFIG_LTDL_DIR
+
+# Initialise:
+m4_define([_LTDL_DIR], [])
+
+
+# _LT_BUILD_PREFIX
+# ----------------
+# If Autoconf is new enough, expand to `${top_build_prefix}', otherwise
+# to `${top_builddir}/'.
+m4_define([_LT_BUILD_PREFIX],
+[m4_ifdef([AC_AUTOCONF_VERSION],
+   [m4_if(m4_version_compare(m4_defn([AC_AUTOCONF_VERSION]), [2.62]),
+	  [-1], [m4_ifdef([_AC_HAVE_TOP_BUILD_PREFIX],
+			  [${top_build_prefix}],
+			  [${top_builddir}/])],
+	  [${top_build_prefix}])],
+   [${top_builddir}/])[]dnl
+])
+
+
+# LTDL_CONVENIENCE
+# ----------------
+# sets LIBLTDL to the link flags for the libltdl convenience library and
+# LTDLINCL to the include flags for the libltdl header and adds
+# --enable-ltdl-convenience to the configure arguments.  Note that
+# AC_CONFIG_SUBDIRS is not called here.  LIBLTDL will be prefixed with
+# '${top_build_prefix}' if available, otherwise with '${top_builddir}/',
+# and LTDLINCL will be prefixed with '${top_srcdir}/' (note the single
+# quotes!).  If your package is not flat and you're not using automake,
+# define top_build_prefix, top_builddir, and top_srcdir appropriately
+# in your Makefiles.
+AC_DEFUN([LTDL_CONVENIENCE],
+[AC_BEFORE([$0], [LTDL_INIT])dnl
+dnl Although the argument is deprecated and no longer documented,
+dnl LTDL_CONVENIENCE used to take a DIRECTORY orgument, if we have one
+dnl here make sure it is the same as any other declaration of libltdl's
+dnl location!  This also ensures lt_ltdl_dir is set when configure.ac is
+dnl not yet using an explicit LT_CONFIG_LTDL_DIR.
+m4_ifval([$1], [_LT_CONFIG_LTDL_DIR([$1])])dnl
+_$0()
+])# LTDL_CONVENIENCE
+
+# AC_LIBLTDL_CONVENIENCE accepted a directory argument in older libtools,
+# now we have LT_CONFIG_LTDL_DIR:
+AU_DEFUN([AC_LIBLTDL_CONVENIENCE],
+[_LT_CONFIG_LTDL_DIR([m4_default([$1], [libltdl])])
+_LTDL_CONVENIENCE])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBLTDL_CONVENIENCE], [])
+
+
+# _LTDL_CONVENIENCE
+# -----------------
+# Code shared by LTDL_CONVENIENCE and LTDL_INIT([convenience]).
+m4_defun([_LTDL_CONVENIENCE],
+[case $enable_ltdl_convenience in
+  no) AC_MSG_ERROR([this package needs a convenience libltdl]) ;;
+  "") enable_ltdl_convenience=yes
+      ac_configure_args="$ac_configure_args --enable-ltdl-convenience" ;;
+esac
+LIBLTDL='_LT_BUILD_PREFIX'"${lt_ltdl_dir+$lt_ltdl_dir/}libltdlc.la"
+LTDLDEPS=$LIBLTDL
+LTDLINCL='-I${top_srcdir}'"${lt_ltdl_dir+/$lt_ltdl_dir}"
+
+AC_SUBST([LIBLTDL])
+AC_SUBST([LTDLDEPS])
+AC_SUBST([LTDLINCL])
+
+# For backwards non-gettext consistent compatibility...
+INCLTDL="$LTDLINCL"
+AC_SUBST([INCLTDL])
+])# _LTDL_CONVENIENCE
+
+
+# LTDL_INSTALLABLE
+# ----------------
+# sets LIBLTDL to the link flags for the libltdl installable library
+# and LTDLINCL to the include flags for the libltdl header and adds
+# --enable-ltdl-install to the configure arguments.  Note that
+# AC_CONFIG_SUBDIRS is not called from here.  If an installed libltdl
+# is not found, LIBLTDL will be prefixed with '${top_build_prefix}' if
+# available, otherwise with '${top_builddir}/', and LTDLINCL will be
+# prefixed with '${top_srcdir}/' (note the single quotes!).  If your
+# package is not flat and you're not using automake, define top_build_prefix,
+# top_builddir, and top_srcdir appropriately in your Makefiles.
+# In the future, this macro may have to be called after LT_INIT.
+AC_DEFUN([LTDL_INSTALLABLE],
+[AC_BEFORE([$0], [LTDL_INIT])dnl
+dnl Although the argument is deprecated and no longer documented,
+dnl LTDL_INSTALLABLE used to take a DIRECTORY orgument, if we have one
+dnl here make sure it is the same as any other declaration of libltdl's
+dnl location!  This also ensures lt_ltdl_dir is set when configure.ac is
+dnl not yet using an explicit LT_CONFIG_LTDL_DIR.
+m4_ifval([$1], [_LT_CONFIG_LTDL_DIR([$1])])dnl
+_$0()
+])# LTDL_INSTALLABLE
+
+# AC_LIBLTDL_INSTALLABLE accepted a directory argument in older libtools,
+# now we have LT_CONFIG_LTDL_DIR:
+AU_DEFUN([AC_LIBLTDL_INSTALLABLE],
+[_LT_CONFIG_LTDL_DIR([m4_default([$1], [libltdl])])
+_LTDL_INSTALLABLE])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBLTDL_INSTALLABLE], [])
+
+
+# _LTDL_INSTALLABLE
+# -----------------
+# Code shared by LTDL_INSTALLABLE and LTDL_INIT([installable]).
+m4_defun([_LTDL_INSTALLABLE],
+[if test -f $prefix/lib/libltdl.la; then
+  lt_save_LDFLAGS="$LDFLAGS"
+  LDFLAGS="-L$prefix/lib $LDFLAGS"
+  AC_CHECK_LIB([ltdl], [lt_dlinit], [lt_lib_ltdl=yes])
+  LDFLAGS="$lt_save_LDFLAGS"
+  if test x"${lt_lib_ltdl-no}" = xyes; then
+    if test x"$enable_ltdl_install" != xyes; then
+      # Don't overwrite $prefix/lib/libltdl.la without --enable-ltdl-install
+      AC_MSG_WARN([not overwriting libltdl at $prefix, force with `--enable-ltdl-install'])
+      enable_ltdl_install=no
+    fi
+  elif test x"$enable_ltdl_install" = xno; then
+    AC_MSG_WARN([libltdl not installed, but installation disabled])
+  fi
+fi
+
+# If configure.ac declared an installable ltdl, and the user didn't override
+# with --disable-ltdl-install, we will install the shipped libltdl.
+case $enable_ltdl_install in
+  no) ac_configure_args="$ac_configure_args --enable-ltdl-install=no"
+      LIBLTDL="-lltdl"
+      LTDLDEPS=
+      LTDLINCL=
+      ;;
+  *)  enable_ltdl_install=yes
+      ac_configure_args="$ac_configure_args --enable-ltdl-install"
+      LIBLTDL='_LT_BUILD_PREFIX'"${lt_ltdl_dir+$lt_ltdl_dir/}libltdl.la"
+      LTDLDEPS=$LIBLTDL
+      LTDLINCL='-I${top_srcdir}'"${lt_ltdl_dir+/$lt_ltdl_dir}"
+      ;;
+esac
+
+AC_SUBST([LIBLTDL])
+AC_SUBST([LTDLDEPS])
+AC_SUBST([LTDLINCL])
+
+# For backwards non-gettext consistent compatibility...
+INCLTDL="$LTDLINCL"
+AC_SUBST([INCLTDL])
+])# LTDL_INSTALLABLE
+
+
+# _LTDL_MODE_DISPATCH
+# -------------------
+m4_define([_LTDL_MODE_DISPATCH],
+[dnl If _LTDL_DIR is `.', then we are configuring libltdl itself:
+m4_if(_LTDL_DIR, [],
+	[],
+    dnl if _LTDL_MODE was not set already, the default value is `subproject':
+    [m4_case(m4_default(_LTDL_MODE, [subproject]),
+	  [subproject], [AC_CONFIG_SUBDIRS(_LTDL_DIR)
+			  _LT_SHELL_INIT([lt_dlopen_dir="$lt_ltdl_dir"])],
+	  [nonrecursive], [_LT_SHELL_INIT([lt_dlopen_dir="$lt_ltdl_dir"; lt_libobj_prefix="$lt_ltdl_dir/"])],
+	  [recursive], [],
+	[m4_fatal([unknown libltdl mode: ]_LTDL_MODE)])])dnl
+dnl Be careful not to expand twice:
+m4_define([$0], [])
+])# _LTDL_MODE_DISPATCH
+
+
+# _LT_LIBOBJ(MODULE_NAME)
+# -----------------------
+# Like AC_LIBOBJ, except that MODULE_NAME goes into _LT_LIBOBJS instead
+# of into LIBOBJS.
+AC_DEFUN([_LT_LIBOBJ], [
+  m4_pattern_allow([^_LT_LIBOBJS$])
+  _LT_LIBOBJS="$_LT_LIBOBJS $1.$ac_objext"
+])# _LT_LIBOBJS
+
+
+# LTDL_INIT([OPTIONS])
+# --------------------
+# Clients of libltdl can use this macro to allow the installer to
+# choose between a shipped copy of the ltdl sources or a preinstalled
+# version of the library.  If the shipped ltdl sources are not in a
+# subdirectory named libltdl, the directory name must be given by
+# LT_CONFIG_LTDL_DIR.
+AC_DEFUN([LTDL_INIT],
+[dnl Parse OPTIONS
+_LT_SET_OPTIONS([$0], [$1])
+
+dnl We need to keep our own list of libobjs separate from our parent project,
+dnl and the easiest way to do that is redefine the AC_LIBOBJs macro while
+dnl we look for our own LIBOBJs.
+m4_pushdef([AC_LIBOBJ], m4_defn([_LT_LIBOBJ]))
+m4_pushdef([AC_LIBSOURCES])
+
+dnl If not otherwise defined, default to the 1.5.x compatible subproject mode:
+m4_if(_LTDL_MODE, [],
+        [m4_define([_LTDL_MODE], m4_default([$2], [subproject]))
+        m4_if([-1], [m4_bregexp(_LTDL_MODE, [\(subproject\|\(non\)?recursive\)])],
+                [m4_fatal([unknown libltdl mode: ]_LTDL_MODE)])])
+
+AC_ARG_WITH([included_ltdl],
+    [AS_HELP_STRING([--with-included-ltdl],
+                    [use the GNU ltdl sources included here])])
+
+if test "x$with_included_ltdl" != xyes; then
+  # We are not being forced to use the included libltdl sources, so
+  # decide whether there is a useful installed version we can use.
+  AC_CHECK_HEADER([ltdl.h],
+      [AC_CHECK_DECL([lt_dlinterface_register],
+	   [AC_CHECK_LIB([ltdl], [lt_dladvise_preload],
+	       [with_included_ltdl=no],
+	       [with_included_ltdl=yes])],
+	   [with_included_ltdl=yes],
+	   [AC_INCLUDES_DEFAULT
+	    #include <ltdl.h>])],
+      [with_included_ltdl=yes],
+      [AC_INCLUDES_DEFAULT]
+  )
+fi
+
+dnl If neither LT_CONFIG_LTDL_DIR, LTDL_CONVENIENCE nor LTDL_INSTALLABLE
+dnl was called yet, then for old times' sake, we assume libltdl is in an
+dnl eponymous directory:
+AC_PROVIDE_IFELSE([LT_CONFIG_LTDL_DIR], [], [_LT_CONFIG_LTDL_DIR([libltdl])])
+
+AC_ARG_WITH([ltdl_include],
+    [AS_HELP_STRING([--with-ltdl-include=DIR],
+                    [use the ltdl headers installed in DIR])])
+
+if test -n "$with_ltdl_include"; then
+  if test -f "$with_ltdl_include/ltdl.h"; then :
+  else
+    AC_MSG_ERROR([invalid ltdl include directory: `$with_ltdl_include'])
+  fi
+else
+  with_ltdl_include=no
+fi
+
+AC_ARG_WITH([ltdl_lib],
+    [AS_HELP_STRING([--with-ltdl-lib=DIR],
+                    [use the libltdl.la installed in DIR])])
+
+if test -n "$with_ltdl_lib"; then
+  if test -f "$with_ltdl_lib/libltdl.la"; then :
+  else
+    AC_MSG_ERROR([invalid ltdl library directory: `$with_ltdl_lib'])
+  fi
+else
+  with_ltdl_lib=no
+fi
+
+case ,$with_included_ltdl,$with_ltdl_include,$with_ltdl_lib, in
+  ,yes,no,no,)
+	m4_case(m4_default(_LTDL_TYPE, [convenience]),
+	    [convenience], [_LTDL_CONVENIENCE],
+	    [installable], [_LTDL_INSTALLABLE],
+	  [m4_fatal([unknown libltdl build type: ]_LTDL_TYPE)])
+	;;
+  ,no,no,no,)
+	# If the included ltdl is not to be used, then use the
+	# preinstalled libltdl we found.
+	AC_DEFINE([HAVE_LTDL], [1],
+	  [Define this if a modern libltdl is already installed])
+	LIBLTDL=-lltdl
+	LTDLDEPS=
+	LTDLINCL=
+	;;
+  ,no*,no,*)
+	AC_MSG_ERROR([`--with-ltdl-include' and `--with-ltdl-lib' options must be used together])
+	;;
+  *)	with_included_ltdl=no
+	LIBLTDL="-L$with_ltdl_lib -lltdl"
+	LTDLDEPS=
+	LTDLINCL="-I$with_ltdl_include"
+	;;
+esac
+INCLTDL="$LTDLINCL"
+
+# Report our decision...
+AC_MSG_CHECKING([where to find libltdl headers])
+AC_MSG_RESULT([$LTDLINCL])
+AC_MSG_CHECKING([where to find libltdl library])
+AC_MSG_RESULT([$LIBLTDL])
+
+_LTDL_SETUP
+
+dnl restore autoconf definition.
+m4_popdef([AC_LIBOBJ])
+m4_popdef([AC_LIBSOURCES])
+
+AC_CONFIG_COMMANDS_PRE([
+    _ltdl_libobjs=
+    _ltdl_ltlibobjs=
+    if test -n "$_LT_LIBOBJS"; then
+      # Remove the extension.
+      _lt_sed_drop_objext='s/\.o$//;s/\.obj$//'
+      for i in `for i in $_LT_LIBOBJS; do echo "$i"; done | sed "$_lt_sed_drop_objext" | sort -u`; do
+        _ltdl_libobjs="$_ltdl_libobjs $lt_libobj_prefix$i.$ac_objext"
+        _ltdl_ltlibobjs="$_ltdl_ltlibobjs $lt_libobj_prefix$i.lo"
+      done
+    fi
+    AC_SUBST([ltdl_LIBOBJS], [$_ltdl_libobjs])
+    AC_SUBST([ltdl_LTLIBOBJS], [$_ltdl_ltlibobjs])
+])
+
+# Only expand once:
+m4_define([LTDL_INIT])
+])# LTDL_INIT
+
+# Old names:
+AU_DEFUN([AC_LIB_LTDL], [LTDL_INIT($@)])
+AU_DEFUN([AC_WITH_LTDL], [LTDL_INIT($@)])
+AU_DEFUN([LT_WITH_LTDL], [LTDL_INIT($@)])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIB_LTDL], [])
+dnl AC_DEFUN([AC_WITH_LTDL], [])
+dnl AC_DEFUN([LT_WITH_LTDL], [])
+
+
+# _LTDL_SETUP
+# -----------
+# Perform all the checks necessary for compilation of the ltdl objects
+#  -- including compiler checks and header checks.  This is a public
+# interface  mainly for the benefit of libltdl's own configure.ac, most
+# other users should call LTDL_INIT instead.
+AC_DEFUN([_LTDL_SETUP],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_SYS_MODULE_EXT])dnl
+AC_REQUIRE([LT_SYS_MODULE_PATH])dnl
+AC_REQUIRE([LT_SYS_DLSEARCH_PATH])dnl
+AC_REQUIRE([LT_LIB_DLLOAD])dnl
+AC_REQUIRE([LT_SYS_SYMBOL_USCORE])dnl
+AC_REQUIRE([LT_FUNC_DLSYM_USCORE])dnl
+AC_REQUIRE([LT_SYS_DLOPEN_DEPLIBS])dnl
+AC_REQUIRE([gl_FUNC_ARGZ])dnl
+
+m4_require([_LT_CHECK_OBJDIR])dnl
+m4_require([_LT_HEADER_DLFCN])dnl
+m4_require([_LT_CHECK_DLPREOPEN])dnl
+m4_require([_LT_DECL_SED])dnl
+
+dnl Don't require this, or it will be expanded earlier than the code
+dnl that sets the variables it relies on:
+_LT_ENABLE_INSTALL
+
+dnl _LTDL_MODE specific code must be called at least once:
+_LTDL_MODE_DISPATCH
+
+# In order that ltdl.c can compile, find out the first AC_CONFIG_HEADERS
+# the user used.  This is so that ltdl.h can pick up the parent projects
+# config.h file, The first file in AC_CONFIG_HEADERS must contain the
+# definitions required by ltdl.c.
+# FIXME: Remove use of undocumented AC_LIST_HEADERS (2.59 compatibility).
+AC_CONFIG_COMMANDS_PRE([dnl
+m4_pattern_allow([^LT_CONFIG_H$])dnl
+m4_ifset([AH_HEADER],
+    [LT_CONFIG_H=AH_HEADER],
+    [m4_ifset([AC_LIST_HEADERS],
+	    [LT_CONFIG_H=`echo "AC_LIST_HEADERS" | $SED 's,^[[      ]]*,,;s,[[ :]].*$,,'`],
+	[])])])
+AC_SUBST([LT_CONFIG_H])
+
+AC_CHECK_HEADERS([unistd.h dl.h sys/dl.h dld.h mach-o/dyld.h dirent.h],
+	[], [], [AC_INCLUDES_DEFAULT])
+
+AC_CHECK_FUNCS([closedir opendir readdir], [], [AC_LIBOBJ([lt__dirent])])
+AC_CHECK_FUNCS([strlcat strlcpy], [], [AC_LIBOBJ([lt__strl])])
+
+m4_pattern_allow([LT_LIBEXT])dnl
+AC_DEFINE_UNQUOTED([LT_LIBEXT],["$libext"],[The archive extension])
+
+name=
+eval "lt_libprefix=\"$libname_spec\""
+m4_pattern_allow([LT_LIBPREFIX])dnl
+AC_DEFINE_UNQUOTED([LT_LIBPREFIX],["$lt_libprefix"],[The archive prefix])
+
+name=ltdl
+eval "LTDLOPEN=\"$libname_spec\""
+AC_SUBST([LTDLOPEN])
+])# _LTDL_SETUP
+
+
+# _LT_ENABLE_INSTALL
+# ------------------
+m4_define([_LT_ENABLE_INSTALL],
+[AC_ARG_ENABLE([ltdl-install],
+    [AS_HELP_STRING([--enable-ltdl-install], [install libltdl])])
+
+case ,${enable_ltdl_install},${enable_ltdl_convenience} in
+  *yes*) ;;
+  *) enable_ltdl_convenience=yes ;;
+esac
+
+m4_ifdef([AM_CONDITIONAL],
+[AM_CONDITIONAL(INSTALL_LTDL, test x"${enable_ltdl_install-no}" != xno)
+ AM_CONDITIONAL(CONVENIENCE_LTDL, test x"${enable_ltdl_convenience-no}" != xno)])
+])# _LT_ENABLE_INSTALL
+
+
+# LT_SYS_DLOPEN_DEPLIBS
+# ---------------------
+AC_DEFUN([LT_SYS_DLOPEN_DEPLIBS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_CACHE_CHECK([whether deplibs are loaded by dlopen],
+  [lt_cv_sys_dlopen_deplibs],
+  [# PORTME does your system automatically load deplibs for dlopen?
+  # or its logical equivalent (e.g. shl_load for HP-UX < 11)
+  # For now, we just catch OSes we know something about -- in the
+  # future, we'll try test this programmatically.
+  lt_cv_sys_dlopen_deplibs=unknown
+  case $host_os in
+  aix3*|aix4.1.*|aix4.2.*)
+    # Unknown whether this is true for these versions of AIX, but
+    # we want this `case' here to explicitly catch those versions.
+    lt_cv_sys_dlopen_deplibs=unknown
+    ;;
+  aix[[4-9]]*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  amigaos*)
+    case $host_cpu in
+    powerpc)
+      lt_cv_sys_dlopen_deplibs=no
+      ;;
+    esac
+    ;;
+  darwin*)
+    # Assuming the user has installed a libdl from somewhere, this is true
+    # If you are looking for one http://www.opendarwin.org/projects/dlcompat
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  freebsd* | dragonfly*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  gnu* | linux* | k*bsd*-gnu | kopensolaris*-gnu)
+    # GNU and its variants, using gnu ld.so (Glibc)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  hpux10*|hpux11*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  interix*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  irix[[12345]]*|irix6.[[01]]*)
+    # Catch all versions of IRIX before 6.2, and indicate that we don't
+    # know how it worked for any of those versions.
+    lt_cv_sys_dlopen_deplibs=unknown
+    ;;
+  irix*)
+    # The case above catches anything before 6.2, and it's known that
+    # at 6.2 and later dlopen does load deplibs.
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  netbsd* | netbsdelf*-gnu)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  openbsd*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  osf[[1234]]*)
+    # dlopen did load deplibs (at least at 4.x), but until the 5.x series,
+    # it did *not* use an RPATH in a shared library to find objects the
+    # library depends on, so we explicitly say `no'.
+    lt_cv_sys_dlopen_deplibs=no
+    ;;
+  osf5.0|osf5.0a|osf5.1)
+    # dlopen *does* load deplibs and with the right loader patch applied
+    # it even uses RPATH in a shared library to search for shared objects
+    # that the library depends on, but there's no easy way to know if that
+    # patch is installed.  Since this is the case, all we can really
+    # say is unknown -- it depends on the patch being installed.  If
+    # it is, this changes to `yes'.  Without it, it would be `no'.
+    lt_cv_sys_dlopen_deplibs=unknown
+    ;;
+  osf*)
+    # the two cases above should catch all versions of osf <= 5.1.  Read
+    # the comments above for what we know about them.
+    # At > 5.1, deplibs are loaded *and* any RPATH in a shared library
+    # is used to find them so we can finally say `yes'.
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  qnx*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  solaris*)
+    lt_cv_sys_dlopen_deplibs=yes
+    ;;
+  sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+    libltdl_cv_sys_dlopen_deplibs=yes
+    ;;
+  esac
+  ])
+if test "$lt_cv_sys_dlopen_deplibs" != yes; then
+ AC_DEFINE([LTDL_DLOPEN_DEPLIBS], [1],
+    [Define if the OS needs help to load dependent libraries for dlopen().])
+fi
+])# LT_SYS_DLOPEN_DEPLIBS
+
+# Old name:
+AU_ALIAS([AC_LTDL_SYS_DLOPEN_DEPLIBS], [LT_SYS_DLOPEN_DEPLIBS])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SYS_DLOPEN_DEPLIBS], [])
+
+
+# LT_SYS_MODULE_EXT
+# -----------------
+AC_DEFUN([LT_SYS_MODULE_EXT],
+[m4_require([_LT_SYS_DYNAMIC_LINKER])dnl
+AC_CACHE_CHECK([which extension is used for runtime loadable modules],
+  [libltdl_cv_shlibext],
+[
+module=yes
+eval libltdl_cv_shlibext=$shrext_cmds
+module=no
+eval libltdl_cv_shrext=$shrext_cmds
+  ])
+if test -n "$libltdl_cv_shlibext"; then
+  m4_pattern_allow([LT_MODULE_EXT])dnl
+  AC_DEFINE_UNQUOTED([LT_MODULE_EXT], ["$libltdl_cv_shlibext"],
+    [Define to the extension used for runtime loadable modules, say, ".so".])
+fi
+if test "$libltdl_cv_shrext" != "$libltdl_cv_shlibext"; then
+  m4_pattern_allow([LT_SHARED_EXT])dnl
+  AC_DEFINE_UNQUOTED([LT_SHARED_EXT], ["$libltdl_cv_shrext"],
+    [Define to the shared library suffix, say, ".dylib".])
+fi
+])# LT_SYS_MODULE_EXT
+
+# Old name:
+AU_ALIAS([AC_LTDL_SHLIBEXT], [LT_SYS_MODULE_EXT])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SHLIBEXT], [])
+
+
+# LT_SYS_MODULE_PATH
+# ------------------
+AC_DEFUN([LT_SYS_MODULE_PATH],
+[m4_require([_LT_SYS_DYNAMIC_LINKER])dnl
+AC_CACHE_CHECK([which variable specifies run-time module search path],
+  [lt_cv_module_path_var], [lt_cv_module_path_var="$shlibpath_var"])
+if test -n "$lt_cv_module_path_var"; then
+  m4_pattern_allow([LT_MODULE_PATH_VAR])dnl
+  AC_DEFINE_UNQUOTED([LT_MODULE_PATH_VAR], ["$lt_cv_module_path_var"],
+    [Define to the name of the environment variable that determines the run-time module search path.])
+fi
+])# LT_SYS_MODULE_PATH
+
+# Old name:
+AU_ALIAS([AC_LTDL_SHLIBPATH], [LT_SYS_MODULE_PATH])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SHLIBPATH], [])
+
+
+# LT_SYS_DLSEARCH_PATH
+# --------------------
+AC_DEFUN([LT_SYS_DLSEARCH_PATH],
+[m4_require([_LT_SYS_DYNAMIC_LINKER])dnl
+AC_CACHE_CHECK([for the default library search path],
+  [lt_cv_sys_dlsearch_path],
+  [lt_cv_sys_dlsearch_path="$sys_lib_dlsearch_path_spec"])
+if test -n "$lt_cv_sys_dlsearch_path"; then
+  sys_dlsearch_path=
+  for dir in $lt_cv_sys_dlsearch_path; do
+    if test -z "$sys_dlsearch_path"; then
+      sys_dlsearch_path="$dir"
+    else
+      sys_dlsearch_path="$sys_dlsearch_path$PATH_SEPARATOR$dir"
+    fi
+  done
+  m4_pattern_allow([LT_DLSEARCH_PATH])dnl
+  AC_DEFINE_UNQUOTED([LT_DLSEARCH_PATH], ["$sys_dlsearch_path"],
+    [Define to the system default library search path.])
+fi
+])# LT_SYS_DLSEARCH_PATH
+
+# Old name:
+AU_ALIAS([AC_LTDL_SYSSEARCHPATH], [LT_SYS_DLSEARCH_PATH])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SYSSEARCHPATH], [])
+
+
+# _LT_CHECK_DLPREOPEN
+# -------------------
+m4_defun([_LT_CHECK_DLPREOPEN],
+[m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+AC_CACHE_CHECK([whether libtool supports -dlopen/-dlpreopen],
+  [libltdl_cv_preloaded_symbols],
+  [if test -n "$lt_cv_sys_global_symbol_pipe"; then
+    libltdl_cv_preloaded_symbols=yes
+  else
+    libltdl_cv_preloaded_symbols=no
+  fi
+  ])
+if test x"$libltdl_cv_preloaded_symbols" = xyes; then
+  AC_DEFINE([HAVE_PRELOADED_SYMBOLS], [1],
+    [Define if libtool can extract symbol lists from object files.])
+fi
+])# _LT_CHECK_DLPREOPEN
+
+
+# LT_LIB_DLLOAD
+# -------------
+AC_DEFUN([LT_LIB_DLLOAD],
+[m4_pattern_allow([^LT_DLLOADERS$])
+LT_DLLOADERS=
+AC_SUBST([LT_DLLOADERS])
+
+AC_LANG_PUSH([C])
+
+LIBADD_DLOPEN=
+AC_SEARCH_LIBS([dlopen], [dl],
+	[AC_DEFINE([HAVE_LIBDL], [1],
+		   [Define if you have the libdl library or equivalent.])
+	if test "$ac_cv_search_dlopen" != "none required" ; then
+	  LIBADD_DLOPEN="-ldl"
+	fi
+	libltdl_cv_lib_dl_dlopen="yes"
+	LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dlopen.la"],
+    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#if HAVE_DLFCN_H
+#  include <dlfcn.h>
+#endif
+    ]], [[dlopen(0, 0);]])],
+	    [AC_DEFINE([HAVE_LIBDL], [1],
+		       [Define if you have the libdl library or equivalent.])
+	    libltdl_cv_func_dlopen="yes"
+	    LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dlopen.la"],
+	[AC_CHECK_LIB([svld], [dlopen],
+		[AC_DEFINE([HAVE_LIBDL], [1],
+			 [Define if you have the libdl library or equivalent.])
+	        LIBADD_DLOPEN="-lsvld" libltdl_cv_func_dlopen="yes"
+		LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dlopen.la"])])])
+if test x"$libltdl_cv_func_dlopen" = xyes || test x"$libltdl_cv_lib_dl_dlopen" = xyes
+then
+  lt_save_LIBS="$LIBS"
+  LIBS="$LIBS $LIBADD_DLOPEN"
+  AC_CHECK_FUNCS([dlerror])
+  LIBS="$lt_save_LIBS"
+fi
+AC_SUBST([LIBADD_DLOPEN])
+
+LIBADD_SHL_LOAD=
+AC_CHECK_FUNC([shl_load],
+	[AC_DEFINE([HAVE_SHL_LOAD], [1],
+		   [Define if you have the shl_load function.])
+	LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}shl_load.la"],
+    [AC_CHECK_LIB([dld], [shl_load],
+	    [AC_DEFINE([HAVE_SHL_LOAD], [1],
+		       [Define if you have the shl_load function.])
+	    LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}shl_load.la"
+	    LIBADD_SHL_LOAD="-ldld"])])
+AC_SUBST([LIBADD_SHL_LOAD])
+
+case $host_os in
+darwin[[1567]].*)
+# We only want this for pre-Mac OS X 10.4.
+  AC_CHECK_FUNC([_dyld_func_lookup],
+	[AC_DEFINE([HAVE_DYLD], [1],
+		   [Define if you have the _dyld_func_lookup function.])
+	LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dyld.la"])
+  ;;
+beos*)
+  LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}load_add_on.la"
+  ;;
+cygwin* | mingw* | os2* | pw32*)
+  AC_CHECK_DECLS([cygwin_conv_path], [], [], [[#include <sys/cygwin.h>]])
+  LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}loadlibrary.la"
+  ;;
+esac
+
+AC_CHECK_LIB([dld], [dld_link],
+	[AC_DEFINE([HAVE_DLD], [1],
+		   [Define if you have the GNU dld library.])
+		LT_DLLOADERS="$LT_DLLOADERS ${lt_dlopen_dir+$lt_dlopen_dir/}dld_link.la"])
+AC_SUBST([LIBADD_DLD_LINK])
+
+m4_pattern_allow([^LT_DLPREOPEN$])
+LT_DLPREOPEN=
+if test -n "$LT_DLLOADERS"
+then
+  for lt_loader in $LT_DLLOADERS; do
+    LT_DLPREOPEN="$LT_DLPREOPEN-dlpreopen $lt_loader "
+  done
+  AC_DEFINE([HAVE_LIBDLLOADER], [1],
+            [Define if libdlloader will be built on this platform])
+fi
+AC_SUBST([LT_DLPREOPEN])
+
+dnl This isn't used anymore, but set it for backwards compatibility
+LIBADD_DL="$LIBADD_DLOPEN $LIBADD_SHL_LOAD"
+AC_SUBST([LIBADD_DL])
+
+AC_LANG_POP
+])# LT_LIB_DLLOAD
+
+# Old name:
+AU_ALIAS([AC_LTDL_DLLIB], [LT_LIB_DLLOAD])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_DLLIB], [])
+
+
+# LT_SYS_SYMBOL_USCORE
+# --------------------
+# does the compiler prefix global symbols with an underscore?
+AC_DEFUN([LT_SYS_SYMBOL_USCORE],
+[m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+AC_CACHE_CHECK([for _ prefix in compiled symbols],
+  [lt_cv_sys_symbol_underscore],
+  [lt_cv_sys_symbol_underscore=no
+  cat > conftest.$ac_ext <<_LT_EOF
+void nm_test_func(){}
+int main(){nm_test_func;return 0;}
+_LT_EOF
+  if AC_TRY_EVAL(ac_compile); then
+    # Now try to grab the symbols.
+    ac_nlist=conftest.nm
+    if AC_TRY_EVAL(NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $ac_nlist) && test -s "$ac_nlist"; then
+      # See whether the symbols have a leading underscore.
+      if grep '^. _nm_test_func' "$ac_nlist" >/dev/null; then
+        lt_cv_sys_symbol_underscore=yes
+      else
+        if grep '^. nm_test_func ' "$ac_nlist" >/dev/null; then
+	  :
+        else
+	  echo "configure: cannot find nm_test_func in $ac_nlist" >&AS_MESSAGE_LOG_FD
+        fi
+      fi
+    else
+      echo "configure: cannot run $lt_cv_sys_global_symbol_pipe" >&AS_MESSAGE_LOG_FD
+    fi
+  else
+    echo "configure: failed program was:" >&AS_MESSAGE_LOG_FD
+    cat conftest.c >&AS_MESSAGE_LOG_FD
+  fi
+  rm -rf conftest*
+  ])
+  sys_symbol_underscore=$lt_cv_sys_symbol_underscore
+  AC_SUBST([sys_symbol_underscore])
+])# LT_SYS_SYMBOL_USCORE
+
+# Old name:
+AU_ALIAS([AC_LTDL_SYMBOL_USCORE], [LT_SYS_SYMBOL_USCORE])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_SYMBOL_USCORE], [])
+
+
+# LT_FUNC_DLSYM_USCORE
+# --------------------
+AC_DEFUN([LT_FUNC_DLSYM_USCORE],
+[AC_REQUIRE([LT_SYS_SYMBOL_USCORE])dnl
+if test x"$lt_cv_sys_symbol_underscore" = xyes; then
+  if test x"$libltdl_cv_func_dlopen" = xyes ||
+     test x"$libltdl_cv_lib_dl_dlopen" = xyes ; then
+	AC_CACHE_CHECK([whether we have to add an underscore for dlsym],
+	  [libltdl_cv_need_uscore],
+	  [libltdl_cv_need_uscore=unknown
+          save_LIBS="$LIBS"
+          LIBS="$LIBS $LIBADD_DLOPEN"
+	  _LT_TRY_DLOPEN_SELF(
+	    [libltdl_cv_need_uscore=no], [libltdl_cv_need_uscore=yes],
+	    [],				 [libltdl_cv_need_uscore=cross])
+	  LIBS="$save_LIBS"
+	])
+  fi
+fi
+
+if test x"$libltdl_cv_need_uscore" = xyes; then
+  AC_DEFINE([NEED_USCORE], [1],
+    [Define if dlsym() requires a leading underscore in symbol names.])
+fi
+])# LT_FUNC_DLSYM_USCORE
+
+# Old name:
+AU_ALIAS([AC_LTDL_DLSYM_USCORE], [LT_FUNC_DLSYM_USCORE])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LTDL_DLSYM_USCORE], [])
+
+# Helper functions for option handling.                    -*- Autoconf -*-
+#
+#   Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation,
+#   Inc.
+#   Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 7 ltoptions.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])
+
+
+# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)
+# ------------------------------------------
+m4_define([_LT_MANGLE_OPTION],
+[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])
+
+
+# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)
+# ---------------------------------------
+# Set option OPTION-NAME for macro MACRO-NAME, and if there is a
+# matching handler defined, dispatch to it.  Other OPTION-NAMEs are
+# saved as a flag.
+m4_define([_LT_SET_OPTION],
+[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl
+m4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),
+        _LT_MANGLE_DEFUN([$1], [$2]),
+    [m4_warning([Unknown $1 option `$2'])])[]dnl
+])
+
+
+# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])
+# ------------------------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+m4_define([_LT_IF_OPTION],
+[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])
+
+
+# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)
+# -------------------------------------------------------
+# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME
+# are set.
+m4_define([_LT_UNLESS_OPTIONS],
+[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+	    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),
+		      [m4_define([$0_found])])])[]dnl
+m4_ifdef([$0_found], [m4_undefine([$0_found])], [$3
+])[]dnl
+])
+
+
+# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)
+# ----------------------------------------
+# OPTION-LIST is a space-separated list of Libtool options associated
+# with MACRO-NAME.  If any OPTION has a matching handler declared with
+# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about
+# the unknown option and exit.
+m4_defun([_LT_SET_OPTIONS],
+[# Set options
+m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+    [_LT_SET_OPTION([$1], _LT_Option)])
+
+m4_if([$1],[LT_INIT],[
+  dnl
+  dnl Simply set some default values (i.e off) if boolean options were not
+  dnl specified:
+  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no
+  ])
+  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no
+  ])
+  dnl
+  dnl If no reference was made to various pairs of opposing options, then
+  dnl we run the default mode handler for the pair.  For example, if neither
+  dnl `shared' nor `disable-shared' was passed, we enable building of shared
+  dnl archives by default:
+  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])
+  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],
+  		   [_LT_ENABLE_FAST_INSTALL])
+  ])
+])# _LT_SET_OPTIONS
+
+
+
+# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)
+# -----------------------------------------
+m4_define([_LT_MANGLE_DEFUN],
+[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])
+
+
+# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)
+# -----------------------------------------------
+m4_define([LT_OPTION_DEFINE],
+[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl
+])# LT_OPTION_DEFINE
+
+
+# dlopen
+# ------
+LT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes
+])
+
+AU_DEFUN([AC_LIBTOOL_DLOPEN],
+[_LT_SET_OPTION([LT_INIT], [dlopen])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `dlopen' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])
+
+
+# win32-dll
+# ---------
+# Declare package support for building win32 dll's.
+LT_OPTION_DEFINE([LT_INIT], [win32-dll],
+[enable_win32_dll=yes
+
+case $host in
+*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-cegcc*)
+  AC_CHECK_TOOL(AS, as, false)
+  AC_CHECK_TOOL(DLLTOOL, dlltool, false)
+  AC_CHECK_TOOL(OBJDUMP, objdump, false)
+  ;;
+esac
+
+test -z "$AS" && AS=as
+_LT_DECL([], [AS],      [1], [Assembler program])dnl
+
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+_LT_DECL([], [DLLTOOL], [1], [DLL creation program])dnl
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [1], [Object dumper program])dnl
+])# win32-dll
+
+AU_DEFUN([AC_LIBTOOL_WIN32_DLL],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+_LT_SET_OPTION([LT_INIT], [win32-dll])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `win32-dll' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])
+
+
+# _LT_ENABLE_SHARED([DEFAULT])
+# ----------------------------
+# implement the --enable-shared flag, and supports the `shared' and
+# `disable-shared' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_SHARED],
+[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([shared],
+    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],
+	[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)
+
+    _LT_DECL([build_libtool_libs], [enable_shared], [0],
+	[Whether or not to build shared libraries])
+])# _LT_ENABLE_SHARED
+
+LT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])
+])
+
+AC_DEFUN([AC_DISABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], [disable-shared])
+])
+
+AU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])
+AU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_SHARED], [])
+dnl AC_DEFUN([AM_DISABLE_SHARED], [])
+
+
+
+# _LT_ENABLE_STATIC([DEFAULT])
+# ----------------------------
+# implement the --enable-static flag, and support the `static' and
+# `disable-static' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_STATIC],
+[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([static],
+    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],
+	[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)
+
+    _LT_DECL([build_old_libs], [enable_static], [0],
+	[Whether or not to build static libraries])
+])# _LT_ENABLE_STATIC
+
+LT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])
+])
+
+AC_DEFUN([AC_DISABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], [disable-static])
+])
+
+AU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])
+AU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_STATIC], [])
+dnl AC_DEFUN([AM_DISABLE_STATIC], [])
+
+
+
+# _LT_ENABLE_FAST_INSTALL([DEFAULT])
+# ----------------------------------
+# implement the --enable-fast-install flag, and support the `fast-install'
+# and `disable-fast-install' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_FAST_INSTALL],
+[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([fast-install],
+    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],
+    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)
+
+_LT_DECL([fast_install], [enable_fast_install], [0],
+	 [Whether or not to optimize for fast installation])dnl
+])# _LT_ENABLE_FAST_INSTALL
+
+LT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])
+
+# Old names:
+AU_DEFUN([AC_ENABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `fast-install' option into LT_INIT's first parameter.])
+])
+
+AU_DEFUN([AC_DISABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], [disable-fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `disable-fast-install' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])
+dnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])
+
+
+# _LT_WITH_PIC([MODE])
+# --------------------
+# implement the --with-pic flag, and support the `pic-only' and `no-pic'
+# LT_INIT options.
+# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.
+m4_define([_LT_WITH_PIC],
+[AC_ARG_WITH([pic],
+    [AS_HELP_STRING([--with-pic@<:@=PKGS@:>@],
+	[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],
+    [lt_p=${PACKAGE-default}
+    case $withval in
+    yes|no) pic_mode=$withval ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for lt_pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$lt_pkg" = "X$lt_p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [pic_mode=default])
+
+test -z "$pic_mode" && pic_mode=m4_default([$1], [default])
+
+_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl
+])# _LT_WITH_PIC
+
+LT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])
+
+# Old name:
+AU_DEFUN([AC_LIBTOOL_PICMODE],
+[_LT_SET_OPTION([LT_INIT], [pic-only])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `pic-only' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])
+
+
+m4_define([_LTDL_MODE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],
+		 [m4_define([_LTDL_MODE], [nonrecursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [recursive],
+		 [m4_define([_LTDL_MODE], [recursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [subproject],
+		 [m4_define([_LTDL_MODE], [subproject])])
+
+m4_define([_LTDL_TYPE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [installable],
+		 [m4_define([_LTDL_TYPE], [installable])])
+LT_OPTION_DEFINE([LTDL_INIT], [convenience],
+		 [m4_define([_LTDL_TYPE], [convenience])])
+
+# ltsugar.m4 -- libtool m4 base layer.                         -*-Autoconf-*-
+#
+# Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+# Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 6 ltsugar.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTSUGAR_VERSION], [m4_if([0.1])])
+
+
+# lt_join(SEP, ARG1, [ARG2...])
+# -----------------------------
+# Produce ARG1SEPARG2...SEPARGn, omitting [] arguments and their
+# associated separator.
+# Needed until we can rely on m4_join from Autoconf 2.62, since all earlier
+# versions in m4sugar had bugs.
+m4_define([lt_join],
+[m4_if([$#], [1], [],
+       [$#], [2], [[$2]],
+       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift(m4_shift($@)))])])
+m4_define([_lt_join],
+[m4_if([$#$2], [2], [],
+       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift(m4_shift($@)))])])
+
+
+# lt_car(LIST)
+# lt_cdr(LIST)
+# ------------
+# Manipulate m4 lists.
+# These macros are necessary as long as will still need to support
+# Autoconf-2.59 which quotes differently.
+m4_define([lt_car], [[$1]])
+m4_define([lt_cdr],
+[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
+       [$#], 1, [],
+       [m4_dquote(m4_shift($@))])])
+m4_define([lt_unquote], $1)
+
+
+# lt_append(MACRO-NAME, STRING, [SEPARATOR])
+# ------------------------------------------
+# Redefine MACRO-NAME to hold its former content plus `SEPARATOR'`STRING'.
+# Note that neither SEPARATOR nor STRING are expanded; they are appended
+# to MACRO-NAME as is (leaving the expansion for when MACRO-NAME is invoked).
+# No SEPARATOR is output if MACRO-NAME was previously undefined (different
+# than defined and empty).
+#
+# This macro is needed until we can rely on Autoconf 2.62, since earlier
+# versions of m4sugar mistakenly expanded SEPARATOR but not STRING.
+m4_define([lt_append],
+[m4_define([$1],
+	   m4_ifdef([$1], [m4_defn([$1])[$3]])[$2])])
+
+
+
+# lt_combine(SEP, PREFIX-LIST, INFIX, SUFFIX1, [SUFFIX2...])
+# ----------------------------------------------------------
+# Produce a SEP delimited list of all paired combinations of elements of
+# PREFIX-LIST with SUFFIX1 through SUFFIXn.  Each element of the list
+# has the form PREFIXmINFIXSUFFIXn.
+# Needed until we can rely on m4_combine added in Autoconf 2.62.
+m4_define([lt_combine],
+[m4_if(m4_eval([$# > 3]), [1],
+       [m4_pushdef([_Lt_sep], [m4_define([_Lt_sep], m4_defn([lt_car]))])]]dnl
+[[m4_foreach([_Lt_prefix], [$2],
+	     [m4_foreach([_Lt_suffix],
+		]m4_dquote(m4_dquote(m4_shift(m4_shift(m4_shift($@)))))[,
+	[_Lt_sep([$1])[]m4_defn([_Lt_prefix])[$3]m4_defn([_Lt_suffix])])])])])
+
+
+# lt_if_append_uniq(MACRO-NAME, VARNAME, [SEPARATOR], [UNIQ], [NOT-UNIQ])
+# -----------------------------------------------------------------------
+# Iff MACRO-NAME does not yet contain VARNAME, then append it (delimited
+# by SEPARATOR if supplied) and expand UNIQ, else NOT-UNIQ.
+m4_define([lt_if_append_uniq],
+[m4_ifdef([$1],
+	  [m4_if(m4_index([$3]m4_defn([$1])[$3], [$3$2$3]), [-1],
+		 [lt_append([$1], [$2], [$3])$4],
+		 [$5])],
+	  [lt_append([$1], [$2], [$3])$4])])
+
+
+# lt_dict_add(DICT, KEY, VALUE)
+# -----------------------------
+m4_define([lt_dict_add],
+[m4_define([$1($2)], [$3])])
+
+
+# lt_dict_add_subkey(DICT, KEY, SUBKEY, VALUE)
+# --------------------------------------------
+m4_define([lt_dict_add_subkey],
+[m4_define([$1($2:$3)], [$4])])
+
+
+# lt_dict_fetch(DICT, KEY, [SUBKEY])
+# ----------------------------------
+m4_define([lt_dict_fetch],
+[m4_ifval([$3],
+	m4_ifdef([$1($2:$3)], [m4_defn([$1($2:$3)])]),
+    m4_ifdef([$1($2)], [m4_defn([$1($2)])]))])
+
+
+# lt_if_dict_fetch(DICT, KEY, [SUBKEY], VALUE, IF-TRUE, [IF-FALSE])
+# -----------------------------------------------------------------
+m4_define([lt_if_dict_fetch],
+[m4_if(lt_dict_fetch([$1], [$2], [$3]), [$4],
+	[$5],
+    [$6])])
+
+
+# lt_dict_filter(DICT, [SUBKEY], VALUE, [SEPARATOR], KEY, [...])
+# --------------------------------------------------------------
+m4_define([lt_dict_filter],
+[m4_if([$5], [], [],
+  [lt_join(m4_quote(m4_default([$4], [[, ]])),
+           lt_unquote(m4_split(m4_normalize(m4_foreach(_Lt_key, lt_car([m4_shiftn(4, $@)]),
+		      [lt_if_dict_fetch([$1], _Lt_key, [$2], [$3], [_Lt_key ])])))))])[]dnl
+])
+
+# ltversion.m4 -- version numbers			-*- Autoconf -*-
+#
+#   Copyright (C) 2004 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# @configure_input@
+
+# serial 3337 ltversion.m4
+# This file is part of GNU Libtool
+
+m4_define([LT_PACKAGE_VERSION], [2.4.2])
+m4_define([LT_PACKAGE_REVISION], [1.3337])
+
+AC_DEFUN([LTVERSION_VERSION],
+[macro_version='2.4.2'
+macro_revision='1.3337'
+_LT_DECL(, macro_version, 0, [Which release of libtool.m4 was used?])
+_LT_DECL(, macro_revision, 0)
+])
+
+# lt~obsolete.m4 -- aclocal satisfying obsolete definitions.    -*-Autoconf-*-
+#
+#   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004.
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 5 lt~obsolete.m4
+
+# These exist entirely to fool aclocal when bootstrapping libtool.
+#
+# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN)
+# which have later been changed to m4_define as they aren't part of the
+# exported API, or moved to Autoconf or Automake where they belong.
+#
+# The trouble is, aclocal is a bit thick.  It'll see the old AC_DEFUN
+# in /usr/share/aclocal/libtool.m4 and remember it, then when it sees us
+# using a macro with the same name in our local m4/libtool.m4 it'll
+# pull the old libtool.m4 in (it doesn't see our shiny new m4_define
+# and doesn't know about Autoconf macros at all.)
+#
+# So we provide this file, which has a silly filename so it's always
+# included after everything else.  This provides aclocal with the
+# AC_DEFUNs it wants, but when m4 processes it, it doesn't do anything
+# because those macros already exist, or will be overwritten later.
+# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6. 
+#
+# Anytime we withdraw an AC_DEFUN or AU_DEFUN, remember to add it here.
+# Yes, that means every name once taken will need to remain here until
+# we give up compatibility with versions before 1.7, at which point
+# we need to keep only those names which we still refer to.
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOBSOLETE_VERSION], [m4_if([1])])
+
+m4_ifndef([AC_LIBTOOL_LINKER_OPTION],	[AC_DEFUN([AC_LIBTOOL_LINKER_OPTION])])
+m4_ifndef([AC_PROG_EGREP],		[AC_DEFUN([AC_PROG_EGREP])])
+m4_ifndef([_LT_AC_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_AC_PROG_ECHO_BACKSLASH])])
+m4_ifndef([_LT_AC_SHELL_INIT],		[AC_DEFUN([_LT_AC_SHELL_INIT])])
+m4_ifndef([_LT_AC_SYS_LIBPATH_AIX],	[AC_DEFUN([_LT_AC_SYS_LIBPATH_AIX])])
+m4_ifndef([_LT_PROG_LTMAIN],		[AC_DEFUN([_LT_PROG_LTMAIN])])
+m4_ifndef([_LT_AC_TAGVAR],		[AC_DEFUN([_LT_AC_TAGVAR])])
+m4_ifndef([AC_LTDL_ENABLE_INSTALL],	[AC_DEFUN([AC_LTDL_ENABLE_INSTALL])])
+m4_ifndef([AC_LTDL_PREOPEN],		[AC_DEFUN([AC_LTDL_PREOPEN])])
+m4_ifndef([_LT_AC_SYS_COMPILER],	[AC_DEFUN([_LT_AC_SYS_COMPILER])])
+m4_ifndef([_LT_AC_LOCK],		[AC_DEFUN([_LT_AC_LOCK])])
+m4_ifndef([AC_LIBTOOL_SYS_OLD_ARCHIVE],	[AC_DEFUN([AC_LIBTOOL_SYS_OLD_ARCHIVE])])
+m4_ifndef([_LT_AC_TRY_DLOPEN_SELF],	[AC_DEFUN([_LT_AC_TRY_DLOPEN_SELF])])
+m4_ifndef([AC_LIBTOOL_PROG_CC_C_O],	[AC_DEFUN([AC_LIBTOOL_PROG_CC_C_O])])
+m4_ifndef([AC_LIBTOOL_SYS_HARD_LINK_LOCKS], [AC_DEFUN([AC_LIBTOOL_SYS_HARD_LINK_LOCKS])])
+m4_ifndef([AC_LIBTOOL_OBJDIR],		[AC_DEFUN([AC_LIBTOOL_OBJDIR])])
+m4_ifndef([AC_LTDL_OBJDIR],		[AC_DEFUN([AC_LTDL_OBJDIR])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH], [AC_DEFUN([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH])])
+m4_ifndef([AC_LIBTOOL_SYS_LIB_STRIP],	[AC_DEFUN([AC_LIBTOOL_SYS_LIB_STRIP])])
+m4_ifndef([AC_PATH_MAGIC],		[AC_DEFUN([AC_PATH_MAGIC])])
+m4_ifndef([AC_PROG_LD_GNU],		[AC_DEFUN([AC_PROG_LD_GNU])])
+m4_ifndef([AC_PROG_LD_RELOAD_FLAG],	[AC_DEFUN([AC_PROG_LD_RELOAD_FLAG])])
+m4_ifndef([AC_DEPLIBS_CHECK_METHOD],	[AC_DEFUN([AC_DEPLIBS_CHECK_METHOD])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_NO_RTTI], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_NO_RTTI])])
+m4_ifndef([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE], [AC_DEFUN([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_PIC], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_PIC])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_SHLIBS],	[AC_DEFUN([AC_LIBTOOL_PROG_LD_SHLIBS])])
+m4_ifndef([AC_LIBTOOL_POSTDEP_PREDEP],	[AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP])])
+m4_ifndef([LT_AC_PROG_EGREP],		[AC_DEFUN([LT_AC_PROG_EGREP])])
+m4_ifndef([LT_AC_PROG_SED],		[AC_DEFUN([LT_AC_PROG_SED])])
+m4_ifndef([_LT_CC_BASENAME],		[AC_DEFUN([_LT_CC_BASENAME])])
+m4_ifndef([_LT_COMPILER_BOILERPLATE],	[AC_DEFUN([_LT_COMPILER_BOILERPLATE])])
+m4_ifndef([_LT_LINKER_BOILERPLATE],	[AC_DEFUN([_LT_LINKER_BOILERPLATE])])
+m4_ifndef([_AC_PROG_LIBTOOL],		[AC_DEFUN([_AC_PROG_LIBTOOL])])
+m4_ifndef([AC_LIBTOOL_SETUP],		[AC_DEFUN([AC_LIBTOOL_SETUP])])
+m4_ifndef([_LT_AC_CHECK_DLFCN],		[AC_DEFUN([_LT_AC_CHECK_DLFCN])])
+m4_ifndef([AC_LIBTOOL_SYS_DYNAMIC_LINKER],	[AC_DEFUN([AC_LIBTOOL_SYS_DYNAMIC_LINKER])])
+m4_ifndef([_LT_AC_TAGCONFIG],		[AC_DEFUN([_LT_AC_TAGCONFIG])])
+m4_ifndef([AC_DISABLE_FAST_INSTALL],	[AC_DEFUN([AC_DISABLE_FAST_INSTALL])])
+m4_ifndef([_LT_AC_LANG_CXX],		[AC_DEFUN([_LT_AC_LANG_CXX])])
+m4_ifndef([_LT_AC_LANG_F77],		[AC_DEFUN([_LT_AC_LANG_F77])])
+m4_ifndef([_LT_AC_LANG_GCJ],		[AC_DEFUN([_LT_AC_LANG_GCJ])])
+m4_ifndef([AC_LIBTOOL_LANG_C_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_C_CONFIG])])
+m4_ifndef([_LT_AC_LANG_C_CONFIG],	[AC_DEFUN([_LT_AC_LANG_C_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_CXX_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_CXX_CONFIG])])
+m4_ifndef([_LT_AC_LANG_CXX_CONFIG],	[AC_DEFUN([_LT_AC_LANG_CXX_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_F77_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_F77_CONFIG])])
+m4_ifndef([_LT_AC_LANG_F77_CONFIG],	[AC_DEFUN([_LT_AC_LANG_F77_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_GCJ_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_GCJ_CONFIG])])
+m4_ifndef([_LT_AC_LANG_GCJ_CONFIG],	[AC_DEFUN([_LT_AC_LANG_GCJ_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_RC_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_RC_CONFIG])])
+m4_ifndef([_LT_AC_LANG_RC_CONFIG],	[AC_DEFUN([_LT_AC_LANG_RC_CONFIG])])
+m4_ifndef([AC_LIBTOOL_CONFIG],		[AC_DEFUN([AC_LIBTOOL_CONFIG])])
+m4_ifndef([_LT_AC_FILE_LTDLL_C],	[AC_DEFUN([_LT_AC_FILE_LTDLL_C])])
+m4_ifndef([_LT_REQUIRED_DARWIN_CHECKS],	[AC_DEFUN([_LT_REQUIRED_DARWIN_CHECKS])])
+m4_ifndef([_LT_AC_PROG_CXXCPP],		[AC_DEFUN([_LT_AC_PROG_CXXCPP])])
+m4_ifndef([_LT_PREPARE_SED_QUOTE_VARS],	[AC_DEFUN([_LT_PREPARE_SED_QUOTE_VARS])])
+m4_ifndef([_LT_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_PROG_ECHO_BACKSLASH])])
+m4_ifndef([_LT_PROG_F77],		[AC_DEFUN([_LT_PROG_F77])])
+m4_ifndef([_LT_PROG_FC],		[AC_DEFUN([_LT_PROG_FC])])
+m4_ifndef([_LT_PROG_CXX],		[AC_DEFUN([_LT_PROG_CXX])])
+
 # pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
 # serial 1 (pkg-config-0.24)
 # 
 # Copyright  2004 Scott James Remnant <scott@netsplit.com>.
 #
 # This program is free software; you can redistribute it and/or modify
@@ -1304,13 +10804,6 @@
   AC_MSG_RESULT([$am_cv_prog_tar_$1])])
 
 AC_SUBST([am__tar])
 AC_SUBST([am__untar])
 ]) # _AM_PROG_TAR
 
-m4_include([libltdl/m4/argz.m4])
-m4_include([libltdl/m4/libtool.m4])
-m4_include([libltdl/m4/ltdl.m4])
-m4_include([libltdl/m4/ltoptions.m4])
-m4_include([libltdl/m4/ltsugar.m4])
-m4_include([libltdl/m4/ltversion.m4])
-m4_include([libltdl/m4/lt~obsolete.m4])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/AUTHORS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/AUTHORS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/AUTHORS	2017-10-06 14:45:52.909917736 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/AUTHORS	2016-12-12 16:03:36.672279373 +0800
@@ -69,13 +69,13 @@
  - memcached plugin.
 
 Aurlien Reynaud <collectd at wattapower.net>
  - LPAR plugin.
  - Various fixes for AIX, HP-UX and Solaris.
 
-Benjamin Gilbert <bgilbert at cs.cmu.edu>
+Benjamin Gilbert <bgilbert at backtick.net>
  - Improvements to the LVM plugin.
 
 Bert Vermeulen <bert at biot.com>
  - sigrok plugin
 
 Brett Hawn <bhawn at llnw.com>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/bindings/java/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/bindings/java/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/bindings/java/Makefile.in	2017-10-06 15:04:19.142135661 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/bindings/java/Makefile.in	2016-12-12 16:03:46.768210836 +0800
@@ -77,20 +77,13 @@
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 subdir = bindings/java
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/libltdl/m4/argz.m4 \
-	$(top_srcdir)/libltdl/m4/libtool.m4 \
-	$(top_srcdir)/libltdl/m4/ltdl.m4 \
-	$(top_srcdir)/libltdl/m4/ltoptions.m4 \
-	$(top_srcdir)/libltdl/m4/ltsugar.m4 \
-	$(top_srcdir)/libltdl/m4/ltversion.m4 \
-	$(top_srcdir)/libltdl/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/src/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -155,12 +148,15 @@
 BUILD_WITH_LIBLVM2APP_CPPFLAGS = @BUILD_WITH_LIBLVM2APP_CPPFLAGS@
 BUILD_WITH_LIBLVM2APP_LDFLAGS = @BUILD_WITH_LIBLVM2APP_LDFLAGS@
 BUILD_WITH_LIBLVM2APP_LIBS = @BUILD_WITH_LIBLVM2APP_LIBS@
 BUILD_WITH_LIBMEMCACHED_CPPFLAGS = @BUILD_WITH_LIBMEMCACHED_CPPFLAGS@
 BUILD_WITH_LIBMEMCACHED_LDFLAGS = @BUILD_WITH_LIBMEMCACHED_LDFLAGS@
 BUILD_WITH_LIBMEMCACHED_LIBS = @BUILD_WITH_LIBMEMCACHED_LIBS@
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS = @BUILD_WITH_LIBMICROHTTPD_CPPFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS = @BUILD_WITH_LIBMICROHTTPD_LDFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LIBS = @BUILD_WITH_LIBMICROHTTPD_LIBS@
 BUILD_WITH_LIBMNL_CFLAGS = @BUILD_WITH_LIBMNL_CFLAGS@
 BUILD_WITH_LIBMNL_LIBS = @BUILD_WITH_LIBMNL_LIBS@
 BUILD_WITH_LIBMODBUS_CFLAGS = @BUILD_WITH_LIBMODBUS_CFLAGS@
 BUILD_WITH_LIBMODBUS_LIBS = @BUILD_WITH_LIBMODBUS_LIBS@
 BUILD_WITH_LIBMONGOC_CPPFLAGS = @BUILD_WITH_LIBMONGOC_CPPFLAGS@
 BUILD_WITH_LIBMONGOC_LDFLAGS = @BUILD_WITH_LIBMONGOC_LDFLAGS@
@@ -174,12 +170,15 @@
 BUILD_WITH_LIBNETSNMP_LIBS = @BUILD_WITH_LIBNETSNMP_LIBS@
 BUILD_WITH_LIBOPING_CPPFLAGS = @BUILD_WITH_LIBOPING_CPPFLAGS@
 BUILD_WITH_LIBOPING_LDFLAGS = @BUILD_WITH_LIBOPING_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_CPPFLAGS = @BUILD_WITH_LIBOWCAPI_CPPFLAGS@
 BUILD_WITH_LIBOWCAPI_LDFLAGS = @BUILD_WITH_LIBOWCAPI_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_LIBS = @BUILD_WITH_LIBOWCAPI_LIBS@
+BUILD_WITH_LIBPQOS_CPPFLAGS = @BUILD_WITH_LIBPQOS_CPPFLAGS@
+BUILD_WITH_LIBPQOS_LDFLAGS = @BUILD_WITH_LIBPQOS_LDFLAGS@
+BUILD_WITH_LIBPQOS_LIBS = @BUILD_WITH_LIBPQOS_LIBS@
 BUILD_WITH_LIBPQ_CPPFLAGS = @BUILD_WITH_LIBPQ_CPPFLAGS@
 BUILD_WITH_LIBPQ_LDFLAGS = @BUILD_WITH_LIBPQ_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LDFLAGS = @BUILD_WITH_LIBPROTOBUF_C_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LIBS = @BUILD_WITH_LIBPROTOBUF_C_LIBS@
@@ -285,12 +284,14 @@
 LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
+LIBDPDK_CPPFLAGS = @LIBDPDK_CPPFLAGS@
+LIBDPDK_LDFLAGS = @LIBDPDK_LDFLAGS@
 LIBLTDL = @LIBLTDL@
 LIBLUA_PKG_CONFIG_NAME = @LIBLUA_PKG_CONFIG_NAME@
 LIBNETAPP_CPPFLAGS = @LIBNETAPP_CPPFLAGS@
 LIBNETAPP_LDFLAGS = @LIBNETAPP_LDFLAGS@
 LIBNETAPP_LIBS = @LIBNETAPP_LIBS@
 LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
@@ -323,12 +324,14 @@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 LUA_CFLAGS = @LUA_CFLAGS@
 LUA_LIBS = @LUA_LIBS@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MICROHTTPD_CFLAGS = @MICROHTTPD_CFLAGS@
+MICROHTTPD_LIBS = @MICROHTTPD_LIBS@
 MKDIR_P = @MKDIR_P@
 NM = @NM@
 NMEDIT = @NMEDIT@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/bindings/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/bindings/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/bindings/Makefile.in	2017-10-06 15:04:19.102135664 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/bindings/Makefile.in	2016-12-12 16:03:46.724211119 +0800
@@ -78,20 +78,13 @@
 build_triplet = @build@
 host_triplet = @host@
 @BUILD_WITH_JAVA_TRUE@am__append_1 = java
 subdir = bindings
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/libltdl/m4/argz.m4 \
-	$(top_srcdir)/libltdl/m4/libtool.m4 \
-	$(top_srcdir)/libltdl/m4/ltdl.m4 \
-	$(top_srcdir)/libltdl/m4/ltoptions.m4 \
-	$(top_srcdir)/libltdl/m4/ltsugar.m4 \
-	$(top_srcdir)/libltdl/m4/ltversion.m4 \
-	$(top_srcdir)/libltdl/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/src/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -216,12 +209,15 @@
 BUILD_WITH_LIBLVM2APP_CPPFLAGS = @BUILD_WITH_LIBLVM2APP_CPPFLAGS@
 BUILD_WITH_LIBLVM2APP_LDFLAGS = @BUILD_WITH_LIBLVM2APP_LDFLAGS@
 BUILD_WITH_LIBLVM2APP_LIBS = @BUILD_WITH_LIBLVM2APP_LIBS@
 BUILD_WITH_LIBMEMCACHED_CPPFLAGS = @BUILD_WITH_LIBMEMCACHED_CPPFLAGS@
 BUILD_WITH_LIBMEMCACHED_LDFLAGS = @BUILD_WITH_LIBMEMCACHED_LDFLAGS@
 BUILD_WITH_LIBMEMCACHED_LIBS = @BUILD_WITH_LIBMEMCACHED_LIBS@
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS = @BUILD_WITH_LIBMICROHTTPD_CPPFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS = @BUILD_WITH_LIBMICROHTTPD_LDFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LIBS = @BUILD_WITH_LIBMICROHTTPD_LIBS@
 BUILD_WITH_LIBMNL_CFLAGS = @BUILD_WITH_LIBMNL_CFLAGS@
 BUILD_WITH_LIBMNL_LIBS = @BUILD_WITH_LIBMNL_LIBS@
 BUILD_WITH_LIBMODBUS_CFLAGS = @BUILD_WITH_LIBMODBUS_CFLAGS@
 BUILD_WITH_LIBMODBUS_LIBS = @BUILD_WITH_LIBMODBUS_LIBS@
 BUILD_WITH_LIBMONGOC_CPPFLAGS = @BUILD_WITH_LIBMONGOC_CPPFLAGS@
 BUILD_WITH_LIBMONGOC_LDFLAGS = @BUILD_WITH_LIBMONGOC_LDFLAGS@
@@ -235,12 +231,15 @@
 BUILD_WITH_LIBNETSNMP_LIBS = @BUILD_WITH_LIBNETSNMP_LIBS@
 BUILD_WITH_LIBOPING_CPPFLAGS = @BUILD_WITH_LIBOPING_CPPFLAGS@
 BUILD_WITH_LIBOPING_LDFLAGS = @BUILD_WITH_LIBOPING_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_CPPFLAGS = @BUILD_WITH_LIBOWCAPI_CPPFLAGS@
 BUILD_WITH_LIBOWCAPI_LDFLAGS = @BUILD_WITH_LIBOWCAPI_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_LIBS = @BUILD_WITH_LIBOWCAPI_LIBS@
+BUILD_WITH_LIBPQOS_CPPFLAGS = @BUILD_WITH_LIBPQOS_CPPFLAGS@
+BUILD_WITH_LIBPQOS_LDFLAGS = @BUILD_WITH_LIBPQOS_LDFLAGS@
+BUILD_WITH_LIBPQOS_LIBS = @BUILD_WITH_LIBPQOS_LIBS@
 BUILD_WITH_LIBPQ_CPPFLAGS = @BUILD_WITH_LIBPQ_CPPFLAGS@
 BUILD_WITH_LIBPQ_LDFLAGS = @BUILD_WITH_LIBPQ_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LDFLAGS = @BUILD_WITH_LIBPROTOBUF_C_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LIBS = @BUILD_WITH_LIBPROTOBUF_C_LIBS@
@@ -346,12 +345,14 @@
 LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
+LIBDPDK_CPPFLAGS = @LIBDPDK_CPPFLAGS@
+LIBDPDK_LDFLAGS = @LIBDPDK_LDFLAGS@
 LIBLTDL = @LIBLTDL@
 LIBLUA_PKG_CONFIG_NAME = @LIBLUA_PKG_CONFIG_NAME@
 LIBNETAPP_CPPFLAGS = @LIBNETAPP_CPPFLAGS@
 LIBNETAPP_LDFLAGS = @LIBNETAPP_LDFLAGS@
 LIBNETAPP_LIBS = @LIBNETAPP_LIBS@
 LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
@@ -384,12 +385,14 @@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 LUA_CFLAGS = @LUA_CFLAGS@
 LUA_LIBS = @LUA_LIBS@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MICROHTTPD_CFLAGS = @MICROHTTPD_CFLAGS@
+MICROHTTPD_LIBS = @MICROHTTPD_LIBS@
 MKDIR_P = @MKDIR_P@
 NM = @NM@
 NMEDIT = @NMEDIT@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/bindings/perl/lib/Collectd/Unixsock.pm /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/bindings/perl/lib/Collectd/Unixsock.pm
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/bindings/perl/lib/Collectd/Unixsock.pm	2017-10-06 14:45:52.921917742 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/bindings/perl/lib/Collectd/Unixsock.pm	2016-12-12 16:03:36.680279316 +0800
@@ -134,13 +134,13 @@
 
 	return $ident;
 } # _parse_identifier
 
 sub _escape_argument
 {
-    my $arg = shift;
+	my $arg = shift;
 
 	return $arg if $arg =~ /^\w+$/;
 
 	$arg =~ s#\\#\\\\#g;
 	$arg =~ s#"#\\"#g;
 	return "\"$arg\"";
@@ -150,25 +150,25 @@
 # Return a single line of result.
 sub _socket_command {
 	my ($self, $command, $args) = @_;
 
 	my $fh = $self->{sock} or confess ('object has no filehandle');
 
-    if($args) {
-        my $identifier = _create_identifier ($args) or return;
-	    $command .= ' ' . _escape_argument ($identifier) . "\n";
-    } else {
-        $command .= "\n";
-    }
+	if($args) {
+		my $identifier = _create_identifier ($args) or return;
+		$command .= ' ' . _escape_argument ($identifier) . "\n";
+	} else {
+		$command .= "\n";
+	}
 	_debug "-> $command";
 	$fh->print($command);
 
 	my $response = $fh->getline;
 	chomp $response;
 	_debug "<- $response\n";
-    return $response;
+	return $response;
 }
 
 # Read any remaining results from a socket and pass them to
 # a callback for caller-defined mangling.
 sub _socket_chat
 {
@@ -185,13 +185,13 @@
 
 	for (1 .. $nresults)
 	{
 		my $entry = $fh->getline;
 		chomp $entry;
 		_debug "<- $entry\n";
-        $callback->($entry, $cbdata);
+		$callback->($entry, $cbdata);
 	}
 	return $cbdata;
 }
 
 # Send a raw message on a socket.
 # Returns true upon success and false otherwise.
@@ -257,20 +257,20 @@
 sub getval # {{{
 {
 	my $self = shift;
 	my %args = @_;
 	my $ret = {};
 
-    my $msg = $self->_socket_command('GETVAL', \%args) or return;
-    $self->_socket_chat($msg, sub {
-            local $_ = shift;
-            my $ret = shift;
-            /^(\w+)=NaN$/ and $ret->{$1} = undef, return;
-            /^(\w+)=(.*)$/ and looks_like_number($2) and $ret->{$1} = 0 + $2, return;
-        }, $ret
-    );
+	my $msg = $self->_socket_command('GETVAL', \%args) or return;
+	$self->_socket_chat($msg, sub {
+			local $_ = shift;
+			my $ret = shift;
+			/^(\w+)=NaN$/ and $ret->{$1} = undef, return;
+			/^(\w+)=(.*)$/ and looks_like_number($2) and $ret->{$1} = 0 + $2, return;
+		}, $ret
+	);
 	return $ret;
 } # }}} sub getval
 
 =item I<$res> = I<$self>-E<gt>B<getthreshold> (I<%identifier>);
 
 Requests a threshold from the daemon. On success a hash-ref is returned with
@@ -281,23 +281,23 @@
 sub getthreshold # {{{
 {
 	my $self = shift;
 	my %args = @_;
 	my $ret = {};
 
-    my $msg = $self->_socket_command('GETTHRESHOLD', \%args) or return;
-    $self->_socket_chat($msg, sub {
-            local $_ = shift;
-            my $ret = shift;
-            my ( $key, $val );
-            ( $key, $val ) = /^\s*([^:]+):\s*(.*)/ and do {
-                  $key =~ s/\s*$//;
-                  $ret->{$key} = $val;
-            };
-        }, $ret
-    );
+	my $msg = $self->_socket_command('GETTHRESHOLD', \%args) or return;
+	$self->_socket_chat($msg, sub {
+			local $_ = shift;
+			my $ret = shift;
+			my ( $key, $val );
+			( $key, $val ) = /^\s*([^:]+):\s*(.*)/ and do {
+				  $key =~ s/\s*$//;
+				  $ret->{$key} = $val;
+			};
+		}, $ret
+	);
 	return $ret;
 } # }}} sub getthreshold
 
 =item I<$self>-E<gt>B<putval> (I<%identifier>, B<time> =E<gt> I<$time>, B<values> =E<gt> [...]);
 
 Submits a value-list to the daemon. If the B<time> argument is omitted
@@ -316,13 +316,13 @@
 	my %args = @_;
 
 	my ($status, $msg, $identifier, $values);
 	my $fh = $self->{sock} or confess;
 
 	my $interval = defined $args{interval} ?
-    ' interval=' . _escape_argument ($args{interval}) : '';
+	' interval=' . _escape_argument ($args{interval}) : '';
 
 	$identifier = _create_identifier (\%args) or return;
 	if (!$args{values})
 	{
 		cluck ("Need argument `values'");
 		return;
@@ -369,29 +369,29 @@
 
 =cut
 
 sub listval_filter
 {
 	my $self = shift;
-    my %args = @_;
+	my %args = @_;
 	my @ret;
 	my $nresults;
 	my $fh = $self->{sock} or confess;
 
-    my $pattern =
-    (exists $args{host}              ? "$args{host}"             : '[^/]+') .
-    (exists $args{plugin}            ? "/$args{plugin}"          : '/[^/-]+') .
+	my $pattern =
+	(exists $args{host}              ? "$args{host}"             : '[^/]+') .
+	(exists $args{plugin}            ? "/$args{plugin}"          : '/[^/-]+') .
 	(exists $args{plugin_instance}   ? "-$args{plugin_instance}" : '(?:-[^/]+)?') .
 	(exists $args{type}              ? "/$args{type}"            : '/[^/-]+') .
 	(exists $args{type_instance}     ? "-$args{type_instance}"   : '(?:-[^/]+)?');
-    $pattern = qr/^\d+ $pattern$/;
+	$pattern = qr/^\d+(?:\.\d+)? $pattern$/;
 
-    my $msg = $self->_socket_command('LISTVAL') or return;
+	my $msg = $self->_socket_command('LISTVAL') or return;
 	($nresults, $msg) = split / /, $msg, 2;
 
-    # This could use _socket_chat() but doesn't for speed reasons
+	# This could use _socket_chat() but doesn't for speed reasons
 	if ($nresults < 0)
 	{
 		$self->{error} = $msg;
 		return;
 	}
 
@@ -401,19 +401,19 @@
 		chomp $msg;
 		_debug "<- $msg\n";
 		next unless $msg =~ $pattern;
 		my ($time, $ident) = split / /, $msg, 2;
 
 		$ident = _parse_identifier ($ident);
-		$ident->{time} = int $time;
+		$ident->{time} = 0+$time;
 
 		push (@ret, $ident);
-	} # for (i = 0 .. $status)
+	} # for (i = 0 .. $nresults)
 
 	return @ret;
-} # listval
+} # listval_filter
 
 =item I<$res> = I<$self>-E<gt>B<listval> ()
 
 Queries a list of values from the daemon. The list is returned as an array of
 hash references, where each hash reference is a valid identifier. The C<time>
 member of each hash holds the epoch value of the last update of that value.
@@ -424,16 +424,16 @@
 {
 	my $self = shift;
 	my $nresults;
 	my @ret;
 	my $fh = $self->{sock} or confess;
 
-    my $msg = $self->_socket_command('LISTVAL') or return;
+	my $msg = $self->_socket_command('LISTVAL') or return;
 	($nresults, $msg) = split / /, $msg, 2;
 
-    # This could use _socket_chat() but doesn't for speed reasons
+	# This could use _socket_chat() but doesn't for speed reasons
 	if ($nresults < 0)
 	{
 		$self->{error} = $msg;
 		return;
 	}
 
@@ -443,16 +443,16 @@
 		chomp $msg;
 		_debug "<- $msg\n";
 
 		my ($time, $ident) = split / /, $msg, 2;
 
 		$ident = _parse_identifier ($ident);
-		$ident->{time} = int $time;
+		$ident->{time} = 0+$time;
 
 		push (@ret, $ident);
-	} # for (i = 0 .. $status)
+	} # for (i = 0 .. $nresults)
 
 	return @ret;
 } # listval
 
 =item I<$res> = I<$self>-E<gt>B<putnotif> (B<severity> =E<gt> I<$severity>, B<message> =E<gt> I<$message>, ...);
 
@@ -494,16 +494,16 @@
 
 	my $status;
 	my $fh = $self->{sock} or confess;
 
 	my $msg; # message sent to the socket
 	
-    for my $arg (qw( message severity ))
-    {
-        cluck ("Need argument `$arg'"), return unless $args{$arg};
-    }
+	for my $arg (qw( message severity ))
+	{
+		cluck ("Need argument `$arg'"), return unless $args{$arg};
+	}
 	$args{severity} = lc $args{severity};
 	if (($args{severity} ne 'failure')
 		&& ($args{severity} ne 'warning')
 		&& ($args{severity} ne 'okay'))
 	{
 		cluck ("Invalid `severity: " . $args{severity});
@@ -551,15 +551,15 @@
 {
 	my $self  = shift;
 	my %args = @_;
 
 	my $fh = $self->{sock} or confess;
 
-	my $msg    = "FLUSH";
+	my $msg = "FLUSH";
 
-    $msg .= " timeout=$args{timeout}" if defined $args{timeout};
+	$msg .= " timeout=$args{timeout}" if defined $args{timeout};
 
 	if ($args{plugins})
 	{
 		foreach my $plugin (@{$args{plugins}})
 		{
 			$msg .= " plugin=" . $plugin;
@@ -584,17 +584,17 @@
 			$ident_str = ' identifier=' . _escape_argument ($ident_str);
 
 			if (length($msg)+length($ident_str) >= 1023) { #1024 - 1 byte for \n
 				$self->_send_message($msg) or return;
 				$msg = $pre;
 			}
-            
+
 			$msg .= $ident_str;
 		}
 	}
-    
+
 	return $self->_send_message($msg);
 }
 
 sub error
 {
 	return shift->{error};
@@ -634,7 +634,7 @@
 =head1 AUTHOR
 
 Florian octo Forster E<lt>octo@collectd.orgE<gt>
 
 =cut
 1;
-# vim: set fdm=marker :
+# vim: set fdm=marker noexpandtab:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/bindings/perl/lib/Collectd.pm /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/bindings/perl/lib/Collectd.pm
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/bindings/perl/lib/Collectd.pm	2017-10-06 14:45:52.917917740 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/bindings/perl/lib/Collectd.pm	2016-12-12 16:03:36.680279316 +0800
@@ -169,51 +169,38 @@
 sub DEBUG   { _log (scalar caller, LOG_DEBUG,   shift); }
 
 sub plugin_call_all {
 	my $type = shift;
 
 	my %plugins;
-	my $interval;
 
 	our $cb_name = undef;
 
 	if (! defined $type) {
 		return;
 	}
 
 	if (TYPE_LOG != $type) {
-		DEBUG ("Collectd::plugin_call: type = \"$type\" ("
+		DEBUG ("Collectd::plugin_call_all: type = \"$type\" ("
 			. $types{$type} . "), args=\""
 			. join(', ', map { defined($_) ? $_ : '<undef>' } @_) . "\"");
 	}
 
 	if (! defined $plugins[$type]) {
-		ERROR ("Collectd::plugin_call: unknown type \"$type\"");
+		ERROR ("Collectd::plugin_call_all: unknown type \"$type\"");
 		return;
 	}
 
 	{
 		lock %{$plugins[$type]};
 		%plugins = %{$plugins[$type]};
 	}
 
-	$interval = plugin_get_interval ();
-
 	foreach my $plugin (keys %plugins) {
-		my $p = $plugins{$plugin};
-
-		my $status = 0;
-
-		if ($p->{'wait_left'} > 0) {
-			$p->{'wait_left'} -= $interval;
-		}
-
-		next if ($p->{'wait_left'} > 0);
-
-		$cb_name = $p->{'cb_name'};
-		$status = call_by_name (@_);
+		$cb_name = $plugins{$plugin};
+		my $status = call_by_name (@_);
 
 		if (! $status) {
 			my $err = undef;
 
 			if ($@) {
 				$err = $@;
@@ -227,29 +214,13 @@
 			}
 
 			$status = 0;
 		}
 
 		if ($status) {
-			$p->{'wait_left'} = 0;
-			$p->{'wait_time'} = $interval;
-		}
-		elsif (TYPE_READ == $type) {
-			if ($p->{'wait_time'} < $interval) {
-				$p->{'wait_time'} = $interval;
-			}
-
-			$p->{'wait_left'} = $p->{'wait_time'};
-			$p->{'wait_time'} *= 2;
-
-			if ($p->{'wait_time'} > 86400) {
-				$p->{'wait_time'} = 86400;
-			}
-
-			WARNING ("${plugin}->read() failed with status $status. "
-				. "Will suspend it for $p->{'wait_left'} seconds.");
+			#NOOP
 		}
 		elsif (TYPE_INIT == $type) {
 			ERROR ("${plugin}->init() failed with status $status. "
 				. "Plugin will be disabled.");
 
 			foreach my $type (keys %types) {
@@ -306,27 +277,35 @@
 
 		lock %cf_callbacks;
 		$cf_callbacks{$name} = $data;
 	}
 	elsif ((TYPE_DATASET != $type) && (! ref $data)) {
 		my $pkg = scalar caller;
-
-		my %p : shared;
-
 		if ($data !~ m/^$pkg\:\:/) {
 			$data = $pkg . "::" . $data;
 		}
-
-		%p = (
-			wait_time => plugin_get_interval (),
-			wait_left => 0,
-			cb_name   => $data,
-		);
-
+		if (TYPE_READ == $type) {
+			return plugin_register_read($name, $data);
+		}
+		if (TYPE_WRITE == $type) {
+			return plugin_register_write($name, $data);
+		}
+		if (TYPE_LOG == $type) {
+			return plugin_register_log($name, $data);
+		}
+		if (TYPE_NOTIF == $type) {
+			return plugin_register_notification($name, $data);
+		}
+		if (TYPE_FLUSH == $type) {
+			#For collectd-5.6 only
+			lock %{$plugins[$type]};
+			$plugins[$type]->{$name} = $data;
+			return plugin_register_flush($name, $data);
+		}
 		lock %{$plugins[$type]};
-		$plugins[$type]->{$name} = \%p;
+		$plugins[$type]->{$name} = $data;
 	}
 	else {
 		ERROR ("Collectd::plugin_register: Invalid data.");
 		return;
 	}
 	return 1;
@@ -348,12 +327,27 @@
 		return plugin_unregister_data_set ($name);
 	}
 	elsif (TYPE_CONFIG == $type) {
 		lock %cf_callbacks;
 		delete $cf_callbacks{$name};
 	}
+	elsif (TYPE_READ == $type) {
+		return plugin_unregister_read ($name);
+	}
+	elsif (TYPE_WRITE == $type) {
+		return plugin_unregister_write($name);
+	}
+	elsif (TYPE_LOG == $type) {
+		return plugin_unregister_log ($name);
+	}
+	elsif (TYPE_NOTIF == $type) {
+		return plugin_unregister_notification($name);
+	}
+	elsif (TYPE_FLUSH == $type) {
+		return plugin_unregister_flush($name);
+	}
 	elsif (defined $plugins[$type]) {
 		lock %{$plugins[$type]};
 		delete $plugins[$type]->{$name};
 	}
 	else {
 		ERROR ("Collectd::plugin_unregister: Invalid type.");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/ChangeLog /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/ChangeLog
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/ChangeLog	2017-10-06 14:53:11.526092175 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/ChangeLog	2016-12-12 16:03:36.676279345 +0800
@@ -1,75 +1,75 @@
-2017-10-06, Version 5.6.3
-	* collectd: support for boolean string config values has been
-	  reintroduced. Thanks to Sebastian Harl. #2083, #2098
-	* collectd: The capability checking has been changed to use
-	  "cap_get_proc()". Thanks to Marc Fournier. #2151
-	* Documentation: A section documenting ignore lists has been added to
-	  collectd.conf(5). Thanks to Florian Forster.
-	* AMQP plugin: The "ExchangeType" option is now also valid for
-	  publishers. Thanks to Florian Forster. #2286
-	* Apache, Ascent, BIND, cURL, cURL-JSON, cURL-XML, nginx, Write HTTP
-	  plugins: Handling of URLs that redirect elsewhere has been fixed.
-	  Thanks to Pavel Rochnyack. #2328
-	* BIND plugin: Fix parsing of the sample time provided by BIND.
-	  Previously, the time was assumed to be in the local time zone when in
-	  fact it was in UTC. Thanks to Ed Ravin. #1268
-	* BIND plugin: Memory leaks have been fixed. Thanks to Ruben Kerkhof.
-	  #2303
-	* Chrony plugin: Build flags have been fixed. Thanks to Thomas Jost and
-	  Marc Fournier. #2133
-	* cURL-JSON plugin: The timeout value has been changed to default to the
-	  collection interval. This fixes a regression. Thanks to Marc Fournier.
-	* cURL-JSON plugin: Handling of arrays has been fixed. Thanks to Florian
-	  Forster. #2266
-	* DBI plugin: Memory leaks at shutdown have been fixes. Thanks to Pavel
-	  Rochnyack and Florian Forster.
-	* E-Mail, Exec, UnixSock plugins: Group ID lookup on systems with many
-	  groups has been fixed. Thanks to Ruben Kerkhof and Florian Forster.
-	  #2208
-	* IPC plugin: A compilation error on AIX has been fixed. Thanks to Pavel
-	  Rochnyack. #2305
-	* LogFile plugin: If writing to the file fails, print log messages on
-	  "STDERR" instead. Thanks to Marc Fournier.
-	* Log Logstash plugin: If writing the log entry fails, print it to
-	  "STDERR" instead. Thanks to Marc Fournier.
-	* memcachec, Tail plugins: A resource leak in the matching
-	  infrastructure has been fixed. Thanks to Krzysztof Matczak. #2192
-	* MQTT plugin: Invalid symbols in topic names are now replaced and a
-	  resource leak has been fixed. Thanks to Denys Fedoryshchenko. #2123
-	* Network plugin: A potential endless-loop has been fixed. This can be
-	  triggered remotely by sending a signed network packet to a server
-	  which is not set up to check signatures. Thanks to Marcin Kozlowski
-	  and Pavel Rochnyack. #2174, #2233, CVE-2017-7401
-	* Network plugin: A use-after-free has been fixed. Thanks to Pavel
-	  Rochnyack. #2375
-	* Notify Email plugin: The plugin is no longer explicitly linked against
-	  libssl and libcrypto, relies on libesmtp being linked correctly.
-	  Thanks to Marc Fournier. Debian#852924
-	* NTPd plugin: Calculation of loop offset and error has been fixed.
-	  Thanks to Neil Wilson. #2188
-	* OpenLDAP plugin: An incorrect use of the ldap library, leading to a
-	  crash, has been fixed. Thanks to Marc Fournier. #2331
-	* Perl plugin: A potential double-free has been fixed. Thanks to Florian
-	  Forster. #2278
-	* Perl plugin: Print an error when an incorrect configuration is
-	  encountered. Thanks to Pavel Rochnyack. #927
-	* RRDtool plugin: Incorrect handling of the flushes timeout option has
-	  been fixed. Handling of the "RandomTimeout" has been fixed. Thanks to
-	  Pavel Rochnyack. #2363
-	* SMART plugin: Some warning messages have been removed and the code has
-	  been cleaned up. Thanks to Florian Forster. #2062
-	* SMART plugin: A check for the "CAP_SYS_RAWIO" capability has been
-	  added. Thanks to Marc Fournier.
-	* SNMP plugin: A double free has been fixed. Thanks to Pavel Rochnyack.
-	  #2291
-	* Write Graphite plugin: Error handling in the case that calculating a
-	  metric's rate fails has been improved. Previously, the raw counter
-	  values were sent to Graphite. Thanks to Iain Buclaw. #2209
-	* Write Kafka plugin: A 32 bit random number is now used when formatting
-	  a random key. Thanks to Florian Forster. #2074
+2016-12-12, Version 5.7.0
+	* Documentation: The Turbostat plugin section has been improved. Thanks
+	  to Florian Forster
+	* Documentation: The semantics of the "TypesDB" option have been
+	  improved. Thanks to Florian Forster.
+	* collectd: A generic interface for parsing the text protocol has been
+	  added. Thanks to Sebastian Harl. #1749
+	* collectd: Threads now get named, making them easier to track using
+	  tools such as top, ps, etc. Thanks to Manuel Luis Sanmartn Rozada
+	  and Marc Fournier. #547
+	* AMQP plugin, Write Graphite plugin, Write Kafka plugin: The new
+	  "[Graphite]PreserveSeparator" option allows retaining the default dot
+	  separator rather than escaping it. Thanks to Florian Forster. #419
+	* Battery plugin: A StateFS backend for gathering statistics has been
+	  added. Thanks to Rinigus. #1795
+	* CPU plugin: CPU aggregation on AIX was fixed. Thanks to Chao Yang.
+	  #1957
+	* Collectd::Unixsock: Fractional seconds support has been made more
+	  robust. Thanks to Matthias Bethke. #2052
+	* DPDKStat plugin: This new plugin collects DPDK interface statistics.
+	  Thanks to Maryam Tahhan, Harry van Haaren, Taras Chornyi and Kim
+	  Jones. #1649
+	* gRPC plugin: The "DispatchValues" option has been renamed to
+	  "PutValues". Thanks to Florian Forster.
+	* HDDTemp plugin: The 32 devices limit has been removed. Thanks to
+	  Benjamin Gilbert. #631
+	* Hugepages plugin: This new plugin reports the number of used and free
+	  hugepages on Linux. Thanks to Jaroslav Safka, Maryam Tahhan, Kim Jones
+	  and Florian Forster. #1799
+	* Intel RDT plugin: This new plugin collects statistics exposed by
+	  Intel's Resource Director Technology . Thanks to SerhiyX. #1970
+	* memcached plugin: The new "Address" option allows connecting to a
+	  different server than specified by the "Host" option. Thanks to Pavel
+	  Rochnyack. #1975
+	* nginx plugin: Support for reporting failed connections has been added.
+	  Thanks to Pavel Rochnyack. #1609
+	* Perl plugin: Significant internal reworking has been made. The new
+	  "RegisterLegacyFlush" option has been added. Thanks to Pavel
+	  Rochnyack. #1731
+	* PostgreSQL plugin: Timestamps are now RFC 3339-formatted local time.
+	  Thanks to Igor Peshansky and Dave Cunningham. #1918
+	* Processes plugin: Internal performance improvements have been made.
+	  Thanks to Pavel Rochnyack. #1980, #1981
+	* RRDCacheD plugin: The plugin now tries to reconnect upon failed
+	  operations. Thanks to Sebastian Harl. #1959
+	* SpamAssassin: The plugin can now run in Perl's "tainted mode" ("-T").
+	  Thanks to Akos Vandra. #1962
+	* Tail plugin: Support for calculating latency distribution of matching
+	  values has been added. Thanks to Pavel Rochnyack and Florian Forster.
+	  #1700
+	* Tail plugin: The new "GaugePersist" option has been added. Thanks to
+	  Florian Forster. #2015
+	* Target:Set, Target:Replace, Match:RegEx: MetaData support has been
+	  added . Thanks to Igor Peshansky. #1922, #1923, #1930
+	* turbostat plugin: The new "LogicalCoreNames" option allows switching
+	  to per-core naming rather than per-CPU. Thanks to Brock Johnson. #2056
+	* virt plugin: The new "BlockDeviceFormat" and
+	  "BlockDeviceFormatBasename" options help controlling the names
+	  reported for block-device metrics. Thanks to Deyan Chepishev. #2004
+	* Write Graphite plugin: A new "DropDuplicateFields" option has been
+	  added. Thanks to Michael Leinartas. #1915
+	* Write Kafka plugin: The "Key Random" setting has been reintroduced.
+	  Thanks to Florian Forster. #1977
+	* Write Log plugin: Support for formatting output in JSON has been
+	  added, using the new "Format" configuration option. Thanks to Igor
+	  Peshansky. #1924
+	* Write Prometheus plugin: This new plugin publishes values using an
+	  embedded HTTP server, in a format compatible with Prometheus'
+	  collectd_exporter. Thanks to Florian Forster. #1967
 
 2016-11-30, Version 5.6.2
 	* collectd: A compile error on AIX has been fixed: "MSG_DONTWAIT" is not
 	  available on AIX. Thanks to Chao Yang.
 	* collectd: The capability checking has been rewritten to be more
 	  portable. Thanks to Florian Forster. #2009
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: compile
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: config.guess
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: config.sub
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/configure	2017-10-06 15:04:17.486135771 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/configure	2016-12-12 16:03:48.160201968 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for collectd 5.6.3.
+# Generated by GNU Autoconf 2.69 for collectd 5.7.0.
 #
 #
 # Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -588,14 +588,14 @@
 MFLAGS=
 MAKEFLAGS=
 
 # Identity of this package.
 PACKAGE_NAME='collectd'
 PACKAGE_TARNAME='collectd'
-PACKAGE_VERSION='5.6.3'
-PACKAGE_STRING='collectd 5.6.3'
+PACKAGE_VERSION='5.7.0'
+PACKAGE_STRING='collectd 5.7.0'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
 ac_unique_file="src/target_set.c"
 : "${ARFLAGS=cr} ${AR_FLAGS=cr}"
 # Factoring default headers for most tests.
@@ -673,12 +673,14 @@
 BUILD_PLUGIN_WRITE_SENSU_FALSE
 BUILD_PLUGIN_WRITE_SENSU_TRUE
 BUILD_PLUGIN_WRITE_RIEMANN_FALSE
 BUILD_PLUGIN_WRITE_RIEMANN_TRUE
 BUILD_PLUGIN_WRITE_REDIS_FALSE
 BUILD_PLUGIN_WRITE_REDIS_TRUE
+BUILD_PLUGIN_WRITE_PROMETHEUS_FALSE
+BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE
 BUILD_PLUGIN_WRITE_MONGODB_FALSE
 BUILD_PLUGIN_WRITE_MONGODB_TRUE
 BUILD_PLUGIN_WRITE_LOG_FALSE
 BUILD_PLUGIN_WRITE_LOG_TRUE
 BUILD_PLUGIN_WRITE_KAFKA_FALSE
 BUILD_PLUGIN_WRITE_KAFKA_TRUE
@@ -865,12 +867,16 @@
 BUILD_PLUGIN_IPMI_FALSE
 BUILD_PLUGIN_IPMI_TRUE
 BUILD_PLUGIN_IPC_FALSE
 BUILD_PLUGIN_IPC_TRUE
 BUILD_PLUGIN_INTERFACE_FALSE
 BUILD_PLUGIN_INTERFACE_TRUE
+BUILD_PLUGIN_INTEL_RDT_FALSE
+BUILD_PLUGIN_INTEL_RDT_TRUE
+BUILD_PLUGIN_HUGEPAGES_FALSE
+BUILD_PLUGIN_HUGEPAGES_TRUE
 BUILD_PLUGIN_HDDTEMP_FALSE
 BUILD_PLUGIN_HDDTEMP_TRUE
 BUILD_PLUGIN_GRPC_FALSE
 BUILD_PLUGIN_GRPC_TRUE
 BUILD_PLUGIN_GPS_FALSE
 BUILD_PLUGIN_GPS_TRUE
@@ -889,12 +895,14 @@
 BUILD_PLUGIN_ENTROPY_FALSE
 BUILD_PLUGIN_ENTROPY_TRUE
 BUILD_PLUGIN_EMAIL_FALSE
 BUILD_PLUGIN_EMAIL_TRUE
 BUILD_PLUGIN_DRBD_FALSE
 BUILD_PLUGIN_DRBD_TRUE
+BUILD_PLUGIN_DPDKSTAT_FALSE
+BUILD_PLUGIN_DPDKSTAT_TRUE
 BUILD_PLUGIN_DNS_FALSE
 BUILD_PLUGIN_DNS_TRUE
 BUILD_PLUGIN_DISK_FALSE
 BUILD_PLUGIN_DISK_TRUE
 BUILD_PLUGIN_DF_FALSE
 BUILD_PLUGIN_DF_TRUE
@@ -1035,12 +1043,15 @@
 PROTOBUF_C_CFLAGS
 BUILD_WITH_LIBPROTOBUF_LIBS
 BUILD_WITH_LIBPROTOBUF_LDFLAGS
 BUILD_WITH_LIBPROTOBUF_CPPFLAGS
 PROTOBUF_LIBS
 PROTOBUF_CFLAGS
+BUILD_WITH_LIBPQOS_LIBS
+BUILD_WITH_LIBPQOS_LDFLAGS
+BUILD_WITH_LIBPQOS_CPPFLAGS
 BUILD_WITH_LIBPQ_FALSE
 BUILD_WITH_LIBPQ_TRUE
 BUILD_WITH_LIBPQ_LDFLAGS
 BUILD_WITH_LIBPQ_CPPFLAGS
 HAVE_BROKEN_PERL_LOAD_MODULE_FALSE
 HAVE_BROKEN_PERL_LOAD_MODULE_TRUE
@@ -1084,12 +1095,17 @@
 BUILD_WITH_LIBMONGOC_FALSE
 BUILD_WITH_LIBMONGOC_TRUE
 BUILD_WITH_LIBMONGOC_LDFLAGS
 BUILD_WITH_LIBMONGOC_CPPFLAGS
 BUILD_WITH_LIBMODBUS_LIBS
 BUILD_WITH_LIBMODBUS_CFLAGS
+BUILD_WITH_LIBMICROHTTPD_LIBS
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS
+MICROHTTPD_LIBS
+MICROHTTPD_CFLAGS
 BUILD_WITH_LIBMEMCACHED_FALSE
 BUILD_WITH_LIBMEMCACHED_TRUE
 BUILD_WITH_LIBMEMCACHED_LIBS
 BUILD_WITH_LIBMEMCACHED_LDFLAGS
 BUILD_WITH_LIBMEMCACHED_CPPFLAGS
 BUILD_WITH_LIBLVM2APP_FALSE
@@ -1111,12 +1127,14 @@
 JAVA_LIBS
 JAVA_LDFLAGS
 JAVA_CFLAGS
 JAVA_CPPFLAGS
 JAR
 JAVAC
+LIBDPDK_LDFLAGS
+LIBDPDK_CPPFLAGS
 BUILD_WITH_LIBIPTC_LDFLAGS
 BUILD_WITH_LIBIPTC_CPPFLAGS
 BUILD_WITH_LIBIPTC_FALSE
 BUILD_WITH_LIBIPTC_TRUE
 BUILD_WITH_LIBGRPCPP_LIBS
 BUILD_WITH_LIBGRPCPP_LDFLAGS
@@ -1395,16 +1413,18 @@
 with_libesmtp
 with_libganglia
 with_libgcrypt
 with_libgps
 with_libgrpc__
 with_libiptc
+with_libdpdk
 with_java
 with_libldap
 with_liblvm2app
 with_libmemcached
+with_libmicrohttpd
 with_libmodbus
 with_libmongoc
 with_libmosquitto
 with_libmysql
 with_libmnl
 with_libnetapp
@@ -1413,12 +1433,13 @@
 with_liboping
 with_oracle
 with_libowcapi
 with_libpcap
 with_libperl
 with_libpq
+with_libpqos
 with_libprotobuf
 with_libprotobuf_c
 with_libpython
 with_librabbitmq
 with_librdkafka
 with_librouteros
@@ -1462,24 +1483,27 @@
 enable_curl_json
 enable_curl_xml
 enable_dbi
 enable_df
 enable_disk
 enable_dns
+enable_dpdkstat
 enable_drbd
 enable_email
 enable_entropy
 enable_ethstat
 enable_exec
 enable_fhcount
 enable_filecount
 enable_fscache
 enable_gmond
 enable_gps
 enable_grpc
 enable_hddtemp
+enable_hugepages
+enable_intel_rdt
 enable_interface
 enable_ipc
 enable_ipmi
 enable_iptables
 enable_ipvs
 enable_irq
@@ -1570,12 +1594,13 @@
 enable_wireless
 enable_write_graphite
 enable_write_http
 enable_write_kafka
 enable_write_log
 enable_write_mongodb
+enable_write_prometheus
 enable_write_redis
 enable_write_riemann
 enable_write_sensu
 enable_write_tsdb
 enable_xencpu
 enable_xmms
@@ -1607,15 +1632,19 @@
 PROTOC_C
 KERNEL_DIR
 HAL_CFLAGS
 HAL_LIBS
 GRPCPP_CFLAGS
 GRPCPP_LIBS
+LIBDPDK_CPPFLAGS
+LIBDPDK_LDFLAGS
 LIBLUA_PKG_CONFIG_NAME
 LUA_CFLAGS
 LUA_LIBS
+MICROHTTPD_CFLAGS
+MICROHTTPD_LIBS
 LIBNETAPP_CPPFLAGS
 LIBNETAPP_LDFLAGS
 LIBNETAPP_LIBS
 PROTOBUF_CFLAGS
 PROTOBUF_LIBS
 PROTOBUF_C_CFLAGS
@@ -2169,13 +2198,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures collectd 5.6.3 to adapt to many kinds of systems.
+\`configure' configures collectd 5.7.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -2239,13 +2268,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of collectd 5.6.3:";;
+     short | recursive ) echo "Configuration of collectd 5.7.0:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
@@ -2298,24 +2327,27 @@
   --enable-curl_json      CouchDB statistics
   --enable-curl_xml       CURL generic xml statistics
   --enable-dbi            General database statistics
   --enable-df             Filesystem usage statistics
   --enable-disk           Disk usage statistics
   --enable-dns            DNS traffic analysis
+  --enable-dpdkstat       Stats & Status from DPDK
   --enable-drbd           DRBD statistics
   --enable-email          EMail statistics
   --enable-entropy        Entropy statistics
   --enable-ethstat        Stats from NIC driver
   --enable-exec           Execution of external programs
   --enable-fhcount        File handles statistics
   --enable-filecount      Count files in directories
   --enable-fscache        fscache statistics
   --enable-gmond          Ganglia plugin
   --enable-gps            GPS plugin
   --enable-grpc           gRPC plugin
   --enable-hddtemp        Query hddtempd
+  --enable-hugepages      Hugepages statistics
+  --enable-intel_rdt      Intel RDT monitor plugin
   --enable-interface      Interface traffic statistics
   --enable-ipc            IPC statistics
   --enable-ipmi           IPMI sensor statistics
   --enable-iptables       IPTables rule counters
   --enable-ipvs           IPVS connection statistics
   --enable-irq            IRQ statistics
@@ -2409,12 +2441,14 @@
   --enable-wireless       Wireless statistics
   --enable-write_graphite Graphite / Carbon output plugin
   --enable-write_http     HTTP output plugin
   --enable-write_kafka    Kafka output plugin
   --enable-write_log      Log output plugin
   --enable-write_mongodb  MongoDB output plugin
+  --enable-write_prometheus
+                          Prometheus write plugin
   --enable-write_redis    Redis output plugin
   --enable-write_riemann  Riemann output plugin
   --enable-write_sensu    Sensu output plugin
   --enable-write_tsdb     TSDB output plugin
   --enable-xencpu         Xen Host CPU usage
   --enable-xmms           XMMS statistics
@@ -2455,18 +2489,21 @@
   --with-libgcrypt[=PREFIX]
                           Path to libgcrypt.
   --with-libgps[=PREFIX]  Path to libgps.
   --with-libgrpc++[=PREFIX]
                           Path to libgrpc++.
   --with-libiptc[=PREFIX] Path to libiptc.
+  --without-libdpdk       Disable libdpdk.
   --with-java[=PREFIX]    Path to Java home.
   --with-libldap[=PREFIX] Path to libldap.
   --with-liblvm2app[=PREFIX]
                           Path to liblvm2app.
   --with-libmemcached[=PREFIX]
                           Path to libmemcached.
+  --with-libmicrohttpd[=PREFIX]
+                          Path to libmicrohttpd.
   --with-libmodbus[=PREFIX]
                           Path to the modbus library.
   --with-libmongoc[=PREFIX]
                           Path to libmongoc.
   --with-libmosquitto[=PREFIX]
                           Path to libmosquitto.
@@ -2485,12 +2522,13 @@
                           Path to Oracle.
   --with-libowcapi[=PREFIX]
                           Path to libowcapi.
   --with-libpcap[=PREFIX] Path to libpcap.
   --with-libperl[=PREFIX] Path to libperl.
   --with-libpq[=PREFIX]   Path to libpq.
+  --with-libpqos[=PREFIX] Path to libpqos.
   --with-libprotobuf[=PREFIX]
                           Path to libprotobuf.
   --with-libprotobuf-c[=PREFIX]
                           Path to libprotobuf-c.
   --with-libpython        if we should build with libpython [default=yes]
 
@@ -2552,16 +2590,24 @@
   KERNEL_DIR  path to Linux kernel sources
   HAL_CFLAGS  C compiler flags for HAL, overriding pkg-config
   HAL_LIBS    linker flags for HAL, overriding pkg-config
   GRPCPP_CFLAGS
               C compiler flags for GRPCPP, overriding pkg-config
   GRPCPP_LIBS linker flags for GRPCPP, overriding pkg-config
+  LIBDPDK_CPPFLAGS
+              Preprocessor flags for libdpdk
+  LIBDPDK_LDFLAGS
+              Linker flags for libdpdk
   LIBLUA_PKG_CONFIG_NAME
               Name of liblua used by pkg-config
   LUA_CFLAGS  C compiler flags for LUA, overriding pkg-config
   LUA_LIBS    linker flags for LUA, overriding pkg-config
+  MICROHTTPD_CFLAGS
+              C compiler flags for MICROHTTPD, overriding pkg-config
+  MICROHTTPD_LIBS
+              linker flags for MICROHTTPD, overriding pkg-config
   LIBNETAPP_CPPFLAGS
               C preprocessor flags required to build with libnetapp
   LIBNETAPP_LDFLAGS
               Linker flags required to build with libnetapp
   LIBNETAPP_LIBS
               Other libraries required to link against libnetapp
@@ -2659,13 +2705,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-collectd configure 5.6.3
+collectd configure 5.7.0
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -3389,13 +3435,13 @@
 
 } # ac_fn_cxx_check_header_mongrel
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by collectd $as_me 5.6.3, which was
+It was created by collectd $as_me 5.7.0, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 exec 5>>config.log
@@ -8722,16 +8768,12 @@
 echo "$lt_simple_link_test_code" >conftest.$ac_ext
 eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
 _lt_linker_boilerplate=`cat conftest.err`
 $RM -r conftest*
 
 
-## CAVEAT EMPTOR:
-## There is no encapsulation within the following macros, do not change
-## the running order or otherwise move them around unless you know exactly
-## what you are doing...
 if test -n "$compiler"; then
 
 lt_prog_compiler_no_builtin_flag=
 
 if test "$GCC" = yes; then
   case $cc_basename in
@@ -13864,13 +13906,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='collectd'
- VERSION='5.6.3'
+ VERSION='5.7.0'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -19626,13 +19668,60 @@
 
 $as_echo "#define HAVE_STDBOOL_H 1" >>confdefs.h
 
 fi
 
 
-for ac_header in stdio.h errno.h math.h stdarg.h syslog.h fcntl.h signal.h assert.h sys/types.h sys/socket.h sys/select.h poll.h netdb.h arpa/inet.h sys/resource.h sys/param.h kstat.h regex.h sys/ioctl.h endian.h sys/isa_defs.h fnmatch.h libgen.h
+for ac_header in  \
+  arpa/inet.h \
+  assert.h \
+  ctype.h \
+  endian.h \
+  errno.h \
+  fcntl.h \
+  fnmatch.h \
+  fs_info.h \
+  fshelp.h \
+  grp.h \
+  kstat.h \
+  kvm.h \
+  libgen.h \
+  limits.h \
+  locale.h \
+  math.h \
+  mntent.h \
+  mnttab.h \
+  netdb.h \
+  paths.h \
+  poll.h \
+  pthread_np.h \
+  pwd.h \
+  regex.h \
+  signal.h \
+  stdarg.h \
+  stdio.h \
+  sys/fs_types.h \
+  sys/fstyp.h \
+  sys/ioctl.h \
+  sys/isa_defs.h \
+  sys/mntent.h \
+  sys/mnttab.h \
+  sys/param.h \
+  sys/resource.h \
+  sys/select.h \
+  sys/socket.h \
+  sys/statfs.h \
+  sys/statvfs.h \
+  sys/types.h \
+  sys/un.h \
+  sys/vfs.h \
+  sys/vfstab.h \
+  sys/vmmeter.h \
+  syslog.h \
+  wordexp.h \
+
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
 if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
@@ -20533,49 +20622,12 @@
 
 fi
 
 done
 
 
-for ac_header in  \
-  ctype.h \
-  fs_info.h \
-  fshelp.h \
-  grp.h \
-  kvm.h \
-  limits.h \
-  locale.h \
-  mntent.h \
-  mnttab.h \
-  paths.h \
-  pwd.h \
-  sys/fs_types.h \
-  sys/fstyp.h \
-  sys/mntent.h \
-  sys/mnttab.h \
-  sys/statfs.h \
-  sys/statvfs.h \
-  sys/un.h \
-  sys/vfs.h \
-  sys/vfstab.h \
-  sys/vmmeter.h \
-  wordexp.h \
-
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
 # --enable-xfs {{{
 # Check whether --enable-xfs was given.
 if test "${enable_xfs+set}" = set; then :
   enableval=$enable_xfs;
 else
   enable_xfs="auto"
@@ -20870,15 +20922,15 @@
   have_capability="no (<sys/capability.h> not found)"
 fi
 
 done
 
 if test "x$have_capability" = "xyes"; then
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for cap_get_proc in -lcap" >&5
-$as_echo_n "checking for cap_get_proc in -lcap... " >&6; }
-if ${ac_cv_lib_cap_cap_get_proc+:} false; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for cap_get_bound in -lcap" >&5
+$as_echo_n "checking for cap_get_bound in -lcap... " >&6; }
+if ${ac_cv_lib_cap_cap_get_bound+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lcap  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -20886,46 +20938,36 @@
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
 #ifdef __cplusplus
 extern "C"
 #endif
-char cap_get_proc ();
+char cap_get_bound ();
 int
 main ()
 {
-return cap_get_proc ();
+return cap_get_bound ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_cap_cap_get_proc=yes
+  ac_cv_lib_cap_cap_get_bound=yes
 else
-  ac_cv_lib_cap_cap_get_proc=no
+  ac_cv_lib_cap_cap_get_bound=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_cap_cap_get_proc" >&5
-$as_echo "$ac_cv_lib_cap_cap_get_proc" >&6; }
-if test "x$ac_cv_lib_cap_cap_get_proc" = xyes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_cap_cap_get_bound" >&5
+$as_echo "$ac_cv_lib_cap_cap_get_bound" >&6; }
+if test "x$ac_cv_lib_cap_cap_get_bound" = xyes; then :
   have_capability="yes"
 else
-  have_capability="no (cap_get_proc() not found)"
-fi
-
-fi
-if test "x$have_capability" = "xyes"; then
-ac_fn_c_check_decl "$LINENO" "CAP_IS_SUPPORTED" "ac_cv_have_decl_CAP_IS_SUPPORTED" "#include <sys/capability.h>
-"
-if test "x$ac_cv_have_decl_CAP_IS_SUPPORTED" = xyes; then :
-  have_capability="yes"
-else
-  have_capability="no (CAP_IS_SUPPORTED not found)"
+  have_capability="no (cap_get_bound() not found)"
 fi
 
 fi
 if test "x$have_capability" = "xyes"; then
 
 $as_echo "#define HAVE_CAPABILITY 1" >>confdefs.h
@@ -21929,138 +21971,12 @@
 if test "x$GCC" = "xyes"
 then
 	CFLAGS="$SAVE_CFLAGS"
 fi
 # }}} Check for strptime
 
-# Check for timegm {{{
-
-# These checks need -Werror because implicit function declarations are only a
-# warning ...
-SAVE_CFLAGS="$CFLAGS"
-CFLAGS="$CFLAGS -Werror"
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for timegm" >&5
-$as_echo_n "checking for timegm... " >&6; }
-if ${c_cv_have_timegm+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#if STRPTIME_NEEDS_STANDARDS
-# ifndef _ISOC99_SOURCE
-#  define _ISOC99_SOURCE 1
-# endif
-# ifndef _POSIX_C_SOURCE
-#  define _POSIX_C_SOURCE 200112L
-# endif
-# ifndef _XOPEN_SOURCE
-#  define _XOPEN_SOURCE 500
-# endif
-#endif
-#include <time.h>
-
-int
-main ()
-{
-
- time_t t = timegm(&(struct tm){0});
- if (t == ((time_t) -1)) {
-   return 1;
- }
-
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  c_cv_have_timegm="yes"
-else
-  c_cv_have_timegm="no"
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $c_cv_have_timegm" >&5
-$as_echo "$c_cv_have_timegm" >&6; }
-
-if test "x$c_cv_have_timegm" != "xyes"
-then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for timegm with _BSD_SOURCE" >&5
-$as_echo_n "checking for timegm with _BSD_SOURCE... " >&6; }
-if ${c_cv_have_timegm_bsd+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#if STRPTIME_NEEDS_STANDARDS
-# ifndef _ISOC99_SOURCE
-#  define _ISOC99_SOURCE 1
-# endif
-# ifndef _POSIX_C_SOURCE
-#  define _POSIX_C_SOURCE 200112L
-# endif
-# ifndef _XOPEN_SOURCE
-#  define _XOPEN_SOURCE 500
-# endif
-#endif
-#ifndef _BSD_SOURCE
-# define _BSD_SOURCE 1
-#endif
-#include <time.h>
-
-int
-main ()
-{
-
- time_t t = timegm(&(struct tm){0});
- if (t == ((time_t) -1)) {
-   return 1;
- }
-
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  c_cv_have_timegm_bsd="yes"
-       c_cv_have_timegm="yes"
-else
-  c_cv_have_timegm_bsd="no"
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $c_cv_have_timegm_bsd" >&5
-$as_echo "$c_cv_have_timegm_bsd" >&6; }
-fi
-
-if test "x$c_cv_have_timegm" = "xyes"
-then
-
-$as_echo "#define HAVE_TIMEGM 1" >>confdefs.h
-
-  if test "x$c_cv_have_timegm_bsd" = "xyes"
-  then
-
-$as_echo "#define TIMEGM_NEEDS_BSD 1" >>confdefs.h
-
-  fi
-fi
-
-CFLAGS="$SAVE_CFLAGS"
-# }}} Check for timegm
-
 for ac_func in swapctl
 do :
   ac_fn_c_check_func "$LINENO" "swapctl" "ac_cv_func_swapctl"
 if test "x$ac_cv_func_swapctl" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_SWAPCTL 1
@@ -23498,12 +23414,85 @@
 _ACEOF
 
 
 fi
 
 
+# check for pthread_setname_np
+SAVE_LDFLAGS="$LDFLAGS"
+LDFLAGS="$LDFLAGS -lpthread"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_setname_np" >&5
+$as_echo_n "checking for pthread_setname_np... " >&6; }
+	have_pthread_setname_np="no"
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#define _GNU_SOURCE
+#include <pthread.h>
+
+int
+main ()
+{
+
+        pthread_setname_np((pthread_t) {0}, "conftest");
+
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+		have_pthread_setname_np="yes"
+
+$as_echo "#define HAVE_PTHREAD_SETNAME_NP 1" >>confdefs.h
+
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_pthread_setname_np" >&5
+$as_echo "$have_pthread_setname_np" >&6; }
+
+# check for pthread_set_name_np(3) (FreeBSD)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_set_name_np" >&5
+$as_echo_n "checking for pthread_set_name_np... " >&6; }
+	have_pthread_set_name_np="no"
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <pthread_np.h>
+
+int
+main ()
+{
+
+        pthread_set_name_np((pthread_t) {0}, "conftest");
+
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+		have_pthread_set_name_np="yes"
+
+$as_echo "#define HAVE_PTHREAD_SET_NAME_NP 1" >>confdefs.h
+
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_pthread_set_name_np" >&5
+$as_echo "$have_pthread_set_name_np" >&6; }
+
+LDFLAGS="$SAVE_LDFLAGS"
+
 #
 # Checks for libraries begin here
 #
 
 with_libresolv="yes"
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for res_search in -lresolv" >&5
@@ -25770,12 +25759,101 @@
 	BUILD_WITH_LIBIPTC_LDFLAGS="$with_libiptc_libs"
 
 
 fi
 # }}}
 
+# --with-libdpdk {{{
+
+
+
+
+# Check whether --with-libdpdk was given.
+if test "${with_libdpdk+set}" = set; then :
+  withval=$with_libdpdk;
+fi
+
+
+if test "x$with_libdpdk" != "xno"
+then
+	if test "x$LIBDPDK_CPPFLAGS" = "x"
+	then
+		LIBDPDK_CPPFLAGS="-I/usr/include/dpdk"
+	fi
+	SAVE_CPPFLAGS="$CPPFLAGS"
+	CPPFLAGS="$LIBDPDK_CPPFLAGS $CPPFLAGS"
+	for ac_header in rte_config.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "rte_config.h" "ac_cv_header_rte_config_h" "$ac_includes_default"
+if test "x$ac_cv_header_rte_config_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_RTE_CONFIG_H 1
+_ACEOF
+ with_libdpdk="yes"
+else
+  with_libdpdk="no (rte_config.h not found)"
+
+fi
+
+done
+
+	CPPFLAGS="$SAVE_CPPFLAGS"
+fi
+
+if test "x$with_libdpdk" = "xyes"
+then
+	SAVE_LDFLAGS="$LDFLAGS"
+	LDFLAGS="$LIBDPDK_LDFLAGS $LDFLAGS"
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for rte_eal_init in -ldpdk" >&5
+$as_echo_n "checking for rte_eal_init in -ldpdk... " >&6; }
+if ${ac_cv_lib_dpdk_rte_eal_init+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldpdk  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char rte_eal_init ();
+int
+main ()
+{
+return rte_eal_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dpdk_rte_eal_init=yes
+else
+  ac_cv_lib_dpdk_rte_eal_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dpdk_rte_eal_init" >&5
+$as_echo "$ac_cv_lib_dpdk_rte_eal_init" >&6; }
+if test "x$ac_cv_lib_dpdk_rte_eal_init" = xyes; then :
+  with_libdpdk="yes"
+else
+  with_libdpdk="no (symbol 'rte_eal_init' not found)"
+
+fi
+
+	LDFLAGS="$SAVE_LDFLAGS"
+fi
+
+# }}}
+
 # --with-java {{{
 with_java_home="$JAVA_HOME"
 if test "x$with_java_home" = "x"
 then
 	with_java_home="/usr/lib/jvm"
 fi
@@ -36006,12 +36084,200 @@
   BUILD_WITH_LIBMEMCACHED_TRUE='#'
   BUILD_WITH_LIBMEMCACHED_FALSE=
 fi
 
 # }}}
 
+# --with-libmicrohttpd {{{
+with_libmicrohttpd_cppflags=""
+with_libmicrohttpd_ldflags=""
+
+# Check whether --with-libmicrohttpd was given.
+if test "${with_libmicrohttpd+set}" = set; then :
+  withval=$with_libmicrohttpd;
+    if test "x$withval" != "xno" && test "x$withval" != "xyes"
+    then
+      with_libmicrohttpd_cppflags="-I$withval/include"
+      with_libmicrohttpd_ldflags="-L$withval/lib"
+      with_libmicrohttpd="yes"
+    fi
+    if test "x$withval" = "xno"
+    then
+      with_libmicrohttpd="no (disabled on command line)"
+    fi
+
+else
+  withval="yes"
+
+fi
+
+if test "x$withval" = "xyes"
+then
+
+pkg_failed=no
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for MICROHTTPD" >&5
+$as_echo_n "checking for MICROHTTPD... " >&6; }
+
+if test -n "$MICROHTTPD_CFLAGS"; then
+    pkg_cv_MICROHTTPD_CFLAGS="$MICROHTTPD_CFLAGS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libmicrohttpd\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "libmicrohttpd") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_MICROHTTPD_CFLAGS=`$PKG_CONFIG --cflags "libmicrohttpd" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+if test -n "$MICROHTTPD_LIBS"; then
+    pkg_cv_MICROHTTPD_LIBS="$MICROHTTPD_LIBS"
+ elif test -n "$PKG_CONFIG"; then
+    if test -n "$PKG_CONFIG" && \
+    { { $as_echo "$as_me:${as_lineno-$LINENO}: \$PKG_CONFIG --exists --print-errors \"libmicrohttpd\""; } >&5
+  ($PKG_CONFIG --exists --print-errors "libmicrohttpd") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  pkg_cv_MICROHTTPD_LIBS=`$PKG_CONFIG --libs "libmicrohttpd" 2>/dev/null`
+		      test "x$?" != "x0" && pkg_failed=yes
+else
+  pkg_failed=yes
+fi
+ else
+    pkg_failed=untried
+fi
+
+
+
+if test $pkg_failed = yes; then
+   	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi
+        if test $_pkg_short_errors_supported = yes; then
+	        MICROHTTPD_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "libmicrohttpd" 2>&1`
+        else
+	        MICROHTTPD_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "libmicrohttpd" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$MICROHTTPD_PKG_ERRORS" >&5
+
+	with_libmicrohttpd="no (pkg-config could not find libmicrohttpd)"
+
+elif test $pkg_failed = untried; then
+     	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	with_libmicrohttpd="no (pkg-config could not find libmicrohttpd)"
+
+else
+	MICROHTTPD_CFLAGS=$pkg_cv_MICROHTTPD_CFLAGS
+	MICROHTTPD_LIBS=$pkg_cv_MICROHTTPD_LIBS
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	with_libmicrohttpd="yes"
+fi
+fi
+
+if test "x$MICROHTTPD_LIBS" = "x"
+then
+  MICROHTTPD_LIBS="-lmicrohttpd"
+fi
+
+SAVE_CPPFLAGS="$CPPFLAGS"
+SAVE_LDFLAGS="$LDFLAGS"
+SAVE_LIBS="$LIBS"
+CPPFLAGS="$with_libmicrohttpd_cppflags $MICROHTTPD_CFLAGS"
+LDFLAGS="$with_libmicrohttpd_ldflags $LDFLAGS"
+LIBS="$LIBS $MICROHTTPD_LIBS"
+
+if test "x$with_libmicrohttpd" = "xyes"
+then
+  for ac_header in microhttpd.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "microhttpd.h" "ac_cv_header_microhttpd_h" "$ac_includes_default"
+if test "x$ac_cv_header_microhttpd_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_MICROHTTPD_H 1
+_ACEOF
+ with_libmicrohttpd="yes"
+else
+  with_libmicrohttpd="no (<microhttpd.h> not found)"
+fi
+
+done
+
+fi
+
+if test "x$with_libmicrohttpd" = "xyes"
+then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for MHD_start_daemon in -lmicrohttpd" >&5
+$as_echo_n "checking for MHD_start_daemon in -lmicrohttpd... " >&6; }
+if ${ac_cv_lib_microhttpd_MHD_start_daemon+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lmicrohttpd  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char MHD_start_daemon ();
+int
+main ()
+{
+return MHD_start_daemon ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_microhttpd_MHD_start_daemon=yes
+else
+  ac_cv_lib_microhttpd_MHD_start_daemon=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_microhttpd_MHD_start_daemon" >&5
+$as_echo "$ac_cv_lib_microhttpd_MHD_start_daemon" >&6; }
+if test "x$ac_cv_lib_microhttpd_MHD_start_daemon" = xyes; then :
+  with_libmicrohttpd="yes"
+else
+  with_libmicrohttpd="no (libmicrohttpd not found)"
+fi
+
+fi
+
+CPPFLAGS="$SAVE_CPPFLAGS"
+LDFLAGS="$SAVE_LDFLAGS"
+LIBS="$SAVE_LIBS"
+
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS="$with_libmicrohttpd_cppflags $MICROHTTPD_CFLAGS"
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS="$with_libmicrohttpd_ldflags"
+BUILD_WITH_LIBMICROHTTPD_LIBS="$MICROHTTPD_LIBS"
+
+
+
+# }}}
+
 # --with-libmodbus {{{
 with_libmodbus_config=""
 with_libmodbus_cflags=""
 with_libmodbus_libs=""
 
 # Check whether --with-libmodbus was given.
@@ -38045,12 +38311,120 @@
   BUILD_WITH_LIBPQ_TRUE='#'
   BUILD_WITH_LIBPQ_FALSE=
 fi
 
 # }}}
 
+# --with-libpqos {{{
+with_libpqos_cppflags=""
+with_libpqos_ldflags=""
+
+# Check whether --with-libpqos was given.
+if test "${with_libpqos+set}" = set; then :
+  withval=$with_libpqos;
+	if test "x$withval" != "xno" && test "x$withval" != "xyes"
+	then
+		with_libpqos_cppflags="-I$withval/include"
+		with_libpqos_ldflags="-L$withval/lib"
+		with_libpqos="yes"
+	else
+		with_libpqos="$withval"
+	fi
+
+else
+
+	with_libpqos="yes"
+
+fi
+
+if test "x$with_libpqos" = "xyes"
+then
+	SAVE_CPPFLAGS="$CPPFLAGS"
+	CPPFLAGS="$CPPFLAGS $with_libpqos_cppflags"
+
+	for ac_header in pqos.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "pqos.h" "ac_cv_header_pqos_h" "$ac_includes_default"
+if test "x$ac_cv_header_pqos_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_PQOS_H 1
+_ACEOF
+ with_libpqos="yes"
+else
+  with_libpqos="no (pqos.h not found)"
+fi
+
+done
+
+
+	CPPFLAGS="$SAVE_CPPFLAGS"
+fi
+if test "x$with_libpqos" = "xyes"
+then
+	SAVE_CPPFLAGS="$CPPFLAGS"
+	SAVE_LDFLAGS="$LDFLAGS"
+	CPPFLAGS="$CPPFLAGS $with_libpqos_cppflags"
+	LDFLAGS="$LDFLAGS $with_libpqos_ldflags"
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for pqos_init in -lpqos" >&5
+$as_echo_n "checking for pqos_init in -lpqos... " >&6; }
+if ${ac_cv_lib_pqos_pqos_init+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpqos  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pqos_init ();
+int
+main ()
+{
+return pqos_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_pqos_pqos_init=yes
+else
+  ac_cv_lib_pqos_pqos_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pqos_pqos_init" >&5
+$as_echo "$ac_cv_lib_pqos_pqos_init" >&6; }
+if test "x$ac_cv_lib_pqos_pqos_init" = xyes; then :
+  with_libpqos="yes"
+else
+  with_libpqos="no (Can't find libpqos)"
+fi
+
+
+	CPPFLAGS="$SAVE_CPPFLAGS"
+	LDFLAGS="$SAVE_LDFLAGS"
+fi
+if test "x$with_libpqos" = "xyes"
+then
+	BUILD_WITH_LIBPQOS_CPPFLAGS="$with_libpqos_cppflags"
+	BUILD_WITH_LIBPQOS_LDFLAGS="$with_libpqos_ldflags"
+	BUILD_WITH_LIBPQOS_LIBS="-lpqos"
+
+
+
+fi
+# }}}
+
 # --with-libprotobuf {{{
 with_libprotobuf_cppflags=""
 with_libprotobuf_ldflags=""
 
 # Check whether --with-libprotobuf was given.
 if test "${with_libprotobuf+set}" = set; then :
@@ -41782,18 +42156,21 @@
 plugin_cpusleep="no"
 plugin_curl_json="no"
 plugin_curl_xml="no"
 plugin_df="no"
 plugin_disk="no"
 plugin_drbd="no"
+plugin_dpdkstat="no"
 plugin_entropy="no"
 plugin_ethstat="no"
 plugin_fhcount="no"
 plugin_fscache="no"
 plugin_gps="no"
 plugin_grpc="no"
+plugin_hugepages="no"
+plugin_intel_rdt="no"
 plugin_interface="no"
 plugin_ipmi="no"
 plugin_ipvs="no"
 plugin_irq="no"
 plugin_load="no"
 plugin_log_logstash="no"
@@ -41817,12 +42194,13 @@
 plugin_uptime="no"
 plugin_users="no"
 plugin_virt="no"
 plugin_vmem="no"
 plugin_vserver="no"
 plugin_wireless="no"
+plugin_write_prometheus="no"
 plugin_xencpu="no"
 plugin_zfs_arc="no"
 plugin_zone="no"
 plugin_zookeeper="no"
 
 # Linux
@@ -41836,12 +42214,13 @@
 	plugin_cpufreq="yes"
 	plugin_disk="yes"
 	plugin_drbd="yes"
 	plugin_entropy="yes"
 	plugin_fhcount="yes"
 	plugin_fscache="yes"
+	plugin_hugepages="yes"
 	plugin_interface="yes"
 	plugin_ipc="yes"
 	plugin_irq="yes"
 	plugin_load="yes"
 	plugin_lvm="yes"
 	plugin_memory="yes"
@@ -42107,12 +42486,16 @@
 	plugin_perl="yes"
 fi
 
 if test "x$have_protoc_c" = "xyes" && test "x$with_libprotobuf_c" = "xyes"
 then
 	plugin_pinba="yes"
+	if test "x$with_libmicrohttpd" = "xyes"
+	then
+		plugin_write_prometheus="yes"
+	fi
 fi
 
 # Mac OS X memory interface
 if test "x$have_host_statistics" = "xyes"
 then
 	plugin_memory="yes"
@@ -42188,12 +42571,17 @@
 
 if test "x$with_libxenctrl" = "xyes"
 then
   plugin_xencpu="yes"
 fi
 
+if test "x$with_libdpdk" = "xyes"
+then
+  plugin_dpdkstat="yes"
+fi
+
 
 
 # Check whether --enable-all-plugins was given.
 if test "${enable_all_plugins+set}" = set; then :
   enableval=$enable_all_plugins;
 		 if test "x$enableval" = "xyes"
@@ -43773,12 +44161,72 @@
     enable_dns="$enable_plugin"
 
 
 
     enable_plugin="no"
     force="no"
+    # Check whether --enable-dpdkstat was given.
+if test "${enable_dpdkstat+set}" = set; then :
+  enableval=$enable_dpdkstat;
+     if test "x$enableval" = "xyes"
+     then
+	     enable_plugin="yes"
+     else if test "x$enableval" = "xforce"
+     then
+	     enable_plugin="yes"
+	     force="yes"
+     else
+	     enable_plugin="no (disabled on command line)"
+     fi; fi
+
+else
+
+	 if test "x$enable_all_plugins" = "xauto"
+	 then
+	     if test "x$plugin_dpdkstat" = "xyes"
+	     then
+		     enable_plugin="yes"
+	     else
+		     enable_plugin="$plugin_dpdkstat"
+	     fi
+	 else
+	     enable_plugin="$enable_all_plugins"
+	 fi
+
+fi
+
+    if test "x$enable_plugin" = "xyes"
+    then
+	    if test "x$plugin_dpdkstat" = "xyes" || test "x$force" = "xyes"
+	    then
+
+$as_echo "#define HAVE_PLUGIN_DPDKSTAT 1" >>confdefs.h
+
+		    if test "x$plugin_dpdkstat" != "xyes"
+		    then
+			    dependency_warning="yes"
+		    fi
+	    else # User passed "yes" but dependency checking yielded "no" => Dependency problem.
+		    dependency_error="yes"
+		    enable_plugin="$plugin_dpdkstat (dependency error)"
+	    fi
+    fi
+     if test "x$enable_plugin" = "xyes"; then
+  BUILD_PLUGIN_DPDKSTAT_TRUE=
+  BUILD_PLUGIN_DPDKSTAT_FALSE='#'
+else
+  BUILD_PLUGIN_DPDKSTAT_TRUE='#'
+  BUILD_PLUGIN_DPDKSTAT_FALSE=
+fi
+
+    enable_dpdkstat="$enable_plugin"
+
+
+
+    enable_plugin="no"
+    force="no"
     # Check whether --enable-drbd was given.
 if test "${enable_drbd+set}" = set; then :
   enableval=$enable_drbd;
      if test "x$enableval" = "xyes"
      then
 	     enable_plugin="yes"
@@ -44493,12 +44941,132 @@
     enable_hddtemp="$enable_plugin"
 
 
 
     enable_plugin="no"
     force="no"
+    # Check whether --enable-hugepages was given.
+if test "${enable_hugepages+set}" = set; then :
+  enableval=$enable_hugepages;
+     if test "x$enableval" = "xyes"
+     then
+	     enable_plugin="yes"
+     else if test "x$enableval" = "xforce"
+     then
+	     enable_plugin="yes"
+	     force="yes"
+     else
+	     enable_plugin="no (disabled on command line)"
+     fi; fi
+
+else
+
+	 if test "x$enable_all_plugins" = "xauto"
+	 then
+	     if test "x$plugin_hugepages" = "xyes"
+	     then
+		     enable_plugin="yes"
+	     else
+		     enable_plugin="$plugin_hugepages"
+	     fi
+	 else
+	     enable_plugin="$enable_all_plugins"
+	 fi
+
+fi
+
+    if test "x$enable_plugin" = "xyes"
+    then
+	    if test "x$plugin_hugepages" = "xyes" || test "x$force" = "xyes"
+	    then
+
+$as_echo "#define HAVE_PLUGIN_HUGEPAGES 1" >>confdefs.h
+
+		    if test "x$plugin_hugepages" != "xyes"
+		    then
+			    dependency_warning="yes"
+		    fi
+	    else # User passed "yes" but dependency checking yielded "no" => Dependency problem.
+		    dependency_error="yes"
+		    enable_plugin="$plugin_hugepages (dependency error)"
+	    fi
+    fi
+     if test "x$enable_plugin" = "xyes"; then
+  BUILD_PLUGIN_HUGEPAGES_TRUE=
+  BUILD_PLUGIN_HUGEPAGES_FALSE='#'
+else
+  BUILD_PLUGIN_HUGEPAGES_TRUE='#'
+  BUILD_PLUGIN_HUGEPAGES_FALSE=
+fi
+
+    enable_hugepages="$enable_plugin"
+
+
+
+    enable_plugin="no"
+    force="no"
+    # Check whether --enable-intel_rdt was given.
+if test "${enable_intel_rdt+set}" = set; then :
+  enableval=$enable_intel_rdt;
+     if test "x$enableval" = "xyes"
+     then
+	     enable_plugin="yes"
+     else if test "x$enableval" = "xforce"
+     then
+	     enable_plugin="yes"
+	     force="yes"
+     else
+	     enable_plugin="no (disabled on command line)"
+     fi; fi
+
+else
+
+	 if test "x$enable_all_plugins" = "xauto"
+	 then
+	     if test "x$with_libpqos" = "xyes"
+	     then
+		     enable_plugin="yes"
+	     else
+		     enable_plugin="$with_libpqos"
+	     fi
+	 else
+	     enable_plugin="$enable_all_plugins"
+	 fi
+
+fi
+
+    if test "x$enable_plugin" = "xyes"
+    then
+	    if test "x$with_libpqos" = "xyes" || test "x$force" = "xyes"
+	    then
+
+$as_echo "#define HAVE_PLUGIN_INTEL_RDT 1" >>confdefs.h
+
+		    if test "x$with_libpqos" != "xyes"
+		    then
+			    dependency_warning="yes"
+		    fi
+	    else # User passed "yes" but dependency checking yielded "no" => Dependency problem.
+		    dependency_error="yes"
+		    enable_plugin="$with_libpqos (dependency error)"
+	    fi
+    fi
+     if test "x$enable_plugin" = "xyes"; then
+  BUILD_PLUGIN_INTEL_RDT_TRUE=
+  BUILD_PLUGIN_INTEL_RDT_FALSE='#'
+else
+  BUILD_PLUGIN_INTEL_RDT_TRUE='#'
+  BUILD_PLUGIN_INTEL_RDT_FALSE=
+fi
+
+    enable_intel_rdt="$enable_plugin"
+
+
+
+    enable_plugin="no"
+    force="no"
     # Check whether --enable-interface was given.
 if test "${enable_interface+set}" = set; then :
   enableval=$enable_interface;
      if test "x$enableval" = "xyes"
      then
 	     enable_plugin="yes"
@@ -50254,12 +50822,72 @@
     enable_write_mongodb="$enable_plugin"
 
 
 
     enable_plugin="no"
     force="no"
+    # Check whether --enable-write_prometheus was given.
+if test "${enable_write_prometheus+set}" = set; then :
+  enableval=$enable_write_prometheus;
+     if test "x$enableval" = "xyes"
+     then
+	     enable_plugin="yes"
+     else if test "x$enableval" = "xforce"
+     then
+	     enable_plugin="yes"
+	     force="yes"
+     else
+	     enable_plugin="no (disabled on command line)"
+     fi; fi
+
+else
+
+	 if test "x$enable_all_plugins" = "xauto"
+	 then
+	     if test "x$plugin_write_prometheus" = "xyes"
+	     then
+		     enable_plugin="yes"
+	     else
+		     enable_plugin="$plugin_write_prometheus"
+	     fi
+	 else
+	     enable_plugin="$enable_all_plugins"
+	 fi
+
+fi
+
+    if test "x$enable_plugin" = "xyes"
+    then
+	    if test "x$plugin_write_prometheus" = "xyes" || test "x$force" = "xyes"
+	    then
+
+$as_echo "#define HAVE_PLUGIN_WRITE_PROMETHEUS 1" >>confdefs.h
+
+		    if test "x$plugin_write_prometheus" != "xyes"
+		    then
+			    dependency_warning="yes"
+		    fi
+	    else # User passed "yes" but dependency checking yielded "no" => Dependency problem.
+		    dependency_error="yes"
+		    enable_plugin="$plugin_write_prometheus (dependency error)"
+	    fi
+    fi
+     if test "x$enable_plugin" = "xyes"; then
+  BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE=
+  BUILD_PLUGIN_WRITE_PROMETHEUS_FALSE='#'
+else
+  BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE='#'
+  BUILD_PLUGIN_WRITE_PROMETHEUS_FALSE=
+fi
+
+    enable_write_prometheus="$enable_plugin"
+
+
+
+    enable_plugin="no"
+    force="no"
     # Check whether --enable-write_redis was given.
 if test "${enable_write_redis+set}" = set; then :
   enableval=$enable_write_redis;
      if test "x$enableval" = "xyes"
      then
 	     enable_plugin="yes"
@@ -51488,12 +52116,16 @@
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_DNS_TRUE}" && test -z "${BUILD_PLUGIN_DNS_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_DNS\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${BUILD_PLUGIN_DPDKSTAT_TRUE}" && test -z "${BUILD_PLUGIN_DPDKSTAT_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_PLUGIN_DPDKSTAT\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${BUILD_PLUGIN_DRBD_TRUE}" && test -z "${BUILD_PLUGIN_DRBD_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_DRBD\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_EMAIL_TRUE}" && test -z "${BUILD_PLUGIN_EMAIL_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_EMAIL\" was never defined.
@@ -51536,12 +52168,20 @@
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_HDDTEMP_TRUE}" && test -z "${BUILD_PLUGIN_HDDTEMP_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_HDDTEMP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${BUILD_PLUGIN_HUGEPAGES_TRUE}" && test -z "${BUILD_PLUGIN_HUGEPAGES_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_PLUGIN_HUGEPAGES\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${BUILD_PLUGIN_INTEL_RDT_TRUE}" && test -z "${BUILD_PLUGIN_INTEL_RDT_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_PLUGIN_INTEL_RDT\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${BUILD_PLUGIN_INTERFACE_TRUE}" && test -z "${BUILD_PLUGIN_INTERFACE_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_INTERFACE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_IPC_TRUE}" && test -z "${BUILD_PLUGIN_IPC_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_IPC\" was never defined.
@@ -51920,12 +52560,16 @@
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_WRITE_MONGODB_TRUE}" && test -z "${BUILD_PLUGIN_WRITE_MONGODB_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_WRITE_MONGODB\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE}" && test -z "${BUILD_PLUGIN_WRITE_PROMETHEUS_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_PLUGIN_WRITE_PROMETHEUS\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${BUILD_PLUGIN_WRITE_REDIS_TRUE}" && test -z "${BUILD_PLUGIN_WRITE_REDIS_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_WRITE_REDIS\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${BUILD_PLUGIN_WRITE_RIEMANN_TRUE}" && test -z "${BUILD_PLUGIN_WRITE_RIEMANN_FALSE}"; then
   as_fn_error $? "conditional \"BUILD_PLUGIN_WRITE_RIEMANN\" was never defined.
@@ -52353,13 +52997,13 @@
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # Save the log message, to keep $0 and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by collectd $as_me 5.6.3, which was
+This file was extended by collectd $as_me 5.7.0, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -52419,13 +53063,13 @@
 Report bugs to the package provider."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-collectd config.status 5.6.3
+collectd config.status 5.7.0
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
 Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
@@ -54674,12 +55318,14 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libatasmart . . . . . $with_libatasmart" >&5
 $as_echo "    libatasmart . . . . . $with_libatasmart" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libcurl . . . . . . . $with_libcurl" >&5
 $as_echo "    libcurl . . . . . . . $with_libcurl" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libdbi  . . . . . . . $with_libdbi" >&5
 $as_echo "    libdbi  . . . . . . . $with_libdbi" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result:     libdpdk . . . . . . . $with_libdpdk" >&5
+$as_echo "    libdpdk . . . . . . . $with_libdpdk" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libesmtp  . . . . . . $with_libesmtp" >&5
 $as_echo "    libesmtp  . . . . . . $with_libesmtp" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libganglia  . . . . . $with_libganglia" >&5
 $as_echo "    libganglia  . . . . . $with_libganglia" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libgcrypt . . . . . . $with_libgcrypt" >&5
 $as_echo "    libgcrypt . . . . . . $with_libgcrypt" >&6; }
@@ -54708,12 +55354,14 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     liblua  . . . . . . . $with_liblua" >&5
 $as_echo "    liblua  . . . . . . . $with_liblua" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     liblvm2app  . . . . . $with_liblvm2app" >&5
 $as_echo "    liblvm2app  . . . . . $with_liblvm2app" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libmemcached  . . . . $with_libmemcached" >&5
 $as_echo "    libmemcached  . . . . $with_libmemcached" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result:     libmicrohttpd . . . . $with_libmicrohttpd" >&5
+$as_echo "    libmicrohttpd . . . . $with_libmicrohttpd" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libmnl  . . . . . . . $with_libmnl" >&5
 $as_echo "    libmnl  . . . . . . . $with_libmnl" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libmodbus . . . . . . $with_libmodbus" >&5
 $as_echo "    libmodbus . . . . . . $with_libmodbus" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libmongoc . . . . . . $with_libmongoc" >&5
 $as_echo "    libmongoc . . . . . . $with_libmongoc" >&6; }
@@ -54740,12 +55388,14 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libperfstat . . . . . $with_perfstat" >&5
 $as_echo "    libperfstat . . . . . $with_perfstat" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libperl . . . . . . . $with_libperl" >&5
 $as_echo "    libperl . . . . . . . $with_libperl" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libpq . . . . . . . . $with_libpq" >&5
 $as_echo "    libpq . . . . . . . . $with_libpq" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result:     libpqos . . . . . . . $with_libpqos" >&5
+$as_echo "    libpqos . . . . . . . $with_libpqos" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libprotobuf . . . . . $with_libprotobuf" >&5
 $as_echo "    libprotobuf . . . . . $with_libprotobuf" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libprotobuf-c . . . . $with_libprotobuf_c" >&5
 $as_echo "    libprotobuf-c . . . . $with_libprotobuf_c" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     libpython . . . . . . $with_libpython" >&5
 $as_echo "    libpython . . . . . . $with_libpython" >&6; }
@@ -54856,12 +55506,14 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     df  . . . . . . . . . $enable_df" >&5
 $as_echo "    df  . . . . . . . . . $enable_df" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     disk  . . . . . . . . $enable_disk" >&5
 $as_echo "    disk  . . . . . . . . $enable_disk" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     dns . . . . . . . . . $enable_dns" >&5
 $as_echo "    dns . . . . . . . . . $enable_dns" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result:     dpdkstat  . . . . . . $enable_dpdkstat" >&5
+$as_echo "    dpdkstat  . . . . . . $enable_dpdkstat" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     drbd  . . . . . . . . $enable_drbd" >&5
 $as_echo "    drbd  . . . . . . . . $enable_drbd" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     email . . . . . . . . $enable_email" >&5
 $as_echo "    email . . . . . . . . $enable_email" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     entropy . . . . . . . $enable_entropy" >&5
 $as_echo "    entropy . . . . . . . $enable_entropy" >&6; }
@@ -54880,12 +55532,16 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     gps . . . . . . . . . $enable_gps" >&5
 $as_echo "    gps . . . . . . . . . $enable_gps" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     grpc  . . . . . . . . $enable_grpc" >&5
 $as_echo "    grpc  . . . . . . . . $enable_grpc" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     hddtemp . . . . . . . $enable_hddtemp" >&5
 $as_echo "    hddtemp . . . . . . . $enable_hddtemp" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result:     hugepages . . . . . . $enable_hugepages" >&5
+$as_echo "    hugepages . . . . . . $enable_hugepages" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result:     intel_rdt. . . . .  . $enable_intel_rdt" >&5
+$as_echo "    intel_rdt. . . . .  . $enable_intel_rdt" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     interface . . . . . . $enable_interface" >&5
 $as_echo "    interface . . . . . . $enable_interface" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     ipc . . . . . . . . . $enable_ipc" >&5
 $as_echo "    ipc . . . . . . . . . $enable_ipc" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     ipmi  . . . . . . . . $enable_ipmi" >&5
 $as_echo "    ipmi  . . . . . . . . $enable_ipmi" >&6; }
@@ -55072,12 +55728,14 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     write_kafka . . . . . $enable_write_kafka" >&5
 $as_echo "    write_kafka . . . . . $enable_write_kafka" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     write_log . . . . . . $enable_write_log" >&5
 $as_echo "    write_log . . . . . . $enable_write_log" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     write_mongodb . . . . $enable_write_mongodb" >&5
 $as_echo "    write_mongodb . . . . $enable_write_mongodb" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result:     write_prometheus. . . $enable_write_prometheus" >&5
+$as_echo "    write_prometheus. . . $enable_write_prometheus" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     write_redis . . . . . $enable_write_redis" >&5
 $as_echo "    write_redis . . . . . $enable_write_redis" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     write_riemann . . . . $enable_write_riemann" >&5
 $as_echo "    write_riemann . . . . $enable_write_riemann" >&6; }
 { $as_echo "$as_me:${as_lineno-$LINENO}: result:     write_sensu . . . . . $enable_write_sensu" >&5
 $as_echo "    write_sensu . . . . . $enable_write_sensu" >&6; }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/configure.ac	2017-10-06 14:45:52.921917742 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/configure.ac	2016-12-12 16:03:36.680279316 +0800
@@ -211,13 +211,60 @@
 #
 AC_HEADER_STDC
 AC_HEADER_SYS_WAIT
 AC_HEADER_DIRENT
 AC_HEADER_STDBOOL
 
-AC_CHECK_HEADERS(stdio.h errno.h math.h stdarg.h syslog.h fcntl.h signal.h assert.h sys/types.h sys/socket.h sys/select.h poll.h netdb.h arpa/inet.h sys/resource.h sys/param.h kstat.h regex.h sys/ioctl.h endian.h sys/isa_defs.h fnmatch.h libgen.h)
+AC_CHECK_HEADERS([ \
+  arpa/inet.h \
+  assert.h \
+  ctype.h \
+  endian.h \
+  errno.h \
+  fcntl.h \
+  fnmatch.h \
+  fs_info.h \
+  fshelp.h \
+  grp.h \
+  kstat.h \
+  kvm.h \
+  libgen.h \
+  limits.h \
+  locale.h \
+  math.h \
+  mntent.h \
+  mnttab.h \
+  netdb.h \
+  paths.h \
+  poll.h \
+  pthread_np.h \
+  pwd.h \
+  regex.h \
+  signal.h \
+  stdarg.h \
+  stdio.h \
+  sys/fs_types.h \
+  sys/fstyp.h \
+  sys/ioctl.h \
+  sys/isa_defs.h \
+  sys/mntent.h \
+  sys/mnttab.h \
+  sys/param.h \
+  sys/resource.h \
+  sys/select.h \
+  sys/socket.h \
+  sys/statfs.h \
+  sys/statvfs.h \
+  sys/types.h \
+  sys/un.h \
+  sys/vfs.h \
+  sys/vfstab.h \
+  sys/vmmeter.h \
+  syslog.h \
+  wordexp.h \
+])
 
 # For entropy plugin on newer NetBSD
 AC_CHECK_HEADERS(sys/rndio.h, [], [],
 [#if HAVE_SYS_TYPES_H
 # include <sys/types.h>
 #endif
@@ -655,37 +702,12 @@
 [
 #if HAVE_SYS_SOCKET_H
 #	include <sys/socket.h>
 #endif
 ])
 
-AC_CHECK_HEADERS([ \
-  ctype.h \
-  fs_info.h \
-  fshelp.h \
-  grp.h \
-  kvm.h \
-  limits.h \
-  locale.h \
-  mntent.h \
-  mnttab.h \
-  paths.h \
-  pwd.h \
-  sys/fs_types.h \
-  sys/fstyp.h \
-  sys/mntent.h \
-  sys/mnttab.h \
-  sys/statfs.h \
-  sys/statvfs.h \
-  sys/un.h \
-  sys/vfs.h \
-  sys/vfstab.h \
-  sys/vmmeter.h \
-  wordexp.h \
-])
-
 # --enable-xfs {{{
 AC_ARG_ENABLE([xfs],
   [AS_HELP_STRING([--enable-xfs], [xfs support in df plugin @<:@default=yes@:>@])],
   [],
   [enable_xfs="auto"]
 )
@@ -810,24 +832,18 @@
 
 have_capability="yes"
 AC_CHECK_HEADERS(sys/capability.h,
                  [have_capability="yes"],
                  [have_capability="no (<sys/capability.h> not found)"])
 if test "x$have_capability" = "xyes"; then
-AC_CHECK_LIB(cap, cap_get_proc,
-                 [have_capability="yes"],
-                 [have_capability="no (cap_get_proc() not found)"])
-fi
-if test "x$have_capability" = "xyes"; then
-AC_CHECK_DECL([CAP_IS_SUPPORTED],
+AC_CHECK_LIB(cap, cap_get_bound,
                  [have_capability="yes"],
-                 [have_capability="no (CAP_IS_SUPPORTED not found)"],
-                 [[#include <sys/capability.h>]])
+                 [have_capability="no (cap_get_bound() not found)"])
 fi
 if test "x$have_capability" = "xyes"; then
-  AC_DEFINE(HAVE_CAPABILITY, 1, [Define to 1 if you have cap_get_proc() (-lcap).])
+  AC_DEFINE(HAVE_CAPABILITY, 1, [Define to 1 if you have cap_get_bound() (-lcap).])
 fi
 AM_CONDITIONAL(BUILD_WITH_CAPABILITY, test "x$have_capability" = "xyes")
 
 #
 # Checks for typedefs, structures, and compiler characteristics.
 #
@@ -1043,98 +1059,12 @@
 if test "x$GCC" = "xyes"
 then
 	CFLAGS="$SAVE_CFLAGS"
 fi
 # }}} Check for strptime
 
-# Check for timegm {{{
-
-# These checks need -Werror because implicit function declarations are only a
-# warning ...
-SAVE_CFLAGS="$CFLAGS"
-CFLAGS="$CFLAGS -Werror"
-
-AC_CACHE_CHECK([for timegm],
-  [c_cv_have_timegm],
-  AC_LINK_IFELSE(
-    [AC_LANG_PROGRAM(
-[[[
-#if STRPTIME_NEEDS_STANDARDS
-# ifndef _ISOC99_SOURCE
-#  define _ISOC99_SOURCE 1
-# endif
-# ifndef _POSIX_C_SOURCE
-#  define _POSIX_C_SOURCE 200112L
-# endif
-# ifndef _XOPEN_SOURCE
-#  define _XOPEN_SOURCE 500
-# endif
-#endif
-#include <time.h>
-]]],
-[[[
- time_t t = timegm(&(struct tm){0});
- if (t == ((time_t) -1)) {
-   return 1;
- }
-]]]
-    )],
-    [c_cv_have_timegm="yes"],
-    [c_cv_have_timegm="no"]
-  )
-)
-
-if test "x$c_cv_have_timegm" != "xyes"
-then
-  AC_CACHE_CHECK([for timegm with _BSD_SOURCE],
-    [c_cv_have_timegm_bsd],
-    AC_LINK_IFELSE(
-      [AC_LANG_PROGRAM(
-[[[
-#if STRPTIME_NEEDS_STANDARDS
-# ifndef _ISOC99_SOURCE
-#  define _ISOC99_SOURCE 1
-# endif
-# ifndef _POSIX_C_SOURCE
-#  define _POSIX_C_SOURCE 200112L
-# endif
-# ifndef _XOPEN_SOURCE
-#  define _XOPEN_SOURCE 500
-# endif
-#endif
-#ifndef _BSD_SOURCE
-# define _BSD_SOURCE 1
-#endif
-#include <time.h>
-]]],
-[[[
- time_t t = timegm(&(struct tm){0});
- if (t == ((time_t) -1)) {
-   return 1;
- }
-]]]
-      )],
-      [c_cv_have_timegm_bsd="yes"
-       c_cv_have_timegm="yes"],
-      [c_cv_have_timegm_bsd="no"]
-    )
-  )
-fi
-
-if test "x$c_cv_have_timegm" = "xyes"
-then
-  AC_DEFINE(HAVE_TIMEGM, 1, [Define if the timegm(3) function is available.])
-  if test "x$c_cv_have_timegm_bsd" = "xyes"
-  then
-    AC_DEFINE(TIMEGM_NEEDS_BSD, 1, [Set to true if timegm is only exported in BSD mode.])
-  fi
-fi
-
-CFLAGS="$SAVE_CFLAGS"
-# }}} Check for timegm
-
 AC_CHECK_FUNCS(swapctl, [have_swapctl="yes"], [have_swapctl="no"])
 if test "x$have_swapctl" = "xyes"; then
         AC_CACHE_CHECK([whether swapctl takes two arguments],
                 [c_cv_have_swapctl_two_args],
                 AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
 [[[
@@ -1751,12 +1681,51 @@
 	[
 #if HAVE_KSTAT_H
 # include <kstat.h>
 #endif
 	])
 
+# check for pthread_setname_np
+SAVE_LDFLAGS="$LDFLAGS"
+LDFLAGS="$LDFLAGS -lpthread"
+
+AC_MSG_CHECKING([for pthread_setname_np])
+	have_pthread_setname_np="no"
+	AC_LINK_IFELSE([AC_LANG_PROGRAM(
+[[
+#define _GNU_SOURCE
+#include <pthread.h>
+]],
+[[
+        pthread_setname_np((pthread_t) {0}, "conftest");
+]]
+	)], [
+		have_pthread_setname_np="yes"
+		AC_DEFINE(HAVE_PTHREAD_SETNAME_NP, 1, [pthread_setname_np() is available.])
+	])
+
+AC_MSG_RESULT([$have_pthread_setname_np])
+
+# check for pthread_set_name_np(3) (FreeBSD)
+AC_MSG_CHECKING([for pthread_set_name_np])
+	have_pthread_set_name_np="no"
+	AC_LINK_IFELSE([AC_LANG_PROGRAM(
+[[
+#include <pthread_np.h>
+]],
+[[
+        pthread_set_name_np((pthread_t) {0}, "conftest");
+]]
+	)], [
+		have_pthread_set_name_np="yes"
+		AC_DEFINE(HAVE_PTHREAD_SET_NAME_NP, 1, [pthread_set_name_np() is available.])
+	])
+AC_MSG_RESULT([$have_pthread_set_name_np])
+
+LDFLAGS="$SAVE_LDFLAGS"
+
 #
 # Checks for libraries begin here
 #
 
 with_libresolv="yes"
 AC_CHECK_LIB(resolv, res_search,
@@ -2633,12 +2602,46 @@
 	BUILD_WITH_LIBIPTC_LDFLAGS="$with_libiptc_libs"
 	AC_SUBST(BUILD_WITH_LIBIPTC_CPPFLAGS)
 	AC_SUBST(BUILD_WITH_LIBIPTC_LDFLAGS)
 fi
 # }}}
 
+# --with-libdpdk {{{
+AC_ARG_VAR([LIBDPDK_CPPFLAGS], [Preprocessor flags for libdpdk])
+AC_ARG_VAR([LIBDPDK_LDFLAGS], [Linker flags for libdpdk])
+
+AC_ARG_WITH([libdpdk], [AS_HELP_STRING([--without-libdpdk], [Disable libdpdk.])])
+
+if test "x$with_libdpdk" != "xno"
+then
+	if test "x$LIBDPDK_CPPFLAGS" = "x"
+	then
+		LIBDPDK_CPPFLAGS="-I/usr/include/dpdk"
+	fi
+	SAVE_CPPFLAGS="$CPPFLAGS"
+	CPPFLAGS="$LIBDPDK_CPPFLAGS $CPPFLAGS"
+	AC_CHECK_HEADERS([rte_config.h],
+		[with_libdpdk="yes"],
+		[with_libdpdk="no (rte_config.h not found)"]
+	)
+	CPPFLAGS="$SAVE_CPPFLAGS"
+fi
+
+if test "x$with_libdpdk" = "xyes"
+then
+	SAVE_LDFLAGS="$LDFLAGS"
+	LDFLAGS="$LIBDPDK_LDFLAGS $LDFLAGS"
+	AC_CHECK_LIB([dpdk], [rte_eal_init],
+		[with_libdpdk="yes"],
+		[with_libdpdk="no (symbol 'rte_eal_init' not found)"]
+	)
+	LDFLAGS="$SAVE_LDFLAGS"
+fi
+
+# }}}
+
 # --with-java {{{
 with_java_home="$JAVA_HOME"
 if test "x$with_java_home" = "x"
 then
 	with_java_home="/usr/lib/jvm"
 fi
@@ -3059,12 +3062,76 @@
 	AC_SUBST(BUILD_WITH_LIBMEMCACHED_LIBS)
 	AC_DEFINE(HAVE_LIBMEMCACHED, 1, [Define if libmemcached is present and usable.])
 fi
 AM_CONDITIONAL(BUILD_WITH_LIBMEMCACHED, test "x$with_libmemcached" = "xyes")
 # }}}
 
+# --with-libmicrohttpd {{{
+with_libmicrohttpd_cppflags=""
+with_libmicrohttpd_ldflags=""
+AC_ARG_WITH([libmicrohttpd], [AS_HELP_STRING([--with-libmicrohttpd@<:@=PREFIX@:>@], [Path to libmicrohttpd.])],
+  [
+    if test "x$withval" != "xno" && test "x$withval" != "xyes"
+    then
+      with_libmicrohttpd_cppflags="-I$withval/include"
+      with_libmicrohttpd_ldflags="-L$withval/lib"
+      with_libmicrohttpd="yes"
+    fi
+    if test "x$withval" = "xno"
+    then
+      with_libmicrohttpd="no (disabled on command line)"
+    fi
+  ],
+  [withval="yes"]
+)
+if test "x$withval" = "xyes"
+then
+PKG_CHECK_MODULES([MICROHTTPD], [libmicrohttpd],
+  [with_libmicrohttpd="yes"],
+  [with_libmicrohttpd="no (pkg-config could not find libmicrohttpd)"]
+)
+fi
+
+if test "x$MICROHTTPD_LIBS" = "x"
+then
+  MICROHTTPD_LIBS="-lmicrohttpd"
+fi
+
+SAVE_CPPFLAGS="$CPPFLAGS"
+SAVE_LDFLAGS="$LDFLAGS"
+SAVE_LIBS="$LIBS"
+CPPFLAGS="$with_libmicrohttpd_cppflags $MICROHTTPD_CFLAGS"
+LDFLAGS="$with_libmicrohttpd_ldflags $LDFLAGS"
+LIBS="$LIBS $MICROHTTPD_LIBS"
+
+if test "x$with_libmicrohttpd" = "xyes"
+then
+  AC_CHECK_HEADERS([microhttpd.h],
+                   [with_libmicrohttpd="yes"],
+                   [with_libmicrohttpd="no (<microhttpd.h> not found)"])
+fi
+
+if test "x$with_libmicrohttpd" = "xyes"
+then
+  AC_CHECK_LIB([microhttpd], [MHD_start_daemon],
+               [with_libmicrohttpd="yes"],
+               [with_libmicrohttpd="no (libmicrohttpd not found)"])
+fi
+
+CPPFLAGS="$SAVE_CPPFLAGS"
+LDFLAGS="$SAVE_LDFLAGS"
+LIBS="$SAVE_LIBS"
+
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS="$with_libmicrohttpd_cppflags $MICROHTTPD_CFLAGS"
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS="$with_libmicrohttpd_ldflags"
+BUILD_WITH_LIBMICROHTTPD_LIBS="$MICROHTTPD_LIBS"
+AC_SUBST([BUILD_WITH_LIBMICROHTTPD_CPPFLAGS])
+AC_SUBST([BUILD_WITH_LIBMICROHTTPD_LDFLAGS])
+AC_SUBST([BUILD_WITH_LIBMICROHTTPD_LIBS])
+# }}}
+
 # --with-libmodbus {{{
 with_libmodbus_config=""
 with_libmodbus_cflags=""
 with_libmodbus_libs=""
 AC_ARG_WITH(libmodbus, [AS_HELP_STRING([--with-libmodbus@<:@=PREFIX@:>@], [Path to the modbus library.])],
 [
@@ -4125,12 +4192,61 @@
 	AC_SUBST(BUILD_WITH_LIBPQ_CPPFLAGS)
 	AC_SUBST(BUILD_WITH_LIBPQ_LDFLAGS)
 fi
 AM_CONDITIONAL(BUILD_WITH_LIBPQ, test "x$with_libpq" = "xyes")
 # }}}
 
+# --with-libpqos {{{
+with_libpqos_cppflags=""
+with_libpqos_ldflags=""
+AC_ARG_WITH(libpqos, [AS_HELP_STRING([--with-libpqos@<:@=PREFIX@:>@], [Path to libpqos.])],
+[
+	if test "x$withval" != "xno" && test "x$withval" != "xyes"
+	then
+		with_libpqos_cppflags="-I$withval/include"
+		with_libpqos_ldflags="-L$withval/lib"
+		with_libpqos="yes"
+	else
+		with_libpqos="$withval"
+	fi
+],
+[
+	with_libpqos="yes"
+])
+if test "x$with_libpqos" = "xyes"
+then
+	SAVE_CPPFLAGS="$CPPFLAGS"
+	CPPFLAGS="$CPPFLAGS $with_libpqos_cppflags"
+
+	AC_CHECK_HEADERS(pqos.h, [with_libpqos="yes"], [with_libpqos="no (pqos.h not found)"])
+
+	CPPFLAGS="$SAVE_CPPFLAGS"
+fi
+if test "x$with_libpqos" = "xyes"
+then
+	SAVE_CPPFLAGS="$CPPFLAGS"
+	SAVE_LDFLAGS="$LDFLAGS"
+	CPPFLAGS="$CPPFLAGS $with_libpqos_cppflags"
+	LDFLAGS="$LDFLAGS $with_libpqos_ldflags"
+
+	AC_CHECK_LIB(pqos, pqos_init, [with_libpqos="yes"], [with_libpqos="no (Can't find libpqos)"])
+
+	CPPFLAGS="$SAVE_CPPFLAGS"
+	LDFLAGS="$SAVE_LDFLAGS"
+fi
+if test "x$with_libpqos" = "xyes"
+then
+	BUILD_WITH_LIBPQOS_CPPFLAGS="$with_libpqos_cppflags"
+	BUILD_WITH_LIBPQOS_LDFLAGS="$with_libpqos_ldflags"
+	BUILD_WITH_LIBPQOS_LIBS="-lpqos"
+	AC_SUBST(BUILD_WITH_LIBPQOS_CPPFLAGS)
+	AC_SUBST(BUILD_WITH_LIBPQOS_LDFLAGS)
+	AC_SUBST(BUILD_WITH_LIBPQOS_LIBS)
+fi
+# }}}
+
 # --with-libprotobuf {{{
 with_libprotobuf_cppflags=""
 with_libprotobuf_ldflags=""
 AC_ARG_WITH([libprotobuf], [AS_HELP_STRING([--with-libprotobuf@<:@=PREFIX@:>@], [Path to libprotobuf.])],
   [
     if test "x$withval" != "xno" && test "x$withval" != "xyes"
@@ -5804,18 +5920,21 @@
 plugin_cpusleep="no"
 plugin_curl_json="no"
 plugin_curl_xml="no"
 plugin_df="no"
 plugin_disk="no"
 plugin_drbd="no"
+plugin_dpdkstat="no"
 plugin_entropy="no"
 plugin_ethstat="no"
 plugin_fhcount="no"
 plugin_fscache="no"
 plugin_gps="no"
 plugin_grpc="no"
+plugin_hugepages="no"
+plugin_intel_rdt="no"
 plugin_interface="no"
 plugin_ipmi="no"
 plugin_ipvs="no"
 plugin_irq="no"
 plugin_load="no"
 plugin_log_logstash="no"
@@ -5839,12 +5958,13 @@
 plugin_uptime="no"
 plugin_users="no"
 plugin_virt="no"
 plugin_vmem="no"
 plugin_vserver="no"
 plugin_wireless="no"
+plugin_write_prometheus="no"
 plugin_xencpu="no"
 plugin_zfs_arc="no"
 plugin_zone="no"
 plugin_zookeeper="no"
 
 # Linux
@@ -5858,12 +5978,13 @@
 	plugin_cpufreq="yes"
 	plugin_disk="yes"
 	plugin_drbd="yes"
 	plugin_entropy="yes"
 	plugin_fhcount="yes"
 	plugin_fscache="yes"
+	plugin_hugepages="yes"
 	plugin_interface="yes"
 	plugin_ipc="yes"
 	plugin_irq="yes"
 	plugin_load="yes"
 	plugin_lvm="yes"
 	plugin_memory="yes"
@@ -6125,12 +6246,16 @@
 	plugin_perl="yes"
 fi
 
 if test "x$have_protoc_c" = "xyes" && test "x$with_libprotobuf_c" = "xyes"
 then
 	plugin_pinba="yes"
+	if test "x$with_libmicrohttpd" = "xyes"
+	then
+		plugin_write_prometheus="yes"
+	fi
 fi
 
 # Mac OS X memory interface
 if test "x$have_host_statistics" = "xyes"
 then
 	plugin_memory="yes"
@@ -6206,12 +6331,17 @@
 
 if test "x$with_libxenctrl" = "xyes"
 then
   plugin_xencpu="yes"
 fi
 
+if test "x$with_libdpdk" = "xyes"
+then
+  plugin_dpdkstat="yes"
+fi
+
 m4_divert_once([HELP_ENABLE], [
 collectd plugins:])
 
 AC_ARG_ENABLE([all-plugins],
 		AS_HELP_STRING([--enable-all-plugins],[enable all plugins (auto by def)]),
 		[
@@ -6252,24 +6382,27 @@
 AC_PLUGIN([curl_json],           [$plugin_curl_json],       [CouchDB statistics])
 AC_PLUGIN([curl_xml],            [$plugin_curl_xml],        [CURL generic xml statistics])
 AC_PLUGIN([dbi],                 [$with_libdbi],            [General database statistics])
 AC_PLUGIN([df],                  [$plugin_df],              [Filesystem usage statistics])
 AC_PLUGIN([disk],                [$plugin_disk],            [Disk usage statistics])
 AC_PLUGIN([dns],                 [$with_libpcap],           [DNS traffic analysis])
+AC_PLUGIN([dpdkstat],            [$plugin_dpdkstat],        [Stats & Status from DPDK])
 AC_PLUGIN([drbd],                [$plugin_drbd],            [DRBD statistics])
 AC_PLUGIN([email],               [yes],                     [EMail statistics])
 AC_PLUGIN([entropy],             [$plugin_entropy],         [Entropy statistics])
 AC_PLUGIN([ethstat],             [$plugin_ethstat],         [Stats from NIC driver])
 AC_PLUGIN([exec],                [yes],                     [Execution of external programs])
 AC_PLUGIN([fhcount],             [$plugin_fhcount],         [File handles statistics])
 AC_PLUGIN([filecount],           [yes],                     [Count files in directories])
 AC_PLUGIN([fscache],             [$plugin_fscache],         [fscache statistics])
 AC_PLUGIN([gmond],               [$with_libganglia],        [Ganglia plugin])
 AC_PLUGIN([gps],                 [$plugin_gps],             [GPS plugin])
 AC_PLUGIN([grpc],                [$plugin_grpc],            [gRPC plugin])
 AC_PLUGIN([hddtemp],             [yes],                     [Query hddtempd])
+AC_PLUGIN([hugepages],           [$plugin_hugepages],       [Hugepages statistics])
+AC_PLUGIN([intel_rdt],           [$with_libpqos],           [Intel RDT monitor plugin])
 AC_PLUGIN([interface],           [$plugin_interface],       [Interface traffic statistics])
 AC_PLUGIN([ipc],                 [$plugin_ipc],             [IPC statistics])
 AC_PLUGIN([ipmi],                [$plugin_ipmi],            [IPMI sensor statistics])
 AC_PLUGIN([iptables],            [$with_libiptc],           [IPTables rule counters])
 AC_PLUGIN([ipvs],                [$plugin_ipvs],            [IPVS connection statistics])
 AC_PLUGIN([irq],                 [$plugin_irq],             [IRQ statistics])
@@ -6361,12 +6494,13 @@
 AC_PLUGIN([wireless],            [$plugin_wireless],        [Wireless statistics])
 AC_PLUGIN([write_graphite],      [yes],                     [Graphite / Carbon output plugin])
 AC_PLUGIN([write_http],          [$with_libcurl],           [HTTP output plugin])
 AC_PLUGIN([write_kafka],         [$with_librdkafka],        [Kafka output plugin])
 AC_PLUGIN([write_log],           [yes],                     [Log output plugin])
 AC_PLUGIN([write_mongodb],       [$with_libmongoc],         [MongoDB output plugin])
+AC_PLUGIN([write_prometheus],    [$plugin_write_prometheus], [Prometheus write plugin])
 AC_PLUGIN([write_redis],         [$with_libhiredis],        [Redis output plugin])
 AC_PLUGIN([write_riemann],       [$with_libriemann_client], [Riemann output plugin])
 AC_PLUGIN([write_sensu],         [yes],                     [Sensu output plugin])
 AC_PLUGIN([write_tsdb],          [yes],                     [TSDB output plugin])
 AC_PLUGIN([xencpu],              [$plugin_xencpu],          [Xen Host CPU usage])
 AC_PLUGIN([xmms],                [$with_libxmms],           [XMMS statistics])
@@ -6591,12 +6725,13 @@
 AC_MSG_RESULT([  Libraries:])
 AC_MSG_RESULT([    intel mic . . . . . . $with_mic])
 AC_MSG_RESULT([    libaquaero5 . . . . . $with_libaquaero5])
 AC_MSG_RESULT([    libatasmart . . . . . $with_libatasmart])
 AC_MSG_RESULT([    libcurl . . . . . . . $with_libcurl])
 AC_MSG_RESULT([    libdbi  . . . . . . . $with_libdbi])
+AC_MSG_RESULT([    libdpdk . . . . . . . $with_libdpdk])
 AC_MSG_RESULT([    libesmtp  . . . . . . $with_libesmtp])
 AC_MSG_RESULT([    libganglia  . . . . . $with_libganglia])
 AC_MSG_RESULT([    libgcrypt . . . . . . $with_libgcrypt])
 AC_MSG_RESULT([    libgps  . . . . . . . $with_libgps])
 AC_MSG_RESULT([    libgrpc++ . . . . . . $with_libgrpcpp])
 AC_MSG_RESULT([    libhal  . . . . . . . $with_libhal])
@@ -6608,12 +6743,13 @@
 AC_MSG_RESULT([    libkstat  . . . . . . $with_kstat])
 AC_MSG_RESULT([    libkvm  . . . . . . . $with_libkvm])
 AC_MSG_RESULT([    libldap . . . . . . . $with_libldap])
 AC_MSG_RESULT([    liblua  . . . . . . . $with_liblua])
 AC_MSG_RESULT([    liblvm2app  . . . . . $with_liblvm2app])
 AC_MSG_RESULT([    libmemcached  . . . . $with_libmemcached])
+AC_MSG_RESULT([    libmicrohttpd . . . . $with_libmicrohttpd])
 AC_MSG_RESULT([    libmnl  . . . . . . . $with_libmnl])
 AC_MSG_RESULT([    libmodbus . . . . . . $with_libmodbus])
 AC_MSG_RESULT([    libmongoc . . . . . . $with_libmongoc])
 AC_MSG_RESULT([    libmosquitto  . . . . $with_libmosquitto])
 AC_MSG_RESULT([    libmysql  . . . . . . $with_libmysql])
 AC_MSG_RESULT([    libnetapp . . . . . . $with_libnetapp])
@@ -6624,12 +6760,13 @@
 AC_MSG_RESULT([    liboping  . . . . . . $with_liboping])
 AC_MSG_RESULT([    libowcapi . . . . . . $with_libowcapi])
 AC_MSG_RESULT([    libpcap . . . . . . . $with_libpcap])
 AC_MSG_RESULT([    libperfstat . . . . . $with_perfstat])
 AC_MSG_RESULT([    libperl . . . . . . . $with_libperl])
 AC_MSG_RESULT([    libpq . . . . . . . . $with_libpq])
+AC_MSG_RESULT([    libpqos . . . . . . . $with_libpqos])
 AC_MSG_RESULT([    libprotobuf . . . . . $with_libprotobuf])
 AC_MSG_RESULT([    libprotobuf-c . . . . $with_libprotobuf_c])
 AC_MSG_RESULT([    libpython . . . . . . $with_libpython])
 AC_MSG_RESULT([    librabbitmq . . . . . $with_librabbitmq])
 AC_MSG_RESULT([    libriemann-client . . $with_libriemann_client])
 AC_MSG_RESULT([    librdkafka  . . . . . $with_librdkafka])
@@ -6682,24 +6819,27 @@
 AC_MSG_RESULT([    curl_json . . . . . . $enable_curl_json])
 AC_MSG_RESULT([    curl_xml  . . . . . . $enable_curl_xml])
 AC_MSG_RESULT([    dbi . . . . . . . . . $enable_dbi])
 AC_MSG_RESULT([    df  . . . . . . . . . $enable_df])
 AC_MSG_RESULT([    disk  . . . . . . . . $enable_disk])
 AC_MSG_RESULT([    dns . . . . . . . . . $enable_dns])
+AC_MSG_RESULT([    dpdkstat  . . . . . . $enable_dpdkstat])
 AC_MSG_RESULT([    drbd  . . . . . . . . $enable_drbd])
 AC_MSG_RESULT([    email . . . . . . . . $enable_email])
 AC_MSG_RESULT([    entropy . . . . . . . $enable_entropy])
 AC_MSG_RESULT([    ethstat . . . . . . . $enable_ethstat])
 AC_MSG_RESULT([    exec  . . . . . . . . $enable_exec])
 AC_MSG_RESULT([    fhcount . . . . . . . $enable_fhcount])
 AC_MSG_RESULT([    filecount . . . . . . $enable_filecount])
 AC_MSG_RESULT([    fscache . . . . . . . $enable_fscache])
 AC_MSG_RESULT([    gmond . . . . . . . . $enable_gmond])
 AC_MSG_RESULT([    gps . . . . . . . . . $enable_gps])
 AC_MSG_RESULT([    grpc  . . . . . . . . $enable_grpc])
 AC_MSG_RESULT([    hddtemp . . . . . . . $enable_hddtemp])
+AC_MSG_RESULT([    hugepages . . . . . . $enable_hugepages])
+AC_MSG_RESULT([    intel_rdt. . . . .  . $enable_intel_rdt])
 AC_MSG_RESULT([    interface . . . . . . $enable_interface])
 AC_MSG_RESULT([    ipc . . . . . . . . . $enable_ipc])
 AC_MSG_RESULT([    ipmi  . . . . . . . . $enable_ipmi])
 AC_MSG_RESULT([    iptables  . . . . . . $enable_iptables])
 AC_MSG_RESULT([    ipvs  . . . . . . . . $enable_ipvs])
 AC_MSG_RESULT([    irq . . . . . . . . . $enable_irq])
@@ -6790,12 +6930,13 @@
 AC_MSG_RESULT([    wireless  . . . . . . $enable_wireless])
 AC_MSG_RESULT([    write_graphite  . . . $enable_write_graphite])
 AC_MSG_RESULT([    write_http  . . . . . $enable_write_http])
 AC_MSG_RESULT([    write_kafka . . . . . $enable_write_kafka])
 AC_MSG_RESULT([    write_log . . . . . . $enable_write_log])
 AC_MSG_RESULT([    write_mongodb . . . . $enable_write_mongodb])
+AC_MSG_RESULT([    write_prometheus. . . $enable_write_prometheus])
 AC_MSG_RESULT([    write_redis . . . . . $enable_write_redis])
 AC_MSG_RESULT([    write_riemann . . . . $enable_write_riemann])
 AC_MSG_RESULT([    write_sensu . . . . . $enable_write_sensu])
 AC_MSG_RESULT([    write_tsdb  . . . . . $enable_write_tsdb])
 AC_MSG_RESULT([    xencpu  . . . . . . . $enable_xencpu])
 AC_MSG_RESULT([    xmms  . . . . . . . . $enable_xmms])
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib/collection3: test.px
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib/examples/myplugin.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/contrib/examples/myplugin.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib/examples/myplugin.c	2017-10-06 14:45:52.925917744 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/contrib/examples/myplugin.c	2016-12-12 16:03:36.684279287 +0800
@@ -75,37 +75,49 @@
   /* A return value != 0 indicates an error and causes the plugin to be
      disabled. */
   return 0;
 } /* static int my_init (void) */
 
 /*
- * This function is called in regular intervalls to collect the data.
+ * This is a utility function used by the read callback to populate a
+ * value_list_t and pass it to plugin_dispatch_values.
  */
-static int my_read(void) {
-  value_t values[1]; /* the size of this list should equal the number of
-                                            data sources */
+static int my_submit(gauge_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  /* do the magic to read the data */
-  values[0].gauge = random();
-
-  vl.values = values;
+  /* Convert the gauge_t to a value_t and add it to the value_list_t. */
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  vl.time = time(NULL);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+
+  /* Only set vl.time yourself if you update multiple metrics (i.e. you
+   * have multiple calls to plugin_dispatch_values()) and they need to all
+   * have the same timestamp. */
+  /* vl.time = cdtime(); */
+
   sstrncpy(vl.plugin, "myplugin", sizeof(vl.plugin));
 
   /* it is strongly recommended to use a type defined in the types.db file
    * instead of a custom type */
   sstrncpy(vl.type, "myplugin", sizeof(vl.type));
   /* optionally set vl.plugin_instance and vl.type_instance to reasonable
    * values (default: "") */
 
   /* dispatch the values to collectd which passes them on to all registered
    * write functions */
-  plugin_dispatch_values(&vl);
+  return plugin_dispatch_values(&vl);
+}
+
+/*
+ * This function is called in regular intervalls to collect the data.
+ */
+static int my_read(void) {
+  /* do the magic to read the data */
+  gauge_t value = random();
+
+  if (my_submit(value) != 0)
+    WARNING("myplugin plugin: Dispatching a random value failed.");
 
   /* A return value != 0 indicates an error and the plugin will be skipped
    * for an increasing amount of time. */
   return 0;
 } /* static int my_read (void) */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib/redhat/collectd.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/contrib/redhat/collectd.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib/redhat/collectd.spec	2017-10-06 14:45:52.925917744 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/contrib/redhat/collectd.spec	2016-12-12 16:03:36.688279258 +0800
@@ -70,12 +70,13 @@
 %define with_fhcount 0%{!?_without_fhcount:1}
 %define with_filecount 0%{!?_without_filecount:1}
 %define with_fscache 0%{!?_without_fscache:1}
 %define with_gmond 0%{!?_without_gmond:1}
 %define with_gps 0%{!?_without_gps:1}
 %define with_hddtemp 0%{!?_without_hddtemp:1}
+%define with_hugepages 0%{!?_without_hugepages:1}
 %define with_interface 0%{!?_without_interface:1}
 %define with_ipc 0%{!?_without_ipc:1}
 %define with_ipmi 0%{!?_without_ipmi:1}
 %define with_iptables 0%{!?_without_iptables:1}
 %define with_ipvs 0%{!?_without_ipvs:1}
 %define with_irq 0%{!?_without_irq:1}
@@ -144,14 +145,14 @@
 %define with_vmem 0%{!?_without_vmem:1}
 %define with_vserver 0%{!?_without_vserver:1}
 %define with_wireless 0%{!?_without_wireless:1}
 %define with_write_graphite 0%{!?_without_write_graphite:1}
 %define with_write_http 0%{!?_without_write_http:1}
 %define with_write_log 0%{!?_without_write_log:1}
+%define with_write_prometheus 0%{!?_without_write_prometheus:1}
 %define with_write_redis 0%{!?_without_write_redis:1}
-%define with_write_riemann 0%{!?_without_write_riemann:1}
 %define with_write_sensu 0%{!?_without_write_sensu:1}
 %define with_write_tsdb 0%{!?_without_write_tsdb:1}
 %define with_xmms 0%{!?_without_xmms:0%{?_has_xmms}}
 %define with_zfs_arc 0%{!?_without_zfs_arc:1}
 %define with_zookeeper 0%{!?_without_zookeeper:1}
 
@@ -163,14 +164,18 @@
 # plugin aquaero disabled, requires a libaquaero5
 %define with_aquaero 0%{!?_without_aquaero:0}
 # plugin barometer disabled, requires a libi2c
 %define with_barometer 0%{!?_without_barometer:0}
 # plugin grpc disabled, requires protobuf-compiler >= 3.0
 %define with_grpc 0%{!?_without_grpc:0}
+# plugin dpdkstat disabled, requires libdpdk
+%define with_dpdkstat 0%{!?_without_dpdkstat:0}
 # plugin lpar disabled, requires AIX
 %define with_lpar 0%{!?_without_lpar:0}
+# plugin intel_rdt disabled, requires intel-cmt-cat
+%define with_intel_rdt 0%{!?_without_intel_rdt:0}
 # plugin mic disabled, requires Mic
 %define with_mic 0%{!?_without_mic:0}
 # plugin netapp disabled, requires libnetapp
 %define with_netapp 0%{!?_without_netapp:0}
 # plugin onewire disabled, requires libowfs
 %define with_onewire 0%{!?_without_onewire:0}
@@ -187,12 +192,14 @@
 # plugin tokyotyrant disabled, requires tcrdb.h
 %define with_tokyotyrant 0%{!?_without_tokyotyrant:0}
 # plugin write_kafka disabled, requires librdkafka
 %define with_write_kafka 0%{!?_without_write_kafka:0}
 # plugin write_mongodb disabled, requires libmongoc
 %define with_write_mongodb 0%{!?_without_write_mongodb:0}
+# plugin write_riemann disabled, requires a new enough riemann_c_client
+%define with_write_riemann 0%{!?_without_write_riemann:0}
 # plugin xencpu disabled, requires xen-devel from non-default repo
 %define with_xencpu 0%{!?_without_xencpu:0}
 # plugin zone disabled, requires Solaris
 %define with_zone 0%{!?_without_zone:0}
 
 # Plugins not buildable on RHEL < 6
@@ -208,42 +215,40 @@
 %define with_lvm 0
 %define with_modbus 0
 %define with_netlink 0
 %define with_redis 0
 %define with_smart 0
 %define with_turbostat 0
+%define with_write_prometheus 0
 %define with_write_redis 0
-%define with_write_riemann 0
 %endif
 
 # Plugins not buildable on RHEL < 7
 %if 0%{?rhel} && 0%{?rhel} < 7
 %define with_cpusleep 0
 %define with_gps 0
 %define with_mqtt 0
 %define with_redis 0
 %define with_rrdcached 0
 %define with_write_redis 0
-%define with_write_riemann 0
 %define with_xmms 0
 %endif
 
 Summary:	Statistics collection and monitoring daemon
 Name:		collectd
-Version:	5.6.1
-Release:	4%{?dist}
+Version:	5.7.0
+Release:	2%{?dist}
 URL:		https://collectd.org
 Source:		https://collectd.org/files/%{name}-%{version}.tar.bz2
 License:	GPLv2
 Group:		System Environment/Daemons
 BuildRoot:	%{_tmppath}/%{name}-%{version}-root
 BuildRequires:	libgcrypt-devel, kernel-headers, libtool-ltdl-devel, libcap-devel, which
 Vendor:		collectd development team <collectd@verplant.org>
 
 %if 0%{?fedora} || 0%{?rhel} >= 7
-BuildRequires:		xfsprogs-devel
 %{?systemd_requires}
 BuildRequires:		systemd
 %else
 Requires(post):		chkconfig
 Requires(preun):	chkconfig, initscripts
 Requires(postun):	initscripts
@@ -452,12 +457,23 @@
 Requires:	%{name}%{?_isa} = %{version}-%{release}, hddtemp
 %description hddtemp
 The HDDTemp plugin collects the temperature of hard disks. The temperatures are
 provided via SMART and queried by the external hddtemp daemon.
 %endif
 
+%if %{with_intel_rdt}
+%package intel_rdt
+Summary:	Intel RDT plugin for collectd
+Group:		System Environment/Daemons
+Requires:	%{name}%{?_isa} = %{version}-%{release}
+BuildRequires:	intel-cmt-cat
+%description intel_rdt
+The intel_rdt plugin collects information provided by monitoring features of
+Intel Resource Director Technology (Intel(R) RDT).
+%endif
+
 %if %{with_ipmi}
 %package ipmi
 Summary:	IPMI plugin for collectd
 Group:		System Environment/Daemons
 Requires:	%{name}%{?_isa} = %{version}-%{release}
 BuildRequires:	OpenIPMI-devel
@@ -480,14 +496,14 @@
 
 %if %{with_java}
 %package java
 Summary:	Java plugin for collectd
 Group:		System Environment/Daemons
 Requires:	%{name}%{?_isa} = %{version}-%{release}
-BuildRequires:	java-devel >= 1.6, jpackage-utils >= 1.6
-Requires:	java >= 1.6, jpackage-utils >= 1.6
+BuildRequires:	java-devel, jpackage-utils
+Requires:	java, jpackage-utils
 %description java
 This plugin for collectd allows plugins to be written in Java and executed
 in an embedded JVM.
 %endif
 
 %if %{with_log_logstash}
@@ -813,12 +829,23 @@
 Requires:      %{name}%{?_isa} = %{version}-%{release}
 BuildRequires: librdkafka-devel
 %description write_kafka
 The write_kafka plugin sends values to kafka, a distributed messaging system.
 %endif
 
+%if %{with_write_prometheus}
+%package write_prometheus
+Summary:	Write-prometheus plugin for collectd
+Group:		System Environment/Daemons
+Requires:	%{name}%{?_isa} = %{version}-%{release}
+BuildRequires:	libmicrohttpd-devel
+%description write_prometheus
+The Write Prometheus plugin exposes collected values using an embedded HTTP
+server, turning the collectd daemon into a Prometheus exporter.
+%endif
+
 %if %{with_write_redis}
 %package write_redis
 Summary:	Write-Redis plugin for collectd
 Group:		System Environment/Daemons
 Requires:	%{name}%{?_isa} = %{version}-%{release}
 BuildRequires:	hiredis-devel
@@ -828,13 +855,13 @@
 
 %if %{with_write_riemann}
 %package write_riemann
 Summary:	riemann plugin for collectd
 Group:		System Environment/Daemons
 Requires:	%{name}%{?_isa} = %{version}-%{release}
-BuildRequires:	riemann-c-client-devel >= 1.6
+BuildRequires:	protobuf-c-devel
 %description write_riemann
 The riemann plugin submits values to Riemann, an event stream processor.
 %endif
 
 %if %{with_xencpu}
 %package xencpu
@@ -1069,12 +1096,18 @@
 %if %{with_drbd}
 %define _with_drbd --enable-drbd
 %else
 %define _with_drbd --disable-drbd
 %endif
 
+%if %{with_dpdkstat}
+%define _with_dpdkstat --enable-dpdkstat
+%else
+%define _with_dpdkstat --disable-dpdkstat
+%endif
+
 %if %{with_email}
 %define _with_email --enable-email
 %else
 %define _with_email --disable-email
 %endif
 
@@ -1135,12 +1168,24 @@
 %if %{with_hddtemp}
 %define _with_hddtemp --enable-hddtemp
 %else
 %define _with_hddtemp --disable-hddtemp
 %endif
 
+%if %{with_hugepages}
+%define _with_hugepages --enable-hugepages
+%else
+%define _with_hugepages --disable-hugepages
+%endif
+
+%if %{with_intel_rdt}
+%define _with_intel_rdt --enable-intel_rdt
+%else
+%define _with_intel_rdt --disable-intel_rdt
+%endif
+
 %if %{with_interface}
 %define _with_interface --enable-interface
 %else
 %define _with_interface --disable-interface
 %endif
 
@@ -1656,12 +1701,18 @@
 %if %{with_write_mongodb}
 %define _with_write_mongodb --enable-write_mongodb
 %else
 %define _with_write_mongodb --disable-write_mongodb
 %endif
 
+%if %{with_write_prometheus}
+%define _with_write_prometheus --enable-write_prometheus
+%else
+%define _with_write_prometheus --disable-write_prometheus
+%endif
+
 %if %{with_write_redis}
 %define _with_write_redis --enable-write_redis
 %else
 %define _with_write_redis --disable-write_redis
 %endif
 
@@ -1752,23 +1803,26 @@
 	%{?_with_curl} \
 	%{?_with_dbi} \
 	%{?_with_df} \
 	%{?_with_disk} \
 	%{?_with_dns} \
 	%{?_with_drbd} \
+	%{?_with_dpdkstat} \
 	%{?_with_email} \
 	%{?_with_entropy} \
 	%{?_with_ethstat} \
 	%{?_with_exec} \
 	%{?_with_fhcount} \
 	%{?_with_filecount} \
 	%{?_with_fscache} \
 	%{?_with_gmond} \
 	%{?_with_gps} \
 	%{?_with_grpc} \
 	%{?_with_hddtemp} \
+	%{?_with_hugepages} \
+	%{?_with_intel_rdt} \
 	%{?_with_interface} \
 	%{?_with_ipc} \
 	%{?_with_ipmi} \
 	%{?_with_iptables} \
 	%{?_with_ipvs} \
 	%{?_with_irq} \
@@ -1850,12 +1904,13 @@
 	%{?_with_write_graphite} \
 	%{?_with_write_http} \
 	%{?_with_write_http} \
 	%{?_with_write_kafka} \
 	%{?_with_write_log} \
 	%{?_with_write_mongodb} \
+	%{?_with_write_prometheus} \
 	%{?_with_write_redis} \
 	%{?_with_write_riemann} \
 	%{?_with_write_sensu} \
 	%{?_with_write_tsdb} \
 	%{?_with_xencpu} \
 	%{?_with_xmms} \
@@ -2028,12 +2083,15 @@
 %if %{with_df}
 %{_libdir}/%{name}/df.so
 %endif
 %if %{with_drbd}
 %{_libdir}/%{name}/drbd.so
 %endif
+%if %{with_dpdkstat}
+%{_libdir}/%{name}/dpdkstat.so
+%endif
 %if %{with_ethstat}
 %{_libdir}/%{name}/ethstat.so
 %endif
 %if %{with_entropy}
 %{_libdir}/%{name}/entropy.so
 %endif
@@ -2046,12 +2104,15 @@
 %if %{with_filecount}
 %{_libdir}/%{name}/filecount.so
 %endif
 %if %{with_fscache}
 %{_libdir}/%{name}/fscache.so
 %endif
+%if %{with_hugepages}
+%{_libdir}/%{name}/hugepages.so
+%endif
 %if %{with_interface}
 %{_libdir}/%{name}/interface.so
 %endif
 %if %{with_ipc}
 %{_libdir}/%{name}/ipc.so
 %endif
@@ -2305,12 +2366,17 @@
 
 %if %{with_hddtemp}
 %files hddtemp
 %{_libdir}/%{name}/hddtemp.so
 %endif
 
+%if %{with_intel_rdt}
+%files intel_rdt
+%{_libdir}/%{name}/intel_rdt.so
+%endif
+
 %if %{with_ipmi}
 %files ipmi
 %{_libdir}/%{name}/ipmi.so
 %endif
 
 %if %{with_iptables}
@@ -2481,12 +2547,17 @@
 
 %if %{with_write_kafka}
 %files write_kafka
 %{_libdir}/%{name}/write_kafka.so
 %endif
 
+%if %{with_write_prometheus}
+%files write_prometheus
+%{_libdir}/%{name}/write_prometheus.so
+%endif
+
 %if %{with_write_redis}
 %files write_redis
 %{_libdir}/%{name}/write_redis.so
 %endif
 
 %if %{with_write_riemann}
@@ -2513,20 +2584,19 @@
 %{_sysconfdir}/httpd/conf.d/php-collection.conf
 
 %files contrib
 %doc contrib/
 
 %changelog
-* Sun Mar 05 2017 Ruben Kerkhof <ruben@rubenkerkhof.com> - 5.6.1-4
-- Don't enable XFS support on RHEL6, it is missing for i386
-
-* Wed Feb 22 2017 Ruben Kerkhof <ruben@rubenkerkhof.com> - 5.6.1-3
-- Enable XFS support in df plugin
+* Tue Nov 29 2016 Ruben Kerkhof <ruben@rubenkerkhof.com> - 5.7.0-2
+- Disable redis plugin on RHEL 6, hiredis has been retired from EPEL6
 
-* Tue Nov 29 2016 Ruben Kerkhof <ruben@rubenkerkhof.com> - 5.6.1-2
-- Disable redis plugin on RHEL < 7, hiredis has been retired from EPEL6
+* Mon Oct 10 2016 Marc Fournier <marc.fournier@camptocamp.com> - 5.7.0-1
+- New PRE-RELEASE version
+- New plugins enabled by default: hugepages, write_prometheus
+- New plugins disabled by default: dpdkstat, intel_rdt
 
 * Mon Oct 10 2016 Victor Demonchy <v.demonchy@criteo.com> - 5.6.1-1
 - New upstream version
 
 * Sun Aug 14 2016 Ruben Kerkhof <ruben@rubenkerkhof.com> - 5.6.0-1
 - New upstream version
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib/SpamAssassin/Collectd.pm /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/contrib/SpamAssassin/Collectd.pm
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib/SpamAssassin/Collectd.pm	2017-10-06 14:45:52.925917744 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/contrib/SpamAssassin/Collectd.pm	2016-12-12 16:03:36.680279316 +0800
@@ -149,14 +149,14 @@
 		alarm $self->{main}->{conf}->{collectd_timeout};
 
 		my $sock;
 		#try at least $self->{main}->{conf}->{collectd_retries} to get a
 		#connection
 		for (my $i = 0; $i < $self->{main}->{conf}->{collectd_retries} ; ++$i) {
-			last if $sock = new IO::Socket::UNIX
-				($self->{main}->{conf}->{collectd_socket});
+		        my ($socket_path) = $self->{main}->{conf}->{collectd_socket} =~ /(.*)/; # Untaint path, which can contain any characters.
+			last if $sock = new IO::Socket::UNIX $socket_path;
 			#sleep a random value between 0 and 50 microsecs to try for a new
 			#thread
 			usleep(int(rand(50))); 
 		}
 
 		die("could not connect to " .
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib/systemd.collectd.service /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/contrib/systemd.collectd.service
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib/systemd.collectd.service	2017-10-06 14:45:52.925917744 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/contrib/systemd.collectd.service	2016-12-12 16:03:36.688279258 +0800
@@ -17,21 +17,22 @@
 # Here's a (incomplete) list of the plugins known capability requirements:
 #   ceph            CAP_DAC_OVERRIDE
 #   dns             CAP_NET_RAW
 #   exec            CAP_SETUID CAP_SETGID
 #   iptables        CAP_NET_ADMIN
 #   ping            CAP_NET_RAW
-#   smart           CAP_SYS_RAWIO
 #   turbostat       CAP_SYS_RAWIO
 #
 # Example, if you use the iptables plugin alongside the dns or ping plugin:
 #CapabilityBoundingSet=CAP_NET_RAW CAP_NET_ADMIN
 #
 # By default, drop all capabilities:
 CapabilityBoundingSet=
 
+NoNewPrivileges=true
+
 # Tell systemd it will receive a notification from collectd over it's control
 # socket once the daemon is ready. See systemd.service(5) for more details.
 Type=notify
 
 # Restart the collectd daemon when it fails.
 Restart=on-failure
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib: wiki2commonmark.pl
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/contrib: wiki2html.pl
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: depcomp
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: INSTALL
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: install-sh
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: ltmain.sh
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/Makefile.in	2017-10-06 15:04:19.054135667 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/Makefile.in	2016-12-12 16:03:46.668211479 +0800
@@ -79,33 +79,24 @@
 host_triplet = @host@
 @BUILD_INCLUDED_LTDL_TRUE@am__append_1 = libltdl
 subdir = .
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(top_srcdir)/configure $(am__configure_deps) \
 	$(top_srcdir)/src/libcollectdclient/collectd/lcc_features.h.in \
-	AUTHORS COPYING ChangeLog INSTALL NEWS README TODO compile \
-	libltdl/config/compile config.guess \
-	libltdl/config/config.guess config.sub \
-	libltdl/config/config.sub depcomp libltdl/config/depcomp \
-	install-sh libltdl/config/install-sh missing \
-	libltdl/config/missing ylwrap libltdl/config/ylwrap ltmain.sh \
-	libltdl/config/ltmain.sh $(top_srcdir)/libltdl/config/compile \
+	AUTHORS COPYING ChangeLog README libltdl/config/compile \
+	libltdl/config/config.guess libltdl/config/config.sub \
+	libltdl/config/depcomp libltdl/config/install-sh \
+	libltdl/config/missing libltdl/config/ltmain.sh \
+	$(top_srcdir)/libltdl/config/compile \
 	$(top_srcdir)/libltdl/config/config.guess \
 	$(top_srcdir)/libltdl/config/config.sub \
 	$(top_srcdir)/libltdl/config/install-sh \
 	$(top_srcdir)/libltdl/config/ltmain.sh \
 	$(top_srcdir)/libltdl/config/missing
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/libltdl/m4/argz.m4 \
-	$(top_srcdir)/libltdl/m4/libtool.m4 \
-	$(top_srcdir)/libltdl/m4/ltdl.m4 \
-	$(top_srcdir)/libltdl/m4/ltoptions.m4 \
-	$(top_srcdir)/libltdl/m4/ltsugar.m4 \
-	$(top_srcdir)/libltdl/m4/ltversion.m4 \
-	$(top_srcdir)/libltdl/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
  configure.lineno config.status.lineno
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/src/config.h
@@ -249,12 +240,15 @@
 BUILD_WITH_LIBLVM2APP_CPPFLAGS = @BUILD_WITH_LIBLVM2APP_CPPFLAGS@
 BUILD_WITH_LIBLVM2APP_LDFLAGS = @BUILD_WITH_LIBLVM2APP_LDFLAGS@
 BUILD_WITH_LIBLVM2APP_LIBS = @BUILD_WITH_LIBLVM2APP_LIBS@
 BUILD_WITH_LIBMEMCACHED_CPPFLAGS = @BUILD_WITH_LIBMEMCACHED_CPPFLAGS@
 BUILD_WITH_LIBMEMCACHED_LDFLAGS = @BUILD_WITH_LIBMEMCACHED_LDFLAGS@
 BUILD_WITH_LIBMEMCACHED_LIBS = @BUILD_WITH_LIBMEMCACHED_LIBS@
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS = @BUILD_WITH_LIBMICROHTTPD_CPPFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS = @BUILD_WITH_LIBMICROHTTPD_LDFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LIBS = @BUILD_WITH_LIBMICROHTTPD_LIBS@
 BUILD_WITH_LIBMNL_CFLAGS = @BUILD_WITH_LIBMNL_CFLAGS@
 BUILD_WITH_LIBMNL_LIBS = @BUILD_WITH_LIBMNL_LIBS@
 BUILD_WITH_LIBMODBUS_CFLAGS = @BUILD_WITH_LIBMODBUS_CFLAGS@
 BUILD_WITH_LIBMODBUS_LIBS = @BUILD_WITH_LIBMODBUS_LIBS@
 BUILD_WITH_LIBMONGOC_CPPFLAGS = @BUILD_WITH_LIBMONGOC_CPPFLAGS@
 BUILD_WITH_LIBMONGOC_LDFLAGS = @BUILD_WITH_LIBMONGOC_LDFLAGS@
@@ -268,12 +262,15 @@
 BUILD_WITH_LIBNETSNMP_LIBS = @BUILD_WITH_LIBNETSNMP_LIBS@
 BUILD_WITH_LIBOPING_CPPFLAGS = @BUILD_WITH_LIBOPING_CPPFLAGS@
 BUILD_WITH_LIBOPING_LDFLAGS = @BUILD_WITH_LIBOPING_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_CPPFLAGS = @BUILD_WITH_LIBOWCAPI_CPPFLAGS@
 BUILD_WITH_LIBOWCAPI_LDFLAGS = @BUILD_WITH_LIBOWCAPI_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_LIBS = @BUILD_WITH_LIBOWCAPI_LIBS@
+BUILD_WITH_LIBPQOS_CPPFLAGS = @BUILD_WITH_LIBPQOS_CPPFLAGS@
+BUILD_WITH_LIBPQOS_LDFLAGS = @BUILD_WITH_LIBPQOS_LDFLAGS@
+BUILD_WITH_LIBPQOS_LIBS = @BUILD_WITH_LIBPQOS_LIBS@
 BUILD_WITH_LIBPQ_CPPFLAGS = @BUILD_WITH_LIBPQ_CPPFLAGS@
 BUILD_WITH_LIBPQ_LDFLAGS = @BUILD_WITH_LIBPQ_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LDFLAGS = @BUILD_WITH_LIBPROTOBUF_C_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LIBS = @BUILD_WITH_LIBPROTOBUF_C_LIBS@
@@ -379,12 +376,14 @@
 LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
+LIBDPDK_CPPFLAGS = @LIBDPDK_CPPFLAGS@
+LIBDPDK_LDFLAGS = @LIBDPDK_LDFLAGS@
 LIBLTDL = @LIBLTDL@
 LIBLUA_PKG_CONFIG_NAME = @LIBLUA_PKG_CONFIG_NAME@
 LIBNETAPP_CPPFLAGS = @LIBNETAPP_CPPFLAGS@
 LIBNETAPP_LDFLAGS = @LIBNETAPP_LDFLAGS@
 LIBNETAPP_LIBS = @LIBNETAPP_LIBS@
 LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
@@ -417,12 +416,14 @@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 LUA_CFLAGS = @LUA_CFLAGS@
 LUA_LIBS = @LUA_LIBS@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MICROHTTPD_CFLAGS = @MICROHTTPD_CFLAGS@
+MICROHTTPD_LIBS = @MICROHTTPD_LIBS@
 MKDIR_P = @MKDIR_P@
 NM = @NM@
 NMEDIT = @NMEDIT@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: missing
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: NEWS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/proto/collectd.proto /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/proto/collectd.proto
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/proto/collectd.proto	2017-10-06 14:45:52.925917744 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/proto/collectd.proto	2016-12-12 16:03:36.688279258 +0800
@@ -27,31 +27,30 @@
 package collectd;
 option go_package = "collectd.org/rpc/proto";
 
 import "types.proto";
 
 service Collectd {
-  // DispatchValues reads the value lists from the DispatchValuesRequest stream.
+  // PutValues reads the value lists from the PutValuesRequest stream.
   // The gRPC server embedded into collectd will inject them into the system
   // just like the network plugin.
-  rpc DispatchValues(stream DispatchValuesRequest)
-      returns(DispatchValuesResponse);
+  rpc PutValues(stream PutValuesRequest) returns(PutValuesResponse);
 
   // QueryValues returns a stream of matching value lists from collectd's
   // internal cache.
   rpc QueryValues(QueryValuesRequest) returns(stream QueryValuesResponse);
 }
 
-// The arguments to DispatchValues.
-message DispatchValuesRequest {
+// The arguments to PutValues.
+message PutValuesRequest {
   // value_list is the metric to be sent to the server.
   collectd.types.ValueList value_list = 1;
 }
 
-// The response from DispatchValues.
-message DispatchValuesResponse {}
+// The response from PutValues.
+message PutValuesResponse {}
 
 // The arguments to QueryValues.
 message QueryValuesRequest {
   // Query by the fields of the identifier. Only return values matching the
   // specified shell wildcard patterns (see fnmatch(3)). Use '*' to match
   // any value.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/proto/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/proto/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/proto/Makefile.am	2017-10-06 14:45:52.925917744 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/proto/Makefile.am	2016-12-12 16:03:36.688279258 +0800
@@ -1 +1 @@
-EXTRA_DIST = collectd.proto types.proto
+EXTRA_DIST = collectd.proto types.proto prometheus.proto
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/proto/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/proto/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/proto/Makefile.in	2017-10-06 15:04:19.186135658 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/proto/Makefile.in	2016-12-12 16:03:46.812210553 +0800
@@ -77,20 +77,13 @@
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 subdir = proto
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/libltdl/m4/argz.m4 \
-	$(top_srcdir)/libltdl/m4/libtool.m4 \
-	$(top_srcdir)/libltdl/m4/ltdl.m4 \
-	$(top_srcdir)/libltdl/m4/ltoptions.m4 \
-	$(top_srcdir)/libltdl/m4/ltsugar.m4 \
-	$(top_srcdir)/libltdl/m4/ltversion.m4 \
-	$(top_srcdir)/libltdl/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/src/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -155,12 +148,15 @@
 BUILD_WITH_LIBLVM2APP_CPPFLAGS = @BUILD_WITH_LIBLVM2APP_CPPFLAGS@
 BUILD_WITH_LIBLVM2APP_LDFLAGS = @BUILD_WITH_LIBLVM2APP_LDFLAGS@
 BUILD_WITH_LIBLVM2APP_LIBS = @BUILD_WITH_LIBLVM2APP_LIBS@
 BUILD_WITH_LIBMEMCACHED_CPPFLAGS = @BUILD_WITH_LIBMEMCACHED_CPPFLAGS@
 BUILD_WITH_LIBMEMCACHED_LDFLAGS = @BUILD_WITH_LIBMEMCACHED_LDFLAGS@
 BUILD_WITH_LIBMEMCACHED_LIBS = @BUILD_WITH_LIBMEMCACHED_LIBS@
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS = @BUILD_WITH_LIBMICROHTTPD_CPPFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS = @BUILD_WITH_LIBMICROHTTPD_LDFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LIBS = @BUILD_WITH_LIBMICROHTTPD_LIBS@
 BUILD_WITH_LIBMNL_CFLAGS = @BUILD_WITH_LIBMNL_CFLAGS@
 BUILD_WITH_LIBMNL_LIBS = @BUILD_WITH_LIBMNL_LIBS@
 BUILD_WITH_LIBMODBUS_CFLAGS = @BUILD_WITH_LIBMODBUS_CFLAGS@
 BUILD_WITH_LIBMODBUS_LIBS = @BUILD_WITH_LIBMODBUS_LIBS@
 BUILD_WITH_LIBMONGOC_CPPFLAGS = @BUILD_WITH_LIBMONGOC_CPPFLAGS@
 BUILD_WITH_LIBMONGOC_LDFLAGS = @BUILD_WITH_LIBMONGOC_LDFLAGS@
@@ -174,12 +170,15 @@
 BUILD_WITH_LIBNETSNMP_LIBS = @BUILD_WITH_LIBNETSNMP_LIBS@
 BUILD_WITH_LIBOPING_CPPFLAGS = @BUILD_WITH_LIBOPING_CPPFLAGS@
 BUILD_WITH_LIBOPING_LDFLAGS = @BUILD_WITH_LIBOPING_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_CPPFLAGS = @BUILD_WITH_LIBOWCAPI_CPPFLAGS@
 BUILD_WITH_LIBOWCAPI_LDFLAGS = @BUILD_WITH_LIBOWCAPI_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_LIBS = @BUILD_WITH_LIBOWCAPI_LIBS@
+BUILD_WITH_LIBPQOS_CPPFLAGS = @BUILD_WITH_LIBPQOS_CPPFLAGS@
+BUILD_WITH_LIBPQOS_LDFLAGS = @BUILD_WITH_LIBPQOS_LDFLAGS@
+BUILD_WITH_LIBPQOS_LIBS = @BUILD_WITH_LIBPQOS_LIBS@
 BUILD_WITH_LIBPQ_CPPFLAGS = @BUILD_WITH_LIBPQ_CPPFLAGS@
 BUILD_WITH_LIBPQ_LDFLAGS = @BUILD_WITH_LIBPQ_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LDFLAGS = @BUILD_WITH_LIBPROTOBUF_C_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LIBS = @BUILD_WITH_LIBPROTOBUF_C_LIBS@
@@ -285,12 +284,14 @@
 LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
+LIBDPDK_CPPFLAGS = @LIBDPDK_CPPFLAGS@
+LIBDPDK_LDFLAGS = @LIBDPDK_LDFLAGS@
 LIBLTDL = @LIBLTDL@
 LIBLUA_PKG_CONFIG_NAME = @LIBLUA_PKG_CONFIG_NAME@
 LIBNETAPP_CPPFLAGS = @LIBNETAPP_CPPFLAGS@
 LIBNETAPP_LDFLAGS = @LIBNETAPP_LDFLAGS@
 LIBNETAPP_LIBS = @LIBNETAPP_LIBS@
 LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
@@ -323,12 +324,14 @@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 LUA_CFLAGS = @LUA_CFLAGS@
 LUA_LIBS = @LUA_LIBS@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MICROHTTPD_CFLAGS = @MICROHTTPD_CFLAGS@
+MICROHTTPD_LIBS = @MICROHTTPD_LIBS@
 MKDIR_P = @MKDIR_P@
 NM = @NM@
 NMEDIT = @NMEDIT@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -423,13 +426,13 @@
 sys_symbol_underscore = @sys_symbol_underscore@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-EXTRA_DIST = collectd.proto types.proto
+EXTRA_DIST = collectd.proto types.proto prometheus.proto
 all: all-am
 
 .SUFFIXES:
 $(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/proto: prometheus.proto
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/README	2017-10-06 14:45:52.917917740 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/README	2016-12-12 16:03:36.676279345 +0800
@@ -93,12 +93,16 @@
       average time an IO-operation took to complete.
 
     - dns
       DNS traffic: Query types, response codes, opcodes and traffic/octets
       transferred.
 
+    - dpdkstat
+      Collect DPDK interface statistics.
+      See docs/BUILD.dpdkstat.md for detailed build instructions.
+
     - drbd
       Collect individual drbd resource statistics.
 
     - email
       Email statistics: Count, traffic, spam scores and checks.
       See collectd-email(5).
@@ -125,18 +129,29 @@
     - gmond
       Receive multicast traffic from Ganglia instances.
 
     - gps
       Monitor gps related data through gpsd.
 
-    - grpc
-      Receive values over the network using the gRPC framework.
-
     - hddtemp
       Hard disk temperatures using hddtempd.
 
+    - hugepages
+      Report the number of used and free hugepages. More info on
+      hugepages can be found here:
+      https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt.
+
+    - intel_rdt
+      The intel_rdt plugin collects information provided by monitoring features
+      of Intel Resource Director Technology (Intel(R) RDT) like Cache Monitoring
+      Technology (CMT), Memory Bandwidth Monitoring (MBM). These features
+      provide information about utilization of shared resources like last level
+      cache occupancy, local memory bandwidth usage, remote memory bandwidth
+      usage, instructions per clock.
+      <https://01.org/packet-processing/cache-monitoring-technology-memory-bandwidth-monitoring-cache-allocation-technology-code-and-data>
+
     - interface
       Interface traffic: Number of octets, packets and errors for each
       interface.
 
     - ipc
       IPC counters: semaphores used, number of allocated segments in shared
@@ -156,13 +171,14 @@
 
     - irq
       IRQ counters: Frequency in which certain interrupts occur.
 
     - java
       Integrates a `Java Virtual Machine' (JVM) to execute plugins in Java
-      bytecode. See Configuring with libjvm below.
+      bytecode.
+      See docs/BUILD.java.md for detailed build instructions.
 
     - load
       System load average over the last 1, 5 and 15 minutes.
 
     - lpar
       Detailed CPU statistics of the Logical Partitions virtualization
@@ -179,20 +195,20 @@
       Logical Volume Manager (LVM).
 
     - madwifi
       Queries very detailed usage statistics from wireless LAN adapters and
       interfaces that use the Atheros chipset and the MadWifi driver.
 
-    - mbmon
-      Motherboard sensors: temperature, fan speed and voltage information,
-      using mbmon(1).
-
     - md
       Linux software-RAID device information (number of active, failed, spare
       and missing disks).
 
+    - mbmon
+      Motherboard sensors: temperature, fan speed and voltage information,
+      using mbmon(1).
+
     - memcachec
       Query and parse data from a memcache daemon (memcached).
 
     - memcached
       Statistics of the memcached distributed caching system.
       <http://www.danga.com/memcached/>
@@ -206,15 +222,12 @@
       Intel Many Integrated Core (MIC) CPUs.
 
     - modbus
       Reads values from Modbus/TCP enabled devices. Supports reading values
       from multiple "slaves" so gateway devices can be used.
 
-    - mqtt
-      Publishes and subscribes to MQTT topics.
-
     - multimeter
       Information provided by serial multimeters, such as the `Metex
       M-4650CR'.
 
     - mysql
       MySQL server statistics: Commands issued, handlers triggered, thread
@@ -387,13 +400,13 @@
       Various statistics from Varnish, an HTTP accelerator.
 
     - virt
       CPU, memory, disk and network I/O statistics from virtual machines.
 
     - vmem
-      Virtual memory statistics, e. g. the number of page-ins/-outs or the
+      Virtual memory statistics, e.g. the number of page-ins/-outs or the
       number of pagefaults.
 
     - vserver
       System resources used by Linux VServers.
       See <http://linux-vserver.org/>.
 
@@ -425,16 +438,22 @@
 
     - csv
       Write to comma separated values (CSV) files. This needs lots of
       diskspace but is extremely portable and can be analysed with almost
       every program that can analyse anything. Even Microsoft's Excel..
 
+    - grpc
+      Send and receive values over the network using the gRPC framework.
+
     - lua
       It's possible to implement write plugins in Lua using the Lua
       plugin. See collectd-lua(5) for details.
 
+    - mqtt
+      Publishes and subscribes to MQTT topics.
+
     - network
       Send the data to a remote host to save the data somehow. This is useful
       for large setups where the data should be saved by a dedicated machine.
 
     - perl
       Of course the values are propagated to plugins written in Perl, too, so
@@ -648,18 +667,28 @@
 -------------
 
   To compile collectd from source you will need:
 
   * Usual suspects: C compiler, linker, preprocessor, make, ...
 
+    collectd makes use of some common C99 features, e.g. compound literals and
+    mixed declarations, and therefore requires a C99 compatible compiler.
+
+    On Debian and Ubuntu, the "build-essential" package should pull in
+    everything that's necessary.
+
   * A POSIX-threads (pthread) implementation.
     Since gathering some statistics is slow (network connections, slow devices,
     etc) collectd is parallelized. The POSIX threads interface is being
     used and should be found in various implementations for hopefully all
     platforms.
 
+  * When building from the Git repository, flex (tokenizer) and bison (parser
+    generator) are required. Release tarballs include the generated files  you
+    don't need these packages in that case.
+
   * aerotools-ng (optional)
     Used by the `aquaero' plugin. Currently, the `libaquaero5' library, which
     is used by the `aerotools-ng' toolkit, is not compiled as a shared object
     nor does it feature an installation routine. Therefore, you need to point
     collectd's configure script at the source directory of the `aerotools-ng'
     project.
@@ -728,14 +757,14 @@
   * libiptc (optional)
     For querying iptables counters.
     <http://netfilter.org/>
 
   * libjvm (optional)
     Library that encapsulates the `Java Virtual Machine' (JVM). This library is
-    used by the `java' plugin to execute Java bytecode. See Configuring with
-    libjvm below.
+    used by the `java' plugin to execute Java bytecode.
+    See docs/BUILD.java.md for detailed build instructions.
     <http://openjdk.java.net/> (and others)
 
   * libldap (optional)
     Used by the `openldap' plugin.
     <http://www.openldap.org/>
 
@@ -803,12 +832,17 @@
     <http://www.perl.org/>
 
   * libpq (optional)
     The PostgreSQL C client library used by the `postgresql' plugin.
     <http://www.postgresql.org/>
 
+  * libpqos (optional)
+    The PQoS library for Intel(R) Resource Director Technology used by the
+    `intel_rdt' plugin.
+    <https://github.com/01org/intel-cmt-cat>
+
   * libprotobuf, protoc 3.0+ (optional)
     Used by the `grpc' plugin to generate service stubs and code to handle
     network packets of collectd's protobuf-based network protocol.
     <https://developers.google.com/protocol-buffers/>
 
   * libprotobuf-c, protoc-c (optional)
@@ -923,50 +957,12 @@
   By default, collectd will be installed into `/opt/collectd'. You can adjust
   this setting by specifying the `--prefix' configure option - see INSTALL for
   details. If you pass DESTDIR=<path> to `make install', <path> will be
   prefixed to all installation directories. This might be useful when creating
   packages for collectd.
 
-Configuring with libjvm
------------------------
-
-  To determine the location of the required files of a Java installation is not
-  an easy task, because the locations vary with your kernel (Linux, SunOS, )
-  and with your architecture (x86, SPARC, ) and there is no java-config
-  script we could use. Configuration of the JVM library is therefore a bit
-  tricky.
-
-  The easiest way to use the `--with-java=$JAVA_HOME' option, where
-  `$JAVA_HOME' is usually something like:
-    /usr/lib/jvm/java-1.5.0-sun-1.5.0.14
-
-  The configure script will then use find(1) to look for the following files:
-
-    - jni.h
-    - jni_md.h
-    - libjvm.so
-
-  If found, appropriate CPP-flags and LD-flags are set and the following
-  library checks succeed.
-
-  If this doesn't work for you, you have the possibility to specify CPP-flags,
-  C-flags, LD-flags and LIBS for the Java plugin by hand, using the
-  following environment variables:
-
-    - JAVA_CPPFLAGS
-    - JAVA_CFLAGS
-    - JAVA_LDFLAGS
-    - JAVA_LIBS
-
-  For example (shortened for demonstration purposes):
-
-    ./configure JAVA_CPPFLAGS="-I$JAVA_HOME/include -I$JAVA_HOME/include/linux"
-
-  Adding "-ljvm" to JAVA_LIBS is done automatically, you don't have to
-  do that.
-
 Generating the configure script
 -------------------------------
 
 Collectd ships with a `build.sh' script to generate the `configure'
 script shipped with releases.
 
@@ -1013,14 +1010,18 @@
     * `intswap'    (12345678 -> 56781234)
 
 
 Contact
 -------
 
-  For questions, bug reports, development information and basically all other
-  concerns please send an email to collectd's mailing list at
+  Please use GitHub to report bugs and submit pull requests:
+  <https://github.com/collectd/collectd/>.
+  See CONTRIBUTING.md for details.
+
+  For questions, development information and basically all other concerns please
+  send an email to collectd's mailing list at
   <list at collectd.org>.
 
   For live discussion and more personal contact visit us in IRC, we're in
   channel #collectd on freenode.
 
 
@@ -1028,8 +1029,6 @@
 ------
 
   Florian octo Forster <octo at collectd.org>,
   Sebastian tokkee Harl <sh at tokkee.org>,
   and many contributors (see `AUTHORS').
 
-  Please use GitHub reporting bugs and submitting pull requests.
-  See CONTRIBUTING.md for details.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/aggregation.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/aggregation.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/aggregation.c	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/aggregation.c	2016-12-12 16:03:36.688279258 +0800
@@ -35,13 +35,13 @@
 
 #define AGG_MATCHES_ALL(str) (strcmp("/.*/", str) == 0)
 #define AGG_FUNC_PLACEHOLDER "%{aggregation}"
 
 struct aggregation_s /* {{{ */
 {
-  identifier_t ident;
+  lookup_identifier_t ident;
   unsigned int group_by;
 
   unsigned int regex_fields;
 
   char *set_host;
   char *set_plugin;
@@ -59,13 +59,13 @@
 
 struct agg_instance_s;
 typedef struct agg_instance_s agg_instance_t;
 struct agg_instance_s /* {{{ */
 {
   pthread_mutex_t lock;
-  identifier_t ident;
+  lookup_identifier_t ident;
 
   int ds_type;
 
   derive_t num;
   gauge_t sum;
   gauge_t squares_sum;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/amqp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/amqp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/amqp.c	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/amqp.c	2016-12-12 16:03:36.688279258 +0800
@@ -567,15 +567,15 @@
            frame.payload.body_fragment.len);
     body_ptr += frame.payload.body_fragment.len;
     received += frame.payload.body_fragment.len;
   } /* while (received < body_size) */
 
   if (strcasecmp("text/collectd", content_type) == 0) {
-    status = handle_putval(stderr, body);
+    status = cmd_handle_putval(stderr, body);
     if (status != 0)
-      ERROR("amqp plugin: handle_putval failed with status %i.", status);
+      ERROR("amqp plugin: cmd_handle_putval failed with status %i.", status);
     return (status);
   } else if (strcasecmp("application/json", content_type) == 0) {
     ERROR("amqp plugin: camqp_read_body: Parsing JSON data has not "
           "been implemented yet. FIXME!");
     return (0);
   } else {
@@ -633,30 +633,26 @@
 
   while (subscriber_threads_running) {
     amqp_frame_t frame;
 
     status = camqp_connect(conf);
     if (status != 0) {
-      struct timespec ts_interval;
       ERROR("amqp plugin: camqp_connect failed. "
             "Will sleep for %.3f seconds.",
             CDTIME_T_TO_DOUBLE(interval));
-      CDTIME_T_TO_TIMESPEC(interval, &ts_interval);
-      nanosleep(&ts_interval, /* remaining = */ NULL);
+      nanosleep(&CDTIME_T_TO_TIMESPEC(interval), /* remaining = */ NULL);
       continue;
     }
 
     status = amqp_simple_wait_frame(conf->connection, &frame);
     if (status < 0) {
-      struct timespec ts_interval;
       ERROR("amqp plugin: amqp_simple_wait_frame failed. "
             "Will sleep for %.3f seconds.",
             CDTIME_T_TO_DOUBLE(interval));
       camqp_close_connection(conf);
-      CDTIME_T_TO_TIMESPEC(interval, &ts_interval);
-      nanosleep(&ts_interval, /* remaining = */ NULL);
+      nanosleep(&CDTIME_T_TO_TIMESPEC(interval), /* remaining = */ NULL);
       continue;
     }
 
     if (frame.frame_type != AMQP_FRAME_METHOD) {
       DEBUG("amqp plugin: Unexpected frame type: %#" PRIx8, frame.frame_type);
       continue;
@@ -692,13 +688,13 @@
   }
   subscriber_threads = tmp;
   tmp = subscriber_threads + subscriber_threads_num;
   memset(tmp, 0, sizeof(*tmp));
 
   status = plugin_thread_create(tmp, /* attr = */ NULL, camqp_subscribe_thread,
-                                conf);
+                                conf, "amqp subscribe");
   if (status != 0) {
     char errbuf[1024];
     ERROR("amqp plugin: pthread_create failed: %s",
           sstrerror(status, errbuf, sizeof(errbuf)));
     return (status);
   }
@@ -774,15 +770,15 @@
       else if (routing_key[i] == '/')
         routing_key[i] = '.';
     }
   }
 
   if (conf->format == CAMQP_FORMAT_COMMAND) {
-    status = create_putval(buffer, sizeof(buffer), ds, vl);
+    status = cmd_create_putval(buffer, sizeof(buffer), ds, vl);
     if (status != 0) {
-      ERROR("amqp plugin: create_putval failed with status %i.", status);
+      ERROR("amqp plugin: cmd_create_putval failed with status %i.", status);
       return (status);
     }
   } else if (conf->format == CAMQP_FORMAT_JSON) {
     size_t bfree = sizeof(buffer);
     size_t bfill = 0;
 
@@ -902,13 +898,13 @@
     else if (strcasecmp("User", child->key) == 0)
       status = cf_util_get_string(child, &conf->user);
     else if (strcasecmp("Password", child->key) == 0)
       status = cf_util_get_string(child, &conf->password);
     else if (strcasecmp("Exchange", child->key) == 0)
       status = cf_util_get_string(child, &conf->exchange);
-    else if (strcasecmp("ExchangeType", child->key) == 0)
+    else if ((strcasecmp("ExchangeType", child->key) == 0) && !publish)
       status = cf_util_get_string(child, &conf->exchange_type);
     else if ((strcasecmp("Queue", child->key) == 0) && !publish)
       status = cf_util_get_string(child, &conf->queue);
     else if ((strcasecmp("QueueDurable", child->key) == 0) && !publish)
       status = cf_util_get_boolean(child, &conf->queue_durable);
     else if ((strcasecmp("QueueAutoDelete", child->key) == 0) && !publish)
@@ -932,12 +928,16 @@
              publish)
       status = cf_util_get_flag(child, &conf->graphite_flags,
                                 GRAPHITE_SEPARATE_INSTANCES);
     else if ((strcasecmp("GraphiteAlwaysAppendDS", child->key) == 0) && publish)
       status = cf_util_get_flag(child, &conf->graphite_flags,
                                 GRAPHITE_ALWAYS_APPEND_DS);
+    else if ((strcasecmp("GraphitePreserveSeparator", child->key) == 0) &&
+             publish)
+      status = cf_util_get_flag(child, &conf->graphite_flags,
+                                GRAPHITE_PRESERVE_SEPARATOR);
     else if ((strcasecmp("GraphitePrefix", child->key) == 0) && publish)
       status = cf_util_get_string(child, &conf->prefix);
     else if ((strcasecmp("GraphitePostfix", child->key) == 0) && publish)
       status = cf_util_get_string(child, &conf->postfix);
     else if ((strcasecmp("GraphiteEscapeChar", child->key) == 0) && publish) {
       char *tmp_buff = NULL;
@@ -977,17 +977,18 @@
     DEBUG("amqp plugin: camqp_config_connection: exchange = %s;",
           conf->exchange);
   }
 
   if (publish) {
     char cbname[128];
-    user_data_t ud = {conf, camqp_config_free};
-
     ssnprintf(cbname, sizeof(cbname), "amqp/%s", conf->name);
 
-    status = plugin_register_write(cbname, camqp_write, &ud);
+    status = plugin_register_write(
+        cbname, camqp_write, &(user_data_t){
+                                 .data = conf, .free_func = camqp_config_free,
+                             });
     if (status != 0) {
       camqp_config_free(conf);
       return (status);
     }
   } else {
     status = camqp_subscribe_init(conf);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/apache.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/apache.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/apache.c	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/apache.c	2016-12-12 16:03:36.688279258 +0800
@@ -214,25 +214,25 @@
           "No URL has been configured.",
           st->name);
     status = -1;
   }
 
   if (status == 0) {
-    user_data_t ud = {.data = st, .free_func = apache_free};
-
     char callback_name[3 * DATA_MAX_NAME_LEN];
 
     ssnprintf(callback_name, sizeof(callback_name), "apache/%s/%s",
               (st->host != NULL) ? st->host : hostname_g,
               (st->name != NULL) ? st->name : "default");
 
-    status = plugin_register_complex_read(/* group = */ NULL,
-                                          /* name      = */ callback_name,
-                                          /* callback  = */ apache_read_host,
-                                          /* interval  = */ 0,
-                                          /* user_data = */ &ud);
+    status = plugin_register_complex_read(
+        /* group = */ NULL,
+        /* name      = */ callback_name,
+        /* callback  = */ apache_read_host,
+        /* interval  = */ 0, &(user_data_t){
+                                 .data = st, .free_func = apache_free,
+                             });
   }
 
   if (status != 0) {
     apache_free(st);
     return (-1);
   }
@@ -325,12 +325,13 @@
     }
 
     curl_easy_setopt(st->curl, CURLOPT_USERPWD, credentials);
 #endif
   }
 
+  curl_easy_setopt(st->curl, CURLOPT_URL, st->url);
   curl_easy_setopt(st->curl, CURLOPT_FOLLOWLOCATION, 1L);
   curl_easy_setopt(st->curl, CURLOPT_MAXREDIRS, 50L);
 
   curl_easy_setopt(st->curl, CURLOPT_SSL_VERIFYPEER, (long)st->verify_peer);
   curl_easy_setopt(st->curl, CURLOPT_SSL_VERIFYHOST, st->verify_host ? 2L : 0L);
   if (st->cacert != NULL)
@@ -353,14 +354,14 @@
                          value_t value, apache_t *st) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = &value;
   vl.values_len = 1;
 
-  sstrncpy(vl.host, (st->host != NULL) ? st->host : hostname_g,
-           sizeof(vl.host));
+  if (st->host != NULL)
+    sstrncpy(vl.host, st->host, sizeof(vl.host));
 
   sstrncpy(vl.plugin, "apache", sizeof(vl.plugin));
   if (st->name != NULL)
     sstrncpy(vl.plugin_instance, st->name, sizeof(vl.plugin_instance));
 
   sstrncpy(vl.type, type, sizeof(vl.type));
@@ -368,23 +369,19 @@
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void submit_value */
 
 static void submit_derive(const char *type, const char *type_instance,
-                          derive_t c, apache_t *st) {
-  value_t v;
-  v.derive = c;
-  submit_value(type, type_instance, v, st);
+                          derive_t d, apache_t *st) {
+  submit_value(type, type_instance, (value_t){.derive = d}, st);
 } /* void submit_derive */
 
 static void submit_gauge(const char *type, const char *type_instance, gauge_t g,
                          apache_t *st) {
-  value_t v;
-  v.gauge = g;
-  submit_value(type, type_instance, v, st);
+  submit_value(type, type_instance, (value_t){.gauge = g}, st);
 } /* void submit_gauge */
 
 static void submit_scoreboard(char *buf, apache_t *st) {
   /*
    * Scoreboard Key:
    * "_" Waiting for Connection, "S" Starting up,
@@ -510,15 +507,12 @@
     if (status != 0)
       return (-1);
   }
   assert(st->curl != NULL);
 
   st->apache_buffer_fill = 0;
-
-  curl_easy_setopt(st->curl, CURLOPT_URL, st->url);
-
   if (curl_easy_perform(st->curl) != CURLE_OK) {
     ERROR("apache: curl_easy_perform failed: %s", st->apache_curl_error);
     return (-1);
   }
 
   /* fallback - server_type to apache if not set at this time */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/apcups.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/apcups.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/apcups.c	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/apcups.c	2016-12-12 16:03:36.688279258 +0800
@@ -382,25 +382,19 @@
 
   return (0);
 } /* int apcups_config */
 
 static void apc_submit_generic(const char *type, const char *type_inst,
                                gauge_t value) {
-  value_t values[1];
-  value_list_t vl = VALUE_LIST_INIT;
-
   if (isnan(value))
     return;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  value_list_t vl = VALUE_LIST_INIT;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "apcups", sizeof(vl.plugin));
-  sstrncpy(vl.plugin_instance, "", sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/apple_sensors.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/apple_sensors.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/apple_sensors.c	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/apple_sensors.c	2016-12-12 16:03:36.688279258 +0800
@@ -73,24 +73,17 @@
   }
 
   return (0);
 }
 
 static void as_submit(const char *type, const char *type_instance, double val) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  DEBUG("type = %s; type_instance = %s; val = %f;", type, type_instance, val);
-
-  values[0].gauge = val;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = val};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "apple_sensors", sizeof(vl.plugin));
-  sstrncpy(vl.plugin_instance, "", sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/aquaero.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/aquaero.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/aquaero.c	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/aquaero.c	2016-12-12 16:03:36.688279258 +0800
@@ -51,25 +51,21 @@
   return (0);
 } /* int aquaero_shutdown */
 
 static void aquaero_submit(const char *type, const char *type_instance,
                            double value) {
   const char *instance = conf_device ? conf_device : "default";
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
   /* Don't report undefined values. */
   if (value == AQ5_FLOAT_UNDEF)
     return;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "aquaero", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ascent.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ascent.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ascent.c	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ascent.c	2016-12-12 16:03:36.688279258 +0800
@@ -107,20 +107,16 @@
 };
 static int config_keys_num = STATIC_ARRAY_SIZE(config_keys);
 
 static int ascent_submit_gauge(const char *plugin_instance, /* {{{ */
                                const char *type, const char *type_instance,
                                gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ascent", sizeof(vl.plugin));
 
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
 
   sstrncpy(vl.type, type, sizeof(vl.type));
@@ -512,12 +508,13 @@
     }
 
     curl_easy_setopt(curl, CURLOPT_USERPWD, credentials);
 #endif
   }
 
+  curl_easy_setopt(curl, CURLOPT_URL, url);
   curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
   curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 50L);
 
   if ((verify_peer == NULL) || IS_TRUE(verify_peer))
     curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
   else
@@ -554,15 +551,12 @@
   if (url == NULL) {
     ERROR("ascent plugin: No URL has been configured.");
     return (-1);
   }
 
   ascent_buffer_fill = 0;
-
-  curl_easy_setopt(curl, CURLOPT_URL, url);
-
   if (curl_easy_perform(curl) != CURLE_OK) {
     ERROR("ascent plugin: curl_easy_perform failed: %s", ascent_curl_error);
     return (-1);
   }
 
   status = ascent_xml(ascent_buffer);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/barometer.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/barometer.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/barometer.c	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/barometer.c	2016-12-12 16:03:36.688279258 +0800
@@ -1413,13 +1413,12 @@
   result = MPL115_read_averaged(&pressure, &temperature);
   if (result)
     return result;
 
   norm_pressure = abs_to_mean_sea_level_pressure(pressure);
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "barometer", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, "mpl115", sizeof(vl.plugin_instance));
 
   vl.values_len = 1;
   vl.values = values;
 
@@ -1473,13 +1472,12 @@
   result = MPL3115_read(&pressure, &temperature);
   if (result)
     return result;
 
   norm_pressure = abs_to_mean_sea_level_pressure(pressure);
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "barometer", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, "mpl3115", sizeof(vl.plugin_instance));
 
   vl.values_len = 1;
   vl.values = values;
 
@@ -1533,13 +1531,12 @@
   result = BMP085_read(&pressure, &temperature);
   if (result)
     return result;
 
   norm_pressure = abs_to_mean_sea_level_pressure(pressure);
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "barometer", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, "bmp085", sizeof(vl.plugin_instance));
 
   vl.values_len = 1;
   vl.values = values;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/battery.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/battery.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/battery.c	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/battery.c	2016-12-12 16:03:36.692279230 +0800
@@ -66,26 +66,26 @@
 #define PROC_ACPI_PATH "/proc/acpi/battery"
 #define PROC_ACPI_FACTOR 0.001
 #define SYSFS_PATH "/sys/class/power_supply"
 #define SYSFS_FACTOR 0.000001
 #endif /* KERNEL_LINUX */
 
+int battery_read_statefs(
+    void); /* defined in battery_statefs; used by StateFS backend */
+
 static _Bool report_percent = 0;
 static _Bool report_degraded = 0;
+static _Bool query_statefs = 0;
 
 static void battery_submit2(char const *plugin_instance, /* {{{ */
                             char const *type, char const *type_instance,
                             gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "battery", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
@@ -313,12 +313,15 @@
    * capacity. We use the two to calculate the current charged capacity. */
   gauge_t charge_rel = NAN;      /* Current charge in percent */
   gauge_t capacity_charged;      /* Charged capacity */
   gauge_t capacity_full = NAN;   /* Total capacity */
   gauge_t capacity_design = NAN; /* Full design capacity */
 
+  if (query_statefs)
+    return battery_read_statefs();
+
 #if HAVE_IOKIT_PS_IOPOWERSOURCES_H
   get_via_io_power_sources(&charge_rel, &current, &voltage);
 #endif
 #if HAVE_IOKIT_IOKITLIB_H
   get_via_generic_iokit(&capacity_full, &capacity_design, &current, &voltage);
 #endif
@@ -338,49 +341,23 @@
 #elif KERNEL_LINUX
 /* Reads a file which contains only a number (and optionally a trailing
  * newline) and parses that number. */
 static int sysfs_file_to_buffer(char const *dir, /* {{{ */
                                 char const *power_supply, char const *basename,
                                 char *buffer, size_t buffer_size) {
-  int status;
-  FILE *fp;
   char filename[PATH_MAX];
+  int status;
 
   ssnprintf(filename, sizeof(filename), "%s/%s/%s", dir, power_supply,
             basename);
 
-  /* No file isn't the end of the world -- not every system will be
-   * reporting the same set of statistics */
-  if (access(filename, R_OK) != 0)
-    return ENOENT;
-
-  fp = fopen(filename, "r");
-  if (fp == NULL) {
-    status = errno;
-    if (status != ENOENT) {
-      char errbuf[1024];
-      WARNING("battery plugin: fopen (%s) failed: %s", filename,
-              sstrerror(status, errbuf, sizeof(errbuf)));
-    }
+  status = (int)read_file_contents(filename, buffer, buffer_size);
+  if (status < 0)
     return status;
-  }
-
-  if (fgets(buffer, buffer_size, fp) == NULL) {
-    status = errno;
-    if (status != ENODEV) {
-      char errbuf[1024];
-      WARNING("battery plugin: fgets (%s) failed: %s", filename,
-              sstrerror(status, errbuf, sizeof(errbuf)));
-    }
-    fclose(fp);
-    return status;
-  }
 
   strstripnewline(buffer);
-
-  fclose(fp);
   return 0;
 } /* }}} int sysfs_file_to_buffer */
 
 /* Reads a file which contains only a number (and optionally a trailing
  * newline) and parses that number. */
 static int sysfs_file_to_gauge(char const *dir, /* {{{ */
@@ -708,12 +685,15 @@
 } /* }}} int read_pmu */
 
 static int battery_read(void) /* {{{ */
 {
   int status;
 
+  if (query_statefs)
+    return battery_read_statefs();
+
   DEBUG("battery plugin: Trying sysfs ...");
   status = read_sysfs();
   if (status == 0)
     return (0);
 
   DEBUG("battery plugin: Trying acpi ...");
@@ -736,12 +716,14 @@
     oconfig_item_t *child = ci->children + i;
 
     if (strcasecmp("ValuesPercentage", child->key) == 0)
       cf_util_get_boolean(child, &report_percent);
     else if (strcasecmp("ReportDegraded", child->key) == 0)
       cf_util_get_boolean(child, &report_degraded);
+    else if (strcasecmp("QueryStateFS", child->key) == 0)
+      cf_util_get_boolean(child, &query_statefs);
     else
       WARNING("battery plugin: Ignoring unknown "
               "configuration option \"%s\".",
               child->key);
   }
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: battery_statefs.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/bind.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/bind.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/bind.c	2017-10-06 14:45:52.933917748 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/bind.c	2016-12-12 16:03:36.692279230 +0800
@@ -32,25 +32,17 @@
 #endif
 #ifndef _XOPEN_SOURCE
 #define _XOPEN_SOURCE 500
 #endif
 #endif /* STRPTIME_NEEDS_STANDARDS */
 
-#if TIMEGM_NEEDS_BSD
-#ifndef _BSD_SOURCE
-#define _BSD_SOURCE 1
-#endif
-#endif /* TIMEGM_NEEDS_BSD */
-
 #include "collectd.h"
 
 #include "common.h"
 #include "plugin.h"
 
-#include <time.h>
-
 /* Some versions of libcurl don't include this themselves and then don't have
  * fd_set available. */
 #if HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 
@@ -135,44 +127,44 @@
         {"ReqBadEDNSVer", "dns_request", "BadEDNSVer"},
         {"ReqTSIG", "dns_request", "TSIG"},
         {"ReqSIG0", "dns_request", "SIG0"},
         {"ReqBadSIG", "dns_request", "BadSIG"},
         {"ReqTCP", "dns_request", "TCP"},
         /* Rejects */
-        {"AuthQryRej", "dns_reject", "authorative"},
+        {"AuthQryRej", "dns_reject", "authoritative"},
         {"RecQryRej", "dns_reject", "recursive"},
         {"XfrRej", "dns_reject", "transfer"},
         {"UpdateRej", "dns_reject", "update"},
         /* Responses */
         {"Response", "dns_response", "normal"},
         {"TruncatedResp", "dns_response", "truncated"},
         {"RespEDNS0", "dns_response", "EDNS0"},
         {"RespTSIG", "dns_response", "TSIG"},
         {"RespSIG0", "dns_response", "SIG0"},
         /* Queries */
-        {"QryAuthAns", "dns_query", "authorative"},
+        {"QryAuthAns", "dns_query", "authoritative"},
         {"QryNoauthAns", "dns_query", "nonauth"},
         {"QryReferral", "dns_query", "referral"},
         {"QryRecursion", "dns_query", "recursion"},
-        {"QryDuplicate", "dns_query", "dupliate"},
+        {"QryDuplicate", "dns_query", "duplicate"},
         {"QryDropped", "dns_query", "dropped"},
         {"QryFailure", "dns_query", "failure"},
         /* Response codes */
         {"QrySuccess", "dns_rcode", "tx-NOERROR"},
         {"QryNxrrset", "dns_rcode", "tx-NXRRSET"},
         {"QrySERVFAIL", "dns_rcode", "tx-SERVFAIL"},
         {"QryFORMERR", "dns_rcode", "tx-FORMERR"},
         {"QryNXDOMAIN", "dns_rcode", "tx-NXDOMAIN"}
 #if 0
-  { "XfrReqDone",      "type", "type_instance"       },
-  { "UpdateReqFwd",    "type", "type_instance"       },
-  { "UpdateRespFwd",   "type", "type_instance"       },
-  { "UpdateFwdFail",   "type", "type_instance"       },
-  { "UpdateDone",      "type", "type_instance"       },
-  { "UpdateFail",      "type", "type_instance"       },
-  { "UpdateBadPrereq", "type", "type_instance"       },
+  { "XfrReqDone",      "type",         "type_instance" },
+  { "UpdateReqFwd",    "type",         "type_instance" },
+  { "UpdateRespFwd",   "type",         "type_instance" },
+  { "UpdateFwdFail",   "type",         "type_instance" },
+  { "UpdateDone",      "type",         "type_instance" },
+  { "UpdateFail",      "type",         "type_instance" },
+  { "UpdateBadPrereq", "type",         "type_instance" },
 #endif
 };
 static int nsstats_translation_table_length =
     STATIC_ARRAY_SIZE(nsstats_translation_table);
 /* }}} */
 
@@ -243,22 +235,18 @@
 static int memsummary_translation_table_length =
     STATIC_ARRAY_SIZE(memsummary_translation_table);
 /* }}} */
 
 static void submit(time_t ts, const char *plugin_instance, /* {{{ */
                    const char *type, const char *type_instance, value_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0] = value;
-
-  vl.values = values;
+  vl.values = &value;
   vl.values_len = 1;
   if (config_parse_time)
     vl.time = TIME_T_TO_CDTIME_T(ts);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "bind", sizeof(vl.plugin));
   if (plugin_instance) {
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
     replace_special(vl.plugin_instance, sizeof(vl.plugin_instance));
   }
   sstrncpy(vl.type, type, sizeof(vl.type));
@@ -438,34 +426,13 @@
   if (tmp == NULL) {
     ERROR("bind plugin: bind_xml_read_timestamp: strptime failed.");
     xmlXPathFreeObject(xpathObj);
     return (-1);
   }
 
-#if HAVE_TIMEGM
-  time_t t = timegm(&tm);
-  if (t == ((time_t)-1)) {
-    char errbuf[1024];
-    ERROR("bind plugin: timegm() failed: %s",
-          sstrerror(errno, errbuf, sizeof(errbuf)));
-    return (-1);
-  }
-  *ret_value = t;
-#else
-  time_t t = mktime(&tm);
-  if (t == ((time_t)-1)) {
-    char errbuf[1024];
-    ERROR("bind plugin: mktime() failed: %s",
-          sstrerror(errno, errbuf, sizeof(errbuf)));
-    return (-1);
-  }
-  /* mktime assumes that tm is local time. Luckily, it also sets timezone to
-   * the offset used for the conversion, and we undo the conversion to convert
-   * back to UTC. */
-  *ret_value = t - timezone;
-#endif
+  *ret_value = mktime(&tm);
 
   xmlXPathFreeObject(xpathObj);
   return (0);
 } /* }}} int bind_xml_read_timestamp */
 
 /*
@@ -523,16 +490,14 @@
       int status;
 
       if (ds_type == DS_TYPE_GAUGE)
         status = bind_xml_read_gauge(doc, counter, &value.gauge);
       else
         status = bind_xml_read_derive(doc, counter, &value.derive);
-      if (status != 0) {
-        xmlFree(name);
+      if (status != 0)
         continue;
-      }
 
       status = (*list_callback)(name, value, current_time, user_data);
       if (status == 0)
         num_entries++;
 
       xmlFree(name);
@@ -658,22 +623,18 @@
         continue;
       }
       if (ds_type == DS_TYPE_GAUGE)
         status = bind_xml_read_gauge(doc, child, &value.gauge);
       else
         status = bind_xml_read_derive(doc, child, &value.derive);
-      if (status != 0) {
-        xmlFree(attr_name);
+      if (status != 0)
         continue;
-      }
 
       status = (*list_callback)(attr_name, value, current_time, user_data);
       if (status == 0)
         num_entries++;
-
-      xmlFree(attr_name);
     }
   }
 
   DEBUG("bind plugin: Found %d %s for XPath expression `%s'", num_entries,
         (num_entries == 1) ? "entry" : "entries", xpath_expression);
 
@@ -1599,12 +1560,13 @@
   }
 
   curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
   curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, bind_curl_callback);
   curl_easy_setopt(curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
   curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, bind_curl_error);
+  curl_easy_setopt(curl, CURLOPT_URL, (url != NULL) ? url : BIND_DEFAULT_URL);
   curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
   curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 50L);
 #ifdef HAVE_CURLOPT_TIMEOUT_MS
   curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS,
                    (timeout >= 0) ? (long)timeout : (long)CDTIME_T_TO_MS(
                                                         plugin_get_interval()));
@@ -1620,15 +1582,12 @@
   if (curl == NULL) {
     ERROR("bind plugin: I don't have a CURL object.");
     return (-1);
   }
 
   bind_buffer_fill = 0;
-
-  curl_easy_setopt(curl, CURLOPT_URL, (url != NULL) ? url : BIND_DEFAULT_URL);
-
   if (curl_easy_perform(curl) != CURLE_OK) {
     ERROR("bind plugin: curl_easy_perform failed: %s", bind_curl_error);
     return (-1);
   }
 
   status = bind_xml(bind_buffer);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ceph.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ceph.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ceph.c	2017-10-06 14:45:52.933917748 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ceph.c	2016-12-12 16:03:36.692279230 +0800
@@ -1024,13 +1024,12 @@
   struct values_tmp *vtmp = calloc(1, sizeof(struct values_tmp) * 1);
   if (!vtmp) {
     return -ENOMEM;
   }
 
   vtmp->vlist = (value_list_t)VALUE_LIST_INIT;
-  sstrncpy(vtmp->vlist.host, hostname_g, sizeof(vtmp->vlist.host));
   sstrncpy(vtmp->vlist.plugin, "ceph", sizeof(vtmp->vlist.plugin));
   sstrncpy(vtmp->vlist.plugin_instance, io->d->name,
            sizeof(vtmp->vlist.plugin_instance));
 
   vtmp->d = io->d;
   vtmp->avgcount_exists = -1;
@@ -1298,21 +1297,28 @@
  */
 static int cconn_main_loop(uint32_t request_type) {
   int ret, some_unreachable = 0;
   struct timeval end_tv;
   struct cconn io_array[g_num_daemons];
 
-  DEBUG("ceph plugin: entering cconn_main_loop(request_type = %d)",
+  DEBUG("ceph plugin: entering cconn_main_loop(request_type = %" PRIu32 ")",
         request_type);
 
+  if (g_num_daemons < 1) {
+    ERROR("ceph plugin: No daemons configured. See the \"Daemon\" config "
+          "option.");
+    return ENOENT;
+  }
+
   /* create cconn array */
-  memset(io_array, 0, sizeof(io_array));
-  for (size_t i = 0; i < g_num_daemons; ++i) {
-    io_array[i].d = g_daemons[i];
-    io_array[i].request_type = request_type;
-    io_array[i].state = CSTATE_UNCONNECTED;
+  for (size_t i = 0; i < g_num_daemons; i++) {
+    io_array[i] = (struct cconn){
+        .d = g_daemons[i],
+        .request_type = request_type,
+        .state = CSTATE_UNCONNECTED,
+    };
   }
 
   /** Calculate the time at which we should give up */
   gettimeofday(&end_tv, NULL);
   end_tv.tv_sec += CEPH_TIMEOUT_INTERVAL;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/cgroups.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/cgroups.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/cgroups.c	2017-10-06 14:45:52.933917748 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/cgroups.c	2016-12-12 16:03:36.692279230 +0800
@@ -37,13 +37,12 @@
 cgroups_submit_one(char const *plugin_instance, char const *type_instance,
                    value_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = &value;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "cgroups", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "cpu", sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/chrony.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/chrony.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/chrony.c	2017-10-06 14:45:52.933917748 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/chrony.c	2016-12-12 16:03:36.692279230 +0800
@@ -595,27 +595,19 @@
 
   return coef * pow(2.0, exp);
 }
 
 static void chrony_push_data(const char *p_type, const char *p_type_inst,
                              double p_value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge =
-      p_value; /* TODO: Check type??? (counter, gauge, derive, absolute) */
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = p_value};
   vl.values_len = 1;
 
   /* XXX: Shall g_chrony_host/g_chrony_port be reflected in the plugin's output?
    */
-  /* hostname_g is set in daemon/collectd.c (from config, via gethostname or by
-   * resolving localhost) */
-  /* defined as: char hostname_g[DATA_MAX_NAME_LEN]; (never NULL) */
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, PLUGIN_NAME_SHORT, sizeof(vl.plugin));
   if (g_chrony_plugin_instance != NULL) {
     sstrncpy(vl.plugin_instance, g_chrony_plugin_instance,
              sizeof(vl.plugin_instance));
   }
   if (p_type != NULL)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd.1	2017-10-06 14:55:01.254112542 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd.1	2016-12-12 16:04:32.251989087 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD 1"
-.TH COLLECTD 1 "2017-10-06" "5.6.2.66.ga46c9c8" "collectd"
+.TH COLLECTD 1 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd \- System statistics collection daemon
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd.conf.5	2017-10-06 14:55:01.890112643 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd.conf.5	2016-12-12 16:04:32.899986881 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD.CONF 5"
-.TH COLLECTD.CONF 5 "2017-10-06" "5.6.2.66.ga46c9c8" "collectd"
+.TH COLLECTD.CONF 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd.conf \- Configuration for the system statistics collection daemon collectd
@@ -667,12 +667,13 @@
 \& #   Format "command"
 \& #   StoreRates false
 \& #   GraphitePrefix "collectd."
 \& #   GraphiteEscapeChar "_"
 \& #   GraphiteSeparateInstances false
 \& #   GraphiteAlwaysAppendDS false
+\& #   GraphitePreserveSeparator false
 \&   </Publish>
 \&
 \&   # Receive values from an AMQP broker
 \&   <Subscribe "some_name">
 \&     Host "localhost"
 \&     Port "5672"
@@ -822,12 +823,17 @@
 instance) are put into one component, for example \f(CW\*(C`host.cpu\-0.cpu\-idle\*(C'\fR.
 .IP "\fBGraphiteAlwaysAppendDS\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "GraphiteAlwaysAppendDS true|false"
 If set to \fBtrue\fR, append the name of the \fIData Source\fR (\s-1DS\s0) to the \*(L"metric\*(R"
 identifier. If set to \fBfalse\fR (the default), this is only done when there is
 more than one \s-1DS.\s0
+.IP "\fBGraphitePreserveSeparator\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "GraphitePreserveSeparator false|true"
+If set to \fBfalse\fR (the default) the \f(CW\*(C`.\*(C'\fR (dot) character is replaced with
+\&\fIGraphiteEscapeChar\fR. Otherwise, if set to \fBtrue\fR, the \f(CW\*(C`.\*(C'\fR (dot) character
+is preserved, i.e. passed through.
 .ie n .SS "Plugin ""apache"""
 .el .SS "Plugin \f(CWapache\fP"
 .IX Subsection "Plugin apache"
 To configure the \f(CW\*(C`apache\*(C'\fR\-plugin you first need to configure the Apache
 webserver correctly. The Apache-plugin \f(CW\*(C`mod_status\*(C'\fR needs to be loaded and
 working and the \f(CW\*(C`ExtendedStatus\*(C'\fR directive needs to be \fBenabled\fR. You can use
@@ -1154,12 +1160,18 @@
 such as the status bar of desktop environments, also do.
 .Sp
 When set to \fBtrue\fR, the battery plugin will report three values: \fBcharged\fR
 (remaining capacity), \fBdischarged\fR (difference between \*(L"last full capacity\*(R"
 and \*(L"remaining capacity\*(R") and \fBdegraded\fR (difference between \*(L"design capacity\*(R"
 and \*(L"last full capacity\*(R").
+.IP "\fBQueryStateFS\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "QueryStateFS false|true"
+When set to \fBtrue\fR, the battery plugin will only read statistics
+related to battery performance as exposed by StateFS at
+/run/state. StateFS is used in Mer-based Sailfish \s-1OS,\s0 for
+example.
 .ie n .SS "Plugin ""bind"""
 .el .SS "Plugin \f(CWbind\fP"
 .IX Subsection "Plugin bind"
 Starting with \s-1BIND 9.5.0,\s0 the most widely used \s-1DNS\s0 server software provides
 extensive statistics about queries, responses and lots of other information.
 The bind plugin retrieves this information that's encoded in \s-1XML\s0 and provided
@@ -1369,14 +1381,12 @@
 \&\fI/sys/fs/cgroup/cpu.cpuacct\fR on machines using systemd).
 .IP "\fBCGroup\fR \fIDirectory\fR" 4
 .IX Item "CGroup Directory"
 Select \fIcgroup\fR based on the name. Whether only matching \fIcgroups\fR are
 collected or if they are ignored is controlled by the \fBIgnoreSelected\fR option;
 see below.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 Invert the selection: If set to true, all cgroups \fIexcept\fR the ones that
 match any one of the criteria are collected. By default only selected
 cgroups are collected if a selection is made. If no selection is configured
 at all, \fBall\fR cgroups are selected.
@@ -2167,24 +2177,18 @@
 .ie n .SS "Plugin ""df"""
 .el .SS "Plugin \f(CWdf\fP"
 .IX Subsection "Plugin df"
 .IP "\fBDevice\fR \fIDevice\fR" 4
 .IX Item "Device Device"
 Select partitions based on the devicename.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBMountPoint\fR \fIDirectory\fR" 4
 .IX Item "MountPoint Directory"
 Select partitions based on the mountpoint.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBFSType\fR \fIFSType\fR" 4
 .IX Item "FSType FSType"
 Select partitions based on the filesystem type.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 Invert the selection: If set to true, all partitions \fBexcept\fR the ones that
 match any one of the criteria are collected. By default only selected
 partitions are collected if a selection is made. If no selection is configured
 at all, \fBall\fR partitions are selected.
@@ -2232,14 +2236,12 @@
 is interpreted as a regular expression. Examples:
 .Sp
 .Vb 2
 \&  Disk "sdd"
 \&  Disk "/hda[34]/"
 .Ve
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 Sets whether selected disks, i.\ e. the ones matches by any of the \fBDisk\fR
 statements, are ignored or if all other disks are ignored. The behavior
 (hopefully) is intuitive: If no \fBDisk\fR option is configured, all disks are
 collected. If at least one \fBDisk\fR option is given and no \fBIgnoreSelected\fR or
@@ -2271,12 +2273,64 @@
 .IP "\fBIgnoreSource\fR \fIIP-address\fR" 4
 .IX Item "IgnoreSource IP-address"
 Ignore packets that originate from this address.
 .IP "\fBSelectNumericQueryTypes\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "SelectNumericQueryTypes true|false"
 Enabled by default, collects unknown (and thus presented as numeric only) query types.
+.ie n .SS "Plugin ""dpdkstat"""
+.el .SS "Plugin \f(CWdpdkstat\fP"
+.IX Subsection "Plugin dpdkstat"
+The \fIdpdkstat plugin\fR collects information about \s-1DPDK\s0 interfaces using the
+extended \s-1NIC\s0 stats \s-1API\s0 in \s-1DPDK.\s0
+.PP
+\&\fBSynopsis:\fR
+.PP
+.Vb 9
+\& <Plugin "dpdkstat">
+\&    Coremask "0x4"
+\&    MemoryChannels "4"
+\&    ProcessType "secondary"
+\&    FilePrefix "rte"
+\&    EnabledPortMask 0xffff
+\&    PortName "interface1"
+\&    PortName "interface2"
+\& </Plugin>
+.Ve
+.PP
+\&\fBOptions:\fR
+.IP "\fBCoremask\fR \fIMask\fR" 4
+.IX Item "Coremask Mask"
+A string containing an hexadecimal bit mask of the cores to run on. Note that
+core numbering can change between platforms and should be determined beforehand.
+.IP "\fBMemorychannels\fR \fIChannels\fR" 4
+.IX Item "Memorychannels Channels"
+A string containing a number of memory channels per processor socket.
+.IP "\fBProcessType\fR \fItype\fR" 4
+.IX Item "ProcessType type"
+A string containing the type of \s-1DPDK\s0 process instance.
+.IP "\fBFilePrefix\fR \fIFile\fR" 4
+.IX Item "FilePrefix File"
+The prefix text used for hugepage filenames. The filename will be set to
+/var/run/.<prefix>_config where prefix is what is passed in by the user.
+.IP "\fBSocketMemory\fR \fI\s-1MB\s0\fR" 4
+.IX Item "SocketMemory MB"
+A string containing amount of Memory to allocate from hugepages on specific
+sockets in \s-1MB\s0
+.IP "\fBEnabledPortMask\fR \fIMask\fR" 4
+.IX Item "EnabledPortMask Mask"
+A hexidecimal bit mask of the \s-1DPDK\s0 ports which should be enabled. A mask
+of 0x0 means that all ports will be disabled. A bitmask of all Fs means
+that all ports will be enabled. This is an optional argument \- default
+is all ports enabled.
+.IP "\fBPortName\fR \fIName\fR" 4
+.IX Item "PortName Name"
+A string containing an optional name for the enabled \s-1DPDK\s0 ports. Each PortName
+option should contain only one port name; specify as many PortName options as
+desired. Default naming convention will be used if PortName is blank. If there
+are less PortName options than there are enabled ports, the default naming
+convention will be used for the additional ports.
 .ie n .SS "Plugin ""email"""
 .el .SS "Plugin \f(CWemail\fP"
 .IX Subsection "Plugin email"
 .IP "\fBSocketFile\fR \fIPath\fR" 4
 .IX Item "SocketFile Path"
 Sets the socket-file which is to be created.
@@ -2647,21 +2701,101 @@
 .IP "\fBHost\fR \fIHostname\fR" 4
 .IX Item "Host Hostname"
 Hostname to connect to. Defaults to \fB127.0.0.1\fR.
 .IP "\fBPort\fR \fIPort\fR" 4
 .IX Item "Port Port"
 TCP-Port to connect to. Defaults to \fB7634\fR.
+.ie n .SS "Plugin ""hugepages"""
+.el .SS "Plugin \f(CWhugepages\fP"
+.IX Subsection "Plugin hugepages"
+To collect \fBhugepages\fR information, collectd reads directories
+\&\*(L"/sys/devices/system/node/*/hugepages\*(R" and
+\&\*(L"/sys/kernel/mm/hugepages\*(R".
+Reading of these directories can be disabled by the following
+options (default is enabled).
+.IP "\fBReportPerNodeHP\fR \fBtrue\fR|\fBfalse\fR" 4
+.IX Item "ReportPerNodeHP true|false"
+If enabled, information will be collected from the hugepage
+counters in \*(L"/sys/devices/system/node/*/hugepages\*(R".
+This is used to check the per-node hugepage statistics on
+a \s-1NUMA\s0 system.
+.IP "\fBReportRootHP\fR \fBtrue\fR|\fBfalse\fR" 4
+.IX Item "ReportRootHP true|false"
+If enabled, information will be collected from the hugepage
+counters in \*(L"/sys/kernel/mm/hugepages\*(R".
+This can be used on both \s-1NUMA\s0 and non-NUMA systems to check
+the overall hugepage statistics.
+.IP "\fBValuesPages\fR \fBtrue\fR|\fBfalse\fR" 4
+.IX Item "ValuesPages true|false"
+Whether to report hugepages metrics in number of pages.
+Defaults to \fBtrue\fR.
+.IP "\fBValuesBytes\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "ValuesBytes false|true"
+Whether to report hugepages metrics in bytes.
+Defaults to \fBfalse\fR.
+.IP "\fBValuesPercentage\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "ValuesPercentage false|true"
+Whether to report hugepages metrics as percentage.
+Defaults to \fBfalse\fR.
+.ie n .SS "Plugin ""intel_rdt"""
+.el .SS "Plugin \f(CWintel_rdt\fP"
+.IX Subsection "Plugin intel_rdt"
+The \fIintel_rdt\fR plugin collects information provided by monitoring features of
+Intel Resource Director Technology (Intel(R) \s-1RDT\s0) like Cache Monitoring
+Technology (\s-1CMT\s0), Memory Bandwidth Monitoring (\s-1MBM\s0). These features provide
+information about utilization of shared resources. \s-1CMT\s0 monitors last level cache
+occupancy (\s-1LLC\s0). \s-1MBM\s0 supports two types of events reporting local and remote
+memory bandwidth. Local memory bandwidth (\s-1MBL\s0) reports the bandwidth of
+accessing memory associated with the local socket. Remote memory bandwidth (\s-1MBR\s0)
+reports the bandwidth of accessing the remote socket. Also this technology
+allows to monitor instructions per clock (\s-1IPC\s0).
+Monitor events are hardware dependant. Monitoring capabilities are detected on
+plugin initialization and only supported events are monitored.
+.PP
+\&\fBSynopsis:\fR
+.PP
+.Vb 3
+\&  <Plugin "intel_rdt">
+\&    Cores "0\-2" "3,4,6" "8\-10,15"
+\&  </Plugin>
+.Ve
+.PP
+\&\fBOptions:\fR
+.IP "\fBInterval\fR \fIseconds\fR" 4
+.IX Item "Interval seconds"
+The interval within which to retrieve statistics on monitored events in seconds.
+For milliseconds divide the time by 1000 for example if the desired interval
+is 50ms, set interval to 0.05. Due to limited capacity of counters it is not
+recommended to set interval higher than 1 sec.
+.IP "\fBCores\fR \fIcores groups\fR" 4
+.IX Item "Cores cores groups"
+All events are reported on a per core basis. Monitoring of the events can be
+configured for group of cores (aggregated statistics). This field defines groups
+of cores on which to monitor supported events. The field is represented as list
+of strings with core group values. Each string represents a list of cores in a
+group. Allowed formats are:
+    0,1,2,3
+    0\-10,20\-18
+    1,3,5\-8,10,0x10\-12
+.Sp
+If an empty string is provided as value for this field default cores
+configuration is applied \- a separate group is created for each core.
+.PP
+\&\fBNote:\fR By default global interval is used to retrieve statistics on monitored
+events. To configure a plugin specific interval use \fBInterval\fR option of the
+intel_rdt <LoadPlugin> block. For milliseconds divide the time by 1000 for
+example if the desired interval is 50ms, set interval to 0.05.
+Due to limited capacity of counters it is not recommended to set interval higher
+than 1 sec.
 .ie n .SS "Plugin ""interface"""
 .el .SS "Plugin \f(CWinterface\fP"
 .IX Subsection "Plugin interface"
 .IP "\fBInterface\fR \fIInterface\fR" 4
 .IX Item "Interface Interface"
 Select this interface. By default these interfaces will then be collected. For
 a more detailed description see \fBIgnoreSelected\fR below.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fItrue\fR|\fIfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 If no configuration if given, the \fBinterface\fR\-plugin will collect data from
 all interfaces. This may not be practical, especially for loopback\- and
 similar interfaces. Thus, you can use the \fBInterface\fR\-option to pick the
 interfaces you're interested in. Sometimes, however, it's easier/preferred
@@ -2712,14 +2846,12 @@
 .ie n .SS "Plugin ""ipmi"""
 .el .SS "Plugin \f(CWipmi\fP"
 .IX Subsection "Plugin ipmi"
 .IP "\fBSensor\fR \fISensor\fR" 4
 .IX Item "Sensor Sensor"
 Selects sensors to collect or to ignore, depending on \fBIgnoreSelected\fR.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fItrue\fR|\fIfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 If no configuration if given, the \fBipmi\fR plugin will collect data from all
 sensors found of type \*(L"temperature\*(R", \*(L"voltage\*(R", \*(L"current\*(R" and \*(L"fanspeed\*(R".
 This option enables you to do that: By setting \fBIgnoreSelected\fR to \fItrue\fR
 the effect of \fBSensor\fR is inverted: All selected sensors are ignored and
@@ -2760,14 +2892,12 @@
 .el .SS "Plugin \f(CWirq\fP"
 .IX Subsection "Plugin irq"
 .IP "\fBIrq\fR \fIIrq\fR" 4
 .IX Item "Irq Irq"
 Select this irq. By default these irqs will then be collected. For a more
 detailed description see \fBIgnoreSelected\fR below.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fItrue\fR|\fIfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 If no configuration if given, the \fBirq\fR\-plugin will collect data from all
 irqs. This may not be practical, especially if no interrupts happen. Thus, you
 can use the \fBIrq\fR\-option to pick the interrupt you're interested in.
 Sometimes, however, it's easier/preferred to collect all interrupts \fIexcept\fR a
@@ -2942,14 +3072,12 @@
 \&\fImissing\fR (physically absent) disks.
 .IP "\fBDevice\fR \fIDevice\fR" 4
 .IX Item "Device Device"
 Select md devices based on device name. The \fIdevice name\fR is the basename of
 the device, i.e. the name of the block device without the leading \f(CW\*(C`/dev/\*(C'\fR.
 See \fBIgnoreSelected\fR for more details.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 Invert device selection: If set to \fBtrue\fR, all md devices \fBexcept\fR those
 listed using \fBDevice\fR are collected. If \fBfalse\fR (the default), only those
 listed are collected. If no configuration is given, the \fBmd\fR plugin will
 collect data from all md devices.
@@ -3000,36 +3128,45 @@
 interpreted. For a description of match blocks, please see \*(L"Plugin tail\*(R".
 .ie n .SS "Plugin ""memcached"""
 .el .SS "Plugin \f(CWmemcached\fP"
 .IX Subsection "Plugin memcached"
 The \fBmemcached plugin\fR connects to a memcached server and queries statistics
 about cache utilization, memory and bandwidth used.
-<http://www.danga.com/memcached/>
+<http://memcached.org/>
 .PP
-.Vb 6
+.Vb 7
 \& <Plugin "memcached">
 \&   <Instance "name">
-\&     Host "memcache.example.com"
+\&     #Host "memcache.example.com"
+\&     Address "127.0.0.1"
 \&     Port 11211
 \&   </Instance>
 \& </Plugin>
 .Ve
 .PP
 The plugin configuration consists of one or more \fBInstance\fR blocks which
 specify one \fImemcached\fR connection each. Within the \fBInstance\fR blocks, the
 following options are allowed:
 .IP "\fBHost\fR \fIHostname\fR" 4
 .IX Item "Host Hostname"
-Hostname to connect to. Defaults to \fB127.0.0.1\fR.
+Sets the \fBhost\fR field of dispatched values. Defaults to the global hostname
+setting.
+For backwards compatibility, values are also dispatched with the global
+hostname when \fBHost\fR is set to \fB127.0.0.1\fR or \fBlocalhost\fR and \fBAddress\fR is
+not set.
+.IP "\fBAddress\fR \fIAddress\fR" 4
+.IX Item "Address Address"
+Hostname or \s-1IP\s0 to connect to. For backwards compatibility, defaults to the
+value of \fBHost\fR or \fB127.0.0.1\fR if \fBHost\fR is unset.
 .IP "\fBPort\fR \fIPort\fR" 4
 .IX Item "Port Port"
-TCP-Port to connect to. Defaults to \fB11211\fR.
+\&\s-1TCP\s0 port to connect to. Defaults to \fB11211\fR.
 .IP "\fBSocket\fR \fIPath\fR" 4
 .IX Item "Socket Path"
 Connect to \fImemcached\fR using the \s-1UNIX\s0 domain socket at \fIPath\fR. If this
-setting is given, the \fBHost\fR and \fBPort\fR settings are ignored.
+setting is given, the \fBAddress\fR and \fBPort\fR settings are ignored.
 .ie n .SS "Plugin ""mic"""
 .el .SS "Plugin \f(CWmic\fP"
 .IX Subsection "Plugin mic"
 The \fBmic plugin\fR gathers \s-1CPU\s0 statistics, memory usage and temperatures from
 Intel's Many Integrated Core (\s-1MIC\s0) systems.
 .PP
@@ -3967,14 +4104,12 @@
 .Sp
 If no regular expression is specified, an exact match is required. Both,
 regular and exact matching are case sensitive.
 .Sp
 If no volume was specified at all for either of the three options, that data
 will be collected for all available volumes.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelectedIO\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "IgnoreSelectedIO true|false"
 .PD 0
 .IP "\fBIgnoreSelectedOps\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "IgnoreSelectedOps true|false"
 .IP "\fBIgnoreSelectedLatency\fR \fBtrue\fR|\fBfalse\fR" 4
@@ -4143,14 +4278,12 @@
 \&    QDisc "eth0" "pfifo_fast\-1:0"
 \&    QDisc "ppp0"
 \&    Class "ppp0" "htb\-1:10"
 \&    Filter "ppp0" "u32\-1:0"
 \&  </Plugin>
 .Ve
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR" 4
 .IX Item "IgnoreSelected"
 The behavior is the same as with all other similar plugins: If nothing is
 selected at all, everything is collected. If some things are selected using the
 options described above, only these statistics are collected. If you set
 \&\fBIgnoreSelected\fR to \fBtrue\fR, this behavior is inverted, i.\ e. the
@@ -4597,14 +4730,12 @@
 In the advanced mode the \fBSensor\fR specifies full \s-1OWFS\s0 path \- e.g.
 \&\f(CW\*(C`/uncached/10.F10FCA000800/temperature\*(C'\fR (or when cached values are \s-1OK
 \&\s0\f(CW\*(C`/10.F10FCA000800/temperature\*(C'\fR). \fBIgnoreSelected\fR is not used.
 .Sp
 As there can be multiple devices on the bus you can list multiple sensor (use
 multiple \fBSensor\fR elements).
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fItrue\fR|\fIfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 If no configuration is given, the \fBonewire\fR plugin will collect data from all
 sensors found. This may not be practical, especially if sensors are added and
 removed regularly. Sometimes, however, it's easier/preferred to collect only
 specific sensors or all sensors \fIexcept\fR a few specified ones. This option
@@ -4886,16 +5017,16 @@
 .IX Item "Host IP-address"
 Host to ping periodically. This option may be repeated several times to ping
 multiple hosts.
 .IP "\fBInterval\fR \fISeconds\fR" 4
 .IX Item "Interval Seconds"
 Sets the interval in which to send \s-1ICMP\s0 echo packets to the configured hosts.
-This is \fBnot\fR the interval in which metrics are read from the plugin but the
-interval in which the hosts are \*(L"pinged\*(R". Therefore, the setting here should be
-smaller than or equal to the global \fBInterval\fR setting. Fractional times, such
-as \*(L"1.24\*(R" are allowed.
+This is \fBnot\fR the interval in which statistics are queries from the plugin but
+the interval in which the hosts are \*(L"pinged\*(R". Therefore, the setting here
+should be smaller than or equal to the global \fBInterval\fR setting. Fractional
+times, such as \*(L"1.24\*(R" are allowed.
 .Sp
 Default: \fB1.0\fR
 .IP "\fBTimeout\fR \fISeconds\fR" 4
 .IX Item "Timeout Seconds"
 Time to wait for a response from the host to which an \s-1ICMP\s0 packet had been
 sent. If a reply was not received after \fISeconds\fR seconds, the host is assumed
@@ -5194,13 +5325,13 @@
 tokens \fB\f(CB$1\fB\fR, \fB\f(CB$2\fB\fR, through \fB\f(CB$9\fB\fR in the statement string. The following
 values are made available through those parameters:
 .RS 4
 .ie n .IP "\fB\fB$1\fB\fR" 4
 .el .IP "\fB\f(CB$1\fB\fR" 4
 .IX Item "$1"
-The timestamp of the queried value as a floating point number.
+The timestamp of the queried value as an \s-1RFC\s0 3339\-formatted local time.
 .ie n .IP "\fB\fB$2\fB\fR" 4
 .el .IP "\fB\f(CB$2\fB\fR" 4
 .IX Item "$2"
 The hostname of the queried value.
 .ie n .IP "\fB\fB$3\fB\fR" 4
 .el .IP "\fB\f(CB$3\fB\fR" 4
@@ -5546,14 +5677,12 @@
 \&  Value "/^TcpExt:/"
 .Ve
 .Sp
 Whether only matched values are selected or all matched values are ignored
 depends on the \fBIgnoreSelected\fR. By default, only matched values are selected.
 If no value is configured at all, all values will be selected.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 If set to \fBtrue\fR, inverts the selection made by \fBValue\fR, i.\ e. all
 matching values will be ignored.
 .ie n .SS "Plugin ""python"""
 .el .SS "Plugin \f(CWpython\fP"
@@ -5855,26 +5984,20 @@
 \&\fIFactor\fR must be in the range \f(CW\*(C`[0.0\-1.0)\*(C'\fR, i.e. between zero (inclusive) and
 one (exclusive).
 .IP "\fBCacheFlush\fR \fISeconds\fR" 4
 .IX Item "CacheFlush Seconds"
 When the \f(CW\*(C`rrdtool\*(C'\fR plugin uses a cache (by setting \fBCacheTimeout\fR, see below)
 it writes all values for a certain RRD-file if the oldest value is older than
-(or equal to) the number of seconds specified by \fBCacheTimeout\fR.
-That check happens on new values arriwal. If some RRD-file is not updated
+(or equal to) the number of seconds specified. If some RRD-file is not updated
 anymore for some reason (the computer was shut down, the network is broken,
-etc.) some values may still be in the cache. If \fBCacheFlush\fR is set, then
-every \fISeconds\fR seconds the entire cache is searched for entries older than
-\&\fBCacheTimeout\fR + \fBRandomTimeout\fR seconds. The entries found are written to
-disk. Since scanning the entire cache is kind of expensive and does nothing
-under normal circumstances, this value should not be too small. 900 seconds
-might be a good value, though setting this to 7200 seconds doesn't normally
-do much harm either.
-.Sp
-Defaults to 10x \fBCacheTimeout\fR.
-\&\fBCacheFlush\fR must be larger than or equal to \fBCacheTimeout\fR, otherwise the
-above default is used.
+etc.) some values may still be in the cache. If \fBCacheFlush\fR is set, then the
+entire cache is searched for entries older than \fBCacheTimeout\fR seconds and
+written to disk every \fISeconds\fR seconds. Since this is kind of expensive and
+does nothing under normal circumstances, this value should not be too small.
+900 seconds might be a good value, though setting this to 7200 seconds doesn't
+normally do much harm either.
 .IP "\fBCacheTimeout\fR \fISeconds\fR" 4
 .IX Item "CacheTimeout Seconds"
 If this option is set to a value greater than zero, the \f(CW\*(C`rrdtool plugin\*(C'\fR will
 save values in a cache, as described above. Writing multiple values at once
 reduces IO-operations and thus lessens the load produced by updating the files.
 The trade off is that the graphs kind of \*(L"drag behind\*(R" and that more memory is
@@ -5926,14 +6049,12 @@
 .IP "\fBSensor\fR \fIchip\-bus\-address/type\-feature\fR" 4
 .IX Item "Sensor chip-bus-address/type-feature"
 Selects the name of the sensor which you want to collect or ignore, depending
 on the \fBIgnoreSelected\fR below. For example, the option "\fBSensor\fR
 \&\fIit8712\-isa\-0290/voltage\-in1\fR" will cause collectd to gather data for the
 voltage sensor \fIin1\fR of the \fIit8712\fR on the isa bus at the address 0290.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fItrue\fR|\fIfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 If no configuration if given, the \fBsensors\fR\-plugin will collect data from all
 sensors. This may not be practical, especially for uninteresting sensors.
 Thus, you can use the \fBSensor\fR\-option to pick the sensors you're interested
 in. Sometimes, however, it's easier/preferred to collect all sensors \fIexcept\fR a
@@ -6024,14 +6145,12 @@
 is interpreted as a regular expression. Examples:
 .Sp
 .Vb 2
 \&  Disk "sdd"
 \&  Disk "/hda[34]/"
 .Ve
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 Sets whether selected disks, i.\ e. the ones matches by any of the \fBDisk\fR
 statements, are ignored or if all other disks are ignored. The behavior
 (hopefully) is intuitive: If no \fBDisk\fR option is configured, all disks are
 collected. If at least one \fBDisk\fR option is given and no \fBIgnoreSelected\fR or
@@ -6277,12 +6396,21 @@
 \&        Regex "\e\e<R=local_user\e\e>"
 \&        ExcludeRegex "\e\e<R=local_user\e\e>.*mail_spool defer"
 \&        DSType "CounterInc"
 \&        Type "counter"
 \&        Instance "local_user"
 \&      </Match>
+\&      <Match>
+\&        Regex "l=([0\-9]*\e\e.[0\-9]*)"
+\&        <DSType "Distribution">
+\&          Percentile 99
+\&          Bucket 0 100
+\&        </DSType>
+\&        Type "latency"
+\&        Instance "foo"
+\&      </Match>
 \&    </File>
 \&  </Plugin>
 .Ve
 .PP
 The config consists of one or more \fBFile\fR blocks, each of which configures one
 logfile to parse. Within each \fBFile\fR block, there are one or more \fBMatch\fR
@@ -6333,12 +6461,18 @@
 .IP "\fBGaugeMax\fR" 4
 .IX Item "GaugeMax"
 Use the greatest number only.
 .IP "\fBGaugeLast\fR" 4
 .IX Item "GaugeLast"
 Use the last number found.
+.IP "\fBGaugePersist\fR" 4
+.IX Item "GaugePersist"
+Use the last number found. The number is not reset at the end of an interval.
+It is continously reported until another number is matched. This is intended
+for cases in which only state changes are reported, for example a thermometer
+that only reports the temperature when it changes.
 .IP "\fBCounterSet\fR" 4
 .IX Item "CounterSet"
 .PD 0
 .IP "\fBDeriveSet\fR" 4
 .IX Item "DeriveSet"
 .IP "\fBAbsoluteSet\fR" 4
@@ -6365,21 +6499,82 @@
 .IP "\fBDeriveInc\fR" 4
 .IX Item "DeriveInc"
 .PD
 Increase the internal counter by one. These \fBDSType\fR are the only ones that do
 not use the matched subexpression, but simply count the number of matched
 lines. Thus, you may use a regular expression without submatch in this case.
+.IP "\fBDistribution\fR" 4
+.IX Item "Distribution"
+Type to do calculations based on the distribution of values, primarily
+calculating percentiles. This is primarily geared towards latency, but can be
+used for other metrics as well. The range of values tracked with this setting
+must be in the range (0X2^34) and can be fractional. Please note that neither
+zero nor 2^34 are inclusive bounds, i.e. zero \fIcannot\fR be handled by a
+distribution.
+.Sp
+This option must be used together with the \fBPercentile\fR and/or \fBBucket\fR
+options.
+.Sp
+\&\fBSynopsis:\fR
+.Sp
+.Vb 4
+\&  <DSType "Distribution">
+\&    Percentile 99
+\&    Bucket 0 100
+\&  </DSType>
+.Ve
+.RS 4
+.IP "\fBPercentile\fR \fIPercent\fR" 4
+.IX Item "Percentile Percent"
+Calculate and dispatch the configured percentile, i.e. compute the value, so
+that \fIPercent\fR of all matched values are smaller than or equal to the computed
+latency.
+.Sp
+Metrics are reported with the \fItype\fR \fBType\fR (the value of the above option)
+and the \fItype instance\fR \f(CW\*(C`[<Instance>\-]<Percent>\*(C'\fR.
+.Sp
+This option may be repeated to calculate more than one percentile.
+.IP "\fBBucket\fR \fIlower_bound\fR \fIupper_bound\fR" 4
+.IX Item "Bucket lower_bound upper_bound"
+Export the number of values (a \f(CW\*(C`DERIVE\*(C'\fR) falling within the given range. Both,
+\&\fIlower_bound\fR and \fIupper_bound\fR may be a fractional number, such as \fB0.5\fR.
+Each \fBBucket\fR option specifies an interval \f(CW\*(C`(\f(CIlower_bound\f(CW,
+\&\f(CIupper_bound\f(CW]\*(C'\fR, i.e. the range \fIexcludes\fR the lower bound and \fIincludes\fR
+the upper bound. \fIlower_bound\fR and \fIupper_bound\fR may be zero, meaning no
+lower/upper bound.
+.Sp
+To export the entire (0Xinf) range without overlap, use the upper bound of the
+previous range as the lower bound of the following range. In other words, use
+the following schema:
+.Sp
+.Vb 7
+\&  Bucket   0   1
+\&  Bucket   1   2
+\&  Bucket   2   5
+\&  Bucket   5  10
+\&  Bucket  10  20
+\&  Bucket  20  50
+\&  Bucket  50   0
+.Ve
+.Sp
+Metrics are reported with the \fItype\fR \f(CW\*(C`bucket\*(C'\fR and the \fItype instance\fR
+\&\f(CW\*(C`<Type>[\-<Instance>]\-<lower_bound>_<upper_bound>\*(C'\fR.
+.Sp
+This option may be repeated to calculate more than one rate.
+.RE
+.RS 4
+.RE
 .RE
 .RS 4
 .Sp
-As you'd expect the \fBGauge*\fR types interpret the submatch as a floating point
-number, using \fIstrtod\fR\|(3). The \fBCounter*\fR and \fBAbsoluteSet\fR types interpret
-the submatch as an unsigned integer using \fIstrtoull\fR\|(3). The \fBDerive*\fR types
-interpret the submatch as a signed integer using \fIstrtoll\fR\|(3). \fBCounterInc\fR
-and \fBDeriveInc\fR do not use the submatch at all and it may be omitted in this
-case.
+The \fBGauge*\fR and \fBDistribution\fR types interpret the submatch as a floating
+point number, using \fIstrtod\fR\|(3). The \fBCounter*\fR and \fBAbsoluteSet\fR types
+interpret the submatch as an unsigned integer using \fIstrtoull\fR\|(3). The
+\&\fBDerive*\fR types interpret the submatch as a signed integer using
+\&\fIstrtoll\fR\|(3). \fBCounterInc\fR and \fBDeriveInc\fR do not use the submatch at all
+and it may be omitted in this case.
 .RE
 .IP "\fBType\fR \fIType\fR" 4
 .IX Item "Type Type"
 Sets the type used to dispatch this value. Detailed information about types and
 their configuration can be found in \fItypes.db\fR\|(5).
 .IP "\fBInstance\fR \fITypeInstance\fR" 4
@@ -6564,14 +6759,12 @@
 plugin to use the latter. This option defaults to \fIfalse\fR.
 .IP "\fBDevice\fR \fIDevice\fR" 4
 .IX Item "Device Device"
 Selects the name of the thermal device that you want to collect or ignore,
 depending on the value of the \fBIgnoreSelected\fR option. This option may be
 used multiple times to specify a list of devices.
-.Sp
-See \fI/\*(L"\s-1IGNORELISTS\*(R"\s0\fR for details.
 .IP "\fBIgnoreSelected\fR \fItrue\fR|\fIfalse\fR" 4
 .IX Item "IgnoreSelected true|false"
 Invert the selection: If set to true, all devices \fBexcept\fR the ones that
 match the device names specified by the \fBDevice\fR option are collected. By
 default only selected devices are collected if a selection is made. If no
 selection is configured at all, \fBall\fR devices are selected.
@@ -6588,69 +6781,73 @@
 .el .SS "Plugin \f(CWtokyotyrant\fP"
 .IX Subsection "Plugin tokyotyrant"
 The \fITokyoTyrant plugin\fR connects to a TokyoTyrant server and collects a
 couple metrics: number of records, and database size on disk.
 .IP "\fBHost\fR \fIHostname/IP\fR" 4
 .IX Item "Host Hostname/IP"
-The hostname or ip which identifies the server.
+The hostname or \s-1IP\s0 which identifies the server.
 Default: \fB127.0.0.1\fR
 .IP "\fBPort\fR \fIService/Port\fR" 4
 .IX Item "Port Service/Port"
 The query port of the server. This needs to be a string, even if the port is
 given in its numeric form.
 Default: \fB1978\fR
 .ie n .SS "Plugin ""turbostat"""
 .el .SS "Plugin \f(CWturbostat\fP"
 .IX Subsection "Plugin turbostat"
 The \fITurbostat plugin\fR reads \s-1CPU\s0 frequency and C\-state residency on modern
-Intel processors by using the new Model Specific Registers.
+Intel processors by using \fIModel Specific Registers\fR.
 .IP "\fBCoreCstates\fR \fIBitmask(Integer)\fR" 4
 .IX Item "CoreCstates Bitmask(Integer)"
-Bitmask of the list of core C states supported by the processor.
+Bit mask of the list of core C\-states supported by the processor.
 This option should only be used if the automated detection fails.
-Default value extracted from the cpu model and family.
+Default value extracted from the \s-1CPU\s0 model and family.
 .Sp
 Currently supported C\-states (by this plugin): 3, 6, 7
 .Sp
-Example: (1<<3)+(1<<6)+(1<<7) = 392 for all states
+\&\fBExample:\fR
+.Sp
+.Vb 2
+\&  All states (3, 6 and 7):
+\&  (1<<3) + (1<<6) + (1<<7) = 392
+.Ve
 .IP "\fBPackageCstates\fR \fIBitmask(Integer)\fR" 4
 .IX Item "PackageCstates Bitmask(Integer)"
-Bitmask of the list of pacages C states supported by the processor.
-This option should only be used if the automated detection fails.
-Default value extracted from the cpu model and family.
+Bit mask of the list of packages C\-states supported by the processor. This
+option should only be used if the automated detection fails. Default value
+extracted from the \s-1CPU\s0 model and family.
 .Sp
 Currently supported C\-states (by this plugin): 2, 3, 6, 7, 8, 9, 10
 .Sp
-Example: (1<<2)+(1<<3)+(1<<6)+(1<<7) = 396 for states 2, 3, 6 and 7
+\&\fBExample:\fR
+.Sp
+.Vb 2
+\&  States 2, 3, 6 and 7:
+\&  (1<<2) + (1<<3) + (1<<6) + (1<<7) = 396
+.Ve
 .IP "\fBSystemManagementInterrupt\fR \fItrue\fR|\fIfalse\fR" 4
 .IX Item "SystemManagementInterrupt true|false"
-Boolean enabling the collection of the I/O System-Management Interrupt
-counter'. This option should only be used if the automated detection
-fails or if you want to disable this feature.
+Boolean enabling the collection of the I/O System-Management Interrupt counter.
+This option should only be used if the automated detection fails or if you want
+to disable this feature.
 .IP "\fBDigitalTemperatureSensor\fR \fItrue\fR|\fIfalse\fR" 4
 .IX Item "DigitalTemperatureSensor true|false"
-Boolean enabling the collection of the temperature of each core.
-This option should only be used if the automated detectionfails or
-if you want to disable this feature.
-.IP "\fBDigitalTemperatureSensor\fR \fItrue\fR|\fIfalse\fR" 4
-.IX Item "DigitalTemperatureSensor true|false"
-Boolean enabling the collection of the temperature of each package.
-This option should only be used if the automated detectionfails or
-if you want to disable this feature.
+Boolean enabling the collection of the temperature of each core. This option
+should only be used if the automated detection fails or if you want to disable
+this feature.
 .IP "\fBTCCActivationTemp\fR \fITemperature\fR" 4
 .IX Item "TCCActivationTemp Temperature"
-Thermal Control Circuit Activation Temperature of the installed
-\&\s-1CPU.\s0 This temperature is used when collecting the temperature of
-cores or packages. This option should only be used if the automated
-detection fails. Default value extracted from \fB\s-1MSR_IA32_TEMPERATURE_TARGET\s0\fR
+\&\fIThermal Control Circuit Activation Temperature\fR of the installed \s-1CPU.\s0 This
+temperature is used when collecting the temperature of cores or packages. This
+option should only be used if the automated detection fails. Default value
+extracted from \fB\s-1MSR_IA32_TEMPERATURE_TARGET\s0\fR.
 .IP "\fBRunningAveragePowerLimit\fR \fIBitmask(Integer)\fR" 4
 .IX Item "RunningAveragePowerLimit Bitmask(Integer)"
-Bitmask of the list of elements to be thermally monitored. This option
-should only be used if the automated detection fails or if you want to
-disable some collections. The different bits of this bitmask accepted
-by this plugin are:
+Bit mask of the list of elements to be thermally monitored. This option should
+only be used if the automated detection fails or if you want to disable some
+collections. The different bits of this bit mask accepted by this plugin are:
 .RS 4
 .IP "0 ('1'): Package" 4
 .IX Item "0 ('1'): Package"
 .PD 0
 .IP "1 ('2'): \s-1DRAM\s0" 4
 .IX Item "1 ('2'): DRAM"
@@ -6658,13 +6855,20 @@
 .IX Item "2 ('4'): Cores"
 .IP "3 ('8'): Embedded graphic device" 4
 .IX Item "3 ('8'): Embedded graphic device"
 .RE
 .RS 4
 .RE
+.IP "\fBLogicalCoreNames\fR \fItrue\fR|\fIfalse\fR" 4
+.IX Item "LogicalCoreNames true|false"
 .PD
+Boolean enabling the use of logical core numbering for per core statistics.
+When enabled, \f(CW\*(C`cpu<n>\*(C'\fR is used as plugin instance, where \fIn\fR is a
+sequential number assigned by the kernel. Otherwise, \f(CW\*(C`core<n>\*(C'\fR is used
+where \fIn\fR is the n\-th core of the socket, causing name conflicts when there is
+more than one socket.
 .ie n .SS "Plugin ""unixsock"""
 .el .SS "Plugin \f(CWunixsock\fP"
 .IX Subsection "Plugin unixsock"
 .IP "\fBSocketFile\fR \fIPath\fR" 4
 .IX Item "SocketFile Path"
 Sets the socket-file which is to be created.
@@ -6892,12 +7096,55 @@
 \& BlockDevice "/:hdb/"
 \& IgnoreSelected "true"
 .Ve
 .Sp
 Ignore all \fIhdb\fR devices on any domain, but other block devices (eg. \fIhda\fR)
 will be collected.
+.IP "\fBBlockDeviceFormat\fR \fBtarget\fR|\fBsource\fR" 4
+.IX Item "BlockDeviceFormat target|source"
+If \fIBlockDeviceFormat\fR is set to \fBtarget\fR, the default, then the device name
+seen by the guest will be used for reporting metrics. 
+This corresponds to the \f(CW\*(C`<target>\*(C'\fR node in the \s-1XML\s0 definition of the
+domain.
+.Sp
+If \fIBlockDeviceFormat\fR is set to \fBsource\fR, then metrics will be reported
+using the path of the source, e.g. an image file.
+This corresponds to the \f(CW\*(C`<source>\*(C'\fR node in the \s-1XML\s0 definition of the
+domain.
+.Sp
+\&\fBExample:\fR
+.Sp
+If the domain \s-1XML\s0 have the following device defined:
+.Sp
+.Vb 7
+\&  <disk type=\*(Aqblock\*(Aq device=\*(Aqdisk\*(Aq>
+\&    <driver name=\*(Aqqemu\*(Aq type=\*(Aqraw\*(Aq cache=\*(Aqnone\*(Aq io=\*(Aqnative\*(Aq discard=\*(Aqunmap\*(Aq/>
+\&    <source dev=\*(Aq/var/lib/libvirt/images/image1.qcow2\*(Aq/>
+\&    <target dev=\*(Aqsda\*(Aq bus=\*(Aqscsi\*(Aq/>
+\&    <boot order=\*(Aq2\*(Aq/>
+\&    <address type=\*(Aqdrive\*(Aq controller=\*(Aq0\*(Aq bus=\*(Aq0\*(Aq target=\*(Aq0\*(Aq unit=\*(Aq0\*(Aq/>
+\&  </disk>
+.Ve
+.Sp
+Setting \f(CW\*(C`BlockDeviceFormat target\*(C'\fR will cause the \fItype instance\fR to be set
+to \f(CW\*(C`sda\*(C'\fR.
+Setting \f(CW\*(C`BlockDeviceFormat source\*(C'\fR will cause the \fItype instance\fR to be set
+to \f(CW\*(C`var_lib_libvirt_images_image1.qcow2\*(C'\fR.
+.IP "\fBBlockDeviceFormatBasename\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "BlockDeviceFormatBasename false|true"
+The \fBBlockDeviceFormatBasename\fR controls whether the full path or the
+\&\fIbasename\fR\|(1) of the source is being used as the \fItype instance\fR when
+\&\fBBlockDeviceFormat\fR is set to \fBsource\fR. Defaults to \fBfalse\fR.
+.Sp
+\&\fBExample:\fR
+.Sp
+Assume the device path (source tag) is \f(CW\*(C`/var/lib/libvirt/images/image1.qcow2\*(C'\fR.
+Setting \f(CW\*(C`BlockDeviceFormatBasename false\*(C'\fR will cause the \fItype instance\fR to
+be set to \f(CW\*(C`var_lib_libvirt_images_image1.qcow2\*(C'\fR.
+Setting \f(CW\*(C`BlockDeviceFormatBasename true\*(C'\fR will cause the \fItype instance\fR to be
+set to \f(CW\*(C`image1.qcow2\*(C'\fR.
 .IP "\fBHostnameFormat\fR \fBname|uuid|hostname|...\fR" 4
 .IX Item "HostnameFormat name|uuid|hostname|..."
 When the virt plugin logs data, it sets the hostname of the collected data
 according to this setting. The default is to use the guest name as provided by
 the hypervisor, which is equal to setting \fBname\fR.
 .Sp
@@ -7037,12 +7284,39 @@
 instance) are put into one component, for example \f(CW\*(C`host.cpu\-0.cpu\-idle\*(C'\fR.
 .IP "\fBAlwaysAppendDS\fR \fBfalse\fR|\fBtrue\fR" 4
 .IX Item "AlwaysAppendDS false|true"
 If set to \fBtrue\fR, append the name of the \fIData Source\fR (\s-1DS\s0) to the \*(L"metric\*(R"
 identifier. If set to \fBfalse\fR (the default), this is only done when there is
 more than one \s-1DS.\s0
+.IP "\fBPreserveSeparator\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "PreserveSeparator false|true"
+If set to \fBfalse\fR (the default) the \f(CW\*(C`.\*(C'\fR (dot) character is replaced with
+\&\fIEscapeCharacter\fR. Otherwise, if set to \fBtrue\fR, the \f(CW\*(C`.\*(C'\fR (dot) character
+is preserved, i.e. passed through.
+.IP "\fBDropDuplicateFields\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "DropDuplicateFields false|true"
+If set to \fBtrue\fR, detect and remove duplicate components in Graphite metric
+names. For example, the metric name  \f(CW\*(C`host.load.load.shortterm\*(C'\fR will
+be shortened to \f(CW\*(C`host.load.shortterm\*(C'\fR.
+.ie n .SS "Plugin ""write_log"""
+.el .SS "Plugin \f(CWwrite_log\fP"
+.IX Subsection "Plugin write_log"
+The \f(CW\*(C`write_log\*(C'\fR plugin writes metrics as \s-1INFO\s0 log messages.
+.PP
+This plugin supports two output formats: \fIGraphite\fR and \fI\s-1JSON\s0\fR.
+.PP
+Synopsis:
+.PP
+.Vb 3
+\& <Plugin write_log>
+\&   Format Graphite
+\& </Plugin>
+.Ve
+.IP "\fBFormat\fR \fIFormat\fR" 4
+.IX Item "Format Format"
+The output format to use. Can be one of \f(CW\*(C`Graphite\*(C'\fR or \f(CW\*(C`JSON\*(C'\fR.
 .ie n .SS "Plugin ""write_tsdb"""
 .el .SS "Plugin \f(CWwrite_tsdb\fP"
 .IX Subsection "Plugin write_tsdb"
 The \f(CW\*(C`write_tsdb\*(C'\fR plugin writes data to \fIOpenTSDB\fR, a scalable open-source
 time series database. The plugin connects to a \fI\s-1TSD\s0\fR, a masterless, no shared
 state daemon that ingests metrics and stores them in HBase. The plugin uses
@@ -7130,12 +7404,41 @@
 .IP "\fBPassword\fR \fIPassword\fR" 4
 .IX Item "Password Password"
 .PD
 Sets the information used when authenticating to a \fIMongoDB\fR database. The
 fields are optional (in which case no authentication is attempted), but if you
 want to use authentication all three fields must be set.
+.ie n .SS "Plugin ""write_prometheus"""
+.el .SS "Plugin \f(CWwrite_prometheus\fP"
+.IX Subsection "Plugin write_prometheus"
+The \fIwrite_prometheus plugin\fR implements a tiny webserver that can be scraped
+using \fIPrometheus\fR.
+.PP
+\&\fBOptions:\fR
+.IP "\fBPort\fR \fIPort\fR" 4
+.IX Item "Port Port"
+Port the embedded webserver should listen on. Defaults to \fB9103\fR.
+.IP "\fBStalenessDelta\fR \fISeconds\fR" 4
+.IX Item "StalenessDelta Seconds"
+Time in seconds after which \fIPrometheus\fR considers a metric \*(L"stale\*(R" if it
+hasn't seen any update for it. This value must match the setting in Prometheus.
+It defaults to \fB300\fR seconds (5 minutes), same as Prometheus.
+.Sp
+\&\fBBackground:\fR
+.Sp
+\&\fIPrometheus\fR has a global setting, \f(CW\*(C`StalenessDelta\*(C'\fR, which controls after
+which time a metric without updates is considered \*(L"stale\*(R". This setting
+effectively puts an upper limit on the interval in which metrics are reported.
+.Sp
+When the \fIwrite_prometheus plugin\fR encounters a metric with an interval
+exceeding this limit, it will inform you, the user, and provide the metric to
+\&\fIPrometheus\fR \fBwithout\fR a timestamp. That causes \fIPrometheus\fR to consider the
+metric \*(L"fresh\*(R" each time it is scraped, with the time of the scrape being
+considered the time of the update. The result is that there appear more
+datapoints in \fIPrometheus\fR than were actually created, but at least the metric
+doesn't disappear periodically.
 .ie n .SS "Plugin ""write_http"""
 .el .SS "Plugin \f(CWwrite_http\fP"
 .IX Subsection "Plugin write_http"
 This output plugin submits values to an \s-1HTTP\s0 server using \s-1POST\s0 requests and
 encoding metrics with \s-1JSON\s0 or using the \f(CW\*(C`PUTVAL\*(C'\fR command described in
 \&\fIcollectd\-unixsock\fR\|(5).
@@ -7333,12 +7636,22 @@
 .IP "\fBGraphiteSeparateInstances\fR \fBfalse\fR|\fBtrue\fR" 4
 .IX Item "GraphiteSeparateInstances false|true"
 If set to \fBtrue\fR, the plugin instance and type instance will be in their own
 path component, for example \f(CW\*(C`host.cpu.0.cpu.idle\*(C'\fR. If set to \fBfalse\fR (the
 default), the plugin and plugin instance (and likewise the type and type
 instance) are put into one component, for example \f(CW\*(C`host.cpu\-0.cpu\-idle\*(C'\fR.
+.IP "\fBGraphiteAlwaysAppendDS\fR \fBtrue\fR|\fBfalse\fR" 4
+.IX Item "GraphiteAlwaysAppendDS true|false"
+If set to \fBtrue\fR, append the name of the \fIData Source\fR (\s-1DS\s0) to the \*(L"metric\*(R"
+identifier. If set to \fBfalse\fR (the default), this is only done when there is
+more than one \s-1DS.\s0
+.IP "\fBGraphitePreserveSeparator\fR \fBfalse\fR|\fBtrue\fR" 4
+.IX Item "GraphitePreserveSeparator false|true"
+If set to \fBfalse\fR (the default) the \f(CW\*(C`.\*(C'\fR (dot) character is replaced with
+\&\fIGraphiteEscapeChar\fR. Otherwise, if set to \fBtrue\fR, the \f(CW\*(C`.\*(C'\fR (dot) character
+is preserved, i.e. passed through.
 .IP "\fBStoreRates\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "StoreRates true|false"
 If set to \fBtrue\fR (the default), convert counter values to rates. If set to
 \&\fBfalse\fR counter values are stored as is, i.e. as an increasing integer number.
 .Sp
 This will be reflected in the \f(CW\*(C`ds_type\*(C'\fR tag: If \fBStoreRates\fR is enabled,
@@ -8191,12 +8504,14 @@
 .IP "\fBPluginInstance\fR \fIRegex\fR" 4
 .IX Item "PluginInstance Regex"
 .IP "\fBType\fR \fIRegex\fR" 4
 .IX Item "Type Regex"
 .IP "\fBTypeInstance\fR \fIRegex\fR" 4
 .IX Item "TypeInstance Regex"
+.IP "\fBMetaData\fR \fIString\fR \fIRegex\fR" 4
+.IX Item "MetaData String Regex"
 .PD
 Match values where the given regular expressions match the various fields of
 the identifier of a value. If multiple regular expressions are given, \fBall\fR
 regexen must match for a value to match.
 .IP "\fBInvert\fR \fBfalse\fR|\fBtrue\fR" 4
 .IX Item "Invert false|true"
@@ -8476,12 +8791,16 @@
 .IP "\fBPlugin\fR \fIRegex\fR \fIReplacement\fR" 4
 .IX Item "Plugin Regex Replacement"
 .IP "\fBPluginInstance\fR \fIRegex\fR \fIReplacement\fR" 4
 .IX Item "PluginInstance Regex Replacement"
 .IP "\fBTypeInstance\fR \fIRegex\fR \fIReplacement\fR" 4
 .IX Item "TypeInstance Regex Replacement"
+.IP "\fBMetaData\fR \fIString\fR \fIRegex\fR \fIReplacement\fR" 4
+.IX Item "MetaData String Regex Replacement"
+.IP "\fBDeleteMetaData\fR \fIString\fR \fIRegex\fR" 4
+.IX Item "DeleteMetaData String Regex"
 .PD
 Match the appropriate field with the given regular expression \fIRegex\fR. If the
 regular expression matches, that part that matches is replaced with
 \&\fIReplacement\fR. If multiple places of the input buffer match a given regular
 expression, only the first occurrence will be replaced.
 .Sp
@@ -8517,15 +8836,42 @@
 .IX Item "PluginInstance String"
 .IP "\fBTypeInstance\fR \fIString\fR" 4
 .IX Item "TypeInstance String"
 .IP "\fBMetaData\fR \fIString\fR \fIString\fR" 4
 .IX Item "MetaData String String"
 .PD
-Set the appropriate field to the given string. The strings for plugin instance
-and type instance may be empty, the strings for host and plugin may not be
-empty. It's currently not possible to set the type of a value this way.
+Set the appropriate field to the given string. The strings for plugin instance,
+type instance, and meta data may be empty, the strings for host and plugin may
+not be empty. It's currently not possible to set the type of a value this way.
+.Sp
+The following placeholders will be replaced by an appropriate value:
+.RS 4
+.IP "\fB%{host}\fR" 4
+.IX Item "%{host}"
+.PD 0
+.IP "\fB%{plugin}\fR" 4
+.IX Item "%{plugin}"
+.IP "\fB%{plugin_instance}\fR" 4
+.IX Item "%{plugin_instance}"
+.IP "\fB%{type}\fR" 4
+.IX Item "%{type}"
+.IP "\fB%{type_instance}\fR" 4
+.IX Item "%{type_instance}"
+.PD
+These placeholders are replaced by the identifier field of the same name.
+.IP "\fB%{meta:\fR\fIname\fR\fB}\fR" 4
+.IX Item "%{meta:name}"
+These placeholders are replaced by the meta data value with the given name.
+.RE
+.RS 4
+.Sp
+Please note that these placeholders are \fBcase sensitive\fR!
+.RE
+.IP "\fBDeleteMetaData\fR \fIString\fR" 4
+.IX Item "DeleteMetaData String"
+Delete the named meta data field.
 .RE
 .RS 4
 .Sp
 Example:
 .Sp
 .Vb 4
@@ -8563,53 +8909,12 @@
 \&     </Match>
 \&     Target "stop"
 \&   </Rule>
 \&   Target "write"
 \& </Chain>
 .Ve
-.SH "IGNORELISTS"
-.IX Header "IGNORELISTS"
-\&\fBIgnorelists\fR are a generic framework to either ignore some metrics or report
-specific metircs only. Plugins usually provide one or more options to specify
-the items (mounts points, devices, ...) and the boolean option
-\&\f(CW\*(C`IgnoreSelected\*(C'\fR.
-.IP "\fBSelect\fR \fIString\fR" 4
-.IX Item "Select String"
-Selects the item \fIString\fR. This option often has a plugin specific name, e.g.
-\&\fBSensor\fR in the \f(CW\*(C`sensors\*(C'\fR plugin. It is also plugin specific what this string
-is compared to. For example, the \f(CW\*(C`df\*(C'\fR plugin's \fBMountPoint\fR compares it to a
-mount point and the \f(CW\*(C`sensors\*(C'\fR plugin's \fBSensor\fR compares it to a sensor name.
-.Sp
-By default, this option is doing a case-sensitive full-string match. The
-following config will match \f(CW\*(C`foo\*(C'\fR, but not \f(CW\*(C`Foo\*(C'\fR:
-.Sp
-.Vb 1
-\&  Select "foo"
-.Ve
-.Sp
-If \fIString\fR starts and ends with \f(CW\*(C`/\*(C'\fR (a slash), the string is compiled as a
-\&\fIregular expression\fR. For example, so match all item starting with \f(CW\*(C`foo\*(C'\fR, use
-could use the following syntax:
-.Sp
-.Vb 1
-\&  Select "/^foo/"
-.Ve
-.Sp
-The regular expression is \fInot\fR anchored, i.e. the following config will match
-\&\f(CW\*(C`foobar\*(C'\fR, \f(CW\*(C`barfoo\*(C'\fR and \f(CW\*(C`AfooZ\*(C'\fR:
-.Sp
-.Vb 1
-\&  Select "/foo/"
-.Ve
-.Sp
-The \fBSelect\fR option may be repeated to select multiple items.
-.IP "\fBIgnoreSelected\fR \fBtrue\fR|\fBfalse\fR" 4
-.IX Item "IgnoreSelected true|false"
-If set to \fBtrue\fR, matching metrics are \fIignored\fR and all other metrics are
-collected. If set to \fBfalse\fR, matching metrics are \fIcollected\fR and all other
-metrics are ignored.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
 \&\fIcollectd\fR\|(1),
 \&\fIcollectd\-exec\fR\|(5),
 \&\fIcollectd\-perl\fR\|(5),
 \&\fIcollectd\-unixsock\fR\|(5),
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd.conf.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd.conf.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd.conf.in	2017-10-06 14:45:52.937917751 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd.conf.in	2016-12-12 16:03:36.700279172 +0800
@@ -111,24 +111,27 @@
 #@BUILD_PLUGIN_CURL_JSON_TRUE@LoadPlugin curl_json
 #@BUILD_PLUGIN_CURL_XML_TRUE@LoadPlugin curl_xml
 #@BUILD_PLUGIN_DBI_TRUE@LoadPlugin dbi
 #@BUILD_PLUGIN_DF_TRUE@LoadPlugin df
 #@BUILD_PLUGIN_DISK_TRUE@LoadPlugin disk
 #@BUILD_PLUGIN_DNS_TRUE@LoadPlugin dns
+#@BUILD_PLUGIN_DPDKSTAT_TRUE@LoadPlugin dpdkstat
 #@BUILD_PLUGIN_DRBD_TRUE@LoadPlugin drbd
 #@BUILD_PLUGIN_EMAIL_TRUE@LoadPlugin email
 #@BUILD_PLUGIN_ENTROPY_TRUE@LoadPlugin entropy
 #@BUILD_PLUGIN_ETHSTAT_TRUE@LoadPlugin ethstat
 #@BUILD_PLUGIN_EXEC_TRUE@LoadPlugin exec
 #@BUILD_PLUGIN_FHCOUNT_TRUE@LoadPlugin fhcount
 #@BUILD_PLUGIN_FILECOUNT_TRUE@LoadPlugin filecount
 #@BUILD_PLUGIN_FSCACHE_TRUE@LoadPlugin fscache
 #@BUILD_PLUGIN_GMOND_TRUE@LoadPlugin gmond
 #@BUILD_PLUGIN_GPS_TRUE@LoadPlugin gps
 #@BUILD_PLUGIN_GRPC_TRUE@LoadPlugin grpc
 #@BUILD_PLUGIN_HDDTEMP_TRUE@LoadPlugin hddtemp
+#@BUILD_PLUGIN_HUGEPAGES_TRUE@LoadPlugin hugepages
+#@BUILD_PLUGIN_INTEL_RDT_TRUE@LoadPlugin intel_rdt
 @BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_PLUGIN_INTERFACE_TRUE@LoadPlugin interface
 #@BUILD_PLUGIN_IPC_TRUE@LoadPlugin ipc
 #@BUILD_PLUGIN_IPMI_TRUE@LoadPlugin ipmi
 #@BUILD_PLUGIN_IPTABLES_TRUE@LoadPlugin iptables
 #@BUILD_PLUGIN_IPVS_TRUE@LoadPlugin ipvs
 #@BUILD_PLUGIN_IRQ_TRUE@LoadPlugin irq
@@ -204,12 +207,13 @@
 #@BUILD_PLUGIN_WIRELESS_TRUE@LoadPlugin wireless
 #@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@LoadPlugin write_graphite
 #@BUILD_PLUGIN_WRITE_HTTP_TRUE@LoadPlugin write_http
 #@BUILD_PLUGIN_WRITE_KAFKA_TRUE@LoadPlugin write_kafka
 #@BUILD_PLUGIN_WRITE_LOG_TRUE@LoadPlugin write_log
 #@BUILD_PLUGIN_WRITE_MONGODB_TRUE@LoadPlugin write_mongodb
+#@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@LoadPlugin write_prometheus
 #@BUILD_PLUGIN_WRITE_REDIS_TRUE@LoadPlugin write_redis
 #@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@LoadPlugin write_riemann
 #@BUILD_PLUGIN_WRITE_SENSU_TRUE@LoadPlugin write_sensu
 #@BUILD_PLUGIN_WRITE_TSDB_TRUE@LoadPlugin write_tsdb
 #@BUILD_PLUGIN_XENCPU_TRUE@LoadPlugin xencpu
 #@BUILD_PLUGIN_XMMS_TRUE@LoadPlugin xmms
@@ -296,12 +300,13 @@
 #   TemperatureSensor "myserver/onewire-F10FCA000800/temperature"
 #</Plugin>
 
 #<Plugin "battery">
 #  ValuesPercentage false
 #  ReportDegraded false
+#  QueryStateFS false
 #</Plugin>
 
 #<Plugin "bind">
 #  URL "http://localhost:8053/"
 #  ParseTime       false
 #  OpCodes         true
@@ -515,12 +520,22 @@
 #<Plugin dns>
 #	Interface "eth0"
 #	IgnoreSource "192.168.0.1"
 #	SelectNumericQueryTypes true
 #</Plugin>
 
+#<Plugin dpdkstat>
+#       Interval 1
+#       Coremask "0xf"
+#       ProcessType "secondary"
+#       FilePrefix "rte"
+#       EnabledPortMask 0xffff
+#       PortName "interface1"
+#       PortName "interface2"
+#</Plugin>
+
 #<Plugin email>
 #	SocketFile "@localstatedir@/run/@PACKAGE_NAME@-email"
 #	SocketGroup "collectd"
 #	SocketPerms "0770"
 #	MaxConns 5
 #</Plugin>
@@ -591,12 +606,24 @@
 
 #<Plugin hddtemp>
 #  Host "127.0.0.1"
 #  Port "7634"
 #</Plugin>
 
+#<Plugin hugepages>
+#    ReportPerNodeHP  true
+#    ReportRootHP     true
+#    ValuesPages      true
+#    ValuesBytes      false
+#    ValuesPercentage false
+#</Plugin>
+
+#<Plugin "intel_rdt">
+#  Cores "0-2"
+#</Plugin>
+
 #<Plugin interface>
 #	Interface "eth0"
 #	IgnoreSelected false
 #	ReportInactive true
 #	UniqueName false
 #</Plugin>
@@ -681,13 +708,14 @@
 #		</Match>
 #	</Page>
 #</Plugin>
 
 #<Plugin memcached>
 #	<Instance "local">
-#		Host "127.0.0.1"
+#		#Host "memcache.example.com"
+#		Address "127.0.0.1"
 #		Port "11211"
 #	</Instance>
 #</Plugin>
 
 #<Plugin memory>
 #	ValuesAbsolute true
@@ -1241,12 +1269,33 @@
 #      ExcludeRegex "\\<R=local_user\\>.*mail_spool defer"
 #      DSType "CounterInc"
 #      Type "counter"
 #      Instance "local_user"
 #    </Match>
 #  </File>
+#  <File "/var/log/nginx/apache-time.log">
+#    #Use the following log format in nginx:
+#    #log_format response_time '[$host] "$upstream_response_time" ...'
+#    Instance "apache"
+#    <Match>
+#      Regex "^\\S+ \"([0-9.]+)\""
+#      <DSType Distribution>
+#        Percentile 80    # -> latency-foo-80
+#        Percentile 95    # -> latency-foo-95
+#        Percentile 99    # -> latency-foo-99
+#        Bucket 0   0.1   # -> bucket-latency-foo-0_0.1
+#        Bucket 0.1 0.2   # -> bucket-latency-foo-0.1_0.2
+#        Bucket 0.2 0.5   # -> bucket-latency-foo-0.2_0.5
+#        Bucket 0.5 1.0   # -> bucket-latency-foo-0.5_1
+#        Bucket 1.0 2.0   # -> bucket-latency-foo-1_2
+#        Bucket 2.0 0     # -> bucket-latency-foo-2_inf
+#      </DSType>
+#      Type "latency"
+#      Instance "foo"
+#    </Match>
+#  </File>
 #</Plugin>
 
 #<Plugin tail_csv>
 #   <Metric "dropped">
 #       Type "percent"
 #       Instance "dropped"
@@ -1382,12 +1431,14 @@
 
 #<Plugin virt>
 #	Connection "xen:///"
 #	RefreshInterval 60
 #	Domain "name"
 #	BlockDevice "name:device"
+#	BlockDeviceFormat target
+#	BlockDeviceFormatBasename false
 #	InterfaceDevice "name:device"
 #	IgnoreSelected false
 #	HostnameFormat name
 #	InterfaceFormat name
 #	PluginInstanceFormat name
 #</Plugin>
@@ -1406,12 +1457,14 @@
 #    Prefix "collectd"
 #    Postfix "collectd"
 #    StoreRates true
 #    AlwaysAppendDS false
 #    EscapeCharacter "_"
 #    SeparateInstances false
+#    PreserveSeparator false
+#    DropDuplicateFields false
 #  </Node>
 #</Plugin>
 
 #<Plugin write_http>
 #	<Node "example">
 #		URL "http://example.com/collectd-post"
@@ -1452,12 +1505,16 @@
 #		Database "auth_db"
 #		User "auth_user"
 #		Password "auth_passwd"
 #	</Node>
 #</Plugin>
 
+#<Plugin write_prometheus>
+#	Port "9103"
+#</Plugin>
+
 #<Plugin write_redis>
 #	<Node "example">
 #		Host "localhost"
 #		Port "6379"
 #		Timeout 1000
 #		Prefix "collectd/"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd.conf.pod /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd.conf.pod
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd.conf.pod	2017-10-06 14:45:52.937917751 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd.conf.pod	2016-12-12 16:03:36.704279144 +0800
@@ -335,13 +335,13 @@
 
 =item B<PreCacheChain> I<ChainName>
 
 =item B<PostCacheChain> I<ChainName>
 
 Configure the name of the "pre-cache chain" and the "post-cache chain". Please
-see L</"FILTER CONFIGURATION"> below on information on chains and how these
+see L<FILTER CONFIGURATION> below on information on chains and how these
 setting change the daemon's behavior.
 
 =back
 
 =head1 PLUGIN OPTIONS
 
@@ -552,12 +552,13 @@
  #   Format "command"
  #   StoreRates false
  #   GraphitePrefix "collectd."
  #   GraphiteEscapeChar "_"
  #   GraphiteSeparateInstances false
  #   GraphiteAlwaysAppendDS false
+ #   GraphitePreserveSeparator false
    </Publish>
 
    # Receive values from an AMQP broker
    <Subscribe "some_name">
      Host "localhost"
      Port "5672"
@@ -726,12 +727,18 @@
 =item B<GraphiteAlwaysAppendDS> B<true>|B<false>
 
 If set to B<true>, append the name of the I<Data Source> (DS) to the "metric"
 identifier. If set to B<false> (the default), this is only done when there is
 more than one DS.
 
+=item B<GraphitePreserveSeparator> B<false>|B<true>
+
+If set to B<false> (the default) the C<.> (dot) character is replaced with
+I<GraphiteEscapeChar>. Otherwise, if set to B<true>, the C<.> (dot) character
+is preserved, i.e. passed through.
+
 =back
 
 =head2 Plugin C<apache>
 
 To configure the C<apache>-plugin you first need to configure the Apache
 webserver correctly. The Apache-plugin C<mod_status> needs to be loaded and
@@ -1111,12 +1118,19 @@
 
 When set to B<true>, the battery plugin will report three values: B<charged>
 (remaining capacity), B<discharged> (difference between "last full capacity"
 and "remaining capacity") and B<degraded> (difference between "design capacity"
 and "last full capacity").
 
+=item B<QueryStateFS> B<false>|B<true>
+
+When set to B<true>, the battery plugin will only read statistics
+related to battery performance as exposed by StateFS at
+/run/state. StateFS is used in Mer-based Sailfish OS, for
+example.
+
 =back
 
 =head2 Plugin C<bind>
 
 Starting with BIND 9.5.0, the most widely used DNS server software provides
 extensive statistics about queries, responses and lots of other information.
@@ -1355,14 +1369,12 @@
 =item B<CGroup> I<Directory>
 
 Select I<cgroup> based on the name. Whether only matching I<cgroups> are
 collected or if they are ignored is controlled by the B<IgnoreSelected> option;
 see below.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> B<true>|B<false>
 
 Invert the selection: If set to true, all cgroups I<except> the ones that
 match any one of the criteria are collected. By default only selected
 cgroups are collected if a selection is made. If no selection is configured
 at all, B<all> cgroups are selected.
@@ -2253,26 +2265,20 @@
 =over 4
 
 =item B<Device> I<Device>
 
 Select partitions based on the devicename.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<MountPoint> I<Directory>
 
 Select partitions based on the mountpoint.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<FSType> I<FSType>
 
 Select partitions based on the filesystem type.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> B<true>|B<false>
 
 Invert the selection: If set to true, all partitions B<except> the ones that
 match any one of the criteria are collected. By default only selected
 partitions are collected if a selection is made. If no selection is configured
 at all, B<all> partitions are selected.
@@ -2328,14 +2334,12 @@
 daemon's ignorelist functionality, a string that starts and ends with a slash
 is interpreted as a regular expression. Examples:
 
   Disk "sdd"
   Disk "/hda[34]/"
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> B<true>|B<false>
 
 Sets whether selected disks, i.E<nbsp>e. the ones matches by any of the B<Disk>
 statements, are ignored or if all other disks are ignored. The behavior
 (hopefully) is intuitive: If no B<Disk> option is configured, all disks are
 collected. If at least one B<Disk> option is given and no B<IgnoreSelected> or
@@ -2376,12 +2380,73 @@
 =item B<SelectNumericQueryTypes> B<true>|B<false>
 
 Enabled by default, collects unknown (and thus presented as numeric only) query types.
 
 =back
 
+=head2 Plugin C<dpdkstat>
+
+The I<dpdkstat plugin> collects information about DPDK interfaces using the
+extended NIC stats API in DPDK.
+
+B<Synopsis:>
+
+ <Plugin "dpdkstat">
+    Coremask "0x4"
+    MemoryChannels "4"
+    ProcessType "secondary"
+    FilePrefix "rte"
+    EnabledPortMask 0xffff
+    PortName "interface1"
+    PortName "interface2"
+ </Plugin>
+
+B<Options:>
+
+=over 4
+
+=item B<Coremask> I<Mask>
+
+A string containing an hexadecimal bit mask of the cores to run on. Note that
+core numbering can change between platforms and should be determined beforehand.
+
+=item B<Memorychannels> I<Channels>
+
+A string containing a number of memory channels per processor socket.
+
+=item B<ProcessType> I<type>
+
+A string containing the type of DPDK process instance.
+
+=item B<FilePrefix> I<File>
+
+The prefix text used for hugepage filenames. The filename will be set to
+/var/run/.<prefix>_config where prefix is what is passed in by the user.
+
+=item B<SocketMemory> I<MB>
+
+A string containing amount of Memory to allocate from hugepages on specific
+sockets in MB
+
+=item B<EnabledPortMask> I<Mask>
+
+A hexidecimal bit mask of the DPDK ports which should be enabled. A mask
+of 0x0 means that all ports will be disabled. A bitmask of all Fs means
+that all ports will be enabled. This is an optional argument - default
+is all ports enabled.
+
+=item B<PortName> I<Name>
+
+A string containing an optional name for the enabled DPDK ports. Each PortName
+option should contain only one port name; specify as many PortName options as
+desired. Default naming convention will be used if PortName is blank. If there
+are less PortName options than there are enabled ports, the default naming
+convention will be used for the additional ports.
+
+=back
+
 =head2 Plugin C<email>
 
 =over 4
 
 =item B<SocketFile> I<Path>
 
@@ -2826,23 +2891,116 @@
 =item B<Port> I<Port>
 
 TCP-Port to connect to. Defaults to B<7634>.
 
 =back
 
+=head2 Plugin C<hugepages>
+
+To collect B<hugepages> information, collectd reads directories
+"/sys/devices/system/node/*/hugepages" and
+"/sys/kernel/mm/hugepages".
+Reading of these directories can be disabled by the following
+options (default is enabled).
+
+=over 4
+
+=item B<ReportPerNodeHP> B<true>|B<false>
+
+If enabled, information will be collected from the hugepage
+counters in "/sys/devices/system/node/*/hugepages".
+This is used to check the per-node hugepage statistics on
+a NUMA system.
+
+=item B<ReportRootHP> B<true>|B<false>
+
+If enabled, information will be collected from the hugepage
+counters in "/sys/kernel/mm/hugepages".
+This can be used on both NUMA and non-NUMA systems to check
+the overall hugepage statistics.
+
+=item B<ValuesPages> B<true>|B<false>
+
+Whether to report hugepages metrics in number of pages.
+Defaults to B<true>.
+
+=item B<ValuesBytes> B<false>|B<true>
+
+Whether to report hugepages metrics in bytes.
+Defaults to B<false>.
+
+=item B<ValuesPercentage> B<false>|B<true>
+
+Whether to report hugepages metrics as percentage.
+Defaults to B<false>.
+
+=back
+
+=head2 Plugin C<intel_rdt>
+
+The I<intel_rdt> plugin collects information provided by monitoring features of
+Intel Resource Director Technology (Intel(R) RDT) like Cache Monitoring
+Technology (CMT), Memory Bandwidth Monitoring (MBM). These features provide
+information about utilization of shared resources. CMT monitors last level cache
+occupancy (LLC). MBM supports two types of events reporting local and remote
+memory bandwidth. Local memory bandwidth (MBL) reports the bandwidth of
+accessing memory associated with the local socket. Remote memory bandwidth (MBR)
+reports the bandwidth of accessing the remote socket. Also this technology
+allows to monitor instructions per clock (IPC).
+Monitor events are hardware dependant. Monitoring capabilities are detected on
+plugin initialization and only supported events are monitored.
+
+B<Synopsis:>
+
+  <Plugin "intel_rdt">
+    Cores "0-2" "3,4,6" "8-10,15"
+  </Plugin>
+
+B<Options:>
+
+=over 4
+
+=item B<Interval> I<seconds>
+
+The interval within which to retrieve statistics on monitored events in seconds.
+For milliseconds divide the time by 1000 for example if the desired interval
+is 50ms, set interval to 0.05. Due to limited capacity of counters it is not
+recommended to set interval higher than 1 sec.
+
+=item B<Cores> I<cores groups>
+
+All events are reported on a per core basis. Monitoring of the events can be
+configured for group of cores (aggregated statistics). This field defines groups
+of cores on which to monitor supported events. The field is represented as list
+of strings with core group values. Each string represents a list of cores in a
+group. Allowed formats are:
+    0,1,2,3
+    0-10,20-18
+    1,3,5-8,10,0x10-12
+
+If an empty string is provided as value for this field default cores
+configuration is applied - a separate group is created for each core.
+
+=back
+
+B<Note:> By default global interval is used to retrieve statistics on monitored
+events. To configure a plugin specific interval use B<Interval> option of the
+intel_rdt <LoadPlugin> block. For milliseconds divide the time by 1000 for
+example if the desired interval is 50ms, set interval to 0.05.
+Due to limited capacity of counters it is not recommended to set interval higher
+than 1 sec.
+
 =head2 Plugin C<interface>
 
 =over 4
 
 =item B<Interface> I<Interface>
 
 Select this interface. By default these interfaces will then be collected. For
 a more detailed description see B<IgnoreSelected> below.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> I<true>|I<false>
 
 If no configuration if given, the B<interface>-plugin will collect data from
 all interfaces. This may not be practical, especially for loopback- and
 similar interfaces. Thus, you can use the B<Interface>-option to pick the
 interfaces you're interested in. Sometimes, however, it's easier/preferred
@@ -2898,14 +3056,12 @@
 =over 4
 
 =item B<Sensor> I<Sensor>
 
 Selects sensors to collect or to ignore, depending on B<IgnoreSelected>.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> I<true>|I<false>
 
 If no configuration if given, the B<ipmi> plugin will collect data from all
 sensors found of type "temperature", "voltage", "current" and "fanspeed".
 This option enables you to do that: By setting B<IgnoreSelected> to I<true>
 the effect of B<Sensor> is inverted: All selected sensors are ignored and
@@ -2956,14 +3112,12 @@
 
 =item B<Irq> I<Irq>
 
 Select this irq. By default these irqs will then be collected. For a more
 detailed description see B<IgnoreSelected> below.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> I<true>|I<false>
 
 If no configuration if given, the B<irq>-plugin will collect data from all
 irqs. This may not be practical, especially if no interrupts happen. Thus, you
 can use the B<Irq>-option to pick the interrupt you're interested in.
 Sometimes, however, it's easier/preferred to collect all interrupts I<except> a
@@ -3181,14 +3335,12 @@
 =item B<Device> I<Device>
 
 Select md devices based on device name. The I<device name> is the basename of
 the device, i.e. the name of the block device without the leading C</dev/>.
 See B<IgnoreSelected> for more details.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> B<true>|B<false>
 
 Invert device selection: If set to B<true>, all md devices B<except> those
 listed using B<Device> are collected. If B<false> (the default), only those
 listed are collected. If no configuration is given, the B<md> plugin will
 collect data from all md devices.
@@ -3247,39 +3399,49 @@
 =back
 
 =head2 Plugin C<memcached>
 
 The B<memcached plugin> connects to a memcached server and queries statistics
 about cache utilization, memory and bandwidth used.
-L<http://www.danga.com/memcached/>
+L<http://memcached.org/>
 
  <Plugin "memcached">
    <Instance "name">
-     Host "memcache.example.com"
+     #Host "memcache.example.com"
+     Address "127.0.0.1"
      Port 11211
    </Instance>
  </Plugin>
 
 The plugin configuration consists of one or more B<Instance> blocks which
 specify one I<memcached> connection each. Within the B<Instance> blocks, the
 following options are allowed:
 
 =over 4
 
 =item B<Host> I<Hostname>
 
-Hostname to connect to. Defaults to B<127.0.0.1>.
+Sets the B<host> field of dispatched values. Defaults to the global hostname
+setting.
+For backwards compatibility, values are also dispatched with the global
+hostname when B<Host> is set to B<127.0.0.1> or B<localhost> and B<Address> is
+not set.
+
+=item B<Address> I<Address>
+
+Hostname or IP to connect to. For backwards compatibility, defaults to the
+value of B<Host> or B<127.0.0.1> if B<Host> is unset.
 
 =item B<Port> I<Port>
 
-TCP-Port to connect to. Defaults to B<11211>.
+TCP port to connect to. Defaults to B<11211>.
 
 =item B<Socket> I<Path>
 
 Connect to I<memcached> using the UNIX domain socket at I<Path>. If this
-setting is given, the B<Host> and B<Port> settings are ignored.
+setting is given, the B<Address> and B<Port> settings are ignored.
 
 =back
 
 =head2 Plugin C<mic>
 
 The B<mic plugin> gathers CPU statistics, memory usage and temperatures from
@@ -4336,14 +4498,12 @@
 If no regular expression is specified, an exact match is required. Both,
 regular and exact matching are case sensitive.
 
 If no volume was specified at all for either of the three options, that data
 will be collected for all available volumes.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelectedIO> B<true>|B<false>
 
 =item B<IgnoreSelectedOps> B<true>|B<false>
 
 =item B<IgnoreSelectedLatency> B<true>|B<false>
 
@@ -4523,14 +4683,12 @@
     QDisc "eth0" "pfifo_fast-1:0"
     QDisc "ppp0"
     Class "ppp0" "htb-1:10"
     Filter "ppp0" "u32-1:0"
   </Plugin>
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected>
 
 The behavior is the same as with all other similar plugins: If nothing is
 selected at all, everything is collected. If some things are selected using the
 options described above, only these statistics are collected. If you set
 B<IgnoreSelected> to B<true>, this behavior is inverted, i.E<nbsp>e. the
@@ -5047,14 +5205,12 @@
 C</uncached/10.F10FCA000800/temperature> (or when cached values are OK
 C</10.F10FCA000800/temperature>). B<IgnoreSelected> is not used.
 
 As there can be multiple devices on the bus you can list multiple sensor (use
 multiple B<Sensor> elements).
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> I<true>|I<false>
 
 If no configuration is given, the B<onewire> plugin will collect data from all
 sensors found. This may not be practical, especially if sensors are added and
 removed regularly. Sometimes, however, it's easier/preferred to collect only
 specific sensors or all sensors I<except> a few specified ones. This option
@@ -5373,16 +5529,16 @@
 Host to ping periodically. This option may be repeated several times to ping
 multiple hosts.
 
 =item B<Interval> I<Seconds>
 
 Sets the interval in which to send ICMP echo packets to the configured hosts.
-This is B<not> the interval in which metrics are read from the plugin but the
-interval in which the hosts are "pinged". Therefore, the setting here should be
-smaller than or equal to the global B<Interval> setting. Fractional times, such
-as "1.24" are allowed.
+This is B<not> the interval in which statistics are queries from the plugin but
+the interval in which the hosts are "pinged". Therefore, the setting here
+should be smaller than or equal to the global B<Interval> setting. Fractional
+times, such as "1.24" are allowed.
 
 Default: B<1.0>
 
 =item B<Timeout> I<Seconds>
 
 Time to wait for a response from the host to which an ICMP packet had been
@@ -5720,13 +5876,13 @@
 values are made available through those parameters:
 
 =over 4
 
 =item B<$1>
 
-The timestamp of the queried value as a floating point number.
+The timestamp of the queried value as an RFC 3339-formatted local time.
 
 =item B<$2>
 
 The hostname of the queried value.
 
 =item B<$3>
@@ -6108,14 +6264,12 @@
   Value "/^TcpExt:/"
 
 Whether only matched values are selected or all matched values are ignored
 depends on the B<IgnoreSelected>. By default, only matched values are selected.
 If no value is configured at all, all values will be selected.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> B<true>|B<false>
 
 If set to B<true>, inverts the selection made by B<Value>, i.E<nbsp>e. all
 matching values will be ignored.
 
 =back
@@ -6463,26 +6617,20 @@
 one (exclusive).
 
 =item B<CacheFlush> I<Seconds>
 
 When the C<rrdtool> plugin uses a cache (by setting B<CacheTimeout>, see below)
 it writes all values for a certain RRD-file if the oldest value is older than
-(or equal to) the number of seconds specified by B<CacheTimeout>.
-That check happens on new values arriwal. If some RRD-file is not updated
+(or equal to) the number of seconds specified. If some RRD-file is not updated
 anymore for some reason (the computer was shut down, the network is broken,
-etc.) some values may still be in the cache. If B<CacheFlush> is set, then
-every I<Seconds> seconds the entire cache is searched for entries older than
-B<CacheTimeout> + B<RandomTimeout> seconds. The entries found are written to
-disk. Since scanning the entire cache is kind of expensive and does nothing
-under normal circumstances, this value should not be too small. 900 seconds
-might be a good value, though setting this to 7200 seconds doesn't normally
-do much harm either.
-
-Defaults to 10x B<CacheTimeout>.
-B<CacheFlush> must be larger than or equal to B<CacheTimeout>, otherwise the
-above default is used.
+etc.) some values may still be in the cache. If B<CacheFlush> is set, then the
+entire cache is searched for entries older than B<CacheTimeout> seconds and
+written to disk every I<Seconds> seconds. Since this is kind of expensive and
+does nothing under normal circumstances, this value should not be too small.
+900 seconds might be a good value, though setting this to 7200 seconds doesn't
+normally do much harm either.
 
 =item B<CacheTimeout> I<Seconds>
 
 If this option is set to a value greater than zero, the C<rrdtool plugin> will
 save values in a cache, as described above. Writing multiple values at once
 reduces IO-operations and thus lessens the load produced by updating the files.
@@ -6544,14 +6692,12 @@
 
 Selects the name of the sensor which you want to collect or ignore, depending
 on the B<IgnoreSelected> below. For example, the option "B<Sensor>
 I<it8712-isa-0290/voltage-in1>" will cause collectd to gather data for the
 voltage sensor I<in1> of the I<it8712> on the isa bus at the address 0290.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> I<true>|I<false>
 
 If no configuration if given, the B<sensors>-plugin will collect data from all
 sensors. This may not be practical, especially for uninteresting sensors.
 Thus, you can use the B<Sensor>-option to pick the sensors you're interested
 in. Sometimes, however, it's easier/preferred to collect all sensors I<except> a
@@ -6655,14 +6801,12 @@
 daemon's ignorelist functionality, a string that starts and ends with a slash
 is interpreted as a regular expression. Examples:
 
   Disk "sdd"
   Disk "/hda[34]/"
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> B<true>|B<false>
 
 Sets whether selected disks, i.E<nbsp>e. the ones matches by any of the B<Disk>
 statements, are ignored or if all other disks are ignored. The behavior
 (hopefully) is intuitive: If no B<Disk> option is configured, all disks are
 collected. If at least one B<Disk> option is given and no B<IgnoreSelected> or
@@ -6942,12 +7086,21 @@
         Regex "\\<R=local_user\\>"
         ExcludeRegex "\\<R=local_user\\>.*mail_spool defer"
         DSType "CounterInc"
         Type "counter"
         Instance "local_user"
       </Match>
+      <Match>
+        Regex "l=([0-9]*\\.[0-9]*)"
+        <DSType "Distribution">
+          Percentile 99
+          Bucket 0 100
+        </DSType>
+        Type "latency"
+        Instance "foo"
+      </Match>
     </File>
   </Plugin>
 
 The config consists of one or more B<File> blocks, each of which configures one
 logfile to parse. Within each B<File> block, there are one or more B<Match>
 blocks, which configure a regular expression to search for.
@@ -7004,12 +7157,19 @@
 Use the greatest number only.
 
 =item B<GaugeLast>
 
 Use the last number found.
 
+=item B<GaugePersist>
+
+Use the last number found. The number is not reset at the end of an interval.
+It is continously reported until another number is matched. This is intended
+for cases in which only state changes are reported, for example a thermometer
+that only reports the temperature when it changes.
+
 =item B<CounterSet>
 
 =item B<DeriveSet>
 
 =item B<AbsoluteSet>
 
@@ -7033,20 +7193,80 @@
 =item B<DeriveInc>
 
 Increase the internal counter by one. These B<DSType> are the only ones that do
 not use the matched subexpression, but simply count the number of matched
 lines. Thus, you may use a regular expression without submatch in this case.
 
+=item B<Distribution>
+
+Type to do calculations based on the distribution of values, primarily
+calculating percentiles. This is primarily geared towards latency, but can be
+used for other metrics as well. The range of values tracked with this setting
+must be in the range (02^34) and can be fractional. Please note that neither
+zero nor 2^34 are inclusive bounds, i.e. zero I<cannot> be handled by a
+distribution.
+
+This option must be used together with the B<Percentile> and/or B<Bucket>
+options.
+
+B<Synopsis:>
+
+  <DSType "Distribution">
+    Percentile 99
+    Bucket 0 100
+  </DSType>
+
+=over 4
+
+=item B<Percentile> I<Percent>
+
+Calculate and dispatch the configured percentile, i.e. compute the value, so
+that I<Percent> of all matched values are smaller than or equal to the computed
+latency.
+
+Metrics are reported with the I<type> B<Type> (the value of the above option)
+and the I<type instance> C<[E<lt>InstanceE<gt>-]E<lt>PercentE<gt>>.
+
+This option may be repeated to calculate more than one percentile.
+
+=item B<Bucket> I<lower_bound> I<upper_bound>
+
+Export the number of values (a C<DERIVE>) falling within the given range. Both,
+I<lower_bound> and I<upper_bound> may be a fractional number, such as B<0.5>.
+Each B<Bucket> option specifies an interval C<(I<lower_bound>,
+I<upper_bound>]>, i.e. the range I<excludes> the lower bound and I<includes>
+the upper bound. I<lower_bound> and I<upper_bound> may be zero, meaning no
+lower/upper bound.
+
+To export the entire (0inf) range without overlap, use the upper bound of the
+previous range as the lower bound of the following range. In other words, use
+the following schema:
+
+  Bucket   0   1
+  Bucket   1   2
+  Bucket   2   5
+  Bucket   5  10
+  Bucket  10  20
+  Bucket  20  50
+  Bucket  50   0
+
+Metrics are reported with the I<type> C<bucket> and the I<type instance>
+C<E<lt>TypeE<gt>[-E<lt>InstanceE<gt>]-E<lt>lower_boundE<gt>_E<lt>upper_boundE<gt>>.
+
+This option may be repeated to calculate more than one rate.
+
 =back
 
-As you'd expect the B<Gauge*> types interpret the submatch as a floating point
-number, using L<strtod(3)>. The B<Counter*> and B<AbsoluteSet> types interpret
-the submatch as an unsigned integer using L<strtoull(3)>. The B<Derive*> types
-interpret the submatch as a signed integer using L<strtoll(3)>. B<CounterInc>
-and B<DeriveInc> do not use the submatch at all and it may be omitted in this
-case.
+=back
+
+The B<Gauge*> and B<Distribution> types interpret the submatch as a floating
+point number, using L<strtod(3)>. The B<Counter*> and B<AbsoluteSet> types
+interpret the submatch as an unsigned integer using L<strtoull(3)>. The
+B<Derive*> types interpret the submatch as a signed integer using
+L<strtoll(3)>. B<CounterInc> and B<DeriveInc> do not use the submatch at all
+and it may be omitted in this case.
 
 =item B<Type> I<Type>
 
 Sets the type used to dispatch this value. Detailed information about types and
 their configuration can be found in L<types.db(5)>.
 
@@ -7268,14 +7488,12 @@
 =item B<Device> I<Device>
 
 Selects the name of the thermal device that you want to collect or ignore,
 depending on the value of the B<IgnoreSelected> option. This option may be
 used multiple times to specify a list of devices.
 
-See F</"IGNORELISTS"> for details.
-
 =item B<IgnoreSelected> I<true>|I<false>
 
 Invert the selection: If set to true, all devices B<except> the ones that
 match the device names specified by the B<Device> option are collected. By
 default only selected devices are collected if a selection is made. If no
 selection is configured at all, B<all> devices are selected.
@@ -7297,13 +7515,13 @@
 couple metrics: number of records, and database size on disk.
 
 =over 4
 
 =item B<Host> I<Hostname/IP>
 
-The hostname or ip which identifies the server.
+The hostname or IP which identifies the server.
 Default: B<127.0.0.1>
 
 =item B<Port> I<Service/Port>
 
 The query port of the server. This needs to be a string, even if the port is
 given in its numeric form.
@@ -7311,67 +7529,66 @@
 
 =back
 
 =head2 Plugin C<turbostat>
 
 The I<Turbostat plugin> reads CPU frequency and C-state residency on modern
-Intel processors by using the new Model Specific Registers.
+Intel processors by using I<Model Specific Registers>.
 
 =over 4
 
 =item B<CoreCstates> I<Bitmask(Integer)>
 
-Bitmask of the list of core C states supported by the processor.
+Bit mask of the list of core C-states supported by the processor.
 This option should only be used if the automated detection fails.
-Default value extracted from the cpu model and family.
+Default value extracted from the CPU model and family.
 
 Currently supported C-states (by this plugin): 3, 6, 7
 
-Example: (1<<3)+(1<<6)+(1<<7) = 392 for all states
+B<Example:>
+
+  All states (3, 6 and 7):
+  (1<<3) + (1<<6) + (1<<7) = 392
 
 =item B<PackageCstates> I<Bitmask(Integer)>
 
-Bitmask of the list of pacages C states supported by the processor.
-This option should only be used if the automated detection fails.
-Default value extracted from the cpu model and family.
+Bit mask of the list of packages C-states supported by the processor. This
+option should only be used if the automated detection fails. Default value
+extracted from the CPU model and family.
 
 Currently supported C-states (by this plugin): 2, 3, 6, 7, 8, 9, 10
 
-Example: (1<<2)+(1<<3)+(1<<6)+(1<<7) = 396 for states 2, 3, 6 and 7
-
-=item B<SystemManagementInterrupt> I<true>|I<false>
+B<Example:>
 
-Boolean enabling the collection of the I/O System-Management Interrupt
-counter'. This option should only be used if the automated detection
-fails or if you want to disable this feature.
+  States 2, 3, 6 and 7:
+  (1<<2) + (1<<3) + (1<<6) + (1<<7) = 396
 
-=item B<DigitalTemperatureSensor> I<true>|I<false>
+=item B<SystemManagementInterrupt> I<true>|I<false>
 
-Boolean enabling the collection of the temperature of each core.
-This option should only be used if the automated detectionfails or
-if you want to disable this feature.
+Boolean enabling the collection of the I/O System-Management Interrupt counter.
+This option should only be used if the automated detection fails or if you want
+to disable this feature.
 
 =item B<DigitalTemperatureSensor> I<true>|I<false>
 
-Boolean enabling the collection of the temperature of each package.
-This option should only be used if the automated detectionfails or
-if you want to disable this feature.
+Boolean enabling the collection of the temperature of each core. This option
+should only be used if the automated detection fails or if you want to disable
+this feature.
 
 =item B<TCCActivationTemp> I<Temperature>
 
-Thermal Control Circuit Activation Temperature of the installed
-CPU. This temperature is used when collecting the temperature of
-cores or packages. This option should only be used if the automated
-detection fails. Default value extracted from B<MSR_IA32_TEMPERATURE_TARGET>
+I<Thermal Control Circuit Activation Temperature> of the installed CPU. This
+temperature is used when collecting the temperature of cores or packages. This
+option should only be used if the automated detection fails. Default value
+extracted from B<MSR_IA32_TEMPERATURE_TARGET>.
 
 =item B<RunningAveragePowerLimit> I<Bitmask(Integer)>
 
-Bitmask of the list of elements to be thermally monitored. This option
-should only be used if the automated detection fails or if you want to
-disable some collections. The different bits of this bitmask accepted
-by this plugin are:
+Bit mask of the list of elements to be thermally monitored. This option should
+only be used if the automated detection fails or if you want to disable some
+collections. The different bits of this bit mask accepted by this plugin are:
 
 =over 4
 
 =item 0 ('1'): Package
 
 =item 1 ('2'): DRAM
@@ -7379,12 +7596,20 @@
 =item 2 ('4'): Cores
 
 =item 3 ('8'): Embedded graphic device
 
 =back
 
+=item B<LogicalCoreNames> I<true>|I<false>
+
+Boolean enabling the use of logical core numbering for per core statistics.
+When enabled, C<cpuE<lt>nE<gt>> is used as plugin instance, where I<n> is a
+sequential number assigned by the kernel. Otherwise, C<coreE<lt>nE<gt>> is used
+where I<n> is the n-th core of the socket, causing name conflicts when there is
+more than one socket.
+
 =back
 
 =head2 Plugin C<unixsock>
 
 =over 4
 
@@ -7660,12 +7885,55 @@
  BlockDevice "/:hdb/"
  IgnoreSelected "true"
 
 Ignore all I<hdb> devices on any domain, but other block devices (eg. I<hda>)
 will be collected.
 
+=item B<BlockDeviceFormat> B<target>|B<source>
+
+If I<BlockDeviceFormat> is set to B<target>, the default, then the device name
+seen by the guest will be used for reporting metrics. 
+This corresponds to the C<E<lt>targetE<gt>> node in the XML definition of the
+domain.
+
+If I<BlockDeviceFormat> is set to B<source>, then metrics will be reported
+using the path of the source, e.g. an image file.
+This corresponds to the C<E<lt>sourceE<gt>> node in the XML definition of the
+domain.
+
+B<Example:>
+
+If the domain XML have the following device defined:
+
+  <disk type='block' device='disk'>
+    <driver name='qemu' type='raw' cache='none' io='native' discard='unmap'/>
+    <source dev='/var/lib/libvirt/images/image1.qcow2'/>
+    <target dev='sda' bus='scsi'/>
+    <boot order='2'/>
+    <address type='drive' controller='0' bus='0' target='0' unit='0'/>
+  </disk>
+
+Setting C<BlockDeviceFormat target> will cause the I<type instance> to be set
+to C<sda>.
+Setting C<BlockDeviceFormat source> will cause the I<type instance> to be set
+to C<var_lib_libvirt_images_image1.qcow2>.
+
+=item B<BlockDeviceFormatBasename> B<false>|B<true>
+
+The B<BlockDeviceFormatBasename> controls whether the full path or the
+L<basename(1)> of the source is being used as the I<type instance> when
+B<BlockDeviceFormat> is set to B<source>. Defaults to B<false>.
+
+B<Example:>
+
+Assume the device path (source tag) is C</var/lib/libvirt/images/image1.qcow2>.
+Setting C<BlockDeviceFormatBasename false> will cause the I<type instance> to
+be set to C<var_lib_libvirt_images_image1.qcow2>.
+Setting C<BlockDeviceFormatBasename true> will cause the I<type instance> to be
+set to C<image1.qcow2>.
+
 =item B<HostnameFormat> B<name|uuid|hostname|...>
 
 When the virt plugin logs data, it sets the hostname of the collected data
 according to this setting. The default is to use the guest name as provided by
 the hypervisor, which is equal to setting B<name>.
 
@@ -7826,12 +8094,44 @@
 =item B<AlwaysAppendDS> B<false>|B<true>
 
 If set to B<true>, append the name of the I<Data Source> (DS) to the "metric"
 identifier. If set to B<false> (the default), this is only done when there is
 more than one DS.
 
+=item B<PreserveSeparator> B<false>|B<true>
+
+If set to B<false> (the default) the C<.> (dot) character is replaced with
+I<EscapeCharacter>. Otherwise, if set to B<true>, the C<.> (dot) character
+is preserved, i.e. passed through.
+
+=item B<DropDuplicateFields> B<false>|B<true>
+
+If set to B<true>, detect and remove duplicate components in Graphite metric
+names. For example, the metric name  C<host.load.load.shortterm> will
+be shortened to C<host.load.shortterm>.
+
+=back
+
+=head2 Plugin C<write_log>
+
+The C<write_log> plugin writes metrics as INFO log messages.
+
+This plugin supports two output formats: I<Graphite> and I<JSON>.
+
+Synopsis:
+
+ <Plugin write_log>
+   Format Graphite
+ </Plugin>
+
+=over 4
+
+=item B<Format> I<Format>
+
+The output format to use. Can be one of C<Graphite> or C<JSON>.
+
 =back
 
 =head2 Plugin C<write_tsdb>
 
 The C<write_tsdb> plugin writes data to I<OpenTSDB>, a scalable open-source
 time series database. The plugin connects to a I<TSD>, a masterless, no shared
@@ -7934,12 +8234,47 @@
 Sets the information used when authenticating to a I<MongoDB> database. The
 fields are optional (in which case no authentication is attempted), but if you
 want to use authentication all three fields must be set.
 
 =back
 
+=head2 Plugin C<write_prometheus>
+
+The I<write_prometheus plugin> implements a tiny webserver that can be scraped
+using I<Prometheus>.
+
+B<Options:>
+
+=over 4
+
+=item B<Port> I<Port>
+
+Port the embedded webserver should listen on. Defaults to B<9103>.
+
+=item B<StalenessDelta> I<Seconds>
+
+Time in seconds after which I<Prometheus> considers a metric "stale" if it
+hasn't seen any update for it. This value must match the setting in Prometheus.
+It defaults to B<300> seconds (5 minutes), same as Prometheus.
+
+B<Background:>
+
+I<Prometheus> has a global setting, C<StalenessDelta>, which controls after
+which time a metric without updates is considered "stale". This setting
+effectively puts an upper limit on the interval in which metrics are reported.
+
+When the I<write_prometheus plugin> encounters a metric with an interval
+exceeding this limit, it will inform you, the user, and provide the metric to
+I<Prometheus> B<without> a timestamp. That causes I<Prometheus> to consider the
+metric "fresh" each time it is scraped, with the time of the scrape being
+considered the time of the update. The result is that there appear more
+datapoints in I<Prometheus> than were actually created, but at least the metric
+doesn't disappear periodically.
+
+=back
+
 =head2 Plugin C<write_http>
 
 This output plugin submits values to an HTTP server using POST requests and
 encoding metrics with JSON or using the C<PUTVAL> command described in
 L<collectd-unixsock(5)>.
 
@@ -8167,12 +8502,24 @@
 
 If set to B<true>, the plugin instance and type instance will be in their own
 path component, for example C<host.cpu.0.cpu.idle>. If set to B<false> (the
 default), the plugin and plugin instance (and likewise the type and type
 instance) are put into one component, for example C<host.cpu-0.cpu-idle>.
 
+=item B<GraphiteAlwaysAppendDS> B<true>|B<false>
+
+If set to B<true>, append the name of the I<Data Source> (DS) to the "metric"
+identifier. If set to B<false> (the default), this is only done when there is
+more than one DS.
+
+=item B<GraphitePreserveSeparator> B<false>|B<true>
+
+If set to B<false> (the default) the C<.> (dot) character is replaced with
+I<GraphiteEscapeChar>. Otherwise, if set to B<true>, the C<.> (dot) character
+is preserved, i.e. passed through.
+
 =item B<StoreRates> B<true>|B<false>
 
 If set to B<true> (the default), convert counter values to rates. If set to
 B<false> counter values are stored as is, i.e. as an increasing integer number.
 
 This will be reflected in the C<ds_type> tag: If B<StoreRates> is enabled,
@@ -9101,12 +9448,14 @@
 =item B<PluginInstance> I<Regex>
 
 =item B<Type> I<Regex>
 
 =item B<TypeInstance> I<Regex>
 
+=item B<MetaData> I<String> I<Regex>
+
 Match values where the given regular expressions match the various fields of
 the identifier of a value. If multiple regular expressions are given, B<all>
 regexen must match for a value to match.
 
 =item B<Invert> B<false>|B<true>
 
@@ -9389,12 +9738,16 @@
 =item B<Plugin> I<Regex> I<Replacement>
 
 =item B<PluginInstance> I<Regex> I<Replacement>
 
 =item B<TypeInstance> I<Regex> I<Replacement>
 
+=item B<MetaData> I<String> I<Regex> I<Replacement>
+
+=item B<DeleteMetaData> I<String> I<Regex>
+
 Match the appropriate field with the given regular expression I<Regex>. If the
 regular expression matches, that part that matches is replaced with
 I<Replacement>. If multiple places of the input buffer match a given regular
 expression, only the first occurrence will be replaced.
 
 You can specify each option multiple times to use multiple regular expressions
@@ -9427,15 +9780,43 @@
 =item B<PluginInstance> I<String>
 
 =item B<TypeInstance> I<String>
 
 =item B<MetaData> I<String> I<String>
 
-Set the appropriate field to the given string. The strings for plugin instance
-and type instance may be empty, the strings for host and plugin may not be
-empty. It's currently not possible to set the type of a value this way.
+Set the appropriate field to the given string. The strings for plugin instance,
+type instance, and meta data may be empty, the strings for host and plugin may
+not be empty. It's currently not possible to set the type of a value this way.
+
+The following placeholders will be replaced by an appropriate value:
+
+=over 4
+
+=item B<%{host}>
+
+=item B<%{plugin}>
+
+=item B<%{plugin_instance}>
+
+=item B<%{type}>
+
+=item B<%{type_instance}>
+
+These placeholders are replaced by the identifier field of the same name.
+
+=item B<%{meta:>I<name>B<}>
+
+These placeholders are replaced by the meta data value with the given name.
+
+=back
+
+Please note that these placeholders are B<case sensitive>!
+
+=item B<DeleteMetaData> I<String>
+
+Delete the named meta data field.
 
 =back
 
 Example:
 
  <Target "set">
@@ -9471,54 +9852,12 @@
      </Match>
      Target "stop"
    </Rule>
    Target "write"
  </Chain>
 
-=head1 IGNORELISTS
-
-B<Ignorelists> are a generic framework to either ignore some metrics or report
-specific metircs only. Plugins usually provide one or more options to specify
-the items (mounts points, devices, ...) and the boolean option
-C<IgnoreSelected>.
-
-=over 4
-
-=item B<Select> I<String>
-
-Selects the item I<String>. This option often has a plugin specific name, e.g.
-B<Sensor> in the C<sensors> plugin. It is also plugin specific what this string
-is compared to. For example, the C<df> plugin's B<MountPoint> compares it to a
-mount point and the C<sensors> plugin's B<Sensor> compares it to a sensor name.
-
-By default, this option is doing a case-sensitive full-string match. The
-following config will match C<foo>, but not C<Foo>:
-
-  Select "foo"
-
-If I<String> starts and ends with C</> (a slash), the string is compiled as a
-I<regular expression>. For example, so match all item starting with C<foo>, use
-could use the following syntax:
-
-  Select "/^foo/"
-
-The regular expression is I<not> anchored, i.e. the following config will match
-C<foobar>, C<barfoo> and C<AfooZ>:
-
-  Select "/foo/"
-
-The B<Select> option may be repeated to select multiple items.
-
-=item B<IgnoreSelected> B<true>|B<false>
-
-If set to B<true>, matching metrics are I<ignored> and all other metrics are
-collected. If set to B<false>, matching metrics are I<collected> and all other
-metrics are ignored.
-
-=back
-
 =head1 SEE ALSO
 
 L<collectd(1)>,
 L<collectd-exec(5)>,
 L<collectd-perl(5)>,
 L<collectd-unixsock(5)>,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectdctl.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectdctl.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectdctl.1	2017-04-06 22:45:13.405988145 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectdctl.1	2016-12-12 16:04:33.107986179 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTDCTL 1"
-.TH COLLECTDCTL 1 "2017-04-05" "5.7.1.253.gbdcefed+" "collectd"
+.TH COLLECTDCTL 1 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectdctl \- Control interface for collectd
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-email.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-email.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-email.5	2017-09-21 14:46:59.402291880 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-email.5	2016-12-12 16:04:32.963986664 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-EMAIL 5"
-.TH COLLECTD-EMAIL 5 "2017-09-21" "5.6.1.343.g725061a+" "collectd"
+.TH COLLECTD-EMAIL 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-email \- Documentation of collectd's "email plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-exec.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-exec.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-exec.5	2017-09-21 14:46:59.478292221 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-exec.5	2016-12-12 16:04:33.047986380 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-EXEC 5"
-.TH COLLECTD-EXEC 5 "2017-09-21" "5.6.1.343.g725061a+" "collectd"
+.TH COLLECTD-EXEC 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-exec \- Documentation of collectd's "exec plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-java.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-java.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-java.5	2017-09-21 14:46:59.586292706 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-java.5	2016-12-12 16:04:33.215985818 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-JAVA 5"
-.TH COLLECTD-JAVA 5 "2017-09-21" "5.6.1.343.g725061a+" "collectd"
+.TH COLLECTD-JAVA 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-java \- Documentation of collectd's "java plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-lua.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-lua.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-lua.5	2017-09-21 14:46:59.658293030 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-lua.5	2016-12-12 16:04:33.275985617 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-LUA 5"
-.TH COLLECTD-LUA 5 "2017-09-21" "5.6.1.343.g725061a+" "collectd"
+.TH COLLECTD-LUA 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-lua \- Documentation of collectd's "Lua plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectdmon.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectdmon.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectdmon.1	2017-04-06 22:45:13.625985338 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectdmon.1	2016-12-12 16:04:33.335985417 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTDMON 1"
-.TH COLLECTDMON 1 "2017-04-05" "5.7.1.253.gbdcefed+" "collectd"
+.TH COLLECTDMON 1 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectdmon \- Monitoring daemon for collectd
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-nagios.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-nagios.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-nagios.1	2017-04-06 22:45:13.717984164 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-nagios.1	2016-12-12 16:04:33.411985163 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-NAGIOS 1"
-.TH COLLECTD-NAGIOS 1 "2017-04-05" "5.7.1.253.gbdcefed+" "collectd"
+.TH COLLECTD-NAGIOS 1 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-nagios \- Nagios plugin for querying collectd
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-perl.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-perl.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-perl.5	2017-10-06 14:55:01.994112660 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-perl.5	2016-12-12 16:04:33.519984802 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-PERL 5"
-.TH COLLECTD-PERL 5 "2017-10-06" "5.6.2.66.ga46c9c8" "collectd"
+.TH COLLECTD-PERL 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-perl \- Documentation of collectd's "perl plugin"
@@ -201,12 +201,25 @@
 the command line driven interface of the debugger.
 .IP "\fBIncludeDir\fR \fIDir\fR" 4
 .IX Item "IncludeDir Dir"
 Adds \fIDir\fR to the \fB\f(CB@INC\fB\fR array. This is the same as using the \fB\-IDir\fR
 command line option or \fBuse lib Dir\fR in the source code. Please note that it
 only has effect on plugins loaded after this option.
+.IP "\fBRegisterLegacyFlush\fR \fItrue|false\fR" 4
+.IX Item "RegisterLegacyFlush true|false"
+The \f(CW\*(C`Perl plugin\*(C'\fR used to register one flush callback (called \fB\*(L"perl\*(R"\fR) and
+call all Perl-based flush handlers when this callback was called. Newer versions
+of the plugin wrap the Perl flush handlers and register them directly with the
+daemon \fIin addition\fR to the legacy \fB\*(L"perl\*(R"\fR callback. This allows to call
+specific Perl flush handlers, but has the downside that flushing \fIall\fR plugins
+now calls the Perl flush handlers twice (once directly and once via the legacy
+callback). Unfortunately, removing the \fB\*(L"perl\*(R"\fR callback would break backwards
+compatibility.
+.Sp
+This option allows you to disable the legacy \fB\*(L"perl\*(R"\fR flush callback if you care
+about the double call and don't call the \fB\*(L"perl\*(R"\fR callback in your setup.
 .SH "WRITING YOUR OWN PLUGINS"
 .IX Header "WRITING YOUR OWN PLUGINS"
 Writing your own plugins is quite simple. collectd manages plugins by means of
 \&\fBdispatch functions\fR which call the appropriate \fBcallback functions\fR
 registered by the plugins. Any plugin basically consists of the implementation
 of these callback functions and initializing code which registers the
@@ -829,18 +842,12 @@
 .IP "\(bu" 4
 The perl plugin exports the internal \s-1API\s0 of collectd which is considered
 unstable and subject to change at any time. We try hard to not break backwards
 compatibility in the Perl \s-1API\s0 during the life cycle of one major release.
 However, this cannot be guaranteed at all times. Watch out for warnings
 dispatched by the perl plugin after upgrades.
-.SH "KNOWN BUGS"
-.IX Header "KNOWN BUGS"
-.IP "\(bu" 4
-Currently, it is not possible to flush a single Perl plugin only. You can
-either flush all Perl plugins or none at all and you have to use \f(CW\*(C`perl\*(C'\fR as
-plugin name when doing so.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
 \&\fIcollectd\fR\|(1),
 \&\fIcollectd.conf\fR\|(5),
 \&\fIcollectd\-exec\fR\|(5),
 \&\fItypes.db\fR\|(5),
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-perl.pod /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-perl.pod
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-perl.pod	2017-10-06 14:45:52.933917748 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-perl.pod	2016-12-12 16:03:36.692279230 +0800
@@ -72,12 +72,26 @@
 =item B<IncludeDir> I<Dir>
 
 Adds I<Dir> to the B<@INC> array. This is the same as using the B<-IDir>
 command line option or B<use lib Dir> in the source code. Please note that it
 only has effect on plugins loaded after this option.
 
+=item B<RegisterLegacyFlush> I<true|false>
+
+The C<Perl plugin> used to register one flush callback (called B<"perl">) and
+call all Perl-based flush handlers when this callback was called. Newer versions
+of the plugin wrap the Perl flush handlers and register them directly with the
+daemon I<in addition> to the legacy B<"perl"> callback. This allows to call
+specific Perl flush handlers, but has the downside that flushing I<all> plugins
+now calls the Perl flush handlers twice (once directly and once via the legacy
+callback). Unfortunately, removing the B<"perl"> callback would break backwards
+compatibility.
+
+This option allows you to disable the legacy B<"perl"> flush callback if you care
+about the double call and don't call the B<"perl"> callback in your setup.
+
 =back
 
 =head1 WRITING YOUR OWN PLUGINS
 
 Writing your own plugins is quite simple. collectd manages plugins by means of
 B<dispatch functions> which call the appropriate B<callback functions>
@@ -756,24 +770,12 @@
 compatibility in the Perl API during the life cycle of one major release.
 However, this cannot be guaranteed at all times. Watch out for warnings
 dispatched by the perl plugin after upgrades.
 
 =back
 
-=head1 KNOWN BUGS
-
-=over 4
-
-=item *
-
-Currently, it is not possible to flush a single Perl plugin only. You can
-either flush all Perl plugins or none at all and you have to use C<perl> as
-plugin name when doing so.
-
-=back
-
 =head1 SEE ALSO
 
 L<collectd(1)>,
 L<collectd.conf(5)>,
 L<collectd-exec(5)>,
 L<types.db(5)>,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-python.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-python.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-python.5	2017-10-06 14:55:02.102112677 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-python.5	2016-12-12 16:04:33.619984467 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-PYTHON 5"
-.TH COLLECTD-PYTHON 5 "2017-10-06" "5.6.2.66.ga46c9c8" "collectd"
+.TH COLLECTD-PYTHON 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-python \- Documentation of collectd's "python plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-snmp.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-snmp.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-snmp.5	2017-10-06 14:55:02.178112689 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-snmp.5	2016-12-12 16:04:33.703984186 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-SNMP 5"
-.TH COLLECTD-SNMP 5 "2017-10-06" "5.6.2.66.ga46c9c8" "collectd"
+.TH COLLECTD-SNMP 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-snmp \- Documentation of collectd's "snmp plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-tg.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-tg.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-tg.1	2017-04-06 22:45:14.025980232 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-tg.1	2016-12-12 16:04:33.763983986 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-TG 1"
-.TH COLLECTD-TG 1 "2017-04-05" "5.7.1.253.gbdcefed+" "collectd"
+.TH COLLECTD-TG 1 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-tg \- Traffic generator for collectd.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-threshold.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-threshold.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-threshold.5	2017-04-06 22:45:14.237977518 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-threshold.5	2016-12-12 16:04:33.843983718 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-THRESHOLD 5"
-.TH COLLECTD-THRESHOLD 5 "2017-04-05" "5.7.1.253.gbdcefed+" "collectd"
+.TH COLLECTD-THRESHOLD 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-threshold \- Documentation of collectd's Threshold plugin
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-unixsock.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-unixsock.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/collectd-unixsock.5	2017-04-06 22:45:14.181978235 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/collectd-unixsock.5	2016-12-12 16:04:33.919983464 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-UNIXSOCK 5"
-.TH COLLECTD-UNIXSOCK 5 "2017-04-05" "5.7.1.253.gbdcefed+" "collectd"
+.TH COLLECTD-UNIXSOCK 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-unixsock \- Documentation of collectd's "unixsock plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/config.h.in	2017-10-06 15:04:18.622135695 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/config.h.in	2016-12-12 16:04:32.191989291 +0800
@@ -90,13 +90,13 @@
 /* Define to 1 if you have the <atasmart.h> header file. */
 #undef HAVE_ATASMART_H
 
 /* Define to 1 if you have the <bsd/nlist.h> header file. */
 #undef HAVE_BSD_NLIST_H
 
-/* Define to 1 if you have cap_get_proc() (-lcap). */
+/* Define to 1 if you have cap_get_bound() (-lcap). */
 #undef HAVE_CAPABILITY
 
 /* Define if the clock_gettime(2) function is available. */
 #undef HAVE_CLOCK_GETTIME
 
 /* Define to 1 if you have the `closedir' function. */
@@ -578,12 +578,15 @@
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
 /* Define to 1 if you have the <MicAccessApi.h> header file. */
 #undef HAVE_MICACCESSAPI_H
 
+/* Define to 1 if you have the <microhttpd.h> header file. */
+#undef HAVE_MICROHTTPD_H
+
 /* Define to 1 if you have the <mntent.h> header file. */
 #undef HAVE_MNTENT_H
 
 /* Define to 1 if you have the <mnttab.h> header file. */
 #undef HAVE_MNTTAB_H
 
@@ -779,12 +782,15 @@
 /* Define to 1 if the disk plugin is enabled. */
 #undef HAVE_PLUGIN_DISK
 
 /* Define to 1 if the dns plugin is enabled. */
 #undef HAVE_PLUGIN_DNS
 
+/* Define to 1 if the dpdkstat plugin is enabled. */
+#undef HAVE_PLUGIN_DPDKSTAT
+
 /* Define to 1 if the drbd plugin is enabled. */
 #undef HAVE_PLUGIN_DRBD
 
 /* Define to 1 if the email plugin is enabled. */
 #undef HAVE_PLUGIN_EMAIL
 
@@ -815,12 +821,18 @@
 /* Define to 1 if the grpc plugin is enabled. */
 #undef HAVE_PLUGIN_GRPC
 
 /* Define to 1 if the hddtemp plugin is enabled. */
 #undef HAVE_PLUGIN_HDDTEMP
 
+/* Define to 1 if the hugepages plugin is enabled. */
+#undef HAVE_PLUGIN_HUGEPAGES
+
+/* Define to 1 if the intel_rdt plugin is enabled. */
+#undef HAVE_PLUGIN_INTEL_RDT
+
 /* Define to 1 if the interface plugin is enabled. */
 #undef HAVE_PLUGIN_INTERFACE
 
 /* Define to 1 if the ipc plugin is enabled. */
 #undef HAVE_PLUGIN_IPC
 
@@ -1103,12 +1115,15 @@
 /* Define to 1 if the write_log plugin is enabled. */
 #undef HAVE_PLUGIN_WRITE_LOG
 
 /* Define to 1 if the write_mongodb plugin is enabled. */
 #undef HAVE_PLUGIN_WRITE_MONGODB
 
+/* Define to 1 if the write_prometheus plugin is enabled. */
+#undef HAVE_PLUGIN_WRITE_PROMETHEUS
+
 /* Define to 1 if the write_redis plugin is enabled. */
 #undef HAVE_PLUGIN_WRITE_REDIS
 
 /* Define to 1 if the write_riemann plugin is enabled. */
 #undef HAVE_PLUGIN_WRITE_RIEMANN
 
@@ -1133,12 +1148,15 @@
 /* Define to 1 if the zookeeper plugin is enabled. */
 #undef HAVE_PLUGIN_ZOOKEEPER
 
 /* Define to 1 if you have the <poll.h> header file. */
 #undef HAVE_POLL_H
 
+/* Define to 1 if you have the <pqos.h> header file. */
+#undef HAVE_PQOS_H
+
 /* Define if libtool can extract symbol lists from object files. */
 #undef HAVE_PRELOADED_SYMBOLS
 
 /* Define to 1 if you have the `processor_info' function. */
 #undef HAVE_PROCESSOR_INFO
 
@@ -1148,12 +1166,21 @@
 /* Define to 1 if you have the <protobuf-c/protobuf-c.h> header file. */
 #undef HAVE_PROTOBUF_C_PROTOBUF_C_H
 
 /* Define to 1 if you have the <pthread.h> header file. */
 #undef HAVE_PTHREAD_H
 
+/* Define to 1 if you have the <pthread_np.h> header file. */
+#undef HAVE_PTHREAD_NP_H
+
+/* pthread_setname_np() is available. */
+#undef HAVE_PTHREAD_SETNAME_NP
+
+/* pthread_set_name_np() is available. */
+#undef HAVE_PTHREAD_SET_NAME_NP
+
 /* Define to 1 if you have the <pwd.h> header file. */
 #undef HAVE_PWD_H
 
 /* Define to 1 if you have the <Python.h> header file. */
 #undef HAVE_PYTHON_H
 
@@ -1178,12 +1205,15 @@
 /* Define to 1 if you have the <routeros_api.h> header file. */
 #undef HAVE_ROUTEROS_API_H
 
 /* Define to 1 if you have the <rrd.h> header file. */
 #undef HAVE_RRD_H
 
+/* Define to 1 if you have the <rte_config.h> header file. */
+#undef HAVE_RTE_CONFIG_H
+
 /* Define if struct rtnl_link_stats64 exists and is usable. */
 #undef HAVE_RTNL_LINK_STATS64
 
 /* Define to 1 if you have the `select' function. */
 #undef HAVE_SELECT
 
@@ -1511,15 +1541,12 @@
 /* Define to 1 if the rrd library is thread-safe */
 #undef HAVE_THREADSAFE_LIBRRD
 
 /* Define to 1 if you have the `thread_info' function. */
 #undef HAVE_THREAD_INFO
 
-/* Define if the timegm(3) function is available. */
-#undef HAVE_TIMEGM
-
 /* Define if the function getmntent exists and takes two arguments. */
 #undef HAVE_TWO_GETMNTENT
 
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
@@ -1673,15 +1700,12 @@
 /* Define to 1 if strerror_r returns char *. */
 #undef STRERROR_R_CHAR_P
 
 /* Set to true if strptime is only exported in X/Open mode (GNU libc). */
 #undef STRPTIME_NEEDS_STANDARDS
 
-/* Set to true if timegm is only exported in BSD mode. */
-#undef TIMEGM_NEEDS_BSD
-
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #undef TIME_WITH_SYS_TIME
 
 /* Version number of package */
 #undef VERSION
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/conntrack.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/conntrack.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/conntrack.c	2017-10-06 14:45:52.937917751 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/conntrack.c	2016-12-12 16:03:36.704279144 +0800
@@ -53,72 +53,39 @@
 static void conntrack_submit(const char *type, const char *type_instance,
                              value_t conntrack) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = &conntrack;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "conntrack", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* static void conntrack_submit */
 
 static int conntrack_read(void) {
   value_t conntrack, conntrack_max, conntrack_pct;
-  FILE *fh;
-  char buffer[64] = {0};
-  size_t buffer_len;
 
-  fh = fopen(old_files ? CONNTRACK_FILE_OLD : CONNTRACK_FILE, "r");
-  if (fh == NULL)
+  char const *path = old_files ? CONNTRACK_FILE_OLD : CONNTRACK_FILE;
+  if (parse_value_file(path, &conntrack, DS_TYPE_GAUGE) != 0) {
+    ERROR("conntrack plugin: Reading \"%s\" failed.", path);
     return (-1);
-
-  if (fgets(buffer, sizeof(buffer), fh) == NULL) {
-    fclose(fh);
-    return (-1);
-  }
-  fclose(fh);
-
-  /* strip trailing newline. */
-  buffer_len = strlen(buffer);
-  while ((buffer_len > 0) && isspace((int)buffer[buffer_len - 1])) {
-    buffer[buffer_len - 1] = 0;
-    buffer_len--;
   }
 
-  if (parse_value(buffer, &conntrack, DS_TYPE_GAUGE) != 0)
-    return (-1);
-
-  conntrack_submit("conntrack", NULL, conntrack);
-
-  fh = fopen(old_files ? CONNTRACK_MAX_FILE_OLD : CONNTRACK_MAX_FILE, "r");
-  if (fh == NULL)
+  path = old_files ? CONNTRACK_MAX_FILE_OLD : CONNTRACK_MAX_FILE;
+  if (parse_value_file(path, &conntrack_max, DS_TYPE_GAUGE) != 0) {
+    ERROR("conntrack plugin: Reading \"%s\" failed.", path);
     return (-1);
-
-  memset(buffer, 0, sizeof(buffer));
-  if (fgets(buffer, sizeof(buffer), fh) == NULL) {
-    fclose(fh);
-    return (-1);
-  }
-  fclose(fh);
-
-  /* strip trailing newline. */
-  buffer_len = strlen(buffer);
-  while ((buffer_len > 0) && isspace((int)buffer[buffer_len - 1])) {
-    buffer[buffer_len - 1] = 0;
-    buffer_len--;
   }
 
-  if (parse_value(buffer, &conntrack_max, DS_TYPE_GAUGE) != 0)
-    return (-1);
+  conntrack_pct.gauge = (conntrack.gauge / conntrack_max.gauge) * 100;
 
+  conntrack_submit("conntrack", NULL, conntrack);
   conntrack_submit("conntrack", "max", conntrack_max);
-  conntrack_pct.gauge = (conntrack.gauge / conntrack_max.gauge) * 100;
   conntrack_submit("percent", "used", conntrack_pct);
 
   return (0);
 } /* static int conntrack_read */
 
 void module_register(void) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/contextswitch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/contextswitch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/contextswitch.c	2017-10-06 14:45:52.937917751 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/contextswitch.c	2016-12-12 16:03:36.704279144 +0800
@@ -45,20 +45,16 @@
 
 #else
 #error "No applicable input method."
 #endif
 
 static void cs_submit(derive_t context_switches) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = (derive_t)context_switches;
-
-  vl.values = values;
+  vl.values = &(value_t){.derive = context_switches};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "contextswitch", sizeof(vl.plugin));
   sstrncpy(vl.type, "contextswitch", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/cpu.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/cpu.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/cpu.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/cpu.c	2016-12-12 16:03:36.704279144 +0800
@@ -153,12 +153,18 @@
 
 #elif defined(HAVE_LIBSTATGRAB)
 /* no variables needed */
 /* #endif  HAVE_LIBSTATGRAB */
 
 #elif defined(HAVE_PERFSTAT)
+#define TOTAL_IDLE 0
+#define TOTAL_USER 1
+#define TOTAL_SYS 2
+#define TOTAL_WAIT 3
+#define TOTAL_STAT_NUM 4
+static value_to_rate_state_t total_conv[TOTAL_STAT_NUM];
 static perfstat_cpu_t *perfcpu;
 static int numcpu;
 static int pnumcpu;
 #endif /* HAVE_PERFSTAT */
 
 #define RATE_ADD(sum, val)                                                     \
@@ -306,50 +312,40 @@
 
   return (0);
 } /* int init */
 
 static void submit_value(int cpu_num, int cpu_state, const char *type,
                          value_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  memcpy(&values[0], &value, sizeof(value));
-
-  vl.values = values;
+  vl.values = &value;
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "cpu", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, cpu_state_names[cpu_state],
            sizeof(vl.type_instance));
 
   if (cpu_num >= 0) {
     ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%i", cpu_num);
   }
   plugin_dispatch_values(&vl);
 }
 
-static void submit_percent(int cpu_num, int cpu_state, gauge_t percent) {
-  value_t value;
-
+static void submit_percent(int cpu_num, int cpu_state, gauge_t value) {
   /* This function is called for all known CPU states, but each read
    * method will only report a subset. The remaining states are left as
    * NAN and we ignore them here. */
-  if (isnan(percent))
+  if (isnan(value))
     return;
 
-  value.gauge = percent;
-  submit_value(cpu_num, cpu_state, "percent", value);
+  submit_value(cpu_num, cpu_state, "percent", (value_t){.gauge = value});
 }
 
-static void submit_derive(int cpu_num, int cpu_state, derive_t derive) {
-  value_t value;
-
-  value.derive = derive;
-  submit_value(cpu_num, cpu_state, "cpu", value);
+static void submit_derive(int cpu_num, int cpu_state, derive_t value) {
+  submit_value(cpu_num, cpu_state, "cpu", (value_t){.derive = value});
 }
 
 /* Takes the zero-index number of a CPU and makes sure that the module-global
  * cpu_states buffer is large enough. Returne ENOMEM on erorr. */
 static int cpu_states_alloc(size_t cpu_num) /* {{{ */
 {
@@ -383,12 +379,30 @@
   if (index >= cpu_states_num)
     return (NULL);
 
   return (&cpu_states[index]);
 } /* }}} cpu_state_t *get_cpu_state */
 
+#if defined(HAVE_PERFSTAT) /* {{{ */
+/* populate global aggregate cpu rate */
+static int total_rate(gauge_t *sum_by_state, size_t state, derive_t d,
+                      value_to_rate_state_t *conv, cdtime_t now) {
+  gauge_t rate = NAN;
+  int status =
+      value_to_rate(&rate, (value_t){.derive = d}, DS_TYPE_DERIVE, now, conv);
+  if (status != 0)
+    return (status);
+
+  sum_by_state[state] = rate;
+
+  if (state != COLLECTD_CPU_STATE_IDLE)
+    RATE_ADD(sum_by_state[COLLECTD_CPU_STATE_ACTIVE], sum_by_state[state]);
+  return (0);
+}
+#endif /* }}} HAVE_PERFSTAT */
+
 /* Populates the per-CPU COLLECTD_CPU_STATE_ACTIVE rate and the global
  * rate_by_state
  * array. */
 static void aggregate(gauge_t *sum_by_state) /* {{{ */
 {
   for (size_t state = 0; state < COLLECTD_CPU_STATE_MAX; state++)
@@ -412,12 +426,37 @@
     if (!isnan(this_cpu_states[COLLECTD_CPU_STATE_ACTIVE].rate))
       this_cpu_states[COLLECTD_CPU_STATE_ACTIVE].has_value = 1;
 
     RATE_ADD(sum_by_state[COLLECTD_CPU_STATE_ACTIVE],
              this_cpu_states[COLLECTD_CPU_STATE_ACTIVE].rate);
   }
+
+#if defined(HAVE_PERFSTAT) /* {{{ */
+  cdtime_t now = cdtime();
+  perfstat_cpu_total_t cputotal = {0};
+
+  if (!perfstat_cpu_total(NULL, &cputotal, sizeof(cputotal), 1)) {
+    char errbuf[1024];
+    WARNING("cpu plugin: perfstat_cpu_total: %s",
+            sstrerror(errno, errbuf, sizeof(errbuf)));
+    return;
+  }
+
+  /* Reset COLLECTD_CPU_STATE_ACTIVE */
+  sum_by_state[COLLECTD_CPU_STATE_ACTIVE] = NAN;
+
+  /* Physical Processor Utilization */
+  total_rate(sum_by_state, COLLECTD_CPU_STATE_IDLE, (derive_t)cputotal.pidle,
+             &total_conv[TOTAL_IDLE], now);
+  total_rate(sum_by_state, COLLECTD_CPU_STATE_USER, (derive_t)cputotal.puser,
+             &total_conv[TOTAL_USER], now);
+  total_rate(sum_by_state, COLLECTD_CPU_STATE_SYSTEM, (derive_t)cputotal.psys,
+             &total_conv[TOTAL_SYS], now);
+  total_rate(sum_by_state, COLLECTD_CPU_STATE_WAIT, (derive_t)cputotal.pwait,
+             &total_conv[TOTAL_WAIT], now);
+#endif /* }}} HAVE_PERFSTAT */
 } /* }}} void aggregate */
 
 /* Commits (dispatches) the values for one CPU or the global aggregation.
  * cpu_num is the index of the CPU to be committed or -1 in case of the global
  * aggregation. rates is a pointer to COLLECTD_CPU_STATE_MAX gauge_t values
  * holding the
@@ -440,23 +479,19 @@
     gauge_t percent = 100.0 * rates[state] / sum;
     submit_percent(cpu_num, state, percent);
   }
 } /* }}} void cpu_commit_one */
 
 /* Commits the number of cores */
-static void cpu_commit_num_cpu(gauge_t num_cpu) /* {{{ */
+static void cpu_commit_num_cpu(gauge_t value) /* {{{ */
 {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = num_cpu;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "cpu", sizeof(vl.plugin));
   sstrncpy(vl.type, "count", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* }}} void cpu_commit_num_cpu */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/cpufreq.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/cpufreq.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/cpufreq.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/cpufreq.c	2016-12-12 16:03:36.704279144 +0800
@@ -22,14 +22,12 @@
 
 #include "collectd.h"
 
 #include "common.h"
 #include "plugin.h"
 
-#define MODULE_NAME "cpufreq"
-
 static int num_cpu = 0;
 
 static int cpufreq_init(void) {
   int status;
   char filename[256];
 
@@ -54,66 +52,40 @@
   if (num_cpu == 0)
     plugin_unregister_read("cpufreq");
 
   return (0);
 } /* int cpufreq_init */
 
-static void cpufreq_submit(int cpu_num, double value) {
-  value_t values[1];
+static void cpufreq_submit(int cpu_num, value_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &value;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "cpufreq", sizeof(vl.plugin));
   sstrncpy(vl.type, "cpufreq", sizeof(vl.type));
   ssnprintf(vl.type_instance, sizeof(vl.type_instance), "%i", cpu_num);
 
   plugin_dispatch_values(&vl);
 }
 
 static int cpufreq_read(void) {
-  int status;
-  unsigned long long val;
-  FILE *fp;
-  char filename[256];
-  char buffer[16];
-
   for (int i = 0; i < num_cpu; i++) {
-    status = ssnprintf(filename, sizeof(filename),
-                       "/sys/devices/system/cpu/cpu%d/cpufreq/"
-                       "scaling_cur_freq",
-                       i);
-    if ((status < 1) || ((unsigned int)status >= sizeof(filename)))
-      return (-1);
-
-    if ((fp = fopen(filename, "r")) == NULL) {
-      char errbuf[1024];
-      WARNING("cpufreq: fopen (%s): %s", filename,
-              sstrerror(errno, errbuf, sizeof(errbuf)));
-      return (-1);
-    }
-
-    if (fgets(buffer, 16, fp) == NULL) {
-      char errbuf[1024];
-      WARNING("cpufreq: fgets: %s", sstrerror(errno, errbuf, sizeof(errbuf)));
-      fclose(fp);
-      return (-1);
-    }
-
-    if (fclose(fp)) {
-      char errbuf[1024];
-      WARNING("cpufreq: fclose: %s", sstrerror(errno, errbuf, sizeof(errbuf)));
+    char filename[PATH_MAX];
+    ssnprintf(filename, sizeof(filename),
+              "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_cur_freq", i);
+
+    value_t v;
+    if (parse_value_file(filename, &v, DS_TYPE_GAUGE) != 0) {
+      WARNING("cpufreq plugin: Reading \"%s\" failed.", filename);
+      continue;
     }
 
-    /* You're seeing correctly: The file is reporting kHz values.. */
-    val = atoll(buffer) * 1000;
+    /* convert kHz to Hz */
+    v.gauge *= 1000.0;
 
-    cpufreq_submit(i, val);
+    cpufreq_submit(i, v);
   }
 
   return (0);
 } /* int cpufreq_read */
 
 void module_register(void) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/cpusleep.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/cpusleep.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/cpusleep.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/cpusleep.c	2016-12-12 16:03:36.704279144 +0800
@@ -34,20 +34,16 @@
 
 #include <time.h>
 #include "common.h"
 #include "plugin.h"
 
 static void cpusleep_submit(derive_t cpu_sleep) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = cpu_sleep;
-
-  vl.values = values;
+  vl.values = &(value_t){.derive = cpu_sleep};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "cpusleep", sizeof(vl.plugin));
   sstrncpy(vl.type, "total_time_in_ms", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/curl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/curl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/curl.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/curl.c	2016-12-12 16:03:36.704279144 +0800
@@ -344,12 +344,13 @@
 
   curl_easy_setopt(wp->curl, CURLOPT_NOSIGNAL, 1L);
   curl_easy_setopt(wp->curl, CURLOPT_WRITEFUNCTION, cc_curl_callback);
   curl_easy_setopt(wp->curl, CURLOPT_WRITEDATA, wp);
   curl_easy_setopt(wp->curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
   curl_easy_setopt(wp->curl, CURLOPT_ERRORBUFFER, wp->curl_errbuf);
+  curl_easy_setopt(wp->curl, CURLOPT_URL, wp->url);
   curl_easy_setopt(wp->curl, CURLOPT_FOLLOWLOCATION, 1L);
   curl_easy_setopt(wp->curl, CURLOPT_MAXREDIRS, 50L);
 
   if (wp->user != NULL) {
 #ifdef HAVE_CURLOPT_USERNAME
     curl_easy_setopt(wp->curl, CURLOPT_USERNAME, wp->user);
@@ -558,57 +559,45 @@
   }
   curl_global_init(CURL_GLOBAL_SSL);
   return (0);
 } /* }}} int cc_init */
 
 static void cc_submit(const web_page_t *wp, const web_match_t *wm, /* {{{ */
-                      const cu_match_value_t *mv) {
-  value_t values[1];
+                      value_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0] = mv->value;
-
-  vl.values = values;
+  vl.values = &value;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "curl", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, wp->instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, wm->type, sizeof(vl.type));
   if (wm->instance != NULL)
     sstrncpy(vl.type_instance, wm->instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* }}} void cc_submit */
 
 static void cc_submit_response_code(const web_page_t *wp, long code) /* {{{ */
 {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = code;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = (gauge_t)code};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "curl", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, wp->instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "response_code", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* }}} void cc_submit_response_code */
 
 static void cc_submit_response_time(const web_page_t *wp, /* {{{ */
-                                    cdtime_t response_time) {
-  value_t values[1];
+                                    gauge_t response_time) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = CDTIME_T_TO_DOUBLE(response_time);
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = response_time};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "curl", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, wp->instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "response_time", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* }}} void cc_submit_response_time */
@@ -619,24 +608,21 @@
   cdtime_t start = 0;
 
   if (wp->response_time)
     start = cdtime();
 
   wp->buffer_fill = 0;
-
-  curl_easy_setopt(wp->curl, CURLOPT_URL, wp->url);
-
   status = curl_easy_perform(wp->curl);
   if (status != CURLE_OK) {
     ERROR("curl plugin: curl_easy_perform failed with status %i: %s", status,
           wp->curl_errbuf);
     return (-1);
   }
 
   if (wp->response_time)
-    cc_submit_response_time(wp, cdtime() - start);
+    cc_submit_response_time(wp, CDTIME_T_TO_DOUBLE(cdtime() - start));
   if (wp->stats != NULL)
     curl_stats_dispatch(wp->stats, wp->curl, hostname_g, "curl", wp->instance);
 
   if (wp->response_code) {
     long response_code = 0;
     status =
@@ -661,13 +647,13 @@
     mv = match_get_user_data(wm->match);
     if (mv == NULL) {
       WARNING("curl plugin: match_get_user_data returned NULL.");
       continue;
     }
 
-    cc_submit(wp, wm, mv);
+    cc_submit(wp, wm, mv->value);
     match_value_reset(mv);
   } /* for (wm = wp->matches; wm != NULL; wm = wm->next) */
 
   return (0);
 } /* }}} int cc_read_page */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/curl_json.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/curl_json.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/curl_json.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/curl_json.c	2016-12-12 16:03:36.704279144 +0800
@@ -168,172 +168,165 @@
         key->type);
   }
 
   return ds->ds[0].type;
 }
 
-/* cj_load_key loads the configuration for "key" from the parent context and
- * sets either .key or .tree in the current context. */
-static int cj_load_key(cj_t *db, char const *key) {
-  if (db == NULL || key == NULL || db->depth <= 0)
-    return EINVAL;
+static int cj_cb_map_key(void *ctx, const unsigned char *val, yajl_len_t len);
 
-  sstrncpy(db->state[db->depth].name, key, sizeof(db->state[db->depth].name));
-
-  c_avl_tree_t *tree = db->state[db->depth - 1].tree;
-  if (tree == NULL) {
-    return 0;
-  }
-
-  /* the parent has a key, so the tree pointer is invalid. */
-  if (CJ_IS_KEY(db->state[db->depth - 1].key)) {
-    return 0;
-  }
-
-  void *value = NULL;
-  if (c_avl_get(tree, key, (void *)&value) == 0) {
-    if (CJ_IS_KEY((cj_key_t *)value)) {
-      db->state[db->depth].key = value;
-    } else {
-      db->state[db->depth].tree = value;
-    }
-  } else if (c_avl_get(tree, CJ_ANY, (void *)&value) == 0) {
-    if (CJ_IS_KEY((cj_key_t *)value)) {
-      db->state[db->depth].key = value;
-    } else {
-      db->state[db->depth].tree = value;
-    }
-  } else {
-    db->state[db->depth].key = NULL;
-  }
-
-  return 0;
-}
+static void cj_cb_inc_array_index(void *ctx, _Bool update_key) {
+  cj_t *db = (cj_t *)ctx;
 
-static void cj_advance_array(cj_t *db) {
   if (!db->state[db->depth].in_array)
     return;
 
   db->state[db->depth].index++;
 
-  char name[DATA_MAX_NAME_LEN];
-  ssnprintf(name, sizeof(name), "%d", db->state[db->depth].index);
-  cj_load_key(db, name);
+  if (update_key) {
+    char name[DATA_MAX_NAME_LEN];
+
+    ssnprintf(name, sizeof(name), "%d", db->state[db->depth].index - 1);
+
+    cj_cb_map_key(ctx, (unsigned char *)name, (yajl_len_t)strlen(name));
+  }
 }
 
 /* yajl callbacks */
 #define CJ_CB_ABORT 0
 #define CJ_CB_CONTINUE 1
 
 static int cj_cb_boolean(void *ctx, int boolVal) {
-  cj_advance_array(ctx);
+  cj_cb_inc_array_index(ctx, /* update_key = */ 0);
   return (CJ_CB_CONTINUE);
 }
 
 static int cj_cb_null(void *ctx) {
-  cj_advance_array(ctx);
+  cj_cb_inc_array_index(ctx, /* update_key = */ 0);
   return (CJ_CB_CONTINUE);
 }
 
 static int cj_cb_number(void *ctx, const char *number, yajl_len_t number_len) {
   char buffer[number_len + 1];
 
   cj_t *db = (cj_t *)ctx;
   cj_key_t *key = db->state[db->depth].key;
+  value_t vt;
+  int type;
+  int status;
 
   /* Create a null-terminated version of the string. */
   memcpy(buffer, number, number_len);
   buffer[sizeof(buffer) - 1] = 0;
 
+  if ((key == NULL) || !CJ_IS_KEY(key)) {
+    if (key != NULL &&
+        !db->state[db->depth].in_array /*can be inhomogeneous*/) {
+      NOTICE("curl_json plugin: Found \"%s\", but the configuration expects"
+             " a map.",
+             buffer);
+      return (CJ_CB_CONTINUE);
+    }
 
-
-  if (key == NULL) {
-    /* no config for this element. */
-    cj_advance_array(ctx);
-    return CJ_CB_CONTINUE;
-  } else if (!CJ_IS_KEY(key)) {
-    /* the config expects a map or an array. */
-    NOTICE(
-        "curl_json plugin: Found \"%s\", but the configuration expects a map.",
-        buffer);
-    cj_advance_array(ctx);
-    return CJ_CB_CONTINUE;
+    cj_cb_inc_array_index(ctx, /* update_key = */ 1);
+    key = db->state[db->depth].key;
+    if ((key == NULL) || !CJ_IS_KEY(key)) {
+      return (CJ_CB_CONTINUE);
+    }
+  } else {
+    cj_cb_inc_array_index(ctx, /* update_key = */ 1);
   }
 
-  int type = cj_get_type(key);
-  value_t vt;
-  int status = parse_value(buffer, &vt, type);
+  type = cj_get_type(key);
+  status = parse_value(buffer, &vt, type);
   if (status != 0) {
     NOTICE("curl_json plugin: Unable to parse number: \"%s\"", buffer);
-    cj_advance_array(ctx);
     return (CJ_CB_CONTINUE);
   }
 
   cj_submit(db, key, &vt);
-  cj_advance_array(ctx);
   return (CJ_CB_CONTINUE);
 } /* int cj_cb_number */
 
 /* Queries the key-tree of the parent context for "in_name" and, if found,
  * updates the "key" field of the current context. Otherwise, "key" is set to
  * NULL. */
 static int cj_cb_map_key(void *ctx, unsigned char const *in_name,
                          yajl_len_t in_name_len) {
-  char name[in_name_len + 1];
+  cj_t *db = (cj_t *)ctx;
+  c_avl_tree_t *tree;
 
-  memmove(name, in_name, in_name_len);
-  name[sizeof(name) - 1] = 0;
+  tree = db->state[db->depth - 1].tree;
 
-  if (cj_load_key(ctx, name) != 0)
-    return CJ_CB_ABORT;
+  if (tree != NULL) {
+    cj_key_t *value = NULL;
+    char *name;
+    size_t name_len;
+
+    /* Create a null-terminated version of the name. */
+    name = db->state[db->depth].name;
+    name_len =
+        COUCH_MIN((size_t)in_name_len, sizeof(db->state[db->depth].name) - 1);
+    memcpy(name, in_name, name_len);
+    name[name_len] = 0;
+
+    if (c_avl_get(tree, name, (void *)&value) == 0) {
+      if (CJ_IS_KEY((cj_key_t *)value)) {
+        db->state[db->depth].key = value;
+      } else {
+        db->state[db->depth].tree = (c_avl_tree_t *)value;
+      }
+    } else if (c_avl_get(tree, CJ_ANY, (void *)&value) == 0)
+      if (CJ_IS_KEY((cj_key_t *)value)) {
+        db->state[db->depth].key = value;
+      } else {
+        db->state[db->depth].tree = (c_avl_tree_t *)value;
+      }
+    else
+      db->state[db->depth].key = NULL;
+  }
 
-  return CJ_CB_CONTINUE;
+  return (CJ_CB_CONTINUE);
 }
 
 static int cj_cb_string(void *ctx, const unsigned char *val, yajl_len_t len) {
   /* Handle the string as if it was a number. */
   return (cj_cb_number(ctx, (const char *)val, len));
 } /* int cj_cb_string */
 
+static int cj_cb_start(void *ctx) {
+  cj_t *db = (cj_t *)ctx;
+  if (++db->depth >= YAJL_MAX_DEPTH) {
+    ERROR("curl_json plugin: %s depth exceeds max, aborting.",
+          db->url ? db->url : db->sock);
+    return (CJ_CB_ABORT);
+  }
+  return (CJ_CB_CONTINUE);
+}
+
 static int cj_cb_end(void *ctx) {
   cj_t *db = (cj_t *)ctx;
   db->state[db->depth].tree = NULL;
-  db->depth--;
-  cj_advance_array(ctx);
+  --db->depth;
   return (CJ_CB_CONTINUE);
 }
 
 static int cj_cb_start_map(void *ctx) {
-  cj_t *db = (cj_t *)ctx;
-
-  if ((db->depth + 1) >= YAJL_MAX_DEPTH) {
-    ERROR("curl_json plugin: %s depth exceeds max, aborting.",
-          db->url ? db->url : db->sock);
-    return (CJ_CB_ABORT);
-  }
-  db->depth++;
-  return (CJ_CB_CONTINUE);
+  cj_cb_inc_array_index(ctx, /* update_key = */ 1);
+  return cj_cb_start(ctx);
 }
 
 static int cj_cb_end_map(void *ctx) { return cj_cb_end(ctx); }
 
 static int cj_cb_start_array(void *ctx) {
   cj_t *db = (cj_t *)ctx;
-
-  if ((db->depth + 1) >= YAJL_MAX_DEPTH) {
-    ERROR("curl_json plugin: %s depth exceeds max, aborting.",
-          db->url ? db->url : db->sock);
-    return CJ_CB_ABORT;
+  cj_cb_inc_array_index(ctx, /* update_key = */ 1);
+  if (db->depth + 1 < YAJL_MAX_DEPTH) {
+    db->state[db->depth + 1].in_array = 1;
+    db->state[db->depth + 1].index = 0;
   }
-  db->depth++;
-  db->state[db->depth].in_array = 1;
-  db->state[db->depth].index = 0;
-
-  cj_load_key(db, "0");
-
-  return CJ_CB_CONTINUE;
+  return cj_cb_start(ctx);
 }
 
 static int cj_cb_end_array(void *ctx) {
   cj_t *db = (cj_t *)ctx;
   db->state[db->depth].in_array = 0;
   return cj_cb_end(ctx);
@@ -559,12 +552,13 @@
 
   curl_easy_setopt(db->curl, CURLOPT_NOSIGNAL, 1L);
   curl_easy_setopt(db->curl, CURLOPT_WRITEFUNCTION, cj_curl_callback);
   curl_easy_setopt(db->curl, CURLOPT_WRITEDATA, db);
   curl_easy_setopt(db->curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
   curl_easy_setopt(db->curl, CURLOPT_ERRORBUFFER, db->curl_errbuf);
+  curl_easy_setopt(db->curl, CURLOPT_URL, db->url);
   curl_easy_setopt(db->curl, CURLOPT_FOLLOWLOCATION, 1L);
   curl_easy_setopt(db->curl, CURLOPT_MAXREDIRS, 50L);
 
   if (db->user != NULL) {
 #ifdef HAVE_CURLOPT_USERNAME
     curl_easy_setopt(db->curl, CURLOPT_USERNAME, db->user);
@@ -603,13 +597,13 @@
 
 #ifdef HAVE_CURLOPT_TIMEOUT_MS
   if (db->timeout >= 0)
     curl_easy_setopt(db->curl, CURLOPT_TIMEOUT_MS, (long)db->timeout);
   else if (db->interval > 0)
     curl_easy_setopt(db->curl, CURLOPT_TIMEOUT_MS,
-                     (long)CDTIME_T_TO_MS(db->interval));
+                     (long)CDTIME_T_TO_MS(db->timeout));
   else
     curl_easy_setopt(db->curl, CURLOPT_TIMEOUT_MS,
                      (long)CDTIME_T_TO_MS(plugin_get_interval()));
 #endif
 
   return (0);
@@ -712,16 +706,17 @@
 
     DEBUG("curl_json plugin: Registering new read callback: %s", db->instance);
 
     cb_name = ssnprintf_alloc("curl_json-%s-%s", db->instance,
                               db->url ? db->url : db->sock);
 
-    user_data_t ud = {.data = db, .free_func = cj_free};
-
     plugin_register_complex_read(/* group = */ NULL, cb_name, cj_read,
-                                 /* interval = */ db->interval, &ud);
+                                 /* interval = */ db->interval,
+                                 &(user_data_t){
+                                     .data = db, .free_func = cj_free,
+                                 });
     sfree(cb_name);
   } else {
     cj_free(db);
     return (-1);
   }
 
@@ -836,19 +831,18 @@
 
 static int cj_curl_perform(cj_t *db) /* {{{ */
 {
   int status;
   long rc;
   char *url;
-
-  curl_easy_setopt(db->curl, CURLOPT_URL, db->url);
+  url = db->url;
 
   status = curl_easy_perform(db->curl);
   if (status != CURLE_OK) {
     ERROR("curl_json plugin: curl_easy_perform failed with status %i: %s (%s)",
-          status, db->curl_errbuf, db->url);
+          status, db->curl_errbuf, url);
     return (-1);
   }
   if (db->stats != NULL)
     curl_stats_dispatch(db->stats, db->curl, cj_host(db), "curl_json",
                         db->instance);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/curl_xml.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/curl_xml.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/curl_xml.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/curl_xml.c	2016-12-12 16:03:36.704279144 +0800
@@ -599,21 +599,19 @@
 static int cx_curl_perform(cx_t *db, CURL *curl) /* {{{ */
 {
   int status;
   long rc;
   char *ptr;
   char *url;
+  url = db->url;
 
   db->buffer_fill = 0;
-
-  curl_easy_setopt(db->curl, CURLOPT_URL, db->url);
-
   status = curl_easy_perform(curl);
   if (status != CURLE_OK) {
     ERROR("curl_xml plugin: curl_easy_perform failed with status %i: %s (%s)",
-          status, db->curl_errbuf, db->url);
+          status, db->curl_errbuf, url);
     return (-1);
   }
   if (db->stats != NULL)
     curl_stats_dispatch(db->stats, db->curl, cx_host(db), "curl_xml",
                         db->instance);
 
@@ -816,12 +814,13 @@
 
   curl_easy_setopt(db->curl, CURLOPT_NOSIGNAL, 1L);
   curl_easy_setopt(db->curl, CURLOPT_WRITEFUNCTION, cx_curl_callback);
   curl_easy_setopt(db->curl, CURLOPT_WRITEDATA, db);
   curl_easy_setopt(db->curl, CURLOPT_USERAGENT, COLLECTD_USERAGENT);
   curl_easy_setopt(db->curl, CURLOPT_ERRORBUFFER, db->curl_errbuf);
+  curl_easy_setopt(db->curl, CURLOPT_URL, db->url);
   curl_easy_setopt(db->curl, CURLOPT_FOLLOWLOCATION, 1L);
   curl_easy_setopt(db->curl, CURLOPT_MAXREDIRS, 50L);
 
   if (db->user != NULL) {
 #ifdef HAVE_CURLOPT_USERNAME
     curl_easy_setopt(db->curl, CURLOPT_USERNAME, db->user);
@@ -964,16 +963,17 @@
       db->instance = strdup("default");
 
     DEBUG("curl_xml plugin: Registering new read callback: %s", db->instance);
 
     cb_name = ssnprintf_alloc("curl_xml-%s-%s", db->instance, db->url);
 
-    user_data_t ud = {.data = db, .free_func = cx_free};
-
     plugin_register_complex_read(/* group = */ "curl_xml", cb_name, cx_read,
-                                 /* interval = */ 0, &ud);
+                                 /* interval = */ 0,
+                                 &(user_data_t){
+                                     .data = db, .free_func = cx_free,
+                                 });
     sfree(cb_name);
   } else {
     cx_free(db);
     return (-1);
   }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/collectd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/collectd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/collectd.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/collectd.c	2016-12-12 16:03:36.704279144 +0800
@@ -89,13 +89,13 @@
   const char *str;
 
   struct addrinfo *ai_list;
   int status;
 
   str = global_option_get("Hostname");
-  if (str != NULL) {
+  if ((str != NULL) && (str[0] != 0)) {
     sstrncpy(hostname_g, str, sizeof(hostname_g));
     return (0);
   }
 
   if (gethostname(hostname_g, sizeof(hostname_g)) != 0) {
     fprintf(stderr, "`gethostname' failed and no "
@@ -301,13 +301,12 @@
   cdtime_t interval = cf_get_default_interval();
   cdtime_t wait_until;
 
   wait_until = cdtime() + interval;
 
   while (loop == 0) {
-    struct timespec ts_wait = {0, 0};
     cdtime_t now;
 
 #if HAVE_LIBKSTAT
     update_kstat();
 #endif
 
@@ -320,13 +319,13 @@
               "%.3f seconds in the past!",
               CDTIME_T_TO_DOUBLE(now - wait_until));
       wait_until = now + interval;
       continue;
     }
 
-    CDTIME_T_TO_TIMESPEC(wait_until - now, &ts_wait);
+    struct timespec ts_wait = CDTIME_T_TO_TIMESPEC(wait_until - now);
     wait_until = wait_until + interval;
 
     while ((loop == 0) && (nanosleep(&ts_wait, &ts_wait) != 0)) {
       if (errno != EINTR) {
         char errbuf[1024];
         ERROR("nanosleep failed: %s", sstrerror(errno, errbuf, sizeof(errbuf)));
@@ -519,13 +518,13 @@
    * line (in that order, with later options overwriting previous ones in
    * general).
    * Also, this will automatically load modules.
    */
   if (cf_read(configfile)) {
     fprintf(stderr, "Error: Reading the config file failed!\n"
-                    "Read the logs for details.\n");
+                    "Read the syslog for details.\n");
     return (1);
   }
 
   /*
    * Change directory. We do this _after_ reading the config and loading
    * modules to relative paths work as expected.
@@ -543,13 +542,13 @@
    * Set global variables or, if that failes, exit. We cannot run with
    * them being uninitialized. If nothing is configured, then defaults
    * are being used. So this means that the user has actually done
    * something wrong.
    */
   if (init_global_variables() != 0)
-    return (1);
+    exit(EXIT_FAILURE);
 
   if (test_config)
     return (0);
 
 #if COLLECT_DAEMON
   /*
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/common.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/common.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/common.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/common.c	2016-12-12 16:03:36.704279144 +0800
@@ -322,50 +322,64 @@
 
   return ((int)i);
 }
 
 int strjoin(char *buffer, size_t buffer_size, char **fields, size_t fields_num,
             const char *sep) {
-  size_t avail;
-  char *ptr;
-  size_t sep_len;
+  size_t avail = 0;
+  char *ptr = buffer;
+  size_t sep_len = 0;
 
-  if ((buffer_size < 1) || (fields_num == 0))
-    return (-1);
+  size_t buffer_req = 0;
+
+  if (((fields_num != 0) && (fields == NULL)) ||
+      ((buffer_size != 0) && (buffer == NULL)))
+    return (-EINVAL);
+
+  if (buffer != NULL)
+    buffer[0] = 0;
 
-  memset(buffer, 0, buffer_size);
-  ptr = buffer;
-  avail = buffer_size - 1;
+  if (buffer_size != 0)
+    avail = buffer_size - 1;
 
-  sep_len = 0;
   if (sep != NULL)
     sep_len = strlen(sep);
 
   for (size_t i = 0; i < fields_num; i++) {
-    size_t field_len;
+    size_t field_len = strlen(fields[i]);
 
-    if ((i > 0) && (sep_len > 0)) {
-      if (avail < sep_len)
-        return (-1);
+    if (i != 0)
+      buffer_req += sep_len;
+    buffer_req += field_len;
+
+    if ((i != 0) && (sep_len > 0)) {
+      if (sep_len >= avail) {
+        /* prevent subsequent iterations from writing to the
+         * buffer. */
+        avail = 0;
+        continue;
+      }
 
       memcpy(ptr, sep, sep_len);
+
       ptr += sep_len;
       avail -= sep_len;
     }
 
-    field_len = strlen(fields[i]);
-    if (avail < field_len)
-      return (-1);
+    if (field_len > avail)
+      field_len = avail;
 
     memcpy(ptr, fields[i], field_len);
     ptr += field_len;
+
     avail -= field_len;
+    if (ptr != NULL)
+      *ptr = 0;
   }
 
-  assert(buffer[buffer_size - 1] == 0);
-  return ((int)strlen(buffer));
+  return (int)buffer_req;
 }
 
 int escape_string(char *buffer, size_t buffer_size) {
   char *temp;
   size_t j;
 
@@ -913,13 +927,13 @@
   sfree(rates);
   return (0);
 } /* }}} int format_values */
 
 int parse_identifier(char *str, char **ret_host, char **ret_plugin,
                      char **ret_plugin_instance, char **ret_type,
-                     char **ret_type_instance) {
+                     char **ret_type_instance, char *default_host) {
   char *hostname = NULL;
   char *plugin = NULL;
   char *plugin_instance = NULL;
   char *type = NULL;
   char *type_instance = NULL;
 
@@ -931,16 +945,23 @@
   if (plugin == NULL)
     return (-1);
   *plugin = '\0';
   plugin++;
 
   type = strchr(plugin, '/');
-  if (type == NULL)
-    return (-1);
-  *type = '\0';
-  type++;
+  if (type == NULL) {
+    if (default_host == NULL)
+      return (-1);
+    /* else: no host specified; use default */
+    type = plugin;
+    plugin = hostname;
+    hostname = default_host;
+  } else {
+    *type = '\0';
+    type++;
+  }
 
   plugin_instance = strchr(plugin, '-');
   if (plugin_instance != NULL) {
     *plugin_instance = '\0';
     plugin_instance++;
   }
@@ -972,13 +993,14 @@
   if ((str == NULL) || (vl == NULL))
     return (EINVAL);
 
   sstrncpy(str_copy, str, sizeof(str_copy));
 
   status = parse_identifier(str_copy, &host, &plugin, &plugin_instance, &type,
-                            &type_instance);
+                            &type_instance,
+                            /* default_host = */ NULL);
   if (status != 0)
     return (status);
 
   sstrncpy(vl->host, host, sizeof(vl->host));
   sstrncpy(vl->plugin, plugin, sizeof(vl->plugin));
   sstrncpy(vl->plugin_instance,
@@ -1099,12 +1121,32 @@
 
   if ((ptr != NULL) || (i == 0))
     return (-1);
   return (0);
 } /* int parse_values */
 
+int parse_value_file(char const *path, value_t *ret_value, int ds_type) {
+  FILE *fh;
+  char buffer[256];
+
+  fh = fopen(path, "r");
+  if (fh == NULL)
+    return (-1);
+
+  if (fgets(buffer, sizeof(buffer), fh) == NULL) {
+    fclose(fh);
+    return (-1);
+  }
+
+  fclose(fh);
+
+  strstripnewline(buffer);
+
+  return parse_value(buffer, ret_value, ds_type);
+} /* int parse_value_file */
+
 #if !HAVE_GETPWNAM_R
 int getpwnam_r(const char *name, struct passwd *pwbuf, char *buf, size_t buflen,
                struct passwd **pwbufp) {
   int status = 0;
   struct passwd *pw;
 
@@ -1419,24 +1461,22 @@
 
 void set_sock_opts(int sockfd) /* {{{ */
 {
   int status;
   int socktype;
 
-  socklen_t socklen = sizeof(socklen_t);
-  int so_keepalive = 1;
-
-  status = getsockopt(sockfd, SOL_SOCKET, SO_TYPE, &socktype, &socklen);
+  status = getsockopt(sockfd, SOL_SOCKET, SO_TYPE, &socktype,
+                      &(socklen_t){sizeof(socktype)});
   if (status != 0) {
     WARNING("set_sock_opts: failed to determine socket type");
     return;
   }
 
   if (socktype == SOCK_STREAM) {
-    status = setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &so_keepalive,
-                        sizeof(so_keepalive));
+    status =
+        setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &(int){1}, sizeof(int));
     if (status != 0)
       WARNING("set_sock_opts: failed to set socket keepalive flag");
 
 #ifdef TCP_KEEPIDLE
     int tcp_keepidle = ((CDTIME_T_TO_MS(plugin_get_interval()) - 1) / 100 + 1);
     status = setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPIDLE, &tcp_keepidle,
@@ -1524,32 +1564,22 @@
   sfree(array);
 } /* }}} void strarray_free */
 
 #if HAVE_CAPABILITY
 int check_capability(int arg) /* {{{ */
 {
-  cap_value_t cap_value = (cap_value_t)arg;
-  cap_t cap;
-  cap_flag_value_t cap_flag_value;
-
-  if (!CAP_IS_SUPPORTED(cap_value))
-    return (-1);
+  cap_value_t cap = (cap_value_t)arg;
 
-  if (!(cap = cap_get_proc())) {
-    ERROR("check_capability: cap_get_proc failed.");
+  if (!CAP_IS_SUPPORTED(cap))
     return (-1);
-  }
 
-  if (cap_get_flag(cap, cap_value, CAP_EFFECTIVE, &cap_flag_value) < 0) {
-    ERROR("check_capability: cap_get_flag failed.");
-    cap_free(cap);
+  int have_cap = cap_get_bound(cap);
+  if (have_cap != 1)
     return (-1);
-  }
-  cap_free(cap);
 
-  return (cap_flag_value != CAP_SET);
+  return (0);
 } /* }}} int check_capability */
 #else
 int check_capability(__attribute__((unused)) int arg) /* {{{ */
 {
   WARNING("check_capability: unsupported capability implementation. "
           "Some plugin(s) may require elevated privileges to work properly.");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/common.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/common.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/common.h	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/common.h	2016-12-12 16:03:36.704279144 +0800
@@ -142,26 +142,29 @@
  *
  * DESCRIPTION
  *   Joins together several parts of a string using `sep' as a separator. This
  *   is equivalent to the Perl built-in `join'.
  *
  * PARAMETERS
- *   `dst'         Buffer where the result is stored.
+ *   `dst'         Buffer where the result is stored. Can be NULL if you need to
+ *                 determine the required buffer size only.
  *   `dst_len'     Length of the destination buffer. No more than this many
  *                 bytes will be written to the memory pointed to by `dst',
- *                 including the trailing null-byte.
+ *                 including the trailing null-byte. Must be zero if dst is
+ *                 NULL.
  *   `fields'      Array of strings to be joined.
  *   `fields_num'  Number of elements in the `fields' array.
  *   `sep'         String to be inserted between any two elements of `fields'.
  *                 This string is neither prepended nor appended to the result.
  *                 Instead of passing "" (empty string) one can pass NULL.
  *
  * RETURN VALUE
- *   Returns the number of characters in `dst', NOT including the trailing
- *   null-byte. If an error occurred (empty array or `dst' too small) a value
- *   smaller than zero will be returned.
+ *   Returns the number of characters in the resulting string, excluding a
+ *   tailing null byte. If this value is greater than or equal to "dst_len", the
+ *   result in "dst" is truncated (but still null terminated). On error a
+ *   negative value is returned.
  */
 int strjoin(char *dst, size_t dst_len, char **fields, size_t fields_num,
             const char *sep);
 
 /*
  * NAME
@@ -311,17 +314,23 @@
               (vl)->type, (vl)->type_instance)
 int format_values(char *ret, size_t ret_len, const data_set_t *ds,
                   const value_list_t *vl, _Bool store_rates);
 
 int parse_identifier(char *str, char **ret_host, char **ret_plugin,
                      char **ret_plugin_instance, char **ret_type,
-                     char **ret_type_instance);
+                     char **ret_type_instance, char *default_host);
 int parse_identifier_vl(const char *str, value_list_t *vl);
 int parse_value(const char *value, value_t *ret_value, int ds_type);
 int parse_values(char *buffer, value_list_t *vl, const data_set_t *ds);
 
+/* parse_value_file reads "path" and parses its content as an integer or
+ * floating point, depending on "ds_type". On success, the value is stored in
+ * "ret_value" and zero is returned. On failure, a non-zero value is returned.
+ */
+int parse_value_file(char const *path, value_t *ret_value, int ds_type);
+
 #if !HAVE_GETPWNAM_R
 int getpwnam_r(const char *name, struct passwd *pwbuf, char *buf, size_t buflen,
                struct passwd **pwbufp);
 #endif
 
 int notification_init(notification_t *n, int severity, const char *message,
@@ -373,10 +382,10 @@
 
 #ifdef HAVE_SYS_CAPABILITY_H
 /** Check if the current process benefits from the capability passed in
  * argument. Returns zero if it does, less than zero if it doesn't or on error.
  * See capabilities(7) for the list of possible capabilities.
  * */
-int check_capability(int arg);
+int check_capability(int capability);
 #endif /* HAVE_SYS_CAPABILITY_H */
 
 #endif /* COMMON_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/common_test.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/common_test.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/common_test.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/common_test.c	2016-12-12 16:03:36.704279144 +0800
@@ -142,50 +142,56 @@
   OK(status == 0);
 
   return (0);
 }
 
 DEF_TEST(strjoin) {
-  char buffer[16];
-  char *fields[4];
-  int status;
+  struct {
+    char **fields;
+    size_t fields_num;
+    char *separator;
 
-  fields[0] = "foo";
-  fields[1] = "bar";
-  fields[2] = "baz";
-  fields[3] = "qux";
-
-  status = strjoin(buffer, sizeof(buffer), fields, 2, "!");
-  OK(status == 7);
-  EXPECT_EQ_STR("foo!bar", buffer);
-
-  status = strjoin(buffer, sizeof(buffer), fields, 1, "!");
-  OK(status == 3);
-  EXPECT_EQ_STR("foo", buffer);
-
-  status = strjoin(buffer, sizeof(buffer), fields, 0, "!");
-  OK(status < 0);
-
-  status = strjoin(buffer, sizeof(buffer), fields, 2, "rcht");
-  OK(status == 10);
-  EXPECT_EQ_STR("foorchtbar", buffer);
-
-  status = strjoin(buffer, sizeof(buffer), fields, 4, "");
-  OK(status == 12);
-  EXPECT_EQ_STR("foobarbazqux", buffer);
-
-  status = strjoin(buffer, sizeof(buffer), fields, 4, "!");
-  OK(status == 15);
-  EXPECT_EQ_STR("foo!bar!baz!qux", buffer);
-
-  fields[0] = "0123";
-  fields[1] = "4567";
-  fields[2] = "8901";
-  fields[3] = "2345";
-  status = strjoin(buffer, sizeof(buffer), fields, 4, "-");
-  OK(status < 0);
+    int want_return;
+    char *want_buffer;
+  } cases[] = {
+      /* Normal case. */
+      {(char *[]){"foo", "bar"}, 2, "!", 7, "foo!bar"},
+      /* One field only. */
+      {(char *[]){"foo"}, 1, "!", 3, "foo"},
+      /* No fields at all. */
+      {NULL, 0, "!", 0, ""},
+      /* Longer separator. */
+      {(char *[]){"foo", "bar"}, 2, "rcht", 10, "foorchtbar"},
+      /* Empty separator. */
+      {(char *[]){"foo", "bar"}, 2, "", 6, "foobar"},
+      /* NULL separator. */
+      {(char *[]){"foo", "bar"}, 2, NULL, 6, "foobar"},
+      /* buffer not large enough -> string is truncated. */
+      {(char *[]){"aaaaaa", "bbbbbb", "c!"}, 3, "-", 16, "aaaaaa-bbbbbb-c"},
+      /* buffer not large enough -> last field fills buffer completely. */
+      {(char *[]){"aaaaaaa", "bbbbbbb", "!"}, 3, "-", 17, "aaaaaaa-bbbbbbb"},
+      /* buffer not large enough -> string does *not* end in separator. */
+      {(char *[]){"aaaa", "bbbb", "cccc", "!"}, 4, "-", 16, "aaaa-bbbb-cccc"},
+      /* buffer not large enough -> string does not end with partial
+         separator. */
+      {(char *[]){"aaaaaa", "bbbbbb", "!"}, 3, "+-", 17, "aaaaaa+-bbbbbb"},
+  };
+
+  for (size_t i = 0; i < STATIC_ARRAY_SIZE(cases); i++) {
+    char buffer[16];
+    int status;
+
+    memset(buffer, 0xFF, sizeof(buffer));
+    status = strjoin(buffer, sizeof(buffer), cases[i].fields,
+                     cases[i].fields_num, cases[i].separator);
+    EXPECT_EQ_INT(cases[i].want_return, status);
+    EXPECT_EQ_STR(cases[i].want_buffer, buffer);
+  }
+
+  /* use (NULL, 0) to determine required buffer size. */
+  EXPECT_EQ_INT(3, strjoin(NULL, 0, (char *[]){"a", "b"}, 2, "-"));
 
   return (0);
 }
 
 DEF_TEST(escape_slashes) {
   struct {
@@ -348,24 +354,27 @@
        {.counter = 18446744073709551558ULL},
        {.counter = 42},
        10.0},
   };
 
   for (size_t i = 0; i < STATIC_ARRAY_SIZE(cases); i++) {
-    value_to_rate_state_t state = {cases[i].v0,
-                                   TIME_T_TO_CDTIME_T(cases[i].t0)};
+    cdtime_t t0 = TIME_T_TO_CDTIME_T(cases[i].t0);
+    value_to_rate_state_t state = {
+        .last_value = cases[i].v0, .last_time = t0,
+    };
     gauge_t got;
 
     if (cases[i].t0 == 0) {
-      OK(value_to_rate(&got, cases[i].v1, cases[i].ds_type,
-                       TIME_T_TO_CDTIME_T(cases[i].t1), &state) == EAGAIN);
+      EXPECT_EQ_INT(EAGAIN,
+                    value_to_rate(&got, cases[i].v1, cases[i].ds_type,
+                                  TIME_T_TO_CDTIME_T(cases[i].t1), &state));
       continue;
     }
 
-    OK(value_to_rate(&got, cases[i].v1, cases[i].ds_type,
-                     TIME_T_TO_CDTIME_T(cases[i].t1), &state) == 0);
+    EXPECT_EQ_INT(0, value_to_rate(&got, cases[i].v1, cases[i].ds_type,
+                                   TIME_T_TO_CDTIME_T(cases[i].t1), &state));
     EXPECT_EQ_DOUBLE(cases[i].want, got);
   }
 
   return 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/configfile.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/configfile.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/configfile.c	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/configfile.c	2016-12-12 16:03:36.704279144 +0800
@@ -1116,42 +1116,20 @@
 
 int cf_util_get_boolean(const oconfig_item_t *ci, _Bool *ret_bool) /* {{{ */
 {
   if ((ci == NULL) || (ret_bool == NULL))
     return (EINVAL);
 
-  if ((ci->values_num != 1) || ((ci->values[0].type != OCONFIG_TYPE_BOOLEAN) &&
-                                (ci->values[0].type != OCONFIG_TYPE_STRING))) {
+  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_BOOLEAN)) {
     ERROR("cf_util_get_boolean: The %s option requires "
           "exactly one boolean argument.",
           ci->key);
     return (-1);
   }
 
-  switch (ci->values[0].type) {
-  case OCONFIG_TYPE_BOOLEAN:
-    *ret_bool = ci->values[0].value.boolean ? 1 : 0;
-    break;
-  case OCONFIG_TYPE_STRING:
-    WARNING("cf_util_get_boolean: Using string value `%s' for boolean option "
-            "`%s' is deprecated and will be removed in future releases. "
-            "Use unquoted true or false instead.",
-            ci->values[0].value.string, ci->key);
-
-    if (IS_TRUE(ci->values[0].value.string))
-      *ret_bool = 1;
-    else if (IS_FALSE(ci->values[0].value.string))
-      *ret_bool = 0;
-    else {
-      ERROR("cf_util_get_boolean: Cannot parse string value `%s' of the `%s' "
-            "option as a boolean value.",
-            ci->values[0].value.string, ci->key);
-      return (-1);
-    }
-    break;
-  }
+  *ret_bool = ci->values[0].value.boolean ? 1 : 0;
 
   return (0);
 } /* }}} int cf_util_get_boolean */
 
 int cf_util_get_flag(const oconfig_item_t *ci, /* {{{ */
                      unsigned int *ret_value, unsigned int flag) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/Makefile.am	2017-10-06 14:45:52.941917753 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/Makefile.am	2016-12-12 16:03:36.704279144 +0800
@@ -58,16 +58,13 @@
 		   plugin.c plugin.h \
 		   utils_cache.c utils_cache.h \
 		   utils_complain.c utils_complain.h \
 		   utils_ignorelist.c utils_ignorelist.h \
 		   utils_llist.c utils_llist.h \
 		   utils_random.c utils_random.h \
-		   utils_tail_match.c utils_tail_match.h \
-		   utils_match.c utils_match.h \
 		   utils_subst.c utils_subst.h \
-		   utils_tail.c utils_tail.h \
 		   utils_time.c utils_time.h \
 		   types_list.c types_list.h \
 		   utils_threshold.c utils_threshold.h
 
 
 collectd_CPPFLAGS =  $(AM_CPPFLAGS) $(LTDLINCL)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/Makefile.in	2017-10-06 15:04:19.786135618 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/Makefile.in	2016-12-12 16:03:47.440206540 +0800
@@ -104,20 +104,13 @@
 	test_utils_time$(EXEEXT) test_utils_subst$(EXEEXT)
 subdir = src/daemon
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(top_srcdir)/libltdl/config/depcomp \
 	$(top_srcdir)/libltdl/config/test-driver
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/libltdl/m4/argz.m4 \
-	$(top_srcdir)/libltdl/m4/libtool.m4 \
-	$(top_srcdir)/libltdl/m4/ltdl.m4 \
-	$(top_srcdir)/libltdl/m4/ltoptions.m4 \
-	$(top_srcdir)/libltdl/m4/ltsugar.m4 \
-	$(top_srcdir)/libltdl/m4/ltversion.m4 \
-	$(top_srcdir)/libltdl/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/src/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -154,15 +147,13 @@
 	collectd-configfile.$(OBJEXT) collectd-filter_chain.$(OBJEXT) \
 	collectd-meta_data.$(OBJEXT) collectd-plugin.$(OBJEXT) \
 	collectd-utils_cache.$(OBJEXT) \
 	collectd-utils_complain.$(OBJEXT) \
 	collectd-utils_ignorelist.$(OBJEXT) \
 	collectd-utils_llist.$(OBJEXT) collectd-utils_random.$(OBJEXT) \
-	collectd-utils_tail_match.$(OBJEXT) \
-	collectd-utils_match.$(OBJEXT) collectd-utils_subst.$(OBJEXT) \
-	collectd-utils_tail.$(OBJEXT) collectd-utils_time.$(OBJEXT) \
+	collectd-utils_subst.$(OBJEXT) collectd-utils_time.$(OBJEXT) \
 	collectd-types_list.$(OBJEXT) \
 	collectd-utils_threshold.$(OBJEXT)
 collectd_OBJECTS = $(am_collectd_OBJECTS)
 @BUILD_WITH_LIBSTATGRAB_TRUE@am__DEPENDENCIES_3 =  \
 @BUILD_WITH_LIBSTATGRAB_TRUE@	$(am__DEPENDENCIES_1)
 @BUILD_WITH_OWN_LIBOCONFIG_TRUE@am__DEPENDENCIES_4 =  \
@@ -505,12 +496,15 @@
 BUILD_WITH_LIBLVM2APP_CPPFLAGS = @BUILD_WITH_LIBLVM2APP_CPPFLAGS@
 BUILD_WITH_LIBLVM2APP_LDFLAGS = @BUILD_WITH_LIBLVM2APP_LDFLAGS@
 BUILD_WITH_LIBLVM2APP_LIBS = @BUILD_WITH_LIBLVM2APP_LIBS@
 BUILD_WITH_LIBMEMCACHED_CPPFLAGS = @BUILD_WITH_LIBMEMCACHED_CPPFLAGS@
 BUILD_WITH_LIBMEMCACHED_LDFLAGS = @BUILD_WITH_LIBMEMCACHED_LDFLAGS@
 BUILD_WITH_LIBMEMCACHED_LIBS = @BUILD_WITH_LIBMEMCACHED_LIBS@
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS = @BUILD_WITH_LIBMICROHTTPD_CPPFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS = @BUILD_WITH_LIBMICROHTTPD_LDFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LIBS = @BUILD_WITH_LIBMICROHTTPD_LIBS@
 BUILD_WITH_LIBMNL_CFLAGS = @BUILD_WITH_LIBMNL_CFLAGS@
 BUILD_WITH_LIBMNL_LIBS = @BUILD_WITH_LIBMNL_LIBS@
 BUILD_WITH_LIBMODBUS_CFLAGS = @BUILD_WITH_LIBMODBUS_CFLAGS@
 BUILD_WITH_LIBMODBUS_LIBS = @BUILD_WITH_LIBMODBUS_LIBS@
 BUILD_WITH_LIBMONGOC_CPPFLAGS = @BUILD_WITH_LIBMONGOC_CPPFLAGS@
 BUILD_WITH_LIBMONGOC_LDFLAGS = @BUILD_WITH_LIBMONGOC_LDFLAGS@
@@ -524,12 +518,15 @@
 BUILD_WITH_LIBNETSNMP_LIBS = @BUILD_WITH_LIBNETSNMP_LIBS@
 BUILD_WITH_LIBOPING_CPPFLAGS = @BUILD_WITH_LIBOPING_CPPFLAGS@
 BUILD_WITH_LIBOPING_LDFLAGS = @BUILD_WITH_LIBOPING_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_CPPFLAGS = @BUILD_WITH_LIBOWCAPI_CPPFLAGS@
 BUILD_WITH_LIBOWCAPI_LDFLAGS = @BUILD_WITH_LIBOWCAPI_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_LIBS = @BUILD_WITH_LIBOWCAPI_LIBS@
+BUILD_WITH_LIBPQOS_CPPFLAGS = @BUILD_WITH_LIBPQOS_CPPFLAGS@
+BUILD_WITH_LIBPQOS_LDFLAGS = @BUILD_WITH_LIBPQOS_LDFLAGS@
+BUILD_WITH_LIBPQOS_LIBS = @BUILD_WITH_LIBPQOS_LIBS@
 BUILD_WITH_LIBPQ_CPPFLAGS = @BUILD_WITH_LIBPQ_CPPFLAGS@
 BUILD_WITH_LIBPQ_LDFLAGS = @BUILD_WITH_LIBPQ_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LDFLAGS = @BUILD_WITH_LIBPROTOBUF_C_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LIBS = @BUILD_WITH_LIBPROTOBUF_C_LIBS@
@@ -635,12 +632,14 @@
 LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
+LIBDPDK_CPPFLAGS = @LIBDPDK_CPPFLAGS@
+LIBDPDK_LDFLAGS = @LIBDPDK_LDFLAGS@
 LIBLTDL = @LIBLTDL@
 LIBLUA_PKG_CONFIG_NAME = @LIBLUA_PKG_CONFIG_NAME@
 LIBNETAPP_CPPFLAGS = @LIBNETAPP_CPPFLAGS@
 LIBNETAPP_LDFLAGS = @LIBNETAPP_LDFLAGS@
 LIBNETAPP_LIBS = @LIBNETAPP_LIBS@
 LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
@@ -673,12 +672,14 @@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 LUA_CFLAGS = @LUA_CFLAGS@
 LUA_LIBS = @LUA_LIBS@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MICROHTTPD_CFLAGS = @MICROHTTPD_CFLAGS@
+MICROHTTPD_LIBS = @MICROHTTPD_LIBS@
 MKDIR_P = @MKDIR_P@
 NM = @NM@
 NMEDIT = @NMEDIT@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -805,16 +806,13 @@
 		   plugin.c plugin.h \
 		   utils_cache.c utils_cache.h \
 		   utils_complain.c utils_complain.h \
 		   utils_ignorelist.c utils_ignorelist.h \
 		   utils_llist.c utils_llist.h \
 		   utils_random.c utils_random.h \
-		   utils_tail_match.c utils_tail_match.h \
-		   utils_match.c utils_match.h \
 		   utils_subst.c utils_subst.h \
-		   utils_tail.c utils_tail.h \
 		   utils_time.c utils_time.h \
 		   types_list.c types_list.h \
 		   utils_threshold.c utils_threshold.h
 
 collectd_CPPFLAGS = $(AM_CPPFLAGS) $(LTDLINCL)
 collectd_CFLAGS = $(AM_CFLAGS) $(am__append_9)
@@ -998,17 +996,14 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-plugin.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-types_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_cache.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_complain.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_ignorelist.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_llist.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_match.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_random.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_subst.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_tail.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_tail_match.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_threshold.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_time.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/common.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/common_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libplugin_mock_la-plugin_mock.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libplugin_mock_la-utils_cache_mock.Plo@am__quote@
@@ -1205,40 +1200,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_random.obj -MD -MP -MF $(DEPDIR)/collectd-utils_random.Tpo -c -o collectd-utils_random.obj `if test -f 'utils_random.c'; then $(CYGPATH_W) 'utils_random.c'; else $(CYGPATH_W) '$(srcdir)/utils_random.c'; fi`
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_random.Tpo $(DEPDIR)/collectd-utils_random.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_random.c' object='collectd-utils_random.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_random.obj `if test -f 'utils_random.c'; then $(CYGPATH_W) 'utils_random.c'; else $(CYGPATH_W) '$(srcdir)/utils_random.c'; fi`
 
-collectd-utils_tail_match.o: utils_tail_match.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_tail_match.o -MD -MP -MF $(DEPDIR)/collectd-utils_tail_match.Tpo -c -o collectd-utils_tail_match.o `test -f 'utils_tail_match.c' || echo '$(srcdir)/'`utils_tail_match.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_tail_match.Tpo $(DEPDIR)/collectd-utils_tail_match.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_tail_match.c' object='collectd-utils_tail_match.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_tail_match.o `test -f 'utils_tail_match.c' || echo '$(srcdir)/'`utils_tail_match.c
-
-collectd-utils_tail_match.obj: utils_tail_match.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_tail_match.obj -MD -MP -MF $(DEPDIR)/collectd-utils_tail_match.Tpo -c -o collectd-utils_tail_match.obj `if test -f 'utils_tail_match.c'; then $(CYGPATH_W) 'utils_tail_match.c'; else $(CYGPATH_W) '$(srcdir)/utils_tail_match.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_tail_match.Tpo $(DEPDIR)/collectd-utils_tail_match.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_tail_match.c' object='collectd-utils_tail_match.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_tail_match.obj `if test -f 'utils_tail_match.c'; then $(CYGPATH_W) 'utils_tail_match.c'; else $(CYGPATH_W) '$(srcdir)/utils_tail_match.c'; fi`
-
-collectd-utils_match.o: utils_match.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_match.o -MD -MP -MF $(DEPDIR)/collectd-utils_match.Tpo -c -o collectd-utils_match.o `test -f 'utils_match.c' || echo '$(srcdir)/'`utils_match.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_match.Tpo $(DEPDIR)/collectd-utils_match.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_match.c' object='collectd-utils_match.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_match.o `test -f 'utils_match.c' || echo '$(srcdir)/'`utils_match.c
-
-collectd-utils_match.obj: utils_match.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_match.obj -MD -MP -MF $(DEPDIR)/collectd-utils_match.Tpo -c -o collectd-utils_match.obj `if test -f 'utils_match.c'; then $(CYGPATH_W) 'utils_match.c'; else $(CYGPATH_W) '$(srcdir)/utils_match.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_match.Tpo $(DEPDIR)/collectd-utils_match.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_match.c' object='collectd-utils_match.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_match.obj `if test -f 'utils_match.c'; then $(CYGPATH_W) 'utils_match.c'; else $(CYGPATH_W) '$(srcdir)/utils_match.c'; fi`
-
 collectd-utils_subst.o: utils_subst.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_subst.o -MD -MP -MF $(DEPDIR)/collectd-utils_subst.Tpo -c -o collectd-utils_subst.o `test -f 'utils_subst.c' || echo '$(srcdir)/'`utils_subst.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_subst.Tpo $(DEPDIR)/collectd-utils_subst.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_subst.c' object='collectd-utils_subst.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_subst.o `test -f 'utils_subst.c' || echo '$(srcdir)/'`utils_subst.c
@@ -1247,26 +1214,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_subst.obj -MD -MP -MF $(DEPDIR)/collectd-utils_subst.Tpo -c -o collectd-utils_subst.obj `if test -f 'utils_subst.c'; then $(CYGPATH_W) 'utils_subst.c'; else $(CYGPATH_W) '$(srcdir)/utils_subst.c'; fi`
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_subst.Tpo $(DEPDIR)/collectd-utils_subst.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_subst.c' object='collectd-utils_subst.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_subst.obj `if test -f 'utils_subst.c'; then $(CYGPATH_W) 'utils_subst.c'; else $(CYGPATH_W) '$(srcdir)/utils_subst.c'; fi`
 
-collectd-utils_tail.o: utils_tail.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_tail.o -MD -MP -MF $(DEPDIR)/collectd-utils_tail.Tpo -c -o collectd-utils_tail.o `test -f 'utils_tail.c' || echo '$(srcdir)/'`utils_tail.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_tail.Tpo $(DEPDIR)/collectd-utils_tail.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_tail.c' object='collectd-utils_tail.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_tail.o `test -f 'utils_tail.c' || echo '$(srcdir)/'`utils_tail.c
-
-collectd-utils_tail.obj: utils_tail.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_tail.obj -MD -MP -MF $(DEPDIR)/collectd-utils_tail.Tpo -c -o collectd-utils_tail.obj `if test -f 'utils_tail.c'; then $(CYGPATH_W) 'utils_tail.c'; else $(CYGPATH_W) '$(srcdir)/utils_tail.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_tail.Tpo $(DEPDIR)/collectd-utils_tail.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_tail.c' object='collectd-utils_tail.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_tail.obj `if test -f 'utils_tail.c'; then $(CYGPATH_W) 'utils_tail.c'; else $(CYGPATH_W) '$(srcdir)/utils_tail.c'; fi`
-
 collectd-utils_time.o: utils_time.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_time.o -MD -MP -MF $(DEPDIR)/collectd-utils_time.Tpo -c -o collectd-utils_time.o `test -f 'utils_time.c' || echo '$(srcdir)/'`utils_time.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_time.Tpo $(DEPDIR)/collectd-utils_time.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_time.c' object='collectd-utils_time.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_time.o `test -f 'utils_time.c' || echo '$(srcdir)/'`utils_time.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/meta_data.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/meta_data.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/meta_data.c	2017-10-06 14:45:52.945917755 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/meta_data.c	2016-12-12 16:03:36.704279144 +0800
@@ -23,15 +23,18 @@
  * Authors:
  *   Florian octo Forster <octo at collectd.org>
  **/
 
 #include "collectd.h"
 
+#include "common.h"
 #include "meta_data.h"
 #include "plugin.h"
 
+#define MD_MAX_NONSTRING_CHARS 128
+
 /*
  * Data types
  */
 union meta_value_u {
   char *mv_string;
   int64_t mv_signed_int;
@@ -681,7 +684,67 @@
   *value = e->value.mv_boolean;
 
   pthread_mutex_unlock(&md->lock);
   return (0);
 } /* }}} int meta_data_get_boolean */
 
+int meta_data_as_string(meta_data_t *md, /* {{{ */
+                        const char *key, char **value) {
+  meta_entry_t *e;
+  char *actual;
+  char buffer[MD_MAX_NONSTRING_CHARS]; /* For non-string types. */
+  char *temp;
+  int type;
+
+  if ((md == NULL) || (key == NULL) || (value == NULL))
+    return (-EINVAL);
+
+  pthread_mutex_lock(&md->lock);
+
+  e = md_entry_lookup(md, key);
+  if (e == NULL) {
+    pthread_mutex_unlock(&md->lock);
+    return (-ENOENT);
+  }
+
+  type = e->type;
+
+  switch (type) {
+  case MD_TYPE_STRING:
+    actual = e->value.mv_string;
+    break;
+  case MD_TYPE_SIGNED_INT:
+    ssnprintf(buffer, sizeof(buffer), "%" PRIi64, e->value.mv_signed_int);
+    actual = buffer;
+    break;
+  case MD_TYPE_UNSIGNED_INT:
+    ssnprintf(buffer, sizeof(buffer), "%" PRIu64, e->value.mv_unsigned_int);
+    actual = buffer;
+    break;
+  case MD_TYPE_DOUBLE:
+    ssnprintf(buffer, sizeof(buffer), GAUGE_FORMAT, e->value.mv_double);
+    actual = buffer;
+    break;
+  case MD_TYPE_BOOLEAN:
+    actual = e->value.mv_boolean ? "true" : "false";
+    break;
+  default:
+    pthread_mutex_unlock(&md->lock);
+    ERROR("meta_data_as_string: unknown type %d for key `%s'", type, key);
+    return (-ENOENT);
+  }
+
+  pthread_mutex_unlock(&md->lock);
+
+  temp = md_strdup(actual);
+  if (temp == NULL) {
+    pthread_mutex_unlock(&md->lock);
+    ERROR("meta_data_as_string: md_strdup failed for key `%s'.", key);
+    return (-ENOMEM);
+  }
+
+  *value = temp;
+
+  return (0);
+} /* }}} int meta_data_as_string */
+
 /* vim: set sw=2 sts=2 et fdm=marker : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/meta_data.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/meta_data.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/meta_data.h	2017-10-06 14:45:52.945917755 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/meta_data.h	2016-12-12 16:03:36.704279144 +0800
@@ -62,8 +62,11 @@
 int meta_data_get_signed_int(meta_data_t *md, const char *key, int64_t *value);
 int meta_data_get_unsigned_int(meta_data_t *md, const char *key,
                                uint64_t *value);
 int meta_data_get_double(meta_data_t *md, const char *key, double *value);
 int meta_data_get_boolean(meta_data_t *md, const char *key, _Bool *value);
 
+/* Returns the value as a string, regardless of the type. */
+int meta_data_as_string(meta_data_t *md, const char *key, char **value);
+
 #endif /* META_DATA_H */
 /* vim: set sw=2 sts=2 et : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/plugin.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/plugin.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/plugin.c	2017-10-06 14:45:52.945917755 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/plugin.c	2016-12-12 16:03:36.704279144 +0800
@@ -22,12 +22,15 @@
  *
  * Authors:
  *   Florian octo Forster <octo at collectd.org>
  *   Sebastian Harl <sh at tokkee.org>
  **/
 
+/* _GNU_SOURCE is needed in Linux to use pthread_setname_np */
+#define _GNU_SOURCE
+
 #include "collectd.h"
 
 #include "common.h"
 #include "configfile.h"
 #include "filter_chain.h"
 #include "plugin.h"
@@ -36,12 +39,16 @@
 #include "utils_complain.h"
 #include "utils_heap.h"
 #include "utils_llist.h"
 #include "utils_random.h"
 #include "utils_time.h"
 
+#if HAVE_PTHREAD_NP_H
+#include <pthread_np.h> /* for pthread_set_name_np(3) */
+#endif
+
 #include <ltdl.h>
 
 /*
  * Private structures
  */
 struct callback_func_s {
@@ -102,21 +109,21 @@
 
 static c_avl_tree_t *data_sets;
 
 static char *plugindir = NULL;
 
 #ifndef DEFAULT_MAX_READ_INTERVAL
-#define DEFAULT_MAX_READ_INTERVAL TIME_T_TO_CDTIME_T(86400)
+#define DEFAULT_MAX_READ_INTERVAL TIME_T_TO_CDTIME_T_STATIC(86400)
 #endif
 static c_heap_t *read_heap = NULL;
 static llist_t *read_list;
 static int read_loop = 1;
 static pthread_mutex_t read_lock = PTHREAD_MUTEX_INITIALIZER;
 static pthread_cond_t read_cond = PTHREAD_COND_INITIALIZER;
 static pthread_t *read_threads = NULL;
-static int read_threads_num = 0;
+static size_t read_threads_num = 0;
 static cdtime_t max_read_interval = DEFAULT_MAX_READ_INTERVAL;
 
 static write_queue_t *write_queue_head;
 static write_queue_t *write_queue_tail;
 static long write_queue_length = 0;
 static _Bool write_loop = 1;
@@ -144,48 +151,43 @@
     return (PLUGINDIR);
   else
     return (plugindir);
 }
 
 static void plugin_update_internal_statistics(void) { /* {{{ */
-  derive_t copy_write_queue_length;
-  value_list_t vl = VALUE_LIST_INIT;
-  value_t values[2];
 
-  copy_write_queue_length = write_queue_length;
+  gauge_t copy_write_queue_length = (gauge_t)write_queue_length;
 
   /* Initialize `vl' */
-  vl.values = values;
-  vl.values_len = 2;
-  vl.time = 0;
+  value_list_t vl = VALUE_LIST_INIT;
   sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "collectd", sizeof(vl.plugin));
 
-  vl.type_instance[0] = 0;
-  vl.values_len = 1;
-
   /* Write queue */
   sstrncpy(vl.plugin_instance, "write_queue", sizeof(vl.plugin_instance));
 
   /* Write queue : queue length */
-  vl.values[0].gauge = (gauge_t)copy_write_queue_length;
+  vl.values = &(value_t){.gauge = copy_write_queue_length};
+  vl.values_len = 1;
   sstrncpy(vl.type, "queue_length", sizeof(vl.type));
   vl.type_instance[0] = 0;
   plugin_dispatch_values(&vl);
 
   /* Write queue : Values dropped (queue length > low limit) */
-  vl.values[0].derive = (derive_t)stats_values_dropped;
+  vl.values = &(value_t){.gauge = (gauge_t)stats_values_dropped};
+  vl.values_len = 1;
   sstrncpy(vl.type, "derive", sizeof(vl.type));
   sstrncpy(vl.type_instance, "dropped", sizeof(vl.type_instance));
   plugin_dispatch_values(&vl);
 
   /* Cache */
   sstrncpy(vl.plugin_instance, "cache", sizeof(vl.plugin_instance));
 
   /* Cache : Nb entry in cache tree */
-  vl.values[0].gauge = (gauge_t)uc_get_size();
+  vl.values = &(value_t){.gauge = (gauge_t)uc_get_size()};
+  vl.values_len = 1;
   sstrncpy(vl.type, "cache_size", sizeof(vl.type));
   vl.type_instance[0] = 0;
   plugin_dispatch_values(&vl);
 
   return;
 } /* }}} void plugin_update_internal_statistics */
@@ -483,17 +485,14 @@
     /* In pthread_cond_timedwait, spurious wakeups are possible
      * (and really happen, at least on NetBSD with > 1 CPU), thus
      * we need to re-evaluate the condition every time
      * pthread_cond_timedwait returns. */
     rc = 0;
     while ((read_loop != 0) && (cdtime() < rf->rf_next_read) && rc == 0) {
-      struct timespec ts = {0};
-
-      CDTIME_T_TO_TIMESPEC(rf->rf_next_read, &ts);
-
-      rc = pthread_cond_timedwait(&read_cond, &read_lock, &ts);
+      rc = pthread_cond_timedwait(&read_cond, &read_lock,
+                                  &CDTIME_T_TO_TIMESPEC(rf->rf_next_read));
     }
 
     /* Must hold `read_lock' when accessing `rf->rf_type'. */
     rf_type = rf->rf_type;
     pthread_mutex_unlock(&read_lock);
 
@@ -598,47 +597,87 @@
   } /* while (read_loop) */
 
   pthread_exit(NULL);
   return ((void *)0);
 } /* void *plugin_read_thread */
 
-static void start_read_threads(int num) {
+#ifdef PTHREAD_MAX_NAMELEN_NP
+#define THREAD_NAME_MAX PTHREAD_MAX_NAMELEN_NP
+#else
+#define THREAD_NAME_MAX 16
+#endif
+
+static void set_thread_name(pthread_t tid, char const *name) {
+#if defined(HAVE_PTHREAD_SETNAME_NP) || defined(HAVE_PTHREAD_SET_NAME_NP)
+
+  /* glibc limits the length of the name and fails if the passed string
+   * is too long, so we truncate it here. */
+  char n[THREAD_NAME_MAX];
+  if (strlen(name) >= THREAD_NAME_MAX)
+    WARNING("set_thread_name(\"%s\"): name too long", name);
+  sstrncpy(n, name, sizeof(n));
+
+#if defined(HAVE_PTHREAD_SETNAME_NP)
+  int status = pthread_setname_np(tid, n);
+  if (status != 0) {
+    char errbuf[1024];
+    ERROR("set_thread_name(\"%s\"): %s", n,
+          sstrerror(status, errbuf, sizeof(errbuf)));
+  }
+#else /* if defined(HAVE_PTHREAD_SET_NAME_NP) */
+  pthread_set_name_np(tid, n);
+#endif
+
+#endif
+}
+
+static void start_read_threads(size_t num) /* {{{ */
+{
   if (read_threads != NULL)
     return;
 
   read_threads = (pthread_t *)calloc(num, sizeof(pthread_t));
   if (read_threads == NULL) {
     ERROR("plugin: start_read_threads: calloc failed.");
     return;
   }
 
   read_threads_num = 0;
-  for (int i = 0; i < num; i++) {
-    if (pthread_create(read_threads + read_threads_num, NULL,
-                       plugin_read_thread, NULL) == 0) {
-      read_threads_num++;
-    } else {
-      ERROR("plugin: start_read_threads: pthread_create failed.");
+  for (size_t i = 0; i < num; i++) {
+    int status = pthread_create(read_threads + read_threads_num,
+                                /* attr = */ NULL, plugin_read_thread,
+                                /* arg = */ NULL);
+    if (status != 0) {
+      char errbuf[1024];
+      ERROR("plugin: start_read_threads: pthread_create failed "
+            "with status %i (%s).",
+            status, sstrerror(status, errbuf, sizeof(errbuf)));
       return;
     }
+
+    char name[THREAD_NAME_MAX];
+    ssnprintf(name, sizeof(name), "reader#%zu", read_threads_num);
+    set_thread_name(read_threads[read_threads_num], name);
+
+    read_threads_num++;
   } /* for (i) */
-} /* void start_read_threads */
+} /* }}} void start_read_threads */
 
 static void stop_read_threads(void) {
   if (read_threads == NULL)
     return;
 
-  INFO("collectd: Stopping %i read threads.", read_threads_num);
+  INFO("collectd: Stopping %zu read threads.", read_threads_num);
 
   pthread_mutex_lock(&read_lock);
   read_loop = 0;
   DEBUG("plugin: stop_read_threads: Signalling `read_cond'");
   pthread_cond_broadcast(&read_cond);
   pthread_mutex_unlock(&read_lock);
 
-  for (int i = 0; i < read_threads_num; i++) {
+  for (size_t i = 0; i < read_threads_num; i++) {
     if (pthread_join(read_threads[i], NULL) != 0) {
       ERROR("plugin: stop_read_threads: pthread_join failed.");
     }
     read_threads[i] = (pthread_t)0;
   }
   sfree(read_threads);
@@ -665,12 +704,15 @@
 
   vl = malloc(sizeof(*vl));
   if (vl == NULL)
     return (NULL);
   memcpy(vl, vl_orig, sizeof(*vl));
 
+  if (vl->host[0] == 0)
+    sstrncpy(vl->host, hostname_g, sizeof(vl->host));
+
   vl->values = calloc(vl_orig->values_len, sizeof(*vl->values));
   if (vl->values == NULL) {
     plugin_value_list_free(vl);
     return (NULL);
   }
   memcpy(vl->values, vl_orig->values,
@@ -805,25 +847,27 @@
     ERROR("plugin: start_write_threads: calloc failed.");
     return;
   }
 
   write_threads_num = 0;
   for (size_t i = 0; i < num; i++) {
-    int status;
-
-    status = pthread_create(write_threads + write_threads_num,
-                            /* attr = */ NULL, plugin_write_thread,
-                            /* arg = */ NULL);
+    int status = pthread_create(write_threads + write_threads_num,
+                                /* attr = */ NULL, plugin_write_thread,
+                                /* arg = */ NULL);
     if (status != 0) {
       char errbuf[1024];
       ERROR("plugin: start_write_threads: pthread_create failed "
             "with status %i (%s).",
             status, sstrerror(status, errbuf, sizeof(errbuf)));
       return;
     }
 
+    char name[THREAD_NAME_MAX];
+    ssnprintf(name, sizeof(name), "writer#%zu", write_threads_num);
+    set_thread_name(write_threads[write_threads_num], name);
+
     write_threads_num++;
   } /* for (i) */
 } /* }}} void start_write_threads */
 
 static void stop_write_threads(void) /* {{{ */
 {
@@ -1607,13 +1651,13 @@
     const char *rt;
     int num;
 
     rt = global_option_get("ReadThreads");
     num = atoi(rt);
     if (num != -1)
-      start_read_threads((num > 0) ? num : 5);
+      start_read_threads((num > 0) ? ((size_t)num) : 5);
   }
   return ret;
 } /* void plugin_init_all */
 
 /* TODO: Rename this function. */
 void plugin_read_all(void) {
@@ -1879,21 +1923,22 @@
 } /* int }}} plugin_dispatch_missing */
 
 static int plugin_dispatch_values_internal(value_list_t *vl) {
   int status;
   static c_complain_t no_write_complaint = C_COMPLAIN_INIT_STATIC;
 
-  value_t *saved_values;
-  int saved_values_len;
-
   data_set_t *ds;
 
-  int free_meta_data = 0;
+  _Bool free_meta_data = 0;
 
-  assert(vl);
-  assert(vl->plugin);
+  assert(vl != NULL);
+
+  /* These fields are initialized by plugin_value_list_clone() if needed: */
+  assert(vl->host[0] != 0);
+  assert(vl->time != 0); /* The time is determined at _enqueue_ time. */
+  assert(vl->interval != 0);
 
   if (vl->type[0] == 0 || vl->values == NULL || vl->values_len < 1) {
     ERROR("plugin_dispatch_values: Invalid value list "
           "from plugin %s.",
           vl->plugin);
     return (-1);
@@ -1925,17 +1970,12 @@
     INFO("plugin_dispatch_values: Dataset not found: %s "
          "(from \"%s\"), check your types.db!",
          vl->type, ident);
     return (-1);
   }
 
-  /* Assured by plugin_value_list_clone(). The time is determined at
-   * _enqueue_ time. */
-  assert(vl->time != 0);
-  assert(vl->interval != 0);
-
   DEBUG("plugin_dispatch_values: time = %.3f; interval = %.3f; "
         "host = %s; "
         "plugin = %s; plugin_instance = %s; "
         "type = %s; type_instance = %s;",
         CDTIME_T_TO_DOUBLE(vl->time), CDTIME_T_TO_DOUBLE(vl->interval),
         vl->host, vl->plugin, vl->plugin_instance, vl->type, vl->type_instance);
@@ -1963,49 +2003,21 @@
   escape_slashes(vl->host, sizeof(vl->host));
   escape_slashes(vl->plugin, sizeof(vl->plugin));
   escape_slashes(vl->plugin_instance, sizeof(vl->plugin_instance));
   escape_slashes(vl->type, sizeof(vl->type));
   escape_slashes(vl->type_instance, sizeof(vl->type_instance));
 
-  /* Copy the values. This way, we can assure `targets' that they get
-   * dynamically allocated values, which they can free and replace if
-   * they like. */
-  if ((pre_cache_chain != NULL) || (post_cache_chain != NULL)) {
-    saved_values = vl->values;
-    saved_values_len = vl->values_len;
-
-    vl->values = (value_t *)calloc(vl->values_len, sizeof(*vl->values));
-    if (vl->values == NULL) {
-      ERROR("plugin_dispatch_values: calloc failed.");
-      vl->values = saved_values;
-      return (-1);
-    }
-    memcpy(vl->values, saved_values, vl->values_len * sizeof(*vl->values));
-  } else /* if ((pre == NULL) && (post == NULL)) */
-  {
-    saved_values = NULL;
-    saved_values_len = 0;
-  }
-
   if (pre_cache_chain != NULL) {
     status = fc_process_chain(ds, vl, pre_cache_chain);
     if (status < 0) {
       WARNING("plugin_dispatch_values: Running the "
               "pre-cache chain failed with "
               "status %i (%#x).",
               status, status);
-    } else if (status == FC_TARGET_STOP) {
-      /* Restore the state of the value_list so that plugins
-       * don't get confused.. */
-      if (saved_values != NULL) {
-        sfree(vl->values);
-        vl->values = saved_values;
-        vl->values_len = saved_values_len;
-      }
+    } else if (status == FC_TARGET_STOP)
       return (0);
-    }
   }
 
   /* Update the value cache */
   uc_update(ds, vl);
 
   if (post_cache_chain != NULL) {
@@ -2016,20 +2028,12 @@
               "status %i (%#x).",
               status, status);
     }
   } else
     fc_default_action(ds, vl);
 
-  /* Restore the state of the value_list so that plugins don't get
-   * confused.. */
-  if (saved_values != NULL) {
-    sfree(vl->values);
-    vl->values = saved_values;
-    vl->values_len = saved_values_len;
-  }
-
   if ((free_meta_data != 0) && (vl->meta != NULL)) {
     meta_data_destroy(vl->meta);
     vl->meta = NULL;
   }
 
   return (0);
@@ -2562,21 +2566,31 @@
   sfree(plugin_thread);
 
   return start_routine(plugin_arg);
 } /* void *plugin_thread_start */
 
 int plugin_thread_create(pthread_t *thread, const pthread_attr_t *attr,
-                         void *(*start_routine)(void *), void *arg) {
+                         void *(*start_routine)(void *), void *arg,
+                         char const *name) {
   plugin_thread_t *plugin_thread;
 
   plugin_thread = malloc(sizeof(*plugin_thread));
   if (plugin_thread == NULL)
-    return -1;
+    return ENOMEM;
 
   plugin_thread->ctx = plugin_get_ctx();
   plugin_thread->start_routine = start_routine;
   plugin_thread->arg = arg;
 
-  return pthread_create(thread, attr, plugin_thread_start, plugin_thread);
+  int ret = pthread_create(thread, attr, plugin_thread_start, plugin_thread);
+  if (ret != 0) {
+    sfree(plugin_thread);
+    return ret;
+  }
+
+  if (name != NULL)
+    set_thread_name(*thread, name);
+
+  return 0;
 } /* int plugin_thread_create */
 
 /* vim: set sw=8 ts=8 noet fdm=marker : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/plugin.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/plugin.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/plugin.h	2017-10-06 14:45:52.945917755 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/plugin.h	2016-12-12 16:03:36.704279144 +0800
@@ -80,12 +80,21 @@
 
 #define plugin_interval (plugin_get_ctx().interval)
 
 /*
  * Public data types
  */
+struct identifier_s {
+  char *host;
+  char *plugin;
+  char *plugin_instance;
+  char *type;
+  char *type_instance;
+};
+typedef struct identifier_s identifier_t;
+
 typedef unsigned long long counter_t;
 typedef double gauge_t;
 typedef int64_t derive_t;
 typedef uint64_t absolute_t;
 
 union value_u {
@@ -108,15 +117,13 @@
   char type_instance[DATA_MAX_NAME_LEN];
   meta_data_t *meta;
 };
 typedef struct value_list_s value_list_t;
 
 #define VALUE_LIST_INIT                                                        \
-  { NULL, 0, 0, plugin_get_interval(), "localhost", "", "", "", "", NULL }
-#define VALUE_LIST_STATIC                                                      \
-  { NULL, 0, 0, 0, "localhost", "", "", "", "", NULL }
+  { .values = NULL, .meta = NULL }
 
 struct data_source_s {
   char name[DATA_MAX_NAME_LEN];
   int type;
   double min;
   double max;
@@ -437,13 +444,14 @@
 
 /*
  * Context-aware thread management.
  */
 
 int plugin_thread_create(pthread_t *thread, const pthread_attr_t *attr,
-                         void *(*start_routine)(void *), void *arg);
+                         void *(*start_routine)(void *), void *arg,
+                         char const *name);
 
 /*
  * Plugins need to implement this
  */
 
 void module_register(void);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/plugin_mock.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/plugin_mock.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/plugin_mock.c	2017-10-06 14:45:52.945917755 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/plugin_mock.c	2016-12-12 16:03:36.704279144 +0800
@@ -48,12 +48,25 @@
 int plugin_register_shutdown(const char *name, int (*callback)(void)) {
   return ENOTSUP;
 }
 
 int plugin_dispatch_values(value_list_t const *vl) { return ENOTSUP; }
 
+int plugin_flush(const char *plugin, cdtime_t timeout, const char *identifier) {
+  return ENOTSUP;
+}
+
+static data_source_t magic_ds[] = {{"value", DS_TYPE_DERIVE, 0.0, NAN}};
+static data_set_t magic = {"MAGIC", 1, magic_ds};
+const data_set_t *plugin_get_ds(const char *name) {
+  if (strcmp(name, "MAGIC"))
+    return NULL;
+
+  return &magic;
+}
+
 void plugin_log(int level, char const *format, ...) {
   char buffer[1024];
   va_list ap;
 
   va_start(ap, format);
   vsnprintf(buffer, sizeof(buffer), format, ap);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_cache.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_cache.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_cache.c	2017-10-06 14:45:52.945917755 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_cache.c	2016-12-12 16:03:36.708279115 +0800
@@ -219,132 +219,100 @@
         c_avl_create((int (*)(const void *, const void *))cache_compare);
 
   return (0);
 } /* int uc_init */
 
 int uc_check_timeout(void) {
-  cdtime_t now;
-  cache_entry_t *ce;
+  cdtime_t now = cdtime();
 
-  char **keys = NULL;
-  cdtime_t *keys_time = NULL;
-  cdtime_t *keys_interval = NULL;
-  int keys_len = 0;
-
-  char *key;
-  c_avl_iterator_t *iter;
-
-  int status;
+  struct {
+    char *key;
+    cdtime_t time;
+    cdtime_t interval;
+  } *expired = NULL;
+  size_t expired_num = 0;
 
   pthread_mutex_lock(&cache_lock);
 
-  now = cdtime();
-
   /* Build a list of entries to be flushed */
-  iter = c_avl_get_iterator(cache_tree);
+  c_avl_iterator_t *iter = c_avl_get_iterator(cache_tree);
+  char *key = NULL;
+  cache_entry_t *ce = NULL;
   while (c_avl_iterator_next(iter, (void *)&key, (void *)&ce) == 0) {
-    char **tmp;
-    cdtime_t *tmp_time;
-
     /* If the entry is fresh enough, continue. */
     if ((now - ce->last_update) < (ce->interval * timeout_g))
       continue;
 
-    /* If entry has not been updated, add to `keys' array */
-    tmp = realloc((void *)keys, (keys_len + 1) * sizeof(char *));
+    void *tmp = realloc(expired, (expired_num + 1) * sizeof(*expired));
     if (tmp == NULL) {
       ERROR("uc_check_timeout: realloc failed.");
       continue;
     }
-    keys = tmp;
+    expired = tmp;
 
-    tmp_time = realloc(keys_time, (keys_len + 1) * sizeof(*keys_time));
-    if (tmp_time == NULL) {
-      ERROR("uc_check_timeout: realloc failed.");
-      continue;
-    }
-    keys_time = tmp_time;
+    expired[expired_num].key = strdup(key);
+    expired[expired_num].time = ce->last_time;
+    expired[expired_num].interval = ce->interval;
 
-    tmp_time = realloc(keys_interval, (keys_len + 1) * sizeof(*keys_interval));
-    if (tmp_time == NULL) {
-      ERROR("uc_check_timeout: realloc failed.");
-      continue;
-    }
-    keys_interval = tmp_time;
-
-    keys[keys_len] = strdup(key);
-    if (keys[keys_len] == NULL) {
+    if (expired[expired_num].key == NULL) {
       ERROR("uc_check_timeout: strdup failed.");
       continue;
     }
-    keys_time[keys_len] = ce->last_time;
-    keys_interval[keys_len] = ce->interval;
 
-    keys_len++;
+    expired_num++;
   } /* while (c_avl_iterator_next) */
 
   c_avl_iterator_destroy(iter);
   pthread_mutex_unlock(&cache_lock);
 
-  if (keys_len == 0) {
-    /* realloc() may have been called for these. */
-    sfree(keys);
-    sfree(keys_time);
-    sfree(keys_interval);
+  if (expired_num == 0) {
+    sfree(expired);
     return (0);
   }
 
   /* Call the "missing" callback for each value. Do this before removing the
    * value from the cache, so that callbacks can still access the data stored,
    * including plugin specific meta data, rates, history, . This must be done
    * without holding the lock, otherwise we will run into a deadlock if a
    * plugin calls the cache interface. */
-  for (int i = 0; i < keys_len; i++) {
-    value_list_t vl = VALUE_LIST_INIT;
-
-    vl.values = NULL;
-    vl.values_len = 0;
-    vl.meta = NULL;
-
-    status = parse_identifier_vl(keys[i], &vl);
-    if (status != 0) {
-      ERROR("uc_check_timeout: parse_identifier_vl (\"%s\") failed.", keys[i]);
+  for (size_t i = 0; i < expired_num; i++) {
+    value_list_t vl = {
+        .time = expired[i].time, .interval = expired[i].interval,
+    };
+
+    if (parse_identifier_vl(expired[i].key, &vl) != 0) {
+      ERROR("uc_check_timeout: parse_identifier_vl (\"%s\") failed.",
+            expired[i].key);
       continue;
     }
 
-    vl.time = keys_time[i];
-    vl.interval = keys_interval[i];
-
     plugin_dispatch_missing(&vl);
-  } /* for (i = 0; i < keys_len; i++) */
+  } /* for (i = 0; i < expired_num; i++) */
 
   /* Now actually remove all the values from the cache. We don't re-evaluate
    * the timestamp again, so in theory it is possible we remove a value after
    * it is updated here. */
   pthread_mutex_lock(&cache_lock);
-  for (int i = 0; i < keys_len; i++) {
-    key = NULL;
-    ce = NULL;
-
-    status = c_avl_remove(cache_tree, keys[i], (void *)&key, (void *)&ce);
-    if (status != 0) {
-      ERROR("uc_check_timeout: c_avl_remove (\"%s\") failed.", keys[i]);
-      sfree(keys[i]);
+  for (size_t i = 0; i < expired_num; i++) {
+    char *key = NULL;
+    cache_entry_t *value = NULL;
+
+    if (c_avl_remove(cache_tree, expired[i].key, (void *)&key,
+                     (void *)&value) != 0) {
+      ERROR("uc_check_timeout: c_avl_remove (\"%s\") failed.", expired[i].key);
+      sfree(expired[i].key);
       continue;
     }
-
-    sfree(keys[i]);
     sfree(key);
-    cache_free(ce);
-  } /* for (i = 0; i < keys_len; i++) */
-  pthread_mutex_unlock(&cache_lock);
+    cache_free(value);
 
-  sfree(keys);
-  sfree(keys_time);
-  sfree(keys_interval);
+    sfree(expired[i].key);
+  } /* for (i = 0; i < expired_num; i++) */
+  pthread_mutex_unlock(&cache_lock);
 
+  sfree(expired);
   return (0);
 } /* int uc_check_timeout */
 
 int uc_update(const data_set_t *ds, const value_list_t *vl) {
   char name[6 * DATA_MAX_NAME_LEN];
   cache_entry_t *ce = NULL;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_cache.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_cache.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_cache.h	2017-10-06 14:45:52.945917755 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_cache.h	2016-12-12 16:03:36.708279115 +0800
@@ -83,15 +83,15 @@
  * DESCRIPTION
  *   Advance the iterator to the next positiion and (optionally) returns the
  *   name of the entry.
  *
  * PARAMETERS
  *   `iter'     The iterator object to advance.
- *   `ret_name' Pointer to a string where to store the name. The returned
- *              value is a copy of the value and has to be freed by the
- *              caller.
+ *   `ret_name' Optional pointer to a string where to store the name. If not
+ *              NULL, the returned value is a copy of the value and has to be
+ *              freed by the caller.
  *
  * RETURN VALUE
  *   Zero upon success or non-zero if the iterator ie NULL or no further
  *   values are available.
  */
 int uc_iterator_next(uc_iter_t *iter, char **ret_name);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_cache_mock.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_cache_mock.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_cache_mock.c	2017-10-06 14:45:52.945917755 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_cache_mock.c	2016-12-12 16:03:36.708279115 +0800
@@ -21,12 +21,23 @@
  * DEALINGS IN THE SOFTWARE.
  *
  * Authors:
  *   Florian octo Forster <octo at collectd.org>
  */
 
+#include <errno.h>
 #include "utils_cache.h"
 
 gauge_t *uc_get_rate(__attribute__((unused)) data_set_t const *ds,
                      __attribute__((unused)) value_list_t const *vl) {
+  errno = ENOTSUP;
   return (NULL);
 }
+
+int uc_get_rate_by_name(const char *name, gauge_t **ret_values,
+                        size_t *ret_values_num) {
+  return (ENOTSUP);
+}
+
+int uc_get_names(char ***ret_names, cdtime_t **ret_times, size_t *ret_number) {
+  return (ENOTSUP);
+}
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon: utils_match.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon: utils_match.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon: utils_tail.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon: utils_tail.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon: utils_tail_match.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon: utils_tail_match.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_time.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_time.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_time.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_time.c	2016-12-12 16:03:36.708279115 +0800
@@ -47,16 +47,16 @@
 
   status = clock_gettime(CLOCK_REALTIME, &ts);
   if (status != 0) {
     char errbuf[1024];
     ERROR("cdtime: clock_gettime failed: %s",
           sstrerror(errno, errbuf, sizeof(errbuf)));
-    return (0);
+    return 0;
   }
 
-  return (TIMESPEC_TO_CDTIME_T(&ts));
+  return TIMESPEC_TO_CDTIME_T(&ts);
 } /* }}} cdtime_t cdtime */
 #else /* !HAVE_CLOCK_GETTIME */
 /* Work around for Mac OS X which doesn't have clock_gettime(2). *sigh* */
 cdtime_t cdtime(void) /* {{{ */
 {
   int status;
@@ -64,20 +64,64 @@
 
   status = gettimeofday(&tv, /* struct timezone = */ NULL);
   if (status != 0) {
     char errbuf[1024];
     ERROR("cdtime: gettimeofday failed: %s",
           sstrerror(errno, errbuf, sizeof(errbuf)));
-    return (0);
+    return 0;
   }
 
-  return (TIMEVAL_TO_CDTIME_T(&tv));
+  return TIMEVAL_TO_CDTIME_T(&tv);
 } /* }}} cdtime_t cdtime */
 #endif
 #endif
 
+/**********************************************************************
+ Time retrieval functions
+***********************************************************************/
+
+static int get_utc_time(cdtime_t t, struct tm *t_tm, long *nsec) /* {{{ */
+{
+  struct timespec t_spec = CDTIME_T_TO_TIMESPEC(t);
+  NORMALIZE_TIMESPEC(t_spec);
+
+  if (gmtime_r(&t_spec.tv_sec, t_tm) == NULL) {
+    char errbuf[1024];
+    int status = errno;
+    ERROR("get_utc_time: gmtime_r failed: %s",
+          sstrerror(status, errbuf, sizeof(errbuf)));
+    return status;
+  }
+
+  *nsec = t_spec.tv_nsec;
+  return 0;
+} /* }}} int get_utc_time */
+
+static int get_local_time(cdtime_t t, struct tm *t_tm, long *nsec) /* {{{ */
+{
+  struct timespec t_spec = CDTIME_T_TO_TIMESPEC(t);
+  NORMALIZE_TIMESPEC(t_spec);
+
+  if (localtime_r(&t_spec.tv_sec, t_tm) == NULL) {
+    char errbuf[1024];
+    int status = errno;
+    ERROR("get_local_time: localtime_r failed: %s",
+          sstrerror(status, errbuf, sizeof(errbuf)));
+    return status;
+  }
+
+  *nsec = t_spec.tv_nsec;
+  return 0;
+} /* }}} int get_local_time */
+
+/**********************************************************************
+ Formatting functions
+***********************************************************************/
+
+static const char zulu_zone[] = "Z";
+
 /* format_zone reads time zone information from "extern long timezone", exported
  * by <time.h>, and formats it according to RFC 3339. This differs from
  * strftime()'s "%z" format by including a colon between hour and minute. */
 static int format_zone(char *buffer, size_t buffer_size,
                        struct tm const *tm) /* {{{ */
 {
@@ -104,64 +148,97 @@
   buffer[5] = tmp[4];
   buffer[6] = 0;
 
   return 0;
 } /* }}} int format_zone */
 
-static int format_rfc3339(char *buffer, size_t buffer_size, cdtime_t t,
-                          _Bool print_nano) /* {{{ */
+int format_rfc3339(char *buffer, size_t buffer_size, struct tm const *t_tm,
+                   long nsec, _Bool print_nano, char const *zone) /* {{{ */
+{
+  int len;
+  char *pos = buffer;
+  size_t size_left = buffer_size;
+
+  if ((len = strftime(pos, size_left, "%Y-%m-%dT%H:%M:%S", t_tm)) == 0)
+    return ENOMEM;
+  pos += len;
+  size_left -= len;
+
+  if (print_nano) {
+    if ((len = ssnprintf(pos, size_left, ".%09ld", nsec)) == 0)
+      return ENOMEM;
+    pos += len;
+    size_left -= len;
+  }
+
+  sstrncpy(pos, zone, size_left);
+  return 0;
+} /* }}} int format_rfc3339 */
+
+int format_rfc3339_utc(char *buffer, size_t buffer_size, cdtime_t t,
+                       _Bool print_nano) /* {{{ */
 {
-  struct timespec t_spec;
   struct tm t_tm;
-  char base[20]; /* 2006-01-02T15:04:05 */
-  char nano[11]; /* .999999999 */
-  char zone[7];  /* +00:00 */
-  char *fields[] = {base, nano, zone};
-  size_t len;
+  long nsec = 0;
   int status;
 
-  CDTIME_T_TO_TIMESPEC(t, &t_spec);
-  NORMALIZE_TIMESPEC(t_spec);
+  if ((status = get_utc_time(t, &t_tm, &nsec)) != 0)
+    return status; /* The error should have already be reported. */
 
-  if (localtime_r(&t_spec.tv_sec, &t_tm) == NULL) {
-    char errbuf[1024];
-    status = errno;
-    ERROR("format_rfc3339: localtime_r failed: %s",
-          sstrerror(status, errbuf, sizeof(errbuf)));
-    return (status);
-  }
+  return format_rfc3339(buffer, buffer_size, &t_tm, nsec, print_nano,
+                        zulu_zone);
+} /* }}} int format_rfc3339_utc */
 
-  len = strftime(base, sizeof(base), "%Y-%m-%dT%H:%M:%S", &t_tm);
-  if (len == 0)
-    return ENOMEM;
+int format_rfc3339_local(char *buffer, size_t buffer_size, cdtime_t t,
+                         _Bool print_nano) /* {{{ */
+{
+  struct tm t_tm;
+  long nsec = 0;
+  int status;
+  char zone[7]; /* +00:00 */
 
-  if (print_nano)
-    ssnprintf(nano, sizeof(nano), ".%09ld", (long)t_spec.tv_nsec);
-  else
-    sstrncpy(nano, "", sizeof(nano));
+  if ((status = get_local_time(t, &t_tm, &nsec)) != 0)
+    return status; /* The error should have already be reported. */
 
-  status = format_zone(zone, sizeof(zone), &t_tm);
-  if (status != 0)
+  if ((status = format_zone(zone, sizeof(zone), &t_tm)) != 0)
     return status;
 
-  if (strjoin(buffer, buffer_size, fields, STATIC_ARRAY_SIZE(fields), "") < 0)
-    return ENOMEM;
-  return 0;
-} /* }}} int format_rfc3339 */
+  return format_rfc3339(buffer, buffer_size, &t_tm, nsec, print_nano, zone);
+} /* }}} int format_rfc3339_local */
+
+/**********************************************************************
+ Public functions
+***********************************************************************/
 
 int rfc3339(char *buffer, size_t buffer_size, cdtime_t t) /* {{{ */
 {
   if (buffer_size < RFC3339_SIZE)
     return ENOMEM;
 
-  return format_rfc3339(buffer, buffer_size, t, 0);
-} /* }}} size_t cdtime_to_rfc3339 */
+  return format_rfc3339_utc(buffer, buffer_size, t, 0);
+} /* }}} int rfc3339 */
 
 int rfc3339nano(char *buffer, size_t buffer_size, cdtime_t t) /* {{{ */
 {
   if (buffer_size < RFC3339NANO_SIZE)
     return ENOMEM;
 
-  return format_rfc3339(buffer, buffer_size, t, 1);
-} /* }}} size_t cdtime_to_rfc3339nano */
+  return format_rfc3339_utc(buffer, buffer_size, t, 1);
+} /* }}} int rfc3339nano */
+
+int rfc3339_local(char *buffer, size_t buffer_size, cdtime_t t) /* {{{ */
+{
+  if (buffer_size < RFC3339_SIZE)
+    return ENOMEM;
+
+  return format_rfc3339_local(buffer, buffer_size, t, 0);
+} /* }}} int rfc3339 */
+
+int rfc3339nano_local(char *buffer, size_t buffer_size, cdtime_t t) /* {{{ */
+{
+  if (buffer_size < RFC3339NANO_SIZE)
+    return ENOMEM;
+
+  return format_rfc3339_local(buffer, buffer_size, t, 1);
+} /* }}} int rfc3339nano */
 
 /* vim: set sw=2 sts=2 et fdm=marker : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_time.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_time.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_time.h	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_time.h	2016-12-12 16:03:36.708279115 +0800
@@ -45,64 +45,89 @@
  */
 /*
  * cdtime_t is defined in "collectd.h" */
 /* typedef uint64_t cdtime_t; */
 
 /* 2^30 = 1073741824 */
-#define TIME_T_TO_CDTIME_T(t) (((cdtime_t)(t)) << 30)
+#define TIME_T_TO_CDTIME_T_STATIC(t) (((cdtime_t)(t)) << 30)
+#define TIME_T_TO_CDTIME_T(t)                                                  \
+  (cdtime_t) { TIME_T_TO_CDTIME_T_STATIC(t) }
 
 #define MS_TO_CDTIME_T(ms)                                                     \
-  (((((cdtime_t)(ms)) / 1000) << 30) |                                         \
-   ((((((cdtime_t)(ms)) % 1000) << 30) + 500) / 1000))
+  (cdtime_t) {                                                                 \
+    ((((cdtime_t)(ms)) / 1000) << 30) |                                        \
+        ((((((cdtime_t)(ms)) % 1000) << 30) + 500) / 1000)                     \
+  }
 #define US_TO_CDTIME_T(us)                                                     \
-  (((((cdtime_t)(us)) / 1000000) << 30) |                                      \
-   ((((((cdtime_t)(us)) % 1000000) << 30) + 500000) / 1000000))
+  (cdtime_t) {                                                                 \
+    ((((cdtime_t)(us)) / 1000000) << 30) |                                     \
+        ((((((cdtime_t)(us)) % 1000000) << 30) + 500000) / 1000000)            \
+  }
 #define NS_TO_CDTIME_T(ns)                                                     \
-  (((((cdtime_t)(ns)) / 1000000000) << 30) |                                   \
-   ((((((cdtime_t)(ns)) % 1000000000) << 30) + 500000000) / 1000000000))
+  (cdtime_t) {                                                                 \
+    ((((cdtime_t)(ns)) / 1000000000) << 30) |                                  \
+        ((((((cdtime_t)(ns)) % 1000000000) << 30) + 500000000) / 1000000000)   \
+  }
 
-#define CDTIME_T_TO_TIME_T(t) ((time_t)(((t) + (1 << 29)) >> 30))
+#define CDTIME_T_TO_TIME_T(t)                                                  \
+  (time_t) { (time_t)(((t) + (1 << 29)) >> 30) }
 #define CDTIME_T_TO_MS(t)                                                      \
-  ((uint64_t)((((t) >> 30) * 1000) +                                           \
-              ((((t)&0x3fffffff) * 1000 + (1 << 29)) >> 30)))
+  (uint64_t) {                                                                 \
+    (uint64_t)((((t) >> 30) * 1000) +                                          \
+               ((((t)&0x3fffffff) * 1000 + (1 << 29)) >> 30))                  \
+  }
 #define CDTIME_T_TO_US(t)                                                      \
-  ((uint64_t)((((t) >> 30) * 1000000) +                                        \
-              ((((t)&0x3fffffff) * 1000000 + (1 << 29)) >> 30)))
+  (uint64_t) {                                                                 \
+    (uint64_t)((((t) >> 30) * 1000000) +                                       \
+               ((((t)&0x3fffffff) * 1000000 + (1 << 29)) >> 30))               \
+  }
 #define CDTIME_T_TO_NS(t)                                                      \
-  ((uint64_t)((((t) >> 30) * 1000000000) +                                     \
-              ((((t)&0x3fffffff) * 1000000000 + (1 << 29)) >> 30)))
-
-#define CDTIME_T_TO_DOUBLE(t) (((double)(t)) / 1073741824.0)
-#define DOUBLE_TO_CDTIME_T(d) ((cdtime_t)((d)*1073741824.0))
-
-#define CDTIME_T_TO_TIMEVAL(cdt, tvp)                                          \
-  do {                                                                         \
-    (tvp)->tv_sec = (time_t)((cdt) >> 30);                                     \
-    (tvp)->tv_usec =                                                           \
-        (suseconds_t)((((cdt)&0x3fffffff) * 1000000 + (1 << 29)) >> 30);       \
-  } while (0)
+  (uint64_t) {                                                                 \
+    (uint64_t)((((t) >> 30) * 1000000000) +                                    \
+               ((((t)&0x3fffffff) * 1000000000 + (1 << 29)) >> 30))            \
+  }
+
+#define CDTIME_T_TO_DOUBLE(t)                                                  \
+  (double) { ((double)(t)) / 1073741824.0 }
+#define DOUBLE_TO_CDTIME_T_STATIC(d) ((cdtime_t)((d)*1073741824.0))
+#define DOUBLE_TO_CDTIME_T(d)                                                  \
+  (cdtime_t) { DOUBLE_TO_CDTIME_T_STATIC(d) }
+
+#define CDTIME_T_TO_TIMEVAL(t)                                                 \
+  (struct timeval) {                                                           \
+    .tv_sec = (time_t)((t) >> 30),                                             \
+    .tv_usec = (suseconds_t)((((t)&0x3fffffff) * 1000000 + (1 << 29)) >> 30),  \
+  }
 #define TIMEVAL_TO_CDTIME_T(tv)                                                \
   US_TO_CDTIME_T(1000000 * (tv)->tv_sec + (tv)->tv_usec)
 
-#define CDTIME_T_TO_TIMESPEC(cdt, tsp)                                         \
-  do {                                                                         \
-    (tsp)->tv_sec = (time_t)((cdt) >> 30);                                     \
-    (tsp)->tv_nsec =                                                           \
-        (long)((((cdt)&0x3fffffff) * 1000000000 + (1 << 29)) >> 30);           \
-  } while (0)
+#define CDTIME_T_TO_TIMESPEC(t)                                                \
+  (struct timespec) {                                                          \
+    .tv_sec = (time_t)((t) >> 30),                                             \
+    .tv_nsec = (long)((((t)&0x3fffffff) * 1000000000 + (1 << 29)) >> 30),      \
+  }
 #define TIMESPEC_TO_CDTIME_T(ts)                                               \
   NS_TO_CDTIME_T(1000000000ULL * (ts)->tv_sec + (ts)->tv_nsec)
 
 cdtime_t cdtime(void);
 
-#define RFC3339_SIZE 26
-#define RFC3339NANO_SIZE 36
+#define RFC3339_SIZE 26     /* 2006-01-02T15:04:05+00:00 */
+#define RFC3339NANO_SIZE 36 /* 2006-01-02T15:04:05.999999999+00:00 */
 
-/* rfc3339 formats a cdtime_t time in RFC 3339 format with second precision. */
+/* rfc3339 formats a cdtime_t time as UTC in RFC 3339 zulu format with second
+ * precision, e.g., "2006-01-02T15:04:05Z". */
 int rfc3339(char *buffer, size_t buffer_size, cdtime_t t);
 
-/* rfc3339nano formats a cdtime_t time in RFC 3339 format with nanosecond
- * precision. */
+/* rfc3339nano formats a cdtime_t as UTC time in RFC 3339 zulu format with
+ * nanosecond precision, e.g., "2006-01-02T15:04:05.999999999Z". */
 int rfc3339nano(char *buffer, size_t buffer_size, cdtime_t t);
 
+/* rfc3339 formats a cdtime_t time as local in RFC 3339 format with second
+ * precision, e.g., "2006-01-02T15:04:05+00:00". */
+int rfc3339_local(char *buffer, size_t buffer_size, cdtime_t t);
+
+/* rfc3339nano formats a cdtime_t time as local in RFC 3339 format with
+ * nanosecond precision, e.g., "2006-01-02T15:04:05.999999999+00:00". */
+int rfc3339nano_local(char *buffer, size_t buffer_size, cdtime_t t);
+
 #endif /* UTILS_TIME_H */
 /* vim: set sw=2 sts=2 et : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_time_test.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_time_test.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/daemon/utils_time_test.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/daemon/utils_time_test.c	2016-12-12 16:03:36.708279115 +0800
@@ -114,28 +114,25 @@
        1439981150048ULL,
        {1439981150, 47590},
        {1439981150, 47589622}},
   };
 
   for (size_t i = 0; i < (sizeof(cases) / sizeof(cases[0])); i++) {
-    struct timeval tv;
-    struct timespec ts;
-
     // cdtime -> s
     EXPECT_EQ_UINT64(cases[i].tt, CDTIME_T_TO_TIME_T(cases[i].t));
 
     // cdtime -> ms
     EXPECT_EQ_UINT64(cases[i].ms, CDTIME_T_TO_MS(cases[i].t));
 
     // cdtime -> us
-    CDTIME_T_TO_TIMEVAL(cases[i].t, &tv);
+    struct timeval tv = CDTIME_T_TO_TIMEVAL(cases[i].t);
     EXPECT_EQ_UINT64(cases[i].tv.tv_sec, tv.tv_sec);
     EXPECT_EQ_UINT64(cases[i].tv.tv_usec, tv.tv_usec);
 
     // cdtime -> ns
-    CDTIME_T_TO_TIMESPEC(cases[i].t, &ts);
+    struct timespec ts = CDTIME_T_TO_TIMESPEC(cases[i].t);
     EXPECT_EQ_UINT64(cases[i].ts.tv_sec, ts.tv_sec);
     EXPECT_EQ_UINT64(cases[i].ts.tv_nsec, ts.tv_nsec);
 
     // cdtime -> double
     EXPECT_EQ_DOUBLE(cases[i].d, CDTIME_T_TO_DOUBLE(cases[i].t));
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/dbi.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/dbi.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/dbi.c	2017-10-06 14:45:59.829921543 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/dbi.c	2016-12-12 16:03:36.708279115 +0800
@@ -169,30 +169,25 @@
 static void cdbi_database_free(cdbi_database_t *db) /* {{{ */
 {
   if (db == NULL)
     return;
 
   sfree(db->name);
-  sfree(db->select_db);
   sfree(db->driver);
-  sfree(db->host);
 
   for (size_t i = 0; i < db->driver_options_num; i++) {
     sfree(db->driver_options[i].key);
     if (!db->driver_options[i].is_numeric)
       sfree(db->driver_options[i].value.string);
   }
   sfree(db->driver_options);
 
   if (db->q_prep_areas)
     for (size_t i = 0; i < db->queries_num; ++i)
       udb_query_delete_preparation_area(db->q_prep_areas[i]);
-  sfree(db->q_prep_areas);
-  /* N.B.: db->queries references objects "owned" by the global queries
-   * variable. Free the array here, but not the content. */
-  sfree(db->queries);
+  free(db->q_prep_areas);
 
   sfree(db);
 } /* }}} void cdbi_database_free */
 
 /* Configuration handling functions {{{
  *
@@ -354,29 +349,26 @@
 
     temp = realloc(databases, sizeof(*databases) * (databases_num + 1));
     if (temp == NULL) {
       ERROR("dbi plugin: realloc failed");
       status = -1;
     } else {
-      char *name = NULL;
-
       databases = temp;
       databases[databases_num] = db;
       databases_num++;
 
-      name = ssnprintf_alloc("dbi:%s", db->name);
-
-      user_data_t ud = {.data = db};
-
+      char *name = ssnprintf_alloc("dbi:%s", db->name);
       plugin_register_complex_read(
           /* group = */ NULL,
           /* name = */ name ? name : db->name,
           /* callback = */ cdbi_read_database,
           /* interval = */ (db->interval > 0) ? db->interval : 0,
-          /* user_data = */ &ud);
-      free(name);
+          &(user_data_t){
+              .data = db,
+          });
+      sfree(name);
     }
   }
 
   if (status != 0) {
     cdbi_database_free(db);
     return (-1);
@@ -411,19 +403,19 @@
 
   if (did_init != 0)
     return (0);
 
   if (queries_num == 0) {
     ERROR("dbi plugin: No <Query> blocks have been found. Without them, "
-          "this plugin can't do anything useful, so we will returns an error.");
+          "this plugin can't do anything useful, so we will return an error.");
     return (-1);
   }
 
   if (databases_num == 0) {
     ERROR("dbi plugin: No <Database> blocks have been found. Without them, "
-          "this plugin can't do anything useful, so we will returns an error.");
+          "this plugin can't do anything useful, so we will return an error.");
     return (-1);
   }
 
   status = dbi_initialize_r(/* driverdir = */ NULL, &dbi_instance);
   if (status < 0) {
     ERROR("dbi plugin: cdbi_init: dbi_initialize_r failed with status %i.",
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/df.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/df.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/df.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/df.c	2016-12-12 16:03:36.708279115 +0800
@@ -129,20 +129,16 @@
 }
 
 __attribute__((nonnull(2))) static void df_submit_one(char *plugin_instance,
                                                       const char *type,
                                                       const char *type_instance,
                                                       gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "df", sizeof(vl.plugin));
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
@@ -190,13 +186,14 @@
       if (dup_ptr == mnt_ptr) {
         dup_ptr = NULL;
         break;
       }
 
       /* Duplicate found: leave non-NULL dup_ptr. */
-      if (by_device &&
+      if (by_device && (mnt_ptr->spec_device != NULL) &&
+          (dup_ptr->spec_device != NULL) &&
           (strcmp(mnt_ptr->spec_device, dup_ptr->spec_device) == 0))
         break;
       else if (!by_device && (strcmp(mnt_ptr->dir, dup_ptr->dir) == 0))
         break;
     }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/disk.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/disk.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/disk.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/disk.c	2016-12-12 16:03:36.708279115 +0800
@@ -124,13 +124,13 @@
 extern kstat_ctl_t *kc;
 static kstat_t *ksp[MAX_NUMDISK];
 static int numdisk = 0;
 /* #endif HAVE_LIBKSTAT */
 
 #elif defined(HAVE_LIBSTATGRAB)
-/* #endif HAVE_LIBKSTATGRAB */
+/* #endif HAVE_LIBSTATGRAB */
 
 #elif HAVE_PERFSTAT
 static perfstat_disk_t *stat_disk;
 static int numdisk;
 static int pnumdisk;
 /* #endif HAVE_PERFSTAT */
@@ -267,58 +267,50 @@
 #endif /* KERNEL_LINUX */
   return (0);
 } /* int disk_shutdown */
 
 static void disk_submit(const char *plugin_instance, const char *type,
                         derive_t read, derive_t write) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = read;
-  values[1].derive = write;
+  value_t values[] = {
+      {.derive = read}, {.derive = write},
+  };
 
   vl.values = values;
-  vl.values_len = 2;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "disk", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* void disk_submit */
 
 #if KERNEL_FREEBSD || KERNEL_LINUX
 static void submit_io_time(char const *plugin_instance, derive_t io_time,
                            derive_t weighted_time) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = io_time;
-  values[1].derive = weighted_time;
+  value_t values[] = {
+      {.derive = io_time}, {.derive = weighted_time},
+  };
 
   vl.values = values;
-  vl.values_len = 2;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "disk", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "disk_io_time", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* void submit_io_time */
 #endif /* KERNEL_FREEBSD || KERNEL_LINUX */
 
 #if KERNEL_LINUX
 static void submit_in_progress(char const *disk_name, gauge_t in_progress) {
-  value_t v;
   value_list_t vl = VALUE_LIST_INIT;
 
-  v.gauge = in_progress;
-
-  vl.values = &v;
+  vl.values = &(value_t){.gauge = in_progress};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "disk", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, disk_name, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "pending_operations", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/dns.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/dns.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/dns.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/dns.c	2016-12-12 16:03:36.708279115 +0800
@@ -239,33 +239,21 @@
   pcap_close(pcap_obj);
   return (status);
 } /* int dns_run_pcap_loop */
 
 static int dns_sleep_one_interval(void) /* {{{ */
 {
-  cdtime_t interval;
-  struct timespec ts = {0, 0};
-  int status = 0;
-
-  interval = plugin_get_interval();
-  CDTIME_T_TO_TIMESPEC(interval, &ts);
-
-  while (42) {
-    struct timespec rem = {0, 0};
-
-    status = nanosleep(&ts, &rem);
-    if (status == 0)
-      break;
-    else if ((errno == EINTR) || (errno == EAGAIN)) {
-      ts = rem;
+  struct timespec ts = CDTIME_T_TO_TIMESPEC(plugin_get_interval());
+  while (nanosleep(&ts, &ts) != 0) {
+    if ((errno == EINTR) || (errno == EAGAIN))
       continue;
-    } else
-      break;
+
+    return (errno);
   }
 
-  return (status);
+  return (0);
 } /* }}} int dns_sleep_one_interval */
 
 static void *dns_child_loop(__attribute__((unused)) void *dummy) /* {{{ */
 {
   int status;
 
@@ -293,14 +281,14 @@
   tr_responses = 0;
   pthread_mutex_unlock(&traffic_mutex);
 
   if (listen_thread_init != 0)
     return (-1);
 
-  status =
-      plugin_thread_create(&listen_thread, NULL, dns_child_loop, (void *)0);
+  status = plugin_thread_create(&listen_thread, NULL, dns_child_loop, (void *)0,
+                                "dns listen");
   if (status != 0) {
     char errbuf[1024];
     ERROR("dns plugin: pthread_create failed: %s",
           sstrerror(errno, errbuf, sizeof(errbuf)));
     return (-1);
   }
@@ -322,37 +310,31 @@
 
   return (0);
 } /* int dns_init */
 
 static void submit_derive(const char *type, const char *type_instance,
                           derive_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.derive = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "dns", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void submit_derive */
 
 static void submit_octets(derive_t queries, derive_t responses) {
-  value_t values[2];
+  value_t values[] = {
+      {.derive = queries}, {.derive = responses},
+  };
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = queries;
-  values[1].derive = responses;
-
   vl.values = values;
-  vl.values_len = 2;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "dns", sizeof(vl.plugin));
   sstrncpy(vl.type, "dns_octets", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* void submit_octets */
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: dpdkstat.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/drbd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/drbd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/drbd.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/drbd.c	2016-12-12 16:03:36.708279115 +0800
@@ -88,13 +88,12 @@
     if (data == NULL)
       return (EINVAL);
     (void)parse_value(++data, &values[i], DS_TYPE_DERIVE);
   }
 
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "drbd", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "drbd_resource", sizeof(vl.type));
 
   for (size_t i = 0; i < fields_num; i++) {
     if (drbd_names[i] == NULL)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/email.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/email.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/email.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/email.c	2016-12-12 16:03:36.708279115 +0800
@@ -358,27 +358,27 @@
 
   pthread_exit((void *)0);
   return ((void *)0);
 } /* static void *collect (void *) */
 
 static void *open_connection(void __attribute__((unused)) * arg) {
-  struct sockaddr_un addr;
-
   const char *path = (NULL == sock_file) ? SOCK_PATH : sock_file;
   const char *group = (NULL == sock_group) ? COLLECTD_GRP_NAME : sock_group;
 
   /* create UNIX socket */
   errno = 0;
   if (-1 == (connector_socket = socket(PF_UNIX, SOCK_STREAM, 0))) {
     char errbuf[1024];
     disabled = 1;
     log_err("socket() failed: %s", sstrerror(errno, errbuf, sizeof(errbuf)));
     pthread_exit((void *)1);
   }
 
-  addr.sun_family = AF_UNIX;
+  struct sockaddr_un addr = {
+    .sun_family = AF_UNIX
+  };
   sstrncpy(addr.sun_path, path, (size_t)(UNIX_PATH_MAX - 1));
 
   errno = 0;
   if (-1 ==
       bind(connector_socket, (struct sockaddr *)&addr,
            offsetof(struct sockaddr_un, sun_path) + strlen(addr.sun_path))) {
@@ -400,27 +400,21 @@
     pthread_exit((void *)1);
   }
 
   {
     struct group sg;
     struct group *grp;
+    char grbuf[2048];
     int status;
 
-    long int grbuf_size = sysconf(_SC_GETGR_R_SIZE_MAX);
-    if (grbuf_size <= 0)
-      grbuf_size = sysconf(_SC_PAGESIZE);
-    if (grbuf_size <= 0)
-      grbuf_size = 4096;
-    char grbuf[grbuf_size];
-
     grp = NULL;
     status = getgrnam_r(group, &sg, grbuf, sizeof(grbuf), &grp);
     if (status != 0) {
       char errbuf[1024];
       log_warn("getgrnam_r (%s) failed: %s", group,
-               sstrerror(status, errbuf, sizeof(errbuf)));
+               sstrerror(errno, errbuf, sizeof(errbuf)));
     } else if (grp == NULL) {
       log_warn("No such group: `%s'", group);
     } else {
       status = chown(path, (uid_t)-1, grp->gr_gid);
       if (status != 0) {
         char errbuf[1024];
@@ -451,13 +445,13 @@
 
     for (int i = 0; i < max_conns; ++i) {
       collectors[i] = smalloc(sizeof(*collectors[i]));
       collectors[i]->socket = NULL;
 
       if (plugin_thread_create(&collectors[i]->thread, &ptattr, collect,
-                               collectors[i]) != 0) {
+                               collectors[i], "email collector") != 0) {
         char errbuf[1024];
         log_err("plugin_thread_create() failed: %s",
                 sstrerror(errno, errbuf, sizeof(errbuf)));
         collectors[i]->thread = (pthread_t)0;
       }
     }
@@ -534,13 +528,14 @@
 
   pthread_exit((void *)0);
   return ((void *)0);
 } /* static void *open_connection (void *) */
 
 static int email_init(void) {
-  if (plugin_thread_create(&connector, NULL, open_connection, NULL) != 0) {
+  if (plugin_thread_create(&connector, NULL, open_connection, NULL,
+                           "email listener") != 0) {
     char errbuf[1024];
     disabled = 1;
     log_err("plugin_thread_create() failed: %s",
             sstrerror(errno, errbuf, sizeof(errbuf)));
     return (-1);
   }
@@ -616,20 +611,16 @@
   sfree(sock_group);
   return (0);
 } /* static void email_shutdown (void) */
 
 static void email_submit(const char *type, const char *type_instance,
                          gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "email", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void email_submit */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/entropy.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/entropy.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/entropy.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/entropy.c	2016-12-12 16:03:36.708279115 +0800
@@ -32,47 +32,31 @@
 #if !KERNEL_LINUX
 #error "No applicable input method."
 #endif
 
 #define ENTROPY_FILE "/proc/sys/kernel/random/entropy_avail"
 
-static void entropy_submit(double entropy) {
-  value_t values[1];
+static void entropy_submit(value_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = entropy;
-
-  vl.values = values;
+  vl.values = &value;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "entropy", sizeof(vl.plugin));
   sstrncpy(vl.type, "entropy", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 }
 
 static int entropy_read(void) {
-  double entropy;
-  FILE *fh;
-  char buffer[64];
-
-  fh = fopen(ENTROPY_FILE, "r");
-  if (fh == NULL)
-    return (-1);
-
-  if (fgets(buffer, sizeof(buffer), fh) == NULL) {
-    fclose(fh);
+  value_t v;
+  if (parse_value_file(ENTROPY_FILE, &v, DS_TYPE_GAUGE) != 0) {
+    ERROR("entropy plugin: Reading \"" ENTROPY_FILE "\" failed.");
     return (-1);
   }
-  fclose(fh);
-
-  entropy = atof(buffer);
-
-  if (entropy > 0.0)
-    entropy_submit(entropy);
 
+  entropy_submit(v);
   return (0);
 }
 
 void module_register(void) {
   plugin_register_read("entropy", entropy_read);
 } /* void module_register */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ethstat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ethstat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ethstat.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ethstat.c	2016-12-12 16:03:36.708279115 +0800
@@ -158,13 +158,12 @@
 } /* }}} */
 
 static void ethstat_submit_value(const char *device, const char *type_instance,
                                  derive_t value) {
   static c_complain_t complain_no_map = C_COMPLAIN_INIT_STATIC;
 
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
   value_map_t *map = NULL;
 
   if (value_map != NULL)
     c_avl_get(value_map, type_instance, (void *)&map);
 
@@ -175,17 +174,15 @@
           LOG_WARNING, &complain_no_map,
           "ethstat plugin: The \"MappedOnly\" option has been set to true, "
           "but no mapping has been configured. All values will be ignored!");
     return;
   }
 
-  values[0].derive = value;
-  vl.values = values;
+  vl.values = &(value_t){.derive = value};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ethstat", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, device, sizeof(vl.plugin_instance));
   if (map != NULL) {
     sstrncpy(vl.type, map->type, sizeof(vl.type));
     sstrncpy(vl.type_instance, map->type_instance, sizeof(vl.type_instance));
   } else {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/exec.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/exec.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/exec.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/exec.c	2016-12-12 16:03:36.708279115 +0800
@@ -247,13 +247,13 @@
 
 #ifdef HAVE_SETENV
   ssnprintf(buffer, sizeof(buffer), "%.3f",
             CDTIME_T_TO_DOUBLE(plugin_get_interval()));
   setenv("COLLECTD_INTERVAL", buffer, /* overwrite = */ 1);
 
-  ssnprintf(buffer, sizeof(buffer), "%s", hostname_g);
+  sstrncpy(buffer, hostname_g, sizeof(buffer));
   setenv("COLLECTD_HOSTNAME", buffer, /* overwrite = */ 1);
 #else
   ssnprintf(buffer, sizeof(buffer), "COLLECTD_INTERVAL=%.3f",
             CDTIME_T_TO_DOUBLE(plugin_get_interval()));
   putenv(buffer);
 
@@ -366,32 +366,26 @@
   int uid;
   int gid;
   int egid;
 
   struct passwd *sp_ptr;
   struct passwd sp;
+  char nambuf[2048];
 
   if (pl->pid != 0)
     return (-1);
 
-  long int nambuf_size = sysconf(_SC_GETPW_R_SIZE_MAX);
-  if (nambuf_size <= 0)
-    nambuf_size = sysconf(_SC_PAGESIZE);
-  if (nambuf_size <= 0)
-    nambuf_size = 4096;
-  char nambuf[nambuf_size];
-
   if ((create_pipe(fd_pipe_in) == -1) || (create_pipe(fd_pipe_out) == -1) ||
       (create_pipe(fd_pipe_err) == -1))
     goto failed;
 
   sp_ptr = NULL;
   status = getpwnam_r(pl->user, &sp, nambuf, sizeof(nambuf), &sp_ptr);
   if (status != 0) {
     ERROR("exec plugin: Failed to get user information for user ``%s'': %s",
-          pl->user, sstrerror(status, errbuf, sizeof(errbuf)));
+          pl->user, sstrerror(errno, errbuf, sizeof(errbuf)));
     goto failed;
   }
 
   if (sp_ptr == NULL) {
     ERROR("exec plugin: No such user: `%s'", pl->user);
     goto failed;
@@ -409,24 +403,17 @@
   egid = -1;
   if (NULL != pl->group) {
     if ('\0' != *pl->group) {
       struct group *gr_ptr = NULL;
       struct group gr;
 
-      long int grbuf_size = sysconf(_SC_GETGR_R_SIZE_MAX);
-      if (grbuf_size <= 0)
-        grbuf_size = sysconf(_SC_PAGESIZE);
-      if (grbuf_size <= 0)
-        grbuf_size = 4096;
-      char grbuf[grbuf_size];
-
-      status = getgrnam_r(pl->group, &gr, grbuf, sizeof(grbuf), &gr_ptr);
+      status = getgrnam_r(pl->group, &gr, nambuf, sizeof(nambuf), &gr_ptr);
       if (0 != status) {
         ERROR("exec plugin: Failed to get group information "
               "for group ``%s'': %s",
-              pl->group, sstrerror(status, errbuf, sizeof(errbuf)));
+              pl->group, sstrerror(errno, errbuf, sizeof(errbuf)));
         goto failed;
       }
       if (NULL == gr_ptr) {
         ERROR("exec plugin: No such group: `%s'", pl->group);
         goto failed;
       }
@@ -510,13 +497,13 @@
   return (-1);
 } /* int fork_child }}} */
 
 static int parse_line(char *buffer) /* {{{ */
 {
   if (strncasecmp("PUTVAL", buffer, strlen("PUTVAL")) == 0)
-    return (handle_putval(stdout, buffer));
+    return (cmd_handle_putval(stdout, buffer));
   else if (strncasecmp("PUTNOTIF", buffer, strlen("PUTNOTIF")) == 0)
     return (handle_putnotif(stdout, buffer));
   else {
     ERROR("exec plugin: Unable to parse command, ignoring line: \"%s\"",
           buffer);
     return (-1);
@@ -797,13 +784,13 @@
     }
     pl->flags |= PL_RUNNING;
     pthread_mutex_unlock(&pl_lock);
 
     pthread_attr_init(&attr);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    plugin_thread_create(&t, &attr, exec_read_one, (void *)pl);
+    plugin_thread_create(&t, &attr, exec_read_one, (void *)pl, "exec read");
     pthread_attr_destroy(&attr);
   } /* for (pl) */
 
   return (0);
 } /* int exec_read }}} */
 
@@ -836,13 +823,14 @@
      * will run into an endless loop. */
     pln->n.meta = NULL;
     plugin_notification_meta_copy(&pln->n, n);
 
     pthread_attr_init(&attr);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    plugin_thread_create(&t, &attr, exec_notification_one, (void *)pln);
+    plugin_thread_create(&t, &attr, exec_notification_one, (void *)pln,
+                         "exec notify");
     pthread_attr_destroy(&attr);
   } /* for (pl) */
 
   return (0);
 } /* }}} int exec_notification */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/fhcount.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/fhcount.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/fhcount.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/fhcount.c	2016-12-12 16:03:36.708279115 +0800
@@ -51,23 +51,18 @@
 
   return (ret);
 }
 
 static void fhcount_submit(const char *type, const char *type_instance,
                            gauge_t value) {
-
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
   // Compose the metric
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "fhcount", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   // Dispatch the metric
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/filecount.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/filecount.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/filecount.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/filecount.c	2016-12-12 16:03:36.708279115 +0800
@@ -56,27 +56,23 @@
 typedef struct fc_directory_conf_s fc_directory_conf_t;
 
 static fc_directory_conf_t **directories = NULL;
 static size_t directories_num = 0;
 
 static void fc_submit_dir(const fc_directory_conf_t *dir) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = (gauge_t)dir->files_num;
-
-  vl.values = values;
-  vl.values_len = STATIC_ARRAY_SIZE(values);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values = &(value_t){.gauge = (gauge_t)dir->files_num};
+  vl.values_len = 1;
   sstrncpy(vl.plugin, "filecount", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, dir->instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "files", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 
-  values[0].gauge = (gauge_t)dir->files_size;
+  vl.values = &(value_t){.gauge = (gauge_t)dir->files_size};
   sstrncpy(vl.type, "bytes", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* void fc_submit_dir */
 
 /*
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/fscache.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/fscache.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/fscache.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/fscache.c	2016-12-12 16:03:36.708279115 +0800
@@ -110,13 +110,12 @@
                            value_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = &value;
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "fscache", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, section, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "fscache_stat", sizeof(vl.type));
   sstrncpy(vl.type_instance, name, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/gmond.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/gmond.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/gmond.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/gmond.c	2016-12-12 16:03:36.708279115 +0800
@@ -809,14 +809,15 @@
 
   if (mc_receive_thread_running != 0)
     return (-1);
 
   mc_receive_thread_loop = 1;
 
-  status = plugin_thread_create(&mc_receive_thread_id, /* attr = */ NULL,
-                                mc_receive_thread, /* args = */ NULL);
+  status =
+      plugin_thread_create(&mc_receive_thread_id, /* attr = */ NULL,
+                           mc_receive_thread, /* args = */ NULL, "gmond recv");
   if (status != 0) {
     ERROR("gmond plugin: Starting receive thread failed.");
     mc_receive_thread_loop = 0;
     return (-1);
   }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/gps.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/gps.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/gps.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/gps.c	2016-12-12 16:03:36.708279115 +0800
@@ -61,37 +61,30 @@
 
 static cgps_data_t cgps_data = {NAN, NAN, NAN, NAN};
 
 static pthread_t cgps_thread_id;
 static pthread_mutex_t cgps_data_lock = PTHREAD_MUTEX_INITIALIZER;
 static pthread_mutex_t cgps_thread_lock = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t cgps_thread_cond = PTHREAD_COND_INITIALIZER;
 static int cgps_thread_shutdown = CGPS_FALSE;
 static int cgps_thread_running = CGPS_FALSE;
 
 /**
  * Non blocking pause for the thread.
  */
 static int cgps_thread_pause(cdtime_t pTime) {
-  cdtime_t now;
-  now = cdtime();
-  struct timespec pause_th;
-  CDTIME_T_TO_TIMESPEC(MS_TO_CDTIME_T(10), &pause_th);
-  while (CGPS_TRUE) {
-    if ((cdtime() - now) > pTime) {
-      break;
-    }
+  cdtime_t until = cdtime() + pTime;
 
-    pthread_mutex_lock(&cgps_thread_lock);
-    if (cgps_thread_shutdown == CGPS_TRUE) {
-      return CGPS_FALSE;
-    }
-    pthread_mutex_unlock(&cgps_thread_lock);
-    nanosleep(&pause_th, NULL);
-  }
+  pthread_mutex_lock(&cgps_thread_lock);
+  pthread_cond_timedwait(&cgps_thread_cond, &cgps_thread_lock,
+                         &CDTIME_T_TO_TIMESPEC(until));
+
+  int ret = !cgps_thread_shutdown;
 
-  return CGPS_TRUE;
+  pthread_mutex_lock(&cgps_thread_lock);
+  return ret;
 }
 
 /**
  * Thread reading from gpsd.
  */
 static void *cgps_thread(void *pData) {
@@ -204,20 +197,16 @@
 
 /**
  * Submit a piece of the data.
  */
 static void cgps_submit(const char *type, gauge_t value,
                         const char *type_instance) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "gps", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
@@ -290,13 +279,14 @@
   DEBUG("gps plugin: config{host: \"%s\", port: \"%s\", timeout: %.6f sec., "
         "pause connect: %.3f sec.}",
         cgps_config_data.host, cgps_config_data.port,
         CDTIME_T_TO_DOUBLE(cgps_config_data.timeout),
         CDTIME_T_TO_DOUBLE(cgps_config_data.pause_connect));
 
-  status = plugin_thread_create(&cgps_thread_id, NULL, cgps_thread, NULL);
+  status =
+      plugin_thread_create(&cgps_thread_id, NULL, cgps_thread, NULL, "gps");
   if (status != 0) {
     ERROR("gps plugin: pthread_create() failed.");
     return (-1);
   }
 
   return (0);
@@ -307,12 +297,13 @@
  */
 static int cgps_shutdown(void) {
   void *res;
 
   pthread_mutex_lock(&cgps_thread_lock);
   cgps_thread_shutdown = CGPS_TRUE;
+  pthread_cond_broadcast(&cgps_thread_cond);
   pthread_mutex_unlock(&cgps_thread_lock);
 
   pthread_join(cgps_thread_id, &res);
   free(res);
 
   // Clean mutex:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/grpc.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/grpc.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/grpc.cc	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/grpc.cc	2016-12-12 16:03:36.708279115 +0800
@@ -1,9 +1,10 @@
 /**
  * collectd - src/grpc.cc
  * Copyright (C) 2015-2016 Sebastian Harl
+ * Copyright (C) 2016      Florian octo Forster
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
  * to deal in the Software without restriction, including without limitation
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
@@ -19,12 +20,13 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  *
  * Authors:
  *   Sebastian Harl <sh at tokkee.org>
+ *   Florian octo Forster <octo at collectd.org>
  **/
 
 #include <grpc++/grpc++.h>
 #include <google/protobuf/util/time_util.h>
 
 #include <fstream>
@@ -44,14 +46,14 @@
 
 #include "daemon/utils_cache.h"
 }
 
 using collectd::Collectd;
 
-using collectd::DispatchValuesRequest;
-using collectd::DispatchValuesResponse;
+using collectd::PutValuesRequest;
+using collectd::PutValuesResponse;
 using collectd::QueryValuesRequest;
 using collectd::QueryValuesResponse;
 
 using google::protobuf::util::TimeUtil;
 
 /*
@@ -280,19 +282,19 @@
 			sfree(vl.values);
 		}
 
 		return status;
 	}
 
-	grpc::Status DispatchValues(grpc::ServerContext *ctx,
-								grpc::ServerReader<DispatchValuesRequest> *reader,
-								DispatchValuesResponse *res) override {
-		DispatchValuesRequest req;
+	grpc::Status PutValues(grpc::ServerContext *ctx,
+						   grpc::ServerReader<PutValuesRequest> *reader,
+						   PutValuesResponse *res) override {
+		PutValuesRequest req;
 
 		while (reader->Read(&req)) {
-			value_list_t vl = VALUE_LIST_INIT;
+			value_list_t vl = {0};
 			auto status = unmarshal_value_list(req.value_list(), &vl);
 			if (!status.ok())
 				return status;
 
 			if (plugin_dispatch_values(&vl))
 				return grpc::Status(grpc::StatusCode::INTERNAL,
@@ -423,24 +425,24 @@
 class CollectdClient final
 {
 public:
 	CollectdClient(std::shared_ptr<grpc::ChannelInterface> channel) : stub_(Collectd::NewStub(channel)) {
 	}
 
-	int DispatchValues(value_list_t const *vl) {
+	int PutValues(value_list_t const *vl) {
 		grpc::ClientContext ctx;
 
-		DispatchValuesRequest req;
+		PutValuesRequest req;
 		auto status = marshal_value_list(vl, req.mutable_value_list());
 		if (!status.ok()) {
 			ERROR("grpc: Marshalling value_list_t failed.");
 			return -1;
 		}
 
-		DispatchValuesResponse res;
-		auto stream = stub_->DispatchValues(&ctx, &res);
+		PutValuesResponse res;
+		auto stream = stub_->PutValues(&ctx, &res);
 		if (!stream->Write(req)) {
 			NOTICE("grpc: Broken stream.");
 			/* intentionally not returning. */
 		}
 
 		stream->WritesDone();
@@ -448,13 +450,13 @@
 		if (!status.ok()) {
 			ERROR ("grpc: Error while closing stream.");
 			return -1;
 		}
 
 		return 0;
-	} /* int DispatchValues */
+	} /* int PutValues */
 
 private:
 	std::unique_ptr<Collectd::Stub> stub_;
 };
 
 static CollectdServer *server = nullptr;
@@ -468,13 +470,13 @@
 	}
 
 	static int c_grpc_write(__attribute__((unused)) data_set_t const *ds,
 			value_list_t const *vl,
 			user_data_t *ud) {
 		CollectdClient *c = (CollectdClient *) ud->data;
-		return c->DispatchValues(vl);
+		return c->PutValues(vl);
 	}
 
 	static int c_grpc_config_listen(oconfig_item_t *ci)
 	{
 		if ((ci->values_num != 2)
 				|| (ci->values[0].type != OCONFIG_TYPE_STRING)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/hddtemp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/hddtemp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/hddtemp.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/hddtemp.c	2016-12-12 16:03:36.708279115 +0800
@@ -1,11 +1,12 @@
 /**
  * collectd - src/hddtemp.c
  * Copyright (C) 2005,2006  Vincent Stehl
  * Copyright (C) 2006-2010  Florian octo Forster
  * Copyright (C) 2008       Sebastian Harl
+ * Copyright (C) 2014       Carnegie Mellon University
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; either version 2 of the License, or (at your
  * option) any later version.
  *
@@ -19,35 +20,38 @@
  * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
  *
  * Authors:
  *   Vincent Stehl <vincent.stehle at free.fr>
  *   Florian octo Forster <octo at collectd.org>
  *   Sebastian Harl <sh at tokkee.org>
+ *   Benjamin Gilbert <bgilbert at backtick.net>
  *
  * TODO:
  *   Do a pass, some day, and spare some memory. We consume too much for now
  *   in string buffers and the like.
  *
  **/
 
 #include "collectd.h"
 
 #include "common.h"
 #include "plugin.h"
 
+#include <assert.h>
 #include <libgen.h> /* for basename */
 #include <netdb.h>
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 
 #if HAVE_LINUX_MAJOR_H
 #include <linux/major.h>
 #endif
 
 #define HDDTEMP_DEF_HOST "127.0.0.1"
 #define HDDTEMP_DEF_PORT "7634"
+#define HDDTEMP_MAX_RECV_BUF (1 << 20)
 
 static const char *config_keys[] = {"Host", "Port"};
 static int config_keys_num = STATIC_ARRAY_SIZE(config_keys);
 
 static char *hddtemp_host = NULL;
 static char hddtemp_port[16];
@@ -72,16 +76,20 @@
  *    |/dev/hda|ST380011A|46|C||/dev/hdd|ST340016A|SLP|*|
  *
  * FIXME:
  *  we need to create a new socket each time. Is there another way?
  *  Hm, maybe we can re-use the `sockaddr' structure? -octo
  */
-static int hddtemp_query_daemon(char *buffer, int buffer_size) {
+static char *hddtemp_query_daemon(void) {
   int fd;
   ssize_t status;
+
+  char *buffer;
+  int buffer_size;
   int buffer_fill;
+  char *new_buffer;
 
   const char *host;
   const char *port;
 
   struct addrinfo *ai_list;
   int ai_return;
@@ -101,13 +109,13 @@
 
   if ((ai_return = getaddrinfo(host, port, &ai_hints, &ai_list)) != 0) {
     char errbuf[1024];
     ERROR("hddtemp plugin: getaddrinfo (%s, %s): %s", host, port,
           (ai_return == EAI_SYSTEM) ? sstrerror(errno, errbuf, sizeof(errbuf))
                                     : gai_strerror(ai_return));
-    return (-1);
+    return (NULL);
   }
 
   fd = -1;
   for (struct addrinfo *ai_ptr = ai_list; ai_ptr != NULL;
        ai_ptr = ai_ptr->ai_next) {
     /* create our socket descriptor */
@@ -135,52 +143,70 @@
   }
 
   freeaddrinfo(ai_list);
 
   if (fd < 0) {
     ERROR("hddtemp plugin: Could not connect to daemon.");
-    return (-1);
+    return (NULL);
   }
 
   /* receive data from the hddtemp daemon */
-  memset(buffer, '\0', buffer_size);
-
+  buffer = NULL;
+  buffer_size = 0;
   buffer_fill = 0;
-  while ((status = read(fd, buffer + buffer_fill, buffer_size - buffer_fill)) !=
-         0) {
-    if (status == -1) {
+  while (1) {
+    if ((buffer_size == 0) || (buffer_fill >= buffer_size - 1)) {
+      if (buffer_size == 0)
+        buffer_size = 1024;
+      else
+        buffer_size *= 2;
+      if (buffer_size > HDDTEMP_MAX_RECV_BUF) {
+        WARNING("hddtemp plugin: Message from hddtemp has been "
+                "truncated.");
+        break;
+      }
+      new_buffer = realloc(buffer, buffer_size);
+      if (new_buffer == NULL) {
+        close(fd);
+        free(buffer);
+        ERROR("hddtemp plugin: Allocation failed.");
+        return (NULL);
+      }
+      buffer = new_buffer;
+    }
+    status = read(fd, buffer + buffer_fill, buffer_size - buffer_fill - 1);
+    if (status == 0) {
+      break;
+    } else if (status == -1) {
       char errbuf[1024];
 
       if ((errno == EAGAIN) || (errno == EINTR))
         continue;
 
       ERROR("hddtemp plugin: Error reading from socket: %s",
             sstrerror(errno, errbuf, sizeof(errbuf)));
       close(fd);
-      return (-1);
+      free(buffer);
+      return (NULL);
     }
     buffer_fill += status;
-
-    if (buffer_fill >= buffer_size)
-      break;
   }
 
-  if (buffer_fill >= buffer_size) {
-    buffer[buffer_size - 1] = '\0';
-    WARNING("hddtemp plugin: Message from hddtemp has been "
-            "truncated.");
-  } else if (buffer_fill == 0) {
+  if (buffer_fill == 0) {
     WARNING("hddtemp plugin: Peer has unexpectedly shut down "
             "the socket. Buffer: `%s'",
             buffer);
     close(fd);
-    return (-1);
+    free(buffer);
+    return (NULL);
   }
 
+  assert(buffer_fill < buffer_size);
+  buffer[buffer_fill] = '\0';
   close(fd);
-  return (0);
+  return (buffer);
 }
 
 static int hddtemp_config(const char *key, const char *value) {
   if (strcasecmp(key, "Host") == 0) {
     if (hddtemp_host != NULL)
       free(hddtemp_host);
@@ -196,74 +222,63 @@
   }
 
   return (0);
 }
 
 static void hddtemp_submit(char *type_instance, double value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "hddtemp", sizeof(vl.plugin));
   sstrncpy(vl.type, "temperature", sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
 static int hddtemp_read(void) {
-  char buf[1024];
-  char *fields[128];
+  char *buf;
   char *ptr;
   char *saveptr;
-  int num_fields;
-  int num_disks;
+  char *name;
+  char *model;
+  char *temperature;
+  char *mode;
 
   /* get data from daemon */
-  if (hddtemp_query_daemon(buf, sizeof(buf)) < 0)
+  buf = hddtemp_query_daemon();
+  if (buf == NULL)
     return (-1);
 
   /* NB: strtok_r will eat up "||" and leading "|"'s */
-  num_fields = 0;
   ptr = buf;
   saveptr = NULL;
-  while ((fields[num_fields] = strtok_r(ptr, "|", &saveptr)) != NULL) {
-    ptr = NULL;
-    num_fields++;
+  while ((name = strtok_r(ptr, "|", &saveptr)) != NULL &&
+         (model = strtok_r(NULL, "|", &saveptr)) != NULL &&
+         (temperature = strtok_r(NULL, "|", &saveptr)) != NULL &&
+         (mode = strtok_r(NULL, "|", &saveptr)) != NULL) {
+    double temperature_value;
 
-    if (num_fields >= 128)
-      break;
-  }
-
-  num_disks = num_fields / 4;
-
-  for (int i = 0; i < num_disks; i++) {
-    char *name;
-    double temperature;
-    char *mode;
-
-    mode = fields[4 * i + 3];
-    name = basename(fields[4 * i + 0]);
+    ptr = NULL;
 
     /* Skip non-temperature information */
     if (mode[0] != 'C' && mode[0] != 'F')
       continue;
 
-    temperature = atof(fields[4 * i + 2]);
+    name = basename(name);
+    temperature_value = atof(temperature);
 
     /* Convert farenheit to celsius */
     if (mode[0] == 'F')
-      temperature = (temperature - 32.0) * 5.0 / 9.0;
+      temperature_value = (temperature_value - 32.0) * 5.0 / 9.0;
 
-    hddtemp_submit(name, temperature);
+    hddtemp_submit(name, temperature_value);
   }
 
+  free(buf);
   return (0);
 } /* int hddtemp_read */
 
 /* module_register
    Register collectd plugin. */
 void module_register(void) {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: hugepages.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: intel_rdt.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/interface.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/interface.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/interface.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/interface.c	2016-12-12 16:03:36.708279115 +0800
@@ -152,24 +152,22 @@
   return (0);
 } /* int interface_init */
 #endif /* HAVE_LIBKSTAT */
 
 static void if_submit(const char *dev, const char *type, derive_t rx,
                       derive_t tx) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
+  value_t values[] = {
+      {.derive = rx}, {.derive = tx},
+  };
 
   if (ignorelist_match(ignorelist, dev) != 0)
     return;
 
-  values[0].derive = rx;
-  values[1].derive = tx;
-
   vl.values = values;
-  vl.values_len = 2;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "interface", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, dev, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* void if_submit */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ipc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ipc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ipc.c	2017-10-06 14:45:52.949917758 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ipc.c	2016-12-12 16:03:36.708279115 +0800
@@ -92,20 +92,16 @@
 #endif
 
 __attribute__((nonnull(1))) static void
 ipc_submit_g(const char *plugin_instance, const char *type,
              const char *type_instance, gauge_t value) /* {{{ */
 {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ipc", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
@@ -252,20 +248,20 @@
 static int ipc_read_shm(void) /* {{{ */
 {
   ipcinfo_shm_t *ipcinfo_shm;
   ipcinfo_shm_t *pshm;
   unsigned int shm_segments = 0;
   size64_t shm_bytes = 0;
-  int i, n;
+  int n;
 
   ipcinfo_shm = (ipcinfo_shm_t *)ipc_get_info(
       0, GET_IPCINFO_SHM_ALL, IPCINFO_SHM_VERSION, sizeof(ipcinfo_shm_t), &n);
   if (ipcinfo_shm == NULL)
     return -1;
 
-  for (i = 0, pshm = ipcinfo_shm; i < n; i++, pshm++) {
+  for (int i = 0, pshm = ipcinfo_shm; i < n; i++, pshm++) {
     shm_segments++;
     shm_bytes += pshm->shm_segsz;
   }
   free(ipcinfo_shm);
 
   ipc_submit_g("shm", "segments", NULL, shm_segments);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ipmi.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ipmi.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ipmi.c	2017-10-06 14:45:52.953917759 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ipmi.c	2016-12-12 16:03:36.708279115 +0800
@@ -99,13 +99,12 @@
 static void sensor_read_handler(ipmi_sensor_t *sensor, int err,
                                 enum ipmi_value_present_e value_present,
                                 unsigned int __attribute__((unused)) raw_value,
                                 double value,
                                 ipmi_states_t __attribute__((unused)) * states,
                                 void *user_data) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
   c_ipmi_sensor_list_t *list_item = (c_ipmi_sensor_list_t *)user_data;
 
   if (err != 0) {
     if ((err & 0xff) == IPMI_NOT_PRESENT_CC) {
@@ -188,18 +187,15 @@
          (value_present == IPMI_RAW_VALUE_PRESENT) ? "only the raw value"
                                                    : "no value");
     sensor_list_remove(sensor);
     return;
   }
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ipmi", sizeof(vl.plugin));
   sstrncpy(vl.type, list_item->sensor_type, sizeof(vl.type));
   sstrncpy(vl.type_instance, list_item->sensor_name, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void sensor_read_handler */
@@ -576,13 +572,13 @@
   time_t iv = CDTIME_T_TO_TIME_T(plugin_get_interval());
   c_ipmi_init_in_progress = 1 + (60 / iv);
 
   c_ipmi_active = 1;
 
   status = plugin_thread_create(&thread_id, /* attr = */ NULL, thread_main,
-                                /* user data = */ NULL);
+                                /* user data = */ NULL, "ipmi");
   if (status != 0) {
     c_ipmi_active = 0;
     thread_id = (pthread_t)0;
     ERROR("ipmi plugin: pthread_create failed.");
     return (-1);
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/iptables.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/iptables.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/iptables.c	2017-10-06 14:45:52.953917759 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/iptables.c	2016-12-12 16:03:36.712279086 +0800
@@ -207,13 +207,12 @@
 } /* int iptables_config */
 
 static int submit6_match(const struct ip6t_entry_match *match,
                          const struct ip6t_entry *entry,
                          const ip_chain_t *chain, int rule_num) {
   int status;
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
   /* Select the rules to collect */
   if (chain->rule_type == RTYPE_NUM) {
     if (chain->rule.num != rule_num)
       return (0);
@@ -222,15 +221,12 @@
       return (0);
     if ((chain->rule_type == RTYPE_COMMENT) &&
         (strcmp(chain->rule.comment, (char *)match->data) != 0))
       return (0);
   }
 
-  vl.values = values;
-  vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ip6tables", sizeof(vl.plugin));
 
   status = ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%s-%s",
                      chain->table, chain->chain);
   if ((status < 1) || ((unsigned int)status >= sizeof(vl.plugin_instance)))
     return (0);
@@ -243,28 +239,28 @@
                 chain->rule.num);
     else
       sstrncpy(vl.type_instance, (char *)match->data, sizeof(vl.type_instance));
   }
 
   sstrncpy(vl.type, "ipt_bytes", sizeof(vl.type));
-  values[0].derive = (derive_t)entry->counters.bcnt;
+  vl.values = &(value_t){.derive = (derive_t)entry->counters.bcnt};
+  vl.values_len = 1;
   plugin_dispatch_values(&vl);
 
   sstrncpy(vl.type, "ipt_packets", sizeof(vl.type));
-  values[0].derive = (derive_t)entry->counters.pcnt;
+  vl.values = &(value_t){.derive = (derive_t)entry->counters.pcnt};
   plugin_dispatch_values(&vl);
 
   return (0);
-} /* int submit_match */
+} /* int submit6_match */
 
 /* This needs to return `int' for IPT_MATCH_ITERATE to work. */
 static int submit_match(const struct ipt_entry_match *match,
                         const struct ipt_entry *entry, const ip_chain_t *chain,
                         int rule_num) {
   int status;
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
   /* Select the rules to collect */
   if (chain->rule_type == RTYPE_NUM) {
     if (chain->rule.num != rule_num)
       return (0);
@@ -273,15 +269,12 @@
       return (0);
     if ((chain->rule_type == RTYPE_COMMENT) &&
         (strcmp(chain->rule.comment, (char *)match->data) != 0))
       return (0);
   }
 
-  vl.values = values;
-  vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "iptables", sizeof(vl.plugin));
 
   status = ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%s-%s",
                      chain->table, chain->chain);
   if ((status < 1) || ((unsigned int)status >= sizeof(vl.plugin_instance)))
     return (0);
@@ -294,17 +287,18 @@
                 chain->rule.num);
     else
       sstrncpy(vl.type_instance, (char *)match->data, sizeof(vl.type_instance));
   }
 
   sstrncpy(vl.type, "ipt_bytes", sizeof(vl.type));
-  values[0].derive = (derive_t)entry->counters.bcnt;
+  vl.values = &(value_t){.derive = (derive_t)entry->counters.bcnt};
+  vl.values_len = 1;
   plugin_dispatch_values(&vl);
 
   sstrncpy(vl.type, "ipt_packets", sizeof(vl.type));
-  values[0].derive = (derive_t)entry->counters.pcnt;
+  vl.values = &(value_t){.derive = (derive_t)entry->counters.pcnt};
   plugin_dispatch_values(&vl);
 
   return (0);
 } /* int submit_match */
 
 /* ipv6 submit_chain */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ipvs.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ipvs.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ipvs.c	2017-10-06 14:45:52.953917759 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ipvs.c	2016-12-12 16:03:36.712279086 +0800
@@ -217,43 +217,37 @@
   }
   return 0;
 } /* get_ti */
 
 static void cipvs_submit_connections(const char *pi, const char *ti,
                                      derive_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.derive = value};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ipvs", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, pi, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "connections", sizeof(vl.type));
   sstrncpy(vl.type_instance, (NULL != ti) ? ti : "total",
            sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
   return;
 } /* cipvs_submit_connections */
 
 static void cipvs_submit_if(const char *pi, const char *t, const char *ti,
                             derive_t rx, derive_t tx) {
-  value_t values[2];
+  value_t values[] = {
+      {.derive = rx}, {.derive = tx},
+  };
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = rx;
-  values[1].derive = tx;
-
   vl.values = values;
-  vl.values_len = 2;
+  vl.values_len = STATIC_ARRAY_SIZE(values);
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ipvs", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, pi, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, t, sizeof(vl.type));
   sstrncpy(vl.type_instance, (NULL != ti) ? ti : "total",
            sizeof(vl.type_instance));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/irq.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/irq.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/irq.c	2017-10-06 14:45:52.953917759 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/irq.c	2016-12-12 16:03:36.712279086 +0800
@@ -58,23 +58,19 @@
   }
 
   return (0);
 }
 
 static void irq_submit(const char *irq_name, derive_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
   if (ignorelist_match(ignorelist, irq_name) != 0)
     return;
 
-  values[0].derive = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.derive = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "irq", sizeof(vl.plugin));
   sstrncpy(vl.type, "irq", sizeof(vl.type));
   sstrncpy(vl.type_instance, irq_name, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void irq_submit */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/java.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/java.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/java.c	2017-10-06 14:45:52.953917759 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/java.c	2016-12-12 16:03:36.712279086 +0800
@@ -1301,16 +1301,18 @@
   cbi = cjni_callback_info_create(jvm_env, o_name, o_read, CB_TYPE_READ);
   if (cbi == NULL)
     return (-1);
 
   DEBUG("java plugin: Registering new read callback: %s", cbi->name);
 
-  user_data_t ud = {.data = cbi, .free_func = cjni_callback_info_destroy};
-
-  plugin_register_complex_read(/* group = */ NULL, cbi->name, cjni_read,
-                               /* interval = */ 0, &ud);
+  plugin_register_complex_read(
+      /* group = */ NULL, cbi->name, cjni_read,
+      /* interval = */ 0,
+      &(user_data_t){
+          .data = cbi, .free_func = cjni_callback_info_destroy,
+      });
 
   (*jvm_env)->DeleteLocalRef(jvm_env, o_read);
 
   return (0);
 } /* }}} jint cjni_api_register_read */
 
@@ -1322,15 +1324,17 @@
   cbi = cjni_callback_info_create(jvm_env, o_name, o_write, CB_TYPE_WRITE);
   if (cbi == NULL)
     return (-1);
 
   DEBUG("java plugin: Registering new write callback: %s", cbi->name);
 
-  user_data_t ud = {.data = cbi, .free_func = cjni_callback_info_destroy};
-
-  plugin_register_write(cbi->name, cjni_write, &ud);
+  plugin_register_write(
+      cbi->name, cjni_write,
+      &(user_data_t){
+          .data = cbi, .free_func = cjni_callback_info_destroy,
+      });
 
   (*jvm_env)->DeleteLocalRef(jvm_env, o_write);
 
   return (0);
 } /* }}} jint cjni_api_register_write */
 
@@ -1342,15 +1346,17 @@
   cbi = cjni_callback_info_create(jvm_env, o_name, o_flush, CB_TYPE_FLUSH);
   if (cbi == NULL)
     return (-1);
 
   DEBUG("java plugin: Registering new flush callback: %s", cbi->name);
 
-  user_data_t ud = {.data = cbi, .free_func = cjni_callback_info_destroy};
-
-  plugin_register_flush(cbi->name, cjni_flush, &ud);
+  plugin_register_flush(
+      cbi->name, cjni_flush,
+      &(user_data_t){
+          .data = cbi, .free_func = cjni_callback_info_destroy,
+      });
 
   (*jvm_env)->DeleteLocalRef(jvm_env, o_flush);
 
   return (0);
 } /* }}} jint cjni_api_register_flush */
 
@@ -1369,15 +1375,16 @@
   cbi = cjni_callback_info_create(jvm_env, o_name, o_log, CB_TYPE_LOG);
   if (cbi == NULL)
     return (-1);
 
   DEBUG("java plugin: Registering new log callback: %s", cbi->name);
 
-  user_data_t ud = {.data = cbi, .free_func = cjni_callback_info_destroy};
-
-  plugin_register_log(cbi->name, cjni_log, &ud);
+  plugin_register_log(cbi->name, cjni_log,
+                      &(user_data_t){
+                          .data = cbi, .free_func = cjni_callback_info_destroy,
+                      });
 
   (*jvm_env)->DeleteLocalRef(jvm_env, o_log);
 
   return (0);
 } /* }}} jint cjni_api_register_log */
 
@@ -1390,15 +1397,17 @@
                                   CB_TYPE_NOTIFICATION);
   if (cbi == NULL)
     return (-1);
 
   DEBUG("java plugin: Registering new notification callback: %s", cbi->name);
 
-  user_data_t ud = {.data = cbi, .free_func = cjni_callback_info_destroy};
-
-  plugin_register_notification(cbi->name, cjni_notification, &ud);
+  plugin_register_notification(
+      cbi->name, cjni_notification,
+      &(user_data_t){
+          .data = cbi, .free_func = cjni_callback_info_destroy,
+      });
 
   (*jvm_env)->DeleteLocalRef(jvm_env, o_notification);
 
   return (0);
 } /* }}} jint cjni_api_register_notification */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/libcollectdclient/collectd/lcc_features.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/libcollectdclient/collectd/lcc_features.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/libcollectdclient/collectd/lcc_features.h	2017-10-06 15:04:52.422133251 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/libcollectdclient/collectd/lcc_features.h	2016-12-12 16:04:27.740005134 +0800
@@ -35,18 +35,18 @@
 # define LCC_END_DECLS
 #endif
 
 #define LCC_API_VERSION 0
 
 #define LCC_VERSION_MAJOR 5
-#define LCC_VERSION_MINOR 6
-#define LCC_VERSION_PATCH 3
+#define LCC_VERSION_MINOR 7
+#define LCC_VERSION_PATCH 0
 
 #define LCC_VERSION_EXTRA ""
 
-#define LCC_VERSION_STRING "5.6.3"
+#define LCC_VERSION_STRING "5.7.0"
 
 #define LCC_VERSION_ENCODE(major, minor, patch) \
 	((major) * 10000 + (minor) * 100 + (patch))
 
 #define LCC_VERSION \
 	LCC_VERSION_ENCODE(LCC_VERSION_MAJOR, LCC_VERSION_MINOR, LCC_VERSION_PATCH)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/libcollectdclient/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/libcollectdclient/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/libcollectdclient/Makefile.in	2017-10-06 15:04:19.846135614 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/libcollectdclient/Makefile.in	2016-12-12 16:03:47.504206132 +0800
@@ -84,20 +84,13 @@
 @BUILD_WITH_LIBGCRYPT_TRUE@am__append_2 = $(GCRYPT_LDFLAGS)
 @BUILD_WITH_LIBGCRYPT_TRUE@am__append_3 = $(GCRYPT_LIBS)
 subdir = src/libcollectdclient
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(srcdir)/libcollectdclient.pc.in $(pkginclude_HEADERS)
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/libltdl/m4/argz.m4 \
-	$(top_srcdir)/libltdl/m4/libtool.m4 \
-	$(top_srcdir)/libltdl/m4/ltdl.m4 \
-	$(top_srcdir)/libltdl/m4/ltoptions.m4 \
-	$(top_srcdir)/libltdl/m4/ltsugar.m4 \
-	$(top_srcdir)/libltdl/m4/ltversion.m4 \
-	$(top_srcdir)/libltdl/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/src/config.h
 CONFIG_CLEAN_FILES = libcollectdclient.pc
 CONFIG_CLEAN_VPATH_FILES =
@@ -248,12 +241,15 @@
 BUILD_WITH_LIBLVM2APP_CPPFLAGS = @BUILD_WITH_LIBLVM2APP_CPPFLAGS@
 BUILD_WITH_LIBLVM2APP_LDFLAGS = @BUILD_WITH_LIBLVM2APP_LDFLAGS@
 BUILD_WITH_LIBLVM2APP_LIBS = @BUILD_WITH_LIBLVM2APP_LIBS@
 BUILD_WITH_LIBMEMCACHED_CPPFLAGS = @BUILD_WITH_LIBMEMCACHED_CPPFLAGS@
 BUILD_WITH_LIBMEMCACHED_LDFLAGS = @BUILD_WITH_LIBMEMCACHED_LDFLAGS@
 BUILD_WITH_LIBMEMCACHED_LIBS = @BUILD_WITH_LIBMEMCACHED_LIBS@
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS = @BUILD_WITH_LIBMICROHTTPD_CPPFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS = @BUILD_WITH_LIBMICROHTTPD_LDFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LIBS = @BUILD_WITH_LIBMICROHTTPD_LIBS@
 BUILD_WITH_LIBMNL_CFLAGS = @BUILD_WITH_LIBMNL_CFLAGS@
 BUILD_WITH_LIBMNL_LIBS = @BUILD_WITH_LIBMNL_LIBS@
 BUILD_WITH_LIBMODBUS_CFLAGS = @BUILD_WITH_LIBMODBUS_CFLAGS@
 BUILD_WITH_LIBMODBUS_LIBS = @BUILD_WITH_LIBMODBUS_LIBS@
 BUILD_WITH_LIBMONGOC_CPPFLAGS = @BUILD_WITH_LIBMONGOC_CPPFLAGS@
 BUILD_WITH_LIBMONGOC_LDFLAGS = @BUILD_WITH_LIBMONGOC_LDFLAGS@
@@ -267,12 +263,15 @@
 BUILD_WITH_LIBNETSNMP_LIBS = @BUILD_WITH_LIBNETSNMP_LIBS@
 BUILD_WITH_LIBOPING_CPPFLAGS = @BUILD_WITH_LIBOPING_CPPFLAGS@
 BUILD_WITH_LIBOPING_LDFLAGS = @BUILD_WITH_LIBOPING_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_CPPFLAGS = @BUILD_WITH_LIBOWCAPI_CPPFLAGS@
 BUILD_WITH_LIBOWCAPI_LDFLAGS = @BUILD_WITH_LIBOWCAPI_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_LIBS = @BUILD_WITH_LIBOWCAPI_LIBS@
+BUILD_WITH_LIBPQOS_CPPFLAGS = @BUILD_WITH_LIBPQOS_CPPFLAGS@
+BUILD_WITH_LIBPQOS_LDFLAGS = @BUILD_WITH_LIBPQOS_LDFLAGS@
+BUILD_WITH_LIBPQOS_LIBS = @BUILD_WITH_LIBPQOS_LIBS@
 BUILD_WITH_LIBPQ_CPPFLAGS = @BUILD_WITH_LIBPQ_CPPFLAGS@
 BUILD_WITH_LIBPQ_LDFLAGS = @BUILD_WITH_LIBPQ_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LDFLAGS = @BUILD_WITH_LIBPROTOBUF_C_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LIBS = @BUILD_WITH_LIBPROTOBUF_C_LIBS@
@@ -378,12 +377,14 @@
 LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
+LIBDPDK_CPPFLAGS = @LIBDPDK_CPPFLAGS@
+LIBDPDK_LDFLAGS = @LIBDPDK_LDFLAGS@
 LIBLTDL = @LIBLTDL@
 LIBLUA_PKG_CONFIG_NAME = @LIBLUA_PKG_CONFIG_NAME@
 LIBNETAPP_CPPFLAGS = @LIBNETAPP_CPPFLAGS@
 LIBNETAPP_LDFLAGS = @LIBNETAPP_LDFLAGS@
 LIBNETAPP_LIBS = @LIBNETAPP_LIBS@
 LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
@@ -416,12 +417,14 @@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 LUA_CFLAGS = @LUA_CFLAGS@
 LUA_LIBS = @LUA_LIBS@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MICROHTTPD_CFLAGS = @MICROHTTPD_CFLAGS@
+MICROHTTPD_LIBS = @MICROHTTPD_LIBS@
 MKDIR_P = @MKDIR_P@
 NM = @NM@
 NMEDIT = @NMEDIT@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/liboconfig/aux_types.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/liboconfig/aux_types.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/liboconfig/aux_types.h	2016-10-20 21:58:10.471782252 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/liboconfig/aux_types.h	2016-12-12 16:03:36.712279086 +0800
@@ -1,16 +1,18 @@
 #ifndef AUX_TYPES_H
 #define AUX_TYPES_H 1
 
-struct statement_list_s {
-  oconfig_item_t *statement;
-  int statement_num;
+struct statement_list_s
+{
+	oconfig_item_t *statement;
+	int             statement_num;
 };
 typedef struct statement_list_s statement_list_t;
 
-struct argument_list_s {
-  oconfig_value_t *argument;
-  int argument_num;
+struct argument_list_s
+{
+	oconfig_value_t *argument;
+	int              argument_num;
 };
 typedef struct argument_list_s argument_list_t;
 
 #endif /* AUX_TYPES_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/liboconfig/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/liboconfig/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/liboconfig/Makefile.in	2017-10-06 15:04:19.910135609 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/liboconfig/Makefile.in	2016-12-12 16:03:47.564205750 +0800
@@ -80,20 +80,13 @@
 host_triplet = @host@
 subdir = src/liboconfig
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am scanner.c \
 	parser.h parser.c $(top_srcdir)/libltdl/config/depcomp \
 	$(top_srcdir)/libltdl/config/ylwrap AUTHORS COPYING ChangeLog
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/libltdl/m4/argz.m4 \
-	$(top_srcdir)/libltdl/m4/libtool.m4 \
-	$(top_srcdir)/libltdl/m4/ltdl.m4 \
-	$(top_srcdir)/libltdl/m4/ltoptions.m4 \
-	$(top_srcdir)/libltdl/m4/ltsugar.m4 \
-	$(top_srcdir)/libltdl/m4/ltversion.m4 \
-	$(top_srcdir)/libltdl/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/src/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
@@ -226,12 +219,15 @@
 BUILD_WITH_LIBLVM2APP_CPPFLAGS = @BUILD_WITH_LIBLVM2APP_CPPFLAGS@
 BUILD_WITH_LIBLVM2APP_LDFLAGS = @BUILD_WITH_LIBLVM2APP_LDFLAGS@
 BUILD_WITH_LIBLVM2APP_LIBS = @BUILD_WITH_LIBLVM2APP_LIBS@
 BUILD_WITH_LIBMEMCACHED_CPPFLAGS = @BUILD_WITH_LIBMEMCACHED_CPPFLAGS@
 BUILD_WITH_LIBMEMCACHED_LDFLAGS = @BUILD_WITH_LIBMEMCACHED_LDFLAGS@
 BUILD_WITH_LIBMEMCACHED_LIBS = @BUILD_WITH_LIBMEMCACHED_LIBS@
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS = @BUILD_WITH_LIBMICROHTTPD_CPPFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS = @BUILD_WITH_LIBMICROHTTPD_LDFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LIBS = @BUILD_WITH_LIBMICROHTTPD_LIBS@
 BUILD_WITH_LIBMNL_CFLAGS = @BUILD_WITH_LIBMNL_CFLAGS@
 BUILD_WITH_LIBMNL_LIBS = @BUILD_WITH_LIBMNL_LIBS@
 BUILD_WITH_LIBMODBUS_CFLAGS = @BUILD_WITH_LIBMODBUS_CFLAGS@
 BUILD_WITH_LIBMODBUS_LIBS = @BUILD_WITH_LIBMODBUS_LIBS@
 BUILD_WITH_LIBMONGOC_CPPFLAGS = @BUILD_WITH_LIBMONGOC_CPPFLAGS@
 BUILD_WITH_LIBMONGOC_LDFLAGS = @BUILD_WITH_LIBMONGOC_LDFLAGS@
@@ -245,12 +241,15 @@
 BUILD_WITH_LIBNETSNMP_LIBS = @BUILD_WITH_LIBNETSNMP_LIBS@
 BUILD_WITH_LIBOPING_CPPFLAGS = @BUILD_WITH_LIBOPING_CPPFLAGS@
 BUILD_WITH_LIBOPING_LDFLAGS = @BUILD_WITH_LIBOPING_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_CPPFLAGS = @BUILD_WITH_LIBOWCAPI_CPPFLAGS@
 BUILD_WITH_LIBOWCAPI_LDFLAGS = @BUILD_WITH_LIBOWCAPI_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_LIBS = @BUILD_WITH_LIBOWCAPI_LIBS@
+BUILD_WITH_LIBPQOS_CPPFLAGS = @BUILD_WITH_LIBPQOS_CPPFLAGS@
+BUILD_WITH_LIBPQOS_LDFLAGS = @BUILD_WITH_LIBPQOS_LDFLAGS@
+BUILD_WITH_LIBPQOS_LIBS = @BUILD_WITH_LIBPQOS_LIBS@
 BUILD_WITH_LIBPQ_CPPFLAGS = @BUILD_WITH_LIBPQ_CPPFLAGS@
 BUILD_WITH_LIBPQ_LDFLAGS = @BUILD_WITH_LIBPQ_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LDFLAGS = @BUILD_WITH_LIBPROTOBUF_C_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LIBS = @BUILD_WITH_LIBPROTOBUF_C_LIBS@
@@ -356,12 +355,14 @@
 LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
+LIBDPDK_CPPFLAGS = @LIBDPDK_CPPFLAGS@
+LIBDPDK_LDFLAGS = @LIBDPDK_LDFLAGS@
 LIBLTDL = @LIBLTDL@
 LIBLUA_PKG_CONFIG_NAME = @LIBLUA_PKG_CONFIG_NAME@
 LIBNETAPP_CPPFLAGS = @LIBNETAPP_CPPFLAGS@
 LIBNETAPP_LDFLAGS = @LIBNETAPP_LDFLAGS@
 LIBNETAPP_LIBS = @LIBNETAPP_LIBS@
 LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
@@ -394,12 +395,14 @@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 LUA_CFLAGS = @LUA_CFLAGS@
 LUA_LIBS = @LUA_LIBS@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MICROHTTPD_CFLAGS = @MICROHTTPD_CFLAGS@
+MICROHTTPD_LIBS = @MICROHTTPD_LIBS@
 MKDIR_P = @MKDIR_P@
 NM = @NM@
 NMEDIT = @NMEDIT@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/load.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/load.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/load.c	2017-10-06 14:45:52.953917759 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/load.c	2016-12-12 16:03:36.712279086 +0800
@@ -69,14 +69,12 @@
             "is not available, because I can't determine the "
             "number of CPUS on this system. Sorry.");
 #endif
   return (-1);
 }
 static void load_submit(gauge_t snum, gauge_t mnum, gauge_t lnum) {
-  value_t values[3];
-  value_list_t vl = VALUE_LIST_INIT;
   int cores = 0;
   char errbuf[1024];
 
 #ifdef _SC_NPROCESSORS_ONLN
   if (report_relative_load) {
     if ((cores = sysconf(_SC_NPROCESSORS_ONLN)) < 1) {
@@ -88,20 +86,20 @@
   if (cores > 0) {
     snum /= cores;
     mnum /= cores;
     lnum /= cores;
   }
 
-  values[0].gauge = snum;
-  values[1].gauge = mnum;
-  values[2].gauge = lnum;
+  value_list_t vl = VALUE_LIST_INIT;
+  value_t values[] = {
+      {.gauge = snum}, {.gauge = mnum}, {.gauge = lnum},
+  };
 
   vl.values = values;
   vl.values_len = STATIC_ARRAY_SIZE(values);
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "load", sizeof(vl.plugin));
   sstrncpy(vl.type, "load", sizeof(vl.type));
 
   if (cores > 0) {
     sstrncpy(vl.type_instance, "relative", sizeof(vl.type_instance));
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/logfile.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/logfile.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/logfile.c	2017-10-06 14:45:52.953917759 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/logfile.c	2016-12-12 16:03:36.712279086 +0800
@@ -28,12 +28,14 @@
 
 #include "collectd.h"
 
 #include "common.h"
 #include "plugin.h"
 
+#define DEFAULT_LOGFILE LOCALSTATEDIR "/log/collectd.log"
+
 #if COLLECT_DEBUG
 static int log_level = LOG_DEBUG;
 #else
 static int log_level = LOG_INFO;
 #endif /* COLLECT_DEBUG */
 
@@ -75,13 +77,12 @@
 } /* int logfile_config (const char *, const char *) */
 
 static void logfile_print(const char *msg, int severity,
                           cdtime_t timestamp_time) {
   FILE *fh;
   _Bool do_close = 0;
-  struct tm timestamp_tm;
   char timestamp_str[64];
   char level_str[16] = "";
 
   if (print_severity) {
     switch (severity) {
     case LOG_ERR:
@@ -102,36 +103,38 @@
     default:
       break;
     }
   }
 
   if (print_timestamp) {
-    time_t tt = CDTIME_T_TO_TIME_T(timestamp_time);
-    localtime_r(&tt, &timestamp_tm);
+    struct tm timestamp_tm;
+    localtime_r(&CDTIME_T_TO_TIME_T(timestamp_time), &timestamp_tm);
 
     strftime(timestamp_str, sizeof(timestamp_str), "%Y-%m-%d %H:%M:%S",
              &timestamp_tm);
     timestamp_str[sizeof(timestamp_str) - 1] = '\0';
   }
 
   pthread_mutex_lock(&file_lock);
 
   if (log_file == NULL) {
-    fh = stderr;
+    fh = fopen(DEFAULT_LOGFILE, "a");
+    do_close = 1;
   } else if (strcasecmp(log_file, "stderr") == 0)
     fh = stderr;
   else if (strcasecmp(log_file, "stdout") == 0)
     fh = stdout;
   else {
     fh = fopen(log_file, "a");
     do_close = 1;
   }
 
   if (fh == NULL) {
     char errbuf[1024];
-    fprintf(stderr, "logfile plugin: fopen (%s) failed: %s\n", log_file,
+    fprintf(stderr, "logfile plugin: fopen (%s) failed: %s\n",
+            (log_file == NULL) ? DEFAULT_LOGFILE : log_file,
             sstrerror(errno, errbuf, sizeof(errbuf)));
   } else {
     if (print_timestamp)
       fprintf(fh, "[%s] %s%s\n", timestamp_str, level_str, msg);
     else
       fprintf(fh, "%s%s\n", level_str, msg);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/log_logstash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/log_logstash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/log_logstash.c	2017-10-06 14:45:52.953917759 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/log_logstash.c	2016-12-12 16:03:36.712279086 +0800
@@ -38,12 +38,14 @@
 #include <yajl/yajl_version.h>
 #endif
 #if defined(YAJL_MAJOR) && (YAJL_MAJOR > 1)
 #define HAVE_YAJL_V2 1
 #endif
 
+#define DEFAULT_LOGFILE LOCALSTATEDIR "/log/" PACKAGE_NAME ".json.log"
+
 #if COLLECT_DEBUG
 static int log_level = LOG_DEBUG;
 #else
 static int log_level = LOG_INFO;
 #endif /* COLLECT_DEBUG */
 
@@ -76,13 +78,12 @@
                                cdtime_t timestamp_time) {
   FILE *fh;
   _Bool do_close = 0;
   struct tm timestamp_tm;
   char timestamp_str[64];
   const unsigned char *buf;
-  time_t tt;
 #if HAVE_YAJL_V2
   size_t len;
 #else
   unsigned int len;
 #endif
 
@@ -124,14 +125,13 @@
   }
 
   if (yajl_gen_string(g, (u_char *)"@timestamp", strlen("@timestamp")) !=
       yajl_gen_status_ok)
     goto err;
 
-  tt = CDTIME_T_TO_TIME_T(timestamp_time);
-  gmtime_r(&tt, &timestamp_tm);
+  gmtime_r(&CDTIME_T_TO_TIME_T(timestamp_time), &timestamp_tm);
 
   /*
    * format time as a UTC ISO 8601 compliant string
    */
   strftime(timestamp_str, sizeof(timestamp_str), "%Y-%m-%dT%H:%M:%SZ",
            &timestamp_tm);
@@ -146,13 +146,14 @@
 
   if (yajl_gen_get_buf(g, &buf, &len) != yajl_gen_status_ok)
     goto err;
   pthread_mutex_lock(&file_lock);
 
   if (log_file == NULL) {
-    fh = stderr;
+    fh = fopen(DEFAULT_LOGFILE, "a");
+    do_close = 1;
   } else if (strcasecmp(log_file, "stdout") == 0) {
     fh = stdout;
     do_close = 0;
   } else if (strcasecmp(log_file, "stderr") == 0) {
     fh = stderr;
     do_close = 0;
@@ -160,13 +161,14 @@
     fh = fopen(log_file, "a");
     do_close = 1;
   }
 
   if (fh == NULL) {
     char errbuf[1024];
-    fprintf(stderr, "log_logstash plugin: fopen (%s) failed: %s\n", log_file,
+    fprintf(stderr, "log_logstash plugin: fopen (%s) failed: %s\n",
+            (log_file == NULL) ? DEFAULT_LOGFILE : log_file,
             sstrerror(errno, errbuf, sizeof(errbuf)));
   } else {
     fprintf(fh, "%s\n", buf);
     if (do_close) {
       fclose(fh);
     } else {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/lpar.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/lpar.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/lpar.c	2017-10-06 14:45:52.953917759 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/lpar.c	2016-12-12 16:03:36.712279086 +0800
@@ -96,24 +96,19 @@
   }
 
   return (0);
 } /* int lpar_init */
 
 static void lpar_submit(const char *type_instance, double value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = (gauge_t)value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
   if (report_by_serial) {
     sstrncpy(vl.host, serial, sizeof(vl.host));
     sstrncpy(vl.plugin_instance, hostname_g, sizeof(vl.plugin));
-  } else {
-    sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   }
   sstrncpy(vl.plugin, "lpar", sizeof(vl.plugin));
   sstrncpy(vl.type, "vcpu", sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/lua.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/lua.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/lua.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/lua.c	2016-12-12 16:03:36.712279086 +0800
@@ -300,19 +300,18 @@
 
   cb->lua_state = thread;
   cb->callback_id = callback_id;
   cb->lua_function_name = strdup(function_name);
   pthread_mutex_init(&cb->lock, NULL);
 
-  user_data_t ud = {.data = cb};
-
   int status = plugin_register_complex_read(/* group = */ "lua",
                                             /* name      = */ function_name,
                                             /* callback  = */ clua_read,
-                                            /* interval  = */ 0,
-                                            /* user_data = */ &ud);
+                                            /* interval  = */ 0, &(user_data_t){
+                                                                     .data = cb,
+                                                                 });
 
   if (status != 0)
     return luaL_error(L, "%s", "plugin_register_complex_read failed");
   return 0;
 } /* }}} int lua_cb_register_read */
 
@@ -344,17 +343,17 @@
 
   cb->lua_state = thread;
   cb->callback_id = callback_id;
   cb->lua_function_name = strdup(function_name);
   pthread_mutex_init(&cb->lock, NULL);
 
-  user_data_t ud = {.data = cb};
-
-  int status = plugin_register_write(/* name = */ function_name,
-                                     /* callback  = */ clua_write,
-                                     /* user_data = */ &ud);
+  int status =
+      plugin_register_write(/* name = */ function_name,
+                            /* callback  = */ clua_write, &(user_data_t){
+                                                              .data = cb,
+                                                          });
 
   if (status != 0)
     return luaL_error(L, "%s", "plugin_register_write failed");
   return 0;
 } /* }}} int lua_cb_register_write */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/lvm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/lvm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/lvm.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/lvm.c	2016-12-12 16:03:36.712279086 +0800
@@ -15,13 +15,13 @@
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
  *
  * Authors:
  *   Chad Malfait <malfaitc at yahoo.com>
- *   Benjamin Gilbert <bgilbert at cs.cmu.edu>
+ *   Benjamin Gilbert <bgilbert at backtick.net>
  **/
 
 #include <lvm2app.h>
 
 #include "collectd.h"
 
@@ -49,21 +49,17 @@
     return NULL;
   return v.value.string;
 }
 
 static void lvm_submit(char const *plugin_instance, char const *type_instance,
                        uint64_t ivalue) {
-  value_t v;
   value_list_t vl = VALUE_LIST_INIT;
 
-  v.gauge = (gauge_t)ivalue;
-
-  vl.values = &v;
+  vl.values = &(value_t){.gauge = (gauge_t)ivalue};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "lvm", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "df_complex", sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/madwifi.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/madwifi.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/madwifi.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/madwifi.c	2016-12-12 16:03:36.712279086 +0800
@@ -506,18 +506,17 @@
     return (-1);
 
   return (0);
 }
 
 static void submit(const char *dev, const char *type, const char *ti1,
-                   const char *ti2, value_t *val, int len) {
+                   const char *ti2, value_t *val, size_t len) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = val;
   vl.values_len = len;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "madwifi", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, dev, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   if ((ti1 != NULL) && (ti2 != NULL))
     ssnprintf(vl.type_instance, sizeof(vl.type_instance), "%s-%s", ti1, ti2);
@@ -525,31 +524,28 @@
     sstrncpy(vl.type_instance, ti1, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
 static void submit_derive(const char *dev, const char *type, const char *ti1,
-                          const char *ti2, derive_t val) {
-  value_t item;
-  item.derive = val;
-  submit(dev, type, ti1, ti2, &item, 1);
+                          const char *ti2, derive_t value) {
+  submit(dev, type, ti1, ti2, &(value_t){.derive = value}, 1);
 }
 
 static void submit_derive2(const char *dev, const char *type, const char *ti1,
                            const char *ti2, derive_t val1, derive_t val2) {
-  value_t items[2];
-  items[0].derive = val1;
-  items[1].derive = val2;
-  submit(dev, type, ti1, ti2, items, 2);
+  value_t values[] = {
+      {.derive = val1}, {.derive = val2},
+  };
+
+  submit(dev, type, ti1, ti2, values, STATIC_ARRAY_SIZE(values));
 }
 
 static void submit_gauge(const char *dev, const char *type, const char *ti1,
-                         const char *ti2, gauge_t val) {
-  value_t item;
-  item.gauge = val;
-  submit(dev, type, ti1, ti2, &item, 1);
+                         const char *ti2, gauge_t value) {
+  submit(dev, type, ti1, ti2, &(value_t){.gauge = value}, 1);
 }
 
 static void submit_antx(const char *dev, const char *name, u_int32_t *vals,
                         int vals_num) {
   char ti2[16];
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/madwifi.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/madwifi.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/madwifi.h	2016-10-20 21:58:10.575782240 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/madwifi.h	2016-12-12 16:03:36.712279086 +0800
@@ -33,272 +33,275 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef MADWIFI_H
 #define MADWIFI_H
 
-#define IEEE80211_ADDR_LEN 6 /* size of 802.11 address */
-#define IEEE80211_RATE_VAL 0x7f
-#define IEEE80211_RATE_SIZE 8     /* 802.11 standard */
-#define IEEE80211_RATE_MAXSIZE 15 /* max rates we'll handle */
+#define	IEEE80211_ADDR_LEN		6		/* size of 802.11 address */
+#define	IEEE80211_RATE_VAL		0x7f
+#define	IEEE80211_RATE_SIZE		8		/* 802.11 standard */
+#define	IEEE80211_RATE_MAXSIZE		15		/* max rates we'll handle */
+
 
 /*
  * Per/node (station) statistics available when operating as an AP.
  */
 struct ieee80211_nodestats {
-  u_int32_t ns_rx_data;      /* rx data frames */
-  u_int32_t ns_rx_mgmt;      /* rx management frames */
-  u_int32_t ns_rx_ctrl;      /* rx control frames */
-  u_int32_t ns_rx_ucast;     /* rx unicast frames */
-  u_int32_t ns_rx_mcast;     /* rx multi/broadcast frames */
-  u_int64_t ns_rx_bytes;     /* rx data count (bytes) */
-  u_int64_t ns_rx_beacons;   /* rx beacon frames */
-  u_int32_t ns_rx_proberesp; /* rx probe response frames */
-
-  u_int32_t ns_rx_dup;         /* rx discard because it's a dup */
-  u_int32_t ns_rx_noprivacy;   /* rx w/ wep but privacy off */
-  u_int32_t ns_rx_wepfail;     /* rx wep processing failed */
-  u_int32_t ns_rx_demicfail;   /* rx demic failed */
-  u_int32_t ns_rx_decap;       /* rx decapsulation failed */
-  u_int32_t ns_rx_defrag;      /* rx defragmentation failed */
-  u_int32_t ns_rx_disassoc;    /* rx disassociation */
-  u_int32_t ns_rx_deauth;      /* rx deauthentication */
-  u_int32_t ns_rx_decryptcrc;  /* rx decrypt failed on crc */
-  u_int32_t ns_rx_unauth;      /* rx on unauthorized port */
-  u_int32_t ns_rx_unencrypted; /* rx unecrypted w/ privacy */
-
-  u_int32_t ns_tx_data;     /* tx data frames */
-  u_int32_t ns_tx_mgmt;     /* tx management frames */
-  u_int32_t ns_tx_ucast;    /* tx unicast frames */
-  u_int32_t ns_tx_mcast;    /* tx multi/broadcast frames */
-  u_int64_t ns_tx_bytes;    /* tx data count (bytes) */
-  u_int32_t ns_tx_probereq; /* tx probe request frames */
-  u_int32_t ns_tx_uapsd;    /* tx on uapsd queue */
-
-  u_int32_t ns_tx_novlantag;    /* tx discard due to no tag */
-  u_int32_t ns_tx_vlanmismatch; /* tx discard due to of bad tag */
-
-  u_int32_t ns_tx_eosplost; /* uapsd EOSP retried out */
-
-  u_int32_t ns_ps_discard; /* ps discard due to of age */
-
-  u_int32_t ns_uapsd_triggers; /* uapsd triggers */
-
-  /* MIB-related state */
-  u_int32_t ns_tx_assoc;         /* [re]associations */
-  u_int32_t ns_tx_assoc_fail;    /* [re]association failures */
-  u_int32_t ns_tx_auth;          /* [re]authentications */
-  u_int32_t ns_tx_auth_fail;     /* [re]authentication failures*/
-  u_int32_t ns_tx_deauth;        /* deauthentications */
-  u_int32_t ns_tx_deauth_code;   /* last deauth reason */
-  u_int32_t ns_tx_disassoc;      /* disassociations */
-  u_int32_t ns_tx_disassoc_code; /* last disassociation reason */
-  u_int32_t ns_psq_drops;        /* power save queue drops */
+	u_int32_t ns_rx_data;		/* rx data frames */
+	u_int32_t ns_rx_mgmt;		/* rx management frames */
+	u_int32_t ns_rx_ctrl;		/* rx control frames */
+	u_int32_t ns_rx_ucast;		/* rx unicast frames */
+	u_int32_t ns_rx_mcast;		/* rx multi/broadcast frames */
+	u_int64_t ns_rx_bytes;		/* rx data count (bytes) */
+	u_int64_t ns_rx_beacons;	/* rx beacon frames */
+	u_int32_t ns_rx_proberesp;	/* rx probe response frames */
+
+	u_int32_t ns_rx_dup;		/* rx discard because it's a dup */
+	u_int32_t ns_rx_noprivacy;	/* rx w/ wep but privacy off */
+	u_int32_t ns_rx_wepfail;	/* rx wep processing failed */
+	u_int32_t ns_rx_demicfail;	/* rx demic failed */
+	u_int32_t ns_rx_decap;		/* rx decapsulation failed */
+	u_int32_t ns_rx_defrag;		/* rx defragmentation failed */
+	u_int32_t ns_rx_disassoc;	/* rx disassociation */
+	u_int32_t ns_rx_deauth;		/* rx deauthentication */
+	u_int32_t ns_rx_decryptcrc;	/* rx decrypt failed on crc */
+	u_int32_t ns_rx_unauth;		/* rx on unauthorized port */
+	u_int32_t ns_rx_unencrypted;	/* rx unecrypted w/ privacy */
+
+	u_int32_t ns_tx_data;		/* tx data frames */
+	u_int32_t ns_tx_mgmt;		/* tx management frames */
+	u_int32_t ns_tx_ucast;		/* tx unicast frames */
+	u_int32_t ns_tx_mcast;		/* tx multi/broadcast frames */
+	u_int64_t ns_tx_bytes;		/* tx data count (bytes) */
+	u_int32_t ns_tx_probereq;	/* tx probe request frames */
+	u_int32_t ns_tx_uapsd;		/* tx on uapsd queue */
+
+	u_int32_t ns_tx_novlantag;	/* tx discard due to no tag */
+	u_int32_t ns_tx_vlanmismatch;	/* tx discard due to of bad tag */
+
+	u_int32_t ns_tx_eosplost;	/* uapsd EOSP retried out */
+
+	u_int32_t ns_ps_discard;	/* ps discard due to of age */
+
+	u_int32_t ns_uapsd_triggers;	/* uapsd triggers */
+
+	/* MIB-related state */
+	u_int32_t ns_tx_assoc;		/* [re]associations */
+	u_int32_t ns_tx_assoc_fail;	/* [re]association failures */
+	u_int32_t ns_tx_auth;		/* [re]authentications */
+	u_int32_t ns_tx_auth_fail;	/* [re]authentication failures*/
+	u_int32_t ns_tx_deauth;		/* deauthentications */
+	u_int32_t ns_tx_deauth_code;	/* last deauth reason */
+	u_int32_t ns_tx_disassoc;	/* disassociations */
+	u_int32_t ns_tx_disassoc_code;	/* last disassociation reason */
+	u_int32_t ns_psq_drops;		/* power save queue drops */
 };
 
 /*
  * Summary statistics.
  */
 struct ieee80211_stats {
-  u_int32_t is_rx_badversion;           /* rx frame with bad version */
-  u_int32_t is_rx_tooshort;             /* rx frame too short */
-  u_int32_t is_rx_wrongbss;             /* rx from wrong bssid */
-  u_int32_t is_rx_dup;                  /* rx discard due to it's a dup */
-  u_int32_t is_rx_wrongdir;             /* rx w/ wrong direction */
-  u_int32_t is_rx_mcastecho;            /* rx discard due to of mcast echo */
-  u_int32_t is_rx_notassoc;             /* rx discard due to sta !assoc */
-  u_int32_t is_rx_noprivacy;            /* rx w/ wep but privacy off */
-  u_int32_t is_rx_unencrypted;          /* rx w/o wep and privacy on */
-  u_int32_t is_rx_wepfail;              /* rx wep processing failed */
-  u_int32_t is_rx_decap;                /* rx decapsulation failed */
-  u_int32_t is_rx_mgtdiscard;           /* rx discard mgt frames */
-  u_int32_t is_rx_ctl;                  /* rx discard ctrl frames */
-  u_int32_t is_rx_beacon;               /* rx beacon frames */
-  u_int32_t is_rx_rstoobig;             /* rx rate set truncated */
-  u_int32_t is_rx_elem_missing;         /* rx required element missing*/
-  u_int32_t is_rx_elem_toobig;          /* rx element too big */
-  u_int32_t is_rx_elem_toosmall;        /* rx element too small */
-  u_int32_t is_rx_elem_unknown;         /* rx element unknown */
-  u_int32_t is_rx_badchan;              /* rx frame w/ invalid chan */
-  u_int32_t is_rx_chanmismatch;         /* rx frame chan mismatch */
-  u_int32_t is_rx_nodealloc;            /* rx frame dropped */
-  u_int32_t is_rx_ssidmismatch;         /* rx frame ssid mismatch  */
-  u_int32_t is_rx_auth_unsupported;     /* rx w/ unsupported auth alg */
-  u_int32_t is_rx_auth_fail;            /* rx sta auth failure */
-  u_int32_t is_rx_auth_countermeasures; /* rx auth discard due to CM */
-  u_int32_t is_rx_assoc_bss;            /* rx assoc from wrong bssid */
-  u_int32_t is_rx_assoc_notauth;        /* rx assoc w/o auth */
-  u_int32_t is_rx_assoc_capmismatch;    /* rx assoc w/ cap mismatch */
-  u_int32_t is_rx_assoc_norate;         /* rx assoc w/ no rate match */
-  u_int32_t is_rx_assoc_badwpaie;       /* rx assoc w/ bad WPA IE */
-  u_int32_t is_rx_deauth;               /* rx deauthentication */
-  u_int32_t is_rx_disassoc;             /* rx disassociation */
-  u_int32_t is_rx_badsubtype;           /* rx frame w/ unknown subtype*/
-  u_int32_t is_rx_nobuf;                /* rx failed for lack of buf */
-  u_int32_t is_rx_decryptcrc;           /* rx decrypt failed on crc */
-  u_int32_t is_rx_ahdemo_mgt;           /* rx discard ahdemo mgt frame*/
-  u_int32_t is_rx_bad_auth;             /* rx bad auth request */
-  u_int32_t is_rx_unauth;               /* rx on unauthorized port */
-  u_int32_t is_rx_badkeyid;             /* rx w/ incorrect keyid */
-  u_int32_t is_rx_ccmpreplay;           /* rx seq# violation (CCMP) */
-  u_int32_t is_rx_ccmpformat;           /* rx format bad (CCMP) */
-  u_int32_t is_rx_ccmpmic;              /* rx MIC check failed (CCMP) */
-  u_int32_t is_rx_tkipreplay;           /* rx seq# violation (TKIP) */
-  u_int32_t is_rx_tkipformat;           /* rx format bad (TKIP) */
-  u_int32_t is_rx_tkipmic;              /* rx MIC check failed (TKIP) */
-  u_int32_t is_rx_tkipicv;              /* rx ICV check failed (TKIP) */
-  u_int32_t is_rx_badcipher;            /* rx failed due to of key type */
-  u_int32_t is_rx_nocipherctx;          /* rx failed due to key !setup */
-  u_int32_t is_rx_acl;                  /* rx discard due to of acl policy */
-  u_int32_t is_rx_ffcnt;                /* rx fast frames */
-  u_int32_t is_rx_badathtnl;            /* driver key alloc failed */
-  u_int32_t is_tx_nobuf;                /* tx failed for lack of buf */
-  u_int32_t is_tx_nonode;               /* tx failed for no node */
-  u_int32_t is_tx_unknownmgt;           /* tx of unknown mgt frame */
-  u_int32_t is_tx_badcipher;            /* tx failed due to of key type */
-  u_int32_t is_tx_nodefkey;             /* tx failed due to no defkey */
-  u_int32_t is_tx_noheadroom;           /* tx failed due to no space */
-  u_int32_t is_tx_ffokcnt;              /* tx fast frames sent success */
-  u_int32_t is_tx_fferrcnt;             /* tx fast frames sent success */
-  u_int32_t is_scan_active;             /* active scans started */
-  u_int32_t is_scan_passive;            /* passive scans started */
-  u_int32_t is_node_timeout;            /* nodes timed out inactivity */
-  u_int32_t is_crypto_nomem;            /* no memory for crypto ctx */
-  u_int32_t is_crypto_tkip;             /* tkip crypto done in s/w */
-  u_int32_t is_crypto_tkipenmic;        /* tkip en-MIC done in s/w */
-  u_int32_t is_crypto_tkipdemic;        /* tkip de-MIC done in s/w */
-  u_int32_t is_crypto_tkipcm;           /* tkip counter measures */
-  u_int32_t is_crypto_ccmp;             /* ccmp crypto done in s/w */
-  u_int32_t is_crypto_wep;              /* wep crypto done in s/w */
-  u_int32_t is_crypto_setkey_cipher;    /* cipher rejected key */
-  u_int32_t is_crypto_setkey_nokey;     /* no key index for setkey */
-  u_int32_t is_crypto_delkey;           /* driver key delete failed */
-  u_int32_t is_crypto_badcipher;        /* unknown cipher */
-  u_int32_t is_crypto_nocipher;         /* cipher not available */
-  u_int32_t is_crypto_attachfail;       /* cipher attach failed */
-  u_int32_t is_crypto_swfallback;       /* cipher fallback to s/w */
-  u_int32_t is_crypto_keyfail;          /* driver key alloc failed */
-  u_int32_t is_crypto_enmicfail;        /* en-MIC failed */
-  u_int32_t is_ibss_capmismatch;        /* merge failed-cap mismatch */
-  u_int32_t is_ibss_norate;             /* merge failed-rate mismatch */
-  u_int32_t is_ps_unassoc;              /* ps-poll for unassoc. sta */
-  u_int32_t is_ps_badaid;               /* ps-poll w/ incorrect aid */
-  u_int32_t is_ps_qempty;               /* ps-poll w/ nothing to send */
+	u_int32_t is_rx_badversion;	/* rx frame with bad version */
+	u_int32_t is_rx_tooshort;	/* rx frame too short */
+	u_int32_t is_rx_wrongbss;	/* rx from wrong bssid */
+	u_int32_t is_rx_dup;		/* rx discard due to it's a dup */
+	u_int32_t is_rx_wrongdir;	/* rx w/ wrong direction */
+	u_int32_t is_rx_mcastecho;	/* rx discard due to of mcast echo */
+	u_int32_t is_rx_notassoc;	/* rx discard due to sta !assoc */
+	u_int32_t is_rx_noprivacy;	/* rx w/ wep but privacy off */
+	u_int32_t is_rx_unencrypted;	/* rx w/o wep and privacy on */
+	u_int32_t is_rx_wepfail;	/* rx wep processing failed */
+	u_int32_t is_rx_decap;		/* rx decapsulation failed */
+	u_int32_t is_rx_mgtdiscard;	/* rx discard mgt frames */
+	u_int32_t is_rx_ctl;		/* rx discard ctrl frames */
+	u_int32_t is_rx_beacon;		/* rx beacon frames */
+	u_int32_t is_rx_rstoobig;	/* rx rate set truncated */
+	u_int32_t is_rx_elem_missing;	/* rx required element missing*/
+	u_int32_t is_rx_elem_toobig;	/* rx element too big */
+	u_int32_t is_rx_elem_toosmall;	/* rx element too small */
+	u_int32_t is_rx_elem_unknown;	/* rx element unknown */
+	u_int32_t is_rx_badchan;	/* rx frame w/ invalid chan */
+	u_int32_t is_rx_chanmismatch;	/* rx frame chan mismatch */
+	u_int32_t is_rx_nodealloc;	/* rx frame dropped */
+	u_int32_t is_rx_ssidmismatch;	/* rx frame ssid mismatch  */
+	u_int32_t is_rx_auth_unsupported;/* rx w/ unsupported auth alg */
+	u_int32_t is_rx_auth_fail;	/* rx sta auth failure */
+	u_int32_t is_rx_auth_countermeasures;/* rx auth discard due to CM */
+	u_int32_t is_rx_assoc_bss;	/* rx assoc from wrong bssid */
+	u_int32_t is_rx_assoc_notauth;	/* rx assoc w/o auth */
+	u_int32_t is_rx_assoc_capmismatch;/* rx assoc w/ cap mismatch */
+	u_int32_t is_rx_assoc_norate;	/* rx assoc w/ no rate match */
+	u_int32_t is_rx_assoc_badwpaie;	/* rx assoc w/ bad WPA IE */
+	u_int32_t is_rx_deauth;		/* rx deauthentication */
+	u_int32_t is_rx_disassoc;	/* rx disassociation */
+	u_int32_t is_rx_badsubtype;	/* rx frame w/ unknown subtype*/
+	u_int32_t is_rx_nobuf;		/* rx failed for lack of buf */
+	u_int32_t is_rx_decryptcrc;	/* rx decrypt failed on crc */
+	u_int32_t is_rx_ahdemo_mgt;	/* rx discard ahdemo mgt frame*/
+	u_int32_t is_rx_bad_auth;	/* rx bad auth request */
+	u_int32_t is_rx_unauth;		/* rx on unauthorized port */
+	u_int32_t is_rx_badkeyid;	/* rx w/ incorrect keyid */
+	u_int32_t is_rx_ccmpreplay;	/* rx seq# violation (CCMP) */
+	u_int32_t is_rx_ccmpformat;	/* rx format bad (CCMP) */
+	u_int32_t is_rx_ccmpmic;	/* rx MIC check failed (CCMP) */
+	u_int32_t is_rx_tkipreplay;	/* rx seq# violation (TKIP) */
+	u_int32_t is_rx_tkipformat;	/* rx format bad (TKIP) */
+	u_int32_t is_rx_tkipmic;	/* rx MIC check failed (TKIP) */
+	u_int32_t is_rx_tkipicv;	/* rx ICV check failed (TKIP) */
+	u_int32_t is_rx_badcipher;	/* rx failed due to of key type */
+	u_int32_t is_rx_nocipherctx;	/* rx failed due to key !setup */
+	u_int32_t is_rx_acl;		/* rx discard due to of acl policy */
+	u_int32_t is_rx_ffcnt;		/* rx fast frames */
+	u_int32_t is_rx_badathtnl;	/* driver key alloc failed */
+	u_int32_t is_tx_nobuf;		/* tx failed for lack of buf */
+	u_int32_t is_tx_nonode;		/* tx failed for no node */
+	u_int32_t is_tx_unknownmgt;	/* tx of unknown mgt frame */
+	u_int32_t is_tx_badcipher;	/* tx failed due to of key type */
+	u_int32_t is_tx_nodefkey;	/* tx failed due to no defkey */
+	u_int32_t is_tx_noheadroom;	/* tx failed due to no space */
+	u_int32_t is_tx_ffokcnt;	/* tx fast frames sent success */
+	u_int32_t is_tx_fferrcnt;	/* tx fast frames sent success */
+	u_int32_t is_scan_active;	/* active scans started */
+	u_int32_t is_scan_passive;	/* passive scans started */
+	u_int32_t is_node_timeout;	/* nodes timed out inactivity */
+	u_int32_t is_crypto_nomem;	/* no memory for crypto ctx */
+	u_int32_t is_crypto_tkip;	/* tkip crypto done in s/w */
+	u_int32_t is_crypto_tkipenmic;	/* tkip en-MIC done in s/w */
+	u_int32_t is_crypto_tkipdemic;	/* tkip de-MIC done in s/w */
+	u_int32_t is_crypto_tkipcm;	/* tkip counter measures */
+	u_int32_t is_crypto_ccmp;	/* ccmp crypto done in s/w */
+	u_int32_t is_crypto_wep;	/* wep crypto done in s/w */
+	u_int32_t is_crypto_setkey_cipher;/* cipher rejected key */
+	u_int32_t is_crypto_setkey_nokey;/* no key index for setkey */
+	u_int32_t is_crypto_delkey;	/* driver key delete failed */
+	u_int32_t is_crypto_badcipher;	/* unknown cipher */
+	u_int32_t is_crypto_nocipher;	/* cipher not available */
+	u_int32_t is_crypto_attachfail;	/* cipher attach failed */
+	u_int32_t is_crypto_swfallback;	/* cipher fallback to s/w */
+	u_int32_t is_crypto_keyfail;	/* driver key alloc failed */
+	u_int32_t is_crypto_enmicfail;	/* en-MIC failed */
+	u_int32_t is_ibss_capmismatch;	/* merge failed-cap mismatch */
+	u_int32_t is_ibss_norate;	/* merge failed-rate mismatch */
+	u_int32_t is_ps_unassoc;	/* ps-poll for unassoc. sta */
+	u_int32_t is_ps_badaid;		/* ps-poll w/ incorrect aid */
+	u_int32_t is_ps_qempty;		/* ps-poll w/ nothing to send */
 };
 
 /*
  * Retrieve per-node statistics.
  */
 struct ieee80211req_sta_stats {
-  union {
-    /* NB: explicitly force 64-bit alignment */
-    u_int8_t macaddr[IEEE80211_ADDR_LEN];
-    u_int64_t pad;
-  } is_u;
-  struct ieee80211_nodestats is_stats;
+	union {
+		/* NB: explicitly force 64-bit alignment */
+		u_int8_t macaddr[IEEE80211_ADDR_LEN];
+		u_int64_t pad;
+	} is_u;
+	struct ieee80211_nodestats is_stats;
 };
 
 /*
  * Station information block; the mac address is used
  * to retrieve other data like stats, unicast key, etc.
  */
 struct ieee80211req_sta_info {
-  u_int16_t isi_len;     /* length (mult of 4) */
-  u_int16_t isi_freq;    /* MHz */
-  u_int16_t isi_flags;   /* channel flags */
-  u_int16_t isi_state;   /* state flags */
-  u_int8_t isi_authmode; /* authentication algorithm */
-  u_int8_t isi_rssi;
-  u_int16_t isi_capinfo; /* capabilities */
-  u_int8_t isi_athflags; /* Atheros capabilities */
-  u_int8_t isi_erp;      /* ERP element */
-  u_int8_t isi_macaddr[IEEE80211_ADDR_LEN];
-  u_int8_t isi_nrates; /* negotiated rates */
-  u_int8_t isi_rates[IEEE80211_RATE_MAXSIZE];
-  u_int8_t isi_txrate;      /* index to isi_rates[] */
-  u_int16_t isi_ie_len;     /* IE length */
-  u_int16_t isi_associd;    /* assoc response */
-  u_int16_t isi_txpower;    /* current tx power */
-  u_int16_t isi_vlan;       /* vlan tag */
-  u_int16_t isi_txseqs[17]; /* seq to be transmitted */
-  u_int16_t isi_rxseqs[17]; /* seq previous for qos frames*/
-  u_int16_t isi_inact;      /* inactivity timer */
-  u_int8_t isi_uapsd;       /* UAPSD queues */
-  u_int8_t isi_opmode;      /* sta operating mode */
+	u_int16_t isi_len;		/* length (mult of 4) */
+	u_int16_t isi_freq;		/* MHz */
+	u_int16_t isi_flags;		/* channel flags */
+	u_int16_t isi_state;		/* state flags */
+	u_int8_t isi_authmode;		/* authentication algorithm */
+	u_int8_t isi_rssi;
+	u_int16_t isi_capinfo;		/* capabilities */
+	u_int8_t isi_athflags;		/* Atheros capabilities */
+	u_int8_t isi_erp;		/* ERP element */
+	u_int8_t isi_macaddr[IEEE80211_ADDR_LEN];
+	u_int8_t isi_nrates;		/* negotiated rates */
+	u_int8_t isi_rates[IEEE80211_RATE_MAXSIZE];
+	u_int8_t isi_txrate;		/* index to isi_rates[] */
+	u_int16_t isi_ie_len;		/* IE length */
+	u_int16_t isi_associd;		/* assoc response */
+	u_int16_t isi_txpower;		/* current tx power */
+	u_int16_t isi_vlan;		/* vlan tag */
+	u_int16_t isi_txseqs[17];	/* seq to be transmitted */
+	u_int16_t isi_rxseqs[17];	/* seq previous for qos frames*/
+	u_int16_t isi_inact;		/* inactivity timer */
+	u_int8_t isi_uapsd;		/* UAPSD queues */
+	u_int8_t isi_opmode;		/* sta operating mode */
 
-  /* XXX frag state? */
-  /* variable length IE data */
+	/* XXX frag state? */
+	/* variable length IE data */
 };
 
+
 struct ath_stats {
-  u_int32_t ast_watchdog;      /* device reset by watchdog */
-  u_int32_t ast_hardware;      /* fatal hardware error interrupts */
-  u_int32_t ast_bmiss;         /* beacon miss interrupts */
-  u_int32_t ast_rxorn;         /* rx overrun interrupts */
-  u_int32_t ast_rxeol;         /* rx eol interrupts */
-  u_int32_t ast_txurn;         /* tx underrun interrupts */
-  u_int32_t ast_mib;           /* mib interrupts */
-  u_int32_t ast_tx_packets;    /* packet sent on the interface */
-  u_int32_t ast_tx_mgmt;       /* management frames transmitted */
-  u_int32_t ast_tx_discard;    /* frames discarded prior to assoc */
-  u_int32_t ast_tx_invalid;    /* frames discarded due to is device gone */
-  u_int32_t ast_tx_qstop;      /* tx queue stopped because it's full */
-  u_int32_t ast_tx_encap;      /* tx encapsulation failed */
-  u_int32_t ast_tx_nonode;     /* tx failed due to of no node */
-  u_int32_t ast_tx_nobuf;      /* tx failed due to of no tx buffer (data) */
-  u_int32_t ast_tx_nobufmgt;   /* tx failed due to of no tx buffer (mgmt)*/
-  u_int32_t ast_tx_xretries;   /* tx failed due to of too many retries */
-  u_int32_t ast_tx_fifoerr;    /* tx failed due to of FIFO underrun */
-  u_int32_t ast_tx_filtered;   /* tx failed due to xmit filtered */
-  u_int32_t ast_tx_shortretry; /* tx on-chip retries (short) */
-  u_int32_t ast_tx_longretry;  /* tx on-chip retries (long) */
-  u_int32_t ast_tx_badrate;    /* tx failed due to of bogus xmit rate */
-  u_int32_t ast_tx_noack;      /* tx frames with no ack marked */
-  u_int32_t ast_tx_rts;        /* tx frames with rts enabled */
-  u_int32_t ast_tx_cts;        /* tx frames with cts enabled */
-  u_int32_t ast_tx_shortpre;   /* tx frames with short preamble */
-  u_int32_t ast_tx_altrate;    /* tx frames with alternate rate */
-  u_int32_t ast_tx_protect;    /* tx frames with protection */
-  u_int32_t ast_rx_orn;        /* rx failed due to of desc overrun */
-  u_int32_t ast_rx_crcerr;     /* rx failed due to of bad CRC */
-  u_int32_t ast_rx_fifoerr;    /* rx failed due to of FIFO overrun */
-  u_int32_t ast_rx_badcrypt;   /* rx failed due to of decryption */
-  u_int32_t ast_rx_badmic;     /* rx failed due to of MIC failure */
-  u_int32_t ast_rx_phyerr;     /* rx PHY error summary count */
-  u_int32_t ast_rx_phy[32];    /* rx PHY error per-code counts */
-  u_int32_t ast_rx_tooshort;   /* rx discarded due to frame too short */
-  u_int32_t ast_rx_toobig;     /* rx discarded due to frame too large */
-  u_int32_t ast_rx_nobuf;      /* rx setup failed due to of no skbuff */
-  u_int32_t ast_rx_packets;    /* packet recv on the interface */
-  u_int32_t ast_rx_mgt;        /* management frames received */
-  u_int32_t ast_rx_ctl;        /* control frames received */
-  int8_t ast_tx_rssi;          /* tx rssi of last ack */
-  int8_t ast_rx_rssi;          /* rx rssi from histogram */
-  u_int32_t ast_be_xmit;       /* beacons transmitted */
-  u_int32_t ast_be_nobuf;      /* no skbuff available for beacon */
-  u_int32_t ast_per_cal;       /* periodic calibration calls */
-  u_int32_t ast_per_calfail;   /* periodic calibration failed */
-  u_int32_t ast_per_rfgain;    /* periodic calibration rfgain reset */
-  u_int32_t ast_rate_calls;    /* rate control checks */
-  u_int32_t ast_rate_raise;    /* rate control raised xmit rate */
-  u_int32_t ast_rate_drop;     /* rate control dropped xmit rate */
-  u_int32_t ast_ant_defswitch; /* rx/default antenna switches */
-  u_int32_t ast_ant_txswitch;  /* tx antenna switches */
-  u_int32_t ast_ant_rx[8];     /* rx frames with antenna */
-  u_int32_t ast_ant_tx[8];     /* tx frames with antenna */
+	u_int32_t ast_watchdog;		/* device reset by watchdog */
+	u_int32_t ast_hardware;		/* fatal hardware error interrupts */
+	u_int32_t ast_bmiss;		/* beacon miss interrupts */
+	u_int32_t ast_rxorn;		/* rx overrun interrupts */
+	u_int32_t ast_rxeol;		/* rx eol interrupts */
+	u_int32_t ast_txurn;		/* tx underrun interrupts */
+	u_int32_t ast_mib;		/* mib interrupts */
+	u_int32_t ast_tx_packets;	/* packet sent on the interface */
+	u_int32_t ast_tx_mgmt;		/* management frames transmitted */
+	u_int32_t ast_tx_discard;	/* frames discarded prior to assoc */
+	u_int32_t ast_tx_invalid;	/* frames discarded due to is device gone */
+	u_int32_t ast_tx_qstop;		/* tx queue stopped because it's full */
+	u_int32_t ast_tx_encap;		/* tx encapsulation failed */
+	u_int32_t ast_tx_nonode;	/* tx failed due to of no node */
+	u_int32_t ast_tx_nobuf;		/* tx failed due to of no tx buffer (data) */
+	u_int32_t ast_tx_nobufmgt;	/* tx failed due to of no tx buffer (mgmt)*/
+	u_int32_t ast_tx_xretries;	/* tx failed due to of too many retries */
+	u_int32_t ast_tx_fifoerr;	/* tx failed due to of FIFO underrun */
+	u_int32_t ast_tx_filtered;	/* tx failed due to xmit filtered */
+	u_int32_t ast_tx_shortretry;	/* tx on-chip retries (short) */
+	u_int32_t ast_tx_longretry;	/* tx on-chip retries (long) */
+	u_int32_t ast_tx_badrate;	/* tx failed due to of bogus xmit rate */
+	u_int32_t ast_tx_noack;		/* tx frames with no ack marked */
+	u_int32_t ast_tx_rts;		/* tx frames with rts enabled */
+	u_int32_t ast_tx_cts;		/* tx frames with cts enabled */
+	u_int32_t ast_tx_shortpre;	/* tx frames with short preamble */
+	u_int32_t ast_tx_altrate;	/* tx frames with alternate rate */
+	u_int32_t ast_tx_protect;	/* tx frames with protection */
+	u_int32_t ast_rx_orn;		/* rx failed due to of desc overrun */
+	u_int32_t ast_rx_crcerr;	/* rx failed due to of bad CRC */
+	u_int32_t ast_rx_fifoerr;	/* rx failed due to of FIFO overrun */
+	u_int32_t ast_rx_badcrypt;	/* rx failed due to of decryption */
+	u_int32_t ast_rx_badmic;	/* rx failed due to of MIC failure */
+	u_int32_t ast_rx_phyerr;	/* rx PHY error summary count */
+	u_int32_t ast_rx_phy[32];	/* rx PHY error per-code counts */
+	u_int32_t ast_rx_tooshort;	/* rx discarded due to frame too short */
+	u_int32_t ast_rx_toobig;	/* rx discarded due to frame too large */
+	u_int32_t ast_rx_nobuf;		/* rx setup failed due to of no skbuff */
+	u_int32_t ast_rx_packets;	/* packet recv on the interface */
+	u_int32_t ast_rx_mgt;		/* management frames received */
+	u_int32_t ast_rx_ctl;		/* control frames received */
+	int8_t ast_tx_rssi;		/* tx rssi of last ack */
+	int8_t ast_rx_rssi;		/* rx rssi from histogram */
+	u_int32_t ast_be_xmit;		/* beacons transmitted */
+	u_int32_t ast_be_nobuf;		/* no skbuff available for beacon */
+	u_int32_t ast_per_cal;		/* periodic calibration calls */
+	u_int32_t ast_per_calfail;	/* periodic calibration failed */
+	u_int32_t ast_per_rfgain;	/* periodic calibration rfgain reset */
+	u_int32_t ast_rate_calls;	/* rate control checks */
+	u_int32_t ast_rate_raise;	/* rate control raised xmit rate */
+	u_int32_t ast_rate_drop;	/* rate control dropped xmit rate */
+	u_int32_t ast_ant_defswitch;	/* rx/default antenna switches */
+	u_int32_t ast_ant_txswitch;	/* tx antenna switches */
+	u_int32_t ast_ant_rx[8];	/* rx frames with antenna */
+	u_int32_t ast_ant_tx[8];	/* tx frames with antenna */
 };
 
-#define SIOCGATHSTATS (SIOCDEVPRIVATE + 0)
-#define SIOCGATHDIAG (SIOCDEVPRIVATE + 1)
-#define SIOCGATHRADARSIG (SIOCDEVPRIVATE + 2)
-#define SIOCGATHHALDIAG (SIOCDEVPRIVATE + 3)
-#define SIOCG80211STATS (SIOCDEVPRIVATE + 2)
+#define	SIOCGATHSTATS			(SIOCDEVPRIVATE+0)
+#define	SIOCGATHDIAG			(SIOCDEVPRIVATE+1)
+#define	SIOCGATHRADARSIG		(SIOCDEVPRIVATE+2)
+#define	SIOCGATHHALDIAG			(SIOCDEVPRIVATE+3)
+#define	SIOCG80211STATS			(SIOCDEVPRIVATE+2)
 /* NB: require in+out parameters so cannot use wireless extensions, yech */
-#define IEEE80211_IOCTL_GETKEY (SIOCDEVPRIVATE + 3)
-#define IEEE80211_IOCTL_GETWPAIE (SIOCDEVPRIVATE + 4)
-#define IEEE80211_IOCTL_STA_STATS (SIOCDEVPRIVATE + 5)
-#define IEEE80211_IOCTL_STA_INFO (SIOCDEVPRIVATE + 6)
-#define SIOC80211IFCREATE (SIOCDEVPRIVATE + 7)
-#define SIOC80211IFDESTROY (SIOCDEVPRIVATE + 8)
-#define IEEE80211_IOCTL_SCAN_RESULTS (SIOCDEVPRIVATE + 9)
+#define	IEEE80211_IOCTL_GETKEY		(SIOCDEVPRIVATE+3)
+#define	IEEE80211_IOCTL_GETWPAIE	(SIOCDEVPRIVATE+4)
+#define	IEEE80211_IOCTL_STA_STATS	(SIOCDEVPRIVATE+5)
+#define	IEEE80211_IOCTL_STA_INFO	(SIOCDEVPRIVATE+6)
+#define	SIOC80211IFCREATE		(SIOCDEVPRIVATE+7)
+#define	SIOC80211IFDESTROY	 	(SIOCDEVPRIVATE+8)
+#define	IEEE80211_IOCTL_SCAN_RESULTS	(SIOCDEVPRIVATE+9)
+
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/Makefile.am	2017-10-06 14:45:52.929917747 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/Makefile.am	2016-12-12 16:03:36.688279258 +0800
@@ -24,12 +24,21 @@
 v_protoc_0 = @echo "  PROTOC  " $@;
 
 noinst_LTLIBRARIES =
 check_PROGRAMS =
 TESTS =
 
+noinst_LTLIBRARIES += libformat_graphite.la
+libformat_graphite_la_SOURCES  = utils_format_graphite.c utils_format_graphite.h
+libformat_graphite_la_CPPFLAGS = $(AM_CPPFLAGS)
+libformat_graphite_la_LDFLAGS  = $(AM_LDFLAGS)
+check_PROGRAMS += test_format_graphite
+TESTS += test_format_graphite
+test_format_graphite_SOURCES = utils_format_graphite_test.c testing.h
+test_format_graphite_LDADD = libformat_graphite.la daemon/libmetadata.la daemon/libplugin_mock.la -lm
+
 noinst_LTLIBRARIES += libformat_json.la
 libformat_json_la_SOURCES   = utils_format_json.c utils_format_json.h
 libformat_json_la_CPPFLAGS  = $(AM_CPPFLAGS)
 libformat_json_la_LDFLAGS   = $(AM_LDFLAGS)
 libformat_json_la_LIBADD    =
 if BUILD_WITH_LIBYAJL
@@ -40,18 +49,35 @@
 TESTS += test_format_json
 test_format_json_SOURCES = utils_format_json_test.c testing.h
 test_format_json_LDADD = libformat_json.la daemon/libmetadata.la daemon/libplugin_mock.la -lm
 endif
 
 noinst_LTLIBRARIES += liblatency.la
-liblatency_la_SOURCES = utils_latency.c utils_latency.h
+liblatency_la_SOURCES = utils_latency.c utils_latency.h utils_latency_config.c utils_latency_config.h
+liblatency_la_LIBADD = daemon/libcommon.la -lm
 check_PROGRAMS += test_utils_latency
 TESTS += test_utils_latency
 test_utils_latency_SOURCES = utils_latency_test.c testing.h
 test_utils_latency_LDADD = liblatency.la daemon/libplugin_mock.la -lm
 
+noinst_LTLIBRARIES += libcmds.la
+libcmds_la_SOURCES = utils_cmds.c utils_cmds.h \
+                     utils_cmd_flush.c utils_cmd_flush.h \
+                     utils_cmd_getthreshold.c utils_cmd_getthreshold.h \
+                     utils_cmd_getval.c utils_cmd_getval.h \
+                     utils_cmd_listval.c utils_cmd_listval.h \
+                     utils_cmd_putnotif.c utils_cmd_putnotif.h \
+                     utils_cmd_putval.c utils_cmd_putval.h \
+                     utils_parse_option.c utils_parse_option.h
+libcmds_la_LIBADD = daemon/libcommon.la daemon/libmetadata.la -lm
+check_PROGRAMS += test_utils_cmds
+TESTS += test_utils_cmds
+test_utils_cmds_SOURCES = utils_cmds_test.c testing.h
+test_utils_cmds_LDADD = libcmds.la \
+                        daemon/libplugin_mock.la
+
 noinst_LTLIBRARIES += liblookup.la
 liblookup_la_SOURCES = utils_vl_lookup.c utils_vl_lookup.h
 liblookup_la_LIBADD = daemon/libavltree.la
 check_PROGRAMS += test_utils_vl_lookup
 TESTS += test_utils_vl_lookup
 test_utils_vl_lookup_SOURCES = utils_vl_lookup_test.c testing.h
@@ -150,19 +176,17 @@
 aggregation_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 aggregation_la_LIBADD = -lm
 endif
 
 if BUILD_PLUGIN_AMQP
 pkglib_LTLIBRARIES += amqp.la
-amqp_la_SOURCES = amqp.c \
-		  utils_cmd_putval.c utils_cmd_putval.h \
-	          utils_parse_option.c utils_parse_option.h \
-		  utils_format_graphite.c utils_format_graphite.h
+amqp_la_SOURCES = amqp.c
 amqp_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBRABBITMQ_LDFLAGS)
 amqp_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBRABBITMQ_CPPFLAGS)
-amqp_la_LIBADD = $(BUILD_WITH_LIBRABBITMQ_LIBS) libformat_json.la
+amqp_la_LIBADD = $(BUILD_WITH_LIBRABBITMQ_LIBS) \
+                 libcmds.la libformat_graphite.la libformat_json.la
 endif
 
 if BUILD_PLUGIN_APACHE
 pkglib_LTLIBRARIES += apache.la
 apache_la_SOURCES = apache.c
 apache_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -210,13 +234,13 @@
 barometer_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 barometer_la_LIBADD = -lm
 endif
 
 if BUILD_PLUGIN_BATTERY
 pkglib_LTLIBRARIES += battery.la
-battery_la_SOURCES = battery.c
+battery_la_SOURCES = battery.c battery_statefs.c
 battery_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 if BUILD_WITH_LIBIOKIT
 battery_la_LDFLAGS += -framework IOKit
 endif
 endif
 
@@ -246,13 +270,12 @@
 endif
 
 if BUILD_PLUGIN_CHRONY
 pkglib_LTLIBRARIES += chrony.la
 chrony_la_SOURCES = chrony.c
 chrony_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-chrony_la_LIBADD = -lm
 endif
 
 if BUILD_PLUGIN_CONNTRACK
 pkglib_LTLIBRARIES += conntrack.la
 conntrack_la_SOURCES = conntrack.c
 conntrack_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -307,16 +330,17 @@
 csv_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_CURL
 pkglib_LTLIBRARIES += curl.la
 curl_la_SOURCES = curl.c \
-		  utils_curl_stats.c utils_curl_stats.h
+                  utils_curl_stats.c utils_curl_stats.h \
+                  utils_match.c utils_match.h
 curl_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 curl_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBCURL_CFLAGS)
-curl_la_LIBADD = $(BUILD_WITH_LIBCURL_LIBS)
+curl_la_LIBADD = $(BUILD_WITH_LIBCURL_LIBS) liblatency.la
 endif
 
 if BUILD_PLUGIN_CURL_JSON
 pkglib_LTLIBRARIES += curl_json.la
 curl_json_la_SOURCES = curl_json.c \
 		  utils_curl_stats.c utils_curl_stats.h
@@ -388,12 +412,20 @@
 pkglib_LTLIBRARIES += dns.la
 dns_la_SOURCES = dns.c utils_dns.c utils_dns.h
 dns_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 dns_la_LIBADD = -lpcap
 endif
 
+if BUILD_PLUGIN_DPDKSTAT
+pkglib_LTLIBRARIES += dpdkstat.la
+dpdkstat_la_SOURCES = dpdkstat.c
+dpdkstat_la_CPPFLAGS = $(AM_CPPFLAGS) $(LIBDPDK_CPPFLAGS)
+dpdkstat_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(LIBDPDK_LDFLAGS)
+dpdkstat_la_LIBADD = -ldpdk
+endif
+
 if BUILD_PLUGIN_DRBD
 pkglib_LTLIBRARIES += drbd.la
 drbd_la_SOURCES = drbd.c
 drbd_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
@@ -408,17 +440,14 @@
 entropy_la_SOURCES = entropy.c
 entropy_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_EXEC
 pkglib_LTLIBRARIES += exec.la
-exec_la_SOURCES = exec.c \
-		  utils_cmd_putnotif.c utils_cmd_putnotif.h \
-		  utils_cmd_putval.c utils_cmd_putval.h \
-		  utils_parse_option.h utils_parse_option.c
-exec_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+exec_la_SOURCES = exec.c
+exec_la_LDFLAGS = $(PLUGIN_LDFLAGS) libcmds.la
 endif
 
 if BUILD_PLUGIN_ETHSTAT
 pkglib_LTLIBRARIES += ethstat.la
 ethstat_la_SOURCES = ethstat.c
 ethstat_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -468,12 +497,18 @@
 hddtemp_la_LIBADD =
 if BUILD_WITH_LIBSOCKET
 hddtemp_la_LIBADD += -lsocket
 endif
 endif
 
+if BUILD_PLUGIN_HUGEPAGES
+pkglib_LTLIBRARIES += hugepages.la
+hugepages_la_SOURCES = hugepages.c
+hugepages_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+endif
+
 if BUILD_PLUGIN_INTERFACE
 pkglib_LTLIBRARIES += interface.la
 interface_la_SOURCES = interface.c
 interface_la_CFLAGS = $(AM_CFLAGS)
 interface_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 interface_la_LIBADD =
@@ -644,16 +679,17 @@
 md_la_SOURCES = md.c
 md_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_MEMCACHEC
 pkglib_LTLIBRARIES += memcachec.la
-memcachec_la_SOURCES = memcachec.c
+memcachec_la_SOURCES = memcachec.c \
+                       utils_match.c utils_match.h
 memcachec_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBMEMCACHED_LDFLAGS)
 memcachec_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBMEMCACHED_CPPFLAGS)
-memcachec_la_LIBADD = $(BUILD_WITH_LIBMEMCACHED_LIBS)
+memcachec_la_LIBADD = $(BUILD_WITH_LIBMEMCACHED_LIBS) liblatency.la
 endif
 
 if BUILD_PLUGIN_MEMCACHED
 pkglib_LTLIBRARIES += memcached.la
 memcached_la_SOURCES = memcached.c
 memcached_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -784,13 +820,13 @@
 endif
 
 if BUILD_PLUGIN_NOTIFY_EMAIL
 pkglib_LTLIBRARIES += notify_email.la
 notify_email_la_SOURCES = notify_email.c
 notify_email_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-notify_email_la_LIBADD = -lesmtp
+notify_email_la_LIBADD = -lesmtp -lssl -lcrypto
 endif
 
 if BUILD_PLUGIN_NOTIFY_NAGIOS
 pkglib_LTLIBRARIES += notify_nagios.la
 notify_nagios_la_SOURCES = notify_nagios.c
 notify_nagios_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -946,12 +982,20 @@
 if BUILD_PLUGIN_PROTOCOLS
 pkglib_LTLIBRARIES += protocols.la
 protocols_la_SOURCES = protocols.c
 protocols_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
+if BUILD_PLUGIN_INTEL_RDT
+pkglib_LTLIBRARIES += intel_rdt.la
+intel_rdt_la_SOURCES = intel_rdt.c
+intel_rdt_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBPQOS_LDFLAGS)
+intel_rdt_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBPQOS_CPPFLAGS)
+intel_rdt_la_LIBADD = $(BUILD_WITH_LIBPQOS_LIBS)
+endif
+
 if BUILD_PLUGIN_REDIS
 pkglib_LTLIBRARIES += redis.la
 redis_la_SOURCES = redis.c
 redis_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBHIREDIS_LDFLAGS)
 redis_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBHIREDIS_CPPFLAGS)
 redis_la_LIBADD = -lhiredis
@@ -1022,13 +1066,13 @@
 endif
 
 if BUILD_PLUGIN_STATSD
 pkglib_LTLIBRARIES += statsd.la
 statsd_la_SOURCES = statsd.c
 statsd_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-statsd_la_LIBADD = liblatency.la -lm
+statsd_la_LIBADD = liblatency.la
 endif
 
 if BUILD_PLUGIN_SWAP
 pkglib_LTLIBRARIES += swap.la
 swap_la_SOURCES = swap.c
 swap_la_CFLAGS = $(AM_CFLAGS)
@@ -1064,19 +1108,24 @@
 table_la_SOURCES = table.c
 table_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_TAIL
 pkglib_LTLIBRARIES += tail.la
-tail_la_SOURCES = tail.c
+tail_la_SOURCES = tail.c \
+                  utils_match.c utils_match.h \
+                  utils_tail.c utils_tail.h \
+                  utils_tail_match.c utils_tail_match.h
 tail_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+tail_la_LIBADD = liblatency.la
 endif
 
 if BUILD_PLUGIN_TAIL_CSV
 pkglib_LTLIBRARIES += tail_csv.la
-tail_csv_la_SOURCES = tail_csv.c
+tail_csv_la_SOURCES = tail_csv.c \
+                      utils_tail.c utils_tail.h
 tail_csv_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_TAPE
 pkglib_LTLIBRARIES += tape.la
 tape_la_SOURCES = tape.c
@@ -1164,21 +1213,14 @@
 turbostat_la_SOURCES = turbostat.c
 turbostat_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_UNIXSOCK
 pkglib_LTLIBRARIES += unixsock.la
-unixsock_la_SOURCES = unixsock.c \
-		      utils_cmd_flush.h utils_cmd_flush.c \
-		      utils_cmd_getval.h utils_cmd_getval.c \
-		      utils_cmd_getthreshold.h utils_cmd_getthreshold.c \
-		      utils_cmd_listval.h utils_cmd_listval.c \
-		      utils_cmd_putval.h utils_cmd_putval.c \
-		      utils_cmd_putnotif.h utils_cmd_putnotif.c \
-		      utils_parse_option.h utils_parse_option.c
-unixsock_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+unixsock_la_SOURCES = unixsock.c
+unixsock_la_LDFLAGS = $(PLUGIN_LDFLAGS) libcmds.la
 endif
 
 if BUILD_PLUGIN_UPTIME
 pkglib_LTLIBRARIES += uptime.la
 uptime_la_SOURCES = uptime.c
 uptime_la_CFLAGS = $(AM_CFLAGS)
@@ -1246,15 +1288,15 @@
 wireless_la_SOURCES = wireless.c
 wireless_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_WRITE_GRAPHITE
 pkglib_LTLIBRARIES += write_graphite.la
-write_graphite_la_SOURCES = write_graphite.c \
-                        utils_format_graphite.c utils_format_graphite.h
+write_graphite_la_SOURCES = write_graphite.c
 write_graphite_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+write_graphite_la_LIBADD = libformat_graphite.la
 endif
 
 if BUILD_PLUGIN_WRITE_HTTP
 pkglib_LTLIBRARIES += write_http.la
 write_http_la_SOURCES = write_http.c \
 			utils_format_kairosdb.c utils_format_kairosdb.h
@@ -1263,35 +1305,43 @@
 write_http_la_LIBADD = $(BUILD_WITH_LIBCURL_LIBS) libformat_json.la
 endif
 
 if BUILD_PLUGIN_WRITE_KAFKA
 pkglib_LTLIBRARIES += write_kafka.la
 write_kafka_la_SOURCES = write_kafka.c \
-                        utils_format_graphite.c utils_format_graphite.h \
-                        utils_cmd_putval.c utils_cmd_putval.h \
-                        utils_crc32.c utils_crc32.h
+                         utils_crc32.c utils_crc32.h
 write_kafka_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBRDKAFKA_CPPFLAGS)
 write_kafka_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBRDKAFKA_LDFLAGS)
-write_kafka_la_LIBADD = $(BUILD_WITH_LIBRDKAFKA_LIBS) libformat_json.la
+write_kafka_la_LIBADD = $(BUILD_WITH_LIBRDKAFKA_LIBS) \
+                        libcmds.la libformat_graphite.la libformat_json.la
 endif
 
 if BUILD_PLUGIN_WRITE_LOG
 pkglib_LTLIBRARIES += write_log.la
-write_log_la_SOURCES = write_log.c \
-                        utils_format_graphite.c utils_format_graphite.h
+write_log_la_SOURCES = write_log.c
 write_log_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+write_log_la_LIBADD = libformat_graphite.la libformat_json.la
 endif
 
 if BUILD_PLUGIN_WRITE_MONGODB
 pkglib_LTLIBRARIES += write_mongodb.la
 write_mongodb_la_SOURCES = write_mongodb.c
 write_mongodb_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBMONGOC_CPPFLAGS)
 write_mongodb_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBMONGOC_LDFLAGS)
 write_mongodb_la_LIBADD = -lmongoc
 endif
 
+if BUILD_PLUGIN_WRITE_PROMETHEUS
+pkglib_LTLIBRARIES += write_prometheus.la
+write_prometheus_la_SOURCES = write_prometheus.c
+nodist_write_prometheus_la_SOURCES = prometheus.pb-c.c prometheus.pb-c.h
+write_prometheus_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS) $(BUILD_WITH_LIBMICROHTTPD_CPPFLAGS)
+write_prometheus_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBPROTOBUF_C_LDFLAGS) $(BUILD_WITH_LIBMICROHTTPD_LDFLAGS)
+write_prometheus_la_LIBADD = $(BUILD_WITH_LIBPROTOBUF_C_LIBS) $(BUILD_WITH_LIBMICROHTTPD_LIBS)
+endif
+
 if BUILD_PLUGIN_WRITE_REDIS
 pkglib_LTLIBRARIES += write_redis.la
 write_redis_la_SOURCES = write_redis.c
 write_redis_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBHIREDIS_LDFLAGS)
 write_redis_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBHIREDIS_CPPFLAGS)
 write_redis_la_LIBADD = -lhiredis
@@ -1428,12 +1478,21 @@
 BUILT_SOURCES += pinba.pb-c.c pinba.pb-c.h
 
 pinba.pb-c.c pinba.pb-c.h: pinba.proto
 	$(AM_V_PROTOC_C)$(PROTOC_C) -I$(srcdir) --c_out . $(srcdir)/pinba.proto
 endif
 
+# Protocol buffer for the "write_prometheus" plugin.
+if BUILD_PLUGIN_WRITE_PROMETHEUS
+CLEANFILES += prometheus.pb-c.c prometheus.pb-c.h
+BUILT_SOURCES += prometheus.pb-c.c prometheus.pb-c.h
+
+prometheus.pb-c.c prometheus.pb-c.h: $(top_srcdir)/proto/prometheus.proto
+	$(AM_V_PROTOC_C)$(PROTOC_C) -I$(top_srcdir)/proto --c_out=$(builddir) $(top_srcdir)/proto/prometheus.proto
+endif
+
 install-exec-hook:
 	$(mkinstalldirs) $(DESTDIR)$(sysconfdir)
 	if test -e $(DESTDIR)$(sysconfdir)/collectd.conf; \
 	then \
 		$(INSTALL) -m 0640 collectd.conf $(DESTDIR)$(sysconfdir)/collectd.conf.pkg-orig; \
 	else \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/Makefile.in	2017-10-06 15:04:19.666135626 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/Makefile.in	2016-12-12 16:03:47.320207305 +0800
@@ -78,16 +78,18 @@
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 @BUILD_WITH_OWN_LIBOCONFIG_TRUE@am__append_1 = liboconfig
 @BUILD_FEATURE_DAEMON_TRUE@am__append_2 = -DPIDFILE='"${localstatedir}/run/${PACKAGE_NAME}.pid"'
-check_PROGRAMS = $(am__EXEEXT_1) test_utils_latency$(EXEEXT) \
+check_PROGRAMS = test_format_graphite$(EXEEXT) $(am__EXEEXT_1) \
+	test_utils_latency$(EXEEXT) test_utils_cmds$(EXEEXT) \
 	test_utils_vl_lookup$(EXEEXT) test_utils_mount$(EXEEXT) \
 	$(am__EXEEXT_2)
-TESTS = $(am__EXEEXT_1) test_utils_latency$(EXEEXT) \
+TESTS = test_format_graphite$(EXEEXT) $(am__EXEEXT_1) \
+	test_utils_latency$(EXEEXT) test_utils_cmds$(EXEEXT) \
 	test_utils_vl_lookup$(EXEEXT) test_utils_mount$(EXEEXT) \
 	$(am__EXEEXT_2)
 @BUILD_WITH_LIBYAJL_TRUE@am__append_3 = $(BUILD_WITH_LIBYAJL_CPPFLAGS)
 @BUILD_WITH_LIBYAJL_TRUE@am__append_4 = $(BUILD_WITH_LIBYAJL_LDFLAGS)
 @BUILD_WITH_LIBYAJL_TRUE@am__append_5 = $(BUILD_WITH_LIBYAJL_LIBS)
 @BUILD_WITH_LIBYAJL_TRUE@am__append_6 = test_format_json
@@ -149,187 +151,188 @@
 @BUILD_PLUGIN_DISK_TRUE@@BUILD_WITH_LIBUDEV_TRUE@am__append_57 = $(BUILD_WITH_LIBUDEV_CFLAGS)
 @BUILD_PLUGIN_DISK_TRUE@@BUILD_WITH_LIBUDEV_TRUE@am__append_58 = $(BUILD_WITH_LIBUDEV_LDFLAGS)
 @BUILD_PLUGIN_DISK_TRUE@@BUILD_WITH_LIBUDEV_TRUE@am__append_59 = $(BUILD_WITH_LIBUDEV_LIBS)
 @BUILD_FREEBSD_TRUE@@BUILD_PLUGIN_DISK_TRUE@am__append_60 = -ldevstat -lgeom
 @BUILD_PLUGIN_DISK_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_61 = -lperfstat
 @BUILD_PLUGIN_DNS_TRUE@am__append_62 = dns.la
-@BUILD_PLUGIN_DRBD_TRUE@am__append_63 = drbd.la
-@BUILD_PLUGIN_EMAIL_TRUE@am__append_64 = email.la
-@BUILD_PLUGIN_ENTROPY_TRUE@am__append_65 = entropy.la
-@BUILD_PLUGIN_EXEC_TRUE@am__append_66 = exec.la
-@BUILD_PLUGIN_ETHSTAT_TRUE@am__append_67 = ethstat.la
-@BUILD_PLUGIN_FHCOUNT_TRUE@am__append_68 = fhcount.la
-@BUILD_PLUGIN_FILECOUNT_TRUE@am__append_69 = filecount.la
-@BUILD_PLUGIN_GMOND_TRUE@am__append_70 = gmond.la
-@BUILD_PLUGIN_GPS_TRUE@am__append_71 = gps.la
-@BUILD_PLUGIN_GRPC_TRUE@am__append_72 = grpc.la
-@BUILD_PLUGIN_HDDTEMP_TRUE@am__append_73 = hddtemp.la
-@BUILD_PLUGIN_HDDTEMP_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_74 = -lsocket
-@BUILD_PLUGIN_INTERFACE_TRUE@am__append_75 = interface.la
-@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_76 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
-@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_77 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
-@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@@BUILD_WITH_LIBSTATGRAB_FALSE@am__append_78 = -lkstat
-@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBDEVINFO_TRUE@@BUILD_WITH_LIBSTATGRAB_FALSE@am__append_79 = -ldevinfo
-@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_80 = -lperfstat
-@BUILD_PLUGIN_IPC_TRUE@am__append_81 = ipc.la
-@BUILD_PLUGIN_IPTABLES_TRUE@am__append_82 = iptables.la
-@BUILD_PLUGIN_IPMI_TRUE@am__append_83 = ipmi.la
-@BUILD_PLUGIN_IPVS_TRUE@am__append_84 = ipvs.la
-@BUILD_PLUGIN_IPVS_TRUE@@IP_VS_H_NEEDS_KERNEL_CFLAGS_TRUE@am__append_85 = $(KERNEL_CFLAGS)
-@BUILD_PLUGIN_IRQ_TRUE@am__append_86 = irq.la
-@BUILD_PLUGIN_JAVA_TRUE@am__append_87 = java.la
-@BUILD_PLUGIN_LOAD_TRUE@am__append_88 = load.la
-@BUILD_PLUGIN_LOAD_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_89 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
-@BUILD_PLUGIN_LOAD_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_90 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
-@BUILD_PLUGIN_LOAD_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_91 = -lperfstat
-@BUILD_PLUGIN_LOGFILE_TRUE@am__append_92 = logfile.la
-@BUILD_PLUGIN_LOG_LOGSTASH_TRUE@am__append_93 = log_logstash.la
-@BUILD_PLUGIN_LPAR_TRUE@am__append_94 = lpar.la
-@BUILD_PLUGIN_LUA_TRUE@am__append_95 = lua.la
-@BUILD_PLUGIN_LVM_TRUE@am__append_96 = lvm.la
-@BUILD_PLUGIN_MADWIFI_TRUE@am__append_97 = madwifi.la
-@BUILD_PLUGIN_MATCH_EMPTY_COUNTER_TRUE@am__append_98 = match_empty_counter.la
-@BUILD_PLUGIN_MATCH_HASHED_TRUE@am__append_99 = match_hashed.la
-@BUILD_PLUGIN_MATCH_REGEX_TRUE@am__append_100 = match_regex.la
-@BUILD_PLUGIN_MATCH_TIMEDIFF_TRUE@am__append_101 = match_timediff.la
-@BUILD_PLUGIN_MATCH_VALUE_TRUE@am__append_102 = match_value.la
-@BUILD_PLUGIN_MBMON_TRUE@am__append_103 = mbmon.la
-@BUILD_PLUGIN_MBMON_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_104 = -lsocket
-@BUILD_PLUGIN_MD_TRUE@am__append_105 = md.la
-@BUILD_PLUGIN_MEMCACHEC_TRUE@am__append_106 = memcachec.la
-@BUILD_PLUGIN_MEMCACHED_TRUE@am__append_107 = memcached.la
-@BUILD_PLUGIN_MEMCACHED_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_108 = -lsocket
-@BUILD_PLUGIN_MEMORY_TRUE@am__append_109 = memory.la
-@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_110 = -lkstat
-@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_LIBDEVINFO_TRUE@am__append_111 = -ldevinfo
-@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_112 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
-@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_113 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
-@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_114 = -lperfstat
-@BUILD_PLUGIN_MIC_TRUE@am__append_115 = mic.la
-@BUILD_PLUGIN_MODBUS_TRUE@am__append_116 = modbus.la
-@BUILD_PLUGIN_MQTT_TRUE@am__append_117 = mqtt.la
-@BUILD_PLUGIN_MULTIMETER_TRUE@am__append_118 = multimeter.la
-@BUILD_PLUGIN_MYSQL_TRUE@am__append_119 = mysql.la
-@BUILD_PLUGIN_NETAPP_TRUE@am__append_120 = netapp.la
-@BUILD_PLUGIN_NETLINK_TRUE@am__append_121 = netlink.la
-@BUILD_PLUGIN_NETWORK_TRUE@am__append_122 = network.la
-@BUILD_PLUGIN_NETWORK_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_123 = -lsocket
-@BUILD_PLUGIN_NETWORK_TRUE@@BUILD_WITH_LIBGCRYPT_TRUE@am__append_124 = $(GCRYPT_CPPFLAGS)
-@BUILD_PLUGIN_NETWORK_TRUE@@BUILD_WITH_LIBGCRYPT_TRUE@am__append_125 = $(GCRYPT_LDFLAGS)
-@BUILD_PLUGIN_NETWORK_TRUE@@BUILD_WITH_LIBGCRYPT_TRUE@am__append_126 = $(GCRYPT_LIBS)
-@BUILD_PLUGIN_NFS_TRUE@am__append_127 = nfs.la
-@BUILD_PLUGIN_FSCACHE_TRUE@am__append_128 = fscache.la
-@BUILD_PLUGIN_NGINX_TRUE@am__append_129 = nginx.la
-@BUILD_PLUGIN_NOTIFY_DESKTOP_TRUE@am__append_130 = notify_desktop.la
-@BUILD_PLUGIN_NOTIFY_EMAIL_TRUE@am__append_131 = notify_email.la
-@BUILD_PLUGIN_NOTIFY_NAGIOS_TRUE@am__append_132 = notify_nagios.la
-@BUILD_PLUGIN_NTPD_TRUE@am__append_133 = ntpd.la
-@BUILD_PLUGIN_NTPD_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_134 = -lsocket
-@BUILD_PLUGIN_NUMA_TRUE@am__append_135 = numa.la
-@BUILD_PLUGIN_NUT_TRUE@am__append_136 = nut.la
-@BUILD_PLUGIN_OLSRD_TRUE@am__append_137 = olsrd.la
-@BUILD_PLUGIN_OLSRD_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_138 = -lsocket
-@BUILD_PLUGIN_ONEWIRE_TRUE@am__append_139 = onewire.la
-@BUILD_PLUGIN_OPENLDAP_TRUE@am__append_140 = openldap.la
-@BUILD_PLUGIN_OPENVPN_TRUE@am__append_141 = openvpn.la
-@BUILD_PLUGIN_ORACLE_TRUE@am__append_142 = oracle.la
-@BUILD_PLUGIN_PERL_TRUE@am__append_143 = perl.la
+@BUILD_PLUGIN_DPDKSTAT_TRUE@am__append_63 = dpdkstat.la
+@BUILD_PLUGIN_DRBD_TRUE@am__append_64 = drbd.la
+@BUILD_PLUGIN_EMAIL_TRUE@am__append_65 = email.la
+@BUILD_PLUGIN_ENTROPY_TRUE@am__append_66 = entropy.la
+@BUILD_PLUGIN_EXEC_TRUE@am__append_67 = exec.la
+@BUILD_PLUGIN_ETHSTAT_TRUE@am__append_68 = ethstat.la
+@BUILD_PLUGIN_FHCOUNT_TRUE@am__append_69 = fhcount.la
+@BUILD_PLUGIN_FILECOUNT_TRUE@am__append_70 = filecount.la
+@BUILD_PLUGIN_GMOND_TRUE@am__append_71 = gmond.la
+@BUILD_PLUGIN_GPS_TRUE@am__append_72 = gps.la
+@BUILD_PLUGIN_GRPC_TRUE@am__append_73 = grpc.la
+@BUILD_PLUGIN_HDDTEMP_TRUE@am__append_74 = hddtemp.la
+@BUILD_PLUGIN_HDDTEMP_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_75 = -lsocket
+@BUILD_PLUGIN_HUGEPAGES_TRUE@am__append_76 = hugepages.la
+@BUILD_PLUGIN_INTERFACE_TRUE@am__append_77 = interface.la
+@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_78 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
+@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_79 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
+@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@@BUILD_WITH_LIBSTATGRAB_FALSE@am__append_80 = -lkstat
+@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBDEVINFO_TRUE@@BUILD_WITH_LIBSTATGRAB_FALSE@am__append_81 = -ldevinfo
+@BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_82 = -lperfstat
+@BUILD_PLUGIN_IPC_TRUE@am__append_83 = ipc.la
+@BUILD_PLUGIN_IPTABLES_TRUE@am__append_84 = iptables.la
+@BUILD_PLUGIN_IPMI_TRUE@am__append_85 = ipmi.la
+@BUILD_PLUGIN_IPVS_TRUE@am__append_86 = ipvs.la
+@BUILD_PLUGIN_IPVS_TRUE@@IP_VS_H_NEEDS_KERNEL_CFLAGS_TRUE@am__append_87 = $(KERNEL_CFLAGS)
+@BUILD_PLUGIN_IRQ_TRUE@am__append_88 = irq.la
+@BUILD_PLUGIN_JAVA_TRUE@am__append_89 = java.la
+@BUILD_PLUGIN_LOAD_TRUE@am__append_90 = load.la
+@BUILD_PLUGIN_LOAD_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_91 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
+@BUILD_PLUGIN_LOAD_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_92 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
+@BUILD_PLUGIN_LOAD_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_93 = -lperfstat
+@BUILD_PLUGIN_LOGFILE_TRUE@am__append_94 = logfile.la
+@BUILD_PLUGIN_LOG_LOGSTASH_TRUE@am__append_95 = log_logstash.la
+@BUILD_PLUGIN_LPAR_TRUE@am__append_96 = lpar.la
+@BUILD_PLUGIN_LUA_TRUE@am__append_97 = lua.la
+@BUILD_PLUGIN_LVM_TRUE@am__append_98 = lvm.la
+@BUILD_PLUGIN_MADWIFI_TRUE@am__append_99 = madwifi.la
+@BUILD_PLUGIN_MATCH_EMPTY_COUNTER_TRUE@am__append_100 = match_empty_counter.la
+@BUILD_PLUGIN_MATCH_HASHED_TRUE@am__append_101 = match_hashed.la
+@BUILD_PLUGIN_MATCH_REGEX_TRUE@am__append_102 = match_regex.la
+@BUILD_PLUGIN_MATCH_TIMEDIFF_TRUE@am__append_103 = match_timediff.la
+@BUILD_PLUGIN_MATCH_VALUE_TRUE@am__append_104 = match_value.la
+@BUILD_PLUGIN_MBMON_TRUE@am__append_105 = mbmon.la
+@BUILD_PLUGIN_MBMON_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_106 = -lsocket
+@BUILD_PLUGIN_MD_TRUE@am__append_107 = md.la
+@BUILD_PLUGIN_MEMCACHEC_TRUE@am__append_108 = memcachec.la
+@BUILD_PLUGIN_MEMCACHED_TRUE@am__append_109 = memcached.la
+@BUILD_PLUGIN_MEMCACHED_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_110 = -lsocket
+@BUILD_PLUGIN_MEMORY_TRUE@am__append_111 = memory.la
+@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_112 = -lkstat
+@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_LIBDEVINFO_TRUE@am__append_113 = -ldevinfo
+@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_114 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
+@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_115 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
+@BUILD_PLUGIN_MEMORY_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_116 = -lperfstat
+@BUILD_PLUGIN_MIC_TRUE@am__append_117 = mic.la
+@BUILD_PLUGIN_MODBUS_TRUE@am__append_118 = modbus.la
+@BUILD_PLUGIN_MQTT_TRUE@am__append_119 = mqtt.la
+@BUILD_PLUGIN_MULTIMETER_TRUE@am__append_120 = multimeter.la
+@BUILD_PLUGIN_MYSQL_TRUE@am__append_121 = mysql.la
+@BUILD_PLUGIN_NETAPP_TRUE@am__append_122 = netapp.la
+@BUILD_PLUGIN_NETLINK_TRUE@am__append_123 = netlink.la
+@BUILD_PLUGIN_NETWORK_TRUE@am__append_124 = network.la
+@BUILD_PLUGIN_NETWORK_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_125 = -lsocket
+@BUILD_PLUGIN_NETWORK_TRUE@@BUILD_WITH_LIBGCRYPT_TRUE@am__append_126 = $(GCRYPT_CPPFLAGS)
+@BUILD_PLUGIN_NETWORK_TRUE@@BUILD_WITH_LIBGCRYPT_TRUE@am__append_127 = $(GCRYPT_LDFLAGS)
+@BUILD_PLUGIN_NETWORK_TRUE@@BUILD_WITH_LIBGCRYPT_TRUE@am__append_128 = $(GCRYPT_LIBS)
+@BUILD_PLUGIN_NFS_TRUE@am__append_129 = nfs.la
+@BUILD_PLUGIN_FSCACHE_TRUE@am__append_130 = fscache.la
+@BUILD_PLUGIN_NGINX_TRUE@am__append_131 = nginx.la
+@BUILD_PLUGIN_NOTIFY_DESKTOP_TRUE@am__append_132 = notify_desktop.la
+@BUILD_PLUGIN_NOTIFY_EMAIL_TRUE@am__append_133 = notify_email.la
+@BUILD_PLUGIN_NOTIFY_NAGIOS_TRUE@am__append_134 = notify_nagios.la
+@BUILD_PLUGIN_NTPD_TRUE@am__append_135 = ntpd.la
+@BUILD_PLUGIN_NTPD_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_136 = -lsocket
+@BUILD_PLUGIN_NUMA_TRUE@am__append_137 = numa.la
+@BUILD_PLUGIN_NUT_TRUE@am__append_138 = nut.la
+@BUILD_PLUGIN_OLSRD_TRUE@am__append_139 = olsrd.la
+@BUILD_PLUGIN_OLSRD_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_140 = -lsocket
+@BUILD_PLUGIN_ONEWIRE_TRUE@am__append_141 = onewire.la
+@BUILD_PLUGIN_OPENLDAP_TRUE@am__append_142 = openldap.la
+@BUILD_PLUGIN_OPENVPN_TRUE@am__append_143 = openvpn.la
+@BUILD_PLUGIN_ORACLE_TRUE@am__append_144 = oracle.la
+@BUILD_PLUGIN_PERL_TRUE@am__append_145 = perl.la
 # Work-around for issues #41 and #42 - Perl 5.10 incorrectly introduced
 # __attribute__nonnull__(3) for Perl_load_module().
-@BUILD_PLUGIN_PERL_TRUE@@HAVE_BROKEN_PERL_LOAD_MODULE_TRUE@am__append_144 = -Wno-nonnull
-@BUILD_PLUGIN_PF_TRUE@am__append_145 = pf.la
-@BUILD_PLUGIN_PINBA_TRUE@am__append_146 = pinba.la
-@BUILD_PLUGIN_PING_TRUE@am__append_147 = ping.la
-@BUILD_PLUGIN_POSTGRESQL_TRUE@am__append_148 = postgresql.la
-@BUILD_PLUGIN_POWERDNS_TRUE@am__append_149 = powerdns.la
-@BUILD_PLUGIN_PYTHON_TRUE@am__append_150 = python.la
-@BUILD_PLUGIN_PYTHON_TRUE@@COMPILER_IS_GCC_TRUE@am__append_151 = -fno-strict-aliasing -Wno-strict-aliasing
-@BUILD_PLUGIN_PROCESSES_TRUE@am__append_152 = processes.la
-@BUILD_PLUGIN_PROCESSES_TRUE@@BUILD_WITH_LIBKVM_GETPROCS_TRUE@am__append_153 = -lkvm
-@BUILD_PLUGIN_PROTOCOLS_TRUE@am__append_154 = protocols.la
-@BUILD_PLUGIN_REDIS_TRUE@am__append_155 = redis.la
-@BUILD_PLUGIN_ROUTEROS_TRUE@am__append_156 = routeros.la
-@BUILD_PLUGIN_RRDCACHED_TRUE@am__append_157 = rrdcached.la
-@BUILD_PLUGIN_RRDTOOL_TRUE@am__append_158 = rrdtool.la
-@BUILD_PLUGIN_SENSORS_TRUE@am__append_159 = sensors.la
-@BUILD_PLUGIN_SERIAL_TRUE@am__append_160 = serial.la
-@BUILD_PLUGIN_SIGROK_TRUE@am__append_161 = sigrok.la
-@BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@am__append_162 = smart.la
-@BUILD_PLUGIN_SNMP_TRUE@am__append_163 = snmp.la
-@BUILD_PLUGIN_STATSD_TRUE@am__append_164 = statsd.la
-@BUILD_PLUGIN_SWAP_TRUE@am__append_165 = swap.la
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_166 = -lkstat
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBDEVINFO_TRUE@am__append_167 = -ldevinfo
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBKVM_GETSWAPINFO_TRUE@am__append_168 = -lkvm
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_169 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_170 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
-@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_171 = -lperfstat
-@BUILD_PLUGIN_SYSLOG_TRUE@am__append_172 = syslog.la
-@BUILD_PLUGIN_TABLE_TRUE@am__append_173 = table.la
-@BUILD_PLUGIN_TAIL_TRUE@am__append_174 = tail.la
-@BUILD_PLUGIN_TAIL_CSV_TRUE@am__append_175 = tail_csv.la
-@BUILD_PLUGIN_TAPE_TRUE@am__append_176 = tape.la
-@BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@am__append_177 = target_notification.la
-@BUILD_PLUGIN_TARGET_REPLACE_TRUE@am__append_178 = target_replace.la
-@BUILD_PLUGIN_TARGET_SCALE_TRUE@am__append_179 = target_scale.la
-@BUILD_PLUGIN_TARGET_SET_TRUE@am__append_180 = target_set.la
-@BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@am__append_181 = target_v5upgrade.la
-@BUILD_PLUGIN_TCPCONNS_TRUE@am__append_182 = tcpconns.la
-@BUILD_PLUGIN_TCPCONNS_TRUE@@BUILD_WITH_LIBKVM_NLIST_TRUE@am__append_183 = -lkvm
-@BUILD_PLUGIN_TEAMSPEAK2_TRUE@am__append_184 = teamspeak2.la
-@BUILD_PLUGIN_TED_TRUE@am__append_185 = ted.la
-@BUILD_PLUGIN_THERMAL_TRUE@am__append_186 = thermal.la
-@BUILD_PLUGIN_THRESHOLD_TRUE@am__append_187 = threshold.la
-@BUILD_PLUGIN_TOKYOTYRANT_TRUE@am__append_188 = tokyotyrant.la
-@BUILD_PLUGIN_TOKYOTYRANT_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_189 = -lsocket
-@BUILD_PLUGIN_TURBOSTAT_TRUE@am__append_190 = turbostat.la
-@BUILD_PLUGIN_UNIXSOCK_TRUE@am__append_191 = unixsock.la
-@BUILD_PLUGIN_UPTIME_TRUE@am__append_192 = uptime.la
-@BUILD_PLUGIN_UPTIME_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_193 = -lkstat
-@BUILD_PLUGIN_UPTIME_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_194 = -lperfstat
-@BUILD_PLUGIN_USERS_TRUE@am__append_195 = users.la
-@BUILD_PLUGIN_USERS_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_196 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
-@BUILD_PLUGIN_USERS_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_197 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
-@BUILD_PLUGIN_UUID_TRUE@am__append_198 = uuid.la
-@BUILD_PLUGIN_VARNISH_TRUE@am__append_199 = varnish.la
-@BUILD_PLUGIN_VIRT_TRUE@am__append_200 = virt.la
-@BUILD_PLUGIN_VMEM_TRUE@am__append_201 = vmem.la
-@BUILD_PLUGIN_VSERVER_TRUE@am__append_202 = vserver.la
-@BUILD_PLUGIN_WIRELESS_TRUE@am__append_203 = wireless.la
-@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am__append_204 = write_graphite.la
-@BUILD_PLUGIN_WRITE_HTTP_TRUE@am__append_205 = write_http.la
-@BUILD_PLUGIN_WRITE_KAFKA_TRUE@am__append_206 = write_kafka.la
-@BUILD_PLUGIN_WRITE_LOG_TRUE@am__append_207 = write_log.la
-@BUILD_PLUGIN_WRITE_MONGODB_TRUE@am__append_208 = write_mongodb.la
-@BUILD_PLUGIN_WRITE_REDIS_TRUE@am__append_209 = write_redis.la
-@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am__append_210 = write_riemann.la
-@BUILD_PLUGIN_WRITE_SENSU_TRUE@am__append_211 = write_sensu.la
-@BUILD_PLUGIN_WRITE_TSDB_TRUE@am__append_212 = write_tsdb.la
-@BUILD_PLUGIN_XENCPU_TRUE@am__append_213 = xencpu.la
-@BUILD_PLUGIN_XMMS_TRUE@am__append_214 = xmms.la
-@BUILD_PLUGIN_ZFS_ARC_TRUE@am__append_215 = zfs_arc.la
-@BUILD_PLUGIN_ZOOKEEPER_TRUE@am__append_216 = zookeeper.la
-@BUILD_PLUGIN_ZONE_TRUE@am__append_217 = zone.la
-@BUILD_PLUGIN_PINBA_TRUE@am__append_218 = pinba.pb-c.c pinba.pb-c.h
-@BUILD_PLUGIN_PINBA_TRUE@am__append_219 = pinba.pb-c.c pinba.pb-c.h
-@BUILD_PLUGIN_CEPH_TRUE@am__append_220 = test_plugin_ceph
-@BUILD_PLUGIN_CEPH_TRUE@am__append_221 = test_plugin_ceph
+@BUILD_PLUGIN_PERL_TRUE@@HAVE_BROKEN_PERL_LOAD_MODULE_TRUE@am__append_146 = -Wno-nonnull
+@BUILD_PLUGIN_PF_TRUE@am__append_147 = pf.la
+@BUILD_PLUGIN_PINBA_TRUE@am__append_148 = pinba.la
+@BUILD_PLUGIN_PING_TRUE@am__append_149 = ping.la
+@BUILD_PLUGIN_POSTGRESQL_TRUE@am__append_150 = postgresql.la
+@BUILD_PLUGIN_POWERDNS_TRUE@am__append_151 = powerdns.la
+@BUILD_PLUGIN_PYTHON_TRUE@am__append_152 = python.la
+@BUILD_PLUGIN_PYTHON_TRUE@@COMPILER_IS_GCC_TRUE@am__append_153 = -fno-strict-aliasing -Wno-strict-aliasing
+@BUILD_PLUGIN_PROCESSES_TRUE@am__append_154 = processes.la
+@BUILD_PLUGIN_PROCESSES_TRUE@@BUILD_WITH_LIBKVM_GETPROCS_TRUE@am__append_155 = -lkvm
+@BUILD_PLUGIN_PROTOCOLS_TRUE@am__append_156 = protocols.la
+@BUILD_PLUGIN_INTEL_RDT_TRUE@am__append_157 = intel_rdt.la
+@BUILD_PLUGIN_REDIS_TRUE@am__append_158 = redis.la
+@BUILD_PLUGIN_ROUTEROS_TRUE@am__append_159 = routeros.la
+@BUILD_PLUGIN_RRDCACHED_TRUE@am__append_160 = rrdcached.la
+@BUILD_PLUGIN_RRDTOOL_TRUE@am__append_161 = rrdtool.la
+@BUILD_PLUGIN_SENSORS_TRUE@am__append_162 = sensors.la
+@BUILD_PLUGIN_SERIAL_TRUE@am__append_163 = serial.la
+@BUILD_PLUGIN_SIGROK_TRUE@am__append_164 = sigrok.la
+@BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@am__append_165 = smart.la
+@BUILD_PLUGIN_SNMP_TRUE@am__append_166 = snmp.la
+@BUILD_PLUGIN_STATSD_TRUE@am__append_167 = statsd.la
+@BUILD_PLUGIN_SWAP_TRUE@am__append_168 = swap.la
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_169 = -lkstat
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBDEVINFO_TRUE@am__append_170 = -ldevinfo
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBKVM_GETSWAPINFO_TRUE@am__append_171 = -lkvm
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_172 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_173 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
+@BUILD_PLUGIN_SWAP_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_174 = -lperfstat
+@BUILD_PLUGIN_SYSLOG_TRUE@am__append_175 = syslog.la
+@BUILD_PLUGIN_TABLE_TRUE@am__append_176 = table.la
+@BUILD_PLUGIN_TAIL_TRUE@am__append_177 = tail.la
+@BUILD_PLUGIN_TAIL_CSV_TRUE@am__append_178 = tail_csv.la
+@BUILD_PLUGIN_TAPE_TRUE@am__append_179 = tape.la
+@BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@am__append_180 = target_notification.la
+@BUILD_PLUGIN_TARGET_REPLACE_TRUE@am__append_181 = target_replace.la
+@BUILD_PLUGIN_TARGET_SCALE_TRUE@am__append_182 = target_scale.la
+@BUILD_PLUGIN_TARGET_SET_TRUE@am__append_183 = target_set.la
+@BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@am__append_184 = target_v5upgrade.la
+@BUILD_PLUGIN_TCPCONNS_TRUE@am__append_185 = tcpconns.la
+@BUILD_PLUGIN_TCPCONNS_TRUE@@BUILD_WITH_LIBKVM_NLIST_TRUE@am__append_186 = -lkvm
+@BUILD_PLUGIN_TEAMSPEAK2_TRUE@am__append_187 = teamspeak2.la
+@BUILD_PLUGIN_TED_TRUE@am__append_188 = ted.la
+@BUILD_PLUGIN_THERMAL_TRUE@am__append_189 = thermal.la
+@BUILD_PLUGIN_THRESHOLD_TRUE@am__append_190 = threshold.la
+@BUILD_PLUGIN_TOKYOTYRANT_TRUE@am__append_191 = tokyotyrant.la
+@BUILD_PLUGIN_TOKYOTYRANT_TRUE@@BUILD_WITH_LIBSOCKET_TRUE@am__append_192 = -lsocket
+@BUILD_PLUGIN_TURBOSTAT_TRUE@am__append_193 = turbostat.la
+@BUILD_PLUGIN_UNIXSOCK_TRUE@am__append_194 = unixsock.la
+@BUILD_PLUGIN_UPTIME_TRUE@am__append_195 = uptime.la
+@BUILD_PLUGIN_UPTIME_TRUE@@BUILD_WITH_LIBKSTAT_TRUE@am__append_196 = -lkstat
+@BUILD_PLUGIN_UPTIME_TRUE@@BUILD_WITH_PERFSTAT_TRUE@am__append_197 = -lperfstat
+@BUILD_PLUGIN_USERS_TRUE@am__append_198 = users.la
+@BUILD_PLUGIN_USERS_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_199 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
+@BUILD_PLUGIN_USERS_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_200 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
+@BUILD_PLUGIN_UUID_TRUE@am__append_201 = uuid.la
+@BUILD_PLUGIN_VARNISH_TRUE@am__append_202 = varnish.la
+@BUILD_PLUGIN_VIRT_TRUE@am__append_203 = virt.la
+@BUILD_PLUGIN_VMEM_TRUE@am__append_204 = vmem.la
+@BUILD_PLUGIN_VSERVER_TRUE@am__append_205 = vserver.la
+@BUILD_PLUGIN_WIRELESS_TRUE@am__append_206 = wireless.la
+@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am__append_207 = write_graphite.la
+@BUILD_PLUGIN_WRITE_HTTP_TRUE@am__append_208 = write_http.la
+@BUILD_PLUGIN_WRITE_KAFKA_TRUE@am__append_209 = write_kafka.la
+@BUILD_PLUGIN_WRITE_LOG_TRUE@am__append_210 = write_log.la
+@BUILD_PLUGIN_WRITE_MONGODB_TRUE@am__append_211 = write_mongodb.la
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@am__append_212 = write_prometheus.la
+@BUILD_PLUGIN_WRITE_REDIS_TRUE@am__append_213 = write_redis.la
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am__append_214 = write_riemann.la
+@BUILD_PLUGIN_WRITE_SENSU_TRUE@am__append_215 = write_sensu.la
+@BUILD_PLUGIN_WRITE_TSDB_TRUE@am__append_216 = write_tsdb.la
+@BUILD_PLUGIN_XENCPU_TRUE@am__append_217 = xencpu.la
+@BUILD_PLUGIN_XMMS_TRUE@am__append_218 = xmms.la
+@BUILD_PLUGIN_ZFS_ARC_TRUE@am__append_219 = zfs_arc.la
+@BUILD_PLUGIN_ZOOKEEPER_TRUE@am__append_220 = zookeeper.la
+@BUILD_PLUGIN_ZONE_TRUE@am__append_221 = zone.la
+@BUILD_PLUGIN_PINBA_TRUE@am__append_222 = pinba.pb-c.c pinba.pb-c.h
+@BUILD_PLUGIN_PINBA_TRUE@am__append_223 = pinba.pb-c.c pinba.pb-c.h
+
+# Protocol buffer for the "write_prometheus" plugin.
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@am__append_224 = prometheus.pb-c.c prometheus.pb-c.h
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@am__append_225 = prometheus.pb-c.c prometheus.pb-c.h
+@BUILD_PLUGIN_CEPH_TRUE@am__append_226 = test_plugin_ceph
+@BUILD_PLUGIN_CEPH_TRUE@am__append_227 = test_plugin_ceph
 subdir = src
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(srcdir)/config.h.in $(srcdir)/collectd.conf.in \
 	$(top_srcdir)/libltdl/config/depcomp $(dist_man_MANS) \
 	$(top_srcdir)/libltdl/config/test-driver
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/libltdl/m4/argz.m4 \
-	$(top_srcdir)/libltdl/m4/libtool.m4 \
-	$(top_srcdir)/libltdl/m4/ltdl.m4 \
-	$(top_srcdir)/libltdl/m4/ltoptions.m4 \
-	$(top_srcdir)/libltdl/m4/ltsugar.m4 \
-	$(top_srcdir)/libltdl/m4/ltversion.m4 \
-	$(top_srcdir)/libltdl/m4/lt~obsolete.m4 \
-	$(top_srcdir)/configure.ac
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = config.h
 CONFIG_CLEAN_FILES = collectd.conf
 CONFIG_CLEAN_VPATH_FILES =
@@ -380,20 +383,16 @@
 	$(AM_CFLAGS) $(CFLAGS) $(aggregation_la_LDFLAGS) $(LDFLAGS) -o \
 	$@
 @BUILD_PLUGIN_AGGREGATION_TRUE@am_aggregation_la_rpath = -rpath \
 @BUILD_PLUGIN_AGGREGATION_TRUE@	$(pkglibdir)
 am__DEPENDENCIES_1 =
 @BUILD_PLUGIN_AMQP_TRUE@amqp_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
+@BUILD_PLUGIN_AMQP_TRUE@	libcmds.la libformat_graphite.la \
 @BUILD_PLUGIN_AMQP_TRUE@	libformat_json.la
-am__amqp_la_SOURCES_DIST = amqp.c utils_cmd_putval.c \
-	utils_cmd_putval.h utils_parse_option.c utils_parse_option.h \
-	utils_format_graphite.c utils_format_graphite.h
-@BUILD_PLUGIN_AMQP_TRUE@am_amqp_la_OBJECTS = amqp_la-amqp.lo \
-@BUILD_PLUGIN_AMQP_TRUE@	amqp_la-utils_cmd_putval.lo \
-@BUILD_PLUGIN_AMQP_TRUE@	amqp_la-utils_parse_option.lo \
-@BUILD_PLUGIN_AMQP_TRUE@	amqp_la-utils_format_graphite.lo
+am__amqp_la_SOURCES_DIST = amqp.c
+@BUILD_PLUGIN_AMQP_TRUE@am_amqp_la_OBJECTS = amqp_la-amqp.lo
 amqp_la_OBJECTS = $(am_amqp_la_OBJECTS)
 amqp_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(amqp_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_AMQP_TRUE@am_amqp_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_APACHE_TRUE@apache_la_DEPENDENCIES =  \
@@ -451,14 +450,15 @@
 barometer_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(barometer_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_BAROMETER_TRUE@am_barometer_la_rpath = -rpath \
 @BUILD_PLUGIN_BAROMETER_TRUE@	$(pkglibdir)
 battery_la_LIBADD =
-am__battery_la_SOURCES_DIST = battery.c
-@BUILD_PLUGIN_BATTERY_TRUE@am_battery_la_OBJECTS = battery.lo
+am__battery_la_SOURCES_DIST = battery.c battery_statefs.c
+@BUILD_PLUGIN_BATTERY_TRUE@am_battery_la_OBJECTS = battery.lo \
+@BUILD_PLUGIN_BATTERY_TRUE@	battery_statefs.lo
 battery_la_OBJECTS = $(am_battery_la_OBJECTS)
 battery_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(battery_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_BATTERY_TRUE@am_battery_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_BIND_TRUE@bind_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
@@ -483,13 +483,13 @@
 @BUILD_PLUGIN_CGROUPS_TRUE@am_cgroups_la_OBJECTS = cgroups.lo
 cgroups_la_OBJECTS = $(am_cgroups_la_OBJECTS)
 cgroups_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(cgroups_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_CGROUPS_TRUE@am_cgroups_la_rpath = -rpath $(pkglibdir)
-chrony_la_DEPENDENCIES =
+chrony_la_LIBADD =
 am__chrony_la_SOURCES_DIST = chrony.c
 @BUILD_PLUGIN_CHRONY_TRUE@am_chrony_la_OBJECTS = chrony.lo
 chrony_la_OBJECTS = $(am_chrony_la_OBJECTS)
 chrony_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(chrony_la_LDFLAGS) $(LDFLAGS) -o $@
@@ -548,17 +548,19 @@
 @BUILD_PLUGIN_CSV_TRUE@am_csv_la_OBJECTS = csv.lo
 csv_la_OBJECTS = $(am_csv_la_OBJECTS)
 csv_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(csv_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_CSV_TRUE@am_csv_la_rpath = -rpath $(pkglibdir)
-@BUILD_PLUGIN_CURL_TRUE@curl_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
+@BUILD_PLUGIN_CURL_TRUE@curl_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
+@BUILD_PLUGIN_CURL_TRUE@	liblatency.la
 am__curl_la_SOURCES_DIST = curl.c utils_curl_stats.c \
-	utils_curl_stats.h
+	utils_curl_stats.h utils_match.c utils_match.h
 @BUILD_PLUGIN_CURL_TRUE@am_curl_la_OBJECTS = curl_la-curl.lo \
-@BUILD_PLUGIN_CURL_TRUE@	curl_la-utils_curl_stats.lo
+@BUILD_PLUGIN_CURL_TRUE@	curl_la-utils_curl_stats.lo \
+@BUILD_PLUGIN_CURL_TRUE@	curl_la-utils_match.lo
 curl_la_OBJECTS = $(am_curl_la_OBJECTS)
 curl_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(curl_la_CFLAGS) \
 	$(CFLAGS) $(curl_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_CURL_TRUE@am_curl_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_CURL_JSON_TRUE@curl_json_la_DEPENDENCIES =  \
@@ -625,12 +627,21 @@
 @BUILD_PLUGIN_DNS_TRUE@am_dns_la_OBJECTS = dns.lo utils_dns.lo
 dns_la_OBJECTS = $(am_dns_la_OBJECTS)
 dns_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(dns_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_DNS_TRUE@am_dns_la_rpath = -rpath $(pkglibdir)
+dpdkstat_la_DEPENDENCIES =
+am__dpdkstat_la_SOURCES_DIST = dpdkstat.c
+@BUILD_PLUGIN_DPDKSTAT_TRUE@am_dpdkstat_la_OBJECTS =  \
+@BUILD_PLUGIN_DPDKSTAT_TRUE@	dpdkstat_la-dpdkstat.lo
+dpdkstat_la_OBJECTS = $(am_dpdkstat_la_OBJECTS)
+dpdkstat_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(dpdkstat_la_LDFLAGS) $(LDFLAGS) -o $@
+@BUILD_PLUGIN_DPDKSTAT_TRUE@am_dpdkstat_la_rpath = -rpath $(pkglibdir)
 drbd_la_LIBADD =
 am__drbd_la_SOURCES_DIST = drbd.c
 @BUILD_PLUGIN_DRBD_TRUE@am_drbd_la_OBJECTS = drbd.lo
 drbd_la_OBJECTS = $(am_drbd_la_OBJECTS)
 drbd_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
@@ -658,19 +669,14 @@
 ethstat_la_OBJECTS = $(am_ethstat_la_OBJECTS)
 ethstat_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(ethstat_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_ETHSTAT_TRUE@am_ethstat_la_rpath = -rpath $(pkglibdir)
 exec_la_LIBADD =
-am__exec_la_SOURCES_DIST = exec.c utils_cmd_putnotif.c \
-	utils_cmd_putnotif.h utils_cmd_putval.c utils_cmd_putval.h \
-	utils_parse_option.h utils_parse_option.c
-@BUILD_PLUGIN_EXEC_TRUE@am_exec_la_OBJECTS = exec.lo \
-@BUILD_PLUGIN_EXEC_TRUE@	utils_cmd_putnotif.lo \
-@BUILD_PLUGIN_EXEC_TRUE@	utils_cmd_putval.lo \
-@BUILD_PLUGIN_EXEC_TRUE@	utils_parse_option.lo
+am__exec_la_SOURCES_DIST = exec.c
+@BUILD_PLUGIN_EXEC_TRUE@am_exec_la_OBJECTS = exec.lo
 exec_la_OBJECTS = $(am_exec_la_OBJECTS)
 exec_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(exec_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_EXEC_TRUE@am_exec_la_rpath = -rpath $(pkglibdir)
 fhcount_la_LIBADD =
@@ -734,12 +740,32 @@
 @BUILD_PLUGIN_HDDTEMP_TRUE@am_hddtemp_la_OBJECTS = hddtemp.lo
 hddtemp_la_OBJECTS = $(am_hddtemp_la_OBJECTS)
 hddtemp_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(hddtemp_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_HDDTEMP_TRUE@am_hddtemp_la_rpath = -rpath $(pkglibdir)
+hugepages_la_LIBADD =
+am__hugepages_la_SOURCES_DIST = hugepages.c
+@BUILD_PLUGIN_HUGEPAGES_TRUE@am_hugepages_la_OBJECTS = hugepages.lo
+hugepages_la_OBJECTS = $(am_hugepages_la_OBJECTS)
+hugepages_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(hugepages_la_LDFLAGS) $(LDFLAGS) -o $@
+@BUILD_PLUGIN_HUGEPAGES_TRUE@am_hugepages_la_rpath = -rpath \
+@BUILD_PLUGIN_HUGEPAGES_TRUE@	$(pkglibdir)
+@BUILD_PLUGIN_INTEL_RDT_TRUE@intel_rdt_la_DEPENDENCIES =  \
+@BUILD_PLUGIN_INTEL_RDT_TRUE@	$(am__DEPENDENCIES_1)
+am__intel_rdt_la_SOURCES_DIST = intel_rdt.c
+@BUILD_PLUGIN_INTEL_RDT_TRUE@am_intel_rdt_la_OBJECTS =  \
+@BUILD_PLUGIN_INTEL_RDT_TRUE@	intel_rdt_la-intel_rdt.lo
+intel_rdt_la_OBJECTS = $(am_intel_rdt_la_OBJECTS)
+intel_rdt_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(intel_rdt_la_CFLAGS) \
+	$(CFLAGS) $(intel_rdt_la_LDFLAGS) $(LDFLAGS) -o $@
+@BUILD_PLUGIN_INTEL_RDT_TRUE@am_intel_rdt_la_rpath = -rpath \
+@BUILD_PLUGIN_INTEL_RDT_TRUE@	$(pkglibdir)
 @BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__DEPENDENCIES_5 = $(am__DEPENDENCIES_1)
 @BUILD_PLUGIN_INTERFACE_TRUE@interface_la_DEPENDENCIES =  \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__DEPENDENCIES_5) \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__DEPENDENCIES_1) \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__DEPENDENCIES_1) \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__DEPENDENCIES_1)
@@ -799,22 +825,36 @@
 @BUILD_PLUGIN_JAVA_TRUE@am_java_la_OBJECTS = java_la-java.lo
 java_la_OBJECTS = $(am_java_la_OBJECTS)
 java_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(java_la_CFLAGS) \
 	$(CFLAGS) $(java_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_JAVA_TRUE@am_java_la_rpath = -rpath $(pkglibdir)
+libcmds_la_DEPENDENCIES = daemon/libcommon.la daemon/libmetadata.la
+am_libcmds_la_OBJECTS = utils_cmds.lo utils_cmd_flush.lo \
+	utils_cmd_getthreshold.lo utils_cmd_getval.lo \
+	utils_cmd_listval.lo utils_cmd_putnotif.lo utils_cmd_putval.lo \
+	utils_parse_option.lo
+libcmds_la_OBJECTS = $(am_libcmds_la_OBJECTS)
+libformat_graphite_la_LIBADD =
+am_libformat_graphite_la_OBJECTS =  \
+	libformat_graphite_la-utils_format_graphite.lo
+libformat_graphite_la_OBJECTS = $(am_libformat_graphite_la_OBJECTS)
+libformat_graphite_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libformat_graphite_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
 @BUILD_WITH_LIBYAJL_TRUE@am__DEPENDENCIES_6 = $(am__DEPENDENCIES_1)
 libformat_json_la_DEPENDENCIES = $(am__DEPENDENCIES_6)
 am_libformat_json_la_OBJECTS = libformat_json_la-utils_format_json.lo
 libformat_json_la_OBJECTS = $(am_libformat_json_la_OBJECTS)
 libformat_json_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(AM_CFLAGS) $(CFLAGS) $(libformat_json_la_LDFLAGS) $(LDFLAGS) \
 	-o $@
-liblatency_la_LIBADD =
-am_liblatency_la_OBJECTS = utils_latency.lo
+liblatency_la_DEPENDENCIES = daemon/libcommon.la
+am_liblatency_la_OBJECTS = utils_latency.lo utils_latency_config.lo
 liblatency_la_OBJECTS = $(am_liblatency_la_OBJECTS)
 liblookup_la_DEPENDENCIES = daemon/libavltree.la
 am_liblookup_la_OBJECTS = utils_vl_lookup.lo
 liblookup_la_OBJECTS = $(am_liblookup_la_OBJECTS)
 libmount_la_LIBADD =
 am_libmount_la_OBJECTS = utils_mount.lo
@@ -951,16 +991,19 @@
 md_la_OBJECTS = $(am_md_la_OBJECTS)
 md_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(md_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_MD_TRUE@am_md_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_DEPENDENCIES =  \
-@BUILD_PLUGIN_MEMCACHEC_TRUE@	$(am__DEPENDENCIES_1)
-am__memcachec_la_SOURCES_DIST = memcachec.c
+@BUILD_PLUGIN_MEMCACHEC_TRUE@	$(am__DEPENDENCIES_1) \
+@BUILD_PLUGIN_MEMCACHEC_TRUE@	liblatency.la
+am__memcachec_la_SOURCES_DIST = memcachec.c utils_match.c \
+	utils_match.h
 @BUILD_PLUGIN_MEMCACHEC_TRUE@am_memcachec_la_OBJECTS =  \
-@BUILD_PLUGIN_MEMCACHEC_TRUE@	memcachec_la-memcachec.lo
+@BUILD_PLUGIN_MEMCACHEC_TRUE@	memcachec_la-memcachec.lo \
+@BUILD_PLUGIN_MEMCACHEC_TRUE@	memcachec_la-utils_match.lo
 memcachec_la_OBJECTS = $(am_memcachec_la_OBJECTS)
 memcachec_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(memcachec_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_MEMCACHEC_TRUE@am_memcachec_la_rpath = -rpath \
 @BUILD_PLUGIN_MEMCACHEC_TRUE@	$(pkglibdir)
@@ -1390,23 +1433,27 @@
 @BUILD_PLUGIN_TABLE_TRUE@am_table_la_OBJECTS = table.lo
 table_la_OBJECTS = $(am_table_la_OBJECTS)
 table_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(table_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_TABLE_TRUE@am_table_la_rpath = -rpath $(pkglibdir)
-tail_la_LIBADD =
-am__tail_la_SOURCES_DIST = tail.c
-@BUILD_PLUGIN_TAIL_TRUE@am_tail_la_OBJECTS = tail.lo
+@BUILD_PLUGIN_TAIL_TRUE@tail_la_DEPENDENCIES = liblatency.la
+am__tail_la_SOURCES_DIST = tail.c utils_match.c utils_match.h \
+	utils_tail.c utils_tail.h utils_tail_match.c \
+	utils_tail_match.h
+@BUILD_PLUGIN_TAIL_TRUE@am_tail_la_OBJECTS = tail.lo utils_match.lo \
+@BUILD_PLUGIN_TAIL_TRUE@	utils_tail.lo utils_tail_match.lo
 tail_la_OBJECTS = $(am_tail_la_OBJECTS)
 tail_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(tail_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_TAIL_TRUE@am_tail_la_rpath = -rpath $(pkglibdir)
 tail_csv_la_LIBADD =
-am__tail_csv_la_SOURCES_DIST = tail_csv.c
-@BUILD_PLUGIN_TAIL_CSV_TRUE@am_tail_csv_la_OBJECTS = tail_csv.lo
+am__tail_csv_la_SOURCES_DIST = tail_csv.c utils_tail.c utils_tail.h
+@BUILD_PLUGIN_TAIL_CSV_TRUE@am_tail_csv_la_OBJECTS = tail_csv.lo \
+@BUILD_PLUGIN_TAIL_CSV_TRUE@	utils_tail.lo
 tail_csv_la_OBJECTS = $(am_tail_csv_la_OBJECTS)
 tail_csv_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(tail_csv_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_TAIL_CSV_TRUE@am_tail_csv_la_rpath = -rpath $(pkglibdir)
 tape_la_DEPENDENCIES =
@@ -1535,26 +1582,14 @@
 turbostat_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(turbostat_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_TURBOSTAT_TRUE@am_turbostat_la_rpath = -rpath \
 @BUILD_PLUGIN_TURBOSTAT_TRUE@	$(pkglibdir)
 unixsock_la_LIBADD =
-am__unixsock_la_SOURCES_DIST = unixsock.c utils_cmd_flush.h \
-	utils_cmd_flush.c utils_cmd_getval.h utils_cmd_getval.c \
-	utils_cmd_getthreshold.h utils_cmd_getthreshold.c \
-	utils_cmd_listval.h utils_cmd_listval.c utils_cmd_putval.h \
-	utils_cmd_putval.c utils_cmd_putnotif.h utils_cmd_putnotif.c \
-	utils_parse_option.h utils_parse_option.c
-@BUILD_PLUGIN_UNIXSOCK_TRUE@am_unixsock_la_OBJECTS = unixsock.lo \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@	utils_cmd_flush.lo \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@	utils_cmd_getval.lo \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@	utils_cmd_getthreshold.lo \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@	utils_cmd_listval.lo \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@	utils_cmd_putval.lo \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@	utils_cmd_putnotif.lo \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@	utils_parse_option.lo
+am__unixsock_la_SOURCES_DIST = unixsock.c
+@BUILD_PLUGIN_UNIXSOCK_TRUE@am_unixsock_la_OBJECTS = unixsock.lo
 unixsock_la_OBJECTS = $(am_unixsock_la_OBJECTS)
 unixsock_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(unixsock_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_UNIXSOCK_TRUE@am_unixsock_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_UPTIME_TRUE@uptime_la_DEPENDENCIES =  \
@@ -1625,18 +1660,17 @@
 @BUILD_PLUGIN_WIRELESS_TRUE@am_wireless_la_OBJECTS = wireless.lo
 wireless_la_OBJECTS = $(am_wireless_la_OBJECTS)
 wireless_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(wireless_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_WIRELESS_TRUE@am_wireless_la_rpath = -rpath $(pkglibdir)
-write_graphite_la_LIBADD =
-am__write_graphite_la_SOURCES_DIST = write_graphite.c \
-	utils_format_graphite.c utils_format_graphite.h
+@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@write_graphite_la_DEPENDENCIES =  \
+@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@	libformat_graphite.la
+am__write_graphite_la_SOURCES_DIST = write_graphite.c
 @BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am_write_graphite_la_OBJECTS =  \
-@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@	write_graphite.lo \
-@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@	utils_format_graphite.lo
+@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@	write_graphite.lo
 write_graphite_la_OBJECTS = $(am_write_graphite_la_OBJECTS)
 write_graphite_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(AM_CFLAGS) $(CFLAGS) $(write_graphite_la_LDFLAGS) $(LDFLAGS) \
 	-o $@
 @BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@am_write_graphite_la_rpath = -rpath \
@@ -1654,34 +1688,32 @@
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(write_http_la_CFLAGS) \
 	$(CFLAGS) $(write_http_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@am_write_http_la_rpath = -rpath \
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@	$(pkglibdir)
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@write_kafka_la_DEPENDENCIES =  \
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@	$(am__DEPENDENCIES_1) \
+@BUILD_PLUGIN_WRITE_KAFKA_TRUE@	libcmds.la \
+@BUILD_PLUGIN_WRITE_KAFKA_TRUE@	libformat_graphite.la \
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@	libformat_json.la
-am__write_kafka_la_SOURCES_DIST = write_kafka.c \
-	utils_format_graphite.c utils_format_graphite.h \
-	utils_cmd_putval.c utils_cmd_putval.h utils_crc32.c \
+am__write_kafka_la_SOURCES_DIST = write_kafka.c utils_crc32.c \
 	utils_crc32.h
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@am_write_kafka_la_OBJECTS =  \
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@	write_kafka_la-write_kafka.lo \
-@BUILD_PLUGIN_WRITE_KAFKA_TRUE@	write_kafka_la-utils_format_graphite.lo \
-@BUILD_PLUGIN_WRITE_KAFKA_TRUE@	write_kafka_la-utils_cmd_putval.lo \
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@	write_kafka_la-utils_crc32.lo
 write_kafka_la_OBJECTS = $(am_write_kafka_la_OBJECTS)
 write_kafka_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(AM_CFLAGS) $(CFLAGS) $(write_kafka_la_LDFLAGS) $(LDFLAGS) -o \
 	$@
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@am_write_kafka_la_rpath = -rpath \
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@	$(pkglibdir)
-write_log_la_LIBADD =
-am__write_log_la_SOURCES_DIST = write_log.c utils_format_graphite.c \
-	utils_format_graphite.h
-@BUILD_PLUGIN_WRITE_LOG_TRUE@am_write_log_la_OBJECTS = write_log.lo \
-@BUILD_PLUGIN_WRITE_LOG_TRUE@	utils_format_graphite.lo
+@BUILD_PLUGIN_WRITE_LOG_TRUE@write_log_la_DEPENDENCIES =  \
+@BUILD_PLUGIN_WRITE_LOG_TRUE@	libformat_graphite.la \
+@BUILD_PLUGIN_WRITE_LOG_TRUE@	libformat_json.la
+am__write_log_la_SOURCES_DIST = write_log.c
+@BUILD_PLUGIN_WRITE_LOG_TRUE@am_write_log_la_OBJECTS = write_log.lo
 write_log_la_OBJECTS = $(am_write_log_la_OBJECTS)
 write_log_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(write_log_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_WRITE_LOG_TRUE@am_write_log_la_rpath = -rpath \
 @BUILD_PLUGIN_WRITE_LOG_TRUE@	$(pkglibdir)
@@ -1692,12 +1724,26 @@
 write_mongodb_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(AM_CFLAGS) $(CFLAGS) $(write_mongodb_la_LDFLAGS) $(LDFLAGS) \
 	-o $@
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@am_write_mongodb_la_rpath = -rpath \
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@	$(pkglibdir)
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@write_prometheus_la_DEPENDENCIES =  \
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@	$(am__DEPENDENCIES_1) \
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@	$(am__DEPENDENCIES_1)
+am__write_prometheus_la_SOURCES_DIST = write_prometheus.c
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@am_write_prometheus_la_OBJECTS = write_prometheus_la-write_prometheus.lo
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@nodist_write_prometheus_la_OBJECTS = write_prometheus_la-prometheus.pb-c.lo
+write_prometheus_la_OBJECTS = $(am_write_prometheus_la_OBJECTS) \
+	$(nodist_write_prometheus_la_OBJECTS)
+write_prometheus_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(write_prometheus_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@am_write_prometheus_la_rpath =  \
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@	-rpath $(pkglibdir)
 write_redis_la_DEPENDENCIES =
 am__write_redis_la_SOURCES_DIST = write_redis.c
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@am_write_redis_la_OBJECTS =  \
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@	write_redis_la-write_redis.lo
 write_redis_la_OBJECTS = $(am_write_redis_la_OBJECTS)
 write_redis_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
@@ -1797,12 +1843,17 @@
 collectdctl_OBJECTS = $(am_collectdctl_OBJECTS)
 collectdctl_DEPENDENCIES = libcollectdclient/libcollectdclient.la \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
 am_collectdmon_OBJECTS = collectdmon.$(OBJEXT)
 collectdmon_OBJECTS = $(am_collectdmon_OBJECTS)
 collectdmon_LDADD = $(LDADD)
+am_test_format_graphite_OBJECTS =  \
+	utils_format_graphite_test.$(OBJEXT)
+test_format_graphite_OBJECTS = $(am_test_format_graphite_OBJECTS)
+test_format_graphite_DEPENDENCIES = libformat_graphite.la \
+	daemon/libmetadata.la daemon/libplugin_mock.la
 am__test_format_json_SOURCES_DIST = utils_format_json_test.c testing.h
 @BUILD_WITH_LIBYAJL_TRUE@am_test_format_json_OBJECTS =  \
 @BUILD_WITH_LIBYAJL_TRUE@	utils_format_json_test.$(OBJEXT)
 test_format_json_OBJECTS = $(am_test_format_json_OBJECTS)
 @BUILD_WITH_LIBYAJL_TRUE@test_format_json_DEPENDENCIES =  \
 @BUILD_WITH_LIBYAJL_TRUE@	libformat_json.la \
@@ -1816,12 +1867,15 @@
 @BUILD_PLUGIN_CEPH_TRUE@	daemon/libplugin_mock.la \
 @BUILD_PLUGIN_CEPH_TRUE@	$(am__DEPENDENCIES_1)
 test_plugin_ceph_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(AM_CFLAGS) $(CFLAGS) $(test_plugin_ceph_LDFLAGS) $(LDFLAGS) \
 	-o $@
+am_test_utils_cmds_OBJECTS = utils_cmds_test.$(OBJEXT)
+test_utils_cmds_OBJECTS = $(am_test_utils_cmds_OBJECTS)
+test_utils_cmds_DEPENDENCIES = libcmds.la daemon/libplugin_mock.la
 am_test_utils_latency_OBJECTS = utils_latency_test.$(OBJEXT)
 test_utils_latency_OBJECTS = $(am_test_utils_latency_OBJECTS)
 test_utils_latency_DEPENDENCIES = liblatency.la \
 	daemon/libplugin_mock.la
 am_test_utils_mount_OBJECTS = utils_mount_test.$(OBJEXT)
 test_utils_mount_OBJECTS = $(am_test_utils_mount_OBJECTS)
@@ -1890,21 +1944,23 @@
 	$(battery_la_SOURCES) $(bind_la_SOURCES) $(ceph_la_SOURCES) \
 	$(cgroups_la_SOURCES) $(chrony_la_SOURCES) \
 	$(conntrack_la_SOURCES) $(contextswitch_la_SOURCES) \
 	$(cpu_la_SOURCES) $(cpufreq_la_SOURCES) $(cpusleep_la_SOURCES) \
 	$(csv_la_SOURCES) $(curl_la_SOURCES) $(curl_json_la_SOURCES) \
 	$(curl_xml_la_SOURCES) $(dbi_la_SOURCES) $(df_la_SOURCES) \
-	$(disk_la_SOURCES) $(dns_la_SOURCES) $(drbd_la_SOURCES) \
-	$(email_la_SOURCES) $(entropy_la_SOURCES) \
+	$(disk_la_SOURCES) $(dns_la_SOURCES) $(dpdkstat_la_SOURCES) \
+	$(drbd_la_SOURCES) $(email_la_SOURCES) $(entropy_la_SOURCES) \
 	$(ethstat_la_SOURCES) $(exec_la_SOURCES) $(fhcount_la_SOURCES) \
 	$(filecount_la_SOURCES) $(fscache_la_SOURCES) \
 	$(gmond_la_SOURCES) $(gps_la_SOURCES) $(grpc_la_SOURCES) \
 	$(nodist_grpc_la_SOURCES) $(hddtemp_la_SOURCES) \
+	$(hugepages_la_SOURCES) $(intel_rdt_la_SOURCES) \
 	$(interface_la_SOURCES) $(ipc_la_SOURCES) $(ipmi_la_SOURCES) \
 	$(iptables_la_SOURCES) $(ipvs_la_SOURCES) $(irq_la_SOURCES) \
-	$(java_la_SOURCES) $(libformat_json_la_SOURCES) \
+	$(java_la_SOURCES) $(libcmds_la_SOURCES) \
+	$(libformat_graphite_la_SOURCES) $(libformat_json_la_SOURCES) \
 	$(liblatency_la_SOURCES) $(liblookup_la_SOURCES) \
 	$(libmount_la_SOURCES) $(load_la_SOURCES) \
 	$(log_logstash_la_SOURCES) $(logfile_la_SOURCES) \
 	$(lpar_la_SOURCES) $(lua_la_SOURCES) $(lvm_la_SOURCES) \
 	$(madwifi_la_SOURCES) $(match_empty_counter_la_SOURCES) \
 	$(match_hashed_la_SOURCES) $(match_regex_la_SOURCES) \
@@ -1940,19 +1996,22 @@
 	$(unixsock_la_SOURCES) $(uptime_la_SOURCES) \
 	$(users_la_SOURCES) $(uuid_la_SOURCES) $(varnish_la_SOURCES) \
 	$(virt_la_SOURCES) $(vmem_la_SOURCES) $(vserver_la_SOURCES) \
 	$(wireless_la_SOURCES) $(write_graphite_la_SOURCES) \
 	$(write_http_la_SOURCES) $(write_kafka_la_SOURCES) \
 	$(write_log_la_SOURCES) $(write_mongodb_la_SOURCES) \
+	$(write_prometheus_la_SOURCES) \
+	$(nodist_write_prometheus_la_SOURCES) \
 	$(write_redis_la_SOURCES) $(write_riemann_la_SOURCES) \
 	$(write_sensu_la_SOURCES) $(write_tsdb_la_SOURCES) \
 	$(xencpu_la_SOURCES) $(xmms_la_SOURCES) $(zfs_arc_la_SOURCES) \
 	$(zone_la_SOURCES) $(zookeeper_la_SOURCES) \
 	$(collectd_nagios_SOURCES) $(collectd_tg_SOURCES) \
 	$(collectdctl_SOURCES) $(collectdmon_SOURCES) \
-	$(test_format_json_SOURCES) $(test_plugin_ceph_SOURCES) \
+	$(test_format_graphite_SOURCES) $(test_format_json_SOURCES) \
+	$(test_plugin_ceph_SOURCES) $(test_utils_cmds_SOURCES) \
 	$(test_utils_latency_SOURCES) $(test_utils_mount_SOURCES) \
 	$(test_utils_vl_lookup_SOURCES)
 DIST_SOURCES = $(am__aggregation_la_SOURCES_DIST) \
 	$(am__amqp_la_SOURCES_DIST) $(am__apache_la_SOURCES_DIST) \
 	$(am__apcups_la_SOURCES_DIST) \
 	$(am__apple_sensors_la_SOURCES_DIST) \
@@ -1964,24 +2023,27 @@
 	$(am__contextswitch_la_SOURCES_DIST) \
 	$(am__cpu_la_SOURCES_DIST) $(am__cpufreq_la_SOURCES_DIST) \
 	$(am__cpusleep_la_SOURCES_DIST) $(am__csv_la_SOURCES_DIST) \
 	$(am__curl_la_SOURCES_DIST) $(am__curl_json_la_SOURCES_DIST) \
 	$(am__curl_xml_la_SOURCES_DIST) $(am__dbi_la_SOURCES_DIST) \
 	$(am__df_la_SOURCES_DIST) $(am__disk_la_SOURCES_DIST) \
-	$(am__dns_la_SOURCES_DIST) $(am__drbd_la_SOURCES_DIST) \
-	$(am__email_la_SOURCES_DIST) $(am__entropy_la_SOURCES_DIST) \
-	$(am__ethstat_la_SOURCES_DIST) $(am__exec_la_SOURCES_DIST) \
-	$(am__fhcount_la_SOURCES_DIST) \
+	$(am__dns_la_SOURCES_DIST) $(am__dpdkstat_la_SOURCES_DIST) \
+	$(am__drbd_la_SOURCES_DIST) $(am__email_la_SOURCES_DIST) \
+	$(am__entropy_la_SOURCES_DIST) $(am__ethstat_la_SOURCES_DIST) \
+	$(am__exec_la_SOURCES_DIST) $(am__fhcount_la_SOURCES_DIST) \
 	$(am__filecount_la_SOURCES_DIST) \
 	$(am__fscache_la_SOURCES_DIST) $(am__gmond_la_SOURCES_DIST) \
 	$(am__gps_la_SOURCES_DIST) $(am__grpc_la_SOURCES_DIST) \
 	$(am__hddtemp_la_SOURCES_DIST) \
+	$(am__hugepages_la_SOURCES_DIST) \
+	$(am__intel_rdt_la_SOURCES_DIST) \
 	$(am__interface_la_SOURCES_DIST) $(am__ipc_la_SOURCES_DIST) \
 	$(am__ipmi_la_SOURCES_DIST) $(am__iptables_la_SOURCES_DIST) \
 	$(am__ipvs_la_SOURCES_DIST) $(am__irq_la_SOURCES_DIST) \
-	$(am__java_la_SOURCES_DIST) $(libformat_json_la_SOURCES) \
+	$(am__java_la_SOURCES_DIST) $(libcmds_la_SOURCES) \
+	$(libformat_graphite_la_SOURCES) $(libformat_json_la_SOURCES) \
 	$(liblatency_la_SOURCES) $(liblookup_la_SOURCES) \
 	$(libmount_la_SOURCES) $(am__load_la_SOURCES_DIST) \
 	$(am__log_logstash_la_SOURCES_DIST) \
 	$(am__logfile_la_SOURCES_DIST) $(am__lpar_la_SOURCES_DIST) \
 	$(am__lua_la_SOURCES_DIST) $(am__lvm_la_SOURCES_DIST) \
 	$(am__madwifi_la_SOURCES_DIST) \
@@ -2038,24 +2100,26 @@
 	$(am__wireless_la_SOURCES_DIST) \
 	$(am__write_graphite_la_SOURCES_DIST) \
 	$(am__write_http_la_SOURCES_DIST) \
 	$(am__write_kafka_la_SOURCES_DIST) \
 	$(am__write_log_la_SOURCES_DIST) \
 	$(am__write_mongodb_la_SOURCES_DIST) \
+	$(am__write_prometheus_la_SOURCES_DIST) \
 	$(am__write_redis_la_SOURCES_DIST) \
 	$(am__write_riemann_la_SOURCES_DIST) \
 	$(am__write_sensu_la_SOURCES_DIST) \
 	$(am__write_tsdb_la_SOURCES_DIST) \
 	$(am__xencpu_la_SOURCES_DIST) $(am__xmms_la_SOURCES_DIST) \
 	$(am__zfs_arc_la_SOURCES_DIST) $(am__zone_la_SOURCES_DIST) \
 	$(am__zookeeper_la_SOURCES_DIST) $(collectd_nagios_SOURCES) \
 	$(collectd_tg_SOURCES) $(collectdctl_SOURCES) \
-	$(collectdmon_SOURCES) $(am__test_format_json_SOURCES_DIST) \
+	$(collectdmon_SOURCES) $(test_format_graphite_SOURCES) \
+	$(am__test_format_json_SOURCES_DIST) \
 	$(am__test_plugin_ceph_SOURCES_DIST) \
-	$(test_utils_latency_SOURCES) $(test_utils_mount_SOURCES) \
-	$(test_utils_vl_lookup_SOURCES)
+	$(test_utils_cmds_SOURCES) $(test_utils_latency_SOURCES) \
+	$(test_utils_mount_SOURCES) $(test_utils_vl_lookup_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
 	ctags-recursive dvi-recursive html-recursive info-recursive \
 	install-data-recursive install-dvi-recursive \
 	install-exec-recursive install-html-recursive \
 	install-info-recursive install-pdf-recursive \
 	install-ps-recursive install-recursive installcheck-recursive \
@@ -2341,12 +2405,15 @@
 BUILD_WITH_LIBLVM2APP_CPPFLAGS = @BUILD_WITH_LIBLVM2APP_CPPFLAGS@
 BUILD_WITH_LIBLVM2APP_LDFLAGS = @BUILD_WITH_LIBLVM2APP_LDFLAGS@
 BUILD_WITH_LIBLVM2APP_LIBS = @BUILD_WITH_LIBLVM2APP_LIBS@
 BUILD_WITH_LIBMEMCACHED_CPPFLAGS = @BUILD_WITH_LIBMEMCACHED_CPPFLAGS@
 BUILD_WITH_LIBMEMCACHED_LDFLAGS = @BUILD_WITH_LIBMEMCACHED_LDFLAGS@
 BUILD_WITH_LIBMEMCACHED_LIBS = @BUILD_WITH_LIBMEMCACHED_LIBS@
+BUILD_WITH_LIBMICROHTTPD_CPPFLAGS = @BUILD_WITH_LIBMICROHTTPD_CPPFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LDFLAGS = @BUILD_WITH_LIBMICROHTTPD_LDFLAGS@
+BUILD_WITH_LIBMICROHTTPD_LIBS = @BUILD_WITH_LIBMICROHTTPD_LIBS@
 BUILD_WITH_LIBMNL_CFLAGS = @BUILD_WITH_LIBMNL_CFLAGS@
 BUILD_WITH_LIBMNL_LIBS = @BUILD_WITH_LIBMNL_LIBS@
 BUILD_WITH_LIBMODBUS_CFLAGS = @BUILD_WITH_LIBMODBUS_CFLAGS@
 BUILD_WITH_LIBMODBUS_LIBS = @BUILD_WITH_LIBMODBUS_LIBS@
 BUILD_WITH_LIBMONGOC_CPPFLAGS = @BUILD_WITH_LIBMONGOC_CPPFLAGS@
 BUILD_WITH_LIBMONGOC_LDFLAGS = @BUILD_WITH_LIBMONGOC_LDFLAGS@
@@ -2360,12 +2427,15 @@
 BUILD_WITH_LIBNETSNMP_LIBS = @BUILD_WITH_LIBNETSNMP_LIBS@
 BUILD_WITH_LIBOPING_CPPFLAGS = @BUILD_WITH_LIBOPING_CPPFLAGS@
 BUILD_WITH_LIBOPING_LDFLAGS = @BUILD_WITH_LIBOPING_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_CPPFLAGS = @BUILD_WITH_LIBOWCAPI_CPPFLAGS@
 BUILD_WITH_LIBOWCAPI_LDFLAGS = @BUILD_WITH_LIBOWCAPI_LDFLAGS@
 BUILD_WITH_LIBOWCAPI_LIBS = @BUILD_WITH_LIBOWCAPI_LIBS@
+BUILD_WITH_LIBPQOS_CPPFLAGS = @BUILD_WITH_LIBPQOS_CPPFLAGS@
+BUILD_WITH_LIBPQOS_LDFLAGS = @BUILD_WITH_LIBPQOS_LDFLAGS@
+BUILD_WITH_LIBPQOS_LIBS = @BUILD_WITH_LIBPQOS_LIBS@
 BUILD_WITH_LIBPQ_CPPFLAGS = @BUILD_WITH_LIBPQ_CPPFLAGS@
 BUILD_WITH_LIBPQ_LDFLAGS = @BUILD_WITH_LIBPQ_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS = @BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LDFLAGS = @BUILD_WITH_LIBPROTOBUF_C_LDFLAGS@
 BUILD_WITH_LIBPROTOBUF_C_LIBS = @BUILD_WITH_LIBPROTOBUF_C_LIBS@
@@ -2471,12 +2541,14 @@
 LEXLIB = @LEXLIB@
 LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
 LIBADD_DL = @LIBADD_DL@
 LIBADD_DLD_LINK = @LIBADD_DLD_LINK@
 LIBADD_DLOPEN = @LIBADD_DLOPEN@
 LIBADD_SHL_LOAD = @LIBADD_SHL_LOAD@
+LIBDPDK_CPPFLAGS = @LIBDPDK_CPPFLAGS@
+LIBDPDK_LDFLAGS = @LIBDPDK_LDFLAGS@
 LIBLTDL = @LIBLTDL@
 LIBLUA_PKG_CONFIG_NAME = @LIBLUA_PKG_CONFIG_NAME@
 LIBNETAPP_CPPFLAGS = @LIBNETAPP_CPPFLAGS@
 LIBNETAPP_LDFLAGS = @LIBNETAPP_LDFLAGS@
 LIBNETAPP_LIBS = @LIBNETAPP_LIBS@
 LIBNOTIFY_CFLAGS = @LIBNOTIFY_CFLAGS@
@@ -2509,12 +2581,14 @@
 LT_DLLOADERS = @LT_DLLOADERS@
 LT_DLPREOPEN = @LT_DLPREOPEN@
 LUA_CFLAGS = @LUA_CFLAGS@
 LUA_LIBS = @LUA_LIBS@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
+MICROHTTPD_CFLAGS = @MICROHTTPD_CFLAGS@
+MICROHTTPD_LIBS = @MICROHTTPD_LIBS@
 MKDIR_P = @MKDIR_P@
 NM = @NM@
 NMEDIT = @NMEDIT@
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 OTOOL = @OTOOL@
@@ -2621,23 +2695,43 @@
 	$(am__append_2) -DPLUGINDIR='"${pkglibdir}"' \
 	-DPKGDATADIR='"${pkgdatadir}"'
 LOG_COMPILER = env VALGRIND="@VALGRIND@" $(abs_top_srcdir)/testwrapper.sh
 V_PROTOC = $(v_protoc_@AM_V@)
 v_protoc_ = $(v_protoc_@AM_DEFAULT_V@)
 v_protoc_0 = @echo "  PROTOC  " $@;
-noinst_LTLIBRARIES = libformat_json.la liblatency.la liblookup.la \
-	libmount.la
+noinst_LTLIBRARIES = libformat_graphite.la libformat_json.la \
+	liblatency.la libcmds.la liblookup.la libmount.la
+libformat_graphite_la_SOURCES = utils_format_graphite.c utils_format_graphite.h
+libformat_graphite_la_CPPFLAGS = $(AM_CPPFLAGS)
+libformat_graphite_la_LDFLAGS = $(AM_LDFLAGS)
+test_format_graphite_SOURCES = utils_format_graphite_test.c testing.h
+test_format_graphite_LDADD = libformat_graphite.la daemon/libmetadata.la daemon/libplugin_mock.la -lm
 libformat_json_la_SOURCES = utils_format_json.c utils_format_json.h
 libformat_json_la_CPPFLAGS = $(AM_CPPFLAGS) $(am__append_3)
 libformat_json_la_LDFLAGS = $(AM_LDFLAGS) $(am__append_4)
 libformat_json_la_LIBADD = $(am__append_5)
 @BUILD_WITH_LIBYAJL_TRUE@test_format_json_SOURCES = utils_format_json_test.c testing.h
 @BUILD_WITH_LIBYAJL_TRUE@test_format_json_LDADD = libformat_json.la daemon/libmetadata.la daemon/libplugin_mock.la -lm
-liblatency_la_SOURCES = utils_latency.c utils_latency.h
+liblatency_la_SOURCES = utils_latency.c utils_latency.h utils_latency_config.c utils_latency_config.h
+liblatency_la_LIBADD = daemon/libcommon.la -lm
 test_utils_latency_SOURCES = utils_latency_test.c testing.h
 test_utils_latency_LDADD = liblatency.la daemon/libplugin_mock.la -lm
+libcmds_la_SOURCES = utils_cmds.c utils_cmds.h \
+                     utils_cmd_flush.c utils_cmd_flush.h \
+                     utils_cmd_getthreshold.c utils_cmd_getthreshold.h \
+                     utils_cmd_getval.c utils_cmd_getval.h \
+                     utils_cmd_listval.c utils_cmd_listval.h \
+                     utils_cmd_putnotif.c utils_cmd_putnotif.h \
+                     utils_cmd_putval.c utils_cmd_putval.h \
+                     utils_parse_option.c utils_parse_option.h
+
+libcmds_la_LIBADD = daemon/libcommon.la daemon/libmetadata.la -lm
+test_utils_cmds_SOURCES = utils_cmds_test.c testing.h
+test_utils_cmds_LDADD = libcmds.la \
+                        daemon/libplugin_mock.la
+
 liblookup_la_SOURCES = utils_vl_lookup.c utils_vl_lookup.h
 liblookup_la_LIBADD = daemon/libavltree.la
 test_utils_vl_lookup_SOURCES = utils_vl_lookup_test.c testing.h
 test_utils_vl_lookup_LDADD = liblookup.la daemon/libplugin_mock.la \
 	$(am__append_8)
 libmount_la_SOURCES = utils_mount.c utils_mount.h
@@ -2676,63 +2770,64 @@
 	$(am__append_44) $(am__append_45) $(am__append_46) \
 	$(am__append_47) $(am__append_48) $(am__append_49) \
 	$(am__append_50) $(am__append_51) $(am__append_62) \
 	$(am__append_63) $(am__append_64) $(am__append_65) \
 	$(am__append_66) $(am__append_67) $(am__append_68) \
 	$(am__append_69) $(am__append_70) $(am__append_71) \
-	$(am__append_72) $(am__append_73) $(am__append_75) \
-	$(am__append_81) $(am__append_82) $(am__append_83) \
-	$(am__append_84) $(am__append_86) $(am__append_87) \
-	$(am__append_88) $(am__append_92) $(am__append_93) \
+	$(am__append_72) $(am__append_73) $(am__append_74) \
+	$(am__append_76) $(am__append_77) $(am__append_83) \
+	$(am__append_84) $(am__append_85) $(am__append_86) \
+	$(am__append_88) $(am__append_89) $(am__append_90) \
 	$(am__append_94) $(am__append_95) $(am__append_96) \
 	$(am__append_97) $(am__append_98) $(am__append_99) \
 	$(am__append_100) $(am__append_101) $(am__append_102) \
-	$(am__append_103) $(am__append_105) $(am__append_106) \
-	$(am__append_107) $(am__append_109) $(am__append_115) \
-	$(am__append_116) $(am__append_117) $(am__append_118) \
+	$(am__append_103) $(am__append_104) $(am__append_105) \
+	$(am__append_107) $(am__append_108) $(am__append_109) \
+	$(am__append_111) $(am__append_117) $(am__append_118) \
 	$(am__append_119) $(am__append_120) $(am__append_121) \
-	$(am__append_122) $(am__append_127) $(am__append_128) \
+	$(am__append_122) $(am__append_123) $(am__append_124) \
 	$(am__append_129) $(am__append_130) $(am__append_131) \
-	$(am__append_132) $(am__append_133) $(am__append_135) \
-	$(am__append_136) $(am__append_137) $(am__append_139) \
-	$(am__append_140) $(am__append_141) $(am__append_142) \
-	$(am__append_143) $(am__append_145) $(am__append_146) \
+	$(am__append_132) $(am__append_133) $(am__append_134) \
+	$(am__append_135) $(am__append_137) $(am__append_138) \
+	$(am__append_139) $(am__append_141) $(am__append_142) \
+	$(am__append_143) $(am__append_144) $(am__append_145) \
 	$(am__append_147) $(am__append_148) $(am__append_149) \
-	$(am__append_150) $(am__append_152) $(am__append_154) \
-	$(am__append_155) $(am__append_156) $(am__append_157) \
+	$(am__append_150) $(am__append_151) $(am__append_152) \
+	$(am__append_154) $(am__append_156) $(am__append_157) \
 	$(am__append_158) $(am__append_159) $(am__append_160) \
 	$(am__append_161) $(am__append_162) $(am__append_163) \
-	$(am__append_164) $(am__append_165) $(am__append_172) \
-	$(am__append_173) $(am__append_174) $(am__append_175) \
+	$(am__append_164) $(am__append_165) $(am__append_166) \
+	$(am__append_167) $(am__append_168) $(am__append_175) \
 	$(am__append_176) $(am__append_177) $(am__append_178) \
 	$(am__append_179) $(am__append_180) $(am__append_181) \
-	$(am__append_182) $(am__append_184) $(am__append_185) \
-	$(am__append_186) $(am__append_187) $(am__append_188) \
-	$(am__append_190) $(am__append_191) $(am__append_192) \
-	$(am__append_195) $(am__append_198) $(am__append_199) \
-	$(am__append_200) $(am__append_201) $(am__append_202) \
+	$(am__append_182) $(am__append_183) $(am__append_184) \
+	$(am__append_185) $(am__append_187) $(am__append_188) \
+	$(am__append_189) $(am__append_190) $(am__append_191) \
+	$(am__append_193) $(am__append_194) $(am__append_195) \
+	$(am__append_198) $(am__append_201) $(am__append_202) \
 	$(am__append_203) $(am__append_204) $(am__append_205) \
 	$(am__append_206) $(am__append_207) $(am__append_208) \
 	$(am__append_209) $(am__append_210) $(am__append_211) \
 	$(am__append_212) $(am__append_213) $(am__append_214) \
-	$(am__append_215) $(am__append_216) $(am__append_217)
-BUILT_SOURCES = $(am__append_17) $(dist_man_MANS) $(am__append_219)
-CLEANFILES = $(am__append_18) $(am__append_218)
+	$(am__append_215) $(am__append_216) $(am__append_217) \
+	$(am__append_218) $(am__append_219) $(am__append_220) \
+	$(am__append_221)
+BUILT_SOURCES = $(am__append_17) $(dist_man_MANS) $(am__append_223) \
+	$(am__append_225)
+CLEANFILES = $(am__append_18) $(am__append_222) $(am__append_224)
 @BUILD_PLUGIN_AGGREGATION_TRUE@aggregation_la_SOURCES = aggregation.c \
 @BUILD_PLUGIN_AGGREGATION_TRUE@                         utils_vl_lookup.c utils_vl_lookup.h
 
 @BUILD_PLUGIN_AGGREGATION_TRUE@aggregation_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_AGGREGATION_TRUE@aggregation_la_LIBADD = -lm
-@BUILD_PLUGIN_AMQP_TRUE@amqp_la_SOURCES = amqp.c \
-@BUILD_PLUGIN_AMQP_TRUE@		  utils_cmd_putval.c utils_cmd_putval.h \
-@BUILD_PLUGIN_AMQP_TRUE@	          utils_parse_option.c utils_parse_option.h \
-@BUILD_PLUGIN_AMQP_TRUE@		  utils_format_graphite.c utils_format_graphite.h
-
+@BUILD_PLUGIN_AMQP_TRUE@amqp_la_SOURCES = amqp.c
 @BUILD_PLUGIN_AMQP_TRUE@amqp_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBRABBITMQ_LDFLAGS)
 @BUILD_PLUGIN_AMQP_TRUE@amqp_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBRABBITMQ_CPPFLAGS)
-@BUILD_PLUGIN_AMQP_TRUE@amqp_la_LIBADD = $(BUILD_WITH_LIBRABBITMQ_LIBS) libformat_json.la
+@BUILD_PLUGIN_AMQP_TRUE@amqp_la_LIBADD = $(BUILD_WITH_LIBRABBITMQ_LIBS) \
+@BUILD_PLUGIN_AMQP_TRUE@                 libcmds.la libformat_graphite.la libformat_json.la
+
 @BUILD_PLUGIN_APACHE_TRUE@apache_la_SOURCES = apache.c
 @BUILD_PLUGIN_APACHE_TRUE@apache_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_APACHE_TRUE@apache_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBCURL_CFLAGS)
 @BUILD_PLUGIN_APACHE_TRUE@apache_la_LIBADD = $(BUILD_WITH_LIBCURL_LIBS)
 @BUILD_PLUGIN_APCUPS_TRUE@apcups_la_SOURCES = apcups.c
 @BUILD_PLUGIN_APCUPS_TRUE@apcups_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -2749,13 +2844,13 @@
 @BUILD_PLUGIN_ASCENT_TRUE@		$(BUILD_WITH_LIBCURL_CFLAGS) $(BUILD_WITH_LIBXML2_CFLAGS)
 
 @BUILD_PLUGIN_ASCENT_TRUE@ascent_la_LIBADD = $(BUILD_WITH_LIBCURL_LIBS) $(BUILD_WITH_LIBXML2_LIBS)
 @BUILD_PLUGIN_BAROMETER_TRUE@barometer_la_SOURCES = barometer.c
 @BUILD_PLUGIN_BAROMETER_TRUE@barometer_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_BAROMETER_TRUE@barometer_la_LIBADD = -lm
-@BUILD_PLUGIN_BATTERY_TRUE@battery_la_SOURCES = battery.c
+@BUILD_PLUGIN_BATTERY_TRUE@battery_la_SOURCES = battery.c battery_statefs.c
 @BUILD_PLUGIN_BATTERY_TRUE@battery_la_LDFLAGS = $(PLUGIN_LDFLAGS) \
 @BUILD_PLUGIN_BATTERY_TRUE@	$(am__append_29)
 @BUILD_PLUGIN_BIND_TRUE@bind_la_SOURCES = bind.c
 @BUILD_PLUGIN_BIND_TRUE@bind_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_BIND_TRUE@bind_la_CFLAGS = $(AM_CFLAGS) \
 @BUILD_PLUGIN_BIND_TRUE@		 $(BUILD_WITH_LIBCURL_CFLAGS) $(BUILD_WITH_LIBXML2_CFLAGS)
@@ -2768,13 +2863,12 @@
 @BUILD_PLUGIN_CEPH_TRUE@ceph_la_LIBADD = $(BUILD_WITH_LIBYAJL_LIBS)
 @BUILD_PLUGIN_CGROUPS_TRUE@cgroups_la_SOURCES = cgroups.c
 @BUILD_PLUGIN_CGROUPS_TRUE@cgroups_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_CGROUPS_TRUE@cgroups_la_LIBADD = libmount.la
 @BUILD_PLUGIN_CHRONY_TRUE@chrony_la_SOURCES = chrony.c
 @BUILD_PLUGIN_CHRONY_TRUE@chrony_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_CHRONY_TRUE@chrony_la_LIBADD = -lm
 @BUILD_PLUGIN_CONNTRACK_TRUE@conntrack_la_SOURCES = conntrack.c
 @BUILD_PLUGIN_CONNTRACK_TRUE@conntrack_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_CONTEXTSWITCH_TRUE@contextswitch_la_SOURCES = contextswitch.c
 @BUILD_PLUGIN_CONTEXTSWITCH_TRUE@contextswitch_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_CONTEXTSWITCH_TRUE@contextswitch_la_LIBADD =  \
 @BUILD_PLUGIN_CONTEXTSWITCH_TRUE@	$(am__append_36)
@@ -2788,17 +2882,18 @@
 @BUILD_PLUGIN_CPUFREQ_TRUE@cpufreq_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_CPUSLEEP_TRUE@cpusleep_la_SOURCES = cpusleep.c
 @BUILD_PLUGIN_CPUSLEEP_TRUE@cpusleep_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_CSV_TRUE@csv_la_SOURCES = csv.c
 @BUILD_PLUGIN_CSV_TRUE@csv_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_CURL_TRUE@curl_la_SOURCES = curl.c \
-@BUILD_PLUGIN_CURL_TRUE@		  utils_curl_stats.c utils_curl_stats.h
+@BUILD_PLUGIN_CURL_TRUE@                  utils_curl_stats.c utils_curl_stats.h \
+@BUILD_PLUGIN_CURL_TRUE@                  utils_match.c utils_match.h
 
 @BUILD_PLUGIN_CURL_TRUE@curl_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_CURL_TRUE@curl_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBCURL_CFLAGS)
-@BUILD_PLUGIN_CURL_TRUE@curl_la_LIBADD = $(BUILD_WITH_LIBCURL_LIBS)
+@BUILD_PLUGIN_CURL_TRUE@curl_la_LIBADD = $(BUILD_WITH_LIBCURL_LIBS) liblatency.la
 @BUILD_PLUGIN_CURL_JSON_TRUE@curl_json_la_SOURCES = curl_json.c \
 @BUILD_PLUGIN_CURL_JSON_TRUE@		  utils_curl_stats.c utils_curl_stats.h
 
 @BUILD_PLUGIN_CURL_JSON_TRUE@curl_json_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBCURL_CFLAGS)
 @BUILD_PLUGIN_CURL_JSON_TRUE@curl_json_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBYAJL_CPPFLAGS)
 @BUILD_PLUGIN_CURL_JSON_TRUE@curl_json_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBYAJL_LDFLAGS)
@@ -2829,24 +2924,24 @@
 @BUILD_PLUGIN_DISK_TRUE@	$(am__append_53) $(am__append_56) \
 @BUILD_PLUGIN_DISK_TRUE@	$(am__append_59) $(am__append_60) \
 @BUILD_PLUGIN_DISK_TRUE@	$(am__append_61)
 @BUILD_PLUGIN_DNS_TRUE@dns_la_SOURCES = dns.c utils_dns.c utils_dns.h
 @BUILD_PLUGIN_DNS_TRUE@dns_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_DNS_TRUE@dns_la_LIBADD = -lpcap
+@BUILD_PLUGIN_DPDKSTAT_TRUE@dpdkstat_la_SOURCES = dpdkstat.c
+@BUILD_PLUGIN_DPDKSTAT_TRUE@dpdkstat_la_CPPFLAGS = $(AM_CPPFLAGS) $(LIBDPDK_CPPFLAGS)
+@BUILD_PLUGIN_DPDKSTAT_TRUE@dpdkstat_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(LIBDPDK_LDFLAGS)
+@BUILD_PLUGIN_DPDKSTAT_TRUE@dpdkstat_la_LIBADD = -ldpdk
 @BUILD_PLUGIN_DRBD_TRUE@drbd_la_SOURCES = drbd.c
 @BUILD_PLUGIN_DRBD_TRUE@drbd_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_EMAIL_TRUE@email_la_SOURCES = email.c
 @BUILD_PLUGIN_EMAIL_TRUE@email_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_ENTROPY_TRUE@entropy_la_SOURCES = entropy.c
 @BUILD_PLUGIN_ENTROPY_TRUE@entropy_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_EXEC_TRUE@exec_la_SOURCES = exec.c \
-@BUILD_PLUGIN_EXEC_TRUE@		  utils_cmd_putnotif.c utils_cmd_putnotif.h \
-@BUILD_PLUGIN_EXEC_TRUE@		  utils_cmd_putval.c utils_cmd_putval.h \
-@BUILD_PLUGIN_EXEC_TRUE@		  utils_parse_option.h utils_parse_option.c
-
-@BUILD_PLUGIN_EXEC_TRUE@exec_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+@BUILD_PLUGIN_EXEC_TRUE@exec_la_SOURCES = exec.c
+@BUILD_PLUGIN_EXEC_TRUE@exec_la_LDFLAGS = $(PLUGIN_LDFLAGS) libcmds.la
 @BUILD_PLUGIN_ETHSTAT_TRUE@ethstat_la_SOURCES = ethstat.c
 @BUILD_PLUGIN_ETHSTAT_TRUE@ethstat_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_FHCOUNT_TRUE@fhcount_la_SOURCES = fhcount.c
 @BUILD_PLUGIN_FHCOUNT_TRUE@fhcount_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_FILECOUNT_TRUE@filecount_la_SOURCES = filecount.c
 @BUILD_PLUGIN_FILECOUNT_TRUE@filecount_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -2862,45 +2957,47 @@
 @BUILD_PLUGIN_GRPC_TRUE@nodist_grpc_la_SOURCES = collectd.grpc.pb.cc collectd.pb.cc types.pb.cc
 @BUILD_PLUGIN_GRPC_TRUE@grpc_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBGRPCPP_CPPFLAGS) $(BUILD_WITH_LIBPROTOBUF_CPPFLAGS)
 @BUILD_PLUGIN_GRPC_TRUE@grpc_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBGRPCPP_LDFLAGS) $(BUILD_WITH_LIBPROTOBUF_LDFLAGS)
 @BUILD_PLUGIN_GRPC_TRUE@grpc_la_LIBADD = $(BUILD_WITH_LIBGRPCPP_LIBS) $(BUILD_WITH_LIBPROTOBUF_LIBS)
 @BUILD_PLUGIN_HDDTEMP_TRUE@hddtemp_la_SOURCES = hddtemp.c
 @BUILD_PLUGIN_HDDTEMP_TRUE@hddtemp_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_HDDTEMP_TRUE@hddtemp_la_LIBADD = $(am__append_74)
+@BUILD_PLUGIN_HDDTEMP_TRUE@hddtemp_la_LIBADD = $(am__append_75)
+@BUILD_PLUGIN_HUGEPAGES_TRUE@hugepages_la_SOURCES = hugepages.c
+@BUILD_PLUGIN_HUGEPAGES_TRUE@hugepages_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_INTERFACE_TRUE@interface_la_SOURCES = interface.c
 @BUILD_PLUGIN_INTERFACE_TRUE@interface_la_CFLAGS = $(AM_CFLAGS) \
-@BUILD_PLUGIN_INTERFACE_TRUE@	$(am__append_76)
+@BUILD_PLUGIN_INTERFACE_TRUE@	$(am__append_78)
 @BUILD_PLUGIN_INTERFACE_TRUE@interface_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_INTERFACE_TRUE@interface_la_LIBADD = $(am__append_77) \
-@BUILD_PLUGIN_INTERFACE_TRUE@	$(am__append_78) $(am__append_79) \
-@BUILD_PLUGIN_INTERFACE_TRUE@	$(am__append_80)
+@BUILD_PLUGIN_INTERFACE_TRUE@interface_la_LIBADD = $(am__append_79) \
+@BUILD_PLUGIN_INTERFACE_TRUE@	$(am__append_80) $(am__append_81) \
+@BUILD_PLUGIN_INTERFACE_TRUE@	$(am__append_82)
 @BUILD_PLUGIN_IPC_TRUE@ipc_la_SOURCES = ipc.c
 @BUILD_PLUGIN_IPC_TRUE@ipc_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_IPTABLES_TRUE@iptables_la_SOURCES = iptables.c
 @BUILD_PLUGIN_IPTABLES_TRUE@iptables_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBIPTC_CPPFLAGS)
 @BUILD_PLUGIN_IPTABLES_TRUE@iptables_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_IPTABLES_TRUE@iptables_la_LIBADD = $(BUILD_WITH_LIBIPTC_LDFLAGS)
 @BUILD_PLUGIN_IPMI_TRUE@ipmi_la_SOURCES = ipmi.c
 @BUILD_PLUGIN_IPMI_TRUE@ipmi_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_OPENIPMI_CFLAGS)
 @BUILD_PLUGIN_IPMI_TRUE@ipmi_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_IPMI_TRUE@ipmi_la_LIBADD = $(BUILD_WITH_OPENIPMI_LIBS)
 @BUILD_PLUGIN_IPVS_TRUE@ipvs_la_SOURCES = ipvs.c
-@BUILD_PLUGIN_IPVS_TRUE@ipvs_la_CFLAGS = $(AM_CFLAGS) $(am__append_85)
+@BUILD_PLUGIN_IPVS_TRUE@ipvs_la_CFLAGS = $(AM_CFLAGS) $(am__append_87)
 @BUILD_PLUGIN_IPVS_TRUE@ipvs_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_IRQ_TRUE@irq_la_SOURCES = irq.c
 @BUILD_PLUGIN_IRQ_TRUE@irq_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_JAVA_TRUE@java_la_SOURCES = java.c
 @BUILD_PLUGIN_JAVA_TRUE@java_la_CPPFLAGS = $(AM_CPPFLAGS) $(JAVA_CPPFLAGS)
 @BUILD_PLUGIN_JAVA_TRUE@java_la_CFLAGS = $(AM_CFLAGS) $(JAVA_CFLAGS)
 @BUILD_PLUGIN_JAVA_TRUE@java_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(JAVA_LDFLAGS)
 @BUILD_PLUGIN_JAVA_TRUE@java_la_LIBADD = $(JAVA_LIBS)
 @BUILD_PLUGIN_LOAD_TRUE@load_la_SOURCES = load.c
-@BUILD_PLUGIN_LOAD_TRUE@load_la_CFLAGS = $(AM_CFLAGS) $(am__append_89)
+@BUILD_PLUGIN_LOAD_TRUE@load_la_CFLAGS = $(AM_CFLAGS) $(am__append_91)
 @BUILD_PLUGIN_LOAD_TRUE@load_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_LOAD_TRUE@load_la_LIBADD = $(am__append_90) \
-@BUILD_PLUGIN_LOAD_TRUE@	$(am__append_91)
+@BUILD_PLUGIN_LOAD_TRUE@load_la_LIBADD = $(am__append_92) \
+@BUILD_PLUGIN_LOAD_TRUE@	$(am__append_93)
 @BUILD_PLUGIN_LOGFILE_TRUE@logfile_la_SOURCES = logfile.c
 @BUILD_PLUGIN_LOGFILE_TRUE@logfile_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_LOG_LOGSTASH_TRUE@log_logstash_la_SOURCES = log_logstash.c
 @BUILD_PLUGIN_LOG_LOGSTASH_TRUE@log_logstash_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBYAJL_LDFLAGS)
 @BUILD_PLUGIN_LOG_LOGSTASH_TRUE@log_logstash_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBYAJL_CPPFLAGS)
 @BUILD_PLUGIN_LOG_LOGSTASH_TRUE@log_logstash_la_LIBADD = $(BUILD_WITH_LIBYAJL_LIBS)
@@ -2928,29 +3025,31 @@
 @BUILD_PLUGIN_MATCH_TIMEDIFF_TRUE@match_timediff_la_SOURCES = match_timediff.c
 @BUILD_PLUGIN_MATCH_TIMEDIFF_TRUE@match_timediff_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MATCH_VALUE_TRUE@match_value_la_SOURCES = match_value.c
 @BUILD_PLUGIN_MATCH_VALUE_TRUE@match_value_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MBMON_TRUE@mbmon_la_SOURCES = mbmon.c
 @BUILD_PLUGIN_MBMON_TRUE@mbmon_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_MBMON_TRUE@mbmon_la_LIBADD = $(am__append_104)
+@BUILD_PLUGIN_MBMON_TRUE@mbmon_la_LIBADD = $(am__append_106)
 @BUILD_PLUGIN_MD_TRUE@md_la_SOURCES = md.c
 @BUILD_PLUGIN_MD_TRUE@md_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_SOURCES = memcachec.c
+@BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_SOURCES = memcachec.c \
+@BUILD_PLUGIN_MEMCACHEC_TRUE@                       utils_match.c utils_match.h
+
 @BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBMEMCACHED_LDFLAGS)
 @BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBMEMCACHED_CPPFLAGS)
-@BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_LIBADD = $(BUILD_WITH_LIBMEMCACHED_LIBS)
+@BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_LIBADD = $(BUILD_WITH_LIBMEMCACHED_LIBS) liblatency.la
 @BUILD_PLUGIN_MEMCACHED_TRUE@memcached_la_SOURCES = memcached.c
 @BUILD_PLUGIN_MEMCACHED_TRUE@memcached_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_MEMCACHED_TRUE@memcached_la_LIBADD = $(am__append_108)
+@BUILD_PLUGIN_MEMCACHED_TRUE@memcached_la_LIBADD = $(am__append_110)
 @BUILD_PLUGIN_MEMORY_TRUE@memory_la_SOURCES = memory.c
 @BUILD_PLUGIN_MEMORY_TRUE@memory_la_CFLAGS = $(AM_CFLAGS) \
-@BUILD_PLUGIN_MEMORY_TRUE@	$(am__append_112)
-@BUILD_PLUGIN_MEMORY_TRUE@memory_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_MEMORY_TRUE@memory_la_LIBADD = $(am__append_110) \
-@BUILD_PLUGIN_MEMORY_TRUE@	$(am__append_111) $(am__append_113) \
 @BUILD_PLUGIN_MEMORY_TRUE@	$(am__append_114)
+@BUILD_PLUGIN_MEMORY_TRUE@memory_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+@BUILD_PLUGIN_MEMORY_TRUE@memory_la_LIBADD = $(am__append_112) \
+@BUILD_PLUGIN_MEMORY_TRUE@	$(am__append_113) $(am__append_115) \
+@BUILD_PLUGIN_MEMORY_TRUE@	$(am__append_116)
 @BUILD_PLUGIN_MIC_TRUE@mic_la_SOURCES = mic.c
 @BUILD_PLUGIN_MIC_TRUE@mic_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_MIC_LIBPATH)
 @BUILD_PLUGIN_MIC_TRUE@mic_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_MIC_CPPFLAGS)
 @BUILD_PLUGIN_MIC_TRUE@mic_la_LIBADD = $(BUILD_WITH_MIC_LDADD)
 @BUILD_PLUGIN_MODBUS_TRUE@modbus_la_SOURCES = modbus.c
 @BUILD_PLUGIN_MODBUS_TRUE@modbus_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -2975,17 +3074,17 @@
 @BUILD_PLUGIN_NETLINK_TRUE@netlink_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBMNL_CFLAGS)
 @BUILD_PLUGIN_NETLINK_TRUE@netlink_la_LIBADD = $(BUILD_WITH_LIBMNL_LIBS)
 @BUILD_PLUGIN_NETWORK_TRUE@network_la_SOURCES = network.c network.h \
 @BUILD_PLUGIN_NETWORK_TRUE@		     utils_fbhash.c utils_fbhash.h
 
 @BUILD_PLUGIN_NETWORK_TRUE@network_la_CPPFLAGS = $(AM_CPPFLAGS) \
-@BUILD_PLUGIN_NETWORK_TRUE@	$(am__append_124)
-@BUILD_PLUGIN_NETWORK_TRUE@network_la_LDFLAGS = $(PLUGIN_LDFLAGS) \
-@BUILD_PLUGIN_NETWORK_TRUE@	$(am__append_125)
-@BUILD_PLUGIN_NETWORK_TRUE@network_la_LIBADD = $(am__append_123) \
 @BUILD_PLUGIN_NETWORK_TRUE@	$(am__append_126)
+@BUILD_PLUGIN_NETWORK_TRUE@network_la_LDFLAGS = $(PLUGIN_LDFLAGS) \
+@BUILD_PLUGIN_NETWORK_TRUE@	$(am__append_127)
+@BUILD_PLUGIN_NETWORK_TRUE@network_la_LIBADD = $(am__append_125) \
+@BUILD_PLUGIN_NETWORK_TRUE@	$(am__append_128)
 @BUILD_PLUGIN_NFS_TRUE@nfs_la_SOURCES = nfs.c
 @BUILD_PLUGIN_NFS_TRUE@nfs_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_FSCACHE_TRUE@fscache_la_SOURCES = fscache.c
 @BUILD_PLUGIN_FSCACHE_TRUE@fscache_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_NGINX_TRUE@nginx_la_SOURCES = nginx.c
 @BUILD_PLUGIN_NGINX_TRUE@nginx_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBCURL_CFLAGS)
@@ -2994,27 +3093,27 @@
 @BUILD_PLUGIN_NOTIFY_DESKTOP_TRUE@notify_desktop_la_SOURCES = notify_desktop.c
 @BUILD_PLUGIN_NOTIFY_DESKTOP_TRUE@notify_desktop_la_CFLAGS = $(AM_CFLAGS) $(LIBNOTIFY_CFLAGS)
 @BUILD_PLUGIN_NOTIFY_DESKTOP_TRUE@notify_desktop_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_NOTIFY_DESKTOP_TRUE@notify_desktop_la_LIBADD = $(LIBNOTIFY_LIBS)
 @BUILD_PLUGIN_NOTIFY_EMAIL_TRUE@notify_email_la_SOURCES = notify_email.c
 @BUILD_PLUGIN_NOTIFY_EMAIL_TRUE@notify_email_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_NOTIFY_EMAIL_TRUE@notify_email_la_LIBADD = -lesmtp
+@BUILD_PLUGIN_NOTIFY_EMAIL_TRUE@notify_email_la_LIBADD = -lesmtp -lssl -lcrypto
 @BUILD_PLUGIN_NOTIFY_NAGIOS_TRUE@notify_nagios_la_SOURCES = notify_nagios.c
 @BUILD_PLUGIN_NOTIFY_NAGIOS_TRUE@notify_nagios_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_NTPD_TRUE@ntpd_la_SOURCES = ntpd.c
 @BUILD_PLUGIN_NTPD_TRUE@ntpd_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_NTPD_TRUE@ntpd_la_LIBADD = $(am__append_134)
+@BUILD_PLUGIN_NTPD_TRUE@ntpd_la_LIBADD = $(am__append_136)
 @BUILD_PLUGIN_NUMA_TRUE@numa_la_SOURCES = numa.c
 @BUILD_PLUGIN_NUMA_TRUE@numa_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_NUT_TRUE@nut_la_SOURCES = nut.c
 @BUILD_PLUGIN_NUT_TRUE@nut_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBUPSCLIENT_CFLAGS)
 @BUILD_PLUGIN_NUT_TRUE@nut_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_NUT_TRUE@nut_la_LIBADD = $(BUILD_WITH_LIBUPSCLIENT_LIBS)
 @BUILD_PLUGIN_OLSRD_TRUE@olsrd_la_SOURCES = olsrd.c
 @BUILD_PLUGIN_OLSRD_TRUE@olsrd_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_OLSRD_TRUE@olsrd_la_LIBADD = $(am__append_138)
+@BUILD_PLUGIN_OLSRD_TRUE@olsrd_la_LIBADD = $(am__append_140)
 @BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_SOURCES = onewire.c
 @BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBOWCAPI_CPPFLAGS)
 @BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_LIBADD = $(BUILD_WITH_LIBOWCAPI_LIBS)
 @BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBOWCAPI_LDFLAGS)
 @BUILD_PLUGIN_OPENLDAP_TRUE@openldap_la_SOURCES = openldap.c
 @BUILD_PLUGIN_OPENLDAP_TRUE@openldap_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBLDAP_CPPFLAGS)
@@ -3036,13 +3135,13 @@
 # On older platforms we also need _REENTRANT. _GNU_SOURCE sets both of these.
 @BUILD_PLUGIN_PERL_TRUE@perl_la_CPPFLAGS = $(AM_CPPFLAGS) -DHAS_BOOL=1 \
 @BUILD_PLUGIN_PERL_TRUE@	-D_GNU_SOURCE
 @BUILD_PLUGIN_PERL_TRUE@perl_la_CFLAGS = $(AM_CFLAGS) $(PERL_CFLAGS) \
 @BUILD_PLUGIN_PERL_TRUE@	-DXS_VERSION=\"$(VERSION)\" \
 @BUILD_PLUGIN_PERL_TRUE@	-DVERSION=\"$(VERSION)\" \
-@BUILD_PLUGIN_PERL_TRUE@	$(am__append_144)
+@BUILD_PLUGIN_PERL_TRUE@	$(am__append_146)
 @BUILD_PLUGIN_PERL_TRUE@perl_la_LDFLAGS = $(PLUGIN_LDFLAGS) \
 @BUILD_PLUGIN_PERL_TRUE@		$(PERL_LDFLAGS)
 
 @BUILD_PLUGIN_PERL_TRUE@perl_la_LIBADD = $(PERL_LIBS)
 @BUILD_PLUGIN_PF_TRUE@pf_la_SOURCES = pf.c
 @BUILD_PLUGIN_PF_TRUE@pf_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -3065,19 +3164,23 @@
 @BUILD_PLUGIN_POSTGRESQL_TRUE@postgresql_la_LIBADD = -lpq
 @BUILD_PLUGIN_POWERDNS_TRUE@powerdns_la_SOURCES = powerdns.c
 @BUILD_PLUGIN_POWERDNS_TRUE@powerdns_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_SOURCES = python.c pyconfig.c pyvalues.c cpython.h
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_CPPFLAGS = $(AM_CPPFLAGS) \
 @BUILD_PLUGIN_PYTHON_TRUE@	$(LIBPYTHON_CPPFLAGS) \
-@BUILD_PLUGIN_PYTHON_TRUE@	$(am__append_151)
+@BUILD_PLUGIN_PYTHON_TRUE@	$(am__append_153)
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(LIBPYTHON_LDFLAGS)
 @BUILD_PLUGIN_PROCESSES_TRUE@processes_la_SOURCES = processes.c
 @BUILD_PLUGIN_PROCESSES_TRUE@processes_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_PROCESSES_TRUE@processes_la_LIBADD = $(am__append_153)
+@BUILD_PLUGIN_PROCESSES_TRUE@processes_la_LIBADD = $(am__append_155)
 @BUILD_PLUGIN_PROTOCOLS_TRUE@protocols_la_SOURCES = protocols.c
 @BUILD_PLUGIN_PROTOCOLS_TRUE@protocols_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+@BUILD_PLUGIN_INTEL_RDT_TRUE@intel_rdt_la_SOURCES = intel_rdt.c
+@BUILD_PLUGIN_INTEL_RDT_TRUE@intel_rdt_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBPQOS_LDFLAGS)
+@BUILD_PLUGIN_INTEL_RDT_TRUE@intel_rdt_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBPQOS_CPPFLAGS)
+@BUILD_PLUGIN_INTEL_RDT_TRUE@intel_rdt_la_LIBADD = $(BUILD_WITH_LIBPQOS_LIBS)
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_SOURCES = redis.c
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBHIREDIS_LDFLAGS)
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBHIREDIS_CPPFLAGS)
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_LIBADD = -lhiredis
 @BUILD_PLUGIN_ROUTEROS_TRUE@routeros_la_SOURCES = routeros.c
 @BUILD_PLUGIN_ROUTEROS_TRUE@routeros_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBROUTEROS_CPPFLAGS)
@@ -3108,27 +3211,34 @@
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_SOURCES = snmp.c
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBNETSNMP_CPPFLAGS)
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBNETSNMP_LDFLAGS)
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_LIBADD = $(BUILD_WITH_LIBNETSNMP_LIBS)
 @BUILD_PLUGIN_STATSD_TRUE@statsd_la_SOURCES = statsd.c
 @BUILD_PLUGIN_STATSD_TRUE@statsd_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_STATSD_TRUE@statsd_la_LIBADD = liblatency.la -lm
+@BUILD_PLUGIN_STATSD_TRUE@statsd_la_LIBADD = liblatency.la
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_SOURCES = swap.c
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_CFLAGS = $(AM_CFLAGS) \
-@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_169)
+@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_172)
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_SWAP_TRUE@swap_la_LIBADD = $(am__append_166) \
-@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_167) $(am__append_168) \
-@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_170) $(am__append_171)
+@BUILD_PLUGIN_SWAP_TRUE@swap_la_LIBADD = $(am__append_169) \
+@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_170) $(am__append_171) \
+@BUILD_PLUGIN_SWAP_TRUE@	$(am__append_173) $(am__append_174)
 @BUILD_PLUGIN_SYSLOG_TRUE@syslog_la_SOURCES = syslog.c
 @BUILD_PLUGIN_SYSLOG_TRUE@syslog_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TABLE_TRUE@table_la_SOURCES = table.c
 @BUILD_PLUGIN_TABLE_TRUE@table_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_TAIL_TRUE@tail_la_SOURCES = tail.c
+@BUILD_PLUGIN_TAIL_TRUE@tail_la_SOURCES = tail.c \
+@BUILD_PLUGIN_TAIL_TRUE@                  utils_match.c utils_match.h \
+@BUILD_PLUGIN_TAIL_TRUE@                  utils_tail.c utils_tail.h \
+@BUILD_PLUGIN_TAIL_TRUE@                  utils_tail_match.c utils_tail_match.h
+
 @BUILD_PLUGIN_TAIL_TRUE@tail_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_TAIL_CSV_TRUE@tail_csv_la_SOURCES = tail_csv.c
+@BUILD_PLUGIN_TAIL_TRUE@tail_la_LIBADD = liblatency.la
+@BUILD_PLUGIN_TAIL_CSV_TRUE@tail_csv_la_SOURCES = tail_csv.c \
+@BUILD_PLUGIN_TAIL_CSV_TRUE@                      utils_tail.c utils_tail.h
+
 @BUILD_PLUGIN_TAIL_CSV_TRUE@tail_csv_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TAPE_TRUE@tape_la_SOURCES = tape.c
 @BUILD_PLUGIN_TAPE_TRUE@tape_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TAPE_TRUE@tape_la_LIBADD = -lkstat -ldevinfo
 @BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@target_notification_la_SOURCES = target_notification.c
 @BUILD_PLUGIN_TARGET_NOTIFICATION_TRUE@target_notification_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -3139,48 +3249,40 @@
 @BUILD_PLUGIN_TARGET_SET_TRUE@target_set_la_SOURCES = target_set.c
 @BUILD_PLUGIN_TARGET_SET_TRUE@target_set_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@target_v5upgrade_la_SOURCES = target_v5upgrade.c
 @BUILD_PLUGIN_TARGET_V5UPGRADE_TRUE@target_v5upgrade_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_SOURCES = tcpconns.c
 @BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_LIBADD = $(am__append_183)
+@BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_LIBADD = $(am__append_186)
 @BUILD_PLUGIN_TEAMSPEAK2_TRUE@teamspeak2_la_SOURCES = teamspeak2.c
 @BUILD_PLUGIN_TEAMSPEAK2_TRUE@teamspeak2_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TED_TRUE@ted_la_SOURCES = ted.c
 @BUILD_PLUGIN_TED_TRUE@ted_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_THERMAL_TRUE@thermal_la_SOURCES = thermal.c
 @BUILD_PLUGIN_THERMAL_TRUE@thermal_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_THRESHOLD_TRUE@threshold_la_SOURCES = threshold.c
 @BUILD_PLUGIN_THRESHOLD_TRUE@threshold_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_SOURCES = tokyotyrant.c
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBTOKYOTYRANT_CPPFLAGS)
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBTOKYOTYRANT_LDFLAGS)
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_LIBADD = $(BUILD_WITH_LIBTOKYOTYRANT_LIBS) \
-@BUILD_PLUGIN_TOKYOTYRANT_TRUE@	$(am__append_189)
+@BUILD_PLUGIN_TOKYOTYRANT_TRUE@	$(am__append_192)
 @BUILD_PLUGIN_TURBOSTAT_TRUE@turbostat_la_SOURCES = turbostat.c
 @BUILD_PLUGIN_TURBOSTAT_TRUE@turbostat_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_UNIXSOCK_TRUE@unixsock_la_SOURCES = unixsock.c \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_flush.h utils_cmd_flush.c \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_getval.h utils_cmd_getval.c \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_getthreshold.h utils_cmd_getthreshold.c \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_listval.h utils_cmd_listval.c \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_putval.h utils_cmd_putval.c \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_cmd_putnotif.h utils_cmd_putnotif.c \
-@BUILD_PLUGIN_UNIXSOCK_TRUE@		      utils_parse_option.h utils_parse_option.c
-
-@BUILD_PLUGIN_UNIXSOCK_TRUE@unixsock_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+@BUILD_PLUGIN_UNIXSOCK_TRUE@unixsock_la_SOURCES = unixsock.c
+@BUILD_PLUGIN_UNIXSOCK_TRUE@unixsock_la_LDFLAGS = $(PLUGIN_LDFLAGS) libcmds.la
 @BUILD_PLUGIN_UPTIME_TRUE@uptime_la_SOURCES = uptime.c
 @BUILD_PLUGIN_UPTIME_TRUE@uptime_la_CFLAGS = $(AM_CFLAGS)
 @BUILD_PLUGIN_UPTIME_TRUE@uptime_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_UPTIME_TRUE@uptime_la_LIBADD = $(am__append_193) \
-@BUILD_PLUGIN_UPTIME_TRUE@	$(am__append_194)
+@BUILD_PLUGIN_UPTIME_TRUE@uptime_la_LIBADD = $(am__append_196) \
+@BUILD_PLUGIN_UPTIME_TRUE@	$(am__append_197)
 @BUILD_PLUGIN_USERS_TRUE@users_la_SOURCES = users.c
 @BUILD_PLUGIN_USERS_TRUE@users_la_CFLAGS = $(AM_CFLAGS) \
-@BUILD_PLUGIN_USERS_TRUE@	$(am__append_196)
+@BUILD_PLUGIN_USERS_TRUE@	$(am__append_199)
 @BUILD_PLUGIN_USERS_TRUE@users_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_USERS_TRUE@users_la_LIBADD = $(am__append_197)
+@BUILD_PLUGIN_USERS_TRUE@users_la_LIBADD = $(am__append_200)
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_SOURCES = uuid.c
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBHAL_CFLAGS)
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_LIBADD = $(BUILD_WITH_LIBHAL_LIBS)
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_VARNISH_TRUE@varnish_la_SOURCES = varnish.c
 @BUILD_PLUGIN_VARNISH_TRUE@varnish_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -3195,38 +3297,41 @@
 @BUILD_PLUGIN_VMEM_TRUE@vmem_la_SOURCES = vmem.c
 @BUILD_PLUGIN_VMEM_TRUE@vmem_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_VSERVER_TRUE@vserver_la_SOURCES = vserver.c
 @BUILD_PLUGIN_VSERVER_TRUE@vserver_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_WIRELESS_TRUE@wireless_la_SOURCES = wireless.c
 @BUILD_PLUGIN_WIRELESS_TRUE@wireless_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@write_graphite_la_SOURCES = write_graphite.c \
-@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@                        utils_format_graphite.c utils_format_graphite.h
-
+@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@write_graphite_la_SOURCES = write_graphite.c
 @BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@write_graphite_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@write_graphite_la_LIBADD = libformat_graphite.la
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@write_http_la_SOURCES = write_http.c \
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@			utils_format_kairosdb.c utils_format_kairosdb.h
 
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@write_http_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@write_http_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBCURL_CFLAGS)
 @BUILD_PLUGIN_WRITE_HTTP_TRUE@write_http_la_LIBADD = $(BUILD_WITH_LIBCURL_LIBS) libformat_json.la
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@write_kafka_la_SOURCES = write_kafka.c \
-@BUILD_PLUGIN_WRITE_KAFKA_TRUE@                        utils_format_graphite.c utils_format_graphite.h \
-@BUILD_PLUGIN_WRITE_KAFKA_TRUE@                        utils_cmd_putval.c utils_cmd_putval.h \
-@BUILD_PLUGIN_WRITE_KAFKA_TRUE@                        utils_crc32.c utils_crc32.h
+@BUILD_PLUGIN_WRITE_KAFKA_TRUE@                         utils_crc32.c utils_crc32.h
 
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@write_kafka_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBRDKAFKA_CPPFLAGS)
 @BUILD_PLUGIN_WRITE_KAFKA_TRUE@write_kafka_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBRDKAFKA_LDFLAGS)
-@BUILD_PLUGIN_WRITE_KAFKA_TRUE@write_kafka_la_LIBADD = $(BUILD_WITH_LIBRDKAFKA_LIBS) libformat_json.la
-@BUILD_PLUGIN_WRITE_LOG_TRUE@write_log_la_SOURCES = write_log.c \
-@BUILD_PLUGIN_WRITE_LOG_TRUE@                        utils_format_graphite.c utils_format_graphite.h
+@BUILD_PLUGIN_WRITE_KAFKA_TRUE@write_kafka_la_LIBADD = $(BUILD_WITH_LIBRDKAFKA_LIBS) \
+@BUILD_PLUGIN_WRITE_KAFKA_TRUE@                        libcmds.la libformat_graphite.la libformat_json.la
 
+@BUILD_PLUGIN_WRITE_LOG_TRUE@write_log_la_SOURCES = write_log.c
 @BUILD_PLUGIN_WRITE_LOG_TRUE@write_log_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+@BUILD_PLUGIN_WRITE_LOG_TRUE@write_log_la_LIBADD = libformat_graphite.la libformat_json.la
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@write_mongodb_la_SOURCES = write_mongodb.c
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@write_mongodb_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBMONGOC_CPPFLAGS)
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@write_mongodb_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBMONGOC_LDFLAGS)
 @BUILD_PLUGIN_WRITE_MONGODB_TRUE@write_mongodb_la_LIBADD = -lmongoc
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@write_prometheus_la_SOURCES = write_prometheus.c
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@nodist_write_prometheus_la_SOURCES = prometheus.pb-c.c prometheus.pb-c.h
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@write_prometheus_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBPROTOBUF_C_CPPFLAGS) $(BUILD_WITH_LIBMICROHTTPD_CPPFLAGS)
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@write_prometheus_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBPROTOBUF_C_LDFLAGS) $(BUILD_WITH_LIBMICROHTTPD_LDFLAGS)
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@write_prometheus_la_LIBADD = $(BUILD_WITH_LIBPROTOBUF_C_LIBS) $(BUILD_WITH_LIBMICROHTTPD_LIBS)
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@write_redis_la_SOURCES = write_redis.c
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@write_redis_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBHIREDIS_LDFLAGS)
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@write_redis_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBHIREDIS_CPPFLAGS)
 @BUILD_PLUGIN_WRITE_REDIS_TRUE@write_redis_la_LIBADD = -lhiredis
 @BUILD_PLUGIN_WRITE_RIEMANN_TRUE@write_riemann_la_SOURCES = write_riemann.c write_riemann_threshold.c write_riemann_threshold.h
 @BUILD_PLUGIN_WRITE_RIEMANN_TRUE@write_riemann_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(LIBRIEMANN_CLIENT_LIBS)
@@ -3463,12 +3568,15 @@
 disk.la: $(disk_la_OBJECTS) $(disk_la_DEPENDENCIES) $(EXTRA_disk_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(disk_la_LINK) $(am_disk_la_rpath) $(disk_la_OBJECTS) $(disk_la_LIBADD) $(LIBS)
 
 dns.la: $(dns_la_OBJECTS) $(dns_la_DEPENDENCIES) $(EXTRA_dns_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(dns_la_LINK) $(am_dns_la_rpath) $(dns_la_OBJECTS) $(dns_la_LIBADD) $(LIBS)
 
+dpdkstat.la: $(dpdkstat_la_OBJECTS) $(dpdkstat_la_DEPENDENCIES) $(EXTRA_dpdkstat_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(dpdkstat_la_LINK) $(am_dpdkstat_la_rpath) $(dpdkstat_la_OBJECTS) $(dpdkstat_la_LIBADD) $(LIBS)
+
 drbd.la: $(drbd_la_OBJECTS) $(drbd_la_DEPENDENCIES) $(EXTRA_drbd_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(drbd_la_LINK) $(am_drbd_la_rpath) $(drbd_la_OBJECTS) $(drbd_la_LIBADD) $(LIBS)
 
 email.la: $(email_la_OBJECTS) $(email_la_DEPENDENCIES) $(EXTRA_email_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(email_la_LINK) $(am_email_la_rpath) $(email_la_OBJECTS) $(email_la_LIBADD) $(LIBS)
 
@@ -3499,12 +3607,18 @@
 grpc.la: $(grpc_la_OBJECTS) $(grpc_la_DEPENDENCIES) $(EXTRA_grpc_la_DEPENDENCIES) 
 	$(AM_V_CXXLD)$(grpc_la_LINK) $(am_grpc_la_rpath) $(grpc_la_OBJECTS) $(grpc_la_LIBADD) $(LIBS)
 
 hddtemp.la: $(hddtemp_la_OBJECTS) $(hddtemp_la_DEPENDENCIES) $(EXTRA_hddtemp_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(hddtemp_la_LINK) $(am_hddtemp_la_rpath) $(hddtemp_la_OBJECTS) $(hddtemp_la_LIBADD) $(LIBS)
 
+hugepages.la: $(hugepages_la_OBJECTS) $(hugepages_la_DEPENDENCIES) $(EXTRA_hugepages_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(hugepages_la_LINK) $(am_hugepages_la_rpath) $(hugepages_la_OBJECTS) $(hugepages_la_LIBADD) $(LIBS)
+
+intel_rdt.la: $(intel_rdt_la_OBJECTS) $(intel_rdt_la_DEPENDENCIES) $(EXTRA_intel_rdt_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(intel_rdt_la_LINK) $(am_intel_rdt_la_rpath) $(intel_rdt_la_OBJECTS) $(intel_rdt_la_LIBADD) $(LIBS)
+
 interface.la: $(interface_la_OBJECTS) $(interface_la_DEPENDENCIES) $(EXTRA_interface_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(interface_la_LINK) $(am_interface_la_rpath) $(interface_la_OBJECTS) $(interface_la_LIBADD) $(LIBS)
 
 ipc.la: $(ipc_la_OBJECTS) $(ipc_la_DEPENDENCIES) $(EXTRA_ipc_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(ipc_la_LINK) $(am_ipc_la_rpath) $(ipc_la_OBJECTS) $(ipc_la_LIBADD) $(LIBS)
 
@@ -3520,12 +3634,18 @@
 irq.la: $(irq_la_OBJECTS) $(irq_la_DEPENDENCIES) $(EXTRA_irq_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(irq_la_LINK) $(am_irq_la_rpath) $(irq_la_OBJECTS) $(irq_la_LIBADD) $(LIBS)
 
 java.la: $(java_la_OBJECTS) $(java_la_DEPENDENCIES) $(EXTRA_java_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(java_la_LINK) $(am_java_la_rpath) $(java_la_OBJECTS) $(java_la_LIBADD) $(LIBS)
 
+libcmds.la: $(libcmds_la_OBJECTS) $(libcmds_la_DEPENDENCIES) $(EXTRA_libcmds_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(LINK)  $(libcmds_la_OBJECTS) $(libcmds_la_LIBADD) $(LIBS)
+
+libformat_graphite.la: $(libformat_graphite_la_OBJECTS) $(libformat_graphite_la_DEPENDENCIES) $(EXTRA_libformat_graphite_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libformat_graphite_la_LINK)  $(libformat_graphite_la_OBJECTS) $(libformat_graphite_la_LIBADD) $(LIBS)
+
 libformat_json.la: $(libformat_json_la_OBJECTS) $(libformat_json_la_DEPENDENCIES) $(EXTRA_libformat_json_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(libformat_json_la_LINK)  $(libformat_json_la_OBJECTS) $(libformat_json_la_LIBADD) $(LIBS)
 
 liblatency.la: $(liblatency_la_OBJECTS) $(liblatency_la_DEPENDENCIES) $(EXTRA_liblatency_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(LINK)  $(liblatency_la_OBJECTS) $(liblatency_la_LIBADD) $(LIBS)
 
@@ -3799,12 +3919,15 @@
 write_log.la: $(write_log_la_OBJECTS) $(write_log_la_DEPENDENCIES) $(EXTRA_write_log_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(write_log_la_LINK) $(am_write_log_la_rpath) $(write_log_la_OBJECTS) $(write_log_la_LIBADD) $(LIBS)
 
 write_mongodb.la: $(write_mongodb_la_OBJECTS) $(write_mongodb_la_DEPENDENCIES) $(EXTRA_write_mongodb_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(write_mongodb_la_LINK) $(am_write_mongodb_la_rpath) $(write_mongodb_la_OBJECTS) $(write_mongodb_la_LIBADD) $(LIBS)
 
+write_prometheus.la: $(write_prometheus_la_OBJECTS) $(write_prometheus_la_DEPENDENCIES) $(EXTRA_write_prometheus_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(write_prometheus_la_LINK) $(am_write_prometheus_la_rpath) $(write_prometheus_la_OBJECTS) $(write_prometheus_la_LIBADD) $(LIBS)
+
 write_redis.la: $(write_redis_la_OBJECTS) $(write_redis_la_DEPENDENCIES) $(EXTRA_write_redis_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(write_redis_la_LINK) $(am_write_redis_la_rpath) $(write_redis_la_OBJECTS) $(write_redis_la_LIBADD) $(LIBS)
 
 write_riemann.la: $(write_riemann_la_OBJECTS) $(write_riemann_la_DEPENDENCIES) $(EXTRA_write_riemann_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(write_riemann_la_LINK) $(am_write_riemann_la_rpath) $(write_riemann_la_OBJECTS) $(write_riemann_la_LIBADD) $(LIBS)
 
@@ -3949,20 +4072,28 @@
 	$(AM_V_CCLD)$(LINK) $(collectdctl_OBJECTS) $(collectdctl_LDADD) $(LIBS)
 
 collectdmon$(EXEEXT): $(collectdmon_OBJECTS) $(collectdmon_DEPENDENCIES) $(EXTRA_collectdmon_DEPENDENCIES) 
 	@rm -f collectdmon$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(collectdmon_OBJECTS) $(collectdmon_LDADD) $(LIBS)
 
+test_format_graphite$(EXEEXT): $(test_format_graphite_OBJECTS) $(test_format_graphite_DEPENDENCIES) $(EXTRA_test_format_graphite_DEPENDENCIES) 
+	@rm -f test_format_graphite$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(test_format_graphite_OBJECTS) $(test_format_graphite_LDADD) $(LIBS)
+
 test_format_json$(EXEEXT): $(test_format_json_OBJECTS) $(test_format_json_DEPENDENCIES) $(EXTRA_test_format_json_DEPENDENCIES) 
 	@rm -f test_format_json$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(test_format_json_OBJECTS) $(test_format_json_LDADD) $(LIBS)
 
 test_plugin_ceph$(EXEEXT): $(test_plugin_ceph_OBJECTS) $(test_plugin_ceph_DEPENDENCIES) $(EXTRA_test_plugin_ceph_DEPENDENCIES) 
 	@rm -f test_plugin_ceph$(EXEEXT)
 	$(AM_V_CCLD)$(test_plugin_ceph_LINK) $(test_plugin_ceph_OBJECTS) $(test_plugin_ceph_LDADD) $(LIBS)
 
+test_utils_cmds$(EXEEXT): $(test_utils_cmds_OBJECTS) $(test_utils_cmds_DEPENDENCIES) $(EXTRA_test_utils_cmds_DEPENDENCIES) 
+	@rm -f test_utils_cmds$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(test_utils_cmds_OBJECTS) $(test_utils_cmds_LDADD) $(LIBS)
+
 test_utils_latency$(EXEEXT): $(test_utils_latency_OBJECTS) $(test_utils_latency_DEPENDENCIES) $(EXTRA_test_utils_latency_DEPENDENCIES) 
 	@rm -f test_utils_latency$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(test_utils_latency_OBJECTS) $(test_utils_latency_LDADD) $(LIBS)
 
 test_utils_mount$(EXEEXT): $(test_utils_mount_OBJECTS) $(test_utils_mount_DEPENDENCIES) $(EXTRA_test_utils_mount_DEPENDENCIES) 
 	@rm -f test_utils_mount$(EXEEXT)
@@ -3977,22 +4108,20 @@
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aggregation.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/amqp_la-amqp.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/amqp_la-utils_cmd_putval.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/amqp_la-utils_format_graphite.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/amqp_la-utils_parse_option.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/apache_la-apache.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/apcups.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/apple_sensors.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aquaero_la-aquaero.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ascent_la-ascent.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/barometer.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/battery.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/battery_statefs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bind_la-bind.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ceph_la-ceph.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cgroups.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chrony.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd_nagios-collectd-nagios.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd_tg-collectd-tg.Po@am__quote@
@@ -4005,19 +4134,21 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpusleep.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/csv.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_json_la-curl_json.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_json_la-utils_curl_stats.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_la-curl.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_la-utils_curl_stats.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_la-utils_match.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_xml_la-curl_xml.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_xml_la-utils_curl_stats.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dbi_la-dbi.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dbi_la-utils_db_query.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/df.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/disk_la-disk.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dns.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dpdkstat_la-dpdkstat.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/drbd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/email.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/entropy.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ethstat.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exec.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fhcount.Plo@am__quote@
@@ -4027,19 +4158,22 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gps_la-gps.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/grpc_la-collectd.grpc.pb.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/grpc_la-collectd.pb.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/grpc_la-grpc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/grpc_la-types.pb.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hddtemp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hugepages.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/intel_rdt_la-intel_rdt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interface_la-interface.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipmi_la-ipmi.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iptables_la-iptables.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipvs_la-ipvs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/irq.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/java_la-java.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libformat_graphite_la-utils_format_graphite.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libformat_json_la-utils_format_json.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/load_la-load.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/log_logstash_la-log_logstash.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/logfile.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lpar.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lua_la-lua.Plo@am__quote@
@@ -4051,12 +4185,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/match_regex.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/match_timediff.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/match_value.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mbmon.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/md.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcachec_la-memcachec.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcachec_la-utils_match.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memory_la-memory.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mic_la-mic.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/modbus_la-modbus.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mqtt_la-mqtt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/multimeter.Plo@am__quote@
@@ -4129,37 +4264,43 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmd_flush.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmd_getthreshold.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmd_getval.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmd_listval.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmd_putnotif.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmd_putval.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmds.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmds_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_dns.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_format_graphite.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_format_graphite_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_format_json_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_latency.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_latency_config.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_latency_test.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_match.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_mount.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_mount_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_parse_option.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_tail.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_tail_match.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_vl_lookup.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_vl_lookup_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uuid_la-uuid.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/varnish_la-varnish.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/virt_la-virt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vmem.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vserver.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wireless.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_graphite.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_http_la-utils_format_kairosdb.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_http_la-write_http.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_kafka_la-utils_cmd_putval.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_kafka_la-utils_crc32.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_kafka_la-utils_format_graphite.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_kafka_la-write_kafka.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_log.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_mongodb_la-write_mongodb.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_prometheus_la-prometheus.pb-c.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_prometheus_la-write_prometheus.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_redis_la-write_redis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_riemann_la-write_riemann.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_riemann_la-write_riemann_threshold.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_sensu.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_tsdb.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xencpu_la-xencpu.Plo@am__quote@
@@ -4196,33 +4337,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT amqp_la-amqp.lo -MD -MP -MF $(DEPDIR)/amqp_la-amqp.Tpo -c -o amqp_la-amqp.lo `test -f 'amqp.c' || echo '$(srcdir)/'`amqp.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/amqp_la-amqp.Tpo $(DEPDIR)/amqp_la-amqp.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='amqp.c' object='amqp_la-amqp.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o amqp_la-amqp.lo `test -f 'amqp.c' || echo '$(srcdir)/'`amqp.c
 
-amqp_la-utils_cmd_putval.lo: utils_cmd_putval.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT amqp_la-utils_cmd_putval.lo -MD -MP -MF $(DEPDIR)/amqp_la-utils_cmd_putval.Tpo -c -o amqp_la-utils_cmd_putval.lo `test -f 'utils_cmd_putval.c' || echo '$(srcdir)/'`utils_cmd_putval.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/amqp_la-utils_cmd_putval.Tpo $(DEPDIR)/amqp_la-utils_cmd_putval.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_cmd_putval.c' object='amqp_la-utils_cmd_putval.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o amqp_la-utils_cmd_putval.lo `test -f 'utils_cmd_putval.c' || echo '$(srcdir)/'`utils_cmd_putval.c
-
-amqp_la-utils_parse_option.lo: utils_parse_option.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT amqp_la-utils_parse_option.lo -MD -MP -MF $(DEPDIR)/amqp_la-utils_parse_option.Tpo -c -o amqp_la-utils_parse_option.lo `test -f 'utils_parse_option.c' || echo '$(srcdir)/'`utils_parse_option.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/amqp_la-utils_parse_option.Tpo $(DEPDIR)/amqp_la-utils_parse_option.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_parse_option.c' object='amqp_la-utils_parse_option.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o amqp_la-utils_parse_option.lo `test -f 'utils_parse_option.c' || echo '$(srcdir)/'`utils_parse_option.c
-
-amqp_la-utils_format_graphite.lo: utils_format_graphite.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT amqp_la-utils_format_graphite.lo -MD -MP -MF $(DEPDIR)/amqp_la-utils_format_graphite.Tpo -c -o amqp_la-utils_format_graphite.lo `test -f 'utils_format_graphite.c' || echo '$(srcdir)/'`utils_format_graphite.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/amqp_la-utils_format_graphite.Tpo $(DEPDIR)/amqp_la-utils_format_graphite.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_format_graphite.c' object='amqp_la-utils_format_graphite.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o amqp_la-utils_format_graphite.lo `test -f 'utils_format_graphite.c' || echo '$(srcdir)/'`utils_format_graphite.c
-
 apache_la-apache.lo: apache.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(apache_la_CFLAGS) $(CFLAGS) -MT apache_la-apache.lo -MD -MP -MF $(DEPDIR)/apache_la-apache.Tpo -c -o apache_la-apache.lo `test -f 'apache.c' || echo '$(srcdir)/'`apache.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/apache_la-apache.Tpo $(DEPDIR)/apache_la-apache.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='apache.c' object='apache_la-apache.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(apache_la_CFLAGS) $(CFLAGS) -c -o apache_la-apache.lo `test -f 'apache.c' || echo '$(srcdir)/'`apache.c
@@ -4273,12 +4393,19 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(curl_la_CFLAGS) $(CFLAGS) -MT curl_la-utils_curl_stats.lo -MD -MP -MF $(DEPDIR)/curl_la-utils_curl_stats.Tpo -c -o curl_la-utils_curl_stats.lo `test -f 'utils_curl_stats.c' || echo '$(srcdir)/'`utils_curl_stats.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/curl_la-utils_curl_stats.Tpo $(DEPDIR)/curl_la-utils_curl_stats.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_curl_stats.c' object='curl_la-utils_curl_stats.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(curl_la_CFLAGS) $(CFLAGS) -c -o curl_la-utils_curl_stats.lo `test -f 'utils_curl_stats.c' || echo '$(srcdir)/'`utils_curl_stats.c
 
+curl_la-utils_match.lo: utils_match.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(curl_la_CFLAGS) $(CFLAGS) -MT curl_la-utils_match.lo -MD -MP -MF $(DEPDIR)/curl_la-utils_match.Tpo -c -o curl_la-utils_match.lo `test -f 'utils_match.c' || echo '$(srcdir)/'`utils_match.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/curl_la-utils_match.Tpo $(DEPDIR)/curl_la-utils_match.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_match.c' object='curl_la-utils_match.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(curl_la_CFLAGS) $(CFLAGS) -c -o curl_la-utils_match.lo `test -f 'utils_match.c' || echo '$(srcdir)/'`utils_match.c
+
 curl_json_la-curl_json.lo: curl_json.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(curl_json_la_CPPFLAGS) $(CPPFLAGS) $(curl_json_la_CFLAGS) $(CFLAGS) -MT curl_json_la-curl_json.lo -MD -MP -MF $(DEPDIR)/curl_json_la-curl_json.Tpo -c -o curl_json_la-curl_json.lo `test -f 'curl_json.c' || echo '$(srcdir)/'`curl_json.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/curl_json_la-curl_json.Tpo $(DEPDIR)/curl_json_la-curl_json.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='curl_json.c' object='curl_json_la-curl_json.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(curl_json_la_CPPFLAGS) $(CPPFLAGS) $(curl_json_la_CFLAGS) $(CFLAGS) -c -o curl_json_la-curl_json.lo `test -f 'curl_json.c' || echo '$(srcdir)/'`curl_json.c
@@ -4322,12 +4449,19 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(disk_la_CFLAGS) $(CFLAGS) -MT disk_la-disk.lo -MD -MP -MF $(DEPDIR)/disk_la-disk.Tpo -c -o disk_la-disk.lo `test -f 'disk.c' || echo '$(srcdir)/'`disk.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/disk_la-disk.Tpo $(DEPDIR)/disk_la-disk.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='disk.c' object='disk_la-disk.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(disk_la_CFLAGS) $(CFLAGS) -c -o disk_la-disk.lo `test -f 'disk.c' || echo '$(srcdir)/'`disk.c
 
+dpdkstat_la-dpdkstat.lo: dpdkstat.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(dpdkstat_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT dpdkstat_la-dpdkstat.lo -MD -MP -MF $(DEPDIR)/dpdkstat_la-dpdkstat.Tpo -c -o dpdkstat_la-dpdkstat.lo `test -f 'dpdkstat.c' || echo '$(srcdir)/'`dpdkstat.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/dpdkstat_la-dpdkstat.Tpo $(DEPDIR)/dpdkstat_la-dpdkstat.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='dpdkstat.c' object='dpdkstat_la-dpdkstat.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(dpdkstat_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o dpdkstat_la-dpdkstat.lo `test -f 'dpdkstat.c' || echo '$(srcdir)/'`dpdkstat.c
+
 gmond_la-gmond.lo: gmond.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gmond_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gmond_la-gmond.lo -MD -MP -MF $(DEPDIR)/gmond_la-gmond.Tpo -c -o gmond_la-gmond.lo `test -f 'gmond.c' || echo '$(srcdir)/'`gmond.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gmond_la-gmond.Tpo $(DEPDIR)/gmond_la-gmond.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gmond.c' object='gmond_la-gmond.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gmond_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gmond_la-gmond.lo `test -f 'gmond.c' || echo '$(srcdir)/'`gmond.c
@@ -4336,12 +4470,19 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gps_la_CFLAGS) $(CFLAGS) -MT gps_la-gps.lo -MD -MP -MF $(DEPDIR)/gps_la-gps.Tpo -c -o gps_la-gps.lo `test -f 'gps.c' || echo '$(srcdir)/'`gps.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gps_la-gps.Tpo $(DEPDIR)/gps_la-gps.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gps.c' object='gps_la-gps.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gps_la_CFLAGS) $(CFLAGS) -c -o gps_la-gps.lo `test -f 'gps.c' || echo '$(srcdir)/'`gps.c
 
+intel_rdt_la-intel_rdt.lo: intel_rdt.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(intel_rdt_la_CFLAGS) $(CFLAGS) -MT intel_rdt_la-intel_rdt.lo -MD -MP -MF $(DEPDIR)/intel_rdt_la-intel_rdt.Tpo -c -o intel_rdt_la-intel_rdt.lo `test -f 'intel_rdt.c' || echo '$(srcdir)/'`intel_rdt.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/intel_rdt_la-intel_rdt.Tpo $(DEPDIR)/intel_rdt_la-intel_rdt.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='intel_rdt.c' object='intel_rdt_la-intel_rdt.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(intel_rdt_la_CFLAGS) $(CFLAGS) -c -o intel_rdt_la-intel_rdt.lo `test -f 'intel_rdt.c' || echo '$(srcdir)/'`intel_rdt.c
+
 interface_la-interface.lo: interface.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(interface_la_CFLAGS) $(CFLAGS) -MT interface_la-interface.lo -MD -MP -MF $(DEPDIR)/interface_la-interface.Tpo -c -o interface_la-interface.lo `test -f 'interface.c' || echo '$(srcdir)/'`interface.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/interface_la-interface.Tpo $(DEPDIR)/interface_la-interface.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='interface.c' object='interface_la-interface.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(interface_la_CFLAGS) $(CFLAGS) -c -o interface_la-interface.lo `test -f 'interface.c' || echo '$(srcdir)/'`interface.c
@@ -4371,12 +4512,19 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(java_la_CPPFLAGS) $(CPPFLAGS) $(java_la_CFLAGS) $(CFLAGS) -MT java_la-java.lo -MD -MP -MF $(DEPDIR)/java_la-java.Tpo -c -o java_la-java.lo `test -f 'java.c' || echo '$(srcdir)/'`java.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/java_la-java.Tpo $(DEPDIR)/java_la-java.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='java.c' object='java_la-java.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(java_la_CPPFLAGS) $(CPPFLAGS) $(java_la_CFLAGS) $(CFLAGS) -c -o java_la-java.lo `test -f 'java.c' || echo '$(srcdir)/'`java.c
 
+libformat_graphite_la-utils_format_graphite.lo: utils_format_graphite.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libformat_graphite_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libformat_graphite_la-utils_format_graphite.lo -MD -MP -MF $(DEPDIR)/libformat_graphite_la-utils_format_graphite.Tpo -c -o libformat_graphite_la-utils_format_graphite.lo `test -f 'utils_format_graphite.c' || echo '$(srcdir)/'`utils_format_graphite.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libformat_graphite_la-utils_format_graphite.Tpo $(DEPDIR)/libformat_graphite_la-utils_format_graphite.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_format_graphite.c' object='libformat_graphite_la-utils_format_graphite.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libformat_graphite_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libformat_graphite_la-utils_format_graphite.lo `test -f 'utils_format_graphite.c' || echo '$(srcdir)/'`utils_format_graphite.c
+
 libformat_json_la-utils_format_json.lo: utils_format_json.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libformat_json_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT libformat_json_la-utils_format_json.lo -MD -MP -MF $(DEPDIR)/libformat_json_la-utils_format_json.Tpo -c -o libformat_json_la-utils_format_json.lo `test -f 'utils_format_json.c' || echo '$(srcdir)/'`utils_format_json.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libformat_json_la-utils_format_json.Tpo $(DEPDIR)/libformat_json_la-utils_format_json.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_format_json.c' object='libformat_json_la-utils_format_json.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libformat_json_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o libformat_json_la-utils_format_json.lo `test -f 'utils_format_json.c' || echo '$(srcdir)/'`utils_format_json.c
@@ -4420,12 +4568,19 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(memcachec_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT memcachec_la-memcachec.lo -MD -MP -MF $(DEPDIR)/memcachec_la-memcachec.Tpo -c -o memcachec_la-memcachec.lo `test -f 'memcachec.c' || echo '$(srcdir)/'`memcachec.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/memcachec_la-memcachec.Tpo $(DEPDIR)/memcachec_la-memcachec.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='memcachec.c' object='memcachec_la-memcachec.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(memcachec_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o memcachec_la-memcachec.lo `test -f 'memcachec.c' || echo '$(srcdir)/'`memcachec.c
 
+memcachec_la-utils_match.lo: utils_match.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(memcachec_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT memcachec_la-utils_match.lo -MD -MP -MF $(DEPDIR)/memcachec_la-utils_match.Tpo -c -o memcachec_la-utils_match.lo `test -f 'utils_match.c' || echo '$(srcdir)/'`utils_match.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/memcachec_la-utils_match.Tpo $(DEPDIR)/memcachec_la-utils_match.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_match.c' object='memcachec_la-utils_match.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(memcachec_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o memcachec_la-utils_match.lo `test -f 'utils_match.c' || echo '$(srcdir)/'`utils_match.c
+
 memory_la-memory.lo: memory.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(memory_la_CFLAGS) $(CFLAGS) -MT memory_la-memory.lo -MD -MP -MF $(DEPDIR)/memory_la-memory.Tpo -c -o memory_la-memory.lo `test -f 'memory.c' || echo '$(srcdir)/'`memory.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/memory_la-memory.Tpo $(DEPDIR)/memory_la-memory.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='memory.c' object='memory_la-memory.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(memory_la_CFLAGS) $(CFLAGS) -c -o memory_la-memory.lo `test -f 'memory.c' || echo '$(srcdir)/'`memory.c
@@ -4735,26 +4890,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_kafka_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write_kafka_la-write_kafka.lo -MD -MP -MF $(DEPDIR)/write_kafka_la-write_kafka.Tpo -c -o write_kafka_la-write_kafka.lo `test -f 'write_kafka.c' || echo '$(srcdir)/'`write_kafka.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/write_kafka_la-write_kafka.Tpo $(DEPDIR)/write_kafka_la-write_kafka.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='write_kafka.c' object='write_kafka_la-write_kafka.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_kafka_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o write_kafka_la-write_kafka.lo `test -f 'write_kafka.c' || echo '$(srcdir)/'`write_kafka.c
 
-write_kafka_la-utils_format_graphite.lo: utils_format_graphite.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_kafka_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write_kafka_la-utils_format_graphite.lo -MD -MP -MF $(DEPDIR)/write_kafka_la-utils_format_graphite.Tpo -c -o write_kafka_la-utils_format_graphite.lo `test -f 'utils_format_graphite.c' || echo '$(srcdir)/'`utils_format_graphite.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/write_kafka_la-utils_format_graphite.Tpo $(DEPDIR)/write_kafka_la-utils_format_graphite.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_format_graphite.c' object='write_kafka_la-utils_format_graphite.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_kafka_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o write_kafka_la-utils_format_graphite.lo `test -f 'utils_format_graphite.c' || echo '$(srcdir)/'`utils_format_graphite.c
-
-write_kafka_la-utils_cmd_putval.lo: utils_cmd_putval.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_kafka_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write_kafka_la-utils_cmd_putval.lo -MD -MP -MF $(DEPDIR)/write_kafka_la-utils_cmd_putval.Tpo -c -o write_kafka_la-utils_cmd_putval.lo `test -f 'utils_cmd_putval.c' || echo '$(srcdir)/'`utils_cmd_putval.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/write_kafka_la-utils_cmd_putval.Tpo $(DEPDIR)/write_kafka_la-utils_cmd_putval.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_cmd_putval.c' object='write_kafka_la-utils_cmd_putval.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_kafka_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o write_kafka_la-utils_cmd_putval.lo `test -f 'utils_cmd_putval.c' || echo '$(srcdir)/'`utils_cmd_putval.c
-
 write_kafka_la-utils_crc32.lo: utils_crc32.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_kafka_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write_kafka_la-utils_crc32.lo -MD -MP -MF $(DEPDIR)/write_kafka_la-utils_crc32.Tpo -c -o write_kafka_la-utils_crc32.lo `test -f 'utils_crc32.c' || echo '$(srcdir)/'`utils_crc32.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/write_kafka_la-utils_crc32.Tpo $(DEPDIR)/write_kafka_la-utils_crc32.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_crc32.c' object='write_kafka_la-utils_crc32.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_kafka_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o write_kafka_la-utils_crc32.lo `test -f 'utils_crc32.c' || echo '$(srcdir)/'`utils_crc32.c
@@ -4763,12 +4904,26 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_mongodb_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write_mongodb_la-write_mongodb.lo -MD -MP -MF $(DEPDIR)/write_mongodb_la-write_mongodb.Tpo -c -o write_mongodb_la-write_mongodb.lo `test -f 'write_mongodb.c' || echo '$(srcdir)/'`write_mongodb.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/write_mongodb_la-write_mongodb.Tpo $(DEPDIR)/write_mongodb_la-write_mongodb.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='write_mongodb.c' object='write_mongodb_la-write_mongodb.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_mongodb_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o write_mongodb_la-write_mongodb.lo `test -f 'write_mongodb.c' || echo '$(srcdir)/'`write_mongodb.c
 
+write_prometheus_la-write_prometheus.lo: write_prometheus.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_prometheus_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write_prometheus_la-write_prometheus.lo -MD -MP -MF $(DEPDIR)/write_prometheus_la-write_prometheus.Tpo -c -o write_prometheus_la-write_prometheus.lo `test -f 'write_prometheus.c' || echo '$(srcdir)/'`write_prometheus.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/write_prometheus_la-write_prometheus.Tpo $(DEPDIR)/write_prometheus_la-write_prometheus.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='write_prometheus.c' object='write_prometheus_la-write_prometheus.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_prometheus_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o write_prometheus_la-write_prometheus.lo `test -f 'write_prometheus.c' || echo '$(srcdir)/'`write_prometheus.c
+
+write_prometheus_la-prometheus.pb-c.lo: prometheus.pb-c.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_prometheus_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write_prometheus_la-prometheus.pb-c.lo -MD -MP -MF $(DEPDIR)/write_prometheus_la-prometheus.pb-c.Tpo -c -o write_prometheus_la-prometheus.pb-c.lo `test -f 'prometheus.pb-c.c' || echo '$(srcdir)/'`prometheus.pb-c.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/write_prometheus_la-prometheus.pb-c.Tpo $(DEPDIR)/write_prometheus_la-prometheus.pb-c.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='prometheus.pb-c.c' object='write_prometheus_la-prometheus.pb-c.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_prometheus_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o write_prometheus_la-prometheus.pb-c.lo `test -f 'prometheus.pb-c.c' || echo '$(srcdir)/'`prometheus.pb-c.c
+
 write_redis_la-write_redis.lo: write_redis.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_redis_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write_redis_la-write_redis.lo -MD -MP -MF $(DEPDIR)/write_redis_la-write_redis.Tpo -c -o write_redis_la-write_redis.lo `test -f 'write_redis.c' || echo '$(srcdir)/'`write_redis.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/write_redis_la-write_redis.Tpo $(DEPDIR)/write_redis_la-write_redis.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='write_redis.c' object='write_redis_la-write_redis.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(write_redis_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o write_redis_la-write_redis.lo `test -f 'write_redis.c' || echo '$(srcdir)/'`write_redis.c
@@ -5238,12 +5393,19 @@
 	log_list=`for i in $$bases; do echo $$i.log; done`; \
 	log_list=`echo $$log_list`; \
 	$(MAKE) $(AM_MAKEFLAGS) $(TEST_SUITE_LOG) \
 	        am__force_recheck=am--force-recheck \
 	        TEST_LOGS="$$log_list"; \
 	exit $$?
+test_format_graphite.log: test_format_graphite$(EXEEXT)
+	@p='test_format_graphite$(EXEEXT)'; \
+	b='test_format_graphite'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
 test_format_json.log: test_format_json$(EXEEXT)
 	@p='test_format_json$(EXEEXT)'; \
 	b='test_format_json'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
@@ -5252,12 +5414,19 @@
 	@p='test_utils_latency$(EXEEXT)'; \
 	b='test_utils_latency'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
 	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test_utils_cmds.log: test_utils_cmds$(EXEEXT)
+	@p='test_utils_cmds$(EXEEXT)'; \
+	b='test_utils_cmds'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
 test_utils_vl_lookup.log: test_utils_vl_lookup$(EXEEXT)
 	@p='test_utils_vl_lookup$(EXEEXT)'; \
 	b='test_utils_vl_lookup'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
@@ -5523,12 +5692,15 @@
 		echo "$@ has some POD errors!"; false; \
 	fi
 
 @BUILD_PLUGIN_PINBA_TRUE@pinba.pb-c.c pinba.pb-c.h: pinba.proto
 @BUILD_PLUGIN_PINBA_TRUE@	$(AM_V_PROTOC_C)$(PROTOC_C) -I$(srcdir) --c_out . $(srcdir)/pinba.proto
 
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@prometheus.pb-c.c prometheus.pb-c.h: $(top_srcdir)/proto/prometheus.proto
+@BUILD_PLUGIN_WRITE_PROMETHEUS_TRUE@	$(AM_V_PROTOC_C)$(PROTOC_C) -I$(top_srcdir)/proto --c_out=$(builddir) $(top_srcdir)/proto/prometheus.proto
+
 install-exec-hook:
 	$(mkinstalldirs) $(DESTDIR)$(sysconfdir)
 	if test -e $(DESTDIR)$(sysconfdir)/collectd.conf; \
 	then \
 		$(INSTALL) -m 0640 collectd.conf $(DESTDIR)$(sysconfdir)/collectd.conf.pkg-orig; \
 	else \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/match_regex.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/match_regex.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/match_regex.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/match_regex.c	2016-12-12 16:03:36.712279086 +0800
@@ -30,13 +30,16 @@
  * This module allows to filter and rewrite value lists based on
  * Perl-compatible regular expressions.
  */
 
 #include "collectd.h"
 
+#include "common.h"
 #include "filter_chain.h"
+#include "meta_data.h"
+#include "utils_llist.h"
 
 #include <regex.h>
 #include <sys/types.h>
 
 #define log_err(...) ERROR("`regex' match: " __VA_ARGS__)
 #define log_warn(...) WARNING("`regex' match: " __VA_ARGS__)
@@ -59,12 +62,13 @@
 struct mr_match_s {
   mr_regex_t *host;
   mr_regex_t *plugin;
   mr_regex_t *plugin_instance;
   mr_regex_t *type;
   mr_regex_t *type_instance;
+  llist_t *meta; /* Maps each meta key into mr_regex_t* */
   _Bool invert;
 };
 
 /*
  * internal helper functions
  */
@@ -72,13 +76,13 @@
 {
   if (r == NULL)
     return;
 
   regfree(&r->re);
   memset(&r->re, 0, sizeof(r->re));
-  free(r->re_str);
+  sfree(r->re_str);
 
   if (r->next != NULL)
     mr_free_regex(r->next);
 } /* }}} void mr_free_regex */
 
 static void mr_free_match(mr_match_t *m) /* {{{ */
@@ -88,14 +92,19 @@
 
   mr_free_regex(m->host);
   mr_free_regex(m->plugin);
   mr_free_regex(m->plugin_instance);
   mr_free_regex(m->type);
   mr_free_regex(m->type_instance);
+  for (llentry_t *e = llist_head(m->meta); e != NULL; e = e->next) {
+    sfree(e->key);
+    mr_free_regex((mr_regex_t *)e->value);
+  }
+  llist_destroy(m->meta);
 
-  free(m);
+  sfree(m);
 } /* }}} void mr_free_match */
 
 static int mr_match_regexen(mr_regex_t *re_head, /* {{{ */
                             const char *string) {
   if (re_head == NULL)
     return (FC_MATCH_MATCHES);
@@ -116,45 +125,40 @@
     }
   }
 
   return (FC_MATCH_MATCHES);
 } /* }}} int mr_match_regexen */
 
-static int mr_config_add_regex(mr_regex_t **re_head, /* {{{ */
-                               oconfig_item_t *ci) {
+static int mr_add_regex(mr_regex_t **re_head, const char *re_str, /* {{{ */
+                        const char *option) {
   mr_regex_t *re;
   int status;
 
-  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING)) {
-    log_warn("`%s' needs exactly one string argument.", ci->key);
-    return (-1);
-  }
-
   re = calloc(1, sizeof(*re));
   if (re == NULL) {
-    log_err("mr_config_add_regex: calloc failed.");
+    log_err("mr_add_regex: calloc failed.");
     return (-1);
   }
   re->next = NULL;
 
-  re->re_str = strdup(ci->values[0].value.string);
+  re->re_str = strdup(re_str);
   if (re->re_str == NULL) {
-    free(re);
-    log_err("mr_config_add_regex: strdup failed.");
+    sfree(re);
+    log_err("mr_add_regex: strdup failed.");
     return (-1);
   }
 
   status = regcomp(&re->re, re->re_str, REG_EXTENDED | REG_NOSUB);
   if (status != 0) {
     char errmsg[1024];
     regerror(status, &re->re, errmsg, sizeof(errmsg));
     errmsg[sizeof(errmsg) - 1] = 0;
-    log_err("Compiling regex `%s' for `%s' failed: %s.", re->re_str, ci->key,
+    log_err("Compiling regex `%s' for `%s' failed: %s.", re->re_str, option,
             errmsg);
-    free(re->re_str);
-    free(re);
+    sfree(re->re_str);
+    sfree(re);
     return (-1);
   }
 
   if (*re_head == NULL) {
     *re_head = re;
   } else {
@@ -165,14 +169,74 @@
       ptr = ptr->next;
 
     ptr->next = re;
   }
 
   return (0);
+} /* }}} int mr_add_regex */
+
+static int mr_config_add_regex(mr_regex_t **re_head, /* {{{ */
+                               oconfig_item_t *ci) {
+  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING)) {
+    log_warn("`%s' needs exactly one string argument.", ci->key);
+    return (-1);
+  }
+
+  return mr_add_regex(re_head, ci->values[0].value.string, ci->key);
 } /* }}} int mr_config_add_regex */
 
+static int mr_config_add_meta_regex(llist_t **meta, /* {{{ */
+                                    oconfig_item_t *ci) {
+  char *meta_key;
+  llentry_t *entry;
+  mr_regex_t *re_head;
+  int status;
+  char buffer[1024];
+
+  if ((ci->values_num != 2) || (ci->values[0].type != OCONFIG_TYPE_STRING) ||
+      (ci->values[1].type != OCONFIG_TYPE_STRING)) {
+    log_warn("`%s' needs exactly two string arguments.", ci->key);
+    return (-1);
+  }
+
+  if (*meta == NULL) {
+    *meta = llist_create();
+    if (*meta == NULL) {
+      log_err("mr_config_add_meta_regex: llist_create failed.");
+      return (-1);
+    }
+  }
+
+  meta_key = ci->values[0].value.string;
+  entry = llist_search(*meta, meta_key);
+  if (entry == NULL) {
+    meta_key = strdup(meta_key);
+    if (meta_key == NULL) {
+      log_err("mr_config_add_meta_regex: strdup failed.");
+      return (-1);
+    }
+    entry = llentry_create(meta_key, NULL);
+    if (entry == NULL) {
+      log_err("mr_config_add_meta_regex: llentry_create failed.");
+      sfree(meta_key);
+      return (-1);
+    }
+    /* meta_key and entry will now be freed by mr_free_match(). */
+    llist_append(*meta, entry);
+  }
+
+  ssnprintf(buffer, sizeof(buffer), "%s `%s'", ci->key, meta_key);
+  /* Can't pass &entry->value into mr_add_regex, so copy in/out. */
+  re_head = entry->value;
+  status = mr_add_regex(&re_head, ci->values[1].value.string, buffer);
+  if (status == 0) {
+    entry->value = re_head;
+  }
+  return status;
+} /* }}} int mr_config_add_meta_regex */
+
 static int mr_create(const oconfig_item_t *ci, void **user_data) /* {{{ */
 {
   mr_match_t *m;
   int status;
 
   m = calloc(1, sizeof(*m));
@@ -195,12 +259,14 @@
     else if (strcasecmp("PluginInstance", child->key) == 0)
       status = mr_config_add_regex(&m->plugin_instance, child);
     else if (strcasecmp("Type", child->key) == 0)
       status = mr_config_add_regex(&m->type, child);
     else if (strcasecmp("TypeInstance", child->key) == 0)
       status = mr_config_add_regex(&m->type_instance, child);
+    else if (strcasecmp("MetaData", child->key) == 0)
+      status = mr_config_add_meta_regex(&m->meta, child);
     else if (strcasecmp("Invert", child->key) == 0)
       status = cf_util_get_boolean(child, &m->invert);
     else {
       log_err("The `%s' configuration option is not understood and "
               "will be ignored.",
               child->key);
@@ -212,13 +278,13 @@
   }
 
   /* Additional sanity-checking */
   while (status == 0) {
     if ((m->host == NULL) && (m->plugin == NULL) &&
         (m->plugin_instance == NULL) && (m->type == NULL) &&
-        (m->type_instance == NULL)) {
+        (m->type_instance == NULL) && (m->meta == NULL)) {
       log_err("No (valid) regular expressions have been configured. "
               "This match will be ignored.");
       status = -1;
     }
 
     break;
@@ -267,12 +333,28 @@
     return (nomatch_value);
   if (mr_match_regexen(m->type, vl->type) == FC_MATCH_NO_MATCH)
     return (nomatch_value);
   if (mr_match_regexen(m->type_instance, vl->type_instance) ==
       FC_MATCH_NO_MATCH)
     return (nomatch_value);
+  if (vl->meta != NULL) {
+    for (llentry_t *e = llist_head(m->meta); e != NULL; e = e->next) {
+      mr_regex_t *meta_re = (mr_regex_t *)e->value;
+      char *value;
+      int status = meta_data_get_string(vl->meta, e->key, &value);
+      if (status == (-ENOENT)) /* key is not present */
+        return (nomatch_value);
+      if (status != 0) /* some other problem */
+        continue;      /* error will have already been printed. */
+      if (mr_match_regexen(meta_re, value) == FC_MATCH_NO_MATCH) {
+        sfree(value);
+        return (nomatch_value);
+      }
+      sfree(value);
+    }
+  }
 
   return (match_value);
 } /* }}} int mr_match */
 
 void module_register(void) {
   match_proc_t mproc = {0};
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/mbmon.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/mbmon.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/mbmon.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/mbmon.c	2016-12-12 16:03:36.712279086 +0800
@@ -188,20 +188,16 @@
 
   return (0);
 }
 
 static void mbmon_submit(const char *type, const char *type_instance,
                          double value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "mbmon", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void mbmon_submit */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/md.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/md.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/md.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/md.c	2016-12-12 16:03:36.712279086 +0800
@@ -58,20 +58,16 @@
 
   return (0);
 }
 
 static void md_submit(const int minor, const char *type_instance,
                       gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "md", sizeof(vl.plugin));
   ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%i", minor);
   sstrncpy(vl.type, "md_disks", sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/memcachec.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/memcachec.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/memcachec.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/memcachec.c	2016-12-12 16:03:36.712279086 +0800
@@ -399,21 +399,17 @@
     return (-1);
   }
   return (0);
 } /* }}} int cmc_init */
 
 static void cmc_submit(const web_page_t *wp, const web_match_t *wm, /* {{{ */
-                       const cu_match_value_t *mv) {
-  value_t values[1];
+                       value_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0] = mv->value;
-
-  vl.values = values;
+  vl.values = &value;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "memcachec", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, wp->instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, wm->type, sizeof(vl.type));
   sstrncpy(vl.type_instance, wm->instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
@@ -449,13 +445,13 @@
     mv = match_get_user_data(wm->match);
     if (mv == NULL) {
       WARNING("memcachec plugin: match_get_user_data returned NULL.");
       continue;
     }
 
-    cmc_submit(wp, wm, mv);
+    cmc_submit(wp, wm, mv->value);
     match_value_reset(mv);
   } /* for (wm = wp->matches; wm != NULL; wm = wm->next) */
 
   sfree(wp->buffer);
 
   return (0);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/memcached.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/memcached.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/memcached.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/memcached.c	2016-12-12 16:03:36.712279086 +0800
@@ -40,29 +40,31 @@
 
 #define MEMCACHED_DEF_HOST "127.0.0.1"
 #define MEMCACHED_DEF_PORT "11211"
 
 struct memcached_s {
   char *name;
-  char *socket;
   char *host;
-  char *port;
+  char *socket;
+  char *connhost;
+  char *connport;
 };
 typedef struct memcached_s memcached_t;
 
 static _Bool memcached_have_instances = 0;
 
 static void memcached_free(void *arg) {
   memcached_t *st = arg;
   if (st == NULL)
     return;
 
   sfree(st->name);
-  sfree(st->socket);
   sfree(st->host);
-  sfree(st->port);
+  sfree(st->socket);
+  sfree(st->connhost);
+  sfree(st->connport);
   sfree(st);
 }
 
 static int memcached_connect_unix(memcached_t *st) {
   struct sockaddr_un serv_addr = {0};
   int fd;
@@ -88,32 +90,26 @@
   }
 
   return (fd);
 } /* int memcached_connect_unix */
 
 static int memcached_connect_inet(memcached_t *st) {
-  const char *host;
-  const char *port;
-
   struct addrinfo *ai_list;
   int status;
   int fd = -1;
 
-  host = (st->host != NULL) ? st->host : MEMCACHED_DEF_HOST;
-  port = (st->port != NULL) ? st->port : MEMCACHED_DEF_PORT;
-
   struct addrinfo ai_hints = {.ai_family = AF_UNSPEC,
                               .ai_flags = AI_ADDRCONFIG,
                               .ai_socktype = SOCK_STREAM};
 
-  status = getaddrinfo(host, port, &ai_hints, &ai_list);
+  status = getaddrinfo(st->connhost, st->connport, &ai_hints, &ai_list);
   if (status != 0) {
     char errbuf[1024];
     ERROR("memcached plugin: memcached_connect_inet: "
           "getaddrinfo(%s,%s) failed: %s",
-          host, port,
+          st->connhost, st->connport,
           (status == EAI_SYSTEM) ? sstrerror(errno, errbuf, sizeof(errbuf))
                                  : gai_strerror(status));
     return (-1);
   }
 
   for (struct addrinfo *ai_ptr = ai_list; ai_ptr != NULL;
@@ -217,93 +213,74 @@
   shutdown(fd, SHUT_RDWR);
   close(fd);
   return (status);
 } /* int memcached_query_daemon */
 
 static void memcached_init_vl(value_list_t *vl, memcached_t const *st) {
-  char const *host = st->host;
-
-  /* Set vl->host to hostname_g, if:
-   * - Legacy mode is used.
-   * - "Socket" option is given (doc: "Host option is ignored").
-   * - "Host" option is not provided.
-   * - "Host" option is set to "localhost" or "127.0.0.1". */
-  if ((strcmp(st->name, "__legacy__") == 0) || (st->socket != NULL) ||
-      (st->host == NULL) || (strcmp("127.0.0.1", st->host) == 0) ||
-      (strcmp("localhost", st->host) == 0))
-    host = hostname_g;
-
   sstrncpy(vl->plugin, "memcached", sizeof(vl->plugin));
-  sstrncpy(vl->host, host, sizeof(vl->host));
-  if (strcmp(st->name, "__legacy__") != 0)
+  if (st->host != NULL)
+    sstrncpy(vl->host, st->host, sizeof(vl->host));
+  if (st->name != NULL)
     sstrncpy(vl->plugin_instance, st->name, sizeof(vl->plugin_instance));
 }
 
 static void submit_derive(const char *type, const char *type_inst,
                           derive_t value, memcached_t *st) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
-  memcached_init_vl(&vl, st);
 
-  values[0].derive = value;
-
-  vl.values = values;
+  memcached_init_vl(&vl, st);
+  vl.values = &(value_t){.derive = value};
   vl.values_len = 1;
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_inst != NULL)
     sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
 static void submit_derive2(const char *type, const char *type_inst,
                            derive_t value0, derive_t value1, memcached_t *st) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-  memcached_init_vl(&vl, st);
-
-  values[0].derive = value0;
-  values[1].derive = value1;
+  value_t values[] = {
+      {.derive = value0}, {.derive = value1},
+  };
 
+  memcached_init_vl(&vl, st);
   vl.values = values;
-  vl.values_len = 2;
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_inst != NULL)
     sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
 static void submit_gauge(const char *type, const char *type_inst, gauge_t value,
                          memcached_t *st) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
-  memcached_init_vl(&vl, st);
-
-  values[0].gauge = value;
 
-  vl.values = values;
+  memcached_init_vl(&vl, st);
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_inst != NULL)
     sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
 static void submit_gauge2(const char *type, const char *type_inst,
                           gauge_t value0, gauge_t value1, memcached_t *st) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-  memcached_init_vl(&vl, st);
-
-  values[0].gauge = value0;
-  values[1].gauge = value1;
+  value_t values[] = {
+      {.gauge = value0}, {.gauge = value1},
+  };
 
+  memcached_init_vl(&vl, st);
   vl.values = values;
-  vl.values_len = 2;
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_inst != NULL)
     sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
@@ -491,29 +468,67 @@
 } /* int memcached_read */
 
 static int memcached_add_read_callback(memcached_t *st) {
   char callback_name[3 * DATA_MAX_NAME_LEN];
   int status;
 
-  assert(st->name != NULL);
-  ssnprintf(callback_name, sizeof(callback_name), "memcached/%s", st->name);
+  ssnprintf(callback_name, sizeof(callback_name), "memcached/%s",
+            (st->name != NULL) ? st->name : "__legacy__");
+
+  /* If no <Address> used then:
+   * - Connect to the destination specified by <Host>, if present.
+   *   If not, use the default address.
+   * - Use the default hostname (set st->host to NULL), if
+   *    - Legacy mode is used (no configuration options at all), or
+   *    - "Host" option is not provided, or
+   *    - "Host" option is set to "localhost" or "127.0.0.1".
+   *
+   * If <Address> used then host may be set to "localhost" or "127.0.0.1"
+   * explicitly.
+   */
+  if (st->connhost == NULL) {
+    if (st->host) {
+      st->connhost = strdup(st->host);
+      if (st->connhost == NULL)
+        return (ENOMEM);
+
+      if ((strcmp("127.0.0.1", st->host) == 0) ||
+          (strcmp("localhost", st->host) == 0))
+        sfree(st->host);
+    } else {
+      st->connhost = strdup(MEMCACHED_DEF_HOST);
+      if (st->connhost == NULL)
+        return (ENOMEM);
+    }
+  }
 
-  user_data_t ud = {.data = st, .free_func = memcached_free};
+  if (st->connport == NULL) {
+    st->connport = strdup(MEMCACHED_DEF_PORT);
+    if (st->connport == NULL)
+      return (ENOMEM);
+  }
+
+  assert(st->connhost != NULL);
+  assert(st->connport != NULL);
+
+  status = plugin_register_complex_read(
+      /* group = */ "memcached",
+      /* name      = */ callback_name,
+      /* callback  = */ memcached_read,
+      /* interval  = */ 0, &(user_data_t){
+                               .data = st, .free_func = memcached_free,
+                           });
 
-  status = plugin_register_complex_read(/* group = */ "memcached",
-                                        /* name      = */ callback_name,
-                                        /* callback  = */ memcached_read,
-                                        /* interval  = */ 0,
-                                        /* user_data = */ &ud);
   return (status);
 } /* int memcached_add_read_callback */
 
 /* Configuration handling functiions
  * <Plugin memcached>
  *   <Instance "instance_name">
  *     Host foo.zomg.com
+ *     Address 1.2.3.4
  *     Port "1234"
  *   </Instance>
  * </Plugin>
  */
 static int config_add_instance(oconfig_item_t *ci) {
   memcached_t *st;
@@ -522,39 +537,40 @@
   /* Disable automatic generation of default instance in the init callback. */
   memcached_have_instances = 1;
 
   st = calloc(1, sizeof(*st));
   if (st == NULL) {
     ERROR("memcached plugin: calloc failed.");
-    return (-1);
+    return (ENOMEM);
   }
 
   st->name = NULL;
-  st->socket = NULL;
   st->host = NULL;
-  st->port = NULL;
+  st->socket = NULL;
+  st->connhost = NULL;
+  st->connport = NULL;
 
-  if (strcasecmp(ci->key, "Plugin") == 0) /* default instance */
-    st->name = sstrdup("__legacy__");
-  else /* <Instance /> block */
+  if (strcasecmp(ci->key, "Instance") == 0)
     status = cf_util_get_string(ci, &st->name);
+
   if (status != 0) {
     sfree(st);
     return (status);
   }
-  assert(st->name != NULL);
 
   for (int i = 0; i < ci->children_num; i++) {
     oconfig_item_t *child = ci->children + i;
 
     if (strcasecmp("Socket", child->key) == 0)
       status = cf_util_get_string(child, &st->socket);
     else if (strcasecmp("Host", child->key) == 0)
       status = cf_util_get_string(child, &st->host);
+    else if (strcasecmp("Address", child->key) == 0)
+      status = cf_util_get_string(child, &st->connhost);
     else if (strcasecmp("Port", child->key) == 0)
-      status = cf_util_get_service(child, &st->port);
+      status = cf_util_get_service(child, &st->connport);
     else {
       WARNING("memcached plugin: Option `%s' not allowed here.", child->key);
       status = -1;
     }
 
     if (status != 0)
@@ -605,16 +621,17 @@
     return (0);
 
   /* No instances were configured, lets start a default instance. */
   st = calloc(1, sizeof(*st));
   if (st == NULL)
     return (ENOMEM);
-  st->name = sstrdup("__legacy__");
-  st->socket = NULL;
+  st->name = NULL;
   st->host = NULL;
-  st->port = NULL;
+  st->socket = NULL;
+  st->connhost = NULL;
+  st->connport = NULL;
 
   status = memcached_add_read_callback(st);
   if (status == 0)
     memcached_have_instances = 1;
   else
     memcached_free(st);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/memory.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/memory.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/memory.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/memory.c	2016-12-12 16:03:36.712279086 +0800
@@ -480,13 +480,12 @@
 {
   value_t v[1];
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = v;
   vl.values_len = STATIC_ARRAY_SIZE(v);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "memory", sizeof(vl.plugin));
   sstrncpy(vl.type, "memory", sizeof(vl.type));
   vl.time = cdtime();
 
   return (memory_read_internal(&vl));
 } /* }}} int memory_read */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/mic.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/mic.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/mic.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/mic.c	2016-12-12 16:03:36.712279086 +0800
@@ -118,25 +118,22 @@
     return (-1);
   }
   return (0);
 }
 
 static void mic_submit_memory_use(int micnumber, const char *type_instance,
-                                  U32 val) {
-  value_t values[1];
+                                  U32 value) {
   value_list_t vl = VALUE_LIST_INIT;
 
   /* MicAccessAPI reports KB's of memory, adjust for this */
-  DEBUG("mic plugin: Memory Value Report; %u %lf", val,
-        ((gauge_t)val) * 1024.0);
-  values[0].gauge = ((gauge_t)val) * 1024.0;
+  DEBUG("mic plugin: Memory Value Report; %u %lf", value,
+        ((gauge_t)value) * 1024.0);
 
-  vl.values = values;
+  vl.values = &(value_t){.gauge = ((gauge_t)value) * 1024.0};
   vl.values_len = 1;
 
-  strncpy(vl.host, hostname_g, sizeof(vl.host));
   strncpy(vl.plugin, "mic", sizeof(vl.plugin));
   ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%i", micnumber);
   strncpy(vl.type, "memory", sizeof(vl.type));
   strncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
@@ -157,19 +154,16 @@
   mic_submit_memory_use(mic, "used", mem_total - mem_free - mem_bufs);
   mic_submit_memory_use(mic, "buffered", mem_bufs);
   DEBUG("mic plugin: Memory Read: %u %u %u", mem_total, mem_free, mem_bufs);
   return (0);
 }
 
-static void mic_submit_temp(int micnumber, const char *type, gauge_t val) {
-  value_t values[1];
+static void mic_submit_temp(int micnumber, const char *type, gauge_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = val;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
   strncpy(vl.host, hostname_g, sizeof(vl.host));
   strncpy(vl.plugin, "mic", sizeof(vl.plugin));
   ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%i", micnumber);
   strncpy(vl.type, "temperature", sizeof(vl.type));
@@ -202,19 +196,16 @@
     mic_submit_temp(mic, name, temp_buffer);
   }
   return (0);
 }
 
 static void mic_submit_cpu(int micnumber, const char *type_instance, int core,
-                           derive_t val) {
-  value_t values[1];
+                           derive_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = val;
-
-  vl.values = values;
+  vl.values = &(value_t){.derive = value};
   vl.values_len = 1;
 
   strncpy(vl.host, hostname_g, sizeof(vl.host));
   strncpy(vl.plugin, "mic", sizeof(vl.plugin));
   if (core < 0) /* global aggregation */
     ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%i", micnumber);
@@ -259,19 +250,16 @@
     }
   }
   return (0);
 }
 
 static void mic_submit_power(int micnumber, const char *type,
-                             const char *type_instance, gauge_t val) {
-  value_t values[1];
+                             const char *type_instance, gauge_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = val;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
   strncpy(vl.host, hostname_g, sizeof(vl.host));
   strncpy(vl.plugin, "mic", sizeof(vl.plugin));
   ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%i", micnumber);
   strncpy(vl.type, type, sizeof(vl.type));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/modbus.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/modbus.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/modbus.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/modbus.c	2016-12-12 16:03:36.712279086 +0800
@@ -440,12 +440,14 @@
   else
     values_num = 1;
 
   if (host->connection == NULL) {
     status = EBADF;
   } else if (host->conntype == MBCONN_TCP) {
+    /* getpeername() is used only to determine if the socket is connected, not
+     * because we're really interested in the peer's IP address. */
     if (getpeername(modbus_get_socket(host->connection),
                     (void *)&(struct sockaddr_storage){0},
                     &(socklen_t){sizeof(struct sockaddr_storage)}) != 0)
       status = errno;
   }
 
@@ -927,23 +929,22 @@
           "options.",
           host->host);
     status = -1;
   }
 
   if (status == 0) {
-    user_data_t ud;
     char name[1024];
 
-    ud.data = host;
-    ud.free_func = host_free;
-
     ssnprintf(name, sizeof(name), "modbus-%s", host->host);
 
     plugin_register_complex_read(/* group = */ NULL, name,
                                  /* callback = */ mb_read,
-                                 /* interval = */ host->interval, &ud);
+                                 /* interval = */ host->interval,
+                                 &(user_data_t){
+                                     .data = host, .free_func = host_free,
+                                 });
   } else {
     host_free(host);
   }
 
   return (status);
 } /* }}} int mb_config_add_host */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/mqtt.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/mqtt.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/mqtt.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/mqtt.c	2016-12-12 16:03:36.716279058 +0800
@@ -445,13 +445,12 @@
                    ? sstrerror(errno, errbuf, sizeof(errbuf))
                    : mosquitto_strerror(status));
     /* Mark our connection "down" regardless of the error as a safety
      * measure; we will try to reconnect the next time we have to publish a
      * message */
     conf->connected = 0;
-    mosquitto_disconnect(conf->mosq);
 
     pthread_mutex_unlock(&conf->lock);
     return (-1);
   }
 
   pthread_mutex_unlock(&conf->lock);
@@ -459,29 +458,24 @@
 } /* int publish */
 
 static int format_topic(char *buf, size_t buf_len, data_set_t const *ds,
                         value_list_t const *vl, mqtt_client_conf_t *conf) {
   char name[MQTT_MAX_TOPIC_SIZE];
   int status;
-  char *c;
 
   if ((conf->topic_prefix == NULL) || (conf->topic_prefix[0] == 0))
     return (FORMAT_VL(buf, buf_len, vl));
 
   status = FORMAT_VL(name, sizeof(name), vl);
   if (status != 0)
     return (status);
 
   status = ssnprintf(buf, buf_len, "%s/%s", conf->topic_prefix, name);
   if ((status < 0) || (((size_t)status) >= buf_len))
     return (ENOMEM);
 
-  while((c = strchr(buf, '#')) || (c = strchr(buf, '+'))) {
-       *c = '_';
-  }
-
   return (0);
 } /* int format_topic */
 
 static int mqtt_write(const data_set_t *ds, const value_list_t *vl,
                       user_data_t *user_data) {
   mqtt_client_conf_t *conf;
@@ -606,15 +600,15 @@
       cf_util_get_string(child, &conf->ciphersuite);
     else
       ERROR("mqtt plugin: Unknown config option: %s", child->key);
   }
 
   ssnprintf(cb_name, sizeof(cb_name), "mqtt/%s", conf->name);
-  user_data_t user_data = {.data = conf};
-
-  plugin_register_write(cb_name, mqtt_write, &user_data);
+  plugin_register_write(cb_name, mqtt_write, &(user_data_t){
+                                                 .data = conf,
+                                             });
   return (0);
 } /* mqtt_config_publisher */
 
 /*
  * <Subscribe "name">
  *   Host "example.com"
@@ -737,13 +731,14 @@
     if (subscribers[i]->loop)
       continue;
 
     status = plugin_thread_create(&subscribers[i]->thread,
                                   /* attrs = */ NULL,
                                   /* func  = */ subscribers_thread,
-                                  /* args  = */ subscribers[i]);
+                                  /* args  = */ subscribers[i],
+                                  /* name  = */ "mqtt");
     if (status != 0) {
       char errbuf[1024];
       ERROR("mqtt plugin: pthread_create failed: %s",
             sstrerror(errno, errbuf, sizeof(errbuf)));
       continue;
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/multimeter.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/multimeter.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/multimeter.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/multimeter.c	2016-12-12 16:03:36.716279058 +0800
@@ -182,20 +182,16 @@
   ERROR("multimeter plugin: No device found");
   return (-1);
 }
 #undef LINE_LENGTH
 
 static void multimeter_submit(double value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "multimeter", sizeof(vl.plugin));
   sstrncpy(vl.type, "multimeter", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/mysql.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/mysql.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/mysql.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/mysql.c	2016-12-12 16:03:36.716279058 +0800
@@ -219,16 +219,17 @@
 
     if (db->instance != NULL)
       ssnprintf(cb_name, sizeof(cb_name), "mysql-%s", db->instance);
     else
       sstrncpy(cb_name, "mysql", sizeof(cb_name));
 
-    user_data_t ud = {.data = db, .free_func = mysql_database_free};
-
-    plugin_register_complex_read(/* group = */ NULL, cb_name, mysql_read,
-                                 /* interval = */ 0, &ud);
+    plugin_register_complex_read(
+        /* group = */ NULL, cb_name, mysql_read, /* interval = */ 0,
+        &(user_data_t){
+            .data = db, .free_func = mysql_database_free,
+        });
   } else {
     mysql_database_free(db);
     return (-1);
   }
 
   return (0);
@@ -334,41 +335,26 @@
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* submit */
 
-static void counter_submit(const char *type, const char *type_instance,
-                           derive_t value, mysql_database_t *db) {
-  value_t values[1];
-
-  values[0].derive = value;
-  submit(type, type_instance, values, STATIC_ARRAY_SIZE(values), db);
-} /* void counter_submit */
-
 static void gauge_submit(const char *type, const char *type_instance,
                          gauge_t value, mysql_database_t *db) {
-  value_t values[1];
-
-  values[0].gauge = value;
-  submit(type, type_instance, values, STATIC_ARRAY_SIZE(values), db);
+  submit(type, type_instance, &(value_t){.gauge = value}, 1, db);
 } /* void gauge_submit */
 
 static void derive_submit(const char *type, const char *type_instance,
                           derive_t value, mysql_database_t *db) {
-  value_t values[1];
-
-  values[0].derive = value;
-  submit(type, type_instance, values, STATIC_ARRAY_SIZE(values), db);
+  submit(type, type_instance, &(value_t){.derive = value}, 1, db);
 } /* void derive_submit */
 
 static void traffic_submit(derive_t rx, derive_t tx, mysql_database_t *db) {
-  value_t values[2];
-
-  values[0].derive = rx;
-  values[1].derive = tx;
+  value_t values[] = {
+      {.derive = rx}, {.derive = tx},
+  };
 
   submit("mysql_octets", NULL, values, STATIC_ARRAY_SIZE(values), db);
 } /* void traffic_submit */
 
 static MYSQL_RES *exec_query(MYSQL *con, const char *query) {
   MYSQL_RES *res;
@@ -421,13 +407,13 @@
           query);
     mysql_free_result(res);
     return (-1);
   }
 
   position = atoll(row[1]);
-  counter_submit("mysql_log_position", "master-bin", position, db);
+  derive_submit("mysql_log_position", "master-bin", position, db);
 
   row = mysql_fetch_row(res);
   if (row != NULL)
     WARNING("mysql plugin: `%s' returned more than one row - "
             "ignoring further results.",
             query);
@@ -478,16 +464,16 @@
 
   if (db->slave_stats) {
     unsigned long long counter;
     double gauge;
 
     counter = atoll(row[READ_MASTER_LOG_POS_IDX]);
-    counter_submit("mysql_log_position", "slave-read", counter, db);
+    derive_submit("mysql_log_position", "slave-read", counter, db);
 
     counter = atoll(row[EXEC_MASTER_LOG_POS_IDX]);
-    counter_submit("mysql_log_position", "slave-exec", counter, db);
+    derive_submit("mysql_log_position", "slave-exec", counter, db);
 
     if (row[SECONDS_BEHIND_MASTER_IDX] != NULL) {
       gauge = atof(row[SECONDS_BEHIND_MASTER_IDX]);
       gauge_submit("time_offset", NULL, gauge, db);
     }
   }
@@ -620,13 +606,13 @@
 
     if (metrics[i].key == NULL)
       continue;
 
     switch (metrics[i].ds_type) {
     case DS_TYPE_COUNTER:
-      counter_submit(metrics[i].type, key, (counter_t)val, db);
+      derive_submit(metrics[i].type, key, (counter_t)val, db);
       break;
     case DS_TYPE_GAUGE:
       gauge_submit(metrics[i].type, key, (gauge_t)val, db);
       break;
     case DS_TYPE_DERIVE:
       derive_submit(metrics[i].type, key, (derive_t)val, db);
@@ -776,18 +762,18 @@
     if (strncmp(key, "Com_", strlen("Com_")) == 0) {
       if (val == 0ULL)
         continue;
 
       /* Ignore `prepared statements' */
       if (strncmp(key, "Com_stmt_", strlen("Com_stmt_")) != 0)
-        counter_submit("mysql_commands", key + strlen("Com_"), val, db);
+        derive_submit("mysql_commands", key + strlen("Com_"), val, db);
     } else if (strncmp(key, "Handler_", strlen("Handler_")) == 0) {
       if (val == 0ULL)
         continue;
 
-      counter_submit("mysql_handler", key + strlen("Handler_"), val, db);
+      derive_submit("mysql_handler", key + strlen("Handler_"), val, db);
     } else if (strncmp(key, "Qcache_", strlen("Qcache_")) == 0) {
       if (strcmp(key, "Qcache_hits") == 0)
         qcache_hits = (derive_t)val;
       else if (strcmp(key, "Qcache_inserts") == 0)
         qcache_inserts = (derive_t)val;
       else if (strcmp(key, "Qcache_not_cached") == 0)
@@ -808,116 +794,116 @@
         threads_connected = (gauge_t)val;
       else if (strcmp(key, "Threads_cached") == 0)
         threads_cached = (gauge_t)val;
       else if (strcmp(key, "Threads_created") == 0)
         threads_created = (derive_t)val;
     } else if (strncmp(key, "Table_locks_", strlen("Table_locks_")) == 0) {
-      counter_submit("mysql_locks", key + strlen("Table_locks_"), val, db);
+      derive_submit("mysql_locks", key + strlen("Table_locks_"), val, db);
     } else if (db->innodb_stats &&
                strncmp(key, "Innodb_", strlen("Innodb_")) == 0) {
       /* buffer pool */
       if (strcmp(key, "Innodb_buffer_pool_pages_data") == 0)
         gauge_submit("mysql_bpool_pages", "data", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_pages_dirty") == 0)
         gauge_submit("mysql_bpool_pages", "dirty", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_pages_flushed") == 0)
-        counter_submit("mysql_bpool_counters", "pages_flushed", val, db);
+        derive_submit("mysql_bpool_counters", "pages_flushed", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_pages_free") == 0)
         gauge_submit("mysql_bpool_pages", "free", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_pages_misc") == 0)
         gauge_submit("mysql_bpool_pages", "misc", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_pages_total") == 0)
         gauge_submit("mysql_bpool_pages", "total", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_read_ahead_rnd") == 0)
-        counter_submit("mysql_bpool_counters", "read_ahead_rnd", val, db);
+        derive_submit("mysql_bpool_counters", "read_ahead_rnd", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_read_ahead") == 0)
-        counter_submit("mysql_bpool_counters", "read_ahead", val, db);
+        derive_submit("mysql_bpool_counters", "read_ahead", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_read_ahead_evicted") == 0)
-        counter_submit("mysql_bpool_counters", "read_ahead_evicted", val, db);
+        derive_submit("mysql_bpool_counters", "read_ahead_evicted", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_read_requests") == 0)
-        counter_submit("mysql_bpool_counters", "read_requests", val, db);
+        derive_submit("mysql_bpool_counters", "read_requests", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_reads") == 0)
-        counter_submit("mysql_bpool_counters", "reads", val, db);
+        derive_submit("mysql_bpool_counters", "reads", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_wait_free") == 0)
-        counter_submit("mysql_bpool_counters", "wait_free", val, db);
+        derive_submit("mysql_bpool_counters", "wait_free", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_write_requests") == 0)
-        counter_submit("mysql_bpool_counters", "write_requests", val, db);
+        derive_submit("mysql_bpool_counters", "write_requests", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_bytes_data") == 0)
         gauge_submit("mysql_bpool_bytes", "data", val, db);
       else if (strcmp(key, "Innodb_buffer_pool_bytes_dirty") == 0)
         gauge_submit("mysql_bpool_bytes", "dirty", val, db);
 
       /* data */
       if (strcmp(key, "Innodb_data_fsyncs") == 0)
-        counter_submit("mysql_innodb_data", "fsyncs", val, db);
+        derive_submit("mysql_innodb_data", "fsyncs", val, db);
       else if (strcmp(key, "Innodb_data_read") == 0)
-        counter_submit("mysql_innodb_data", "read", val, db);
+        derive_submit("mysql_innodb_data", "read", val, db);
       else if (strcmp(key, "Innodb_data_reads") == 0)
-        counter_submit("mysql_innodb_data", "reads", val, db);
+        derive_submit("mysql_innodb_data", "reads", val, db);
       else if (strcmp(key, "Innodb_data_writes") == 0)
-        counter_submit("mysql_innodb_data", "writes", val, db);
+        derive_submit("mysql_innodb_data", "writes", val, db);
       else if (strcmp(key, "Innodb_data_written") == 0)
-        counter_submit("mysql_innodb_data", "written", val, db);
+        derive_submit("mysql_innodb_data", "written", val, db);
 
       /* double write */
       else if (strcmp(key, "Innodb_dblwr_writes") == 0)
-        counter_submit("mysql_innodb_dblwr", "writes", val, db);
+        derive_submit("mysql_innodb_dblwr", "writes", val, db);
       else if (strcmp(key, "Innodb_dblwr_pages_written") == 0)
-        counter_submit("mysql_innodb_dblwr", "written", val, db);
+        derive_submit("mysql_innodb_dblwr", "written", val, db);
       else if (strcmp(key, "Innodb_dblwr_page_size") == 0)
         gauge_submit("mysql_innodb_dblwr", "page_size", val, db);
 
       /* log */
       else if (strcmp(key, "Innodb_log_waits") == 0)
-        counter_submit("mysql_innodb_log", "waits", val, db);
+        derive_submit("mysql_innodb_log", "waits", val, db);
       else if (strcmp(key, "Innodb_log_write_requests") == 0)
-        counter_submit("mysql_innodb_log", "write_requests", val, db);
+        derive_submit("mysql_innodb_log", "write_requests", val, db);
       else if (strcmp(key, "Innodb_log_writes") == 0)
-        counter_submit("mysql_innodb_log", "writes", val, db);
+        derive_submit("mysql_innodb_log", "writes", val, db);
       else if (strcmp(key, "Innodb_os_log_fsyncs") == 0)
-        counter_submit("mysql_innodb_log", "fsyncs", val, db);
+        derive_submit("mysql_innodb_log", "fsyncs", val, db);
       else if (strcmp(key, "Innodb_os_log_written") == 0)
-        counter_submit("mysql_innodb_log", "written", val, db);
+        derive_submit("mysql_innodb_log", "written", val, db);
 
       /* pages */
       else if (strcmp(key, "Innodb_pages_created") == 0)
-        counter_submit("mysql_innodb_pages", "created", val, db);
+        derive_submit("mysql_innodb_pages", "created", val, db);
       else if (strcmp(key, "Innodb_pages_read") == 0)
-        counter_submit("mysql_innodb_pages", "read", val, db);
+        derive_submit("mysql_innodb_pages", "read", val, db);
       else if (strcmp(key, "Innodb_pages_written") == 0)
-        counter_submit("mysql_innodb_pages", "written", val, db);
+        derive_submit("mysql_innodb_pages", "written", val, db);
 
       /* row lock */
       else if (strcmp(key, "Innodb_row_lock_time") == 0)
-        counter_submit("mysql_innodb_row_lock", "time", val, db);
+        derive_submit("mysql_innodb_row_lock", "time", val, db);
       else if (strcmp(key, "Innodb_row_lock_waits") == 0)
-        counter_submit("mysql_innodb_row_lock", "waits", val, db);
+        derive_submit("mysql_innodb_row_lock", "waits", val, db);
 
       /* rows */
       else if (strcmp(key, "Innodb_rows_deleted") == 0)
-        counter_submit("mysql_innodb_rows", "deleted", val, db);
+        derive_submit("mysql_innodb_rows", "deleted", val, db);
       else if (strcmp(key, "Innodb_rows_inserted") == 0)
-        counter_submit("mysql_innodb_rows", "inserted", val, db);
+        derive_submit("mysql_innodb_rows", "inserted", val, db);
       else if (strcmp(key, "Innodb_rows_read") == 0)
-        counter_submit("mysql_innodb_rows", "read", val, db);
+        derive_submit("mysql_innodb_rows", "read", val, db);
       else if (strcmp(key, "Innodb_rows_updated") == 0)
-        counter_submit("mysql_innodb_rows", "updated", val, db);
+        derive_submit("mysql_innodb_rows", "updated", val, db);
     } else if (strncmp(key, "Select_", strlen("Select_")) == 0) {
-      counter_submit("mysql_select", key + strlen("Select_"), val, db);
+      derive_submit("mysql_select", key + strlen("Select_"), val, db);
     } else if (strncmp(key, "Sort_", strlen("Sort_")) == 0) {
       if (strcmp(key, "Sort_merge_passes") == 0)
-        counter_submit("mysql_sort_merge_passes", NULL, val, db);
+        derive_submit("mysql_sort_merge_passes", NULL, val, db);
       else if (strcmp(key, "Sort_rows") == 0)
-        counter_submit("mysql_sort_rows", NULL, val, db);
+        derive_submit("mysql_sort_rows", NULL, val, db);
       else if (strcmp(key, "Sort_range") == 0)
-        counter_submit("mysql_sort", "range", val, db);
+        derive_submit("mysql_sort", "range", val, db);
       else if (strcmp(key, "Sort_scan") == 0)
-        counter_submit("mysql_sort", "scan", val, db);
+        derive_submit("mysql_sort", "scan", val, db);
 
     } else if (strncmp(key, "Slow_queries", strlen("Slow_queries")) == 0) {
-      counter_submit("mysql_slow_queries", NULL, val, db);
+      derive_submit("mysql_slow_queries", NULL, val, db);
     }
   }
   mysql_free_result(res);
   res = NULL;
 
   if ((qcache_hits != 0) || (qcache_inserts != 0) || (qcache_not_cached != 0) ||
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/netapp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/netapp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/netapp.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/netapp.c	2016-12-12 16:03:36.716279058 +0800
@@ -608,14 +608,15 @@
  *
  * They all eventually call "submit_values" which creates a value_list_t and
  * dispatches it to the daemon.
  */
 static int submit_values(const char *host, /* {{{ */
                          const char *plugin_inst, const char *type,
-                         const char *type_inst, value_t *values, int values_len,
-                         cdtime_t timestamp, cdtime_t interval) {
+                         const char *type_inst, value_t *values,
+                         size_t values_len, cdtime_t timestamp,
+                         cdtime_t interval) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = values;
   vl.values_len = values_len;
 
   if (timestamp > 0)
@@ -623,14 +624,12 @@
 
   if (interval > 0)
     vl.interval = interval;
 
   if (host != NULL)
     sstrncpy(vl.host, host, sizeof(vl.host));
-  else
-    sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "netapp", sizeof(vl.plugin));
   if (plugin_inst != NULL)
     sstrncpy(vl.plugin_instance, plugin_inst, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_inst != NULL)
     sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
@@ -640,76 +639,64 @@
 
 static int submit_two_derive(const char *host,
                              const char *plugin_inst, /* {{{ */
                              const char *type, const char *type_inst,
                              derive_t val0, derive_t val1, cdtime_t timestamp,
                              cdtime_t interval) {
-  value_t values[2];
-
-  values[0].derive = val0;
-  values[1].derive = val1;
+  value_t values[] = {
+      {.derive = val0}, {.derive = val1},
+  };
 
-  return (submit_values(host, plugin_inst, type, type_inst, values, 2,
-                        timestamp, interval));
+  return (submit_values(host, plugin_inst, type, type_inst, values,
+                        STATIC_ARRAY_SIZE(values), timestamp, interval));
 } /* }}} int submit_two_derive */
 
 static int submit_derive(const char *host, const char *plugin_inst, /* {{{ */
                          const char *type, const char *type_inst,
                          derive_t counter, cdtime_t timestamp,
                          cdtime_t interval) {
-  value_t v;
-
-  v.derive = counter;
-
-  return (submit_values(host, plugin_inst, type, type_inst, &v, 1, timestamp,
-                        interval));
+  return (submit_values(host, plugin_inst, type, type_inst,
+                        &(value_t){.derive = counter}, 1, timestamp, interval));
 } /* }}} int submit_derive */
 
 static int submit_two_gauge(const char *host, const char *plugin_inst, /* {{{ */
                             const char *type, const char *type_inst,
                             gauge_t val0, gauge_t val1, cdtime_t timestamp,
                             cdtime_t interval) {
-  value_t values[2];
+  value_t values[] = {
+      {.gauge = val0}, {.gauge = val1},
+  };
 
-  values[0].gauge = val0;
-  values[1].gauge = val1;
-
-  return (submit_values(host, plugin_inst, type, type_inst, values, 2,
-                        timestamp, interval));
+  return (submit_values(host, plugin_inst, type, type_inst, values,
+                        STATIC_ARRAY_SIZE(values), timestamp, interval));
 } /* }}} int submit_two_gauge */
 
 static int submit_double(const char *host, const char *plugin_inst, /* {{{ */
                          const char *type, const char *type_inst, double d,
                          cdtime_t timestamp, cdtime_t interval) {
-  value_t v;
-
-  v.gauge = (gauge_t)d;
-
-  return (submit_values(host, plugin_inst, type, type_inst, &v, 1, timestamp,
-                        interval));
+  return (submit_values(host, plugin_inst, type, type_inst,
+                        &(value_t){.gauge = counter}, 1, timestamp, interval));
 } /* }}} int submit_uint64 */
 
 /* Calculate hit ratio from old and new counters and submit the resulting
  * percentage. Used by "submit_wafl_data". */
 static int submit_cache_ratio(const char *host, /* {{{ */
                               const char *plugin_inst, const char *type_inst,
                               uint64_t new_hits, uint64_t new_misses,
                               uint64_t old_hits, uint64_t old_misses,
                               cdtime_t timestamp, cdtime_t interval) {
-  value_t v;
+  value_t v = {.gauge = NAN};
 
   if ((new_hits >= old_hits) && (new_misses >= old_misses)) {
     uint64_t hits;
     uint64_t misses;
 
     hits = new_hits - old_hits;
     misses = new_misses - old_misses;
 
     v.gauge = 100.0 * ((gauge_t)hits) / ((gauge_t)(hits + misses));
-  } else {
-    v.gauge = NAN;
   }
 
   return (submit_values(host, plugin_inst, "cache_ratio", type_inst, &v, 1,
                         timestamp, interval));
 } /* }}} int submit_cache_ratio */
 
@@ -2831,19 +2818,19 @@
   if (host->vfiler)
     ssnprintf(cb_name, sizeof(cb_name), "netapp-%s-%s", host->name,
               host->vfiler);
   else
     ssnprintf(cb_name, sizeof(cb_name), "netapp-%s", host->name);
 
-  user_data_t ud = {.data = host,
-                    .free_func = (void (*)(void *))free_host_config};
-
-  plugin_register_complex_read(/* group = */ NULL, cb_name,
-                               /* callback  = */ cna_read,
-                               /* interval  = */ host->interval,
-                               /* user data = */ &ud);
+  plugin_register_complex_read(
+      /* group = */ NULL, cb_name,
+      /* callback  = */ cna_read,
+      /* interval  = */ host->interval,
+      &(user_data_t){
+          .data = host, .free_func = (void *)free_host_config,
+      });
 
   return (0);
 } /* }}} int cna_register_host */
 
 static int cna_config_host(host_config_t *host, /* {{{ */
                            const oconfig_item_t *ci) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/netlink.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/netlink.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/netlink.c	2017-10-06 14:45:52.957917762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/netlink.c	2016-12-12 16:03:36.716279058 +0800
@@ -171,41 +171,35 @@
 
   return (ir_ignorelist_invert);
 } /* int check_ignorelist */
 
 static void submit_one(const char *dev, const char *type,
                        const char *type_instance, derive_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.derive = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "netlink", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, dev, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void submit_one */
 
 static void submit_two(const char *dev, const char *type,
                        const char *type_instance, derive_t rx, derive_t tx) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = rx;
-  values[1].derive = tx;
+  value_t values[] = {
+      {.derive = rx}, {.derive = tx},
+  };
 
   vl.values = values;
-  vl.values_len = 2;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "netlink", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, dev, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/network.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/network.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/network.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/network.c	2016-12-12 16:03:36.716279058 +0800
@@ -289,13 +289,13 @@
 
 /* Buffer in which to-be-sent network packets are constructed. */
 static char *send_buffer;
 static char *send_buffer_ptr;
 static int send_buffer_fill;
 static cdtime_t send_buffer_last_update;
-static value_list_t send_buffer_vl = VALUE_LIST_STATIC;
+static value_list_t send_buffer_vl = VALUE_LIST_INIT;
 static pthread_mutex_t send_buffer_lock = PTHREAD_MUTEX_INITIALIZER;
 
 /* XXX: These counters are incremented from one place only. The spot in which
  * the values are incremented is either only reachable by one thread (the
  * dispatch thread, for example) or locked by some lock (send_buffer_lock for
  * example). Only if neither is true, the stats_lock is acquired. The counters
@@ -1000,12 +1000,20 @@
   unsigned char *hash_ptr;
 
   buffer = *ret_buffer;
   buffer_len = *ret_buffer_len;
   buffer_offset = 0;
 
+  if (se->data.server.userdb == NULL) {
+    c_complain(
+        LOG_NOTICE, &complain_no_users,
+        "network plugin: Received signed network packet but can't verify it "
+        "because no user DB has been configured. Will accept it.");
+    return (0);
+  }
+
   /* Check if the buffer has enough data for this structure. */
   if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)
     return (-ENOMEM);
 
   /* Read type and length header */
   BUFFER_READ(&pss.head.type, sizeof(pss.head.type));
@@ -1016,24 +1024,12 @@
   if ((pss_head_length <= PART_SIGNATURE_SHA256_SIZE) ||
       (pss_head_length > buffer_len)) {
     ERROR("network plugin: HMAC-SHA-256 with invalid length received.");
     return (-1);
   }
 
-  if (se->data.server.userdb == NULL) {
-    c_complain(
-        LOG_NOTICE, &complain_no_users,
-        "network plugin: Received signed network packet but can't verify it "
-        "because no user DB has been configured. Will accept it.");
-
-    *ret_buffer = buffer + pss_head_length;
-    *ret_buffer_len -= pss_head_length;
-
-    return (0);
-  }
-
   /* Copy the hash. */
   BUFFER_READ(pss.hash, sizeof(pss.hash));
 
   /* Calculate username length (without null byte) and allocate memory */
   username_len = pss_head_length - PART_SIGNATURE_SHA256_SIZE;
   pss.username = malloc(username_len + 1);
@@ -1227,15 +1223,15 @@
 
   /* Decrypt the packet in-place */
   err = gcry_cipher_decrypt(cypher, buffer + buffer_offset,
                             part_size - buffer_offset,
                             /* in = */ NULL, /* in len = */ 0);
   if (err != 0) {
+    sfree(pea.username);
     ERROR("network plugin: gcry_cipher_decrypt returned: %s. Username: %s",
           gcry_strerror(err), pea.username);
-    sfree(pea.username);
     return (-1);
   }
 
   /* Read the hash */
   BUFFER_READ(pea.hash, sizeof(pea.hash));
 
@@ -1251,12 +1247,14 @@
     return (-1);
   }
 
   parse_packet(se, buffer + buffer_offset, payload_len, flags | PP_ENCRYPTED,
                pea.username);
 
+  /* XXX: Free pea.username?!? */
+
   /* Update return values */
   *ret_buffer = buffer + part_size;
   *ret_buffer_len = buffer_len - part_size;
 
   sfree(pea.username);
 
@@ -3081,13 +3079,12 @@
   copy_receive_list_length = receive_list_length;
 
   /* Initialize `vl' */
   vl.values = values;
   vl.values_len = 2;
   vl.time = 0;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "network", sizeof(vl.plugin));
 
   /* Octets received / sent */
   vl.values[0].derive = (derive_t)copy_octets_rx;
   vl.values[1].derive = (derive_t)copy_octets_tx;
   sstrncpy(vl.type, "if_octets", sizeof(vl.type));
@@ -3162,26 +3159,28 @@
       ((dispatch_thread_running != 0) && (receive_thread_running != 0)))
     return (0);
 
   if (dispatch_thread_running == 0) {
     int status;
     status = plugin_thread_create(&dispatch_thread_id, NULL /* no attributes */,
-                                  dispatch_thread, NULL /* no argument */);
+                                  dispatch_thread, NULL /* no argument */,
+                                  "network disp");
     if (status != 0) {
       char errbuf[1024];
       ERROR("network: pthread_create failed: %s",
             sstrerror(errno, errbuf, sizeof(errbuf)));
     } else {
       dispatch_thread_running = 1;
     }
   }
 
   if (receive_thread_running == 0) {
     int status;
     status = plugin_thread_create(&receive_thread_id, NULL /* no attributes */,
-                                  receive_thread, NULL /* no argument */);
+                                  receive_thread, NULL /* no argument */,
+                                  "network recv");
     if (status != 0) {
       char errbuf[1024];
       ERROR("network: pthread_create failed: %s",
             sstrerror(errno, errbuf, sizeof(errbuf)));
     } else {
       receive_thread_running = 1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/nfs.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/nfs.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/nfs.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/nfs.c	2016-12-12 16:03:36.716279058 +0800
@@ -336,13 +336,12 @@
 static void nfs_procedures_submit(const char *plugin_instance,
                                   const char **type_instances, value_t *values,
                                   size_t values_num) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "nfs", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "nfs_procedure", sizeof(vl.type));
 
   for (size_t i = 0; i < values_num; i++) {
     vl.values = values + i;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/nginx.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/nginx.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/nginx.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/nginx.c	2016-12-12 16:03:36.716279058 +0800
@@ -130,12 +130,16 @@
     }
 
     curl_easy_setopt(curl, CURLOPT_USERPWD, credentials);
 #endif
   }
 
+  if (url != NULL) {
+    curl_easy_setopt(curl, CURLOPT_URL, url);
+  }
+
   curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
   curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 50L);
 
   if ((verify_peer == NULL) || IS_TRUE(verify_peer)) {
     curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
   } else {
@@ -175,16 +179,14 @@
   else if (strcmp(type, "connections") == 0)
     values[0].derive = value;
   else
     return;
 
   vl.values = values;
-  vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "nginx", sizeof(vl.plugin));
-  sstrncpy(vl.plugin_instance, "", sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   if (inst != NULL)
     sstrncpy(vl.type_instance, inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
@@ -202,15 +204,12 @@
   if (curl == NULL)
     return (-1);
   if (url == NULL)
     return (-1);
 
   nginx_buffer_len = 0;
-
-  curl_easy_setopt(curl, CURLOPT_URL, url);
-
   if (curl_easy_perform(curl) != CURLE_OK) {
     WARNING("nginx plugin: curl_easy_perform failed: %s", nginx_curl_error);
     return (-1);
   }
 
   ptr = nginx_buffer;
@@ -223,13 +222,13 @@
       break;
   }
 
   /*
    * Active connections: 291
    * server accepts handled requests
-   *  16630948 16630948 31070465
+   *  101059015 100422216 347910649
    * Reading: 6 Writing: 179 Waiting: 106
    */
   for (int i = 0; i < lines_num; i++) {
     fields_num =
         strsplit(lines[i], fields, (sizeof(fields) / sizeof(fields[0])));
 
@@ -237,13 +236,17 @@
       if ((strcmp(fields[0], "Active") == 0) &&
           (strcmp(fields[1], "connections:") == 0)) {
         submit("nginx_connections", "active", atoll(fields[2]));
       } else if ((atoll(fields[0]) != 0) && (atoll(fields[1]) != 0) &&
                  (atoll(fields[2]) != 0)) {
         submit("connections", "accepted", atoll(fields[0]));
+        /* TODO: The legacy metric "handled", which is the sum of "accepted" and
+         * "failed", is reported for backwards compatibility only. Remove in the
+         * next major version. */
         submit("connections", "handled", atoll(fields[1]));
+        submit("connections", "failed", (atoll(fields[0]) - atoll(fields[1])));
         submit("nginx_requests", NULL, atoll(fields[2]));
       }
     } else if (fields_num == 6) {
       if ((strcmp(fields[0], "Reading:") == 0) &&
           (strcmp(fields[2], "Writing:") == 0) &&
           (strcmp(fields[4], "Waiting:") == 0)) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/notify_email.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/notify_email.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/notify_email.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/notify_email.c	2016-12-12 16:03:36.716279058 +0800
@@ -201,13 +201,12 @@
 } /* int notify_email_config (const char *, const char *) */
 
 static int notify_email_notification(const notification_t *n,
                                      user_data_t __attribute__((unused)) *
                                          user_data) {
 
-  time_t tt;
   struct tm timestamp_tm;
   char timestamp_str[64];
 
   char severity[32];
   char subject[MAXSTRING];
 
@@ -223,14 +222,13 @@
                        : ((n->severity == NOTIF_OKAY) ? "OKAY" : "UNKNOWN")));
 
   ssnprintf(subject, sizeof(subject),
             (email_subject == NULL) ? DEFAULT_SMTP_SUBJECT : email_subject,
             severity, n->host);
 
-  tt = CDTIME_T_TO_TIME_T(n->time);
-  localtime_r(&tt, &timestamp_tm);
+  localtime_r(&CDTIME_T_TO_TIME_T(n->time), &timestamp_tm);
   strftime(timestamp_str, sizeof(timestamp_str), "%Y-%m-%d %H:%M:%S",
            &timestamp_tm);
   timestamp_str[sizeof(timestamp_str) - 1] = '\0';
 
   /* Let's make RFC822 message text with \r\n EOLs */
   ssnprintf(buf, buf_len, "MIME-Version: 1.0\r\n"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ntpd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ntpd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ntpd.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ntpd.c	2016-12-12 16:03:36.716279058 +0800
@@ -289,22 +289,17 @@
 
   return (0);
 }
 
 static void ntpd_submit(const char *type, const char *type_inst,
                         gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ntpd", sizeof(vl.plugin));
-  sstrncpy(vl.plugin_instance, "", sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
@@ -852,15 +847,15 @@
   if (ntohs(ik->status) & STA_NANO) {
     scale_loop = 1e-9;
     scale_error = 1e-9;
   }
 
   /* kerninfo -> estimated error */
-  offset_loop = (gauge_t)((int32_t)ntohl(ik->offset) * scale_loop);
+  offset_loop = scale_loop * ((gauge_t)ntohl(ik->offset));
   freq_loop = ntpd_read_fp(ik->freq);
-  offset_error = (gauge_t)((int32_t)ntohl(ik->esterror) * scale_error);
+  offset_error = scale_error * ((gauge_t)ntohl(ik->esterror));
 
   DEBUG("info_kernel:\n"
         "  pll offset    = %.8g\n"
         "  pll frequency = %.8g\n" /* drift compensation */
         "  est error     = %.8g\n",
         offset_loop, freq_loop, offset_error);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/numa.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/numa.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/numa.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/numa.c	2016-12-12 16:03:36.716279058 +0800
@@ -43,13 +43,12 @@
                                 const char *type_instance, value_t v) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = &v;
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "numa", sizeof(vl.plugin));
   ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "node%i", node);
   sstrncpy(vl.type, "vmpage_action", sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/nut.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/nut.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/nut.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/nut.c	2016-12-12 16:03:36.716279058 +0800
@@ -104,19 +104,16 @@
   else
     return (-1);
 } /* int nut_config */
 
 static void nut_submit(nut_ups_t *ups, const char *type,
                        const char *type_instance, gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
-  vl.values_len = STATIC_ARRAY_SIZE(values);
+  vl.values = &(value_t){.gauge = value};
+  vl.values_len = 1;
   sstrncpy(vl.host,
            (strcasecmp(ups->hostname, "localhost") == 0) ? hostname_g
                                                          : ups->hostname,
            sizeof(vl.host));
   sstrncpy(vl.plugin, "nut", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, ups->upsname, sizeof(vl.plugin_instance));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/olsrd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/olsrd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/olsrd.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/olsrd.c	2016-12-12 16:03:36.716279058 +0800
@@ -194,21 +194,17 @@
   return (fh);
 } /* }}} FILE *olsrd_connect */
 
 __attribute__((nonnull(2))) static void
 olsrd_submit(const char *plugin_instance, /* {{{ */
              const char *type, const char *type_instance, gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "olsrd", sizeof(vl.plugin));
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/onewire.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/onewire.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/onewire.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/onewire.c	2016-12-12 16:03:36.716279058 +0800
@@ -274,33 +274,29 @@
 
   return (0);
 }
 
 static int cow_read_values(const char *path, const char *name,
                            const ow_family_features_t *family_info) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
   int success = 0;
 
   if (sensor_list != NULL) {
     DEBUG("onewire plugin: Checking ignorelist for `%s'", name);
     if (ignorelist_match(sensor_list, name) != 0)
       return 0;
   }
 
-  vl.values = values;
-  vl.values_len = 1;
-
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "onewire", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, name, sizeof(vl.plugin_instance));
 
   for (size_t i = 0; i < family_info->features_num; i++) {
     char *buffer;
     size_t buffer_size;
     int status;
+    char errbuf[1024];
 
     char file[4096];
     char *endptr;
 
     snprintf(file, sizeof(file), "%s/%s", path,
              family_info->features[i].filename);
@@ -308,29 +304,33 @@
 
     buffer = NULL;
     buffer_size = 0;
     DEBUG("Start reading onewire device %s", file);
     status = OW_get(file, &buffer, &buffer_size);
     if (status < 0) {
-      ERROR("onewire plugin: OW_get (%s/%s) failed. status = %#x;", path,
-            family_info->features[i].filename, status);
+      ERROR("onewire plugin: OW_get (%s/%s) failed. error = %s;", path,
+            family_info->features[i].filename,
+            sstrerror(errno, errbuf, sizeof(errbuf)));
       return (-1);
     }
     DEBUG("Read onewire device %s as %s", file, buffer);
 
     endptr = NULL;
-    values[0].gauge = strtod(buffer, &endptr);
+    gauge_t g = strtod(buffer, &endptr);
     if (endptr == NULL) {
       ERROR("onewire plugin: Buffer is not a number: %s", buffer);
       continue;
     }
 
     sstrncpy(vl.type, family_info->features[i].type, sizeof(vl.type));
     sstrncpy(vl.type_instance, family_info->features[i].type_instance,
              sizeof(vl.type_instance));
 
+    vl.values = &(value_t){.gauge = g};
+    vl.values_len = 1;
+
     plugin_dispatch_values(&vl);
     success++;
 
     free(buffer);
   } /* for (i = 0; i < features_num; i++) */
 
@@ -362,21 +362,23 @@
 } /* int cow_read_ds2409 */
 
 static int cow_read_bus(const char *path) {
   char *buffer;
   size_t buffer_size;
   int status;
+  char errbuf[1024];
 
   char *buffer_ptr;
   char *dummy;
   char *saveptr;
   char subpath[4096];
 
   status = OW_get(path, &buffer, &buffer_size);
   if (status < 0) {
-    ERROR("onewire plugin: OW_get (%s) failed. status = %#x;", path, status);
+    ERROR("onewire plugin: OW_get (%s) failed. error = %s;", path,
+          sstrerror(errno, errbuf, sizeof(errbuf)));
     return (-1);
   }
   DEBUG("onewire plugin: OW_get (%s) returned: %s", path, buffer);
 
   dummy = buffer;
   saveptr = NULL;
@@ -417,48 +419,47 @@
 } /* int cow_read_bus */
 
 /* ===================================================================================
  */
 
 static int cow_simple_read(void) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
   char *buffer;
   size_t buffer_size;
   int status;
+  char errbuf[1024];
   char *endptr;
   direct_access_element_t *traverse;
 
   /* traverse list and check entries */
   for (traverse = direct_list; traverse != NULL; traverse = traverse->next) {
-    vl.values = values;
-    vl.values_len = 1;
-
-    sstrncpy(vl.host, hostname_g, sizeof(vl.host));
     sstrncpy(vl.plugin, "onewire", sizeof(vl.plugin));
     sstrncpy(vl.plugin_instance, traverse->address, sizeof(vl.plugin_instance));
 
     status = OW_get(traverse->path, &buffer, &buffer_size);
     if (status < 0) {
-      ERROR("onewire plugin: OW_get (%s) failed. status = %#x;", traverse->path,
-            status);
+      ERROR("onewire plugin: OW_get (%s) failed. status = %s;", traverse->path,
+            sstrerror(errno, errbuf, sizeof(errbuf)));
       return (-1);
     }
     DEBUG("onewire plugin: Read onewire device %s as %s", traverse->path,
           buffer);
 
     endptr = NULL;
-    values[0].gauge = strtod(buffer, &endptr);
+    gauge_t g = strtod(buffer, &endptr);
     if (endptr == NULL) {
       ERROR("onewire plugin: Buffer is not a number: %s", buffer);
       continue;
     }
 
     sstrncpy(vl.type, traverse->file, sizeof(vl.type));
     sstrncpy(vl.type_instance, "", sizeof(""));
 
+    vl.values = &(value_t){.gauge = g};
+    vl.values_len = 1;
+
     plugin_dispatch_values(&vl);
     free(buffer);
   } /* for (traverse) */
 
   return 0;
 } /* int cow_simple_read */
@@ -503,22 +504,24 @@
 
   return (0);
 } /* int cow_shutdown */
 
 static int cow_init(void) {
   int status;
+  char errbuf[1024];
 
   if (device_g == NULL) {
     ERROR("onewire plugin: cow_init: No device configured.");
     return (-1);
   }
 
   DEBUG("onewire plugin: about to init device <%s>.", device_g);
   status = (int)OW_init(device_g);
   if (status != 0) {
-    ERROR("onewire plugin: OW_init(%s) failed: %i.", device_g, status);
+    ERROR("onewire plugin: OW_init(%s) failed: %s.", device_g,
+          sstrerror(errno, errbuf, sizeof(errbuf)));
     return (1);
   }
 
   plugin_register_complex_read(/* group = */ NULL, "onewire", cow_read,
                                ow_interval, /* user data = */ NULL);
   plugin_register_shutdown("onewire", cow_shutdown);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/openldap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/openldap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/openldap.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/openldap.c	2016-12-12 16:03:36.716279058 +0800
@@ -89,14 +89,13 @@
   }
 
   rc = ldap_initialize(&ld, st->url);
   if (rc != LDAP_SUCCESS) {
     ERROR("openldap plugin: ldap_initialize failed: %s", ldap_err2string(rc));
     st->state = 0;
-    if (ld != NULL)
-      ldap_unbind_ext_s(ld, NULL, NULL);
+    ldap_unbind_ext_s(ld, NULL, NULL);
     return (-1);
   }
 
   st->ld = ld;
 
   ldap_set_option(st->ld, LDAP_OPT_PROTOCOL_VERSION, &st->version);
@@ -117,14 +116,13 @@
   if (st->starttls != 0) {
     rc = ldap_start_tls_s(ld, NULL, NULL);
     if (rc != LDAP_SUCCESS) {
       ERROR("openldap plugin: Failed to start tls on %s: %s", st->url,
             ldap_err2string(rc));
       st->state = 0;
-      if (st->ld != NULL)
-        ldap_unbind_ext_s(st->ld, NULL, NULL);
+      ldap_unbind_ext_s(st->ld, NULL, NULL);
       return (-1);
     }
   }
 
   struct berval cred;
   if (st->password != NULL) {
@@ -138,14 +136,13 @@
   rc = ldap_sasl_bind_s(st->ld, st->binddn, LDAP_SASL_SIMPLE, &cred, NULL, NULL,
                         NULL);
   if (rc != LDAP_SUCCESS) {
     ERROR("openldap plugin: Failed to bind to %s: %s", st->url,
           ldap_err2string(rc));
     st->state = 0;
-    if (st->ld != NULL)
-      ldap_unbind_ext_s(st->ld, NULL, NULL);
+    ldap_unbind_ext_s(st->ld, NULL, NULL);
     return (-1);
   } else {
     DEBUG("openldap plugin: Successfully connected to %s", st->url);
     st->state = 1;
     return (0);
   }
@@ -156,16 +153,13 @@
                                value_t value, cldap_t *st) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = &value;
   vl.values_len = 1;
 
-  if ((st->host == NULL) || (strcmp("", st->host) == 0) ||
-      (strcmp("localhost", st->host) == 0))
-    sstrncpy(vl.host, hostname_g, sizeof(vl.host));
-  else
+  if ((st->host != NULL) && (strcmp("localhost", st->host) != 0))
     sstrncpy(vl.host, st->host, sizeof(vl.host));
 
   sstrncpy(vl.plugin, "openldap", sizeof(vl.plugin));
   if (st->name != NULL)
     sstrncpy(vl.plugin_instance, st->name, sizeof(vl.plugin_instance));
 
@@ -176,23 +170,19 @@
   plugin_dispatch_values(&vl);
 } /* }}} void cldap_submit_value */
 
 static void cldap_submit_derive(const char *type,
                                 const char *type_instance, /* {{{ */
                                 derive_t d, cldap_t *st) {
-  value_t v;
-  v.derive = d;
-  cldap_submit_value(type, type_instance, v, st);
+  cldap_submit_value(type, type_instance, (value_t){.derive = d}, st);
 } /* }}} void cldap_submit_derive */
 
 static void cldap_submit_gauge(const char *type,
                                const char *type_instance, /* {{{ */
                                gauge_t g, cldap_t *st) {
-  value_t v;
-  v.gauge = g;
-  cldap_submit_value(type, type_instance, v, st);
+  cldap_submit_value(type, type_instance, (value_t){.gauge = g}, st);
 } /* }}} void cldap_submit_gauge */
 
 static int cldap_read_host(user_data_t *ud) /* {{{ */
 {
   cldap_t *st;
   LDAPMessage *result;
@@ -221,14 +211,13 @@
                          NULL, 0, &result);
 
   if (rc != LDAP_SUCCESS) {
     ERROR("openldap plugin: Failed to execute search: %s", ldap_err2string(rc));
     ldap_msgfree(result);
     st->state = 0;
-    if (st->ld != NULL)
-      ldap_unbind_ext_s(st->ld, NULL, NULL);
+    ldap_unbind_ext_s(st->ld, NULL, NULL);
     return (-1);
   }
 
   for (LDAPMessage *e = ldap_first_entry(st->ld, result); e != NULL;
        e = ldap_next_entry(st->ld, e)) {
     if ((dn = ldap_get_dn(st->ld, e)) != NULL) {
@@ -411,13 +400,13 @@
   if (status != 0) {
     sfree(st);
     return (status);
   }
 
   st->starttls = 0;
-  st->timeout = (long)(CDTIME_T_TO_MS(plugin_get_interval()) / 1000);
+  st->timeout = (long)CDTIME_T_TO_TIME_T(plugin_get_interval());
   st->verifyhost = 1;
   st->version = LDAP_VERSION3;
 
   for (int i = 0; i < ci->children_num; i++) {
     oconfig_item_t *child = ci->children + i;
 
@@ -488,19 +477,18 @@
       databases_num++;
 
       ssnprintf(callback_name, sizeof(callback_name), "openldap/%s/%s",
                 (st->host != NULL) ? st->host : hostname_g,
                 (st->name != NULL) ? st->name : "default");
 
-      user_data_t ud = {.data = st};
-
       status = plugin_register_complex_read(/* group = */ NULL,
                                             /* name      = */ callback_name,
                                             /* callback  = */ cldap_read_host,
-                                            /* interval  = */ 0,
-                                            /* user_data = */ &ud);
+                                            /* interval  = */ 0, &(user_data_t){
+                                                                     .data = st,
+                                                                 });
     }
   }
 
   if (status != 0) {
     cldap_free(st);
     return (-1);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/openvpn.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/openvpn.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/openvpn.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/openvpn.c	2016-12-12 16:03:36.716279058 +0800
@@ -91,20 +91,16 @@
   return (i);
 } /* int openvpn_strsplit */
 
 /* dispatches number of users */
 static void numusers_submit(const char *pinst, const char *tinst,
                             gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
-  vl.values_len = STATIC_ARRAY_SIZE(values);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values = &(value_t){.gauge = value};
+  vl.values_len = 1;
   sstrncpy(vl.plugin, "openvpn", sizeof(vl.plugin));
   sstrncpy(vl.type, "users", sizeof(vl.type));
   if (pinst != NULL)
     sstrncpy(vl.plugin_instance, pinst, sizeof(vl.plugin_instance));
   if (tinst != NULL)
     sstrncpy(vl.type_instance, tinst, sizeof(vl.type_instance));
@@ -113,27 +109,25 @@
 } /* void numusers_submit */
 
 /* dispatches stats about traffic (TCP or UDP) generated by the tunnel
  * per single endpoint */
 static void iostats_submit(const char *pinst, const char *tinst, derive_t rx,
                            derive_t tx) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = rx;
-  values[1].derive = tx;
+  value_t values[] = {
+      {.derive = rx}, {.derive = tx},
+  };
 
   /* NOTE ON THE NEW NAMING SCHEMA:
    *       using plugin_instance to identify each vpn config (and
    *       status) file; using type_instance to identify the endpoint
    *       host when in multimode, traffic or overhead when in single.
    */
 
   vl.values = values;
   vl.values_len = STATIC_ARRAY_SIZE(values);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "openvpn", sizeof(vl.plugin));
   if (pinst != NULL)
     sstrncpy(vl.plugin_instance, pinst, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "if_octets", sizeof(vl.type));
   if (tinst != NULL)
     sstrncpy(vl.type_instance, tinst, sizeof(vl.type_instance));
@@ -141,21 +135,19 @@
   plugin_dispatch_values(&vl);
 } /* void traffic_submit */
 
 /* dispatches stats about data compression shown when in single mode */
 static void compression_submit(const char *pinst, const char *tinst,
                                derive_t uncompressed, derive_t compressed) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = uncompressed;
-  values[1].derive = compressed;
+  value_t values[] = {
+      {.derive = uncompressed}, {.derive = compressed},
+  };
 
   vl.values = values;
   vl.values_len = STATIC_ARRAY_SIZE(values);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "openvpn", sizeof(vl.plugin));
   if (pinst != NULL)
     sstrncpy(vl.plugin_instance, pinst, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "compression", sizeof(vl.type));
   if (tinst != NULL)
     sstrncpy(vl.type_instance, tinst, sizeof(vl.type_instance));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/perl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/perl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/perl.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/perl.c	2016-12-12 16:03:36.716279058 +0800
@@ -19,12 +19,13 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  *
  * Authors:
  *   Sebastian Harl <sh at tokkee.org>
+ *   Pavel Rochnyak <pavel2000 ngs.ru>
  **/
 
 /*
  * This plugin embeds a Perl interpreter into collectd and provides an
  * interface for collectd plugins written in perl.
  */
@@ -74,14 +75,15 @@
 #define PLUGIN_READ 1
 #define PLUGIN_WRITE 2
 #define PLUGIN_SHUTDOWN 3
 #define PLUGIN_LOG 4
 #define PLUGIN_NOTIF 5
 #define PLUGIN_FLUSH 6
+#define PLUGIN_FLUSH_ALL 7 /* For collectd-5.6 only */
 
-#define PLUGIN_TYPES 7
+#define PLUGIN_TYPES 8
 
 #define PLUGIN_CONFIG 254
 #define PLUGIN_DATASET 255
 
 #define FC_MATCH 0
 #define FC_TARGET 1
@@ -99,23 +101,41 @@
 #define log_warn(...) WARNING("perl: " __VA_ARGS__)
 #define log_err(...) ERROR("perl: " __VA_ARGS__)
 
 /* this is defined in DynaLoader.a */
 void boot_DynaLoader(PerlInterpreter *, CV *);
 
+static XS(Collectd_plugin_register_read);
+static XS(Collectd_plugin_register_write);
+static XS(Collectd_plugin_register_log);
+static XS(Collectd_plugin_register_notification);
+static XS(Collectd_plugin_register_flush);
+static XS(Collectd_plugin_unregister_read);
+static XS(Collectd_plugin_unregister_write);
+static XS(Collectd_plugin_unregister_log);
+static XS(Collectd_plugin_unregister_notification);
+static XS(Collectd_plugin_unregister_flush);
 static XS(Collectd_plugin_register_ds);
 static XS(Collectd_plugin_unregister_ds);
 static XS(Collectd_plugin_dispatch_values);
 static XS(Collectd_plugin_get_interval);
 static XS(Collectd__plugin_write);
 static XS(Collectd__plugin_flush);
 static XS(Collectd_plugin_dispatch_notification);
 static XS(Collectd_plugin_log);
 static XS(Collectd__fc_register);
 static XS(Collectd_call_by_name);
 
+static int perl_read(user_data_t *ud);
+static int perl_write(const data_set_t *ds, const value_list_t *vl,
+                      user_data_t *user_data);
+static void perl_log(int level, const char *msg, user_data_t *user_data);
+static int perl_notify(const notification_t *notif, user_data_t *user_data);
+static int perl_flush(cdtime_t timeout, const char *identifier,
+                      user_data_t *user_data);
+
 /*
  * private data types
  */
 
 typedef struct c_ithread_s {
   /* the thread's Perl interpreter */
@@ -162,12 +182,14 @@
 extern char **environ;
 
 /*
  * private variables
  */
 
+static _Bool register_legacy_flush = 1;
+
 /* if perl_threads != NULL perl_threads->head must
  * point to the "base" thread */
 static c_ithread_list_t *perl_threads = NULL;
 
 /* the key used to store each pthread's ithread */
 static pthread_key_t perl_thr_key;
@@ -178,12 +200,24 @@
 static char base_name[DATA_MAX_NAME_LEN] = "";
 
 static struct {
   char name[64];
   XS((*f));
 } api[] = {
+    {"Collectd::plugin_register_read", Collectd_plugin_register_read},
+    {"Collectd::plugin_register_write", Collectd_plugin_register_write},
+    {"Collectd::plugin_register_log", Collectd_plugin_register_log},
+    {"Collectd::plugin_register_notification",
+     Collectd_plugin_register_notification},
+    {"Collectd::plugin_register_flush", Collectd_plugin_register_flush},
+    {"Collectd::plugin_unregister_read", Collectd_plugin_unregister_read},
+    {"Collectd::plugin_unregister_write", Collectd_plugin_unregister_write},
+    {"Collectd::plugin_unregister_log", Collectd_plugin_unregister_log},
+    {"Collectd::plugin_unregister_notification",
+     Collectd_plugin_unregister_notification},
+    {"Collectd::plugin_unregister_flush", Collectd_plugin_unregister_flush},
     {"Collectd::plugin_register_data_set", Collectd_plugin_register_ds},
     {"Collectd::plugin_unregister_data_set", Collectd_plugin_unregister_ds},
     {"Collectd::plugin_dispatch_values", Collectd_plugin_dispatch_values},
     {"Collectd::plugin_get_interval", Collectd_plugin_get_interval},
     {"Collectd::_plugin_write", Collectd__plugin_write},
     {"Collectd::_plugin_flush", Collectd__plugin_flush},
@@ -459,74 +493,66 @@
  *   type     => $type,
  *   plugin_instance => $instance,
  *   type_instance   => $type_instance,
  *   meta     => [ { name => <name>, value => <value> }, ... ]
  * }
  */
-static int av2notification_meta(pTHX_ AV *array, notification_meta_t **ret_meta) {
-  notification_meta_t *tail = NULL;
+static int av2notification_meta(pTHX_ AV *array, notification_meta_t **meta) {
+  notification_meta_t **m = meta;
 
   int len = av_len(array);
 
   for (int i = 0; i <= len; ++i) {
     SV **tmp = av_fetch(array, i, 0);
+    HV *hash;
 
-    if (tmp == NULL)
+    if (NULL == tmp)
       return -1;
 
     if (!(SvROK(*tmp) && (SVt_PVHV == SvTYPE(SvRV(*tmp))))) {
       log_warn("av2notification_meta: Skipping invalid "
                "meta information.");
       continue;
     }
 
-    HV *hash = (HV *)SvRV(*tmp);
+    hash = (HV *)SvRV(*tmp);
 
-    notification_meta_t *m = calloc(1, sizeof(*m));
-    if (m == NULL)
-      return ENOMEM;
+    *m = smalloc(sizeof(**m));
 
-    SV **name = hv_fetch(hash, "name", strlen("name"), 0);
-    if (name == NULL) {
+    if (NULL == (tmp = hv_fetch(hash, "name", 4, 0))) {
       log_warn("av2notification_meta: Skipping invalid "
                "meta information.");
-      sfree(m);
+      free(*m);
       continue;
     }
-    sstrncpy(m->name, SvPV_nolen(*name), sizeof(m->name));
+    sstrncpy((*m)->name, SvPV_nolen(*tmp), sizeof((*m)->name));
 
-    SV **value = hv_fetch(hash, "value", strlen("value"), 0);
-    if (value == NULL) {
+    if (NULL == (tmp = hv_fetch(hash, "value", 5, 0))) {
       log_warn("av2notification_meta: Skipping invalid "
                "meta information.");
-      sfree(m);
+      free(*m);
       continue;
     }
 
-    if (SvNOK(*value)) {
-      m->nm_value.nm_double = SvNVX(*value);
-      m->type = NM_TYPE_DOUBLE;
-    } else if (SvUOK(*value)) {
-      m->nm_value.nm_unsigned_int = SvUVX(*value);
-      m->type = NM_TYPE_UNSIGNED_INT;
-    } else if (SvIOK(*value)) {
-      m->nm_value.nm_signed_int = SvIVX(*value);
-      m->type = NM_TYPE_SIGNED_INT;
+    if (SvNOK(*tmp)) {
+      (*m)->nm_value.nm_double = SvNVX(*tmp);
+      (*m)->type = NM_TYPE_DOUBLE;
+    } else if (SvUOK(*tmp)) {
+      (*m)->nm_value.nm_unsigned_int = SvUVX(*tmp);
+      (*m)->type = NM_TYPE_UNSIGNED_INT;
+    } else if (SvIOK(*tmp)) {
+      (*m)->nm_value.nm_signed_int = SvIVX(*tmp);
+      (*m)->type = NM_TYPE_SIGNED_INT;
     } else {
-      m->nm_value.nm_string = sstrdup(SvPV_nolen(*value));
-      m->type = NM_TYPE_STRING;
+      (*m)->nm_value.nm_string = sstrdup(SvPV_nolen(*tmp));
+      (*m)->type = NM_TYPE_STRING;
     }
 
-    m->next = NULL;
-    if (tail == NULL)
-      *ret_meta = m;
-    else
-      tail->next = m;
-    tail = m;
+    (*m)->next = NULL;
+    m = &((*m)->next);
   }
-
   return 0;
 } /* static int av2notification_meta (AV *, notification_meta_t *) */
 
 static int hv2notification(pTHX_ HV *hash, notification_t *n) {
   SV **tmp = NULL;
 
@@ -970,26 +996,27 @@
 
   if (t->shutdown) {
     t->running = old_running;
     return 0;
   }
 
-  ret = call_pv(sub_name, G_SCALAR);
+  ret = call_pv(sub_name, G_SCALAR | G_EVAL);
 
   t->running = old_running;
   return ret;
 } /* static int call_pv_locked (pTHX, *sub_name) */
 
 /*
  * Call all working functions of the given type.
  */
-static int pplugin_call_all(pTHX_ int type, ...) {
+static int pplugin_call(pTHX_ int type, ...) {
   int retvals = 0;
 
   va_list ap;
   int ret = 0;
+  char *subname;
 
   dSP;
 
   if ((type < 0) || (type >= PLUGIN_TYPES))
     return -1;
 
@@ -997,15 +1024,22 @@
 
   ENTER;
   SAVETMPS;
 
   PUSHMARK(SP);
 
-  XPUSHs(sv_2mortal(newSViv((IV)type)));
+  if (PLUGIN_READ == type) {
+    subname = va_arg(ap, char *);
+  } else if (PLUGIN_WRITE == type) {
+    data_set_t *ds;
+    value_list_t *vl;
 
-  if (PLUGIN_WRITE == type) {
+    AV *pds = newAV();
+    HV *pvl = newHV();
+
+    subname = va_arg(ap, char *);
     /*
      * $_[0] = $plugin_type;
      *
      * $_[1] =
      * [
      *   {
@@ -1025,18 +1059,12 @@
      *   plugin => $plugin,
      *   type   => $type,
      *   plugin_instance => $instance,
      *   type_instance   => $type_instance
      * };
      */
-    data_set_t *ds;
-    value_list_t *vl;
-
-    AV *pds = newAV();
-    HV *pvl = newHV();
-
     ds = va_arg(ap, data_set_t *);
     vl = va_arg(ap, value_list_t *);
 
     if (-1 == data_set2av(aTHX_ ds, pds)) {
       av_clear(pds);
       av_undef(pds);
@@ -1052,20 +1080,25 @@
     }
 
     XPUSHs(sv_2mortal(newSVpv(ds->type, 0)));
     XPUSHs(sv_2mortal(newRV_noinc((SV *)pds)));
     XPUSHs(sv_2mortal(newRV_noinc((SV *)pvl)));
   } else if (PLUGIN_LOG == type) {
+    subname = va_arg(ap, char *);
     /*
      * $_[0] = $level;
      *
      * $_[1] = $message;
      */
     XPUSHs(sv_2mortal(newSViv(va_arg(ap, int))));
     XPUSHs(sv_2mortal(newSVpv(va_arg(ap, char *), 0)));
   } else if (PLUGIN_NOTIF == type) {
+    notification_t *n;
+    HV *notif = newHV();
+
+    subname = va_arg(ap, char *);
     /*
      * $_[0] =
      * {
      *   severity => $severity,
      *   time     => $time,
      *   message  => $msg,
@@ -1073,56 +1106,78 @@
      *   plugin   => $plugin,
      *   type     => $type,
      *   plugin_instance => $instance,
      *   type_instance   => $type_instance
      * };
      */
-    notification_t *n;
-    HV *notif = newHV();
-
     n = va_arg(ap, notification_t *);
 
     if (-1 == notification2hv(aTHX_ n, notif)) {
       hv_clear(notif);
       hv_undef(notif);
       notif = (HV *)&PL_sv_undef;
       ret = -1;
     }
 
     XPUSHs(sv_2mortal(newRV_noinc((SV *)notif)));
   } else if (PLUGIN_FLUSH == type) {
     cdtime_t timeout;
+    subname = va_arg(ap, char *);
+    /*
+     * $_[0] = $timeout;
+     * $_[1] = $identifier;
+     */
+    timeout = va_arg(ap, cdtime_t);
 
+    XPUSHs(sv_2mortal(newSVnv(CDTIME_T_TO_DOUBLE(timeout))));
+    XPUSHs(sv_2mortal(newSVpv(va_arg(ap, char *), 0)));
+  } else if (PLUGIN_FLUSH_ALL == type) {
+    cdtime_t timeout;
+    subname = "Collectd::plugin_call_all";
     /*
      * $_[0] = $timeout;
      * $_[1] = $identifier;
      */
     timeout = va_arg(ap, cdtime_t);
 
+    XPUSHs(sv_2mortal(newSViv((IV)PLUGIN_FLUSH)));
     XPUSHs(sv_2mortal(newSVnv(CDTIME_T_TO_DOUBLE(timeout))));
     XPUSHs(sv_2mortal(newSVpv(va_arg(ap, char *), 0)));
+  } else if (PLUGIN_INIT == type) {
+    subname = "Collectd::plugin_call_all";
+    XPUSHs(sv_2mortal(newSViv((IV)type)));
+  } else if (PLUGIN_SHUTDOWN == type) {
+    subname = "Collectd::plugin_call_all";
+    XPUSHs(sv_2mortal(newSViv((IV)type)));
+  } else { /* Unknown type. Run 'plugin_call_all' and make compiler happy */
+    subname = "Collectd::plugin_call_all";
+    XPUSHs(sv_2mortal(newSViv((IV)type)));
   }
 
   PUTBACK;
 
-  retvals = call_pv_locked(aTHX_ "Collectd::plugin_call_all");
+  retvals = call_pv_locked(aTHX_ subname);
 
   SPAGAIN;
-  if (0 < retvals) {
+  if (SvTRUE(ERRSV)) {
+    if (PLUGIN_LOG != type)
+      ERROR("perl: %s error: %s", subname, SvPV_nolen(ERRSV));
+    ret = -1;
+  } else if (0 < retvals) {
     SV *tmp = POPs;
     if (!SvTRUE(tmp))
       ret = -1;
   }
 
   PUTBACK;
   FREETMPS;
   LEAVE;
 
   va_end(ap);
   return ret;
-} /* static int pplugin_call_all (int, ...) */
+} /* static int pplugin_call (int, ...) */
 
 /*
  * collectd's Perl interpreter based thread implementation.
  *
  * This has been inspired by Perl's ithreads introduced in version 5.6.0.
  */
@@ -1131,12 +1186,16 @@
 static void c_ithread_destroy(c_ithread_t *ithread) {
   dTHXa(ithread->interp);
 
   assert(NULL != perl_threads);
 
   PERL_SET_CONTEXT(aTHX);
+  /* Mark as running to avoid deadlock:
+     c_ithread_destroy -> log_debug -> perl_log()
+  */
+  ithread->running = 1;
   log_debug("Shutting down Perl interpreter %p...", aTHX);
 
 #if COLLECT_DEBUG
   sv_report_used();
 
   --perl_threads->number_of_threads;
@@ -1344,13 +1403,16 @@
 
     plugin_notification_meta_free(*meta);
     av2notification_meta(aTHX_ pmeta, meta);
   }
 
   SPAGAIN;
-  if (0 < retvals) {
+  if (SvTRUE(ERRSV)) {
+    ERROR("perl: Collectd::fc_call error: %s", SvPV_nolen(ERRSV));
+    ret = -1;
+  } else if (0 < retvals) {
     SV *tmp = POPs;
 
     /* the exec callbacks return a status, while
      * the others return a boolean value */
     if (FC_CB_EXEC == cb_type)
       ret = SvIV(tmp);
@@ -1500,12 +1562,169 @@
                                 ptarget_invoke};
 
 /*
  * Exported Perl API.
  */
 
+static void _plugin_register_generic_userdata(pTHX, int type,
+                                              const char *desc) {
+  int ret = 0;
+  user_data_t userdata;
+  char *pluginname;
+
+  dXSARGS;
+
+  if (2 != items) {
+    log_err("Usage: Collectd::plugin_register_%s(pluginname, subname)", desc);
+    XSRETURN_EMPTY;
+  }
+
+  if (!SvOK(ST(0))) {
+    log_err("Collectd::plugin_register_%s(pluginname, subname): "
+            "Invalid pluginname",
+            desc);
+    XSRETURN_EMPTY;
+  }
+  if (!SvOK(ST(1))) {
+    log_err("Collectd::plugin_register_%s(pluginname, subname): "
+            "Invalid subname",
+            desc);
+    XSRETURN_EMPTY;
+  }
+
+  /* Use pluginname as-is to allow flush a single perl plugin */
+  pluginname = SvPV_nolen(ST(0));
+
+  log_debug("Collectd::plugin_register_%s: "
+            "plugin = \"%s\", sub = \"%s\"",
+            desc, pluginname, SvPV_nolen(ST(1)));
+
+  memset(&userdata, 0, sizeof(userdata));
+  userdata.data = strdup(SvPV_nolen(ST(1)));
+  userdata.free_func = free;
+
+  if (PLUGIN_READ == type) {
+    ret = plugin_register_complex_read(
+        "perl",                                       /* group */
+        pluginname, perl_read, plugin_get_interval(), /* Default interval */
+        &userdata);
+  } else if (PLUGIN_WRITE == type) {
+    ret = plugin_register_write(pluginname, perl_write, &userdata);
+  } else if (PLUGIN_LOG == type) {
+    ret = plugin_register_log(pluginname, perl_log, &userdata);
+  } else if (PLUGIN_NOTIF == type) {
+    ret = plugin_register_notification(pluginname, perl_notify, &userdata);
+  } else if (PLUGIN_FLUSH == type) {
+    if (1 == register_legacy_flush) { /* For collectd-5.7 only, #1731 */
+      register_legacy_flush = 0;
+      ret = plugin_register_flush("perl", perl_flush, /* user_data = */ NULL);
+    }
+
+    if (0 == ret)
+      ret = plugin_register_flush(pluginname, perl_flush, &userdata);
+  } else {
+    ret = -1;
+  }
+
+  if (0 == ret)
+    XSRETURN_YES;
+  else {
+    free(userdata.data);
+    XSRETURN_EMPTY;
+  }
+} /* static void _plugin_register_generic_userdata ( ... ) */
+
+/*
+ * Collectd::plugin_register_TYPE (pluginname, subname).
+ *
+ * pluginname:
+ *   name of the perl plugin
+ *
+ * subname:
+ *   name of the plugin's subroutine that does the work
+ */
+
+static XS(Collectd_plugin_register_read) {
+  return _plugin_register_generic_userdata(aTHX, PLUGIN_READ, "read");
+}
+
+static XS(Collectd_plugin_register_write) {
+  return _plugin_register_generic_userdata(aTHX, PLUGIN_WRITE, "write");
+}
+
+static XS(Collectd_plugin_register_log) {
+  return _plugin_register_generic_userdata(aTHX, PLUGIN_LOG, "log");
+}
+
+static XS(Collectd_plugin_register_notification) {
+  return _plugin_register_generic_userdata(aTHX, PLUGIN_NOTIF, "notification");
+}
+
+static XS(Collectd_plugin_register_flush) {
+  return _plugin_register_generic_userdata(aTHX, PLUGIN_FLUSH, "flush");
+}
+
+typedef int perl_unregister_function_t(const char *name);
+
+static void _plugin_unregister_generic(pTHX, perl_unregister_function_t *unreg,
+                                       const char *desc) {
+  dXSARGS;
+
+  if (1 != items) {
+    log_err("Usage: Collectd::plugin_unregister_%s(pluginname)", desc);
+    XSRETURN_EMPTY;
+  }
+
+  if (!SvOK(ST(0))) {
+    log_err("Collectd::plugin_unregister_%s(pluginname): "
+            "Invalid pluginname",
+            desc);
+    XSRETURN_EMPTY;
+  }
+
+  log_debug("Collectd::plugin_unregister_%s: plugin = \"%s\"", desc,
+            SvPV_nolen(ST(0)));
+
+  unreg(SvPV_nolen(ST(0)));
+
+  XSRETURN_EMPTY;
+
+  return;
+} /* static void _plugin_unregister_generic ( ... ) */
+
+/*
+ * Collectd::plugin_unregister_TYPE (pluginname).
+ *
+ * TYPE:
+ *   type of callback to be unregistered: read, write, log, notification, flush
+ *
+ * pluginname:
+ *   name of the perl plugin
+ */
+
+static XS(Collectd_plugin_unregister_read) {
+  return _plugin_unregister_generic(aTHX, plugin_unregister_read, "read");
+}
+
+static XS(Collectd_plugin_unregister_write) {
+  return _plugin_unregister_generic(aTHX, plugin_unregister_write, "write");
+}
+
+static XS(Collectd_plugin_unregister_log) {
+  return _plugin_unregister_generic(aTHX, plugin_unregister_log, "log");
+}
+
+static XS(Collectd_plugin_unregister_notification) {
+  return _plugin_unregister_generic(aTHX, plugin_unregister_notification,
+                                    "notification");
+}
+
+static XS(Collectd_plugin_unregister_flush) {
+  return _plugin_unregister_generic(aTHX, plugin_unregister_flush, "flush");
+}
+
 /*
  * Collectd::plugin_register_data_set (type, dataset).
  *
  * type:
  *   type of the dataset
  *
@@ -1875,20 +2094,20 @@
    * See https://github.com/collectd/collectd/issues/9 and
    *     https://github.com/collectd/collectd/issues/1706 for details.
   */
   assert(aTHX == perl_threads->head->interp);
   pthread_mutex_lock(&perl_threads->mutex);
 
-  status = pplugin_call_all(aTHX_ PLUGIN_INIT);
+  status = pplugin_call(aTHX_ PLUGIN_INIT);
 
   pthread_mutex_unlock(&perl_threads->mutex);
 
   return status;
 } /* static int perl_init (void) */
 
-static int perl_read(void) {
+static int perl_read(user_data_t *user_data) {
   dTHX;
 
   if (NULL == perl_threads)
     return 0;
 
   if (NULL == aTHX) {
@@ -1905,17 +2124,18 @@
    * run into concurrency issues with c_ithread_create(). See
    * https://github.com/collectd/collectd/issues/9 for details. */
   assert(aTHX != perl_threads->head->interp);
 
   log_debug("perl_read: c_ithread: interp = %p (active threads: %i)", aTHX,
             perl_threads->number_of_threads);
-  return pplugin_call_all(aTHX_ PLUGIN_READ);
-} /* static int perl_read (void) */
+
+  return pplugin_call(aTHX_ PLUGIN_READ, user_data->data);
+} /* static int perl_read (user_data_t *user_data) */
 
 static int perl_write(const data_set_t *ds, const value_list_t *vl,
-                      user_data_t __attribute__((unused)) * user_data) {
+                      user_data_t *user_data) {
   int status;
   dTHX;
 
   if (NULL == perl_threads)
     return 0;
 
@@ -1934,22 +2154,21 @@
    * https://github.com/collectd/collectd/issues/9 for details. */
   if (aTHX == perl_threads->head->interp)
     pthread_mutex_lock(&perl_threads->mutex);
 
   log_debug("perl_write: c_ithread: interp = %p (active threads: %i)", aTHX,
             perl_threads->number_of_threads);
-  status = pplugin_call_all(aTHX_ PLUGIN_WRITE, ds, vl);
+  status = pplugin_call(aTHX_ PLUGIN_WRITE, user_data->data, ds, vl);
 
   if (aTHX == perl_threads->head->interp)
     pthread_mutex_unlock(&perl_threads->mutex);
 
   return status;
 } /* static int perl_write (const data_set_t *, const value_list_t *) */
 
-static void perl_log(int level, const char *msg,
-                     user_data_t __attribute__((unused)) * user_data) {
+static void perl_log(int level, const char *msg, user_data_t *user_data) {
   dTHX;
 
   if (NULL == perl_threads)
     return;
 
   if (NULL == aTHX) {
@@ -1967,22 +2186,21 @@
    * https://github.com/collectd/collectd/issues/9 for details.
   */
 
   if (aTHX == perl_threads->head->interp)
     pthread_mutex_lock(&perl_threads->mutex);
 
-  pplugin_call_all(aTHX_ PLUGIN_LOG, level, msg);
+  pplugin_call(aTHX_ PLUGIN_LOG, user_data->data, level, msg);
 
   if (aTHX == perl_threads->head->interp)
     pthread_mutex_unlock(&perl_threads->mutex);
 
   return;
 } /* static void perl_log (int, const char *) */
 
-static int perl_notify(const notification_t *notif,
-                       user_data_t __attribute__((unused)) * user_data) {
+static int perl_notify(const notification_t *notif, user_data_t *user_data) {
   dTHX;
 
   if (NULL == perl_threads)
     return 0;
 
   if (NULL == aTHX) {
@@ -1991,17 +2209,17 @@
     pthread_mutex_lock(&perl_threads->mutex);
     t = c_ithread_create(perl_threads->head->interp);
     pthread_mutex_unlock(&perl_threads->mutex);
 
     aTHX = t->interp;
   }
-  return pplugin_call_all(aTHX_ PLUGIN_NOTIF, notif);
+  return pplugin_call(aTHX_ PLUGIN_NOTIF, user_data->data, notif);
 } /* static int perl_notify (const notification_t *) */
 
 static int perl_flush(cdtime_t timeout, const char *identifier,
-                      user_data_t __attribute__((unused)) * user_data) {
+                      user_data_t *user_data) {
   dTHX;
 
   if (NULL == perl_threads)
     return 0;
 
   if (NULL == aTHX) {
@@ -2010,22 +2228,28 @@
     pthread_mutex_lock(&perl_threads->mutex);
     t = c_ithread_create(perl_threads->head->interp);
     pthread_mutex_unlock(&perl_threads->mutex);
 
     aTHX = t->interp;
   }
-  return pplugin_call_all(aTHX_ PLUGIN_FLUSH, timeout, identifier);
+
+  /* For collectd-5.6 only, #1731 */
+  if (user_data == NULL || user_data->data == NULL)
+    return pplugin_call(aTHX_ PLUGIN_FLUSH_ALL, timeout, identifier);
+
+  return pplugin_call(aTHX_ PLUGIN_FLUSH, user_data->data, timeout, identifier);
 } /* static int perl_flush (const int) */
 
 static int perl_shutdown(void) {
   c_ithread_t *t;
   int ret;
 
   dTHX;
 
   plugin_unregister_complex_config("perl");
+  plugin_unregister_read_group("perl");
 
   if (NULL == perl_threads)
     return 0;
 
   if (NULL == aTHX) {
     pthread_mutex_lock(&perl_threads->mutex);
@@ -2035,20 +2259,16 @@
     aTHX = t->interp;
   }
 
   log_debug("perl_shutdown: c_ithread: interp = %p (active threads: %i)", aTHX,
             perl_threads->number_of_threads);
 
-  plugin_unregister_log("perl");
-  plugin_unregister_notification("perl");
   plugin_unregister_init("perl");
-  plugin_unregister_read("perl");
-  plugin_unregister_write("perl");
-  plugin_unregister_flush("perl");
+  plugin_unregister_flush("perl"); /* For collectd-5.6 only, #1731 */
 
-  ret = pplugin_call_all(aTHX_ PLUGIN_SHUTDOWN);
+  ret = pplugin_call(aTHX_ PLUGIN_SHUTDOWN);
 
   pthread_mutex_lock(&perl_threads->mutex);
   t = perl_threads->tail;
 
   while (NULL != t) {
     struct timespec ts_wait;
@@ -2245,21 +2465,13 @@
 
   /* Set $0 to "collectd" because perl_parse() has to set it to "-e". */
   sv_setpv(get_sv("0", 0), "collectd");
 
   perl_run(aTHX);
 
-  plugin_register_log("perl", perl_log, /* user_data = */ NULL);
-  plugin_register_notification("perl", perl_notify,
-                               /* user_data = */ NULL);
   plugin_register_init("perl", perl_init);
-
-  plugin_register_read("perl", perl_read);
-
-  plugin_register_write("perl", perl_write, /* user_data = */ NULL);
-  plugin_register_flush("perl", perl_flush, /* user_data = */ NULL);
   plugin_register_shutdown("perl", perl_shutdown);
   return 0;
 } /* static int init_pi (const char **, const int) */
 
 /*
  * LoadPlugin "<Plugin>"
@@ -2395,18 +2607,12 @@
   int retvals = 0;
   int ret = 0;
 
   char *plugin;
   HV *config;
 
-  if (NULL == perl_threads) {
-    log_err("A `Plugin' block was encountered but no plugin was loaded yet. "
-            "Put the appropriate `LoadPlugin' option in front of it.");
-    return -1;
-  }
-
   dSP;
 
   if ((1 != ci->values_num) || (OCONFIG_TYPE_STRING != ci->values[0].type)) {
     log_err("LoadPlugin expects a single string argument.");
     return 1;
   }
@@ -2469,12 +2675,14 @@
     else if (0 == strcasecmp(c->key, "EnableDebugger"))
       current_status = perl_config_enabledebugger(aTHX_ c);
     else if (0 == strcasecmp(c->key, "IncludeDir"))
       current_status = perl_config_includedir(aTHX_ c);
     else if (0 == strcasecmp(c->key, "Plugin"))
       current_status = perl_config_plugin(aTHX_ c);
+    else if (0 == strcasecmp(c->key, "RegisterLegacyFlush"))
+      cf_util_get_boolean(c, &register_legacy_flush);
     else {
       log_warn("Ignoring unknown config key \"%s\".", c->key);
       current_status = 0;
     }
 
     /* fatal error - it's up to perl_config_* to clean up */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/pf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/pf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/pf.c	2017-10-06 14:45:52.961917764 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/pf.c	2016-12-12 16:03:36.716279058 +0800
@@ -66,13 +66,12 @@
     values[0].gauge = (gauge_t)val;
   else
     values[0].derive = (derive_t)val;
 
   vl.values = values;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "pf", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void pf_submit */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/pinba.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/pinba.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/pinba.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/pinba.c	2016-12-12 16:03:36.716279058 +0800
@@ -588,13 +588,13 @@
 
   if (collector_thread_running)
     return (0);
 
   status = plugin_thread_create(&collector_thread_id,
                                 /* attrs = */ NULL, collector_thread,
-                                /* args = */ NULL);
+                                /* args = */ NULL, "pinba collector");
   if (status != 0) {
     char errbuf[1024];
     ERROR("pinba plugin: pthread_create(3) failed: %s",
           sstrerror(errno, errbuf, sizeof(errbuf)));
     return (-1);
   }
@@ -624,44 +624,44 @@
 
   return (0);
 } /* }}} int plugin_shutdown */
 
 static int plugin_submit(const pinba_statnode_t *res) /* {{{ */
 {
-  value_t value;
   value_list_t vl = VALUE_LIST_INIT;
 
-  vl.values = &value;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "pinba", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, res->name, sizeof(vl.plugin_instance));
 
-  value.derive = res->req_count;
+  vl.values = &(value_t){.derive = res->req_count};
   sstrncpy(vl.type, "total_requests", sizeof(vl.type));
   plugin_dispatch_values(&vl);
 
-  value.derive = float_counter_get(&res->req_time, /* factor = */ 1000);
+  vl.values = &(value_t){
+      .derive = float_counter_get(&res->req_time, /* factor = */ 1000)};
   sstrncpy(vl.type, "total_time_in_ms", sizeof(vl.type));
   plugin_dispatch_values(&vl);
 
-  value.derive = res->doc_size;
+  vl.values = &(value_t){.derive = res->doc_size};
   sstrncpy(vl.type, "total_bytes", sizeof(vl.type));
   plugin_dispatch_values(&vl);
 
-  value.derive = float_counter_get(&res->ru_utime, /* factor = */ 100);
+  vl.values = &(value_t){
+      .derive = float_counter_get(&res->ru_utime, /* factor = */ 100)};
   sstrncpy(vl.type, "cpu", sizeof(vl.type));
   sstrncpy(vl.type_instance, "user", sizeof(vl.type_instance));
   plugin_dispatch_values(&vl);
 
-  value.derive = float_counter_get(&res->ru_stime, /* factor = */ 100);
+  vl.values = &(value_t){
+      .derive = float_counter_get(&res->ru_stime, /* factor = */ 100)};
   sstrncpy(vl.type, "cpu", sizeof(vl.type));
   sstrncpy(vl.type_instance, "system", sizeof(vl.type_instance));
   plugin_dispatch_values(&vl);
 
-  value.gauge = res->mem_peak;
+  vl.values = &(value_t){.gauge = res->mem_peak};
   sstrncpy(vl.type, "memory", sizeof(vl.type));
   sstrncpy(vl.type_instance, "peak", sizeof(vl.type_instance));
   plugin_dispatch_values(&vl);
 
   return (0);
 } /* }}} int plugin_submit */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ping.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ping.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ping.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ping.c	2016-12-12 16:03:36.716279058 +0800
@@ -356,13 +356,13 @@
     return (0);
   }
 
   ping_thread_loop = 1;
   ping_thread_error = 0;
   status = plugin_thread_create(&ping_thread_id, /* attr = */ NULL, ping_thread,
-                                /* arg = */ (void *)0);
+                                /* arg = */ (void *)0, "ping");
   if (status != 0) {
     ping_thread_loop = 0;
     ERROR("ping plugin: Starting thread failed.");
     pthread_mutex_unlock(&ping_lock);
     return (-1);
   }
@@ -551,22 +551,17 @@
 
   return (0);
 } /* }}} int ping_config */
 
 static void submit(const char *host, const char *type, /* {{{ */
                    gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ping", sizeof(vl.plugin));
-  sstrncpy(vl.plugin_instance, "", sizeof(vl.plugin_instance));
   sstrncpy(vl.type_instance, host, sizeof(vl.type_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* }}} void ping_submit */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/postgresql.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/postgresql.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/postgresql.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/postgresql.c	2016-12-12 16:03:36.716279058 +0800
@@ -787,13 +787,13 @@
   }
 
   db = ud->data;
   assert(db->database != NULL);
   assert(db->writers != NULL);
 
-  if (rfc3339nano(time_str, sizeof(time_str), vl->time) != 0) {
+  if (rfc3339nano_local(time_str, sizeof(time_str), vl->time) != 0) {
     log_err("c_psql_write: Failed to convert time to RFC 3339 format");
     return -1;
   }
 
   if (values_name_to_sqlarray(ds, values_name_str, sizeof(values_name_str)) ==
       NULL)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/powerdns.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/powerdns.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/powerdns.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/powerdns.c	2016-12-12 16:03:36.716279058 +0800
@@ -45,12 +45,18 @@
 #define FUNC_ERROR(func)                                                       \
   do {                                                                         \
     char errbuf[1024];                                                         \
     ERROR("powerdns plugin: %s failed: %s", func,                              \
           sstrerror(errno, errbuf, sizeof(errbuf)));                           \
   } while (0)
+#define SOCK_ERROR(func, sockpath)                                             \
+  do {                                                                         \
+    char errbuf[1024];                                                         \
+    ERROR("powerdns plugin: Socket `%s` %s failed: %s", sockpath, func,        \
+          sstrerror(errno, errbuf, sizeof(errbuf)));                           \
+  } while (0)
 
 #define SERVER_SOCKET LOCALSTATEDIR "/run/pdns.controlsocket"
 #define SERVER_COMMAND "SHOW * \n"
 
 #define RECURSOR_SOCKET LOCALSTATEDIR "/run/pdns_recursor.controlsocket"
 #define RECURSOR_COMMAND                                                       \
@@ -311,15 +317,15 @@
  *
  * -octo
  */
 
 /* <https://doc.powerdns.com/md/recursor/stats/> */
 static void submit(const char *plugin_instance, /* {{{ */
-                   const char *pdns_type, const char *value) {
+                   const char *pdns_type, const char *value_str) {
   value_list_t vl = VALUE_LIST_INIT;
-  value_t values[1];
+  value_t value;
 
   const char *type = NULL;
   const char *type_instance = NULL;
   const data_set_t *ds;
 
   int i;
@@ -327,13 +333,13 @@
   for (i = 0; i < lookup_table_length; i++)
     if (strcmp(lookup_table[i].name, pdns_type) == 0)
       break;
 
   if (i >= lookup_table_length) {
     INFO("powerdns plugin: submit: Not found in lookup table: %s = %s;",
-         pdns_type, value);
+         pdns_type, value_str);
     return;
   }
 
   if (lookup_table[i].type == NULL)
     return;
 
@@ -352,22 +358,21 @@
     ERROR("powerdns plugin: type `%s' has %zu data sources, "
           "but I can only handle one.",
           type, ds->ds_num);
     return;
   }
 
-  if (0 != parse_value(value, &values[0], ds->ds[0].type)) {
+  if (0 != parse_value(value_str, &value, ds->ds[0].type)) {
     ERROR("powerdns plugin: Cannot convert `%s' "
           "to a number.",
-          value);
+          value_str);
     return;
   }
 
-  vl.values = values;
+  vl.values = &value;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "powerdns", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
 
@@ -382,13 +387,12 @@
   char temp[4096];
   char *buffer = NULL;
   size_t buffer_size = 0;
 
   struct sockaddr_un sa_unix = {0};
 
-  struct timeval stv_timeout;
   cdtime_t cdt_timeout;
 
   sd = socket(PF_UNIX, item->socktype, 0);
   if (sd < 0) {
     FUNC_ERROR("socket");
     return (-1);
@@ -398,63 +402,62 @@
   sstrncpy(sa_unix.sun_path,
            (local_sockpath != NULL) ? local_sockpath : PDNS_LOCAL_SOCKPATH,
            sizeof(sa_unix.sun_path));
 
   status = unlink(sa_unix.sun_path);
   if ((status != 0) && (errno != ENOENT)) {
-    FUNC_ERROR("unlink");
+    SOCK_ERROR("unlink", sa_unix.sun_path);
     close(sd);
     return (-1);
   }
 
   do /* while (0) */
   {
     /* We need to bind to a specific path, because this is a datagram socket
      * and otherwise the daemon cannot answer. */
     status = bind(sd, (struct sockaddr *)&sa_unix, sizeof(sa_unix));
     if (status != 0) {
-      FUNC_ERROR("bind");
+      SOCK_ERROR("bind", sa_unix.sun_path);
       break;
     }
 
     /* Make the socket writeable by the daemon.. */
     status = chmod(sa_unix.sun_path, 0666);
     if (status != 0) {
-      FUNC_ERROR("chmod");
+      SOCK_ERROR("chmod", sa_unix.sun_path);
       break;
     }
 
     cdt_timeout = plugin_get_interval() * 3 / 4;
     if (cdt_timeout < TIME_T_TO_CDTIME_T(2))
       cdt_timeout = TIME_T_TO_CDTIME_T(2);
 
-    CDTIME_T_TO_TIMEVAL(cdt_timeout, &stv_timeout);
-
-    status = setsockopt(sd, SOL_SOCKET, SO_RCVTIMEO, &stv_timeout,
-                        sizeof(stv_timeout));
+    status =
+        setsockopt(sd, SOL_SOCKET, SO_RCVTIMEO,
+                   &CDTIME_T_TO_TIMEVAL(cdt_timeout), sizeof(struct timeval));
     if (status != 0) {
-      FUNC_ERROR("setsockopt");
+      SOCK_ERROR("setsockopt", sa_unix.sun_path);
       break;
     }
 
     status =
         connect(sd, (struct sockaddr *)&item->sockaddr, sizeof(item->sockaddr));
     if (status != 0) {
-      FUNC_ERROR("connect");
+      SOCK_ERROR("connect", sa_unix.sun_path);
       break;
     }
 
     status = send(sd, item->command, strlen(item->command), 0);
     if (status < 0) {
-      FUNC_ERROR("send");
+      SOCK_ERROR("send", sa_unix.sun_path);
       break;
     }
 
     status = recv(sd, temp, sizeof(temp), /* flags = */ 0);
     if (status < 0) {
-      FUNC_ERROR("recv");
+      SOCK_ERROR("recv", sa_unix.sun_path);
       break;
     }
     buffer_size = status + 1;
     status = 0;
   } while (0);
 
@@ -506,32 +509,32 @@
     return (-1);
   }
 
   status =
       connect(sd, (struct sockaddr *)&item->sockaddr, sizeof(item->sockaddr));
   if (status != 0) {
-    FUNC_ERROR("connect");
+    SOCK_ERROR("connect", item->sockaddr.sun_path);
     close(sd);
     return (-1);
   }
 
   /* strlen + 1, because we need to send the terminating NULL byte, too. */
   status = send(sd, item->command, strlen(item->command) + 1,
                 /* flags = */ 0);
   if (status < 0) {
-    FUNC_ERROR("send");
+    SOCK_ERROR("send", item->sockaddr.sun_path);
     close(sd);
     return (-1);
   }
 
   while (42) {
     char *buffer_new;
 
     status = recv(sd, temp, sizeof(temp), /* flags = */ 0);
     if (status < 0) {
-      FUNC_ERROR("recv");
+      SOCK_ERROR("recv", item->sockaddr.sun_path);
       break;
     } else if (status == 0)
       break;
 
     buffer_new = realloc(buffer, buffer_size + status + 1);
     if (buffer_new == NULL) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/processes.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/processes.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/processes.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/processes.c	2016-12-12 16:03:36.720279029 +0800
@@ -168,30 +168,28 @@
   unsigned long vmem_size;
   unsigned long vmem_rss;
   unsigned long vmem_data;
   unsigned long vmem_code;
   unsigned long stack_size;
 
-  unsigned long vmem_minflt;
-  unsigned long vmem_majflt;
   derive_t vmem_minflt_counter;
   derive_t vmem_majflt_counter;
 
-  unsigned long cpu_user;
-  unsigned long cpu_system;
   derive_t cpu_user_counter;
   derive_t cpu_system_counter;
 
   /* io data */
   derive_t io_rchar;
   derive_t io_wchar;
   derive_t io_syscr;
   derive_t io_syscw;
+  _Bool has_io;
 
   derive_t cswitch_vol;
   derive_t cswitch_invol;
+  _Bool has_cswitch;
 
   struct procstat_entry_s *next;
 } procstat_entry_t;
 
 #define PROCSTAT_NAME_LEN 256
 typedef struct procstat {
@@ -226,24 +224,26 @@
   struct procstat *next;
   struct procstat_entry_s *instances;
 } procstat_t;
 
 static procstat_t *list_head_g = NULL;
 
+static _Bool want_init = 1;
 static _Bool report_ctx_switch = 0;
 
 #if HAVE_THREAD_INFO
 static mach_port_t port_host_self;
 static mach_port_t port_task_self;
 
 static processor_set_name_array_t pset_list;
 static mach_msg_type_number_t pset_list_len;
 /* #endif HAVE_THREAD_INFO */
 
 #elif KERNEL_LINUX
 static long pagesize_g;
+static void ps_fill_details(const procstat_t *ps, procstat_entry_t *entry);
 /* #endif KERNEL_LINUX */
 
 #elif HAVE_LIBKVM_GETPROCS &&                                                  \
     (HAVE_STRUCT_KINFO_PROC_FREEBSD || HAVE_STRUCT_KINFO_PROC_OPENBSD)
 static int pagesize;
 /* #endif HAVE_LIBKVM_GETPROCS && (HAVE_STRUCT_KINFO_PROC_FREEBSD ||
@@ -358,45 +358,46 @@
       if (strcmp(ps->name, name) == 0)
     return (1);
 
   return (0);
 } /* int ps_list_match */
 
-static void ps_update_counter(_Bool init, derive_t *group_counter,
-                              derive_t *curr_counter, unsigned long *curr_value,
-                              derive_t new_counter, unsigned long new_value) {
-  if (init) {
-    *curr_value = new_value;
-    *curr_counter += new_value;
-    *group_counter += new_value;
+static void ps_update_counter(derive_t *group_counter, derive_t *curr_counter,
+                              derive_t new_counter) {
+  unsigned long curr_value;
+
+  if (want_init) {
+    *curr_counter = new_counter;
     return;
   }
 
   if (new_counter < *curr_counter)
-    *curr_value = new_counter + (ULONG_MAX - *curr_counter);
+    curr_value = new_counter + (ULONG_MAX - *curr_counter);
   else
-    *curr_value = new_counter - *curr_counter;
+    curr_value = new_counter - *curr_counter;
 
   *curr_counter = new_counter;
-  *group_counter += *curr_value;
+  *group_counter += curr_value;
 }
 
 /* add process entry to 'instances' of process 'name' (or refresh it) */
 static void ps_list_add(const char *name, const char *cmdline,
                         procstat_entry_t *entry) {
   procstat_entry_t *pse;
 
   if (entry->id == 0)
     return;
 
   for (procstat_t *ps = list_head_g; ps != NULL; ps = ps->next) {
-    _Bool want_init;
-
     if ((ps_list_match(name, cmdline, ps)) == 0)
       continue;
 
+#if KERNEL_LINUX
+    ps_fill_details(ps, entry);
+#endif
+
     for (pse = ps->instances; pse != NULL; pse = pse->next)
       if ((pse->id == entry->id) || (pse->next == NULL))
         break;
 
     if ((pse == NULL) || (pse->id != entry->id)) {
       procstat_entry_t *new;
@@ -442,28 +443,21 @@
     ps->io_syscr += ((pse->io_syscr == -1) ? 0 : pse->io_syscr);
     ps->io_syscw += ((pse->io_syscw == -1) ? 0 : pse->io_syscw);
 
     ps->cswitch_vol += ((pse->cswitch_vol == -1) ? 0 : pse->cswitch_vol);
     ps->cswitch_invol += ((pse->cswitch_invol == -1) ? 0 : pse->cswitch_invol);
 
-    want_init =
-        (entry->vmem_minflt_counter == 0) && (entry->vmem_majflt_counter == 0);
-    ps_update_counter(want_init, &ps->vmem_minflt_counter,
-                      &pse->vmem_minflt_counter, &pse->vmem_minflt,
-                      entry->vmem_minflt_counter, entry->vmem_minflt);
-    ps_update_counter(want_init, &ps->vmem_majflt_counter,
-                      &pse->vmem_majflt_counter, &pse->vmem_majflt,
-                      entry->vmem_majflt_counter, entry->vmem_majflt);
-
-    want_init =
-        (entry->cpu_user_counter == 0) && (entry->cpu_system_counter == 0);
-    ps_update_counter(want_init, &ps->cpu_user_counter, &pse->cpu_user_counter,
-                      &pse->cpu_user, entry->cpu_user_counter, entry->cpu_user);
-    ps_update_counter(want_init, &ps->cpu_system_counter,
-                      &pse->cpu_system_counter, &pse->cpu_system,
-                      entry->cpu_system_counter, entry->cpu_system);
+    ps_update_counter(&ps->vmem_minflt_counter, &pse->vmem_minflt_counter,
+                      entry->vmem_minflt_counter);
+    ps_update_counter(&ps->vmem_majflt_counter, &pse->vmem_majflt_counter,
+                      entry->vmem_majflt_counter);
+
+    ps_update_counter(&ps->cpu_user_counter, &pse->cpu_user_counter,
+                      entry->cpu_user_counter);
+    ps_update_counter(&ps->cpu_system_counter, &pse->cpu_system_counter,
+                      entry->cpu_system_counter);
   }
 }
 
 /* remove old entries from instances of processes in list_head_g */
 static void ps_list_reset(void) {
   procstat_entry_t *pse;
@@ -618,36 +612,30 @@
 
   return (0);
 } /* int ps_init */
 
 /* submit global state (e.g.: qty of zombies, running, etc..) */
 static void ps_submit_state(const char *state, double value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "processes", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, "", sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "ps_state", sizeof(vl.type));
   sstrncpy(vl.type_instance, state, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
 /* submit info about specific process (e.g.: memory taken, cpu usage, etc..) */
 static void ps_submit_proc_list(procstat_t *ps) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
+  value_t values[2];
 
   vl.values = values;
-  vl.values_len = 2;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "processes", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, ps->name, sizeof(vl.plugin_instance));
 
   sstrncpy(vl.type, "ps_vm", sizeof(vl.type));
   vl.values[0].gauge = ps->vmem_size;
   vl.values_len = 1;
@@ -735,59 +723,55 @@
         ps->io_rchar, ps->io_wchar, ps->io_syscr, ps->io_syscw, ps->cswitch_vol,
         ps->cswitch_invol);
 } /* void ps_submit_proc_list */
 
 #if KERNEL_LINUX || KERNEL_SOLARIS
 static void ps_submit_fork_rate(derive_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.derive = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "processes", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, "", sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "fork_rate", sizeof(vl.type));
   sstrncpy(vl.type_instance, "", sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 #endif /* KERNEL_LINUX || KERNEL_SOLARIS*/
 
 /* ------- additional functions for KERNEL_LINUX/HAVE_THREAD_INFO ------- */
 #if KERNEL_LINUX
-static procstat_t *ps_read_tasks_status(long pid, procstat_t *ps) {
+static int ps_read_tasks_status(procstat_entry_t *ps) {
   char dirname[64];
   DIR *dh;
   char filename[64];
   FILE *fh;
   struct dirent *ent;
   derive_t cswitch_vol = 0;
   derive_t cswitch_invol = 0;
   char buffer[1024];
   char *fields[8];
   int numfields;
 
-  ssnprintf(dirname, sizeof(dirname), "/proc/%li/task", pid);
+  ssnprintf(dirname, sizeof(dirname), "/proc/%li/task", ps->id);
 
   if ((dh = opendir(dirname)) == NULL) {
     DEBUG("Failed to open directory `%s'", dirname);
-    return (NULL);
+    return (-1);
   }
 
   while ((ent = readdir(dh)) != NULL) {
     char *tpid;
 
     if (!isdigit((int)ent->d_name[0]))
       continue;
 
     tpid = ent->d_name;
 
-    ssnprintf(filename, sizeof(filename), "/proc/%li/task/%s/status", pid,
+    ssnprintf(filename, sizeof(filename), "/proc/%li/task/%s/status", ps->id,
               tpid);
     if ((fh = fopen(filename, "r")) == NULL) {
       DEBUG("Failed to open file `%s'", filename);
       continue;
     }
 
@@ -824,13 +808,13 @@
   }
   closedir(dh);
 
   ps->cswitch_vol = cswitch_vol;
   ps->cswitch_invol = cswitch_invol;
 
-  return (ps);
+  return (0);
 } /* int *ps_read_tasks_status */
 
 /* Read data from /proc/pid/status */
 static procstat_t *ps_read_status(long pid, procstat_t *ps) {
   FILE *fh;
   char buffer[1024];
@@ -884,23 +868,23 @@
   if (threads != 0)
     ps->num_lwp = threads;
 
   return (ps);
 } /* procstat_t *ps_read_vmem */
 
-static procstat_t *ps_read_io(long pid, procstat_t *ps) {
+static int ps_read_io(procstat_entry_t *ps) {
   FILE *fh;
   char buffer[1024];
   char filename[64];
 
   char *fields[8];
   int numfields;
 
-  ssnprintf(filename, sizeof(filename), "/proc/%li/io", pid);
+  ssnprintf(filename, sizeof(filename), "/proc/%li/io", ps->id);
   if ((fh = fopen(filename, "r")) == NULL)
-    return (NULL);
+    return (-1);
 
   while (fgets(buffer, sizeof(buffer), fh) != NULL) {
     derive_t *val = NULL;
     long long tmp;
     char *endptr;
 
@@ -930,15 +914,39 @@
   } /* while (fgets) */
 
   if (fclose(fh)) {
     char errbuf[1024];
     WARNING("processes: fclose: %s", sstrerror(errno, errbuf, sizeof(errbuf)));
   }
+  return (0);
+} /* int ps_read_io (...) */
 
-  return (ps);
-} /* procstat_t *ps_read_io */
+static void ps_fill_details(const procstat_t *ps, procstat_entry_t *entry) {
+  if (entry->has_io == 0 && ps_read_io(entry) != 0) {
+    /* no io data */
+    entry->io_rchar = -1;
+    entry->io_wchar = -1;
+    entry->io_syscr = -1;
+    entry->io_syscw = -1;
+
+    DEBUG("ps_read_process: not get io data for pid %li", entry->id);
+  }
+  entry->has_io = 1;
+
+  if (report_ctx_switch) {
+    if (entry->has_cswitch == 0 && ps_read_tasks_status(entry) != 0) {
+      entry->cswitch_vol = -1;
+      entry->cswitch_invol = -1;
+
+      DEBUG("ps_read_tasks_status: not get context "
+            "switch data for pid %li",
+            entry->id);
+    }
+    entry->has_cswitch = 1;
+  }
+} /* void ps_fill_details (...) */
 
 static int ps_read_process(long pid, procstat_t *ps, char *state) {
   char filename[64];
   char buffer[1024];
 
   char *fields[64];
@@ -1057,33 +1065,12 @@
   ps->cpu_user_counter = cpu_user_counter;
   ps->cpu_system_counter = cpu_system_counter;
   ps->vmem_size = (unsigned long)vmem_size;
   ps->vmem_rss = (unsigned long)vmem_rss;
   ps->stack_size = (unsigned long)stack_size;
 
-  if ((ps_read_io(pid, ps)) == NULL) {
-    /* no io data */
-    ps->io_rchar = -1;
-    ps->io_wchar = -1;
-    ps->io_syscr = -1;
-    ps->io_syscw = -1;
-
-    DEBUG("ps_read_process: not get io data for pid %li", pid);
-  }
-
-  if (report_ctx_switch) {
-    if ((ps_read_tasks_status(pid, ps)) == NULL) {
-      ps->cswitch_vol = -1;
-      ps->cswitch_invol = -1;
-
-      DEBUG("ps_read_tasks_status: not get context "
-            "switch data for pid %li",
-            pid);
-    }
-  }
-
   /* success */
   return (0);
 } /* int ps_read_process (...) */
 
 static char *ps_get_cmdline(long pid, char *name, char *buf, size_t buf_len) {
   char *buf_ptr;
@@ -1705,20 +1692,16 @@
     pse.vmem_size = ps.vmem_size;
     pse.vmem_rss = ps.vmem_rss;
     pse.vmem_data = ps.vmem_data;
     pse.vmem_code = ps.vmem_code;
     pse.stack_size = ps.stack_size;
 
-    pse.vmem_minflt = 0;
     pse.vmem_minflt_counter = ps.vmem_minflt_counter;
-    pse.vmem_majflt = 0;
     pse.vmem_majflt_counter = ps.vmem_majflt_counter;
 
-    pse.cpu_user = 0;
     pse.cpu_user_counter = ps.cpu_user_counter;
-    pse.cpu_system = 0;
     pse.cpu_system_counter = ps.cpu_system_counter;
 
     pse.io_rchar = ps.io_rchar;
     pse.io_wchar = ps.io_wchar;
     pse.io_syscr = ps.io_syscr;
     pse.io_syscw = ps.io_syscw;
@@ -1839,19 +1822,15 @@
 
       pse.vmem_size = procs[i].ki_size;
       pse.vmem_rss = procs[i].ki_rssize * pagesize;
       pse.vmem_data = procs[i].ki_dsize * pagesize;
       pse.vmem_code = procs[i].ki_tsize * pagesize;
       pse.stack_size = procs[i].ki_ssize * pagesize;
-      pse.vmem_minflt = 0;
       pse.vmem_minflt_counter = procs[i].ki_rusage.ru_minflt;
-      pse.vmem_majflt = 0;
       pse.vmem_majflt_counter = procs[i].ki_rusage.ru_majflt;
 
-      pse.cpu_user = 0;
-      pse.cpu_system = 0;
       pse.cpu_user_counter = 0;
       pse.cpu_system_counter = 0;
       /*
        * The u-area might be swapped out, and we can't get
        * at it because we have a crashdump and no swap.
        * If it's here fill in these fields, otherwise, just
@@ -1991,19 +1970,15 @@
 
       pse.vmem_rss = procs[i].p_vm_rssize * pagesize;
       pse.vmem_data = procs[i].p_vm_dsize * pagesize;
       pse.vmem_code = procs[i].p_vm_tsize * pagesize;
       pse.stack_size = procs[i].p_vm_ssize * pagesize;
       pse.vmem_size = pse.stack_size + pse.vmem_code + pse.vmem_data;
-      pse.vmem_minflt = 0;
       pse.vmem_minflt_counter = procs[i].p_uru_minflt;
-      pse.vmem_majflt = 0;
       pse.vmem_majflt_counter = procs[i].p_uru_majflt;
 
-      pse.cpu_user = 0;
-      pse.cpu_system = 0;
       pse.cpu_user_counter =
           procs[i].p_uutime_usec + (1000000lu * procs[i].p_uutime_sec);
       pse.cpu_system_counter =
           procs[i].p_ustime_usec + (1000000lu * procs[i].p_ustime_sec);
 
       /* no I/O data */
@@ -2145,25 +2120,22 @@
           }
         }
         if (nthreads < MAXTHRDENTRY)
           break;
       }
 
-      pse.cpu_user = 0;
       /* tv_usec is nanosec ??? */
       pse.cpu_user_counter = procentry[i].pi_ru.ru_utime.tv_sec * 1000000 +
                              procentry[i].pi_ru.ru_utime.tv_usec / 1000;
 
       pse.cpu_system = 0;
       /* tv_usec is nanosec ??? */
       pse.cpu_system_counter = procentry[i].pi_ru.ru_stime.tv_sec * 1000000 +
                                procentry[i].pi_ru.ru_stime.tv_usec / 1000;
 
-      pse.vmem_minflt = 0;
       pse.vmem_minflt_counter = procentry[i].pi_minflt;
-      pse.vmem_majflt = 0;
       pse.vmem_majflt_counter = procentry[i].pi_majflt;
 
       pse.vmem_size = procentry[i].pi_tsize + procentry[i].pi_dvm * pagesize;
       pse.vmem_rss = (procentry[i].pi_drss + procentry[i].pi_trss) * pagesize;
       /* Not supported */
       pse.vmem_data = 0;
@@ -2253,20 +2225,16 @@
     pse.vmem_size = ps.vmem_size;
     pse.vmem_rss = ps.vmem_rss;
     pse.vmem_data = ps.vmem_data;
     pse.vmem_code = ps.vmem_code;
     pse.stack_size = ps.stack_size;
 
-    pse.vmem_minflt = 0;
     pse.vmem_minflt_counter = ps.vmem_minflt_counter;
-    pse.vmem_majflt = 0;
     pse.vmem_majflt_counter = ps.vmem_majflt_counter;
 
-    pse.cpu_user = 0;
     pse.cpu_user_counter = ps.cpu_user_counter;
-    pse.cpu_system = 0;
     pse.cpu_system_counter = ps.cpu_system_counter;
 
     pse.io_rchar = ps.io_rchar;
     pse.io_wchar = ps.io_wchar;
     pse.io_syscr = ps.io_syscr;
     pse.io_syscw = ps.io_syscw;
@@ -2318,12 +2286,14 @@
   for (procstat_t *ps_ptr = list_head_g; ps_ptr != NULL; ps_ptr = ps_ptr->next)
     ps_submit_proc_list(ps_ptr);
 
   read_fork_rate();
 #endif /* KERNEL_SOLARIS */
 
+  want_init = 0;
+
   return (0);
 } /* int ps_read */
 
 void module_register(void) {
   plugin_register_complex_config("processes", ps_config);
   plugin_register_init("processes", ps_init);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/protocols.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/protocols.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/protocols.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/protocols.c	2016-12-12 16:03:36.720279029 +0800
@@ -49,25 +49,24 @@
 
 /*
  * Functions
  */
 static void submit(const char *protocol_name, const char *str_key,
                    const char *str_value) {
-  value_t values[1];
+  value_t value;
   value_list_t vl = VALUE_LIST_INIT;
   int status;
 
-  status = parse_value(str_value, values, DS_TYPE_DERIVE);
+  status = parse_value(str_value, &value, DS_TYPE_DERIVE);
   if (status != 0) {
     ERROR("protocols plugin: Parsing string as integer failed: %s", str_value);
     return;
   }
 
-  vl.values = values;
+  vl.values = &value;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "protocols", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, protocol_name, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "protocol_counter", sizeof(vl.type));
   sstrncpy(vl.type_instance, str_key, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/python.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/python.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/python.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/python.c	2016-12-12 16:03:36.720279029 +0800
@@ -715,15 +715,17 @@
 
   c->name = strdup(buf);
   c->callback = callback;
   c->data = data;
   c->next = NULL;
 
-  user_data_t user_data = {.data = c, .free_func = cpy_destroy_user_data};
+  register_function(buf, handler,
+                    &(user_data_t){
+                        .data = c, .free_func = cpy_destroy_user_data,
+                    });
 
-  register_function(buf, handler, &user_data);
   ++cpy_num_callbacks;
   return cpy_string_to_unicode_or_bytes(buf);
 }
 
 static PyObject *cpy_register_read(PyObject *self, PyObject *args,
                                    PyObject *kwds) {
@@ -754,16 +756,18 @@
 
   c->name = strdup(buf);
   c->callback = callback;
   c->data = data;
   c->next = NULL;
 
-  user_data_t user_data = {.data = c, .free_func = cpy_destroy_user_data};
-
-  plugin_register_complex_read(/* group = */ "python", buf, cpy_read_callback,
-                               DOUBLE_TO_CDTIME_T(interval), &user_data);
+  plugin_register_complex_read(
+      /* group = */ "python", buf, cpy_read_callback,
+      DOUBLE_TO_CDTIME_T(interval),
+      &(user_data_t){
+          .data = c, .free_func = cpy_destroy_user_data,
+      });
   ++cpy_num_callbacks;
   return cpy_string_to_unicode_or_bytes(buf);
 }
 
 static PyObject *cpy_register_log(PyObject *self, PyObject *args,
                                   PyObject *kwds) {
@@ -1091,13 +1095,14 @@
   main_thread = pthread_self();
   if (do_interactive) {
     if (pipe(pipefd)) {
       ERROR("python: Unable to create pipe.");
       return 1;
     }
-    if (plugin_thread_create(&thread, NULL, cpy_interactive, pipefd + 1)) {
+    if (plugin_thread_create(&thread, NULL, cpy_interactive, pipefd + 1,
+                             "python interpreter")) {
       ERROR("python: Error creating thread for interactive interpreter.");
     }
     if (read(pipefd[0], &buf, 1))
       ;
     (void)close(pipefd[0]);
   } else {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/redis.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/redis.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/redis.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/redis.c	2016-12-12 16:03:36.720279029 +0800
@@ -234,20 +234,16 @@
 } /* }}} */
 
 __attribute__((nonnull(2))) static void
 redis_submit(char *plugin_instance, const char *type, const char *type_instance,
              value_t value) /* {{{ */
 {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0] = value;
-
-  vl.values = values;
+  vl.values = &value;
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "redis", sizeof(vl.plugin));
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/routeros.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/routeros.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/routeros.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/routeros.c	2016-12-12 16:03:36.720279029 +0800
@@ -47,17 +47,16 @@
   _Bool collect_disk;
 };
 typedef struct cr_data_s cr_data_t;
 
 static void cr_submit_io(cr_data_t *rd, const char *type, /* {{{ */
                          const char *type_instance, derive_t rx, derive_t tx) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = rx;
-  values[1].derive = tx;
+  value_t values[] = {
+      {.derive = rx}, {.derive = tx},
+  };
 
   vl.values = values;
   vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.host, rd->node, sizeof(vl.host));
   sstrncpy(vl.plugin, "routeros", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
@@ -303,13 +302,12 @@
 } /* }}} void cr_free_data */
 
 static int cr_config_router(oconfig_item_t *ci) /* {{{ */
 {
   cr_data_t *router_data;
   char read_name[128];
-  user_data_t user_data;
   int status;
 
   router_data = calloc(1, sizeof(*router_data));
   if (router_data == NULL)
     return (-1);
   router_data->connection = NULL;
@@ -378,17 +376,18 @@
       ERROR("routeros plugin: sstrdup failed.");
       status = -1;
     }
   }
 
   ssnprintf(read_name, sizeof(read_name), "routeros/%s", router_data->node);
-  user_data.data = router_data;
-  user_data.free_func = (void *)cr_free_data;
   if (status == 0)
     status = plugin_register_complex_read(
-        /* group = */ NULL, read_name, cr_read, /* interval = */ 0, &user_data);
+        /* group = */ NULL, read_name, cr_read, /* interval = */ 0,
+        &(user_data_t){
+            .data = router_data, .free_func = (void *)cr_free_data,
+        });
 
   if (status != 0)
     cr_free_data(router_data);
 
   return (status);
 } /* }}} int cr_config_router */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/rrdcached.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/rrdcached.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/rrdcached.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/rrdcached.c	2016-12-12 16:03:36.720279029 +0800
@@ -283,28 +283,24 @@
 
 static int rc_read(void) {
   int status;
   rrdc_stats_t *head;
   _Bool retried = 0;
 
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
+  vl.values = &(value_t){.gauge = NAN};
+  vl.values_len = 1;
 
   if (daemon_address == NULL)
     return (-1);
 
   if (!config_collect_stats)
     return (-1);
 
-  vl.values = values;
-  vl.values_len = 1;
-
-  if ((strncmp("unix:", daemon_address, strlen("unix:")) == 0) ||
-      (daemon_address[0] == '/'))
-    sstrncpy(vl.host, hostname_g, sizeof(vl.host));
-  else
+  if ((strncmp("unix:", daemon_address, strlen("unix:")) != 0) &&
+      (daemon_address[0] != '/'))
     sstrncpy(vl.host, daemon_address, sizeof(vl.host));
   sstrncpy(vl.plugin, "rrdcached", sizeof(vl.plugin));
 
   rrd_clear_error();
   status = rrdc_connect(daemon_address);
   if (status != 0) {
@@ -334,15 +330,15 @@
           rrd_get_error(), status);
     return (-1);
   }
 
   for (rrdc_stats_t *ptr = head; ptr != NULL; ptr = ptr->next) {
     if (ptr->type == RRDC_STATS_TYPE_GAUGE)
-      values[0].gauge = (gauge_t)ptr->value.gauge;
+      vl.values[0].gauge = (gauge_t)ptr->value.gauge;
     else if (ptr->type == RRDC_STATS_TYPE_COUNTER)
-      values[0].counter = (counter_t)ptr->value.counter;
+      vl.values[0].counter = (counter_t)ptr->value.counter;
     else
       continue;
 
     if (strcasecmp("QueueLength", ptr->name) == 0) {
       sstrncpy(vl.type, "queue_length", sizeof(vl.type));
       sstrncpy(vl.type_instance, "", sizeof(vl.type_instance));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/rrdtool.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/rrdtool.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/rrdtool.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/rrdtool.c	2016-12-12 16:03:36.720279029 +0800
@@ -84,13 +84,13 @@
     /* async = */ 0};
 
 /* XXX: If you need to lock both, cache_lock and queue_lock, at the same time,
  * ALWAYS lock `cache_lock' first! */
 static cdtime_t cache_timeout = 0;
 static cdtime_t cache_flush_timeout = 0;
-static cdtime_t random_timeout = 0;
+static cdtime_t random_timeout = TIME_T_TO_CDTIME_T_STATIC(1);
 static cdtime_t cache_flush_last;
 static c_avl_tree_t *cache = NULL;
 static pthread_mutex_t cache_lock = PTHREAD_MUTEX_INITIALIZER;
 
 static rrd_queue_t *queue_head = NULL;
 static rrd_queue_t *queue_tail = NULL;
@@ -502,12 +502,13 @@
   c_avl_iterator_t *iter;
 
   DEBUG("rrdtool plugin: Flushing cache, timeout = %.3f",
         CDTIME_T_TO_DOUBLE(timeout));
 
   now = cdtime();
+  timeout = TIME_T_TO_CDTIME_T(timeout);
 
   /* Build a list of entries to be flushed */
   iter = c_avl_get_iterator(cache);
   while (c_avl_iterator_next(iter, (void *)&key, (void *)&rc) == 0) {
     if (rc->flags != FLAG_NONE)
       continue;
@@ -602,16 +603,29 @@
   }
 
   return (status);
 } /* int rrd_cache_flush_identifier */
 
 static int64_t rrd_get_random_variation(void) {
+  long min;
+  long max;
+
   if (random_timeout == 0)
     return (0);
 
-  return (int64_t)cdrand_range(-random_timeout, random_timeout);
+  /* Assure that "cache_timeout + random_variation" is never negative. */
+  if (random_timeout > cache_timeout) {
+    INFO("rrdtool plugin: Adjusting \"RandomTimeout\" to %.3f seconds.",
+         CDTIME_T_TO_DOUBLE(cache_timeout));
+    random_timeout = cache_timeout;
+  }
+
+  max = (long)(random_timeout / 2);
+  min = max - ((long)random_timeout);
+
+  return ((int64_t)cdrand_range(min, max));
 } /* int64_t rrd_get_random_variation */
 
 static int rrd_cache_insert(const char *filename, const char *value,
                             cdtime_t value_time) {
   rrd_cache_t *rc = NULL;
   int new_rc = 0;
@@ -723,13 +737,13 @@
       DEBUG("rrdtool plugin: `%s' is already queued.", filename);
     }
   }
 
   if ((cache_timeout > 0) &&
       ((cdtime() - cache_flush_last) > cache_flush_timeout))
-    rrd_cache_flush(cache_timeout + random_timeout);
+    rrd_cache_flush(cache_flush_timeout);
 
   pthread_mutex_unlock(&cache_lock);
 
   return (0);
 } /* int rrd_cache_insert */
 
@@ -860,21 +874,21 @@
       ERROR("rrdtool: `CacheTimeout' must "
             "be greater than 0.\n");
       return (1);
     }
     cache_timeout = DOUBLE_TO_CDTIME_T(tmp);
   } else if (strcasecmp("CacheFlush", key) == 0) {
-    double tmp = atof(value);
+    int tmp = atoi(value);
     if (tmp < 0) {
       fprintf(stderr, "rrdtool: `CacheFlush' must "
                       "be greater than 0.\n");
       ERROR("rrdtool: `CacheFlush' must "
             "be greater than 0.\n");
       return (1);
     }
-    cache_flush_timeout = DOUBLE_TO_CDTIME_T(tmp);
+    cache_flush_timeout = tmp;
   } else if (strcasecmp("DataDir", key) == 0) {
     char *tmp;
     size_t len;
 
     tmp = strdup(value);
     if (tmp == NULL) {
@@ -1048,34 +1062,21 @@
     ERROR("rrdtool plugin: c_avl_create failed.");
     return (-1);
   }
 
   cache_flush_last = cdtime();
   if (cache_timeout == 0) {
-    random_timeout = 0;
     cache_flush_timeout = 0;
-  } else if (cache_flush_timeout < cache_timeout) {
-    INFO("rrdtool plugin: \"CacheFlush %.3f\" is less than \"CacheTimeout %.3f\". "
-         "Ajusting \"CacheFlush\" to %.3f seconds.",
-         CDTIME_T_TO_DOUBLE(cache_flush_timeout),
-         CDTIME_T_TO_DOUBLE(cache_timeout),
-         CDTIME_T_TO_DOUBLE(cache_timeout * 10));
+  } else if (cache_flush_timeout < cache_timeout)
     cache_flush_timeout = 10 * cache_timeout;
-  }
-
-  /* Assure that "cache_timeout + random_variation" is never negative. */
-  if (random_timeout > cache_timeout) {
-    INFO("rrdtool plugin: Adjusting \"RandomTimeout\" to %.3f seconds.",
-         CDTIME_T_TO_DOUBLE(cache_timeout));
-    random_timeout = cache_timeout;
-  }
 
   pthread_mutex_unlock(&cache_lock);
 
-  status = plugin_thread_create(&queue_thread, /* attr = */ NULL,
-                                rrd_queue_thread, /* args = */ NULL);
+  status =
+      plugin_thread_create(&queue_thread, /* attr = */ NULL, rrd_queue_thread,
+                           /* args = */ NULL, "rrdtool queue");
   if (status != 0) {
     ERROR("rrdtool plugin: Cannot create queue-thread.");
     return (-1);
   }
   queue_thread_running = 1;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/sensors.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/sensors.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/sensors.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/sensors.c	2016-12-12 16:03:36.720279029 +0800
@@ -421,17 +421,16 @@
   ignorelist_free(sensor_list);
 
   return (0);
 } /* int sensors_shutdown */
 
 static void sensors_submit(const char *plugin_instance, const char *type,
-                           const char *type_instance, double val) {
+                           const char *type_instance, double value) {
   char match_key[1024];
   int status;
 
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
   status = ssnprintf(match_key, sizeof(match_key), "%s/%s-%s", plugin_instance,
                      type, type_instance);
   if (status < 1)
     return;
@@ -439,18 +438,15 @@
   if (sensor_list != NULL) {
     DEBUG("sensors plugin: Checking ignorelist for `%s'", match_key);
     if (ignorelist_match(sensor_list, match_key))
       return;
   }
 
-  values[0].gauge = val;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "sensors", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/serial.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/serial.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/serial.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/serial.c	2016-12-12 16:03:36.720279029 +0800
@@ -28,21 +28,19 @@
 
 #if !KERNEL_LINUX
 #error "No applicable input method."
 #endif
 
 static void serial_submit(const char *type_instance, derive_t rx, derive_t tx) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = rx;
-  values[1].derive = tx;
+  value_t values[] = {
+      {.derive = rx}, {.derive = tx},
+  };
 
   vl.values = values;
-  vl.values_len = 2;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "serial", sizeof(vl.plugin));
   sstrncpy(vl.type, "serial_octets", sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/sigrok.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/sigrok.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/sigrok.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/sigrok.c	2016-12-12 16:03:36.720279029 +0800
@@ -152,13 +152,12 @@
 
 static void sigrok_feed_callback(const struct sr_dev_inst *sdi,
                                  const struct sr_datafeed_packet *packet,
                                  void *cb_data) {
   const struct sr_datafeed_analog *analog;
   struct config_device *cfdev;
-  value_t value;
   value_list_t vl = VALUE_LIST_INIT;
 
   /* Find this device's configuration. */
   cfdev = NULL;
   for (GSList *l = config_devices; l; l = l->next) {
     cfdev = l->data;
@@ -189,18 +188,16 @@
   if ((cfdev->min_dispatch_interval != 0) &&
       ((cdtime() - cfdev->last_dispatch) < cfdev->min_dispatch_interval))
     return;
 
   /* Ignore all but the first sample on the first probe. */
   analog = packet->payload;
-  value.gauge = analog->data[0];
-  vl.values = &value;
+  vl.values = &(value_t){.gauge = analog->data[0]};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "sigrok", sizeof(vl.plugin));
-  ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%s", cfdev->name);
+  sstrncpy(vl.plugin_instance, cfdev->name, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, sigrok_value_type(analog), sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
   cfdev->last_dispatch = cdtime();
 }
 
@@ -337,13 +334,14 @@
 
   if (sr_thread_running) {
     ERROR("sigrok plugin: Thread already running.");
     return -1;
   }
 
-  status = plugin_thread_create(&sr_thread, NULL, sigrok_read_thread, NULL);
+  status = plugin_thread_create(&sr_thread, NULL, sigrok_read_thread, NULL,
+                                "sigrok read");
   if (status != 0) {
     char errbuf[1024];
     ERROR("sigrok plugin: Failed to create thread: %s.",
           sstrerror(errno, errbuf, sizeof(errbuf)));
     return -1;
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/smart.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/smart.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/smart.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/smart.c	2016-12-12 16:03:36.720279029 +0800
@@ -30,16 +30,12 @@
 #include "plugin.h"
 #include "utils_ignorelist.h"
 
 #include <atasmart.h>
 #include <libudev.h>
 
-#ifdef HAVE_SYS_CAPABILITY_H
-#include <sys/capability.h>
-#endif
-
 static const char *config_keys[] = {"Disk", "IgnoreSelected", "IgnoreSleepMode",
                                     "UseSerial"};
 
 static int config_keys_num = STATIC_ARRAY_SIZE(config_keys);
 
 static ignorelist_t *ignorelist = NULL;
@@ -71,44 +67,41 @@
 
   return (0);
 } /* int smart_config */
 
 static void smart_submit(const char *dev, const char *type,
                          const char *type_inst, double value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "smart", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, dev, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
 static void handle_attribute(SkDisk *d, const SkSmartAttributeParsedData *a,
                              void *userdata) {
   char const *name = userdata;
-  value_t values[4];
-  value_list_t vl = VALUE_LIST_INIT;
 
   if (!a->current_value_valid || !a->worst_value_valid)
     return;
-  values[0].gauge = a->current_value;
-  values[1].gauge = a->worst_value;
-  values[2].gauge = a->threshold_valid ? a->threshold : 0;
-  values[3].gauge = a->pretty_value;
+
+  value_list_t vl = VALUE_LIST_INIT;
+  value_t values[] = {
+      {.gauge = a->current_value},
+      {.gauge = a->worst_value},
+      {.gauge = a->threshold_valid ? a->threshold : 0},
+      {.gauge = a->pretty_value},
+  };
 
   vl.values = values;
-  vl.values_len = 4;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "smart", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, name, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "smart_attribute", sizeof(vl.type));
   sstrncpy(vl.type_instance, a->name, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
@@ -242,28 +235,10 @@
   udev_enumerate_unref(enumerate);
   udev_unref(handle_udev);
 
   return (0);
 } /* int smart_read */
 
-static int smart_init(void) {
-#if defined(HAVE_SYS_CAPABILITY_H) && defined(CAP_SYS_RAWIO)
-  if (check_capability(CAP_SYS_RAWIO) != 0) {
-    if (getuid() == 0)
-      WARNING("smart plugin: Running collectd as root, but the "
-              "CAP_SYS_RAWIO capability is missing. The plugin's read "
-              "function will probably fail. Is your init system dropping "
-              "capabilities?");
-    else
-      WARNING("smart plugin: collectd doesn't have the CAP_SYS_RAWIO "
-              "capability. If you don't want to run collectd as root, try "
-              "running \"setcap cap_sys_rawio=ep\" on the collectd binary.");
-  }
-#endif
-  return (0);
-} /* int smart_init */
-
 void module_register(void) {
   plugin_register_config("smart", smart_config, config_keys, config_keys_num);
-  plugin_register_init("smart", smart_init);
   plugin_register_read("smart", smart_read);
 } /* void module_register */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/snmp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/snmp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/snmp.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/snmp.c	2016-12-12 16:03:36.720279029 +0800
@@ -703,17 +703,17 @@
   DEBUG("snmp plugin: hd = { name = %s, address = %s, community = %s, version "
         "= %i }",
         hd->name, hd->address, hd->community, hd->version);
 
   ssnprintf(cb_name, sizeof(cb_name), "snmp-%s", hd->name);
 
-  user_data_t ud = {.data = hd, .free_func = csnmp_host_definition_destroy};
-
-  status =
-      plugin_register_complex_read(/* group = */ NULL, cb_name, csnmp_read_host,
-                                   hd->interval, /* user_data = */ &ud);
+  status = plugin_register_complex_read(
+      /* group = */ NULL, cb_name, csnmp_read_host, hd->interval,
+      &(user_data_t){
+          .data = hd, .free_func = csnmp_host_definition_destroy,
+      });
   if (status != 0) {
     ERROR("snmp plugin: Registering complex read function failed.");
     csnmp_host_definition_destroy(hd);
     return (-1);
   }
 
@@ -1354,23 +1354,18 @@
       snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);
     }
 
     if (oid_list_todo_num == 0) {
       /* The request is still empty - so we are finished */
       DEBUG("snmp plugin: all variables have left their subtree");
-      snmp_free_pdu(req);
       status = 0;
       break;
     }
 
     res = NULL;
     status = snmp_sess_synch_response(host->sess_handle, req, &res);
-
-    /* snmp_sess_synch_response always frees our req PDU */
-    req = NULL;
-
     if ((status != STAT_SUCCESS) || (res == NULL)) {
       char *errstr = NULL;
 
       snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);
 
       c_complain(LOG_ERR, &host->complaint,
@@ -1378,12 +1373,14 @@
                  host->name, (errstr == NULL) ? "Unknown problem" : errstr);
 
       if (res != NULL)
         snmp_free_pdu(res);
       res = NULL;
 
+      /* snmp_synch_response already freed our PDU */
+      req = NULL;
       sfree(errstr);
       csnmp_host_close_session(host);
 
       status = -1;
       break;
     }
@@ -1492,12 +1489,15 @@
   } /* while (status == 0) */
 
   if (res != NULL)
     snmp_free_pdu(res);
   res = NULL;
 
+  if (req != NULL)
+    snmp_free_pdu(req);
+  req = NULL;
 
   if (status == 0)
     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);
 
   /* Free all allocated variables here */
   while (instance_list_head != NULL) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/statsd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/statsd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/statsd.c	2017-10-06 14:45:52.965917766 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/statsd.c	2016-12-12 16:03:36.720279029 +0800
@@ -703,18 +703,16 @@
 } /* }}} int statsd_metric_clear_set_unsafe */
 
 /* Must hold metrics_lock when calling this function. */
 static int statsd_metric_submit_unsafe(char const *name,
                                        statsd_metric_t *metric) /* {{{ */
 {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  vl.values = values;
+  vl.values = &(value_t){.gauge = NAN};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "statsd", sizeof(vl.plugin));
 
   if (metric->type == STATSD_GAUGE)
     sstrncpy(vl.type, "gauge", sizeof(vl.type));
   else if (metric->type == STATSD_TIMER)
     sstrncpy(vl.type, "latency", sizeof(vl.type));
@@ -723,101 +721,101 @@
   else /* if (metric->type == STATSD_COUNTER) */
     sstrncpy(vl.type, "derive", sizeof(vl.type));
 
   sstrncpy(vl.type_instance, name, sizeof(vl.type_instance));
 
   if (metric->type == STATSD_GAUGE)
-    values[0].gauge = (gauge_t)metric->value;
+    vl.values[0].gauge = (gauge_t)metric->value;
   else if (metric->type == STATSD_TIMER) {
     _Bool have_events = (metric->updates_num > 0);
 
     /* Make sure all timer metrics share the *same* timestamp. */
     vl.time = cdtime();
 
     ssnprintf(vl.type_instance, sizeof(vl.type_instance), "%s-average", name);
-    values[0].gauge =
+    vl.values[0].gauge =
         have_events
             ? CDTIME_T_TO_DOUBLE(latency_counter_get_average(metric->latency))
             : NAN;
     plugin_dispatch_values(&vl);
 
     if (conf_timer_lower) {
       ssnprintf(vl.type_instance, sizeof(vl.type_instance), "%s-lower", name);
-      values[0].gauge =
+      vl.values[0].gauge =
           have_events
               ? CDTIME_T_TO_DOUBLE(latency_counter_get_min(metric->latency))
               : NAN;
       plugin_dispatch_values(&vl);
     }
 
     if (conf_timer_upper) {
       ssnprintf(vl.type_instance, sizeof(vl.type_instance), "%s-upper", name);
-      values[0].gauge =
+      vl.values[0].gauge =
           have_events
               ? CDTIME_T_TO_DOUBLE(latency_counter_get_max(metric->latency))
               : NAN;
       plugin_dispatch_values(&vl);
     }
 
     if (conf_timer_sum) {
       ssnprintf(vl.type_instance, sizeof(vl.type_instance), "%s-sum", name);
-      values[0].gauge =
+      vl.values[0].gauge =
           have_events
               ? CDTIME_T_TO_DOUBLE(latency_counter_get_sum(metric->latency))
               : NAN;
       plugin_dispatch_values(&vl);
     }
 
     for (size_t i = 0; i < conf_timer_percentile_num; i++) {
       ssnprintf(vl.type_instance, sizeof(vl.type_instance),
                 "%s-percentile-%.0f", name, conf_timer_percentile[i]);
-      values[0].gauge = have_events
-                            ? CDTIME_T_TO_DOUBLE(latency_counter_get_percentile(
-                                  metric->latency, conf_timer_percentile[i]))
-                            : NAN;
+      vl.values[0].gauge =
+          have_events ? CDTIME_T_TO_DOUBLE(latency_counter_get_percentile(
+                            metric->latency, conf_timer_percentile[i]))
+                      : NAN;
       plugin_dispatch_values(&vl);
     }
 
     /* Keep this at the end, since vl.type is set to "gauge" here. The
      * vl.type's above are implicitly set to "latency". */
     if (conf_timer_count) {
       sstrncpy(vl.type, "gauge", sizeof(vl.type));
       ssnprintf(vl.type_instance, sizeof(vl.type_instance), "%s-count", name);
-      values[0].gauge = latency_counter_get_num(metric->latency);
+      vl.values[0].gauge = latency_counter_get_num(metric->latency);
       plugin_dispatch_values(&vl);
     }
 
     latency_counter_reset(metric->latency);
     return (0);
   } else if (metric->type == STATSD_SET) {
     if (metric->set == NULL)
-      values[0].gauge = 0.0;
+      vl.values[0].gauge = 0.0;
     else
-      values[0].gauge = (gauge_t)c_avl_size(metric->set);
+      vl.values[0].gauge = (gauge_t)c_avl_size(metric->set);
   } else { /* STATSD_COUNTER */
     gauge_t delta = nearbyint(metric->value);
 
     /* Etsy's statsd writes counters as two metrics: a rate and the change since
      * the last write. Since collectd does not reset its DERIVE metrics to zero,
      * this makes little sense, but we're dispatching a "count" metric here
      * anyway - if requested by the user - for compatibility reasons. */
     if (conf_counter_sum) {
       sstrncpy(vl.type, "count", sizeof(vl.type));
-      values[0].gauge = delta;
+      vl.values[0].gauge = delta;
       plugin_dispatch_values(&vl);
 
       /* restore vl.type */
       sstrncpy(vl.type, "derive", sizeof(vl.type));
     }
 
     /* Rather than resetting value to zero, subtract delta so we correctly keep
      * track of residuals. */
     metric->value -= delta;
     metric->counter += (derive_t)delta;
 
-    values[0].derive = metric->counter;
+    vl.values[0].derive = metric->counter;
   }
 
   return (plugin_dispatch_values(&vl));
 } /* }}} int statsd_metric_submit_unsafe */
 
 static int statsd_read(void) /* {{{ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/swap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/swap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/swap.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/swap.c	2016-12-12 16:03:36.720279029 +0800
@@ -187,18 +187,16 @@
   return (0);
 } /* }}} int swap_init */
 
 static void swap_submit_usage(char const *plugin_instance, /* {{{ */
                               gauge_t used, gauge_t free,
                               char const *other_name, gauge_t other_value) {
-  value_t v[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  vl.values = v;
-  vl.values_len = STATIC_ARRAY_SIZE(v);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values = &(value_t){.gauge = NAN};
+  vl.values_len = 1;
   sstrncpy(vl.plugin, "swap", sizeof(vl.plugin));
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "swap", sizeof(vl.type));
 
   if (values_absolute)
@@ -211,19 +209,15 @@
 
 #if KERNEL_LINUX || HAVE_PERFSTAT
 __attribute__((nonnull(1))) static void
 swap_submit_derive(char const *type_instance, /* {{{ */
                    derive_t value) {
   value_list_t vl = VALUE_LIST_INIT;
-  value_t v[1];
 
-  v[0].derive = value;
-
-  vl.values = v;
-  vl.values_len = STATIC_ARRAY_SIZE(v);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values = &(value_t){.derive = value};
+  vl.values_len = 1;
   sstrncpy(vl.plugin, "swap", sizeof(vl.plugin));
   sstrncpy(vl.type, "swap_io", sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* }}} void swap_submit_derive */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/table.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/table.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/table.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/table.c	2016-12-12 16:03:36.720279029 +0800
@@ -364,13 +364,12 @@
       return -1;
   }
 
   vl.values = values;
   vl.values_len = STATIC_ARRAY_SIZE(values);
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "table", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, tbl->instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, res->type, sizeof(vl.type));
 
   if (0 == res->instances_num) {
     if (NULL != res->instance_prefix)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tail.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tail.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tail.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tail.c	2016-12-12 16:03:36.720279029 +0800
@@ -25,12 +25,13 @@
  **/
 
 #include "collectd.h"
 
 #include "common.h"
 #include "plugin.h"
+#include "utils_latency_config.h"
 #include "utils_tail_match.h"
 
 /*
  *  <Plugin tail>
  *    <File "/var/log/exim4/mainlog">
  *	Instance "exim"
@@ -50,12 +51,13 @@
   char *regex;
   char *excluderegex;
   int flags;
   char *type;
   char *type_instance;
   cdtime_t interval;
+  latency_config_t latency;
 };
 typedef struct ctail_config_match_s ctail_config_match_t;
 
 static cu_tail_match_t **tail_match_list = NULL;
 static size_t tail_match_list_num = 0;
 static cdtime_t tail_match_list_intervals[255];
@@ -64,54 +66,60 @@
                                          oconfig_item_t *ci) {
   if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING)) {
     WARNING("tail plugin: `DSType' needs exactly one string argument.");
     return (-1);
   }
 
-  if (strncasecmp("Gauge", ci->values[0].value.string, strlen("Gauge")) == 0) {
+  char const *ds_type = ci->values[0].value.string;
+  if (strncasecmp("Gauge", ds_type, strlen("Gauge")) == 0) {
     cm->flags = UTILS_MATCH_DS_TYPE_GAUGE;
-    if (strcasecmp("GaugeAverage", ci->values[0].value.string) == 0)
+    if (strcasecmp("GaugeAverage", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_GAUGE_AVERAGE;
-    else if (strcasecmp("GaugeMin", ci->values[0].value.string) == 0)
+    else if (strcasecmp("GaugeMin", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_GAUGE_MIN;
-    else if (strcasecmp("GaugeMax", ci->values[0].value.string) == 0)
+    else if (strcasecmp("GaugeMax", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_GAUGE_MAX;
-    else if (strcasecmp("GaugeLast", ci->values[0].value.string) == 0)
+    else if (strcasecmp("GaugeLast", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_GAUGE_LAST;
-    else if (strcasecmp("GaugeInc", ci->values[0].value.string) == 0)
+    else if (strcasecmp("GaugeInc", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_GAUGE_INC;
-    else if (strcasecmp("GaugeAdd", ci->values[0].value.string) == 0)
+    else if (strcasecmp("GaugeAdd", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_GAUGE_ADD;
+    else if (strcasecmp("GaugePersist", ci->values[0].value.string) == 0)
+      cm->flags |= UTILS_MATCH_CF_GAUGE_PERSIST;
     else
       cm->flags = 0;
-  } else if (strncasecmp("Counter", ci->values[0].value.string,
-                         strlen("Counter")) == 0) {
+  } else if (strcasecmp("Distribution", ds_type) == 0) {
+    cm->flags = UTILS_MATCH_DS_TYPE_GAUGE | UTILS_MATCH_CF_GAUGE_DIST;
+
+    int status = latency_config(&cm->latency, ci, "tail");
+    if (status != 0)
+      return (status);
+  } else if (strncasecmp("Counter", ds_type, strlen("Counter")) == 0) {
     cm->flags = UTILS_MATCH_DS_TYPE_COUNTER;
-    if (strcasecmp("CounterSet", ci->values[0].value.string) == 0)
+    if (strcasecmp("CounterSet", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_COUNTER_SET;
-    else if (strcasecmp("CounterAdd", ci->values[0].value.string) == 0)
+    else if (strcasecmp("CounterAdd", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_COUNTER_ADD;
-    else if (strcasecmp("CounterInc", ci->values[0].value.string) == 0)
+    else if (strcasecmp("CounterInc", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_COUNTER_INC;
     else
       cm->flags = 0;
-  } else if (strncasecmp("Derive", ci->values[0].value.string,
-                         strlen("Derive")) == 0) {
+  } else if (strncasecmp("Derive", ds_type, strlen("Derive")) == 0) {
     cm->flags = UTILS_MATCH_DS_TYPE_DERIVE;
-    if (strcasecmp("DeriveSet", ci->values[0].value.string) == 0)
+    if (strcasecmp("DeriveSet", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_DERIVE_SET;
-    else if (strcasecmp("DeriveAdd", ci->values[0].value.string) == 0)
+    else if (strcasecmp("DeriveAdd", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_DERIVE_ADD;
-    else if (strcasecmp("DeriveInc", ci->values[0].value.string) == 0)
+    else if (strcasecmp("DeriveInc", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_DERIVE_INC;
     else
       cm->flags = 0;
-  } else if (strncasecmp("Absolute", ci->values[0].value.string,
-                         strlen("Absolute")) == 0) {
+  } else if (strncasecmp("Absolute", ds_type, strlen("Absolute")) == 0) {
     cm->flags = UTILS_MATCH_DS_TYPE_ABSOLUTE;
-    if (strcasecmp("AbsoluteSet", ci->values[0].value.string) == 0)
+    if (strcasecmp("AbsoluteSet", ds_type) == 0)
       cm->flags |= UTILS_MATCH_CF_ABSOLUTE_SET;
     else
       cm->flags = 0;
   } else {
     cm->flags = 0;
   }
@@ -178,25 +186,26 @@
     }
 
     break;
   } /* while (status == 0) */
 
   if (status == 0) {
-    status = tail_match_add_match_simple(tm, cm.regex, cm.excluderegex,
-                                         cm.flags, "tail", plugin_instance,
-                                         cm.type, cm.type_instance, interval);
+    // TODO(octo): there's nothing "simple" about the latency stuff 
+    status = tail_match_add_match_simple(
+        tm, cm.regex, cm.excluderegex, cm.flags, "tail", plugin_instance,
+        cm.type, cm.type_instance, cm.latency, interval);
 
-    if (status != 0) {
+    if (status != 0)
       ERROR("tail plugin: tail_match_add_match_simple failed.");
-    }
   }
 
   sfree(cm.regex);
   sfree(cm.excluderegex);
   sfree(cm.type);
   sfree(cm.type_instance);
+  latency_config_free(cm.latency);
 
   return (status);
 } /* int ctail_config_add_match */
 
 static int ctail_config_add_file(oconfig_item_t *ci) {
   cu_tail_match_t *tm;
@@ -299,16 +308,17 @@
     return (-1);
   }
 
   for (size_t i = 0; i < tail_match_list_num; i++) {
     ssnprintf(str, sizeof(str), "tail-%zu", i);
 
-    user_data_t ud = {.data = tail_match_list[i]};
-
     plugin_register_complex_read(NULL, str, ctail_read,
-                                 tail_match_list_intervals[i], &ud);
+                                 tail_match_list_intervals[i],
+                                 &(user_data_t){
+                                     .data = tail_match_list[i],
+                                 });
   }
 
   return (0);
 } /* int ctail_init */
 
 static int ctail_shutdown(void) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tail_csv.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tail_csv.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tail_csv.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tail_csv.c	2016-12-12 16:03:36.720279029 +0800
@@ -64,13 +64,12 @@
   value_list_t vl = VALUE_LIST_INIT;
 
   /* Register */
   vl.values_len = 1;
   vl.values = &v;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "tail_csv", sizeof(vl.plugin));
   if (id->instance != NULL)
     sstrncpy(vl.plugin_instance, id->instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, md->type, sizeof(vl.type));
   if (md->instance != NULL)
     sstrncpy(vl.type_instance, md->instance, sizeof(vl.type_instance));
@@ -475,17 +474,17 @@
     tcsv_instance_definition_destroy(id);
     return (-1);
   }
 
   ssnprintf(cb_name, sizeof(cb_name), "tail_csv/%s", id->path);
 
-  user_data_t ud = {.data = id, .free_func = tcsv_instance_definition_destroy};
-
-  status =
-      plugin_register_complex_read(NULL, cb_name, tcsv_read, id->interval, &ud);
-
+  status = plugin_register_complex_read(
+      NULL, cb_name, tcsv_read, id->interval,
+      &(user_data_t){
+          .data = id, .free_func = tcsv_instance_definition_destroy,
+      });
   if (status != 0) {
     ERROR("tail_csv plugin: Registering complex read function failed.");
     tcsv_instance_definition_destroy(id);
     return (-1);
   }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tape.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tape.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tape.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tape.c	2016-12-12 16:03:36.720279029 +0800
@@ -54,21 +54,19 @@
 
   return (0);
 } /* int tape_init */
 
 static void tape_submit(const char *plugin_instance, const char *type,
                         derive_t read, derive_t write) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = read;
-  values[1].derive = write;
+  value_t values[] = {
+      {.derive = read}, {.derive = write},
+  };
 
   vl.values = values;
-  vl.values_len = 2;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "tape", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* void tape_submit */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/target_replace.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/target_replace.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/target_replace.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/target_replace.c	2016-12-12 16:03:36.720279029 +0800
@@ -34,23 +34,34 @@
 
 struct tr_action_s;
 typedef struct tr_action_s tr_action_t;
 struct tr_action_s {
   regex_t re;
   char *replacement;
-  int may_be_empty;
+  _Bool may_be_empty;
 
   tr_action_t *next;
 };
 
+struct tr_meta_data_action_s;
+typedef struct tr_meta_data_action_s tr_meta_data_action_t;
+struct tr_meta_data_action_s {
+  char *key;
+  regex_t re;
+  char *replacement;
+
+  tr_meta_data_action_t *next;
+};
+
 struct tr_data_s {
   tr_action_t *host;
   tr_action_t *plugin;
   tr_action_t *plugin_instance;
   /* tr_action_t *type; */
   tr_action_t *type_instance;
+  tr_meta_data_action_t *meta;
 };
 typedef struct tr_data_s tr_data_t;
 
 static char *tr_strdup(const char *orig) /* {{{ */
 {
   size_t sz;
@@ -80,14 +91,29 @@
   if (act->next != NULL)
     tr_action_destroy(act->next);
 
   sfree(act);
 } /* }}} void tr_action_destroy */
 
+static void tr_meta_data_action_destroy(tr_meta_data_action_t *act) /* {{{ */
+{
+  if (act == NULL)
+    return;
+
+  sfree(act->key);
+  regfree(&act->re);
+  sfree(act->replacement);
+
+  if (act->next != NULL)
+    tr_meta_data_action_destroy(act->next);
+
+  sfree(act);
+} /* }}} void tr_meta_data_action_destroy */
+
 static int tr_config_add_action(tr_action_t **dest, /* {{{ */
-                                const oconfig_item_t *ci, int may_be_empty) {
+                                const oconfig_item_t *ci, _Bool may_be_empty) {
   tr_action_t *act;
   int status;
 
   if (dest == NULL)
     return (-EINVAL);
 
@@ -121,14 +147,13 @@
     return (-EINVAL);
   }
 
   act->replacement = tr_strdup(ci->values[1].value.string);
   if (act->replacement == NULL) {
     ERROR("tr_config_add_action: tr_strdup failed.");
-    regfree(&act->re);
-    sfree(act);
+    tr_action_destroy(act);
     return (-ENOMEM);
   }
 
   /* Insert action at end of list. */
   if (*dest == NULL)
     *dest = act;
@@ -142,15 +167,105 @@
     prev->next = act;
   }
 
   return (0);
 } /* }}} int tr_config_add_action */
 
+static int tr_config_add_meta_action(tr_meta_data_action_t **dest, /* {{{ */
+                                     const oconfig_item_t *ci,
+                                     _Bool should_delete) {
+  tr_meta_data_action_t *act;
+  int status;
+
+  if (dest == NULL)
+    return (-EINVAL);
+
+  if (should_delete) {
+    if ((ci->values_num != 2) || (ci->values[0].type != OCONFIG_TYPE_STRING) ||
+        (ci->values[1].type != OCONFIG_TYPE_STRING)) {
+      ERROR("Target `replace': The `%s' option requires exactly two string "
+            "arguments.",
+            ci->key);
+      return (-1);
+    }
+  } else {
+    if ((ci->values_num != 3) || (ci->values[0].type != OCONFIG_TYPE_STRING) ||
+        (ci->values[1].type != OCONFIG_TYPE_STRING) ||
+        (ci->values[2].type != OCONFIG_TYPE_STRING)) {
+      ERROR("Target `replace': The `%s' option requires exactly three string "
+            "arguments.",
+            ci->key);
+      return (-1);
+    }
+  }
+
+  if (strlen(ci->values[0].value.string) == 0) {
+    ERROR("Target `replace': The `%s' option does not accept empty string as "
+          "first argument.",
+          ci->key);
+    return (-1);
+  }
+
+  act = calloc(1, sizeof(*act));
+  if (act == NULL) {
+    ERROR("tr_config_add_meta_action: calloc failed.");
+    return (-ENOMEM);
+  }
+
+  act->key = NULL;
+  act->replacement = NULL;
+
+  status = regcomp(&act->re, ci->values[1].value.string, REG_EXTENDED);
+  if (status != 0) {
+    char errbuf[1024] = "";
+
+    /* regerror assures null termination. */
+    regerror(status, &act->re, errbuf, sizeof(errbuf));
+    ERROR("Target `replace': Compiling the regular expression `%s' "
+          "failed: %s.",
+          ci->values[1].value.string, errbuf);
+    sfree(act->key);
+    sfree(act);
+    return (-EINVAL);
+  }
+
+  act->key = tr_strdup(ci->values[0].value.string);
+  if (act->key == NULL) {
+    ERROR("tr_config_add_meta_action: tr_strdup failed.");
+    tr_meta_data_action_destroy(act);
+    return (-ENOMEM);
+  }
+
+  if (!should_delete) {
+    act->replacement = tr_strdup(ci->values[2].value.string);
+    if (act->replacement == NULL) {
+      ERROR("tr_config_add_meta_action: tr_strdup failed.");
+      tr_meta_data_action_destroy(act);
+      return (-ENOMEM);
+    }
+  }
+
+  /* Insert action at end of list. */
+  if (*dest == NULL)
+    *dest = act;
+  else {
+    tr_meta_data_action_t *prev;
+
+    prev = *dest;
+    while (prev->next != NULL)
+      prev = prev->next;
+
+    prev->next = act;
+  }
+
+  return (0);
+} /* }}} int tr_config_add_meta_action */
+
 static int tr_action_invoke(tr_action_t *act_head, /* {{{ */
                             char *buffer_in, size_t buffer_in_size,
-                            int may_be_empty) {
+                            _Bool may_be_empty) {
   int status;
   char buffer[DATA_MAX_NAME_LEN];
   regmatch_t matches[8] = {[0] = {0}};
 
   if (act_head == NULL)
     return (-EINVAL);
@@ -199,12 +314,116 @@
   DEBUG("target_replace plugin: tr_action_invoke: -> buffer = %s;", buffer);
   sstrncpy(buffer_in, buffer, buffer_in_size);
 
   return (0);
 } /* }}} int tr_action_invoke */
 
+static int tr_meta_data_action_invoke(/* {{{ */
+                                      tr_meta_data_action_t *act_head,
+                                      meta_data_t **dest) {
+  int status;
+  regmatch_t matches[8] = {[0] = {0}};
+
+  if (act_head == NULL)
+    return (-EINVAL);
+
+  if ((*dest) == NULL) /* nothing to do */
+    return (0);
+
+  for (tr_meta_data_action_t *act = act_head; act != NULL; act = act->next) {
+    char temp[DATA_MAX_NAME_LEN];
+    char *subst_status;
+    int value_type;
+    int meta_data_status;
+    char *value;
+    meta_data_t *result;
+
+    value_type = meta_data_type(*dest, act->key);
+    if (value_type == 0) /* not found */
+      continue;
+    if (value_type != MD_TYPE_STRING) {
+      WARNING("Target `replace': Attempting replace on metadata key `%s', "
+              "which isn't a string.",
+              act->key);
+      continue;
+    }
+
+    meta_data_status = meta_data_get_string(*dest, act->key, &value);
+    if (meta_data_status != 0) {
+      ERROR("Target `replace': Unable to retrieve metadata value for `%s'.",
+            act->key);
+      return (meta_data_status);
+    }
+
+    DEBUG("target_replace plugin: tr_meta_data_action_invoke: `%s' "
+          "old value = `%s'",
+          act->key, value);
+
+    status = regexec(&act->re, value, STATIC_ARRAY_SIZE(matches), matches,
+                     /* flags = */ 0);
+    if (status == REG_NOMATCH) {
+      sfree(value);
+      continue;
+    } else if (status != 0) {
+      char errbuf[1024] = "";
+
+      regerror(status, &act->re, errbuf, sizeof(errbuf));
+      ERROR("Target `replace': Executing a regular expression failed: %s.",
+            errbuf);
+      sfree(value);
+      continue;
+    }
+
+    if (act->replacement == NULL) {
+      /* no replacement; delete the key */
+      DEBUG("target_replace plugin: tr_meta_data_action_invoke: "
+            "deleting `%s'",
+            act->key);
+      meta_data_delete(*dest, act->key);
+      sfree(value);
+      continue;
+    }
+
+    subst_status = subst(temp, sizeof(temp), value, (size_t)matches[0].rm_so,
+                         (size_t)matches[0].rm_eo, act->replacement);
+    if (subst_status == NULL) {
+      ERROR("Target `replace': subst (value = %s, start = %zu, end = %zu, "
+            "replacement = %s) failed.",
+            value, (size_t)matches[0].rm_so, (size_t)matches[0].rm_eo,
+            act->replacement);
+      sfree(value);
+      continue;
+    }
+
+    DEBUG("target_replace plugin: tr_meta_data_action_invoke: `%s' "
+          "value `%s' -> `%s'",
+          act->key, value, temp);
+
+    if ((result = meta_data_create()) == NULL) {
+      ERROR("Target `replace': failed to create metadata for `%s'.", act->key);
+      sfree(value);
+      return (-ENOMEM);
+    }
+
+    meta_data_status = meta_data_add_string(result, act->key, temp);
+    if (meta_data_status != 0) {
+      ERROR("Target `replace': Unable to set metadata value for `%s'.",
+            act->key);
+      meta_data_destroy(result);
+      sfree(value);
+      return (meta_data_status);
+    }
+
+    meta_data_clone_merge(dest, result);
+    meta_data_destroy(result);
+    sfree(value);
+  } /* for (act = act_head; act != NULL; act = act->next) */
+
+  return (0);
+} /* }}} int tr_meta_data_action_invoke */
+
 static int tr_destroy(void **user_data) /* {{{ */
 {
   tr_data_t *data;
 
   if (user_data == NULL)
     return (-EINVAL);
@@ -215,12 +434,13 @@
 
   tr_action_destroy(data->host);
   tr_action_destroy(data->plugin);
   tr_action_destroy(data->plugin_instance);
   /* tr_action_destroy (data->type); */
   tr_action_destroy(data->type_instance);
+  tr_meta_data_action_destroy(data->meta);
   sfree(data);
 
   return (0);
 } /* }}} int tr_destroy */
 
 static int tr_create(const oconfig_item_t *ci, void **user_data) /* {{{ */
@@ -236,12 +456,13 @@
 
   data->host = NULL;
   data->plugin = NULL;
   data->plugin_instance = NULL;
   /* data->type = NULL; */
   data->type_instance = NULL;
+  data->meta = NULL;
 
   status = 0;
   for (int i = 0; i < ci->children_num; i++) {
     oconfig_item_t *child = ci->children + i;
 
     if ((strcasecmp("Host", child->key) == 0) ||
@@ -259,12 +480,18 @@
       status = tr_config_add_action (&data->type, child,
           /* may be empty = */ 0);
 #endif
     else if (strcasecmp("TypeInstance", child->key) == 0)
       status = tr_config_add_action(&data->type_instance, child,
                                     /* may be empty = */ 1);
+    else if (strcasecmp("MetaData", child->key) == 0)
+      status = tr_config_add_meta_action(&data->meta, child,
+                                         /* should delete = */ 0);
+    else if (strcasecmp("DeleteMetaData", child->key) == 0)
+      status = tr_config_add_meta_action(&data->meta, child,
+                                         /* should delete = */ 1);
     else {
       ERROR("Target `replace': The `%s' configuration option is not understood "
             "and will be ignored.",
             child->key);
       status = 0;
     }
@@ -275,13 +502,13 @@
 
   /* Additional sanity-checking */
   while (status == 0) {
     if ((data->host == NULL) && (data->plugin == NULL) &&
         (data->plugin_instance == NULL)
         /* && (data->type == NULL) */
-        && (data->type_instance == NULL)) {
+        && (data->type_instance == NULL) && (data->meta == NULL)) {
       ERROR("Target `replace': You need to set at least one of `Host', "
             "`Plugin', `PluginInstance' or `TypeInstance'.");
       status = -1;
     }
 
     break;
@@ -307,19 +534,23 @@
   data = *user_data;
   if (data == NULL) {
     ERROR("Target `replace': Invoke: `data' is NULL.");
     return (-EINVAL);
   }
 
+  if (data->meta != NULL) {
+    tr_meta_data_action_invoke(data->meta, &(vl->meta));
+  }
+
 #define HANDLE_FIELD(f, e)                                                     \
   if (data->f != NULL)                                                         \
   tr_action_invoke(data->f, vl->f, sizeof(vl->f), e)
   HANDLE_FIELD(host, 0);
   HANDLE_FIELD(plugin, 0);
   HANDLE_FIELD(plugin_instance, 1);
-  /* HANDLE_FIELD (type); */
+  /* HANDLE_FIELD (type, 0); */
   HANDLE_FIELD(type_instance, 1);
 
   return (FC_TARGET_CONTINUE);
 } /* }}} int tr_invoke */
 
 void module_register(void) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/target_set.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/target_set.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/target_set.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/target_set.c	2016-12-12 16:03:36.720279029 +0800
@@ -25,31 +25,53 @@
  **/
 
 #include "collectd.h"
 
 #include "common.h"
 #include "filter_chain.h"
+#include "meta_data.h"
+#include "utils_subst.h"
+
+struct ts_key_list_s {
+  char *key;
+  struct ts_key_list_s *next;
+};
+typedef struct ts_key_list_s ts_key_list_t;
+
+static void ts_key_list_free(ts_key_list_t *l) /* {{{ */
+{
+  if (l == NULL)
+    return;
+
+  sfree(l->key);
+
+  if (l->next != NULL)
+    ts_key_list_free(l->next);
+
+  sfree(l);
+} /* }}} void ts_name_list_free */
 
 struct ts_data_s {
   char *host;
   char *plugin;
   char *plugin_instance;
   /* char *type; */
   char *type_instance;
   meta_data_t *meta;
+  ts_key_list_t *meta_delete;
 };
 typedef struct ts_data_s ts_data_t;
 
 static int ts_util_get_key_and_string_wo_strdup(const oconfig_item_t *ci,
                                                 char **ret_key,
                                                 char **ret_string) /* {{{ */
 {
   if ((ci->values_num != 2) || (ci->values[0].type != OCONFIG_TYPE_STRING) ||
       (ci->values[1].type != OCONFIG_TYPE_STRING)) {
     ERROR("ts_util_get_key_and_string_wo_strdup: The %s option requires "
-          "exactly two string argument.",
+          "exactly two string arguments.",
           ci->key);
     return (-1);
   }
 
   *ret_key = ci->values[0].value.string;
   *ret_string = ci->values[1].value.string;
@@ -85,36 +107,104 @@
 
   status = ts_util_get_key_and_string_wo_strdup(ci, &key, &string);
   if (status != 0)
     return (status);
 
   if (strlen(key) == 0) {
-    ERROR("Target `set': The `%s' option does not accept empty string as first "
-          "argument.",
+    ERROR("Target `set': The `%s' option does not accept empty string as "
+          "first argument.",
           ci->key);
     return (-1);
   }
 
   if (!may_be_empty && (strlen(string) == 0)) {
     ERROR("Target `set': The `%s' option does not accept empty string as "
           "second argument.",
           ci->key);
     return (-1);
   }
 
   if ((*dest) == NULL) {
-    // Create a new meta_data_t
+    /* Create a new meta_data_t */
     if ((*dest = meta_data_create()) == NULL) {
       ERROR("Target `set': failed to create a meta data for `%s'.", ci->key);
-      return (-1);
+      return (-ENOMEM);
     }
   }
 
   return (meta_data_add_string(*dest, key, string));
 } /* }}} int ts_config_add_meta */
 
+static int ts_config_add_meta_delete(ts_key_list_t **dest, /* {{{ */
+                                     const oconfig_item_t *ci) {
+  ts_key_list_t *entry = NULL;
+
+  entry = calloc(1, sizeof(*entry));
+  if (entry == NULL) {
+    ERROR("ts_config_add_meta_delete: calloc failed.");
+    return (-ENOMEM);
+  }
+
+  if (cf_util_get_string(ci, &entry->key) != 0) {
+    ts_key_list_free(entry);
+    return (-1); /* An error has already been reported. */
+  }
+
+  if (strlen(entry->key) == 0) {
+    ERROR("Target `set': The `%s' option does not accept empty string as "
+          "first argument.",
+          ci->key);
+    ts_key_list_free(entry);
+    return (-1);
+  }
+
+  entry->next = *dest;
+  *dest = entry;
+
+  return (0);
+} /* }}} int ts_config_add_meta_delete */
+
+static void ts_subst(char *dest, size_t size, const char *string, /* {{{ */
+                     const value_list_t *vl) {
+  char temp[DATA_MAX_NAME_LEN];
+
+  /* Initialize the field with the template. */
+  sstrncpy(dest, string, size);
+
+  if (strchr(dest, '%') == NULL)
+    return;
+
+#define REPLACE_FIELD(t, v)                                                    \
+  if (subst_string(temp, sizeof(temp), dest, t, v) != NULL)                    \
+    sstrncpy(dest, temp, size);
+  REPLACE_FIELD("%{host}", vl->host);
+  REPLACE_FIELD("%{plugin}", vl->plugin);
+  REPLACE_FIELD("%{plugin_instance}", vl->plugin_instance);
+  REPLACE_FIELD("%{type}", vl->type);
+  REPLACE_FIELD("%{type_instance}", vl->type_instance);
+
+  if (vl->meta != NULL) {
+    char **meta_toc;
+    int meta_entries = meta_data_toc(vl->meta, &meta_toc);
+    for (int i = 0; i < meta_entries; i++) {
+      char meta_name[DATA_MAX_NAME_LEN];
+      char *value_str;
+      const char *key = meta_toc[i];
+
+      ssnprintf(meta_name, sizeof(meta_name), "%%{meta:%s}", key);
+      if (meta_data_as_string(vl->meta, key, &value_str) != 0)
+        continue;
+
+      REPLACE_FIELD(meta_name, value_str);
+      sfree(value_str);
+    }
+
+    strarray_free(meta_toc, (size_t)meta_entries);
+  }
+} /* }}} int ts_subst */
+
 static int ts_destroy(void **user_data) /* {{{ */
 {
   ts_data_t *data;
 
   if (user_data == NULL)
     return (-EINVAL);
@@ -126,12 +216,13 @@
   free(data->host);
   free(data->plugin);
   free(data->plugin_instance);
   /* free (data->type); */
   free(data->type_instance);
   meta_data_destroy(data->meta);
+  ts_key_list_free(data->meta_delete);
   free(data);
 
   return (0);
 } /* }}} int ts_destroy */
 
 static int ts_create(const oconfig_item_t *ci, void **user_data) /* {{{ */
@@ -148,12 +239,13 @@
   data->host = NULL;
   data->plugin = NULL;
   data->plugin_instance = NULL;
   /* data->type = NULL; */
   data->type_instance = NULL;
   data->meta = NULL;
+  data->meta_delete = NULL;
 
   status = 0;
   for (int i = 0; i < ci->children_num; i++) {
     oconfig_item_t *child = ci->children + i;
 
     if ((strcasecmp("Host", child->key) == 0) ||
@@ -174,12 +266,14 @@
     else if (strcasecmp("TypeInstance", child->key) == 0)
       status = ts_config_add_string(&data->type_instance, child,
                                     /* may be empty = */ 1);
     else if (strcasecmp("MetaData", child->key) == 0)
       status = ts_config_add_meta(&data->meta, child,
                                   /* may be empty = */ 1);
+    else if (strcasecmp("DeleteMetaData", child->key) == 0)
+      status = ts_config_add_meta_delete(&data->meta_delete, child);
     else {
       ERROR("Target `set': The `%s' configuration option is not understood "
             "and will be ignored.",
             child->key);
       status = 0;
     }
@@ -190,18 +284,32 @@
 
   /* Additional sanity-checking */
   while (status == 0) {
     if ((data->host == NULL) && (data->plugin == NULL) &&
         (data->plugin_instance == NULL)
         /* && (data->type == NULL) */
-        && (data->type_instance == NULL) && (data->meta == NULL)) {
+        && (data->type_instance == NULL) && (data->meta == NULL) &&
+        (data->meta_delete == NULL)) {
       ERROR("Target `set': You need to set at least one of `Host', "
-            "`Plugin', `PluginInstance', `TypeInstance', `MetaData'.");
+            "`Plugin', `PluginInstance', `TypeInstance', "
+            "`MetaData', or `DeleteMetaData'.");
       status = -1;
     }
 
+    if (data->meta != NULL) {
+      /* If data->meta_delete is NULL, this loop is a no-op. */
+      for (ts_key_list_t *l = data->meta_delete; l != NULL; l = l->next) {
+        if (meta_data_type(data->meta, l->key) != 0) {
+          /* MetaData and DeleteMetaData for the same key. */
+          ERROR("Target `set': Can only have one of `MetaData' or "
+                "`DeleteMetaData' for any given key.");
+          status = -1;
+        }
+      }
+    }
+
     break;
   }
 
   if (status != 0) {
     ts_destroy((void *)&data);
     return (status);
@@ -212,35 +320,92 @@
 } /* }}} int ts_create */
 
 static int ts_invoke(const data_set_t *ds, value_list_t *vl, /* {{{ */
                      notification_meta_t __attribute__((unused)) * *meta,
                      void **user_data) {
   ts_data_t *data;
+  value_list_t orig;
+  meta_data_t *new_meta = NULL;
 
   if ((ds == NULL) || (vl == NULL) || (user_data == NULL))
     return (-EINVAL);
 
   data = *user_data;
   if (data == NULL) {
     ERROR("Target `set': Invoke: `data' is NULL.");
     return (-EINVAL);
   }
 
+  orig = *vl;
+
   if (data->meta != NULL) {
-    meta_data_clone_merge(&(vl->meta), data->meta);
+    char temp[DATA_MAX_NAME_LEN * 2];
+    int meta_entries;
+    char **meta_toc;
+
+    if ((new_meta = meta_data_create()) == NULL) {
+      ERROR("Target `set': failed to create replacement metadata.");
+      return (-ENOMEM);
+    }
+
+    meta_entries = meta_data_toc(data->meta, &meta_toc);
+    for (int i = 0; i < meta_entries; i++) {
+      const char *key = meta_toc[i];
+      char *string;
+      int status;
+
+      status = meta_data_get_string(data->meta, key, &string);
+      if (status) {
+        ERROR("Target `set': Unable to get replacement metadata value `%s'.",
+              key);
+        strarray_free(meta_toc, (size_t)meta_entries);
+        return (status);
+      }
+
+      ts_subst(temp, sizeof(temp), string, &orig);
+
+      DEBUG("target_set: ts_invoke: setting metadata value for key `%s': "
+            "`%s'.",
+            key, temp);
+
+      sfree(string);
+
+      status = meta_data_add_string(new_meta, key, temp);
+      if (status) {
+        ERROR("Target `set': Unable to set metadata value `%s'.", key);
+        strarray_free(meta_toc, (size_t)meta_entries);
+        return (status);
+      }
+    }
+
+    strarray_free(meta_toc, (size_t)meta_entries);
   }
 
-#define SET_FIELD(f)                                                           \
+#define SUBST_FIELD(f)                                                         \
   if (data->f != NULL) {                                                       \
-    sstrncpy(vl->f, data->f, sizeof(vl->f));                                   \
+    ts_subst(vl->f, sizeof(vl->f), data->f, &orig);                            \
+    DEBUG("target_set: ts_invoke: setting " #f ": `%s'.", vl->f);              \
+  }
+  SUBST_FIELD(host);
+  SUBST_FIELD(plugin);
+  SUBST_FIELD(plugin_instance);
+  /* SUBST_FIELD (type); */
+  SUBST_FIELD(type_instance);
+
+  /* Need to merge the metadata in now, because of the shallow copy. */
+  if (new_meta != NULL) {
+    meta_data_clone_merge(&(vl->meta), new_meta);
+    meta_data_destroy(new_meta);
+  }
+
+  /* If data->meta_delete is NULL, this loop is a no-op. */
+  for (ts_key_list_t *l = data->meta_delete; l != NULL; l = l->next) {
+    DEBUG("target_set: ts_invoke: deleting metadata value for key `%s'.",
+          l->key);
+    meta_data_delete(vl->meta, l->key);
   }
-  SET_FIELD(host);
-  SET_FIELD(plugin);
-  SET_FIELD(plugin_instance);
-  /* SET_FIELD (type); */
-  SET_FIELD(type_instance);
 
   return (FC_TARGET_CONTINUE);
 } /* }}} int ts_invoke */
 
 void module_register(void) {
   target_proc_t tproc = {0};
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/target_v5upgrade.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/target_v5upgrade.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/target_v5upgrade.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/target_v5upgrade.c	2016-12-12 16:03:36.720279029 +0800
@@ -50,23 +50,22 @@
  * to "df_complex". This can be selected in versions 4.9 and 4.10 by setting
  * the "ReportReserved" option of the "df" plugin.
  */
 static int v5_df(const data_set_t *ds, value_list_t *vl) /* {{{ */
 {
   value_list_t new_vl;
-  value_t new_value;
 
   /* Can't upgrade if both instances have been set. */
   if ((vl->plugin_instance[0] != 0) && (vl->type_instance[0] != 0))
     return (FC_TARGET_CONTINUE);
 
   /* Copy everything: Time, interval, host, ... */
   memcpy(&new_vl, vl, sizeof(new_vl));
 
   /* Reset data we can't simply copy */
-  new_vl.values = &new_value;
+  new_vl.values = &(value_t){.gauge = NAN};
   new_vl.values_len = 1;
   new_vl.meta = NULL;
 
   /* Move the mount point name to the plugin instance */
   if (new_vl.plugin_instance[0] == 0)
     v5_swap_instances(&new_vl);
@@ -109,22 +108,21 @@
  * 4.* uses the "mysql_qcache" type which mixes different types of
  * information. In 5.* this has been broken up.
  */
 static int v5_mysql_qcache(const data_set_t *ds, value_list_t *vl) /* {{{ */
 {
   value_list_t new_vl;
-  value_t new_value;
 
   if (vl->values_len != 5)
     return (FC_TARGET_STOP);
 
   /* Copy everything: Time, interval, host, ... */
   memcpy(&new_vl, vl, sizeof(new_vl));
 
   /* Reset data we can't simply copy */
-  new_vl.values = &new_value;
+  new_vl.values = &(value_t){.gauge = NAN};
   new_vl.values_len = 1;
   new_vl.meta = NULL;
 
   /* Change the type to "cache_result" */
   sstrncpy(new_vl.type, "cache_result", sizeof(new_vl.type));
 
@@ -164,22 +162,21 @@
  * 4.* uses the "mysql_threads" type which mixes different types of
  * information. In 5.* this has been broken up.
  */
 static int v5_mysql_threads(const data_set_t *ds, value_list_t *vl) /* {{{ */
 {
   value_list_t new_vl;
-  value_t new_value;
 
   if (vl->values_len != 4)
     return (FC_TARGET_STOP);
 
   /* Copy everything: Time, interval, host, ... */
   memcpy(&new_vl, vl, sizeof(new_vl));
 
   /* Reset data we can't simply copy */
-  new_vl.values = &new_value;
+  new_vl.values = &(value_t){.gauge = NAN};
   new_vl.values_len = 1;
   new_vl.meta = NULL;
 
   /* Change the type to "threads" */
   sstrncpy(new_vl.type, "threads", sizeof(new_vl.type));
 
@@ -213,13 +210,12 @@
  * 4.* uses the flawed "arc_counts" type. In 5.* this has been replaced by the
  * more generic "cache_result" type.
  */
 static int v5_zfs_arc_counts(const data_set_t *ds, value_list_t *vl) /* {{{ */
 {
   value_list_t new_vl;
-  value_t new_value;
   _Bool is_hits;
 
   if (vl->values_len != 4)
     return (FC_TARGET_STOP);
 
   if (strcmp("hits", vl->type_instance) == 0)
@@ -230,13 +226,13 @@
     return (FC_TARGET_STOP);
 
   /* Copy everything: Time, interval, host, ... */
   memcpy(&new_vl, vl, sizeof(new_vl));
 
   /* Reset data we can't simply copy */
-  new_vl.values = &new_value;
+  new_vl.values = &(value_t){.gauge = NAN};
   new_vl.values_len = 1;
   new_vl.meta = NULL;
 
   /* Change the type to "cache_result" */
   sstrncpy(new_vl.type, "cache_result", sizeof(new_vl.type));
 
@@ -270,32 +266,33 @@
  *
  * "arc_l2_bytes" -> "io_octets-L2".
  */
 static int v5_zfs_arc_l2_bytes(const data_set_t *ds, value_list_t *vl) /* {{{ */
 {
   value_list_t new_vl;
-  value_t new_values[2];
 
   if (vl->values_len != 2)
     return (FC_TARGET_STOP);
 
   /* Copy everything: Time, interval, host, ... */
   memcpy(&new_vl, vl, sizeof(new_vl));
 
   /* Reset data we can't simply copy */
-  new_vl.values = new_values;
-  new_vl.values_len = 2;
   new_vl.meta = NULL;
 
   /* Change the type/-instance to "io_octets-L2" */
   sstrncpy(new_vl.type, "io_octets", sizeof(new_vl.type));
   sstrncpy(new_vl.type_instance, "L2", sizeof(new_vl.type_instance));
 
   /* Copy the actual values. */
-  new_vl.values[0].derive = (derive_t)vl->values[0].counter;
-  new_vl.values[1].derive = (derive_t)vl->values[1].counter;
+  value_t values[] = {
+      {.derive = (derive_t)vl->values[0].counter},
+      {.derive = (derive_t)vl->values[1].counter},
+  };
+  new_vl.values = values;
+  new_vl.values_len = STATIC_ARRAY_SIZE(values);
 
   /* Dispatch new value lists instead of this one */
   plugin_dispatch_values(&new_vl);
 
   /* Abort processing */
   return (FC_TARGET_STOP);
@@ -307,22 +304,21 @@
  * 4.* uses a separate type for this. 5.* uses the generic "cache_size" type
  * instead.
  */
 static int v5_zfs_arc_l2_size(const data_set_t *ds, value_list_t *vl) /* {{{ */
 {
   value_list_t new_vl;
-  value_t new_value;
 
   if (vl->values_len != 1)
     return (FC_TARGET_STOP);
 
   /* Copy everything: Time, interval, host, ... */
   memcpy(&new_vl, vl, sizeof(new_vl));
 
   /* Reset data we can't simply copy */
-  new_vl.values = &new_value;
+  new_vl.values = &(value_t){.gauge = NAN};
   new_vl.values_len = 1;
   new_vl.meta = NULL;
 
   new_vl.values[0].gauge = (gauge_t)vl->values[0].gauge;
 
   /* Change the type to "cache_size" */
@@ -344,22 +340,21 @@
  * "arc_ratio-L1" -> "cache_ratio-arc"
  * "arc_ratio-L2" -> "cache_ratio-L2"
  */
 static int v5_zfs_arc_ratio(const data_set_t *ds, value_list_t *vl) /* {{{ */
 {
   value_list_t new_vl;
-  value_t new_value;
 
   if (vl->values_len != 1)
     return (FC_TARGET_STOP);
 
   /* Copy everything: Time, interval, host, ... */
   memcpy(&new_vl, vl, sizeof(new_vl));
 
   /* Reset data we can't simply copy */
-  new_vl.values = &new_value;
+  new_vl.values = &(value_t){.gauge = NAN};
   new_vl.values_len = 1;
   new_vl.meta = NULL;
 
   new_vl.values[0].gauge = (gauge_t)vl->values[0].gauge;
 
   /* Change the type to "cache_ratio" */
@@ -382,22 +377,21 @@
  * 4.* uses the "arc_size" type with four data sources. In 5.* this has been
  * replaces with the "cache_size" type and static data has been removed.
  */
 static int v5_zfs_arc_size(const data_set_t *ds, value_list_t *vl) /* {{{ */
 {
   value_list_t new_vl;
-  value_t new_value;
 
   if (vl->values_len != 4)
     return (FC_TARGET_STOP);
 
   /* Copy everything: Time, interval, host, ... */
   memcpy(&new_vl, vl, sizeof(new_vl));
 
   /* Reset data we can't simply copy */
-  new_vl.values = &new_value;
+  new_vl.values = &(value_t){.gauge = NAN};
   new_vl.values_len = 1;
   new_vl.meta = NULL;
 
   /* Change the type to "cache_size" */
   sstrncpy(new_vl.type, "cache_size", sizeof(new_vl.type));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tcpconns.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tcpconns.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tcpconns.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tcpconns.c	2016-12-12 16:03:36.720279029 +0800
@@ -248,13 +248,12 @@
 static enum { SRC_DUNNO, SRC_NETLINK, SRC_PROC } linux_source = SRC_DUNNO;
 #endif
 
 static void conn_prepare_vl(value_list_t *vl, value_t *values) {
   vl->values = values;
   vl->values_len = 1;
-  sstrncpy(vl->host, hostname_g, sizeof(vl->host));
   sstrncpy(vl->plugin, "tcpconns", sizeof(vl->plugin));
   sstrncpy(vl->type, "tcp_connections", sizeof(vl->type));
 }
 
 static void conn_submit_port_entry(port_entry_t *pe) {
   value_t values[1];
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/teamspeak2.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/teamspeak2.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/teamspeak2.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/teamspeak2.c	2016-12-12 16:03:36.720279029 +0800
@@ -105,20 +105,16 @@
 
 static void tss2_submit_gauge(const char *plugin_instance, const char *type,
                               const char *type_instance, gauge_t value) {
   /*
    * Submits a gauge value to the collectd daemon
    */
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "teamspeak2", sizeof(vl.plugin));
 
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
 
   sstrncpy(vl.type, type, sizeof(vl.type));
@@ -131,21 +127,19 @@
 
 static void tss2_submit_io(const char *plugin_instance, const char *type,
                            derive_t rx, derive_t tx) {
   /*
    * Submits the io rx/tx tuple to the collectd daemon
    */
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = rx;
-  values[1].derive = tx;
+  value_t values[] = {
+      {.derive = rx}, {.derive = tx},
+  };
 
   vl.values = values;
-  vl.values_len = 2;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values_len = STATIC_ARRAY_SIZE(values);
   sstrncpy(vl.plugin, "teamspeak2", sizeof(vl.plugin));
 
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
 
   sstrncpy(vl.type, type, sizeof(vl.type));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ted.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ted.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/ted.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/ted.c	2016-12-12 16:03:36.720279029 +0800
@@ -226,20 +226,16 @@
 
   INFO("ted plugin: Successfully opened %s.", dev);
   return (0);
 } /* int ted_open_device */
 
 static void ted_submit(const char *type, double value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "ted", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/testing.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/testing.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/testing.h	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/testing.h	2016-12-12 16:03:36.720279029 +0800
@@ -48,16 +48,19 @@
       fail_count__++;                                                          \
     }                                                                          \
   } while (0)
 
 #define END_TEST exit((fail_count__ == 0) ? 0 : 1);
 
+#define LOG(result, text)                                                      \
+  printf("%s %i - %s\n", result ? "ok" : "not ok", ++check_count__, text)
+
 #define OK1(cond, text)                                                        \
   do {                                                                         \
     _Bool result = (cond);                                                     \
-    printf("%s %i - %s\n", result ? "ok" : "not ok", ++check_count__, text);   \
+    LOG(result, text);                                                         \
     if (!result) {                                                             \
       return -1;                                                               \
     }                                                                          \
   } while (0)
 #define OK(cond) OK1(cond, #cond)
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/thermal.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/thermal.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/thermal.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/thermal.c	2016-12-12 16:03:36.720279029 +0800
@@ -38,79 +38,47 @@
 static _Bool force_procfs = 0;
 static ignorelist_t *device_list;
 
 enum dev_type { TEMP = 0, COOLING_DEV };
 
 static void thermal_submit(const char *plugin_instance, enum dev_type dt,
-                           gauge_t value) {
+                           value_t value) {
   value_list_t vl = VALUE_LIST_INIT;
-  value_t v;
-
-  v.gauge = value;
-  vl.values = &v;
 
+  vl.values = &value;
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "thermal", sizeof(vl.plugin));
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, (dt == TEMP) ? "temperature" : "gauge", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 }
 
 static int thermal_sysfs_device_read(const char __attribute__((unused)) * dir,
                                      const char *name,
                                      void __attribute__((unused)) * user_data) {
-  char filename[256];
-  char data[1024];
-  int len;
+  char filename[PATH_MAX];
   _Bool success = 0;
+  value_t value;
 
   if (device_list && ignorelist_match(device_list, name))
     return -1;
 
-  len =
-      ssnprintf(filename, sizeof(filename), "%s/%s/temp", dirname_sysfs, name);
-  if ((len < 0) || ((size_t)len >= sizeof(filename)))
-    return -1;
-
-  len = (ssize_t)read_file_contents(filename, data, sizeof(data));
-  if (len > 1 && data[--len] == '\n') {
-    char *endptr = NULL;
-    double temp;
-
-    data[len] = 0;
-    errno = 0;
-    temp = strtod(data, &endptr) / 1000.0;
-
-    if (endptr == data + len && errno == 0) {
-      thermal_submit(name, TEMP, temp);
-      success = 1;
-    }
+  ssnprintf(filename, sizeof(filename), "%s/%s/temp", dirname_sysfs, name);
+  if (parse_value_file(filename, &value, DS_TYPE_GAUGE) == 0) {
+    value.gauge /= 1000.0;
+    thermal_submit(name, TEMP, value);
+    success = 1;
   }
 
-  len = ssnprintf(filename, sizeof(filename), "%s/%s/cur_state", dirname_sysfs,
-                  name);
-  if ((len < 0) || ((size_t)len >= sizeof(filename)))
-    return -1;
-
-  len = (ssize_t)read_file_contents(filename, data, sizeof(data));
-  if (len > 1 && data[--len] == '\n') {
-    char *endptr = NULL;
-    double state;
-
-    data[len] = 0;
-    errno = 0;
-    state = strtod(data, &endptr);
-
-    if (endptr == data + len && errno == 0) {
-      thermal_submit(name, COOLING_DEV, state);
-      success = 1;
-    }
+  ssnprintf(filename, sizeof(filename), "%s/%s/cur_state", dirname_sysfs, name);
+  if (parse_value_file(filename, &value, DS_TYPE_GAUGE) == 0) {
+    thermal_submit(name, COOLING_DEV, value);
+    success = 1;
   }
 
   return (success ? 0 : -1);
 }
 
 static int thermal_procfs_device_read(const char __attribute__((unused)) * dir,
@@ -163,13 +131,13 @@
     ++len;
 
     errno = 0;
     temp = (strtod(data + len, &endptr) + add) * factor;
 
     if (endptr != data + len && errno == 0) {
-      thermal_submit(name, TEMP, temp);
+      thermal_submit(name, TEMP, (value_t){.gauge = temp});
       return 0;
     }
   }
 
   return -1;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tokyotyrant.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tokyotyrant.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/tokyotyrant.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/tokyotyrant.c	2016-12-12 16:03:36.720279029 +0800
@@ -69,20 +69,17 @@
 
 static void printerr(void) {
   int ecode = tcrdbecode(rdb);
   ERROR("tokyotyrant plugin: error: %d, %s", ecode, tcrdberrmsg(ecode));
 }
 
-static void tt_submit(gauge_t val, const char *type) {
-  value_t values[1];
+static void tt_submit(gauge_t value, const char *type) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = val;
-
-  vl.values = values;
-  vl.values_len = STATIC_ARRAY_SIZE(values);
+  vl.values = &(value_t){.gauge = value};
+  vl.values_len = 1;
 
   sstrncpy(vl.host, config_host, sizeof(vl.host));
   sstrncpy(vl.plugin, "tokyotyrant", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, config_port, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/turbostat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/turbostat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/turbostat.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/turbostat.c	2016-12-12 16:03:36.720279029 +0800
@@ -65,12 +65,17 @@
  *
  * This value is automatically set if mperf or aperf go backward
  */
 static _Bool aperf_mperf_unstable;
 
 /*
+ * If set, use kernel logical core numbering for all "per core" metrics.
+ */
+static _Bool config_lcn;
+
+/*
  * Bitmask of the list of core C states supported by the processor.
  * Currently supported C-states (by this plugin): 3, 6, 7
  */
 static unsigned int do_core_cstate;
 static unsigned int config_core_cstate;
 static _Bool apply_config_core_cstate;
@@ -224,12 +229,13 @@
     "PackageCstates",
     "SystemManagementInterrupt",
     "DigitalTemperatureSensor",
     "PackageThermalManagement",
     "TCCActivationTemp",
     "RunningAveragePowerLimit",
+    "LogicalCoreNames",
 };
 static const int config_keys_num = STATIC_ARRAY_SIZE(config_keys);
 
 /*****************************
  *  MSR Manipulation helpers *
  *****************************/
@@ -516,18 +522,15 @@
 /*
  * Submit one gauge value
  */
 static void turbostat_submit(const char *plugin_instance, const char *type,
                              const char *type_instance, gauge_t value) {
   value_list_t vl = VALUE_LIST_INIT;
-  value_t v;
 
-  v.gauge = value;
-  vl.values = &v;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, PLUGIN_NAME, sizeof(vl.plugin));
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
@@ -547,12 +550,15 @@
                            struct pkg_data *p) {
   char name[DATA_MAX_NAME_LEN];
   double interval_float;
 
   interval_float = CDTIME_T_TO_DOUBLE(time_delta);
 
+  DEBUG("turbostat plugin: submit stats for cpu: %d, core: %d, pkg: %d",
+        t->cpu_id, c->core_id, p->package_id);
+
   ssnprintf(name, sizeof(name), "cpu%02d", t->cpu_id);
 
   if (!aperf_mperf_unstable)
     turbostat_submit(name, "percent", "c0", 100.0 * t->mperf / t->tsc);
   if (!aperf_mperf_unstable)
     turbostat_submit(name, "percent", "c1", 100.0 * t->c1 / t->tsc);
@@ -574,13 +580,16 @@
     turbostat_submit(name, "count", NULL, t->smi_count);
 
   /* submit per-core data only for 1st thread in core */
   if (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))
     goto done;
 
-  ssnprintf(name, sizeof(name), "core%02d", c->core_id);
+  /* If not using logical core numbering, set core id */
+  if (!config_lcn) {
+    ssnprintf(name, sizeof(name), "core%02d", c->core_id);
+  }
 
   if (do_core_cstate & (1 << 3))
     turbostat_submit(name, "percent", "c3", 100.0 * c->c3 / t->tsc);
   if (do_core_cstate & (1 << 6))
     turbostat_submit(name, "percent", "c6", 100.0 * c->c6 / t->tsc);
   if (do_core_cstate & (1 << 7))
@@ -1026,35 +1035,29 @@
  * Read a single int from a file.
  */
 static int __attribute__((format(printf, 1, 2)))
 parse_int_file(const char *fmt, ...) {
   va_list args;
   char path[PATH_MAX];
-  FILE *filep;
-  int len, value;
+  int len;
 
   va_start(args, fmt);
   len = vsnprintf(path, sizeof(path), fmt, args);
   va_end(args);
   if (len < 0 || len >= PATH_MAX) {
     ERROR("turbostat plugin: path truncated: '%s'", path);
     return -1;
   }
 
-  filep = fopen(path, "r");
-  if (!filep) {
-    ERROR("turbostat plugin: Failed to open '%s'", path);
-    return -1;
-  }
-  if (fscanf(filep, "%d", &value) != 1) {
-    ERROR("turbostat plugin: Failed to parse number from '%s'", path);
-    fclose(filep);
+  value_t v;
+  if (parse_value_file(path, &v, DS_TYPE_DERIVE) != 0) {
+    ERROR("turbostat plugin: Parsing \"%s\" failed.", path);
     return -1;
   }
-  fclose(filep);
-  return value;
+
+  return (int)v.derive;
 }
 
 static int get_threads_on_core(unsigned int cpu) {
   char path[80];
   FILE *filep;
   int sib1, sib2;
@@ -1561,12 +1564,14 @@
   } else if (strcasecmp("DigitalTemperatureSensor", key) == 0) {
     config_dts = IS_TRUE(value);
     apply_config_dts = 1;
   } else if (strcasecmp("PackageThermalManagement", key) == 0) {
     config_ptm = IS_TRUE(value);
     apply_config_ptm = 1;
+  } else if (strcasecmp("LogicalCoreNames", key) == 0) {
+    config_lcn = IS_TRUE(value);
   } else if (strcasecmp("RunningAveragePowerLimit", key) == 0) {
     tmp_val = strtoul(value, &end, 0);
     if (*end != '\0' || tmp_val > UINT_MAX) {
       ERROR("turbostat plugin: Invalid RunningAveragePowerLimit '%s'", value);
       return -1;
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/types.db /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/types.db
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/types.db	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/types.db	2016-12-12 16:03:36.720279029 +0800
@@ -6,12 +6,13 @@
 apache_scoreboard       value:GAUGE:0:65535
 ath_nodes               value:GAUGE:0:65535
 ath_stat                value:DERIVE:0:U
 backends                value:GAUGE:0:65535
 bitrate                 value:GAUGE:0:4294967295
 blocked_clients         value:GAUGE:0:U
+bucket                  value:GAUGE:0:U
 bytes                   value:GAUGE:0:U
 cache_eviction          value:DERIVE:0:U
 cache_operation         value:DERIVE:0:U
 cache_ratio             value:GAUGE:0:100
 cache_result            value:DERIVE:0:U
 cache_size              value:GAUGE:0:1125899906842623
@@ -71,19 +72,23 @@
 dns_zops                value:DERIVE:0:U
 drbd_resource           value:DERIVE:0:U
 duration                seconds:GAUGE:0:U
 email_check             value:GAUGE:0:U
 email_count             value:GAUGE:0:U
 email_size              value:GAUGE:0:U
+energy                  value:GAUGE:U:U
+energy_wh               value:GAUGE:U:U
 entropy                 value:GAUGE:0:4294967295
+errors                  value:DERIVE:0:U
 evicted_keys            value:DERIVE:0:U
 expired_keys            value:DERIVE:0:U
 fanspeed                value:GAUGE:0:U
 file_handles            value:GAUGE:0:U
 file_size               value:GAUGE:0:U
 files                   value:GAUGE:0:U
+filter_result           value:DERIVE:0:U
 flow                    value:GAUGE:0:U
 fork_rate               value:DERIVE:0:U
 frequency               value:GAUGE:0:U
 frequency_error         value:GAUGE:-2:2 
 frequency_offset        value:GAUGE:-1000000:1000000
 fscache_stat            value:DERIVE:0:U
@@ -96,25 +101,31 @@
 if_collisions           value:DERIVE:0:U
 if_dropped              rx:DERIVE:0:U, tx:DERIVE:0:U
 if_errors               rx:DERIVE:0:U, tx:DERIVE:0:U
 if_multicast            value:DERIVE:0:U
 if_octets               rx:DERIVE:0:U, tx:DERIVE:0:U
 if_packets              rx:DERIVE:0:U, tx:DERIVE:0:U
+if_rx_dropped           value:DERIVE:0:U
 if_rx_errors            value:DERIVE:0:U
 if_rx_octets            value:DERIVE:0:U
+if_rx_packets           value:DERIVE:0:U
+if_tx_dropped           value:DERIVE:0:U
 if_tx_errors            value:DERIVE:0:U
 if_tx_octets            value:DERIVE:0:U
+if_tx_packets           value:DERIVE:0:U
 invocations             value:DERIVE:0:U
 io_octets               rx:DERIVE:0:U, tx:DERIVE:0:U
 io_packets              rx:DERIVE:0:U, tx:DERIVE:0:U
+ipc                     value:GAUGE:0:U
 ipt_bytes               value:DERIVE:0:U
 ipt_packets             value:DERIVE:0:U
 irq                     value:DERIVE:0:U
 latency                 value:GAUGE:0:U
 links                   value:GAUGE:0:U
 load                    shortterm:GAUGE:0:5000, midterm:GAUGE:0:5000, longterm:GAUGE:0:5000
+memory_bandwidth        value:DERIVE:0:U
 md_disks                value:GAUGE:0:U
 memcached_command       value:DERIVE:0:U
 memcached_connections   value:GAUGE:0:U
 memcached_items         value:GAUGE:0:U
 memcached_octets        rx:DERIVE:0:U, tx:DERIVE:0:U
 memcached_ops           value:DERIVE:0:U
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/types.db.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/types.db.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/types.db.5	2017-04-06 22:45:14.237977518 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/types.db.5	2016-12-12 16:04:33.987983237 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "TYPES.DB 5"
-.TH TYPES.DB 5 "2017-04-05" "5.7.1.253.gbdcefed+" "collectd"
+.TH TYPES.DB 5 "2016-12-12" "5.7.0" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 types.db \- Data\-set specifications for the system statistics collection daemon
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/unixsock.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/unixsock.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/unixsock.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/unixsock.c	2016-12-12 16:03:36.720279029 +0800
@@ -131,28 +131,22 @@
   }
 
   do {
     const char *grpname;
     struct group *g;
     struct group sg;
-
-    long int grbuf_size = sysconf(_SC_GETGR_R_SIZE_MAX);
-    if (grbuf_size <= 0)
-      grbuf_size = sysconf(_SC_PAGESIZE);
-    if (grbuf_size <= 0)
-      grbuf_size = 4096;
-    char grbuf[grbuf_size];
+    char grbuf[2048];
 
     grpname = (sock_group != NULL) ? sock_group : COLLECTD_GRP_NAME;
     g = NULL;
 
     status = getgrnam_r(grpname, &sg, grbuf, sizeof(grbuf), &g);
     if (status != 0) {
       char errbuf[1024];
       WARNING("unixsock plugin: getgrnam_r (%s) failed: %s", grpname,
-              sstrerror(status, errbuf, sizeof(errbuf)));
+              sstrerror(errno, errbuf, sizeof(errbuf)));
       break;
     }
     if (g == NULL) {
       WARNING("unixsock plugin: No such group: `%s'", grpname);
       break;
     }
@@ -260,23 +254,23 @@
       fclose(fhout);
       pthread_exit((void *)1);
       return ((void *)1);
     }
 
     if (strcasecmp(fields[0], "getval") == 0) {
-      handle_getval(fhout, buffer);
+      cmd_handle_getval(fhout, buffer);
     } else if (strcasecmp(fields[0], "getthreshold") == 0) {
       handle_getthreshold(fhout, buffer);
     } else if (strcasecmp(fields[0], "putval") == 0) {
-      handle_putval(fhout, buffer);
+      cmd_handle_putval(fhout, buffer);
     } else if (strcasecmp(fields[0], "listval") == 0) {
-      handle_listval(fhout, buffer);
+      cmd_handle_listval(fhout, buffer);
     } else if (strcasecmp(fields[0], "putnotif") == 0) {
       handle_putnotif(fhout, buffer);
     } else if (strcasecmp(fields[0], "flush") == 0) {
-      handle_flush(fhout, buffer);
+      cmd_handle_flush(fhout, buffer);
     } else {
       if (fprintf(fhout, "-1 Unknown command: %s\n", fields[0]) < 0) {
         char errbuf[1024];
         WARNING("unixsock plugin: failed to write to socket #%i: %s",
                 fileno(fhout), sstrerror(errno, errbuf, sizeof(errbuf)));
         break;
@@ -331,13 +325,13 @@
     }
     *remote_fd = status;
 
     DEBUG("Spawning child to handle connection on fd #%i", *remote_fd);
 
     status = plugin_thread_create(&th, &th_attr, us_handle_client,
-                                  (void *)remote_fd);
+                                  (void *)remote_fd, "unixsock conn");
     if (status != 0) {
       char errbuf[1024];
       WARNING("unixsock plugin: pthread_create failed: %s",
               sstrerror(errno, errbuf, sizeof(errbuf)));
       close(*remote_fd);
       free(remote_fd);
@@ -398,13 +392,14 @@
   if (have_init != 0)
     return (0);
   have_init = 1;
 
   loop = 1;
 
-  status = plugin_thread_create(&listen_thread, NULL, us_server_thread, NULL);
+  status = plugin_thread_create(&listen_thread, NULL, us_server_thread, NULL,
+                                "unixsock listen");
   if (status != 0) {
     char errbuf[1024];
     ERROR("unixsock plugin: pthread_create failed: %s",
           sstrerror(errno, errbuf, sizeof(errbuf)));
     return (-1);
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/uptime.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/uptime.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/uptime.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/uptime.c	2016-12-12 16:03:36.720279029 +0800
@@ -57,22 +57,18 @@
 static time_t boottime;
 
 #if HAVE_LIBKSTAT
 extern kstat_ctl_t *kc;
 #endif /* #endif HAVE_LIBKSTAT */
 
-static void uptime_submit(gauge_t uptime) {
-  value_t values[1];
+static void uptime_submit(gauge_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = uptime;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "uptime", sizeof(vl.plugin));
   sstrncpy(vl.type, "uptime", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/users.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/users.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/users.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/users.c	2016-12-12 16:03:36.724279000 +0800
@@ -41,20 +41,16 @@
 #elif HAVE_UTMP_H
 #include <utmp.h>
 /* #endif HAVE_UTMP_H */
 #endif
 
 static void users_submit(gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "users", sizeof(vl.plugin));
   sstrncpy(vl.type, "users", sizeof(vl.plugin));
 
   plugin_dispatch_values(&vl);
 } /* void users_submit */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_flush.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_flush.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_flush.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_flush.c	2016-12-12 16:03:36.724279000 +0800
@@ -1,9 +1,9 @@
 /**
  * collectd - src/utils_cmd_flush.c
- * Copyright (C) 2008       Sebastian Harl
+ * Copyright (C) 2008, 2016 Sebastian Harl
  * Copyright (C) 2008       Florian Forster
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
  * to deal in the Software without restriction, including without limitation
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
@@ -28,117 +28,154 @@
 
 #include "collectd.h"
 
 #include "common.h"
 #include "plugin.h"
 #include "utils_cmd_flush.h"
-#include "utils_parse_option.h"
 
-int handle_flush(FILE *fh, char *buffer) {
-  int success = 0;
-  int error = 0;
-
-  double timeout = 0.0;
-  char **plugins = NULL;
-  size_t plugins_num = 0;
-  char **identifiers = NULL;
-  size_t identifiers_num = 0;
-
-#define PRINT_TO_SOCK(fh, ...)                                                 \
-  do {                                                                         \
-    if (fprintf(fh, __VA_ARGS__) < 0) {                                        \
-      char errbuf[1024];                                                       \
-      WARNING("handle_flush: failed to write to socket #%i: %s", fileno(fh),   \
-              sstrerror(errno, errbuf, sizeof(errbuf)));                       \
-      strarray_free(plugins, plugins_num);                                     \
-      strarray_free(identifiers, identifiers_num);                             \
-      return -1;                                                               \
-    }                                                                          \
-    fflush(fh);                                                                \
-  } while (0)
-
-  if ((fh == NULL) || (buffer == NULL))
-    return (-1);
-
-  DEBUG("utils_cmd_flush: handle_flush (fh = %p, buffer = %s);", (void *)fh,
-        buffer);
-
-  if (strncasecmp("FLUSH", buffer, strlen("FLUSH")) != 0) {
-    PRINT_TO_SOCK(fh, "-1 Cannot parse command.\n");
-    return (-1);
+cmd_status_t cmd_parse_flush(size_t argc, char **argv, cmd_flush_t *ret_flush,
+                             const cmd_options_t *opts,
+                             cmd_error_handler_t *err) {
+
+  if ((ret_flush == NULL) || (opts == NULL)) {
+    errno = EINVAL;
+    cmd_error(CMD_ERROR, err, "Invalid arguments to cmd_parse_flush.");
+    return (CMD_ERROR);
   }
-  buffer += strlen("FLUSH");
 
-  while (*buffer != 0) {
+  for (size_t i = 0; i < argc; i++) {
     char *opt_key;
     char *opt_value;
     int status;
 
     opt_key = NULL;
     opt_value = NULL;
-    status = parse_option(&buffer, &opt_key, &opt_value);
+    status = cmd_parse_option(argv[i], &opt_key, &opt_value, err);
     if (status != 0) {
-      PRINT_TO_SOCK(fh, "-1 Parsing options failed.\n");
-      strarray_free(plugins, plugins_num);
-      strarray_free(identifiers, identifiers_num);
-      return (-1);
+      if (status == CMD_NO_OPTION)
+        cmd_error(CMD_PARSE_ERROR, err, "Invalid option string `%s'.", argv[i]);
+      cmd_destroy_flush(ret_flush);
+      return (CMD_PARSE_ERROR);
     }
 
-    if (strcasecmp("plugin", opt_key) == 0)
-      strarray_add(&plugins, &plugins_num, opt_value);
-    else if (strcasecmp("identifier", opt_key) == 0)
-      strarray_add(&identifiers, &identifiers_num, opt_value);
-    else if (strcasecmp("timeout", opt_key) == 0) {
+    if (strcasecmp("plugin", opt_key) == 0) {
+      strarray_add(&ret_flush->plugins, &ret_flush->plugins_num, opt_value);
+    } else if (strcasecmp("identifier", opt_key) == 0) {
+      identifier_t *id =
+          realloc(ret_flush->identifiers,
+                  (ret_flush->identifiers_num + 1) * sizeof(*id));
+      if (id == NULL) {
+        cmd_error(CMD_ERROR, err, "realloc failed.");
+        cmd_destroy_flush(ret_flush);
+        return (CMD_ERROR);
+      }
+
+      ret_flush->identifiers = id;
+      id = ret_flush->identifiers + ret_flush->identifiers_num;
+      ret_flush->identifiers_num++;
+      if (parse_identifier(opt_value, &id->host, &id->plugin,
+                           &id->plugin_instance, &id->type, &id->type_instance,
+                           opts->identifier_default_host) != 0) {
+        cmd_error(CMD_PARSE_ERROR, err, "Invalid identifier `%s'.", opt_value);
+        cmd_destroy_flush(ret_flush);
+        return (CMD_PARSE_ERROR);
+      }
+    } else if (strcasecmp("timeout", opt_key) == 0) {
       char *endptr;
 
       errno = 0;
       endptr = NULL;
-      timeout = strtod(opt_value, &endptr);
+      ret_flush->timeout = strtod(opt_value, &endptr);
 
-      if ((endptr == opt_value) || (errno != 0) || (!isfinite(timeout))) {
-        PRINT_TO_SOCK(fh, "-1 Invalid value for option `timeout': "
-                          "%s\n",
-                      opt_value);
-        strarray_free(plugins, plugins_num);
-        strarray_free(identifiers, identifiers_num);
-        return (-1);
-      } else if (timeout < 0.0) {
-        timeout = 0.0;
+      if ((endptr == opt_value) || (errno != 0) ||
+          (!isfinite(ret_flush->timeout))) {
+        cmd_error(CMD_PARSE_ERROR, err,
+                  "Invalid value for option `timeout': %s", opt_value);
+        cmd_destroy_flush(ret_flush);
+        return (CMD_PARSE_ERROR);
+      } else if (ret_flush->timeout < 0.0) {
+        ret_flush->timeout = 0.0;
       }
     } else {
-      PRINT_TO_SOCK(fh, "-1 Cannot parse option %s\n", opt_key);
-      strarray_free(plugins, plugins_num);
-      strarray_free(identifiers, identifiers_num);
-      return (-1);
+      cmd_error(CMD_PARSE_ERROR, err, "Cannot parse option `%s'.", opt_key);
+      cmd_destroy_flush(ret_flush);
+      return (CMD_PARSE_ERROR);
     }
-  } /* while (*buffer != 0) */
+  }
 
-  for (size_t i = 0; (i == 0) || (i < plugins_num); i++) {
+  return (CMD_OK);
+} /* cmd_status_t cmd_parse_flush */
+
+cmd_status_t cmd_handle_flush(FILE *fh, char *buffer) {
+  cmd_error_handler_t err = {cmd_error_fh, fh};
+  cmd_t cmd;
+
+  int success = 0;
+  int error = 0;
+  int status;
+
+  if ((fh == NULL) || (buffer == NULL))
+    return (-1);
+
+  DEBUG("utils_cmd_flush: cmd_handle_flush (fh = %p, buffer = %s);", (void *)fh,
+        buffer);
+
+  if ((status = cmd_parse(buffer, &cmd, NULL, &err)) != CMD_OK)
+    return (status);
+  if (cmd.type != CMD_FLUSH) {
+    cmd_error(CMD_UNKNOWN_COMMAND, &err, "Unexpected command: `%s'.",
+              CMD_TO_STRING(cmd.type));
+    cmd_destroy(&cmd);
+    return (CMD_UNKNOWN_COMMAND);
+  }
+
+  for (size_t i = 0; (i == 0) || (i < cmd.cmd.flush.plugins_num); i++) {
     char *plugin = NULL;
 
-    if (plugins_num != 0)
-      plugin = plugins[i];
+    if (cmd.cmd.flush.plugins_num != 0)
+      plugin = cmd.cmd.flush.plugins[i];
 
-    for (size_t j = 0; (j == 0) || (j < identifiers_num); j++) {
+    for (size_t j = 0; (j == 0) || (j < cmd.cmd.flush.identifiers_num); j++) {
       char *identifier = NULL;
+      char buffer[1024];
       int status;
 
-      if (identifiers_num != 0)
-        identifier = identifiers[j];
+      if (cmd.cmd.flush.identifiers_num != 0) {
+        identifier_t *id = cmd.cmd.flush.identifiers + j;
+        if (format_name(buffer, sizeof(buffer), id->host, id->plugin,
+                        id->plugin_instance, id->type,
+                        id->type_instance) != 0) {
+          error++;
+          continue;
+        }
+        identifier = buffer;
+      }
 
-      status = plugin_flush(plugin, DOUBLE_TO_CDTIME_T(timeout), identifier);
+      status = plugin_flush(plugin, DOUBLE_TO_CDTIME_T(cmd.cmd.flush.timeout),
+                            identifier);
       if (status == 0)
         success++;
       else
         error++;
     }
   }
 
-  PRINT_TO_SOCK(fh, "0 Done: %i successful, %i errors\n", success, error);
+  cmd_error(CMD_OK, &err, "Done: %i successful, %i errors", success, error);
 
-  strarray_free(plugins, plugins_num);
-  strarray_free(identifiers, identifiers_num);
+  cmd_destroy(&cmd);
   return (0);
 #undef PRINT_TO_SOCK
-} /* int handle_flush */
+} /* cmd_status_t cmd_handle_flush */
+
+void cmd_destroy_flush(cmd_flush_t *flush) {
+  if (flush == NULL)
+    return;
+
+  strarray_free(flush->plugins, flush->plugins_num);
+  flush->plugins = NULL;
+  flush->plugins_num = 0;
+
+  sfree(flush->identifiers);
+  flush->identifiers_num = 0;
+} /* void cmd_destroy_flush */
 
 /* vim: set sw=4 ts=4 tw=78 noexpandtab : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_flush.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_flush.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_flush.h	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_flush.h	2016-12-12 16:03:36.724279000 +0800
@@ -1,9 +1,9 @@
 /**
  * collectd - src/utils_cmd_flush.h
- * Copyright (C) 2008       Sebastian Harl
+ * Copyright (C) 2008, 2016 Sebastian Harl
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
  * to deal in the Software without restriction, including without limitation
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
@@ -24,13 +24,21 @@
  *   Sebastian "tokkee" Harl <sh at tokkee.org>
  **/
 
 #ifndef UTILS_CMD_FLUSH_H
 #define UTILS_CMD_FLUSH_H 1
 
+#include "utils_cmds.h"
+
 #include <stdio.h>
 
-int handle_flush(FILE *fh, char *buffer);
+cmd_status_t cmd_parse_flush(size_t argc, char **argv, cmd_flush_t *ret_flush,
+                             const cmd_options_t *opts,
+                             cmd_error_handler_t *err);
+
+cmd_status_t cmd_handle_flush(FILE *fh, char *buffer);
+
+void cmd_destroy_flush(cmd_flush_t *flush);
 
 #endif /* UTILS_CMD_FLUSH_H */
 
 /* vim: set sw=4 ts=4 tw=78 noexpandtab : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_getthreshold.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_getthreshold.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_getthreshold.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_getthreshold.c	2016-12-12 16:03:36.724279000 +0800
@@ -92,13 +92,14 @@
 
   /* parse_identifier() modifies its first argument,
    * returning pointers into it */
   identifier_copy = sstrdup(identifier);
 
   status = parse_identifier(identifier_copy, &host, &plugin, &plugin_instance,
-                            &type, &type_instance);
+                            &type, &type_instance,
+                            /* default_host = */ NULL);
   if (status != 0) {
     DEBUG("handle_getthreshold: Cannot parse identifier `%s'.", identifier);
     print_to_socket(fh, "-1 Cannot parse identifier `%s'.\n", identifier);
     sfree(identifier_copy);
     return (-1);
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_getval.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_getval.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_getval.c	2017-10-06 14:45:52.969917769 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_getval.c	2016-12-12 16:03:36.724279000 +0800
@@ -30,110 +30,118 @@
 #include "plugin.h"
 
 #include "utils_cache.h"
 #include "utils_cmd_getval.h"
 #include "utils_parse_option.h"
 
+cmd_status_t cmd_parse_getval(size_t argc, char **argv,
+                              cmd_getval_t *ret_getval,
+                              const cmd_options_t *opts,
+                              cmd_error_handler_t *err) {
+  char *identifier_copy;
+  int status;
+
+  if ((ret_getval == NULL) || (opts == NULL)) {
+    errno = EINVAL;
+    cmd_error(CMD_ERROR, err, "Invalid arguments to cmd_parse_getval.");
+    return (CMD_ERROR);
+  }
+
+  if (argc != 1) {
+    if (argc == 0)
+      cmd_error(CMD_PARSE_ERROR, err, "Missing identifier.");
+    else
+      cmd_error(CMD_PARSE_ERROR, err, "Garbage after identifier: `%s'.",
+                argv[1]);
+    return (CMD_PARSE_ERROR);
+  }
+
+  /* parse_identifier() modifies its first argument,
+   * returning pointers into it */
+  identifier_copy = sstrdup(argv[0]);
+
+  status = parse_identifier(
+      argv[0], &ret_getval->identifier.host, &ret_getval->identifier.plugin,
+      &ret_getval->identifier.plugin_instance, &ret_getval->identifier.type,
+      &ret_getval->identifier.type_instance, opts->identifier_default_host);
+  if (status != 0) {
+    DEBUG("cmd_parse_getval: Cannot parse identifier `%s'.", identifier_copy);
+    cmd_error(CMD_PARSE_ERROR, err, "Cannot parse identifier `%s'.",
+              identifier_copy);
+    sfree(identifier_copy);
+    return (CMD_PARSE_ERROR);
+  }
+
+  ret_getval->raw_identifier = identifier_copy;
+  return (CMD_OK);
+} /* cmd_status_t cmd_parse_getval */
+
 #define print_to_socket(fh, ...)                                               \
   do {                                                                         \
     if (fprintf(fh, __VA_ARGS__) < 0) {                                        \
       char errbuf[1024];                                                       \
-      WARNING("handle_getval: failed to write to socket #%i: %s", fileno(fh),  \
-              sstrerror(errno, errbuf, sizeof(errbuf)));                       \
+      WARNING("cmd_handle_getval: failed to write to socket #%i: %s",          \
+              fileno(fh), sstrerror(errno, errbuf, sizeof(errbuf)));           \
       return -1;                                                               \
     }                                                                          \
     fflush(fh);                                                                \
   } while (0)
 
-int handle_getval(FILE *fh, char *buffer) {
-  char *command;
-  char *identifier;
-  char *identifier_copy;
+cmd_status_t cmd_handle_getval(FILE *fh, char *buffer) {
+  cmd_error_handler_t err = {cmd_error_fh, fh};
+  cmd_status_t status;
+  cmd_t cmd;
 
-  char *hostname;
-  char *plugin;
-  char *plugin_instance;
-  char *type;
-  char *type_instance;
   gauge_t *values;
   size_t values_num;
 
   const data_set_t *ds;
 
-  int status;
-
   if ((fh == NULL) || (buffer == NULL))
     return (-1);
 
-  DEBUG("utils_cmd_getval: handle_getval (fh = %p, buffer = %s);", (void *)fh,
-        buffer);
+  DEBUG("utils_cmd_getval: cmd_handle_getval (fh = %p, buffer = %s);",
+        (void *)fh, buffer);
 
-  command = NULL;
-  status = parse_string(&buffer, &command);
-  if (status != 0) {
-    print_to_socket(fh, "-1 Cannot parse command.\n");
-    return (-1);
-  }
-  assert(command != NULL);
-
-  if (strcasecmp("GETVAL", command) != 0) {
-    print_to_socket(fh, "-1 Unexpected command: `%s'.\n", command);
-    return (-1);
+  if ((status = cmd_parse(buffer, &cmd, NULL, &err)) != CMD_OK)
+    return (status);
+  if (cmd.type != CMD_GETVAL) {
+    cmd_error(CMD_UNKNOWN_COMMAND, &err, "Unexpected command: `%s'.",
+              CMD_TO_STRING(cmd.type));
+    cmd_destroy(&cmd);
+    return (CMD_UNKNOWN_COMMAND);
   }
 
-  identifier = NULL;
-  status = parse_string(&buffer, &identifier);
-  if (status != 0) {
-    print_to_socket(fh, "-1 Cannot parse identifier.\n");
-    return (-1);
-  }
-  assert(identifier != NULL);
-
-  if (*buffer != 0) {
-    print_to_socket(fh, "-1 Garbage after end of command: %s\n", buffer);
-    return (-1);
-  }
-
-  /* parse_identifier() modifies its first argument,
-   * returning pointers into it */
-  identifier_copy = sstrdup(identifier);
-
-  status = parse_identifier(identifier_copy, &hostname, &plugin,
-                            &plugin_instance, &type, &type_instance);
-  if (status != 0) {
-    DEBUG("handle_getval: Cannot parse identifier `%s'.", identifier);
-    print_to_socket(fh, "-1 Cannot parse identifier `%s'.\n", identifier);
-    sfree(identifier_copy);
-    return (-1);
-  }
-
-  ds = plugin_get_ds(type);
+  ds = plugin_get_ds(cmd.cmd.getval.identifier.type);
   if (ds == NULL) {
-    DEBUG("handle_getval: plugin_get_ds (%s) == NULL;", type);
-    print_to_socket(fh, "-1 Type `%s' is unknown.\n", type);
-    sfree(identifier_copy);
+    DEBUG("cmd_handle_getval: plugin_get_ds (%s) == NULL;",
+          cmd.cmd.getval.identifier.type);
+    cmd_error(CMD_ERROR, &err, "Type `%s' is unknown.\n",
+              cmd.cmd.getval.identifier.type);
+    cmd_destroy(&cmd);
     return (-1);
   }
 
   values = NULL;
   values_num = 0;
-  status = uc_get_rate_by_name(identifier, &values, &values_num);
+  status =
+      uc_get_rate_by_name(cmd.cmd.getval.raw_identifier, &values, &values_num);
   if (status != 0) {
-    print_to_socket(fh, "-1 No such value\n");
-    sfree(identifier_copy);
-    return (-1);
+    cmd_error(CMD_ERROR, &err, "No such value.");
+    cmd_destroy(&cmd);
+    return (CMD_ERROR);
   }
 
   if (ds->ds_num != values_num) {
     ERROR("ds[%s]->ds_num = %zu, "
           "but uc_get_rate_by_name returned %zu values.",
           ds->type, ds->ds_num, values_num);
-    print_to_socket(fh, "-1 Error reading value from cache.\n");
+    cmd_error(CMD_ERROR, &err, "Error reading value from cache.");
     sfree(values);
-    sfree(identifier_copy);
-    return (-1);
+    cmd_destroy(&cmd);
+    return (CMD_ERROR);
   }
 
   print_to_socket(fh, "%zu Value%s found\n", values_num,
                   (values_num == 1) ? "" : "s");
   for (size_t i = 0; i < values_num; i++) {
     print_to_socket(fh, "%s=", ds->ds[i].name);
@@ -142,12 +150,19 @@
     } else {
       print_to_socket(fh, "%12e\n", values[i]);
     }
   }
 
   sfree(values);
-  sfree(identifier_copy);
+  cmd_destroy(&cmd);
+
+  return (CMD_OK);
+} /* cmd_status_t cmd_handle_getval */
+
+void cmd_destroy_getval(cmd_getval_t *getval) {
+  if (getval == NULL)
+    return;
 
-  return (0);
-} /* int handle_getval */
+  sfree(getval->raw_identifier);
+} /* void cmd_destroy_getval */
 
 /* vim: set sw=2 sts=2 ts=8 : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_getval.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_getval.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_getval.h	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_getval.h	2016-12-12 16:03:36.724279000 +0800
@@ -26,11 +26,20 @@
 
 #ifndef UTILS_CMD_GETVAL_H
 #define UTILS_CMD_GETVAL_H 1
 
 #include <stdio.h>
 
-int handle_getval(FILE *fh, char *buffer);
+#include "utils_cmds.h"
+
+cmd_status_t cmd_parse_getval(size_t argc, char **argv,
+                              cmd_getval_t *ret_getval,
+                              const cmd_options_t *opts,
+                              cmd_error_handler_t *err);
+
+cmd_status_t cmd_handle_getval(FILE *fh, char *buffer);
+
+void cmd_destroy_getval(cmd_getval_t *getval);
 
 #endif /* UTILS_CMD_GETVAL_H */
 
 /* vim: set sw=2 sts=2 ts=8 : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_listval.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_listval.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_listval.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_listval.c	2016-12-12 16:03:36.724279000 +0800
@@ -30,12 +30,27 @@
 #include "plugin.h"
 
 #include "utils_cache.h"
 #include "utils_cmd_listval.h"
 #include "utils_parse_option.h"
 
+cmd_status_t cmd_parse_listval(size_t argc, char **argv,
+                               cmd_listval_t *ret_listval
+                               __attribute__((unused)),
+                               const cmd_options_t *opts
+                               __attribute__((unused)),
+                               cmd_error_handler_t *err) {
+  if (argc != 0) {
+    cmd_error(CMD_PARSE_ERROR, err, "Garbage after end of command: `%s'.",
+              argv[0]);
+    return (CMD_PARSE_ERROR);
+  }
+
+  return (CMD_OK);
+} /* cmd_status_t cmd_parse_listval */
+
 #define free_everything_and_return(status)                                     \
   do {                                                                         \
     for (size_t j = 0; j < number; j++) {                                      \
       sfree(names[j]);                                                         \
       names[j] = NULL;                                                         \
     }                                                                          \
@@ -47,55 +62,51 @@
 #define print_to_socket(fh, ...)                                               \
   do {                                                                         \
     if (fprintf(fh, __VA_ARGS__) < 0) {                                        \
       char errbuf[1024];                                                       \
       WARNING("handle_listval: failed to write to socket #%i: %s", fileno(fh), \
               sstrerror(errno, errbuf, sizeof(errbuf)));                       \
-      free_everything_and_return(-1);                                          \
+      free_everything_and_return(CMD_ERROR);                                   \
     }                                                                          \
     fflush(fh);                                                                \
   } while (0)
 
-int handle_listval(FILE *fh, char *buffer) {
-  char *command;
+cmd_status_t cmd_handle_listval(FILE *fh, char *buffer) {
+  cmd_error_handler_t err = {cmd_error_fh, fh};
+  cmd_status_t status;
+  cmd_t cmd;
+
   char **names = NULL;
   cdtime_t *times = NULL;
   size_t number = 0;
-  int status;
 
   DEBUG("utils_cmd_listval: handle_listval (fh = %p, buffer = %s);", (void *)fh,
         buffer);
 
-  command = NULL;
-  status = parse_string(&buffer, &command);
-  if (status != 0) {
-    print_to_socket(fh, "-1 Cannot parse command.\n");
-    free_everything_and_return(-1);
-  }
-  assert(command != NULL);
-
-  if (strcasecmp("LISTVAL", command) != 0) {
-    print_to_socket(fh, "-1 Unexpected command: `%s'.\n", command);
-    free_everything_and_return(-1);
-  }
-
-  if (*buffer != 0) {
-    print_to_socket(fh, "-1 Garbage after end of command: %s\n", buffer);
-    free_everything_and_return(-1);
+  if ((status = cmd_parse(buffer, &cmd, NULL, &err)) != CMD_OK)
+    return (status);
+  if (cmd.type != CMD_LISTVAL) {
+    cmd_error(CMD_UNKNOWN_COMMAND, &err, "Unexpected command: `%s'.",
+              CMD_TO_STRING(cmd.type));
+    free_everything_and_return(CMD_UNKNOWN_COMMAND);
   }
 
   status = uc_get_names(&names, &times, &number);
   if (status != 0) {
     DEBUG("command listval: uc_get_names failed with status %i", status);
-    print_to_socket(fh, "-1 uc_get_names failed.\n");
-    free_everything_and_return(-1);
+    cmd_error(CMD_ERROR, &err, "uc_get_names failed.");
+    free_everything_and_return(CMD_ERROR);
   }
 
   print_to_socket(fh, "%i Value%s found\n", (int)number,
                   (number == 1) ? "" : "s");
   for (size_t i = 0; i < number; i++)
     print_to_socket(fh, "%.3f %s\n", CDTIME_T_TO_DOUBLE(times[i]), names[i]);
 
-  free_everything_and_return(0);
-} /* int handle_listval */
+  free_everything_and_return(CMD_OK);
+} /* cmd_status_t cmd_handle_listval */
+
+void cmd_destroy_listval(cmd_listval_t *listval __attribute__((unused))) {
+  /* nothing to do */
+} /* void cmd_destroy_listval */
 
 /* vim: set sw=2 sts=2 ts=8 : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_listval.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_listval.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_listval.h	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_listval.h	2016-12-12 16:03:36.724279000 +0800
@@ -26,11 +26,20 @@
 
 #ifndef UTILS_CMD_LISTVAL_H
 #define UTILS_CMD_LISTVAL_H 1
 
 #include <stdio.h>
 
-int handle_listval(FILE *fh, char *buffer);
+#include "utils_cmds.h"
+
+cmd_status_t cmd_parse_listval(size_t argc, char **argv,
+                               cmd_listval_t *ret_listval,
+                               const cmd_options_t *opts,
+                               cmd_error_handler_t *err);
+
+cmd_status_t cmd_handle_listval(FILE *fh, char *buffer);
+
+void cmd_destroy_listval(cmd_listval_t *listval);
 
 #endif /* UTILS_CMD_LISTVAL_H */
 
 /* vim: set sw=2 sts=2 ts=8 : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_putval.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_putval.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_putval.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_putval.c	2016-12-12 16:03:36.724279000 +0800
@@ -1,9 +1,10 @@
 /**
  * collectd - src/utils_cmd_putval.c
  * Copyright (C) 2007-2009  Florian octo Forster
+ * Copyright (C) 2016       Sebastian tokkee Harl
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
  * to deal in the Software without restriction, including without limitation
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
@@ -19,33 +20,23 @@
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  *
  * Authors:
  *   Florian octo Forster <octo at collectd.org>
+ *   Sebastian tokkee Harl <sh at tokkee.org>
  **/
 
 #include "collectd.h"
 
 #include "common.h"
-#include "plugin.h"
-
 #include "utils_cmd_putval.h"
-#include "utils_parse_option.h"
 
-#define print_to_socket(fh, ...)                                               \
-  do {                                                                         \
-    if (fprintf(fh, __VA_ARGS__) < 0) {                                        \
-      char errbuf[1024];                                                       \
-      WARNING("handle_putval: failed to write to socket #%i: %s", fileno(fh),  \
-              sstrerror(errno, errbuf, sizeof(errbuf)));                       \
-      sfree(vl.values);                                                        \
-      return -1;                                                               \
-    }                                                                          \
-    fflush(fh);                                                                \
-  } while (0)
+/*
+ * private helper functions
+ */
 
 static int set_option(value_list_t *vl, const char *key, const char *value) {
   if ((vl == NULL) || (key == NULL) || (value == NULL))
     return (-1);
 
   if (strcasecmp("interval", key) == 0) {
@@ -59,161 +50,216 @@
     if ((errno == 0) && (endptr != NULL) && (endptr != value) && (tmp > 0.0))
       vl->interval = DOUBLE_TO_CDTIME_T(tmp);
   } else
     return (1);
 
   return (0);
-} /* int parse_option */
+} /* int set_option */
+
+/*
+ * public API
+ */
+
+cmd_status_t cmd_parse_putval(size_t argc, char **argv,
+                              cmd_putval_t *ret_putval,
+                              const cmd_options_t *opts,
+                              cmd_error_handler_t *err) {
+  cmd_status_t result;
 
-int handle_putval(FILE *fh, char *buffer) {
-  char *command;
   char *identifier;
   char *hostname;
   char *plugin;
   char *plugin_instance;
   char *type;
   char *type_instance;
   int status;
-  int values_submitted;
 
   char *identifier_copy;
 
   const data_set_t *ds;
   value_list_t vl = VALUE_LIST_INIT;
-  vl.values = NULL;
-
-  DEBUG("utils_cmd_putval: handle_putval (fh = %p, buffer = %s);", (void *)fh,
-        buffer);
 
-  command = NULL;
-  status = parse_string(&buffer, &command);
-  if (status != 0) {
-    print_to_socket(fh, "-1 Cannot parse command.\n");
-    return (-1);
+  if ((ret_putval == NULL) || (opts == NULL)) {
+    errno = EINVAL;
+    cmd_error(CMD_ERROR, err, "Invalid arguments to cmd_parse_putval.");
+    return (CMD_ERROR);
   }
-  assert(command != NULL);
 
-  if (strcasecmp("PUTVAL", command) != 0) {
-    print_to_socket(fh, "-1 Unexpected command: `%s'.\n", command);
-    return (-1);
+  if (argc < 2) {
+    cmd_error(CMD_PARSE_ERROR, err, "Missing identifier and/or value-list.");
+    return (CMD_PARSE_ERROR);
   }
 
-  identifier = NULL;
-  status = parse_string(&buffer, &identifier);
-  if (status != 0) {
-    print_to_socket(fh, "-1 Cannot parse identifier.\n");
-    return (-1);
-  }
-  assert(identifier != NULL);
+  identifier = argv[0];
 
-  /* parse_identifier() modifies its first argument,
-   * returning pointers into it */
+  /* parse_identifier() modifies its first argument, returning pointers into
+   * it; retain the old value for later. */
   identifier_copy = sstrdup(identifier);
 
-  status = parse_identifier(identifier_copy, &hostname, &plugin,
-                            &plugin_instance, &type, &type_instance);
+  status =
+      parse_identifier(identifier, &hostname, &plugin, &plugin_instance, &type,
+                       &type_instance, opts->identifier_default_host);
   if (status != 0) {
-    DEBUG("handle_putval: Cannot parse identifier `%s'.", identifier);
-    print_to_socket(fh, "-1 Cannot parse identifier `%s'.\n", identifier);
+    DEBUG("cmd_handle_putval: Cannot parse identifier `%s'.", identifier_copy);
+    cmd_error(CMD_PARSE_ERROR, err, "Cannot parse identifier `%s'.",
+              identifier_copy);
     sfree(identifier_copy);
-    return (-1);
+    return (CMD_PARSE_ERROR);
   }
 
   if ((strlen(hostname) >= sizeof(vl.host)) ||
       (strlen(plugin) >= sizeof(vl.plugin)) ||
       ((plugin_instance != NULL) &&
        (strlen(plugin_instance) >= sizeof(vl.plugin_instance))) ||
       ((type_instance != NULL) &&
        (strlen(type_instance) >= sizeof(vl.type_instance)))) {
-    print_to_socket(fh, "-1 Identifier too long.\n");
+    cmd_error(CMD_PARSE_ERROR, err, "Identifier too long.");
     sfree(identifier_copy);
-    return (-1);
+    return (CMD_PARSE_ERROR);
   }
 
   sstrncpy(vl.host, hostname, sizeof(vl.host));
   sstrncpy(vl.plugin, plugin, sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   ds = plugin_get_ds(type);
   if (ds == NULL) {
-    print_to_socket(fh, "-1 Type `%s' isn't defined.\n", type);
+    cmd_error(CMD_PARSE_ERROR, err, "1 Type `%s' isn't defined.", type);
     sfree(identifier_copy);
-    return (-1);
+    return (CMD_PARSE_ERROR);
   }
 
-  /* Free identifier_copy */
   hostname = NULL;
   plugin = NULL;
   plugin_instance = NULL;
   type = NULL;
   type_instance = NULL;
-  sfree(identifier_copy);
 
   vl.values_len = ds->ds_num;
   vl.values = malloc(vl.values_len * sizeof(*vl.values));
   if (vl.values == NULL) {
-    print_to_socket(fh, "-1 malloc failed.\n");
-    return (-1);
+    cmd_error(CMD_ERROR, err, "malloc failed.");
+    sfree(identifier_copy);
+    return (CMD_ERROR);
+  }
+
+  ret_putval->raw_identifier = identifier_copy;
+  if (ret_putval->raw_identifier == NULL) {
+    cmd_error(CMD_ERROR, err, "malloc failed.");
+    cmd_destroy_putval(ret_putval);
+    sfree(vl.values);
+    return (CMD_ERROR);
   }
 
-  /* All the remaining fields are part of the optionlist. */
-  values_submitted = 0;
-  while (*buffer != 0) {
-    char *string = NULL;
+  /* All the remaining fields are part of the option list. */
+  result = CMD_OK;
+  for (size_t i = 1; i < argc; ++i) {
+    value_list_t *tmp;
+
+    char *key = NULL;
     char *value = NULL;
 
-    status = parse_option(&buffer, &string, &value);
-    if (status < 0) {
-      /* parse_option failed, buffer has been modified.
-       * => we need to abort */
-      print_to_socket(fh, "-1 Misformatted option.\n");
-      sfree(vl.values);
-      return (-1);
-    } else if (status == 0) {
-      assert(string != NULL);
+    status = cmd_parse_option(argv[i], &key, &value, err);
+    if (status == CMD_OK) {
+      assert(key != NULL);
       assert(value != NULL);
-      set_option(&vl, string, value);
+      set_option(&vl, key, value);
       continue;
+    } else if (status != CMD_NO_OPTION) {
+      /* parse_option failed, buffer has been modified.
+       * => we need to abort */
+      result = status;
+      break;
     }
-    /* else: parse_option but buffer has not been modified. This is
-     * the default if no `=' is found.. */
+    /* else: cmd_parse_option did not find an option; treat this as a
+     * value list. */
 
-    status = parse_string(&buffer, &string);
+    status = parse_values(argv[i], &vl, ds);
     if (status != 0) {
-      print_to_socket(fh, "-1 Misformatted value.\n");
-      sfree(vl.values);
-      return (-1);
+      cmd_error(CMD_PARSE_ERROR, err, "Parsing the values string failed.");
+      result = CMD_PARSE_ERROR;
+      break;
     }
-    assert(string != NULL);
 
-    status = parse_values(string, &vl, ds);
-    if (status != 0) {
-      print_to_socket(fh, "-1 Parsing the values string failed.\n");
-      sfree(vl.values);
-      return (-1);
+    tmp = (value_list_t *)realloc(ret_putval->vl, (ret_putval->vl_num + 1) *
+                                                      sizeof(*ret_putval->vl));
+    if (tmp == NULL) {
+      cmd_error(CMD_ERROR, err, "realloc failed.");
+      cmd_destroy_putval(ret_putval);
+      result = CMD_ERROR;
+      break;
     }
 
-    plugin_dispatch_values(&vl);
-    values_submitted++;
+    ret_putval->vl = tmp;
+    ret_putval->vl_num++;
+    memcpy(&ret_putval->vl[ret_putval->vl_num - 1], &vl, sizeof(vl));
   } /* while (*buffer != 0) */
   /* Done parsing the options. */
 
-  if (fh != stdout)
-    print_to_socket(fh, "0 Success: %i %s been dispatched.\n", values_submitted,
-                    (values_submitted == 1) ? "value has" : "values have");
+  if (result != CMD_OK) {
+    if (ret_putval->vl_num == 0)
+      sfree(vl.values);
+    cmd_destroy_putval(ret_putval);
+  }
 
-  sfree(vl.values);
-  return (0);
-} /* int handle_putval */
+  return (result);
+} /* cmd_status_t cmd_parse_putval */
+
+void cmd_destroy_putval(cmd_putval_t *putval) {
+  if (putval == NULL)
+    return;
+
+  sfree(putval->raw_identifier);
+
+  for (size_t i = 0; i < putval->vl_num; ++i) {
+    if (i == 0) /* values is shared between all entries */
+      sfree(putval->vl[i].values);
+    meta_data_destroy(putval->vl[i].meta);
+    putval->vl[i].meta = NULL;
+  }
+  sfree(putval->vl);
+  putval->vl = NULL;
+  putval->vl_num = 0;
+} /* void cmd_destroy_putval */
+
+cmd_status_t cmd_handle_putval(FILE *fh, char *buffer) {
+  cmd_error_handler_t err = {cmd_error_fh, fh};
+  cmd_t cmd;
+
+  int status;
+
+  DEBUG("utils_cmd_putval: cmd_handle_putval (fh = %p, buffer = %s);",
+        (void *)fh, buffer);
+
+  if ((status = cmd_parse(buffer, &cmd, NULL, &err)) != CMD_OK)
+    return (status);
+  if (cmd.type != CMD_PUTVAL) {
+    cmd_error(CMD_UNKNOWN_COMMAND, &err, "Unexpected command: `%s'.",
+              CMD_TO_STRING(cmd.type));
+    cmd_destroy(&cmd);
+    return (CMD_UNKNOWN_COMMAND);
+  }
+
+  for (size_t i = 0; i < cmd.cmd.putval.vl_num; ++i)
+    plugin_dispatch_values(&cmd.cmd.putval.vl[i]);
+
+  if (fh != stdout)
+    cmd_error(CMD_OK, &err, "Success: %i %s been dispatched.",
+              (int)cmd.cmd.putval.vl_num,
+              (cmd.cmd.putval.vl_num == 1) ? "value has" : "values have");
+
+  cmd_destroy(&cmd);
+  return (CMD_OK);
+} /* int cmd_handle_putval */
 
-int create_putval(char *ret, size_t ret_len, /* {{{ */
-                  const data_set_t *ds, const value_list_t *vl) {
+int cmd_create_putval(char *ret, size_t ret_len, /* {{{ */
+                      const data_set_t *ds, const value_list_t *vl) {
   char buffer_ident[6 * DATA_MAX_NAME_LEN];
   char buffer_values[1024];
   int status;
 
   status = FORMAT_VL(buffer_ident, sizeof(buffer_ident), vl);
   if (status != 0)
@@ -229,7 +275,7 @@
   ssnprintf(ret, ret_len, "PUTVAL %s interval=%.3f %s", buffer_ident,
             (vl->interval > 0) ? CDTIME_T_TO_DOUBLE(vl->interval)
                                : CDTIME_T_TO_DOUBLE(plugin_get_interval()),
             buffer_values);
 
   return (0);
-} /* }}} int create_putval */
+} /* }}} int cmd_create_putval */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_putval.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_putval.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_cmd_putval.h	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_cmd_putval.h	2016-12-12 16:03:36.724279000 +0800
@@ -24,16 +24,24 @@
  *   Florian octo Forster <octo at collectd.org>
  **/
 
 #ifndef UTILS_CMD_PUTVAL_H
 #define UTILS_CMD_PUTVAL_H 1
 
+#include "plugin.h"
+#include "utils_cmds.h"
+
 #include <stdio.h>
 
-#include "plugin.h"
+cmd_status_t cmd_parse_putval(size_t argc, char **argv,
+                              cmd_putval_t *ret_putval,
+                              const cmd_options_t *opts,
+                              cmd_error_handler_t *err);
+
+cmd_status_t cmd_handle_putval(FILE *fh, char *buffer);
 
-int handle_putval(FILE *fh, char *buffer);
+void cmd_destroy_putval(cmd_putval_t *putval);
 
-int create_putval(char *ret, size_t ret_len, const data_set_t *ds,
-                  const value_list_t *vl);
+int cmd_create_putval(char *ret, size_t ret_len, const data_set_t *ds,
+                      const value_list_t *vl);
 
 #endif /* UTILS_CMD_PUTVAL_H */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_cmds.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_cmds.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_cmds_test.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_format_graphite.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_format_graphite.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_format_graphite.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_format_graphite.c	2016-12-12 16:03:36.724279000 +0800
@@ -74,25 +74,26 @@
 #undef BUFFER_ADD
 
   return (0);
 }
 
 static void gr_copy_escape_part(char *dst, const char *src, size_t dst_len,
-                                char escape_char) {
+                                char escape_char, _Bool preserve_separator) {
   memset(dst, 0, dst_len);
 
   if (src == NULL)
     return;
 
   for (size_t i = 0; i < dst_len; i++) {
     if (src[i] == 0) {
       dst[i] = 0;
       break;
     }
 
-    if ((src[i] == '.') || isspace((int)src[i]) || iscntrl((int)src[i]))
+    if ((!preserve_separator && (src[i] == '.')) || isspace((int)src[i]) ||
+        iscntrl((int)src[i]))
       dst[i] = escape_char;
     else
       dst[i] = src[i];
   }
 }
 
@@ -112,40 +113,54 @@
   if (prefix == NULL)
     prefix = "";
 
   if (postfix == NULL)
     postfix = "";
 
-  gr_copy_escape_part(n_host, vl->host, sizeof(n_host), escape_char);
-  gr_copy_escape_part(n_plugin, vl->plugin, sizeof(n_plugin), escape_char);
+  _Bool preserve_separator = (flags & GRAPHITE_PRESERVE_SEPARATOR) ? 1 : 0;
+
+  gr_copy_escape_part(n_host, vl->host, sizeof(n_host), escape_char,
+                      preserve_separator);
+  gr_copy_escape_part(n_plugin, vl->plugin, sizeof(n_plugin), escape_char,
+                      preserve_separator);
   gr_copy_escape_part(n_plugin_instance, vl->plugin_instance,
-                      sizeof(n_plugin_instance), escape_char);
-  gr_copy_escape_part(n_type, vl->type, sizeof(n_type), escape_char);
+                      sizeof(n_plugin_instance), escape_char,
+                      preserve_separator);
+  gr_copy_escape_part(n_type, vl->type, sizeof(n_type), escape_char,
+                      preserve_separator);
   gr_copy_escape_part(n_type_instance, vl->type_instance,
-                      sizeof(n_type_instance), escape_char);
+                      sizeof(n_type_instance), escape_char, preserve_separator);
 
   if (n_plugin_instance[0] != '\0')
     ssnprintf(tmp_plugin, sizeof(tmp_plugin), "%s%c%s", n_plugin,
               (flags & GRAPHITE_SEPARATE_INSTANCES) ? '.' : '-',
               n_plugin_instance);
   else
     sstrncpy(tmp_plugin, n_plugin, sizeof(tmp_plugin));
 
-  if (n_type_instance[0] != '\0')
-    ssnprintf(tmp_type, sizeof(tmp_type), "%s%c%s", n_type,
-              (flags & GRAPHITE_SEPARATE_INSTANCES) ? '.' : '-',
-              n_type_instance);
-  else
+  if (n_type_instance[0] != '\0') {
+    if ((flags & GRAPHITE_DROP_DUPE_FIELDS) && strcmp(n_plugin, n_type) == 0)
+      sstrncpy(tmp_type, n_type_instance, sizeof(tmp_type));
+    else
+      ssnprintf(tmp_type, sizeof(tmp_type), "%s%c%s", n_type,
+                (flags & GRAPHITE_SEPARATE_INSTANCES) ? '.' : '-',
+                n_type_instance);
+  } else
     sstrncpy(tmp_type, n_type, sizeof(tmp_type));
 
   /* Assert always_append_ds -> ds_name */
   assert(!(flags & GRAPHITE_ALWAYS_APPEND_DS) || (ds_name != NULL));
-  if (ds_name != NULL)
-    ssnprintf(ret, ret_len, "%s%s%s.%s.%s.%s", prefix, n_host, postfix,
-              tmp_plugin, tmp_type, ds_name);
-  else
+  if (ds_name != NULL) {
+    if ((flags & GRAPHITE_DROP_DUPE_FIELDS) &&
+        strcmp(tmp_plugin, tmp_type) == 0)
+      ssnprintf(ret, ret_len, "%s%s%s.%s.%s", prefix, n_host, postfix,
+                tmp_plugin, ds_name);
+    else
+      ssnprintf(ret, ret_len, "%s%s%s.%s.%s.%s", prefix, n_host, postfix,
+                tmp_plugin, tmp_type, ds_name);
+  } else
     ssnprintf(ret, ret_len, "%s%s%s.%s.%s", prefix, n_host, postfix, tmp_plugin,
               tmp_type);
 
   return (0);
 }
 
@@ -162,19 +177,14 @@
                     char const *postfix, char const escape_char,
                     unsigned int flags) {
   int status = 0;
   int buffer_pos = 0;
 
   gauge_t *rates = NULL;
-  if (flags & GRAPHITE_STORE_RATES) {
+  if (flags & GRAPHITE_STORE_RATES)
     rates = uc_get_rate(ds, vl);
-    if (rates == NULL) {
-      ERROR("format_graphite: error with uc_get_rate");
-      return -1;
-    }
-  }
 
   for (size_t i = 0; i < ds->ds_num; i++) {
     char const *ds_name = NULL;
     char key[10 * DATA_MAX_NAME_LEN];
     char values[512];
     size_t message_len;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_format_graphite.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_format_graphite.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_format_graphite.h	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_format_graphite.h	2016-12-12 16:03:36.724279000 +0800
@@ -26,12 +26,14 @@
 
 #include "plugin.h"
 
 #define GRAPHITE_STORE_RATES 0x01
 #define GRAPHITE_SEPARATE_INSTANCES 0x02
 #define GRAPHITE_ALWAYS_APPEND_DS 0x04
+#define GRAPHITE_DROP_DUPE_FIELDS 0x08
+#define GRAPHITE_PRESERVE_SEPARATOR 0x10
 
 int format_graphite(char *buffer, size_t buffer_size, const data_set_t *ds,
                     const value_list_t *vl, const char *prefix,
                     const char *postfix, const char escape_char,
                     unsigned int flags);
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_format_graphite_test.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_latency.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_latency.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_latency.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_latency.c	2016-12-12 16:03:36.724279000 +0800
@@ -34,16 +34,12 @@
 #include <math.h>
 
 #ifndef LLONG_MAX
 #define LLONG_MAX 9223372036854775807LL
 #endif
 
-#ifndef HISTOGRAM_NUM_BINS
-#define HISTOGRAM_NUM_BINS 1000
-#endif
-
 #ifndef HISTOGRAM_DEFAULT_BIN_WIDTH
 /* 1048576 = 2^20 ^= 1/1024 s */
 #define HISTOGRAM_DEFAULT_BIN_WIDTH 1048576
 #endif
 
 struct latency_counter_s {
@@ -149,13 +145,13 @@
     lc->min = lc->max = latency;
   if (lc->min > latency)
     lc->min = latency;
   if (lc->max < latency)
     lc->max = latency;
 
-  /* A latency of _exactly_ 1.0 ms should be stored in the buffer 0, so
+  /* A latency of _exactly_ 1.0 ms is stored in the buffer 0, so
    * subtract one from the cdtime_t value so that exactly 1.0 ms get sorted
    * accordingly. */
   bin = (latency - 1) / lc->bin_width;
   if (bin >= HISTOGRAM_NUM_BINS) {
     change_bin_width(lc, latency);
     bin = (latency - 1) / lc->bin_width;
@@ -284,7 +280,67 @@
 
   DEBUG("latency_counter_get_percentile: latency_interpolated = %.3f",
         CDTIME_T_TO_DOUBLE(latency_interpolated));
   return (latency_interpolated);
 } /* }}} cdtime_t latency_counter_get_percentile */
 
+double latency_counter_get_rate(const latency_counter_t *lc, /* {{{ */
+                                cdtime_t lower, cdtime_t upper,
+                                const cdtime_t now) {
+  if ((lc == NULL) || (lc->num == 0))
+    return (NAN);
+
+  if (upper && (upper < lower))
+    return (NAN);
+  if (lower == upper)
+    return (0);
+
+  /* Buckets have an exclusive lower bound and an inclusive upper bound. That
+   * means that the first bucket, index 0, represents (0-bin_width]. That means
+   * that latency==bin_width needs to result in bin=0, that's why we need to
+   * subtract one before dividing by bin_width. */
+  cdtime_t lower_bin = 0;
+  if (lower)
+    /* lower is *exclusive* => determine bucket for lower+1 */
+    lower_bin = ((lower + 1) - 1) / lc->bin_width;
+
+  /* lower is greater than the longest latency observed => rate is zero. */
+  if (lower_bin >= HISTOGRAM_NUM_BINS)
+    return (0);
+
+  cdtime_t upper_bin = HISTOGRAM_NUM_BINS - 1;
+  if (upper)
+    upper_bin = (upper - 1) / lc->bin_width;
+
+  if (upper_bin >= HISTOGRAM_NUM_BINS) {
+    upper_bin = HISTOGRAM_NUM_BINS - 1;
+    upper = 0;
+  }
+
+  double sum = 0;
+  for (size_t i = lower_bin; i <= upper_bin; i++)
+    sum += lc->histogram[i];
+
+  if (lower) {
+    /* Approximate ratio of requests in lower_bin, that fall between
+     * lower_bin_boundary and lower. This ratio is then subtracted from sum to
+     * increase accuracy. */
+    cdtime_t lower_bin_boundary = lower_bin * lc->bin_width;
+    assert(lower >= lower_bin_boundary);
+    double lower_ratio =
+        (double)(lower - lower_bin_boundary) / ((double)lc->bin_width);
+    sum -= lower_ratio * lc->histogram[lower_bin];
+  }
+
+  if (upper) {
+    /* As above: approximate ratio of requests in upper_bin, that fall between
+     * upper and upper_bin_boundary. */
+    cdtime_t upper_bin_boundary = (upper_bin + 1) * lc->bin_width;
+    assert(upper <= upper_bin_boundary);
+    double ratio = (double)(upper_bin_boundary - upper) / (double)lc->bin_width;
+    sum -= ratio * lc->histogram[upper_bin];
+  }
+
+  return sum / (CDTIME_T_TO_DOUBLE(now - lc->start_time));
+} /* }}} double latency_counter_get_rate */
+
 /* vim: set sw=2 sts=2 et fdm=marker : */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_latency_config.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_latency_config.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_latency.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_latency.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_latency.h	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_latency.h	2016-12-12 16:03:36.724279000 +0800
@@ -25,12 +25,16 @@
  **/
 
 #include "collectd.h"
 
 #include "utils_time.h"
 
+#ifndef HISTOGRAM_NUM_BINS
+#define HISTOGRAM_NUM_BINS 1000
+#endif
+
 struct latency_counter_s;
 typedef struct latency_counter_s latency_counter_t;
 
 latency_counter_t *latency_counter_create(void);
 void latency_counter_destroy(latency_counter_t *lc);
 
@@ -41,7 +45,21 @@
 cdtime_t latency_counter_get_max(latency_counter_t *lc);
 cdtime_t latency_counter_get_sum(latency_counter_t *lc);
 size_t latency_counter_get_num(latency_counter_t *lc);
 cdtime_t latency_counter_get_average(latency_counter_t *lc);
 cdtime_t latency_counter_get_percentile(latency_counter_t *lc, double percent);
 
+/*
+ * NAME
+ *  latency_counter_get_rate(counter,lower,upper,now)
+ *
+ * DESCRIPTION
+ *   Calculates rate of latency values fall within requested interval.
+ *   Interval specified as (lower,upper], i.e. the lower boundary is exclusive,
+ *   the upper boundary is inclusive.
+ *   When lower is zero, then the interval is (0, upper].
+ *   When upper is zero, then the interval is (lower, infinity).
+ */
+double latency_counter_get_rate(const latency_counter_t *lc, cdtime_t lower,
+                                cdtime_t upper, const cdtime_t now);
+
 /* vim: set sw=2 sts=2 et : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_latency_test.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_latency_test.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_latency_test.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_latency_test.c	2016-12-12 16:03:36.724279000 +0800
@@ -21,13 +21,13 @@
  * DEALINGS IN THE SOFTWARE.
  *
  * Authors:
  *   Florian octo Forster <octo at collectd.org>
  */
 
-#define DBL_PRECISION 1e-9
+#define DBL_PRECISION 1e-6
 
 #include "common.h" /* for STATIC_ARRAY_SIZE */
 #include "collectd.h"
 
 #include "testing.h"
 #include "utils_latency.h"
@@ -98,14 +98,139 @@
   CHECK_ZERO(latency_counter_get_percentile(l, 101.0));
 
   latency_counter_destroy(l);
   return 0;
 }
 
+DEF_TEST(get_rate) {
+  /* We re-declare the struct here so we can inspect its content. */
+  struct {
+    cdtime_t start_time;
+    cdtime_t sum;
+    size_t num;
+    cdtime_t min;
+    cdtime_t max;
+    cdtime_t bin_width;
+    int histogram[HISTOGRAM_NUM_BINS];
+  } * peek;
+  latency_counter_t *l;
+
+  CHECK_NOT_NULL(l = latency_counter_create());
+  peek = (void *)l;
+
+  for (time_t i = 1; i <= 125; i++) {
+    latency_counter_add(l, TIME_T_TO_CDTIME_T(i));
+  }
+
+  /* We expect a bucket width of 125ms. */
+  EXPECT_EQ_UINT64(DOUBLE_TO_CDTIME_T(0.125), peek->bin_width);
+
+  struct {
+    size_t index;
+    int want;
+  } bucket_cases[] = {
+      {0, 0},  /* (0.000-0.125] */
+      {1, 0},  /* (0.125-0.250] */
+      {2, 0},  /* (0.250-0.375] */
+      {3, 0},  /* (0.375-0.500] */
+      {4, 0},  /* (0.500-0.625] */
+      {5, 0},  /* (0.625-0.750] */
+      {6, 0},  /* (0.750-0.875] */
+      {7, 1},  /* (0.875-1.000] */
+      {8, 0},  /* (1.000-1.125] */
+      {9, 0},  /* (1.125-1.250] */
+      {10, 0}, /* (1.250-1.375] */
+      {11, 0}, /* (1.375-1.500] */
+      {12, 0}, /* (1.500-1.625] */
+      {13, 0}, /* (1.625-1.750] */
+      {14, 0}, /* (1.750-1.875] */
+      {15, 1}, /* (1.875-2.000] */
+      {16, 0}, /* (2.000-2.125] */
+  };
+
+  for (size_t i = 0; i < STATIC_ARRAY_SIZE(bucket_cases); i++) {
+    size_t index = bucket_cases[i].index;
+    EXPECT_EQ_INT(bucket_cases[i].want, peek->histogram[index]);
+  }
+
+  struct {
+    cdtime_t lower_bound;
+    cdtime_t upper_bound;
+    double want;
+  } cases[] = {
+      {
+          // bucket 6 is zero
+          DOUBLE_TO_CDTIME_T_STATIC(0.750), DOUBLE_TO_CDTIME_T_STATIC(0.875),
+          0.00,
+      },
+      {
+          // bucket 7 contains the t=1 update
+          DOUBLE_TO_CDTIME_T_STATIC(0.875), DOUBLE_TO_CDTIME_T_STATIC(1.000),
+          1.00,
+      },
+      {
+          // range: bucket 7 - bucket 15; contains the t=1 and t=2 updates
+          DOUBLE_TO_CDTIME_T_STATIC(0.875), DOUBLE_TO_CDTIME_T_STATIC(2.000),
+          2.00,
+      },
+      {
+          // lower bucket is only partially applied
+          DOUBLE_TO_CDTIME_T_STATIC(0.875 + (0.125 / 4)),
+          DOUBLE_TO_CDTIME_T_STATIC(2.000), 1.75,
+      },
+      {
+          // upper bucket is only partially applied
+          DOUBLE_TO_CDTIME_T_STATIC(0.875),
+          DOUBLE_TO_CDTIME_T_STATIC(2.000 - (0.125 / 4)), 1.75,
+      },
+      {
+          // both buckets are only partially applied
+          DOUBLE_TO_CDTIME_T_STATIC(0.875 + (0.125 / 4)),
+          DOUBLE_TO_CDTIME_T_STATIC(2.000 - (0.125 / 4)), 1.50,
+      },
+      {
+          // lower bound is unspecified
+          0, DOUBLE_TO_CDTIME_T_STATIC(2.000), 2.00,
+      },
+      {
+          // upper bound is unspecified
+          DOUBLE_TO_CDTIME_T_STATIC(125.000 - 0.125), 0, 1.00,
+      },
+      {
+          // overflow test: upper >> longest latency
+          DOUBLE_TO_CDTIME_T_STATIC(1.000), DOUBLE_TO_CDTIME_T_STATIC(999999),
+          124.00,
+      },
+      {
+          // overflow test: lower > longest latency
+          DOUBLE_TO_CDTIME_T_STATIC(130), 0, 0.00,
+      },
+      {
+          // lower > upper => error
+          DOUBLE_TO_CDTIME_T_STATIC(10), DOUBLE_TO_CDTIME_T_STATIC(9), NAN,
+      },
+      {
+          // lower == upper => zero
+          DOUBLE_TO_CDTIME_T_STATIC(9), DOUBLE_TO_CDTIME_T_STATIC(9), 0.00,
+      },
+  };
+
+  for (size_t i = 0; i < STATIC_ARRAY_SIZE(cases); i++) {
+    cdtime_t now = peek->start_time + TIME_T_TO_CDTIME_T(1);
+    EXPECT_EQ_DOUBLE(cases[i].want,
+                     latency_counter_get_rate(l, cases[i].lower_bound,
+                                              cases[i].upper_bound, now));
+  }
+
+  latency_counter_destroy(l);
+  return 0;
+}
+
 int main(void) {
   RUN_TEST(simple);
   RUN_TEST(percentile);
+  RUN_TEST(get_rate);
 
   END_TEST;
 }
 
 /* vim: set sw=2 sts=2 et : */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_match.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_match.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_mount.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_mount.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_mount.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_mount.c	2016-12-12 16:03:36.724279000 +0800
@@ -524,13 +524,13 @@
   }
 
   fclose(fp);
 
   return (first);
 } /* static cu_mount_t *cu_mount_gen_getmntent (void) */
-  /* #endif HAVE_TWO_GETMNTENT || HAVE_GEN_GETMNTENT || HAVE_SUN_GETMNTENT */
+/* #endif HAVE_TWO_GETMNTENT || HAVE_GEN_GETMNTENT || HAVE_SUN_GETMNTENT */
 
 #elif HAVE_SEQ_GETMNTENT
 #warn "This version of `getmntent' hat not yet been implemented!"
 /* #endif HAVE_SEQ_GETMNTENT */
 
 #elif HAVE_GETMNTENT_R
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_tail.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_tail.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_tail_match.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: utils_tail_match.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_vl_lookup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_vl_lookup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_vl_lookup.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_vl_lookup.c	2016-12-12 16:03:36.724279000 +0800
@@ -78,13 +78,13 @@
 };
 
 struct user_obj_s;
 typedef struct user_obj_s user_obj_t;
 struct user_obj_s {
   void *user_obj;
-  identifier_t ident;
+  lookup_identifier_t ident;
 
   user_obj_t *next;
 };
 
 struct user_class_s {
   pthread_mutex_t lock;
@@ -159,13 +159,13 @@
   match_part->is_regex = 1;
 
   return (0);
 } /* }}} int lu_copy_ident_to_match_part */
 
 static int lu_copy_ident_to_match(identifier_match_t *match, /* {{{ */
-                                  identifier_t const *ident,
+                                  lookup_identifier_t const *ident,
                                   unsigned int group_by) {
   memset(match, 0, sizeof(*match));
 
   match->group_by = group_by;
 
 #define COPY_FIELD(field)                                                      \
@@ -564,13 +564,13 @@
   obj->by_type_tree = NULL;
 
   sfree(obj);
 } /* }}} void lookup_destroy */
 
 int lookup_add(lookup_t *obj, /* {{{ */
-               identifier_t const *ident, unsigned int group_by,
+               lookup_identifier_t const *ident, unsigned int group_by,
                void *user_class) {
   by_type_entry_t *by_type = NULL;
   user_class_list_t *user_class_obj;
 
   by_type = lu_search_by_type(obj, ident->type, /* allocate = */ 1);
   if (by_type == NULL)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_vl_lookup.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_vl_lookup.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_vl_lookup.h	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_vl_lookup.h	2016-12-12 16:03:36.724279000 +0800
@@ -51,20 +51,20 @@
 typedef void (*lookup_free_class_callback_t)(void *user_class);
 
 /* Used to free user_obj pointers. May be NULL in which case nothing is
  * freed. */
 typedef void (*lookup_free_obj_callback_t)(void *user_obj);
 
-struct identifier_s {
+struct lookup_identifier_s {
   char host[DATA_MAX_NAME_LEN];
   char plugin[DATA_MAX_NAME_LEN];
   char plugin_instance[DATA_MAX_NAME_LEN];
   char type[DATA_MAX_NAME_LEN];
   char type_instance[DATA_MAX_NAME_LEN];
 };
-typedef struct identifier_s identifier_t;
+typedef struct lookup_identifier_s lookup_identifier_t;
 
 #define LU_GROUP_BY_HOST 0x01
 #define LU_GROUP_BY_PLUGIN 0x02
 #define LU_GROUP_BY_PLUGIN_INSTANCE 0x04
 /* #define LU_GROUP_BY_TYPE            0x00 */
 #define LU_GROUP_BY_TYPE_INSTANCE 0x10
@@ -75,13 +75,13 @@
 __attribute__((nonnull(1, 2)))
 lookup_t *lookup_create(lookup_class_callback_t, lookup_obj_callback_t,
                         lookup_free_class_callback_t,
                         lookup_free_obj_callback_t);
 void lookup_destroy(lookup_t *obj);
 
-int lookup_add(lookup_t *obj, identifier_t const *ident, unsigned int group_by,
-               void *user_class);
+int lookup_add(lookup_t *obj, lookup_identifier_t const *ident,
+               unsigned int group_by, void *user_class);
 
 /* TODO(octo): Pass lookup_obj_callback_t to lookup_search()? */
 int lookup_search(lookup_t *obj, data_set_t const *ds, value_list_t const *vl);
 
 #endif /* UTILS_VL_LOOKUP_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_vl_lookup_test.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_vl_lookup_test.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/utils_vl_lookup_test.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/utils_vl_lookup_test.c	2016-12-12 16:03:36.724279000 +0800
@@ -29,25 +29,25 @@
 #include "testing.h"
 #include "utils_vl_lookup.h"
 
 static _Bool expect_new_obj = 0;
 static _Bool have_new_obj = 0;
 
-static identifier_t last_class_ident;
-static identifier_t last_obj_ident;
+static lookup_identifier_t last_class_ident;
+static lookup_identifier_t last_obj_ident;
 
 static data_source_t dsrc_test = {"value", DS_TYPE_DERIVE, 0.0, NAN};
 static data_set_t const ds_test = {"test", 1, &dsrc_test};
 
 static data_source_t dsrc_unknown = {"value", DS_TYPE_DERIVE, 0.0, NAN};
 static data_set_t const ds_unknown = {"unknown", 1, &dsrc_unknown};
 
 static int lookup_obj_callback(data_set_t const *ds, value_list_t const *vl,
                                void *user_class, void *user_obj) {
-  identifier_t *class = user_class;
-  identifier_t *obj = user_obj;
+  lookup_identifier_t *class = user_class;
+  lookup_identifier_t *obj = user_obj;
 
   OK1(expect_new_obj == have_new_obj,
       (expect_new_obj ? "New obj is created." : "Updating existing obj."));
 
   memcpy(&last_class_ident, class, sizeof(last_class_ident));
   memcpy(&last_obj_ident, obj, sizeof(last_obj_ident));
@@ -57,14 +57,14 @@
 
   return (0);
 }
 
 static void *lookup_class_callback(data_set_t const *ds, value_list_t const *vl,
                                    void *user_class) {
-  identifier_t *class = user_class;
-  identifier_t *obj;
+  lookup_identifier_t *class = user_class;
+  lookup_identifier_t *obj;
 
   assert(expect_new_obj);
 
   memcpy(&last_class_ident, class, sizeof(last_class_ident));
 
   obj = malloc(sizeof(*obj));
@@ -82,13 +82,13 @@
 
 static int checked_lookup_add(lookup_t *obj, /* {{{ */
                               char const *host, char const *plugin,
                               char const *plugin_instance, char const *type,
                               char const *type_instance,
                               unsigned int group_by) {
-  identifier_t ident;
+  lookup_identifier_t ident;
   void *user_class;
 
   strncpy(ident.host, host, sizeof(ident.host));
   strncpy(ident.plugin, plugin, sizeof(ident.plugin));
   strncpy(ident.plugin_instance, plugin_instance,
           sizeof(ident.plugin_instance));
@@ -104,13 +104,13 @@
 
 static int checked_lookup_search(lookup_t *obj, char const *host,
                                  char const *plugin,
                                  char const *plugin_instance, char const *type,
                                  char const *type_instance, _Bool expect_new) {
   int status;
-  value_list_t vl = VALUE_LIST_STATIC;
+  value_list_t vl = VALUE_LIST_INIT;
   data_set_t const *ds = &ds_unknown;
 
   strncpy(vl.host, host, sizeof(vl.host));
   strncpy(vl.plugin, plugin, sizeof(vl.plugin));
   strncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   strncpy(vl.type, type, sizeof(vl.type));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/valgrind.FreeBSD.suppress /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/valgrind.FreeBSD.suppress
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/valgrind.FreeBSD.suppress	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/valgrind.FreeBSD.suppress	2016-12-12 16:03:36.728278972 +0800
@@ -1,8 +1,8 @@
 {
    strlen_bogus_invalid_read_after_strdup
    Memcheck:Addr4
    fun:parse_value
    fun:parse_values
-   fun:test_parse_values
+   ...
    fun:main
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/varnish.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/varnish.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/varnish.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/varnish.c	2016-12-12 16:03:36.728278972 +0800
@@ -91,19 +91,16 @@
                           const char *type_instance, value_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = &value;
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
-
   sstrncpy(vl.plugin, "varnish", sizeof(vl.plugin));
 
   if (plugin_instance == NULL)
     plugin_instance = "default";
-
   ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%s-%s",
             plugin_instance, category);
 
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   if (type_instance != NULL)
@@ -113,30 +110,22 @@
 } /* }}} int varnish_submit */
 
 static int varnish_submit_gauge(const char *plugin_instance, /* {{{ */
                                 const char *category, const char *type,
                                 const char *type_instance,
                                 uint64_t gauge_value) {
-  value_t value;
-
-  value.gauge = (gauge_t)gauge_value;
-
-  return (
-      varnish_submit(plugin_instance, category, type, type_instance, value));
+  return (varnish_submit(plugin_instance, category, type, type_instance,
+                         (value_t){.gauge = (gauge_t)gauge_value}));
 } /* }}} int varnish_submit_gauge */
 
 static int varnish_submit_derive(const char *plugin_instance, /* {{{ */
                                  const char *category, const char *type,
                                  const char *type_instance,
                                  uint64_t derive_value) {
-  value_t value;
-
-  value.derive = (derive_t)derive_value;
-
-  return (
-      varnish_submit(plugin_instance, category, type, type_instance, value));
+  return (varnish_submit(plugin_instance, category, type, type_instance,
+                         (value_t){.derive = (derive_t)derive_value}));
 } /* }}} int varnish_submit_derive */
 
 #if HAVE_VARNISH_V3 || HAVE_VARNISH_V4
 static int varnish_monitor(void *priv,
                            const struct VSC_point *const pt) /* {{{ */
 {
@@ -1137,27 +1126,26 @@
 
   /* Default settings: */
   conf->instance = NULL;
 
   varnish_config_apply_default(conf);
 
-  user_data_t ud = {.data = conf, .free_func = varnish_config_free};
-
-  plugin_register_complex_read(/* group = */ "varnish",
-                               /* name      = */ "varnish/localhost",
-                               /* callback  = */ varnish_read,
-                               /* interval  = */ 0,
-                               /* user data = */ &ud);
+  plugin_register_complex_read(
+      /* group = */ "varnish",
+      /* name      = */ "varnish/localhost",
+      /* callback  = */ varnish_read,
+      /* interval  = */ 0, &(user_data_t){
+                               .data = conf, .free_func = varnish_config_free,
+                           });
 
   return (0);
 } /* }}} int varnish_init */
 
 static int varnish_config_instance(const oconfig_item_t *ci) /* {{{ */
 {
   user_config_t *conf;
-  user_data_t ud;
   char callback_name[DATA_MAX_NAME_LEN];
 
   conf = calloc(1, sizeof(*conf));
   if (conf == NULL)
     return (ENOMEM);
   conf->instance = NULL;
@@ -1305,20 +1293,19 @@
     return (EINVAL);
   }
 
   ssnprintf(callback_name, sizeof(callback_name), "varnish/%s",
             (conf->instance == NULL) ? "localhost" : conf->instance);
 
-  ud.data = conf;
-  ud.free_func = varnish_config_free;
-
-  plugin_register_complex_read(/* group = */ "varnish",
-                               /* name      = */ callback_name,
-                               /* callback  = */ varnish_read,
-                               /* interval  = */ 0,
-                               /* user data = */ &ud);
+  plugin_register_complex_read(
+      /* group = */ "varnish",
+      /* name      = */ callback_name,
+      /* callback  = */ varnish_read,
+      /* interval  = */ 0, &(user_data_t){
+                               .data = conf, .free_func = varnish_config_free,
+                           });
 
   have_instance = 1;
 
   return (0);
 } /* }}} int varnish_config_instance */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/virt.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/virt.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/virt.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/virt.c	2016-12-12 16:03:36.728278972 +0800
@@ -23,12 +23,13 @@
 
 #include "common.h"
 #include "plugin.h"
 #include "utils_complain.h"
 #include "utils_ignorelist.h"
 
+#include <libgen.h> /* for basename(3) */
 #include <libvirt/libvirt.h>
 #include <libvirt/virterror.h>
 #include <libxml/parser.h>
 #include <libxml/tree.h>
 #include <libxml/xpath.h>
 
@@ -38,12 +39,14 @@
 static const char *config_keys[] = {"Connection",
 
                                     "RefreshInterval",
 
                                     "Domain",
                                     "BlockDevice",
+                                    "BlockDeviceFormat",
+                                    "BlockDeviceFormatBasename",
                                     "InterfaceDevice",
                                     "IgnoreSelected",
 
                                     "HostnameFormat",
                                     "InterfaceFormat",
 
@@ -116,15 +119,21 @@
 
 enum plginst_field { plginst_none = 0, plginst_name, plginst_uuid };
 
 static enum plginst_field plugin_instance_format[PLGINST_MAX_FIELDS] = {
     plginst_none};
 
+/* BlockDeviceFormat */
+enum bd_field { target, source };
+
 /* InterfaceFormat. */
 enum if_field { if_address, if_name, if_number };
 
+/* BlockDeviceFormatBasename */
+_Bool blockdevice_format_basename = 0;
+static enum bd_field blockdevice_format = target;
 static enum if_field interface_format = if_name;
 
 /* Time that we last refreshed. */
 static time_t last_refresh = (time_t)0;
 
 static int refresh_lists(void);
@@ -207,101 +216,67 @@
   }
 
   vl->plugin_instance[sizeof(vl->plugin_instance) - 1] = '\0';
 
 } /* void init_value_list */
 
-static void memory_submit(gauge_t memory, virDomainPtr dom) {
-  value_t values[1];
+static void submit(virDomainPtr dom, char const *type,
+                   char const *type_instance, value_t *values,
+                   size_t values_len) {
   value_list_t vl = VALUE_LIST_INIT;
-
   init_value_list(&vl, dom);
 
-  values[0].gauge = memory;
-
   vl.values = values;
-  vl.values_len = 1;
+  vl.values_len = values_len;
 
-  sstrncpy(vl.type, "memory", sizeof(vl.type));
-  sstrncpy(vl.type_instance, "total", sizeof(vl.type_instance));
+  sstrncpy(vl.type, type, sizeof(vl.type));
+  if (type_instance != NULL)
+    sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
-static void memory_stats_submit(gauge_t memory, virDomainPtr dom,
+static void memory_submit(gauge_t value, virDomainPtr dom) {
+  submit(dom, "memory", "total", &(value_t){.gauge = value}, 1);
+}
+
+static void memory_stats_submit(gauge_t value, virDomainPtr dom,
                                 int tag_index) {
   static const char *tags[] = {"swap_in",        "swap_out", "major_fault",
                                "minor_fault",    "unused",   "available",
                                "actual_balloon", "rss"};
 
-  value_t values[1];
-  value_list_t vl = VALUE_LIST_INIT;
-
-  init_value_list(&vl, dom);
-
-  values[0].gauge = memory;
-
-  vl.values = values;
-  vl.values_len = 1;
-
-  sstrncpy(vl.type, "memory", sizeof(vl.type));
-  sstrncpy(vl.type_instance, tags[tag_index], sizeof(vl.type_instance));
+  if ((tag_index < 0) || (tag_index >= STATIC_ARRAY_SIZE(tags))) {
+    ERROR("virt plugin: Array index out of bounds: tag_index = %d", tag_index);
+    return;
+  }
 
-  plugin_dispatch_values(&vl);
+  submit(dom, "memory", tags[tag_index], &(value_t){.gauge = value}, 1);
 }
 
-static void cpu_submit(unsigned long long cpu_time, virDomainPtr dom,
+static void cpu_submit(unsigned long long value, virDomainPtr dom,
                        const char *type) {
-  value_t values[1];
-  value_list_t vl = VALUE_LIST_INIT;
-
-  init_value_list(&vl, dom);
-
-  values[0].derive = cpu_time;
-
-  vl.values = values;
-  vl.values_len = 1;
-
-  sstrncpy(vl.type, type, sizeof(vl.type));
-
-  plugin_dispatch_values(&vl);
+  submit(dom, type, NULL, &(value_t){.derive = (derive_t)value}, 1);
 }
 
-static void vcpu_submit(derive_t cpu_time, virDomainPtr dom, int vcpu_nr,
+static void vcpu_submit(derive_t value, virDomainPtr dom, int vcpu_nr,
                         const char *type) {
-  value_t values[1];
-  value_list_t vl = VALUE_LIST_INIT;
+  char type_instance[DATA_MAX_NAME_LEN];
 
-  init_value_list(&vl, dom);
-
-  values[0].derive = cpu_time;
-  vl.values = values;
-  vl.values_len = 1;
+  ssnprintf(type_instance, sizeof(type_instance), "%d", vcpu_nr);
 
-  sstrncpy(vl.type, type, sizeof(vl.type));
-  ssnprintf(vl.type_instance, sizeof(vl.type_instance), "%d", vcpu_nr);
-
-  plugin_dispatch_values(&vl);
+  submit(dom, type, type_instance, &(value_t){.derive = value}, 1);
 }
 
 static void submit_derive2(const char *type, derive_t v0, derive_t v1,
                            virDomainPtr dom, const char *devname) {
-  value_t values[2];
-  value_list_t vl = VALUE_LIST_INIT;
-
-  init_value_list(&vl, dom);
-
-  values[0].derive = v0;
-  values[1].derive = v1;
-  vl.values = values;
-  vl.values_len = 2;
-
-  sstrncpy(vl.type, type, sizeof(vl.type));
-  sstrncpy(vl.type_instance, devname, sizeof(vl.type_instance));
+  value_t values[] = {
+      {.derive = v0}, {.derive = v1},
+  };
 
-  plugin_dispatch_values(&vl);
+  submit(dom, type, devname, values, STATIC_ARRAY_SIZE(values));
 } /* void submit_derive2 */
 
 static int lv_init(void) {
   if (virInitialize() != 0)
     return -1;
   else
@@ -345,12 +320,28 @@
   }
   if (strcasecmp(key, "BlockDevice") == 0) {
     if (ignorelist_add(il_block_devices, value))
       return 1;
     return 0;
   }
+
+  if (strcasecmp(key, "BlockDeviceFormat") == 0) {
+    if (strcasecmp(value, "target") == 0)
+      blockdevice_format = target;
+    else if (strcasecmp(value, "source") == 0)
+      blockdevice_format = source;
+    else {
+      ERROR(PLUGIN_NAME " plugin: unknown BlockDeviceFormat: %s", value);
+      return -1;
+    }
+    return 0;
+  }
+  if (strcasecmp(key, "BlockDeviceFormatBasename") == 0) {
+    blockdevice_format_basename = IS_TRUE(value);
+    return 0;
+  }
   if (strcasecmp(key, "InterfaceDevice") == 0) {
     if (ignorelist_add(il_interface_devices, value))
       return 1;
     return 0;
   }
 
@@ -580,20 +571,28 @@
     struct _virDomainBlockStats stats;
 
     if (virDomainBlockStats(block_devices[i].dom, block_devices[i].path, &stats,
                             sizeof stats) != 0)
       continue;
 
+    char *type_instance = NULL;
+    if (blockdevice_format_basename && blockdevice_format == source)
+      type_instance = strdup(basename(block_devices[i].path));
+    else
+      type_instance = strdup(block_devices[i].path);
+
     if ((stats.rd_req != -1) && (stats.wr_req != -1))
       submit_derive2("disk_ops", (derive_t)stats.rd_req, (derive_t)stats.wr_req,
-                     block_devices[i].dom, block_devices[i].path);
+                     block_devices[i].dom, type_instance);
 
     if ((stats.rd_bytes != -1) && (stats.wr_bytes != -1))
       submit_derive2("disk_octets", (derive_t)stats.rd_bytes,
                      (derive_t)stats.wr_bytes, block_devices[i].dom,
-                     block_devices[i].path);
+                     type_instance);
+
+    sfree(type_instance);
   } /* for (nr_block_devices) */
 
   /* Get interface stats for each domain. */
   for (int i = 0; i < nr_interface_devices; ++i) {
     struct _virDomainInterfaceStats stats;
     char *display_name = NULL;
@@ -713,14 +712,17 @@
         goto cont;
       }
 
       xpath_ctx = xmlXPathNewContext(xml_doc);
 
       /* Block devices. */
-      xpath_obj = xmlXPathEval((xmlChar *)"/domain/devices/disk/target[@dev]",
-                               xpath_ctx);
+      char *bd_xmlpath = "/domain/devices/disk/target[@dev]";
+      if (blockdevice_format == source)
+        bd_xmlpath = "/domain/devices/disk/source[@dev]";
+      xpath_obj = xmlXPathEval((xmlChar *)bd_xmlpath, xpath_ctx);
+
       if (xpath_obj == NULL || xpath_obj->type != XPATH_NODESET ||
           xpath_obj->nodesetval == NULL)
         goto cont;
 
       for (int j = 0; j < xpath_obj->nodesetval->nodeNr; ++j) {
         xmlNodePtr node;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/vmem.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/vmem.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/vmem.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/vmem.c	2016-12-12 16:03:36.728278972 +0800
@@ -44,31 +44,30 @@
                    const char *type_instance, value_t *values, int values_len) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = values;
   vl.values_len = values_len;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "vmem", sizeof(vl.plugin));
   if (plugin_instance != NULL)
     sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_instance != NULL)
     sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void vmem_submit */
 
 static void submit_two(const char *plugin_instance, const char *type,
                        const char *type_instance, derive_t c0, derive_t c1) {
-  value_t values[2];
+  value_t values[] = {
+      {.derive = c0}, {.derive = c1},
+  };
 
-  values[0].derive = c0;
-  values[1].derive = c1;
-
-  submit(plugin_instance, type, type_instance, values, 2);
+  submit(plugin_instance, type, type_instance, values,
+         STATIC_ARRAY_SIZE(values));
 } /* void submit_one */
 
 static void submit_one(const char *plugin_instance, const char *type,
                        const char *type_instance, value_t value) {
   submit(plugin_instance, type, type_instance, &value, 1);
 } /* void submit_one */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/vserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/vserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/vserver.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/vserver.c	2016-12-12 16:03:36.728278972 +0800
@@ -52,60 +52,51 @@
   return (0);
 } /* static void vserver_init(void) */
 
 static void traffic_submit(const char *plugin_instance,
                            const char *type_instance, derive_t rx,
                            derive_t tx) {
-  value_t values[2];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].derive = rx;
-  values[1].derive = tx;
+  value_t values[] = {
+      {.derive = rx}, {.derive = tx},
+  };
 
   vl.values = values;
   vl.values_len = STATIC_ARRAY_SIZE(values);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "vserver", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "if_octets", sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* void traffic_submit */
 
 static void load_submit(const char *plugin_instance, gauge_t snum, gauge_t mnum,
                         gauge_t lnum) {
-  value_t values[3];
   value_list_t vl = VALUE_LIST_INIT;
-
-  values[0].gauge = snum;
-  values[1].gauge = mnum;
-  values[2].gauge = lnum;
+  value_t values[] = {
+      {.gauge = snum}, {.gauge = mnum}, {.gauge = lnum},
+  };
 
   vl.values = values;
   vl.values_len = STATIC_ARRAY_SIZE(values);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "vserver", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, "load", sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 }
 
 static void submit_gauge(const char *plugin_instance, const char *type,
                          const char *type_instance, gauge_t value)
 
 {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
-  vl.values_len = STATIC_ARRAY_SIZE(values);
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
+  vl.values = &(value_t){.gauge = value};
+  vl.values_len = 1;
   sstrncpy(vl.plugin, "vserver", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/wireless.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/wireless.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/wireless.c	2017-10-06 14:45:52.973917770 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/wireless.c	2016-12-12 16:03:36.728278972 +0800
@@ -50,20 +50,16 @@
 	return (watt);
 }
 #endif
 
 static void wireless_submit(const char *plugin_instance, const char *type,
                             double value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "wireless", sizeof(vl.plugin));
   sstrncpy(vl.plugin_instance, plugin_instance, sizeof(vl.plugin_instance));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* void wireless_submit */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_graphite.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_graphite.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_graphite.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_graphite.c	2016-12-12 16:03:36.728278972 +0800
@@ -518,12 +518,16 @@
     else if (strcasecmp("StoreRates", child->key) == 0)
       cf_util_get_flag(child, &cb->format_flags, GRAPHITE_STORE_RATES);
     else if (strcasecmp("SeparateInstances", child->key) == 0)
       cf_util_get_flag(child, &cb->format_flags, GRAPHITE_SEPARATE_INSTANCES);
     else if (strcasecmp("AlwaysAppendDS", child->key) == 0)
       cf_util_get_flag(child, &cb->format_flags, GRAPHITE_ALWAYS_APPEND_DS);
+    else if (strcasecmp("PreserveSeparator", child->key) == 0)
+      cf_util_get_flag(child, &cb->format_flags, GRAPHITE_PRESERVE_SEPARATOR);
+    else if (strcasecmp("DropDuplicateFields", child->key) == 0)
+      cf_util_get_flag(child, &cb->format_flags, GRAPHITE_DROP_DUPE_FIELDS);
     else if (strcasecmp("EscapeCharacter", child->key) == 0)
       config_set_char(&cb->escape_char, child);
     else {
       ERROR("write_graphite plugin: Invalid configuration "
             "option: %s.",
             child->key);
@@ -544,18 +548,18 @@
     ssnprintf(callback_name, sizeof(callback_name), "write_graphite/%s/%s/%s",
               cb->node, cb->service, cb->protocol);
   else
     ssnprintf(callback_name, sizeof(callback_name), "write_graphite/%s",
               cb->name);
 
-  user_data_t ud = {.data = cb, .free_func = wg_callback_free};
+  plugin_register_write(callback_name, wg_write,
+                        &(user_data_t){
+                            .data = cb, .free_func = wg_callback_free,
+                        });
 
-  plugin_register_write(callback_name, wg_write, &ud);
-
-  ud.free_func = NULL;
-  plugin_register_flush(callback_name, wg_flush, &ud);
+  plugin_register_flush(callback_name, wg_flush, &(user_data_t){.data = cb});
 
   return (0);
 }
 
 static int wg_config(oconfig_item_t *ci) {
   for (int i = 0; i < ci->children_num; i++) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_http.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_http.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_http.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_http.c	2016-12-12 16:03:36.728278972 +0800
@@ -111,13 +111,12 @@
 
 /* must hold cb->send_lock when calling */
 static int wh_post_nolock(wh_callback_t *cb, char const *data) /* {{{ */
 {
   int status = 0;
 
-  curl_easy_setopt(cb->curl, CURLOPT_URL, cb->location);
   curl_easy_setopt(cb->curl, CURLOPT_POSTFIELDS, data);
   status = curl_easy_perform(cb->curl);
 
   wh_log_http_error(cb);
 
   if (status != CURLE_OK) {
@@ -161,12 +160,13 @@
   else
     cb->headers = curl_slist_append(cb->headers, "Content-Type: text/plain");
   cb->headers = curl_slist_append(cb->headers, "Expect:");
   curl_easy_setopt(cb->curl, CURLOPT_HTTPHEADER, cb->headers);
 
   curl_easy_setopt(cb->curl, CURLOPT_ERRORBUFFER, cb->curl_errbuf);
+  curl_easy_setopt(cb->curl, CURLOPT_URL, cb->location);
   curl_easy_setopt(cb->curl, CURLOPT_FOLLOWLOCATION, 1L);
   curl_easy_setopt(cb->curl, CURLOPT_MAXREDIRS, 50L);
 
   if (cb->user != NULL) {
 #ifdef HAVE_CURLOPT_USERNAME
     curl_easy_setopt(cb->curl, CURLOPT_USERNAME, cb->user);
@@ -387,12 +387,15 @@
       pthread_mutex_unlock(&cb->send_lock);
       return (status);
     }
   }
   assert(command_len < cb->send_buffer_free);
 
+  /* Make scan-build happy. */
+  assert(cb->send_buffer != NULL);
+
   /* `command_len + 1' because `command_len' does not include the
    * trailing null byte. Neither does `send_buffer_fill'. */
   memcpy(cb->send_buffer + cb->send_buffer_fill, command, command_len + 1);
   cb->send_buffer_fill += command_len;
   cb->send_buffer_free -= command_len;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_kafka.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_kafka.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_kafka.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_kafka.c	2016-12-12 16:03:36.728278972 +0800
@@ -183,15 +183,16 @@
     return status;
 
   bzero(buffer, sizeof(buffer));
 
   switch (ctx->format) {
   case KAFKA_FORMAT_COMMAND:
-    status = create_putval(buffer, sizeof(buffer), ds, vl);
+    status = cmd_create_putval(buffer, sizeof(buffer), ds, vl);
     if (status != 0) {
-      ERROR("write_kafka plugin: create_putval failed with status %i.", status);
+      ERROR("write_kafka plugin: cmd_create_putval failed with status %i.",
+            status);
       return status;
     }
     blen = strlen(buffer);
     break;
   case KAFKA_FORMAT_JSON:
     format_json_initialize(buffer, &bfill, &bfree);
@@ -367,12 +368,16 @@
                                 GRAPHITE_SEPARATE_INSTANCES);
 
     } else if (strcasecmp("GraphiteAlwaysAppendDS", child->key) == 0) {
       status = cf_util_get_flag(child, &tctx->graphite_flags,
                                 GRAPHITE_ALWAYS_APPEND_DS);
 
+    } else if (strcasecmp("GraphitePreserveSeparator", child->key) == 0) {
+      status = cf_util_get_flag(child, &tctx->graphite_flags,
+                                GRAPHITE_PRESERVE_SEPARATOR);
+
     } else if (strcasecmp("GraphitePrefix", child->key) == 0) {
       status = cf_util_get_string(child, &tctx->prefix);
     } else if (strcasecmp("GraphitePostfix", child->key) == 0) {
       status = cf_util_get_string(child, &tctx->postfix);
     } else if (strcasecmp("GraphiteEscapeChar", child->key) == 0) {
       char *tmp_buff = NULL;
@@ -393,15 +398,17 @@
   rd_kafka_topic_conf_set_partitioner_cb(tctx->conf, kafka_partition);
   rd_kafka_topic_conf_set_opaque(tctx->conf, tctx);
 
   ssnprintf(callback_name, sizeof(callback_name), "write_kafka/%s",
             tctx->topic_name);
 
-  user_data_t ud = {.data = tctx, .free_func = kafka_topic_context_free};
-
-  status = plugin_register_write(callback_name, kafka_write, &ud);
+  status = plugin_register_write(
+      callback_name, kafka_write,
+      &(user_data_t){
+          .data = tctx, .free_func = kafka_topic_context_free,
+      });
   if (status != 0) {
     WARNING("write_kafka plugin: plugin_register_write (\"%s\") "
             "failed with status %i.",
             callback_name, status);
     goto errout;
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_log.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_log.c	2016-12-12 16:03:36.728278972 +0800
@@ -28,44 +28,113 @@
 #include "collectd.h"
 
 #include "common.h"
 #include "plugin.h"
 
 #include "utils_format_graphite.h"
+#include "utils_format_json.h"
 
 #include <netdb.h>
 
-#define WL_BUF_SIZE 8192
+#define WL_BUF_SIZE 16384
 
-static int wl_write_messages(const data_set_t *ds, const value_list_t *vl) {
+#define WL_FORMAT_GRAPHITE 1
+#define WL_FORMAT_JSON 2
+
+/* Plugin:WriteLog has to also operate without a config, so use a global. */
+int wl_format = WL_FORMAT_GRAPHITE;
+
+static int wl_write_graphite(const data_set_t *ds, const value_list_t *vl) {
   char buffer[WL_BUF_SIZE] = {0};
   int status;
 
   if (0 != strcmp(ds->type, vl->type)) {
-    ERROR("write_log plugin: DS type does not match "
-          "value list type");
+    ERROR("write_log plugin: DS type does not match value list type");
     return -1;
   }
 
   status = format_graphite(buffer, sizeof(buffer), ds, vl, NULL, NULL, '_', 0);
   if (status != 0) /* error message has been printed already. */
     return (status);
 
   INFO("write_log values:\n%s", buffer);
 
   return (0);
-} /* int wl_write_messages */
+} /* int wl_write_graphite */
+
+static int wl_write_json(const data_set_t *ds, const value_list_t *vl) {
+  char buffer[WL_BUF_SIZE] = {0};
+  size_t bfree = sizeof(buffer);
+  size_t bfill = 0;
+
+  if (0 != strcmp(ds->type, vl->type)) {
+    ERROR("write_log plugin: DS type does not match value list type");
+    return -1;
+  }
+
+  format_json_initialize(buffer, &bfill, &bfree);
+  format_json_value_list(buffer, &bfill, &bfree, ds, vl,
+                         /* store rates = */ 0);
+  format_json_finalize(buffer, &bfill, &bfree);
+
+  INFO("write_log values:\n%s", buffer);
+
+  return (0);
+} /* int wl_write_json */
 
 static int wl_write(const data_set_t *ds, const value_list_t *vl,
                     __attribute__((unused)) user_data_t *user_data) {
-  int status;
+  int status = 0;
 
-  status = wl_write_messages(ds, vl);
+  if (wl_format == WL_FORMAT_GRAPHITE) {
+    status = wl_write_graphite(ds, vl);
+  } else if (wl_format == WL_FORMAT_JSON) {
+    status = wl_write_json(ds, vl);
+  }
 
   return (status);
 }
 
+static int wl_config(oconfig_item_t *ci) /* {{{ */
+{
+  _Bool format_seen = 0;
+
+  for (int i = 0; i < ci->children_num; i++) {
+    oconfig_item_t *child = ci->children + i;
+
+    if (strcasecmp("Format", child->key) == 0) {
+      char str[16];
+
+      if (cf_util_get_string_buffer(child, str, sizeof(str)) != 0)
+        continue;
+
+      if (format_seen) {
+        WARNING("write_log plugin: Redefining option `%s'.", child->key);
+      }
+      format_seen = 1;
+
+      if (strcasecmp("Graphite", str) == 0)
+        wl_format = WL_FORMAT_GRAPHITE;
+      else if (strcasecmp("JSON", str) == 0)
+        wl_format = WL_FORMAT_JSON;
+      else {
+        ERROR("write_log plugin: Unknown format `%s' for option `%s'.", str,
+              child->key);
+        return (-EINVAL);
+      }
+    } else {
+      ERROR("write_log plugin: Invalid configuration option: `%s'.",
+            child->key);
+      return (-EINVAL);
+    }
+  }
+
+  return (0);
+} /* }}} int wl_config */
+
 void module_register(void) {
+  plugin_register_complex_config("write_log", wl_config);
+  /* If config is supplied, the global wl_format will be set. */
   plugin_register_write("write_log", wl_write, NULL);
 }
 
 /* vim: set sw=4 ts=4 sts=4 tw=78 et : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_mongodb.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_mongodb.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_mongodb.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_mongodb.c	2016-12-12 16:03:36.728278972 +0800
@@ -312,15 +312,16 @@
 
   if (status == 0) {
     char cb_name[DATA_MAX_NAME_LEN];
 
     ssnprintf(cb_name, sizeof(cb_name), "write_mongodb/%s", node->name);
 
-    user_data_t ud = {.data = node, .free_func = wm_config_free};
-
-    status = plugin_register_write(cb_name, wm_write, &ud);
+    status = plugin_register_write(
+        cb_name, wm_write, &(user_data_t){
+                               .data = node, .free_func = wm_config_free,
+                           });
     INFO("write_mongodb plugin: registered write plugin %s %d", cb_name,
          status);
   }
 
   if (status != 0)
     wm_config_free(node);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src: write_prometheus.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_redis.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_redis.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/write_redis.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/write_redis.c	2016-12-12 16:03:36.728278972 +0800
@@ -218,15 +218,16 @@
 
   if (status == 0) {
     char cb_name[DATA_MAX_NAME_LEN];
 
     ssnprintf(cb_name, sizeof(cb_name), "write_redis/%s", node->name);
 
-    user_data_t ud = {.data = node, .free_func = wr_config_free};
-
-    status = plugin_register_write(cb_name, wr_write, &ud);
+    status = plugin_register_write(
+        cb_name, wr_write, &(user_data_t){
+                               .data = node, .free_func = wr_config_free,
+                           });
   }
 
   if (status != 0)
     wr_config_free(node);
 
   return (status);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/xencpu.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/xencpu.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/xencpu.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/xencpu.c	2016-12-12 16:03:36.728278972 +0800
@@ -98,22 +98,18 @@
   free(cpu_info);
   xc_interface_close(xc_handle);
 
   return 0;
 } /* static int xencpu_shutdown */
 
-static void submit_value(int cpu_num, gauge_t percent) {
-  value_t values[1];
+static void submit_value(int cpu_num, gauge_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = percent;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "xencpu", sizeof(vl.plugin));
   sstrncpy(vl.type, "percent", sizeof(vl.type));
   sstrncpy(vl.type_instance, "load", sizeof(vl.type_instance));
 
   if (cpu_num >= 0) {
     ssnprintf(vl.plugin_instance, sizeof(vl.plugin_instance), "%i", cpu_num);
@@ -133,15 +129,15 @@
     return (-1);
   }
 
   int status;
   for (int cpu = 0; cpu < nr_cpus; cpu++) {
     gauge_t rate = NAN;
-    value_t value = {.derive = cpu_info[cpu].idletime};
 
-    status = value_to_rate(&rate, value, DS_TYPE_DERIVE, now, &cpu_states[cpu]);
+    status = value_to_rate(&rate, (value_t){.derive = cpu_info[cpu].idletime},
+                           DS_TYPE_DERIVE, now, &cpu_states[cpu]);
     if (status == 0) {
       submit_value(cpu, 100 - rate / 10000000);
     }
   }
 
   return (0);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/xmms.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/xmms.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/xmms.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/xmms.c	2016-12-12 16:03:36.728278972 +0800
@@ -31,20 +31,16 @@
 
 #include <xmms/xmmsctrl.h>
 
 static gint xmms_session;
 
 static void cxmms_submit(const char *type, gauge_t value) {
-  value_t values[1];
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = value;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "xmms", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
 
   plugin_dispatch_values(&vl);
 } /* void cxmms_submit */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/zfs_arc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/zfs_arc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/zfs_arc.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/zfs_arc.c	2016-12-12 16:03:36.728278972 +0800
@@ -127,63 +127,53 @@
 
   return (-1);
 }
 #endif
 
 static void za_submit(const char *type, const char *type_instance,
-                      value_t *values, int values_len) {
+                      value_t *values, size_t values_len) {
   value_list_t vl = VALUE_LIST_INIT;
 
   vl.values = values;
   vl.values_len = values_len;
 
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "zfs_arc", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   sstrncpy(vl.type_instance, type_instance, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 }
 
 static void za_submit_gauge(const char *type, const char *type_instance,
                             gauge_t value) {
-  value_t vv;
-
-  vv.gauge = value;
-  za_submit(type, type_instance, &vv, 1);
+  za_submit(type, type_instance, &(value_t){.gauge = value}, 1);
 }
 
 static int za_read_derive(kstat_t *ksp, const char *kstat_value,
                           const char *type, const char *type_instance) {
-  long long tmp;
-  value_t v;
-
-  tmp = get_zfs_value(ksp, (char *)kstat_value);
+  long long tmp = get_zfs_value(ksp, (char *)kstat_value);
   if (tmp == -1LL) {
     WARNING("zfs_arc plugin: Reading kstat value \"%s\" failed.", kstat_value);
     return (-1);
   }
 
-  v.derive = (derive_t)tmp;
-  za_submit(type, type_instance, /* values = */ &v, /* values_num = */ 1);
+  za_submit(type, type_instance, &(value_t){.derive = (derive_t)tmp},
+            /* values_num = */ 1);
   return (0);
 }
 
 static int za_read_gauge(kstat_t *ksp, const char *kstat_value,
                          const char *type, const char *type_instance) {
-  long long tmp;
-  value_t v;
-
-  tmp = get_zfs_value(ksp, (char *)kstat_value);
+  long long tmp = get_zfs_value(ksp, (char *)kstat_value);
   if (tmp == -1LL) {
     WARNING("zfs_arc plugin: Reading kstat value \"%s\" failed.", kstat_value);
     return (-1);
   }
 
-  v.gauge = (gauge_t)tmp;
-  za_submit(type, type_instance, /* values = */ &v, /* values_num = */ 1);
+  za_submit(type, type_instance, &(value_t){.gauge = (gauge_t)tmp},
+            /* values_num = */ 1);
   return (0);
 }
 
 static void za_submit_ratio(const char *type_instance, gauge_t hits,
                             gauge_t misses) {
   gauge_t ratio = NAN;
@@ -198,13 +188,12 @@
 
   za_submit_gauge("cache_ratio", type_instance, ratio);
 }
 
 static int za_read(void) {
   gauge_t arc_hits, arc_misses, l2_hits, l2_misses;
-  value_t l2_io[2];
   kstat_t *ksp = NULL;
 
 #if defined(KERNEL_LINUX)
   FILE *fh;
   char buffer[1024];
 
@@ -315,16 +304,17 @@
   l2_misses = (gauge_t)get_zfs_value(ksp, "l2_misses");
 
   za_submit_ratio("arc", arc_hits, arc_misses);
   za_submit_ratio("L2", l2_hits, l2_misses);
 
   /* I/O */
-  l2_io[0].derive = get_zfs_value(ksp, "l2_read_bytes");
-  l2_io[1].derive = get_zfs_value(ksp, "l2_write_bytes");
-
-  za_submit("io_octets", "L2", l2_io, /* num values = */ 2);
+  value_t l2_io[] = {
+      {.derive = (derive_t)get_zfs_value(ksp, "l2_read_bytes")},
+      {.derive = (derive_t)get_zfs_value(ksp, "l2_write_bytes")},
+  };
+  za_submit("io_octets", "L2", l2_io, STATIC_ARRAY_SIZE(l2_io));
 
 #if defined(KERNEL_LINUX)
   free_zfs_values(ksp);
 #endif
 
   return (0);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/zone.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/zone.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/zone.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/zone.c	2016-12-12 16:03:36.728278972 +0800
@@ -84,13 +84,12 @@
   value_t values[1];
 
   values[0].gauge = value;
 
   vl.values = values;
   vl.values_len = 1; /*STATIC_ARRAY_SIZE (values);*/
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "zone", sizeof(vl.plugin));
   sstrncpy(vl.type, "percent", sizeof(vl.type));
   sstrncpy(vl.type_instance, zone, sizeof(vl.type_instance));
 
   return (plugin_dispatch_values(&vl));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/zookeeper.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/zookeeper.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/src/zookeeper.c	2017-10-06 14:45:52.977917773 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/src/zookeeper.c	2016-12-12 16:03:36.728278972 +0800
@@ -54,39 +54,31 @@
     return -1;
   }
   return 0;
 }
 
 static void zookeeper_submit_gauge(const char *type, const char *type_inst,
-                                   gauge_t val) {
-  value_t values[1];
+                                   gauge_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].gauge = val;
-
-  vl.values = values;
+  vl.values = &(value_t){.gauge = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "zookeeper", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_inst != NULL)
     sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
 } /* zookeeper_submit_gauge */
 
 static void zookeeper_submit_derive(const char *type, const char *type_inst,
-                                    derive_t val) {
-  value_t values[1];
+                                    derive_t value) {
   value_list_t vl = VALUE_LIST_INIT;
 
-  values[0].derive = val;
-
-  vl.values = values;
+  vl.values = &(value_t){.derive = value};
   vl.values_len = 1;
-  sstrncpy(vl.host, hostname_g, sizeof(vl.host));
   sstrncpy(vl.plugin, "zookeeper", sizeof(vl.plugin));
   sstrncpy(vl.type, type, sizeof(vl.type));
   if (type_inst != NULL)
     sstrncpy(vl.type_instance, type_inst, sizeof(vl.type_instance));
 
   plugin_dispatch_values(&vl);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: TODO
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/version-gen.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/version-gen.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3/version-gen.sh	2017-10-06 14:53:18.666093677 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.7.0/version-gen.sh	2016-12-12 16:03:36.728278972 +0800
@@ -1,9 +1,9 @@
 #!/bin/sh
 
-DEFAULT_VERSION="5.6.3.git"
+DEFAULT_VERSION="5.7.0.git"
 
 if [ -d .git ]; then
 	VERSION="`git describe --dirty=+ --abbrev=7 2> /dev/null | grep collectd | sed -e 's/^collectd-//' -e 's/-/./g'`"
 fi
 
 if test -z "$VERSION"; then
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.6.3: ylwrap
