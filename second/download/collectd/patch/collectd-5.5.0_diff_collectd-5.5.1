diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/bindings/perl/lib/Collectd/Unixsock.pm /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/bindings/perl/lib/Collectd/Unixsock.pm
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/bindings/perl/lib/Collectd/Unixsock.pm	2015-03-10 22:14:45.813113801 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/bindings/perl/lib/Collectd/Unixsock.pm	2016-01-22 17:51:17.689918701 +0800
@@ -259,16 +259,17 @@
 	my $ret = {};
 
     my $msg = $self->_socket_command('GETTHRESHOLD', \%args) or return;
     $self->_socket_chat($msg, sub {
             local $_ = shift;
             my $ret = shift;
-		    /^\s*([^:]+):\s*(.*)/ and do {
-			    $1 =~ s/\s*$//;
-			    $ret->{$1} = $2;
-		    };
+            my ( $key, $val );
+            ( $key, $val ) = /^\s*([^:]+):\s*(.*)/ and do {
+                  $key =~ s/\s*$//;
+                  $ret->{$key} = $val;
+            };
         }, $ret
     );
 	return $ret;
 } # }}} sub getthreshold
 
 =item I<$self>-E<gt>B<putval> (I<%identifier>, B<time> =E<gt> I<$time>, B<values> =E<gt> [...]);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/ChangeLog /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/ChangeLog
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/ChangeLog	2015-05-27 15:48:54.623095614 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/ChangeLog	2016-01-22 17:51:17.685918703 +0800
@@ -1,6 +1,79 @@
+2016-01-22, Version 5.5.1
+	* Build system: Compilation errors have been avoided by correctly
+	  defining package name and version used by autoconf. Thanks to Nathan
+	  Berkley. #1063
+	* Build system: Dependency ordering was fixed to ensure parallel builds
+	  work reliably. Thanks to Gustavo Zacarias. #1125
+	* Build system: Error messages have been improved and building the unit
+	  tests has been fixed on Solaris. Thanks to Florian Forster and
+	  Dagobert Michelsen. #1077
+	* Build system: The move of the "utils_ignorelist" functions has been
+	  reverted. This fixes build issues of numerous plugins. Thanks to
+	  Benjamin Drung;. #1323
+	* Build system: The fhcount plugin has been restricted to Linux. Thanks
+	  to Ruben Kerkhof. #1195
+	* Build system: Detection of header files for the turbostat plugin has
+	  been fixed. Thanks to Marc Fournier. #1075
+	* collectd: The "LC_NUMERIC" locale is now forced, to prevent issues
+	  with some plugins on environments using a comma as decimal separator.
+	  Thanks to Florian Forster. #1237
+	* Documentation: Some precisions related to the virt plugin have beed
+	  added. Thanks to Wojtek Bocer and Ruben Kerkhof.
+	* Documentation: The CollectdInternalStats documentation has been
+	  improved. Thanks to Yves Mettier and Florian Forster.
+	* Battery plugin: A missing Type has been added. Thanks to Marc
+	  Fournier. #1338
+	* Bind plugin: An off-by-one error has been fixed: an index was checked
+	  against a wrong variable, which may lead to an out-of-bounds read.
+	  Thanks to Michal Humpula. #1123
+	* Ceph plugin: JSON parsing has been refactored to support ceph 10.0.0
+	  and fixes several buffer overflows. Thanks to Florian Forster. #1350
+	* CPU plugin: A Mac OS X specific bug has been fixed: the plugin
+	  expected an incorrect number of CPU states, resulting in failing read
+	  callbacks. This regression was introduced in 5.5.0. Thanks to Robert
+	  Viduya.
+	* Disk plugin: Support for Mac OS X 10.10 has been added. Thanks to
+	  Robert Viduya. #1065
+	* IPC plugin: Support for building with musl-libc has been added. Thanks
+	  to Natanael Copa. #1147
+	* Log Logstash plugin: A segfault when using libyajl, version 1 was
+	  fixed. Thanks to Vincent Bernat. #1190
+	* Log Logstash plugin: The timestamp is now ISO 8601 compliant. Thanks
+	  to Marc Fournier. #1132
+	* memcached plugin: The Type of the listen-disabled metric was fixed.
+	  Thanks to Florian Forster. #1356
+	* MySQL plugin: The Type used by Innodb_buffer_pool_pages_flushed was
+	  fixed. Thanks to Marek Becka. #1085
+	* OpenLDAP plugin: A crash when using LDAPI (LDAP-over-IPC) got fixed.
+	  Thanks to Marek Becka. #1080
+	* OpenLDAP plugin: Support for Mac OS X has been added. Thanks to Ruben
+	  Kerkhof. #1489
+	* SMART plugin: A memory leak has been fixed. Thanks to Florian
+	  Schüller and Pierre-Yves Ritschard. #1076
+	* Swap plugin: A regression that would lead to swap usage being reported
+	  in kilobytes (instead of bytes) has been fixed. Thanks to Marek Becka.
+	  #1071
+	* Varnish plugin: Support for FreeBSD has been added. Thanks to Ruben
+	  Kerkhof. #1182
+	* Varnish plugin: Support for versions 3 and 4 has been made more
+	  tolerant to minor changes in Varnish point releases. Thanks to Marc
+	  Fournier. #1302
+	* virt plugin: A copy-and-paste mistake in an error message has been
+	  fixed. Thanks to Ruben Kerkhof. #1101
+	* Write Kafka plugin: Support for Solaris has been added. Thanks to
+	  Shahul Hameed. #1171
+	* Write Redis plugin: Dead code has been removed. Thanks to Brian Kelly.
+	  #1143
+	* 27 patches have been applied to numerous plugins and core components,
+	  fixing various programming errors which were reported by scan-build,
+	  libasan, FBInfer, coverity-scan and clang: Thanks to Ruben Kerkhof,
+	  Florian Forster and Marek Becka.
+	* Collectd::Unixsock: A Perl error got corrected. Thanks to Ciaran Mac
+	  An Iomaire. #1295
+
 2015-05-27, Version 5.5.0
 	* Build system: Ability to make out-of-tree builds has been fixed.
 	  Thanks to Vincent Bernat. #792
 	* Build system, Disk and Users plugins: Detection and use of libstatgrab
 	  ≧ 0.90 has been added. Thanks to Vincent Bernat. #445, #795, #806,
 	  #807, #908
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/configure	2015-05-27 15:51:50.237943000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/configure	2016-01-22 17:55:47.281693173 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for collectd 5.5.0.
+# Generated by GNU Autoconf 2.69 for collectd 5.5.1.
 #
 #
 # Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -588,18 +588,19 @@
 MFLAGS=
 MAKEFLAGS=
 
 # Identity of this package.
 PACKAGE_NAME='collectd'
 PACKAGE_TARNAME='collectd'
-PACKAGE_VERSION='5.5.0'
-PACKAGE_STRING='collectd 5.5.0'
+PACKAGE_VERSION='5.5.1'
+PACKAGE_STRING='collectd 5.5.1'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
 ac_unique_file="src/"
+: "${ARFLAGS=cr} ${AR_FLAGS=cr}"
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #ifdef HAVE_SYS_TYPES_H
 # include <sys/types.h>
 #endif
@@ -1200,12 +1201,14 @@
 PACKAGE
 CYGPATH_W
 am__isrc
 INSTALL_DATA
 INSTALL_SCRIPT
 INSTALL_PROGRAM
+BUILD_INCLUDED_LTDL_FALSE
+BUILD_INCLUDED_LTDL_TRUE
 LTDLOPEN
 LT_CONFIG_H
 subdirs
 CONVENIENCE_LTDL_FALSE
 CONVENIENCE_LTDL_TRUE
 INSTALL_LTDL_FALSE
@@ -2061,13 +2064,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures collectd 5.5.0 to adapt to many kinds of systems.
+\`configure' configures collectd 5.5.1 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -2131,13 +2134,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of collectd 5.5.0:";;
+     short | recursive ) echo "Configuration of collectd 5.5.1:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
@@ -2491,13 +2494,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-collectd configure 5.5.0
+collectd configure 5.5.1
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -3067,13 +3070,13 @@
 
 } # ac_fn_c_check_member
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by collectd $as_me 5.5.0, which was
+It was created by collectd $as_me 5.5.1, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 exec 5>>config.log
@@ -13023,12 +13028,21 @@
 
 $as_echo "#define LIBTOOL_VERSION 2" >>confdefs.h
 
 
 
 
+ if test "x$LTDLDEPS" != "x"; then
+  BUILD_INCLUDED_LTDL_TRUE=
+  BUILD_INCLUDED_LTDL_FALSE='#'
+else
+  BUILD_INCLUDED_LTDL_TRUE='#'
+  BUILD_INCLUDED_LTDL_FALSE=
+fi
+
+
 am__api_version='1.14'
 
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
 # incompatible versions:
 # SysV /etc/install, /usr/sbin/install
@@ -13527,13 +13541,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='collectd'
- VERSION='5.5.0'
+ VERSION='5.5.1'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -15104,12 +15118,16 @@
 
   test -n "$YACC" && break
 done
 test -n "$YACC" || YACC="yacc"
 
 
+# Warn when pkg.m4 is missing
+
+
+
 
 
 
 
 
 
@@ -15262,29 +15280,80 @@
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
-for ac_header in google/protobuf-c/protobuf-c.h
+if test "x$have_protoc_c" = "xno"
+then
+	have_protoc_c="no (protoc-c compiler not found)"
+fi
+
+if test "x$have_protoc_c" = "xyes"
+then
+	for ac_header in protobuf-c/protobuf-c.h google/protobuf-c/protobuf-c.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "google/protobuf-c/protobuf-c.h" "ac_cv_header_google_protobuf_c_protobuf_c_h" "$ac_includes_default"
-if test "x$ac_cv_header_google_protobuf_c_protobuf_c_h" = xyes; then :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
-#define HAVE_GOOGLE_PROTOBUF_C_PROTOBUF_C_H 1
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
- have_protobuf_c_h="yes"
+ have_protoc_c="yes"; break
 else
-  have_protobuf_c_h="no"
+  have_protoc_c="no (<google/protobuf-c/protobuf-c.h> not found)"
 fi
 
 done
 
-if test "x$have_protoc_c" = "xyes" && test "x$have_protobuf_c_h" != "xyes"
+fi
+if test "x$have_protoc_c" = "xyes"
 then
-	have_protoc_c="no (unable to find <google/protobuf-c/protobuf-c.h>)"
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for protobuf_c_message_pack in -lprotobuf-c" >&5
+$as_echo_n "checking for protobuf_c_message_pack in -lprotobuf-c... " >&6; }
+if ${ac_cv_lib_protobuf_c_protobuf_c_message_pack+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lprotobuf-c  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char protobuf_c_message_pack ();
+int
+main ()
+{
+return protobuf_c_message_pack ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_protobuf_c_protobuf_c_message_pack=yes
+else
+  ac_cv_lib_protobuf_c_protobuf_c_message_pack=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_protobuf_c_protobuf_c_message_pack" >&5
+$as_echo "$ac_cv_lib_protobuf_c_protobuf_c_message_pack" >&6; }
+if test "x$ac_cv_lib_protobuf_c_protobuf_c_message_pack" = xyes; then :
+  have_protoc_c="yes"
+else
+  have_protoc_c="no (libprotobuf-c not found)"
+fi
+
+
 fi
  if test "x$have_protoc_c" = "xyes"; then
   HAVE_PROTOC_C_TRUE=
   HAVE_PROTOC_C_FALSE='#'
 else
   HAVE_PROTOC_C_TRUE='#'
@@ -15334,53 +15403,53 @@
 	*)
 	ac_system="unknown"
 esac
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_system" >&5
 $as_echo "$ac_system" >&6; }
 
- if test "x$x$ac_system" = "xLinux"; then
+ if test "x$ac_system" = "xLinux"; then
   BUILD_LINUX_TRUE=
   BUILD_LINUX_FALSE='#'
 else
   BUILD_LINUX_TRUE='#'
   BUILD_LINUX_FALSE=
 fi
 
- if test "x$x$ac_system" = "xSolaris"; then
+ if test "x$ac_system" = "xSolaris"; then
   BUILD_SOLARIS_TRUE=
   BUILD_SOLARIS_FALSE='#'
 else
   BUILD_SOLARIS_TRUE='#'
   BUILD_SOLARIS_FALSE=
 fi
 
- if test "x$x$ac_system" = "xDarwin"; then
+ if test "x$ac_system" = "xDarwin"; then
   BUILD_DARWIN_TRUE=
   BUILD_DARWIN_FALSE='#'
 else
   BUILD_DARWIN_TRUE='#'
   BUILD_DARWIN_FALSE=
 fi
 
- if test "x$x$ac_system" = "xOpenBSD"; then
+ if test "x$ac_system" = "xOpenBSD"; then
   BUILD_OPENBSD_TRUE=
   BUILD_OPENBSD_FALSE='#'
 else
   BUILD_OPENBSD_TRUE='#'
   BUILD_OPENBSD_FALSE=
 fi
 
- if test "x$x$ac_system" = "xAIX"; then
+ if test "x$ac_system" = "xAIX"; then
   BUILD_AIX_TRUE=
   BUILD_AIX_FALSE='#'
 else
   BUILD_AIX_TRUE='#'
   BUILD_AIX_FALSE=
 fi
 
- if test "x$x$ac_system" = "xFreeBSD"; then
+ if test "x$ac_system" = "xFreeBSD"; then
   BUILD_FREEBSD_TRUE=
   BUILD_FREEBSD_FALSE='#'
 else
   BUILD_FREEBSD_TRUE='#'
   BUILD_FREEBSD_FALSE=
 fi
@@ -15403,13 +15472,44 @@
 
 $as_echo "#define _POSIX_PTHREAD_SEMANTICS 1" >>confdefs.h
 
 
 $as_echo "#define _REENTRANT 1" >>confdefs.h
 
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler builds 64bit binaries" >&5
+$as_echo_n "checking whether compiler builds 64bit binaries... " >&6; }
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+			   #ifndef _LP64
+			   # error "Compiler not in 64bit mode."
+			   #endif
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+
+			    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+			    { $as_echo "$as_me:${as_lineno-$LINENO}: Solaris detected. Please consider building a 64-bit binary." >&5
+$as_echo "$as_me: Solaris detected. Please consider building a 64-bit binary." >&6;}
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
+
 if test "x$ac_system" = "xAIX"
 then
 
 $as_echo "#define _THREAD_SAFE_ERRNO 1" >>confdefs.h
 
 fi
@@ -16106,12 +16206,80 @@
 
 fi
 
 done
 
 
+have_ip6_ext="no"
+ac_fn_c_check_type "$LINENO" "struct ip6_ext" "ac_cv_type_struct_ip6_ext" "#if HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_SYSTM_H
+# include <netinet/in_systm.h>
+#endif
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP6_H
+# include <netinet/ip6.h>
+#endif
+
+"
+if test "x$ac_cv_type_struct_ip6_ext" = xyes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STRUCT_IP6_EXT 1
+_ACEOF
+
+have_ip6_ext="yes"
+else
+  have_ip6_ext="no"
+fi
+
+
+if test "x$have_ip6_ext" = "xno"; then
+	SAVE_CFLAGS="$CFLAGS"
+	CFLAGS="$CFLAGS -DSOLARIS2=8"
+
+	ac_fn_c_check_type "$LINENO" "struct ip6_ext" "ac_cv_type_struct_ip6_ext" "#if HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_SYSTM_H
+# include <netinet/in_systm.h>
+#endif
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP6_H
+# include <netinet/ip6.h>
+#endif
+
+"
+if test "x$ac_cv_type_struct_ip6_ext" = xyes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STRUCT_IP6_EXT 1
+_ACEOF
+
+have_ip6_ext="yes, with -DSOLARIS2=8"
+else
+  have_ip6_ext="no"
+fi
+
+
+	if test "x$have_ip6_ext" = "xno"; then
+		CFLAGS="$SAVE_CFLAGS"
+	fi
+fi
+
 # For cpu modules
 for ac_header in sys/dkstat.h
 do :
   ac_fn_c_check_header_mongrel "$LINENO" "sys/dkstat.h" "ac_cv_header_sys_dkstat_h" "$ac_includes_default"
 if test "x$ac_cv_header_sys_dkstat_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
@@ -16306,25 +16474,12 @@
   have_sys_swap_h="no"
 fi
 
 done
 
 
-if test "x$have_sys_swap_h$ac_system" = "xnoSolaris"
-then
-	hint_64=""
-	if test "x$GCC" = "xyes"
-	then
-		hint_64="CFLAGS='-m64'"
-	else
-		hint_64="CFLAGS='-xarch=v9'"
-	fi
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: Solaris detected and sys/swap.h not usable. Try building a 64-bit binary ($hint_64 ./configure)." >&5
-$as_echo "$as_me: Solaris detected and sys/swap.h not usable. Try building a 64-bit binary ($hint_64 ./configure)." >&6;}
-fi
-
 # For load module
 # For the processes plugin
 # For users module
 for ac_header in sys/loadavg.h linux/config.h utmp.h utmpx.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
@@ -16798,12 +16953,15 @@
 #if HAVE_SYS_SOCKET_H
 # include <sys/socket.h>
 #endif
 #if HAVE_NET_IF_H
 # include <net/if.h>
 #endif
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
 
 "
 if test "x$ac_cv_header_net_pfvar_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
 #define HAVE_NET_PFVAR_H 1
 _ACEOF
@@ -16844,27 +17002,27 @@
 
 done
 
 
 if test "x$have_asm_msrindex_h" = "xyes"
 then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether asm/msr-index.h has MSR_CORE_C3_RESIDENCY" >&5
-$as_echo_n "checking whether asm/msr-index.h has MSR_CORE_C3_RESIDENCY... " >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether asm/msr-index.h has MSR_PKG_C10_RESIDENCY" >&5
+$as_echo_n "checking whether asm/msr-index.h has MSR_PKG_C10_RESIDENCY... " >&6; }
 if ${c_cv_have_usable_asm_msrindex_h+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 #include<asm/msr-index.h>
 
 int
 main ()
 {
 
-int y = MSR_CORE_C3_RESIDENCY;
+int y = MSR_PKG_C10_RESIDENCY;
 return(y);
 
 
   ;
   return 0;
 }
@@ -18607,12 +18765,24 @@
 #define HAVE_LISTMNTENT 1
 _ACEOF
  have_listmntent="yes"
 fi
 done
 
+have_getmntent_r="no"
+for ac_func in getmntent_r
+do :
+  ac_fn_c_check_func "$LINENO" "getmntent_r" "ac_cv_func_getmntent_r"
+if test "x$ac_cv_func_getmntent_r" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GETMNTENT_R 1
+_ACEOF
+ have_getmntent_r="yes"
+fi
+done
+
 
 have_getmntent="no"
 for ac_func in getmntent
 do :
   ac_fn_c_check_func "$LINENO" "getmntent" "ac_cv_func_getmntent"
 if test "x$ac_cv_func_getmntent" = xyes; then :
@@ -20623,39 +20793,42 @@
  else if test -d "$withval"
  then
 	 GANGLIA_CPPFLAGS="-I$withval/include"
 	 GANGLIA_LDFLAGS="-L$withval/lib"
 	 with_libganglia="yes"
  else
-	 with_libganglia_config="ganglia-config"
 	 with_libganglia="$withval"
  fi; fi; fi
 
 else
 
- with_libganglia_config="ganglia-config"
  with_libganglia="yes"
 
 fi
 
 
-if test "x$with_libganglia" = "xyes" && test "x$with_libganglia_config" != "x"
+if test "x$with_libganglia" = "xyes"
 then
-	if test "x$GANGLIA_CPPFLAGS" = "x"
+	if test "x$with_libganglia_config" != "x"
 	then
-		GANGLIA_CPPFLAGS=`"$with_libganglia_config" --cflags 2>/dev/null`
-	fi
+		if test "x$GANGLIA_CPPFLAGS" = "x"
+		then
+			GANGLIA_CPPFLAGS=`"$with_libganglia_config" --cflags 2>/dev/null`
+		fi
 
-	if test "x$GANGLIA_LDFLAGS" = "x"
-	then
-		GANGLIA_LDFLAGS=`"$with_libganglia_config" --ldflags 2>/dev/null`
-	fi
+		if test "x$GANGLIA_LDFLAGS" = "x"
+		then
+			GANGLIA_LDFLAGS=`"$with_libganglia_config" --ldflags 2>/dev/null`
+		fi
 
-	if test "x$GANGLIA_LIBS" = "x"
-	then
-		GANGLIA_LIBS=`"$with_libganglia_config" --libs 2>/dev/null`
+		if test "x$GANGLIA_LIBS" = "x"
+		then
+			GANGLIA_LIBS=`"$with_libganglia_config" --libs 2>/dev/null`
+		fi
+	else
+		GANGLIA_LIBS="-lganglia"
 	fi
 fi
 
 SAVE_CPPFLAGS="$CPPFLAGS"
 SAVE_LDFLAGS="$LDFLAGS"
 CPPFLAGS="$CPPFLAGS $GANGLIA_CPPFLAGS"
@@ -20787,28 +20960,24 @@
 then
 	if test "x$GCRYPT_CPPFLAGS" = "x"
 	then
 		GCRYPT_CPPFLAGS=`"$with_libgcrypt_config" --cflags 2>/dev/null`
 	fi
 
-	if test "x$GCRYPT_LDFLAGS" = "x"
-	then
-		gcrypt_exec_prefix=`"$with_libgcrypt_config" --exec-prefix 2>/dev/null`
-		GCRYPT_LDFLAGS="-L$gcrypt_exec_prefix/lib"
-	fi
-
 	if test "x$GCRYPT_LIBS" = "x"
 	then
 		GCRYPT_LIBS=`"$with_libgcrypt_config" --libs 2>/dev/null`
 	fi
 fi
 
 SAVE_CPPFLAGS="$CPPFLAGS"
 SAVE_LDFLAGS="$LDFLAGS"
+SAVE_LIBS="$LIBS"
 CPPFLAGS="$CPPFLAGS $GCRYPT_CPPFLAGS"
 LDFLAGS="$LDFLAGS $GCRYPT_LDFLAGS"
+LIBS="$LIBS $GCRYPT_LIBS"
 
 if test "x$with_libgcrypt" = "xyes"
 then
 	if test "x$GCRYPT_CPPFLAGS" != "x"
 	then
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: gcrypt CPPFLAGS: $GCRYPT_CPPFLAGS" >&5
@@ -20829,17 +20998,12 @@
 done
 
 fi
 
 if test "x$with_libgcrypt" = "xyes"
 then
-	if test "x$GCRYPT_LDFLAGS" != "x"
-	then
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: gcrypt LDFLAGS: $GCRYPT_LDFLAGS" >&5
-$as_echo "$as_me: gcrypt LDFLAGS: $GCRYPT_LDFLAGS" >&6;}
-	fi
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gcry_md_hash_buffer in -lgcrypt" >&5
 $as_echo_n "checking for gcry_md_hash_buffer in -lgcrypt... " >&6; }
 if ${ac_cv_lib_gcrypt_gcry_md_hash_buffer+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -21100,12 +21264,13 @@
 		GCRYPT_LIBS="$LIBGCRYPT_LIBS"
 	fi
 fi
 
 CPPFLAGS="$SAVE_CPPFLAGS"
 LDFLAGS="$SAVE_LDFLAGS"
+LIBS="$SAVE_LIBS"
 
 if test "x$with_libgcrypt" = "xyes"
 then
 
 $as_echo "#define HAVE_LIBGCRYPT 1" >>confdefs.h
 
@@ -21375,13 +21540,13 @@
 			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
 $as_echo "not found" >&6; }
 		fi
 
 		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for libjvm.so" >&5
 $as_echo_n "checking for libjvm.so... " >&6; }
-		TMPVAR=`find -L "$with_java_home" -name libjvm.so -type f -exec 'dirname' '{}' ';' 2>/dev/null | head -n 1`
+		TMPVAR=`find -L "$with_java_home" -type f \( -name libjvm.so -o -name libjvm.dylib \) -exec 'dirname' '{}' ';' 2>/dev/null | head -n 1`
 		if test "x$TMPVAR" != "x"
 		then
 			{ $as_echo "$as_me:${as_lineno-$LINENO}: result: found in $TMPVAR" >&5
 $as_echo "found in $TMPVAR" >&6; }
 			JAVA_LDFLAGS="$JAVA_LDFLAGS -L$TMPVAR -Wl,-rpath -Wl,$TMPVAR"
 		else
@@ -22079,22 +22244,22 @@
 # the actual checks.
 if test "x$with_libmodbus" = "xyes"
 then
 	SAVE_CPPFLAGS="$CPPFLAGS"
 	CPPFLAGS="$CPPFLAGS $with_libmodbus_cflags"
 
-	for ac_header in modbus/modbus.h
+	for ac_header in modbus.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "modbus/modbus.h" "ac_cv_header_modbus_modbus_h" "$ac_includes_default"
-if test "x$ac_cv_header_modbus_modbus_h" = xyes; then :
+  ac_fn_c_check_header_mongrel "$LINENO" "modbus.h" "ac_cv_header_modbus_h" "$ac_includes_default"
+if test "x$ac_cv_header_modbus_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define HAVE_MODBUS_MODBUS_H 1
+#define HAVE_MODBUS_H 1
 _ACEOF
 
 else
-  with_libmodbus="no (modbus/modbus.h not found)"
+  with_libmodbus="no (modbus.h not found)"
 fi
 
 done
 
 
 	CPPFLAGS="$SAVE_CPPFLAGS"
@@ -22319,13 +22484,13 @@
 	with_libmysql="yes"
 
 fi
 
 if test "x$with_libmysql" = "xyes"
 then
-	with_mysql_cflags=`$with_mysql_config --cflags 2>/dev/null`
+	with_mysql_cflags=`$with_mysql_config --include 2>/dev/null`
 	mysql_config_status=$?
 
 	if test $mysql_config_status -ne 0
 	then
 		with_libmysql="no ($with_mysql_config failed)"
 	else
@@ -22377,97 +22542,76 @@
 	mysql_config_status=$?
 
 	if test $mysql_config_status -ne 0
 	then
 		with_libmysql="no ($with_mysql_config failed)"
 	else
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for mysql_init in -lmysqlclient" >&5
-$as_echo_n "checking for mysql_init in -lmysqlclient... " >&6; }
-if ${ac_cv_lib_mysqlclient_mysql_init+:} false; then :
+		SAVE_CPPFLAGS="$CPPFLAGS"
+		CPPFLAGS="$CPPFLAGS $with_mysql_cflags"
+		SAVE_LIBS="$LIBS"
+		LIBS="$with_mysql_libs"
+		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing mysql_get_server_version" >&5
+$as_echo_n "checking for library containing mysql_get_server_version... " >&6; }
+if ${ac_cv_search_mysql_get_server_version+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lmysqlclient $with_mysql_libs $LIBS"
+  ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
 #ifdef __cplusplus
 extern "C"
 #endif
-char mysql_init ();
+char mysql_get_server_version ();
 int
 main ()
 {
-return mysql_init ();
+return mysql_get_server_version ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_mysqlclient_mysql_init=yes
-else
-  ac_cv_lib_mysqlclient_mysql_init=no
+for ac_lib in '' ; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_mysql_get_server_version=$ac_res
 fi
 rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_mysqlclient_mysql_init" >&5
-$as_echo "$ac_cv_lib_mysqlclient_mysql_init" >&6; }
-if test "x$ac_cv_lib_mysqlclient_mysql_init" = xyes; then :
-  with_libmysql="yes"
-else
-  with_libmysql="no (symbol 'mysql_init' not found)"
+    conftest$ac_exeext
+  if ${ac_cv_search_mysql_get_server_version+:} false; then :
+  break
 fi
+done
+if ${ac_cv_search_mysql_get_server_version+:} false; then :
 
-
-		{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for mysql_get_server_version in -lmysqlclient" >&5
-$as_echo_n "checking for mysql_get_server_version in -lmysqlclient... " >&6; }
-if ${ac_cv_lib_mysqlclient_mysql_get_server_version+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lmysqlclient $with_mysql_libs $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char mysql_get_server_version ();
-int
-main ()
-{
-return mysql_get_server_version ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_mysqlclient_mysql_get_server_version=yes
 else
-  ac_cv_lib_mysqlclient_mysql_get_server_version=no
+  ac_cv_search_mysql_get_server_version=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_mysqlclient_mysql_get_server_version" >&5
-$as_echo "$ac_cv_lib_mysqlclient_mysql_get_server_version" >&6; }
-if test "x$ac_cv_lib_mysqlclient_mysql_get_server_version" = xyes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_mysql_get_server_version" >&5
+$as_echo "$ac_cv_search_mysql_get_server_version" >&6; }
+ac_res=$ac_cv_search_mysql_get_server_version
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
   with_libmysql="yes"
 else
   with_libmysql="no (symbol 'mysql_get_server_version' not found)"
 fi
 
+		CPPFLAGS="$SAVE_CPPFLAGS"
+		LIBS="$SAVE_LIBS"
 	fi
 fi
 if test "x$with_libmysql" = "xyes"
 then
 	BUILD_WITH_LIBMYSQL_CFLAGS="$with_mysql_cflags"
 	BUILD_WITH_LIBMYSQL_LIBS="$with_mysql_libs"
@@ -23485,29 +23629,12 @@
 
 done
 
 fi
 if test "x$with_libpcap" = "xyes"
 then
-	for ac_header in pcap-bpf.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "pcap-bpf.h" "ac_cv_header_pcap_bpf_h" "$ac_includes_default"
-if test "x$ac_cv_header_pcap_bpf_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_PCAP_BPF_H 1
-_ACEOF
-
-else
-  with_libpcap="no (pcap-bpf.h not found)"
-fi
-
-done
-
-fi
-if test "x$with_libpcap" = "xyes"
-then
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether libpcap has PCAP_ERROR_IFACE_NOT_UP" >&5
 $as_echo_n "checking whether libpcap has PCAP_ERROR_IFACE_NOT_UP... " >&6; }
 if ${c_cv_libpcap_have_pcap_error_iface_not_up+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -26848,40 +26975,40 @@
 if test "x$with_libvarnish" = "xyes"
 then
 	SAVE_CPPFLAGS="$CPPFLAGS"
 
 	CPPFLAGS="$CPPFLAGS $with_libvarnish_cflags"
 
-	for ac_header in varnish/vapi/vsc.h
+	for ac_header in vapi/vsc.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "varnish/vapi/vsc.h" "ac_cv_header_varnish_vapi_vsc_h" "$ac_includes_default"
-if test "x$ac_cv_header_varnish_vapi_vsc_h" = xyes; then :
+  ac_fn_c_check_header_mongrel "$LINENO" "vapi/vsc.h" "ac_cv_header_vapi_vsc_h" "$ac_includes_default"
+if test "x$ac_cv_header_vapi_vsc_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define HAVE_VARNISH_VAPI_VSC_H 1
+#define HAVE_VAPI_VSC_H 1
 _ACEOF
 
 $as_echo "#define HAVE_VARNISH_V4 1" >>confdefs.h
 
 else
-  for ac_header in varnish/vsc.h
+  for ac_header in vsc.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "varnish/vsc.h" "ac_cv_header_varnish_vsc_h" "$ac_includes_default"
-if test "x$ac_cv_header_varnish_vsc_h" = xyes; then :
+  ac_fn_c_check_header_mongrel "$LINENO" "vsc.h" "ac_cv_header_vsc_h" "$ac_includes_default"
+if test "x$ac_cv_header_vsc_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define HAVE_VARNISH_VSC_H 1
+#define HAVE_VSC_H 1
 _ACEOF
 
 $as_echo "#define HAVE_VARNISH_V3 1" >>confdefs.h
 
 else
-  for ac_header in varnish/varnishapi.h
+  for ac_header in varnishapi.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "varnish/varnishapi.h" "ac_cv_header_varnish_varnishapi_h" "$ac_includes_default"
-if test "x$ac_cv_header_varnish_varnishapi_h" = xyes; then :
+  ac_fn_c_check_header_mongrel "$LINENO" "varnishapi.h" "ac_cv_header_varnishapi_h" "$ac_includes_default"
+if test "x$ac_cv_header_varnishapi_h" = xyes; then :
   cat >>confdefs.h <<_ACEOF
-#define HAVE_VARNISH_VARNISHAPI_H 1
+#define HAVE_VARNISHAPI_H 1
 _ACEOF
 
 $as_echo "#define HAVE_VARNISH_V2 1" >>confdefs.h
 
 else
   with_libvarnish="no (found none of the varnish header files)"
@@ -27567,12 +27694,13 @@
 plugin_curl_xml="no"
 plugin_df="no"
 plugin_disk="no"
 plugin_drbd="no"
 plugin_entropy="no"
 plugin_ethstat="no"
+plugin_fhcount="no"
 plugin_fscache="no"
 plugin_interface="no"
 plugin_ipmi="no"
 plugin_ipvs="no"
 plugin_irq="no"
 plugin_load="no"
@@ -27609,12 +27737,13 @@
 	plugin_cgroups="yes"
 	plugin_cpu="yes"
 	plugin_cpufreq="yes"
 	plugin_disk="yes"
 	plugin_drbd="yes"
 	plugin_entropy="yes"
+	plugin_fhcount="yes"
 	plugin_fscache="yes"
 	plugin_interface="yes"
 	plugin_ipc="yes"
 	plugin_irq="yes"
 	plugin_load="yes"
 	plugin_lvm="yes"
@@ -27808,12 +27937,17 @@
 #fi
 if test "x$c_cv_have_one_getmntent" = "xyes"
 then
 	plugin_df="yes"
 fi
 
+if test "x$c_cv_have_getmntent_r" = "xyes"
+then
+	plugin_df="yes"
+fi
+
 # Df plugin: Check if we have either `statfs' or `statvfs' second.
 if test "x$plugin_df" = "xyes"
 then
 	plugin_df="no"
 	if test "x$have_statfs" = "xyes"
 	then
@@ -29690,13 +29824,13 @@
      fi; fi
 
 else
 
 	 if test "x$enable_all_plugins" = "xauto"
 	 then
-	     if test "xyes" = "xyes"
+	     if test "x$plugin_fhcount" = "xyes"
 	     then
 		     enable_plugin="yes"
 	     else
 		     enable_plugin="no"
 	     fi
 	 else
@@ -29704,18 +29838,18 @@
 	 fi
 
 fi
 
     if test "x$enable_plugin" = "xyes"
     then
-	    if test "xyes" = "xyes" || test "x$force" = "xyes"
+	    if test "x$plugin_fhcount" = "xyes" || test "x$force" = "xyes"
 	    then
 
 $as_echo "#define HAVE_PLUGIN_FHCOUNT 1" >>confdefs.h
 
-		    if test "xyes" != "xyes"
+		    if test "x$plugin_fhcount" != "xyes"
 		    then
 			    dependency_warning="yes"
 		    fi
 	    else # User passed "yes" but dependency checking yielded "no" => Dependency problem.
 		    dependency_error="yes"
 		    enable_plugin="no (dependency error)"
@@ -36262,12 +36396,16 @@
     fi
     ltdl_LIBOBJS=$_ltdl_libobjs
 
     ltdl_LTLIBOBJS=$_ltdl_ltlibobjs
 
 
+if test -z "${BUILD_INCLUDED_LTDL_TRUE}" && test -z "${BUILD_INCLUDED_LTDL_FALSE}"; then
+  as_fn_error $? "conditional \"BUILD_INCLUDED_LTDL\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
 $as_echo_n "checking that generated files are newer than configure... " >&6; }
    if test -n "$am_sleep_pid"; then
      # Hide warnings about reused PIDs.
      wait $am_sleep_pid 2>/dev/null
    fi
@@ -37459,13 +37597,13 @@
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # Save the log message, to keep $0 and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by collectd $as_me 5.5.0, which was
+This file was extended by collectd $as_me 5.5.1, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -37525,13 +37663,13 @@
 Report bugs to the package provider."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-collectd config.status 5.5.0
+collectd config.status 5.5.1
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
 Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/configure.ac	2015-05-27 15:51:35.609705819 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/configure.ac	2016-01-22 17:51:17.689918701 +0800
@@ -1,12 +1,17 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_INIT([collectd],[m4_esyscmd(./version-gen.sh)])
 AC_CONFIG_SRCDIR(src/)
 AC_CONFIG_HEADERS(src/config.h)
 AC_CONFIG_AUX_DIR([libltdl/config])
 
+dnl older automake's default of ARFLAGS=cru is noisy on newer binutils;
+dnl we don't really need the 'u' even in older toolchains.  Then there is
+dnl older libtool, which spelled it AR_FLAGS
+m4_divert_text([DEFAULTS], [: "${ARFLAGS=cr} ${AR_FLAGS=cr}"])
+
 m4_ifdef([LT_PACKAGE_VERSION],
 	# libtool >= 2.2
 	[
 	 LT_CONFIG_LTDL_DIR([libltdl])
 	 LT_INIT([dlopen])
 	 LTDL_INIT([convenience])
@@ -21,12 +26,14 @@
 	 AC_LIBTOOL_DLOPEN
 	 AC_CONFIG_SUBDIRS(libltdl)
 	 AC_DEFINE(LIBTOOL_VERSION, 1, [Define to used libtool version.])
 	]
 )
 
+AM_CONDITIONAL([BUILD_INCLUDED_LTDL], [test "x$LTDLDEPS" != "x"])
+
 AM_INIT_AUTOMAKE([tar-pax dist-bzip2 foreign])
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
 AC_LANG(C)
 
 AC_PREFIX_DEFAULT("/opt/collectd")
 
@@ -44,21 +51,36 @@
 AM_CONDITIONAL(COMPILER_IS_GCC, test "x$GCC" = "xyes")
 
 AC_DISABLE_STATIC
 AC_PROG_LIBTOOL
 AC_PROG_LEX
 AC_PROG_YACC
+
+# Warn when pkg.m4 is missing
+m4_pattern_forbid([^_?PKG_[A-Z_]+$],[*** pkg.m4 missing, please install pkg-config])
+
 PKG_PROG_PKG_CONFIG
 
 AC_CHECK_PROG([have_protoc_c], [protoc-c], [yes], [no])
-AC_CHECK_HEADERS([google/protobuf-c/protobuf-c.h],
-                 [have_protobuf_c_h="yes"],
-                 [have_protobuf_c_h="no"])
-if test "x$have_protoc_c" = "xyes" && test "x$have_protobuf_c_h" != "xyes"
+if test "x$have_protoc_c" = "xno"
+then
+	have_protoc_c="no (protoc-c compiler not found)"
+fi
+
+if test "x$have_protoc_c" = "xyes"
+then
+	AC_CHECK_HEADERS([protobuf-c/protobuf-c.h google/protobuf-c/protobuf-c.h],
+			 [have_protoc_c="yes"; break],
+			 [have_protoc_c="no (<google/protobuf-c/protobuf-c.h> not found)"])
+fi
+if test "x$have_protoc_c" = "xyes"
 then
-	have_protoc_c="no (unable to find <google/protobuf-c/protobuf-c.h>)"
+	AC_CHECK_LIB([protobuf-c], [protobuf_c_message_pack],
+		     [have_protoc_c="yes"],
+		     [have_protoc_c="no (libprotobuf-c not found)"])
+
 fi
 AM_CONDITIONAL(HAVE_PROTOC_C, test "x$have_protoc_c" = "xyes")
 
 AC_MSG_CHECKING([for kernel type ($host_os)])
 case $host_os in
 	*linux*)
@@ -87,18 +109,18 @@
 	;;
 	*)
 	ac_system="unknown"
 esac
 AC_MSG_RESULT([$ac_system])
 
-AM_CONDITIONAL([BUILD_LINUX],[test "x$x$ac_system" = "xLinux"])
-AM_CONDITIONAL([BUILD_SOLARIS],[test "x$x$ac_system" = "xSolaris"])
-AM_CONDITIONAL([BUILD_DARWIN],[test "x$x$ac_system" = "xDarwin"])
-AM_CONDITIONAL([BUILD_OPENBSD],[test "x$x$ac_system" = "xOpenBSD"])
-AM_CONDITIONAL([BUILD_AIX],[test "x$x$ac_system" = "xAIX"])
-AM_CONDITIONAL([BUILD_FREEBSD],[test "x$x$ac_system" = "xFreeBSD"])
+AM_CONDITIONAL([BUILD_LINUX],[test "x$ac_system" = "xLinux"])
+AM_CONDITIONAL([BUILD_SOLARIS],[test "x$ac_system" = "xSolaris"])
+AM_CONDITIONAL([BUILD_DARWIN],[test "x$ac_system" = "xDarwin"])
+AM_CONDITIONAL([BUILD_OPENBSD],[test "x$ac_system" = "xOpenBSD"])
+AM_CONDITIONAL([BUILD_AIX],[test "x$ac_system" = "xAIX"])
+AM_CONDITIONAL([BUILD_FREEBSD],[test "x$ac_system" = "xFreeBSD"])
 
 if test "x$ac_system" = "xLinux"
 then
 	AC_ARG_VAR([KERNEL_DIR], [path to Linux kernel sources])
 	if test -z "$KERNEL_DIR"
 	then
@@ -110,13 +132,26 @@
 fi
 
 if test "x$ac_system" = "xSolaris"
 then
 	AC_DEFINE(_POSIX_PTHREAD_SEMANTICS, 1, [Define to enforce POSIX thread semantics under Solaris.])
 	AC_DEFINE(_REENTRANT,               1, [Define to enable reentrancy interfaces.])
+
+	AC_MSG_CHECKING([whether compiler builds 64bit binaries])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
+			   #ifndef _LP64
+			   # error "Compiler not in 64bit mode."
+			   #endif
+			   ])],
+			   [AC_MSG_RESULT([yes])],
+			   [
+			    AC_MSG_RESULT([no])
+			    AC_MSG_NOTICE([Solaris detected. Please consider building a 64-bit binary.])
+			   ])
 fi
+
 if test "x$ac_system" = "xAIX"
 then
 	AC_DEFINE(_THREAD_SAFE_ERRNO, 1, [Define to use the thread-safe version of errno under AIX.])
 fi
 
 # Where to install .pc files.
@@ -282,12 +317,60 @@
 #endif
 #if HAVE_NETINET_IP_H
 # include <netinet/ip.h>
 #endif
 ])
 
+have_ip6_ext="no"
+AC_CHECK_TYPES([struct ip6_ext], [have_ip6_ext="yes"], [have_ip6_ext="no"],
+[#if HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_SYSTM_H
+# include <netinet/in_systm.h>
+#endif
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP6_H
+# include <netinet/ip6.h>
+#endif
+])
+
+if test "x$have_ip6_ext" = "xno"; then
+	SAVE_CFLAGS="$CFLAGS"
+	CFLAGS="$CFLAGS -DSOLARIS2=8"
+
+	AC_CHECK_TYPES([struct ip6_ext],
+		       [have_ip6_ext="yes, with -DSOLARIS2=8"],
+		       [have_ip6_ext="no"],
+[#if HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_SYSTM_H
+# include <netinet/in_systm.h>
+#endif
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
+#if HAVE_NETINET_IP6_H
+# include <netinet/ip6.h>
+#endif
+])
+
+	if test "x$have_ip6_ext" = "xno"; then
+		CFLAGS="$SAVE_CFLAGS"
+	fi
+fi
+
 # For cpu modules
 AC_CHECK_HEADERS(sys/dkstat.h)
 if test "x$ac_system" = "xDarwin"
 then
 	AC_CHECK_HEADERS(mach/mach_init.h mach/host_priv.h mach/mach_error.h mach/mach_host.h mach/mach_port.h mach/mach_types.h mach/message.h mach/processor_set.h mach/processor.h mach/processor_info.h mach/task.h mach/thread_act.h mach/vm_region.h mach/vm_map.h mach/vm_prot.h mach/vm_statistics.h mach/kern_return.h)
 	AC_CHECK_HEADERS(CoreFoundation/CoreFoundation.h IOKit/IOKitLib.h IOKit/IOTypes.h IOKit/ps/IOPSKeys.h IOKit/IOBSD.h IOKit/storage/IOBlockStorageDriver.h)
@@ -373,24 +456,12 @@
 #endif
 #if HAVE_SYS_PARAM_H
 # include <sys/param.h>
 #endif
 ])
 
-if test "x$have_sys_swap_h$ac_system" = "xnoSolaris"
-then
-	hint_64=""
-	if test "x$GCC" = "xyes"
-	then
-		hint_64="CFLAGS='-m64'"
-	else
-		hint_64="CFLAGS='-xarch=v9'"
-	fi
-	AC_MSG_NOTICE([Solaris detected and sys/swap.h not usable. Try building a 64-bit binary ($hint_64 ./configure).])
-fi
-
 # For load module
 # For the processes plugin
 # For users module
 AC_CHECK_HEADERS(sys/loadavg.h linux/config.h utmp.h utmpx.h)
 
 # For interface plugin
@@ -580,32 +651,35 @@
 #if HAVE_SYS_SOCKET_H
 # include <sys/socket.h>
 #endif
 #if HAVE_NET_IF_H
 # include <net/if.h>
 #endif
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
 ])
 
 # For the multimeter plugin
 have_termios_h="no"
 AC_CHECK_HEADERS(termios.h, [have_termios_h="yes"])
 
 # For the turbostat plugin
 have_asm_msrindex_h="no"
 AC_CHECK_HEADERS(asm/msr-index.h, [have_asm_msrindex_h="yes"])
 
 if test "x$have_asm_msrindex_h" = "xyes"
 then
-  AC_CACHE_CHECK([whether asm/msr-index.h has MSR_CORE_C3_RESIDENCY],
+  AC_CACHE_CHECK([whether asm/msr-index.h has MSR_PKG_C10_RESIDENCY],
                  [c_cv_have_usable_asm_msrindex_h],
                  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
 [[[
 #include<asm/msr-index.h>
 ]]],
 [[[
-int y = MSR_CORE_C3_RESIDENCY;
+int y = MSR_PKG_C10_RESIDENCY;
 return(y);
 ]]]
   )],
                  [c_cv_have_usable_asm_msrindex_h="yes"],
                  [c_cv_have_usable_asm_msrindex_h="no"],
                                   )
@@ -1192,12 +1266,14 @@
 have_getfsstat="no"
 AC_CHECK_FUNCS(getfsstat, [have_getfsstat="yes"])
 have_getvfsstat="no"
 AC_CHECK_FUNCS(getvfsstat, [have_getvfsstat="yes"])
 have_listmntent="no"
 AC_CHECK_FUNCS(listmntent, [have_listmntent="yes"])
+have_getmntent_r="no"
+AC_CHECK_FUNCS(getmntent_r, [have_getmntent_r="yes"])
 
 have_getmntent="no"
 AC_CHECK_FUNCS(getmntent, [have_getmntent="c"])
 if test "x$have_getmntent" = "xno"; then
 	AC_CHECK_LIB(sun, getmntent, [have_getmntent="sun"])
 fi
@@ -1863,36 +1939,39 @@
  else if test -d "$withval"
  then
 	 GANGLIA_CPPFLAGS="-I$withval/include"
 	 GANGLIA_LDFLAGS="-L$withval/lib"
 	 with_libganglia="yes"
  else
-	 with_libganglia_config="ganglia-config"
 	 with_libganglia="$withval"
  fi; fi; fi
 ],
 [
- with_libganglia_config="ganglia-config"
  with_libganglia="yes"
 ])
 
-if test "x$with_libganglia" = "xyes" && test "x$with_libganglia_config" != "x"
+if test "x$with_libganglia" = "xyes"
 then
-	if test "x$GANGLIA_CPPFLAGS" = "x"
+	if test "x$with_libganglia_config" != "x"
 	then
-		GANGLIA_CPPFLAGS=`"$with_libganglia_config" --cflags 2>/dev/null`
-	fi
+		if test "x$GANGLIA_CPPFLAGS" = "x"
+		then
+			GANGLIA_CPPFLAGS=`"$with_libganglia_config" --cflags 2>/dev/null`
+		fi
 
-	if test "x$GANGLIA_LDFLAGS" = "x"
-	then
-		GANGLIA_LDFLAGS=`"$with_libganglia_config" --ldflags 2>/dev/null`
-	fi
+		if test "x$GANGLIA_LDFLAGS" = "x"
+		then
+			GANGLIA_LDFLAGS=`"$with_libganglia_config" --ldflags 2>/dev/null`
+		fi
 
-	if test "x$GANGLIA_LIBS" = "x"
-	then
-		GANGLIA_LIBS=`"$with_libganglia_config" --libs 2>/dev/null`
+		if test "x$GANGLIA_LIBS" = "x"
+		then
+			GANGLIA_LIBS=`"$with_libganglia_config" --libs 2>/dev/null`
+		fi
+	else
+		GANGLIA_LIBS="-lganglia"
 	fi
 fi
 
 SAVE_CPPFLAGS="$CPPFLAGS"
 SAVE_LDFLAGS="$LDFLAGS"
 CPPFLAGS="$CPPFLAGS $GANGLIA_CPPFLAGS"
@@ -1958,28 +2037,24 @@
 then
 	if test "x$GCRYPT_CPPFLAGS" = "x"
 	then
 		GCRYPT_CPPFLAGS=`"$with_libgcrypt_config" --cflags 2>/dev/null`
 	fi
 
-	if test "x$GCRYPT_LDFLAGS" = "x"
-	then
-		gcrypt_exec_prefix=`"$with_libgcrypt_config" --exec-prefix 2>/dev/null`
-		GCRYPT_LDFLAGS="-L$gcrypt_exec_prefix/lib"
-	fi
-
 	if test "x$GCRYPT_LIBS" = "x"
 	then
 		GCRYPT_LIBS=`"$with_libgcrypt_config" --libs 2>/dev/null`
 	fi
 fi
 
 SAVE_CPPFLAGS="$CPPFLAGS"
 SAVE_LDFLAGS="$LDFLAGS"
+SAVE_LIBS="$LIBS"
 CPPFLAGS="$CPPFLAGS $GCRYPT_CPPFLAGS"
 LDFLAGS="$LDFLAGS $GCRYPT_LDFLAGS"
+LIBS="$LIBS $GCRYPT_LIBS"
 
 if test "x$with_libgcrypt" = "xyes"
 then
 	if test "x$GCRYPT_CPPFLAGS" != "x"
 	then
 		AC_MSG_NOTICE([gcrypt CPPFLAGS: $GCRYPT_CPPFLAGS])
@@ -1988,16 +2063,12 @@
 		[with_libgcrypt="yes"],
 		[with_libgcrypt="no (gcrypt.h not found)"])
 fi
 
 if test "x$with_libgcrypt" = "xyes"
 then
-	if test "x$GCRYPT_LDFLAGS" != "x"
-	then
-		AC_MSG_NOTICE([gcrypt LDFLAGS: $GCRYPT_LDFLAGS])
-	fi
 	AC_CHECK_LIB(gcrypt, gcry_md_hash_buffer,
 		[with_libgcrypt="yes"],
 		[with_libgcrypt="no (symbol gcry_md_hash_buffer not found)"])
 
 	if test "$with_libgcrypt" != "no"; then
 		m4_ifdef([AM_PATH_LIBGCRYPT],[AM_PATH_LIBGCRYPT(1:1.2.0,,with_libgcrypt="no (version 1.2.0+ required)")])
@@ -2005,12 +2076,13 @@
 		GCRYPT_LIBS="$LIBGCRYPT_LIBS"
 	fi
 fi
 
 CPPFLAGS="$SAVE_CPPFLAGS"
 LDFLAGS="$SAVE_LDFLAGS"
+LIBS="$SAVE_LIBS"
 
 if test "x$with_libgcrypt" = "xyes"
 then
 	AC_DEFINE(HAVE_LIBGCRYPT, 1, [Define to 1 if you have the gcrypt library (-lgcrypt).])
 fi
 
@@ -2162,13 +2234,13 @@
 			JAVA_CPPFLAGS="$JAVA_CPPFLAGS -I$TMPVAR"
 		else
 			AC_MSG_RESULT([not found])
 		fi
 
 		AC_MSG_CHECKING([for libjvm.so])
-		TMPVAR=`find -L "$with_java_home" -name libjvm.so -type f -exec 'dirname' '{}' ';' 2>/dev/null | head -n 1`
+		TMPVAR=`find -L "$with_java_home" -type f \( -name libjvm.so -o -name libjvm.dylib \) -exec 'dirname' '{}' ';' 2>/dev/null | head -n 1`
 		if test "x$TMPVAR" != "x"
 		then
 			AC_MSG_RESULT([found in $TMPVAR])
 			JAVA_LDFLAGS="$JAVA_LDFLAGS -L$TMPVAR -Wl,-rpath -Wl,$TMPVAR"
 		else
 			AC_MSG_RESULT([not found])
@@ -2510,13 +2582,13 @@
 # the actual checks.
 if test "x$with_libmodbus" = "xyes"
 then
 	SAVE_CPPFLAGS="$CPPFLAGS"
 	CPPFLAGS="$CPPFLAGS $with_libmodbus_cflags"
 
-	AC_CHECK_HEADERS(modbus/modbus.h, [], [with_libmodbus="no (modbus/modbus.h not found)"])
+	AC_CHECK_HEADERS(modbus.h, [], [with_libmodbus="no (modbus.h not found)"])
 
 	CPPFLAGS="$SAVE_CPPFLAGS"
 fi
 if test "x$with_libmodbus" = "xyes"
 then
 	SAVE_CPPFLAGS="$CPPFLAGS"
@@ -2629,13 +2701,13 @@
 ],
 [
 	with_libmysql="yes"
 ])
 if test "x$with_libmysql" = "xyes"
 then
-	with_mysql_cflags=`$with_mysql_config --cflags 2>/dev/null`
+	with_mysql_cflags=`$with_mysql_config --include 2>/dev/null`
 	mysql_config_status=$?
 
 	if test $mysql_config_status -ne 0
 	then
 		with_libmysql="no ($with_mysql_config failed)"
 	else
@@ -2665,21 +2737,23 @@
 	mysql_config_status=$?
 
 	if test $mysql_config_status -ne 0
 	then
 		with_libmysql="no ($with_mysql_config failed)"
 	else
-		AC_CHECK_LIB(mysqlclient, mysql_init,
-		 [with_libmysql="yes"],
-		 [with_libmysql="no (symbol 'mysql_init' not found)"],
-		 [$with_mysql_libs])
-
-		AC_CHECK_LIB(mysqlclient, mysql_get_server_version,
+		SAVE_CPPFLAGS="$CPPFLAGS"
+		CPPFLAGS="$CPPFLAGS $with_mysql_cflags"
+		SAVE_LIBS="$LIBS"
+		LIBS="$with_mysql_libs"
+		AC_SEARCH_LIBS([mysql_get_server_version],
+		 [],
 		 [with_libmysql="yes"],
 		 [with_libmysql="no (symbol 'mysql_get_server_version' not found)"],
-		 [$with_mysql_libs])
+		 [])
+		CPPFLAGS="$SAVE_CPPFLAGS"
+		LIBS="$SAVE_LIBS"
 	fi
 fi
 if test "x$with_libmysql" = "xyes"
 then
 	BUILD_WITH_LIBMYSQL_CFLAGS="$with_mysql_cflags"
 	BUILD_WITH_LIBMYSQL_LIBS="$with_mysql_libs"
@@ -3193,17 +3267,12 @@
 then
 	AC_CHECK_HEADERS(pcap.h,,
 			 [with_libpcap="no (pcap.h not found)"])
 fi
 if test "x$with_libpcap" = "xyes"
 then
-	AC_CHECK_HEADERS(pcap-bpf.h,,
-			 [with_libpcap="no (pcap-bpf.h not found)"])
-fi
-if test "x$with_libpcap" = "xyes"
-then
 	AC_CACHE_CHECK([whether libpcap has PCAP_ERROR_IFACE_NOT_UP],
 		       [c_cv_libpcap_have_pcap_error_iface_not_up],
 		       AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
 [[[
 #include <pcap.h>
 ]]],
@@ -4739,17 +4808,17 @@
 if test "x$with_libvarnish" = "xyes"
 then
 	SAVE_CPPFLAGS="$CPPFLAGS"
 
 	CPPFLAGS="$CPPFLAGS $with_libvarnish_cflags"
 
-	AC_CHECK_HEADERS(varnish/vapi/vsc.h,
+	AC_CHECK_HEADERS(vapi/vsc.h,
 		[AC_DEFINE([HAVE_VARNISH_V4], [1], [Varnish 4 API support])],
-		[AC_CHECK_HEADERS(varnish/vsc.h,
+		[AC_CHECK_HEADERS(vsc.h,
 			[AC_DEFINE([HAVE_VARNISH_V3], [1], [Varnish 3 API support])],
-			[AC_CHECK_HEADERS(varnish/varnishapi.h,
+			[AC_CHECK_HEADERS(varnishapi.h,
 				[AC_DEFINE([HAVE_VARNISH_V2], [1], [Varnish 2 API support])],
 				[with_libvarnish="no (found none of the varnish header files)"])])])
 
 	CPPFLAGS="$SAVE_CPPFLAGS"
 fi
 if test "x$with_libvarnish" = "xyes"
@@ -5163,12 +5232,13 @@
 plugin_curl_xml="no"
 plugin_df="no"
 plugin_disk="no"
 plugin_drbd="no"
 plugin_entropy="no"
 plugin_ethstat="no"
+plugin_fhcount="no"
 plugin_fscache="no"
 plugin_interface="no"
 plugin_ipmi="no"
 plugin_ipvs="no"
 plugin_irq="no"
 plugin_load="no"
@@ -5205,12 +5275,13 @@
 	plugin_cgroups="yes"
 	plugin_cpu="yes"
 	plugin_cpufreq="yes"
 	plugin_disk="yes"
 	plugin_drbd="yes"
 	plugin_entropy="yes"
+	plugin_fhcount="yes"
 	plugin_fscache="yes"
 	plugin_interface="yes"
 	plugin_ipc="yes"
 	plugin_irq="yes"
 	plugin_load="yes"
 	plugin_lvm="yes"
@@ -5400,12 +5471,17 @@
 #fi
 if test "x$c_cv_have_one_getmntent" = "xyes"
 then
 	plugin_df="yes"
 fi
 
+if test "x$c_cv_have_getmntent_r" = "xyes"
+then
+	plugin_df="yes"
+fi
+
 # Df plugin: Check if we have either `statfs' or `statvfs' second.
 if test "x$plugin_df" = "xyes"
 then
 	plugin_df="no"
 	if test "x$have_statfs" = "xyes"
 	then
@@ -5548,13 +5624,13 @@
 AC_PLUGIN([drbd],        [$plugin_drbd],       [DRBD statistics])
 AC_PLUGIN([dns],         [$with_libpcap],      [DNS traffic analysis])
 AC_PLUGIN([email],       [yes],                [EMail statistics])
 AC_PLUGIN([entropy],     [$plugin_entropy],    [Entropy statistics])
 AC_PLUGIN([ethstat],     [$plugin_ethstat],    [Stats from NIC driver])
 AC_PLUGIN([exec],        [yes],                [Execution of external programs])
-AC_PLUGIN([fhcount],     [yes],                [File handles statistics])
+AC_PLUGIN([fhcount],     [$plugin_fhcount],    [File handles statistics])
 AC_PLUGIN([filecount],   [yes],                [Count files in directories])
 AC_PLUGIN([fscache],     [$plugin_fscache],    [fscache statistics])
 AC_PLUGIN([gmond],       [$with_libganglia],   [Ganglia plugin])
 AC_PLUGIN([hddtemp],     [yes],                [Query hddtempd])
 AC_PLUGIN([interface],   [$plugin_interface],  [Interface traffic statistics])
 AC_PLUGIN([ipc],         [$plugin_ipc],        [IPC statistics])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/contrib/collectd2html.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/contrib/collectd2html.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/contrib/collectd2html.pl	2012-09-13 19:10:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/contrib/collectd2html.pl	2016-01-22 16:33:25.038182532 +0800
@@ -213,13 +213,13 @@
 	$cleaned_bn =~ tr/%\//__/;
 	print OUT <<END;
 <h2><a id="$cleaned_bn">$bn</a></h2>
 END
 
 	# graph various ranges
-	foreach my $span qw(1hour 1day 1week 1month){
+	foreach my $span (qw(1hour 1day 1week 1month)){
 		system("mkdir -p $IMG_DIR/" . dirname($bn));
 		my $img = "$IMG_DIR/${bn}-$span$IMG_SFX";
 
 		my $cmd = "rrdtool graph $img"
 			." -t \"$bn $span\" --imgformat $IMG_FMT --width 600 --height 100"
 			." --start now-$span --end now --interlaced"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/contrib/systemd.collectd.service /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/contrib/systemd.collectd.service
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/contrib/systemd.collectd.service	2015-03-10 22:14:45.813113801 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/contrib/systemd.collectd.service	2016-01-22 17:51:17.693918698 +0800
@@ -2,22 +2,39 @@
 Description=Collectd
 After=local-fs.target network.target
 Requires=local-fs.target network.target
 
 [Service]
 ExecStart=/usr/sbin/collectd
+EnvironmentFile=-/etc/sysconfig/collectd
+EnvironmentFile=-/etc/default/collectd
+ProtectSystem=full
+ProtectHome=true
+
+# A few plugins won't work without some privileges, which you'll have to
+# specify using the CapabilityBoundingSet directive below.
+#
+# Here's a (incomplete) list of the plugins known capability requirements:
+#   ceph            CAP_DAC_OVERRIDE
+#   dns             CAP_NET_RAW
+#   exec            CAP_SETUID CAP_SETGID
+#   iptables        CAP_NET_ADMIN
+#   ping            CAP_NET_RAW
+#   turbostat       CAP_SYS_RAWIO
+#
+# Example, if you use the iptables plugin alongside the dns or ping plugin:
+#CapabilityBoundingSet=CAP_NET_RAW CAP_NET_ADMIN
+#
+# By default, drop all capabilities:
+CapabilityBoundingSet=
+
+NoNewPrivileges=true
 
 # Tell systemd it will receive a notification from collectd over it's control
 # socket once the daemon is ready. See systemd.service(5) for more details.
 Type=notify
-NotifyAccess=main
 
 # Restart the collectd daemon after a 10 seconds delay, in case it crashes.
-Restart=always
-RestartSec=10
-
-# Send all console messages to syslog.
-StandardOutput=syslog
-StandardError=syslog
+Restart=on-failure
 
 [Install]
 WantedBy=multi-user.target
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/contrib/wiki2changelog.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/contrib/wiki2changelog.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/contrib/wiki2changelog.pl	2015-05-22 18:04:36.951771009 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/contrib/wiki2changelog.pl	2016-01-22 17:51:17.693918698 +0800
@@ -61,14 +61,14 @@
 	$line =~ s#&gt;#>#g;
 	$line =~ s#&nbsp;# #g;
 	$line =~ s#&quot;#"#g;
 
 	$line =~ s#\{\{Plugin\|([^}]+)\}\}#$1 plugin#g;
 	$line =~ s@\{\{Issue\|([^}]+)\}\}@#$1@g;
-	$line =~ s#\[\[[^|]+\|([^\]]+)\]\]#$1#g;
-	$line =~ s#\[\[([^|]+)\]\]#$1#g;
+	$line =~ s#\[\[[^|\]]+\|([^\]]+)\]\]#$1#g;
+	$line =~ s#\[\[([^|\]]+)\]\]#$1#g;
 
 	$line =~ s#'''(.*?)'''#*$1*#g;
 	$line =~ s#''(.*?)''#$1#g;
 	$line =~ s#<code>(.*?)</code>#"$1"#gi;
 
 	print format_entry($line);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/contrib: wiki2commonmark.pl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/Makefile.am	2015-03-09 17:38:22.004220280 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/Makefile.am	2016-01-22 16:33:25.038182532 +0800
@@ -1,9 +1,15 @@
 ACLOCAL_AMFLAGS = -I libltdl/m4
 
-SUBDIRS = libltdl src bindings .
+SUBDIRS =
+
+if BUILD_INCLUDED_LTDL
+SUBDIRS += libltdl
+endif
+
+SUBDIRS += src bindings .
 
 AM_CPPFLAGS = $(LTDLINCL)
 
 EXTRA_DIST = contrib version-gen.sh
 
 install-exec-hook:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/Makefile.in	2015-05-27 15:51:48.181909664 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/Makefile.in	2016-01-22 17:55:46.077694232 +0800
@@ -74,12 +74,13 @@
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
+@BUILD_INCLUDED_LTDL_TRUE@am__append_1 = libltdl
 subdir = .
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(top_srcdir)/configure $(am__configure_deps) \
 	$(top_srcdir)/src/libcollectdclient/collectd/lcc_features.h.in \
 	AUTHORS COPYING ChangeLog INSTALL NEWS README TODO compile \
 	libltdl/config/compile config.guess \
@@ -155,13 +156,13 @@
   unique=`for i in $$list; do \
     if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
   done | $(am__uniquify_input)`
 ETAGS = etags
 CTAGS = ctags
 CSCOPE = cscope
-DIST_SUBDIRS = $(SUBDIRS)
+DIST_SUBDIRS = libltdl src bindings .
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
 top_distdir = $(distdir)
 am__remove_distdir = \
   if test -d "$(distdir)"; then \
     find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
@@ -469,13 +470,13 @@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 ACLOCAL_AMFLAGS = -I libltdl/m4
-SUBDIRS = libltdl src bindings .
+SUBDIRS = $(am__append_1) src bindings .
 AM_CPPFLAGS = $(LTDLINCL)
 EXTRA_DIST = contrib version-gen.sh
 all: all-recursive
 
 .SUFFIXES:
 am--refresh: Makefile
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/README	2015-05-20 20:05:42.668059928 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/README	2016-01-22 17:51:17.685918703 +0800
@@ -461,13 +461,13 @@
 
     - write_tsdb
       Sends data OpenTSDB, a scalable no master, no shared state time series
       database.
 
   * Logging is, as everything in collectd, provided by plugins. The following
-    plugins keep up informed about what's going on:
+    plugins keep us informed about what's going on:
 
     - logfile
       Writes log messages to a file or STDOUT/STDERR.
 
     - perl
       Log messages are propagated to plugins written in Perl as well.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/aggregation.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/aggregation.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/aggregation.c	2014-08-18 15:36:18.632139234 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/aggregation.c	2016-01-22 16:33:25.038182532 +0800
@@ -259,12 +259,13 @@
 #define INIT_STATE(field) do { \
   inst->state_ ## field = NULL; \
   if (agg->calc_ ## field) { \
     inst->state_ ## field = malloc (sizeof (*inst->state_ ## field)); \
     if (inst->state_ ## field == NULL) { \
       agg_instance_destroy (inst); \
+      free (inst); \
       ERROR ("aggregation plugin: malloc() failed."); \
       return (NULL); \
     } \
     memset (inst->state_ ## field, 0, sizeof (*inst->state_ ## field)); \
   } \
 } while (0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/amqp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/amqp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/amqp.c	2015-05-20 20:04:47.179035320 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/amqp.c	2016-01-22 17:51:17.693918698 +0800
@@ -196,29 +196,29 @@
     amqp_rpc_reply_t r;
 
     r = amqp_get_rpc_reply (conf->connection);
     switch (r.reply_type)
     {
         case AMQP_RESPONSE_NORMAL:
-            sstrncpy (buffer, "Success", sizeof (buffer));
+            sstrncpy (buffer, "Success", buffer_size);
             break;
 
         case AMQP_RESPONSE_NONE:
-            sstrncpy (buffer, "Missing RPC reply type", sizeof (buffer));
+            sstrncpy (buffer, "Missing RPC reply type", buffer_size);
             break;
 
         case AMQP_RESPONSE_LIBRARY_EXCEPTION:
 #if HAVE_AMQP_RPC_REPLY_T_LIBRARY_ERRNO
             if (r.library_errno)
                 return (sstrerror (r.library_errno, buffer, buffer_size));
 #else
             if (r.library_error)
                 return (sstrerror (r.library_error, buffer, buffer_size));
 #endif
             else
-                sstrncpy (buffer, "End of stream", sizeof (buffer));
+                sstrncpy (buffer, "End of stream", buffer_size);
             break;
 
         case AMQP_RESPONSE_SERVER_EXCEPTION:
             if (r.reply.id == AMQP_CONNECTION_CLOSE_METHOD)
             {
                 amqp_connection_close_t *m = r.reply.decoded;
@@ -713,13 +713,13 @@
         {
             DEBUG ("amqp plugin: Unexpected method id: %#"PRIx32,
                     frame.payload.method.id);
             continue;
         }
 
-        status = camqp_read_header (conf);
+        camqp_read_header (conf);
 
         amqp_maybe_release_buffers (conf->connection);
     } /* while (subscriber_threads_running) */
 
     camqp_config_free (conf);
     pthread_exit (NULL);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/apache.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/apache.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/apache.c	2015-05-20 20:04:47.179035320 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/apache.c	2016-01-22 17:51:17.693918698 +0800
@@ -78,12 +78,13 @@
 	sfree (st->server);
 	sfree (st->apache_buffer);
 	if (st->curl) {
 		curl_easy_cleanup(st->curl);
 		st->curl = NULL;
 	}
+	sfree (st);
 } /* apache_free */
 
 static size_t apache_curl_callback (void *buf, size_t size, size_t nmemb,
 		void *user_data)
 {
 	size_t len = size * nmemb;
@@ -516,18 +517,15 @@
 		submit_gauge ("apache_scoreboard", "response_end"  , response_end, st);
 	}
 }
 
 static int apache_read_host (user_data_t *user_data) /* {{{ */
 {
-	int i;
-
 	char *ptr;
 	char *saveptr;
-	char *lines[16];
-	int   lines_num = 0;
+	char *line;
 
 	char *fields[4];
 	int   fields_num;
 
 	apache_t *st;
 
@@ -561,35 +559,23 @@
 				"automatically. Will assume Apache.");
 		st->server_type = APACHE;
 	}
 
 	ptr = st->apache_buffer;
 	saveptr = NULL;
-	while ((lines[lines_num] = strtok_r (ptr, "\n\r", &saveptr)) != NULL)
+	while ((line = strtok_r (ptr, "\n\r", &saveptr)) != NULL)
 	{
 		ptr = NULL;
-		lines_num++;
-
-		if (lines_num >= 16)
-			break;
-	}
-
-	for (i = 0; i < lines_num; i++)
-	{
-		fields_num = strsplit (lines[i], fields, 4);
+		fields_num = strsplit (line, fields, STATIC_ARRAY_SIZE (fields));
 
 		if (fields_num == 3)
 		{
-			if ((strcmp (fields[0], "Total") == 0)
-					&& (strcmp (fields[1], "Accesses:") == 0))
-				submit_derive ("apache_requests", "",
-						atoll (fields[2]), st);
-			else if ((strcmp (fields[0], "Total") == 0)
-					&& (strcmp (fields[1], "kBytes:") == 0))
-				submit_derive ("apache_bytes", "",
-						1024LL * atoll (fields[2]), st);
+			if ((strcmp (fields[0], "Total") == 0) && (strcmp (fields[1], "Accesses:") == 0))
+				submit_derive ("apache_requests", "", atoll (fields[2]), st);
+			else if ((strcmp (fields[0], "Total") == 0) && (strcmp (fields[1], "kBytes:") == 0))
+				submit_derive ("apache_bytes", "", 1024LL * atoll (fields[2]), st);
 		}
 		else if (fields_num == 2)
 		{
 			if (strcmp (fields[0], "Scoreboard:") == 0)
 				submit_scoreboard (fields[1], st);
 			else if ((strcmp (fields[0], "BusyServers:") == 0) /* Apache 1.* */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/apcups.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/apcups.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/apcups.c	2015-03-10 22:14:45.817113888 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/apcups.c	2016-01-22 17:51:17.693918698 +0800
@@ -136,13 +136,13 @@
 	ai_hints.ai_socktype = SOCK_STREAM;
 
 	status = getaddrinfo (host, port_str, &ai_hints, &ai_return);
 	if (status != 0)
 	{
 		char errbuf[1024];
-		INFO ("getaddrinfo failed: %s",
+		INFO ("apcups plugin: getaddrinfo failed: %s",
 				(status == EAI_SYSTEM)
 				? sstrerror (errno, errbuf, sizeof (errbuf))
 				: gai_strerror (status));
 		return (-1);
 	}
 
@@ -155,31 +155,31 @@
 			break;
 	}
 	/* `ai_list' still holds the current description of the socket.. */
 
 	if (sd < 0)
 	{
-		DEBUG ("Unable to open a socket");
+		DEBUG ("apcups plugin: Unable to open a socket");
 		freeaddrinfo (ai_return);
 		return (-1);
 	}
 
 	status = connect (sd, ai_list->ai_addr, ai_list->ai_addrlen);
 
 	freeaddrinfo (ai_return);
 
 	if (status != 0) /* `connect(2)' failed */
 	{
 		char errbuf[1024];
-		INFO ("connect failed: %s",
+		INFO ("apcups plugin: connect failed: %s",
 				sstrerror (errno, errbuf, sizeof (errbuf)));
 		close (sd);
 		return (-1);
 	}
 
-	DEBUG ("Done opening a socket %i", sd);
+	DEBUG ("apcups plugin: Done opening a socket %i", sd);
 
 	return (sd);
 } /* int net_open (char *host, char *service, int port) */
 
 /*
  * Receive a message from the other end. Each message consists of
@@ -477,13 +477,13 @@
 	/*
 	 * if we did not connect then do not bother submitting
 	 * zeros. We want rrd files to have NAN.
 	 */
 	if (status != 0)
 	{
-		DEBUG ("apc_query_server (%s, %i) = %i",
+		DEBUG ("apcups plugin: apc_query_server (%s, %i) = %i",
 				conf_host == NULL
 				? APCUPS_DEFAULT_HOST
 				: conf_host,
 				conf_port, status);
 		return (-1);
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/barometer.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/barometer.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/barometer.c	2015-05-20 20:04:47.179035320 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/barometer.c	2016-01-22 17:51:17.693918698 +0800
@@ -30,26 +30,26 @@
 #include <linux/i2c-dev.h>
 #include <math.h>
 
 /* ------------ MPL115 defines ------------ */
 /* I2C address of the MPL115 sensor */
 #define MPL115_I2C_ADDRESS          0x60
-                                    
-/* register addresses */            
+
+/* register addresses */
 #define MPL115_ADDR_CONV            0x00
 #define MPL115_ADDR_COEFFS          0x04
-                                    
-/* register sizes */                
+
+/* register sizes */
 #define MPL115_NUM_CONV             4
 #define MPL115_NUM_COEFFS           12
-                                    
-/* commands / addresses */          
+
+/* commands / addresses */
 #define MPL115_CMD_CONVERT_PRESS    0x10
 #define MPL115_CMD_CONVERT_TEMP     0x11
 #define MPL115_CMD_CONVERT_BOTH     0x12
-                                    
+
 #define MPL115_CONVERSION_RETRIES   5
 
 
 /* ------------ MPL3115 defines ------------ */
 /* MPL3115 I2C address */
 #define MPL3115_I2C_ADDRESS         0x60
@@ -79,18 +79,18 @@
 /* Register values, masks */
 #define MPL3115_WHO_AM_I_RESP       0xC4
 
 #define MPL3115_PT_DATA_DREM        0x04
 #define MPL3115_PT_DATA_PDEF        0x02
 #define MPL3115_PT_DATA_TDEF        0x01
-                                    
+
 #define MPL3115_DR_STATUS_TDR       0x02
 #define MPL3115_DR_STATUS_PDR       0x04
 #define MPL3115_DR_STATUS_PTDR      0x08
 #define MPL3115_DR_STATUS_DR        (MPL3115_DR_STATUS_TDR | MPL3115_DR_STATUS_PDR | MPL3115_DR_STATUS_PTDR)
-                                    
+
 #define MPL3115_DR_STATUS_TOW       0x20
 #define MPL3115_DR_STATUS_POW       0x40
 #define MPL3115_DR_STATUS_PTOW      0x80
 
 #define MPL3115_CTRL_REG1_ALT       0x80
 #define MPL3115_CTRL_REG1_RAW       0x40
@@ -112,22 +112,22 @@
 
 
 /* ------------ BMP085 defines ------------ */
 /* I2C address of the BMP085 sensor */
 #define BMP085_I2C_ADDRESS          0x77
 
-/* register addresses */            
+/* register addresses */
 #define BMP085_ADDR_ID_REG          0xD0
 #define BMP085_ADDR_VERSION         0xD1
 
 #define BMP085_ADDR_CONV            0xF6
 
 #define BMP085_ADDR_CTRL_REG        0xF4
 #define BMP085_ADDR_COEFFS          0xAA
 
-/* register sizes */                
+/* register sizes */
 #define BMP085_NUM_COEFFS           22
 
 /* commands, values */
 #define BMP085_CHIP_ID              0x55
 
 #define BMP085_CMD_CONVERT_TEMP     0x2E
@@ -175,24 +175,24 @@
     "Altitude",
     "Normalization",
     "TemperatureSensor"
 };
 
 static int    config_keys_num     = STATIC_ARRAY_SIZE(config_keys);
-                                  
+
 static char * config_device       = NULL;  /**< I2C bus device */
 static int    config_oversample   = 1;     /**< averaging window */
 
 static double config_press_offset = 0.0;   /**< pressure offset */
 static double config_temp_offset  = 0.0;   /**< temperature offset */
 
 static double config_altitude     = NAN;   /**< altitude */
 static int    config_normalize    = 0;     /**< normalization method */
-                                  
+
 static _Bool  configured          = 0;     /**< the whole plugin config status */
-                                  
+
 static int    i2c_bus_fd          = -1;    /**< I2C bus device FD */
 
 static enum Sensor_type sensor_type = Sensor_none; /**< detected/used sensor type */
 
 static __s32  mpl3115_oversample  = 0;    /**< MPL3115 CTRL1 oversample setting */
 
@@ -240,39 +240,32 @@
 
 
 static averaging_t pressure_averaging    = { NULL, 0, 0L, 0 };
 static averaging_t temperature_averaging = { NULL, 0, 0L, 0 };
 
 
-/** 
+/**
  * Create / allocate averaging buffer
  *
  * The buffer is initialized with zeros.
  *
  * @param avg  pointer to ring buffer to be allocated
  * @param size requested buffer size
  *
  * @return Zero when successful
  */
-static int averaging_create(averaging_t * avg, int size)
+static int averaging_create(averaging_t *avg, int size)
 {
-    int a;
-
-    avg->ring_buffer = (long int *) malloc(size * sizeof(*avg));
+    avg->ring_buffer = calloc ((size_t) size, sizeof (*avg->ring_buffer));
     if (avg->ring_buffer == NULL)
     {
         ERROR ("barometer: averaging_create - ring buffer allocation of size %d failed",
                size);
         return -1;
     }
 
-    for (a=0; a<size; ++a)
-    {
-      avg->ring_buffer[a] = 0L;
-    }
-
     avg->ring_buffer_size = size;
     avg->ring_buffer_sum  = 0L;
     avg->ring_buffer_head = 0;
 
     return 0;
 }
@@ -313,15 +306,15 @@
     double result;
 
     avg->ring_buffer_sum += sample - avg->ring_buffer[avg->ring_buffer_head];
     avg->ring_buffer[avg->ring_buffer_head] = sample;
     avg->ring_buffer_head = (avg->ring_buffer_head+1) % avg->ring_buffer_size;
     result = (double)(avg->ring_buffer_sum) / (double)(avg->ring_buffer_size);
-    
-    DEBUG ("barometer: averaging_add_sample - added %ld, result = %lf", 
-           sample, 
+
+    DEBUG ("barometer: averaging_add_sample - added %ld, result = %lf",
+           sample,
            result);
 
     return result;
 }
 
 
@@ -478,13 +471,13 @@
                    list->sensor_name);
             list->initialized = 0;
             list->num_values = 0;
             list = list->next;
             continue;
         }
-            
+
         for(i=0; i<REF_TEMP_AVG_NUM*list->num_values; ++i)
         {
             DEBUG ("barometer: get_reference_temperature - history %d: %lf",
                    i,
                    values_history[i]);
             if(!isnan(values_history[i]))
@@ -537,34 +530,34 @@
                 *result=average;
             else if(*result>average)
                 *result=average;
         }
         list = list->next;
     }  /* while sensor list */
-    
+
     if(*result == NAN)
     {
         ERROR("barometer: get_reference_temperature - no sensor available (yet?)");
         return -1;
     }
     DEBUG ("barometer: get_reference_temperature - temp is %lf", *result);
     return 0;
 }
 
 
 /* ------------------------ MPL115 access ------------------------ */
 
-/** 
+/**
  * Detect presence of a MPL115 pressure sensor.
  *
  * Unfortunately there seems to be no ID register so we just try to read first
  * conversion coefficient from device at MPL115 address and hope it is really
  * MPL115. We should use this check as the last resort (which would be the typical
  * case anyway since MPL115 is the least accurate sensor).
  * As a sideeffect will leave set I2C slave address.
- * 
+ *
  * @return 1 if MPL115, 0 otherwise
  */
 static int MPL115_detect(void)
 {
     __s32 res;
     char errbuf[1024];
@@ -585,58 +578,58 @@
     }
 
     DEBUG ("barometer: MPL115_detect - negative detection");
     return 0;
 }
 
-/** 
+/**
  * Read the MPL115 sensor conversion coefficients.
  *
  * These are (device specific) constants so we can read them just once.
  *
  * @return Zero when successful
  */
 static int MPL115_read_coeffs(void)
 {
-    uint8_t mpl115_coeffs[MPL115_NUM_COEFFS]; 
+    uint8_t mpl115_coeffs[MPL115_NUM_COEFFS] = { 0 };
     int32_t res;
 
     int8_t  sia0MSB, sia0LSB, sib1MSB, sib1LSB, sib2MSB, sib2LSB;
     int8_t  sic12MSB, sic12LSB, sic11MSB, sic11LSB, sic22MSB, sic22LSB;
     int16_t sia0, sib1, sib2, sic12, sic11, sic22;
-      
+
     char errbuf[1024];
 
-    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd, 
-                                        MPL115_ADDR_COEFFS, 
-                                        MPL115_NUM_COEFFS, 
+    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd,
+                                        MPL115_ADDR_COEFFS,
+                                        STATIC_ARRAY_SIZE (mpl115_coeffs),
                                         mpl115_coeffs);
     if (res < 0)
     {
         ERROR ("barometer: MPL115_read_coeffs - problem reading data: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return -1;
     }
-   
+
     /* Using perhaps less elegant/efficient code, but more readable. */
     /* a0: 16total 1sign 12int 4fract 0pad */
     sia0MSB = mpl115_coeffs[0];
     sia0LSB = mpl115_coeffs[1];
     sia0 = (int16_t) sia0MSB <<8;          /* s16 type, Shift to MSB */
     sia0 += (int16_t) sia0LSB & 0x00FF;    /* Add LSB to 16bit number */
     mpl115_coeffA0 = (double) (sia0);
     mpl115_coeffA0 /= 8.0;                 /* 3 fract bits */
-    
+
     /* b1: 16total 1sign 2int 13fract 0pad */
     sib1MSB= mpl115_coeffs[2];
     sib1LSB= mpl115_coeffs[3];
     sib1 = sib1MSB <<8;                    /* Shift to MSB */
     sib1 += sib1LSB & 0x00FF;              /* Add LSB to 16bit number */
     mpl115_coeffB1 = (double) (sib1);
     mpl115_coeffB1 /= 8192.0;              /* 13 fract */
-    
+
     /* b2: 16total 1sign 1int 14fract 0pad */
     sib2MSB= mpl115_coeffs[4];
     sib2LSB= mpl115_coeffs[5];
     sib2 = sib2MSB <<8;                     /* Shift to MSB */
     sib2 += sib2LSB & 0x00FF;               /* Add LSB to 16bit number */
     mpl115_coeffB2 = (double) (sib2);
@@ -667,17 +660,17 @@
     sic22 += sic22LSB & 0x00FF;
     mpl115_coeffC22 = (double) (sic22);
     mpl115_coeffC22 /= 32.0; //16-11=5
     mpl115_coeffC22 /= 33554432.0;          /* 10+15=25 fract */
 
     DEBUG("barometer: MPL115_read_coeffs: a0=%lf, b1=%lf, b2=%lf, c12=%lf, c11=%lf, c22=%lf",
-          mpl115_coeffA0, 
-          mpl115_coeffB1, 
-          mpl115_coeffB2, 
-          mpl115_coeffC12, 
-          mpl115_coeffC11, 
+          mpl115_coeffA0,
+          mpl115_coeffB1,
+          mpl115_coeffB2,
+          mpl115_coeffC12,
+          mpl115_coeffC11,
           mpl115_coeffC22);
     return 0;
 }
 
 
 /**
@@ -694,43 +687,43 @@
                                        double * temperature)
 {
     double Pcomp;
     Pcomp = mpl115_coeffA0 +                                            \
         (mpl115_coeffB1 + mpl115_coeffC11*adc_pressure + mpl115_coeffC12*adc_temp) * adc_pressure + \
         (mpl115_coeffB2 + mpl115_coeffC22*adc_temp) * adc_temp;
-    
+
     *pressure = ((1150.0-500.0) * Pcomp / 1023.0) + 500.0;
     *temperature = (472.0 - adc_temp) / 5.35 + 25.0;
     DEBUG ("barometer: MPL115_convert_adc_to_real - got %lf hPa, %lf C",
            *pressure,
            *temperature);
 }
 
 
-/** 
+/**
  * Read sensor averegaed measurements
  *
  * @param pressure    averaged measured pressure
  * @param temperature averaged measured temperature
  *
  * @return Zero when successful
  */
 static int MPL115_read_averaged(double * pressure, double * temperature)
 {
-    uint8_t mpl115_conv[MPL115_NUM_CONV]; 
+    uint8_t mpl115_conv[MPL115_NUM_CONV] = { 0 };
     int8_t  res;
     int     retries;
     int     conv_pressure;
     int     conv_temperature;
     double  adc_pressure;
     double  adc_temperature;
     char    errbuf[1024];
 
     *pressure    = 0.0;
     *temperature = 0.0;
-   
+
     /* start conversion of both temp and presure */
     retries = MPL115_CONVERSION_RETRIES;
     while (retries>0)
     {
         /* write 1 to start conversion */
         res = i2c_smbus_write_byte_data (i2c_bus_fd,
@@ -760,14 +753,14 @@
 
     retries=MPL115_CONVERSION_RETRIES;
     while (retries>0)
     {
         res = i2c_smbus_read_i2c_block_data(i2c_bus_fd,
                                             MPL115_ADDR_CONV,
-                                            MPL115_NUM_CONV,
-                                            mpl115_conv); 
+                                            STATIC_ARRAY_SIZE (mpl115_conv),
+                                            mpl115_conv);
         if (res >= 0)
             break;
 
         --retries;
         if (retries>0)
         {
@@ -781,13 +774,13 @@
             ERROR ("barometer: MPL115_read_averaged - reading conversion: %s, " \
                    "too many failed retries",
                    sstrerror (errno, errbuf, sizeof (errbuf)));
             return -1;
         }
     }
-    
+
     conv_pressure    = ((mpl115_conv[0] << 8) | mpl115_conv[1]) >> 6;
     conv_temperature = ((mpl115_conv[2] << 8) | mpl115_conv[3]) >> 6;
     DEBUG ("barometer: MPL115_read_averaged, raw pressure ADC value = %d, " \
            "raw temperature ADC value = %d",
            conv_pressure,
            conv_temperature);
@@ -800,23 +793,23 @@
     DEBUG ("barometer: MPL115_read_averaged - averaged ADC pressure = %lf / temperature = %lf, " \
            "real pressure = %lf hPa / temperature = %lf C",
            adc_pressure,
            adc_temperature,
            *pressure,
            *temperature);
-    
+
     return 0;
 }
 
 /* ------------------------ MPL3115 access ------------------------ */
 
-/** 
+/**
  * Detect presence of a MPL3115 pressure sensor by checking register "WHO AM I"
  *
  * As a sideeffect will leave set I2C slave address.
- * 
+ *
  * @return 1 if MPL3115, 0 otherwise
  */
 static int MPL3115_detect(void)
 {
     __s32 res;
     char errbuf[1024];
@@ -837,16 +830,16 @@
     }
 
     DEBUG ("barometer: MPL3115_detect - negative detection");
     return 0;
 }
 
-/** 
+/**
  * Adjusts oversampling to values supported by MPL3115
  *
- * MPL3115 supports only power of 2 in the range 1 to 128. 
+ * MPL3115 supports only power of 2 in the range 1 to 128.
  */
 static void MPL3115_adjust_oversampling(void)
 {
     int new_val = 0;
 
     if(config_oversample > 100)
@@ -888,19 +881,19 @@
     {
         new_val = 1;
         mpl3115_oversample = MPL3115_CTRL_REG1_OST_1;
     }
 
     DEBUG("barometer: MPL3115_adjust_oversampling - correcting oversampling from %d to %d",
-          config_oversample, 
+          config_oversample,
           new_val);
     config_oversample = new_val;
 }
 
-/** 
- * Read sensor averegaed measurements
+/**
+ * Read sensor averaged measurements
  *
  * @param pressure    averaged measured pressure
  * @param temperature averaged measured temperature
  *
  * @return Zero when successful
  */
@@ -908,152 +901,152 @@
 {
     __s32 res;
     __s32 ctrl ;
     __u8 data[MPL3115_NUM_CONV_VALS];
     long int tmp_value = 0;
     char errbuf[1024];
-    
+
     /* Set Active - activate the device from standby */
     res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_CTRL_REG1);
     if (res < 0)
     {
         ERROR ("barometer: MPL3115_read - cannot read CTRL_REG1: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return 1;
     }
     ctrl = res;
-    res = i2c_smbus_write_byte_data(i2c_bus_fd, 
-                                    MPL3115_REG_CTRL_REG1, 
+    res = i2c_smbus_write_byte_data(i2c_bus_fd,
+                                    MPL3115_REG_CTRL_REG1,
                                     ctrl | MPL3115_CTRL_REG1_SBYB);
     if (res < 0)
     {
         ERROR ("barometer: MPL3115_read - problem activating: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return 1;
     }
-    
+
     /* base sleep is 5ms x OST */
     usleep(5000 * config_oversample);
-      
+
     /* check the flags/status if ready */
     res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_STATUS);
     if (res < 0)
     {
         ERROR ("barometer: MPL3115_read - cannot read status register: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return 1;
     }
-    
+
     while ((res & MPL3115_DR_STATUS_DR) != MPL3115_DR_STATUS_DR)
     {
         /* try some extra sleep... */
         usleep(10000);
-        
+
         /* ... and repeat the check. The conversion has to finish sooner or later. */
         res = i2c_smbus_read_byte_data(i2c_bus_fd, MPL3115_REG_STATUS);
         if (res < 0)
         {
             ERROR ("barometer: MPL3115_read - cannot read status register: %s",
                    sstrerror (errno, errbuf, sizeof (errbuf)));
             return 1;
         }
     }
-    
+
     /* Now read all the data in one block. There is address autoincrement. */
-    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd, 
-                                        MPL3115_REG_OUT_P_MSB, 
+    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd,
+                                        MPL3115_REG_OUT_P_MSB,
                                         MPL3115_NUM_CONV_VALS,
                                         data);
     if (res < 0)
     {
         ERROR ("barometer: MPL3115_read - cannot read data registers: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return 1;
     }
-    
+
     tmp_value = (data[0] << 16) | (data[1] << 8) | data[2];
     *pressure = ((double) tmp_value) / 4.0 / 16.0 / 100.0;
     DEBUG ("barometer: MPL3115_read - absolute pressure = %lf hPa", *pressure);
-    
+
     if(data[3] > 0x7F)
     {
         data[3] = ~data[3] + 1;
         *temperature = data[3];
         *temperature = - *temperature;
     }
     else
     {
         *temperature = data[3];
     }
-    
+
     *temperature += (double)(data[4]) / 256.0;
     DEBUG ("barometer: MPL3115_read - temperature = %lf C", *temperature);
-    
+
     return 0;
 }
 
-/** 
+/**
  * Initialize MPL3115 for barometeric measurements
- * 
+ *
  * @return 0 if successful
  */
 static int MPL3115_init_sensor(void)
 {
     __s32 res;
     __s8 offset;
     char errbuf[1024];
-    
+
     /* Reset the sensor. It will reset immediately without ACKing */
     /* the transaction, so no error handling here. */
-    i2c_smbus_write_byte_data(i2c_bus_fd, 
-                              MPL3115_REG_CTRL_REG1, 
+    i2c_smbus_write_byte_data(i2c_bus_fd,
+                              MPL3115_REG_CTRL_REG1,
                               MPL3115_CTRL_REG1_RST);
-    
+
     /* wait some time for the reset to finish */
     usleep(100000);
 
     /* now it should be in standby already so we can go and configure it */
-    
+
     /*  Set temperature offset. */
     /*  result = ADCtemp + offset [C] */
     offset = (__s8) (config_temp_offset * 16.0);
     res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_OFF_T, offset);
     if (res < 0)
     {
         ERROR ("barometer: MPL3115_init_sensor - problem setting temp offset: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return -1;
     }
-    
+
     /*  Set pressure offset. */
     /*  result = ADCpress + offset [hPa] */
     offset = (__s8) (config_press_offset * 100.0 / 4.0);
     res = i2c_smbus_write_byte_data(i2c_bus_fd, MPL3115_REG_OFF_P, offset);
     if (res < 0)
     {
         ERROR ("barometer: MPL3115_init_sensor - problem setting pressure offset: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return -1;
     }
 
     /* Enable Data Flags in PT_DATA_CFG - flags on both pressure and temp */
-    res = i2c_smbus_write_byte_data(i2c_bus_fd, 
+    res = i2c_smbus_write_byte_data(i2c_bus_fd,
                                     MPL3115_REG_PT_DATA_CFG,
                                     MPL3115_PT_DATA_DREM        \
                                     | MPL3115_PT_DATA_PDEF      \
                                     | MPL3115_PT_DATA_TDEF);
     if (res < 0)
     {
         ERROR ("barometer: MPL3115_init_sensor - problem setting PT_DATA_CFG: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return -1;
     }
 
-    /* Set to barometer with an OSR */ 
-    res = i2c_smbus_write_byte_data(i2c_bus_fd, 
-                                    MPL3115_REG_CTRL_REG1, 
+    /* Set to barometer with an OSR */
+    res = i2c_smbus_write_byte_data(i2c_bus_fd,
+                                    MPL3115_REG_CTRL_REG1,
                                     mpl3115_oversample);
     if (res < 0)
     {
         ERROR ("barometer: MPL3115_init_sensor - problem configuring CTRL_REG1: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return -1;
@@ -1061,17 +1054,17 @@
 
     return 0;
 }
 
 /* ------------------------ BMP085 access ------------------------ */
 
-/** 
+/**
  * Detect presence of a BMP085 pressure sensor by checking its ID register
  *
  * As a sideeffect will leave set I2C slave address.
- * 
+ *
  * @return 1 if BMP085, 0 otherwise
  */
 static int BMP085_detect(void)
 {
     __s32 res;
     char errbuf[1024];
@@ -1105,16 +1098,16 @@
 
     DEBUG ("barometer: BMP085_detect - negative detection");
     return 0;
 }
 
 
-/** 
+/**
  * Adjusts oversampling settings to values supported by BMP085
  *
- * BMP085 supports only 1,2,4 or 8 samples. 
+ * BMP085 supports only 1,2,4 or 8 samples.
  */
 static void BMP085_adjust_oversampling(void)
 {
     int new_val = 0;
 
     if( config_oversample > 6 ) /* 8 */
@@ -1144,42 +1137,42 @@
         bmp085_oversampling = 0;
         bmp085_cmdCnvPress = BMP085_CMD_CONVERT_PRESS_0;
         bmp085_timeCnvPress = BMP085_TIME_CNV_PRESS_0;
     }
 
     DEBUG("barometer: BMP085_adjust_oversampling - correcting oversampling from %d to %d",
-          config_oversample, 
+          config_oversample,
           new_val);
     config_oversample = new_val;
 }
 
 
-/** 
+/**
  * Read the BMP085 sensor conversion coefficients.
  *
  * These are (device specific) constants so we can read them just once.
  *
  * @return Zero when successful
  */
 static int BMP085_read_coeffs(void)
 {
     __s32 res;
-    __u8 coeffs[BMP085_NUM_COEFFS]; 
+    __u8 coeffs[BMP085_NUM_COEFFS];
     char errbuf[1024];
 
-    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd, 
+    res = i2c_smbus_read_i2c_block_data(i2c_bus_fd,
                                         BMP085_ADDR_COEFFS,
-                                        BMP085_NUM_COEFFS, 
+                                        BMP085_NUM_COEFFS,
                                         coeffs);
     if (res < 0)
     {
         ERROR ("barometer: BMP085_read_coeffs - problem reading data: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return -1;
     }
-    
+
     bmp085_AC1 = ((int16_t)  coeffs[0]  <<8) | (int16_t)  coeffs[1];
     bmp085_AC2 = ((int16_t)  coeffs[2]  <<8) | (int16_t)  coeffs[3];
     bmp085_AC3 = ((int16_t)  coeffs[4]  <<8) | (int16_t)  coeffs[5];
     bmp085_AC4 = ((uint16_t) coeffs[6]  <<8) | (uint16_t) coeffs[7];
     bmp085_AC5 = ((uint16_t) coeffs[8]  <<8) | (uint16_t) coeffs[9];
     bmp085_AC6 = ((uint16_t) coeffs[10] <<8) | (uint16_t) coeffs[11];
@@ -1244,19 +1237,19 @@
     /* B6, B3 */
     B6 = B5 - 4000;
     X1 = ((bmp085_B2 * ((B6 * B6)>>12)) >> 11 );
     X2 = (((long)bmp085_AC2 * B6) >> 11);
     X3 = X1 + X2;
     B3 = (((((long)bmp085_AC1 * 4) + X3) << bmp085_oversampling) + 2) >> 2;
-    
+
     /* B4 */
     X1 = (((long)bmp085_AC3*B6) >> 13);
     X2 = (bmp085_B1*((B6*B6) >> 12) ) >> 16;
     X3 = ((X1 + X2) + 2 ) >> 2;
     B4 = ((long)bmp085_AC4* (unsigned long)(X3 + 32768)) >> 15;
-    
+
     /* B7, P */
     B7 =  (unsigned long)(adc_pressure - B3)*(50000>>bmp085_oversampling);
     if( B7 < 0x80000000 )
     {
         P = (B7 << 1) / B4;
     }
@@ -1265,21 +1258,21 @@
         P = (B7/B4) << 1;
     }
     X1 = (P >> 8) * (P >> 8);
     X1 = (X1 * 3038) >> 16;
     X2 = ((-7357) * P) >> 16;
     P = P + ( ( X1 + X2 + 3791 ) >> 4);
-    
-    *pressure = P / 100.0; // in [hPa] 
+
+    *pressure = P / 100.0; // in [hPa]
     DEBUG ("barometer: BMP085_convert_adc_to_real - got %lf hPa, %lf C",
            *pressure,
            *temperature);
 }
 
-    
-/** 
+
+/**
  * Read compensated sensor measurements
  *
  * @param pressure    averaged measured pressure
  * @param temperature averaged measured temperature
  *
  * @return Zero when successful
@@ -1305,51 +1298,51 @@
         return 1;
     }
 
     usleep(BMP085_TIME_CNV_TEMP); /* wait for the conversion */
 
     res = i2c_smbus_read_i2c_block_data( i2c_bus_fd,
-                                         BMP085_ADDR_CONV, 
+                                         BMP085_ADDR_CONV,
                                          2,
-                                         measBuff); 
+                                         measBuff);
     if (res < 0)
     {
         ERROR ("barometer: BMP085_read - problem reading temperature data: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return 1;
     }
 
-    adc_temperature = ( (unsigned short)measBuff[0] << 8 ) + measBuff[1]; 
-    
+    adc_temperature = ( (unsigned short)measBuff[0] << 8 ) + measBuff[1];
+
 
     /* get presure */
     res = i2c_smbus_write_byte_data( i2c_bus_fd,
-                                     BMP085_ADDR_CTRL_REG, 
+                                     BMP085_ADDR_CTRL_REG,
                                      bmp085_cmdCnvPress );
     if (res < 0)
     {
         ERROR ("barometer: BMP085_read - problem requesting pressure conversion: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return 1;
     }
 
     usleep(bmp085_timeCnvPress); /* wait for the conversion */
 
     res = i2c_smbus_read_i2c_block_data( i2c_bus_fd,
-                                         BMP085_ADDR_CONV, 
+                                         BMP085_ADDR_CONV,
                                          3,
                                          measBuff );
     if (res < 0)
     {
         ERROR ("barometer: BMP085_read - problem reading pressure data: %s",
                sstrerror (errno, errbuf, sizeof (errbuf)));
         return 1;
     }
 
     adc_pressure = (long)((((ulong)measBuff[0]<<16) | ((ulong)measBuff[1]<<8) | (ulong)measBuff[2] ) >> (8 - bmp085_oversampling));
-    
+
 
     DEBUG ("barometer: BMP085_read - raw pressure ADC value = %ld, " \
            "raw temperature ADC value = %ld",
            adc_pressure,
            adc_temperature);
 
@@ -1358,19 +1351,19 @@
     return 0;
 }
 
 
 
 /* ------------------------ Sensor detection ------------------------ */
-/** 
+/**
  * Detect presence of a supported sensor.
  *
  * As a sideeffect will leave set I2C slave address.
  * The detection is done in the order BMP085, MPL3115, MPL115 and stops after
  * first sensor beeing found.
- * 
+ *
  * @return detected sensor type
  */
 enum Sensor_type Detect_sensor_type(void)
 {
     if(BMP085_detect())
         return Sensor_BMP085;
@@ -1392,13 +1385,13 @@
  * Implemented methods are:
  * - MSLP_NONE - no converions, returns absolute pressure
  *
  * - MSLP_INTERNATIONAL - see http://en.wikipedia.org/wiki/Atmospheric_pressure#Altitude_atmospheric_pressure_variation
  *           Requires #config_altitude
  *
- * - MSLP_DEU_WETT - formula as recommended by the Deutsche Wetterdienst. See 
+ * - MSLP_DEU_WETT - formula as recommended by the Deutsche Wetterdienst. See
  *                http://de.wikipedia.org/wiki/Barometrische_H%C3%B6henformel#Theorie
  *           Requires both #config_altitude and temperature reference(s).
  *
  * @param abs_pressure absloute pressure to be converted
  *
  * @return mean sea level pressure if successful, NAN otherwise
@@ -1420,18 +1413,18 @@
 
     switch(config_normalize)
     {
     case MSLP_NONE:
         mean = abs_pressure;
         break;
-        
+
     case MSLP_INTERNATIONAL:
         mean = abs_pressure / \
             pow(1.0 - 0.0065*config_altitude/288.15, 9.80665*0.0289644/(8.31447*0.0065));
         break;
-        
+
     case MSLP_DEU_WETT:
     {
         double E; /* humidity */
         double x;
         if(temp<9.1)
             E = 5.6402 * (-0.0916 + exp(0.06*temp) );
@@ -1440,34 +1433,34 @@
         x = 9.80665 / (287.05 * (temp+273.15 + 0.12*E + 0.0065*config_altitude/2)) * config_altitude;
         mean = abs_pressure * exp(x);
     }
     break;
 
     default:
-        ERROR ("barometer: abs_to_mean_sea_level_pressure: wrong conversion method %d", 
+        ERROR ("barometer: abs_to_mean_sea_level_pressure: wrong conversion method %d",
                config_normalize);
         mean = abs_pressure;
         break;
     }
 
     DEBUG ("barometer: abs_to_mean_sea_level_pressure: absPressure = %lf hPa, method = %d, meanPressure = %lf hPa",
            abs_pressure,
            config_normalize,
            mean);
 
-    return mean; 
+    return mean;
 }
 
 /* ------------------------ main plugin callbacks ------------------------ */
 
-/** 
+/**
  * Main plugin configuration callback (using simple config)
- * 
+ *
  * @param key   configuration key we should process
  * @param value configuration value we should process
- * 
+ *
  * @return Zero when successful.
  */
 static int collectd_barometer_config (const char *key, const char *value)
 {
     DEBUG("barometer: collectd_barometer_config");
 
@@ -1515,26 +1508,26 @@
         config_press_offset = atof(value);
     }
     else if (strcasecmp (key, "TemperatureOffset") == 0)
     {
         config_temp_offset = atof(value);
     }
-    else 
+    else
     {
         return -1;
     }
 
     return 0;
 }
 
 
-/** 
+/**
  * Shutdown callback.
- * 
+ *
  * Close I2C and delete all the buffers.
- * 
+ *
  * @return Zero when successful (at the moment the only possible outcome)
  */
 static int collectd_barometer_shutdown(void)
 {
     DEBUG ("barometer: collectd_barometer_shutdown");
 
@@ -1554,15 +1547,15 @@
     }
 
     return 0;
 }
 
 
-/** 
+/**
  * Plugin read callback for MPL115.
- * 
+ *
  *  Dispatching will create values:
  *  - <hostname>/barometer-mpl115/pressure-normalized
  *  - <hostname>/barometer-mpl115/pressure-absolute
  *  - <hostname>/barometer-mpl115/temperature
  *
  * @return Zero when successful.
@@ -1574,13 +1567,13 @@
     double pressure        = 0.0;
     double temperature     = 0.0;
     double norm_pressure   = 0.0;
 
     value_list_t vl = VALUE_LIST_INIT;
     value_t      values[1];
-    
+
     DEBUG("barometer: MPL115_collectd_barometer_read");
 
     if (!configured)
     {
         return -1;
     }
@@ -1636,40 +1629,40 @@
     plugin_dispatch_values (&vl);
 
     return 0;
 }
 
 
-/** 
+/**
  * Plugin read callback for MPL3115.
- * 
+ *
  *  Dispatching will create values:
  *  - <hostname>/barometer-mpl3115/pressure-normalized
  *  - <hostname>/barometer-mpl3115/pressure-absolute
  *  - <hostname>/barometer-mpl3115/temperature
  *
  * @return Zero when successful.
  */
 static int MPL3115_collectd_barometer_read (void)
 {
     int result = 0;
-    
+
     double pressure        = 0.0;
     double temperature     = 0.0;
     double norm_pressure   = 0.0;
-    
+
     value_list_t vl = VALUE_LIST_INIT;
     value_t      values[1];
-    
+
     DEBUG("barometer: MPL3115_collectd_barometer_read");
-    
+
     if (!configured)
     {
         return -1;
     }
-    
+
     result = MPL3115_read(&pressure, &temperature);
     if(result)
         return result;
 
     norm_pressure = abs_to_mean_sea_level_pressure(pressure);
 
@@ -1699,40 +1692,40 @@
     plugin_dispatch_values (&vl);
 
     return 0;
 }
 
 
-/** 
+/**
  * Plugin read callback for BMP085.
- * 
+ *
  *  Dispatching will create values:
  *  - <hostname>/barometer-bmp085/pressure-normalized
  *  - <hostname>/barometer-bmp085/pressure-absolute
  *  - <hostname>/barometer-bmp085/temperature
  *
  * @return Zero when successful.
  */
 static int BMP085_collectd_barometer_read (void)
 {
     int result = 0;
-    
+
     double pressure        = 0.0;
     double temperature     = 0.0;
     double norm_pressure   = 0.0;
-    
+
     value_list_t vl = VALUE_LIST_INIT;
     value_t      values[1];
-    
+
     DEBUG("barometer: BMP085_collectd_barometer_read");
-    
+
     if (!configured)
     {
         return -1;
     }
-    
+
     result = BMP085_read(&pressure, &temperature);
     if(result)
         return result;
 
     norm_pressure = abs_to_mean_sea_level_pressure(pressure);
 
@@ -1762,18 +1755,18 @@
     plugin_dispatch_values (&vl);
 
     return 0;
 }
 
 
-/** 
+/**
  * Initialization callback
- * 
+ *
  * Check config, initialize I2C bus access, conversion coefficients and averaging
  * ring buffers
- * 
+ *
  * @return Zero when successful.
  */
 static int collectd_barometer_init (void)
 {
     char errbuf[1024];
 
@@ -1818,38 +1811,38 @@
     switch(sensor_type)
     {
 /* MPL3115 */
     case Sensor_MPL3115:
     {
         MPL3115_adjust_oversampling();
-        
+
         if(MPL3115_init_sensor())
             return -1;
-        
+
         plugin_register_read ("barometer", MPL3115_collectd_barometer_read);
     }
     break;
 
 /* MPL115 */
     case Sensor_MPL115:
     {
         if (averaging_create (&pressure_averaging, config_oversample))
         {
             ERROR("barometer: collectd_barometer_init pressure averaging init failed");
             return -1;
         }
-        
+
         if (averaging_create (&temperature_averaging, config_oversample))
         {
             ERROR("barometer: collectd_barometer_init temperature averaging init failed");
             return -1;
         }
-        
+
         if (MPL115_read_coeffs() < 0)
             return -1;
-        
+
         plugin_register_read ("barometer", MPL115_collectd_barometer_read);
     }
     break;
 
 /* BMP085 */
     case Sensor_BMP085:
@@ -1865,27 +1858,27 @@
 
 /* anything else -> error */
     default:
         ERROR("barometer: collectd_barometer_init - no supported sensor found");
         return -1;
     }
-        
+
 
     configured = 1;
     return 0;
 }
 
 /* ------------------------ plugin register / entry point ------------------------ */
 
-/** 
+/**
  * Plugin "entry" - register all callback.
- * 
+ *
  */
 void module_register (void)
 {
-    plugin_register_config ("barometer", 
-                            collectd_barometer_config, 
-                            config_keys, 
+    plugin_register_config ("barometer",
+                            collectd_barometer_config,
+                            config_keys,
                             config_keys_num);
     plugin_register_init ("barometer", collectd_barometer_init);
     plugin_register_shutdown ("barometer", collectd_barometer_shutdown);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/battery.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/battery.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/battery.c	2015-05-20 20:04:47.179035320 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/battery.c	2016-01-22 17:51:17.693918698 +0800
@@ -553,13 +553,13 @@
 	char buffer[1024];
 
 	FILE *fh;
 
 	ssnprintf (filename, sizeof (filename), "%s/%s/info", dir, power_supply);
 	fh = fopen (filename, "r");
-	if ((fh = fopen (filename, "r")) == NULL)
+	if (fh == NULL)
 		return (errno);
 
 	/* last full capacity:      40090 mWh */
 	while (fgets (buffer, sizeof (buffer), fh) != NULL)
 	{
 		gauge_t *value_ptr;
@@ -612,13 +612,13 @@
 	char buffer[1024];
 
 	FILE *fh;
 
 	ssnprintf (filename, sizeof (filename), "%s/%s/state", dir, power_supply);
 	fh = fopen (filename, "r");
-	if ((fh = fopen (filename, "r")) == NULL)
+	if (fh == NULL)
 	{
 		if ((errno == EAGAIN) || (errno == EINTR) || (errno == ENOENT))
 			return (0);
 		else
 			return (errno);
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/bind.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/bind.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/bind.c	2015-05-20 20:04:47.183035394 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/bind.c	2016-01-22 17:51:17.693918698 +0800
@@ -760,13 +760,13 @@
       break;
   }
 
   xmlFree (zone_name);
   zone_name = NULL;
 
-  if (j >= views->zones_num)
+  if (j >= view->zones_num)
     return (0);
 
   zone_name = view->zones[j];
 
   DEBUG ("bind plugin: bind_xml_stats_handle_zone: Found zone `%s'.",
       zone_name);
@@ -1663,13 +1663,13 @@
   tmp->zones_num = 0;
 
   tmp->name = strdup (ci->values[0].value.string);
   if (tmp->name == NULL)
   {
     ERROR ("bind plugin: strdup failed.");
-    free (tmp);
+    sfree (views);
     return (-1);
   }
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *child = ci->children + i;
@@ -1706,12 +1706,13 @@
       {
         WARNING ("bind plugin: The `Url' option needs "
                  "exactly one string argument.");
         return (-1);
       }
 
+      sfree (url);
       url = strdup (child->values[0].value.string);
     } else if (strcasecmp ("OpCodes", child->key) == 0)
       bind_config_set_bool ("OpCodes", &global_opcodes, child);
     else if (strcasecmp ("QTypes", child->key) == 0)
       bind_config_set_bool ("QTypes", &global_qtypes, child);
     else if (strcasecmp ("ServerStats", child->key) == 0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ceph.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ceph.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ceph.c	2015-05-20 20:04:47.183035394 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ceph.c	2016-01-22 17:51:17.693918698 +0800
@@ -1,9 +1,10 @@
 /**
  * collectd - src/ceph.c
  * Copyright (C) 2011  New Dream Network
+ * Copyright (C) 2015  Florian octo Forster
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; only version 2 of the License is applicable.
  *
  * This program is distributed in the hope that it will be useful, but
@@ -13,15 +14,16 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
  *
  * Authors:
- *   Colin McCabe <cmccabe@alumni.cmu.edu>
- *   Dennis Zou <yunzou@cisco.com>
- *   Dan Ryder <daryder@cisco.com>
+ *   Colin McCabe <cmccabe at alumni.cmu.edu>
+ *   Dennis Zou <yunzou at cisco.com>
+ *   Dan Ryder <daryder at cisco.com>
+ *   Florian octo Forster <octo at collectd.org>
  **/
 
 #define _DEFAULT_SOURCE
 #define _BSD_SOURCE
 
 #include "collectd.h"
@@ -130,17 +132,16 @@
 
 /** Track state and handler while parsing JSON */
 struct yajl_struct
 {
     node_handler_t handler;
     void * handler_arg;
-    struct {
-      char key[DATA_MAX_NAME_LEN];
-      int key_len;
-    } state[YAJL_MAX_DEPTH];
-    int depth;
+
+    char *key;
+    char *stack[YAJL_MAX_DEPTH];
+    size_t depth;
 };
 typedef struct yajl_struct yajl_struct;
 
 enum perfcounter_type_d
 {
     PERFCOUNTER_LATENCY = 0x4, PERFCOUNTER_DERIVE = 0x8,
@@ -253,116 +254,144 @@
 
 static int ceph_cb_boolean(void *ctx, int bool_val)
 {
     return CEPH_CB_CONTINUE;
 }
 
+#define BUFFER_ADD(dest, src) do { \
+    size_t dest_size = sizeof (dest); \
+    strncat ((dest), (src), dest_size - strlen (dest)); \
+    (dest)[dest_size - 1] = 0; \
+} while (0)
+
 static int
 ceph_cb_number(void *ctx, const char *number_val, yajl_len_t number_len)
 {
-    yajl_struct *yajl = (yajl_struct*)ctx;
+    yajl_struct *state = (yajl_struct*) ctx;
     char buffer[number_len+1];
-    int i, latency_type = 0, result;
-    char key[128];
+    char key[2 * DATA_MAX_NAME_LEN];
+    _Bool latency_type = 0;
+    size_t i;
+    int status;
 
     memcpy(buffer, number_val, number_len);
     buffer[sizeof(buffer) - 1] = 0;
 
-    ssnprintf(key, yajl->state[0].key_len, "%s", yajl->state[0].key);
-    for(i = 1; i < yajl->depth; i++)
+    memset (key, 0, sizeof (key));
+    for (i = 0; i < state->depth; i++)
+    {
+        if (state->stack[i] == NULL)
+            continue;
+
+        if (strlen (key) != 0)
+            BUFFER_ADD (key, ".");
+        BUFFER_ADD (key, state->stack[i]);
+    }
+
+    /* Special case for latency metrics. */
+    if ((strcmp ("avgcount", state->key) == 0)
+        || (strcmp ("sum", state->key) == 0))
     {
-        if((i == yajl->depth-1) && ((strcmp(yajl->state[i].key,"avgcount") == 0)
-                || (strcmp(yajl->state[i].key,"sum") == 0)))
+        latency_type = 1;
+
+        /* Super-special case for filestore.journal_wr_bytes.avgcount: For
+         * some reason, Ceph schema encodes this as a count/sum pair while all
+         * other "Bytes" data (excluding used/capacity bytes for OSD space) uses
+         * a single "Derive" type. To spare further confusion, keep this KPI as
+         * the same type of other "Bytes". Instead of keeping an "average" or
+         * "rate", use the "sum" in the pair and assign that to the derive
+         * value. */
+        if (convert_special_metrics && (state->depth >= 2)
+            && (strcmp("filestore", state->stack[state->depth - 2]) == 0)
+            && (strcmp("journal_wr_bytes", state->stack[state->depth - 1]) == 0)
+            && (strcmp("avgcount", state->key) == 0))
         {
-            if(convert_special_metrics)
-            {
-                /**
-                 * Special case for filestore:JournalWrBytes. For some reason,
-                 * Ceph schema encodes this as a count/sum pair while all
-                 * other "Bytes" data (excluding used/capacity bytes for OSD
-                 * space) uses a single "Derive" type. To spare further
-                 * confusion, keep this KPI as the same type of other "Bytes".
-                 * Instead of keeping an "average" or "rate", use the "sum" in
-                 * the pair and assign that to the derive value.
-                 */
-                if((strcmp(yajl->state[i-1].key, "journal_wr_bytes") == 0) &&
-                        (strcmp(yajl->state[i-2].key,"filestore") == 0) &&
-                        (strcmp(yajl->state[i].key,"avgcount") == 0))
-                {
-                    DEBUG("ceph plugin: Skipping avgcount for filestore.JournalWrBytes");
-                    yajl->depth = (yajl->depth - 1);
-                    return CEPH_CB_CONTINUE;
-                }
-            }
-            //probably a avgcount/sum pair. if not - we'll try full key later
-            latency_type = 1;
-            break;
+            DEBUG("ceph plugin: Skipping avgcount for filestore.JournalWrBytes");
+            return CEPH_CB_CONTINUE;
         }
-        strncat(key, ".", 1);
-        strncat(key, yajl->state[i].key, yajl->state[i].key_len+1);
+    }
+    else /* not a latency type */
+    {
+        BUFFER_ADD (key, ".");
+        BUFFER_ADD (key, state->key);
     }
 
-    result = yajl->handler(yajl->handler_arg, buffer, key);
-
-    if((result == RETRY_AVGCOUNT) && latency_type)
+    status = state->handler(state->handler_arg, buffer, key);
+    if((status == RETRY_AVGCOUNT) && latency_type)
     {
-        strncat(key, ".", 1);
-        strncat(key, yajl->state[yajl->depth-1].key,
-                yajl->state[yajl->depth-1].key_len+1);
-        result = yajl->handler(yajl->handler_arg, buffer, key);
+        /* Add previously skipped part of the key, either "avgcount" or "sum",
+         * and try again. */
+        BUFFER_ADD (key, ".");
+        BUFFER_ADD (key, state->key);
+
+        status = state->handler(state->handler_arg, buffer, key);
     }
 
-    if(result == -ENOMEM)
+    if (status != 0)
     {
-        ERROR("ceph plugin: memory allocation failed");
+        ERROR("ceph plugin: JSON handler failed with status %d.", status);
         return CEPH_CB_ABORT;
     }
 
-    yajl->depth = (yajl->depth - 1);
     return CEPH_CB_CONTINUE;
 }
 
 static int ceph_cb_string(void *ctx, const unsigned char *string_val,
         yajl_len_t string_len)
 {
     return CEPH_CB_CONTINUE;
 }
 
 static int ceph_cb_start_map(void *ctx)
 {
+    yajl_struct *state = (yajl_struct*) ctx;
+
+    /* Push key to the stack */
+    if (state->depth == YAJL_MAX_DEPTH)
+        return CEPH_CB_ABORT;
+
+    state->stack[state->depth] = state->key;
+    state->depth++;
+    state->key = NULL;
+
     return CEPH_CB_CONTINUE;
 }
 
-static int
-ceph_cb_map_key(void *ctx, const unsigned char *key, yajl_len_t string_len)
+static int ceph_cb_end_map(void *ctx)
 {
-    yajl_struct *yajl = (yajl_struct*)ctx;
+    yajl_struct *state = (yajl_struct*) ctx;
 
-    if((yajl->depth+1)  >= YAJL_MAX_DEPTH)
-    {
-        ERROR("ceph plugin: depth exceeds max, aborting.");
+    /* Pop key from the stack */
+    if (state->depth == 0)
         return CEPH_CB_ABORT;
-    }
-
-    char buffer[string_len+1];
-
-    memcpy(buffer, key, string_len);
-    buffer[sizeof(buffer) - 1] = 0;
 
-    snprintf(yajl->state[yajl->depth].key, sizeof(buffer), "%s", buffer);
-    yajl->state[yajl->depth].key_len = sizeof(buffer);
-    yajl->depth = (yajl->depth + 1);
+    sfree (state->key);
+    state->depth--;
+    state->key = state->stack[state->depth];
+    state->stack[state->depth] = NULL;
 
     return CEPH_CB_CONTINUE;
 }
 
-static int ceph_cb_end_map(void *ctx)
+static int
+ceph_cb_map_key(void *ctx, const unsigned char *key, yajl_len_t string_len)
 {
-    yajl_struct *yajl = (yajl_struct*)ctx;
+    yajl_struct *state = (yajl_struct*) ctx;
+    size_t sz = ((size_t) string_len) + 1;
+
+    sfree (state->key);
+    state->key = malloc (sz);
+    if (state->key == NULL)
+    {
+        ERROR ("ceph plugin: malloc failed.");
+        return CEPH_CB_ABORT;
+    }
+
+    memmove (state->key, key, sz - 1);
+    state->key[sz - 1] = 0;
 
-    yajl->depth = (yajl->depth - 1);
     return CEPH_CB_CONTINUE;
 }
 
 static int ceph_cb_start_array(void *ctx)
 {
     return CEPH_CB_CONTINUE;
@@ -417,146 +446,146 @@
     }
     sfree(d->ds_types);
     sfree(d->ds_names);
     sfree(d);
 }
 
-/**
- * Compact ds name by removing special characters and trimming length to
- * DATA_MAX_NAME_LEN if necessary
- */
-static void compact_ds_name(char *source, char *dest)
+/* compact_ds_name removed the special characters ":", "_", "-" and "+" from the
+ * intput string. Characters following these special characters are capitalized.
+ * Trailing "+" and "-" characters are replaces with the strings "Plus" and
+ * "Minus". */
+static int compact_ds_name (char *buffer, size_t buffer_size, char const *src)
 {
-    int keys_num = 0, i;
-    char *save_ptr = NULL, *tmp_ptr = source;
-    char *keys[16];
-    char len_str[3];
-    char tmp[DATA_MAX_NAME_LEN];
-    size_t key_chars_remaining = (DATA_MAX_NAME_LEN-1);
-    int reserved = 0;
-    int offset = 0;
-    memset(tmp, 0, sizeof(tmp));
-    if(source == NULL || dest == NULL || source[0] == '\0' || dest[0] != '\0')
-    {
-        return;
-    }
-    size_t src_len = strlen(source);
-    snprintf(len_str, sizeof(len_str), "%zu", src_len);
-    unsigned char append_status = 0x0;
-    append_status |= (source[src_len - 1] == '-') ? 0x1 : 0x0;
-    append_status |= (source[src_len - 1] == '+') ? 0x2 : 0x0;
-    while ((keys[keys_num] = strtok_r(tmp_ptr, ":_-+", &save_ptr)) != NULL)
-    {
-        tmp_ptr = NULL;
-        /** capitalize 1st char **/
-        keys[keys_num][0] = toupper(keys[keys_num][0]);
-        keys_num++;
-        if(keys_num >= 16)
-        {
-            break;
-        }
-    }
-    /** concatenate each part of source string **/
-    for(i = 0; i < keys_num; i++)
-    {
-        strncat(tmp, keys[i], key_chars_remaining);
-        key_chars_remaining -= strlen(keys[i]);
-    }
-    tmp[DATA_MAX_NAME_LEN - 1] = '\0';
-    /** to coordinate limitation of length of type_instance
-     *  we will truncate ds_name
-     *  when the its length is more than
-     *  DATA_MAX_NAME_LEN
-     */
-    if(strlen(tmp) > DATA_MAX_NAME_LEN - 1)
+    char *src_copy;
+    size_t src_len;
+    char *ptr = buffer;
+    size_t ptr_size = buffer_size;
+    _Bool append_plus = 0;
+    _Bool append_minus = 0;
+
+    if ((buffer == NULL) || (buffer_size <= strlen ("Minus")) || (src == NULL))
+      return EINVAL;
+
+    src_copy = strdup (src);
+    src_len = strlen(src);
+
+    /* Remove trailing "+" and "-". */
+    if (src_copy[src_len - 1] == '+')
     {
-        append_status |= 0x4;
-        /** we should reserve space for
-         * len_str
-         */
-        reserved += 2;
+        append_plus = 1;
+        src_len--;
+        src_copy[src_len] = 0;
     }
-    if(append_status & 0x1)
+    else if (src_copy[src_len - 1] == '-')
     {
-        /** we should reserve space for
-         * "Minus"
-         */
-        reserved += 5;
+        append_minus = 1;
+        src_len--;
+        src_copy[src_len] = 0;
     }
-    if(append_status & 0x2)
+
+    /* Split at special chars, capitalize first character, append to buffer. */
+    char *dummy = src_copy;
+    char *token;
+    char *save_ptr = NULL;
+    while ((token = strtok_r (dummy, ":_-+", &save_ptr)) != NULL)
     {
-        /** we should reserve space for
-         * "Plus"
-         */
-        reserved += 4;
+        size_t len;
+
+        dummy = NULL;
+
+        token[0] = toupper ((int) token[0]);
+
+        assert (ptr_size > 1);
+
+        len = strlen (token);
+        if (len >= ptr_size)
+            len = ptr_size - 1;
+
+        assert (len > 0);
+        assert (len < ptr_size);
+
+        sstrncpy (ptr, token, len + 1);
+        ptr += len;
+        ptr_size -= len;
+
+        assert (*ptr == 0);
+        if (ptr_size <= 1)
+            break;
     }
-    snprintf(dest, DATA_MAX_NAME_LEN - reserved, "%s", tmp);
-    offset = strlen(dest);
-    switch (append_status)
+
+    /* Append "Plus" or "Minus" if "+" or "-" has been stripped above. */
+    if (append_plus || append_minus)
     {
-        case 0x1:
-            memcpy(dest + offset, "Minus", 5);
-            break;
-        case 0x2:
-            memcpy(dest + offset, "Plus", 5);
-            break;
-        case 0x4:
-            memcpy(dest + offset, len_str, 2);
-            break;
-        case 0x5:
-            memcpy(dest + offset, "Minus", 5);
-            memcpy(dest + offset + 5, len_str, 2);
-            break;
-        case 0x6:
-            memcpy(dest + offset, "Plus", 4);
-            memcpy(dest + offset + 4, len_str, 2);
-            break;
-        default:
-            break;
+        char const *append = "Plus";
+        if (append_minus)
+            append = "Minus";
+
+        size_t offset = buffer_size - (strlen (append) + 1);
+        if (offset > strlen (buffer))
+            offset = strlen (buffer);
+
+        sstrncpy (buffer + offset, append, buffer_size - offset);
     }
+
+    sfree (src_copy);
+    return 0;
+}
+
+static _Bool has_suffix (char const *str, char const *suffix)
+{
+    size_t str_len = strlen (str);
+    size_t suffix_len = strlen (suffix);
+    size_t offset;
+
+    if (suffix_len > str_len)
+        return 0;
+    offset = str_len - suffix_len;
+
+    if (strcmp (str + offset, suffix) == 0)
+        return 1;
+
+    return 0;
+}
+
+/* count_parts returns the number of elements a "foo.bar.baz" style key has. */
+static size_t count_parts (char const *key)
+{
+    char const *ptr;
+    size_t parts_num = 0;
+
+    for (ptr = key; ptr != NULL; ptr = strchr (ptr + 1, '.'))
+        parts_num++;
+
+    return parts_num;
 }
 
 /**
  * Parse key to remove "type" if this is for schema and initiate compaction
  */
-static int parse_keys(const char *key_str, char *ds_name)
+static int parse_keys (char *buffer, size_t buffer_size, const char *key_str)
 {
-    char *ptr, *rptr;
-    size_t ds_name_len = 0;
-    /**
-     * allow up to 100 characters before compaction - compact_ds_name will not
-     * allow more than DATA_MAX_NAME_LEN chars
-     */
-    int max_str_len = 100;
-    char tmp_ds_name[max_str_len];
-    memset(tmp_ds_name, 0, sizeof(tmp_ds_name));
-    if(ds_name == NULL || key_str == NULL ||  key_str[0] == '\0' ||
-                                                            ds_name[0] != '\0')
-    {
-        return -1;
-    }
-    if((ptr = strchr(key_str, '.')) == NULL
-            || (rptr = strrchr(key_str, '.')) == NULL)
+    char tmp[2 * buffer_size];
+
+    if (buffer == NULL || buffer_size == 0 || key_str == NULL || strlen (key_str) == 0)
+        return EINVAL;
+
+    if ((count_parts (key_str) > 2) && has_suffix (key_str, ".type"))
     {
-        memcpy(tmp_ds_name, key_str, max_str_len - 1);
-        goto compact;
-    }
+        /* strip ".type" suffix iff the key has more than two parts. */
+        size_t sz = strlen (key_str) - strlen (".type") + 1;
 
-    ds_name_len = (rptr - ptr) > max_str_len ? max_str_len : (rptr - ptr);
-    if((ds_name_len == 0) || strncmp(rptr + 1, "type", 4))
-    { /** copy whole key **/
-        memcpy(tmp_ds_name, key_str, max_str_len - 1);
+        if (sz > sizeof (tmp))
+            sz = sizeof (tmp);
+        sstrncpy (tmp, key_str, sz);
     }
     else
-    {/** more than two keys **/
-        memcpy(tmp_ds_name, key_str, ((rptr - key_str) > (max_str_len - 1) ?
-                (max_str_len - 1) : (rptr - key_str)));
+    {
+        sstrncpy (tmp, key_str, sizeof (tmp));
     }
 
-    compact: compact_ds_name(tmp_ds_name, ds_name);
-    return 0;
+    return compact_ds_name (buffer, buffer_size, tmp);
 }
 
 /**
  * while parsing ceph admin socket schema, save counter name and type for later
  * data processing
  */
@@ -602,13 +631,13 @@
     }
 
     type = (pc_type & PERFCOUNTER_DERIVE) ? DSET_RATE :
             ((pc_type & PERFCOUNTER_LATENCY) ? DSET_LATENCY : DSET_BYTES);
     d->ds_types[d->ds_num] = type;
 
-    if(parse_keys(name, ds_name))
+    if (parse_keys(ds_name, sizeof (ds_name), name))
     {
         return 1;
     }
 
     sstrncpy(d->ds_names[d->ds_num], ds_name, DATA_MAX_NAME_LEN -1);
     d->ds_num = (d->ds_num + 1);
@@ -654,13 +683,14 @@
     return 0;
 }
 
 static int cc_add_daemon_config(oconfig_item_t *ci)
 {
     int ret, i;
-    struct ceph_daemon *array, *nd, cd;
+    struct ceph_daemon *nd, cd;
+    struct ceph_daemon **tmp;
     memset(&cd, 0, sizeof(struct ceph_daemon));
 
     if((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING))
     {
         WARNING("ceph plugin: `Daemon' blocks need exactly one string "
                 "argument.");
@@ -706,27 +736,27 @@
     {
         ERROR("ceph plugin(name=%s): administrative socket paths must begin "
                 "with '/' or './' Can't parse: '%s'\n", cd.name, cd.asok_path);
         return -EINVAL;
     }
 
-    array = realloc(g_daemons,
-                    sizeof(struct ceph_daemon *) * (g_num_daemons + 1));
-    if(array == NULL)
+    tmp = realloc(g_daemons, (g_num_daemons+1) * sizeof(*g_daemons));
+    if(tmp == NULL)
     {
         /* The positive return value here indicates that this is a
          * runtime error, not a configuration error.  */
         return ENOMEM;
     }
-    g_daemons = (struct ceph_daemon**) array;
-    nd = malloc(sizeof(struct ceph_daemon));
+    g_daemons = tmp;
+
+    nd = malloc(sizeof(*nd));
     if(!nd)
     {
         return ENOMEM;
     }
-    memcpy(nd, &cd, sizeof(struct ceph_daemon));
+    memcpy(nd, &cd, sizeof(*nd));
     g_daemons[g_num_daemons++] = nd;
     return 0;
 }
 
 static int ceph_config(oconfig_item_t *ci)
 {
@@ -953,13 +983,13 @@
     uint32_t type = DSET_TYPE_UNFOUND;
     int index = vtmp->index;
 
     char ds_name[DATA_MAX_NAME_LEN];
     memset(ds_name, 0, sizeof(ds_name));
 
-    if(parse_keys(key, ds_name))
+    if (parse_keys (ds_name, sizeof (ds_name), key))
     {
         return 1;
     }
 
     if(index >= vtmp->d->ds_num)
     {
@@ -1079,21 +1109,23 @@
     RETRY_ON_EINTR(err,
         connect(fd, (struct sockaddr *) &address, sizeof(struct sockaddr_un)));
     if(err < 0)
     {
         ERROR("ceph plugin: cconn_connect: connect(%d) failed: error %d",
             fd, err);
+        close(fd);
         return err;
     }
 
     flags = fcntl(fd, F_GETFL, 0);
     if(fcntl(fd, F_SETFL, flags | O_NONBLOCK) != 0)
     {
         err = -errno;
         ERROR("ceph plugin: cconn_connect: fcntl(%d, O_NONBLOCK) error %d",
             fd, err);
+        close(fd);
         return err;
     }
     io->asok = fd;
     io->state = CSTATE_WRITE_REQUEST;
     io->amt = 0;
     io->json_len = 0;
@@ -1575,6 +1607,7 @@
 {
     plugin_register_complex_config("ceph", ceph_config);
     plugin_register_init("ceph", ceph_init);
     plugin_register_read("ceph", ceph_read);
     plugin_register_shutdown("ceph", ceph_shutdown);
 }
+/* vim: set sw=4 sts=4 et : */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src: ceph_test.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd.1	2015-03-10 22:29:57.236961731 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd.1	2016-01-22 17:56:33.217659233 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD 1"
-.TH COLLECTD 1 "2015-03-10" "5.4.1.805.g42e4d6c" "collectd"
+.TH COLLECTD 1 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd \- System statistics collection daemon
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd.conf.5	2015-05-21 04:02:32.956552499 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd.conf.5	2016-01-22 17:56:33.797658943 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD.CONF 5"
-.TH COLLECTD.CONF 5 "2015-05-20" "5.4.2.911.g0c88d3b" "collectd"
+.TH COLLECTD.CONF 5 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd.conf \- Configuration for the system statistics collection daemon collectd
@@ -280,18 +280,33 @@
 plugins that don't provide any configuration, e.g. the \fILoad plugin\fR.
 .IP "\fBCollectInternalStats\fR \fBfalse\fR|\fBtrue\fR" 4
 .IX Item "CollectInternalStats false|true"
 When set to \fBtrue\fR, various statistics about the \fIcollectd\fR daemon will be
 collected, with \*(L"collectd\*(R" as the \fIplugin name\fR. Defaults to \fBfalse\fR.
 .Sp
-The \*(L"write_queue\*(R" \fIplugin instance\fR reports the number of elements currently
-queued and the number of elements dropped off the queue by the
-\&\fBWriteQueueLimitLow\fR/\fBWriteQueueLimitHigh\fR mechanism.
-.Sp
-The \*(L"cache\*(R" \fIplugin instance\fR reports the number of elements in the value list
-cache (the cache you can interact with using \fIcollectd\-unixsock\fR\|(5)).
+The following metrics are reported:
+.RS 4
+.ie n .IP """collectd\-write_queue/queue_length""" 4
+.el .IP "\f(CWcollectd\-write_queue/queue_length\fR" 4
+.IX Item "collectd-write_queue/queue_length"
+The number of metrics currently in the write queue. You can limit the queue
+length with the \fBWriteQueueLimitLow\fR and \fBWriteQueueLimitHigh\fR options.
+.ie n .IP """collectd\-write_queue/derive\-dropped""" 4
+.el .IP "\f(CWcollectd\-write_queue/derive\-dropped\fR" 4
+.IX Item "collectd-write_queue/derive-dropped"
+The number of metrics dropped due to a queue length limitation.
+If this value is non-zero, your system can't handle all incoming metrics and
+protects itself against overload by dropping metrics.
+.ie n .IP """collectd\-cache/cache_size""" 4
+.el .IP "\f(CWcollectd\-cache/cache_size\fR" 4
+.IX Item "collectd-cache/cache_size"
+The number of elements in the metric cache (the cache you can interact with
+using \fIcollectd\-unixsock\fR\|(5)).
+.RE
+.RS 4
+.RE
 .IP "\fBInclude\fR \fIPath\fR [\fIpattern\fR]" 4
 .IX Item "Include Path [pattern]"
 If \fIPath\fR points to a file, includes that file. If \fIPath\fR points to a
 directory, recursively includes all files within that directory and its
 subdirectories. If the \f(CW\*(C`wordexp\*(C'\fR function is available on your system,
 shell-like wildcards are expanded before files are included. This means you can
@@ -616,13 +631,13 @@
 Boolean options for enabling calculation of the number of value lists, their
 sum, average, minimum, maximum and\ / or standard deviation. All options
 are disabled by default.
 .ie n .SS "Plugin ""amqp"""
 .el .SS "Plugin \f(CWamqp\fP"
 .IX Subsection "Plugin amqp"
-The \fI\s-1AMQMP\s0 plugin\fR can be used to communicate with other instances of
+The \fI\s-1AMQP\s0 plugin\fR can be used to communicate with other instances of
 \&\fIcollectd\fR or third party applications using an \s-1AMQP\s0 message broker. Values
 are sent to or received from the broker, which handles routing, queueing and
 possibly filtering or messages.
 .PP
 .Vb 10
 \& <Plugin "amqp">
@@ -1520,13 +1535,13 @@
 network connection will stall one read thread. Adjust the \fBReadThreads\fR global
 setting accordingly to prevent this from blocking other plugins.
 .ie n .SS "Plugin ""curl_json"""
 .el .SS "Plugin \f(CWcurl_json\fP"
 .IX Subsection "Plugin curl_json"
 The \fBcurl_json plugin\fR collects values from \s-1JSON\s0 data to be parsed by
-\&\fBlibyajl\fR (<http://www.lloydforge.org/projects/yajl/>) retrieved via
+\&\fBlibyajl\fR (<https://lloyd.github.io/yajl/>) retrieved via
 either \fBlibcurl\fR (<http://curl.haxx.se/>) or read directly from a
 unix socket. The former can be used, for example, to collect values
 from CouchDB documents (which are stored \s-1JSON\s0 notation), and the
 latter to collect values from a uWSGI stats socket.
 .PP
 The following example will collect several values from the built-in
@@ -2185,13 +2200,13 @@
 programs executed, i.\ e. the data passed to them and the response
 expected from them. This is documented in great detail in \fIcollectd\-exec\fR\|(5).
 .ie n .SS "Plugin ""fhcount"""
 .el .SS "Plugin \f(CWfhcount\fP"
 .IX Subsection "Plugin fhcount"
 The \f(CW\*(C`fhcount\*(C'\fR plugin provides statistics about used, unused and total number of
-file handles.
+file handles on Linux.
 .PP
 The \fIfhcount plugin\fR provides the following configuration options:
 .IP "\fBValuesAbsolute\fR \fBtrue\fR|\fBfalse\fR" 4
 .IX Item "ValuesAbsolute true|false"
 Enables or disables reporting of file handles usage in absolute numbers,
 e.g. file handles used. Defaults to \fBtrue\fR.
@@ -2371,12 +2386,30 @@
 similar interfaces. Thus, you can use the \fBInterface\fR\-option to pick the
 interfaces you're interested in. Sometimes, however, it's easier/preferred
 to collect all interfaces \fIexcept\fR a few ones. This option enables you to
 do that: By setting \fBIgnoreSelected\fR to \fItrue\fR the effect of
 \&\fBInterface\fR is inverted: All selected interfaces are ignored and all
 other interfaces are collected.
+.Sp
+It is possible to use regular expressions to match interface names, if the
+name is surrounded by \fI/.../\fR and collectd was compiled with support for
+regexps. This is useful if there's a need to collect (or ignore) data
+for a group of interfaces that are similarly named, without the need to
+explicitly list all of them (especially useful if the list is dynamic).
+Example:
+.Sp
+.Vb 4
+\& Interface "lo"
+\& Interface "/^veth/"
+\& Interface "/^tun[0\-9]+/"
+\& IgnoreSelected "true"
+.Ve
+.Sp
+This will ignore the loopback interface, all interfaces with names starting
+with \fIveth\fR and all interfaces with names starting with \fItun\fR followed by
+at least one digit.
 .ie n .SS "Plugin ""ipmi"""
 .el .SS "Plugin \f(CWipmi\fP"
 .IX Subsection "Plugin ipmi"
 .IP "\fBSensor\fR \fISensor\fR" 4
 .IX Item "Sensor Sensor"
 Selects sensors to collect or to ignore, depending on \fBIgnoreSelected\fR.
@@ -2400,15 +2433,21 @@
 a notification is sent.
 .ie n .SS "Plugin ""iptables"""
 .el .SS "Plugin \f(CWiptables\fP"
 .IX Subsection "Plugin iptables"
 .IP "\fBChain\fR \fITable\fR \fIChain\fR [\fIComment|Number\fR [\fIName\fR]]" 4
 .IX Item "Chain Table Chain [Comment|Number [Name]]"
-Select the rules to count. If only \fITable\fR and \fIChain\fR are given, this plugin
-will collect the counters of all rules which have a comment-match. The comment
-is then used as type-instance.
+.PD 0
+.IP "\fBChain6\fR \fITable\fR \fIChain\fR [\fIComment|Number\fR [\fIName\fR]]" 4
+.IX Item "Chain6 Table Chain [Comment|Number [Name]]"
+.PD
+Select the iptables/ip6tables filter rules to count packets and bytes from.
+.Sp
+If only \fITable\fR and \fIChain\fR are given, this plugin will collect the counters
+of all rules which have a comment-match. The comment is then used as
+type-instance.
 .Sp
 If \fIComment\fR or \fINumber\fR is given, only the rule with the matching comment or
 the \fIn\fRth rule will be collected. Again, the comment (or the number) will be
 used as the type-instance.
 .Sp
 If \fIName\fR is supplied, it will be used as the type-instance instead of the
@@ -3928,12 +3967,23 @@
 with the hostname.
 .Sp
 Default: \f(CW\*(C`Collectd notify: %s@%s\*(C'\fR
 .ie n .SS "Plugin ""ntpd"""
 .el .SS "Plugin \f(CWntpd\fP"
 .IX Subsection "Plugin ntpd"
+The \f(CW\*(C`ntpd\*(C'\fR plugin collects per-peer ntpd data such as time offset and time
+dispersion.
+.PP
+For talking to \fBntpd\fR, it mimics what the \fBntpdc\fR control program does on
+wire \- using \fBmode 7\fR specific requests. This mode is deprecated with
+newer \fBntpd\fR releases (4.2.7p230 and later). For the \f(CW\*(C`ntpd\*(C'\fR plugin to work
+correctly with them, the ntp daemon must be explicitly configured to
+enable \fBmode 7\fR (which is disabled by default). Refer to the \fI\fIntp.conf\fI\|(5)\fR
+manual page for details.
+.PP
+Available configuration options for the \f(CW\*(C`ntpd\*(C'\fR plugin:
 .IP "\fBHost\fR \fIHostname\fR" 4
 .IX Item "Host Hostname"
 Hostname of the host running \fBntpd\fR. Defaults to \fBlocalhost\fR.
 .IP "\fBPort\fR \fIPort\fR" 4
 .IX Item "Port Port"
 UDP-Port to connect to. Defaults to \fB123\fR.
@@ -6304,12 +6354,16 @@
 \&\fBhostname\fR means to use the global \fBHostname\fR setting, which is probably not
 useful on its own because all guests will appear to have the same name.
 .Sp
 You can also specify combinations of these fields. For example \fBname uuid\fR
 means to concatenate the guest name and \s-1UUID \s0(with a literal colon character
 between, thus \fI\*(L"foo:1234\-1234\-1234\-1234\*(R"\fR).
+.Sp
+At the moment of writing (collectd\-5.5), hostname string is limited to 62
+characters. In case when combination of fields exceeds 62 characters,
+hostname will be truncated without a warning.
 .IP "\fBInterfaceFormat\fR \fBname\fR|\fBaddress\fR" 4
 .IX Item "InterfaceFormat name|address"
 When the virt plugin logs interface data, it sets the name of the collected
 data according to this setting. The default is to use the path as provided by
 the hypervisor (the \*(L"dev\*(R" property of the target node), which is equal to
 setting \fBname\fR.
@@ -6320,12 +6374,16 @@
 .IX Item "PluginInstanceFormat name|uuid"
 When the virt plugin logs data, it sets the plugin_instance of the collected
 data according to this setting. The default is to use the guest name as provided
 by the hypervisor, which is equal to setting \fBname\fR.
 .Sp
 \&\fBuuid\fR means use the guest's \s-1UUID.\s0
+.Sp
+You can also specify combinations of these fields. For example \fBname uuid\fR
+means to concatenate the guest name and \s-1UUID \s0(with a literal colon character
+between, thus \fI\*(L"foo:1234\-1234\-1234\-1234\*(R"\fR).
 .ie n .SS "Plugin ""vmem"""
 .el .SS "Plugin \f(CWvmem\fP"
 .IX Subsection "Plugin vmem"
 The \f(CW\*(C`vmem\*(C'\fR plugin collects information about the usage of virtual memory.
 Since the statistics provided by the Linux kernel are very detailed, they are
 collected very detailed. However, to get all the details, you have to switch
@@ -6732,13 +6790,13 @@
 \&    </Node>
 \&  </Plugin>
 .Ve
 .PP
 Values are submitted to \fISorted Sets\fR, using the metric name as the key, and
 the timestamp as the score. Retrieving a date range can then be done using the
-\&\f(CW\*(C`ZRANGEBYSCORE\*(C'\fR \fIRedis\fR command. Additionnally, all the identifiers of these
+\&\f(CW\*(C`ZRANGEBYSCORE\*(C'\fR \fIRedis\fR command. Additionally, all the identifiers of these
 \&\fISorted Sets\fR are kept in a \fISet\fR called \f(CW\*(C`collectd/values\*(C'\fR and can be
 retrieved using the \f(CW\*(C`SMEMBERS\*(C'\fR \fIRedis\fR command. See
 <http://redis.io/commands#sorted_set> and <http://redis.io/commands#set> for
 details.
 .PP
 The information shown in the synopsis above is the \fIdefault configuration\fR
@@ -6747,15 +6805,15 @@
 The plugin can send values to multiple instances of \fIRedis\fR by specifying
 one \fBNode\fR block for each instance. Within the \fBNode\fR blocks, the following
 options are available:
 .IP "\fBNode\fR \fINodename\fR" 4
 .IX Item "Node Nodename"
 The \fBNode\fR block identifies a new \fIRedis\fR node, that is a new \fIRedis\fR
-instance running in an specified host and port. The name for node is a
+instance running on a specified host and port. The node name is a
 canonical identifier which is used as \fIplugin instance\fR. It is limited to
-64\ characters in length.
+51\ characters in length.
 .IP "\fBHost\fR \fIHostname\fR" 4
 .IX Item "Host Hostname"
 The \fBHost\fR option is the hostname or IP-address where the \fIRedis\fR instance is
 running on.
 .IP "\fBPort\fR \fIPort\fR" 4
 .IX Item "Port Port"
@@ -6831,13 +6889,13 @@
 .Sp
 This will be reflected in the \f(CW\*(C`ds_type\*(C'\fR tag: If \fBStoreRates\fR is enabled,
 converted values will have \*(L"rate\*(R" appended to the data source type, e.g.
 \&\f(CW\*(C`ds_type:derive:rate\*(C'\fR.
 .IP "\fBAlwaysAppendDS\fR \fBfalse\fR|\fBtrue\fR" 4
 .IX Item "AlwaysAppendDS false|true"
-If set the \fBtrue\fR, append the name of the \fIData Source\fR (\s-1DS\s0) to the
+If set to \fBtrue\fR, append the name of the \fIData Source\fR (\s-1DS\s0) to the
 \&\*(L"service\*(R", i.e. the field that, together with the \*(L"host\*(R" field, uniquely
 identifies a metric in \fIRiemann\fR. If set to \fBfalse\fR (the default), this is
 only done when there is more than one \s-1DS.\s0
 .IP "\fBTTLFactor\fR \fIFactor\fR" 4
 .IX Item "TTLFactor Factor"
 \&\fIRiemann\fR events have a \fITime to Live\fR (\s-1TTL\s0) which specifies how long each
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd.conf.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd.conf.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd.conf.in	2015-05-20 20:05:42.672060002 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd.conf.in	2016-01-22 17:51:17.697918694 +0800
@@ -96,15 +96,15 @@
 #@BUILD_PLUGIN_AQUAERO_TRUE@LoadPlugin aquaero
 #@BUILD_PLUGIN_ASCENT_TRUE@LoadPlugin ascent
 #@BUILD_PLUGIN_BAROMETER_TRUE@LoadPlugin barometer
 #@BUILD_PLUGIN_BATTERY_TRUE@LoadPlugin battery
 #@BUILD_PLUGIN_BIND_TRUE@LoadPlugin bind
 #@BUILD_PLUGIN_CEPH_TRUE@LoadPlugin ceph
+#@BUILD_PLUGIN_CGROUPS_TRUE@LoadPlugin cgroups
 #@BUILD_PLUGIN_CONNTRACK_TRUE@LoadPlugin conntrack
 #@BUILD_PLUGIN_CONTEXTSWITCH_TRUE@LoadPlugin contextswitch
-#@BUILD_PLUGIN_CGROUPS_TRUE@LoadPlugin cgroups
 @BUILD_PLUGIN_CPU_TRUE@@BUILD_PLUGIN_CPU_TRUE@LoadPlugin cpu
 #@BUILD_PLUGIN_CPUFREQ_TRUE@LoadPlugin cpufreq
 @LOAD_PLUGIN_CSV@LoadPlugin csv
 #@BUILD_PLUGIN_CURL_TRUE@LoadPlugin curl
 #@BUILD_PLUGIN_CURL_JSON_TRUE@LoadPlugin curl_json
 #@BUILD_PLUGIN_CURL_XML_TRUE@LoadPlugin curl_xml
@@ -121,26 +121,27 @@
 #@BUILD_PLUGIN_FILECOUNT_TRUE@LoadPlugin filecount
 #@BUILD_PLUGIN_FSCACHE_TRUE@LoadPlugin fscache
 #@BUILD_PLUGIN_GMOND_TRUE@LoadPlugin gmond
 #@BUILD_PLUGIN_HDDTEMP_TRUE@LoadPlugin hddtemp
 @BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_PLUGIN_INTERFACE_TRUE@LoadPlugin interface
 #@BUILD_PLUGIN_IPC_TRUE@@BUILD_PLUGIN_IPC_TRUE@LoadPlugin ipc
-#@BUILD_PLUGIN_IPTABLES_TRUE@LoadPlugin iptables
 #@BUILD_PLUGIN_IPMI_TRUE@LoadPlugin ipmi
+#@BUILD_PLUGIN_IPTABLES_TRUE@LoadPlugin iptables
 #@BUILD_PLUGIN_IPVS_TRUE@LoadPlugin ipvs
 #@BUILD_PLUGIN_IRQ_TRUE@LoadPlugin irq
 #@BUILD_PLUGIN_JAVA_TRUE@LoadPlugin java
 @BUILD_PLUGIN_LOAD_TRUE@@BUILD_PLUGIN_LOAD_TRUE@LoadPlugin load
 #@BUILD_PLUGIN_LPAR_TRUE@LoadPlugin lpar
 #@BUILD_PLUGIN_LVM_TRUE@LoadPlugin lvm
 #@BUILD_PLUGIN_MADWIFI_TRUE@LoadPlugin madwifi
 #@BUILD_PLUGIN_MBMON_TRUE@LoadPlugin mbmon
 #@BUILD_PLUGIN_MD_TRUE@LoadPlugin md
 #@BUILD_PLUGIN_MEMCACHEC_TRUE@LoadPlugin memcachec
 #@BUILD_PLUGIN_MEMCACHED_TRUE@LoadPlugin memcached
 @BUILD_PLUGIN_MEMORY_TRUE@@BUILD_PLUGIN_MEMORY_TRUE@LoadPlugin memory
+#@BUILD_PLUGIN_MIC_TRUE@LoadPlugin mic
 #@BUILD_PLUGIN_MODBUS_TRUE@LoadPlugin modbus
 #@BUILD_PLUGIN_MULTIMETER_TRUE@LoadPlugin multimeter
 #@BUILD_PLUGIN_MYSQL_TRUE@LoadPlugin mysql
 #@BUILD_PLUGIN_NETAPP_TRUE@LoadPlugin netapp
 #@BUILD_PLUGIN_NETLINK_TRUE@LoadPlugin netlink
 @LOAD_PLUGIN_NETWORK@LoadPlugin network
@@ -187,13 +188,12 @@
 #@BUILD_PLUGIN_TURBOSTAT_TRUE@LoadPlugin turbostat
 #@BUILD_PLUGIN_UNIXSOCK_TRUE@LoadPlugin unixsock
 #@BUILD_PLUGIN_UPTIME_TRUE@LoadPlugin uptime
 #@BUILD_PLUGIN_USERS_TRUE@LoadPlugin users
 #@BUILD_PLUGIN_UUID_TRUE@LoadPlugin uuid
 #@BUILD_PLUGIN_VARNISH_TRUE@LoadPlugin varnish
-#@BUILD_PLUGIN_MIC_TRUE@LoadPlugin mic
 #@BUILD_PLUGIN_VIRT_TRUE@LoadPlugin virt
 #@BUILD_PLUGIN_VMEM_TRUE@LoadPlugin vmem
 #@BUILD_PLUGIN_VSERVER_TRUE@LoadPlugin vserver
 #@BUILD_PLUGIN_WIRELESS_TRUE@LoadPlugin wireless
 #@BUILD_PLUGIN_WRITE_GRAPHITE_TRUE@LoadPlugin write_graphite
 #@BUILD_PLUGIN_WRITE_HTTP_TRUE@LoadPlugin write_http
@@ -285,13 +285,13 @@
 #   Altitude          238.0
 #   TemperatureSensor "myserver/onewire-F10FCA000800/temperature"
 #</Plugin>
 
 #<Plugin "battery">
 #  ValuesPercentage false
-#  ReportDegraded
+#  ReportDegraded false
 #</Plugin>
 
 #<Plugin "bind">
 #  URL "http://localhost:8053/"
 #  ParseTime       false
 #  OpCodes         true
@@ -481,13 +481,12 @@
 #	Device "/dev/hda1"
 #	Device "192.168.0.2:/mnt/nfs"
 #	MountPoint "/home"
 #	FSType "ext3"
 #	IgnoreSelected false
 #	ReportByDevice false
-#	ReportReserved false
 #	ReportInodes false
 #	ValuesAbsolute true
 #	ValuesPercentage false
 #</Plugin>
 
 #<Plugin disk>
@@ -570,12 +569,13 @@
 #	NotifySensorRemove true
 #	NotifySensorNotPresent false
 #</Plugin>
 
 #<Plugin iptables>
 #	Chain table chain
+#	Chain6 table chain
 #</Plugin>
 
 #<Plugin irq>
 #	Irq 7
 #	Irq 8
 #	Irq 9
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd.conf.pod /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd.conf.pod
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd.conf.pod	2015-05-20 20:05:42.672060002 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd.conf.pod	2016-01-22 17:55:01.089733484 +0800
@@ -147,18 +147,33 @@
 
 =item B<CollectInternalStats> B<false>|B<true>
 
 When set to B<true>, various statistics about the I<collectd> daemon will be
 collected, with "collectd" as the I<plugin name>. Defaults to B<false>.
 
-The "write_queue" I<plugin instance> reports the number of elements currently
-queued and the number of elements dropped off the queue by the
-B<WriteQueueLimitLow>/B<WriteQueueLimitHigh> mechanism.
+The following metrics are reported:
 
-The "cache" I<plugin instance> reports the number of elements in the value list
-cache (the cache you can interact with using L<collectd-unixsock(5)>).
+=over 4
+
+=item C<collectd-write_queue/queue_length>
+
+The number of metrics currently in the write queue. You can limit the queue
+length with the B<WriteQueueLimitLow> and B<WriteQueueLimitHigh> options.
+
+=item C<collectd-write_queue/derive-dropped>
+
+The number of metrics dropped due to a queue length limitation.
+If this value is non-zero, your system can't handle all incoming metrics and
+protects itself against overload by dropping metrics.
+
+=item C<collectd-cache/cache_size>
+
+The number of elements in the metric cache (the cache you can interact with
+using L<collectd-unixsock(5)>).
+
+=back
 
 =item B<Include> I<Path> [I<pattern>]
 
 If I<Path> points to a file, includes that file. If I<Path> points to a
 directory, recursively includes all files within that directory and its
 subdirectories. If the C<wordexp> function is available on your system,
@@ -498,13 +513,13 @@
 are disabled by default.
 
 =back
 
 =head2 Plugin C<amqp>
 
-The I<AMQMP plugin> can be used to communicate with other instances of
+The I<AMQP plugin> can be used to communicate with other instances of
 I<collectd> or third party applications using an AMQP message broker. Values
 are sent to or received from the broker, which handles routing, queueing and
 possibly filtering or messages.
 
  <Plugin "amqp">
    # Send values to an AMQP broker
@@ -1543,13 +1558,13 @@
 
 =back
 
 =head2 Plugin C<curl_json>
 
 The B<curl_json plugin> collects values from JSON data to be parsed by
-B<libyajl> (L<http://www.lloydforge.org/projects/yajl/>) retrieved via
+B<libyajl> (L<https://lloyd.github.io/yajl/>) retrieved via
 either B<libcurl> (L<http://curl.haxx.se/>) or read directly from a
 unix socket. The former can be used, for example, to collect values
 from CouchDB documents (which are stored JSON notation), and the
 latter to collect values from a uWSGI stats socket.
 
 The following example will collect several values from the built-in
@@ -2264,13 +2279,13 @@
 
 =back
 
 =head2 Plugin C<fhcount>
 
 The C<fhcount> plugin provides statistics about used, unused and total number of
-file handles.
+file handles on Linux.
 
 The I<fhcount plugin> provides the following configuration options:
 
 =over 4
 
 =item B<ValuesAbsolute> B<true>|B<false>
@@ -2495,12 +2510,29 @@
 interfaces you're interested in. Sometimes, however, it's easier/preferred
 to collect all interfaces I<except> a few ones. This option enables you to
 do that: By setting B<IgnoreSelected> to I<true> the effect of
 B<Interface> is inverted: All selected interfaces are ignored and all
 other interfaces are collected.
 
+It is possible to use regular expressions to match interface names, if the
+name is surrounded by I</.../> and collectd was compiled with support for
+regexps. This is useful if there's a need to collect (or ignore) data
+for a group of interfaces that are similarly named, without the need to
+explicitly list all of them (especially useful if the list is dynamic).
+Example:
+
+ Interface "lo"
+ Interface "/^veth/"
+ Interface "/^tun[0-9]+/"
+ IgnoreSelected "true"
+
+This will ignore the loopback interface, all interfaces with names starting
+with I<veth> and all interfaces with names starting with I<tun> followed by
+at least one digit.
+
+
 =back
 
 =head2 Plugin C<ipmi>
 
 =over 4
 
@@ -2535,15 +2567,19 @@
 =head2 Plugin C<iptables>
 
 =over 4
 
 =item B<Chain> I<Table> I<Chain> [I<Comment|Number> [I<Name>]]
 
-Select the rules to count. If only I<Table> and I<Chain> are given, this plugin
-will collect the counters of all rules which have a comment-match. The comment
-is then used as type-instance.
+=item B<Chain6> I<Table> I<Chain> [I<Comment|Number> [I<Name>]]
+
+Select the iptables/ip6tables filter rules to count packets and bytes from.
+
+If only I<Table> and I<Chain> are given, this plugin will collect the counters
+of all rules which have a comment-match. The comment is then used as
+type-instance.
 
 If I<Comment> or I<Number> is given, only the rule with the matching comment or
 the I<n>th rule will be collected. Again, the comment (or the number) will be
 used as the type-instance.
 
 If I<Name> is supplied, it will be used as the type-instance instead of the
@@ -4268,12 +4304,24 @@
 Default: C<Collectd notify: %s@%s>
 
 =back
 
 =head2 Plugin C<ntpd>
 
+The C<ntpd> plugin collects per-peer ntpd data such as time offset and time
+dispersion.
+
+For talking to B<ntpd>, it mimics what the B<ntpdc> control program does on
+wire - using B<mode 7> specific requests. This mode is deprecated with
+newer B<ntpd> releases (4.2.7p230 and later). For the C<ntpd> plugin to work
+correctly with them, the ntp daemon must be explicitly configured to
+enable B<mode 7> (which is disabled by default). Refer to the I<ntp.conf(5)>
+manual page for details.
+
+Available configuration options for the C<ntpd> plugin:
+
 =over 4
 
 =item B<Host> I<Hostname>
 
 Hostname of the host running B<ntpd>. Defaults to B<localhost>.
 
@@ -6973,12 +7021,16 @@
 useful on its own because all guests will appear to have the same name.
 
 You can also specify combinations of these fields. For example B<name uuid>
 means to concatenate the guest name and UUID (with a literal colon character
 between, thus I<"foo:1234-1234-1234-1234">).
 
+At the moment of writing (collectd-5.5), hostname string is limited to 62
+characters. In case when combination of fields exceeds 62 characters,
+hostname will be truncated without a warning.
+
 =item B<InterfaceFormat> B<name>|B<address>
 
 When the virt plugin logs interface data, it sets the name of the collected
 data according to this setting. The default is to use the path as provided by
 the hypervisor (the "dev" property of the target node), which is equal to
 setting B<name>.
@@ -6991,12 +7043,16 @@
 When the virt plugin logs data, it sets the plugin_instance of the collected
 data according to this setting. The default is to use the guest name as provided
 by the hypervisor, which is equal to setting B<name>.
 
 B<uuid> means use the guest's UUID.
 
+You can also specify combinations of these fields. For example B<name uuid>
+means to concatenate the guest name and UUID (with a literal colon character
+between, thus I<"foo:1234-1234-1234-1234">).
+
 =back
 
 =head2 Plugin C<vmem>
 
 The C<vmem> plugin collects information about the usage of virtual memory.
 Since the statistics provided by the Linux kernel are very detailed, they are
@@ -7463,13 +7519,13 @@
         Timeout 1000
     </Node>
   </Plugin>
 
 Values are submitted to I<Sorted Sets>, using the metric name as the key, and
 the timestamp as the score. Retrieving a date range can then be done using the
-C<ZRANGEBYSCORE> I<Redis> command. Additionnally, all the identifiers of these
+C<ZRANGEBYSCORE> I<Redis> command. Additionally, all the identifiers of these
 I<Sorted Sets> are kept in a I<Set> called C<collectd/values> and can be
 retrieved using the C<SMEMBERS> I<Redis> command. See
 L<http://redis.io/commands#sorted_set> and L<http://redis.io/commands#set> for
 details.
 
 The information shown in the synopsis above is the I<default configuration>
@@ -7481,15 +7537,15 @@
 
 =over 4
 
 =item B<Node> I<Nodename>
 
 The B<Node> block identifies a new I<Redis> node, that is a new I<Redis>
-instance running in an specified host and port. The name for node is a
+instance running on a specified host and port. The node name is a
 canonical identifier which is used as I<plugin instance>. It is limited to
-64E<nbsp>characters in length.
+51E<nbsp>characters in length.
 
 =item B<Host> I<Hostname>
 
 The B<Host> option is the hostname or IP-address where the I<Redis> instance is
 running on.
 
@@ -7579,13 +7635,13 @@
 This will be reflected in the C<ds_type> tag: If B<StoreRates> is enabled,
 converted values will have "rate" appended to the data source type, e.g.
 C<ds_type:derive:rate>.
 
 =item B<AlwaysAppendDS> B<false>|B<true>
 
-If set the B<true>, append the name of the I<Data Source> (DS) to the
+If set to B<true>, append the name of the I<Data Source> (DS) to the
 "service", i.e. the field that, together with the "host" field, uniquely
 identifies a metric in I<Riemann>. If set to B<false> (the default), this is
 only done when there is more than one DS.
 
 =item B<TTLFactor> I<Factor>
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectdctl.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectdctl.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectdctl.1	2015-03-10 22:29:57.380964860 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectdctl.1	2016-01-22 17:56:33.997658843 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTDCTL 1"
-.TH COLLECTDCTL 1 "2015-03-10" "5.4.1.805.g42e4d6c" "collectd"
+.TH COLLECTDCTL 1 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectdctl \- Control interface for collectd
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectdctl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectdctl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectdctl.c	2015-03-10 22:14:45.821113976 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectdctl.c	2016-01-22 17:51:17.697918694 +0800
@@ -95,13 +95,13 @@
 
       "  [<hostname>/]<plugin>[-<plugin_instance>]/<type>[-<type_instance>]\n\n"
 
       "Hostname defaults to the local hostname if omitted (e.g., uptime/uptime).\n"
       "No error is returned if the specified identifier does not exist.\n"
 
-      "\n"PACKAGE" "VERSION", http://collectd.org/\n"
+      "\n"PACKAGE_NAME" "PACKAGE_VERSION", http://collectd.org/\n"
       "by Florian octo Forster <octo@collectd.org>\n"
       "for contributions see `AUTHORS'\n"
       , name);
   exit (status);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-email.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-email.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-email.5	2015-03-10 22:29:57.164960167 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-email.5	2016-01-22 17:56:33.857658913 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-EMAIL 5"
-.TH COLLECTD-EMAIL 5 "2015-03-10" "5.4.1.805.g42e4d6c" "collectd"
+.TH COLLECTD-EMAIL 5 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-email \- Documentation of collectd's "email plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-exec.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-exec.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-exec.5	2015-05-21 04:02:33.068554446 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-exec.5	2016-01-22 17:56:33.929658877 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-EXEC 5"
-.TH COLLECTD-EXEC 5 "2015-05-20" "5.4.2.911.g0c88d3b" "collectd"
+.TH COLLECTD-EXEC 5 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-exec \- Documentation of collectd's "exec plugin"
@@ -151,13 +151,13 @@
 \&    Exec "otheruser" "/path/to/another/binary" "arg0" "arg1"
 \&    NotificationExec "user" "/usr/lib/collectd/exec/handle_notification"
 \&  </Plugin>
 .Ve
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-The \f(CW\*(C`exec plugin\*(C'\fR forks of an executable either to receive values or to
+The \f(CW\*(C`exec plugin\*(C'\fR forks off an executable either to receive values or to
 dispatch notifications to the outside world. The syntax of the configuration is
 explained in \fIcollectd.conf\fR\|(5) but summarized in the above synopsis.
 .PP
 If you want/need better performance or more functionality you should take a
 long look at the \f(CW\*(C`perl plugin\*(C'\fR, \fIcollectd\-perl\fR\|(5).
 .SH "EXECUTABLE TYPES"
@@ -173,13 +173,13 @@
 \&\fIInterval\fR seconds. It is perfectly legal for the executable to run for a long
 time and continuously write values to \f(CW\*(C`STDOUT\*(C'\fR.
 .Sp
 See \*(L"\s-1EXEC DATA FORMAT\*(R"\s0 below for a description of the output format expected
 from these programs.
 .Sp
-\&\fBWarning:\fR If the executable only writes one value and then exits I will be
+\&\fBWarning:\fR If the executable only writes one value and then exits it will be
 executed every \fIInterval\fR seconds. If \fIInterval\fR is short (the default is 10
 seconds) this may result in serious system load.
 .ie n .IP """NotificationExec""" 4
 .el .IP "\f(CWNotificationExec\fR" 4
 .IX Item "NotificationExec"
 The program is forked once for each notification that is handled by the daemon.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-exec.pod /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-exec.pod
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-exec.pod	2015-05-20 20:04:47.183035394 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-exec.pod	2016-01-22 17:51:17.693918698 +0800
@@ -14,13 +14,13 @@
     Exec "otheruser" "/path/to/another/binary" "arg0" "arg1"
     NotificationExec "user" "/usr/lib/collectd/exec/handle_notification"
   </Plugin>
 
 =head1 DESCRIPTION
 
-The C<exec plugin> forks of an executable either to receive values or to
+The C<exec plugin> forks off an executable either to receive values or to
 dispatch notifications to the outside world. The syntax of the configuration is
 explained in L<collectd.conf(5)> but summarized in the above synopsis.
 
 If you want/need better performance or more functionality you should take a
 long look at the C<perl plugin>, L<collectd-perl(5)>.
 
@@ -39,13 +39,13 @@
 I<Interval> seconds. It is perfectly legal for the executable to run for a long
 time and continuously write values to C<STDOUT>.
 
 See L<EXEC DATA FORMAT> below for a description of the output format expected
 from these programs.
 
-B<Warning:> If the executable only writes one value and then exits I will be
+B<Warning:> If the executable only writes one value and then exits it will be
 executed every I<Interval> seconds. If I<Interval> is short (the default is 10
 seconds) this may result in serious system load.
 
 =item C<NotificationExec>
 
 The program is forked once for each notification that is handled by the daemon.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-java.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-java.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-java.5	2015-03-10 22:29:57.560968771 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-java.5	2016-01-22 17:56:34.097658793 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-JAVA 5"
-.TH COLLECTD-JAVA 5 "2015-03-10" "5.4.1.805.g42e4d6c" "collectd"
+.TH COLLECTD-JAVA 5 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-java \- Documentation of collectd's "java plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectdmon.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectdmon.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectdmon.1	2015-03-10 22:29:57.444966250 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectdmon.1	2016-01-22 17:56:34.169658757 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTDMON 1"
-.TH COLLECTDMON 1 "2015-03-10" "5.4.1.805.g42e4d6c" "collectd"
+.TH COLLECTDMON 1 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectdmon \- Monitoring daemon for collectd
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectdmon.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectdmon.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectdmon.c	2015-03-10 22:14:45.825114063 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectdmon.c	2016-01-22 17:51:17.697918694 +0800
@@ -77,13 +77,13 @@
 			"  -h         Display this help and exit.\n"
 			"  -c <path>  Path to the collectd binary.\n"
 			"  -P <file>  PID-file.\n"
 
 			"\nFor <collectd options> see collectd.conf(5).\n"
 
-			"\n"PACKAGE" "VERSION", http://collectd.org/\n"
+			"\n"PACKAGE_NAME" "PACKAGE_VERSION", http://collectd.org/\n"
 			"by Florian octo Forster <octo@collectd.org>\n"
 			"for contributions see `AUTHORS'\n", name);
 	exit (0);
 } /* exit_usage */
 
 static int pidfile_create (void)
@@ -314,32 +314,38 @@
 
 	collectd_argv[collectd_argc] = NULL;
 
 	openlog ("collectdmon", LOG_CONS | LOG_PID, LOG_DAEMON);
 
 	if (-1 == daemonize ())
+	{
+		free (collectd_argv);
 		return 1;
+	}
 
 	sa.sa_handler = sig_int_term_handler;
 	sa.sa_flags   = 0;
 	sigemptyset (&sa.sa_mask);
 
 	if (0 != sigaction (SIGINT, &sa, NULL)) {
 		syslog (LOG_ERR, "Error: sigaction() failed: %s", strerror (errno));
+		free (collectd_argv);
 		return 1;
 	}
 
 	if (0 != sigaction (SIGTERM, &sa, NULL)) {
 		syslog (LOG_ERR, "Error: sigaction() failed: %s", strerror (errno));
+		free (collectd_argv);
 		return 1;
 	}
 
 	sa.sa_handler = sig_hup_handler;
 
 	if (0 != sigaction (SIGHUP, &sa, NULL)) {
 		syslog (LOG_ERR, "Error: sigaction() failed: %s", strerror (errno));
+		free (collectd_argv);
 		return 1;
 	}
 
 	while (0 == loop) {
 		int status = 0;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-nagios.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-nagios.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-nagios.1	2015-03-10 22:29:57.552968596 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-nagios.1	2016-01-22 17:56:34.233658725 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-NAGIOS 1"
-.TH COLLECTD-NAGIOS 1 "2015-03-10" "5.4.1.805.g42e4d6c" "collectd"
+.TH COLLECTD-NAGIOS 1 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-nagios \- Nagios plugin for querying collectd
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-nagios.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-nagios.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-nagios.c	2015-03-10 22:14:45.821113976 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-nagios.c	2016-01-22 17:51:17.693918698 +0800
@@ -305,14 +305,13 @@
 
 		if ((hostname_g != NULL) && (strcasecmp (hostname_g, ret_ident[i].host)))
 			continue;
 
 		if ((hostname == NULL) || strcasecmp (hostname, ret_ident[i].host))
 		{
-			if (hostname != NULL)
-				free (hostname);
+			free (hostname);
 			hostname = strdup (ret_ident[i].host);
 			printf ("Host: %s\n", hostname);
 		}
 
 		/* empty hostname; not to be printed again */
 		ret_ident[i].host[0] = '\0';
@@ -320,21 +319,23 @@
 		status = lcc_identifier_to_string (connection,
 				id, sizeof (id), ret_ident + i);
 		if (status != 0) {
 			printf ("ERROR: listval: Failed to convert returned "
 					"identifier to a string: %s\n",
 					lcc_strerror (connection));
+			free (hostname);
+			hostname = NULL;
 			continue;
 		}
 
 		/* skip over the (empty) hostname and following '/' */
 		printf ("\t%s\n", id + 1);
 	}
 
-	if (ret_ident != NULL)
-		free (ret_ident);
+	free (ret_ident);
+	free (hostname);
 	return (RET_OKAY);
 } /* int do_listval */
 
 static int do_check_con_none (size_t values_num,
 		double *values, char **values_names)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-perl.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-perl.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-perl.5	2015-05-21 04:02:33.212556949 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-perl.5	2016-01-22 17:56:34.329658677 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-PERL 5"
-.TH COLLECTD-PERL 5 "2015-05-20" "5.4.2.911.g0c88d3b" "collectd"
+.TH COLLECTD-PERL 5 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-perl \- Documentation of collectd's "perl plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-python.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-python.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-python.5	2015-05-21 04:02:33.380559869 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-python.5	2016-01-22 17:56:34.425658629 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-PYTHON 5"
-.TH COLLECTD-PYTHON 5 "2015-05-20" "5.4.2.911.g0c88d3b" "collectd"
+.TH COLLECTD-PYTHON 5 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-python \- Documentation of collectd's "python plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-snmp.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-snmp.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-snmp.5	2015-03-10 22:29:57.812974246 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-snmp.5	2016-01-22 17:56:34.505658589 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-SNMP 5"
-.TH COLLECTD-SNMP 5 "2015-03-10" "5.4.1.805.g42e4d6c" "collectd"
+.TH COLLECTD-SNMP 5 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-snmp \- Documentation of collectd's "snmp plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-tg.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-tg.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-tg.1	2014-08-18 15:51:38.787539710 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-tg.1	2015-06-18 19:03:18.000000000 +0800
@@ -1,7 +1,7 @@
-.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
+.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -35,33 +35,42 @@
 'br\}
 .el\{\
 .    ds -- \|\(em\|
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
 .\" Escape single quotes in literal strings from groff's Unicode transform.
 .ie \n(.g .ds Aq \(aq
 .el       .ds Aq '
 .\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
 .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.ie \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
 ..
-.    nr % 0
-.    rr F
-.\}
-.el \{\
-.    de IX
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
 .    \" fudge factors for nroff and troff
 .if n \{\
 .    ds #H 0
@@ -121,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-TG 1"
-.TH COLLECTD-TG 1 "2014-08-18" "5.4.1.359.g103f05e" "collectd"
+.TH COLLECTD-TG 1 "2015-06-18" "5.4.2.124.gd09ec85" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-tg \- Traffic generator for collectd.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-tg.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-tg.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-tg.c	2015-05-26 16:50:06.288318128 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-tg.c	2016-01-22 17:51:17.693918698 +0800
@@ -185,12 +185,13 @@
       "host%04i", host_num);
   snprintf (vl->identifier.plugin, sizeof (vl->identifier.plugin),
       "plugin%03i", get_boundet_random (0, conf_num_plugins));
   strncpy (vl->identifier.type,
       (vl->values_types[0] == LCC_TYPE_GAUGE) ? "gauge" : "derive",
       sizeof (vl->identifier.type));
+  vl->identifier.type[sizeof (vl->identifier.type) - 1] = 0;
   snprintf (vl->identifier.type_instance, sizeof (vl->identifier.type_instance),
       "ti%li", random ());
 
   return (vl);
 } /* }}} int create_value_list */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-threshold.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-threshold.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-threshold.5	2014-08-18 15:51:38.859541348 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-threshold.5	2015-06-18 19:03:18.000000000 +0800
@@ -1,7 +1,7 @@
-.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
+.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -35,33 +35,42 @@
 'br\}
 .el\{\
 .    ds -- \|\(em\|
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
 .\" Escape single quotes in literal strings from groff's Unicode transform.
 .ie \n(.g .ds Aq \(aq
 .el       .ds Aq '
 .\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
 .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.ie \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
 ..
-.    nr % 0
-.    rr F
-.\}
-.el \{\
-.    de IX
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
 .    \" fudge factors for nroff and troff
 .if n \{\
 .    ds #H 0
@@ -121,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-THRESHOLD 5"
-.TH COLLECTD-THRESHOLD 5 "2014-08-18" "5.4.1.359.g103f05e" "collectd"
+.TH COLLECTD-THRESHOLD 5 "2015-06-18" "5.4.2.124.gd09ec85" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-threshold \- Documentation of collectd's Threshold plugin
@@ -164,13 +173,13 @@
 threshold only once for a notification to be generated. There's no such thing
 as a moving average or similar \- at least not now.
 .PP
 Also, all values that match a threshold are considered to be relevant or
 \&\*(L"interesting\*(R". As a consequence collectd will issue a notification if they are
 not received for \fBTimeout\fR iterations. The \fBTimeout\fR configuration option is
-explained in section \*(L"\s-1GLOBAL\s0 \s-1OPTIONS\s0\*(R" in \fIcollectd.conf\fR\|(5). If, for example,
+explained in section \*(L"\s-1GLOBAL OPTIONS\*(R"\s0 in \fIcollectd.conf\fR\|(5). If, for example,
 \&\fBTimeout\fR is set to \*(L"2\*(R" (the default) and some hosts sends it's \s-1CPU\s0 statistics
 to the server every 60 seconds, a notification will be dispatched after about
 120 seconds. It may take a little longer because the timeout is checked only
 once each \fBInterval\fR on the server.
 .PP
 When a value comes within range again or is received after it was missing, an
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-unixsock.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-unixsock.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/collectd-unixsock.5	2015-03-10 22:29:57.956977374 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/collectd-unixsock.5	2016-01-22 17:56:34.577658553 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "COLLECTD-UNIXSOCK 5"
-.TH COLLECTD-UNIXSOCK 5 "2015-03-10" "5.4.1.805.g42e4d6c" "collectd"
+.TH COLLECTD-UNIXSOCK 5 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 collectd\-unixsock \- Documentation of collectd's "unixsock plugin"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/config.h.in	2015-05-27 15:53:03.419129546 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/config.h.in	2016-01-22 17:56:33.157659263 +0800
@@ -191,12 +191,15 @@
 /* Define to 1 if you have the `getloadavg' function. */
 #undef HAVE_GETLOADAVG
 
 /* Define to 1 if you have the `getmntent' function. */
 #undef HAVE_GETMNTENT
 
+/* Define to 1 if you have the `getmntent_r' function. */
+#undef HAVE_GETMNTENT_R
+
 /* Define to 1 if you have the `getnameinfo' function. */
 #undef HAVE_GETNAMEINFO
 
 /* Define to 1 if you have the `getpwnam_r' function. */
 #undef HAVE_GETPWNAM_R
 
@@ -553,14 +556,14 @@
 /* Define to 1 if you have the <mntent.h> header file. */
 #undef HAVE_MNTENT_H
 
 /* Define to 1 if you have the <mnttab.h> header file. */
 #undef HAVE_MNTTAB_H
 
-/* Define to 1 if you have the <modbus/modbus.h> header file. */
-#undef HAVE_MODBUS_MODBUS_H
+/* Define to 1 if you have the <modbus.h> header file. */
+#undef HAVE_MODBUS_H
 
 /* Define to 1 if you have the <mongo.h> header file. */
 #undef HAVE_MONGO_H
 
 /* Define to 1 if you have the <mysql.h> header file. */
 #undef HAVE_MYSQL_H
@@ -658,15 +661,12 @@
 /* Define to 1 if you have the <owcapi.h> header file. */
 #undef HAVE_OWCAPI_H
 
 /* Define to 1 if you have the <paths.h> header file. */
 #undef HAVE_PATHS_H
 
-/* Define to 1 if you have the <pcap-bpf.h> header file. */
-#undef HAVE_PCAP_BPF_H
-
 /* Define to 1 if you have the <pcap.h> header file. */
 #undef HAVE_PCAP_H
 
 /* Define to 1 if you have the 'perfstat' library (-lperfstat) */
 #undef HAVE_PERFSTAT
 
@@ -1087,12 +1087,15 @@
 /* Define to 1 if you have the `processor_info' function. */
 #undef HAVE_PROCESSOR_INFO
 
 /* Define to 1 if you have the procinfo.h */
 #undef HAVE_PROCINFO_H
 
+/* Define to 1 if you have the <protobuf-c/protobuf-c.h> header file. */
+#undef HAVE_PROTOBUF_C_PROTOBUF_C_H
+
 /* Define to 1 if you have the <pthread.h> header file. */
 #undef HAVE_PTHREAD_H
 
 /* Define to 1 if you have the <pwd.h> header file. */
 #undef HAVE_PWD_H
 
@@ -1240,12 +1243,15 @@
 /* Define to 1 if `id' is a member of `struct inet_diag_req'. */
 #undef HAVE_STRUCT_INET_DIAG_REQ_ID
 
 /* Define to 1 if `idiag_states' is a member of `struct inet_diag_req'. */
 #undef HAVE_STRUCT_INET_DIAG_REQ_IDIAG_STATES
 
+/* Define to 1 if the system has the type `struct ip6_ext'. */
+#undef HAVE_STRUCT_IP6_EXT
+
 /* Define to 1 if `imr_ifindex' is a member of `struct ip_mreqn'. */
 #undef HAVE_STRUCT_IP_MREQN_IMR_IFINDEX
 
 /* Define if struct kinfo_proc exists in the FreeBSD variant. */
 #undef HAVE_STRUCT_KINFO_PROC_FREEBSD
 
@@ -1453,33 +1459,33 @@
 /* Define to 1 if you have the <utmpx.h> header file. */
 #undef HAVE_UTMPX_H
 
 /* Define to 1 if you have the <utmp.h> header file. */
 #undef HAVE_UTMP_H
 
+/* Define to 1 if you have the <vapi/vsc.h> header file. */
+#undef HAVE_VAPI_VSC_H
+
+/* Define to 1 if you have the <varnishapi.h> header file. */
+#undef HAVE_VARNISHAPI_H
+
 /* Varnish 2 API support */
 #undef HAVE_VARNISH_V2
 
 /* Varnish 3 API support */
 #undef HAVE_VARNISH_V3
 
 /* Varnish 4 API support */
 #undef HAVE_VARNISH_V4
 
-/* Define to 1 if you have the <varnish/vapi/vsc.h> header file. */
-#undef HAVE_VARNISH_VAPI_VSC_H
-
-/* Define to 1 if you have the <varnish/varnishapi.h> header file. */
-#undef HAVE_VARNISH_VARNISHAPI_H
-
-/* Define to 1 if you have the <varnish/vsc.h> header file. */
-#undef HAVE_VARNISH_VSC_H
-
 /* Define to 1 if you have the <vm/anon.h> header file. */
 #undef HAVE_VM_ANON_H
 
+/* Define to 1 if you have the <vsc.h> header file. */
+#undef HAVE_VSC_H
+
 /* Define to 1 if you have the <wordexp.h> header file. */
 #undef HAVE_WORDEXP_H
 
 /* This value is set to 1 to indicate that the system argz facility works */
 #undef HAVE_WORKING_ARGZ
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/cpu.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/cpu.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/cpu.c	2015-03-10 22:14:45.825114063 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/cpu.c	2016-01-22 17:51:17.697918694 +0800
@@ -218,21 +218,31 @@
 {
 #if PROCESSOR_CPU_LOAD_INFO
 	kern_return_t status;
 
 	port_host = mach_host_self ();
 
-	/* FIXME: Free `cpu_list' if it's not NULL */
-	if ((status = host_processors (port_host, &cpu_list, &cpu_list_len)) != KERN_SUCCESS)
+	status = host_processors (port_host, &cpu_list, &cpu_list_len);
+	if (status == KERN_INVALID_ARGUMENT)
 	{
-		ERROR ("cpu plugin: host_processors returned %i", (int) status);
+		ERROR ("cpu plugin: Don't have a privileged host control port. "
+				"The most common cause for this problem is "
+				"that collectd is running without root "
+				"privileges, which are required to read CPU "
+				"load information. "
+				"<https://collectd.org/bugs/22>");
+		cpu_list_len = 0;
+		return (-1);
+	}
+	if (status != KERN_SUCCESS)
+	{
+		ERROR ("cpu plugin: host_processors() failed with status %d.", (int) status);
 		cpu_list_len = 0;
 		return (-1);
 	}
 
-	DEBUG ("host_processors returned %i %s", (int) cpu_list_len, cpu_list_len == 1 ? "processor" : "processors");
 	INFO ("cpu plugin: Found %i processor%s.", (int) cpu_list_len, cpu_list_len == 1 ? "" : "s");
 /* #endif PROCESSOR_CPU_LOAD_INFO */
 
 #elif defined(HAVE_LIBKSTAT)
 	kstat_t *ksp_chain;
 
@@ -579,22 +589,22 @@
 		{
 			ERROR ("cpu plugin: processor_info (PROCESSOR_CPU_LOAD_INFO) failed: %s",
 					mach_error_string (status));
 			continue;
 		}
 
-		if (cpu_info_len < COLLECTD_CPU_STATE_MAX)
+		if (cpu_info_len < CPU_STATE_MAX)
 		{
 			ERROR ("cpu plugin: processor_info returned only %i elements..", cpu_info_len);
 			continue;
 		}
 
-		cpu_stage (cpu, COLLECTD_CPU_STATE_USER,   (derive_t) cpu_info.cpu_ticks[COLLECTD_CPU_STATE_USER],   now);
-		cpu_stage (cpu, COLLECTD_CPU_STATE_NICE,   (derive_t) cpu_info.cpu_ticks[COLLECTD_CPU_STATE_NICE],   now);
-		cpu_stage (cpu, COLLECTD_CPU_STATE_SYSTEM, (derive_t) cpu_info.cpu_ticks[COLLECTD_CPU_STATE_SYSTEM], now);
-		cpu_stage (cpu, COLLECTD_CPU_STATE_IDLE,   (derive_t) cpu_info.cpu_ticks[COLLECTD_CPU_STATE_IDLE],   now);
+		cpu_stage (cpu, COLLECTD_CPU_STATE_USER,   (derive_t) cpu_info.cpu_ticks[CPU_STATE_USER],   now);
+		cpu_stage (cpu, COLLECTD_CPU_STATE_NICE,   (derive_t) cpu_info.cpu_ticks[CPU_STATE_NICE],   now);
+		cpu_stage (cpu, COLLECTD_CPU_STATE_SYSTEM, (derive_t) cpu_info.cpu_ticks[CPU_STATE_SYSTEM], now);
+		cpu_stage (cpu, COLLECTD_CPU_STATE_IDLE,   (derive_t) cpu_info.cpu_ticks[CPU_STATE_IDLE],   now);
 	}
 /* }}} #endif PROCESSOR_CPU_LOAD_INFO */
 
 #elif defined(KERNEL_LINUX) /* {{{ */
 	int cpu;
 	FILE *fh;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/csv.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/csv.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/csv.c	2015-03-10 22:14:45.825114063 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/csv.c	2016-01-22 17:51:17.697918694 +0800
@@ -61,19 +61,22 @@
 	for (i = 0; i < ds->ds_num; i++)
 	{
 		if ((ds->ds[i].type != DS_TYPE_COUNTER)
 				&& (ds->ds[i].type != DS_TYPE_GAUGE)
 				&& (ds->ds[i].type != DS_TYPE_DERIVE)
 				&& (ds->ds[i].type != DS_TYPE_ABSOLUTE))
+		{
+			sfree (rates);
 			return (-1);
+		}
 
-		if (ds->ds[i].type == DS_TYPE_GAUGE) 
+		if (ds->ds[i].type == DS_TYPE_GAUGE)
 		{
 			status = ssnprintf (buffer + offset, buffer_len - offset,
 					",%lf", vl->values[i].gauge);
-		} 
+		}
 		else if (store_rates != 0)
 		{
 			if (rates == NULL)
 				rates = uc_get_rate (ds, vl);
 			if (rates == NULL)
 			{
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/curl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/curl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/curl.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/curl.c	2016-01-22 17:51:17.697918694 +0800
@@ -324,13 +324,16 @@
     }
 
     break;
   } /* while (status == 0) */
 
   if (status != 0)
+  {
+    cc_web_match_free (match);
     return (status);
+  }
 
   match->match = match_create_simple (match->regex, match->exclude_regex,
       match->dstype);
   if (match->match == NULL)
   {
     ERROR ("curl plugin: tail_match_add_match_simple failed.");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/curl_json.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/curl_json.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/curl_json.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/curl_json.c	2016-01-22 17:51:17.697918694 +0800
@@ -129,23 +129,17 @@
     return (len);
 #if !HAVE_YAJL_V2
   else if (status == yajl_status_insufficient_data)
     return (len);
 #endif
 
-  if (status != yajl_status_ok)
-  {
-    unsigned char *msg =
-      yajl_get_error(db->yajl, /* verbose = */ 1,
-          /* jsonText = */ (unsigned char *) buf, (unsigned int) len);
-    ERROR ("curl_json plugin: yajl_parse failed: %s", msg);
-    yajl_free_error(db->yajl, msg);
-    return (0); /* abort write callback */
-  }
-
-  return (len);
+  unsigned char *msg = yajl_get_error(db->yajl, /* verbose = */ 1,
+        /* jsonText = */ (unsigned char *) buf, (unsigned int) len);
+  ERROR ("curl_json plugin: yajl_parse failed: %s", msg);
+  yajl_free_error(db->yajl, msg);
+  return (0); /* abort write callback */
 } /* }}} size_t cj_curl_callback */
 
 static int cj_get_type (cj_key_t *key)
 {
   const data_set_t *ds;
 
@@ -500,12 +494,13 @@
     }
   }
   else
   {
     ERROR ("curl_json plugin: cj_config: "
            "Invalid key: %s", ci->key);
+    cj_key_free (key);
     return (-1);
   }
 
   status = 0;
   for (i = 0; i < ci->children_num; i++)
   {
@@ -522,78 +517,74 @@
     }
 
     if (status != 0)
       break;
   } /* for (i = 0; i < ci->children_num; i++) */
 
-  while (status == 0)
+  if (status != 0)
   {
-    if (key->type == NULL)
-    {
-      WARNING ("curl_json plugin: `Type' missing in `Key' block.");
-      status = -1;
-    }
+    cj_key_free (key);
+    return (-1);
+  }
 
-    break;
-  } /* while (status == 0) */
+  if (key->type == NULL)
+  {
+    WARNING ("curl_json plugin: `Type' missing in `Key' block.");
+    cj_key_free (key);
+    return (-1);
+  }
 
   /* store path in a tree that will match the json map structure, example:
    * "httpd/requests/count",
    * "httpd/requests/current" ->
    * { "httpd": { "requests": { "count": $key, "current": $key } } }
    */
-  if (status == 0)
+  char *ptr;
+  char *name;
+  c_avl_tree_t *tree;
+
+  if (db->tree == NULL)
+    db->tree = cj_avl_create();
+
+  tree = db->tree;
+  ptr = key->path;
+  if (*ptr == '/')
+    ++ptr;
+
+  name = ptr;
+  while ((ptr = strchr (name, '/')) != NULL)
   {
-    char *ptr;
-    char *name;
     char ent[PATH_MAX];
-    c_avl_tree_t *tree;
+    c_avl_tree_t *value;
+    size_t len;
 
-    if (db->tree == NULL)
-      db->tree = cj_avl_create();
+    len = ptr - name;
+    if (len == 0)
+      break;
 
-    tree = db->tree;
-    name = key->path;
-    ptr = key->path;
-    if (*ptr == '/')
-      ++ptr;
+    len = COUCH_MIN(len, sizeof (ent)-1);
+    sstrncpy (ent, name, len+1);
 
-    name = ptr;
-    while (*ptr)
+    if (c_avl_get (tree, ent, (void *) &value) != 0)
     {
-      if (*ptr == '/')
-      {
-        c_avl_tree_t *value;
-        int len;
-
-        len = ptr-name;
-        if (len == 0)
-          break;
-        len = COUCH_MIN(len, sizeof (ent)-1);
-        sstrncpy (ent, name, len+1);
-
-        if (c_avl_get (tree, ent, (void *) &value) != 0)
-        {
-          value = cj_avl_create ();
-          c_avl_insert (tree, strdup (ent), value);
-        }
-
-        tree = value;
-        name = ptr+1;
-      }
-      ++ptr;
-    }
-    if (*name)
-      c_avl_insert (tree, strdup(name), key);
-    else
-    {
-      ERROR ("curl_json plugin: invalid key: %s", key->path);
-      status = -1;
+      value = cj_avl_create ();
+      c_avl_insert (tree, strdup (ent), value);
     }
+
+    tree = value;
+    name = ptr + 1;
+  }
+
+  if (strlen (name) == 0)
+  {
+    ERROR ("curl_json plugin: invalid key: %s", key->path);
+    cj_key_free (key);
+    return (-1);
   }
 
+  c_avl_insert (tree, strdup (name), key);
   return (status);
 } /* }}} int cj_config_add_key */
 
 static int cj_init_curl (cj_t *db) /* {{{ */
 {
   db->curl = curl_easy_init ();
@@ -694,12 +685,13 @@
   else if (strcasecmp ("Sock", ci->key) == 0)
     status = cf_util_get_string (ci, &db->sock);
   else
   {
     ERROR ("curl_json plugin: cj_config: "
            "Invalid key: %s", ci->key);
+    cj_free (db);
     return (-1);
   }
   if (status != 0)
   {
     sfree (db);
     return (status);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/curl_xml.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/curl_xml.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/curl_xml.c	2015-05-21 04:09:46.035448950 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/curl_xml.c	2016-01-22 17:51:17.697918694 +0800
@@ -695,42 +695,44 @@
   for (i = 0; i < ci->values_num; i++)
   {
     xpath->values[i].path_len = sizeof (ci->values[i].value.string);
     sstrncpy (xpath->values[i].path, ci->values[i].value.string, sizeof (xpath->values[i].path));
   }
 
-  return (0); 
+  return (0);
 } /* }}} cx_config_add_values */
 
-static int cx_config_add_xpath (cx_t *db, /* {{{ */
-                                   oconfig_item_t *ci)
+static int cx_config_add_xpath (cx_t *db, oconfig_item_t *ci) /* {{{ */
 {
   cx_xpath_t *xpath;
+  char *name;
+  llentry_t *le;
   int status;
   int i;
 
-  xpath = (cx_xpath_t *) malloc (sizeof (*xpath));
+  xpath = malloc (sizeof (*xpath));
   if (xpath == NULL)
   {
     ERROR ("curl_xml plugin: malloc failed.");
     return (-1);
   }
   memset (xpath, 0, sizeof (*xpath));
 
   status = cf_util_get_string (ci, &xpath->path);
   if (status != 0)
   {
-    sfree (xpath);
+    cx_xpath_free (xpath);
     return (status);
   }
 
   /* error out if xpath->path is an empty string */
-  if (*xpath->path == 0)
+  if (strlen (xpath->path) == 0)
   {
     ERROR ("curl_xml plugin: invalid xpath. "
            "xpath value can't be an empty string");
+    cx_xpath_free (xpath);
     return (-1);
   }
 
   status = 0;
   for (i = 0; i < ci->children_num; i++)
   {
@@ -751,51 +753,55 @@
     }
 
     if (status != 0)
       break;
   } /* for (i = 0; i < ci->children_num; i++) */
 
-  if (status == 0 && xpath->type == NULL)
+  if (status != 0)
   {
-    WARNING ("curl_xml plugin: `Type' missing in `xpath' block.");
-    status = -1;
+    cx_xpath_free (xpath);
+    return status;
   }
 
-  if (status == 0)
+  if (xpath->type == NULL)
   {
-    char *name;
-    llentry_t *le;
+    WARNING ("curl_xml plugin: `Type' missing in `xpath' block.");
+    cx_xpath_free (xpath);
+    return -1;
+  }
 
+  if (db->list == NULL)
+  {
+    db->list = llist_create();
     if (db->list == NULL)
     {
-      db->list = llist_create();
-      if (db->list == NULL)
-      {
-        ERROR ("curl_xml plugin: list creation failed.");
-        return (-1);
-      }
-    }
-
-    name = strdup(xpath->path);
-    if (name == NULL)
-    {
-        ERROR ("curl_xml plugin: strdup failed.");
-        return (-1);
-    }
-
-    le = llentry_create (name, xpath);
-    if (le == NULL)
-    {
-      ERROR ("curl_xml plugin: llentry_create failed.");
+      ERROR ("curl_xml plugin: list creation failed.");
+      cx_xpath_free (xpath);
       return (-1);
     }
+  }
+
+  name = strdup (xpath->path);
+  if (name == NULL)
+  {
+    ERROR ("curl_xml plugin: strdup failed.");
+    cx_xpath_free (xpath);
+    return (-1);
+  }
 
-    llist_append (db->list, le);
+  le = llentry_create (name, xpath);
+  if (le == NULL)
+  {
+    ERROR ("curl_xml plugin: llentry_create failed.");
+    cx_xpath_free (xpath);
+    sfree (name);
+    return (-1);
   }
 
-  return (status);
+  llist_append (db->list, le);
+  return (0);
 } /* }}} int cx_config_add_xpath */
 
 static int cx_config_add_namespace (cx_t *db, /* {{{ */
     oconfig_item_t *ci)
 {
   cx_namespace_t *ns;
@@ -938,12 +944,13 @@
     }
   }
   else
   {
     ERROR ("curl_xml plugin: cx_config: "
            "Invalid key: %s", ci->key);
+    cx_free (db);
     return (-1);
   }
 
   /* Fill the `cx_t' structure.. */
   for (i = 0; i < ci->children_num; i++)
   {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/collectd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/collectd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/collectd.c	2015-03-10 22:14:45.825114063 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/collectd.c	2016-01-22 17:51:17.697918694 +0800
@@ -194,14 +194,16 @@
 	}
 
 	dirlen = strlen (dir);
 	while ((dirlen > 0) && (dir[dirlen - 1] == '/'))
 		dir[--dirlen] = '\0';
 
-	if (dirlen <= 0)
+	if (dirlen <= 0) {
+		free (dir);
 		return (-1);
+	}
 
 	status = chdir (dir);
 	if (status == 0)
 	{
 		free (dir);
 		return (0);
@@ -267,13 +269,13 @@
 
 /* TODO
  * Remove all settings but `-f' and `-C'
  */
 static void exit_usage (int status)
 {
-	printf ("Usage: "PACKAGE" [OPTIONS]\n\n"
+	printf ("Usage: "PACKAGE_NAME" [OPTIONS]\n\n"
 
 			"Available options:\n"
 			"  General:\n"
 			"    -C <file>       Configuration file.\n"
 			"                    Default: "CONFIGFILE"\n"
 			"    -t              Test config and exit.\n"
@@ -286,23 +288,28 @@
 			"    -h              Display help (this message)\n"
 			"\nBuiltin defaults:\n"
 			"  Config file       "CONFIGFILE"\n"
 			"  PID file          "PIDFILE"\n"
 			"  Plugin directory  "PLUGINDIR"\n"
 			"  Data directory    "PKGLOCALSTATEDIR"\n"
-			"\n"PACKAGE" "VERSION", http://collectd.org/\n"
+			"\n"PACKAGE_NAME" "PACKAGE_VERSION", http://collectd.org/\n"
 			"by Florian octo Forster <octo@collectd.org>\n"
 			"for contributions see `AUTHORS'\n");
 	exit (status);
 } /* static void exit_usage (int status) */
 
 static int do_init (void)
 {
 #if HAVE_SETLOCALE
 	if (setlocale (LC_NUMERIC, COLLECTD_LOCALE) == NULL)
 		WARNING ("setlocale (\"%s\") failed.", COLLECTD_LOCALE);
+
+	/* Update the environment, so that libraries that are calling
+	 * setlocale(LC_NUMERIC, "") don't accidentally revert these changes. */
+	unsetenv ("LC_ALL");
+	setenv ("LC_NUMERIC", COLLECTD_LOCALE, /* overwrite = */ 1);
 #endif
 
 #if HAVE_LIBKSTAT
 	kc = NULL;
 	update_kstat ();
 #endif
@@ -405,14 +412,15 @@
 	return (0);
 } /* static int pidfile_create (const char *file) */
 
 static int pidfile_remove (void)
 {
 	const char *file = global_option_get ("PIDFile");
+	if (file == NULL)
+		return 0;
 
-	DEBUG ("unlink (%s)", (file != NULL) ? file : "<null>");
 	return (unlink (file));
 } /* static int pidfile_remove (const char *file) */
 #endif /* COLLECT_DAEMON */
 
 #ifdef KERNEL_LINUX
 int notify_upstart (void)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/common.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/common.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/common.c	2015-05-22 18:04:36.951771009 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/common.c	2016-01-22 17:51:17.697918694 +0800
@@ -46,12 +46,14 @@
 
 /* for getaddrinfo */
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netdb.h>
 
+#include <poll.h>
+
 #if HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
 
 /* for ntohl and htonl */
 #if HAVE_ARPA_INET_H
@@ -267,15 +269,29 @@
 
 ssize_t swrite (int fd, const void *buf, size_t count)
 {
 	const char *ptr;
 	size_t      nleft;
 	ssize_t     status;
+	struct      pollfd pfd;
 
 	ptr   = (const char *) buf;
 	nleft = count;
+	
+	/* checking for closed peer connection */
+	pfd.fd = fd;
+	pfd.events = POLLIN | POLLHUP;
+	pfd.revents = 0;
+	if (poll(&pfd, 1, 0) > 0) {
+		char buffer[32];
+		if (recv(fd, buffer, sizeof(buffer), MSG_PEEK | MSG_DONTWAIT) == 0) {
+			// if recv returns zero (even though poll() said there is data to be read),
+			// that means the connection has been closed
+			return -1;
+		}
+	}
 
 	while (nleft > 0)
 	{
 		status = write (fd, (const void *) ptr, nleft);
 
 		if ((status < 0) && ((errno == EAGAIN) || (errno == EINTR)))
@@ -309,50 +325,57 @@
 			break;
 	}
 
 	return ((int) i);
 }
 
-int strjoin (char *dst, size_t dst_len,
+int strjoin (char *buffer, size_t buffer_size,
 		char **fields, size_t fields_num,
 		const char *sep)
 {
-	size_t field_len;
+	size_t avail;
+	char *ptr;
 	size_t sep_len;
-	int i;
-
-	memset (dst, '\0', dst_len);
+	size_t i;
 
-	if (fields_num <= 0)
+	if ((buffer_size < 1) || (fields_num <= 0))
 		return (-1);
 
+	memset (buffer, 0, buffer_size);
+	ptr = buffer;
+	avail = buffer_size - 1;
+
 	sep_len = 0;
 	if (sep != NULL)
 		sep_len = strlen (sep);
 
-	for (i = 0; i < (int)fields_num; i++)
+	for (i = 0; i < fields_num; i++)
 	{
+		size_t field_len;
+
 		if ((i > 0) && (sep_len > 0))
 		{
-			if (dst_len <= sep_len)
+			if (avail < sep_len)
 				return (-1);
 
-			strncat (dst, sep, dst_len);
-			dst_len -= sep_len;
+			memcpy (ptr, sep, sep_len);
+			ptr += sep_len;
+			avail -= sep_len;
 		}
 
 		field_len = strlen (fields[i]);
-
-		if (dst_len <= field_len)
+		if (avail < field_len)
 			return (-1);
 
-		strncat (dst, fields[i], dst_len);
-		dst_len -= field_len;
+		memcpy (ptr, fields[i], field_len);
+		ptr += field_len;
+		avail -= field_len;
 	}
 
-	return (strlen (dst));
+	assert (buffer[buffer_size - 1] == 0);
+	return (strlen (buffer));
 }
 
 int strsubstitute (char *str, char c_from, char c_to)
 {
 	int ret;
 
@@ -504,13 +527,13 @@
 	if (buffer[0] == '/')
 	{
 		memmove (buffer, buffer + 1, buffer_len);
 		buffer_len--;
 	}
 
-	for (i = 0; i < buffer_len - 1; i++)
+	for (i = 0; i < buffer_len; i++)
 	{
 		if (buffer[i] == '/')
 			buffer[i] = '_';
 	}
 
 	return (0);
@@ -1144,12 +1167,15 @@
 {
 	int i;
 	char *dummy;
 	char *ptr;
 	char *saveptr;
 
+	if ((buffer == NULL) || (vl == NULL) || (ds == NULL))
+		return EINVAL;
+
 	i = -1;
 	dummy = buffer;
 	saveptr = NULL;
 	while ((ptr = strtok_r (dummy, ":", &saveptr)) != NULL)
 	{
 		dummy = NULL;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/configfile.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/configfile.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/configfile.c	2015-03-10 22:14:45.829114150 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/configfile.c	2016-01-22 17:51:17.697918694 +0800
@@ -70,40 +70,42 @@
 	struct cf_complex_callback_s *next;
 } cf_complex_callback_t;
 
 typedef struct cf_value_map_s
 {
 	char *key;
-	int (*func) (const oconfig_item_t *);
+	int (*func) (oconfig_item_t *);
 } cf_value_map_t;
 
 typedef struct cf_global_option_s
 {
 	char *key;
 	char *value;
 	char *def;
 } cf_global_option_t;
 
 /*
  * Prototypes of callback functions
  */
-static int dispatch_value_typesdb (const oconfig_item_t *ci);
-static int dispatch_value_plugindir (const oconfig_item_t *ci);
-static int dispatch_loadplugin (const oconfig_item_t *ci);
+static int dispatch_value_typesdb (oconfig_item_t *ci);
+static int dispatch_value_plugindir (oconfig_item_t *ci);
+static int dispatch_loadplugin (oconfig_item_t *ci);
+static int dispatch_block_plugin (oconfig_item_t *ci);
 
 /*
  * Private variables
  */
 static cf_callback_t *first_callback = NULL;
 static cf_complex_callback_t *complex_callback_head = NULL;
 
 static cf_value_map_t cf_value_map[] =
 {
 	{"TypesDB",    dispatch_value_typesdb},
 	{"PluginDir",  dispatch_value_plugindir},
-	{"LoadPlugin", dispatch_loadplugin}
+	{"LoadPlugin", dispatch_loadplugin},
+	{"Plugin",     dispatch_block_plugin}
 };
 static int cf_value_map_num = STATIC_ARRAY_SIZE (cf_value_map);
 
 static cf_global_option_t cf_global_options[] =
 {
 	{"BaseDir",     NULL, PKGLOCALSTATEDIR},
@@ -151,15 +153,18 @@
 	plugin_ctx_t old_ctx;
 	char *key;
 	char *value;
 	int ret;
 	int i;
 
+	if (orig_key == NULL)
+		return (EINVAL);
+
 	DEBUG ("type = %s, key = %s, value = %s",
 			ESCAPE_NULL(type),
-			ESCAPE_NULL(orig_key),
+			orig_key,
 			ESCAPE_NULL(orig_value));
 
 	if ((cf_cb = cf_search (type)) == NULL)
 	{
 		WARNING ("Found a configuration for the `%s' plugin, but "
 				"the plugin isn't loaded or didn't register "
@@ -194,14 +199,12 @@
 	if (i >= cf_cb->keys_num)
 		WARNING ("Plugin `%s' did not register for value `%s'.", type, key);
 
 	free (key);
 	free (value);
 
-	DEBUG ("cf_dispatch: return (%i)", ret);
-
 	return (ret);
 } /* int cf_dispatch */
 
 static int dispatch_global_option (const oconfig_item_t *ci)
 {
 	if (ci->values_num != 1)
@@ -222,13 +225,13 @@
 			return (global_option_set (ci->key, "false"));
 	}
 
 	return (-1);
 } /* int dispatch_global_option */
 
-static int dispatch_value_typesdb (const oconfig_item_t *ci)
+static int dispatch_value_typesdb (oconfig_item_t *ci)
 {
 	int i = 0;
 
 	assert (strcasecmp (ci->key, "TypesDB") == 0);
 
 	cf_default_typesdb = 0;
@@ -248,26 +251,26 @@
 
 		read_types_list (ci->values[i].value.string);
 	}
 	return (0);
 } /* int dispatch_value_typesdb */
 
-static int dispatch_value_plugindir (const oconfig_item_t *ci)
+static int dispatch_value_plugindir (oconfig_item_t *ci)
 {
 	assert (strcasecmp (ci->key, "PluginDir") == 0);
 	
 	if (ci->values_num != 1)
 		return (-1);
 	if (ci->values[0].type != OCONFIG_TYPE_STRING)
 		return (-1);
 
 	plugin_set_dir (ci->values[0].value.string);
 	return (0);
 }
 
-static int dispatch_loadplugin (const oconfig_item_t *ci)
+static int dispatch_loadplugin (oconfig_item_t *ci)
 {
 	int i;
 	const char *name;
 	unsigned int flags = 0;
 	plugin_ctx_t ctx;
 	plugin_ctx_t old_ctx;
@@ -345,13 +348,13 @@
 	/* skip the initial space */
 	buffer_ptr = buffer + 1;
 
 	return (cf_dispatch (plugin, ci->key, buffer_ptr));
 } /* int dispatch_value_plugin */
 
-static int dispatch_value (const oconfig_item_t *ci)
+static int dispatch_value (oconfig_item_t *ci)
 {
 	int ret = -2;
 	int i;
 
 	for (i = 0; i < cf_value_map_num; i++)
 		if (strcasecmp (cf_value_map[i].key, ci->key) == 0)
@@ -394,15 +397,25 @@
 				"This compatibility code will go away eventually.");
 		name = "virt";
 	}
 
 	if (IS_TRUE (global_option_get ("AutoLoadPlugin")))
 	{
+		plugin_ctx_t ctx;
+		plugin_ctx_t old_ctx;
 		int status;
 
+		/* default to the global interval set before loading this plugin */
+		memset (&ctx, 0, sizeof (ctx));
+		ctx.interval = cf_get_default_interval ();
+
+		old_ctx = plugin_set_ctx (ctx);
 		status = plugin_load (name, /* flags = */ 0);
+		/* reset to the "global" context */
+		plugin_set_ctx (old_ctx);
+
 		if (status != 0)
 		{
 			ERROR ("Automatically loading plugin \"%s\" failed "
 					"with status %i.", name, status);
 			return (status);
 		}
@@ -607,14 +620,17 @@
 		sfree (pattern);
 
 		if (new == NULL)
 			return (-1);
 
 		/* Now replace the i'th child in `root' with `new'. */
-		if (cf_ci_replace_child (root, new, i) < 0)
+		if (cf_ci_replace_child (root, new, i) < 0) {
+			sfree (new->values);
+			sfree (new);
 			return (-1);
+		}
 
 		/* ... and go back to the new i'th child. */
 		--i;
 
 		sfree (new->values);
 		sfree (new);
@@ -697,12 +713,13 @@
 	}
 
 	root = (oconfig_item_t *) malloc (sizeof (oconfig_item_t));
 	if (root == NULL)
 	{
 		ERROR ("configfile: malloc failed.");
+		closedir (dh);
 		return (NULL);
 	}
 	memset (root, 0, sizeof (oconfig_item_t));
 
 	while ((de = readdir (dh)) != NULL)
 	{
@@ -716,35 +733,43 @@
 				dir, de->d_name);
 		if ((status < 0) || ((size_t) status >= sizeof (name)))
 		{
 			ERROR ("configfile: Not including `%s/%s' because its"
 					" name is too long.",
 					dir, de->d_name);
+			closedir (dh);
 			for (i = 0; i < filenames_num; ++i)
 				free (filenames[i]);
 			free (filenames);
 			free (root);
 			return (NULL);
 		}
 
 		++filenames_num;
 		tmp = (char **) realloc (filenames,
 				filenames_num * sizeof (*filenames));
 		if (tmp == NULL) {
 			ERROR ("configfile: realloc failed.");
+			closedir (dh);
 			for (i = 0; i < filenames_num - 1; ++i)
 				free (filenames[i]);
 			free (filenames);
 			free (root);
 			return (NULL);
 		}
 		filenames = tmp;
 
 		filenames[filenames_num - 1] = sstrdup (name);
 	}
 
+	if (filenames == NULL)
+	{
+		closedir (dh);
+		return (root);
+	}
+
 	qsort ((void *) filenames, filenames_num, sizeof (*filenames),
 			cf_compare_string);
 
 	for (i = 0; i < filenames_num; ++i)
 	{
 		oconfig_item_t *temp;
@@ -762,17 +787,18 @@
 		sfree (temp->children);
 		sfree (temp);
 
 		free (name);
 	}
 
+	closedir (dh);
 	free(filenames);
 	return (root);
 } /* oconfig_item_t *cf_read_dir */
 
-/* 
+/*
  * cf_read_generic
  *
  * Path is stat'ed and either cf_read_file or cf_read_dir is called
  * accordingly.
  *
  * There are two versions of this function: If `wordexp' exists shell wildcards
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/filter_chain.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/filter_chain.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/filter_chain.c	2015-05-27 02:40:18.589714987 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/filter_chain.c	2016-01-22 17:51:17.697918694 +0800
@@ -389,13 +389,12 @@
         ci->values[0].value.string);
   }
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *option = ci->children + i;
-    status = 0;
 
     if (strcasecmp ("Match", option->key) == 0)
       status = fc_config_add_match (&rule->matches, option);
     else if (strcasecmp ("Target", option->key) == 0)
       status = fc_config_add_target (&rule->targets, option);
     else
@@ -483,13 +482,12 @@
     chain->next = NULL;
   }
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *option = ci->children + i;
-    status = 0;
 
     if (strcasecmp ("Rule", option->key) == 0)
       status = fc_config_add_rule (chain, option);
     else if (strcasecmp ("Target", option->key) == 0)
       status = fc_config_add_target (&chain->targets, option);
     else
@@ -903,23 +901,23 @@
 
 int fc_process_chain (const data_set_t *ds, value_list_t *vl, /* {{{ */
     fc_chain_t *chain)
 {
   fc_rule_t *rule;
   fc_target_t *target;
-  int status;
+  int status = FC_TARGET_CONTINUE;
 
   if (chain == NULL)
     return (-1);
 
   DEBUG ("fc_process_chain (chain = %s);", chain->name);
 
-  status = FC_TARGET_CONTINUE;
   for (rule = chain->rules; rule != NULL; rule = rule->next)
   {
     fc_match_t *match;
+    status = FC_TARGET_CONTINUE;
 
     if (rule->name[0] != 0)
     {
       DEBUG ("fc_process_chain (%s): Testing the `%s' rule.",
           chain->name, rule->name);
     }
@@ -975,38 +973,27 @@
         WARNING ("fc_process_chain (%s): Unknown return value "
             "from target `%s': %i",
             chain->name, target->name, status);
       }
     }
 
-    if ((status == FC_TARGET_STOP)
-        || (status == FC_TARGET_RETURN))
+    if ((status == FC_TARGET_STOP) || (status == FC_TARGET_RETURN))
     {
       if (rule->name[0] != 0)
       {
         DEBUG ("fc_process_chain (%s): Rule `%s' signaled "
             "the %s condition.",
             chain->name, rule->name,
             (status == FC_TARGET_STOP) ? "stop" : "return");
       }
       break;
     }
-    else
-    {
-      status = FC_TARGET_CONTINUE;
-    }
   } /* for (rule) */
 
-  if (status == FC_TARGET_STOP)
-    return (FC_TARGET_STOP);
-  else if (status == FC_TARGET_RETURN)
-    return (FC_TARGET_CONTINUE);
-
-  /* for-loop has been aborted: A target returned `FC_TARGET_STOP' */
-  if (rule != NULL)
-    return (FC_TARGET_CONTINUE);
+  if ((status == FC_TARGET_STOP) || (status == FC_TARGET_RETURN))
+    return (status);
 
   DEBUG ("fc_process_chain (%s): Executing the default targets.",
       chain->name);
 
   status = FC_TARGET_CONTINUE;
   for (target = chain->targets; target != NULL; target = target->next)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/Makefile.am	2015-05-27 03:38:31.425174694 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/Makefile.am	2016-01-22 17:51:17.697918694 +0800
@@ -10,12 +10,36 @@
 if BUILD_FEATURE_DAEMON
 AM_CPPFLAGS += -DPIDFILE='"${localstatedir}/run/${PACKAGE_NAME}.pid"'
 endif
 AM_CPPFLAGS += -DPLUGINDIR='"${pkglibdir}"'
 AM_CPPFLAGS += -DPKGDATADIR='"${pkgdatadir}"'
 
+# Link to these libraries..
+COMMON_LIBS =
+if BUILD_WITH_LIBRT
+COMMON_LIBS += -lrt
+endif
+if BUILD_WITH_LIBPOSIX4
+COMMON_LIBS += -lposix4
+endif
+if BUILD_WITH_LIBSOCKET
+COMMON_LIBS += -lsocket
+endif
+if BUILD_WITH_LIBRESOLV
+COMMON_LIBS += -lresolv
+endif
+if BUILD_WITH_LIBPTHREAD
+COMMON_LIBS += -lpthread
+endif
+if BUILD_WITH_LIBKSTAT
+COMMON_LIBS += -lkstat
+endif
+if BUILD_WITH_LIBDEVINFO
+COMMON_LIBS += -ldevinfo
+endif
+
 AUTOMAKE_OPTIONS = subdir-objects
 
 sbin_PROGRAMS = collectd
 
 noinst_LTLIBRARIES = libavltree.la libcommon.la libheap.la libplugin_mock.la
 
@@ -31,12 +55,13 @@
 		   configfile.c configfile.h \
 		   filter_chain.c filter_chain.h \
 		   meta_data.c meta_data.h \
 		   plugin.c plugin.h \
 		   utils_cache.c utils_cache.h \
 		   utils_complain.c utils_complain.h \
+		   utils_ignorelist.c utils_ignorelist.h \
 		   utils_llist.c utils_llist.h \
 		   utils_random.c utils_random.h \
 		   utils_tail_match.c utils_tail_match.h \
 		   utils_match.c utils_match.h \
 		   utils_subst.c utils_subst.h \
 		   utils_tail.c utils_tail.h \
@@ -45,40 +70,14 @@
 		   utils_threshold.c utils_threshold.h
 
 
 collectd_CPPFLAGS =  $(AM_CPPFLAGS) $(LTDLINCL)
 collectd_CFLAGS = $(AM_CFLAGS)
 collectd_LDFLAGS = -export-dynamic
-collectd_LDADD = libavltree.la libcommon.la libheap.la -lm
-collectd_DEPENDENCIES =
-
-# Link to these libraries..
-if BUILD_WITH_LIBRT
-collectd_LDADD += -lrt
-endif
-if BUILD_WITH_LIBPOSIX4
-collectd_LDADD += -lposix4
-endif
-if BUILD_WITH_LIBSOCKET
-collectd_LDADD += -lsocket
-endif
-if BUILD_WITH_LIBRESOLV
-collectd_LDADD += -lresolv
-endif
-if BUILD_WITH_LIBPTHREAD
-collectd_LDADD += -lpthread
-endif
-if BUILD_WITH_LIBKSTAT
-collectd_LDADD += -lkstat
-endif
-if BUILD_WITH_LIBDEVINFO
-collectd_LDADD += -ldevinfo
-endif
-if BUILD_AIX
-collectd_LDFLAGS += -Wl,-bexpall,-brtllib
-endif
+collectd_LDADD = libavltree.la libcommon.la libheap.la -lm $(COMMON_LIBS)
+collectd_DEPENDENCIES = libavltree.la libcommon.la libheap.la
 
 # The daemon needs to call sg_init, so we need to link it against libstatgrab,
 # too. -octo
 if BUILD_WITH_LIBSTATGRAB
 collectd_CFLAGS += $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
 collectd_LDADD += $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
@@ -92,13 +91,13 @@
 endif
 
 check_PROGRAMS = test_common test_utils_avltree test_utils_heap
 TESTS = test_common test_utils_avltree test_utils_heap
 
 test_common_SOURCES = common_test.c ../testing.h
-test_common_LDADD = libcommon.la libplugin_mock.la
+test_common_LDADD = libcommon.la libplugin_mock.la $(COMMON_LIBS)
 
 test_utils_avltree_SOURCES = utils_avltree_test.c ../testing.h
-test_utils_avltree_LDADD = libavltree.la
+test_utils_avltree_LDADD = libavltree.la $(COMMON_LIBS)
 
 test_utils_heap_SOURCES = utils_heap_test.c ../testing.h
-test_utils_heap_LDADD = libheap.la
+test_utils_heap_LDADD = libheap.la $(COMMON_LIBS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/Makefile.in	2015-05-27 15:51:49.153925424 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/Makefile.in	2016-01-22 17:55:46.705693680 +0800
@@ -77,31 +77,28 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 @BUILD_FEATURE_DAEMON_TRUE@am__append_1 = -DPIDFILE='"${localstatedir}/run/${PACKAGE_NAME}.pid"'
-sbin_PROGRAMS = collectd$(EXEEXT)
-
-# Link to these libraries..
 @BUILD_WITH_LIBRT_TRUE@am__append_2 = -lrt
 @BUILD_WITH_LIBPOSIX4_TRUE@am__append_3 = -lposix4
 @BUILD_WITH_LIBSOCKET_TRUE@am__append_4 = -lsocket
 @BUILD_WITH_LIBRESOLV_TRUE@am__append_5 = -lresolv
 @BUILD_WITH_LIBPTHREAD_TRUE@am__append_6 = -lpthread
 @BUILD_WITH_LIBKSTAT_TRUE@am__append_7 = -lkstat
 @BUILD_WITH_LIBDEVINFO_TRUE@am__append_8 = -ldevinfo
-@BUILD_AIX_TRUE@am__append_9 = -Wl,-bexpall,-brtllib
+sbin_PROGRAMS = collectd$(EXEEXT)
 
 # The daemon needs to call sg_init, so we need to link it against libstatgrab,
 # too. -octo
-@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_10 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
-@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_11 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
-@BUILD_WITH_OWN_LIBOCONFIG_TRUE@am__append_12 = $(LIBLTDL) $(top_builddir)/src/liboconfig/liboconfig.la
-@BUILD_WITH_OWN_LIBOCONFIG_TRUE@am__append_13 = $(top_builddir)/src/liboconfig/liboconfig.la
-@BUILD_WITH_OWN_LIBOCONFIG_FALSE@am__append_14 = -loconfig
+@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_9 = $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
+@BUILD_WITH_LIBSTATGRAB_TRUE@am__append_10 = $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
+@BUILD_WITH_OWN_LIBOCONFIG_TRUE@am__append_11 = $(LIBLTDL) $(top_builddir)/src/liboconfig/liboconfig.la
+@BUILD_WITH_OWN_LIBOCONFIG_TRUE@am__append_12 = $(top_builddir)/src/liboconfig/liboconfig.la
+@BUILD_WITH_OWN_LIBOCONFIG_FALSE@am__append_13 = -loconfig
 check_PROGRAMS = test_common$(EXEEXT) test_utils_avltree$(EXEEXT) \
 	test_utils_heap$(EXEEXT)
 TESTS = test_common$(EXEEXT) test_utils_avltree$(EXEEXT) \
 	test_utils_heap$(EXEEXT)
 subdir = src/daemon
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
@@ -137,37 +134,43 @@
 PROGRAMS = $(sbin_PROGRAMS)
 am_collectd_OBJECTS = collectd-collectd.$(OBJEXT) \
 	collectd-configfile.$(OBJEXT) collectd-filter_chain.$(OBJEXT) \
 	collectd-meta_data.$(OBJEXT) collectd-plugin.$(OBJEXT) \
 	collectd-utils_cache.$(OBJEXT) \
 	collectd-utils_complain.$(OBJEXT) \
+	collectd-utils_ignorelist.$(OBJEXT) \
 	collectd-utils_llist.$(OBJEXT) collectd-utils_random.$(OBJEXT) \
 	collectd-utils_tail_match.$(OBJEXT) \
 	collectd-utils_match.$(OBJEXT) collectd-utils_subst.$(OBJEXT) \
 	collectd-utils_tail.$(OBJEXT) collectd-utils_time.$(OBJEXT) \
 	collectd-types_list.$(OBJEXT) \
 	collectd-utils_threshold.$(OBJEXT)
 collectd_OBJECTS = $(am_collectd_OBJECTS)
 am__DEPENDENCIES_1 =
-@BUILD_WITH_LIBSTATGRAB_TRUE@am__DEPENDENCIES_2 =  \
+am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1)
+@BUILD_WITH_LIBSTATGRAB_TRUE@am__DEPENDENCIES_3 =  \
 @BUILD_WITH_LIBSTATGRAB_TRUE@	$(am__DEPENDENCIES_1)
-@BUILD_WITH_OWN_LIBOCONFIG_TRUE@am__DEPENDENCIES_3 =  \
+@BUILD_WITH_OWN_LIBOCONFIG_TRUE@am__DEPENDENCIES_4 =  \
 @BUILD_WITH_OWN_LIBOCONFIG_TRUE@	$(am__DEPENDENCIES_1) \
 @BUILD_WITH_OWN_LIBOCONFIG_TRUE@	$(top_builddir)/src/liboconfig/liboconfig.la
 collectd_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(collectd_CFLAGS) \
 	$(CFLAGS) $(collectd_LDFLAGS) $(LDFLAGS) -o $@
 am_test_common_OBJECTS = common_test.$(OBJEXT)
 test_common_OBJECTS = $(am_test_common_OBJECTS)
-test_common_DEPENDENCIES = libcommon.la libplugin_mock.la
+test_common_DEPENDENCIES = libcommon.la libplugin_mock.la \
+	$(am__DEPENDENCIES_2)
 am_test_utils_avltree_OBJECTS = utils_avltree_test.$(OBJEXT)
 test_utils_avltree_OBJECTS = $(am_test_utils_avltree_OBJECTS)
-test_utils_avltree_DEPENDENCIES = libavltree.la
+test_utils_avltree_DEPENDENCIES = libavltree.la $(am__DEPENDENCIES_2)
 am_test_utils_heap_OBJECTS = utils_heap_test.$(OBJEXT)
 test_utils_heap_OBJECTS = $(am_test_utils_heap_OBJECTS)
-test_utils_heap_DEPENDENCIES = libheap.la
+test_utils_heap_DEPENDENCIES = libheap.la $(am__DEPENDENCIES_2)
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
 am__v_P_0 = false
 am__v_P_1 = :
 AM_V_GEN = $(am__v_GEN_@AM_V@)
 am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
@@ -710,12 +713,17 @@
 AM_CPPFLAGS = -I$(top_srcdir)/src -DPREFIX='"${prefix}"' \
 	-DCONFIGFILE='"${sysconfdir}/${PACKAGE_NAME}.conf"' \
 	-DLOCALSTATEDIR='"${localstatedir}"' \
 	-DPKGLOCALSTATEDIR='"${localstatedir}/lib/${PACKAGE_NAME}"' \
 	$(am__append_1) -DPLUGINDIR='"${pkglibdir}"' \
 	-DPKGDATADIR='"${pkgdatadir}"'
+
+# Link to these libraries..
+COMMON_LIBS = $(am__append_2) $(am__append_3) $(am__append_4) \
+	$(am__append_5) $(am__append_6) $(am__append_7) \
+	$(am__append_8)
 AUTOMAKE_OPTIONS = subdir-objects
 noinst_LTLIBRARIES = libavltree.la libcommon.la libheap.la libplugin_mock.la
 libavltree_la_SOURCES = utils_avltree.c utils_avltree.h
 libcommon_la_SOURCES = common.c common.h
 libheap_la_SOURCES = utils_heap.c utils_heap.h
 libplugin_mock_la_SOURCES = plugin_mock.c utils_cache_mock.c utils_time_mock.c
@@ -723,37 +731,37 @@
 		   configfile.c configfile.h \
 		   filter_chain.c filter_chain.h \
 		   meta_data.c meta_data.h \
 		   plugin.c plugin.h \
 		   utils_cache.c utils_cache.h \
 		   utils_complain.c utils_complain.h \
+		   utils_ignorelist.c utils_ignorelist.h \
 		   utils_llist.c utils_llist.h \
 		   utils_random.c utils_random.h \
 		   utils_tail_match.c utils_tail_match.h \
 		   utils_match.c utils_match.h \
 		   utils_subst.c utils_subst.h \
 		   utils_tail.c utils_tail.h \
 		   utils_time.c utils_time.h \
 		   types_list.c types_list.h \
 		   utils_threshold.c utils_threshold.h
 
 collectd_CPPFLAGS = $(AM_CPPFLAGS) $(LTDLINCL)
-collectd_CFLAGS = $(AM_CFLAGS) $(am__append_10)
-collectd_LDFLAGS = -export-dynamic $(am__append_9)
+collectd_CFLAGS = $(AM_CFLAGS) $(am__append_9)
+collectd_LDFLAGS = -export-dynamic
 collectd_LDADD = libavltree.la libcommon.la libheap.la -lm \
-	$(am__append_2) $(am__append_3) $(am__append_4) \
-	$(am__append_5) $(am__append_6) $(am__append_7) \
-	$(am__append_8) $(am__append_11) $(am__append_12) \
-	$(am__append_14)
-collectd_DEPENDENCIES = $(am__append_13)
+	$(COMMON_LIBS) $(am__append_10) $(am__append_11) \
+	$(am__append_13)
+collectd_DEPENDENCIES = libavltree.la libcommon.la libheap.la \
+	$(am__append_12)
 test_common_SOURCES = common_test.c ../testing.h
-test_common_LDADD = libcommon.la libplugin_mock.la
+test_common_LDADD = libcommon.la libplugin_mock.la $(COMMON_LIBS)
 test_utils_avltree_SOURCES = utils_avltree_test.c ../testing.h
-test_utils_avltree_LDADD = libavltree.la
+test_utils_avltree_LDADD = libavltree.la $(COMMON_LIBS)
 test_utils_heap_SOURCES = utils_heap_test.c ../testing.h
-test_utils_heap_LDADD = libheap.la
+test_utils_heap_LDADD = libheap.la $(COMMON_LIBS)
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .lo .log .o .obj .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
@@ -894,12 +902,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-filter_chain.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-meta_data.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-plugin.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-types_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_cache.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_complain.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_ignorelist.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_llist.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_match.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_random.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_subst.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_tail.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/collectd-utils_tail_match.Po@am__quote@
@@ -1034,12 +1043,26 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_complain.obj -MD -MP -MF $(DEPDIR)/collectd-utils_complain.Tpo -c -o collectd-utils_complain.obj `if test -f 'utils_complain.c'; then $(CYGPATH_W) 'utils_complain.c'; else $(CYGPATH_W) '$(srcdir)/utils_complain.c'; fi`
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_complain.Tpo $(DEPDIR)/collectd-utils_complain.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_complain.c' object='collectd-utils_complain.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_complain.obj `if test -f 'utils_complain.c'; then $(CYGPATH_W) 'utils_complain.c'; else $(CYGPATH_W) '$(srcdir)/utils_complain.c'; fi`
 
+collectd-utils_ignorelist.o: utils_ignorelist.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_ignorelist.o -MD -MP -MF $(DEPDIR)/collectd-utils_ignorelist.Tpo -c -o collectd-utils_ignorelist.o `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_ignorelist.Tpo $(DEPDIR)/collectd-utils_ignorelist.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='collectd-utils_ignorelist.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_ignorelist.o `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
+
+collectd-utils_ignorelist.obj: utils_ignorelist.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_ignorelist.obj -MD -MP -MF $(DEPDIR)/collectd-utils_ignorelist.Tpo -c -o collectd-utils_ignorelist.obj `if test -f 'utils_ignorelist.c'; then $(CYGPATH_W) 'utils_ignorelist.c'; else $(CYGPATH_W) '$(srcdir)/utils_ignorelist.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_ignorelist.Tpo $(DEPDIR)/collectd-utils_ignorelist.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='collectd-utils_ignorelist.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_ignorelist.obj `if test -f 'utils_ignorelist.c'; then $(CYGPATH_W) 'utils_ignorelist.c'; else $(CYGPATH_W) '$(srcdir)/utils_ignorelist.c'; fi`
+
 collectd-utils_llist.o: utils_llist.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -MT collectd-utils_llist.o -MD -MP -MF $(DEPDIR)/collectd-utils_llist.Tpo -c -o collectd-utils_llist.o `test -f 'utils_llist.c' || echo '$(srcdir)/'`utils_llist.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectd-utils_llist.Tpo $(DEPDIR)/collectd-utils_llist.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_llist.c' object='collectd-utils_llist.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectd_CPPFLAGS) $(CPPFLAGS) $(collectd_CFLAGS) $(CFLAGS) -c -o collectd-utils_llist.o `test -f 'utils_llist.c' || echo '$(srcdir)/'`utils_llist.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/meta_data.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/meta_data.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/meta_data.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/meta_data.c	2016-01-22 17:51:17.697918694 +0800
@@ -111,12 +111,14 @@
   meta_entry_t *copy;
 
   if (orig == NULL)
     return (NULL);
 
   copy = md_entry_alloc (orig->key);
+  if (copy == NULL)
+    return (NULL);
   copy->type = orig->type;
   if (copy->type == MD_TYPE_STRING)
     copy->value.mv_string = strdup (orig->value.mv_string);
   else
     copy->value = orig->value;
 
@@ -252,13 +254,12 @@
 
 void meta_data_destroy (meta_data_t *md) /* {{{ */
 {
   if (md == NULL)
     return;
 
-  pthread_mutex_destroy(&md->lock);
   md_entry_free (md->head);
   pthread_mutex_destroy (&md->lock);
   free (md);
 } /* }}} void meta_data_destroy */
 
 int meta_data_exists (meta_data_t *md, const char *key) /* {{{ */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/plugin.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/plugin.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/plugin.c	2015-05-27 02:40:18.589714987 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/plugin.c	2016-01-22 17:51:17.701918691 +0800
@@ -232,19 +232,19 @@
 {
 	if (read_heap == NULL)
 		return;
 
 	while (42)
 	{
-		callback_func_t *cf;
+		read_func_t *rf;
 
-		cf = c_heap_get_root (read_heap);
-		if (cf == NULL)
+		rf = c_heap_get_root (read_heap);
+		if (rf == NULL)
 			break;
-
-		destroy_callback (cf);
+		sfree (rf->rf_name);
+		destroy_callback ((callback_func_t *) rf);
 	}
 
 	c_heap_destroy (read_heap);
 	read_heap = NULL;
 } /* }}} void destroy_read_heap */
 
@@ -1234,14 +1234,16 @@
 	rf->rf_group[0] = '\0';
 	rf->rf_name = strdup (name);
 	rf->rf_type = RF_SIMPLE;
 	rf->rf_interval = plugin_get_interval ();
 
 	status = plugin_insert_read (rf);
-	if (status != 0)
+	if (status != 0) {
+		sfree (rf->rf_name);
 		sfree (rf);
+	}
 
 	return (status);
 } /* int plugin_register_read */
 
 int plugin_register_complex_read (const char *group, const char *name,
 		plugin_read_cb callback,
@@ -1282,14 +1284,16 @@
 		rf->rf_udata = *user_data;
 	}
 
 	rf->rf_ctx = plugin_get_ctx ();
 
 	status = plugin_insert_read (rf);
-	if (status != 0)
+	if (status != 0) {
+		sfree (rf->rf_name);
 		sfree (rf);
+	}
 
 	return (status);
 } /* int plugin_register_complex_read */
 
 int plugin_register_write (const char *name,
 		plugin_write_cb callback, user_data_t *ud)
@@ -1606,14 +1610,12 @@
 	if (write_threads_num < 1)
 	{
 		ERROR ("WriteThreads must be positive.");
 		write_threads_num = 5;
 	}
 
-	start_write_threads ((size_t) write_threads_num);
-
 	if ((list_init == NULL) && (read_heap == NULL))
 		return;
 
 	/* Calling all init callbacks before checking if read callbacks
 	 * are available allows the init callbacks to register the read
 	 * callback. */
@@ -1643,12 +1645,14 @@
 			plugin_unregister_read (le->key);
 		}
 
 		le = le->next;
 	}
 
+	start_write_threads ((size_t) write_threads_num);
+
 	max_read_interval = global_option_get_time ("MaxReadInterval",
 			DEFAULT_MAX_READ_INTERVAL);
 
 	/* Start read-threads */
 	if (read_heap != NULL)
 	{
@@ -1717,12 +1721,13 @@
 		{
 			NOTICE ("read-function of plugin `%s' failed.",
 					rf->rf_name);
 			return_status = -1;
 		}
 
+		sfree (rf->rf_name);
 		destroy_callback ((void *) rf);
 	}
 
 	return (return_status);
 } /* int plugin_read_all_once */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/plugin_mock.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/plugin_mock.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/plugin_mock.c	2015-05-27 02:40:18.821717947 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/plugin_mock.c	2016-01-22 17:51:17.701918691 +0800
@@ -23,19 +23,51 @@
  * Authors:
  *   Florian octo Forster <octo at collectd.org>
  */
 
 #include "plugin.h"
 
+char hostname_g[] = "example.com";
+
+int plugin_register_complex_config (const char *type, int (*callback) (oconfig_item_t *))
+{
+  return ENOTSUP;
+}
+
+int plugin_register_init (const char *name, plugin_init_cb callback)
+{
+  return ENOTSUP;
+}
+
+int plugin_register_read (const char *name, int (*callback) (void))
+{
+  return ENOTSUP;
+}
+
+int plugin_register_shutdown (const char *name, int (*callback) (void))
+{
+  return ENOTSUP;
+}
+
+int plugin_dispatch_values (value_list_t const *vl)
+{
+  return ENOTSUP;
+}
+
 void plugin_log (int level, char const *format, ...)
 {
   char buffer[1024];
   va_list ap;
 
   va_start (ap, format);
   vsnprintf (buffer, sizeof (buffer), format, ap);
   va_end (ap);
 
   printf ("plugin_log (%i, \"%s\");\n", level, buffer);
 }
 
+cdtime_t plugin_get_interval (void)
+{
+  return TIME_T_TO_CDTIME_T (10);
+}
+
 /* vim: set sw=2 sts=2 et : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/utils_avltree.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/utils_avltree.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/utils_avltree.c	2015-03-10 22:14:45.829114150 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/utils_avltree.c	2016-01-22 17:51:17.701918691 +0800
@@ -143,12 +143,15 @@
 static c_avl_node_t *rotate_right (c_avl_tree_t *t, c_avl_node_t *x)
 {
 	c_avl_node_t *p;
 	c_avl_node_t *y;
 	c_avl_node_t *b;
 
+	assert (x != NULL);
+	assert (x->left != NULL);
+
 	p = x->parent;
 	y = x->left;
 	b = y->right;
 
 	x->left = b;
 	if (b != NULL)
@@ -167,13 +170,13 @@
 		p->right = y;
 
 	x->height = calc_height (x);
 	y->height = calc_height (y);
 
 	return (y);
-} /* void rotate_left */
+} /* void rotate_right */
 
 /*
  *    (x)                   (y)
  *   /   \                 /   \
  *  /\    (y)           (x)    /\
  * /_a\  /   \   ==>   /   \  / c\
@@ -184,12 +187,15 @@
 static c_avl_node_t *rotate_left (c_avl_tree_t *t, c_avl_node_t *x)
 {
 	c_avl_node_t *p;
 	c_avl_node_t *y;
 	c_avl_node_t *b;
 
+	assert (x != NULL);
+	assert (x->right != NULL);
+
 	p = x->parent;
 	y = x->right;
 	b = y->left;
 
 	x->right = b;
 	if (b != NULL)
@@ -614,16 +620,24 @@
 	if (t->root == NULL)
 		return (-1);
 
 	n = t->root;
 	while ((n->left != NULL) || (n->right != NULL))
 	{
-		int height_left  = (n->left  == NULL) ? 0 : n->left->height;
-		int height_right = (n->right == NULL) ? 0 : n->right->height;
+		if (n->left == NULL)
+		{
+			n = n->right;
+			continue;
+		}
+		else if (n->right == NULL)
+		{
+			n = n->left;
+			continue;
+		}
 
-		if (height_left > height_right)
+		if (n->left->height > n->right->height)
 			n = n->left;
 		else
 			n = n->right;
 	}
 
 	p = n->parent;
@@ -635,12 +649,13 @@
 		p->right = NULL;
 
 	*key   = n->key;
 	*value = n->value;
 
 	free_node (n);
+	--t->size;
 	rebalance (t, p);
 
 	return (0);
 } /* int c_avl_pick */
 
 c_avl_iterator_t *c_avl_get_iterator (c_avl_tree_t *t)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/utils_cache.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/utils_cache.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/utils_cache.c	2015-03-10 22:14:45.833114238 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/utils_cache.c	2016-01-22 17:51:17.701918691 +0800
@@ -190,17 +190,19 @@
 	ce->values_gauge[i] = NAN;
 	if (vl->interval > 0)
 	  ce->values_gauge[i] = ((double) vl->values[i].absolute)
 	    / CDTIME_T_TO_DOUBLE (vl->interval);
 	ce->values_raw[i].absolute = vl->values[i].absolute;
 	break;
-	
+
       default:
 	/* This shouldn't happen. */
 	ERROR ("uc_insert: Don't know how to handle data source type %i.",
 	    ds->ds[i].type);
+	sfree (key_copy);
+	cache_free (ce);
 	return (-1);
     } /* switch (ds->ds[i].type) */
   } /* for (i) */
 
   /* Prune invalid gauge data */
   uc_check_range (ds, ce);
@@ -300,13 +302,19 @@
   } /* while (c_avl_iterator_next) */
 
   c_avl_iterator_destroy (iter);
   pthread_mutex_unlock (&cache_lock);
 
   if (keys_len == 0)
+  {
+    /* realloc() may have been called for these. */
+    sfree (keys);
+    sfree (keys_time);
+    sfree (keys_interval);
     return (0);
+  }
 
   /* Call the "missing" callback for each value. Do this before removing the
    * value from the cache, so that callbacks can still access the data stored,
    * including plugin specific meta data, rates, history, …. This must be done
    * without holding the lock, otherwise we will run into a deadlock if a
    * plugin calls the cache interface. */
@@ -319,13 +327,12 @@
     vl.meta = NULL;
 
     status = parse_identifier_vl (keys[i], &vl);
     if (status != 0)
     {
       ERROR ("uc_check_timeout: parse_identifier_vl (\"%s\") failed.", keys[i]);
-      cache_free (ce);
       continue;
     }
 
     vl.time = keys_time[i];
     vl.interval = keys_interval[i];
 
@@ -645,25 +652,28 @@
   c_avl_iterator_destroy (iter);
   pthread_mutex_unlock (&cache_lock);
 
   if (status != 0)
   {
     size_t i;
-    
+
     for (i = 0; i < number; i++)
     {
       sfree (names[i]);
     }
     sfree (names);
+    sfree (times);
 
     return (-1);
   }
 
   *ret_names = names;
   if (ret_times != NULL)
     *ret_times = times;
+  else
+    sfree (times);
   *ret_number = number;
 
   return (0);
 } /* int uc_get_names */
 
 int uc_get_state (const data_set_t *ds, const value_list_t *vl)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon: utils_ignorelist.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon: utils_ignorelist.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/utils_llist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/utils_llist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/daemon/utils_llist.c	2015-03-10 22:14:45.833114238 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/daemon/utils_llist.c	2016-01-22 17:51:17.701918691 +0800
@@ -120,12 +120,15 @@
 }
 
 void llist_remove (llist_t *l, llentry_t *e)
 {
 	llentry_t *prev;
 
+	if ((l == NULL) || (e == NULL))
+		return;
+
 	prev = l->head;
 	while ((prev != NULL) && (prev->next != e))
 		prev = prev->next;
 
 	if (prev != NULL)
 		prev->next = e->next;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/df.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/df.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/df.c	2015-03-10 22:14:45.833114238 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/df.c	2016-01-22 17:55:01.089733484 +0800
@@ -50,13 +50,12 @@
 {
 	"Device",
 	"MountPoint",
 	"FSType",
 	"IgnoreSelected",
 	"ReportByDevice",
-	"ReportReserved",
 	"ReportInodes",
 	"ValuesAbsolute",
 	"ValuesPercentage"
 };
 static int config_keys_num = STATIC_ARRAY_SIZE (config_keys);
 
@@ -201,26 +200,49 @@
 	}
 
 	for (mnt_ptr = mnt_list; mnt_ptr != NULL; mnt_ptr = mnt_ptr->next)
 	{
 		unsigned long long blocksize;
 		char disk_name[256];
+		cu_mount_t *dup_ptr;
 		uint64_t blk_free;
 		uint64_t blk_reserved;
 		uint64_t blk_used;
 
-		if (ignorelist_match (il_device,
-					(mnt_ptr->spec_device != NULL)
-					? mnt_ptr->spec_device
-					: mnt_ptr->device))
+		char const *dev = (mnt_ptr->spec_device != NULL)
+			? mnt_ptr->spec_device
+			: mnt_ptr->device;
+
+		if (ignorelist_match (il_device, dev))
 			continue;
 		if (ignorelist_match (il_mountpoint, mnt_ptr->dir))
 			continue;
 		if (ignorelist_match (il_fstype, mnt_ptr->type))
 			continue;
 
+		/* search for duplicates *in front of* the current mnt_ptr. */
+		for (dup_ptr = mnt_list; dup_ptr != NULL; dup_ptr = dup_ptr->next)
+		{
+			/* No duplicate found: mnt_ptr is the first of its kind. */
+			if (dup_ptr == mnt_ptr)
+			{
+				dup_ptr = NULL;
+				break;
+			}
+
+			/* Duplicate found: leave non-NULL dup_ptr. */
+			if (by_device && (strcmp (mnt_ptr->spec_device, dup_ptr->spec_device) == 0))
+				break;
+			else if (!by_device && (strcmp (mnt_ptr->dir, dup_ptr->dir) == 0))
+				break;
+		}
+
+		/* ignore duplicates */
+		if (dup_ptr != NULL)
+			continue;
+
 		if (STATANYFS (mnt_ptr->dir, &statbuf) < 0)
 		{
 			char errbuf[1024];
 			ERROR (STATANYFS_STR"(%s) failed: %s",
 					mnt_ptr->dir,
 					sstrerror (errno, errbuf,
@@ -231,31 +253,27 @@
 		if (!statbuf.f_blocks)
 			continue;
 
 		if (by_device)
 		{
 			/* eg, /dev/hda1  -- strip off the "/dev/" */
-			if (strncmp (mnt_ptr->spec_device, "/dev/", strlen ("/dev/")) == 0)
-				sstrncpy (disk_name, mnt_ptr->spec_device + strlen ("/dev/"), sizeof (disk_name));
+			if (strncmp (dev, "/dev/", strlen ("/dev/")) == 0)
+				sstrncpy (disk_name, dev + strlen ("/dev/"), sizeof (disk_name));
 			else
-				sstrncpy (disk_name, mnt_ptr->spec_device, sizeof (disk_name));
+				sstrncpy (disk_name, dev, sizeof (disk_name));
 
 			if (strlen(disk_name) < 1)
 			{
 				DEBUG("df: no device name for mountpoint %s, skipping", mnt_ptr->dir);
 				continue;
 			}
 		}
 		else
 		{
 			if (strcmp (mnt_ptr->dir, "/") == 0)
-			{
-				if (strcmp (mnt_ptr->type, "rootfs") == 0)
-					continue;
 				sstrncpy (disk_name, "root", sizeof (disk_name));
-			}
 			else
 			{
 				int i, len;
 
 				sstrncpy (disk_name, mnt_ptr->dir + 1, sizeof (disk_name));
 				len = strlen (disk_name);
@@ -317,13 +335,13 @@
 					(gauge_t) ((float_t)(blk_used) / statbuf.f_blocks * 100));
 				}
 			else return (-1);
 		}
 
 		/* inode handling */
-		if (report_inodes)
+		if (report_inodes && statbuf.f_files != 0 && statbuf.f_ffree != 0)
 		{
 			uint64_t inode_free;
 			uint64_t inode_reserved;
 			uint64_t inode_used;
 
 			/* Sanity-check for the values in the struct */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/disk.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/disk.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/disk.c	2015-03-10 22:14:45.833114238 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/disk.c	2016-01-22 17:51:17.701918691 +0800
@@ -392,175 +392,118 @@
 static int disk_read (void)
 {
 #if HAVE_IOKIT_IOKITLIB_H
 	io_registry_entry_t	disk;
 	io_registry_entry_t	disk_child;
 	io_iterator_t		disk_list;
-	CFDictionaryRef		props_dict;
+	CFMutableDictionaryRef	props_dict, child_dict;
 	CFDictionaryRef		stats_dict;
-	CFDictionaryRef		child_dict;
 	CFStringRef		tmp_cf_string_ref;
 	kern_return_t		status;
 
-	signed long long read_ops;
-	signed long long read_byt;
-	signed long long read_tme;
-	signed long long write_ops;
-	signed long long write_byt;
-	signed long long write_tme;
+	signed long long read_ops, read_byt, read_tme;
+	signed long long write_ops, write_byt, write_tme;
 
-	int  disk_major;
-	int  disk_minor;
+	int  disk_major, disk_minor;
 	char disk_name[DATA_MAX_NAME_LEN];
-	char disk_name_bsd[DATA_MAX_NAME_LEN];
+	char child_disk_name_bsd[DATA_MAX_NAME_LEN], props_disk_name_bsd[DATA_MAX_NAME_LEN];
 
 	/* Get the list of all disk objects. */
-	if (IOServiceGetMatchingServices (io_master_port,
-				IOServiceMatching (kIOBlockStorageDriverClass),
-				&disk_list) != kIOReturnSuccess)
-	{
+	if (IOServiceGetMatchingServices (io_master_port, IOServiceMatching (kIOBlockStorageDriverClass), &disk_list) != kIOReturnSuccess) {
 		ERROR ("disk plugin: IOServiceGetMatchingServices failed.");
 		return (-1);
 	}
 
-	while ((disk = IOIteratorNext (disk_list)) != 0)
-	{
+	while ((disk = IOIteratorNext (disk_list)) != 0) {
 		props_dict = NULL;
 		stats_dict = NULL;
 		child_dict = NULL;
 
-		/* `disk_child' must be released */
-		if ((status = IORegistryEntryGetChildEntry (disk, kIOServicePlane, &disk_child))
-			       	!= kIOReturnSuccess)
-		{
-			/* This fails for example for DVD/CD drives.. */
+		/* get child of disk entry and corresponding property dictionary */
+		if ((status = IORegistryEntryGetChildEntry (disk, kIOServicePlane, &disk_child)) != kIOReturnSuccess) {
+			/* This fails for example for DVD/CD drives, which we want to ignore anyway */
 			DEBUG ("IORegistryEntryGetChildEntry (disk) failed: 0x%08x", status);
 			IOObjectRelease (disk);
 			continue;
 		}
-
-		/* We create `props_dict' => we need to release it later */
-		if (IORegistryEntryCreateCFProperties (disk,
-					(CFMutableDictionaryRef *) &props_dict,
-					kCFAllocatorDefault,
-					kNilOptions)
-				!= kIOReturnSuccess)
-		{
-			ERROR ("disk-plugin: IORegistryEntryCreateCFProperties failed.");
+		if (IORegistryEntryCreateCFProperties (disk_child, (CFMutableDictionaryRef *) &child_dict, kCFAllocatorDefault, kNilOptions) != kIOReturnSuccess || child_dict == NULL) {
+			ERROR ("disk plugin: IORegistryEntryCreateCFProperties (disk_child) failed.");
 			IOObjectRelease (disk_child);
 			IOObjectRelease (disk);
 			continue;
 		}
 
-		if (props_dict == NULL)
-		{
-			DEBUG ("IORegistryEntryCreateCFProperties (disk) failed.");
-			IOObjectRelease (disk_child);
-			IOObjectRelease (disk);
-			continue;
+		/* extract name and major/minor numbers */
+		memset (child_disk_name_bsd, 0, sizeof (child_disk_name_bsd));
+		tmp_cf_string_ref = (CFStringRef) CFDictionaryGetValue (child_dict, CFSTR(kIOBSDNameKey));
+		if (tmp_cf_string_ref) {
+			assert (CFGetTypeID (tmp_cf_string_ref) == CFStringGetTypeID ());
+			CFStringGetCString (tmp_cf_string_ref, child_disk_name_bsd, sizeof (child_disk_name_bsd), kCFStringEncodingUTF8);
 		}
+		disk_major = (int) dict_get_value (child_dict, kIOBSDMajorKey);
+		disk_minor = (int) dict_get_value (child_dict, kIOBSDMinorKey);
+		DEBUG ("disk plugin: child_disk_name_bsd=\"%s\" major=%d minor=%d", child_disk_name_bsd, disk_major, disk_minor);
+		CFRelease (child_dict);
+		IOObjectRelease (disk_child);
 
-		/* tmp_cf_string_ref doesn't need to be released. */
-		tmp_cf_string_ref = (CFStringRef) CFDictionaryGetValue (props_dict,
-				CFSTR(kIOBSDNameKey));
-		if (!tmp_cf_string_ref)
-		{
-			DEBUG ("disk plugin: CFDictionaryGetValue("
-					"kIOBSDNameKey) failed.");
-			CFRelease (props_dict);
-			IOObjectRelease (disk_child);
+		/* get property dictionary of the disk entry itself */
+		if (IORegistryEntryCreateCFProperties (disk, (CFMutableDictionaryRef *) &props_dict, kCFAllocatorDefault, kNilOptions) != kIOReturnSuccess || props_dict == NULL) {
+			ERROR ("disk-plugin: IORegistryEntryCreateCFProperties failed.");
 			IOObjectRelease (disk);
 			continue;
 		}
-		assert (CFGetTypeID (tmp_cf_string_ref) == CFStringGetTypeID ());
 
-		memset (disk_name_bsd, 0, sizeof (disk_name_bsd));
-		CFStringGetCString (tmp_cf_string_ref,
-				disk_name_bsd, sizeof (disk_name_bsd),
-				kCFStringEncodingUTF8);
-		if (disk_name_bsd[0] == 0)
-		{
-			ERROR ("disk plugin: CFStringGetCString() failed.");
+		/* extract name and stats dictionary */
+		memset (props_disk_name_bsd, 0, sizeof (props_disk_name_bsd));
+		tmp_cf_string_ref = (CFStringRef) CFDictionaryGetValue (props_dict, CFSTR(kIOBSDNameKey));
+		if (tmp_cf_string_ref) {
+			assert (CFGetTypeID (tmp_cf_string_ref) == CFStringGetTypeID ());
+			CFStringGetCString (tmp_cf_string_ref, props_disk_name_bsd, sizeof (props_disk_name_bsd), kCFStringEncodingUTF8);
+		}
+		stats_dict = (CFDictionaryRef) CFDictionaryGetValue (props_dict, CFSTR (kIOBlockStorageDriverStatisticsKey));
+		if (stats_dict == NULL) {
+			ERROR ("disk plugin: CFDictionaryGetValue (%s) failed.", kIOBlockStorageDriverStatisticsKey);
 			CFRelease (props_dict);
-			IOObjectRelease (disk_child);
 			IOObjectRelease (disk);
 			continue;
 		}
-		DEBUG ("disk plugin: disk_name_bsd = \"%s\"", disk_name_bsd);
-
-		stats_dict = (CFDictionaryRef) CFDictionaryGetValue (props_dict,
-				CFSTR (kIOBlockStorageDriverStatisticsKey));
+		DEBUG ("disk plugin: props_disk_name_bsd=\"%s\"", props_disk_name_bsd);
 
-		if (stats_dict == NULL)
-		{
-			DEBUG ("disk plugin: CFDictionaryGetValue ("
-					"%s) failed.",
-				       	kIOBlockStorageDriverStatisticsKey);
-			CFRelease (props_dict);
-			IOObjectRelease (disk_child);
-			IOObjectRelease (disk);
-			continue;
-		}
-
-		if (IORegistryEntryCreateCFProperties (disk_child,
-					(CFMutableDictionaryRef *) &child_dict,
-					kCFAllocatorDefault,
-					kNilOptions)
-				!= kIOReturnSuccess)
-		{
-			DEBUG ("disk plugin: IORegistryEntryCreateCFProperties ("
-					"disk_child) failed.");
-			IOObjectRelease (disk_child);
-			CFRelease (props_dict);
-			IOObjectRelease (disk);
-			continue;
+		/* choose name */
+		if (use_bsd_name) {
+			if (child_disk_name_bsd[0] != 0)
+				sstrncpy (disk_name, child_disk_name_bsd, sizeof (disk_name));
+			else if (props_disk_name_bsd[0] != 0)
+				sstrncpy (disk_name, props_disk_name_bsd, sizeof (disk_name));
+			else {
+				ERROR ("disk plugin: can't find bsd disk name.");
+				ssnprintf (disk_name, sizeof (disk_name), "%i-%i", disk_major, disk_minor);
+			}
 		}
+		else
+			ssnprintf (disk_name, sizeof (disk_name), "%i-%i", disk_major, disk_minor);
 
-		/* kIOBSDNameKey */
-		disk_major = (int) dict_get_value (child_dict,
-			       	kIOBSDMajorKey);
-		disk_minor = (int) dict_get_value (child_dict,
-			       	kIOBSDMinorKey);
-		read_ops  = dict_get_value (stats_dict,
-				kIOBlockStorageDriverStatisticsReadsKey);
-		read_byt  = dict_get_value (stats_dict,
-				kIOBlockStorageDriverStatisticsBytesReadKey);
-		read_tme  = dict_get_value (stats_dict,
-				kIOBlockStorageDriverStatisticsTotalReadTimeKey);
-		write_ops = dict_get_value (stats_dict,
-				kIOBlockStorageDriverStatisticsWritesKey);
-		write_byt = dict_get_value (stats_dict,
-				kIOBlockStorageDriverStatisticsBytesWrittenKey);
-		/* This property describes the number of nanoseconds spent
-		 * performing writes since the block storage driver was
-		 * instantiated. It is one of the statistic entries listed
-		 * under the top-level kIOBlockStorageDriverStatisticsKey
-		 * property table. It has an OSNumber value. */
-		write_tme = dict_get_value (stats_dict,
-				kIOBlockStorageDriverStatisticsTotalWriteTimeKey);
+		/* extract the stats */
+		read_ops  = dict_get_value (stats_dict, kIOBlockStorageDriverStatisticsReadsKey);
+		read_byt  = dict_get_value (stats_dict, kIOBlockStorageDriverStatisticsBytesReadKey);
+		read_tme  = dict_get_value (stats_dict, kIOBlockStorageDriverStatisticsTotalReadTimeKey);
+		write_ops = dict_get_value (stats_dict, kIOBlockStorageDriverStatisticsWritesKey);
+		write_byt = dict_get_value (stats_dict, kIOBlockStorageDriverStatisticsBytesWrittenKey);
+		write_tme = dict_get_value (stats_dict, kIOBlockStorageDriverStatisticsTotalWriteTimeKey);
+		CFRelease (props_dict);
+		IOObjectRelease (disk);
 
-		if (use_bsd_name)
-			sstrncpy (disk_name, disk_name_bsd, sizeof (disk_name));
-		else
-			ssnprintf (disk_name, sizeof (disk_name), "%i-%i",
-					disk_major, disk_minor);
+		/* and submit */
 		DEBUG ("disk plugin: disk_name = \"%s\"", disk_name);
-
 		if ((read_byt != -1LL) || (write_byt != -1LL))
 			disk_submit (disk_name, "disk_octets", read_byt, write_byt);
 		if ((read_ops != -1LL) || (write_ops != -1LL))
 			disk_submit (disk_name, "disk_ops", read_ops, write_ops);
 		if ((read_tme != -1LL) || (write_tme != -1LL))
-			disk_submit (disk_name, "disk_time",
-					read_tme / 1000,
-					write_tme / 1000);
+			disk_submit (disk_name, "disk_time", read_tme / 1000, write_tme / 1000);
 
-		CFRelease (child_dict);
-		IOObjectRelease (disk_child);
-		CFRelease (props_dict);
-		IOObjectRelease (disk);
 	}
 	IOObjectRelease (disk_list);
 /* #endif HAVE_IOKIT_IOKITLIB_H */
 
 #elif KERNEL_LINUX
 	FILE *fh;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/dns.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/dns.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/dns.c	2015-03-10 22:14:45.833114238 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/dns.c	2016-01-22 17:51:17.701918691 +0800
@@ -31,13 +31,12 @@
 
 #include "utils_dns.h"
 #include <pthread.h>
 #include <poll.h>
 
 #include <pcap.h>
-#include <pcap-bpf.h>
 
 /*
  * Private data types
  */
 struct counter_list_s
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/drbd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/drbd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/drbd.c	2015-03-10 22:14:45.837114325 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/drbd.c	2016-01-22 17:51:17.741918659 +0800
@@ -139,14 +139,18 @@
 	while (fgets (buffer, sizeof (buffer), fh) != NULL)
 	{
 		fields_num = strsplit (buffer,
 				fields, STATIC_ARRAY_SIZE (fields));
 
 		/* ignore headers (first two iterations) */
-		if (fields_num < 4)
+		if ((strcmp(fields[0], "version:") == 0) ||
+				(strcmp(fields[0], "srcversion:") == 0) ||
+				(strcmp(fields[0], "GIT-hash:") == 0))
+		{
 			continue;
+		}
 
 		if (isdigit(fields[0][0]))
 		{
 			/* parse the resource line, next loop iteration
 			   will submit values for this resource */
 			resource = strtol(fields[0], NULL, 10);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/email.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/email.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/email.c	2015-03-10 22:14:45.837114325 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/email.c	2016-01-22 17:51:17.701918691 +0800
@@ -253,14 +253,12 @@
 
 static void *collect (void *arg)
 {
 	collector_t *this = (collector_t *)arg;
 
 	while (1) {
-		int loop = 1;
-
 		conn_t *connection;
 
 		pthread_mutex_lock (&conns_mutex);
 
 		while (NULL == conns.head) {
 			pthread_cond_wait (&conn_available, &conns_mutex);
@@ -279,21 +277,19 @@
 		 * thread and connection management */
 		this->socket = connection->socket;
 
 		log_debug ("collect: handling connection on fd #%i",
 				fileno (this->socket));
 
-		while (loop) {
+		while (42) {
 			/* 256 bytes ought to be enough for anybody ;-) */
 			char line[256 + 1]; /* line + '\0' */
 			int  len = 0;
 
 			errno = 0;
 			if (NULL == fgets (line, sizeof (line), this->socket)) {
-				loop = 0;
-
 				if (0 != errno) {
 					char errbuf[1024];
 					log_err ("collect: reading from socket (fd #%i) "
 							"failed: %s", fileno (this->socket),
 							sstrerror (errno, errbuf, sizeof (errbuf)));
 				}
@@ -307,14 +303,17 @@
 
 				while (NULL != fgets (line, sizeof (line), this->socket))
 					if (('\n' == line[len - 1]) || ('\r' == line[len - 1]))
 						break;
 				continue;
 			}
+			if (len < 3) { /* [a-z] ':' '\n' */
+				continue;
+			}
 
-			line[len - 1] = '\0';
+			line[len - 1] = 0;
 
 			log_debug ("collect: line = '%s'", line);
 
 			if (':' != line[1]) {
 				log_err ("collect: syntax error in line '%s'", line);
 				continue;
@@ -331,42 +330,45 @@
 					continue;
 				}
 
 				bytes = atoi (tmp);
 
 				pthread_mutex_lock (&count_mutex);
-				type_list_incr (&list_count, type, 1);
+				type_list_incr (&list_count, type, /* increment = */ 1);
 				pthread_mutex_unlock (&count_mutex);
 
 				if (bytes > 0) {
 					pthread_mutex_lock (&size_mutex);
-					type_list_incr (&list_size, type, bytes);
+					type_list_incr (&list_size, type, /* increment = */ bytes);
 					pthread_mutex_unlock (&size_mutex);
 				}
 			}
 			else if ('s' == line[0]) { /* s:<value> */
 				pthread_mutex_lock (&score_mutex);
 				score = (score * (double)score_count + atof (line + 2))
 						/ (double)(score_count + 1);
 				++score_count;
 				pthread_mutex_unlock (&score_mutex);
 			}
 			else if ('c' == line[0]) { /* c:<type1>[,<type2>,...] */
-				char *ptr  = NULL;
-				char *type = strtok_r (line + 2, ",", &ptr);
-
-				do {
-					pthread_mutex_lock (&check_mutex);
-					type_list_incr (&list_check, type, 1);
-					pthread_mutex_unlock (&check_mutex);
-				} while (NULL != (type = strtok_r (NULL, ",", &ptr)));
+				char *dummy = line + 2;
+				char *endptr = NULL;
+				char *type;
+
+				pthread_mutex_lock (&check_mutex);
+				while ((type = strtok_r (dummy, ",", &endptr)) != NULL)
+				{
+					dummy = NULL;
+					type_list_incr (&list_check, type, /* increment = */ 1);
+				}
+				pthread_mutex_unlock (&check_mutex);
 			}
 			else {
 				log_err ("collect: unknown type '%c'", line[0]);
 			}
-		} /* while (loop) */
+		} /* while (42) */
 
 		log_debug ("Shutting down connection on fd #%i",
 				fileno (this->socket));
 
 		fclose (connection->socket);
 		free (connection);
@@ -511,34 +513,48 @@
 		}
 
 		--available_collectors;
 
 		pthread_mutex_unlock (&available_mutex);
 
-		do {
+		while (42) {
 			errno = 0;
-			if (-1 == (remote = accept (connector_socket, NULL, NULL))) {
-				if (EINTR != errno) {
-					char errbuf[1024];
-					disabled = 1;
-					close (connector_socket);
-					connector_socket = -1;
-					log_err ("accept() failed: %s",
-							sstrerror (errno, errbuf, sizeof (errbuf)));
-					pthread_exit ((void *)1);
-				}
+
+			remote = accept (connector_socket, NULL, NULL);
+			if (remote == -1) {
+				char errbuf[1024];
+
+				if (errno == EINTR)
+					continue;
+
+				disabled = 1;
+				close (connector_socket);
+				connector_socket = -1;
+				log_err ("accept() failed: %s",
+						 sstrerror (errno, errbuf, sizeof (errbuf)));
+				pthread_exit ((void *)1);
 			}
-		} while (EINTR == errno);
 
-		connection = (conn_t *)smalloc (sizeof (conn_t));
+			/* access() succeeded. */
+			break;
+		}
+
+		connection = malloc (sizeof (*connection));
+		if (connection == NULL)
+		{
+			close (remote);
+			continue;
+		}
+		memset (connection, 0, sizeof (*connection));
 
 		connection->socket = fdopen (remote, "r");
 		connection->next   = NULL;
 
 		if (NULL == connection->socket) {
 			close (remote);
+			sfree (connection);
 			continue;
 		}
 
 		pthread_mutex_lock (&conns_mutex);
 
 		if (NULL == conns.head) {
@@ -572,16 +588,33 @@
 		return (-1);
 	}
 
 	return (0);
 } /* int email_init */
 
-static int email_shutdown (void)
+static void type_list_free (type_list_t *t)
 {
-	type_t *ptr = NULL;
+	type_t *this;
+
+	this = t->head;
+	while (this != NULL)
+	{
+		type_t *next = this->next;
+
+		sfree (this->name);
+		sfree (this);
+
+		this = next;
+	}
+
+	t->head = NULL;
+	t->tail = NULL;
+}
 
+static int email_shutdown (void)
+{
 	int i = 0;
 
 	if (connector != ((pthread_t) 0)) {
 		pthread_kill (connector, SIGTERM);
 		connector = (pthread_t) 0;
 	}
@@ -615,41 +648,18 @@
 		}
 		sfree (collectors);
 	} /* if (collectors != NULL) */
 
 	pthread_mutex_unlock (&conns_mutex);
 
-	for (ptr = list_count.head; NULL != ptr; ptr = ptr->next) {
-		free (ptr->name);
-		free (ptr);
-	}
-
-	for (ptr = list_count_copy.head; NULL != ptr; ptr = ptr->next) {
-		free (ptr->name);
-		free (ptr);
-	}
-
-	for (ptr = list_size.head; NULL != ptr; ptr = ptr->next) {
-		free (ptr->name);
-		free (ptr);
-	}
-
-	for (ptr = list_size_copy.head; NULL != ptr; ptr = ptr->next) {
-		free (ptr->name);
-		free (ptr);
-	}
-
-	for (ptr = list_check.head; NULL != ptr; ptr = ptr->next) {
-		free (ptr->name);
-		free (ptr);
-	}
-
-	for (ptr = list_check_copy.head; NULL != ptr; ptr = ptr->next) {
-		free (ptr->name);
-		free (ptr);
-	}
+	type_list_free (&list_count);
+	type_list_free (&list_count_copy);
+	type_list_free (&list_size);
+	type_list_free (&list_size_copy);
+	type_list_free (&list_check);
+	type_list_free (&list_check_copy);
 
 	unlink ((NULL == sock_file) ? SOCK_PATH : sock_file);
 
 	sfree (sock_file);
 	sfree (sock_group);
 	return (0);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/exec.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/exec.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/exec.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/exec.c	2016-01-22 17:51:17.701918691 +0800
@@ -336,13 +336,13 @@
   {
     ERROR ("exec plugin: setuid (%i) failed: %s",
         uid, sstrerror (errno, errbuf, sizeof (errbuf)));
     exit (-1);
   }
 
-  status = execvp (pl->exec, pl->argv);
+  execvp (pl->exec, pl->argv);
 
   ERROR ("exec plugin: Failed to execute ``%s'': %s",
       pl->exec, sstrerror (errno, errbuf, sizeof (errbuf)));
   exit (-1);
 } /* void exec_child }}} */
 
@@ -352,23 +352,48 @@
 
   memset (&ss, 0, sizeof (ss));
   sigemptyset (&ss);
   sigprocmask (SIG_SETMASK, &ss, /* old mask = */ NULL);
 } /* }}} void reset_signal_mask */
 
+static int create_pipe (int fd_pipe[2]) /* {{{ */
+{
+  char errbuf[1024];
+  int status;
+
+  status = pipe (fd_pipe);
+  if (status != 0)
+  {
+    ERROR ("exec plugin: pipe failed: %s",
+        sstrerror (errno, errbuf, sizeof (errbuf)));
+    return (-1);
+  }
+
+  return 0;
+} /* }}} int create_pipe */
+
+static void close_pipe (int fd_pipe[2]) /* {{{ */
+{
+  if (fd_pipe[0] != -1)
+    close (fd_pipe[0]);
+
+  if (fd_pipe[1] != -1)
+    close (fd_pipe[1]);
+} /* }}} void close_pipe */
+
 /*
  * Creates three pipes (one for reading, one for writing and one for errors),
  * forks a child, sets up the pipes so that fd_in is connected to STDIN of
  * the child and fd_out is connected to STDOUT and fd_err is connected to STDERR
  * of the child. Then is calls `exec_child'.
  */
 static int fork_child (program_list_t *pl, int *fd_in, int *fd_out, int *fd_err) /* {{{ */
 {
-  int fd_pipe_in[2];
-  int fd_pipe_out[2];
-  int fd_pipe_err[2];
+  int fd_pipe_in[2] = {-1, -1};
+  int fd_pipe_out[2] = {-1, -1};
+  int fd_pipe_err[2] = {-1, -1};
   char errbuf[1024];
   int status;
   int pid;
 
   int uid;
   int gid;
@@ -378,56 +403,38 @@
   struct passwd sp;
   char nambuf[2048];
 
   if (pl->pid != 0)
     return (-1);
 
-  status = pipe (fd_pipe_in);
-  if (status != 0)
-  {
-    ERROR ("exec plugin: pipe failed: %s",
-        sstrerror (errno, errbuf, sizeof (errbuf)));
-    return (-1);
-  }
-
-  status = pipe (fd_pipe_out);
-  if (status != 0)
-  {
-    ERROR ("exec plugin: pipe failed: %s",
-        sstrerror (errno, errbuf, sizeof (errbuf)));
-    return (-1);
-  }
-
-  status = pipe (fd_pipe_err);
-  if (status != 0)
-  {
-    ERROR ("exec plugin: pipe failed: %s",
-        sstrerror (errno, errbuf, sizeof (errbuf)));
-    return (-1);
-  }
+  if ((create_pipe(fd_pipe_in) == -1)
+      || (create_pipe(fd_pipe_out) == -1)
+      || (create_pipe(fd_pipe_err) == -1))
+    goto failed;
 
   sp_ptr = NULL;
   status = getpwnam_r (pl->user, &sp, nambuf, sizeof (nambuf), &sp_ptr);
   if (status != 0)
   {
     ERROR ("exec plugin: Failed to get user information for user ``%s'': %s",
         pl->user, sstrerror (errno, errbuf, sizeof (errbuf)));
-    return (-1);
+    goto failed;
   }
+
   if (sp_ptr == NULL)
   {
     ERROR ("exec plugin: No such user: `%s'", pl->user);
-    return (-1);
+    goto failed;
   }
 
   uid = sp.pw_uid;
   gid = sp.pw_gid;
   if (uid == 0)
   {
     ERROR ("exec plugin: Cowardly refusing to exec program as root.");
-    return (-1);
+    goto failed;
   }
 
   /* The group configured in the configfile is set as effective group, because
    * this way the forked process can (re-)gain the user's primary group. */
   egid = -1;
   if (NULL != pl->group)
@@ -439,18 +446,18 @@
       status = getgrnam_r (pl->group, &gr, nambuf, sizeof (nambuf), &gr_ptr);
       if (0 != status)
       {
         ERROR ("exec plugin: Failed to get group information "
             "for group ``%s'': %s", pl->group,
             sstrerror (errno, errbuf, sizeof (errbuf)));
-        return (-1);
+        goto failed;
       }
       if (NULL == gr_ptr)
       {
         ERROR ("exec plugin: No such group: `%s'", pl->group);
-        return (-1);
+        goto failed;
       }
 
       egid = gr.gr_gid;
     }
     else
     {
@@ -460,13 +467,13 @@
 
   pid = fork ();
   if (pid < 0)
   {
     ERROR ("exec plugin: fork failed: %s",
         sstrerror (errno, errbuf, sizeof (errbuf)));
-    return (-1);
+    goto failed;
   }
   else if (pid == 0)
   {
     int fd_num;
     int fd;
 
@@ -528,12 +535,19 @@
   if (fd_err != NULL)
     *fd_err = fd_pipe_err[0];
   else
     close (fd_pipe_err[0]);
 
   return (pid);
+
+failed:
+  close_pipe(fd_pipe_in);
+  close_pipe(fd_pipe_out);
+  close_pipe(fd_pipe_err);
+
+  return (-1);
 } /* int fork_child }}} */
 
 static int parse_line (char *buffer) /* {{{ */
 {
   if (strncasecmp ("PUTVAL", buffer, strlen ("PUTVAL")) == 0)
     return (handle_putval (stdout, buffer));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/fhcount.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/fhcount.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/fhcount.c	2015-05-20 20:05:42.672060002 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/fhcount.c	2016-01-22 17:51:17.701918691 +0800
@@ -95,12 +95,13 @@
   if (fp == NULL) {
     ERROR("fhcount: fopen: %s", sstrerror(errno, errbuf, sizeof(errbuf)));
     return(EXIT_FAILURE);
   }
   if (fgets(buffer, buffer_len, fp) == NULL) {
     ERROR("fhcount: fgets: %s", sstrerror(errno, errbuf, sizeof(errbuf)));
+    fclose(fp);
     return(EXIT_FAILURE);
   }
   fclose(fp);
 
   // Tokenize string
   numfields = strsplit(buffer, fields, STATIC_ARRAY_SIZE(fields));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/filecount.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/filecount.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/filecount.c	2015-03-10 22:14:45.837114325 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/filecount.c	2016-01-22 17:51:17.701918691 +0800
@@ -353,12 +353,13 @@
   memset (dir, 0, sizeof (*dir));
 
   dir->path = strdup (ci->values[0].value.string);
   if (dir->path == NULL)
   {
     ERROR ("filecount plugin: strdup failed.");
+    sfree (dir);
     return (-1);
   }
 
   fc_config_set_instance (dir, dir->path);
 
   dir->options = FC_RECURSIVE;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/gmond.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/gmond.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/gmond.c	2015-03-10 22:14:45.837114325 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/gmond.c	2016-01-22 17:51:17.701918691 +0800
@@ -1,9 +1,9 @@
 /**
  * collectd - src/gmond.c
- * Copyright (C) 2009,2010  Florian octo Forster
+ * Copyright (C) 2009-2015  Florian octo Forster
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
  * to deal in the Software without restriction, including without limitation
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
@@ -219,19 +219,19 @@
 {
   struct addrinfo  ai_hints;
   struct addrinfo *ai_list;
   struct addrinfo *ai_ptr;
   int              ai_return;
 
-  socket_entry_t *sockets;
-  size_t          sockets_num;
+  socket_entry_t *sockets = NULL;
+  size_t          sockets_num = 0;
 
   int status;
-    
-  sockets     = *ret_sockets;
-  sockets_num = *ret_sockets_num;
+
+  if (*ret_sockets != NULL)
+    return (EINVAL);
 
   memset (&ai_hints, 0, sizeof (ai_hints));
   ai_hints.ai_flags    = 0;
 #ifdef AI_PASSIVE
   ai_hints.ai_flags |= AI_PASSIVE;
 #endif
@@ -288,14 +288,20 @@
       break;
     }
     else
     {
       int yes = 1;
 
-      setsockopt (sockets[sockets_num].fd, SOL_SOCKET, SO_REUSEADDR,
+      status = setsockopt (sockets[sockets_num].fd, SOL_SOCKET, SO_REUSEADDR,
           (void *) &yes, sizeof (yes));
+      if (status != 0)
+      {
+        char errbuf[1024];
+        WARNING ("gmond plugin: setsockopt(2) failed: %s",
+                 sstrerror (errno, errbuf, sizeof (errbuf)));
+      }
     }
 
     status = bind (sockets[sockets_num].fd, ai_ptr->ai_addr, ai_ptr->ai_addrlen);
     if (status != 0)
     {
       char errbuf[1024];
@@ -357,14 +363,17 @@
 
     sockets_num++;
   } /* }}} for (ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next) */
 
   freeaddrinfo (ai_list);
 
-  if ((*ret_sockets_num) >= sockets_num)
+  if (sockets_num == 0)
+  {
+    sfree (sockets);
     return (-1);
+  }
 
   *ret_sockets = sockets;
   *ret_sockets_num = sockets_num;
   return (0);
 } /* }}} int create_sockets */
 
@@ -404,16 +413,25 @@
 
   DEBUG ("gmond plugin: Requesting meta data for %s/%s.",
       host, name);
 
   pthread_mutex_lock (&mc_send_sockets_lock);
   for (i = 0; i < mc_send_sockets_num; i++)
-    sendto (mc_send_sockets[i].fd, buffer, (size_t) buffer_size,
+  {
+    ssize_t status = sendto (mc_send_sockets[i].fd, buffer, (size_t) buffer_size,
         /* flags = */ 0,
         (struct sockaddr *) &mc_send_sockets[i].addr,
         mc_send_sockets[i].addrlen);
+    if (status == -1)
+    {
+      char errbuf[1024];
+      ERROR ("gmond plugin: sendto(2) failed: %s",
+             sstrerror (errno, errbuf, sizeof (errbuf)));
+      continue;
+    }
+  }
   pthread_mutex_unlock (&mc_send_sockets_lock);
 
   sfree (msg.Ganglia_metadata_msg_u.grequest.metric_id.host);
   sfree (msg.Ganglia_metadata_msg_u.grequest.metric_id.name);
   return (0);
 } /* }}} int request_meta_data */
@@ -473,42 +491,12 @@
     return (NULL);
   }
 
   return (se);
 } /* }}} staging_entry_t *staging_entry_get */
 
-static int staging_entry_submit (const char *host, const char *name, /* {{{ */
-    staging_entry_t *se)
-{
-  value_list_t vl;
-  value_t values[se->vl.values_len];
-
-  if (se->vl.interval == 0)
-  {
-    /* No meta data has been received for this metric yet. */
-    se->flags = 0;
-    pthread_mutex_unlock (&staging_lock);
-    request_meta_data (host, name);
-    return (0);
-  }
-
-  se->flags = 0;
-
-  memcpy (values, se->vl.values, sizeof (values));
-  memcpy (&vl, &se->vl, sizeof (vl));
-
-  /* Unlock before calling `plugin_dispatch_values'.. */
-  pthread_mutex_unlock (&staging_lock);
-
-  vl.values = values;
-
-  plugin_dispatch_values (&vl);
-
-  return (0);
-} /* }}} int staging_entry_submit */
-
 static int staging_entry_update (const char *host, const char *name, /* {{{ */
     const char *type, const char *type_instance,
     int ds_index, int ds_type, value_t value)
 {
   const data_set_t *ds;
   staging_entry_t *se;
@@ -552,23 +540,36 @@
     se->vl.values[ds_index].absolute = value.absolute;
   else
     assert (23 == 42);
 
   se->flags |= (0x01 << ds_index);
 
-  /* Check if all values have been set and submit if so. */
-  if (se->flags == ((0x01 << se->vl.values_len) - 1))
+  /* Check if all data sources have been set. If not, return here. */
+  if (se->flags != ((0x01 << se->vl.values_len) - 1))
   {
-    /* `staging_lock' is unlocked in `staging_entry_submit'. */
-    staging_entry_submit (host, name, se);
+    pthread_mutex_unlock (&staging_lock);
+    return (0);
   }
-  else
+
+  /* Check if the interval of this metric is known. If not, request meta data
+   * and return. */
+  if (se->vl.interval == 0)
   {
+    /* No meta data has been received for this metric yet. */
+    se->flags = 0;
     pthread_mutex_unlock (&staging_lock);
+
+    request_meta_data (host, name);
+    return (0);
   }
 
+  plugin_dispatch_values (&se->vl);
+
+  se->flags = 0;
+  pthread_mutex_unlock (&staging_lock);
+
   return (0);
 } /* }}} int staging_entry_update */
 
 static int mc_handle_value_msg (Ganglia_value_msg *msg) /* {{{ */
 {
   const char *host;
@@ -662,13 +663,13 @@
   {
     value_t val_copy;
 
     if ((map->ds_type == DS_TYPE_COUNTER)
         || (map->ds_type == DS_TYPE_ABSOLUTE))
       val_copy = value_counter;
-    if (map->ds_type == DS_TYPE_GAUGE)
+    else if (map->ds_type == DS_TYPE_GAUGE)
       val_copy = value_gauge;
     else if (map->ds_type == DS_TYPE_DERIVE)
       val_copy = value_derive;
     else
       assert (23 == 42);
 
@@ -869,12 +870,13 @@
     {
       if (mc_receive_sockets[i].revents != 0)
         mc_handle_socket (mc_receive_sockets + i);
     }
   } /* while (mc_receive_thread_loop != 0) */
 
+  free (mc_receive_socket_entries);
   return ((void *) 0);
 } /* }}} void *mc_receive_thread */
 
 static int mc_receive_thread_start (void) /* {{{ */
 {
   int status;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ipc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ipc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ipc.c	2015-05-21 04:09:46.147450803 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ipc.c	2016-01-22 17:51:17.705918688 +0800
@@ -29,12 +29,15 @@
 #include "collectd.h"
 #include "common.h"
 #include "plugin.h"
 #include "configfile.h"
 
 #if KERNEL_LINUX
+  /* _GNU_SOURCE is needed for struct shm_info.used_ids on musl libc */
+# define _GNU_SOURCE
+
   /* X/OPEN tells us to use <sys/{types,ipc,sem}.h> for semctl() */
   /* X/OPEN tells us to use <sys/{types,ipc,msg}.h> for msgctl() */
   /* X/OPEN tells us to use <sys/{types,ipc,shm}.h> for shmctl() */
 # include <sys/types.h>
 # include <sys/ipc.h>
 # include <sys/sem.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/iptables.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/iptables.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/iptables.c	2014-08-18 15:33:14.288460635 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/iptables.c	2016-01-22 17:37:50.190392655 +0800
@@ -108,136 +108,133 @@
 	protocol_version_t ip_version = 0;
 
 	if (strcasecmp (key, "Chain") == 0)
 		ip_version = IPV4;
 	else if (strcasecmp (key, "Chain6") == 0)
 		ip_version = IPV6;
+	else
+		return (1);
 
-	if (( ip_version == IPV4 ) || ( ip_version == IPV6 ))
-	{
-		ip_chain_t temp, *final, **list;
-		char *table;
-		int   table_len;
-		char *chain;
-		int   chain_len;
-
-		char *value_copy;
-		char *fields[4];
-		int   fields_num;
-		
-		memset (&temp, 0, sizeof (temp));
+	ip_chain_t temp, *final, **list;
+	char *table;
+	int   table_len;
+	char *chain;
+	int   chain_len;
+
+	char *value_copy;
+	char *fields[4];
+	int   fields_num;
 
-		value_copy = strdup (value);
-		if (value_copy == NULL)
-		{
-		    char errbuf[1024];
-		    ERROR ("strdup failed: %s",
-			    sstrerror (errno, errbuf, sizeof (errbuf)));
-		    return (1);
-		}
+	memset (&temp, 0, sizeof (temp));
 
-		/*
-	         *  Time to fill the temp element
-        	 *  Examine value string, it should look like:
-	         *  Chain[6] <table> <chain> [<comment|num> [name]]
-       		 */
-
-		/* set IPv4 or IPv6 */
-                temp.ip_version = ip_version;
-
-		/* Chain <table> <chain> [<comment|num> [name]] */
-		fields_num = strsplit (value_copy, fields, 4);
-		if (fields_num < 2)
-		{
-		    free (value_copy);
-		    return (1);
-		}
-
-		table = fields[0];
-		chain = fields[1];
-
-		table_len = strlen (table) + 1;
-		if ((unsigned int)table_len > sizeof(temp.table))
-		{
-			ERROR ("Table `%s' too long.", table);
-			free (value_copy);
-			return (1);
-		}
-		sstrncpy (temp.table, table, table_len);
+	value_copy = strdup (value);
+	if (value_copy == NULL)
+	{
+	    char errbuf[1024];
+	    ERROR ("strdup failed: %s",
+		    sstrerror (errno, errbuf, sizeof (errbuf)));
+	    return (1);
+	}
 
-		chain_len = strlen (chain) + 1;
-		if ((unsigned int)chain_len > sizeof(temp.chain))
-		{
-			ERROR ("Chain `%s' too long.", chain);
-			free (value_copy);
-			return (1);
-		}
-		sstrncpy (temp.chain, chain, chain_len);
+	/*
+	 *  Time to fill the temp element
+	 *  Examine value string, it should look like:
+	 *  Chain[6] <table> <chain> [<comment|num> [name]]
+	 */
+
+	/* set IPv4 or IPv6 */
+	temp.ip_version = ip_version;
+
+	/* Chain <table> <chain> [<comment|num> [name]] */
+	fields_num = strsplit (value_copy, fields, 4);
+	if (fields_num < 2)
+	{
+	    free (value_copy);
+	    return (1);
+	}
 
-		if (fields_num >= 3)
-		{
-		    char *comment = fields[2];
-		    int   rule = atoi (comment);
+	table = fields[0];
+	chain = fields[1];
 
-		    if (rule)
-		    {
-			temp.rule.num = rule;
-			temp.rule_type = RTYPE_NUM;
-		    }
-		    else
-		    {
-			temp.rule.comment = strdup (comment);
-			if (temp.rule.comment == NULL)
-			{
-			    free (value_copy);
-			    return (1);
-			}
-			temp.rule_type = RTYPE_COMMENT;
-		    }
-		}
-		else
-		{
-		    temp.rule_type = RTYPE_COMMENT_ALL;
-		}
-
-		if (fields_num >= 4)
-		    sstrncpy (temp.name, fields[3], sizeof (temp.name));
+	table_len = strlen (table) + 1;
+	if ((unsigned int)table_len > sizeof(temp.table))
+	{
+		ERROR ("Table `%s' too long.", table);
+		free (value_copy);
+		return (1);
+	}
+	sstrncpy (temp.table, table, table_len);
 
+	chain_len = strlen (chain) + 1;
+	if ((unsigned int)chain_len > sizeof(temp.chain))
+	{
+		ERROR ("Chain `%s' too long.", chain);
 		free (value_copy);
-		value_copy = NULL;
-		table = NULL;
-		chain = NULL;
+		return (1);
+	}
+	sstrncpy (temp.chain, chain, chain_len);
 
-		list = (ip_chain_t **) realloc (chain_list, (chain_num + 1) * sizeof (ip_chain_t *));
-		if (list == NULL)
-		{
-		    char errbuf[1024];
-		    ERROR ("realloc failed: %s",
-			    sstrerror (errno, errbuf, sizeof (errbuf)));
-		    return (1);
-		}
+	if (fields_num >= 3)
+	{
+	    char *comment = fields[2];
+	    int   rule = atoi (comment);
 
-		chain_list = list;
-		final = (ip_chain_t *) malloc( sizeof(temp) );
-		if (final == NULL) 
+	    if (rule)
+	    {
+		temp.rule.num = rule;
+		temp.rule_type = RTYPE_NUM;
+	    }
+	    else
+	    {
+		temp.rule.comment = strdup (comment);
+		if (temp.rule.comment == NULL)
 		{
-		    char errbuf[1024];
-		    ERROR ("malloc failed: %s",
-			    sstrerror (errno, errbuf, sizeof (errbuf)));
+		    free (value_copy);
 		    return (1);
 		}
-		memcpy (final, &temp, sizeof (temp));
-		chain_list[chain_num] = final;
-		chain_num++;
+		temp.rule_type = RTYPE_COMMENT;
+	    }
+	}
+	else
+	{
+	    temp.rule_type = RTYPE_COMMENT_ALL;
+	}
 
-		DEBUG ("Chain #%i: table = %s; chain = %s;", chain_num, final->table, final->chain);
+	if (fields_num >= 4)
+	    sstrncpy (temp.name, fields[3], sizeof (temp.name));
+
+	free (value_copy);
+	value_copy = NULL;
+	table = NULL;
+	chain = NULL;
+
+	list = (ip_chain_t **) realloc (chain_list, (chain_num + 1) * sizeof (ip_chain_t *));
+	if (list == NULL)
+	{
+	    char errbuf[1024];
+	    ERROR ("realloc failed: %s",
+		    sstrerror (errno, errbuf, sizeof (errbuf)));
+	    sfree (temp.rule.comment);
+	    return (1);
 	}
-	else 
+
+	chain_list = list;
+	final = (ip_chain_t *) malloc( sizeof(temp) );
+	if (final == NULL)
 	{
-		return (-1);
+	    char errbuf[1024];
+	    ERROR ("malloc failed: %s",
+		    sstrerror (errno, errbuf, sizeof (errbuf)));
+	    sfree (temp.rule.comment);
+	    return (1);
 	}
+	memcpy (final, &temp, sizeof (temp));
+	chain_list[chain_num] = final;
+	chain_num++;
+
+	DEBUG ("Chain #%i: table = %s; chain = %s;", chain_num, final->table, final->chain);
 
 	return (0);
 } /* int iptables_config */
 
 static int submit6_match (const struct ip6t_entry_match *match,
                 const struct ip6t_entry *entry,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ipvs.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ipvs.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ipvs.c	2014-08-18 15:33:14.288460635 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ipvs.c	2016-01-22 17:37:50.190392655 +0800
@@ -292,13 +292,16 @@
 
 	char pi[DATA_MAX_NAME_LEN];
 
 	int i = 0;
 
 	if (0 != get_pi (se, pi, sizeof (pi)))
+	{
+		free (dests);
 		return;
+	}
 
 	cipvs_submit_connections (pi, NULL, stats.conns);
 	cipvs_submit_if (pi, "if_packets", NULL, stats.inpkts, stats.outpkts);
 	cipvs_submit_if (pi, "if_octets", NULL, stats.inbytes, stats.outbytes);
 
 	for (i = 0; i < dests->num_dests; ++i)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/irq.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/irq.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/irq.c	2014-09-05 16:57:01.456282539 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/irq.c	2016-01-22 16:33:25.050182513 +0800
@@ -117,12 +117,13 @@
 	if(fgets (buffer, sizeof (buffer), fh) != NULL) {
 		cpu_count = strsplit (buffer, fields,
 				STATIC_ARRAY_SIZE (fields));
 	} else {
 		ERROR ("irq plugin: unable to get CPU count from first line "
 				"of /proc/interrupts");
+		fclose (fh);
 		return (-1);
 	}
 
 	while (fgets (buffer, sizeof (buffer), fh) != NULL)
 	{
 		char *irq_name;
@@ -152,12 +153,16 @@
 
 		/* Check if irq name ends with colon.
 		 * Otherwise it's a header. */
 		if (irq_name[irq_name_len - 1] != ':')
 			continue;
 
+		/* Is it the the ARM fast interrupt (FIQ)? */
+		if (irq_name_len == 4 && (strncmp(irq_name, "FIQ:", 4) == 0))
+			continue;
+
 		irq_name[irq_name_len - 1] = 0;
 		irq_name_len--;
 
 		irq_value = 0;
 		for (i = 1; i <= irq_values_to_parse; i++)
 		{
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/java.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/java.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/java.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/java.c	2016-01-22 17:51:17.705918688 +0800
@@ -1814,41 +1814,47 @@
   cbi->name = strdup (c_name);
   if (cbi->name == NULL)
   {
     pthread_mutex_unlock (&java_callbacks_lock);
     ERROR ("java plugin: cjni_callback_info_create: strdup failed.");
     (*jvm_env)->ReleaseStringUTFChars (jvm_env, o_name, c_name);
+    sfree (cbi);
     return (NULL);
   }
 
   (*jvm_env)->ReleaseStringUTFChars (jvm_env, o_name, c_name);
 
   cbi->object = (*jvm_env)->NewGlobalRef (jvm_env, o_callback);
   if (cbi->object == NULL)
   {
     ERROR ("java plugin: cjni_callback_info_create: NewGlobalRef failed.");
-    free (cbi);
+    sfree (cbi->name);
+    sfree (cbi);
     return (NULL);
   }
 
   cbi->class  = (*jvm_env)->GetObjectClass (jvm_env, cbi->object);
   if (cbi->class == NULL)
   {
     ERROR ("java plugin: cjni_callback_info_create: GetObjectClass failed.");
-    free (cbi);
+    (*jvm_env)->DeleteGlobalRef (jvm_env, cbi->object);
+    sfree (cbi->name);
+    sfree (cbi);
     return (NULL);
   }
 
   cbi->method = (*jvm_env)->GetMethodID (jvm_env, cbi->class,
       method_name, method_signature);
   if (cbi->method == NULL)
   {
     ERROR ("java plugin: cjni_callback_info_create: "
         "Cannot find the `%s' method with signature `%s'.",
         method_name, method_signature);
-    free (cbi);
+    (*jvm_env)->DeleteGlobalRef (jvm_env, cbi->object);
+    sfree (cbi->name);
+    sfree (cbi);
     return (NULL);
   }
 
   return (cbi);
 } /* }}} cjni_callback_info_t cjni_callback_info_create */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/libcollectdclient/client.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/libcollectdclient/client.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/libcollectdclient/client.c	2015-03-10 22:14:45.837114325 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/libcollectdclient/client.c	2016-01-22 17:51:17.705918688 +0800
@@ -497,44 +497,43 @@
   for (ai_ptr = ai_res; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next)
   {
     fd = socket (ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol);
     if (fd < 0)
     {
       status = errno;
-      fd = -1;
       continue;
     }
 
     status = connect (fd, ai_ptr->ai_addr, ai_ptr->ai_addrlen);
     if (status != 0)
     {
       status = errno;
       close (fd);
-      fd = -1;
       continue;
     }
 
     c->fh = fdopen (fd, "r+");
     if (c->fh == NULL)
     {
       status = errno;
       close (fd);
-      fd = -1;
       continue;
     }
 
     assert (status == 0);
     break;
   } /* for (ai_ptr) */
 
   if (status != 0)
   {
     lcc_set_errno (c, status);
+    freeaddrinfo (ai_res);
     return (-1);
   }
 
+  freeaddrinfo (ai_res);
   return (0);
 } /* }}} int lcc_open_netsocket */
 
 static int lcc_open_socket (lcc_connection_t *c, const char *addr) /* {{{ */
 {
   int status = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/libcollectdclient/collectd/lcc_features.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/libcollectdclient/collectd/lcc_features.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/libcollectdclient/collectd/lcc_features.h	2015-05-27 15:52:29.266575803 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/libcollectdclient/collectd/lcc_features.h	2016-01-22 17:56:12.341671041 +0800
@@ -36,17 +36,17 @@
 #endif
 
 #define LCC_API_VERSION 0
 
 #define LCC_VERSION_MAJOR 5
 #define LCC_VERSION_MINOR 5
-#define LCC_VERSION_PATCH 0
+#define LCC_VERSION_PATCH 1
 
 #define LCC_VERSION_EXTRA ""
 
-#define LCC_VERSION_STRING "5.5.0"
+#define LCC_VERSION_STRING "5.5.1"
 
 #define LCC_VERSION_ENCODE(major, minor, patch) \
 	((major) * 10000 + (minor) * 100 + (patch))
 
 #define LCC_VERSION \
 	LCC_VERSION_ENCODE(LCC_VERSION_MAJOR, LCC_VERSION_MINOR, LCC_VERSION_PATCH)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/libcollectdclient/network.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/libcollectdclient/network.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/libcollectdclient/network.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/libcollectdclient/network.c	2016-01-22 17:51:17.705918688 +0800
@@ -86,12 +86,13 @@
     return (EINVAL);
 
   if (srv->fd < 0)
     return (0);
 
   close (srv->fd);
+  srv->fd = -1;
   free (srv->sa);
   srv->sa = NULL;
   srv->sa_len = 0;
 
   return (0);
 } /* }}} int server_close_socket */
@@ -104,18 +105,12 @@
     return;
 
   server_close_socket (srv);
 
   next = srv->next;
 
-  if (srv->fd >= 0)
-  {
-    close (srv->fd);
-    srv->fd = -1;
-  }
-
   free (srv->node);
   free (srv->service);
   free (srv->username);
   free (srv->password);
   free (srv);
 
@@ -160,30 +154,35 @@
 
       if (IN_MULTICAST (ntohl (addr->sin_addr.s_addr)))
         optname = IP_MULTICAST_TTL;
       else
         optname = IP_TTL;
 
-      setsockopt (srv->fd, IPPROTO_IP, optname,
-          &srv->ttl,
-          sizeof (srv->ttl));
+      status = setsockopt (srv->fd, IPPROTO_IP, optname,
+          &srv->ttl, sizeof (srv->ttl));
     }
     else if (ai_ptr->ai_family == AF_INET6)
     {
       /* Useful example: http://gsyc.escet.urjc.es/~eva/IPv6-web/examples/mcast.html */
       struct sockaddr_in6 *addr = (struct sockaddr_in6 *) ai_ptr->ai_addr;
       int optname;
 
       if (IN6_IS_ADDR_MULTICAST (&addr->sin6_addr))
         optname = IPV6_MULTICAST_HOPS;
       else
         optname = IPV6_UNICAST_HOPS;
 
-      setsockopt (srv->fd, IPPROTO_IPV6, optname,
-          &srv->ttl,
-          sizeof (srv->ttl));
+      status = setsockopt (srv->fd, IPPROTO_IPV6, optname,
+          &srv->ttl, sizeof (srv->ttl));
+    }
+    if (status != 0)
+    {
+      /* setsockopt failed. */
+      close (srv->fd);
+      srv->fd = -1;
+      continue;
     }
 
     srv->sa = malloc (ai_ptr->ai_addrlen);
     if (srv->sa == NULL)
     {
       close (srv->fd);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/Makefile.am	2012-09-13 19:10:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/Makefile.am	2016-01-22 16:33:25.050182513 +0800
@@ -3,8 +3,8 @@
 BUILT_SOURCES = parser.h
 #CLEANFILES = parser.[ch] scanner.c
 AM_YFLAGS = -d
 
 noinst_LTLIBRARIES = liboconfig.la
 
-liboconfig_la_LDFLAGS = -version-info 0:0:0 $(LEXLIB)
+liboconfig_la_LDFLAGS = -avoid-version $(LEXLIB)
 liboconfig_la_SOURCES = oconfig.c oconfig.h aux_types.h scanner.l parser.y
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/Makefile.in	2015-05-27 15:51:49.321928148 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/Makefile.in	2016-01-22 17:55:46.817693581 +0800
@@ -450,13 +450,13 @@
 top_srcdir = @top_srcdir@
 AUTOMAKE_OPTIONS = foreign no-dependencies
 BUILT_SOURCES = parser.h
 #CLEANFILES = parser.[ch] scanner.c
 AM_YFLAGS = -d
 noinst_LTLIBRARIES = liboconfig.la
-liboconfig_la_LDFLAGS = -version-info 0:0:0 $(LEXLIB)
+liboconfig_la_LDFLAGS = -avoid-version $(LEXLIB)
 liboconfig_la_SOURCES = oconfig.c oconfig.h aux_types.h scanner.l parser.y
 all: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .l .lo .o .obj .y
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/oconfig.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/oconfig.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/oconfig.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/oconfig.c	2016-01-22 17:51:17.705918688 +0800
@@ -30,12 +30,13 @@
 #include <assert.h>
 #include <errno.h>
 
 #include "oconfig.h"
 
 extern FILE *yyin;
+extern int yyparse (void);
 
 oconfig_item_t *ci_root;
 const char     *c_file;
 
 static void yyset_in  (FILE *fd)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/parser.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/parser.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/parser.c	2015-03-10 22:29:59.785017090 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/parser.c	2016-01-22 17:56:34.965658358 +0800
@@ -72,17 +72,18 @@
 static char *unquote (const char *orig);
 static int yyerror (const char *s);
 
 /* Lexer variables */
 extern int yylineno;
 extern char *yytext;
+extern int yylex (void);
 
 extern oconfig_item_t *ci_root;
 extern char           *c_file;
 
-#line 83 "parser.c" /* yacc.c:339  */
+#line 84 "parser.c" /* yacc.c:339  */
 
 # ifndef YY_NULLPTR
 #  if defined __cplusplus && 201103L <= __cplusplus
 #   define YY_NULLPTR nullptr
 #  else
 #   define YY_NULLPTR 0
@@ -138,23 +139,23 @@
 
 /* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE YYSTYPE;
 union YYSTYPE
 {
-#line 46 "parser.y" /* yacc.c:355  */
+#line 47 "parser.y" /* yacc.c:355  */
 
 	double  number;
 	int     boolean;
 	char   *string;
 	oconfig_value_t  cv;
 	oconfig_item_t   ci;
 	argument_list_t  al;
 	statement_list_t sl;
 
-#line 155 "parser.c" /* yacc.c:355  */
+#line 156 "parser.c" /* yacc.c:355  */
 };
 # define YYSTYPE_IS_TRIVIAL 1
 # define YYSTYPE_IS_DECLARED 1
 #endif
 
 
@@ -163,13 +164,13 @@
 int yyparse (void);
 
 #endif /* !YY_YY_Y_TAB_H_INCLUDED  */
 
 /* Copy the second part of user declarations.  */
 
-#line 170 "parser.c" /* yacc.c:358  */
+#line 171 "parser.c" /* yacc.c:358  */
 
 #ifdef short
 # undef short
 #endif
 
 #ifdef YYTYPE_UINT8
@@ -461,15 +462,15 @@
 };
 
 #if YYDEBUG
   /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_uint8 yyrline[] =
 {
-       0,    81,    81,    82,    86,    87,    88,    89,    93,   100,
-     109,   113,   123,   129,   139,   146,   159,   175,   176,   177,
-     181,   191,   208,   216
+       0,    82,    82,    83,    87,    88,    89,    90,    94,   101,
+     110,   114,   124,   130,   140,   147,   160,   176,   177,   178,
+     182,   192,   209,   217
 };
 #endif
 
 #if YYDEBUG || YYERROR_VERBOSE || 1
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
@@ -1256,181 +1257,181 @@
 
 
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
         case 2:
-#line 81 "parser.y" /* yacc.c:1646  */
+#line 82 "parser.y" /* yacc.c:1646  */
     {(yyval.string) = unquote ((yyvsp[0].string));}
-#line 1265 "parser.c" /* yacc.c:1646  */
+#line 1266 "parser.c" /* yacc.c:1646  */
     break;
 
   case 3:
-#line 82 "parser.y" /* yacc.c:1646  */
+#line 83 "parser.y" /* yacc.c:1646  */
     {(yyval.string) = strdup ((yyvsp[0].string));}
-#line 1271 "parser.c" /* yacc.c:1646  */
+#line 1272 "parser.c" /* yacc.c:1646  */
     break;
 
   case 4:
-#line 86 "parser.y" /* yacc.c:1646  */
+#line 87 "parser.y" /* yacc.c:1646  */
     {(yyval.cv).value.number = (yyvsp[0].number); (yyval.cv).type = OCONFIG_TYPE_NUMBER;}
-#line 1277 "parser.c" /* yacc.c:1646  */
+#line 1278 "parser.c" /* yacc.c:1646  */
     break;
 
   case 5:
-#line 87 "parser.y" /* yacc.c:1646  */
+#line 88 "parser.y" /* yacc.c:1646  */
     {(yyval.cv).value.boolean = 1; (yyval.cv).type = OCONFIG_TYPE_BOOLEAN;}
-#line 1283 "parser.c" /* yacc.c:1646  */
+#line 1284 "parser.c" /* yacc.c:1646  */
     break;
 
   case 6:
-#line 88 "parser.y" /* yacc.c:1646  */
+#line 89 "parser.y" /* yacc.c:1646  */
     {(yyval.cv).value.boolean = 0; (yyval.cv).type = OCONFIG_TYPE_BOOLEAN;}
-#line 1289 "parser.c" /* yacc.c:1646  */
+#line 1290 "parser.c" /* yacc.c:1646  */
     break;
 
   case 7:
-#line 89 "parser.y" /* yacc.c:1646  */
+#line 90 "parser.y" /* yacc.c:1646  */
     {(yyval.cv).value.string = (yyvsp[0].string); (yyval.cv).type = OCONFIG_TYPE_STRING;}
-#line 1295 "parser.c" /* yacc.c:1646  */
+#line 1296 "parser.c" /* yacc.c:1646  */
     break;
 
   case 8:
-#line 94 "parser.y" /* yacc.c:1646  */
+#line 95 "parser.y" /* yacc.c:1646  */
     {
 	 (yyval.al) = (yyvsp[-1].al);
 	 (yyval.al).argument_num++;
 	 (yyval.al).argument = realloc ((yyval.al).argument, (yyval.al).argument_num * sizeof (oconfig_value_t));
 	 (yyval.al).argument[(yyval.al).argument_num-1] = (yyvsp[0].cv);
 	}
-#line 1306 "parser.c" /* yacc.c:1646  */
+#line 1307 "parser.c" /* yacc.c:1646  */
     break;
 
   case 9:
-#line 101 "parser.y" /* yacc.c:1646  */
+#line 102 "parser.y" /* yacc.c:1646  */
     {
 	 (yyval.al).argument = malloc (sizeof (oconfig_value_t));
 	 (yyval.al).argument[0] = (yyvsp[0].cv);
 	 (yyval.al).argument_num = 1;
 	}
-#line 1316 "parser.c" /* yacc.c:1646  */
+#line 1317 "parser.c" /* yacc.c:1646  */
     break;
 
   case 10:
-#line 109 "parser.y" /* yacc.c:1646  */
+#line 110 "parser.y" /* yacc.c:1646  */
     {(yyval.string) = strdup ((yyvsp[0].string));}
-#line 1322 "parser.c" /* yacc.c:1646  */
+#line 1323 "parser.c" /* yacc.c:1646  */
     break;
 
   case 11:
-#line 114 "parser.y" /* yacc.c:1646  */
+#line 115 "parser.y" /* yacc.c:1646  */
     {
 	 memset (&(yyval.ci), '\0', sizeof ((yyval.ci)));
 	 (yyval.ci).key = (yyvsp[-2].string);
 	 (yyval.ci).values = (yyvsp[-1].al).argument;
 	 (yyval.ci).values_num = (yyvsp[-1].al).argument_num;
 	}
-#line 1333 "parser.c" /* yacc.c:1646  */
+#line 1334 "parser.c" /* yacc.c:1646  */
     break;
 
   case 12:
-#line 124 "parser.y" /* yacc.c:1646  */
+#line 125 "parser.y" /* yacc.c:1646  */
     {
 	 memset (&(yyval.ci), '\0', sizeof ((yyval.ci)));
 	 (yyval.ci).key = (yyvsp[-2].string);
 	}
-#line 1342 "parser.c" /* yacc.c:1646  */
+#line 1343 "parser.c" /* yacc.c:1646  */
     break;
 
   case 13:
-#line 130 "parser.y" /* yacc.c:1646  */
+#line 131 "parser.y" /* yacc.c:1646  */
     {
 	 memset (&(yyval.ci), '\0', sizeof ((yyval.ci)));
 	 (yyval.ci).key = (yyvsp[-3].string);
 	 (yyval.ci).values = (yyvsp[-2].al).argument;
 	 (yyval.ci).values_num = (yyvsp[-2].al).argument_num;
 	}
-#line 1353 "parser.c" /* yacc.c:1646  */
+#line 1354 "parser.c" /* yacc.c:1646  */
     break;
 
   case 14:
-#line 140 "parser.y" /* yacc.c:1646  */
+#line 141 "parser.y" /* yacc.c:1646  */
     {
 	 (yyval.string) = (yyvsp[-2].string);
 	}
-#line 1361 "parser.c" /* yacc.c:1646  */
+#line 1362 "parser.c" /* yacc.c:1646  */
     break;
 
   case 15:
-#line 147 "parser.y" /* yacc.c:1646  */
+#line 148 "parser.y" /* yacc.c:1646  */
     {
 	 if (strcmp ((yyvsp[-2].ci).key, (yyvsp[0].string)) != 0)
 	 {
 		printf ("block_begin = %s; block_end = %s;\n", (yyvsp[-2].ci).key, (yyvsp[0].string));
 	 	yyerror ("Block not closed..\n");
 		exit (1);
 	 }
 	 free ((yyvsp[0].string)); (yyvsp[0].string) = NULL;
 	 (yyval.ci) = (yyvsp[-2].ci);
 	 (yyval.ci).children = (yyvsp[-1].sl).statement;
 	 (yyval.ci).children_num = (yyvsp[-1].sl).statement_num;
 	}
-#line 1378 "parser.c" /* yacc.c:1646  */
+#line 1379 "parser.c" /* yacc.c:1646  */
     break;
 
   case 16:
-#line 160 "parser.y" /* yacc.c:1646  */
+#line 161 "parser.y" /* yacc.c:1646  */
     {
 	 if (strcmp ((yyvsp[-1].ci).key, (yyvsp[0].string)) != 0)
 	 {
 		printf ("block_begin = %s; block_end = %s;\n", (yyvsp[-1].ci).key, (yyvsp[0].string));
 		yyerror ("Block not closed..\n");
 		exit (1);
 	 }
 	 free ((yyvsp[0].string)); (yyvsp[0].string) = NULL;
 	 (yyval.ci) = (yyvsp[-1].ci);
 	 (yyval.ci).children = NULL;
 	 (yyval.ci).children_num = 0;
 	}
-#line 1395 "parser.c" /* yacc.c:1646  */
+#line 1396 "parser.c" /* yacc.c:1646  */
     break;
 
   case 17:
-#line 175 "parser.y" /* yacc.c:1646  */
+#line 176 "parser.y" /* yacc.c:1646  */
     {(yyval.ci) = (yyvsp[0].ci);}
-#line 1401 "parser.c" /* yacc.c:1646  */
+#line 1402 "parser.c" /* yacc.c:1646  */
     break;
 
   case 18:
-#line 176 "parser.y" /* yacc.c:1646  */
+#line 177 "parser.y" /* yacc.c:1646  */
     {(yyval.ci) = (yyvsp[0].ci);}
-#line 1407 "parser.c" /* yacc.c:1646  */
+#line 1408 "parser.c" /* yacc.c:1646  */
     break;
 
   case 19:
-#line 177 "parser.y" /* yacc.c:1646  */
+#line 178 "parser.y" /* yacc.c:1646  */
     {(yyval.ci).values_num = 0;}
-#line 1413 "parser.c" /* yacc.c:1646  */
+#line 1414 "parser.c" /* yacc.c:1646  */
     break;
 
   case 20:
-#line 182 "parser.y" /* yacc.c:1646  */
+#line 183 "parser.y" /* yacc.c:1646  */
     {
 	 (yyval.sl) = (yyvsp[-1].sl);
 	 if (((yyvsp[0].ci).values_num > 0) || ((yyvsp[0].ci).children_num > 0))
 	 {
 		 (yyval.sl).statement_num++;
 		 (yyval.sl).statement = realloc ((yyval.sl).statement, (yyval.sl).statement_num * sizeof (oconfig_item_t));
 		 (yyval.sl).statement[(yyval.sl).statement_num-1] = (yyvsp[0].ci);
 	 }
 	}
-#line 1427 "parser.c" /* yacc.c:1646  */
+#line 1428 "parser.c" /* yacc.c:1646  */
     break;
 
   case 21:
-#line 192 "parser.y" /* yacc.c:1646  */
+#line 193 "parser.y" /* yacc.c:1646  */
     {
 	 if (((yyvsp[0].ci).values_num > 0) || ((yyvsp[0].ci).children_num > 0))
 	 {
 		 (yyval.sl).statement = malloc (sizeof (oconfig_item_t));
 		 (yyval.sl).statement[0] = (yyvsp[0].ci);
 		 (yyval.sl).statement_num = 1;
@@ -1438,39 +1439,39 @@
 	 else
 	 {
 	 	(yyval.sl).statement = NULL;
 		(yyval.sl).statement_num = 0;
 	 }
 	}
-#line 1445 "parser.c" /* yacc.c:1646  */
+#line 1446 "parser.c" /* yacc.c:1646  */
     break;
 
   case 22:
-#line 209 "parser.y" /* yacc.c:1646  */
+#line 210 "parser.y" /* yacc.c:1646  */
     {
 	 ci_root = malloc (sizeof (oconfig_item_t));
 	 memset (ci_root, '\0', sizeof (oconfig_item_t));
 	 ci_root->children = (yyvsp[0].sl).statement;
 	 ci_root->children_num = (yyvsp[0].sl).statement_num;
 	}
-#line 1456 "parser.c" /* yacc.c:1646  */
+#line 1457 "parser.c" /* yacc.c:1646  */
     break;
 
   case 23:
-#line 216 "parser.y" /* yacc.c:1646  */
+#line 217 "parser.y" /* yacc.c:1646  */
     {
 	 ci_root = malloc (sizeof (oconfig_item_t));
 	 memset (ci_root, '\0', sizeof (oconfig_item_t));
 	 ci_root->children = NULL;
 	 ci_root->children_num = 0;
 	}
-#line 1467 "parser.c" /* yacc.c:1646  */
+#line 1468 "parser.c" /* yacc.c:1646  */
     break;
 
 
-#line 1471 "parser.c" /* yacc.c:1646  */
+#line 1472 "parser.c" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
      that yytoken be updated with the new translation.  We take the
      approach of translating immediately before every use of yytoken.
      One alternative is translating here after every semantic action,
@@ -1692,13 +1693,13 @@
 #if YYERROR_VERBOSE
   if (yymsg != yymsgbuf)
     YYSTACK_FREE (yymsg);
 #endif
   return yyresult;
 }
-#line 224 "parser.y" /* yacc.c:1906  */
+#line 225 "parser.y" /* yacc.c:1906  */
 
 static int yyerror (const char *s)
 {
 	char *text;
 
 	if (*yytext == '\n')
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/parser.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/parser.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/parser.h	2015-03-10 22:29:59.793017264 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/parser.h	2015-12-14 20:29:42.609223817 +0800
@@ -69,13 +69,13 @@
 
 /* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE YYSTYPE;
 union YYSTYPE
 {
-#line 46 "parser.y" /* yacc.c:1909  */
+#line 47 "parser.y" /* yacc.c:1909  */
 
 	double  number;
 	int     boolean;
 	char   *string;
 	oconfig_value_t  cv;
 	oconfig_item_t   ci;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/parser.y /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/parser.y
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/parser.y	2015-03-10 22:14:45.841114412 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/parser.y	2016-01-22 17:51:17.705918688 +0800
@@ -33,12 +33,13 @@
 static char *unquote (const char *orig);
 static int yyerror (const char *s);
 
 /* Lexer variables */
 extern int yylineno;
 extern char *yytext;
+extern int yylex (void);
 
 extern oconfig_item_t *ci_root;
 extern char           *c_file;
 %}
 
 %start entire_file
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/scanner.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/scanner.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/scanner.c	2015-03-10 22:29:59.893019436 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/scanner.c	2016-01-22 17:56:34.905658388 +0800
@@ -3348,12 +3348,13 @@
  * Authors:
  *   Florian Forster <octo at collectd.org>
  *   Sebastian Harl <sh at tokkee.org>
  */
 #line 30 "scanner.l"
 #include <stdlib.h>
+#include <string.h>
 #include "oconfig.h"
 #include "aux_types.h"
 #include "parser.h"
 
 /* multiline string buffer */
 static char *ml_buffer = NULL;
@@ -3367,19 +3368,20 @@
 #ifdef yyterminate
 # undef yyterminate
 #endif
 #define yyterminate() \
 	do { free (ml_buffer); ml_buffer = NULL; ml_pos = 0; ml_len = 0; \
 		return YY_NULL; } while (0)
+#define YY_NO_INPUT 1
 
 /* IPv6 address according to http://www.ietf.org/rfc/rfc2373.txt
  * This supports embedded IPv4 addresses as well but does not strictly check
  * for the right prefix (::0:<v4> or ::FFFF:<v4>) because there are too many
  * ways to correctly represent the zero bytes. It's up to the user to check
  * for valid addresses. */
-#line 3380 "scanner.c"
+#line 3382 "scanner.c"
 
 #define INITIAL 0
 #define ML 1
 
 #ifndef YY_NO_UNISTD_H
 /* Special case for "unistd.h", since it is non-ANSI. We include it way
@@ -3433,14 +3435,12 @@
 extern "C" int yywrap (void );
 #else
 extern int yywrap (void );
 #endif
 #endif
 
-    static void yyunput (int c,char *buf_ptr  );
-    
 #ifndef yytext_ptr
 static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
 
 #ifdef YY_NEED_STRLEN
 static int yy_flex_strlen (yyconst char * );
@@ -3591,13 +3591,13 @@
 		}
 
 		yy_load_buffer_state( );
 		}
 
 	{
-#line 82 "scanner.l"
+#line 85 "scanner.l"
 
 #line 3600 "scanner.c"
 
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
 		yy_cp = (yy_c_buf_p);
@@ -3662,85 +3662,85 @@
 			*yy_cp = (yy_hold_char);
 			yy_cp = (yy_last_accepting_cpos);
 			yy_current_state = (yy_last_accepting_state);
 			goto yy_find_action;
 
 case 1:
-#line 84 "scanner.l"
+#line 87 "scanner.l"
 case 2:
 YY_RULE_SETUP
-#line 84 "scanner.l"
+#line 87 "scanner.l"
 {/* ignore */}
 	YY_BREAK
 case 3:
 /* rule 3 can match eol */
 YY_RULE_SETUP
-#line 86 "scanner.l"
+#line 89 "scanner.l"
 {/* continue line */}
 	YY_BREAK
 case 4:
 /* rule 4 can match eol */
 YY_RULE_SETUP
-#line 88 "scanner.l"
+#line 91 "scanner.l"
 {return (EOL);}
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 89 "scanner.l"
+#line 92 "scanner.l"
 {return (SLASH);}
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 90 "scanner.l"
+#line 93 "scanner.l"
 {return (OPENBRAC);}
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 91 "scanner.l"
+#line 94 "scanner.l"
 {return (CLOSEBRAC);}
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 92 "scanner.l"
+#line 95 "scanner.l"
 {yylval.boolean = 1; return (BTRUE);}
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 93 "scanner.l"
+#line 96 "scanner.l"
 {yylval.boolean = 0; return (BFALSE);}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 95 "scanner.l"
+#line 98 "scanner.l"
 {yylval.string = yytext; return (UNQUOTED_STRING);}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 96 "scanner.l"
+#line 99 "scanner.l"
 {yylval.string = yytext; return (UNQUOTED_STRING);}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 98 "scanner.l"
+#line 101 "scanner.l"
 {yylval.number = strtod (yytext, NULL); return (NUMBER);}
 	YY_BREAK
 case 13:
 /* rule 13 can match eol */
 YY_RULE_SETUP
-#line 100 "scanner.l"
+#line 103 "scanner.l"
 {yylval.string = yytext; return (QUOTED_STRING);}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 101 "scanner.l"
+#line 104 "scanner.l"
 {yylval.string = yytext; return (UNQUOTED_STRING);}
 	YY_BREAK
 case 15:
 /* rule 15 can match eol */
 YY_RULE_SETUP
-#line 103 "scanner.l"
+#line 106 "scanner.l"
 {
 	int len = strlen (yytext);
 
 	ml_pos = 0;
 
 	/* remove "\\<EOL>" */
@@ -3753,19 +3753,19 @@
 	ml_append (yytext);
 	BEGIN (ML);
 }
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 118 "scanner.l"
+#line 121 "scanner.l"
 {/* remove leading white-space */}
 	YY_BREAK
 case 17:
 /* rule 17 can match eol */
 YY_RULE_SETUP
-#line 119 "scanner.l"
+#line 122 "scanner.l"
 {
 	int len = strlen (yytext);
 
 	/* remove "\\<EOL>" */
 	if ('\r' == yytext[len - 2])
 		len -= 3;
@@ -3776,24 +3776,24 @@
 	ml_append(yytext);
 }
 	YY_BREAK
 case 18:
 /* rule 18 can match eol */
 YY_RULE_SETUP
-#line 131 "scanner.l"
+#line 134 "scanner.l"
 {
 	ml_append(yytext);
 	yylval.string = ml_buffer;
 
 	BEGIN (INITIAL);
 	return (QUOTED_STRING);
 }
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 138 "scanner.l"
+#line 141 "scanner.l"
 ECHO;
 	YY_BREAK
 #line 3797 "scanner.c"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(ML):
 	yyterminate();
@@ -4122,53 +4122,12 @@
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 	yy_is_jam = (yy_current_state == 1518);
 
 		return yy_is_jam ? 0 : yy_current_state;
 }
 
-    static void yyunput (int c, register char * yy_bp )
-{
-	register char *yy_cp;
-    
-    yy_cp = (yy_c_buf_p);
-
-	/* undo effects of setting up yytext */
-	*yy_cp = (yy_hold_char);
-
-	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register yy_size_t number_to_move = (yy_n_chars) + 2;
-		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
-					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
-		register char *source =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
-
-		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
-
-		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-    if ( c == '\n' ){
-        --yylineno;
-    }
-
-	(yytext_ptr) = yy_bp;
-	(yy_hold_char) = *yy_cp;
-	(yy_c_buf_p) = yy_cp;
-}
-
 #ifndef YY_NO_INPUT
 #ifdef __cplusplus
     static int yyinput (void)
 #else
     static int input  (void)
 #endif
@@ -4800,13 +4759,13 @@
 {
 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
 }
 
 #define YYTABLES_NAME "yytables"
 
-#line 137 "scanner.l"
+#line 140 "scanner.l"
 
 
 static void ml_append (char *string)
 {
 	int len = strlen (string);
 	int s;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/scanner.l /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/scanner.l
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/liboconfig/scanner.l	2015-03-10 22:14:45.841114412 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/liboconfig/scanner.l	2016-01-22 17:51:17.705918688 +0800
@@ -25,12 +25,13 @@
  *   Florian Forster <octo at collectd.org>
  *   Sebastian Harl <sh at tokkee.org>
  */
 
 %{
 #include <stdlib.h>
+#include <string.h>
 #include "oconfig.h"
 #include "aux_types.h"
 #include "parser.h"
 
 /* multiline string buffer */
 static char *ml_buffer = NULL;
@@ -47,12 +48,14 @@
 #define yyterminate() \
 	do { free (ml_buffer); ml_buffer = NULL; ml_pos = 0; ml_len = 0; \
 		return YY_NULL; } while (0)
 %}
 %option yylineno
 %option noyywrap
+%option noinput
+%option nounput
 %x ML
 WHITE_SPACE [\ \t\b]
 NON_WHITE_SPACE [^\ \t\b]
 EOL (\r\n|\n)
 QUOTED_STRING ([^\\"]+|\\.)*
 UNQUOTED_STRING [0-9A-Za-z_]+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/log_logstash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/log_logstash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/log_logstash.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/log_logstash.c	2016-01-22 17:51:17.705918688 +0800
@@ -144,13 +144,13 @@
 	gmtime_r (&tt, &timestamp_tm);
 
 	/*
 	 * format time as a UTC ISO 8601 compliant string
 	 */
 	strftime (timestamp_str, sizeof (timestamp_str),
-		  "%Y-%m-%d %H:%M:%SZ", &timestamp_tm);
+		  "%Y-%m-%dT%H:%M:%SZ", &timestamp_tm);
 	timestamp_str[sizeof (timestamp_str) - 1] = '\0';
 
 	if (yajl_gen_string(g, (u_char *)timestamp_str,
 			    strlen(timestamp_str)) !=
 	    yajl_gen_status_ok)
 		goto err;
@@ -205,13 +205,13 @@
 
 static void log_logstash_log (int severity, const char *msg,
 		user_data_t __attribute__((unused)) *user_data)
 {
 	yajl_gen g;
 #if !defined(HAVE_YAJL_V2)
-	yajl_gen_config conf;
+	yajl_gen_config conf = {};
 
 	conf.beautify = 0;
 #endif
 
 	if (severity > log_level)
 		return;
@@ -249,13 +249,13 @@
 		user_data_t __attribute__((unused)) *user_data)
 {
 	yajl_gen g;
 #if HAVE_YAJL_V2
 	g = yajl_gen_alloc(NULL);
 #else
-	yajl_gen_config conf;
+	yajl_gen_config conf = {};
 
 	conf.beautify = 0;
 	g = yajl_gen_alloc(&conf, NULL);
 #endif
 
 	if (g == NULL) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/madwifi.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/madwifi.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/madwifi.c	2014-08-18 15:33:14.292460715 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/madwifi.c	2016-01-22 17:37:50.190392655 +0800
@@ -818,21 +818,22 @@
 	char buf[PATH_MAX];
 	char buf2[PATH_MAX];
 	int i;
 
 	if (dev[0] == '.')
 		return 0;
-	
+
 	ssnprintf (buf, sizeof (buf), "/sys/class/net/%s/device/driver", dev);
-	buf[sizeof (buf) - 1] = 0;
+	buf[sizeof (buf) - 1] = '\0';
 
-	memset (buf2, 0, sizeof (buf2));
 	i = readlink (buf, buf2, sizeof (buf2) - 1);
 	if (i < 0)
 		return 0;
 
+	buf2[i] = '\0';
+
 	if (strstr (buf2, "/drivers/ath_") == NULL)
 		return 0;
 	return 1;
 }
 
 static int
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/Makefile.am	2015-05-27 03:38:14.116865752 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/Makefile.am	2016-01-22 17:51:17.693918698 +0800
@@ -96,12 +96,13 @@
 endif
 
 if BUILD_PLUGIN_AMQP
 pkglib_LTLIBRARIES += amqp.la
 amqp_la_SOURCES = amqp.c \
 		  utils_cmd_putval.c utils_cmd_putval.h \
+  	          utils_parse_option.c utils_parse_option.h \
 		  utils_format_graphite.c utils_format_graphite.h \
 		  utils_format_json.c utils_format_json.h
 amqp_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBRABBITMQ_LDFLAGS)
 amqp_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBRABBITMQ_CPPFLAGS)
 amqp_la_LIBADD = $(BUILD_WITH_LIBRABBITMQ_LIBS)
 endif
@@ -186,14 +187,13 @@
 ceph_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBYAJL_CPPFLAGS)
 ceph_la_LIBADD = $(BUILD_WITH_LIBYAJL_LIBS)
 endif
 
 if BUILD_PLUGIN_CGROUPS
 pkglib_LTLIBRARIES += cgroups.la
-cgroups_la_SOURCES = cgroups.c \
-		     utils_ignorelist.c utils_ignorelist.h
+cgroups_la_SOURCES = cgroups.c
 cgroups_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 cgroups_la_LIBADD = libmount.la
 endif
 
 if BUILD_PLUGIN_CONNTRACK
 pkglib_LTLIBRARIES += conntrack.la
@@ -286,22 +286,20 @@
 dbi_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBDBI_LDFLAGS)
 dbi_la_LIBADD = $(BUILD_WITH_LIBDBI_LIBS)
 endif
 
 if BUILD_PLUGIN_DF
 pkglib_LTLIBRARIES += df.la
-df_la_SOURCES = df.c \
-		utils_ignorelist.c utils_ignorelist.h
+df_la_SOURCES = df.c
 df_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 df_la_LIBADD = libmount.la
 endif
 
 if BUILD_PLUGIN_DISK
 pkglib_LTLIBRARIES += disk.la
-disk_la_SOURCES = disk.c \
-		  utils_ignorelist.c utils_ignorelist.h
+disk_la_SOURCES = disk.c
 disk_la_CFLAGS = $(AM_CFLAGS)
 disk_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 disk_la_LIBADD =
 if BUILD_WITH_LIBKSTAT
 disk_la_LIBADD += -lkstat
 endif
@@ -395,14 +393,13 @@
 hddtemp_la_LIBADD += -lsocket
 endif
 endif
 
 if BUILD_PLUGIN_INTERFACE
 pkglib_LTLIBRARIES += interface.la
-interface_la_SOURCES = interface.c \
-		       utils_ignorelist.c utils_ignorelist.h
+interface_la_SOURCES = interface.c
 interface_la_CFLAGS = $(AM_CFLAGS)
 interface_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 interface_la_LIBADD =
 if BUILD_WITH_LIBSTATGRAB
 interface_la_CFLAGS += $(BUILD_WITH_LIBSTATGRAB_CFLAGS)
 interface_la_LIBADD += $(BUILD_WITH_LIBSTATGRAB_LDFLAGS)
@@ -433,14 +430,13 @@
 iptables_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 iptables_la_LIBADD = $(BUILD_WITH_LIBIPTC_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_IPMI
 pkglib_LTLIBRARIES += ipmi.la
-ipmi_la_SOURCES = ipmi.c \
-		  utils_ignorelist.c utils_ignorelist.h
+ipmi_la_SOURCES = ipmi.c
 ipmi_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_OPENIPMI_CFLAGS)
 ipmi_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 ipmi_la_LIBADD = $(BUILD_WITH_OPENIPMI_LIBS)
 endif
 
 if BUILD_PLUGIN_IPVS
@@ -451,14 +447,13 @@
 endif
 ipvs_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_IRQ
 pkglib_LTLIBRARIES += irq.la
-irq_la_SOURCES = irq.c \
-		 utils_ignorelist.c utils_ignorelist.h
+irq_la_SOURCES = irq.c
 irq_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_JAVA
 pkglib_LTLIBRARIES += java.la
 java_la_SOURCES = java.c
@@ -511,14 +506,13 @@
 lvm_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 lvm_la_LIBADD = $(BUILD_WITH_LIBLVM2APP_LIBS)
 endif
 
 if BUILD_PLUGIN_MADWIFI
 pkglib_LTLIBRARIES += madwifi.la
-madwifi_la_SOURCES = madwifi.c madwifi.h \
-		     utils_ignorelist.c utils_ignorelist.h
+madwifi_la_SOURCES = madwifi.c madwifi.h
 madwifi_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_MATCH_EMPTY_COUNTER
 pkglib_LTLIBRARIES += match_empty_counter.la
 match_empty_counter_la_SOURCES = match_empty_counter.c
@@ -558,14 +552,13 @@
 mbmon_la_LIBADD += -lsocket
 endif
 endif
 
 if BUILD_PLUGIN_MD
 pkglib_LTLIBRARIES += md.la
-md_la_SOURCES = md.c \
-		utils_ignorelist.c utils_ignorelist.h
+md_la_SOURCES = md.c
 md_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_MEMCACHEC
 pkglib_LTLIBRARIES += memcachec.la
 memcachec_la_SOURCES = memcachec.c
@@ -604,14 +597,13 @@
 memory_la_LIBADD += -lperfstat
 endif
 endif
 
 if BUILD_PLUGIN_MIC
 pkglib_LTLIBRARIES += mic.la
-mic_la_SOURCES = mic.c \
-		 utils_ignorelist.c utils_ignorelist.h
+mic_la_SOURCES = mic.c
 mic_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_MIC_LIBPATH)
 mic_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_MIC_CPPFLAGS)
 mic_la_LIBADD = $(BUILD_WITH_MIC_LDADD)
 endif
 
 if BUILD_PLUGIN_MODBUS
@@ -639,14 +631,13 @@
 mysql_la_LIBADD += $(BUILD_WITH_LIBMYSQL_LIBS)
 endif
 endif
 
 if BUILD_PLUGIN_NETAPP
 pkglib_LTLIBRARIES += netapp.la
-netapp_la_SOURCES = netapp.c \
-		    utils_ignorelist.c utils_ignorelist.h
+netapp_la_SOURCES = netapp.c
 netapp_la_CPPFLAGS = $(AM_CPPFLAGS) $(LIBNETAPP_CPPFLAGS)
 netapp_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(LIBNETAPP_LDFLAGS)
 netapp_la_LIBADD = $(LIBNETAPP_LIBS)
 endif
 
 if BUILD_PLUGIN_NETLINK
@@ -746,14 +737,13 @@
 olsrd_la_LIBADD += -lsocket
 endif
 endif
 
 if BUILD_PLUGIN_ONEWIRE
 pkglib_LTLIBRARIES += onewire.la
-onewire_la_SOURCES = onewire.c \
-		     utils_ignorelist.c utils_ignorelist.h
+onewire_la_SOURCES = onewire.c
 onewire_la_CFLAGS = $(AM_CFLAGS)
 onewire_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBOWCAPI_CPPFLAGS)
 onewire_la_LIBADD = $(BUILD_WITH_LIBOWCAPI_LIBS)
 onewire_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
@@ -860,14 +850,13 @@
 processes_la_LIBADD += -lkvm
 endif
 endif
 
 if BUILD_PLUGIN_PROTOCOLS
 pkglib_LTLIBRARIES += protocols.la
-protocols_la_SOURCES = protocols.c \
-		       utils_ignorelist.c utils_ignorelist.h
+protocols_la_SOURCES = protocols.c
 protocols_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_REDIS
 pkglib_LTLIBRARIES += redis.la
 redis_la_SOURCES = redis.c
@@ -899,14 +888,13 @@
 rrdtool_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBRRD_CFLAGS)
 rrdtool_la_LIBADD = $(BUILD_WITH_LIBRRD_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_SENSORS
 pkglib_LTLIBRARIES += sensors.la
-sensors_la_SOURCES = sensors.c \
-		     utils_ignorelist.c utils_ignorelist.h
+sensors_la_SOURCES = sensors.c
 sensors_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBSENSORS_CFLAGS)
 sensors_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBSENSORS_LDFLAGS)
 sensors_la_LIBADD = -lsensors
 endif
 
 if BUILD_PLUGIN_SERIAL
@@ -923,14 +911,13 @@
 sigrok_la_LIBADD = -lsigrok
 endif
 
 if BUILD_PLUGIN_SMART
 if BUILD_WITH_LIBUDEV
 pkglib_LTLIBRARIES += smart.la
-smart_la_SOURCES = smart.c \
-		   utils_ignorelist.c utils_ignorelist.h
+smart_la_SOURCES = smart.c
 smart_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBATASMART_CPPFLAGS)
 smart_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBATASMART_LDFLAGS)
 smart_la_LIBADD = $(BUILD_WITH_LIBATASMART_LIBS) -ludev
 endif
 endif
 
@@ -951,13 +938,13 @@
 
 if BUILD_PLUGIN_STATSD
 pkglib_LTLIBRARIES += statsd.la
 statsd_la_SOURCES = statsd.c \
                     utils_latency.h utils_latency.c
 statsd_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-statsd_la_LIBADD = -lpthread
+statsd_la_LIBADD = -lpthread -lm
 endif
 
 if BUILD_PLUGIN_SWAP
 pkglib_LTLIBRARIES += swap.la
 swap_la_SOURCES = swap.c
 swap_la_CFLAGS = $(AM_CFLAGS)
@@ -1064,14 +1051,13 @@
 ted_la_SOURCES = ted.c
 ted_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_THERMAL
 pkglib_LTLIBRARIES += thermal.la
-thermal_la_SOURCES = thermal.c \
-		     utils_ignorelist.c utils_ignorelist.h
+thermal_la_SOURCES = thermal.c
 thermal_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
 if BUILD_PLUGIN_THRESHOLD
 pkglib_LTLIBRARIES += threshold.la
 threshold_la_SOURCES = threshold.c
@@ -1150,14 +1136,13 @@
 varnish_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBVARNISH_CFLAGS)
 varnish_la_LIBADD = $(BUILD_WITH_LIBVARNISH_LIBS)
 endif
 
 if BUILD_PLUGIN_VIRT
 pkglib_LTLIBRARIES += virt.la
-virt_la_SOURCES = virt.c \
-		  utils_ignorelist.c utils_ignorelist.h
+virt_la_SOURCES = virt.c
 virt_la_CFLAGS = $(AM_CFLAGS) \
 		$(BUILD_WITH_LIBVIRT_CFLAGS) $(BUILD_WITH_LIBXML2_CFLAGS)
 virt_la_LIBADD = $(BUILD_WITH_LIBVIRT_LIBS) $(BUILD_WITH_LIBXML2_LIBS)
 virt_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 endif
 
@@ -1338,31 +1323,36 @@
 		>.pod2man.tmp.$$$$ 2>/dev/null && mv -f .pod2man.tmp.$$$$ $@ || true
 	@if grep '\<POD ERRORS\>' $@ >/dev/null 2>&1; \
 	then \
 		echo "$@ has some POD errors!"; false; \
 	fi
 
+AM_V_PROTOC_C = $(am__v_PROTOC_C_@AM_V@)
+am__v_PROTOC_C_ = $(am__v_PROTOC_C_@AM_DEFAULT_V@)
+am__v_PROTOC_C_0 = @echo "  PROTOC-C    " $@;
+am__v_PROTOC_C_1 =
+
 # Protocol buffer for the "pinba" plugin.
 EXTRA_DIST += pinba.proto
-if HAVE_PROTOC_C
+if BUILD_PLUGIN_PINBA
 CLEANFILES += pinba.pb-c.c pinba.pb-c.h
 BUILT_SOURCES += pinba.pb-c.c pinba.pb-c.h
 
 pinba.pb-c.c pinba.pb-c.h: pinba.proto
-	protoc-c -I$(srcdir) --c_out . $(srcdir)/pinba.proto
+	$(AM_V_PROTOC_C)protoc-c -I$(srcdir) --c_out . $(srcdir)/pinba.proto
 endif
 
 # Protocol buffer for the "write_riemann" plugin.
 EXTRA_DIST += riemann.proto
-if HAVE_PROTOC_C
+if BUILD_PLUGIN_WRITE_RIEMANN
 CLEANFILES += riemann.pb-c.c riemann.pb-c.h
 
 BUILT_SOURCES += riemann.pb-c.c riemann.pb-c.h
 
 riemann.pb-c.c riemann.pb-c.h: riemann.proto
-	protoc-c -I$(srcdir) --c_out . $(srcdir)/riemann.proto
+	$(AM_V_PROTOC_C)protoc-c -I$(srcdir) --c_out . $(srcdir)/riemann.proto
 endif
 
 install-exec-hook:
 	$(mkinstalldirs) $(DESTDIR)$(sysconfdir)
 	if test -e $(DESTDIR)$(sysconfdir)/collectd.conf; \
 	then \
@@ -1386,6 +1376,15 @@
 test_utils_mount_LDADD = libmount.la daemon/libplugin_mock.la
 
 test_utils_vl_lookup_SOURCES = utils_vl_lookup_test.c testing.h
 test_utils_vl_lookup_LDADD = liblookup.la daemon/libplugin_mock.la
 
 TESTS = test_utils_mount test_utils_vl_lookup
+
+if BUILD_PLUGIN_CEPH
+test_plugin_ceph_SOURCES = ceph_test.c
+test_plugin_ceph_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBYAJL_CPPFLAGS)
+test_plugin_ceph_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBYAJL_LDFLAGS)
+test_plugin_ceph_LDADD = daemon/libcommon.la daemon/libplugin_mock.la $(BUILD_WITH_LIBYAJL_LIBS)
+check_PROGRAMS += test_plugin_ceph
+TESTS += test_plugin_ceph
+endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/Makefile.in	2015-05-27 15:51:49.001922959 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/Makefile.in	2016-01-22 17:55:46.609693764 +0800
@@ -292,19 +292,22 @@
 @BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am__append_206 = write_riemann.la
 @BUILD_PLUGIN_WRITE_SENSU_TRUE@am__append_207 = write_sensu.la
 @BUILD_PLUGIN_WRITE_TSDB_TRUE@am__append_208 = write_tsdb.la
 @BUILD_PLUGIN_XMMS_TRUE@am__append_209 = xmms.la
 @BUILD_PLUGIN_ZFS_ARC_TRUE@am__append_210 = zfs_arc.la
 @BUILD_PLUGIN_ZOOKEEPER_TRUE@am__append_211 = zookeeper.la
-@HAVE_PROTOC_C_TRUE@am__append_212 = pinba.pb-c.c pinba.pb-c.h \
-@HAVE_PROTOC_C_TRUE@	riemann.pb-c.c riemann.pb-c.h
-@HAVE_PROTOC_C_TRUE@am__append_213 = pinba.pb-c.c pinba.pb-c.h \
-@HAVE_PROTOC_C_TRUE@	riemann.pb-c.c riemann.pb-c.h
+@BUILD_PLUGIN_PINBA_TRUE@am__append_212 = pinba.pb-c.c pinba.pb-c.h
+@BUILD_PLUGIN_PINBA_TRUE@am__append_213 = pinba.pb-c.c pinba.pb-c.h
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am__append_214 = riemann.pb-c.c riemann.pb-c.h
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@am__append_215 = riemann.pb-c.c riemann.pb-c.h
 check_PROGRAMS = test_utils_mount$(EXEEXT) \
-	test_utils_vl_lookup$(EXEEXT)
-TESTS = test_utils_mount$(EXEEXT) test_utils_vl_lookup$(EXEEXT)
+	test_utils_vl_lookup$(EXEEXT) $(am__EXEEXT_1)
+TESTS = test_utils_mount$(EXEEXT) test_utils_vl_lookup$(EXEEXT) \
+	$(am__EXEEXT_1)
+@BUILD_PLUGIN_CEPH_TRUE@am__append_216 = test_plugin_ceph
+@BUILD_PLUGIN_CEPH_TRUE@am__append_217 = test_plugin_ceph
 subdir = src
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(srcdir)/config.h.in $(srcdir)/collectd.conf.in \
 	$(top_srcdir)/libltdl/config/depcomp $(dist_man_MANS) \
 	$(top_srcdir)/libltdl/config/test-driver
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -363,17 +366,18 @@
 	$@
 @BUILD_PLUGIN_AGGREGATION_TRUE@am_aggregation_la_rpath = -rpath \
 @BUILD_PLUGIN_AGGREGATION_TRUE@	$(pkglibdir)
 am__DEPENDENCIES_1 =
 @BUILD_PLUGIN_AMQP_TRUE@amqp_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
 am__amqp_la_SOURCES_DIST = amqp.c utils_cmd_putval.c \
-	utils_cmd_putval.h utils_format_graphite.c \
-	utils_format_graphite.h utils_format_json.c \
-	utils_format_json.h
+	utils_cmd_putval.h utils_parse_option.c utils_parse_option.h \
+	utils_format_graphite.c utils_format_graphite.h \
+	utils_format_json.c utils_format_json.h
 @BUILD_PLUGIN_AMQP_TRUE@am_amqp_la_OBJECTS = amqp_la-amqp.lo \
 @BUILD_PLUGIN_AMQP_TRUE@	amqp_la-utils_cmd_putval.lo \
+@BUILD_PLUGIN_AMQP_TRUE@	amqp_la-utils_parse_option.lo \
 @BUILD_PLUGIN_AMQP_TRUE@	amqp_la-utils_format_graphite.lo \
 @BUILD_PLUGIN_AMQP_TRUE@	amqp_la-utils_format_json.lo
 amqp_la_OBJECTS = $(am_amqp_la_OBJECTS)
 amqp_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(amqp_la_LDFLAGS) $(LDFLAGS) -o $@
@@ -460,16 +464,14 @@
 ceph_la_OBJECTS = $(am_ceph_la_OBJECTS)
 ceph_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ceph_la_CFLAGS) \
 	$(CFLAGS) $(ceph_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_CEPH_TRUE@am_ceph_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_CGROUPS_TRUE@cgroups_la_DEPENDENCIES = libmount.la
-am__cgroups_la_SOURCES_DIST = cgroups.c utils_ignorelist.c \
-	utils_ignorelist.h
-@BUILD_PLUGIN_CGROUPS_TRUE@am_cgroups_la_OBJECTS = cgroups.lo \
-@BUILD_PLUGIN_CGROUPS_TRUE@	utils_ignorelist.lo
+am__cgroups_la_SOURCES_DIST = cgroups.c
+@BUILD_PLUGIN_CGROUPS_TRUE@am_cgroups_la_OBJECTS = cgroups.lo
 cgroups_la_OBJECTS = $(am_cgroups_la_OBJECTS)
 cgroups_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(cgroups_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_CGROUPS_TRUE@am_cgroups_la_rpath = -rpath $(pkglibdir)
 conntrack_la_LIBADD =
@@ -561,29 +563,27 @@
 dbi_la_OBJECTS = $(am_dbi_la_OBJECTS)
 dbi_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(dbi_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_DBI_TRUE@am_dbi_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_DF_TRUE@df_la_DEPENDENCIES = libmount.la
-am__df_la_SOURCES_DIST = df.c utils_ignorelist.c utils_ignorelist.h
-@BUILD_PLUGIN_DF_TRUE@am_df_la_OBJECTS = df.lo utils_ignorelist.lo
+am__df_la_SOURCES_DIST = df.c
+@BUILD_PLUGIN_DF_TRUE@am_df_la_OBJECTS = df.lo
 df_la_OBJECTS = $(am_df_la_OBJECTS)
 df_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(df_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_DF_TRUE@am_df_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_DISK_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__DEPENDENCIES_6 = $(am__DEPENDENCIES_1)
 @BUILD_PLUGIN_DISK_TRUE@disk_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 @BUILD_PLUGIN_DISK_TRUE@	$(am__DEPENDENCIES_1) \
 @BUILD_PLUGIN_DISK_TRUE@	$(am__DEPENDENCIES_6) \
 @BUILD_PLUGIN_DISK_TRUE@	$(am__DEPENDENCIES_1) \
 @BUILD_PLUGIN_DISK_TRUE@	$(am__DEPENDENCIES_1)
-am__disk_la_SOURCES_DIST = disk.c utils_ignorelist.c \
-	utils_ignorelist.h
-@BUILD_PLUGIN_DISK_TRUE@am_disk_la_OBJECTS = disk_la-disk.lo \
-@BUILD_PLUGIN_DISK_TRUE@	disk_la-utils_ignorelist.lo
+am__disk_la_SOURCES_DIST = disk.c
+@BUILD_PLUGIN_DISK_TRUE@am_disk_la_OBJECTS = disk_la-disk.lo
 disk_la_OBJECTS = $(am_disk_la_OBJECTS)
 disk_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(disk_la_CFLAGS) \
 	$(CFLAGS) $(disk_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_DISK_TRUE@am_disk_la_rpath = -rpath $(pkglibdir)
 dns_la_DEPENDENCIES =
@@ -685,17 +685,15 @@
 @BUILD_PLUGIN_INTERFACE_TRUE@@BUILD_WITH_LIBSTATGRAB_TRUE@am__DEPENDENCIES_7 = $(am__DEPENDENCIES_1)
 @BUILD_PLUGIN_INTERFACE_TRUE@interface_la_DEPENDENCIES =  \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__DEPENDENCIES_7) \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__DEPENDENCIES_1) \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__DEPENDENCIES_1) \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__DEPENDENCIES_1)
-am__interface_la_SOURCES_DIST = interface.c utils_ignorelist.c \
-	utils_ignorelist.h
+am__interface_la_SOURCES_DIST = interface.c
 @BUILD_PLUGIN_INTERFACE_TRUE@am_interface_la_OBJECTS =  \
-@BUILD_PLUGIN_INTERFACE_TRUE@	interface_la-interface.lo \
-@BUILD_PLUGIN_INTERFACE_TRUE@	interface_la-utils_ignorelist.lo
+@BUILD_PLUGIN_INTERFACE_TRUE@	interface_la-interface.lo
 interface_la_OBJECTS = $(am_interface_la_OBJECTS)
 interface_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(interface_la_CFLAGS) \
 	$(CFLAGS) $(interface_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_INTERFACE_TRUE@am_interface_la_rpath = -rpath \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(pkglibdir)
@@ -705,16 +703,14 @@
 ipc_la_OBJECTS = $(am_ipc_la_OBJECTS)
 ipc_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ipc_la_CFLAGS) $(CFLAGS) \
 	$(ipc_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_IPC_TRUE@am_ipc_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_IPMI_TRUE@ipmi_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
-am__ipmi_la_SOURCES_DIST = ipmi.c utils_ignorelist.c \
-	utils_ignorelist.h
-@BUILD_PLUGIN_IPMI_TRUE@am_ipmi_la_OBJECTS = ipmi_la-ipmi.lo \
-@BUILD_PLUGIN_IPMI_TRUE@	ipmi_la-utils_ignorelist.lo
+am__ipmi_la_SOURCES_DIST = ipmi.c
+@BUILD_PLUGIN_IPMI_TRUE@am_ipmi_la_OBJECTS = ipmi_la-ipmi.lo
 ipmi_la_OBJECTS = $(am_ipmi_la_OBJECTS)
 ipmi_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ipmi_la_CFLAGS) \
 	$(CFLAGS) $(ipmi_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_IPMI_TRUE@am_ipmi_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_IPTABLES_TRUE@iptables_la_DEPENDENCIES =  \
@@ -733,14 +729,14 @@
 ipvs_la_OBJECTS = $(am_ipvs_la_OBJECTS)
 ipvs_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(ipvs_la_CFLAGS) \
 	$(CFLAGS) $(ipvs_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_IPVS_TRUE@am_ipvs_la_rpath = -rpath $(pkglibdir)
 irq_la_LIBADD =
-am__irq_la_SOURCES_DIST = irq.c utils_ignorelist.c utils_ignorelist.h
-@BUILD_PLUGIN_IRQ_TRUE@am_irq_la_OBJECTS = irq.lo utils_ignorelist.lo
+am__irq_la_SOURCES_DIST = irq.c
+@BUILD_PLUGIN_IRQ_TRUE@am_irq_la_OBJECTS = irq.lo
 irq_la_OBJECTS = $(am_irq_la_OBJECTS)
 irq_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(irq_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_IRQ_TRUE@am_irq_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_JAVA_TRUE@java_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
@@ -800,16 +796,14 @@
 lvm_la_OBJECTS = $(am_lvm_la_OBJECTS)
 lvm_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(lvm_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_LVM_TRUE@am_lvm_la_rpath = -rpath $(pkglibdir)
 madwifi_la_LIBADD =
-am__madwifi_la_SOURCES_DIST = madwifi.c madwifi.h utils_ignorelist.c \
-	utils_ignorelist.h
-@BUILD_PLUGIN_MADWIFI_TRUE@am_madwifi_la_OBJECTS = madwifi.lo \
-@BUILD_PLUGIN_MADWIFI_TRUE@	utils_ignorelist.lo
+am__madwifi_la_SOURCES_DIST = madwifi.c madwifi.h
+@BUILD_PLUGIN_MADWIFI_TRUE@am_madwifi_la_OBJECTS = madwifi.lo
 madwifi_la_OBJECTS = $(am_madwifi_la_OBJECTS)
 madwifi_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(madwifi_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_MADWIFI_TRUE@am_madwifi_la_rpath = -rpath $(pkglibdir)
 match_empty_counter_la_LIBADD =
@@ -874,14 +868,14 @@
 mbmon_la_OBJECTS = $(am_mbmon_la_OBJECTS)
 mbmon_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(mbmon_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_MBMON_TRUE@am_mbmon_la_rpath = -rpath $(pkglibdir)
 md_la_LIBADD =
-am__md_la_SOURCES_DIST = md.c utils_ignorelist.c utils_ignorelist.h
-@BUILD_PLUGIN_MD_TRUE@am_md_la_OBJECTS = md.lo utils_ignorelist.lo
+am__md_la_SOURCES_DIST = md.c
+@BUILD_PLUGIN_MD_TRUE@am_md_la_OBJECTS = md.lo
 md_la_OBJECTS = $(am_md_la_OBJECTS)
 md_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(md_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_MD_TRUE@am_md_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_DEPENDENCIES =  \
@@ -916,15 +910,14 @@
 memory_la_OBJECTS = $(am_memory_la_OBJECTS)
 memory_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(memory_la_CFLAGS) \
 	$(CFLAGS) $(memory_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_MEMORY_TRUE@am_memory_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_MIC_TRUE@mic_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
-am__mic_la_SOURCES_DIST = mic.c utils_ignorelist.c utils_ignorelist.h
-@BUILD_PLUGIN_MIC_TRUE@am_mic_la_OBJECTS = mic_la-mic.lo \
-@BUILD_PLUGIN_MIC_TRUE@	mic_la-utils_ignorelist.lo
+am__mic_la_SOURCES_DIST = mic.c
+@BUILD_PLUGIN_MIC_TRUE@am_mic_la_OBJECTS = mic_la-mic.lo
 mic_la_OBJECTS = $(am_mic_la_OBJECTS)
 mic_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(mic_la_CFLAGS) $(CFLAGS) \
 	$(mic_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_MIC_TRUE@am_mic_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_MODBUS_TRUE@modbus_la_DEPENDENCIES =  \
@@ -955,16 +948,14 @@
 mysql_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(mysql_la_CFLAGS) \
 	$(CFLAGS) $(mysql_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_MYSQL_TRUE@am_mysql_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_NETAPP_TRUE@netapp_la_DEPENDENCIES =  \
 @BUILD_PLUGIN_NETAPP_TRUE@	$(am__DEPENDENCIES_1)
-am__netapp_la_SOURCES_DIST = netapp.c utils_ignorelist.c \
-	utils_ignorelist.h
-@BUILD_PLUGIN_NETAPP_TRUE@am_netapp_la_OBJECTS = netapp_la-netapp.lo \
-@BUILD_PLUGIN_NETAPP_TRUE@	netapp_la-utils_ignorelist.lo
+am__netapp_la_SOURCES_DIST = netapp.c
+@BUILD_PLUGIN_NETAPP_TRUE@am_netapp_la_OBJECTS = netapp_la-netapp.lo
 netapp_la_OBJECTS = $(am_netapp_la_OBJECTS)
 netapp_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(netapp_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_NETAPP_TRUE@am_netapp_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_NETLINK_TRUE@netlink_la_DEPENDENCIES =  \
@@ -1063,17 +1054,15 @@
 olsrd_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(olsrd_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_OLSRD_TRUE@am_olsrd_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_DEPENDENCIES =  \
 @BUILD_PLUGIN_ONEWIRE_TRUE@	$(am__DEPENDENCIES_1)
-am__onewire_la_SOURCES_DIST = onewire.c utils_ignorelist.c \
-	utils_ignorelist.h
+am__onewire_la_SOURCES_DIST = onewire.c
 @BUILD_PLUGIN_ONEWIRE_TRUE@am_onewire_la_OBJECTS =  \
-@BUILD_PLUGIN_ONEWIRE_TRUE@	onewire_la-onewire.lo \
-@BUILD_PLUGIN_ONEWIRE_TRUE@	onewire_la-utils_ignorelist.lo
+@BUILD_PLUGIN_ONEWIRE_TRUE@	onewire_la-onewire.lo
 onewire_la_OBJECTS = $(am_onewire_la_OBJECTS)
 onewire_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(onewire_la_CFLAGS) \
 	$(CFLAGS) $(onewire_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_ONEWIRE_TRUE@am_onewire_la_rpath = -rpath $(pkglibdir)
 openldap_la_DEPENDENCIES =
@@ -1166,16 +1155,14 @@
 processes_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(processes_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_PROCESSES_TRUE@am_processes_la_rpath = -rpath \
 @BUILD_PLUGIN_PROCESSES_TRUE@	$(pkglibdir)
 protocols_la_LIBADD =
-am__protocols_la_SOURCES_DIST = protocols.c utils_ignorelist.c \
-	utils_ignorelist.h
-@BUILD_PLUGIN_PROTOCOLS_TRUE@am_protocols_la_OBJECTS = protocols.lo \
-@BUILD_PLUGIN_PROTOCOLS_TRUE@	utils_ignorelist.lo
+am__protocols_la_SOURCES_DIST = protocols.c
+@BUILD_PLUGIN_PROTOCOLS_TRUE@am_protocols_la_OBJECTS = protocols.lo
 protocols_la_OBJECTS = $(am_protocols_la_OBJECTS)
 protocols_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(protocols_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_PROTOCOLS_TRUE@am_protocols_la_rpath = -rpath \
 @BUILD_PLUGIN_PROTOCOLS_TRUE@	$(pkglibdir)
@@ -1230,17 +1217,15 @@
 rrdtool_la_OBJECTS = $(am_rrdtool_la_OBJECTS)
 rrdtool_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(rrdtool_la_CFLAGS) \
 	$(CFLAGS) $(rrdtool_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_RRDTOOL_TRUE@am_rrdtool_la_rpath = -rpath $(pkglibdir)
 sensors_la_DEPENDENCIES =
-am__sensors_la_SOURCES_DIST = sensors.c utils_ignorelist.c \
-	utils_ignorelist.h
+am__sensors_la_SOURCES_DIST = sensors.c
 @BUILD_PLUGIN_SENSORS_TRUE@am_sensors_la_OBJECTS =  \
-@BUILD_PLUGIN_SENSORS_TRUE@	sensors_la-sensors.lo \
-@BUILD_PLUGIN_SENSORS_TRUE@	sensors_la-utils_ignorelist.lo
+@BUILD_PLUGIN_SENSORS_TRUE@	sensors_la-sensors.lo
 sensors_la_OBJECTS = $(am_sensors_la_OBJECTS)
 sensors_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(sensors_la_CFLAGS) \
 	$(CFLAGS) $(sensors_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_SENSORS_TRUE@am_sensors_la_rpath = -rpath $(pkglibdir)
 serial_la_LIBADD =
@@ -1257,16 +1242,14 @@
 sigrok_la_OBJECTS = $(am_sigrok_la_OBJECTS)
 sigrok_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(sigrok_la_CFLAGS) \
 	$(CFLAGS) $(sigrok_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_SIGROK_TRUE@am_sigrok_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@smart_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
-am__smart_la_SOURCES_DIST = smart.c utils_ignorelist.c \
-	utils_ignorelist.h
-@BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@am_smart_la_OBJECTS = smart_la-smart.lo \
-@BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@	smart_la-utils_ignorelist.lo
+am__smart_la_SOURCES_DIST = smart.c
+@BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@am_smart_la_OBJECTS = smart_la-smart.lo
 smart_la_OBJECTS = $(am_smart_la_OBJECTS)
 smart_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(smart_la_CFLAGS) \
 	$(CFLAGS) $(smart_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@am_smart_la_rpath =  \
 @BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@	-rpath \
@@ -1422,16 +1405,14 @@
 ted_la_OBJECTS = $(am_ted_la_OBJECTS)
 ted_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(ted_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_TED_TRUE@am_ted_la_rpath = -rpath $(pkglibdir)
 thermal_la_LIBADD =
-am__thermal_la_SOURCES_DIST = thermal.c utils_ignorelist.c \
-	utils_ignorelist.h
-@BUILD_PLUGIN_THERMAL_TRUE@am_thermal_la_OBJECTS = thermal.lo \
-@BUILD_PLUGIN_THERMAL_TRUE@	utils_ignorelist.lo
+am__thermal_la_SOURCES_DIST = thermal.c
+@BUILD_PLUGIN_THERMAL_TRUE@am_thermal_la_OBJECTS = thermal.lo
 thermal_la_OBJECTS = $(am_thermal_la_OBJECTS)
 thermal_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(thermal_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_THERMAL_TRUE@am_thermal_la_rpath = -rpath $(pkglibdir)
 threshold_la_LIBADD =
@@ -1522,16 +1503,14 @@
 varnish_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(varnish_la_CFLAGS) \
 	$(CFLAGS) $(varnish_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_VARNISH_TRUE@am_varnish_la_rpath = -rpath $(pkglibdir)
 @BUILD_PLUGIN_VIRT_TRUE@virt_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 @BUILD_PLUGIN_VIRT_TRUE@	$(am__DEPENDENCIES_1)
-am__virt_la_SOURCES_DIST = virt.c utils_ignorelist.c \
-	utils_ignorelist.h
-@BUILD_PLUGIN_VIRT_TRUE@am_virt_la_OBJECTS = virt_la-virt.lo \
-@BUILD_PLUGIN_VIRT_TRUE@	virt_la-utils_ignorelist.lo
+am__virt_la_SOURCES_DIST = virt.c
+@BUILD_PLUGIN_VIRT_TRUE@am_virt_la_OBJECTS = virt_la-virt.lo
 virt_la_OBJECTS = $(am_virt_la_OBJECTS)
 virt_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(virt_la_CFLAGS) \
 	$(CFLAGS) $(virt_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_VIRT_TRUE@am_virt_la_rpath = -rpath $(pkglibdir)
 vmem_la_LIBADD =
@@ -1698,23 +1677,36 @@
 zookeeper_la_OBJECTS = $(am_zookeeper_la_OBJECTS)
 zookeeper_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(zookeeper_la_LDFLAGS) $(LDFLAGS) -o $@
 @BUILD_PLUGIN_ZOOKEEPER_TRUE@am_zookeeper_la_rpath = -rpath \
 @BUILD_PLUGIN_ZOOKEEPER_TRUE@	$(pkglibdir)
+@BUILD_PLUGIN_CEPH_TRUE@am__EXEEXT_1 = test_plugin_ceph$(EXEEXT)
 PROGRAMS = $(bin_PROGRAMS) $(sbin_PROGRAMS)
 am_collectd_nagios_OBJECTS =  \
 	collectd_nagios-collectd-nagios.$(OBJEXT)
 collectd_nagios_OBJECTS = $(am_collectd_nagios_OBJECTS)
 am_collectd_tg_OBJECTS = collectd_tg-collectd-tg.$(OBJEXT)
 collectd_tg_OBJECTS = $(am_collectd_tg_OBJECTS)
 am_collectdctl_OBJECTS = collectdctl-collectdctl.$(OBJEXT)
 collectdctl_OBJECTS = $(am_collectdctl_OBJECTS)
 am_collectdmon_OBJECTS = collectdmon-collectdmon.$(OBJEXT)
 collectdmon_OBJECTS = $(am_collectdmon_OBJECTS)
 collectdmon_LDADD = $(LDADD)
+am__test_plugin_ceph_SOURCES_DIST = ceph_test.c
+@BUILD_PLUGIN_CEPH_TRUE@am_test_plugin_ceph_OBJECTS =  \
+@BUILD_PLUGIN_CEPH_TRUE@	test_plugin_ceph-ceph_test.$(OBJEXT)
+test_plugin_ceph_OBJECTS = $(am_test_plugin_ceph_OBJECTS)
+@BUILD_PLUGIN_CEPH_TRUE@test_plugin_ceph_DEPENDENCIES =  \
+@BUILD_PLUGIN_CEPH_TRUE@	daemon/libcommon.la \
+@BUILD_PLUGIN_CEPH_TRUE@	daemon/libplugin_mock.la \
+@BUILD_PLUGIN_CEPH_TRUE@	$(am__DEPENDENCIES_1)
+test_plugin_ceph_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(test_plugin_ceph_LDFLAGS) $(LDFLAGS) \
+	-o $@
 am_test_utils_mount_OBJECTS = utils_mount_test.$(OBJEXT)
 test_utils_mount_OBJECTS = $(am_test_utils_mount_OBJECTS)
 test_utils_mount_DEPENDENCIES = libmount.la daemon/libplugin_mock.la
 am_test_utils_vl_lookup_OBJECTS = utils_vl_lookup_test.$(OBJEXT)
 test_utils_vl_lookup_OBJECTS = $(am_test_utils_vl_lookup_OBJECTS)
 test_utils_vl_lookup_DEPENDENCIES = liblookup.la \
@@ -1811,14 +1803,14 @@
 	$(write_mongodb_la_SOURCES) $(write_redis_la_SOURCES) \
 	$(write_riemann_la_SOURCES) $(nodist_write_riemann_la_SOURCES) \
 	$(write_sensu_la_SOURCES) $(write_tsdb_la_SOURCES) \
 	$(xmms_la_SOURCES) $(zfs_arc_la_SOURCES) \
 	$(zookeeper_la_SOURCES) $(collectd_nagios_SOURCES) \
 	$(collectd_tg_SOURCES) $(collectdctl_SOURCES) \
-	$(collectdmon_SOURCES) $(test_utils_mount_SOURCES) \
-	$(test_utils_vl_lookup_SOURCES)
+	$(collectdmon_SOURCES) $(test_plugin_ceph_SOURCES) \
+	$(test_utils_mount_SOURCES) $(test_utils_vl_lookup_SOURCES)
 DIST_SOURCES = $(am__aggregation_la_SOURCES_DIST) \
 	$(am__amqp_la_SOURCES_DIST) $(am__apache_la_SOURCES_DIST) \
 	$(am__apcups_la_SOURCES_DIST) \
 	$(am__apple_sensors_la_SOURCES_DIST) \
 	$(am__aquaero_la_SOURCES_DIST) $(am__ascent_la_SOURCES_DIST) \
 	$(am__barometer_la_SOURCES_DIST) \
@@ -1905,14 +1897,14 @@
 	$(am__write_riemann_la_SOURCES_DIST) \
 	$(am__write_sensu_la_SOURCES_DIST) \
 	$(am__write_tsdb_la_SOURCES_DIST) $(am__xmms_la_SOURCES_DIST) \
 	$(am__zfs_arc_la_SOURCES_DIST) \
 	$(am__zookeeper_la_SOURCES_DIST) $(collectd_nagios_SOURCES) \
 	$(collectd_tg_SOURCES) $(collectdctl_SOURCES) \
-	$(collectdmon_SOURCES) $(test_utils_mount_SOURCES) \
-	$(test_utils_vl_lookup_SOURCES)
+	$(collectdmon_SOURCES) $(am__test_plugin_ceph_SOURCES_DIST) \
+	$(test_utils_mount_SOURCES) $(test_utils_vl_lookup_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
 	ctags-recursive dvi-recursive html-recursive info-recursive \
 	install-data-recursive install-dvi-recursive \
 	install-exec-recursive install-html-recursive \
 	install-info-recursive install-pdf-recursive \
 	install-ps-recursive install-recursive installcheck-recursive \
@@ -2503,21 +2495,22 @@
 	$(am__append_192) $(am__append_193) $(am__append_194) \
 	$(am__append_195) $(am__append_196) $(am__append_197) \
 	$(am__append_198) $(am__append_199) $(am__append_202) \
 	$(am__append_203) $(am__append_204) $(am__append_205) \
 	$(am__append_206) $(am__append_207) $(am__append_208) \
 	$(am__append_209) $(am__append_210) $(am__append_211)
-BUILT_SOURCES = $(dist_man_MANS) $(am__append_213)
-CLEANFILES = $(am__append_212)
+BUILT_SOURCES = $(dist_man_MANS) $(am__append_213) $(am__append_215)
+CLEANFILES = $(am__append_212) $(am__append_214)
 @BUILD_PLUGIN_AGGREGATION_TRUE@aggregation_la_SOURCES = aggregation.c \
 @BUILD_PLUGIN_AGGREGATION_TRUE@                         utils_vl_lookup.c utils_vl_lookup.h
 
 @BUILD_PLUGIN_AGGREGATION_TRUE@aggregation_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_AGGREGATION_TRUE@aggregation_la_LIBADD = -lm
 @BUILD_PLUGIN_AMQP_TRUE@amqp_la_SOURCES = amqp.c \
 @BUILD_PLUGIN_AMQP_TRUE@		  utils_cmd_putval.c utils_cmd_putval.h \
+@BUILD_PLUGIN_AMQP_TRUE@  	          utils_parse_option.c utils_parse_option.h \
 @BUILD_PLUGIN_AMQP_TRUE@		  utils_format_graphite.c utils_format_graphite.h \
 @BUILD_PLUGIN_AMQP_TRUE@		  utils_format_json.c utils_format_json.h
 
 @BUILD_PLUGIN_AMQP_TRUE@amqp_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBRABBITMQ_LDFLAGS)
 @BUILD_PLUGIN_AMQP_TRUE@amqp_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBRABBITMQ_CPPFLAGS)
 @BUILD_PLUGIN_AMQP_TRUE@amqp_la_LIBADD = $(BUILD_WITH_LIBRABBITMQ_LIBS)
@@ -2558,15 +2551,13 @@
 @BUILD_PLUGIN_BIND_TRUE@bind_la_LIBADD = $(BUILD_WITH_LIBCURL_LIBS) $(BUILD_WITH_LIBXML2_LIBS)
 @BUILD_PLUGIN_CEPH_TRUE@ceph_la_SOURCES = ceph.c
 @BUILD_PLUGIN_CEPH_TRUE@ceph_la_CFLAGS = $(AM_CFLAGS)
 @BUILD_PLUGIN_CEPH_TRUE@ceph_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBYAJL_LDFLAGS)
 @BUILD_PLUGIN_CEPH_TRUE@ceph_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBYAJL_CPPFLAGS)
 @BUILD_PLUGIN_CEPH_TRUE@ceph_la_LIBADD = $(BUILD_WITH_LIBYAJL_LIBS)
-@BUILD_PLUGIN_CGROUPS_TRUE@cgroups_la_SOURCES = cgroups.c \
-@BUILD_PLUGIN_CGROUPS_TRUE@		     utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_CGROUPS_TRUE@cgroups_la_SOURCES = cgroups.c
 @BUILD_PLUGIN_CGROUPS_TRUE@cgroups_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_CGROUPS_TRUE@cgroups_la_LIBADD = libmount.la
 @BUILD_PLUGIN_CONNTRACK_TRUE@conntrack_la_SOURCES = conntrack.c
 @BUILD_PLUGIN_CONNTRACK_TRUE@conntrack_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_CONTEXTSWITCH_TRUE@contextswitch_la_SOURCES = contextswitch.c
 @BUILD_PLUGIN_CONTEXTSWITCH_TRUE@contextswitch_la_LDFLAGS = $(PLUGIN_LDFLAGS)
@@ -2603,20 +2594,16 @@
 @BUILD_PLUGIN_DBI_TRUE@dbi_la_SOURCES = dbi.c \
 @BUILD_PLUGIN_DBI_TRUE@		 utils_db_query.c utils_db_query.h
 
 @BUILD_PLUGIN_DBI_TRUE@dbi_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBDBI_CPPFLAGS)
 @BUILD_PLUGIN_DBI_TRUE@dbi_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBDBI_LDFLAGS)
 @BUILD_PLUGIN_DBI_TRUE@dbi_la_LIBADD = $(BUILD_WITH_LIBDBI_LIBS)
-@BUILD_PLUGIN_DF_TRUE@df_la_SOURCES = df.c \
-@BUILD_PLUGIN_DF_TRUE@		utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_DF_TRUE@df_la_SOURCES = df.c
 @BUILD_PLUGIN_DF_TRUE@df_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_DF_TRUE@df_la_LIBADD = libmount.la
-@BUILD_PLUGIN_DISK_TRUE@disk_la_SOURCES = disk.c \
-@BUILD_PLUGIN_DISK_TRUE@		  utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_DISK_TRUE@disk_la_SOURCES = disk.c
 @BUILD_PLUGIN_DISK_TRUE@disk_la_CFLAGS = $(AM_CFLAGS) $(am__append_51)
 @BUILD_PLUGIN_DISK_TRUE@disk_la_LDFLAGS = $(PLUGIN_LDFLAGS) \
 @BUILD_PLUGIN_DISK_TRUE@	$(am__append_50)
 @BUILD_PLUGIN_DISK_TRUE@disk_la_LIBADD = $(am__append_48) \
 @BUILD_PLUGIN_DISK_TRUE@	$(am__append_49) $(am__append_52) \
 @BUILD_PLUGIN_DISK_TRUE@	$(am__append_53) $(am__append_54)
@@ -2648,15 +2635,13 @@
 @BUILD_PLUGIN_GMOND_TRUE@gmond_la_CPPFLAGS = $(AM_CPPFLAGS) $(GANGLIA_CPPFLAGS)
 @BUILD_PLUGIN_GMOND_TRUE@gmond_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(GANGLIA_LDFLAGS)
 @BUILD_PLUGIN_GMOND_TRUE@gmond_la_LIBADD = $(GANGLIA_LIBS)
 @BUILD_PLUGIN_HDDTEMP_TRUE@hddtemp_la_SOURCES = hddtemp.c
 @BUILD_PLUGIN_HDDTEMP_TRUE@hddtemp_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_HDDTEMP_TRUE@hddtemp_la_LIBADD = $(am__append_65)
-@BUILD_PLUGIN_INTERFACE_TRUE@interface_la_SOURCES = interface.c \
-@BUILD_PLUGIN_INTERFACE_TRUE@		       utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_INTERFACE_TRUE@interface_la_SOURCES = interface.c
 @BUILD_PLUGIN_INTERFACE_TRUE@interface_la_CFLAGS = $(AM_CFLAGS) \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__append_67)
 @BUILD_PLUGIN_INTERFACE_TRUE@interface_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_INTERFACE_TRUE@interface_la_LIBADD = $(am__append_68) \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__append_69) $(am__append_70) \
 @BUILD_PLUGIN_INTERFACE_TRUE@	$(am__append_71)
@@ -2664,24 +2649,20 @@
 @BUILD_PLUGIN_IPC_TRUE@ipc_la_CFLAGS = $(AM_CFLAGS)
 @BUILD_PLUGIN_IPC_TRUE@ipc_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_IPTABLES_TRUE@iptables_la_SOURCES = iptables.c
 @BUILD_PLUGIN_IPTABLES_TRUE@iptables_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBIPTC_CPPFLAGS)
 @BUILD_PLUGIN_IPTABLES_TRUE@iptables_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_IPTABLES_TRUE@iptables_la_LIBADD = $(BUILD_WITH_LIBIPTC_LDFLAGS)
-@BUILD_PLUGIN_IPMI_TRUE@ipmi_la_SOURCES = ipmi.c \
-@BUILD_PLUGIN_IPMI_TRUE@		  utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_IPMI_TRUE@ipmi_la_SOURCES = ipmi.c
 @BUILD_PLUGIN_IPMI_TRUE@ipmi_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_OPENIPMI_CFLAGS)
 @BUILD_PLUGIN_IPMI_TRUE@ipmi_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_IPMI_TRUE@ipmi_la_LIBADD = $(BUILD_WITH_OPENIPMI_LIBS)
 @BUILD_PLUGIN_IPVS_TRUE@ipvs_la_SOURCES = ipvs.c
 @BUILD_PLUGIN_IPVS_TRUE@@IP_VS_H_NEEDS_KERNEL_CFLAGS_TRUE@ipvs_la_CFLAGS = $(AM_CFLAGS) $(KERNEL_CFLAGS)
 @BUILD_PLUGIN_IPVS_TRUE@ipvs_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_IRQ_TRUE@irq_la_SOURCES = irq.c \
-@BUILD_PLUGIN_IRQ_TRUE@		 utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_IRQ_TRUE@irq_la_SOURCES = irq.c
 @BUILD_PLUGIN_IRQ_TRUE@irq_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_JAVA_TRUE@java_la_SOURCES = java.c
 @BUILD_PLUGIN_JAVA_TRUE@java_la_CPPFLAGS = $(AM_CPPFLAGS) $(JAVA_CPPFLAGS)
 @BUILD_PLUGIN_JAVA_TRUE@java_la_CFLAGS = $(AM_CFLAGS) $(JAVA_CFLAGS)
 @BUILD_PLUGIN_JAVA_TRUE@java_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(JAVA_LDFLAGS)
 @BUILD_PLUGIN_JAVA_TRUE@java_la_LIBADD = $(JAVA_LIBS)
@@ -2700,15 +2681,13 @@
 @BUILD_PLUGIN_LPAR_TRUE@lpar_la_SOURCES = lpar.c
 @BUILD_PLUGIN_LPAR_TRUE@lpar_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_LPAR_TRUE@lpar_la_LIBADD = -lperfstat
 @BUILD_PLUGIN_LVM_TRUE@lvm_la_SOURCES = lvm.c
 @BUILD_PLUGIN_LVM_TRUE@lvm_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_LVM_TRUE@lvm_la_LIBADD = $(BUILD_WITH_LIBLVM2APP_LIBS)
-@BUILD_PLUGIN_MADWIFI_TRUE@madwifi_la_SOURCES = madwifi.c madwifi.h \
-@BUILD_PLUGIN_MADWIFI_TRUE@		     utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_MADWIFI_TRUE@madwifi_la_SOURCES = madwifi.c madwifi.h
 @BUILD_PLUGIN_MADWIFI_TRUE@madwifi_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MATCH_EMPTY_COUNTER_TRUE@match_empty_counter_la_SOURCES = match_empty_counter.c
 @BUILD_PLUGIN_MATCH_EMPTY_COUNTER_TRUE@match_empty_counter_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MATCH_HASHED_TRUE@match_hashed_la_SOURCES = match_hashed.c
 @BUILD_PLUGIN_MATCH_HASHED_TRUE@match_hashed_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MATCH_REGEX_TRUE@match_regex_la_SOURCES = match_regex.c
@@ -2717,15 +2696,13 @@
 @BUILD_PLUGIN_MATCH_TIMEDIFF_TRUE@match_timediff_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MATCH_VALUE_TRUE@match_value_la_SOURCES = match_value.c
 @BUILD_PLUGIN_MATCH_VALUE_TRUE@match_value_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MBMON_TRUE@mbmon_la_SOURCES = mbmon.c
 @BUILD_PLUGIN_MBMON_TRUE@mbmon_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MBMON_TRUE@mbmon_la_LIBADD = $(am__append_93)
-@BUILD_PLUGIN_MD_TRUE@md_la_SOURCES = md.c \
-@BUILD_PLUGIN_MD_TRUE@		utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_MD_TRUE@md_la_SOURCES = md.c
 @BUILD_PLUGIN_MD_TRUE@md_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_SOURCES = memcachec.c
 @BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBMEMCACHED_LDFLAGS)
 @BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBMEMCACHED_CPPFLAGS)
 @BUILD_PLUGIN_MEMCACHEC_TRUE@memcachec_la_LIBADD = $(BUILD_WITH_LIBMEMCACHED_LIBS)
 @BUILD_PLUGIN_MEMCACHED_TRUE@memcached_la_SOURCES = memcached.c
@@ -2735,15 +2712,13 @@
 @BUILD_PLUGIN_MEMORY_TRUE@memory_la_CFLAGS = $(AM_CFLAGS) \
 @BUILD_PLUGIN_MEMORY_TRUE@	$(am__append_101)
 @BUILD_PLUGIN_MEMORY_TRUE@memory_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MEMORY_TRUE@memory_la_LIBADD = $(am__append_99) \
 @BUILD_PLUGIN_MEMORY_TRUE@	$(am__append_100) $(am__append_102) \
 @BUILD_PLUGIN_MEMORY_TRUE@	$(am__append_103)
-@BUILD_PLUGIN_MIC_TRUE@mic_la_SOURCES = mic.c \
-@BUILD_PLUGIN_MIC_TRUE@		 utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_MIC_TRUE@mic_la_SOURCES = mic.c
 @BUILD_PLUGIN_MIC_TRUE@mic_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_MIC_LIBPATH)
 @BUILD_PLUGIN_MIC_TRUE@mic_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_MIC_CPPFLAGS)
 @BUILD_PLUGIN_MIC_TRUE@mic_la_LIBADD = $(BUILD_WITH_MIC_LDADD)
 @BUILD_PLUGIN_MODBUS_TRUE@modbus_la_SOURCES = modbus.c
 @BUILD_PLUGIN_MODBUS_TRUE@modbus_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MODBUS_TRUE@modbus_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBMODBUS_CFLAGS)
@@ -2752,15 +2727,13 @@
 @BUILD_PLUGIN_MULTIMETER_TRUE@multimeter_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MYSQL_TRUE@mysql_la_SOURCES = mysql.c
 @BUILD_PLUGIN_MYSQL_TRUE@mysql_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_MYSQL_TRUE@mysql_la_CFLAGS = $(AM_CFLAGS) \
 @BUILD_PLUGIN_MYSQL_TRUE@	$(am__append_108)
 @BUILD_PLUGIN_MYSQL_TRUE@mysql_la_LIBADD = $(am__append_109)
-@BUILD_PLUGIN_NETAPP_TRUE@netapp_la_SOURCES = netapp.c \
-@BUILD_PLUGIN_NETAPP_TRUE@		    utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_NETAPP_TRUE@netapp_la_SOURCES = netapp.c
 @BUILD_PLUGIN_NETAPP_TRUE@netapp_la_CPPFLAGS = $(AM_CPPFLAGS) $(LIBNETAPP_CPPFLAGS)
 @BUILD_PLUGIN_NETAPP_TRUE@netapp_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(LIBNETAPP_LDFLAGS)
 @BUILD_PLUGIN_NETAPP_TRUE@netapp_la_LIBADD = $(LIBNETAPP_LIBS)
 @BUILD_PLUGIN_NETLINK_TRUE@netlink_la_SOURCES = netlink.c
 @BUILD_PLUGIN_NETLINK_TRUE@netlink_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_NETLINK_TRUE@netlink_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBMNL_CFLAGS)
@@ -2799,15 +2772,13 @@
 @BUILD_PLUGIN_NUT_TRUE@nut_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBUPSCLIENT_CFLAGS)
 @BUILD_PLUGIN_NUT_TRUE@nut_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_NUT_TRUE@nut_la_LIBADD = -lpthread $(BUILD_WITH_LIBUPSCLIENT_LIBS)
 @BUILD_PLUGIN_OLSRD_TRUE@olsrd_la_SOURCES = olsrd.c
 @BUILD_PLUGIN_OLSRD_TRUE@olsrd_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_OLSRD_TRUE@olsrd_la_LIBADD = $(am__append_129)
-@BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_SOURCES = onewire.c \
-@BUILD_PLUGIN_ONEWIRE_TRUE@		     utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_SOURCES = onewire.c
 @BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_CFLAGS = $(AM_CFLAGS)
 @BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBOWCAPI_CPPFLAGS)
 @BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_LIBADD = $(BUILD_WITH_LIBOWCAPI_LIBS)
 @BUILD_PLUGIN_ONEWIRE_TRUE@onewire_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_OPENLDAP_TRUE@openldap_la_SOURCES = openldap.c
 @BUILD_PLUGIN_OPENLDAP_TRUE@openldap_la_LDFLAGS = -module -avoid-version $(BUILD_WITH_LIBLDAP_LDFLAGS)
@@ -2861,15 +2832,13 @@
 @BUILD_PLUGIN_PYTHON_TRUE@	$(am__append_142)
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_PYTHON_LDFLAGS)
 @BUILD_PLUGIN_PYTHON_TRUE@python_la_LIBADD = $(BUILD_WITH_PYTHON_LIBS)
 @BUILD_PLUGIN_PROCESSES_TRUE@processes_la_SOURCES = processes.c
 @BUILD_PLUGIN_PROCESSES_TRUE@processes_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_PROCESSES_TRUE@processes_la_LIBADD = $(am__append_144)
-@BUILD_PLUGIN_PROTOCOLS_TRUE@protocols_la_SOURCES = protocols.c \
-@BUILD_PLUGIN_PROTOCOLS_TRUE@		       utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_PROTOCOLS_TRUE@protocols_la_SOURCES = protocols.c
 @BUILD_PLUGIN_PROTOCOLS_TRUE@protocols_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_SOURCES = redis.c
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBHIREDIS_LDFLAGS)
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBHIREDIS_CPPFLAGS)
 @BUILD_PLUGIN_REDIS_TRUE@redis_la_LIBADD = -lhiredis
 @BUILD_PLUGIN_ROUTEROS_TRUE@routeros_la_SOURCES = routeros.c
@@ -2881,27 +2850,23 @@
 @BUILD_PLUGIN_RRDCACHED_TRUE@rrdcached_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBRRD_CFLAGS)
 @BUILD_PLUGIN_RRDCACHED_TRUE@rrdcached_la_LIBADD = $(BUILD_WITH_LIBRRD_LDFLAGS)
 @BUILD_PLUGIN_RRDTOOL_TRUE@rrdtool_la_SOURCES = rrdtool.c utils_rrdcreate.c utils_rrdcreate.h
 @BUILD_PLUGIN_RRDTOOL_TRUE@rrdtool_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_RRDTOOL_TRUE@rrdtool_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBRRD_CFLAGS)
 @BUILD_PLUGIN_RRDTOOL_TRUE@rrdtool_la_LIBADD = $(BUILD_WITH_LIBRRD_LDFLAGS)
-@BUILD_PLUGIN_SENSORS_TRUE@sensors_la_SOURCES = sensors.c \
-@BUILD_PLUGIN_SENSORS_TRUE@		     utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_SENSORS_TRUE@sensors_la_SOURCES = sensors.c
 @BUILD_PLUGIN_SENSORS_TRUE@sensors_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBSENSORS_CFLAGS)
 @BUILD_PLUGIN_SENSORS_TRUE@sensors_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBSENSORS_LDFLAGS)
 @BUILD_PLUGIN_SENSORS_TRUE@sensors_la_LIBADD = -lsensors
 @BUILD_PLUGIN_SERIAL_TRUE@serial_la_SOURCES = serial.c
 @BUILD_PLUGIN_SERIAL_TRUE@serial_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_SIGROK_TRUE@sigrok_la_SOURCES = sigrok.c
 @BUILD_PLUGIN_SIGROK_TRUE@sigrok_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBSIGROK_CFLAGS)
 @BUILD_PLUGIN_SIGROK_TRUE@sigrok_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBSIGROK_LDFLAGS)
 @BUILD_PLUGIN_SIGROK_TRUE@sigrok_la_LIBADD = -lsigrok
-@BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@smart_la_SOURCES = smart.c \
-@BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@		   utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@smart_la_SOURCES = smart.c
 @BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@smart_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBATASMART_CPPFLAGS)
 @BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@smart_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBATASMART_LDFLAGS)
 @BUILD_PLUGIN_SMART_TRUE@@BUILD_WITH_LIBUDEV_TRUE@smart_la_LIBADD = $(BUILD_WITH_LIBATASMART_LIBS) -ludev
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_SOURCES = snmp.c
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_CFLAGS = $(AM_CFLAGS) \
@@ -2909,13 +2874,13 @@
 @BUILD_PLUGIN_SNMP_TRUE@snmp_la_LIBADD = $(am__append_156) \
 @BUILD_PLUGIN_SNMP_TRUE@	$(am__append_157)
 @BUILD_PLUGIN_STATSD_TRUE@statsd_la_SOURCES = statsd.c \
 @BUILD_PLUGIN_STATSD_TRUE@                    utils_latency.h utils_latency.c
 
 @BUILD_PLUGIN_STATSD_TRUE@statsd_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_STATSD_TRUE@statsd_la_LIBADD = -lpthread
+@BUILD_PLUGIN_STATSD_TRUE@statsd_la_LIBADD = -lpthread -lm
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_SOURCES = swap.c
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_CFLAGS = $(AM_CFLAGS) \
 @BUILD_PLUGIN_SWAP_TRUE@	$(am__append_163)
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_SWAP_TRUE@swap_la_LIBADD = $(am__append_160) \
 @BUILD_PLUGIN_SWAP_TRUE@	$(am__append_161) $(am__append_162) \
@@ -2945,15 +2910,13 @@
 @BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TCPCONNS_TRUE@tcpconns_la_LIBADD = $(am__append_177)
 @BUILD_PLUGIN_TEAMSPEAK2_TRUE@teamspeak2_la_SOURCES = teamspeak2.c
 @BUILD_PLUGIN_TEAMSPEAK2_TRUE@teamspeak2_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TED_TRUE@ted_la_SOURCES = ted.c
 @BUILD_PLUGIN_TED_TRUE@ted_la_LDFLAGS = $(PLUGIN_LDFLAGS)
-@BUILD_PLUGIN_THERMAL_TRUE@thermal_la_SOURCES = thermal.c \
-@BUILD_PLUGIN_THERMAL_TRUE@		     utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_THERMAL_TRUE@thermal_la_SOURCES = thermal.c
 @BUILD_PLUGIN_THERMAL_TRUE@thermal_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_THRESHOLD_TRUE@threshold_la_SOURCES = threshold.c
 @BUILD_PLUGIN_THRESHOLD_TRUE@threshold_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_SOURCES = tokyotyrant.c
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBTOKYOTYRANT_CPPFLAGS)
 @BUILD_PLUGIN_TOKYOTYRANT_TRUE@tokyotyrant_la_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBTOKYOTYRANT_LDFLAGS)
@@ -2987,15 +2950,13 @@
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_LIBADD = $(BUILD_WITH_LIBHAL_LIBS)
 @BUILD_PLUGIN_UUID_TRUE@uuid_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_VARNISH_TRUE@varnish_la_SOURCES = varnish.c
 @BUILD_PLUGIN_VARNISH_TRUE@varnish_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_VARNISH_TRUE@varnish_la_CFLAGS = $(AM_CFLAGS) $(BUILD_WITH_LIBVARNISH_CFLAGS)
 @BUILD_PLUGIN_VARNISH_TRUE@varnish_la_LIBADD = $(BUILD_WITH_LIBVARNISH_LIBS)
-@BUILD_PLUGIN_VIRT_TRUE@virt_la_SOURCES = virt.c \
-@BUILD_PLUGIN_VIRT_TRUE@		  utils_ignorelist.c utils_ignorelist.h
-
+@BUILD_PLUGIN_VIRT_TRUE@virt_la_SOURCES = virt.c
 @BUILD_PLUGIN_VIRT_TRUE@virt_la_CFLAGS = $(AM_CFLAGS) \
 @BUILD_PLUGIN_VIRT_TRUE@		$(BUILD_WITH_LIBVIRT_CFLAGS) $(BUILD_WITH_LIBXML2_CFLAGS)
 
 @BUILD_PLUGIN_VIRT_TRUE@virt_la_LIBADD = $(BUILD_WITH_LIBVIRT_LIBS) $(BUILD_WITH_LIBXML2_LIBS)
 @BUILD_PLUGIN_VIRT_TRUE@virt_la_LDFLAGS = $(PLUGIN_LDFLAGS)
 @BUILD_PLUGIN_VMEM_TRUE@vmem_la_SOURCES = vmem.c
@@ -3084,16 +3045,24 @@
 EXTRA_DIST = types.db collectd.conf.pod collectd-email.pod \
 	collectd-exec.pod collectdctl.pod collectd-java.pod \
 	collectdmon.pod collectd-nagios.pod collectd-perl.pod \
 	collectd-python.pod collectd.pod collectd-snmp.pod \
 	collectd-tg.pod collectd-threshold.pod collectd-unixsock.pod \
 	postgresql_default.conf types.db.pod pinba.proto riemann.proto
+AM_V_PROTOC_C = $(am__v_PROTOC_C_@AM_V@)
+am__v_PROTOC_C_ = $(am__v_PROTOC_C_@AM_DEFAULT_V@)
+am__v_PROTOC_C_0 = @echo "  PROTOC-C    " $@;
+am__v_PROTOC_C_1 = 
 test_utils_mount_SOURCES = utils_mount_test.c testing.h
 test_utils_mount_LDADD = libmount.la daemon/libplugin_mock.la
 test_utils_vl_lookup_SOURCES = utils_vl_lookup_test.c testing.h
 test_utils_vl_lookup_LDADD = liblookup.la daemon/libplugin_mock.la
+@BUILD_PLUGIN_CEPH_TRUE@test_plugin_ceph_SOURCES = ceph_test.c
+@BUILD_PLUGIN_CEPH_TRUE@test_plugin_ceph_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBYAJL_CPPFLAGS)
+@BUILD_PLUGIN_CEPH_TRUE@test_plugin_ceph_LDFLAGS = $(PLUGIN_LDFLAGS) $(BUILD_WITH_LIBYAJL_LDFLAGS)
+@BUILD_PLUGIN_CEPH_TRUE@test_plugin_ceph_LDADD = daemon/libcommon.la daemon/libplugin_mock.la $(BUILD_WITH_LIBYAJL_LIBS)
 all: $(BUILT_SOURCES) config.h
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
 .SUFFIXES:
 .SUFFIXES: .1 .5 .c .lo .log .o .obj .pod .test .test$(EXEEXT) .trs
 $(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
@@ -3718,12 +3687,16 @@
 	$(AM_V_CCLD)$(LINK) $(collectdctl_OBJECTS) $(collectdctl_LDADD) $(LIBS)
 
 collectdmon$(EXEEXT): $(collectdmon_OBJECTS) $(collectdmon_DEPENDENCIES) $(EXTRA_collectdmon_DEPENDENCIES) 
 	@rm -f collectdmon$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(collectdmon_OBJECTS) $(collectdmon_LDADD) $(LIBS)
 
+test_plugin_ceph$(EXEEXT): $(test_plugin_ceph_OBJECTS) $(test_plugin_ceph_DEPENDENCIES) $(EXTRA_test_plugin_ceph_DEPENDENCIES) 
+	@rm -f test_plugin_ceph$(EXEEXT)
+	$(AM_V_CCLD)$(test_plugin_ceph_LINK) $(test_plugin_ceph_OBJECTS) $(test_plugin_ceph_LDADD) $(LIBS)
+
 test_utils_mount$(EXEEXT): $(test_utils_mount_OBJECTS) $(test_utils_mount_DEPENDENCIES) $(EXTRA_test_utils_mount_DEPENDENCIES) 
 	@rm -f test_utils_mount$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(test_utils_mount_OBJECTS) $(test_utils_mount_LDADD) $(LIBS)
 
 test_utils_vl_lookup$(EXEEXT): $(test_utils_vl_lookup_OBJECTS) $(test_utils_vl_lookup_DEPENDENCIES) $(EXTRA_test_utils_vl_lookup_DEPENDENCIES) 
 	@rm -f test_utils_vl_lookup$(EXEEXT)
@@ -3737,12 +3710,13 @@
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aggregation.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/amqp_la-amqp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/amqp_la-utils_cmd_putval.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/amqp_la-utils_format_graphite.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/amqp_la-utils_format_json.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/amqp_la-utils_parse_option.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/apache_la-apache.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/apcups.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/apple_sensors.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aquaero_la-aquaero.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ascent_la-ascent.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/barometer.Plo@am__quote@
@@ -3763,29 +3737,26 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_la-curl.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_xml_la-curl_xml.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dbi_la-dbi.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dbi_la-utils_db_query.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/df.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/disk_la-disk.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/disk_la-utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dns.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/drbd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/email.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/entropy.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ethstat.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exec.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fhcount.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/filecount.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fscache.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gmond_la-gmond.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hddtemp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interface_la-interface.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interface_la-utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipc_la-ipc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipmi_la-ipmi.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipmi_la-utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iptables_la-iptables.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipvs_la-ipvs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/irq.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/java_la-java.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/load_la-load.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/log_logstash_la-log_logstash.Plo@am__quote@
@@ -3801,31 +3772,28 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mbmon.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/md.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcachec_la-memcachec.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memcached.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memory_la-memory.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mic_la-mic.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mic_la-utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/modbus_la-modbus.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/multimeter.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mysql_la-mysql.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/netapp_la-netapp.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/netapp_la-utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/netlink_la-netlink.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/network_la-network.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/network_la-utils_fbhash.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nfs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nginx_la-nginx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/notify_desktop_la-notify_desktop.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/notify_email.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ntpd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/numa.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nut_la-nut.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/olsrd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/onewire_la-onewire.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/onewire_la-utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openldap_la-openldap.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openvpn_la-openvpn.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oracle_la-oracle.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oracle_la-utils_db_query.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/perl_la-perl.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pf.Plo@am__quote@
@@ -3845,17 +3813,15 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/routeros_la-routeros.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rrdcached_la-rrdcached.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rrdcached_la-utils_rrdcreate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rrdtool_la-rrdtool.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rrdtool_la-utils_rrdcreate.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sensors_la-sensors.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sensors_la-utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/serial.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sigrok_la-sigrok.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/smart_la-smart.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/smart_la-utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/snmp_la-snmp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/statsd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/swap_la-swap.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/syslog.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/table.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tail.Plo@am__quote@
@@ -3866,12 +3832,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target_scale.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target_set.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/target_v5upgrade.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tcpconns.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/teamspeak2.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ted.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_plugin_ceph-ceph_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thermal.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/threshold.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tokyotyrant_la-tokyotyrant.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/turbostat.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unixsock.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uptime_la-uptime.Plo@am__quote@
@@ -3882,22 +3849,20 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmd_listval.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmd_putnotif.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_cmd_putval.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_dns.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_format_graphite.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_format_json.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_latency.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_mount.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_mount_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_parse_option.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_vl_lookup.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils_vl_lookup_test.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uuid_la-uuid.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/varnish_la-varnish.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/virt_la-utils_ignorelist.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/virt_la-virt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vmem.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vserver.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wireless.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_graphite.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/write_http_la-utils_format_json.Plo@am__quote@
@@ -3953,12 +3918,19 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT amqp_la-utils_cmd_putval.lo -MD -MP -MF $(DEPDIR)/amqp_la-utils_cmd_putval.Tpo -c -o amqp_la-utils_cmd_putval.lo `test -f 'utils_cmd_putval.c' || echo '$(srcdir)/'`utils_cmd_putval.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/amqp_la-utils_cmd_putval.Tpo $(DEPDIR)/amqp_la-utils_cmd_putval.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_cmd_putval.c' object='amqp_la-utils_cmd_putval.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o amqp_la-utils_cmd_putval.lo `test -f 'utils_cmd_putval.c' || echo '$(srcdir)/'`utils_cmd_putval.c
 
+amqp_la-utils_parse_option.lo: utils_parse_option.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT amqp_la-utils_parse_option.lo -MD -MP -MF $(DEPDIR)/amqp_la-utils_parse_option.Tpo -c -o amqp_la-utils_parse_option.lo `test -f 'utils_parse_option.c' || echo '$(srcdir)/'`utils_parse_option.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/amqp_la-utils_parse_option.Tpo $(DEPDIR)/amqp_la-utils_parse_option.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_parse_option.c' object='amqp_la-utils_parse_option.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o amqp_la-utils_parse_option.lo `test -f 'utils_parse_option.c' || echo '$(srcdir)/'`utils_parse_option.c
+
 amqp_la-utils_format_graphite.lo: utils_format_graphite.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT amqp_la-utils_format_graphite.lo -MD -MP -MF $(DEPDIR)/amqp_la-utils_format_graphite.Tpo -c -o amqp_la-utils_format_graphite.lo `test -f 'utils_format_graphite.c' || echo '$(srcdir)/'`utils_format_graphite.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/amqp_la-utils_format_graphite.Tpo $(DEPDIR)/amqp_la-utils_format_graphite.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_format_graphite.c' object='amqp_la-utils_format_graphite.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(amqp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o amqp_la-utils_format_graphite.lo `test -f 'utils_format_graphite.c' || echo '$(srcdir)/'`utils_format_graphite.c
@@ -4051,19 +4023,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(disk_la_CFLAGS) $(CFLAGS) -MT disk_la-disk.lo -MD -MP -MF $(DEPDIR)/disk_la-disk.Tpo -c -o disk_la-disk.lo `test -f 'disk.c' || echo '$(srcdir)/'`disk.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/disk_la-disk.Tpo $(DEPDIR)/disk_la-disk.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='disk.c' object='disk_la-disk.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(disk_la_CFLAGS) $(CFLAGS) -c -o disk_la-disk.lo `test -f 'disk.c' || echo '$(srcdir)/'`disk.c
 
-disk_la-utils_ignorelist.lo: utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(disk_la_CFLAGS) $(CFLAGS) -MT disk_la-utils_ignorelist.lo -MD -MP -MF $(DEPDIR)/disk_la-utils_ignorelist.Tpo -c -o disk_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/disk_la-utils_ignorelist.Tpo $(DEPDIR)/disk_la-utils_ignorelist.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='disk_la-utils_ignorelist.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(disk_la_CFLAGS) $(CFLAGS) -c -o disk_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-
 gmond_la-gmond.lo: gmond.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gmond_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT gmond_la-gmond.lo -MD -MP -MF $(DEPDIR)/gmond_la-gmond.Tpo -c -o gmond_la-gmond.lo `test -f 'gmond.c' || echo '$(srcdir)/'`gmond.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/gmond_la-gmond.Tpo $(DEPDIR)/gmond_la-gmond.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='gmond.c' object='gmond_la-gmond.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(gmond_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gmond_la-gmond.lo `test -f 'gmond.c' || echo '$(srcdir)/'`gmond.c
@@ -4072,19 +4037,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(interface_la_CFLAGS) $(CFLAGS) -MT interface_la-interface.lo -MD -MP -MF $(DEPDIR)/interface_la-interface.Tpo -c -o interface_la-interface.lo `test -f 'interface.c' || echo '$(srcdir)/'`interface.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/interface_la-interface.Tpo $(DEPDIR)/interface_la-interface.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='interface.c' object='interface_la-interface.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(interface_la_CFLAGS) $(CFLAGS) -c -o interface_la-interface.lo `test -f 'interface.c' || echo '$(srcdir)/'`interface.c
 
-interface_la-utils_ignorelist.lo: utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(interface_la_CFLAGS) $(CFLAGS) -MT interface_la-utils_ignorelist.lo -MD -MP -MF $(DEPDIR)/interface_la-utils_ignorelist.Tpo -c -o interface_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/interface_la-utils_ignorelist.Tpo $(DEPDIR)/interface_la-utils_ignorelist.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='interface_la-utils_ignorelist.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(interface_la_CFLAGS) $(CFLAGS) -c -o interface_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-
 ipc_la-ipc.lo: ipc.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ipc_la_CFLAGS) $(CFLAGS) -MT ipc_la-ipc.lo -MD -MP -MF $(DEPDIR)/ipc_la-ipc.Tpo -c -o ipc_la-ipc.lo `test -f 'ipc.c' || echo '$(srcdir)/'`ipc.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ipc_la-ipc.Tpo $(DEPDIR)/ipc_la-ipc.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='ipc.c' object='ipc_la-ipc.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ipc_la_CFLAGS) $(CFLAGS) -c -o ipc_la-ipc.lo `test -f 'ipc.c' || echo '$(srcdir)/'`ipc.c
@@ -4093,19 +4051,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ipmi_la_CFLAGS) $(CFLAGS) -MT ipmi_la-ipmi.lo -MD -MP -MF $(DEPDIR)/ipmi_la-ipmi.Tpo -c -o ipmi_la-ipmi.lo `test -f 'ipmi.c' || echo '$(srcdir)/'`ipmi.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ipmi_la-ipmi.Tpo $(DEPDIR)/ipmi_la-ipmi.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='ipmi.c' object='ipmi_la-ipmi.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ipmi_la_CFLAGS) $(CFLAGS) -c -o ipmi_la-ipmi.lo `test -f 'ipmi.c' || echo '$(srcdir)/'`ipmi.c
 
-ipmi_la-utils_ignorelist.lo: utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ipmi_la_CFLAGS) $(CFLAGS) -MT ipmi_la-utils_ignorelist.lo -MD -MP -MF $(DEPDIR)/ipmi_la-utils_ignorelist.Tpo -c -o ipmi_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ipmi_la-utils_ignorelist.Tpo $(DEPDIR)/ipmi_la-utils_ignorelist.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='ipmi_la-utils_ignorelist.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ipmi_la_CFLAGS) $(CFLAGS) -c -o ipmi_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-
 iptables_la-iptables.lo: iptables.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(iptables_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iptables_la-iptables.lo -MD -MP -MF $(DEPDIR)/iptables_la-iptables.Tpo -c -o iptables_la-iptables.lo `test -f 'iptables.c' || echo '$(srcdir)/'`iptables.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/iptables_la-iptables.Tpo $(DEPDIR)/iptables_la-iptables.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='iptables.c' object='iptables_la-iptables.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(iptables_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iptables_la-iptables.lo `test -f 'iptables.c' || echo '$(srcdir)/'`iptables.c
@@ -4156,19 +4107,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mic_la_CFLAGS) $(CFLAGS) -MT mic_la-mic.lo -MD -MP -MF $(DEPDIR)/mic_la-mic.Tpo -c -o mic_la-mic.lo `test -f 'mic.c' || echo '$(srcdir)/'`mic.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/mic_la-mic.Tpo $(DEPDIR)/mic_la-mic.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='mic.c' object='mic_la-mic.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mic_la_CFLAGS) $(CFLAGS) -c -o mic_la-mic.lo `test -f 'mic.c' || echo '$(srcdir)/'`mic.c
 
-mic_la-utils_ignorelist.lo: utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mic_la_CFLAGS) $(CFLAGS) -MT mic_la-utils_ignorelist.lo -MD -MP -MF $(DEPDIR)/mic_la-utils_ignorelist.Tpo -c -o mic_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/mic_la-utils_ignorelist.Tpo $(DEPDIR)/mic_la-utils_ignorelist.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='mic_la-utils_ignorelist.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mic_la_CFLAGS) $(CFLAGS) -c -o mic_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-
 modbus_la-modbus.lo: modbus.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(modbus_la_CFLAGS) $(CFLAGS) -MT modbus_la-modbus.lo -MD -MP -MF $(DEPDIR)/modbus_la-modbus.Tpo -c -o modbus_la-modbus.lo `test -f 'modbus.c' || echo '$(srcdir)/'`modbus.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/modbus_la-modbus.Tpo $(DEPDIR)/modbus_la-modbus.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='modbus.c' object='modbus_la-modbus.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(modbus_la_CFLAGS) $(CFLAGS) -c -o modbus_la-modbus.lo `test -f 'modbus.c' || echo '$(srcdir)/'`modbus.c
@@ -4184,19 +4128,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(netapp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT netapp_la-netapp.lo -MD -MP -MF $(DEPDIR)/netapp_la-netapp.Tpo -c -o netapp_la-netapp.lo `test -f 'netapp.c' || echo '$(srcdir)/'`netapp.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/netapp_la-netapp.Tpo $(DEPDIR)/netapp_la-netapp.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='netapp.c' object='netapp_la-netapp.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(netapp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o netapp_la-netapp.lo `test -f 'netapp.c' || echo '$(srcdir)/'`netapp.c
 
-netapp_la-utils_ignorelist.lo: utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(netapp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT netapp_la-utils_ignorelist.lo -MD -MP -MF $(DEPDIR)/netapp_la-utils_ignorelist.Tpo -c -o netapp_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/netapp_la-utils_ignorelist.Tpo $(DEPDIR)/netapp_la-utils_ignorelist.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='netapp_la-utils_ignorelist.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(netapp_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o netapp_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-
 netlink_la-netlink.lo: netlink.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(netlink_la_CFLAGS) $(CFLAGS) -MT netlink_la-netlink.lo -MD -MP -MF $(DEPDIR)/netlink_la-netlink.Tpo -c -o netlink_la-netlink.lo `test -f 'netlink.c' || echo '$(srcdir)/'`netlink.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/netlink_la-netlink.Tpo $(DEPDIR)/netlink_la-netlink.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='netlink.c' object='netlink_la-netlink.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(netlink_la_CFLAGS) $(CFLAGS) -c -o netlink_la-netlink.lo `test -f 'netlink.c' || echo '$(srcdir)/'`netlink.c
@@ -4240,19 +4177,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(onewire_la_CPPFLAGS) $(CPPFLAGS) $(onewire_la_CFLAGS) $(CFLAGS) -MT onewire_la-onewire.lo -MD -MP -MF $(DEPDIR)/onewire_la-onewire.Tpo -c -o onewire_la-onewire.lo `test -f 'onewire.c' || echo '$(srcdir)/'`onewire.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/onewire_la-onewire.Tpo $(DEPDIR)/onewire_la-onewire.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='onewire.c' object='onewire_la-onewire.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(onewire_la_CPPFLAGS) $(CPPFLAGS) $(onewire_la_CFLAGS) $(CFLAGS) -c -o onewire_la-onewire.lo `test -f 'onewire.c' || echo '$(srcdir)/'`onewire.c
 
-onewire_la-utils_ignorelist.lo: utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(onewire_la_CPPFLAGS) $(CPPFLAGS) $(onewire_la_CFLAGS) $(CFLAGS) -MT onewire_la-utils_ignorelist.lo -MD -MP -MF $(DEPDIR)/onewire_la-utils_ignorelist.Tpo -c -o onewire_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/onewire_la-utils_ignorelist.Tpo $(DEPDIR)/onewire_la-utils_ignorelist.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='onewire_la-utils_ignorelist.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(onewire_la_CPPFLAGS) $(CPPFLAGS) $(onewire_la_CFLAGS) $(CFLAGS) -c -o onewire_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-
 openldap_la-openldap.lo: openldap.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(openldap_la_CFLAGS) $(CFLAGS) -MT openldap_la-openldap.lo -MD -MP -MF $(DEPDIR)/openldap_la-openldap.Tpo -c -o openldap_la-openldap.lo `test -f 'openldap.c' || echo '$(srcdir)/'`openldap.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/openldap_la-openldap.Tpo $(DEPDIR)/openldap_la-openldap.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='openldap.c' object='openldap_la-openldap.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(openldap_la_CFLAGS) $(CFLAGS) -c -o openldap_la-openldap.lo `test -f 'openldap.c' || echo '$(srcdir)/'`openldap.c
@@ -4373,19 +4303,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(sensors_la_CFLAGS) $(CFLAGS) -MT sensors_la-sensors.lo -MD -MP -MF $(DEPDIR)/sensors_la-sensors.Tpo -c -o sensors_la-sensors.lo `test -f 'sensors.c' || echo '$(srcdir)/'`sensors.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sensors_la-sensors.Tpo $(DEPDIR)/sensors_la-sensors.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='sensors.c' object='sensors_la-sensors.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(sensors_la_CFLAGS) $(CFLAGS) -c -o sensors_la-sensors.lo `test -f 'sensors.c' || echo '$(srcdir)/'`sensors.c
 
-sensors_la-utils_ignorelist.lo: utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(sensors_la_CFLAGS) $(CFLAGS) -MT sensors_la-utils_ignorelist.lo -MD -MP -MF $(DEPDIR)/sensors_la-utils_ignorelist.Tpo -c -o sensors_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sensors_la-utils_ignorelist.Tpo $(DEPDIR)/sensors_la-utils_ignorelist.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='sensors_la-utils_ignorelist.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(sensors_la_CFLAGS) $(CFLAGS) -c -o sensors_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-
 sigrok_la-sigrok.lo: sigrok.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(sigrok_la_CFLAGS) $(CFLAGS) -MT sigrok_la-sigrok.lo -MD -MP -MF $(DEPDIR)/sigrok_la-sigrok.Tpo -c -o sigrok_la-sigrok.lo `test -f 'sigrok.c' || echo '$(srcdir)/'`sigrok.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sigrok_la-sigrok.Tpo $(DEPDIR)/sigrok_la-sigrok.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='sigrok.c' object='sigrok_la-sigrok.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(sigrok_la_CFLAGS) $(CFLAGS) -c -o sigrok_la-sigrok.lo `test -f 'sigrok.c' || echo '$(srcdir)/'`sigrok.c
@@ -4394,19 +4317,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(smart_la_CFLAGS) $(CFLAGS) -MT smart_la-smart.lo -MD -MP -MF $(DEPDIR)/smart_la-smart.Tpo -c -o smart_la-smart.lo `test -f 'smart.c' || echo '$(srcdir)/'`smart.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/smart_la-smart.Tpo $(DEPDIR)/smart_la-smart.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='smart.c' object='smart_la-smart.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(smart_la_CFLAGS) $(CFLAGS) -c -o smart_la-smart.lo `test -f 'smart.c' || echo '$(srcdir)/'`smart.c
 
-smart_la-utils_ignorelist.lo: utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(smart_la_CFLAGS) $(CFLAGS) -MT smart_la-utils_ignorelist.lo -MD -MP -MF $(DEPDIR)/smart_la-utils_ignorelist.Tpo -c -o smart_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/smart_la-utils_ignorelist.Tpo $(DEPDIR)/smart_la-utils_ignorelist.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='smart_la-utils_ignorelist.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(smart_la_CFLAGS) $(CFLAGS) -c -o smart_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-
 snmp_la-snmp.lo: snmp.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(snmp_la_CFLAGS) $(CFLAGS) -MT snmp_la-snmp.lo -MD -MP -MF $(DEPDIR)/snmp_la-snmp.Tpo -c -o snmp_la-snmp.lo `test -f 'snmp.c' || echo '$(srcdir)/'`snmp.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/snmp_la-snmp.Tpo $(DEPDIR)/snmp_la-snmp.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='snmp.c' object='snmp_la-snmp.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(snmp_la_CFLAGS) $(CFLAGS) -c -o snmp_la-snmp.lo `test -f 'snmp.c' || echo '$(srcdir)/'`snmp.c
@@ -4457,19 +4373,12 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(virt_la_CFLAGS) $(CFLAGS) -MT virt_la-virt.lo -MD -MP -MF $(DEPDIR)/virt_la-virt.Tpo -c -o virt_la-virt.lo `test -f 'virt.c' || echo '$(srcdir)/'`virt.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/virt_la-virt.Tpo $(DEPDIR)/virt_la-virt.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='virt.c' object='virt_la-virt.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(virt_la_CFLAGS) $(CFLAGS) -c -o virt_la-virt.lo `test -f 'virt.c' || echo '$(srcdir)/'`virt.c
 
-virt_la-utils_ignorelist.lo: utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(virt_la_CFLAGS) $(CFLAGS) -MT virt_la-utils_ignorelist.lo -MD -MP -MF $(DEPDIR)/virt_la-utils_ignorelist.Tpo -c -o virt_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/virt_la-utils_ignorelist.Tpo $(DEPDIR)/virt_la-utils_ignorelist.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='utils_ignorelist.c' object='virt_la-utils_ignorelist.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(virt_la_CFLAGS) $(CFLAGS) -c -o virt_la-utils_ignorelist.lo `test -f 'utils_ignorelist.c' || echo '$(srcdir)/'`utils_ignorelist.c
-
 write_http_la-write_http.lo: write_http.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(write_http_la_CFLAGS) $(CFLAGS) -MT write_http_la-write_http.lo -MD -MP -MF $(DEPDIR)/write_http_la-write_http.Tpo -c -o write_http_la-write_http.lo `test -f 'write_http.c' || echo '$(srcdir)/'`write_http.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/write_http_la-write_http.Tpo $(DEPDIR)/write_http_la-write_http.Plo
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='write_http.c' object='write_http_la-write_http.lo' libtool=yes @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(write_http_la_CFLAGS) $(CFLAGS) -c -o write_http_la-write_http.lo `test -f 'write_http.c' || echo '$(srcdir)/'`write_http.c
@@ -4597,12 +4506,26 @@
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectdmon_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT collectdmon-collectdmon.obj -MD -MP -MF $(DEPDIR)/collectdmon-collectdmon.Tpo -c -o collectdmon-collectdmon.obj `if test -f 'collectdmon.c'; then $(CYGPATH_W) 'collectdmon.c'; else $(CYGPATH_W) '$(srcdir)/collectdmon.c'; fi`
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/collectdmon-collectdmon.Tpo $(DEPDIR)/collectdmon-collectdmon.Po
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='collectdmon.c' object='collectdmon-collectdmon.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(collectdmon_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o collectdmon-collectdmon.obj `if test -f 'collectdmon.c'; then $(CYGPATH_W) 'collectdmon.c'; else $(CYGPATH_W) '$(srcdir)/collectdmon.c'; fi`
 
+test_plugin_ceph-ceph_test.o: ceph_test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_plugin_ceph_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_plugin_ceph-ceph_test.o -MD -MP -MF $(DEPDIR)/test_plugin_ceph-ceph_test.Tpo -c -o test_plugin_ceph-ceph_test.o `test -f 'ceph_test.c' || echo '$(srcdir)/'`ceph_test.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_plugin_ceph-ceph_test.Tpo $(DEPDIR)/test_plugin_ceph-ceph_test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='ceph_test.c' object='test_plugin_ceph-ceph_test.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_plugin_ceph_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_plugin_ceph-ceph_test.o `test -f 'ceph_test.c' || echo '$(srcdir)/'`ceph_test.c
+
+test_plugin_ceph-ceph_test.obj: ceph_test.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_plugin_ceph_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT test_plugin_ceph-ceph_test.obj -MD -MP -MF $(DEPDIR)/test_plugin_ceph-ceph_test.Tpo -c -o test_plugin_ceph-ceph_test.obj `if test -f 'ceph_test.c'; then $(CYGPATH_W) 'ceph_test.c'; else $(CYGPATH_W) '$(srcdir)/ceph_test.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/test_plugin_ceph-ceph_test.Tpo $(DEPDIR)/test_plugin_ceph-ceph_test.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='ceph_test.c' object='test_plugin_ceph-ceph_test.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(test_plugin_ceph_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o test_plugin_ceph-ceph_test.obj `if test -f 'ceph_test.c'; then $(CYGPATH_W) 'ceph_test.c'; else $(CYGPATH_W) '$(srcdir)/ceph_test.c'; fi`
+
 mostlyclean-libtool:
 	-rm -f *.lo
 
 clean-libtool:
 	-rm -rf .libs _libs
 install-man1: $(dist_man_MANS)
@@ -4943,12 +4866,19 @@
 	@p='test_utils_vl_lookup$(EXEEXT)'; \
 	b='test_utils_vl_lookup'; \
 	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
 	"$$tst" $(AM_TESTS_FD_REDIRECT)
+test_plugin_ceph.log: test_plugin_ceph$(EXEEXT)
+	@p='test_plugin_ceph$(EXEEXT)'; \
+	b='test_plugin_ceph'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
 .test.log:
 	@p='$<'; \
 	$(am__set_b); \
 	$(am__check_pre) $(TEST_LOG_DRIVER) --test-name "$$f" \
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_TEST_LOG_DRIVER_FLAGS) $(TEST_LOG_DRIVER_FLAGS) -- $(TEST_LOG_COMPILE) \
@@ -5180,17 +5110,17 @@
 		>.pod2man.tmp.$$$$ 2>/dev/null && mv -f .pod2man.tmp.$$$$ $@ || true
 	@if grep '\<POD ERRORS\>' $@ >/dev/null 2>&1; \
 	then \
 		echo "$@ has some POD errors!"; false; \
 	fi
 
-@HAVE_PROTOC_C_TRUE@pinba.pb-c.c pinba.pb-c.h: pinba.proto
-@HAVE_PROTOC_C_TRUE@	protoc-c -I$(srcdir) --c_out . $(srcdir)/pinba.proto
+@BUILD_PLUGIN_PINBA_TRUE@pinba.pb-c.c pinba.pb-c.h: pinba.proto
+@BUILD_PLUGIN_PINBA_TRUE@	$(AM_V_PROTOC_C)protoc-c -I$(srcdir) --c_out . $(srcdir)/pinba.proto
 
-@HAVE_PROTOC_C_TRUE@riemann.pb-c.c riemann.pb-c.h: riemann.proto
-@HAVE_PROTOC_C_TRUE@	protoc-c -I$(srcdir) --c_out . $(srcdir)/riemann.proto
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@riemann.pb-c.c riemann.pb-c.h: riemann.proto
+@BUILD_PLUGIN_WRITE_RIEMANN_TRUE@	$(AM_V_PROTOC_C)protoc-c -I$(srcdir) --c_out . $(srcdir)/riemann.proto
 
 install-exec-hook:
 	$(mkinstalldirs) $(DESTDIR)$(sysconfdir)
 	if test -e $(DESTDIR)$(sysconfdir)/collectd.conf; \
 	then \
 		$(INSTALL) -m 0640 collectd.conf $(DESTDIR)$(sysconfdir)/collectd.conf.pkg-orig; \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/memcachec.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/memcachec.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/memcachec.c	2015-03-10 22:14:45.841114412 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/memcachec.c	2016-01-22 17:51:17.705918688 +0800
@@ -260,13 +260,16 @@
     }
 
     break;
   } /* while (status == 0) */
 
   if (status != 0)
+  {
+    cmc_web_match_free (match);
     return (status);
+  }
 
   match->match = match_create_simple (match->regex, match->exclude_regex,
       match->dstype);
   if (match->match == NULL)
   {
     ERROR ("memcachec plugin: tail_match_add_match_simple failed.");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/memcached.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/memcached.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/memcached.c	2015-03-10 22:14:45.841114412 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/memcached.c	2016-01-22 17:51:17.705918688 +0800
@@ -59,12 +59,13 @@
     return;
 
   sfree (st->name);
   sfree (st->socket);
   sfree (st->host);
   sfree (st->port);
+  sfree (st);
 }
 
 static int memcached_connect_unix (memcached_t *st)
 {
   struct sockaddr_un serv_addr;
   int fd;
@@ -436,13 +437,13 @@
     else if (FIELD_IS ("curr_connections"))
     {
       submit_gauge ("memcached_connections", "current", atof (fields[2]), st);
     }
     else if (FIELD_IS ("listen_disabled_num"))
     {
-      submit_derive ("memcached_connections", "listen_disabled", atof (fields[2]), st);
+      submit_derive ("connections", "listen_disabled", atof (fields[2]), st);
     }
 
     /*
      * Commands
      */
     else if ((name_len > 4) && (strncmp (fields[1], "cmd_", 4) == 0))
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/modbus.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/modbus.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/modbus.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/modbus.c	2016-01-22 17:51:17.705918688 +0800
@@ -24,13 +24,13 @@
 #include "common.h"
 #include "plugin.h"
 #include "configfile.h"
 
 #include <netdb.h>
 
-#include <modbus/modbus.h>
+#include <modbus.h>
 
 #ifndef LIBMODBUS_VERSION_CHECK
 /* Assume version 2.0.3 */
 # define LEGACY_LIBMODBUS 1
 #else
 /* Assume version 2.9.2 */
@@ -423,13 +423,13 @@
 static int mb_read_data (mb_host_t *host, mb_slave_t *slave, /* {{{ */
     mb_data_t *data)
 {
   uint16_t values[2];
   int values_num;
   const data_set_t *ds;
-  int status;
+  int status = 0;
 
   if ((host == NULL) || (slave == NULL) || (data == NULL))
     return (EINVAL);
 
   ds = plugin_get_ds (data->type);
   if (ds == NULL)
@@ -460,13 +460,12 @@
       || (data->register_type == REG_TYPE_UINT32)
       || (data->register_type == REG_TYPE_FLOAT))
     values_num = 2;
   else
     values_num = 1;
 
-  status = 0;
   if (host->connection == NULL)
   {
     status = EBADF;
   }
   else if (host->conntype == MBCONN_TCP)
   {
@@ -730,13 +729,12 @@
   if (status != 0)
     return (status);
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *child = ci->children + i;
-    status = 0;
 
     if (strcasecmp ("Type", child->key) == 0)
       status = cf_util_get_string_buffer (child,
           data.type, sizeof (data.type));
     else if (strcasecmp ("Instance", child->key) == 0)
       status = cf_util_get_string_buffer (child,
@@ -891,13 +889,12 @@
   if (status != 0)
     return (status);
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *child = ci->children + i;
-    status = 0;
 
     if (strcasecmp ("Instance", child->key) == 0)
       status = cf_util_get_string_buffer (child,
           slave->instance, sizeof (slave->instance));
     else if (strcasecmp ("Collect", child->key) == 0)
     {
@@ -942,15 +939,21 @@
     return (ENOMEM);
   memset (host, 0, sizeof (*host));
   host->slaves = NULL;
 
   status = cf_util_get_string_buffer (ci, host->host, sizeof (host->host));
   if (status != 0)
+  {
+    sfree (host);
     return (status);
+  }
   if (host->host[0] == 0)
+  {
+    sfree (host);
     return (EINVAL);
+  }
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *child = ci->children + i;
     status = 0;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/multimeter.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/multimeter.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/multimeter.c	2012-09-13 19:10:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/multimeter.c	2016-01-22 16:33:25.050182513 +0800
@@ -150,31 +150,32 @@
 {
 	int i;
 	char device[] = "/dev/ttyS ";
 
 	for (i = 0; i < 10; i++)
 	{
-		device[strlen(device)-1] = i + '0'; 
+		device[strlen(device)-1] = i + '0';
 
-		if ((fd = open(device, O_RDWR | O_NOCTTY)) > 0)
+		if ((fd = open(device, O_RDWR | O_NOCTTY)) != -1)
 		{
 			struct termios tios;
 			int rts = TIOCM_RTS;
 			double value;
 
+			memset (&tios, 0, sizeof (tios));
 			tios.c_cflag = B1200 | CS7 | CSTOPB | CREAD | CLOCAL;
 			tios.c_iflag = IGNBRK | IGNPAR;
 	    		tios.c_oflag = 0;
 			tios.c_lflag = 0;
 			tios.c_cc[VTIME] = 3;
 			tios.c_cc[VMIN]  = LINE_LENGTH;
 
 			tcflush(fd, TCIFLUSH);
 			tcsetattr(fd, TCSANOW, &tios);
 			ioctl(fd, TIOCMBIC, &rts);
-			
+
     			if (multimeter_read_value (&value) < -1)
 			{
 				close (fd);
 				fd = -1;
 			}
 			else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/mysql.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/mysql.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/mysql.c	2015-03-10 22:14:45.841114412 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/mysql.c	2016-01-22 17:51:17.709918685 +0800
@@ -812,13 +812,13 @@
 			/* buffer pool */
 			if (strcmp (key, "Innodb_buffer_pool_pages_data") == 0)
 				gauge_submit ("mysql_bpool_pages", "data", val, db);
 			else if (strcmp (key, "Innodb_buffer_pool_pages_dirty") == 0)
 				gauge_submit ("mysql_bpool_pages", "dirty", val, db);
 			else if (strcmp (key, "Innodb_buffer_pool_pages_flushed") == 0)
-				counter_submit ("mysql_bpool_pages", "flushed", val, db);
+				counter_submit ("mysql_bpool_counters", "pages_flushed", val, db);
 			else if (strcmp (key, "Innodb_buffer_pool_pages_free") == 0)
 				gauge_submit ("mysql_bpool_pages", "free", val, db);
 			else if (strcmp (key, "Innodb_buffer_pool_pages_misc") == 0)
 				gauge_submit ("mysql_bpool_pages", "misc", val, db);
 			else if (strcmp (key, "Innodb_buffer_pool_pages_total") == 0)
 				gauge_submit ("mysql_bpool_pages", "total", val, db);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/netapp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/netapp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/netapp.c	2014-08-18 15:33:14.292460715 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/netapp.c	2016-01-22 17:37:50.194392654 +0800
@@ -1521,13 +1521,13 @@
  * notification. */
 static int cna_change_volume_status (const char *hostname, /* {{{ */
 		data_volume_usage_t *v)
 {
 	notification_t n;
 
-	memset (&n, 0, sizeof (&n));
+	memset (&n, 0, sizeof (n));
 	n.time = cdtime ();
 	sstrncpy (n.host, hostname, sizeof (n.host));
 	sstrncpy (n.plugin, "netapp", sizeof (n.plugin));
 	sstrncpy (n.plugin_instance, v->name, sizeof (n.plugin_instance));
 
 	if ((v->flags & IS_VOLUME_USAGE_OFFLINE) != 0) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/network.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/network.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/network.c	2015-03-12 17:33:23.010207874 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/network.c	2016-01-22 17:51:17.709918685 +0800
@@ -2024,12 +2024,13 @@
 	se->interface = 0;
 	se->next = NULL;
 
 	if (type == SOCKENT_TYPE_SERVER)
 	{
 		se->data.server.fd = NULL;
+		se->data.server.fd_num = 0;
 #if HAVE_LIBGCRYPT
 		se->data.server.security_level = SECURITY_LEVEL_NONE;
 		se->data.server.auth_file = NULL;
 		se->data.server.userdb = NULL;
 		se->data.server.cypher = NULL;
 #endif
@@ -2237,12 +2238,15 @@
         const char *node;
         const char *service;
 
 	if (se == NULL)
 		return (-1);
 
+	assert (se->data.server.fd == NULL);
+	assert (se->data.server.fd_num == 0);
+
         node = se->node;
         service = se->service;
 
         if (service == NULL)
           service = NET_DEFAULT_PORT;
 
@@ -2436,13 +2440,13 @@
 static int network_receive (void) /* {{{ */
 {
 	char buffer[network_config_packet_size];
 	int  buffer_len;
 
 	int i;
-	int status;
+	int status = 0;
 
 	receive_list_entry_t *private_list_head;
 	receive_list_entry_t *private_list_tail;
 	uint64_t              private_list_length;
 
         assert (listen_sockets_num > 0);
@@ -2451,21 +2455,20 @@
 	private_list_tail = NULL;
 	private_list_length = 0;
 
 	while (listen_loop == 0)
 	{
 		status = poll (listen_sockets_pollfd, listen_sockets_num, -1);
-
 		if (status <= 0)
 		{
 			char errbuf[1024];
 			if (errno == EINTR)
 				continue;
-			ERROR ("poll failed: %s",
+			ERROR ("network plugin: poll(2) failed: %s",
 					sstrerror (errno, errbuf, sizeof (errbuf)));
-			return (-1);
+			break;
 		}
 
 		for (i = 0; (i < listen_sockets_num) && (status > 0); i++)
 		{
 			receive_list_entry_t *ent;
 
@@ -2477,16 +2480,16 @@
 			buffer_len = recv (listen_sockets_pollfd[i].fd,
 					buffer, sizeof (buffer),
 					0 /* no flags */);
 			if (buffer_len < 0)
 			{
 				char errbuf[1024];
-				ERROR ("recv failed: %s",
-						sstrerror (errno, errbuf,
-							sizeof (errbuf)));
-				return (-1);
+				status = (errno != 0) ? errno : -1;
+				ERROR ("network plugin: recv(2) failed: %s",
+						sstrerror (errno, errbuf, sizeof (errbuf)));
+				break;
 			}
 
 			stats_octets_rx += ((uint64_t) buffer_len);
 			stats_packets_rx++;
 
 			/* TODO: Possible performance enhancement: Do not free
@@ -2494,21 +2497,23 @@
 			 * another list, so we don't have to allocate more and
 			 * more of these structures. */
 			ent = malloc (sizeof (receive_list_entry_t));
 			if (ent == NULL)
 			{
 				ERROR ("network plugin: malloc failed.");
-				return (-1);
+				status = ENOMEM;
+				break;
 			}
 			memset (ent, 0, sizeof (receive_list_entry_t));
 			ent->data = malloc (network_config_packet_size);
 			if (ent->data == NULL)
 			{
 				sfree (ent);
 				ERROR ("network plugin: malloc failed.");
-				return (-1);
+				status = ENOMEM;
+				break;
 			}
 			ent->fd = listen_sockets_pollfd[i].fd;
 			ent->next = NULL;
 
 			memcpy (ent->data, buffer, buffer_len);
 			ent->data_len = buffer_len;
@@ -2538,13 +2543,18 @@
 				pthread_mutex_unlock (&receive_list_lock);
 
 				private_list_head = NULL;
 				private_list_tail = NULL;
 				private_list_length = 0;
 			}
+
+			status = 0;
 		} /* for (listen_sockets_pollfd) */
+
+		if (status != 0)
+			break;
 	} /* while (listen_loop == 0) */
 
 	/* Make sure everything is dispatched before exiting. */
 	if (private_list_head != NULL)
 	{
 		pthread_mutex_lock (&receive_list_lock);
@@ -2553,21 +2563,17 @@
 			receive_list_head = private_list_head;
 		else
 			receive_list_tail->next = private_list_head;
 		receive_list_tail = private_list_tail;
 		receive_list_length += private_list_length;
 
-		private_list_head = NULL;
-		private_list_tail = NULL;
-		private_list_length = 0;
-
 		pthread_cond_signal (&receive_list_cond);
 		pthread_mutex_unlock (&receive_list_lock);
 	}
 
-	return (0);
+	return (status);
 } /* }}} int network_receive */
 
 static void *receive_thread (void __attribute__((unused)) *arg)
 {
 	return (network_receive () ? (void *) 1 : (void *) 0);
 } /* void *receive_thread */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/nfs.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/nfs.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/nfs.c	2015-03-10 22:14:45.845114500 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/nfs.c	2016-01-22 17:51:17.709918685 +0800
@@ -503,12 +503,13 @@
 		case 41:
 			proc40_names_num = 35;
 			break;
 		case 42:
 		case 44:
 			proc40_names_num = 36;
+			break;
 		case 46:
 		case 47:
 		case 51:
 		case 53:
 			proc40_names_num = 37;
 			break;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ntpd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ntpd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ntpd.c	2015-03-10 22:14:45.845114500 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ntpd.c	2016-01-22 17:51:17.709918685 +0800
@@ -307,13 +307,13 @@
 		return (-1);
 	}
 
 	return (0);
 }
 
-static void ntpd_submit (char *type, char *type_inst, double value)
+static void ntpd_submit (char *type, char *type_inst, gauge_t value)
 {
 	value_t values[1];
 	value_list_t vl = VALUE_LIST_INIT;
 
 	values[0].gauge = value;
 
@@ -329,13 +329,13 @@
 }
 
 /* Each time a peer is polled, ntpd shifts the reach register to the left and
  * sets the LSB based on whether the peer was reachable. If the LSB is zero,
  * the values are out of date. */
 static void ntpd_submit_reach (char *type, char *type_inst, uint8_t reach,
-		double value)
+		gauge_t value)
 {
 	if (!(reach & 1))
 		value = NAN;
 
 	ntpd_submit (type, type_inst, value);
 }
@@ -667,13 +667,12 @@
 		DEBUG ("realloc (%p, %zu)", (void *) *res_data,
 				(items_num + pkt_item_num) * res_item_size);
 		items = realloc ((void *) *res_data,
 				(items_num + pkt_item_num) * res_item_size);
 		if (items == NULL)
 		{
-			items = *res_data;
 			ERROR ("ntpd plugin: realloc failed.");
 			continue;
 		}
 		items_num += pkt_item_num;
 		*res_data = items;
 
@@ -903,15 +902,25 @@
 	int                 ik_size;
 
 	struct info_peer_summary *ps;
 	int                       ps_num;
 	int                       ps_size;
 
+	gauge_t offset_loop;
+	gauge_t freq_loop;
+	gauge_t offset_error;
+
 	int status;
 	int i;
 
+	/* On Linux, if the STA_NANO bit is set in ik->status, then ik->offset
+	 * is is nanoseconds, otherwise it's microseconds.
+	 * TODO(octo): STA_NANO is defined in the Linux specific <sys/timex.h> header. */
+	double scale_loop  = 1e-6;
+	double scale_error = 1e-6;
+
 	ik      = NULL;
 	ik_num  = 0;
 	ik_size = 0;
 
 	status = ntpd_do_query (REQ_GET_KERNEL,
 			0, 0, NULL, /* request data */
@@ -928,24 +937,25 @@
 				"(ik = %p; ik_num = %i; ik_size = %i)",
 				(void *) ik, ik_num, ik_size);
 		return (-1);
 	}
 
 	/* kerninfo -> estimated error */
+	offset_loop  = scale_loop * ((gauge_t) ntohl (ik->offset));
+	freq_loop    = ntpd_read_fp (ik->freq);
+	offset_error = scale_error * ((gauge_t) ntohl (ik->esterror));
 
 	DEBUG ("info_kernel:\n"
-			"  pll offset    = %.8f\n"
-			"  pll frequency = %.8f\n" /* drift compensation */
-			"  est error     = %.8f\n",
-			ntpd_read_fp (ik->offset),
-			ntpd_read_fp (ik->freq),
-			ntpd_read_fp (ik->esterror));
-
-	ntpd_submit ("frequency_offset", "loop",  ntpd_read_fp (ik->freq));
-	ntpd_submit ("time_offset",      "loop",  ntpd_read_fp (ik->offset));
-	ntpd_submit ("time_offset",      "error", ntpd_read_fp (ik->esterror));
+			"  pll offset    = %.8g\n"
+			"  pll frequency = %.8g\n" /* drift compensation */
+			"  est error     = %.8g\n",
+			offset_loop, freq_loop, offset_error);
+
+	ntpd_submit ("frequency_offset", "loop",  freq_loop);
+	ntpd_submit ("time_offset",      "loop",  offset_loop);
+	ntpd_submit ("time_offset",      "error", offset_error);
 
 	free (ik);
 	ik = NULL;
 
 	status = ntpd_do_query (REQ_PEER_LIST_SUM,
 			0, 0, NULL, /* request data */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/onewire.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/onewire.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/onewire.c	2015-03-10 22:14:45.845114500 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/onewire.c	2016-01-22 17:51:17.709918685 +0800
@@ -381,13 +381,12 @@
 
     endptr = NULL;
     values[0].gauge = strtod (buffer, &endptr);
     if (endptr == NULL)
     {
       ERROR ("onewire plugin: Buffer is not a number: %s", buffer);
-      status = -1;
       continue;
     }
 
     sstrncpy (vl.type, family_info->features[i].type, sizeof (vl.type));
     sstrncpy (vl.type_instance, family_info->features[i].type_instance,
         sizeof (vl.type_instance));
@@ -525,13 +524,12 @@
 
       endptr = NULL;
       values[0].gauge = strtod (buffer, &endptr);
       if (endptr == NULL)
       {
           ERROR ("onewire plugin: Buffer is not a number: %s", buffer);
-          status = -1;
           continue;
       }
 
       sstrncpy (vl.type, traverse->file, sizeof (vl.type));
       sstrncpy (vl.type_instance, "",   sizeof (""));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/openldap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/openldap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/openldap.c	2015-03-10 22:14:45.845114500 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/openldap.c	2016-01-22 17:51:17.709918685 +0800
@@ -28,12 +28,17 @@
 
 #include "collectd.h"
 #include "common.h"
 #include "plugin.h"
 #include "configfile.h"
 
+#if defined(__APPLE__)
+#pragma clang diagnostic push
+#pragma clang diagnostic warning "-Wdeprecated-declarations"
+#endif
+
 #include <lber.h>
 #include <ldap.h>
 
 struct cldap_s /* {{{ */
 {
 	char *name;
@@ -601,13 +606,14 @@
 		{
 			ERROR ("openldap plugin: Instance `%s': "
 				"Invalid URL: `%s'",
 				st->name, st->url);
 			status = -1;
 		}
-		else
+
+		if ((status == 0) && (ludpp->lud_host != NULL))
 		{
 			st->host = strdup (ludpp->lud_host);
 		}
 
 		ldap_free_urldesc (ludpp);
 	}
@@ -677,6 +683,10 @@
 
 void module_register (void) /* {{{ */
 {
 	plugin_register_complex_config ("openldap", cldap_config);
 	plugin_register_init ("openldap", cldap_init);
 } /* }}} void module_register */
+
+#if defined(__APPLE__)
+#pragma clang diagnostic pop
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/openvpn.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/openvpn.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/openvpn.c	2015-03-10 22:14:45.845114500 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/openvpn.c	2016-01-22 17:51:17.709918685 +0800
@@ -186,14 +186,12 @@
 	tun_rx = 0;
 	tun_tx = 0;
 	pre_compress = 0;
 	post_compress = 0;
 	pre_decompress = 0;
 	post_decompress = 0;
-	overhead_rx = 0;
-	overhead_tx = 0;
 
 	while (fgets (buffer, sizeof (buffer), fh) != NULL)
 	{
 		fields_num = openvpn_strsplit (buffer, fields, max_fields);
 
 		/* status file is generated by openvpn/sig.c:print_status()
@@ -517,19 +515,21 @@
 } /* int multi4_read */
 
 /* read callback */
 static int openvpn_read (void)
 {
 	FILE *fh;
-	int  i, vpn_read, read;
+	int  i, read;
 
-	vpn_read = read = 0;
+	read = 0;
 
 	/* call the right read function for every status entry in the list */
 	for (i = 0; i < vpn_num; i++)
 	{
+		int vpn_read = 0;
+
 		fh = fopen (vpn_list[i]->file, "r");
 		if (fh == NULL)
 		{
 			char errbuf[1024];
 			WARNING ("openvpn plugin: fopen(%s) failed: %s", vpn_list[i]->file,
 					sstrerror (errno, errbuf, sizeof (errbuf)));
@@ -694,21 +694,29 @@
 				return (1);
 			}
 		}
 
 		/* create a new vpn element since file, version and name are ok */
 		temp = (vpn_status_t *) malloc (sizeof (vpn_status_t));
+		if (temp == NULL)
+		{
+			char errbuf[1024];
+			ERROR ("openvpn plugin: malloc failed: %s",
+					sstrerror (errno, errbuf, sizeof (errbuf)));
+			sfree (status_file);
+			return (1);
+		}
 		temp->file = status_file;
 		temp->version = status_version;
 		temp->name = status_name;
 
 		vpn_list = (vpn_status_t **) realloc (vpn_list, (vpn_num + 1) * sizeof (vpn_status_t *));
 		if (vpn_list == NULL)
 		{
 			char errbuf[1024];
-			ERROR ("openvpn plugin: malloc failed: %s",
+			ERROR ("openvpn plugin: realloc failed: %s",
 					sstrerror (errno, errbuf, sizeof (errbuf)));
 
 			sfree (temp->file);
 			sfree (temp);
 			return (1);
 		}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/perl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/perl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/perl.c	2015-03-10 22:14:45.845114500 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/perl.c	2016-01-22 17:51:17.709918685 +0800
@@ -513,13 +513,12 @@
 		}
 		sstrncpy ((*m)->name, SvPV_nolen (*tmp), sizeof ((*m)->name));
 
 		if (NULL == (tmp = hv_fetch (hash, "value", 5, 0))) {
 			log_warn ("av2notification_meta: Skipping invalid "
 					"meta information.");
-			free ((*m)->name);
 			free (*m);
 			continue;
 		}
 
 		if (SvNOK (*tmp)) {
 			(*m)->nm_value.nm_double = SvNVX (*tmp);
@@ -1206,13 +1205,16 @@
 	for (t = perl_threads->head; NULL != t; t = t->next)
 		if (t == ithread)
 			break;
 
 	/* the ithread no longer exists */
 	if (NULL == t)
+	{
+		pthread_mutex_unlock (&perl_threads->mutex);
 		return;
+	}
 
 	c_ithread_destroy (ithread);
 
 	pthread_mutex_unlock (&perl_threads->mutex);
 	return;
 } /* static void c_ithread_destructor (void *) */
@@ -1647,21 +1649,21 @@
 
 	log_debug ("Collectd::plugin_dispatch_values: values=\"%s\"",
 			SvPV_nolen (ST (/* stack index = */ 0)));
 
 	values = ST (/* stack index = */ 0);
 
+	if (NULL == values)
+		XSRETURN_EMPTY;
+
 	/* Make sure the argument is a hash reference. */
 	if (! (SvROK (values) && (SVt_PVHV == SvTYPE (SvRV (values))))) {
 		log_err ("Collectd::plugin_dispatch_values: Invalid values.");
 		XSRETURN_EMPTY;
 	}
 
-	if (NULL == values)
-		XSRETURN_EMPTY;
-
 	ret = pplugin_dispatch_values (aTHX_ (HV *)SvRV (values));
 
 	if (0 == ret)
 		XSRETURN_YES;
 	else
 		XSRETURN_EMPTY;
@@ -2513,13 +2515,16 @@
 
 	for (i = 0; i < ci->children_num; ++i) {
 		oconfig_item_t *c = ci->children + i;
 		int current_status = 0;
 
 		if (NULL != perl_threads)
-			aTHX = PERL_GET_CONTEXT;
+		{
+			if ((aTHX = PERL_GET_CONTEXT) == NULL)
+				return -1;
+		}
 
 		if (0 == strcasecmp (c->key, "LoadPlugin"))
 			current_status = perl_config_loadplugin (aTHX_ c);
 		else if (0 == strcasecmp (c->key, "BaseName"))
 			current_status = perl_config_basename (aTHX_ c);
 		else if (0 == strcasecmp (c->key, "EnableDebugger"))
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/pf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/pf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/pf.c	2015-03-10 22:14:45.845114500 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/pf.c	2016-01-22 17:51:17.709918685 +0800
@@ -29,12 +29,15 @@
 #if HAVE_SYS_SOCKET_H
 # include <sys/socket.h>
 #endif
 #if HAVE_NET_IF_H
 # include <net/if.h>
 #endif
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
 
 #include <net/pfvar.h>
 
 #ifndef FCNT_NAMES
 # if FCNT_MAX != 3
 #  error "Unexpected value for FCNT_MAX"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/pinba.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/pinba.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/pinba.c	2015-03-10 22:14:45.845114500 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/pinba.c	2016-01-22 17:51:17.709918685 +0800
@@ -333,12 +333,13 @@
   status = bind (fd, ai->ai_addr, ai->ai_addrlen);
   if (status != 0)
   {
     char errbuf[1024];
     ERROR ("pinba plugin: bind(2) failed: %s",
         sstrerror (errno, errbuf, sizeof (errbuf)));
+    close (fd);
     return (0);
   }
 
   s->fd[s->fd_num].fd = fd;
   s->fd[s->fd_num].events = POLLIN | POLLPRI;
   s->fd[s->fd_num].revents = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ping.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ping.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ping.c	2015-03-10 22:14:45.845114500 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ping.c	2016-01-22 17:51:17.709918685 +0800
@@ -238,13 +238,13 @@
 
   return (0);
 } /* }}} int ping_dispatch_all */
 
 static void *ping_thread (void *arg) /* {{{ */
 {
-  static pingobj_t *pingobj = NULL;
+  pingobj_t *pingobj = NULL;
 
   struct timeval  tv_begin;
   struct timeval  tv_end;
   struct timespec ts_wait;
   struct timespec ts_int;
 
@@ -356,13 +356,13 @@
     }
 
     /* Calculate the absolute time until which to wait and store it in
      * `ts_wait'. */
     time_calc (&ts_wait, &ts_int, &tv_begin, &tv_end);
 
-    status = pthread_cond_timedwait (&ping_cond, &ping_lock, &ts_wait);
+    pthread_cond_timedwait (&ping_cond, &ping_lock, &ts_wait);
     if (ping_thread_loop <= 0)
       break;
   } /* while (ping_thread_loop > 0) */
 
   pthread_mutex_unlock (&ping_lock);
   ping_destroy (pingobj);
@@ -418,14 +418,16 @@
   if (status != 0)
   {
     ERROR ("ping plugin: Stopping thread failed.");
     status = -1;
   }
 
+  pthread_mutex_lock (&ping_lock);
   memset (&ping_thread_id, 0, sizeof (ping_thread_id));
   ping_thread_error = 0;
+  pthread_mutex_unlock (&ping_lock);
 
   return (status);
 } /* }}} int stop_thread */
 
 static int ping_init (void) /* {{{ */
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/postgresql.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/postgresql.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/postgresql.c	2015-05-22 18:04:36.951771009 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/postgresql.c	2016-01-22 17:51:17.709918685 +0800
@@ -1042,23 +1042,25 @@
 	const char *param_str;
 
 	c_psql_param_t *tmp;
 
 	data = udb_query_get_user_data (q);
 	if (NULL == data) {
-		data = (c_psql_user_data_t *) smalloc (sizeof (*data));
+		data = malloc (sizeof (*data));
 		if (NULL == data) {
 			log_err ("Out of memory.");
 			return -1;
 		}
 		memset (data, 0, sizeof (*data));
 		data->params = NULL;
+		data->params_num = 0;
+
+		udb_query_set_user_data (q, data);
 	}
 
-	tmp = (c_psql_param_t *) realloc (data->params,
-			(data->params_num + 1) * sizeof (c_psql_param_t));
+	tmp = realloc (data->params, (data->params_num + 1) * sizeof (*data->params));
 	if (NULL == tmp) {
 		log_err ("Out of memory.");
 		return -1;
 	}
 	data->params = tmp;
 
@@ -1076,14 +1078,12 @@
 	else {
 		log_err ("Invalid parameter \"%s\".", param_str);
 		return 1;
 	}
 
 	data->params_num++;
-	udb_query_set_user_data (q, data);
-
 	return (0);
 } /* config_query_param_add */
 
 static int config_query_callback (udb_query_t *q, oconfig_item_t *ci)
 {
 	if (0 == strcasecmp ("Param", ci->key))
@@ -1161,13 +1161,13 @@
 		log_err ("Out of memory.");
 		return -1;
 	}
 
 	writers = tmp;
 	writer  = writers + writers_num;
-	++writers_num;
+	memset (writer, 0, sizeof (*writer));
 
 	writer->name = sstrdup (ci->values[0].value.string);
 	writer->statement = NULL;
 	writer->store_rates = 1;
 
 	for (i = 0; i < ci->children_num; ++i) {
@@ -1181,16 +1181,16 @@
 			log_warn ("Ignoring unknown config key \"%s\".", c->key);
 	}
 
 	if (status != 0) {
 		sfree (writer->statement);
 		sfree (writer->name);
-		sfree (writer);
 		return status;
 	}
 
+	++writers_num;
 	return 0;
 } /* c_psql_config_writer */
 
 static int c_psql_config_database (oconfig_item_t *ci)
 {
 	c_psql_database_t *db;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/powerdns.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/powerdns.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/powerdns.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/powerdns.c	2016-01-22 17:51:17.709918685 +0800
@@ -120,13 +120,13 @@
 uptime              number of seconds process has been running (since 3.1.5)
 user-msec           number of CPU milliseconds spent in 'user' mode
 }}} */
 
 const char* const default_server_fields[] = /* {{{ */
 {
-  "latency"
+  "latency",
   "packetcache-hit",
   "packetcache-miss",
   "packetcache-size",
   "query-cache-hit",
   "query-cache-miss",
   "recursing-answers",
@@ -459,12 +459,18 @@
   }
 
   struct timeval timeout;
   timeout.tv_sec=5;
   timeout.tv_usec=0;
   status = setsockopt (sd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof (timeout));
+  if (status != 0)
+  {
+    FUNC_ERROR ("setsockopt");
+    close (sd);
+    return (-1);
+  }
 
   status = connect (sd, (struct sockaddr *) &item->sockaddr,
       sizeof (item->sockaddr));
   if (status != 0)
   {
     FUNC_ERROR ("connect");
@@ -506,13 +512,12 @@
 
     memcpy (buffer + buffer_size, temp, status);
     buffer_size += status;
     buffer[buffer_size] = 0;
   } /* while (42) */
   close (sd);
-  sd = -1;
 
   if (status < 0)
   {
     sfree (buffer);
   }
   else
@@ -729,31 +734,12 @@
   sfree (buffer);
   sfree (keys_list);
 
   return (0);
 } /* }}} int powerdns_read_recursor */
 
-static int powerdns_config_add_string (const char *name, /* {{{ */
-    char **dest,
-    oconfig_item_t *ci)
-{
-  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING))
-  {
-    WARNING ("powerdns plugin: `%s' needs exactly one string argument.",
-	name);
-    return (-1);
-  }
-
-  sfree (*dest);
-  *dest = strdup (ci->values[0].value.string);
-  if (*dest == NULL)
-    return (-1);
-
-  return (0);
-} /* }}} int powerdns_config_add_string */
-
 static int powerdns_config_add_collect (list_item_t *li, /* {{{ */
     oconfig_item_t *ci)
 {
   int i;
   char **temp;
 
@@ -858,13 +844,13 @@
   {
     oconfig_item_t *option = ci->children + i;
 
     if (strcasecmp ("Collect", option->key) == 0)
       status = powerdns_config_add_collect (item, option);
     else if (strcasecmp ("Socket", option->key) == 0)
-      status = powerdns_config_add_string ("Socket", &socket_temp, option);
+      status = cf_util_get_string (option, &socket_temp);
     else
     {
       ERROR ("powerdns plugin: Option `%s' not allowed here.", option->key);
       status = -1;
     }
 
@@ -898,18 +884,20 @@
 
     break;
   }
 
   if (status != 0)
   {
+    sfree (socket_temp);
     sfree (item);
     return (-1);
   }
 
   DEBUG ("powerdns plugin: Add server: instance = %s;", item->instance);
 
+  sfree (socket_temp);
   return (0);
 } /* }}} int powerdns_config_add_server */
 
 static int powerdns_config (oconfig_item_t *ci) /* {{{ */
 {
   int i;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/processes.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/processes.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/processes.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/processes.c	2016-01-22 17:51:17.709918685 +0800
@@ -277,12 +277,13 @@
 
 		status = regcomp (new->re, regexp, REG_EXTENDED | REG_NOSUB);
 		if (status != 0)
 		{
 			DEBUG ("ProcessMatch: compiling the regular expression \"%s\" failed.", regexp);
 			sfree(new->re);
+			sfree(new);
 			return;
 		}
 	}
 #else
 	if (regexp != NULL)
 	{
@@ -1014,13 +1015,13 @@
 		ps->num_proc = 1;
 	}
 
 	/* Leave the rest at zero if this is only a zombi */
 	if (ps->num_proc == 0)
 	{
-		DEBUG ("processes plugin: This is only a zombi: pid = %i; "
+		DEBUG ("processes plugin: This is only a zombie: pid = %i; "
 				"name = %s;", pid, ps->name);
 		return (0);
 	}
 
 	cpu_user_counter   = atoll (fields[11]);
 	cpu_system_counter = atoll (fields[12]);
@@ -1737,12 +1738,13 @@
 		if (status != 0)
 		{
 			DEBUG ("ps_read_process failed: %i", status);
 			continue;
 		}
 
+		memset (&pse, 0, sizeof (pse));
 		pse.id       = pid;
 		pse.age      = 0;
 
 		pse.num_proc   = ps.num_proc;
 		pse.num_lwp    = ps.num_lwp;
 		pse.vmem_size  = ps.vmem_size;
@@ -1909,24 +1911,24 @@
 			pse.io_rchar = -1;
 			pse.io_wchar = -1;
 			pse.io_syscr = -1;
 			pse.io_syscw = -1;
 
 			ps_list_add (procs[i].ki_comm, have_cmdline ? cmdline : NULL, &pse);
-		} /* if ((proc_ptr == NULL) || (proc_ptr->ki_pid != procs[i].ki_pid)) */
 
-		switch (procs[i].ki_stat)
-		{
-			case SSTOP: 	stopped++;	break;
-			case SSLEEP:	sleeping++;	break;
-			case SRUN:	running++;	break;
-			case SIDL:	idle++;		break;
-			case SWAIT:	wait++;		break;
-			case SLOCK:	blocked++;	break;
-			case SZOMB:	zombies++;	break;
-		}
+			switch (procs[i].ki_stat)
+			{
+				case SSTOP:	stopped++;	break;
+				case SSLEEP:	sleeping++;	break;
+				case SRUN:	running++;	break;
+				case SIDL:	idle++;		break;
+				case SWAIT:	wait++;		break;
+				case SLOCK:	blocked++;	break;
+				case SZOMB:	zombies++;	break;
+			}
+		} /* if ((proc_ptr == NULL) || (proc_ptr->ki_pid != procs[i].ki_pid)) */
 	}
 
 	kvm_close(kd);
 
 	ps_submit_state ("running",  running);
 	ps_submit_state ("sleeping", sleeping);
@@ -2011,12 +2013,13 @@
 						WARNING ("processes plugin: Command line did not fit into buffer.");
 					else
 						have_cmdline = 1;
 				}
 			} /* if (process has argument list) */
 
+			memset (&pse, 0, sizeof (pse));
 			pse.id       = procs[i].p_pid;
 			pse.age      = 0;
 
 			pse.num_proc = 1;
 			pse.num_lwp  = 1; /* XXX: accumulate p_tid values for a single p_pid ? */
 
@@ -2040,25 +2043,28 @@
 			/* no I/O data */
 			pse.io_rchar = -1;
 			pse.io_wchar = -1;
 			pse.io_syscr = -1;
 			pse.io_syscw = -1;
 
+			pse.cswitch_vol = -1;
+			pse.cswitch_invol = -1;
+
 			ps_list_add (procs[i].p_comm, have_cmdline ? cmdline : NULL, &pse);
-		} /* if ((proc_ptr == NULL) || (proc_ptr->p_pid != procs[i].p_pid)) */
 
-		switch (procs[i].p_stat)
-		{
-			case SSTOP: 	stopped++;	break;
-			case SSLEEP:	sleeping++;	break;
-			case SRUN:	running++;	break;
-			case SIDL:	idle++;		break;
-			case SONPROC:	onproc++;	break;
-			case SDEAD:	dead++;		break;
-			case SZOMB:	zombies++;	break;
-		}
+			switch (procs[i].p_stat)
+			{
+				case SSTOP:	stopped++;	break;
+				case SSLEEP:	sleeping++;	break;
+				case SRUN:	running++;	break;
+				case SIDL:	idle++;		break;
+				case SONPROC:	onproc++;	break;
+				case SDEAD:	dead++;		break;
+				case SZOMB:	zombies++;	break;
+			}
+		} /* if ((proc_ptr == NULL) || (proc_ptr->p_pid != procs[i].p_pid)) */
 	}
 
 	kvm_close(kd);
 
 	ps_submit_state ("running",  running);
 	ps_submit_state ("sleeping", sleeping);
@@ -2255,12 +2261,13 @@
 		if (status != 0)
 		{
 			DEBUG("ps_read_process failed: %i", status);
 			continue;
 		}
 
+		memset (&pse, 0, sizeof (pse));
 		pse.id = pid;
 		pse.age = 0;
 
 		pse.num_proc   = ps.num_proc;
 		pse.num_lwp    = ps.num_lwp;
 		pse.vmem_size  = ps.vmem_size;
@@ -2281,12 +2288,15 @@
 
 		pse.io_rchar = ps.io_rchar;
 		pse.io_wchar = ps.io_wchar;
 		pse.io_syscr = ps.io_syscr;
 		pse.io_syscw = ps.io_syscw;
 
+		pse.cswitch_vol = -1;
+		pse.cswitch_invol = -1;
+
 		switch (state)
 		{
 			case 'R': running++;  break;
 			case 'S': sleeping++; break;
 			case 'E': detached++; break;
 			case 'Z': zombies++;  break;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/python.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/python.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/python.c	2015-05-20 20:04:47.187035468 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/python.c	2016-01-22 17:51:17.709918685 +0800
@@ -299,35 +299,45 @@
 		PyErr_Clear();
 		Py_DECREF(type);
 		Py_XDECREF(value);
 		Py_XDECREF(traceback);
 		return;
 	}
-	list = PyObject_CallFunction(cpy_format_exception, "NNN", type, value, traceback); /* New reference. */
+	list = PyObject_CallFunction(cpy_format_exception, "NNN", type, value, traceback); /* New reference. Steals references from "type", "value" and "traceback". */
 	if (list)
 		l = PyObject_Length(list);
+
 	for (i = 0; i < l; ++i) {
-		char *s;
 		PyObject *line;
-		
+		char const *msg;
+		char *cpy;
+
 		line = PyList_GET_ITEM(list, i); /* Borrowed reference. */
 		Py_INCREF(line);
-		s = strdup(cpy_unicode_or_bytes_to_string(&line));
+
+		msg = cpy_unicode_or_bytes_to_string(&line);
 		Py_DECREF(line);
-		if (s[strlen(s) - 1] == '\n')
-			s[strlen(s) - 1] = 0;
+		if (msg == NULL)
+			continue;
+
+		cpy = strdup(msg);
+		if (cpy == NULL)
+			continue;
+
+		if (cpy[strlen(cpy) - 1] == '\n')
+			cpy[strlen(cpy) - 1] = 0;
+
 		Py_BEGIN_ALLOW_THREADS
-		ERROR("%s", s);
+		ERROR("%s", cpy);
 		Py_END_ALLOW_THREADS
-		free(s);
+
+		free(cpy);
 	}
+
 	Py_XDECREF(list);
 	PyErr_Clear();
-	Py_DECREF(type);
-	Py_XDECREF(value);
-	Py_XDECREF(traceback);
 }
 
 static int cpy_read_callback(user_data_t *data) {
 	cpy_callback_t *c = data->data;
 	PyObject *ret;
 
@@ -547,13 +557,18 @@
 		return NULL;
 	}
 	cpy_build_name(buf, sizeof(buf), callback, name);
 
 	Py_INCREF(callback);
 	Py_XINCREF(data);
+
 	c = malloc(sizeof(*c));
+	if (c == NULL)
+		return NULL;
+	memset (c, 0, sizeof (*c));
+
 	c->name = strdup(buf);
 	c->callback = callback;
 	c->data = data;
 	c->next = *list_head;
 	*list_head = c;
 	Py_XDECREF(mod);
@@ -618,13 +633,13 @@
 typedef int reg_function_t(const char *name, void *callback, void *data);
 
 static PyObject *cpy_register_generic_userdata(void *reg, void *handler, PyObject *args, PyObject *kwds) {
 	char buf[512];
 	reg_function_t *register_function = (reg_function_t *) reg;
 	cpy_callback_t *c = NULL;
-	user_data_t *user_data = NULL;
+	user_data_t user_data;
 	char *name = NULL;
 	PyObject *callback = NULL, *data = NULL;
 	static char *kwlist[] = {"callback", "data", "name", NULL};
 	
 	if (PyArg_ParseTupleAndKeywords(args, kwds, "O|Oet", kwlist, &callback, &data, NULL, &name) == 0) return NULL;
 	if (PyCallable_Check(callback) == 0) {
@@ -634,28 +649,35 @@
 	}
 	cpy_build_name(buf, sizeof(buf), callback, name);
 	PyMem_Free(name);
 	
 	Py_INCREF(callback);
 	Py_XINCREF(data);
+
 	c = malloc(sizeof(*c));
+	if (c == NULL)
+		return NULL;
+	memset (c, 0, sizeof (*c));
+
 	c->name = strdup(buf);
 	c->callback = callback;
 	c->data = data;
 	c->next = NULL;
-	user_data = malloc(sizeof(*user_data));
-	user_data->free_func = cpy_destroy_user_data;
-	user_data->data = c;
-	register_function(buf, handler, user_data);
+
+	memset (&user_data, 0, sizeof (user_data));
+	user_data.free_func = cpy_destroy_user_data;
+	user_data.data = c;
+
+	register_function(buf, handler, &user_data);
 	return cpy_string_to_unicode_or_bytes(buf);
 }
 
 static PyObject *cpy_register_read(PyObject *self, PyObject *args, PyObject *kwds) {
 	char buf[512];
 	cpy_callback_t *c = NULL;
-	user_data_t *user_data = NULL;
+	user_data_t user_data;
 	double interval = 0;
 	char *name = NULL;
 	PyObject *callback = NULL, *data = NULL;
 	struct timespec ts;
 	static char *kwlist[] = {"callback", "interval", "data", "name", NULL};
 	
@@ -667,24 +689,32 @@
 	}
 	cpy_build_name(buf, sizeof(buf), callback, name);
 	PyMem_Free(name);
 	
 	Py_INCREF(callback);
 	Py_XINCREF(data);
+
 	c = malloc(sizeof(*c));
+	if (c == NULL)
+		return NULL;
+	memset (c, 0, sizeof (*c));
+
 	c->name = strdup(buf);
 	c->callback = callback;
 	c->data = data;
 	c->next = NULL;
-	user_data = malloc(sizeof(*user_data));
-	user_data->free_func = cpy_destroy_user_data;
-	user_data->data = c;
+
+	memset (&user_data, 0, sizeof (user_data));
+	user_data.free_func = cpy_destroy_user_data;
+	user_data.data = c;
+
 	ts.tv_sec = interval;
 	ts.tv_nsec = (interval - ts.tv_sec) * 1000000000;
-	plugin_register_complex_read(/* group = */ NULL, buf,
-			cpy_read_callback, &ts, user_data);
+	plugin_register_complex_read(/* group = */ "python", buf,
+			cpy_read_callback, &ts, &user_data);
+
 	return cpy_string_to_unicode_or_bytes(buf);
 }
 
 static PyObject *cpy_register_log(PyObject *self, PyObject *args, PyObject *kwds) {
 	return cpy_register_generic_userdata((void *) plugin_register_log,
 			(void *) cpy_log_callback, args, kwds);
@@ -778,13 +808,13 @@
 		cpy_build_name(buf, sizeof(buf), arg, NULL);
 		name = buf;
 	}
 	for (tmp = *list_head; tmp; prev = tmp, tmp = tmp->next)
 		if (strcmp(name, tmp->name) == 0)
 			break;
-	
+
 	Py_DECREF(arg);
 	if (tmp == NULL) {
 		PyErr_Format(PyExc_RuntimeError, "Unable to unregister %s callback '%s'.", desc, name);
 		return NULL;
 	}
 	/* Yes, this is actually save. To call this function the caller has to
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/redis.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/redis.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/redis.c	2015-03-10 22:14:45.849114587 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/redis.c	2016-01-22 17:51:17.713918682 +0800
@@ -138,13 +138,13 @@
         goto err;
 
     /*
      * Default to a gauge type.
      */
     (void)strncpy(rq->type, "gauge", sizeof(rq->type));
-    (void)strncpy(rq->instance, rq->query, sizeof(rq->instance));
+    (void)sstrncpy(rq->instance, rq->query, sizeof(rq->instance));
     replace_special(rq->instance, sizeof(rq->instance));
 
     for (i = 0; i < ci->children_num; i++) {
         oconfig_item_t *option = ci->children + i;
 
         if (strcasecmp("Type", option->key) == 0) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/routeros.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/routeros.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/routeros.c	2015-03-10 22:14:45.849114587 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/routeros.c	2016-01-22 17:51:17.713918682 +0800
@@ -328,13 +328,13 @@
   int status;
   int i;
 
   router_data = malloc (sizeof (*router_data));
   if (router_data == NULL)
     return (-1);
-  memset (router_data, 0, sizeof (router_data));
+  memset (router_data, 0, sizeof (*router_data));
   router_data->connection = NULL;
   router_data->node = NULL;
   router_data->service = NULL;
   router_data->username = NULL;
   router_data->password = NULL;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/rrdtool.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/rrdtool.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/rrdtool.c	2015-05-22 18:04:36.951771009 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/rrdtool.c	2016-01-22 17:37:50.198392653 +0800
@@ -730,22 +730,26 @@
 	c_avl_get (cache, filename, (void *) &rc);
 
 	if (rc == NULL)
 	{
 		rc = malloc (sizeof (*rc));
 		if (rc == NULL)
+		{
+			pthread_mutex_unlock (&cache_lock);
 			return (-1);
+		}
 		rc->values_num = 0;
 		rc->values = NULL;
 		rc->first_value = 0;
 		rc->last_value = 0;
 		rc->random_variation = rrd_get_random_variation ();
 		rc->flags = FLAG_NONE;
 		new_rc = 1;
 	}
 
+	assert (value_time > 0); /* plugin_dispatch() ensures this. */
 	if (rc->last_value >= value_time)
 	{
 		pthread_mutex_unlock (&cache_lock);
 		DEBUG ("rrdtool plugin: (rc->last_value = %"PRIu64") "
 				">= (value_time = %"PRIu64")",
 				rc->last_value, value_time);
@@ -1001,29 +1005,42 @@
 			return (1);
 		}
 		cache_flush_timeout = tmp;
 	}
 	else if (strcasecmp ("DataDir", key) == 0)
 	{
-		if (datadir != NULL)
-			free (datadir);
-		datadir = strdup (value);
+		char *tmp;
+		size_t len;
+
+		tmp = strdup (value);
+		if (tmp == NULL)
+		{
+			ERROR ("rrdtool plugin: strdup failed.");
+			return (1);
+		}
+
+		len = strlen (tmp);
+		while ((len > 0) && (tmp[len - 1] == '/'))
+		{
+			len--;
+			tmp[len] = 0;
+		}
+
+		if (len == 0)
+		{
+			ERROR ("rrdtool plugin: Invalid \"DataDir\" option.");
+			sfree (tmp);
+			return (1);
+		}
+
 		if (datadir != NULL)
 		{
-			int len = strlen (datadir);
-			while ((len > 0) && (datadir[len - 1] == '/'))
-			{
-				len--;
-				datadir[len] = '\0';
-			}
-			if (len <= 0)
-			{
-				free (datadir);
-				datadir = NULL;
-			}
+			sfree (datadir);
 		}
+
+		datadir = tmp;
 	}
 	else if (strcasecmp ("StepSize", key) == 0)
 	{
 		unsigned long temp = strtoul (value, NULL, 0);
 		if (temp > 0)
 			rrdcreate_config.stepsize = temp;
@@ -1200,12 +1217,13 @@
 	/* Set the cache up */
 	pthread_mutex_lock (&cache_lock);
 
 	cache = c_avl_create ((int (*) (const void *, const void *)) strcmp);
 	if (cache == NULL)
 	{
+		pthread_mutex_unlock (&cache_lock);
 		ERROR ("rrdtool plugin: c_avl_create failed.");
 		return (-1);
 	}
 
 	cache_flush_last = cdtime ();
 	if (cache_timeout == 0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/sigrok.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/sigrok.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/sigrok.c	2015-03-10 22:14:45.849114587 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/sigrok.c	2016-01-22 17:51:17.713918682 +0800
@@ -357,16 +357,19 @@
 
 	if (sr_thread_running) {
 		ERROR("sigrok plugin: Thread already running.");
 		return -1;
 	}
 
-	if ((status = plugin_thread_create(&sr_thread, NULL, sigrok_read_thread,
-			NULL)) != 0) {
+	status = plugin_thread_create(&sr_thread, NULL, sigrok_read_thread,
+			NULL);
+	if (status != 0)
+	{
+		char errbuf[1024];
 		ERROR("sigrok plugin: Failed to create thread: %s.",
-				strerror(status));
+				sstrerror (errno, errbuf, sizeof (errbuf)));
 		return -1;
 	}
 	sr_thread_running = TRUE;
 
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/smart.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/smart.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/smart.c	2015-03-10 22:14:45.849114587 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/smart.c	2016-01-22 17:51:17.713918682 +0800
@@ -250,12 +250,13 @@
     path = udev_list_entry_get_name (dev_list_entry);
     dev = udev_device_new_from_syspath (handle_udev, path);
     devpath = udev_device_get_devnode (dev);
 
     /* Query status with libatasmart */
     smart_handle_disk (devpath);
+    udev_device_unref (dev);
   }
 
   udev_enumerate_unref (enumerate);
   udev_unref (handle_udev);
 
   return (0);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/snmp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/snmp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/snmp.c	2015-05-20 20:04:47.191035542 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/snmp.c	2016-01-22 17:51:17.713918682 +0800
@@ -399,13 +399,12 @@
   dd->scale = 1.0;
   dd->shift = 0.0;
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *option = ci->children + i;
-    status = 0;
 
     if (strcasecmp ("Type", option->key) == 0)
       status = cf_util_get_string(option, &dd->type);
     else if (strcasecmp ("Table", option->key) == 0)
       status = cf_util_get_boolean(option, &dd->is_table);
     else if (strcasecmp ("Instance", option->key) == 0)
@@ -654,13 +653,16 @@
   memset (hd, '\0', sizeof (host_definition_t));
   hd->version = 2;
   C_COMPLAIN_INIT (&hd->complaint);
 
   status = cf_util_get_string(ci, &hd->name);
   if (status != 0)
+  {
+    sfree (hd);
     return status;
+  }
 
   hd->sess_handle = NULL;
   hd->interval = 0;
 
   for (i = 0; i < ci->children_num; i++)
   {
@@ -926,14 +928,13 @@
 #endif
       || (vl->type == ASN_GAUGE))
   {
     tmp_unsigned = (uint32_t) *vl->val.integer;
     tmp_signed = (int32_t) *vl->val.integer;
 
-    if ((vl->type == ASN_INTEGER)
-        || (vl->type == ASN_GAUGE))
+    if (vl->type == ASN_INTEGER)
       prefer_signed = 1;
 
     DEBUG ("snmp plugin: Parsed int32 value is %"PRIu64".", tmp_unsigned);
   }
   else if (vl->type == ASN_COUNTER64)
   {
@@ -1233,22 +1234,23 @@
   if (!ds)
   {
     ERROR ("snmp plugin: DataSet `%s' not defined.", data->type);
     return (-1);
   }
   assert (ds->ds_num == data->values_len);
+  assert (data->values_len > 0);
 
   instance_list_ptr = instance_list;
 
-  value_table_ptr = malloc (sizeof (*value_table_ptr) * data->values_len);
+  value_table_ptr = calloc ((size_t) data->values_len, sizeof (*value_table_ptr));
   if (value_table_ptr == NULL)
     return (-1);
   for (i = 0; i < data->values_len; i++)
     value_table_ptr[i] = value_table[i];
 
-  vl.values_len = ds->ds_num;
+  vl.values_len = data->values_len;
   vl.values = malloc (sizeof (*vl.values) * vl.values_len);
   if (vl.values == NULL)
   {
     ERROR ("snmp plugin: malloc failed.");
     sfree (value_table_ptr);
     return (-1);
@@ -1374,13 +1376,13 @@
   return (0);
 } /* int csnmp_dispatch_table */
 
 static int csnmp_read_table (host_definition_t *host, data_definition_t *data)
 {
   struct snmp_pdu *req;
-  struct snmp_pdu *res;
+  struct snmp_pdu *res = NULL;
   struct variable_list *vb;
 
   const data_set_t *ds;
 
   uint32_t oid_list_len = (uint32_t) (data->values_len + 1);
   /* Holds the last OID returned by the device. We use this in the GETNEXT
@@ -1421,12 +1423,13 @@
   if (ds->ds_num != data->values_len)
   {
     ERROR ("snmp plugin: DataSet `%s' requires %i values, but config talks about %i",
         data->type, ds->ds_num, data->values_len);
     return (-1);
   }
+  assert (data->values_len > 0);
 
   /* We need a copy of all the OIDs, because GETNEXT will destroy them. */
   memcpy (oid_list, data->values, data->values_len * sizeof (oid_t));
   if (data->instance.oid.oid_len > 0)
     memcpy (oid_list + data->values_len, &data->instance.oid, sizeof (oid_t));
   else /* no InstanceFrom option specified. */
@@ -1520,13 +1523,13 @@
       break;
     }
 
     for (vb = res->variables, i = 0; (vb != NULL); vb = vb->next_variable, i++)
     {
       /* Calculate value index from todo list */
-      while (!oid_list_todo[i] && (i < oid_list_len))
+      while ((i < oid_list_len) && !oid_list_todo[i])
         i++;
 
       /* An instance is configured and the res variable we process is the
        * instance value (last index) */
       if ((data->instance.oid.oid_len > 0) && (i == data->values_len))
       {
@@ -1667,13 +1670,13 @@
 
   DEBUG ("snmp plugin: csnmp_read_value (host = %s, data = %s)",
       host->name, data->name);
 
   if (host->sess_handle == NULL)
   {
-    DEBUG ("snmp plugin: csnmp_read_table: host->sess_handle == NULL");
+    DEBUG ("snmp plugin: csnmp_read_value: host->sess_handle == NULL");
     return (-1);
   }
 
   ds = plugin_get_ds (data->type);
   if (!ds)
   {
@@ -1731,12 +1734,13 @@
 
     if (res != NULL)
       snmp_free_pdu (res);
     res = NULL;
 
     sfree (errstr);
+    sfree (vl.values);
     csnmp_host_close_session (host);
 
     return (-1);
   }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/statsd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/statsd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/statsd.c	2015-03-10 22:14:45.849114587 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/statsd.c	2016-01-22 17:51:17.713918682 +0800
@@ -192,12 +192,41 @@
 
   pthread_mutex_unlock (&metrics_lock);
 
   return (0);
 } /* }}} int statsd_metric_add */
 
+static void statsd_metric_free (statsd_metric_t *metric) /* {{{ */
+{
+  if (metric == NULL)
+    return;
+
+  if (metric->latency != NULL)
+  {
+    latency_counter_destroy (metric->latency);
+    metric->latency = NULL;
+  }
+
+  if (metric->set != NULL)
+  {
+    void *key;
+    void *value;
+
+    while (c_avl_pick (metric->set, &key, &value) == 0)
+    {
+      sfree (key);
+      assert (value == NULL);
+    }
+
+    c_avl_destroy (metric->set);
+    metric->set = NULL;
+  }
+
+  sfree (metric);
+} /* }}} void statsd_metric_free */
+
 static int statsd_parse_value (char const *str, value_t *ret_value) /* {{{ */
 {
   char *endptr = NULL;
 
   ret_value->gauge = (gauge_t) strtod (str, &endptr);
   if ((str == endptr) || ((endptr != NULL) && (*endptr != 0)))
@@ -530,12 +559,13 @@
     }
 
     tmp = realloc (fds, sizeof (*fds) * (fds_num + 1));
     if (tmp == NULL)
     {
       ERROR ("statsd plugin: realloc failed.");
+      close (fd);
       continue;
     }
     fds = tmp;
     tmp = fds + fds_num;
     fds_num++;
 
@@ -750,55 +780,58 @@
 
   if (metric->type == STATSD_GAUGE)
     values[0].gauge = (gauge_t) metric->value;
   else if (metric->type == STATSD_TIMER)
   {
     size_t i;
+    _Bool have_events = (metric->updates_num > 0);
 
-    if (metric->updates_num == 0)
-      return (0);
-
+    /* Make sure all timer metrics share the *same* timestamp. */
     vl.time = cdtime ();
 
     ssnprintf (vl.type_instance, sizeof (vl.type_instance),
         "%s-average", name);
-    values[0].gauge = CDTIME_T_TO_DOUBLE (
-        latency_counter_get_average (metric->latency));
+    values[0].gauge = have_events
+      ? CDTIME_T_TO_DOUBLE (latency_counter_get_average (metric->latency))
+      : NAN;
     plugin_dispatch_values (&vl);
 
     if (conf_timer_lower) {
       ssnprintf (vl.type_instance, sizeof (vl.type_instance),
           "%s-lower", name);
-      values[0].gauge = CDTIME_T_TO_DOUBLE (
-          latency_counter_get_min (metric->latency));
+      values[0].gauge = have_events
+        ? CDTIME_T_TO_DOUBLE (latency_counter_get_min (metric->latency))
+        : NAN;
       plugin_dispatch_values (&vl);
     }
 
     if (conf_timer_upper) {
       ssnprintf (vl.type_instance, sizeof (vl.type_instance),
           "%s-upper", name);
-      values[0].gauge = CDTIME_T_TO_DOUBLE (
-          latency_counter_get_max (metric->latency));
+      values[0].gauge = have_events
+        ? CDTIME_T_TO_DOUBLE (latency_counter_get_max (metric->latency))
+        : NAN;
       plugin_dispatch_values (&vl);
     }
 
     if (conf_timer_sum) {
       ssnprintf (vl.type_instance, sizeof (vl.type_instance),
           "%s-sum", name);
-      values[0].gauge = CDTIME_T_TO_DOUBLE (
-          latency_counter_get_sum (metric->latency));
+      values[0].gauge = have_events
+        ? CDTIME_T_TO_DOUBLE (latency_counter_get_sum (metric->latency))
+        : NAN;
       plugin_dispatch_values (&vl);
     }
 
     for (i = 0; i < conf_timer_percentile_num; i++)
     {
       ssnprintf (vl.type_instance, sizeof (vl.type_instance),
           "%s-percentile-%.0f", name, conf_timer_percentile[i]);
-      values[0].gauge = CDTIME_T_TO_DOUBLE (
-          latency_counter_get_percentile (
-            metric->latency, conf_timer_percentile[i]));
+      values[0].gauge = have_events
+        ? CDTIME_T_TO_DOUBLE (latency_counter_get_percentile (metric->latency, conf_timer_percentile[i]))
+        : NAN;
       plugin_dispatch_values (&vl);
     }
 
     /* Keep this at the end, since vl.type is set to "gauge" here. The
      * vl.type's above are implicitly set to "latency". */
     if (conf_timer_count) {
@@ -816,14 +849,25 @@
   {
     if (metric->set == NULL)
       values[0].gauge = 0.0;
     else
       values[0].gauge = (gauge_t) c_avl_size (metric->set);
   }
-  else
-    values[0].derive = (derive_t) metric->value;
+  else { /* STATSD_COUNTER */
+      /*
+       * Expand a single value to two metrics:
+       *
+       * - The absolute counter, as a gauge
+       * - A derived rate for this counter
+       */
+      values[0].derive = (derive_t) metric->value;
+      plugin_dispatch_values(&vl);
+
+      sstrncpy(vl.type, "gauge", sizeof (vl.type));
+      values[0].gauge = (gauge_t) metric->value;
+  }
 
   return (plugin_dispatch_values (&vl));
 } /* }}} int statsd_metric_submit_unsafe */
 
 static int statsd_read (void) /* {{{ */
 {
@@ -879,13 +923,13 @@
       ERROR ("stats plugin: c_avl_remove (\"%s\") failed with status %i.",
           to_be_deleted[i], status);
       continue;
     }
 
     sfree (name);
-    sfree (metric);
+    statsd_metric_free (metric);
   }
 
   pthread_mutex_unlock (&metrics_lock);
 
   strarray_free (to_be_deleted, to_be_deleted_num);
 
@@ -907,13 +951,13 @@
   }
   network_thread_running = 0;
 
   while (c_avl_pick (metrics_tree, &key, &value) == 0)
   {
     sfree (key);
-    sfree (value);
+    statsd_metric_free (value);
   }
   c_avl_destroy (metrics_tree);
   metrics_tree = NULL;
 
   sfree (conf_node);
   sfree (conf_service);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/swap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/swap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/swap.c	2015-05-20 20:04:47.191035542 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/swap.c	2016-01-22 17:51:17.713918682 +0800
@@ -278,13 +278,14 @@
 		if ((endptr == fields[3]) || (errno != 0))
 			continue;
 
 		if (total < used)
 			continue;
 
-		swap_submit_usage (path, used, total - used, NULL, NAN);
+		swap_submit_usage (path, used * 1024.0, (total - used) * 1024.0,
+				NULL, NAN);
 	}
 
 	fclose (fh);
 
 	return (0);
 } /* }}} int swap_read_separate */
@@ -337,14 +338,15 @@
 		swap_used = swap_total - (swap_free + swap_cached);
 	assert (!isnan (swap_used));
 
 	if (swap_used < 0.0)
 		return (EINVAL);
 
-	swap_submit_usage (NULL, swap_used, swap_free,
-			isnan (swap_cached) ? NULL : "cached", swap_cached);
+	swap_submit_usage (NULL, swap_used * 1024.0, swap_free * 1024.0,
+			isnan (swap_cached) ? NULL : "cached",
+			isnan (swap_cached) ? NAN : swap_cached * 1024.0);
 	return (0);
 } /* }}} int swap_read_combined */
 
 static int swap_read_io (void) /* {{{ */
 {
 	FILE *fh;
@@ -516,26 +518,26 @@
                 return (-1);
         }
         else if (swap_num == 0)
                 return (0);
 
 	/* Allocate and initialize the swaptbl_t structure */
-        s = (swaptbl_t *) smalloc (swap_num * sizeof (swapent_t) + sizeof (struct swaptable));
+        s = malloc (swap_num * sizeof (swapent_t) + sizeof (struct swaptable));
         if (s == NULL)
         {
-                ERROR ("swap plugin: smalloc failed.");
+                ERROR ("swap plugin: malloc failed.");
                 return (-1);
         }
 
 	/* Memory to store the path names. We only use these paths when the
 	 * separate option has been configured, but it's easier to just
 	 * allocate enough memory in any case. */
 	s_paths = calloc (swap_num, PATH_MAX);
 	if (s_paths == NULL)
 	{
-		ERROR ("swap plugin: malloc failed.");
+		ERROR ("swap plugin: calloc failed.");
 		sfree (s);
 		return (-1);
 	}
         for (i = 0; i < swap_num; i++)
 		s->swt_ent[i].ste_path = s_paths + (i * PATH_MAX);
         s->swt_n = swap_num;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/table.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/table.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/table.c	2015-03-10 22:14:45.849114587 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/table.c	2016-01-22 17:51:17.713918682 +0800
@@ -185,13 +185,13 @@
 		log_err ("<Result> does not expect any arguments.");
 		return 1;
 	}
 
 	res = (tbl_result_t *)realloc (tbl->results,
 			(tbl->results_num + 1) * sizeof (*tbl->results));
-	if (NULL == tbl) {
+	if (res == NULL) {
 		char errbuf[1024];
 		log_err ("realloc failed: %s.",
 				sstrerror (errno, errbuf, sizeof (errbuf)));
 		return -1;
 	}
 
@@ -280,14 +280,15 @@
 					"in <Table %s>.", c->key, tbl->file);
 	}
 
 	if (NULL == tbl->sep) {
 		log_err ("Table \"%s\" does not specify any separator.", tbl->file);
 		status = 1;
+	} else {
+		strunescape (tbl->sep, strlen (tbl->sep) + 1);
 	}
-	strunescape (tbl->sep, strlen (tbl->sep) + 1);
 
 	if (NULL == tbl->instance) {
 		tbl->instance = sstrdup (tbl->file);
 		replace_special (tbl->instance, strlen (tbl->instance));
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/tail.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/tail.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/tail.c	2015-03-10 22:14:45.849114587 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/tail.c	2016-01-22 17:51:17.713918682 +0800
@@ -221,13 +221,12 @@
 static int ctail_config_add_file (oconfig_item_t *ci)
 {
   cu_tail_match_t *tm;
   cdtime_t interval = 0;
   char *plugin_instance = NULL;
   int num_matches = 0;
-  int status;
   int i;
 
   if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_STRING))
   {
     WARNING ("tail plugin: `File' needs exactly one string argument.");
     return (-1);
@@ -238,16 +237,16 @@
   {
     ERROR ("tail plugin: tail_match_create (%s) failed.",
 	ci->values[0].value.string);
     return (-1);
   }
 
-  status = 0;
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *option = ci->children + i;
+    int status = 0;
 
     if (strcasecmp ("Instance", option->key) == 0)
       status = cf_util_get_string (option, &plugin_instance);
     else if (strcasecmp ("Interval", option->key) == 0)
       cf_util_get_cdtime (option, &interval);
     else if (strcasecmp ("Match", option->key) == 0)
@@ -264,12 +263,14 @@
     }
 
     if (status != 0)
       break;
   } /* for (i = 0; i < ci->children_num; i++) */
 
+  sfree (plugin_instance);
+
   if (num_matches == 0)
   {
     ERROR ("tail plugin: No (valid) matches found for file `%s'.",
 	ci->values[0].value.string);
     tail_match_destroy (tm);
     return (-1);
@@ -339,12 +340,14 @@
   if (tail_match_list_num == 0)
   {
     WARNING ("tail plugin: File list is empty. Returning an error.");
     return (-1);
   }
 
+  memset(&ud, '\0', sizeof(ud));
+
   for (i = 0; i < tail_match_list_num; i++)
   {
     ud.data = (void *)tail_match_list[i];
     ssnprintf(str, sizeof(str), "tail-%zu", i);
     CDTIME_T_TO_TIMESPEC (tail_match_list_intervals[i], &cb_interval);
     plugin_register_complex_read (NULL, str, ctail_read, &cb_interval, &ud);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/tail_csv.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/tail_csv.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/tail_csv.c	2014-08-18 15:33:14.300460874 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/tail_csv.c	2016-01-22 17:37:50.202392651 +0800
@@ -103,13 +103,16 @@
     cdtime_t t;
     int status;
 
     if (md->data_source_type == -1)
         return (EINVAL);
 
-    if ((md->value_from >= fields_num) || (id->time_from >= fields_num))
+    if (md->value_from >= fields_num)
+        return (EINVAL);
+
+    if (id->time_from >= 0 && (id->time_from >= fields_num))
         return (EINVAL);
 
     t = 0;
     if (id->time_from >= 0)
         t = parse_time (fields[id->time_from]);
 
@@ -306,13 +309,12 @@
         sfree (md);
         return (-1);
     }
 
     for (i = 0; i < ci->children_num; ++i){
         oconfig_item_t *option = ci->children + i;
-        status = 0;
 
         if (strcasecmp("Type", option->key) == 0)
             status = cf_util_get_string(option, &md->type);
         else if (strcasecmp("Instance", option->key) == 0)
             status = cf_util_get_string(option, &md->instance);
         else if (strcasecmp("ValueFrom", option->key) == 0)
@@ -371,43 +373,48 @@
     sfree(id->instance);
     sfree(id->path);
     sfree(id->metric_list);
     sfree(id);
 }
 
-static int tcsv_config_add_instance_collect(instance_definition_t *id, oconfig_item_t *ci){
+static int tcsv_config_add_instance_collect(instance_definition_t *id, oconfig_item_t *ci) {
     metric_definition_t *metric;
+    metric_definition_t **metric_list;
+    size_t metric_list_size;
     int i;
 
-    if (ci->values_num < 1){
+    if (ci->values_num < 1) {
         WARNING("tail_csv plugin: The `Collect' config option needs at least one argument.");
         return (-1);
     }
 
-    /* Verify string arguments */
-    for (i = 0; i < ci->values_num; ++i)
-        if (ci->values[i].type != OCONFIG_TYPE_STRING){
+    metric_list_size = id->metric_list_len + (size_t) ci->values_num;
+    metric_list = realloc (id->metric_list, sizeof (*id->metric_list) * metric_list_size);
+    if (metric_list == NULL)
+        return (-1);
+    id->metric_list = metric_list;
+
+    for (i = 0; i < ci->values_num; i++) {
+        char *metric_name;
+
+        if (ci->values[i].type != OCONFIG_TYPE_STRING) {
             WARNING("tail_csv plugin: All arguments to `Collect' must be strings.");
-            return (-1);
+            continue;
         }
+        metric_name = ci->values[i].value.string;
 
-    id->metric_list = (metric_definition_t **)malloc(sizeof(metric_definition_t *) * ci->values_num);
-    if (id->metric_list == NULL)
-        return (-1);
-
-    for (i = 0; i < ci->values_num; ++i){
         for (metric = metric_head; metric != NULL; metric = metric->next)
-            if (strcasecmp(ci->values[i].value.string, metric->name) == 0)
+            if (strcasecmp(metric_name, metric->name) == 0)
                 break;
 
-        if (metric == NULL){
-            WARNING("tail_csv plugin: `Collect' argument not found `%s'.", ci->values[i].value.string);
-            return (-1);
+        if (metric == NULL) {
+            WARNING ("tail_csv plugin: `Collect' argument not found `%s'.", metric_name);
+            continue;
         }
 
-        id->metric_list[i] = metric;
+        id->metric_list[id->metric_list_len] = metric;
         id->metric_list_len++;
     }
 
     return (0);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/target_notification.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/target_notification.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/target_notification.c	2015-05-22 18:04:36.951771009 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/target_notification.c	2016-01-22 17:51:17.713918682 +0800
@@ -178,13 +178,13 @@
 
     break;
   }
 
   if (status != 0)
   {
-    tn_destroy ((void *) data);
+    tn_destroy ((void *) &data);
     return (status);
   }
 
   *user_data = data;
   return (0);
 } /* }}} int tn_create */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/tcpconns.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/tcpconns.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/tcpconns.c	2015-05-20 20:04:47.191035542 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/tcpconns.c	2016-01-22 17:51:17.713918682 +0800
@@ -439,12 +439,13 @@
     }
 
     memset (pe->count_local, '\0', sizeof (pe->count_local));
     memset (pe->count_remote, '\0', sizeof (pe->count_remote));
     pe->flags &= ~PORT_IS_LISTENING;
 
+    prev = pe;
     pe = pe->next;
   }
 } /* void conn_reset_port_entry */
 
 static int conn_handle_ports (uint16_t port_local, uint16_t port_remote, uint8_t state)
 {
@@ -978,13 +979,15 @@
   next = (struct inpcb *)CIRCLEQ_FIRST (&table.inpt_queue);
 
   while (next != head)
 #endif
   {
     /* Read the pcb pointed to by `next' into `inpcb' */
-    kread ((u_long) next, &inpcb, sizeof (inpcb));
+    status = kread ((u_long) next, &inpcb, sizeof (inpcb));
+    if (status != 0)
+      return (-1);
 
     /* Advance `next' */
 #if defined(__OpenBSD__) || (defined(__NetBSD_Version__) && __NetBSD_Version__ > 699002700)
     /* inpt_queue is a TAILQ on OpenBSD */
     next = (struct inpcb *)TAILQ_NEXT (&inpcb, inp_queue);
 #else
@@ -1001,13 +1004,15 @@
       continue;
     if ((inpcb.inp_flags & INP_IPV6)
 	&& IN6_IS_ADDR_UNSPECIFIED (&inpcb.inp_laddr6))
       continue;
 #endif
 
-    kread ((u_long) inpcb.inp_ppcb, &tcpcb, sizeof (tcpcb));
+    status = kread ((u_long) inpcb.inp_ppcb, &tcpcb, sizeof (tcpcb));
+    if (status != 0)
+      return (-1);
     conn_handle_ports (ntohs(inpcb.inp_lport), ntohs(inpcb.inp_fport), tcpcb.t_state);
   } /* while (next != head) */
 
   conn_submit_all ();
 
   return (0);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/teamspeak2.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/teamspeak2.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/teamspeak2.c	2015-03-10 22:14:45.853114674 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/teamspeak2.c	2016-01-22 17:51:17.713918682 +0800
@@ -255,12 +255,13 @@
 		if (status != 0)
 		{
 			char errbuf[1024];
 			WARNING ("teamspeak2 plugin: connect failed: %s",
 					sstrerror (errno, errbuf, sizeof (errbuf)));
 			close (sd);
+			sd = -1;
 			continue;
 		}
 
 		/*
 		 * Success, we can break. Don't need more than one connection
 		 */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ted.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ted.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/ted.c	2014-08-18 15:33:14.304460953 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/ted.c	2016-01-22 17:37:50.202392651 +0800
@@ -101,13 +101,12 @@
         ERROR ("ted plugin: swrite failed.");
         return (-1);
     }
 
     /* Loop until we find the end of the package */
     end_flag = 0;
-    escape_flag = 0;
     package_buffer_pos = 0;
     while (end_flag == 0)
     {
         ssize_t receive_buffer_length;
         ssize_t i;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/threshold.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/threshold.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/threshold.c	2015-03-10 22:14:45.853114674 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/threshold.c	2016-01-22 17:51:17.713918682 +0800
@@ -248,13 +248,12 @@
   th.hysteresis = 0;
   th.flags = UT_FLAG_INTERESTING; /* interesting by default */
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *option = ci->children + i;
-    status = 0;
 
     if (strcasecmp ("Instance", option->key) == 0)
       status = ut_config_type_instance (&th, option);
     else if (strcasecmp ("DataSource", option->key) == 0)
       status = ut_config_type_datasource (&th, option);
     else if ((strcasecmp ("WarningMax", option->key) == 0)
@@ -336,13 +335,12 @@
   memcpy (&th, th_orig, sizeof (th));
   sstrncpy (th.plugin, ci->values[0].value.string, sizeof (th.plugin));
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *option = ci->children + i;
-    status = 0;
 
     if (strcasecmp ("Type", option->key) == 0)
       status = ut_config_type (&th, option);
     else if (strcasecmp ("Instance", option->key) == 0)
       status = ut_config_plugin_instance (&th, option);
     else
@@ -383,13 +381,12 @@
   memcpy (&th, th_orig, sizeof (th));
   sstrncpy (th.host, ci->values[0].value.string, sizeof (th.host));
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *option = ci->children + i;
-    status = 0;
 
     if (strcasecmp ("Type", option->key) == 0)
       status = ut_config_type (&th, option);
     else if (strcasecmp ("Plugin", option->key) == 0)
       status = ut_config_plugin (&th, option);
     else
@@ -512,21 +509,18 @@
   plugin_notification_meta_add_double (&n, "FailureMax", th->failure_max);
 
   /* Send an okay notification */
   if (state == STATE_OKAY)
   {
     if (state_old == STATE_MISSING)
-      status = ssnprintf (buf, bufsize,
-          ": Value is no longer missing.");
+      ssnprintf (buf, bufsize, ": Value is no longer missing.");
     else
-      status = ssnprintf (buf, bufsize,
+      ssnprintf (buf, bufsize,
           ": All data sources are within range again. "
           "Current value of \"%s\" is %f.",
           ds->ds[ds_index].name, values[ds_index]);
-    buf += status;
-    bufsize -= status;
   }
   else
   {
     double min;
     double max;
 
@@ -534,22 +528,22 @@
     max = (state == STATE_ERROR) ? th->failure_max : th->warning_max;
 
     if (th->flags & UT_FLAG_INVERT)
     {
       if (!isnan (min) && !isnan (max))
       {
-        status = ssnprintf (buf, bufsize, ": Data source \"%s\" is currently "
+        ssnprintf (buf, bufsize, ": Data source \"%s\" is currently "
             "%f. That is within the %s region of %f%s and %f%s.",
             ds->ds[ds_index].name, values[ds_index],
             (state == STATE_ERROR) ? "failure" : "warning",
             min, ((th->flags & UT_FLAG_PERCENTAGE) != 0) ? "%" : "",
             max, ((th->flags & UT_FLAG_PERCENTAGE) != 0) ? "%" : "");
       }
       else
       {
-	status = ssnprintf (buf, bufsize, ": Data source \"%s\" is currently "
+        ssnprintf (buf, bufsize, ": Data source \"%s\" is currently "
 	    "%f. That is %s the %s threshold of %f%s.",
 	    ds->ds[ds_index].name, values[ds_index],
 	    isnan (min) ? "below" : "above",
 	    (state == STATE_ERROR) ? "failure" : "warning",
 	    isnan (min) ? max : min,
 	    ((th->flags & UT_FLAG_PERCENTAGE) != 0) ? "%" : "");
@@ -572,30 +566,28 @@
 
       if (sum == 0.0)
         value = NAN;
       else
         value = 100.0 * values[ds_index] / sum;
 
-      status = ssnprintf (buf, bufsize, ": Data source \"%s\" is currently "
+      ssnprintf (buf, bufsize, ": Data source \"%s\" is currently "
           "%g (%.2f%%). That is %s the %s threshold of %.2f%%.",
           ds->ds[ds_index].name, values[ds_index], value,
           (value < min) ? "below" : "above",
           (state == STATE_ERROR) ? "failure" : "warning",
           (value < min) ? min : max);
     }
     else /* is not inverted */
     {
-      status = ssnprintf (buf, bufsize, ": Data source \"%s\" is currently "
+      ssnprintf (buf, bufsize, ": Data source \"%s\" is currently "
 	  "%f. That is %s the %s threshold of %f.",
 	  ds->ds[ds_index].name, values[ds_index],
 	  (values[ds_index] < min) ? "below" : "above",
 	  (state == STATE_ERROR) ? "failure" : "warning",
 	  (values[ds_index] < min) ? min : max);
     }
-    buf += status;
-    bufsize -= status;
   }
 
   plugin_dispatch_notification (&n);
 
   plugin_notification_meta_free (n.meta);
   return (0);
@@ -877,12 +869,13 @@
 } /* }}} int ut_missing */
 
 int ut_config (oconfig_item_t *ci)
 { /* {{{ */
   int i;
   int status = 0;
+  int old_size = c_avl_size (threshold_tree);
 
   threshold_t th;
 
   if (threshold_tree == NULL)
   {
     threshold_tree = c_avl_create ((void *) strcmp);
@@ -903,13 +896,12 @@
   th.hysteresis = 0;
   th.flags = UT_FLAG_INTERESTING; /* interesting by default */
 
   for (i = 0; i < ci->children_num; i++)
   {
     oconfig_item_t *option = ci->children + i;
-    status = 0;
 
     if (strcasecmp ("Type", option->key) == 0)
       status = ut_config_type (&th, option);
     else if (strcasecmp ("Plugin", option->key) == 0)
       status = ut_config_plugin (&th, option);
     else if (strcasecmp ("Host", option->key) == 0)
@@ -921,13 +913,15 @@
     }
 
     if (status != 0)
       break;
   }
 
-  if (c_avl_size (threshold_tree) > 0) {
+  /* register callbacks if this is the first time we see a valid config */
+  if ((old_size == 0) && (c_avl_size (threshold_tree) > 0))
+  {
     plugin_register_missing ("threshold", ut_missing,
         /* user data = */ NULL);
     plugin_register_write ("threshold", ut_check_threshold,
         /* user data = */ NULL);
   }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/turbostat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/turbostat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/turbostat.c	2015-05-20 20:05:42.672060002 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/turbostat.c	2016-01-22 17:51:17.713918682 +0800
@@ -1034,12 +1034,13 @@
 	if (!filep) {
 		ERROR("turbostat plugin: Failed to open '%s'", path);
 		return -1;
 	}
 	if (fscanf(filep, "%d", &value) != 1) {
 		ERROR("turbostat plugin: Failed to parse number from '%s'", path);
+		fclose(filep);
 		return -1;
 	}
 	fclose(filep);
 	return value;
 }
 
@@ -1250,38 +1251,51 @@
 static int
 allocate_counters(struct thread_data **threads, struct core_data **cores, struct pkg_data **packages)
 {
 	unsigned int i;
 	unsigned int total_threads, total_cores;
 
+	if ((topology.num_threads == 0)
+	    || (topology.num_cores == 0)
+	    || (topology.num_packages == 0))
+	{
+		ERROR ("turbostat plugin: Invalid topology: %u threads, %u cores, %u packages",
+		       topology.num_threads, topology.num_cores, topology.num_packages);
+		return -1;
+	}
+
 	total_threads = topology.num_threads * topology.num_cores * topology.num_packages;
 	*threads = calloc(total_threads, sizeof(struct thread_data));
 	if (*threads == NULL)
-		goto err;
+	{
+		ERROR ("turbostat plugin: calloc failed");
+		return -1;
+	}
 
 	for (i = 0; i < total_threads; ++i)
 		(*threads)[i].cpu_id = topology.max_cpu_id + 1;
 
 	total_cores = topology.num_cores * topology.num_packages;
 	*cores = calloc(total_cores, sizeof(struct core_data));
 	if (*cores == NULL)
-		goto err_clean_threads;
+	{
+		ERROR ("turbostat plugin: calloc failed");
+		sfree (threads);
+		return -1;
+	}
 
 	*packages = calloc(topology.num_packages, sizeof(struct pkg_data));
 	if (*packages == NULL)
-		goto err_clean_cores;
+	{
+		ERROR ("turbostat plugin: calloc failed");
+		sfree (cores);
+		sfree (threads);
+		return -1;
+	}
 
 	return 0;
-
-err_clean_cores:
-	free(*cores);
-err_clean_threads:
-	free(*threads);
-err:
-	ERROR("turbostat plugin: Failled to allocate memory for counters");
-	return -1;
 }
 
 static void
 init_counter(struct thread_data *thread_base, struct core_data *core_base,
 	struct pkg_data *pkg_base, unsigned int cpu_id)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/types.db /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/types.db
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/types.db	2015-05-20 20:05:42.672060002 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/types.db	2016-01-22 17:51:17.717918678 +0800
@@ -12,12 +12,13 @@
 bytes			value:GAUGE:0:U
 cache_eviction		value:DERIVE:0:U
 cache_operation		value:DERIVE:0:U
 cache_ratio		value:GAUGE:0:100
 cache_result		value:DERIVE:0:U
 cache_size		value:GAUGE:0:U
+capacity	value:GAUGE:0:U
 ceph_bytes		value:GAUGE:U:U
 ceph_latency	value:GAUGE:U:U
 ceph_rate			value:DERIVE:0:U
 changes_since_last_save   value:GAUGE:0:U
 charge			value:GAUGE:0:U
 compression_ratio	value:GAUGE:0:2
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/types.db.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/types.db.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/types.db.5	2015-03-10 22:29:57.988978069 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/types.db.5	2016-01-22 17:56:34.637658523 +0800
@@ -130,13 +130,13 @@
 .    ds Ae AE
 .\}
 .rm #[ #] #H #V #F C
 .\" ========================================================================
 .\"
 .IX Title "TYPES.DB 5"
-.TH TYPES.DB 5 "2015-03-10" "5.4.1.805.g42e4d6c" "collectd"
+.TH TYPES.DB 5 "2016-01-22" "5.5.1" "collectd"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
 .nh
 .SH "NAME"
 types.db \- Data\-set specifications for the system statistics collection daemon
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/unixsock.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/unixsock.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/unixsock.c	2015-03-10 22:14:45.853114674 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/unixsock.c	2016-01-22 17:51:17.717918678 +0800
@@ -125,13 +125,22 @@
 		ERROR ("unixsock plugin: bind failed: %s", errbuf);
 		close (sock_fd);
 		sock_fd = -1;
 		return (-1);
 	}
 
-	chmod (sa.sun_path, sock_perms);
+	status = chmod (sa.sun_path, sock_perms);
+	if (status == -1)
+	{
+		char errbuf[1024];
+		ERROR ("unixsock plugin: chmod failed: %s",
+				sstrerror (errno, errbuf, sizeof (errbuf)));
+		close (sock_fd);
+		sock_fd = -1;
+		return (-1);
+	}
 
 	status = listen (sock_fd, 8);
 	if (status != 0)
 	{
 		char errbuf[1024];
 		ERROR ("unixsock plugin: listen failed: %s",
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/users.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/users.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/users.c	2015-03-10 22:14:45.853114674 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/users.c	2016-01-22 17:51:17.717918678 +0800
@@ -37,15 +37,12 @@
 # include <utmpx.h>
 /* #endif HAVE_UTMPX_H */
 
 #elif HAVE_UTMP_H
 # include <utmp.h>
 /* #endif HAVE_UTMP_H */
-
-#else
-# error "No applicable input method."
 #endif
 
 static void users_submit (gauge_t value)
 {
 	value_t values[1];
 	value_list_t vl = VALUE_LIST_INIT;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_cmd_flush.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_cmd_flush.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_cmd_flush.c	2015-03-10 22:14:45.853114674 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_cmd_flush.c	2016-01-22 17:51:17.717918678 +0800
@@ -28,60 +28,47 @@
 
 #include "collectd.h"
 #include "common.h"
 #include "plugin.h"
 #include "utils_parse_option.h"
 
-#define print_to_socket(fh, ...) \
-	do { \
-		if (fprintf (fh, __VA_ARGS__) < 0) { \
-			char errbuf[1024]; \
-			WARNING ("handle_flush: failed to write to socket #%i: %s", \
-					fileno (fh), sstrerror (errno, errbuf, sizeof (errbuf))); \
-			return -1; \
-		} \
-		fflush(fh); \
-	} while (0)
-
-static int add_to_array (char ***array, int *array_num, char *value)
-{
-	char **temp;
-
-	temp = (char **) realloc (*array, sizeof (char *) * (*array_num + 1));
-	if (temp == NULL)
-		return (-1);
-
-	*array = temp;
-	(*array)[*array_num] = value;
-	(*array_num)++;
-
-	return (0);
-} /* int add_to_array */
-
 int handle_flush (FILE *fh, char *buffer)
 {
 	int success = 0;
 	int error   = 0;
 
 	double timeout = 0.0;
 	char **plugins = NULL;
-	int plugins_num = 0;
+	size_t plugins_num = 0;
 	char **identifiers = NULL;
-	int identifiers_num = 0;
+	size_t identifiers_num = 0;
 
-	int i;
+	size_t i;
+
+#define PRINT_TO_SOCK(fh, ...) \
+	do { \
+		if (fprintf (fh, __VA_ARGS__) < 0) { \
+			char errbuf[1024]; \
+			WARNING ("handle_flush: failed to write to socket #%i: %s", \
+					fileno (fh), sstrerror (errno, errbuf, sizeof (errbuf))); \
+			strarray_free (plugins, plugins_num); \
+			strarray_free (identifiers, identifiers_num); \
+			return -1; \
+		} \
+		fflush(fh); \
+	} while (0)
 
 	if ((fh == NULL) || (buffer == NULL))
 		return (-1);
 
 	DEBUG ("utils_cmd_flush: handle_flush (fh = %p, buffer = %s);",
 			(void *) fh, buffer);
 
 	if (strncasecmp ("FLUSH", buffer, strlen ("FLUSH")) != 0)
 	{
-		print_to_socket (fh, "-1 Cannot parse command.\n");
+		PRINT_TO_SOCK (fh, "-1 Cannot parse command.\n");
 		return (-1);
 	}
 	buffer += strlen ("FLUSH");
 
 	while (*buffer != 0)
 	{
@@ -91,99 +78,83 @@
 
 		opt_key = NULL;
 		opt_value = NULL;
 		status = parse_option (&buffer, &opt_key, &opt_value);
 		if (status != 0)
 		{
-			print_to_socket (fh, "-1 Parsing options failed.\n");
-			sfree (plugins);
-			sfree (identifiers);
+			PRINT_TO_SOCK (fh, "-1 Parsing options failed.\n");
+			strarray_free (plugins, plugins_num);
+			strarray_free (identifiers, identifiers_num);
 			return (-1);
 		}
 
 		if (strcasecmp ("plugin", opt_key) == 0)
-		{
-			add_to_array (&plugins, &plugins_num, opt_value);
-		}
+			strarray_add (&plugins, &plugins_num, opt_value);
 		else if (strcasecmp ("identifier", opt_key) == 0)
-		{
-			add_to_array (&identifiers, &identifiers_num, opt_value);
-		}
+			strarray_add (&identifiers, &identifiers_num, opt_value);
 		else if (strcasecmp ("timeout", opt_key) == 0)
 		{
 			char *endptr;
-			
+
 			errno = 0;
 			endptr = NULL;
 			timeout = strtod (opt_value, &endptr);
 
 			if ((endptr == opt_value) || (errno != 0) || (!isfinite (timeout)))
 			{
-				print_to_socket (fh, "-1 Invalid value for option `timeout': "
+				PRINT_TO_SOCK (fh, "-1 Invalid value for option `timeout': "
 						"%s\n", opt_value);
-				sfree (plugins);
-				sfree (identifiers);
+				strarray_free (plugins, plugins_num);
+				strarray_free (identifiers, identifiers_num);
 				return (-1);
 			}
 			else if (timeout < 0.0)
 			{
 				timeout = 0.0;
 			}
 		}
 		else
 		{
-			print_to_socket (fh, "-1 Cannot parse option %s\n", opt_key);
-			sfree (plugins);
-			sfree (identifiers);
+			PRINT_TO_SOCK (fh, "-1 Cannot parse option %s\n", opt_key);
+			strarray_free (plugins, plugins_num);
+			strarray_free (identifiers, identifiers_num);
 			return (-1);
 		}
 	} /* while (*buffer != 0) */
 
-	/* Add NULL entries for `any plugin' and/or `any value' if nothing was
-	 * specified. */
-	if (plugins_num == 0)
-		add_to_array (&plugins, &plugins_num, NULL);
-
-	if (identifiers_num == 0)
-		add_to_array (&identifiers, &identifiers_num, NULL);
-
-	for (i = 0; i < plugins_num; i++)
+	for (i = 0; (i == 0) || (i < plugins_num); i++)
 	{
-		char *plugin;
+		char *plugin = NULL;
 		int j;
 
-		plugin = plugins[i];
+		if (plugins_num != 0)
+			plugin = plugins[i];
 
-		for (j = 0; j < identifiers_num; j++)
+		for (j = 0; (j == 0) || (j < identifiers_num); j++)
 		{
-			char *identifier;
+			char *identifier = NULL;
 			int status;
 
-			identifier = identifiers[j];
+			if (identifiers_num != 0)
+				identifier = identifiers[j];
+
 			status = plugin_flush (plugin,
 					DOUBLE_TO_CDTIME_T (timeout),
 					identifier);
 			if (status == 0)
 				success++;
 			else
 				error++;
 		}
 	}
 
-	if ((success + error) > 0)
-	{
-		print_to_socket (fh, "0 Done: %i successful, %i errors\n",
-				success, error);
-	}
-	else
-	{
-		plugin_flush (NULL, DOUBLE_TO_CDTIME_T (timeout), NULL);
-		print_to_socket (fh, "0 Done\n");
-	}
+	PRINT_TO_SOCK (fh, "0 Done: %i successful, %i errors\n",
+			success, error);
 
-	sfree (plugins);
-	sfree (identifiers);
+	strarray_free (plugins, plugins_num);
+	strarray_free (identifiers, identifiers_num);
 	return (0);
+#undef PRINT_TO_SOCK
 } /* int handle_flush */
 
 /* vim: set sw=4 ts=4 tw=78 noexpandtab : */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_cmd_putval.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_cmd_putval.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_cmd_putval.c	2015-03-10 22:14:45.853114674 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_cmd_putval.c	2016-01-22 17:51:17.717918678 +0800
@@ -33,33 +33,18 @@
 #define print_to_socket(fh, ...) \
     do { \
         if (fprintf (fh, __VA_ARGS__) < 0) { \
             char errbuf[1024]; \
             WARNING ("handle_putval: failed to write to socket #%i: %s", \
                     fileno (fh), sstrerror (errno, errbuf, sizeof (errbuf))); \
+            sfree (vl.values); \
             return -1; \
         } \
         fflush(fh); \
     } while (0)
 
-static int dispatch_values (const data_set_t *ds, value_list_t *vl,
-	       	FILE *fh, char *buffer)
-{
-	int status;
-
-	status = parse_values (buffer, vl, ds);
-	if (status != 0)
-	{
-		print_to_socket (fh, "-1 Parsing the values string failed.\n");
-		return (-1);
-	}
-
-	plugin_dispatch_values (vl);
-	return (0);
-} /* int dispatch_values */
-
 static int set_option (value_list_t *vl, const char *key, const char *value)
 {
 	if ((vl == NULL) || (key == NULL) || (value == NULL))
 		return (-1);
 
 	if (strcasecmp ("interval", key) == 0)
@@ -94,12 +79,13 @@
 	int   values_submitted;
 
 	char *identifier_copy;
 
 	const data_set_t *ds;
 	value_list_t vl = VALUE_LIST_INIT;
+	vl.values = NULL;
 
 	DEBUG ("utils_cmd_putval: handle_putval (fh = %p, buffer = %s);",
 			(void *) fh, buffer);
 
 	command = NULL;
 	status = parse_string (&buffer, &command);
@@ -193,12 +179,13 @@
 		status = parse_option (&buffer, &string, &value);
 		if (status < 0)
 		{
 			/* parse_option failed, buffer has been modified.
 			 * => we need to abort */
 			print_to_socket (fh, "-1 Misformatted option.\n");
+			sfree (vl.values);
 			return (-1);
 		}
 		else if (status == 0)
 		{
 			assert (string != NULL);
 			assert (value != NULL);
@@ -209,32 +196,35 @@
 		 * the default if no `=' is found.. */
 
 		status = parse_string (&buffer, &string);
 		if (status != 0)
 		{
 			print_to_socket (fh, "-1 Misformatted value.\n");
+			sfree (vl.values);
 			return (-1);
 		}
 		assert (string != NULL);
 
-		status = dispatch_values (ds, &vl, fh, string);
+		status = parse_values (string, &vl, ds);
 		if (status != 0)
 		{
-			/* An error has already been printed. */
+			print_to_socket (fh, "-1 Parsing the values string failed.\n");
+			sfree (vl.values);
 			return (-1);
 		}
+
+		plugin_dispatch_values (&vl);
 		values_submitted++;
 	} /* while (*buffer != 0) */
 	/* Done parsing the options. */
 
 	print_to_socket (fh, "0 Success: %i %s been dispatched.\n",
 			values_submitted,
 			(values_submitted == 1) ? "value has" : "values have");
 
-	sfree (vl.values); 
-
+	sfree (vl.values);
 	return (0);
 } /* int handle_putval */
 
 int create_putval (char *ret, size_t ret_len, /* {{{ */
 	const data_set_t *ds, const value_list_t *vl)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_crc32.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_crc32.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_crc32.c	2015-03-10 22:14:45.853114674 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_crc32.c	2016-01-22 17:51:17.717918678 +0800
@@ -34,15 +34,16 @@
  *      logic; the shift must be unsigned (bring in zeroes).  On some
  *      hardware you could probably optimize the shift in assembler by
  *      using byte-swap instructions
  *      polynomial $edb88320
  */
 
-#include <sys/types.h>
+#include <stdint.h>
+#include <stddef.h>
 
-u_int32_t               crc32_buffer(const u_char *, size_t);
+uint32_t               crc32_buffer(const unsigned char *, size_t);
 static unsigned int     crc32_tab[] = {
 	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
 	0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
 	0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
 	0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
 	0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
@@ -94,17 +95,17 @@
 	0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
 	0x2d02ef8dL
 };
 
 /* Return a 32-bit CRC of the contents of the buffer. */
 
-u_int32_t
-crc32_buffer(const u_char *s, size_t len)
+uint32_t
+crc32_buffer(const unsigned char *s, size_t len)
 {
     size_t      i;
-    u_int32_t   ret;
+    uint32_t   ret;
 
     ret = 0;
     for (i = 0;  i < len;  i++)
         ret = crc32_tab[(ret ^ s[i]) & 0xff] ^ (ret >> 8);
     return ret;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_crc32.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_crc32.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_crc32.h	2015-03-10 22:14:45.853114674 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_crc32.h	2016-01-22 17:51:17.717918678 +0800
@@ -24,9 +24,9 @@
  *   Pierre-Yves Ritschard <pyr at spootnik.org>
  */
 
 #ifndef UTILS_CRC32_H
 #define UTILS_CRC32_H 1
 
-u_int32_t               crc32_buffer(const u_char *, size_t);
+uint32_t               crc32_buffer(const unsigned char *, size_t);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_db_query.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_db_query.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_db_query.c	2015-03-10 22:14:45.853114674 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_db_query.c	2016-01-22 17:51:17.717918678 +0800
@@ -199,14 +199,15 @@
   size_t i;
   int status;
 
   assert (r != NULL);
   assert (r_area->ds != NULL);
   assert (((size_t) r_area->ds->ds_num) == r->values_num);
+  assert (r->values_num > 0);
 
-  vl.values = (value_t *) calloc (r_area->ds->ds_num, sizeof (value_t));
+  vl.values = (value_t *) calloc (r->values_num, sizeof (value_t));
   if (vl.values == NULL)
   {
     ERROR ("db query utils: malloc failed.");
     return (-1);
   }
   vl.values_len = r_area->ds->ds_num;
@@ -1068,16 +1069,15 @@
 udb_query_allocate_preparation_area (udb_query_t *q) /* {{{ */
 {
   udb_query_preparation_area_t   *q_area;
   udb_result_preparation_area_t **next_r_area;
   udb_result_t *r;
 
-  q_area = (udb_query_preparation_area_t *)malloc (sizeof (*q_area));
+  q_area = malloc (sizeof (*q_area));
   if (q_area == NULL)
     return NULL;
-
   memset (q_area, 0, sizeof (*q_area));
 
   next_r_area = &q_area->result_prep_areas;
   for (r = q->results; r != NULL; r = r->next)
   {
     udb_result_preparation_area_t *r_area;
@@ -1079,20 +1079,24 @@
 
   next_r_area = &q_area->result_prep_areas;
   for (r = q->results; r != NULL; r = r->next)
   {
     udb_result_preparation_area_t *r_area;
 
-    r_area = (udb_result_preparation_area_t *)malloc (sizeof (*r_area));
+    r_area = malloc (sizeof (*r_area));
     if (r_area == NULL)
     {
-      for (r_area = q_area->result_prep_areas;
-          r_area != NULL; r_area = r_area->next)
+      udb_result_preparation_area_t *a = q_area->result_prep_areas;
+
+      while (a != NULL)
       {
-        free (r_area);
+        udb_result_preparation_area_t *next = a->next;
+        sfree (a);
+        a = next;
       }
+
       free (q_area);
       return NULL;
     }
 
     memset (r_area, 0, sizeof (*r_area));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_dns.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_dns.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_dns.c	2015-03-10 22:14:45.857114762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_dns.c	2016-01-22 17:51:17.717918678 +0800
@@ -127,12 +127,16 @@
 # define UDP_DEST dest
 # define UDP_SRC  source
 #else
 # error "`struct udphdr' is unusable."
 #endif
 
+#if HAVE_NETINET_IP6_H && HAVE_STRUCT_IP6_EXT
+# define HAVE_IPV6 1
+#endif
+
 #include "utils_dns.h"
 
 /*
  * Type definitions
  */
 struct ip_list_s
@@ -442,13 +446,13 @@
     memcpy(buf, udp + 1, len - sizeof(*udp));
     if (0 == handle_dns(buf, len - sizeof(*udp)))
 	return 0;
     return 1;
 }
 
-#if HAVE_NETINET_IP6_H
+#if HAVE_IPV6
 static int
 handle_ipv6 (struct ip6_hdr *ipv6, int len)
 {
     char buf[PCAP_SNAPLEN];
     unsigned int offset;
     int nexthdr;
@@ -511,22 +515,22 @@
     memcpy (buf, (char *) ipv6 + offset, payload_len);
     if (handle_udp ((struct udphdr *) buf, payload_len) == 0)
 	return (0);
 
     return (1); /* Success */
 } /* int handle_ipv6 */
-/* #endif HAVE_NETINET_IP6_H */
+/* #endif HAVE_IPV6 */
 
-#else /* if !HAVE_NETINET_IP6_H */
+#else /* if !HAVE_IPV6 */
 static int
 handle_ipv6 (__attribute__((unused)) void *pkg,
 	__attribute__((unused)) int len)
 {
     return (0);
 }
-#endif /* !HAVE_NETINET_IP6_H */
+#endif /* !HAVE_IPV6 */
 
 static int
 handle_ip(const struct ip *ip, int len)
 {
     char buf[PCAP_SNAPLEN];
     int offset = ip->ip_hl << 2;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_fbhash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_fbhash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_fbhash.c	2015-03-10 22:14:45.857114762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_fbhash.c	2016-01-22 17:51:17.717918678 +0800
@@ -38,13 +38,13 @@
   time_t mtime;
 
   pthread_mutex_t lock;
   c_avl_tree_t *tree;
 };
 
-/* 
+/*
  * Private functions
  */
 static void fbh_free_tree (c_avl_tree_t *tree) /* {{{ */
 {
   int status;
 
@@ -195,13 +195,13 @@
   if (status == 0)
     h->mtime = statbuf.st_mtime;
 
   return (status);
 } /* }}} int fbh_check_file */
 
-/* 
+/*
  * Public functions
  */
 fbhash_t *fbh_create (const char *file) /* {{{ */
 {
   fbhash_t *h;
   int status;
@@ -225,12 +225,13 @@
   pthread_mutex_init (&h->lock, /* attr = */ NULL);
 
   status = fbh_check_file (h);
   if (status != 0)
   {
     fbh_destroy (h);
+    free (h);
     return (NULL);
   }
 
   return (h);
 } /* }}} fbhash_t *fbh_create */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_format_json.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_format_json.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_format_json.c	2015-05-22 18:04:36.951771009 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_format_json.c	2016-01-22 17:51:17.717918678 +0800
@@ -227,58 +227,50 @@
 
   DEBUG ("format_json: dsnames_to_json: buffer = %s;", buffer);
 
   return (0);
 } /* }}} int dsnames_to_json */
 
-static int meta_data_to_json (char *buffer, size_t buffer_size, /* {{{ */
-    meta_data_t *meta)
+static int meta_data_keys_to_json (char *buffer, size_t buffer_size, /* {{{ */
+    meta_data_t *meta, char **keys, size_t keys_num)
 {
   size_t offset = 0;
-  char **keys = NULL;
-  int keys_num;
   int status;
-  int i;
+  size_t i;
 
   buffer[0] = 0;
 
-  if (meta == NULL)
-    return (EINVAL);
-
 #define BUFFER_ADD(...) do { \
   status = ssnprintf (buffer + offset, buffer_size - offset, \
       __VA_ARGS__); \
   if (status < 1) \
     return (-1); \
   else if (((size_t) status) >= (buffer_size - offset)) \
     return (-ENOMEM); \
   else \
     offset += ((size_t) status); \
 } while (0)
 
-  keys_num = meta_data_toc (meta, &keys);
-  if (keys_num == 0)
-  {
-    sfree (keys);
-    return (0);
-  }
-
   for (i = 0; i < keys_num; ++i)
   {
     int type;
     char *key = keys[i];
 
     type = meta_data_type (meta, key);
     if (type == MD_TYPE_STRING)
     {
       char *value = NULL;
       if (meta_data_get_string (meta, key, &value) == 0)
       {
         char temp[512] = "";
-        json_escape_string (temp, sizeof (temp), value);
+
+        status = json_escape_string (temp, sizeof (temp), value);
         sfree (value);
+        if (status != 0)
+          return status;
+
         BUFFER_ADD (",\"%s\":%s", key, temp);
       }
     }
     else if (type == MD_TYPE_SIGNED_INT)
     {
       int64_t value = 0;
@@ -300,26 +292,48 @@
     else if (type == MD_TYPE_BOOLEAN)
     {
       _Bool value = 0;
       if (meta_data_get_boolean (meta, key, &value) == 0)
         BUFFER_ADD (",\"%s\":%s", key, value ? "true" : "false");
     }
-
-    free (key);
   } /* for (keys) */
-  free (keys);
 
   if (offset <= 0)
     return (ENOENT);
 
   buffer[0] = '{'; /* replace leading ',' */
   BUFFER_ADD ("}");
 
 #undef BUFFER_ADD
 
   return (0);
+} /* }}} int meta_data_keys_to_json */
+
+static int meta_data_to_json (char *buffer, size_t buffer_size, /* {{{ */
+    meta_data_t *meta)
+{
+  char **keys = NULL;
+  size_t keys_num;
+  int status;
+  size_t i;
+
+  if ((buffer == NULL) || (buffer_size == 0) || (meta == NULL))
+    return (EINVAL);
+
+  status = meta_data_toc (meta, &keys);
+  if (status <= 0)
+    return (status);
+  keys_num = (size_t) status;
+
+  status = meta_data_keys_to_json (buffer, buffer_size, meta, keys, keys_num);
+
+  for (i = 0; i < keys_num; ++i)
+    sfree (keys[i]);
+  sfree (keys);
+
+  return status;
 } /* }}} int meta_data_to_json */
 
 static int value_list_to_json (char *buffer, size_t buffer_size, /* {{{ */
                 const data_set_t *ds, const value_list_t *vl, int store_rates)
 {
   char temp[512];
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src: utils_ignorelist.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src: utils_ignorelist.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_latency.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_latency.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_latency.c	2015-05-20 20:04:47.191035542 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_latency.c	2016-01-22 17:51:17.717918678 +0800
@@ -27,30 +27,38 @@
 #include "collectd.h"
 #include "plugin.h"
 #include "utils_latency.h"
 #include "common.h"
 
 #include <math.h>
+#include <limits.h>
+
+#ifndef LLONG_MAX
+# define LLONG_MAX 9223372036854775807LL
+#endif
 
 #ifndef HISTOGRAM_NUM_BINS
 # define HISTOGRAM_NUM_BINS 1000
 #endif
 
-static const int HISTOGRAM_DEFAULT_BIN_WIDTH = 1;
+#ifndef HISTOGRAM_DEFAULT_BIN_WIDTH
+/* 1048576 = 2^20 ^= 1/1024 s */
+# define HISTOGRAM_DEFAULT_BIN_WIDTH 1048576
+#endif
 
 struct latency_counter_s
 {
   cdtime_t start_time;
 
   cdtime_t sum;
   size_t num;
 
   cdtime_t min;
   cdtime_t max;
 
-  int bin_width;
+  cdtime_t bin_width;
   int histogram[HISTOGRAM_NUM_BINS];
 };
 
 /*
 * Histogram represents the distribution of data, it has a list of "bins".
 * Each bin represents an interval and has a count (frequency) of
@@ -64,62 +72,62 @@
 * to be visited to update it's count. To reduce frequent change of bin width,
 * new bin width will be the next nearest power of 2. Example: 2, 4, 8, 16, 32,
 * 64, 128, 256, 512, 1024, 2048, 5086, ...
 *
 * So, if the required bin width is 300, then new bin width will be 512 as it is
 * the next nearest power of 2.
-*
 */
-void change_bin_width (latency_counter_t *lc, size_t val) /* {{{ */
+void change_bin_width (latency_counter_t *lc, cdtime_t latency) /* {{{ */
 {
-  int i=0;
   /* This function is called because the new value is above histogram's range.
    * First find the required bin width:
    *           requiredBinWidth = (value + 1) / numBins
    * then get the next nearest power of 2
    *           newBinWidth = 2^(ceil(log2(requiredBinWidth)))
    */
-  double required_bin_width = (double)(val + 1) / HISTOGRAM_NUM_BINS;
-  double required_bin_width_logbase2 = log(required_bin_width) / log(2.0);
-  int new_bin_width = (int)(pow(2.0, ceil( required_bin_width_logbase2)));
-  int old_bin_width = lc->bin_width;
+  double required_bin_width = ((double) (latency + 1)) / ((double) HISTOGRAM_NUM_BINS);
+  double required_bin_width_logbase2 = log (required_bin_width) / log (2.0);
+  cdtime_t new_bin_width = (cdtime_t) (pow (2.0, ceil (required_bin_width_logbase2)) + .5);
+  cdtime_t old_bin_width = lc->bin_width;
+
   lc->bin_width = new_bin_width;
 
-  /*
-   * bin width has been increased, now iterate through all bins and move the
-   * old bin's count to new bin.
-   */
+  /* bin_width has been increased, now iterate through all bins and move the
+   * old bin's count to new bin. */
   if (lc->num > 0) // if the histogram has data then iterate else skip
   {
-      double width_change_ratio = old_bin_width / new_bin_width;
-      for (i=0; i<HISTOGRAM_NUM_BINS; i++)
+      double width_change_ratio = ((double) old_bin_width) / ((double) new_bin_width);
+      size_t i;
+
+      for (i = 0; i < HISTOGRAM_NUM_BINS; i++)
       {
-         int new_bin = (int)(i * width_change_ratio);
+         size_t new_bin = (size_t) (((double) i) * width_change_ratio);
          if (i == new_bin)
              continue;
+         assert (new_bin < i);
+
          lc->histogram[new_bin] += lc->histogram[i];
          lc->histogram[i] = 0;
       }
-      DEBUG("utils_latency: change_bin_width: fixed all bins");
   }
 
-  DEBUG("utils_latency: change_bin_width: val-[%zu], oldBinWidth-[%d], "
-          "newBinWidth-[%d], required_bin_width-[%f], "
-          "required_bin_width_logbase2-[%f]",
-          val, old_bin_width, new_bin_width, required_bin_width,
-          required_bin_width_logbase2);
-
+  DEBUG("utils_latency: change_bin_width: latency = %.3f; "
+      "old_bin_width = %.3f; new_bin_width = %.3f;",
+      CDTIME_T_TO_DOUBLE (latency),
+      CDTIME_T_TO_DOUBLE (old_bin_width),
+      CDTIME_T_TO_DOUBLE (new_bin_width));
 } /* }}} void change_bin_width */
 
 latency_counter_t *latency_counter_create () /* {{{ */
 {
   latency_counter_t *lc;
 
   lc = malloc (sizeof (*lc));
   if (lc == NULL)
     return (NULL);
+  memset (lc, 0, sizeof (*lc));
 
   latency_counter_reset (lc);
   lc->bin_width = HISTOGRAM_DEFAULT_BIN_WIDTH;
   return (lc);
 } /* }}} latency_counter_t *latency_counter_create */
 
@@ -127,15 +135,15 @@
 {
   sfree (lc);
 } /* }}} void latency_counter_destroy */
 
 void latency_counter_add (latency_counter_t *lc, cdtime_t latency) /* {{{ */
 {
-  size_t latency_ms;
+  cdtime_t bin;
 
-  if ((lc == NULL) || (latency == 0))
+  if ((lc == NULL) || (latency == 0) || (latency > ((cdtime_t) LLONG_MAX)))
     return;
 
   lc->sum += latency;
   lc->num++;
 
   if ((lc->min == 0) && (lc->max == 0))
@@ -145,34 +153,32 @@
   if (lc->max < latency)
     lc->max = latency;
 
   /* A latency of _exactly_ 1.0 ms should be stored in the buffer 0, so
    * subtract one from the cdtime_t value so that exactly 1.0 ms get sorted
    * accordingly. */
-  latency_ms = (size_t) CDTIME_T_TO_MS (latency - 1);
-
-  int bin = (int)(latency_ms / lc->bin_width);
+  bin = (latency - 1) / lc->bin_width;
   if (bin >= HISTOGRAM_NUM_BINS)
   {
-      change_bin_width(lc, latency_ms);
-      bin = (int)(latency_ms / lc->bin_width);
+      change_bin_width (lc, latency);
+      bin = (latency - 1) / lc->bin_width;
       if (bin >= HISTOGRAM_NUM_BINS)
       {
-          ERROR("utils_latency: latency_counter_add: Invalid bin %d", bin);
+          ERROR ("utils_latency: latency_counter_add: Invalid bin: %"PRIu64, bin);
           return;
       }
   }
   lc->histogram[bin]++;
 } /* }}} void latency_counter_add */
 
 void latency_counter_reset (latency_counter_t *lc) /* {{{ */
 {
   if (lc == NULL)
     return;
 
-  int bin_width = lc->bin_width;
+  cdtime_t bin_width = lc->bin_width;
   memset (lc, 0, sizeof (*lc));
 
   /* preserve bin width */
   lc->bin_width = bin_width;
   lc->start_time = cdtime ();
 } /* }}} void latency_counter_reset */
@@ -213,20 +219,20 @@
     return (0);
 
   average = CDTIME_T_TO_DOUBLE (lc->sum) / ((double) lc->num);
   return (DOUBLE_TO_CDTIME_T (average));
 } /* }}} cdtime_t latency_counter_get_average */
 
-cdtime_t latency_counter_get_percentile (latency_counter_t *lc,
+cdtime_t latency_counter_get_percentile (latency_counter_t *lc, /* {{{ */
     double percent)
 {
   double percent_upper;
   double percent_lower;
-  double ms_upper;
-  double ms_lower;
-  double ms_interpolated;
+  double p;
+  cdtime_t latency_lower;
+  cdtime_t latency_interpolated;
   int sum;
   size_t i;
 
   if ((lc == NULL) || (lc->num == 0) || !((percent > 0.0) && (percent < 100.0)))
     return (0);
 
@@ -250,19 +256,21 @@
   if (i >= HISTOGRAM_NUM_BINS)
     return (0);
 
   assert (percent_upper >= percent);
   assert (percent_lower < percent);
 
-  ms_upper = (double) ( (i + 1) * lc->bin_width );
-  ms_lower = (double) ( i * lc->bin_width );
   if (i == 0)
-    return (MS_TO_CDTIME_T (ms_upper));
+    return (lc->bin_width);
+
+  latency_lower = ((cdtime_t) i) * lc->bin_width;
+  p = (percent - percent_lower) / (percent_upper - percent_lower);
 
-  ms_interpolated = (((percent_upper - percent) * ms_lower)
-      + ((percent - percent_lower) * ms_upper))
-    / (percent_upper - percent_lower);
+  latency_interpolated = latency_lower
+    + DOUBLE_TO_CDTIME_T (p * CDTIME_T_TO_DOUBLE (lc->bin_width));
 
-  return (MS_TO_CDTIME_T (ms_interpolated));
+  DEBUG ("latency_counter_get_percentile: latency_interpolated = %.3f",
+      CDTIME_T_TO_DOUBLE (latency_interpolated));
+  return (latency_interpolated);
 } /* }}} cdtime_t latency_counter_get_percentile */
 
 /* vim: set sw=2 sts=2 et fdm=marker : */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_mount.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_mount.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_mount.c	2015-05-27 02:40:18.821717947 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_mount.c	2016-01-22 17:51:17.717918678 +0800
@@ -568,12 +568,70 @@
 /* #endif HAVE_TWO_GETMNTENT || HAVE_GEN_GETMNTENT || HAVE_SUN_GETMNTENT */
 
 #elif HAVE_SEQ_GETMNTENT
 #warn "This version of `getmntent' hat not yet been implemented!"
 /* #endif HAVE_SEQ_GETMNTENT */
 
+#elif HAVE_GETMNTENT_R
+static cu_mount_t *cu_mount_getmntent (void)
+{
+	FILE *fp;
+	struct mntent me;
+	char mntbuf[1024];
+
+	cu_mount_t *first = NULL;
+	cu_mount_t *last  = NULL;
+	cu_mount_t *new   = NULL;
+
+	DEBUG ("utils_mount: (void); COLLECTD_MNTTAB = %s", COLLECTD_MNTTAB);
+
+	if ((fp = setmntent (COLLECTD_MNTTAB, "r")) == NULL)
+	{
+		char errbuf[1024];
+		ERROR ("setmntent (%s): %s", COLLECTD_MNTTAB,
+				sstrerror (errno, errbuf, sizeof (errbuf)));
+		return (NULL);
+	}
+
+	while (getmntent_r (fp, &me, mntbuf, sizeof (mntbuf) ))
+	{
+		if ((new = malloc (sizeof (cu_mount_t))) == NULL)
+			break;
+		memset (new, '\0', sizeof (cu_mount_t));
+
+		/* Copy values from `struct mntent *' */
+		new->dir         = sstrdup (me.mnt_dir);
+		new->spec_device = sstrdup (me.mnt_fsname);
+		new->type        = sstrdup (me.mnt_type);
+		new->options     = sstrdup (me.mnt_opts);
+		new->device      = get_device_name (new->options);
+		new->next        = NULL;
+
+		DEBUG ("utils_mount: new = {dir = %s, spec_device = %s, type = %s, options = %s, device = %s}",
+				new->dir, new->spec_device, new->type, new->options, new->device);
+
+		/* Append to list */
+		if (first == NULL)
+		{
+			first = new;
+			last  = new;
+		}
+		else
+		{
+			last->next = new;
+			last       = new;
+		}
+	}
+
+	endmntent (fp);
+
+	DEBUG ("utils_mount: return (0x%p)", (void *) first);
+
+	return (first);
+} /* HAVE_GETMNTENT_R */
+
 #elif HAVE_ONE_GETMNTENT
 static cu_mount_t *cu_mount_getmntent (void)
 {
 	FILE *fp;
 	struct mntent *me;
 
@@ -699,19 +757,19 @@
 	}
 } /* void cu_mount_freelist(cu_mount_t *list) */
 
 char *
 cu_mount_checkoption(char *line, char *keyword, int full)
 {
-	char *line2, *l2;
-	int l = strlen(keyword);
-	char *p1, *p2;
+	char *line2, *l2, *p1, *p2;
+	int l;
 
 	if(line == NULL || keyword == NULL) {
 		return NULL;
 	}
+
 	if(full != 0) {
 		full = 1;
 	}
 
 	line2 = sstrdup(line);
 	l2 = line2;
@@ -719,12 +777,13 @@
 		if(*l2 == ',') {
 			*l2 = '\0';
 		}
 		l2++;
 	}
 
+	l = strlen(keyword);
 	p1 = line - 1;
 	p2 = strchr(line, ',');
 	do {
 		if(strncmp(line2+(p1-line)+1, keyword, l+full) == 0) {
 			free(line2);
 			return p1+1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_rrdcreate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_rrdcreate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_rrdcreate.c	2015-03-10 22:14:45.857114762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_rrdcreate.c	2016-01-22 17:51:17.717918678 +0800
@@ -168,20 +168,16 @@
 
   int *rts;
   int  rts_num;
 
   int rra_max;
 
-  int span;
-
   int cdp_num;
   int cdp_len;
   int i, j;
 
-  char buffer[128];
-
   /* The stepsize we use here: If it is user-set, use it. If not, use the
    * interval of the value-list. */
   int ss;
 
   if (cfg->rrarows <= 0)
   {
@@ -215,22 +211,23 @@
   {
     rts = rra_timespans;
     rts_num = rra_timespans_num;
   }
 
   rra_max = rts_num * rra_types_num;
+  assert (rra_max > 0);
 
-  if ((rra_def = (char **) malloc ((rra_max + 1) * sizeof (char *))) == NULL)
+  if ((rra_def = malloc ((rra_max + 1) * sizeof (*rra_def))) == NULL)
     return (-1);
-  memset (rra_def, '\0', (rra_max + 1) * sizeof (char *));
+  memset (rra_def, 0, (rra_max + 1) * sizeof (*rra_def));
   rra_num = 0;
 
   cdp_len = 0;
   for (i = 0; i < rts_num; i++)
   {
-    span = rts[i];
+    int span = rts[i];
 
     if ((span / ss) < cfg->rrarows)
       span = ss * cfg->rrarows;
 
     if (cdp_len == 0)
       cdp_len = 1;
@@ -240,12 +237,13 @@
 
     cdp_num = (int) ceil (((double) span)
         / ((double) (cdp_len * ss)));
 
     for (j = 0; j < rra_types_num; j++)
     {
+      char buffer[128];
       int status;
 
       if (rra_num >= rra_max)
         break;
 
       status = ssnprintf (buffer, sizeof (buffer), "RRA:%s:%.10f:%u:%u",
@@ -258,12 +256,18 @@
       }
 
       rra_def[rra_num++] = sstrdup (buffer);
     }
   }
 
+  if (rra_num <= 0)
+  {
+    sfree (rra_def);
+    return (0);
+  }
+
   *ret = rra_def;
   return (rra_num);
 } /* }}} int rra_get */
 
 static void ds_free (int ds_num, char **ds_def) /* {{{ */
 {
@@ -283,21 +287,23 @@
   int ds_num;
 
   char min[32];
   char max[32];
   char buffer[128];
 
-  ds_def = (char **) malloc (ds->ds_num * sizeof (char *));
+  assert (ds->ds_num > 0);
+
+  ds_def = malloc (ds->ds_num * sizeof (*ds_def));
   if (ds_def == NULL)
   {
     char errbuf[1024];
     ERROR ("rrdtool plugin: malloc failed: %s",
         sstrerror (errno, errbuf, sizeof (errbuf)));
     return (-1);
   }
-  memset (ds_def, '\0', ds->ds_num * sizeof (char *));
+  memset (ds_def, 0, ds->ds_num * sizeof (*ds_def));
 
   for (ds_num = 0; ds_num < ds->ds_num; ds_num++)
   {
     data_source_t *d = ds->ds + ds_num;
     char *type;
     int status;
@@ -349,12 +355,18 @@
   if (ds_num != ds->ds_num)
   {
     ds_free (ds_num, ds_def);
     return (-1);
   }
 
+  if (ds_num <= 0)
+  {
+    sfree (ds_def);
+    return (0);
+  }
+
   *ret = ds_def;
   return (ds_num);
 } /* }}} int ds_get */
 
 #if HAVE_THREADSAFE_LIBRRD
 static int srrd_create (const char *filename, /* {{{ */
@@ -648,15 +660,15 @@
 int cu_rrd_create_file (const char *filename, /* {{{ */
     const data_set_t *ds, const value_list_t *vl,
     const rrdcreate_config_t *cfg)
 {
   char **argv;
   int argc;
-  char **rra_def;
+  char **rra_def = NULL;
   int rra_num;
-  char **ds_def;
+  char **ds_def = NULL;
   int ds_num;
   int status = 0;
   time_t last_up;
   unsigned long stepsize;
 
   if (check_create_dir (filename))
@@ -668,22 +680,25 @@
     return (-1);
   }
 
   if ((ds_num = ds_get (&ds_def, ds, vl, cfg)) < 1)
   {
     ERROR ("cu_rrd_create_file failed: Could not calculate DSes");
+    rra_free (rra_num, rra_def);
     return (-1);
   }
 
   argc = ds_num + rra_num;
 
   if ((argv = (char **) malloc (sizeof (char *) * (argc + 1))) == NULL)
   {
     char errbuf[1024];
     ERROR ("cu_rrd_create_file failed: %s",
         sstrerror (errno, errbuf, sizeof (errbuf)));
+    rra_free (rra_num, rra_def);
+    ds_free (ds_num, ds_def);
     return (-1);
   }
 
   memcpy (argv, ds_def, ds_num * sizeof (char *));
   memcpy (argv + ds_num, rra_def, rra_num * sizeof (char *));
   argv[ds_num + rra_num] = NULL;
@@ -706,24 +721,38 @@
       WARNING ("cu_rrd_create_file: srrd_create_async (%s) "
           "returned status %i.",
           filename, status);
   }
   else /* synchronous */
   {
-    status = srrd_create (filename, stepsize, last_up,
-        argc, (const char **) argv);
-
+    status = lock_file (filename);
     if (status != 0)
     {
-      WARNING ("cu_rrd_create_file: srrd_create (%s) returned status %i.",
-          filename, status);
+      if (status == EEXIST)
+        NOTICE ("cu_rrd_create_file: File \"%s\" is already being created.",
+            filename);
+      else
+        ERROR ("cu_rrd_create_file: Unable to lock file \"%s\".",
+            filename);
     }
     else
     {
-      DEBUG ("cu_rrd_create_file: Successfully created RRD file \"%s\".",
-          filename);
+      status = srrd_create (filename, stepsize, last_up,
+          argc, (const char **) argv);
+
+      if (status != 0)
+      {
+        WARNING ("cu_rrd_create_file: srrd_create (%s) returned status %i.",
+            filename, status);
+      }
+      else
+      {
+        DEBUG ("cu_rrd_create_file: Successfully created RRD file \"%s\".",
+            filename);
+      }
+      unlock_file (filename);
     }
   }
 
   free (argv);
   ds_free (ds_num, ds_def);
   rra_free (rra_num, rra_def);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_vl_lookup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_vl_lookup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/utils_vl_lookup.c	2015-03-10 22:14:45.857114762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/utils_vl_lookup.c	2016-01-22 17:51:17.721918675 +0800
@@ -301,15 +301,16 @@
   pthread_mutex_lock (&user_class->lock);
   user_obj = lu_find_user_obj (user_class, vl);
   if (user_obj == NULL)
   {
     /* call lookup_class_callback_t() and insert into the list of user objects. */
     user_obj = lu_create_user_obj (obj, ds, vl, user_class);
-    pthread_mutex_unlock (&user_class->lock);
-    if (user_obj == NULL)
+    if (user_obj == NULL) {
+      pthread_mutex_unlock (&user_class->lock);
       return (-1);
+    }
   }
   pthread_mutex_unlock (&user_class->lock);
 
   status = obj->cb_user_obj (ds, vl,
       user_class->user_class, user_obj->user_obj);
   if (status != 0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/varnish.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/varnish.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/varnish.c	2015-03-10 22:14:45.857114762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/varnish.c	2016-01-22 17:51:17.721918675 +0800
@@ -26,25 +26,25 @@
 #include "collectd.h"
 #include "common.h"
 #include "plugin.h"
 #include "configfile.h"
 
 #if HAVE_VARNISH_V4
-#include <varnish/vapi/vsm.h>
-#include <varnish/vapi/vsc.h>
+#include <vapi/vsm.h>
+#include <vapi/vsc.h>
 typedef struct VSC_C_main c_varnish_stats_t;
 #endif
 
 #if HAVE_VARNISH_V3
-#include <varnish/varnishapi.h>
-#include <varnish/vsc.h>
+#include <varnishapi.h>
+#include <vsc.h>
 typedef struct VSC_C_main c_varnish_stats_t;
 #endif
 
 #if HAVE_VARNISH_V2
-#include <varnish/varnishapi.h>
+#include <varnishapi.h>
 typedef struct varnish_stats c_varnish_stats_t;
 #endif
 
 /* {{{ user_config_s */
 struct user_config_s {
 	char *instance;
@@ -132,12 +132,403 @@
 
 	value.derive = (derive_t) derive_value;
 
 	return (varnish_submit (plugin_instance, category, type, type_instance, value));
 } /* }}} int varnish_submit_derive */
 
+#if HAVE_VARNISH_V3 || HAVE_VARNISH_V4
+static int varnish_monitor (void *priv, const struct VSC_point * const pt) /* {{{ */
+{
+	uint64_t val;
+	const user_config_t *conf;
+	const char *class;
+	const char *name;
+
+	if (pt == NULL)
+		return (0);
+
+	conf = priv;
+
+#if HAVE_VARNISH_V4
+	class = pt->section->fantom->type;
+	name  = pt->desc->name;
+
+	if (strcmp(class, "MAIN") != 0)
+		return (0);
+
+#elif HAVE_VARNISH_V3
+	class = pt->class;
+	name  = pt->name;
+
+	if (strcmp(class, "") != 0)
+		return (0);
+#endif
+
+	val = *(const volatile uint64_t*) pt->ptr;
+
+	if (conf->collect_cache)
+	{
+		if (strcmp(name, "cache_hit") == 0)
+			return varnish_submit_derive (conf->instance, "cache", "cache_result", "hit",     val);
+		else if (strcmp(name, "cache_miss") == 0)
+			return varnish_submit_derive (conf->instance, "cache", "cache_result", "miss",    val);
+		else if (strcmp(name, "cache_hitpass") == 0)
+			return varnish_submit_derive (conf->instance, "cache", "cache_result", "hitpass", val);
+	}
+
+	if (conf->collect_connections)
+	{
+		if (strcmp(name, "client_conn") == 0)
+			return varnish_submit_derive (conf->instance, "connections", "connections", "accepted", val);
+		else if (strcmp(name, "client_drop") == 0)
+			return varnish_submit_derive (conf->instance, "connections", "connections", "dropped" , val);
+		else if (strcmp(name, "client_req") == 0)
+			return varnish_submit_derive (conf->instance, "connections", "connections", "received", val);
+	}
+
+#ifdef HAVE_VARNISH_V3
+	if (conf->collect_dirdns)
+	{
+		if (strcmp(name, "dir_dns_lookups") == 0)
+			return varnish_submit_derive (conf->instance, "dirdns", "cache_operation", "lookups",    val);
+		else if (strcmp(name, "dir_dns_failed") == 0)
+			return varnish_submit_derive (conf->instance, "dirdns", "cache_result",    "failed",     val);
+		else if (strcmp(name, "dir_dns_hit") == 0)
+			return varnish_submit_derive (conf->instance, "dirdns", "cache_result",    "hits",       val);
+		else if (strcmp(name, "dir_dns_cache_full") == 0)
+			return varnish_submit_derive (conf->instance, "dirdns", "cache_result",    "cache_full", val);
+	}
+#endif
+
+	if (conf->collect_esi)
+	{
+		if (strcmp(name, "esi_errors") == 0)
+			return varnish_submit_derive (conf->instance, "esi", "total_operations", "error",   val);
+		else if (strcmp(name, "esi_parse") == 0)
+			return varnish_submit_derive (conf->instance, "esi", "total_operations", "parsed",  val);
+		else if (strcmp(name, "esi_warnings") == 0)
+			return varnish_submit_derive (conf->instance, "esi", "total_operations", "warning", val);
+	}
+
+	if (conf->collect_backend)
+	{
+		if (strcmp(name, "backend_conn") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "connections", "success",       val);
+		else if (strcmp(name, "backend_unhealthy") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "connections", "not-attempted", val);
+		else if (strcmp(name, "backend_busy") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "connections", "too-many",      val);
+		else if (strcmp(name, "backend_fail") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "connections", "failures",      val);
+		else if (strcmp(name, "backend_reuse") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "connections", "reuses",        val);
+		else if (strcmp(name, "backend_toolate") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "connections", "was-closed",    val);
+		else if (strcmp(name, "backend_recycle") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "connections", "recycled",      val);
+		else if (strcmp(name, "backend_unused") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "connections", "unused",        val);
+		else if (strcmp(name, "backend_retry") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "connections", "retries",       val);
+		else if (strcmp(name, "backend_req") == 0)
+			return varnish_submit_derive (conf->instance, "backend", "http_requests", "requests",    val);
+		else if (strcmp(name, "n_backend") == 0)
+			return varnish_submit_gauge  (conf->instance, "backend", "backends", "n_backends",       val);
+	}
+
+	if (conf->collect_fetch)
+	{
+		if (strcmp(name, "fetch_head") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "head",        val);
+		else if (strcmp(name, "fetch_length") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "length",      val);
+		else if (strcmp(name, "fetch_chunked") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "chunked",     val);
+		else if (strcmp(name, "fetch_eof") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "eof",         val);
+		else if (strcmp(name, "fetch_bad") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "bad_headers", val);
+		else if (strcmp(name, "fetch_close") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "close",       val);
+		else if (strcmp(name, "fetch_oldhttp") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "oldhttp",     val);
+		else if (strcmp(name, "fetch_zero") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "zero",        val);
+		else if (strcmp(name, "fetch_failed") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "failed",      val);
+		else if (strcmp(name, "fetch_1xx") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "no_body_1xx", val);
+		else if (strcmp(name, "fetch_204") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "no_body_204", val);
+		else if (strcmp(name, "fetch_304") == 0)
+			return varnish_submit_derive (conf->instance, "fetch", "http_requests", "no_body_304", val);
+	}
+
+	if (conf->collect_hcb)
+	{
+		if (strcmp(name, "hcb_nolock") == 0)
+			return varnish_submit_derive (conf->instance, "hcb", "cache_operation", "lookup_nolock", val);
+		else if (strcmp(name, "hcb_lock") == 0)
+			return varnish_submit_derive (conf->instance, "hcb", "cache_operation", "lookup_lock",   val);
+		else if (strcmp(name, "hcb_insert") == 0)
+			return varnish_submit_derive (conf->instance, "hcb", "cache_operation", "insert",        val);
+	}
+
+	if (conf->collect_objects)
+	{
+		if (strcmp(name, "n_expired") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "expired",            val);
+		else if (strcmp(name, "n_lru_nuked") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "lru_nuked",          val);
+		else if (strcmp(name, "n_lru_saved") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "lru_saved",          val);
+		else if (strcmp(name, "n_lru_moved") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "lru_moved",          val);
+		else if (strcmp(name, "n_deathrow") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "deathrow",           val);
+		else if (strcmp(name, "losthdr") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "header_overflow",    val);
+		else if (strcmp(name, "n_obj_purged") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "purged",             val);
+		else if (strcmp(name, "n_objsendfile") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "sent_sendfile",      val);
+		else if (strcmp(name, "n_objwrite") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "sent_write",         val);
+		else if (strcmp(name, "n_objoverflow") == 0)
+			return varnish_submit_derive (conf->instance, "objects", "total_objects", "workspace_overflow", val);
+	}
+
+#if HAVE_VARNISH_V3
+	if (conf->collect_ban)
+	{
+		if (strcmp(name, "n_ban") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "total",          val);
+		else if (strcmp(name, "n_ban_add") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "added",          val);
+		else if (strcmp(name, "n_ban_retire") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "deleted",        val);
+		else if (strcmp(name, "n_ban_obj_test") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "objects_tested", val);
+		else if (strcmp(name, "n_ban_re_test") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "regexps_tested", val);
+		else if (strcmp(name, "n_ban_dups") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "duplicate",      val);
+	}
+#endif
+#if HAVE_VARNISH_V4
+	if (conf->collect_ban)
+	{
+		if (strcmp(name, "bans") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "total",     val);
+		else if (strcmp(name, "bans_added") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "added",     val);
+		else if (strcmp(name, "bans_obj") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "obj",       val);
+		else if (strcmp(name, "bans_req") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "req",       val);
+		else if (strcmp(name, "bans_completed") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "completed", val);
+		else if (strcmp(name, "bans_deleted") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "deleted",   val);
+		else if (strcmp(name, "bans_tested") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "tested",    val);
+		else if (strcmp(name, "bans_dups") == 0)
+			return varnish_submit_derive (conf->instance, "ban", "total_operations", "duplicate", val);
+	}
+#endif
+
+	if (conf->collect_session)
+	{
+		if (strcmp(name, "sess_closed") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "closed",    val);
+		else if (strcmp(name, "sess_pipeline") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "pipeline",  val);
+		else if (strcmp(name, "sess_readahead") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "readahead", val);
+		else if (strcmp(name, "sess_conn") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "accepted",  val);
+		else if (strcmp(name, "sess_drop") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "dropped",   val);
+		else if (strcmp(name, "sess_fail") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "failed",    val);
+		else if (strcmp(name, "sess_pipe_overflow") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "overflow",  val);
+		else if (strcmp(name, "sess_queued") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "queued",    val);
+		else if (strcmp(name, "sess_linger") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "linger",    val);
+		else if (strcmp(name, "sess_herd") == 0)
+			return varnish_submit_derive (conf->instance, "session", "total_operations", "herd",      val);
+	}
+
+	if (conf->collect_shm)
+	{
+		if (strcmp(name, "shm_records") == 0)
+			return varnish_submit_derive (conf->instance, "shm", "total_operations", "records",    val);
+		else if (strcmp(name, "shm_writes") == 0)
+			return varnish_submit_derive (conf->instance, "shm", "total_operations", "writes",     val);
+		else if (strcmp(name, "shm_flushes") == 0)
+			return varnish_submit_derive (conf->instance, "shm", "total_operations", "flushes",    val);
+		else if (strcmp(name, "shm_cont") == 0)
+			return varnish_submit_derive (conf->instance, "shm", "total_operations", "contention", val);
+		else if (strcmp(name, "shm_cycles") == 0)
+			return varnish_submit_derive (conf->instance, "shm", "total_operations", "cycles",     val);
+	}
+
+	if (conf->collect_sms)
+	{
+		if (strcmp(name, "sms_nreq") == 0)
+			return varnish_submit_derive (conf->instance, "sms", "total_requests", "allocator", val);
+		else if (strcmp(name, "sms_nobj") == 0)
+			return varnish_submit_gauge (conf->instance,  "sms", "requests", "outstanding",     val);
+		else if (strcmp(name, "sms_nbytes") == 0)
+			return varnish_submit_gauge (conf->instance,  "sms", "bytes", "outstanding",        val);
+		else if (strcmp(name, "sms_balloc") == 0)
+			return varnish_submit_derive (conf->instance,  "sms", "total_bytes", "allocated",   val);
+		else if (strcmp(name, "sms_bfree") == 0)
+			return varnish_submit_derive (conf->instance,  "sms", "total_bytes", "free",        val);
+	}
+
+	if (conf->collect_struct)
+	{
+		if (strcmp(name, "n_sess_mem") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "current_sessions", "sess_mem",  val);
+		else if (strcmp(name, "n_sess") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "current_sessions", "sess",      val);
+		else if (strcmp(name, "n_object") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "objects", "object",             val);
+		else if (strcmp(name, "n_vampireobject") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "objects", "vampireobject",      val);
+		else if (strcmp(name, "n_objectcore") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "objects", "objectcore",         val);
+		else if (strcmp(name, "n_waitinglist") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "objects", "waitinglist",        val);
+		else if (strcmp(name, "n_objecthead") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "objects", "objecthead",         val);
+		else if (strcmp(name, "n_smf") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "objects", "smf",                val);
+		else if (strcmp(name, "n_smf_frag") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "objects", "smf_frag",           val);
+		else if (strcmp(name, "n_smf_large") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "objects", "smf_large",          val);
+		else if (strcmp(name, "n_vbe_conn") == 0)
+			return varnish_submit_gauge (conf->instance, "struct", "objects", "vbe_conn",           val);
+	}
+
+	if (conf->collect_totals)
+	{
+		if (strcmp(name, "s_sess") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_sessions", "sessions",  val);
+		else if (strcmp(name, "s_req") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_requests", "requests",  val);
+		else if (strcmp(name, "s_pipe") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_operations", "pipe",    val);
+		else if (strcmp(name, "s_pass") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_operations", "pass",    val);
+		else if (strcmp(name, "s_fetch") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_operations", "fetches", val);
+		else if (strcmp(name, "s_synth") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "synth",        val);
+		else if (strcmp(name, "s_req_hdrbytes") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "req_header",   val);
+		else if (strcmp(name, "s_req_bodybytes") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "req_body",     val);
+		else if (strcmp(name, "s_resp_hdrbytes") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "resp_header",  val);
+		else if (strcmp(name, "s_resp_bodybytes") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "resp_body",    val);
+		else if (strcmp(name, "s_pipe_hdrbytes") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "pipe_header",  val);
+		else if (strcmp(name, "s_pipe_in") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "pipe_in",      val);
+		else if (strcmp(name, "s_pipe_out") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "pipe_out",     val);
+		else if (strcmp(name, "n_purges") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_operations", "purges",  val);
+		else if (strcmp(name, "s_hdrbytes") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "header-bytes", val);
+		else if (strcmp(name, "s_bodybytes") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_bytes", "body-bytes",   val);
+		else if (strcmp(name, "n_gzip") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_operations", "gzip",    val);
+		else if (strcmp(name, "n_gunzip") == 0)
+			return varnish_submit_derive (conf->instance, "totals", "total_operations", "gunzip",  val);
+	}
+
+	if (conf->collect_uptime)
+	{
+		if (strcmp(name, "uptime") == 0)
+			return varnish_submit_gauge (conf->instance, "uptime", "uptime", "client_uptime", val);
+	}
+
+	if (conf->collect_vcl)
+	{
+		if (strcmp(name, "n_vcl") == 0)
+			return varnish_submit_gauge (conf->instance, "vcl", "vcl", "total_vcl",     val);
+		else if (strcmp(name, "n_vcl_avail") == 0)
+			return varnish_submit_gauge (conf->instance, "vcl", "vcl", "avail_vcl",     val);
+		else if (strcmp(name, "n_vcl_discard") == 0)
+			return varnish_submit_gauge (conf->instance, "vcl", "vcl", "discarded_vcl", val);
+		else if (strcmp(name, "vmods") == 0)
+			return varnish_submit_gauge (conf->instance, "vcl", "objects", "vmod",      val);
+	}
+
+	if (conf->collect_workers)
+	{
+		if (strcmp(name, "threads") == 0)
+			return varnish_submit_gauge (conf->instance, "workers", "threads", "worker",               val);
+		else if (strcmp(name, "threads_created") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_threads", "created",       val);
+		else if (strcmp(name, "threads_failed") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_threads", "failed",        val);
+		else if (strcmp(name, "threads_limited") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_threads", "limited",       val);
+		else if (strcmp(name, "threads_destroyed") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_threads", "dropped",       val);
+		else if (strcmp(name, "thread_queue_len") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "queue_length",  "threads",       val);
+		else if (strcmp(name, "n_wrk") == 0)
+			return varnish_submit_gauge (conf->instance, "workers", "threads", "worker",               val);
+		else if (strcmp(name, "n_wrk_create") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_threads", "created",       val);
+		else if (strcmp(name, "n_wrk_failed") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_threads", "failed",        val);
+		else if (strcmp(name, "n_wrk_max") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_threads", "limited",       val);
+		else if (strcmp(name, "n_wrk_drop") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_threads", "dropped",       val);
+		else if (strcmp(name, "n_wrk_queue") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_requests", "queued",       val);
+		else if (strcmp(name, "n_wrk_overflow") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_requests", "overflowed",   val);
+		else if (strcmp(name, "n_wrk_queued") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_requests", "queued",       val);
+		else if (strcmp(name, "n_wrk_lqueue") == 0)
+			return varnish_submit_derive (conf->instance, "workers", "total_requests", "queue_length", val);
+	}
+
+#if HAVE_VARNISH_V4
+	if (conf->collect_vsm)
+	{
+		if (strcmp(name, "vsm_free") == 0)
+			return varnish_submit_gauge (conf->instance, "vsm", "bytes", "free",              val);
+		else if (strcmp(name, "vsm_used") == 0)
+			return varnish_submit_gauge (conf->instance, "vsm", "bytes", "used",              val);
+		else if (strcmp(name, "vsm_cooling") == 0)
+			return varnish_submit_gauge (conf->instance, "vsm", "bytes", "cooling",           val);
+		else if (strcmp(name, "vsm_overflow") == 0)
+			return varnish_submit_gauge (conf->instance, "vsm", "bytes", "overflow",          val);
+		else if (strcmp(name, "vsm_overflowed") == 0)
+			return varnish_submit_derive (conf->instance, "vsm", "total_bytes", "overflowed", val);
+	}
+#endif
+
+	return (0);
+
+} /* }}} static int varnish_monitor */
+#else /* if HAVE_VARNISH_V2 */
 static void varnish_monitor (const user_config_t *conf, /* {{{ */
 		const c_varnish_stats_t *stats)
 {
 	if (conf->collect_cache)
 	{
 		/* Cache hits */
@@ -147,47 +538,26 @@
 		/* Cache hits for pass */
 		varnish_submit_derive (conf->instance, "cache", "cache_result", "hitpass", stats->cache_hitpass);
 	}
 
 	if (conf->collect_connections)
 	{
-#ifndef HAVE_VARNISH_V4
 		/* Client connections accepted */
 		varnish_submit_derive (conf->instance, "connections", "connections", "accepted", stats->client_conn);
 		/* Connection dropped, no sess */
 		varnish_submit_derive (conf->instance, "connections", "connections", "dropped" , stats->client_drop);
-#endif
 		/* Client requests received    */
 		varnish_submit_derive (conf->instance, "connections", "connections", "received", stats->client_req);
 	}
 
-#ifdef HAVE_VARNISH_V3
-	if (conf->collect_dirdns)
-	{
-		/* DNS director lookups */
-		varnish_submit_derive (conf->instance, "dirdns", "cache_operation", "lookups",    stats->dir_dns_lookups);
-		/* DNS director failed lookups */
-		varnish_submit_derive (conf->instance, "dirdns", "cache_result",    "failed",     stats->dir_dns_failed);
-		/* DNS director cached lookups hit */
-		varnish_submit_derive (conf->instance, "dirdns", "cache_result",    "hits",       stats->dir_dns_hit);
-		/* DNS director full dnscache */
-		varnish_submit_derive (conf->instance, "dirdns", "cache_result",    "cache_full", stats->dir_dns_cache_full);
-	}
-#endif
-
 	if (conf->collect_esi)
 	{
 		/* ESI parse errors (unlock)   */
 		varnish_submit_derive (conf->instance, "esi", "total_operations", "error",   stats->esi_errors);
-#if HAVE_VARNISH_V2
 		/* Objects ESI parsed (unlock) */
 		varnish_submit_derive (conf->instance, "esi", "total_operations", "parsed",  stats->esi_parse);
-#else
-		/* ESI parse warnings (unlock) */
-		varnish_submit_derive (conf->instance, "esi", "total_operations", "warning", stats->esi_warnings);
-#endif
 	}
 
 	if (conf->collect_backend)
 	{
 		/* Backend conn. success       */
 		varnish_submit_derive (conf->instance, "backend", "connections", "success"      , stats->backend_conn);
@@ -200,19 +570,14 @@
 		/* Backend conn. reuses        */
 		varnish_submit_derive (conf->instance, "backend", "connections", "reuses"       , stats->backend_reuse);
 		/* Backend conn. was closed    */
 		varnish_submit_derive (conf->instance, "backend", "connections", "was-closed"   , stats->backend_toolate);
 		/* Backend conn. recycles      */
 		varnish_submit_derive (conf->instance, "backend", "connections", "recycled"     , stats->backend_recycle);
-#if HAVE_VARNISH_V2
 		/* Backend conn. unused        */
 		varnish_submit_derive (conf->instance, "backend", "connections", "unused"       , stats->backend_unused);
-#else
-		/* Backend conn. retry         */
-		varnish_submit_derive (conf->instance, "backend", "connections", "retries"      , stats->backend_retry);
-#endif
 		/* Backend requests mades      */
 		varnish_submit_derive (conf->instance, "backend", "http_requests", "requests"   , stats->backend_req);
 		/* N backends                  */
 		varnish_submit_gauge  (conf->instance, "backend", "backends", "n_backends"      , stats->n_backend);
 	}
 
@@ -233,20 +598,12 @@
 		/* Fetch pre HTTP/1.1 closed */
 		varnish_submit_derive (conf->instance, "fetch", "http_requests", "oldhttp"    , stats->fetch_oldhttp);
 		/* Fetch zero len            */
 		varnish_submit_derive (conf->instance, "fetch", "http_requests", "zero"       , stats->fetch_zero);
 		/* Fetch failed              */
 		varnish_submit_derive (conf->instance, "fetch", "http_requests", "failed"     , stats->fetch_failed);
-#if HAVE_VARNISH_V3 || HAVE_VARNISH_V4
-		/* Fetch no body (1xx)       */
-		varnish_submit_derive (conf->instance, "fetch", "http_requests", "no_body_1xx", stats->fetch_1xx);
-		/* Fetch no body (204)       */
-		varnish_submit_derive (conf->instance, "fetch", "http_requests", "no_body_204", stats->fetch_204);
-		/* Fetch no body (304)       */
-		varnish_submit_derive (conf->instance, "fetch", "http_requests", "no_body_304", stats->fetch_304);
-#endif
 	}
 
 	if (conf->collect_hcb)
 	{
 		/* HCB Lookups without lock */
 		varnish_submit_derive (conf->instance, "hcb", "cache_operation", "lookup_nolock", stats->hcb_nolock);
@@ -259,38 +616,28 @@
 	if (conf->collect_objects)
 	{
 		/* N expired objects             */
 		varnish_submit_derive (conf->instance, "objects", "total_objects", "expired",            stats->n_expired);
 		/* N LRU nuked objects           */
 		varnish_submit_derive (conf->instance, "objects", "total_objects", "lru_nuked",          stats->n_lru_nuked);
-#if HAVE_VARNISH_V2
 		/* N LRU saved objects           */
 		varnish_submit_derive (conf->instance, "objects", "total_objects", "lru_saved",          stats->n_lru_saved);
-#endif
 		/* N LRU moved objects           */
 		varnish_submit_derive (conf->instance, "objects", "total_objects", "lru_moved",          stats->n_lru_moved);
-#if HAVE_VARNISH_V2
 		/* N objects on deathrow         */
 		varnish_submit_derive (conf->instance, "objects", "total_objects", "deathrow",           stats->n_deathrow);
-#endif
 		/* HTTP header overflows         */
 		varnish_submit_derive (conf->instance, "objects", "total_objects", "header_overflow",    stats->losthdr);
-#if HAVE_VARNISH_V4
-		/* N purged objects              */
-		varnish_submit_derive (conf->instance, "objects", "total_objects", "purged",             stats->n_obj_purged);
-#else
 		/* Objects sent with sendfile    */
 		varnish_submit_derive (conf->instance, "objects", "total_objects", "sent_sendfile",      stats->n_objsendfile);
 		/* Objects sent with write       */
 		varnish_submit_derive (conf->instance, "objects", "total_objects", "sent_write",         stats->n_objwrite);
 		/* Objects overflowing workspace */
 		varnish_submit_derive (conf->instance, "objects", "total_objects", "workspace_overflow", stats->n_objoverflow);
-#endif
 	}
 
-#if HAVE_VARNISH_V2
 	if (conf->collect_purge)
 	{
 		/* N total active purges      */
 		varnish_submit_derive (conf->instance, "purge", "total_operations", "total",            stats->n_purge);
 		/* N new purges added         */
 		varnish_submit_derive (conf->instance, "purge", "total_operations", "added",            stats->n_purge_add);
@@ -300,75 +647,23 @@
 		varnish_submit_derive (conf->instance, "purge", "total_operations", "objects_tested",   stats->n_purge_obj_test);
 		/* N regexps tested against   */
 		varnish_submit_derive (conf->instance, "purge", "total_operations", "regexps_tested",   stats->n_purge_re_test);
 		/* N duplicate purges removed */
 		varnish_submit_derive (conf->instance, "purge", "total_operations", "duplicate",        stats->n_purge_dups);
 	}
-#endif
-#if HAVE_VARNISH_V3
-	if (conf->collect_ban)
-	{
-		/* N total active bans      */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "total",          stats->n_ban);
-		/* N new bans added         */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "added",          stats->n_ban_add);
-		/* N old bans deleted       */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "deleted",        stats->n_ban_retire);
-		/* N objects tested         */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "objects_tested", stats->n_ban_obj_test);
-		/* N regexps tested against */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "regexps_tested", stats->n_ban_re_test);
-		/* N duplicate bans removed */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "duplicate",      stats->n_ban_dups);
-	}
-#endif
-#if HAVE_VARNISH_V4
-	if (conf->collect_ban)
-	{
-		/* N total active bans      */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "total",          stats->bans);
-		/* N new bans added         */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "added",          stats->bans_added);
-		/* N bans using obj */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "obj",            stats->bans_obj);
-		/* N bans using req */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "req",            stats->bans_req);
-		/* N new bans completed     */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "completed",      stats->bans_completed);
-		/* N old bans deleted       */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "deleted",        stats->bans_deleted);
-		/* N objects tested         */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "tested",         stats->bans_tested);
-		/* N duplicate bans removed */
-		varnish_submit_derive (conf->instance, "ban", "total_operations", "duplicate",      stats->bans_dups);
-	}
-#endif
 
 	if (conf->collect_session)
 	{
 		/* Session Closed     */
 		varnish_submit_derive (conf->instance, "session", "total_operations", "closed",    stats->sess_closed);
 		/* Session Pipeline   */
 		varnish_submit_derive (conf->instance, "session", "total_operations", "pipeline",  stats->sess_pipeline);
 		/* Session Read Ahead */
 		varnish_submit_derive (conf->instance, "session", "total_operations", "readahead", stats->sess_readahead);
-#if HAVE_VARNISH_V4
-		/* Sessions accepted */
-		varnish_submit_derive (conf->instance, "session", "total_operations", "accepted",  stats->sess_conn);
-		/* Sessions dropped for thread */
-		varnish_submit_derive (conf->instance, "session", "total_operations", "dropped",   stats->sess_drop);
-		/* Sessions accept failure */
-		varnish_submit_derive (conf->instance, "session", "total_operations", "failed",    stats->sess_fail);
-		/* Sessions pipe overflow */
-		varnish_submit_derive (conf->instance, "session", "total_operations", "overflow",  stats->sess_pipe_overflow);
-		/* Sessions queued for thread */
-		varnish_submit_derive (conf->instance, "session", "total_operations", "queued",    stats->sess_queued);
-#else
 		/* Session Linger     */
 		varnish_submit_derive (conf->instance, "session", "total_operations", "linger",    stats->sess_linger);
-#endif
 		/* Session herd       */
 		varnish_submit_derive (conf->instance, "session", "total_operations", "herd",      stats->sess_herd);
 	}
 
 	if (conf->collect_shm)
 	{
@@ -381,13 +676,12 @@
 		/* SHM MTX contention          */
 		varnish_submit_derive (conf->instance, "shm", "total_operations", "contention", stats->shm_cont);
 		/* SHM cycles through buffer   */
 		varnish_submit_derive (conf->instance, "shm", "total_operations", "cycles"    , stats->shm_cycles);
 	}
 
-#if HAVE_VARNISH_V2
 	if (conf->collect_sm)
 	{
 		/* allocator requests */
 		varnish_submit_derive (conf->instance, "sm", "total_requests", "nreq",         stats->sm_nreq);
 		/* outstanding allocations */
 		varnish_submit_gauge (conf->instance,  "sm", "requests", "outstanding",        stats->sm_nobj);
@@ -407,13 +701,12 @@
 		varnish_submit_gauge (conf->instance,  "sma", "bytes", "outstanding",      stats->sma_nbytes);
 		/* SMA bytes allocated */
 		varnish_submit_derive (conf->instance,  "sma", "total_bytes", "allocated", stats->sma_balloc);
 		/* SMA bytes free */
 		varnish_submit_derive (conf->instance,  "sma", "total_bytes", "free" ,     stats->sma_bfree);
 	}
-#endif
 
 	if (conf->collect_sms)
 	{
 		/* SMS allocator requests */
 		varnish_submit_derive (conf->instance, "sms", "total_requests", "allocator", stats->sms_nreq);
 		/* SMS outstanding allocations */
@@ -425,40 +718,28 @@
 		/* SMS bytes freed */
 		varnish_submit_derive (conf->instance,  "sms", "total_bytes", "free",        stats->sms_bfree);
 	}
 
 	if (conf->collect_struct)
 	{
-#if !HAVE_VARNISH_V4
 		/* N struct sess_mem       */
 		varnish_submit_gauge (conf->instance, "struct", "current_sessions", "sess_mem",  stats->n_sess_mem);
 		/* N struct sess           */
 		varnish_submit_gauge (conf->instance, "struct", "current_sessions", "sess",      stats->n_sess);
-#endif
 		/* N struct object         */
 		varnish_submit_gauge (conf->instance, "struct", "objects", "object",             stats->n_object);
-#if HAVE_VARNISH_V3 || HAVE_VARNISH_V4
-		/* N unresurrected objects */
-		varnish_submit_gauge (conf->instance, "struct", "objects", "vampireobject",      stats->n_vampireobject);
-		/* N struct objectcore     */
-		varnish_submit_gauge (conf->instance, "struct", "objects", "objectcore",         stats->n_objectcore);
-		/* N struct waitinglist    */
-		varnish_submit_gauge (conf->instance, "struct", "objects", "waitinglist",        stats->n_waitinglist);
-#endif
 		/* N struct objecthead     */
 		varnish_submit_gauge (conf->instance, "struct", "objects", "objecthead",         stats->n_objecthead);
-#ifdef HAVE_VARNISH_V2
 		/* N struct smf            */
 		varnish_submit_gauge (conf->instance, "struct", "objects", "smf",                stats->n_smf);
 		/* N small free smf         */
 		varnish_submit_gauge (conf->instance, "struct", "objects", "smf_frag",           stats->n_smf_frag);
 		/* N large free smf         */
 		varnish_submit_gauge (conf->instance, "struct", "objects", "smf_large",          stats->n_smf_large);
 		/* N struct vbe_conn        */
 		varnish_submit_gauge (conf->instance, "struct", "objects", "vbe_conn",           stats->n_vbe_conn);
-#endif
 	}
 
 	if (conf->collect_totals)
 	{
 		/* Total Sessions */
 		varnish_submit_derive (conf->instance, "totals", "total_sessions", "sessions",  stats->s_sess);
@@ -467,124 +748,48 @@
 		/* Total pipe */
 		varnish_submit_derive (conf->instance, "totals", "total_operations", "pipe",    stats->s_pipe);
 		/* Total pass */
 		varnish_submit_derive (conf->instance, "totals", "total_operations", "pass",    stats->s_pass);
 		/* Total fetch */
 		varnish_submit_derive (conf->instance, "totals", "total_operations", "fetches", stats->s_fetch);
-#if HAVE_VARNISH_V4
-		/* Total synth */
-		varnish_submit_derive (conf->instance, "totals", "total_bytes", "synth",       stats->s_synth);
-		/* Request header bytes */
-		varnish_submit_derive (conf->instance, "totals", "total_bytes", "req_header",  stats->s_req_hdrbytes);
-		/* Request body byte */
-		varnish_submit_derive (conf->instance, "totals", "total_bytes", "req_body",    stats->s_req_bodybytes);
-		/* Response header bytes */
-		varnish_submit_derive (conf->instance, "totals", "total_bytes", "resp_header", stats->s_resp_hdrbytes);
-		/* Response body byte */
-		varnish_submit_derive (conf->instance, "totals", "total_bytes", "resp_body",   stats->s_resp_bodybytes);
-		/* Pipe request header bytes */
-		varnish_submit_derive (conf->instance, "totals", "total_bytes", "pipe_header", stats->s_pipe_hdrbytes);
-		/* Piped bytes from client */
-		varnish_submit_derive (conf->instance, "totals", "total_bytes", "pipe_in",     stats->s_pipe_in);
-		/* Piped bytes to client */
-		varnish_submit_derive (conf->instance, "totals", "total_bytes", "pipe_out",    stats->s_pipe_out);
-		/* Number of purge operations */
-		varnish_submit_derive (conf->instance, "totals", "total_operations", "purges", stats->n_purges);
-#else
 		/* Total header bytes */
 		varnish_submit_derive (conf->instance, "totals", "total_bytes", "header-bytes", stats->s_hdrbytes);
 		/* Total body byte */
 		varnish_submit_derive (conf->instance, "totals", "total_bytes", "body-bytes",   stats->s_bodybytes);
-#endif
-#if HAVE_VARNISH_V3 || HAVE_VARNISH_V4
-		/* Gzip operations */
-		varnish_submit_derive (conf->instance, "totals", "total_operations", "gzip",    stats->n_gzip);
-		/* Gunzip operations */
-		varnish_submit_derive (conf->instance, "totals", "total_operations", "gunzip",  stats->n_gunzip);
-#endif
-	}
-
-#if HAVE_VARNISH_V3 || HAVE_VARNISH_V4
-	if (conf->collect_uptime)
-	{
-		/* Client uptime */
-		varnish_submit_gauge (conf->instance, "uptime", "uptime", "client_uptime", stats->uptime);
 	}
-#endif
 
 	if (conf->collect_vcl)
 	{
 		/* N vcl total     */
 		varnish_submit_gauge (conf->instance, "vcl", "vcl", "total_vcl",     stats->n_vcl);
 		/* N vcl available */
 		varnish_submit_gauge (conf->instance, "vcl", "vcl", "avail_vcl",     stats->n_vcl_avail);
 		/* N vcl discarded */
 		varnish_submit_gauge (conf->instance, "vcl", "vcl", "discarded_vcl", stats->n_vcl_discard);
-#if HAVE_VARNISH_V3 || HAVE_VARNISH_V4
-		/* Loaded VMODs */
-		varnish_submit_gauge (conf->instance, "vcl", "objects", "vmod",      stats->vmods);
-#endif
 	}
 
 	if (conf->collect_workers)
 	{
-#ifdef HAVE_VARNISH_V4
-		/* total number of threads */
-		varnish_submit_gauge (conf->instance, "workers", "threads", "worker",             stats->threads);
-		/* threads created */
-		varnish_submit_derive (conf->instance, "workers", "total_threads", "created",     stats->threads_created);
-		/* thread creation failed */
-		varnish_submit_derive (conf->instance, "workers", "total_threads", "failed",      stats->threads_failed);
-		/* threads hit max */
-		varnish_submit_derive (conf->instance, "workers", "total_threads", "limited",     stats->threads_limited);
-		/* threads destroyed */
-		varnish_submit_derive (conf->instance, "workers", "total_threads", "dropped",     stats->threads_destroyed);
-		/* length of session queue */
-		varnish_submit_derive (conf->instance, "workers", "queue_length",  "threads",     stats->thread_queue_len);
-#else
 		/* worker threads */
 		varnish_submit_gauge (conf->instance, "workers", "threads", "worker",             stats->n_wrk);
 		/* worker threads created */
 		varnish_submit_derive (conf->instance, "workers", "total_threads", "created",     stats->n_wrk_create);
 		/* worker threads not created */
 		varnish_submit_derive (conf->instance, "workers", "total_threads", "failed",      stats->n_wrk_failed);
 		/* worker threads limited */
 		varnish_submit_derive (conf->instance, "workers", "total_threads", "limited",     stats->n_wrk_max);
 		/* dropped work requests */
 		varnish_submit_derive (conf->instance, "workers", "total_threads", "dropped",     stats->n_wrk_drop);
-#ifdef HAVE_VARNISH_V2
 		/* queued work requests */
 		varnish_submit_derive (conf->instance, "workers", "total_requests", "queued",     stats->n_wrk_queue);
 		/* overflowed work requests */
 		varnish_submit_derive (conf->instance, "workers", "total_requests", "overflowed", stats->n_wrk_overflow);
-#else /* HAVE_VARNISH_V3 */
-		/* queued work requests */
-		varnish_submit_derive (conf->instance, "workers", "total_requests", "queued",       stats->n_wrk_queued);
-		/* work request queue length */
-		varnish_submit_derive (conf->instance, "workers", "total_requests", "queue_length", stats->n_wrk_lqueue);
-#endif
-#endif
-	}
-
-#if HAVE_VARNISH_V4
-	if (conf->collect_vsm)
-	{
-		/* Free VSM space */
-		varnish_submit_gauge (conf->instance, "vsm", "bytes", "free",              stats->vsm_free);
-		/* Used VSM space */
-		varnish_submit_gauge (conf->instance, "vsm", "bytes", "used",              stats->vsm_used);
-		/* Cooling VSM space */
-		varnish_submit_gauge (conf->instance, "vsm", "bytes", "cooling",           stats->vsm_cooling);
-		/* Overflow VSM space */
-		varnish_submit_gauge (conf->instance, "vsm", "bytes", "overflow",          stats->vsm_overflow);
-		/* Total overflowed VSM space */
-		varnish_submit_derive (conf->instance, "vsm", "total_bytes", "overflowed", stats->vsm_overflowed);
 	}
-#endif
 
 } /* }}} void varnish_monitor */
+#endif
 
 #if HAVE_VARNISH_V3 || HAVE_VARNISH_V4
 static int varnish_read (user_data_t *ud) /* {{{ */
 {
 	struct VSM_data *vd;
 	const c_varnish_stats_t *stats;
@@ -605,12 +810,13 @@
 	{
 		int status;
 
 		status = VSM_n_Arg (vd, conf->instance);
 		if (status < 0)
 		{
+			VSM_Delete (vd);
 			ERROR ("varnish plugin: VSM_n_Arg (\"%s\") failed "
 					"with status %i.",
 					conf->instance, status);
 			return (-1);
 		}
 	}
@@ -618,25 +824,37 @@
 #if HAVE_VARNISH_V3
 	if (VSC_Open (vd, /* diag = */ 1))
 #else /* if HAVE_VARNISH_V4 */
 	if (VSM_Open (vd))
 #endif
 	{
-		ERROR ("varnish plugin: Unable to load statistics.");
+		VSM_Delete (vd);
+		ERROR ("varnish plugin: Unable to open connection.");
 
 		return (-1);
 	}
 
 #if HAVE_VARNISH_V3
 	stats = VSC_Main(vd);
 #else /* if HAVE_VARNISH_V4 */
 	stats = VSC_Main(vd, NULL);
 #endif
+	if (!stats)
+	{
+		VSM_Delete (vd);
+		ERROR ("varnish plugin: Unable to get statistics.");
 
-	varnish_monitor (conf, stats);
-	VSM_Close (vd);
+		return (-1);
+	}
+
+#if HAVE_VARNISH_V3
+	VSC_Iter (vd, varnish_monitor, conf);
+#else /* if HAVE_VARNISH_V4 */
+	VSC_Iter (vd, NULL, varnish_monitor, conf);
+#endif
+	VSM_Delete (vd);
 
 	return (0);
 } /* }}} */
 #else /* if HAVE_VARNISH_V2 */
 static int varnish_read (user_data_t *ud) /* {{{ */
 {
@@ -779,12 +997,13 @@
 		}
 	}
 	else if (ci->values_num > 1)
 	{
 		WARNING ("Varnish plugin: \"Instance\" blocks accept only "
 				"one argument.");
+		sfree (conf);
 		return (EINVAL);
 	}
 
 	for (i = 0; i < ci->children_num; i++)
 	{
 		oconfig_item_t *child = ci->children + i;
@@ -886,12 +1105,13 @@
 #endif
 	)
 	{
 		WARNING ("Varnish plugin: No metric has been configured for "
 				"instance \"%s\". Disabling this instance.",
 				(conf->instance == NULL) ? "localhost" : conf->instance);
+		sfree (conf);
 		return (EINVAL);
 	}
 
 	ssnprintf (callback_name, sizeof (callback_name), "varnish/%s",
 			(conf->instance == NULL) ? "localhost" : conf->instance);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/virt.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/virt.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/virt.c	2015-03-10 22:14:45.857114762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/virt.c	2016-01-22 17:51:17.721918675 +0800
@@ -324,13 +324,13 @@
 
 static int
 lv_init (void)
 {
     if (virInitialize () != 0)
         return -1;
-
+    else
 	return 0;
 }
 
 static int
 lv_config (const char *key, const char *value)
 {
@@ -414,14 +414,14 @@
                 hostname_format[i] = hf_hostname;
             else if (strcasecmp (fields[i], "name") == 0)
                 hostname_format[i] = hf_name;
             else if (strcasecmp (fields[i], "uuid") == 0)
                 hostname_format[i] = hf_uuid;
             else {
-                sfree (value_copy);
                 ERROR (PLUGIN_NAME " plugin: unknown HostnameFormat field: %s", fields[i]);
+                sfree (value_copy);
                 return -1;
             }
         }
         sfree (value_copy);
 
         for (i = n; i < HF_MAX_FIELDS; ++i)
@@ -451,14 +451,14 @@
         for (i = 0; i < n; ++i) {
             if (strcasecmp (fields[i], "name") == 0)
                 plugin_instance_format[i] = plginst_name;
             else if (strcasecmp (fields[i], "uuid") == 0)
                 plugin_instance_format[i] = plginst_uuid;
             else {
+                ERROR (PLUGIN_NAME " plugin: unknown PluginInstanceFormat field: %s", fields[i]);
                 sfree (value_copy);
-                ERROR (PLUGIN_NAME " plugin: unknown HostnameFormat field: %s", fields[i]);
                 return -1;
             }
         }
         sfree (value_copy);
 
         for (i = n; i < PLGINST_MAX_FIELDS; ++i)
@@ -923,12 +923,15 @@
 add_interface_device (virDomainPtr dom, const char *path, const char *address, unsigned int number)
 {
     struct interface_device *new_ptr;
     int new_size = sizeof (interface_devices[0]) * (nr_interface_devices+1);
     char *path_copy, *address_copy, number_string[15];
 
+    if ((path == NULL) || (address == NULL))
+        return EINVAL;
+
     path_copy = strdup (path);
     if (!path_copy) return -1;
 
     address_copy = strdup (address);
     if (!address_copy) {
         sfree(path_copy);
@@ -958,12 +961,15 @@
 static int
 ignore_device_match (ignorelist_t *il, const char *domname, const char *devpath)
 {
     char *name;
     int n, r;
 
+    if ((domname == NULL) || (devpath == NULL))
+        return 0;
+
     n = sizeof (char) * (strlen (domname) + strlen (devpath) + 2);
     name = malloc (n);
     if (name == NULL) {
         ERROR (PLUGIN_NAME " plugin: malloc failed.");
         return 0;
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/vmem.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/vmem.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/vmem.c	2015-03-10 22:14:45.857114762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/vmem.c	2016-01-22 17:51:17.721918675 +0800
@@ -152,14 +152,22 @@
      *
      * The total number of {inst} pages, e. g dirty pages.
      */
     if (strncmp ("nr_", key, strlen ("nr_")) == 0)
     {
       char *inst = key + strlen ("nr_");
-      value_t value = { .gauge = gauge };
-      submit_one (NULL, "vmpage_number", inst, value);
+      if (strcmp(inst, "dirtied") == 0 || strcmp(inst, "written") == 0)
+      {
+        value_t value = { .derive = counter };
+        submit_one (NULL, "vmpage_action", inst, value);
+      }
+      else
+      {
+        value_t value = { .gauge = gauge };
+        submit_one (NULL, "vmpage_number", inst, value);
+      }
     }
 
     /* 
      * Page in and page outs. For memory and swap.
      */
     else if (strcmp ("pgpgin", key) == 0)
@@ -216,12 +224,25 @@
     else if (strncmp ("pgrefill_", key, strlen ("pgrefill_")) == 0)
     {
       char *inst = key + strlen ("pgrefill_");
       value_t value  = { .derive = counter };
       submit_one (inst, "vmpage_action", "refill", value);
     }
+    else if (strncmp ("pgsteal_kswapd_", key, strlen ("pgsteal_kswapd_")) == 0)
+    {
+      char *inst = key + strlen ("pgsteal_kswapd_");
+      value_t value  = { .derive = counter };
+      submit_one (inst, "vmpage_action", "steal_kswapd", value);
+    }
+    else if (strncmp ("pgsteal_direct_", key, strlen ("pgsteal_direct_")) == 0)
+    {
+      char *inst = key + strlen ("pgsteal_direct_");
+      value_t value  = { .derive = counter };
+      submit_one (inst, "vmpage_action", "steal_direct", value);
+    }
+    /* For backwards compatibility (somewhen before 4.2.3) */
     else if (strncmp ("pgsteal_", key, strlen ("pgsteal_")) == 0)
     {
       char *inst = key + strlen ("pgsteal_");
       value_t value  = { .derive = counter };
       submit_one (inst, "vmpage_action", "steal", value);
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_graphite.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_graphite.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_graphite.c	2015-03-10 22:14:45.857114762 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_graphite.c	2016-01-22 17:51:17.721918675 +0800
@@ -129,13 +129,13 @@
 
 static int wg_send_buffer (struct wg_callback *cb)
 {
     ssize_t status = 0;
 
     status = swrite (cb->sock_fd, cb->send_buf, strlen (cb->send_buf));
-    if (status < 0)
+    if (status != 0)
     {
         const char *protocol = cb->protocol ? cb->protocol : WG_DEFAULT_PROTOCOL;
 
         if (cb->log_send_errors)
         {
             char errbuf[1024];
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_kafka.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_kafka.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_kafka.c	2015-05-20 20:04:47.191035542 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_kafka.c	2016-01-22 17:51:17.721918675 +0800
@@ -31,31 +31,31 @@
 #include "utils_cache.h"
 #include "utils_cmd_putval.h"
 #include "utils_format_graphite.h"
 #include "utils_format_json.h"
 #include "utils_crc32.h"
 
-#include <sys/types.h>
+#include <stdint.h>
 #include <librdkafka/rdkafka.h>
 #include <pthread.h>
 #include <zlib.h>
 #include <errno.h>
 
 struct kafka_topic_context {
 #define KAFKA_FORMAT_JSON        0
 #define KAFKA_FORMAT_COMMAND     1
 #define KAFKA_FORMAT_GRAPHITE    2
-    u_int8_t                     format;
+    uint8_t                     format;
     unsigned int                 graphite_flags;
     _Bool                        store_rates;
     rd_kafka_topic_conf_t       *conf;
     rd_kafka_topic_t            *topic;
     rd_kafka_conf_t             *kafka_conf;
     rd_kafka_t                  *kafka;
     int                          has_key;
-    u_int32_t                    key;
+    uint32_t                    key;
     char                        *prefix;
     char                        *postfix;
     char                         escape_char;
     char                        *topic_name;
     pthread_mutex_t 		lock;
 };
@@ -76,14 +76,14 @@
 #endif
 
 static int32_t kafka_partition(const rd_kafka_topic_t *rkt,
                                const void *keydata, size_t keylen,
                                int32_t partition_cnt, void *p, void *m)
 {
-    u_int32_t key = *((u_int32_t *)keydata );
-    u_int32_t target = key % partition_cnt;
+    uint32_t key = *((uint32_t *)keydata );
+    uint32_t target = key % partition_cnt;
     int32_t   i = partition_cnt;
 
     while (--i > 0 && !rd_kafka_topic_partition_available(rkt, target)) {
         target = (target + 1) % partition_cnt;
     }
     return target;
@@ -145,13 +145,13 @@
 
 static int kafka_write(const data_set_t *ds, /* {{{ */
 	      const value_list_t *vl,
 	      user_data_t *ud)
 {
 	int			 status = 0;
-    u_int32_t    key;
+    uint32_t    key;
     char         buffer[8192];
     size_t bfree = sizeof(buffer);
     size_t bfill = 0;
     size_t blen = 0;
 	struct kafka_topic_context	*ctx = ud->data;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_redis.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_redis.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_redis.c	2015-05-27 02:40:18.593715038 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_redis.c	2016-01-22 17:51:17.721918675 +0800
@@ -59,55 +59,25 @@
   char value[512];
   char time[24];
   size_t value_size;
   char *value_ptr;
   int status;
   redisReply   *rr;
-  int i;
 
   status = FORMAT_VL (ident, sizeof (ident), vl);
   if (status != 0)
     return (status);
   ssnprintf (key, sizeof (key), "collectd/%s", ident);
   ssnprintf (time, sizeof (time), "%.9f", CDTIME_T_TO_DOUBLE(vl->time));
 
   memset (value, 0, sizeof (value));
   value_size = sizeof (value);
   value_ptr = &value[0];
-
-#define APPEND(...) do {                                             \
-  status = snprintf (value_ptr, value_size, __VA_ARGS__);            \
-  if (((size_t) status) > value_size)                                \
-  {                                                                  \
-    value_ptr += value_size;                                         \
-    value_size = 0;                                                  \
-  }                                                                  \
-  else                                                               \
-  {                                                                  \
-    value_ptr += status;                                             \
-    value_size -= status;                                            \
-  }                                                                  \
-} while (0)
-
-  APPEND ("%s:", time);
-
-  for (i = 0; i < ds->ds_num; i++)
-  {
-    if (ds->ds[i].type == DS_TYPE_COUNTER)
-      APPEND ("%llu", vl->values[i].counter);
-    else if (ds->ds[i].type == DS_TYPE_GAUGE)
-      APPEND (GAUGE_FORMAT, vl->values[i].gauge);
-    else if (ds->ds[i].type == DS_TYPE_DERIVE)
-      APPEND ("%"PRIi64, vl->values[i].derive);
-    else if (ds->ds[i].type == DS_TYPE_ABSOLUTE)
-      APPEND ("%"PRIu64, vl->values[i].absolute);
-    else
-      assert (23 == 42);
-  }
-
-#undef APPEND
+  status = format_values (value_ptr, value_size, ds, vl, /* store rates = */ 0);
+  if (status != 0)
+    return (status);
 
   pthread_mutex_lock (&node->lock);
 
   if (node->conn == NULL)
   {
     node->conn = redisConnectWithTimeout ((char *)node->host, node->port, node->timeout);
@@ -128,18 +98,25 @@
       pthread_mutex_unlock (&node->lock);
       return (-1);
     }
   }
 
   rr = redisCommand (node->conn, "ZADD %s %s %s", key, time, value);
-  if (rr==NULL)
+  if (rr == NULL)
     WARNING("ZADD command error. key:%s message:%s", key, node->conn->errstr);
+  else
+    freeReplyObject (rr);
 
+  /* TODO(octo): This is more overhead than necessary. Use the cache and
+   * metadata to determine if it is a new metric and call SADD only once for
+   * each metric. */
   rr = redisCommand (node->conn, "SADD collectd/values %s", ident);
   if (rr==NULL)
     WARNING("SADD command error. ident:%s message:%s", ident, node->conn->errstr);
+  else
+    freeReplyObject (rr);
 
   pthread_mutex_unlock (&node->lock);
 
   return (0);
 } /* }}} int wr_write */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_riemann.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_riemann.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_riemann.c	2015-03-10 22:14:45.861114849 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_riemann.c	2016-01-22 17:51:17.721918675 +0800
@@ -1048,12 +1048,13 @@
 			if ((key = strdup(child->values[0].value.string)) == NULL) {
 				WARNING("cannot allocate memory for attribute key.");
 				return (-1);
 			}
 			if ((val = strdup(child->values[1].value.string)) == NULL) {
 				WARNING("cannot allocate memory for attribute value.");
+				sfree (key);
 				return (-1);
 			}
 			strarray_add(&riemann_attrs, &riemann_attrs_num, key);
 			strarray_add(&riemann_attrs, &riemann_attrs_num, val);
 			DEBUG("write_riemann: got attr: %s => %s", key, val);
 			sfree(key);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_sensu.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_sensu.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_sensu.c	2015-05-22 18:04:36.951771009 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_sensu.c	2016-01-22 17:51:17.721918675 +0800
@@ -110,14 +110,14 @@
 	char			*service;
 	int              s;
 	struct addrinfo *res;
 	int			     reference_count;
 };
 
-static char	*sensu_tags;
-static char	**sensu_attrs;
+static char	*sensu_tags = NULL;
+static char	**sensu_attrs = NULL;
 static size_t sensu_attrs_num;
 
 static int add_str_to_list(struct str_list *strs,
 		const char *str_to_add) /* {{{ */
 {
 	char **old_strs_ptr = strs->strs;
@@ -555,13 +555,13 @@
 		const char *new)
 {
 	char *ret, *r;
 	const char *p, *q;
 	size_t oldlen = strlen(old);
 	size_t count = strlen(new);
-	size_t retlen = count;
+	size_t retlen;
 	size_t newlen = count;
 	int samesize = (oldlen == newlen);
 
 	if (!samesize) {
 		for (count = 0, p = str; (q = strstr(p, old)) != NULL; p = q + oldlen)
 			count++;
@@ -677,12 +677,13 @@
 	}
 	ret_str = temp_str;
 
 	char *handlers_str = build_json_str_list("handlers", &(host->notification_handlers));
 	if (handlers_str == NULL) {
 		ERROR("write_sensu plugin: Unable to alloc memory");
+		free(ret_str);
 		return NULL;
 	}
 	// incorporate the handlers
 	if (strlen(handlers_str) != 0) {
 		res = asprintf(&temp_str, "%s, %s", ret_str, handlers_str);
 		free(ret_str);
@@ -778,12 +779,13 @@
 
 	// incorporate the check output
 	if (n->message[0] != 0) {
 		char *msg = replace_json_reserved(n->message);
 		if (msg == NULL) {
 			ERROR("write_sensu plugin: Unable to alloc memory");
+			free(ret_str);
 			return NULL;
 		}
 		res = asprintf(&temp_str, "%s, \"output\": \"%s - %s\"", ret_str, severity, msg);
 		free(ret_str);
 		free(msg);
 		if (res == -1) {
@@ -1157,55 +1159,35 @@
 	oconfig_item_t	*child;
 	int		 status;
 	struct str_list sensu_tags_arr;
 
 	sensu_tags_arr.nb_strs = 0;
 	sensu_tags_arr.strs = NULL;
-	sensu_tags = malloc(sizeof(char));
-	if (sensu_tags == NULL) {
-		ERROR("write_sensu plugin: Unable to alloc memory");
-		return -1;
-	}
-	sensu_tags[0] = '\0';
 
 	for (i = 0; i < ci->children_num; i++)  {
 		child = &ci->children[i];
 
 		if (strcasecmp("Node", child->key) == 0) {
 			sensu_config_node(child);
 		} else if (strcasecmp(child->key, "attribute") == 0) {
-			char *key = NULL;
-			char *val = NULL;
-
 			if (child->values_num != 2) {
 				WARNING("sensu attributes need both a key and a value.");
-				free(sensu_tags);
-				return -1;
+				continue;
 			}
 			if (child->values[0].type != OCONFIG_TYPE_STRING ||
-			    child->values[1].type != OCONFIG_TYPE_STRING) {
+					child->values[1].type != OCONFIG_TYPE_STRING) {
 				WARNING("sensu attribute needs string arguments.");
-				free(sensu_tags);
-				return -1;
-			}
-			if ((key = strdup(child->values[0].value.string)) == NULL) {
-				ERROR("write_sensu plugin: Unable to alloc memory");
-				free(sensu_tags);
-				return -1;
-			}
-			if ((val = strdup(child->values[1].value.string)) == NULL) {
-				free(sensu_tags);
-				free(key);
-				ERROR("write_sensu plugin: Unable to alloc memory");
-				return -1;
+				continue;
 			}
-			strarray_add(&sensu_attrs, &sensu_attrs_num, key);
-			strarray_add(&sensu_attrs, &sensu_attrs_num, val);
-			DEBUG("write_sensu: got attr: %s => %s", key, val);
-			sfree(key);
-			sfree(val);
+
+			strarray_add(&sensu_attrs, &sensu_attrs_num, child->values[0].value.string);
+			strarray_add(&sensu_attrs, &sensu_attrs_num, child->values[1].value.string);
+
+			DEBUG("write_sensu plugin: New attribute: %s => %s",
+					child->values[0].value.string,
+					child->values[1].value.string);
 		} else if (strcasecmp(child->key, "tag") == 0) {
 			char *tmp = NULL;
 			status = cf_util_get_string(child, &tmp);
 			if (status != 0)
 				continue;
 
@@ -1218,13 +1200,13 @@
 			WARNING("write_sensu plugin: Ignoring unknown "
 				 "configuration option \"%s\" at top level.",
 				 child->key);
 		}
 	}
 	if (sensu_tags_arr.nb_strs > 0) {
-		free(sensu_tags);
+		sfree (sensu_tags);
 		sensu_tags = build_json_str_list("tags", &sensu_tags_arr);
 		free_str_list(&sensu_tags_arr);
 		if (sensu_tags == NULL) {
 			ERROR("write_sensu plugin: Unable to alloc memory");
 			return -1;
 		}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_tsdb.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_tsdb.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/write_tsdb.c	2015-05-22 18:04:36.951771009 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/write_tsdb.c	2016-01-22 17:51:17.721918675 +0800
@@ -209,13 +209,12 @@
     if (cb->sock_fd < 0)
     {
         char errbuf[1024];
         ERROR("write_tsdb plugin: Connecting to %s:%s failed. "
               "The last error was: %s", node, service,
               sstrerror (errno, errbuf, sizeof(errbuf)));
-        close(cb->sock_fd);
         return -1;
     }
 
     wt_reset_buffer(cb);
 
     return 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/zfs_arc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/zfs_arc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/zfs_arc.c	2015-05-20 20:04:47.191035542 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/zfs_arc.c	2016-01-22 17:51:17.721918675 +0800
@@ -183,13 +183,13 @@
 	if (ksp == NULL)
 	{
 		ERROR ("zfs_arc plugin: `llist_create' failed.");
 		return (-1);
 	}
 
-	len = read_file_contents (ZOL_ARCSTATS_FILE, file_contents, sizeof(file_contents));
+	len = read_file_contents (ZOL_ARCSTATS_FILE, file_contents, sizeof(file_contents) - 1);
 	if (len > 1)
 	{
 
 		int i=0;
 		char *pnl = file_contents;
 		char *pnnl;
@@ -205,12 +205,18 @@
 		}
 
 		if (i > 0)
 		{
 			llentry_t *e;
 			llvalues = malloc(sizeof(long long int) * i);
+			if (llvalues == NULL)
+			{
+				ERROR ("zfs_arc plugin: `malloc' failed.");
+				llist_destroy (ksp);
+				return (-1);
+			}
 			int j = 0;
 
 			pnl = file_contents;
 			while (pnl != NULL)
 			{
 				pnnl = strchr(pnl, '\n');
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/zookeeper.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/zookeeper.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/src/zookeeper.c	2015-03-10 22:14:45.861114849 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/src/zookeeper.c	2016-01-22 17:51:17.721918675 +0800
@@ -196,17 +196,12 @@
 				   sstrerror (errno, errbuf, sizeof (errbuf)));
 			close (sk);
 			return (-1);
 		}
 
 		buffer_fill += (size_t) status;
-		if (status == 0)
-		{
-			/* done reading from the socket */
-			break;
-		}
 	} /* while (recv) */
 
 	status = 0;
 	if (buffer_fill == 0)
 	{
 		WARNING ("zookeeper: No data returned by MNTR command.");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/version-gen.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/version-gen.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.0/version-gen.sh	2015-05-27 04:23:28.891814238 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/collectd/repos/collectd-5.5.1/version-gen.sh	2016-01-22 17:51:17.721918675 +0800
@@ -1,9 +1,9 @@
 #!/bin/sh
 
-DEFAULT_VERSION="5.5.0.git"
+DEFAULT_VERSION="5.5.1.git"
 
 VERSION="`git describe 2> /dev/null | grep collectd | sed -e 's/^collectd-//'`"
 
 if test -z "$VERSION"; then
 	VERSION="$DEFAULT_VERSION"
 fi
