diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/configure	2007-08-02 05:50:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/configure	2007-08-14 01:54:41.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.60 for rtorrent 0.7.6.
+# Generated by GNU Autoconf 2.60 for rtorrent 0.7.7.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
@@ -710,14 +710,14 @@
 MAKEFLAGS=
 SHELL=${CONFIG_SHELL-/bin/sh}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.7.6'
-PACKAGE_STRING='rtorrent 0.7.6'
+PACKAGE_VERSION='0.7.7'
+PACKAGE_STRING='rtorrent 0.7.7'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #if HAVE_SYS_TYPES_H
@@ -1375,13 +1375,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.7.6 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.7.7 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1445,13 +1445,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.7.6:";;
+     short | recursive ) echo "Configuration of rtorrent 0.7.7:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
@@ -1562,13 +1562,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.7.6
+rtorrent configure 0.7.7
 generated by GNU Autoconf 2.60
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
@@ -1576,13 +1576,13 @@
   exit
 fi
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.7.6, which was
+It was created by rtorrent $as_me 0.7.7, which was
 generated by GNU Autoconf 2.60.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 exec 5>>config.log
@@ -2247,13 +2247,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.7.6'
+ VERSION='0.7.7'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -22479,13 +22479,13 @@
       { echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6; }
 
     else
       if eval xmlrpc-c-config --version 2>/dev/null >/dev/null; then
         CXXFLAGS="$CXXFLAGS `xmlrpc-c-config --cflags server-util`"
-        LIBS="$LIBS `xmlrpc-c-config --libs server-util` -lxmlrpc_server"
+        LIBS="$LIBS `xmlrpc-c-config server-util --libs`"
 
         cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
@@ -23080,13 +23080,13 @@
 exec 6>&1
 
 # Save the log message, to keep $[0] and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by rtorrent $as_me 0.7.6, which was
+This file was extended by rtorrent $as_me 0.7.7, which was
 generated by GNU Autoconf 2.60.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -23133,13 +23133,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.7.6
+rtorrent config.status 0.7.7
 configured by $0, generated by GNU Autoconf 2.60,
   with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2006 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/configure.ac	2007-08-02 05:46:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/configure.ac	2007-08-07 04:19:11.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.7.6, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.7.7, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 TORRENT_CHECK_CXXFLAGS()
 TORRENT_ENABLE_DEBUG()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/rak/error_number.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/error_number.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/rak/error_number.h	2007-07-20 05:23:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/error_number.h	2007-08-16 22:00:23.000000000 +0800
@@ -60,13 +60,13 @@
   error_number() : m_errno(0) {}
   error_number(int e) : m_errno(e) {}
 
   bool                is_valid() const             { return m_errno != 0; }
 
   int                 value() const                { return m_errno; }
-  const char*         c_str() const                { return strerror(m_errno); }
+  const char*         c_str() const                { return std::strerror(m_errno); }
 
   bool                is_blocked_momentary() const { return m_errno == e_again || m_errno == e_intr; }
   bool                is_blocked_prolonged() const { return m_errno == e_deadlk; }
 
   bool                is_closed() const            { return m_errno == e_connreset || m_errno == e_connaborted; }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/rak/path.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/path.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/rak/path.h	2007-07-20 05:23:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/path.h	2007-08-11 19:45:54.000000000 +0800
@@ -55,9 +55,53 @@
   if (home == NULL)
     return path;
   
   return home + path.substr(1);
 }
 
+// Don't inline this...
+//
+// Same strlcpy as found in *bsd.
+inline size_t
+strlcpy(char *dest, const char *src, size_t size) {
+  size_t n = size;
+  const char* first = src;
+
+  if (n != 0) {
+    while (--n != 0)
+      if ((*dest++ = *src++) == '\0')
+        break;
+  }
+
+  if (n == 0) {
+    if (size != 0)
+      *dest = '\0';
+    
+    while (*src++)
+      ;
+  }
+
+  return src - first - 1;
+}
+
+inline char*
+path_expand(const char* src, char* first, char* last) {
+  if (*src == '~') {
+    char* home = std::getenv("HOME");
+
+    if (home == NULL)
+      return first;
+
+    first += strlcpy(first, home, std::distance(first, last));
+
+    if (first > last)
+      return last;
+
+    src++;
+  }
+
+  return std::min(first + strlcpy(first, src, std::distance(first, last)), last);
+}
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/rak/timer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/timer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/rak/timer.h	2007-07-20 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/timer.h	2007-08-16 22:11:08.000000000 +0800
@@ -52,13 +52,18 @@
 
   int32_t             seconds() const                    { return m_time / 1000000; }
   int64_t             usec() const                       { return m_time; }
 
   timer               round_seconds() const              { return (m_time / 1000000) * 1000000; }
 
-  timeval             tval() const                       { return (timeval) { m_time / 1000000, m_time % 1000000}; }
+  timeval             tval() const {
+    timeval val;
+    val.tv_sec  = m_time / 1000000;
+    val.tv_usec = m_time % 1000000;
+    return val;
+  }
 
   static timer        current();
   static timer        from_seconds(uint32_t seconds)      { return rak::timer((uint64_t)seconds * 1000000); }
   static timer        from_milliseconds(uint32_t seconds) { return rak::timer((uint64_t)seconds * 1000); }
 
   static timer        max()                              { return std::numeric_limits<int64_t>::max(); }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/scripts/checks.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/scripts/checks.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/scripts/checks.m4	2007-05-27 05:57:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/scripts/checks.m4	2007-08-14 01:53:52.000000000 +0800
@@ -346,13 +346,13 @@
     if test "$withval" = "no"; then
       AC_MSG_RESULT(no)
 
     else
       if eval xmlrpc-c-config --version 2>/dev/null >/dev/null; then
         CXXFLAGS="$CXXFLAGS `xmlrpc-c-config --cflags server-util`"
-        LIBS="$LIBS `xmlrpc-c-config --libs server-util` -lxmlrpc_server"
+        LIBS="$LIBS `xmlrpc-c-config server-util --libs`"
 
         AC_TRY_LINK(
         [ #include <xmlrpc-c/server.h>
         ],[ xmlrpc_registry_new(NULL); ],
         [
           AC_MSG_RESULT(ok)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_download.cc	2007-08-02 05:36:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_download.cc	2007-08-13 02:25:16.000000000 +0800
@@ -97,27 +97,27 @@
     throw torrent::input_error("Invalid arguments.");
 
   std::string target;
   std::string link;
 
   if (type == "base_path") {
-    target = rpc::call_command_d_string("get_d_base_path", download);
-    link = rak::path_expand(prefix + rpc::call_command_d_string("get_d_base_path", download) + postfix);
+    target = rpc::call_command_d_string("d.get_base_path", download);
+    link = rak::path_expand(prefix + rpc::call_command_d_string("d.get_base_path", download) + postfix);
 
   } else if (type == "base_filename") {
-    target = rpc::call_command_d_string("get_d_base_path", download);
-    link = rak::path_expand(prefix + rpc::call_command_d_string("get_d_base_filename", download) + postfix);
+    target = rpc::call_command_d_string("d.get_base_path", download);
+    link = rak::path_expand(prefix + rpc::call_command_d_string("d.get_base_filename", download) + postfix);
 
   } else if (type == "tied") {
-    link = rak::path_expand(rpc::call_command_d_string("get_d_tied_to_file", download));
+    link = rak::path_expand(rpc::call_command_d_string("d.get_tied_to_file", download));
 
     if (link.empty())
       return torrent::Object();
 
     link = rak::path_expand(prefix + link + postfix);
-    target = rpc::call_command_d_string("get_d_base_path", download);
+    target = rpc::call_command_d_string("d.get_base_path", download);
 
   } else {
     throw torrent::input_error("Unknown type argument.");
   }
 
   switch (changeType) {
@@ -145,21 +145,21 @@
 
   return torrent::Object();
 }
 
 void
 apply_d_delete_tied(core::Download* download) {
-  const std::string& tie = rpc::call_command_d_string("get_d_tied_to_file", download);
+  const std::string& tie = rpc::call_command_d_string("d.get_tied_to_file", download);
 
   if (tie.empty())
     return;
 
   if (::unlink(rak::path_expand(tie).c_str()) == -1)
     control->core()->push_log_std("Could not unlink tied file: " + std::string(rak::error_number::current().c_str()));
 
-  rpc::call_command_d("set_d_tied_to_file", download, std::string());
+  rpc::call_command_d("d.set_tied_to_file", download, std::string());
 }
 
 void
 apply_d_connection_type(core::Download* download, const std::string& name) {
   torrent::Download::ConnectionType connType;
 
@@ -200,12 +200,15 @@
     throw torrent::input_error("Priority out of range.");
   }
 }
 
 torrent::Object
 apply_d_ratio(core::Download* download) {
+  if (download->is_hash_checking())
+    return int64_t();
+
   int64_t bytesDone = download->download()->bytes_done();
   int64_t upTotal   = download->download()->up_rate()->total();
 
   return bytesDone > 0 ? (1000 * upTotal) / bytesDone : 0;
 }
 
@@ -215,54 +218,54 @@
 
 #define ADD_CD_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandDownloadSlotsItr->set_slot(slot); \
   rpc::commands.insert_download(key, commandDownloadSlotsItr++, &rpc::CommandDownloadSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CD_VOID(key, slot) \
-  ADD_CD_SLOT_PUBLIC("get_d_" key, call_unknown, rpc::object_d_fn(slot), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_d_fn(slot), "i:", "")
 
 #define ADD_CD_V_VOID(key, slot) \
-  ADD_CD_SLOT_PUBLIC("d_" key, call_unknown, rpc::object_d_fn(slot), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d." key, call_unknown, rpc::object_d_fn(slot), "i:", "")
 
 #define ADD_CD_F_VOID(key, slot) \
-  ADD_CD_SLOT_PUBLIC("d_" key, call_unknown, rpc::object_void_d_fn(slot), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d." key, call_unknown, rpc::object_void_d_fn(slot), "i:", "")
 
 #define ADD_CD_LIST(key, slot) \
   ADD_CD_SLOT_PUBLIC(key, call_list, slot, "i:", "")
 
 #define ADD_CD_VARIABLE_VALUE(key, firstKey, secondKey) \
-  ADD_CD_SLOT_PUBLIC("get_d_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
-  ADD_CD_SLOT("set_d_" key, call_value,   rpc::set_variable_d_fn(firstKey, secondKey), "i:i", "");
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
+  ADD_CD_SLOT("d.set_" key, call_value,   rpc::set_variable_d_fn(firstKey, secondKey), "i:i", "");
 
 #define ADD_CD_VARIABLE_VALUE_PUBLIC(key, firstKey, secondKey) \
-  ADD_CD_SLOT_PUBLIC("get_d_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
-  ADD_CD_SLOT_PUBLIC("set_d_" key, call_value,   rpc::set_variable_d_fn(firstKey, secondKey), "i:i", "");
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
+  ADD_CD_SLOT_PUBLIC("d.set_" key, call_value,   rpc::set_variable_d_fn(firstKey, secondKey), "i:i", "");
 
 #define ADD_CD_VARIABLE_STRING(key, firstKey, secondKey) \
-  ADD_CD_SLOT_PUBLIC("get_d_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
-  ADD_CD_SLOT("set_d_" key, call_string,  rpc::set_variable_d_fn(firstKey, secondKey), "i:s", "");
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
+  ADD_CD_SLOT("d.set_" key, call_string,  rpc::set_variable_d_fn(firstKey, secondKey), "i:s", "");
 
 #define ADD_CD_VALUE_UNI(key, get) \
-  ADD_CD_SLOT_PUBLIC("get_d_" key, call_unknown, rpc::object_void_d_fn(get), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(get), "i:", "")
 
 #define ADD_CD_VALUE_BI(key, set, get) \
-  ADD_CD_SLOT_PUBLIC("set_d_" key, call_value, rpc::object_value_d_fn(set), "i:i", "") \
-  ADD_CD_SLOT_PUBLIC("get_d_" key, call_unknown, rpc::object_void_d_fn(get), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d.set_" key, call_value, rpc::object_value_d_fn(set), "i:i", "") \
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(get), "i:", "")
 
 #define ADD_CD_VALUE_MEM_BI(key, target, set, get) \
   ADD_CD_VALUE_BI(key, rak::on2(std::mem_fun(target), std::mem_fun(set)), rak::on(std::mem_fun(target), std::mem_fun(get)));
 
 #define ADD_CD_VALUE_MEM_UNI(key, target, get) \
-  ADD_CD_SLOT_PUBLIC("get_d_" key, call_unknown, rpc::object_void_d_fn(rak::on(rak::on(std::mem_fun(&core::Download::download), std::mem_fun(target)), std::mem_fun(get))), "i:", "");
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(rak::on(rak::on(std::mem_fun(&core::Download::download), std::mem_fun(target)), std::mem_fun(get))), "i:", "");
 
 #define ADD_CD_STRING_UNI(key, get) \
-  ADD_CD_SLOT_PUBLIC("get_d_" key, call_unknown, rpc::object_void_d_fn(get), "s:", "")
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(get), "s:", "")
 
 #define ADD_CD_STRING_BI(key, set, get) \
-  ADD_CD_SLOT_PUBLIC("set_d_" key, call_string, rpc::object_string_d_fn(set), "i:s", "") \
-  ADD_CD_SLOT_PUBLIC("get_d_" key, call_unknown, rpc::object_void_d_fn(get), "s:", "")
+  ADD_CD_SLOT_PUBLIC("d.set_" key, call_string, rpc::object_string_d_fn(set), "i:s", "") \
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(get), "s:", "")
 
 void
 add_copy_to_download(const char* src, const char* dest) {
   rpc::CommandMap::iterator itr = rpc::commands.find(src);
 
   if (itr == rpc::commands.end())
@@ -318,16 +321,16 @@
   // resume/pause.
   ADD_CD_VARIABLE_VALUE("state_changed", "rtorrent", "state_changed");
   ADD_CD_VARIABLE_VALUE_PUBLIC("ignore_commands", "rtorrent", "ignore_commands");
 
   ADD_CD_STRING_BI("connection_current", std::ptr_fun(&apply_d_connection_type), std::ptr_fun(&retrieve_d_connection_type));
 
-  add_copy_to_download("get_connection_leech", "get_d_connection_leech");
-  add_copy_to_download("set_connection_leech", "set_d_connection_leech");
-  add_copy_to_download("get_connection_seed", "get_d_connection_seed");
-  add_copy_to_download("set_connection_seed", "set_d_connection_seed");
+  add_copy_to_download("get_connection_leech", "d.get_connection_leech");
+  add_copy_to_download("set_connection_leech", "d.set_connection_leech");
+  add_copy_to_download("get_connection_seed", "d.get_connection_seed");
+  add_copy_to_download("set_connection_seed", "d.set_connection_seed");
 
   ADD_CD_VALUE_MEM_BI("max_file_size", &core::Download::file_list, &torrent::FileList::set_max_file_size, &torrent::FileList::max_file_size);
 
   // Deprecated.
   ADD_CD_VALUE_MEM_BI("min_peers",     &core::Download::download, &torrent::Download::set_peers_min, &torrent::Download::peers_min);
   ADD_CD_VALUE_MEM_BI("max_peers",     &core::Download::download, &torrent::Download::set_peers_max, &torrent::Download::peers_max);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_events.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_events.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_events.cc	2007-07-25 23:45:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_events.cc	2007-08-16 05:33:57.000000000 +0800
@@ -59,24 +59,24 @@
 #include "command_helpers.h"
 
 torrent::Object
 apply_on_state_change(core::DownloadList::slot_map* slotMap, const torrent::Object& rawArgs) {
   const torrent::Object::list_type& args = rawArgs.as_list();
 
-  if (args.size() < 2)
-    throw torrent::input_error("Too few arguments.");
+  if (args.size() == 0 || args.size() > 2)
+    throw torrent::input_error("Wrong number of arguments.");
 
   if (args.front().as_string().empty())
     throw torrent::input_error("Empty key.");
 
   std::string key = "1_state_" + args.front().as_string();
 
-  if (args.back().as_string().empty())
+  if (args.size() == 1)
     slotMap->erase(key);
   else
-    (*slotMap)[key] = sigc::bind(sigc::ptr_fun(&rpc::parse_command_d_multiple_std), rpc::convert_list_to_command(++args.begin(), args.end()));
+    (*slotMap)[key] = sigc::bind(sigc::ptr_fun(&rpc::parse_command_d_multiple_std), args.back().as_string());
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_stop_on_ratio(const torrent::Object& rawArgs) {
@@ -102,75 +102,75 @@
     int64_t totalDone   = (*itr)->download()->bytes_done();
     int64_t totalUpload = (*itr)->download()->up_rate()->total();
 
     if ((totalUpload >= minUpload && totalUpload * 100 >= totalDone * minRatio) ||
         (maxRatio > 0 && totalUpload * 100 > totalDone * maxRatio)) {
       downloadList->stop_try(*itr);
-      rpc::call_command_d("set_d_ignore_commands", *itr, (int64_t)1);
+      rpc::call_command_d("d.set_ignore_commands", *itr, (int64_t)1);
     }
 
     ++itr;
   }
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_start_tied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ++itr) {
-    if (rpc::call_command_d_value("get_d_state", *itr) == 1)
+    if (rpc::call_command_d_value("d.get_state", *itr) == 1)
       continue;
 
     rak::file_stat fs;
-    const std::string& tiedToFile = rpc::call_command_d_string("get_d_tied_to_file", *itr);
+    const std::string& tiedToFile = rpc::call_command_d_string("d.get_tied_to_file", *itr);
 
     if (!tiedToFile.empty() && fs.update(rak::path_expand(tiedToFile)))
       control->core()->download_list()->start_try(*itr);
   }
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_stop_untied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ++itr) {
-    if (rpc::call_command_d_value("get_d_state", *itr) == 0)
+    if (rpc::call_command_d_value("d.get_state", *itr) == 0)
       continue;
 
     rak::file_stat fs;
-    const std::string& tiedToFile = rpc::call_command_d_string("get_d_tied_to_file", *itr);
+    const std::string& tiedToFile = rpc::call_command_d_string("d.get_tied_to_file", *itr);
 
     if (!tiedToFile.empty() && !fs.update(rak::path_expand(tiedToFile)))
       control->core()->download_list()->stop_try(*itr);
   }
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_close_untied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ++itr) {
     rak::file_stat fs;
-    const std::string& tiedToFile = rpc::call_command_d_string("get_d_tied_to_file", *itr);
+    const std::string& tiedToFile = rpc::call_command_d_string("d.get_tied_to_file", *itr);
 
     if (!tiedToFile.empty() && !fs.update(rak::path_expand(tiedToFile)) && control->core()->download_list()->stop_try(*itr))
       control->core()->download_list()->close(*itr);
   }
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_remove_untied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ) {
     rak::file_stat fs;
-    const std::string& tiedToFile = rpc::call_command_d_string("get_d_tied_to_file", *itr);
+    const std::string& tiedToFile = rpc::call_command_d_string("d.get_tied_to_file", *itr);
 
     if (!tiedToFile.empty() && !fs.update(rak::path_expand(tiedToFile))) {
       // Need to clear tied_to_file so it doesn't try to delete it.
-      rpc::call_command_d("set_d_tied_to_file", *itr, std::string());
+      rpc::call_command_d("d.set_tied_to_file", *itr, std::string());
 
       itr = control->core()->download_list()->erase(itr);
 
     } else {
       ++itr;
     }
@@ -180,22 +180,23 @@
 }
 
 torrent::Object
 apply_schedule(const torrent::Object& rawArgs) {
   const torrent::Object::list_type& args = rawArgs.as_list();
 
-  if (args.size() < 4)
-    throw torrent::input_error("Too few arguments.");
+  if (args.size() != 4)
+    throw torrent::input_error("Wrong number of arguments.");
 
   torrent::Object::list_type::const_iterator itr = args.begin();
 
   const std::string& arg1 = (itr++)->as_string();
   const std::string& arg2 = (itr++)->as_string();
   const std::string& arg3 = (itr++)->as_string();
+  const std::string& arg4 = (itr++)->as_string();
 
-  control->command_scheduler()->parse(arg1, arg2, arg3, rpc::convert_list_to_command(itr, args.end()));
+  control->command_scheduler()->parse(arg1, arg2, arg3, arg4);
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_load(int flags, const torrent::Object& rawArgs) {
@@ -266,39 +267,53 @@
   return result;
 }
 
 torrent::Object
 apply_call_download(const torrent::Object& rawArgs) {
   const torrent::Object::list_type&          args = rawArgs.as_list();
-  torrent::Object::list_type::const_iterator argsItr = args.begin();
 
-  if (argsItr == args.end() || ++argsItr == args.end())
+  if (args.empty())
     throw torrent::input_error("Too few arguments.");
 
-  const torrent::Object::string_type& infoHash = args.begin()->as_string();
+//   const torrent::Object::string_type& infoHash = args.begin()->as_string();
 
-  core::DownloadList*          dList = control->core()->download_list();
-  core::DownloadList::iterator dItr  = dList->end();
+//   core::DownloadList*          dList = control->core()->download_list();
+//   core::DownloadList::iterator dItr  = dList->end();
 
-  if (infoHash.size() == 40)
-    dItr = dList->find_hex(infoHash.c_str());
+//   if (infoHash.size() == 40)
+//     dItr = dList->find_hex(infoHash.c_str());
 
-  if (dItr == dList->end())
-    throw torrent::input_error("Not a valid info-hash.");
+//   if (dItr == dList->end())
+//     throw torrent::input_error("Not a valid info-hash.");
 
-  torrent::Object result;
-  const char*     command = (argsItr++)->as_string().c_str();
+  core::ViewManager* viewManager = control->view_manager();
+  core::ViewManager::iterator viewItr;
 
-  if (argsItr == args.end())
-    result = rpc::call_command_d(command, *dItr, torrent::Object());
-  else if (argsItr == --args.end())
-    result = rpc::call_command_d(command, *dItr, *argsItr);
+  if (!args.front().as_string().empty())
+    viewItr = viewManager->find(args.front().as_string());
   else
-    result = rpc::call_command_d_range(command, *dItr, argsItr, args.end());
+    viewItr = viewManager->find("default");
 
-  return result;
+  if (viewItr == viewManager->end())
+    throw torrent::input_error("Could not find view.");
+
+  // Add some pre-parsing of the commands, so we don't spend time
+  // parsing and searching command map for every single call.
+  torrent::Object             resultRaw(torrent::Object::TYPE_LIST);
+  torrent::Object::list_type& result = resultRaw.as_list();
+
+  for (core::View::const_iterator vItr = (*viewItr)->begin_visible(), vLast = (*viewItr)->end_visible(); vItr != vLast; vItr++) {
+    torrent::Object::list_type& row = result.insert(result.end(), torrent::Object(torrent::Object::TYPE_LIST))->as_list();
+
+    for (torrent::Object::list_type::const_iterator cItr = ++args.begin(), cLast = args.end(); cItr != args.end(); cItr++) {
+      const std::string& cmd = cItr->as_string();
+      row.push_back(rpc::parse_command_d_single(*vItr, cmd.c_str(), cmd.c_str() + cmd.size()));
+    }
+  }
+
+  return resultRaw;
 }
 
 void
 initialize_command_events() {
   core::DownloadList* downloadList = control->core()->download_list();
 
@@ -336,8 +351,8 @@
   ADD_COMMAND_LIST("load_start",              rak::bind_ptr_fn(&apply_load, core::Manager::create_quiet | core::Manager::create_tied | core::Manager::create_start));
   ADD_COMMAND_LIST("load_start_verbose",      rak::bind_ptr_fn(&apply_load, core::Manager::create_tied | core::Manager::create_start));
 
   ADD_COMMAND_VALUE_UN("close_low_diskspace", std::ptr_fun(&apply_close_low_diskspace));
 
   ADD_COMMAND_LIST("download_list",           rak::ptr_fn(&apply_download_list));
-//   ADD_COMMAND_LIST("call_download",           rak::ptr_fn(&apply_call_download));
+  ADD_COMMAND_LIST("call_download",           rak::ptr_fn(&apply_call_download));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_file.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_file.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_file.cc	2007-07-27 22:52:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_file.cc	2007-08-13 02:25:17.000000000 +0800
@@ -93,23 +93,23 @@
 
 #define ADD_CF_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandFileSlotsItr->set_slot(slot); \
   rpc::commands.insert_file(key, commandFileSlotsItr++, &rpc::CommandFileSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CF_VOID(key, slot) \
-  ADD_CF_SLOT_PUBLIC("get_f_" key, call_unknown, rpc::object_f_fn(slot), "i:", "")
+  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_f_fn(slot), "i:", "")
 
 #define ADD_CF_VALUE_UNI(key, get) \
-  ADD_CF_SLOT_PUBLIC("get_f_" key, call_unknown, rpc::object_void_f_fn(get), "i:", "")
+  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_f_fn(get), "i:", "")
 
 #define ADD_CF_VALUE_BI(key, set, get) \
-  ADD_CF_SLOT_PUBLIC("set_f_" key, call_value, rpc::object_value_f_fn(set), "i:i", "") \
-  ADD_CF_SLOT_PUBLIC("get_f_" key, call_unknown, rpc::object_void_f_fn(get), "i:", "")
+  ADD_CF_SLOT_PUBLIC("f.set_" key, call_value, rpc::object_value_f_fn(set), "i:i", "") \
+  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_f_fn(get), "i:", "")
 
 #define ADD_CF_STRING_UNI(key, get) \
-  ADD_CF_SLOT_PUBLIC("get_f_" key, call_unknown, rpc::object_void_f_fn(get), "s:", "")
+  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_f_fn(get), "s:", "")
 
 void
 initialize_command_file() {
   ADD_CF_VALUE_UNI("is_created",       std::mem_fun(&torrent::File::is_created));
   ADD_CF_VALUE_UNI("is_open",          std::mem_fun(&torrent::File::is_open));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_helpers.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_helpers.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_helpers.cc	2007-07-26 06:13:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_helpers.cc	2007-08-17 01:06:54.000000000 +0800
@@ -39,12 +39,13 @@
 #include <torrent/exceptions.h>
 
 #include "rpc/command_slot.h"
 #include "rpc/command_variable.h"
 #include "rpc/command_download_slot.h"
 #include "rpc/command_file_slot.h"
+#include "rpc/command_peer_slot.h"
 #include "rpc/command_tracker_slot.h"
 
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
@@ -53,18 +54,21 @@
 rpc::CommandVariable      commandVariables[COMMAND_VARIABLES_SIZE];
 rpc::CommandVariable*     commandVariablesItr = commandVariables;
 rpc::CommandDownloadSlot  commandDownloadSlots[COMMAND_DOWNLOAD_SLOTS_SIZE];
 rpc::CommandDownloadSlot* commandDownloadSlotsItr = commandDownloadSlots;
 rpc::CommandFileSlot      commandFileSlots[COMMAND_FILE_SLOTS_SIZE];
 rpc::CommandFileSlot*     commandFileSlotsItr = commandFileSlots;
+rpc::CommandPeerSlot      commandPeerSlots[COMMAND_PEER_SLOTS_SIZE];
+rpc::CommandPeerSlot*     commandPeerSlotsItr = commandPeerSlots;
 rpc::CommandTrackerSlot   commandTrackerSlots[COMMAND_TRACKER_SLOTS_SIZE];
 rpc::CommandTrackerSlot*  commandTrackerSlotsItr = commandTrackerSlots;
 
 void initialize_command_download();
 void initialize_command_events();
 void initialize_command_file();
+void initialize_command_peer();
 void initialize_command_local();
 void initialize_command_network();
 void initialize_command_tracker();
 void initialize_command_ui();
 
 void
@@ -72,25 +76,28 @@
   initialize_command_events();
   initialize_command_network();
   initialize_command_local();
   initialize_command_ui();
   initialize_command_download();
   initialize_command_file();
+  initialize_command_peer();
   initialize_command_tracker();
 
 #ifdef ADDING_COMMANDS 
   if (commandSlotsItr > commandSlots + COMMAND_SLOTS_SIZE ||
       commandVariablesItr > commandVariables + COMMAND_VARIABLES_SIZE ||
       commandDownloadSlotsItr > commandDownloadSlots + COMMAND_DOWNLOAD_SLOTS_SIZE ||
       commandFileSlotsItr > commandFileSlots + COMMAND_FILE_SLOTS_SIZE ||
+      commandPeerSlotsItr > commandPeerSlots + COMMAND_PEER_SLOTS_SIZE ||
       commandTrackerSlotsItr > commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE)
 #else
   if (commandSlotsItr != commandSlots + COMMAND_SLOTS_SIZE ||
       commandVariablesItr != commandVariables + COMMAND_VARIABLES_SIZE ||
       commandDownloadSlotsItr != commandDownloadSlots + COMMAND_DOWNLOAD_SLOTS_SIZE ||
       commandFileSlotsItr != commandFileSlots + COMMAND_FILE_SLOTS_SIZE ||
+      commandPeerSlotsItr != commandPeerSlots + COMMAND_PEER_SLOTS_SIZE ||
       commandTrackerSlotsItr != commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE)
 #endif
     throw torrent::internal_error("initialize_commands() static command array size mismatch.");
 }
 
 void
@@ -98,11 +105,13 @@
              rpc::CommandMap::generic_slot getSlot, rpc::CommandMap::generic_slot setSlot,
              const torrent::Object& defaultObject) {
   rpc::CommandVariable* variable = commandVariablesItr++;
   variable->set_variable(defaultObject);
 
   rpc::commands.insert_generic(getKey, variable, getSlot, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, "i:", "");
-  rpc::commands.insert_generic(setKey, variable, setSlot, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, "i:", "");
+
+  if (setKey)
+    rpc::commands.insert_generic(setKey, variable, setSlot, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, "i:", "");
 
   if (defaultSetKey)
     rpc::commands.insert_generic(defaultSetKey, variable, setSlot, rpc::CommandMap::flag_dont_delete, "i:", "");
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_helpers.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_helpers.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_helpers.h	2007-07-27 22:53:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_helpers.h	2007-08-17 00:25:17.000000000 +0800
@@ -41,33 +41,37 @@
 
 namespace rpc {
   class CommandSlot;
   class CommandVariable;
   class CommandDownloadSlot;
   class CommandFileSlot;
+  class CommandPeerSlot;
   class CommandTrackerSlot;
 }
 
 // By using a static array we avoid allocating the variables on the
 // heap. This should reduce memory use and improve cache locality.
 #define COMMAND_SLOTS_SIZE          100
 #define COMMAND_VARIABLES_SIZE      100
 #define COMMAND_DOWNLOAD_SLOTS_SIZE 100
 #define COMMAND_FILE_SLOTS_SIZE     20
+#define COMMAND_PEER_SLOTS_SIZE     20
 #define COMMAND_TRACKER_SLOTS_SIZE  15
 
 #define ADDING_COMMANDS
 
 extern rpc::CommandSlot          commandSlots[COMMAND_SLOTS_SIZE];
 extern rpc::CommandSlot*         commandSlotsItr;
 extern rpc::CommandVariable      commandVariables[COMMAND_VARIABLES_SIZE];
 extern rpc::CommandVariable*     commandVariablesItr;
 extern rpc::CommandDownloadSlot  commandDownloadSlots[COMMAND_DOWNLOAD_SLOTS_SIZE];
 extern rpc::CommandDownloadSlot* commandDownloadSlotsItr;
 extern rpc::CommandFileSlot      commandFileSlots[COMMAND_FILE_SLOTS_SIZE];
 extern rpc::CommandFileSlot*     commandFileSlotsItr;
+extern rpc::CommandPeerSlot      commandPeerSlots[COMMAND_PEER_SLOTS_SIZE];
+extern rpc::CommandPeerSlot*     commandPeerSlotsItr;
 extern rpc::CommandTrackerSlot   commandTrackerSlots[COMMAND_TRACKER_SLOTS_SIZE];
 extern rpc::CommandTrackerSlot*  commandTrackerSlotsItr;
 
 void initialize_commands();
 
 void
@@ -81,12 +85,15 @@
 #define ADD_VARIABLE_VALUE(key, defaultValue) \
 add_variable("get_" key, "set_" key, key, &rpc::CommandVariable::get_value, &rpc::CommandVariable::set_value, (int64_t)defaultValue);
 
 #define ADD_VARIABLE_STRING(key, defaultValue) \
 add_variable("get_" key, "set_" key, key, &rpc::CommandVariable::get_string, &rpc::CommandVariable::set_string, std::string(defaultValue));
 
+#define ADD_VARIABLE_C_STRING(key, defaultValue) \
+add_variable("get_" key, NULL, NULL, &rpc::CommandVariable::get_string, NULL, std::string(defaultValue));
+
 #define ADD_COMMAND_SLOT(key, function, slot, parm, doc)    \
   commandSlotsItr->set_slot(slot); \
   rpc::commands.insert_generic(key, commandSlotsItr++, &rpc::CommandSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_COMMAND_SLOT_PRIVATE(key, function, slot) \
   commandSlotsItr->set_slot(slot); \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_local.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_local.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_local.cc	2007-07-20 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_local.cc	2007-08-17 04:42:31.000000000 +0800
@@ -33,16 +33,18 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include <fcntl.h>
 #include <functional>
+#include <unistd.h>
+#include <rak/path.h>
 #include <torrent/torrent.h>
 #include <torrent/chunk_manager.h>
-//#include <torrent/connection_manager.h>
 
 #include "core/download_list.h"
 #include "core/download_store.h"
 #include "core/manager.h"
 #include "rpc/command_slot.h"
 #include "rpc/command_variable.h"
@@ -51,19 +53,44 @@
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
 typedef torrent::ChunkManager CM_t;
 
+torrent::Object
+apply_execute_log(const torrent::Object& rawArgs) {
+  if (rpc::execFile.log_fd() != -1) {
+    ::close(rpc::execFile.log_fd());
+    rpc::execFile.set_log_fd(-1);
+  }
+
+  if (rawArgs.is_string() && !rawArgs.as_string().empty()) {
+    int logFd = open(rak::path_expand(rawArgs.as_string()).c_str(), O_WRONLY | O_APPEND | O_CREAT, 0644);
+
+    if (logFd < 0)
+      throw torrent::input_error("Could not open execute log file.");
+
+    rpc::execFile.set_log_fd(logFd);
+    control->core()->push_log("Opened execute log file.");
+
+  } else {
+    control->core()->push_log("Closed execute log file.");
+  }
+
+  return torrent::Object();
+}
+
 void
 initialize_command_local() {
-//   core::DownloadList* downloadList = control->core()->download_list();
   torrent::ChunkManager* chunkManager = torrent::chunk_manager();
   core::DownloadList*    dList = control->core()->download_list();
   core::DownloadStore*   dStore = control->core()->download_store();
 
+  ADD_VARIABLE_C_STRING("client_version",  PACKAGE_VERSION);
+  ADD_VARIABLE_C_STRING("library_version", torrent::version());
+
   ADD_VARIABLE_VALUE("max_file_size", -1);
   ADD_VARIABLE_VALUE("split_file_size", -1);
   ADD_VARIABLE_STRING("split_suffix", ".part");
 
   ADD_COMMAND_VALUE_TRI("max_memory_usage",      rak::make_mem_fun(chunkManager, &CM_t::set_max_memory_usage), rak::make_mem_fun(chunkManager, &CM_t::max_memory_usage));
   ADD_COMMAND_VALUE_TRI("safe_sync",             rak::make_mem_fun(chunkManager, &CM_t::set_safe_sync), rak::make_mem_fun(chunkManager, &CM_t::safe_sync));
@@ -79,8 +106,13 @@
   ADD_COMMAND_STRING_TRI("session",            rak::make_mem_fun(dStore, &core::DownloadStore::set_path), rak::make_mem_fun(dStore, &core::DownloadStore::path));
   ADD_COMMAND_VOID("session_save",             rak::make_mem_fun(dList, &core::DownloadList::session_save));
 
   ADD_COMMAND_VALUE_TRI_OCT("umask",           rak::make_mem_fun(control, &Control::set_umask), rak::make_mem_fun(control, &Control::umask));
   ADD_COMMAND_STRING_TRI("working_directory",  rak::make_mem_fun(control, &Control::set_working_directory), rak::make_mem_fun(control, &Control::working_directory));
 
-  ADD_COMMAND_LIST("execute", rak::mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object));
+  ADD_COMMAND_LIST("execute",             rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, rpc::ExecFile::flag_throw | rpc::ExecFile::flag_expand_tilde));
+  ADD_COMMAND_LIST("execute_nothrow",     rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, rpc::ExecFile::flag_expand_tilde));
+  ADD_COMMAND_LIST("execute_raw",         rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, rpc::ExecFile::flag_throw));
+  ADD_COMMAND_LIST("execute_raw_nothrow", rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, 0));
+
+  ADD_COMMAND_STRING_UN("execute_log",    std::ptr_fun(&apply_execute_log));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_network.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_network.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_network.cc	2007-07-28 21:07:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_network.cc	2007-08-03 03:36:43.000000000 +0800
@@ -280,18 +280,23 @@
   ADD_VARIABLE_VALUE("min_peers", 40);
   ADD_VARIABLE_VALUE("max_peers", 100);
   ADD_VARIABLE_VALUE("min_peers_seed", -1);
   ADD_VARIABLE_VALUE("max_peers_seed", -1);
 
   ADD_VARIABLE_VALUE("max_uploads", 15);
-  ADD_VARIABLE_VALUE("max_uploads_div", 1);
 
-  ADD_VARIABLE_VALUE("max_downloads_div", 0);
+  ADD_VARIABLE_VALUE("max_uploads_div",      1);
+  ADD_VARIABLE_VALUE("max_uploads_global",   0);
+  ADD_VARIABLE_VALUE("max_downloads_div",    1);
+  ADD_VARIABLE_VALUE("max_downloads_global", 0);
 
-  ADD_COMMAND_VALUE_TRI_KB("download_rate", rak::make_mem_fun(control->ui(), &ui::Root::set_down_throttle_i64), rak::ptr_fun(&torrent::down_throttle));
-  ADD_COMMAND_VALUE_TRI_KB("upload_rate",   rak::make_mem_fun(control->ui(), &ui::Root::set_up_throttle_i64), rak::ptr_fun(&torrent::up_throttle));
+//   ADD_COMMAND_VALUE_TRI("max_uploads_global",   rak::make_mem_fun(control->ui(), &ui::Root::set_max_uploads_global), rak::make_mem_fun(control->ui(), &ui::Root::max_uploads_global));
+//   ADD_COMMAND_VALUE_TRI("max_downloads_global", rak::make_mem_fun(control->ui(), &ui::Root::set_max_downloads_global), rak::make_mem_fun(control->ui(), &ui::Root::max_downloads_global));
+
+  ADD_COMMAND_VALUE_TRI_KB("download_rate",     rak::make_mem_fun(control->ui(), &ui::Root::set_down_throttle_i64), rak::ptr_fun(&torrent::down_throttle));
+  ADD_COMMAND_VALUE_TRI_KB("upload_rate",       rak::make_mem_fun(control->ui(), &ui::Root::set_up_throttle_i64), rak::ptr_fun(&torrent::up_throttle));
 
   ADD_VARIABLE_VALUE("tracker_numwant", -1);
 
   ADD_COMMAND_LIST("encryption",          rak::ptr_fn(&apply_encryption));
 
   ADD_COMMAND_STRING("tos",               rak::ptr_fn(&apply_tos));
@@ -303,15 +308,12 @@
   ADD_COMMAND_STRING_TRI("http_capath",   rak::make_mem_fun(httpStack, &core::CurlStack::set_http_capath), rak::make_mem_fun(httpStack, &core::CurlStack::http_capath));
   ADD_COMMAND_STRING_TRI("http_cacert",   rak::make_mem_fun(httpStack, &core::CurlStack::set_http_cacert), rak::make_mem_fun(httpStack, &core::CurlStack::http_cacert));
 
   ADD_COMMAND_VALUE_TRI("send_buffer_size",    rak::make_mem_fun(cm, &torrent::ConnectionManager::set_send_buffer_size), rak::make_mem_fun(cm, &torrent::ConnectionManager::send_buffer_size));
   ADD_COMMAND_VALUE_TRI("receive_buffer_size", rak::make_mem_fun(cm, &torrent::ConnectionManager::set_receive_buffer_size), rak::make_mem_fun(cm, &torrent::ConnectionManager::receive_buffer_size));
 
-  ADD_COMMAND_VALUE_TRI("max_uploads_global",   rak::make_mem_fun(control->ui(), &ui::Root::set_max_uploads_global), rak::make_mem_fun(control->ui(), &ui::Root::max_uploads_global));
-  ADD_COMMAND_VALUE_TRI("max_downloads_global", rak::make_mem_fun(control->ui(), &ui::Root::set_max_downloads_global), rak::make_mem_fun(control->ui(), &ui::Root::max_downloads_global));
-
   ADD_COMMAND_VALUE_TRI("hash_max_tries",       std::ptr_fun(&torrent::set_hash_max_tries), rak::ptr_fun(&torrent::hash_max_tries));
   ADD_COMMAND_VALUE_TRI("max_open_files",       std::ptr_fun(&torrent::set_max_open_files), rak::ptr_fun(&torrent::max_open_files));
   ADD_COMMAND_VALUE_TRI("max_open_sockets",     rak::make_mem_fun(cm, &torrent::ConnectionManager::set_max_size), rak::make_mem_fun(cm, &torrent::ConnectionManager::max_size));
   ADD_COMMAND_VALUE_TRI("max_open_http",        rak::make_mem_fun(httpStack, &core::CurlStack::set_max_active), rak::make_mem_fun(httpStack, &core::CurlStack::max_active));
 
   ADD_COMMAND_STRING_UN("scgi_port",            rak::bind2nd(std::ptr_fun(&apply_scgi), 1));
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src: command_peer.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_tracker.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_tracker.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_tracker.cc	2007-07-27 22:51:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_tracker.cc	2007-08-13 02:25:17.000000000 +0800
@@ -61,23 +61,23 @@
 
 #define ADD_CT_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandTrackerSlotsItr->set_slot(slot); \
   rpc::commands.insert_tracker(key, commandTrackerSlotsItr++, &rpc::CommandTrackerSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CT_VOID(key, slot) \
-  ADD_CT_SLOT_PUBLIC("get_t_" key, call_unknown, rpc::object_t_fn(slot), "i:", "")
+  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_t_fn(slot), "i:", "")
 
 #define ADD_CT_VALUE_UNI(key, get) \
-  ADD_CT_SLOT_PUBLIC("get_t_" key, call_unknown, rpc::object_void_t_fn(get), "i:", "")
+  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_t_fn(get), "i:", "")
 
 #define ADD_CT_VALUE_BI(key, set, get) \
-  ADD_CT_SLOT_PUBLIC("set_t_" key, call_value, rpc::object_value_t_fn(set), "i:i", "") \
-  ADD_CT_SLOT_PUBLIC("get_t_" key, call_unknown, rpc::object_void_t_fn(get), "i:", "")
+  ADD_CT_SLOT_PUBLIC("t.set_" key, call_value, rpc::object_value_t_fn(set), "i:i", "") \
+  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_t_fn(get), "i:", "")
 
 #define ADD_CT_STRING_UNI(key, get) \
-  ADD_CT_SLOT_PUBLIC("get_t_" key, call_unknown, rpc::object_void_t_fn(get), "s:", "")
+  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_t_fn(get), "s:", "")
 
 void
 initialize_command_tracker() {
   ADD_CT_STRING_UNI("url",              std::mem_fun(&torrent::Tracker::url));
   ADD_CT_VALUE_UNI("group",             std::mem_fun(&torrent::Tracker::group));
   ADD_CT_VALUE_UNI("type",              std::mem_fun(&torrent::Tracker::tracker_type));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_ui.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_ui.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/command_ui.cc	2007-07-26 03:31:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_ui.cc	2007-08-11 18:28:33.000000000 +0800
@@ -108,30 +108,13 @@
   return rawResult;
 }
 
 torrent::Object
 apply_print(const torrent::Object& rawArgs) {
   char buffer[1024];
-  char* current = buffer;
-
-  for (torrent::Object::list_type::const_iterator itr = rawArgs.as_list().begin(), last = rawArgs.as_list().end(); itr != last; itr++) {
-    switch (itr->type()) {
-    case torrent::Object::TYPE_STRING:
-    {
-      int len = std::min<int>(itr->as_string().size(), buffer + 1024 - current);
-
-      std::memcpy(current, itr->as_string().c_str(), len + 1);
-      current += len;
-      break;
-    }
-    case torrent::Object::TYPE_VALUE:
-    default:
-      current += snprintf(current, buffer + 1024 - current, "%lli", itr->as_value());
-      break;
-    }
-  }
+  rpc::print_object(buffer, buffer + 1024, &rawArgs, 0);
 
   control->core()->push_log(buffer);
   return torrent::Object();
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/core/download_factory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_factory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/core/download_factory.cc	2007-07-25 02:48:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_factory.cc	2007-08-16 22:58:14.000000000 +0800
@@ -101,13 +101,15 @@
 
 void
 DownloadFactory::receive_load() {
   if (m_stream)
     throw torrent::internal_error("DownloadFactory::load() called on an object with m_stream != NULL");
 
-  if (std::strncmp(m_uri.c_str(), "http://", 7) == 0) {
+  if (std::strncmp(m_uri.c_str(), "http://", 7) == 0 ||
+      std::strncmp(m_uri.c_str(), "https://", 8) == 0 ||
+      std::strncmp(m_uri.c_str(), "ftp://", 6) == 0) {
     // Http handling here.
     m_stream = new std::stringstream;
     HttpQueue::iterator itr = m_manager->http_queue()->insert(m_uri, m_stream);
 
     (*itr)->signal_done().slots().push_front(sigc::mem_fun(*this, &DownloadFactory::receive_loaded));
     (*itr)->signal_failed().slots().push_front(sigc::mem_fun(*this, &DownloadFactory::receive_failed));
@@ -170,50 +172,50 @@
     
   torrent::Object* rtorrent = &root->get_key("rtorrent");
 
   initialize_rtorrent(download, rtorrent);
 
   // Move to 'rtorrent'.
-  rpc::call_command_d("set_d_connection_leech", download, m_variables["connection_leech"]);
-  rpc::call_command_d("set_d_connection_seed", download,  m_variables["connection_seed"]);
+  rpc::call_command_d("d.set_connection_leech", download, m_variables["connection_leech"]);
+  rpc::call_command_d("d.set_connection_seed", download,  m_variables["connection_seed"]);
 
-  rpc::call_command_d("set_d_max_uploads", download,      rpc::call_command_void("get_max_uploads"));
-  rpc::call_command_d("set_d_min_peers", download,        rpc::call_command_void("get_min_peers"));
-  rpc::call_command_d("set_d_max_peers", download,        rpc::call_command_void("get_max_peers"));
-  rpc::call_command_d("set_d_tracker_numwant", download,  rpc::call_command_void("get_tracker_numwant"));
+  rpc::call_command_d("d.set_max_uploads", download,      rpc::call_command_void("get_max_uploads"));
+  rpc::call_command_d("d.set_min_peers", download,        rpc::call_command_void("get_min_peers"));
+  rpc::call_command_d("d.set_max_peers", download,        rpc::call_command_void("get_max_peers"));
+  rpc::call_command_d("d.set_tracker_numwant", download,  rpc::call_command_void("get_tracker_numwant"));
 
-  if (rpc::call_command_d_value("get_d_complete", download) != 0) {
+  if (rpc::call_command_d_value("d.get_complete", download) != 0) {
     if (rpc::call_command_value("get_min_peers_seed") >= 0)
-      rpc::call_command_d("set_d_min_peers", download, rpc::call_command_void("get_min_peers_seed"));
+      rpc::call_command_d("d.set_min_peers", download, rpc::call_command_void("get_min_peers_seed"));
 
     if (rpc::call_command_value("get_max_peers_seed") >= 0)
-      rpc::call_command_d("set_d_max_peers", download, rpc::call_command_void("get_max_peers_seed"));
+      rpc::call_command_d("d.set_max_peers", download, rpc::call_command_void("get_max_peers_seed"));
   }
 
   if (!rpc::call_command_value("get_use_udp_trackers"))
     download->enable_udp_trackers(false);
 
   if (rpc::call_command_value("get_max_file_size") > 0)
-    rpc::call_command_d("set_d_max_file_size", download, rpc::call_command_void("get_max_file_size"));
+    rpc::call_command_d("d.set_max_file_size", download, rpc::call_command_void("get_max_file_size"));
 
   // Check first if we already have these values set in the session
   // torrent, so that it is safe to change the values.
   //
   // Need to also catch the exceptions.
   if (rpc::call_command_value("get_split_file_size") >= 0)
     torrent::file_split_all(download->download()->file_list(),
                             rpc::call_command_value("get_split_file_size"),
                             rpc::call_command_string("split_suffix"));
 
   if (!rtorrent->has_key_string("directory"))
-    rpc::call_command_d("set_d_directory", download, m_variables["directory"]);
+    rpc::call_command_d("d.set_directory", download, m_variables["directory"]);
   else
-    rpc::call_command_d("set_d_directory", download, rtorrent->get_key("directory"));
+    rpc::call_command_d("d.set_directory", download, rtorrent->get_key("directory"));
 
   if (!m_session && m_variables["tied_to_file"].as_value())
-    rpc::call_command_d("set_d_tied_to_file", download, m_uri);
+    rpc::call_command_d("d.set_tied_to_file", download, m_uri);
 
   torrent::Object& resumeObject = root->has_key_map("libtorrent_resume")
     ? root->get_key("libtorrent_resume")
     : root->insert_key("libtorrent_resume", torrent::Object(torrent::Object::TYPE_MAP));
 
   torrent::resume_load_addresses(*download->download(), resumeObject);
@@ -259,14 +261,14 @@
 
   // When a download scheduler is implemented, this is handled by the
   // above insertion into download list.
   if (m_session) {
     // This torrent was queued for hashing or hashing when the session
     // file was saved. Or it was in a started state.
-    if (rpc::call_command_d_value("get_d_hashing", download) != Download::variable_hashing_stopped ||
-        rpc::call_command_d_value("get_d_state", download) != 0)
+    if (rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped ||
+        rpc::call_command_d_value("d.get_state", download) != 0)
       m_manager->download_list()->resume(download);
 
   } else {
     // Use the state thingie here, move below.
     if (m_start)
       m_manager->download_list()->start_normal(download);
@@ -309,15 +311,15 @@
     rtorrent->insert_key("hashing", (int64_t)Download::variable_hashing_stopped);
 
   if (!rtorrent->has_key_string("tied_to_file"))
     rtorrent->insert_key("tied_to_file", std::string());
 
   if (rtorrent->has_key_value("priority"))
-    rpc::call_command_d("set_d_priority", download, rtorrent->get_key_value("priority") % 4);
+    rpc::call_command_d("d.set_priority", download, rtorrent->get_key_value("priority") % 4);
   else
-    rpc::call_command_d("set_d_priority", download, (int64_t)2);
+    rpc::call_command_d("d.set_priority", download, (int64_t)2);
 
   if (rtorrent->has_key_value("key")) {
     download->tracker_list()->set_key(rtorrent->get_key_value("key"));
 
   } else {
     download->tracker_list()->set_key(random() % (std::numeric_limits<uint32_t>::max() - 1) + 1);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/core/download_list.cc	2007-07-25 02:33:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_list.cc	2007-08-13 02:25:17.000000000 +0800
@@ -70,13 +70,17 @@
 }
 
 struct download_list_call {
   download_list_call(Download* d) : m_download(d) {}
 
   void operator () (const DownloadList::slot_map::value_type& s) {
-    s.second(m_download);
+    try {
+      s.second(m_download);
+    } catch (torrent::input_error& e) {
+      control->core()->push_log((std::string("Download event action failed: ") + e.what()).c_str());
+    }
   }
 
   Download* m_download;
 };    
 
 void
@@ -262,13 +266,13 @@
   //
   // Reconsider this save. Should be done explicitly when shutting down.
   //control->core()->download_store()->save(download);
 
   download->download()->close();
 
-  if (!download->is_hash_failed() && rpc::call_command_d_value("get_d_hashing", download) != Download::variable_hashing_stopped)
+  if (!download->is_hash_failed() && rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped)
     throw torrent::internal_error("DownloadList::close_throw(...) called but we're going into a hashing loop.");
 
   std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
   std::for_each(slot_map_close().begin(), slot_map_close().end(), download_list_call(download));
 }
 
@@ -276,52 +280,52 @@
 DownloadList::start_normal(Download* download) {
   check_contains(download);
 
   // Clear hash failed as we're doing a manual start and want to try
   // hashing again.
   download->set_hash_failed(false);
-  rpc::call_command_d("set_d_state", download, (int64_t)1);
+  rpc::call_command_d("d.set_state", download, (int64_t)1);
 
   resume(download);
 }
 
 bool
 DownloadList::start_try(Download* download) {
   check_contains(download);
 
   // Also don't start if the state is one of those that indicate we
   // were manually stopped?
 
-  if (download->is_hash_failed() || rpc::call_command_d_value("get_d_ignore_commands", download) != 0)
+  if (download->is_hash_failed() || rpc::call_command_d_value("d.get_ignore_commands", download) != 0)
     return false;
 
   // Don't clear the hash failed as this function is used by scripts,
   // etc.
-  rpc::call_command_d("set_d_state", download, (int64_t)1);
+  rpc::call_command_d("d.set_state", download, (int64_t)1);
 
   resume(download);
   return true;
 }
 
 void
 DownloadList::stop_normal(Download* download) {
   check_contains(download);
 
-  rpc::call_command_d("set_d_state", download, (int64_t)0);
+  rpc::call_command_d("d.set_state", download, (int64_t)0);
 
   pause(download);
 }
 
 bool
 DownloadList::stop_try(Download* download) {
   check_contains(download);
 
-  if (rpc::call_command_d_value("get_d_ignore_commands", download) != 0)
+  if (rpc::call_command_d_value("d.get_ignore_commands", download) != 0)
     return false;
 
-  rpc::call_command_d("set_d_state", download, (int64_t)0);
+  rpc::call_command_d("d.set_state", download, (int64_t)0);
 
   pause(download);
   return true;
 }
 
 void
@@ -341,28 +345,28 @@
     if (!download->is_hash_checked()) {
       // If the hash failed flag wasn't cleared then hashing won't be
       // initiated.
       if (download->is_hash_failed())
         return;
 
-      if (rpc::call_command_d_value("get_d_hashing", download) == Download::variable_hashing_stopped)
-        rpc::call_command_d("set_d_hashing", download, Download::variable_hashing_initial);
+      if (rpc::call_command_d_value("d.get_hashing", download) == Download::variable_hashing_stopped)
+        rpc::call_command_d("d.set_hashing", download, Download::variable_hashing_initial);
 
       std::for_each(slot_map_hash_queued().begin(), slot_map_hash_queued().end(), download_list_call(download));
       return;
     }
 
     // This will never actually do anything due to the above hash check.
     // open_throw(download);
 
-    rpc::call_command_d("set_d_state_changed", download, cachedTime.seconds());
+    rpc::call_command_d("d.set_state_changed", download, cachedTime.seconds());
 
     if (download->is_done()) {
-      rpc::call_command_d("set_d_connection_current", download, rpc::call_command_d_void("get_d_connection_seed", download));
+      rpc::call_command_d("d.set_connection_current", download, rpc::call_command_d_void("d.get_connection_seed", download));
     } else {
-      rpc::call_command_d("set_d_connection_current", download, rpc::call_command_d_void("get_d_connection_leech", download));
+      rpc::call_command_d("d.set_connection_current", download, rpc::call_command_d_void("d.get_connection_leech", download));
 
       // For the moment, clear the resume data so we force hash-check
       // on non-complete downloads after a crash. This shouldn't be
       // needed, but for some reason linux 2.6 is very lazy about
       // updating mtime.
       torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"), true);
@@ -385,28 +389,28 @@
   check_contains(download);
 
   try {
 
     // Always clear hashing on pause. When a hashing request is added,
     // it should have cleared the hash resume data.
-    if (rpc::call_command_d_value("get_d_hashing", download) != Download::variable_hashing_stopped) {
+    if (rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped) {
       download->download()->hash_stop();
-      rpc::call_command_d_set_value("set_d_hashing", download, Download::variable_hashing_stopped);
+      rpc::call_command_d_set_value("d.set_hashing", download, Download::variable_hashing_stopped);
 
       std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
     }
 
     if (!download->download()->is_active())
       return;
 
     download->download()->stop();
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
     
     std::for_each(slot_map_stop().begin(), slot_map_stop().end(), download_list_call(download));
 
-    rpc::call_command_d("set_d_state_changed", download, cachedTime.seconds());
+    rpc::call_command_d("d.set_state_changed", download, cachedTime.seconds());
 
     // Save the state after all the slots, etc have been called so we
     // include the modifications they may make.
     //control->core()->download_store()->save(download);
 
   } catch (torrent::local_error& e) {
@@ -417,13 +421,13 @@
 void
 DownloadList::check_hash(Download* download) {
   check_contains(download);
 
   try {
 
-    if (rpc::call_command_d_value("get_d_hashing", download) != Download::variable_hashing_stopped)
+    if (rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped)
       return;
 
     hash_queue(download, Download::variable_hashing_rehash);
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
@@ -450,33 +454,33 @@
   //
   // Perhaps we should use a seperate variable or state, and check
   // that. Thus we can bork the download if the hash check doesn't
   // confirm all the data, avoiding large BW usage on f.ex. the
   // ReiserFS bug with >4GB files.
 
-  int64_t hashing = rpc::call_command_d_value("get_d_hashing", download);
-  rpc::call_command_d_set_value("set_d_hashing", download, Download::variable_hashing_stopped);
+  int64_t hashing = rpc::call_command_d_value("d.get_hashing", download);
+  rpc::call_command_d_set_value("d.set_hashing", download, Download::variable_hashing_stopped);
 
   switch (hashing) {
   case Download::variable_hashing_initial:
   case Download::variable_hashing_rehash:
     // Normal re/hashing.
 
     // If the download was previously completed but the files were
     // f.ex deleted, then we clear the state and complete.
-    if (rpc::call_command_d_value("get_d_complete", download) && !download->is_done()) {
-      rpc::call_command_d("set_d_state", download, (int64_t)0);
+    if (rpc::call_command_d_value("d.get_complete", download) && !download->is_done()) {
+      rpc::call_command_d("d.set_state", download, (int64_t)0);
       download->set_message("Download registered as completed, but hash check returned unfinished chunks.");
     }
 
     // Save resume data so we update time-stamps and priorities if
     // they were invalid/changed while loading/hashing.
-    rpc::call_command_d("set_d_complete", download, (int64_t)download->is_done());
+    rpc::call_command_d("d.set_complete", download, (int64_t)download->is_done());
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
 
-    if (rpc::call_command_d_value("get_d_state", download) == 1)
+    if (rpc::call_command_d_value("d.get_state", download) == 1)
       resume(download);
 
     break;
 
   case Download::variable_hashing_last:
 
@@ -500,20 +504,20 @@
 }
 
 void
 DownloadList::hash_queue(Download* download, int type) {
   check_contains(download);
 
-  if (rpc::call_command_d_value("get_d_hashing", download) != Download::variable_hashing_stopped)
+  if (rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped)
     throw torrent::internal_error("DownloadList::hash_queue(...) hashing already queued.");
 
   close_throw(download);
   torrent::resume_clear_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
 
   download->set_hash_failed(false);
-  rpc::call_command_d_set_value("set_d_hashing", download, type);
+  rpc::call_command_d_set_value("d.set_hashing", download, type);
 
   if (download->is_open())
     throw torrent::internal_error("DownloadList::hash_clear(...) download still open.");
 
   // If any more stuff is added here, make sure resume etc are still
   // correct.
@@ -536,35 +540,38 @@
 
 // The download must be open when we call this function.
 void
 DownloadList::confirm_finished(Download* download) {
   check_contains(download);
 
-  rpc::call_command_d("set_d_complete", download, (int64_t)1);
+  rpc::call_command_d("d.set_complete", download, (int64_t)1);
 
-  rpc::call_command_d("set_d_connection_current", download, rpc::call_command_d_void("get_d_connection_seed", download));
+  rpc::call_command_d("d.set_connection_current", download, rpc::call_command_d_void("d.get_connection_seed", download));
   download->set_priority(download->priority());
 
-  if (rpc::call_command_d_value("get_d_min_peers", download) == rpc::call_command_value("get_min_peers") && rpc::call_command_value("get_min_peers_seed") >= 0)
-    rpc::call_command_d("set_d_min_peers", download, rpc::call_command_void("get_min_peers_seed"));
+  if (rpc::call_command_d_value("d.get_min_peers", download) == rpc::call_command_value("get_min_peers") && rpc::call_command_value("get_min_peers_seed") >= 0)
+    rpc::call_command_d("d.set_min_peers", download, rpc::call_command_void("get_min_peers_seed"));
 
-  if (rpc::call_command_d_value("get_d_max_peers", download) == rpc::call_command_value("get_max_peers") && rpc::call_command_value("get_max_peers_seed") >= 0)
-    rpc::call_command_d("set_d_max_peers", download, rpc::call_command_void("get_max_peers_seed"));
+  if (rpc::call_command_d_value("d.get_max_peers", download) == rpc::call_command_value("get_max_peers") && rpc::call_command_value("get_max_peers_seed") >= 0)
+    rpc::call_command_d("d.set_max_peers", download, rpc::call_command_void("get_max_peers_seed"));
 
   // Do this before the slots are called in case one of them closes
   // the download.
   if (!download->is_active() && rpc::call_command_value("get_session_on_completion") != 0) {
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
     control->core()->download_store()->save(download);
   }
 
   // Send the completed request before resuming so we don't reset the
   // up/downloaded baseline.
   download->download()->tracker_list().send_completed();
 
+  // Close before calling on_finished to ensure the user can do stuff
+  // like change move the downloaded files and change the directory.
+  close_throw(download);
   std::for_each(slot_map_finished().begin(), slot_map_finished().end(), download_list_call(download));
 
-  if (!download->is_active() && rpc::call_command_d_value("get_d_state", download) == 1)
+  if (!download->is_active() && rpc::call_command_d_value("d.get_state", download) == 1)
     resume(download);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/core/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/core/manager.cc	2007-07-21 07:02:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/manager.cc	2007-08-13 02:25:16.000000000 +0800
@@ -227,13 +227,13 @@
   // Register slots to be called when a download is inserted/erased,
   // opened or closed.
   m_downloadList->slot_map_insert()["1_connect_network_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_network_log), sigc::mem_fun(m_logComplete, &Log::push_front));
   m_downloadList->slot_map_insert()["1_connect_storage_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_storage_log), sigc::mem_fun(m_logComplete, &Log::push_front));
   m_downloadList->slot_map_insert()["1_connect_tracker_dump"] = sigc::bind(sigc::ptr_fun(&connect_signal_tracker_dump), sigc::ptr_fun(&receive_tracker_dump));
 
-  m_downloadList->slot_map_erase()["9_delete_tied"] = sigc::bind<0>(&rpc::call_command_d_v_void, "d_delete_tied");
+  m_downloadList->slot_map_erase()["9_delete_tied"] = sigc::bind<0>(&rpc::call_command_d_v_void, "d.delete_tied");
 
   torrent::connection_manager()->set_signal_handshake_log(sigc::mem_fun(this, &Manager::handshake_log));
 }
 
 void
 Manager::cleanup() {
@@ -457,13 +457,13 @@
 
   std::transform(currentCache.begin(), currentCache.end(), std::back_inserter(*paths), std::mem_fun_ref(&utils::Directory::get_path));
 }
 
 bool
 manager_equal_tied(const std::string& path, Download* download) {
-  return path == rpc::call_command_d_string("get_d_tied_to_file", download);
+  return path == rpc::call_command_d_string("d.get_tied_to_file", download);
 }
 
 void
 Manager::try_create_download_expand(const std::string& uri, int flags, command_list_type commands) {
   std::vector<std::string> paths;
   paths.reserve(256);
@@ -501,13 +501,13 @@
       throw torrent::internal_error("core::Manager::receive_hashing_changed() (*itr)->is_hash_checked().");
   
     if ((*itr)->is_hash_checking() || (*itr)->is_hash_failed())
       continue;
 
     bool tryQuick =
-      rpc::call_command_d_value("get_d_hashing", *itr) == Download::variable_hashing_initial &&
+      rpc::call_command_d_value("d.get_hashing", *itr) == Download::variable_hashing_initial &&
       (*itr)->download()->file_list()->bitfield()->empty();
 
     if (!tryQuick && foundHashing)
       continue;
 
     try {
@@ -524,24 +524,24 @@
         if ((*itr)->download()->hash_check(true))
           continue;
 
         (*itr)->download()->hash_stop();
 
         if (foundHashing) {
-          rpc::call_command_d_set_value("set_d_hashing", *itr, Download::variable_hashing_rehash);
+          rpc::call_command_d_set_value("d.set_hashing", *itr, Download::variable_hashing_rehash);
           continue;
         }
       }
 
       (*itr)->download()->hash_check(false);
       foundHashing = true;
 
     } catch (torrent::local_error& e) {
       if (tryQuick) {
         // Make sure we don't repeat the quick hashing.
-        rpc::call_command_d_set_value("set_d_hashing", *itr, Download::variable_hashing_rehash);
+        rpc::call_command_d_set_value("d.set_hashing", *itr, Download::variable_hashing_rehash);
 
       } else {
         (*itr)->set_hash_failed(true);
         push_log(e.what());
       }
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/core/view_manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/view_manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/core/view_manager.cc	2007-07-20 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/view_manager.cc	2007-08-13 02:25:17.000000000 +0800
@@ -133,25 +133,25 @@
 
 //   m_sort["first"]        = new ViewSortNot(new ViewSort());
   m_sort["last"]          = new ViewSortFalse();
   m_sort["name"]          = new ViewSortName();
   m_sort["name_reverse"]  = new ViewSortReverse(new ViewSortName());
 
-  m_sort["stopped"]       = new ViewSortVariableValue("get_d_state");
-  m_sort["started"]       = new ViewSortVariableValue("get_d_state", true);
-  m_sort["complete"]      = new ViewSortVariableValue("get_d_complete");
-  m_sort["incomplete"]    = new ViewSortVariableValue("get_d_complete", true);
+  m_sort["stopped"]       = new ViewSortVariableValue("d.get_state");
+  m_sort["started"]       = new ViewSortVariableValue("d.get_state", true);
+  m_sort["complete"]      = new ViewSortVariableValue("d.get_complete");
+  m_sort["incomplete"]    = new ViewSortVariableValue("d.get_complete", true);
 
-  m_sort["state_changed"]         = new ViewSortVariableValue("get_d_state_changed");
-  m_sort["state_changed_reverse"] = new ViewSortVariableValue("get_d_state_changed", true);
+  m_sort["state_changed"]         = new ViewSortVariableValue("d.get_state_changed");
+  m_sort["state_changed_reverse"] = new ViewSortVariableValue("d.get_state_changed", true);
 
-  m_filter["started"]     = new ViewFilterVariableValue("get_d_state", 1);
-  m_filter["stopped"]     = new ViewFilterVariableValue("get_d_state", 0);
-  m_filter["complete"]    = new ViewFilterVariableValue("get_d_complete", 0, true);
-  m_filter["incomplete"]  = new ViewFilterVariableValue("get_d_complete", 0);
-  m_filter["hashing"]     = new ViewFilterVariableValue("get_d_hashing", 0, true);
+  m_filter["started"]     = new ViewFilterVariableValue("d.get_state", 1);
+  m_filter["stopped"]     = new ViewFilterVariableValue("d.get_state", 0);
+  m_filter["complete"]    = new ViewFilterVariableValue("d.get_complete", 0, true);
+  m_filter["incomplete"]  = new ViewFilterVariableValue("d.get_complete", 0);
+  m_filter["hashing"]     = new ViewFilterVariableValue("d.get_hashing", 0, true);
 }
 
 void
 ViewManager::clear() {
   std::for_each(begin(), end(), rak::call_delete<View>());
   std::for_each(m_sort.begin(), m_sort.end(), rak::on(rak::mem_ref(&sort_map::value_type::second), rak::call_delete<ViewSort>()));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/display/utils.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/utils.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/display/utils.cc	2007-07-26 00:51:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/utils.cc	2007-08-13 02:25:16.000000000 +0800
@@ -157,18 +157,18 @@
     first = print_download_time_left(first, last, d);
   } else {
     first = print_buffer(first, last, "                ");
   }
 
   first = print_buffer(first, last, " [%c%c R: %4.2f",
-                       rpc::call_command_d_string("get_d_tied_to_file", d).empty() ? ' ' : 'T',
-                       rpc::call_command_d_value("get_d_ignore_commands", d) == 0 ? ' ' : 'I',
-                       (double)rpc::call_command_d_value("get_d_ratio", d) / 1000.0);
+                       rpc::call_command_d_string("d.get_tied_to_file", d).empty() ? ' ' : 'T',
+                       rpc::call_command_d_value("d.get_ignore_commands", d) == 0 ? ' ' : 'I',
+                       (double)rpc::call_command_d_value("d.get_ratio", d) / 1000.0);
 
   if (d->priority() != 2)
-    first = print_buffer(first, last, " %s]", rpc::call_command_d_string("get_d_priority_str", d).c_str());
+    first = print_buffer(first, last, " %s]", rpc::call_command_d_string("d.get_priority_str", d).c_str());
   else
     first = print_buffer(first, last, "]");
 
   if (first > last)
     throw torrent::internal_error("print_download_info(...) wrote past end of the buffer.");
 
@@ -176,13 +176,13 @@
 }
 
 char*
 print_download_status(char* first, char* last, core::Download* d) {
   if (d->is_active())
     ;
-  else if (rpc::call_command_d_value("get_d_hashing", d) != 0)
+  else if (rpc::call_command_d_value("d.get_hashing", d) != 0)
     first = print_buffer(first, last, "Hashing: ");
   else if (!d->is_active())
     first = print_buffer(first, last, "Inactive: ");
 
   if (d->is_hash_checking()) {
     first = print_buffer(first, last, "Checking hash [%2i%%]",
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/main.cc	2007-07-25 23:45:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/main.cc	2007-08-12 03:05:45.000000000 +0800
@@ -217,12 +217,13 @@
        //     "schedule = view_stopped,10,10,view_sort=stopped,5\n"
        //     "schedule = view_complete,10,10,view_sort=complete,5\n"
        //     "schedule = view_incomplete,10,10,view_sort=incomplete,5\n"
 
        //"schedule = scheduler,10,10,download_scheduler=\n"
        "schedule = session_save,1800,1800,session_save=\n"
+       "schedule = low_diskspace,5,60,close_low_diskspace=500M\n"
 
        // Changing these will bork the (non-existant) scheduler.
        "view_add = scheduler\n"
        "view_sort_new = scheduler,state_changed\n" // add started?
        "view_sort_current = scheduler,state_changed\n"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/Makefile.am	2007-07-26 04:46:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/Makefile.am	2007-08-17 00:18:57.000000000 +0800
@@ -21,12 +21,13 @@
 	command_events.cc \
 	command_file.cc \
 	command_helpers.cc \
 	command_helpers.h \
 	command_local.cc \
 	command_network.cc \
+	command_peer.cc \
 	command_tracker.cc \
 	command_ui.cc \
 	control.cc \
 	control.h \
 	globals.cc \
 	globals.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/Makefile.in	2007-08-02 05:50:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/Makefile.in	2007-08-17 00:26:00.000000000 +0800
@@ -51,16 +51,16 @@
 am__installdirs = "$(DESTDIR)$(bindir)"
 binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
 PROGRAMS = $(bin_PROGRAMS)
 am_rtorrent_OBJECTS = command_download.$(OBJEXT) \
 	command_events.$(OBJEXT) command_file.$(OBJEXT) \
 	command_helpers.$(OBJEXT) command_local.$(OBJEXT) \
-	command_network.$(OBJEXT) command_tracker.$(OBJEXT) \
-	command_ui.$(OBJEXT) control.$(OBJEXT) globals.$(OBJEXT) \
-	main.$(OBJEXT) option_parser.$(OBJEXT) \
-	signal_handler.$(OBJEXT)
+	command_network.$(OBJEXT) command_peer.$(OBJEXT) \
+	command_tracker.$(OBJEXT) command_ui.$(OBJEXT) \
+	control.$(OBJEXT) globals.$(OBJEXT) main.$(OBJEXT) \
+	option_parser.$(OBJEXT) signal_handler.$(OBJEXT)
 rtorrent_OBJECTS = $(am_rtorrent_OBJECTS)
 rtorrent_DEPENDENCIES = $(top_srcdir)/src/ui/libsub_ui.a \
 	$(top_srcdir)/src/core/libsub_core.a \
 	$(top_srcdir)/src/display/libsub_display.a \
 	$(top_srcdir)/src/input/libsub_input.a \
 	$(top_srcdir)/src/rpc/libsub_rpc.a \
@@ -221,12 +221,13 @@
 	command_events.cc \
 	command_file.cc \
 	command_helpers.cc \
 	command_helpers.h \
 	command_local.cc \
 	command_network.cc \
+	command_peer.cc \
 	command_tracker.cc \
 	command_ui.cc \
 	control.cc \
 	control.h \
 	globals.cc \
 	globals.h \
@@ -310,12 +311,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_download.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_events.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_file.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_helpers.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_local.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_network.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_peer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_tracker.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_ui.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/control.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/globals.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/option_parser.Po@am__quote@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/command_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/command_map.cc	2007-07-28 21:15:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_map.cc	2007-08-17 00:23:09.000000000 +0800
@@ -82,12 +82,20 @@
 
   itr->second.m_target   = target_file;
   itr->second.m_fileSlot = targetSlot;
 }
 
 void
+CommandMap::insert_peer(key_type key, Command* variable, peer_slot targetSlot, int flags, const char* parm, const char* doc) {
+  iterator itr = insert(key, variable, flags, parm, doc);
+
+  itr->second.m_target   = target_peer;
+  itr->second.m_peerSlot = targetSlot;
+}
+
+void
 CommandMap::insert_tracker(key_type key, Command* variable, tracker_slot targetSlot, int flags, const char* parm, const char* doc) {
   iterator itr = insert(key, variable, flags, parm, doc);
 
   itr->second.m_target      = target_tracker;
   itr->second.m_trackerSlot = targetSlot;
 }
@@ -100,16 +108,18 @@
     throw torrent::internal_error("CommandMap::insert(...) tried to insert an already existing key.");
 
   itr = base_type::insert(itr, value_type(key, command_map_data_type(src.m_variable, src.m_flags | flag_dont_delete, src.m_parm, src.m_doc)));
 
   itr->second.m_target       = src.m_target;
 
+  // This _should_ be optimized int just one assignment.
   switch (itr->second.m_target) {
   case target_generic:  itr->second.m_genericSlot  = src.m_genericSlot; break;
   case target_download: itr->second.m_downloadSlot = src.m_downloadSlot; break;
   case target_file:     itr->second.m_fileSlot     = src.m_fileSlot; break;
+  case target_peer:     itr->second.m_peerSlot     = src.m_peerSlot; break;
   case target_tracker:  itr->second.m_trackerSlot  = src.m_trackerSlot; break;
   default: throw torrent::internal_error("CommandMap::insert(...) Invalid target.");
   }
 }
 
 const CommandMap::mapped_type
@@ -120,16 +130,18 @@
     throw torrent::input_error("Command \"" + std::string(key) + "\" does not exist.");
 
   if ((itr->second.m_target != target.first && itr->second.m_target != target_generic) ||
       (itr->second.m_target != target_generic && target.second == NULL))
     throw torrent::input_error("Command type mis-match.");
 
+  // This _should_ be optimized int just two calls.
   switch (itr->second.m_target) {
   case target_generic:  return itr->second.m_genericSlot(itr->second.m_variable, arg);
   case target_download: return itr->second.m_downloadSlot(itr->second.m_variable, (core::Download*)target.second, arg);
   case target_file:     return itr->second.m_fileSlot(itr->second.m_variable, (torrent::File*)target.second, arg);
+  case target_peer:     return itr->second.m_peerSlot(itr->second.m_variable, (torrent::Peer*)target.second, arg);
   case target_tracker:  return itr->second.m_trackerSlot(itr->second.m_variable, (torrent::Tracker*)target.second, arg);
   default: throw torrent::internal_error("CommandMap::call_command(...) Invalid target.");
   }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/command_map.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_map.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/command_map.h	2007-07-26 04:22:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_map.h	2007-08-17 00:50:27.000000000 +0800
@@ -45,12 +45,13 @@
 namespace core {
   class Download;
 }
 
 namespace torrent {
   class File;
+  class Peer;
   class Tracker;
 }
 
 namespace rpc {
 
 class Command;
@@ -63,23 +64,25 @@
   // Some commands will need to share data, like get/set a variable. So
   // instead of using a single virtual member function, each command
   // will register a member function pointer to be used instead.
   typedef const torrent::Object (*generic_slot) (Command*, const torrent::Object&);
   typedef const torrent::Object (*download_slot)(Command*, core::Download*, const torrent::Object&);
   typedef const torrent::Object (*file_slot)    (Command*, torrent::File*, const torrent::Object&);
+  typedef const torrent::Object (*peer_slot)    (Command*, torrent::Peer*, const torrent::Object&);
   typedef const torrent::Object (*tracker_slot) (Command*, torrent::Tracker*, const torrent::Object&);
 
   command_map_data_type(Command* variable, int flags, const char* parm, const char* doc) :
     m_variable(variable), m_flags(flags), m_parm(parm), m_doc(doc) {}
 
   Command*      m_variable;
 
   union {
     generic_slot  m_genericSlot;
     download_slot m_downloadSlot;
     file_slot     m_fileSlot;
+    peer_slot     m_peerSlot;
     tracker_slot  m_trackerSlot;
   };
 
   int           m_flags;
   int           m_target;
 
@@ -91,12 +94,13 @@
 public:
   typedef std::map<const char*, command_map_data_type, command_map_comp> base_type;
 
   typedef command_map_data_type::generic_slot  generic_slot;
   typedef command_map_data_type::download_slot download_slot;
   typedef command_map_data_type::file_slot     file_slot;
+  typedef command_map_data_type::peer_slot     peer_slot;
   typedef command_map_data_type::tracker_slot  tracker_slot;
 
   typedef torrent::Object         mapped_type;
   typedef mapped_type::value_type mapped_value_type;
 
   using base_type::iterator;
@@ -109,35 +113,38 @@
 
   typedef std::pair<int, void*> target_type;
 
   static const int target_generic  = 0;
   static const int target_download = 1;
   static const int target_file     = 2;
-  static const int target_tracker  = 3;
+  static const int target_peer     = 3;
+  static const int target_tracker  = 4;
 
   static const int flag_dont_delete   = 0x1;
   static const int flag_public_xmlrpc = 0x2;
 
   CommandMap() {}
   ~CommandMap();
 
   bool                has(const char* key) const        { return base_type::find(key) != base_type::end(); }
   bool                has(const std::string& key) const { return has(key.c_str()); }
 
   iterator            insert(key_type key, Command* variable, int flags, const char* parm, const char* doc);
 
-  void                insert_generic(key_type key, Command* variable, generic_slot targetSlot, int flags, const char* parm, const char* doc);
+  void                insert_generic (key_type key, Command* variable, generic_slot targetSlot,  int flags, const char* parm, const char* doc);
   void                insert_download(key_type key, Command* variable, download_slot targetSlot, int flags, const char* parm, const char* doc);
-  void                insert_file(key_type key, Command* variable, file_slot targetSlot, int flags, const char* parm, const char* doc);
-  void                insert_tracker(key_type key, Command* variable, tracker_slot targetSlot, int flags, const char* parm, const char* doc);
+  void                insert_file    (key_type key, Command* variable, file_slot targetSlot,     int flags, const char* parm, const char* doc);
+  void                insert_peer    (key_type key, Command* variable, peer_slot targetSlot,     int flags, const char* parm, const char* doc);
+  void                insert_tracker (key_type key, Command* variable, tracker_slot targetSlot,  int flags, const char* parm, const char* doc);
 
   void                insert(key_type key, const command_map_data_type src);
 
   const mapped_type   call_command(key_type key, const mapped_type& arg, target_type target = target_type((int)target_generic, NULL));
   const mapped_type   call_command_d(key_type key, core::Download* download, const mapped_type& arg)  { return call_command(key, arg, target_type((int)target_download, download)); }
   const mapped_type   call_command_f(key_type key, torrent::File* file, const mapped_type& arg)       { return call_command(key, arg, target_type((int)target_file, file)); }
+  const mapped_type   call_command_p(key_type key, torrent::Peer* peer, const mapped_type& arg)       { return call_command(key, arg, target_type((int)target_peer, peer)); }
   const mapped_type   call_command_t(key_type key, torrent::Tracker* tracker, const mapped_type& arg) { return call_command(key, arg, target_type((int)target_tracker, tracker)); }
 
 private:
   CommandMap(const CommandMap&);
   void operator = (const CommandMap&);
 };
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_peer_slot.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_peer_slot.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/exec_file.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/exec_file.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/exec_file.cc	2007-07-22 06:34:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/exec_file.cc	2007-08-12 02:59:23.000000000 +0800
@@ -33,30 +33,58 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include <string>
 #include <unistd.h>
+#include <rak/path.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 
 #include "exec_file.h"
+#include "parse.h"
 
 namespace rpc {
 
+// Close m_logFd.
+
 int
 ExecFile::execute(const char* file, char* const* argv) {
+  // Write the execued command and its parameters to the log fd.
+  if (m_logFd != -1) {
+    for (char* const* itr = argv; *itr != NULL; itr++) {
+      if (itr == argv)
+        write(m_logFd, "\n---\n", sizeof("\n---\n"));
+      else
+        write(m_logFd, " ", 1);
+
+      write(m_logFd, *itr, std::strlen(*itr));
+    }
+
+    write(m_logFd, "\n---\n", sizeof("\n---\n"));
+  }
+
   pid_t childPid = fork();
 
   if (childPid == -1)
     throw torrent::input_error("ExecFile::execute(...) Fork failed.");
 
   if (childPid == 0) {
+    ::close(0);
+    ::close(1);
+    ::close(2);
+
+    if (m_logFd != -1) {
+      dup2(m_logFd, 1);
+      dup2(m_logFd, 2);
+    }
+
     // Close all fd's.
-    for (int i = 0, last = sysconf(_SC_OPEN_MAX); i != last; i++)
+    for (int i = 3, last = sysconf(_SC_OPEN_MAX); i != last; i++)
       ::close(i);
 
     int result = execvp(file, argv);
 
     _exit(result);
 
@@ -64,56 +92,58 @@
     int status;
 
     if (waitpid(childPid, &status, 0) != childPid)
       throw torrent::internal_error("ExecFile::execute(...) waitpid failed.");
 
     // Check return value?
+    if (m_logFd) {
+      if (status == 0)
+        write(m_logFd, "\n--- Success ---\n", sizeof("\n--- Success ---\n"));
+      else
+        write(m_logFd, "\n--- Error ---\n", sizeof("\n--- Error ---\n"));
+    }
 
     return status;
   }
 }
 
 torrent::Object
-ExecFile::execute_object(const torrent::Object& rawArgs) {
-  char*  argsBuffer[128];
+ExecFile::execute_object(const torrent::Object& rawArgs, int flags) {
+  char*  argsBuffer[max_args];
   char** argsCurrent = argsBuffer;
 
-  // Size of strings are less than 24.
-  char   valueBuffer[3072];
+  // Size of value strings are less than 24.
+  char   valueBuffer[buffer_size];
   char*  valueCurrent = valueBuffer;
 
   const torrent::Object::list_type& args = rawArgs.as_list();
 
   if (args.empty())
     throw torrent::input_error("Too few arguments.");
 
   for (torrent::Object::list_type::const_iterator itr = args.begin(), last = args.end(); itr != last; itr++, argsCurrent++) {
-    if (argsCurrent == argsBuffer + 128 - 1)
+    if (argsCurrent == argsBuffer + max_args - 1)
       throw torrent::input_error("Too many arguments.");
 
-    switch (itr->type()) {
-    case torrent::Object::TYPE_STRING:
+    if (itr->is_string() && (!(flags & flag_expand_tilde) || *itr->as_string().c_str() != '~')) {
       *argsCurrent = const_cast<char*>(itr->as_string().c_str());
-      break;
 
-    case torrent::Object::TYPE_VALUE:
+    } else {
       *argsCurrent = valueCurrent;
+      valueCurrent = print_object(valueCurrent, valueBuffer + buffer_size, &*itr, flags) + 1;
 
-      valueCurrent += std::max(snprintf(valueCurrent, valueBuffer + 3072 - valueCurrent, "%lli", itr->as_value()), 0);
-      break;
-
-    default:
-      throw torrent::input_error("Invalid type.");
-    }
+      if (valueCurrent >= valueBuffer + buffer_size)
+        throw torrent::input_error("Overflowed execute arg buffer.");
+    }      
   }
 
   *argsCurrent = NULL;
 
   int status = execute(argsBuffer[0], argsBuffer);
 
-  if (status != 0)
-    throw torrent::input_error("ExecFile::execute_object(...) status != 0.");
+  if ((flags & flag_throw) && status != 0)
+    throw torrent::input_error("Bad return code.");
 
-  return torrent::Object();
+  return torrent::Object((int64_t)status);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/exec_file.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/exec_file.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/exec_file.h	2007-07-22 06:34:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/exec_file.h	2007-08-12 01:48:02.000000000 +0800
@@ -40,18 +40,28 @@
 #include <torrent/object.h>
 
 namespace rpc {
 
 class ExecFile {
 public:
-  
+  static const unsigned int max_args    = 128;
+  static const unsigned int buffer_size = 4096;
+    
+  static const int flag_expand_tilde = 0x1;
+  static const int flag_throw        = 0x2;
+
+  ExecFile() : m_logFd(-1) {}
+
+  int                 log_fd() const     { return m_logFd; }
+  void                set_log_fd(int fd) { m_logFd = fd; }
+
   int                 execute(const char* file, char* const* argv);
 
-  torrent::Object     execute_object(const torrent::Object& rawArgs);
+  torrent::Object     execute_object(const torrent::Object& rawArgs, int flags);
   
 private:
-
+  int                 m_logFd;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/Makefile.am	2007-07-26 04:58:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/Makefile.am	2007-08-17 01:14:06.000000000 +0800
@@ -3,12 +3,14 @@
 libsub_rpc_a_SOURCES = \
 	command.h \
 	command_download_slot.cc \
 	command_download_slot.h \
 	command_file_slot.cc \
 	command_file_slot.h \
+	command_peer_slot.cc \
+	command_peer_slot.h \
 	command_tracker_slot.cc \
 	command_tracker_slot.h \
 	command_map.cc \
 	command_map.h \
 	command_scheduler.cc \
 	command_scheduler.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/Makefile.in	2007-08-02 05:50:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/Makefile.in	2007-08-17 01:14:15.000000000 +0800
@@ -49,18 +49,18 @@
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 libsub_rpc_a_AR = $(AR) $(ARFLAGS)
 libsub_rpc_a_LIBADD =
 am_libsub_rpc_a_OBJECTS = command_download_slot.$(OBJEXT) \
-	command_file_slot.$(OBJEXT) command_tracker_slot.$(OBJEXT) \
-	command_map.$(OBJEXT) command_scheduler.$(OBJEXT) \
-	command_scheduler_item.$(OBJEXT) command_slot.$(OBJEXT) \
-	command_variable.$(OBJEXT) exec_file.$(OBJEXT) parse.$(OBJEXT) \
-	parse_commands.$(OBJEXT) scgi.$(OBJEXT) scgi_task.$(OBJEXT) \
-	xmlrpc.$(OBJEXT)
+	command_file_slot.$(OBJEXT) command_peer_slot.$(OBJEXT) \
+	command_tracker_slot.$(OBJEXT) command_map.$(OBJEXT) \
+	command_scheduler.$(OBJEXT) command_scheduler_item.$(OBJEXT) \
+	command_slot.$(OBJEXT) command_variable.$(OBJEXT) \
+	exec_file.$(OBJEXT) parse.$(OBJEXT) parse_commands.$(OBJEXT) \
+	scgi.$(OBJEXT) scgi_task.$(OBJEXT) xmlrpc.$(OBJEXT)
 libsub_rpc_a_OBJECTS = $(am_libsub_rpc_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
@@ -191,12 +191,14 @@
 libsub_rpc_a_SOURCES = \
 	command.h \
 	command_download_slot.cc \
 	command_download_slot.h \
 	command_file_slot.cc \
 	command_file_slot.h \
+	command_peer_slot.cc \
+	command_peer_slot.h \
 	command_tracker_slot.cc \
 	command_tracker_slot.h \
 	command_map.cc \
 	command_map.h \
 	command_scheduler.cc \
 	command_scheduler.h \
@@ -267,12 +269,13 @@
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_download_slot.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_file_slot.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_map.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_peer_slot.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_scheduler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_scheduler_item.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_slot.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_tracker_slot.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_variable.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exec_file.Po@am__quote@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/parse.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/parse.cc	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse.cc	2007-08-11 19:56:34.000000000 +0800
@@ -34,12 +34,13 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <locale>
+#include <rak/path.h>
 #include <torrent/exceptions.h>
 
 #include "parse.h"
 
 namespace rpc {
 
@@ -57,13 +58,13 @@
     first++;
 
   return first;
 }
 
 const char*
-parse_string(const char* first, const char* last, std::string* dest) {
+parse_string(const char* first, const char* last, std::string* dest, bool (*delim)(const char)) {
   if (first == last)
     return first;
 
   bool quoted = parse_is_quote(*first);
 
   if (quoted)
@@ -72,19 +73,18 @@
   while (first != last) {
     if (quoted) {
       if (parse_is_quote(*first))
         return ++first;
 
     } else {
-      if (parse_is_seperator(*first) || std::isspace(*first))
+      if (delim(*first))
         return first;
     }
         
-    if (parse_is_escape(*first))
-      if (++first == last)
-        throw torrent::input_error("Escape character at end of input.");
+    if (parse_is_escape(*first) && ++first == last)
+      throw torrent::input_error("Escape character at end of input.");
 
     dest->push_back(*first);
     first++;
   }
   
   if (quoted)
@@ -163,51 +163,67 @@
   default: *value = *value * unit; break;
   }
 
   return last;
 }
 
+// Somewhat ugly...
 const char*
-parse_list(const char* first, const char* last, torrent::Object* dest) {
+parse_object(const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char)) {
+  if (*first == '{') {
+    *dest = torrent::Object(torrent::Object::TYPE_LIST);
+    first = parse_list(first + 1, last, dest, &parse_is_delim_list);
+    first = parse_skip_wspace(first, last);
+    
+    if (first == last || *first != '}')
+      throw torrent::input_error("Could not find closing '}'.");
+
+    return ++first;
+
+  } else {
+    *dest = std::string();
+
+    return parse_string(first, last, &dest->as_string(), delim);
+  }
+}
+
+const char*
+parse_list(const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char)) {
   if (!dest->is_list())
     throw torrent::internal_error("parse_list(...) !dest->is_list().");
 
   while (true) {
-    std::string str;
+    torrent::Object tmp;
 
     first = parse_skip_wspace(first, last);
-    first = parse_string(first, last, &str);
+    first = parse_object(first, last, &tmp, delim);
     first = parse_skip_wspace(first, last);
 
-    dest->as_list().push_back(str);
+    dest->as_list().push_back(tmp);
     
     if (first == last || !parse_is_seperator(*first))
       break;
 
     first++;
   }
 
   return first;
 }
 
 const char*
 parse_whole_list(const char* first, const char* last, torrent::Object* dest) {
-  std::string str;
-
   first = parse_skip_wspace(first, last);
-  first = parse_string(first, last, &str);
+  first = parse_object(first, last, dest);
   first = parse_skip_wspace(first, last);
 
   if (first != last && parse_is_seperator(*first)) {
-    *dest = torrent::Object(torrent::Object::TYPE_LIST);
+    torrent::Object tmp = torrent::Object(torrent::Object::TYPE_LIST);
+    tmp.swap(*dest);
 
-    dest->as_list().push_back(str);
+    dest->as_list().push_back(tmp);
     first = parse_list(++first, last, dest);
-
-  } else {
-    *dest = str;
   }
 
   return first;
 }
 
 std::string
@@ -330,7 +346,47 @@
     return false;
   }
   
   return true;
 }
 
+char*
+print_object(char* first, char* last, const torrent::Object* src, int flags) {
+  switch (src->type()) {
+  case torrent::Object::TYPE_STRING:
+  {
+    const std::string& str = src->as_string();
+
+    if ((flags & print_expand_tilde) && *str.c_str() == '~') {
+      return rak::path_expand(str.c_str(), first, last);
+
+    } else {
+      if (first == last)
+        return first;
+
+      size_t n = std::min<size_t>(str.size(), std::distance(first, last) - 1);
+
+      std::memcpy(first, str.c_str(), n);
+      *(first += n) = '\0';
+
+      return first;
+    }
+  }
+  case torrent::Object::TYPE_VALUE:
+    return std::max(first + snprintf(first, std::distance(first, last), "%lli", src->as_value()), last);
+
+  case torrent::Object::TYPE_LIST:
+    for (torrent::Object::list_type::const_iterator itr = src->as_list().begin(), itrEnd = src->as_list().end(); itr != itrEnd; itr++) {
+      first = print_object(first, last, &*itr, flags);
+
+      // Don't expand tilde after the first element in the list.
+      flags &= ~print_expand_tilde;
+    }
+
+    return first;
+
+  default:
+    throw torrent::input_error("Invalid type.");
+  }
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/parse_commands.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse_commands.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/parse_commands.cc	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse_commands.cc	2007-08-13 03:47:40.000000000 +0800
@@ -74,12 +74,29 @@
   while (last != first && *--last == '\\')
     escaped++;
 
   return escaped;
 }
 
+// Replace any strings starting with '$' with the result of the
+// result of the command.
+//
+// Find a better name.
+void
+parse_command_execute(core::Download* download, torrent::Object* object) {
+  if (object->is_list()) {
+    for (torrent::Object::list_type::iterator itr = object->as_list().begin(), last = object->as_list().end(); itr != last; itr++)
+      parse_command_execute(download, &*itr);
+
+  } else if (*object->as_string().c_str() == '$') {
+    const std::string& str = object->as_string();
+
+    *object = parse_command_d_single(download, str.c_str() + 1, str.c_str() + str.size());
+  }
+}
+
 // Set 'download' to NULL to call the generic functions, thus reusing
 // the code below for both cases.
 std::pair<torrent::Object, const char*>
 parse_command(core::Download* download, const char* first, const char* last) {
   first = std::find_if(first, last, std::not1(command_map_is_space()));
 
@@ -107,28 +124,13 @@
 
     first++;
   }
 
   // Replace any strings starting with '$' with the result of the
   // following command.
-  if (args.is_list()) {
-    for (torrent::Object::list_type::iterator itr = args.as_list().begin(), last = args.as_list().end(); itr != last; itr++) {
-      if (!itr->is_string())
-        continue;
-
-      const std::string& str = itr->as_string();
-
-      if (*str.c_str() == '$')
-        *itr = parse_command_d_single(download, str.c_str() + 1, str.c_str() + str.size());
-    }
-
-  } else if (*args.as_string().c_str() == '$') {
-    const std::string& str = args.as_string();
-
-    args = parse_command_d_single(download, str.c_str() + 1, str.c_str() + str.size());
-  }
+  parse_command_execute(download, &args);
 
   return std::make_pair(commands.call_command_d(key.c_str(), download, args), first);
 }
 
 void
 parse_command_single(const char* first) {
@@ -199,13 +201,13 @@
 // Use a static length buffer for dest.
 const char*
 parse_command_name(const char* first, const char* last, std::string* dest) {
   if (first == last || !std::isalpha(*first))
     throw torrent::input_error("Invalid start of name.");
 
-  for ( ; first != last && (std::isalnum(*first) || *first == '_'); ++first)
+  for ( ; first != last && (std::isalnum(*first) || *first == '_' || *first == '.'); ++first)
     dest->push_back(*first);
 
   return first;
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/parse_commands.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse_commands.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/parse_commands.h	2007-07-26 04:39:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse_commands.h	2007-08-17 04:05:22.000000000 +0800
@@ -102,17 +102,15 @@
 inline void            call_command_d_v_void(const char* key, core::Download* download) { commands.call_command_d(key, download, torrent::Object()); }
 
 inline void            call_command_d_set_value(const char* key, core::Download* download, int64_t arg)                        { commands.call_command_d(key, download, torrent::Object(arg)); }
 inline void            call_command_d_set_string(const char* key, core::Download* download, const std::string& arg)            { commands.call_command_d(key, download, torrent::Object(arg)); }
 inline void            call_command_d_set_std_string(const std::string& key, core::Download* download, const std::string& arg) { commands.call_command_d(key.c_str(), download, torrent::Object(arg)); }
 
-inline torrent::Object call_command_f(const char* key, torrent::File* file, const torrent::Object& obj)       { return commands.call_command_f(key, file, obj); }
-inline torrent::Object call_command_t(const char* key, torrent::Tracker* tracker, const torrent::Object& obj) { return commands.call_command_t(key, tracker, obj); }
-
 inline torrent::Object
 call_command_d_range(const char* key, core::Download* download, torrent::Object::list_type::const_iterator first, torrent::Object::list_type::const_iterator last) {
+  // Change to using range ctor.
   torrent::Object rawArgs(torrent::Object::TYPE_LIST);
   torrent::Object::list_type& args = rawArgs.as_list();
   
   while (first != last)
     args.push_back(*first++);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/parse.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/parse.h	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse.h	2007-08-11 19:53:48.000000000 +0800
@@ -51,25 +51,29 @@
 
 inline bool parse_is_quote(const char c)     { return c == '"'; }
 inline bool parse_is_escape(const char c)    { return c == '\\'; }
 inline bool parse_is_seperator(const char c) { return c == ','; }
 inline bool parse_is_space(const char c)     { return c == ' ' || c == '\t'; }
 
+inline bool parse_is_delim_default(const char c) { return parse_is_seperator(c) || std::isspace(c); }
+inline bool parse_is_delim_list(const char c)    { return parse_is_seperator(c) || c == '}' || std::isspace(c); }
+
 const char* parse_skip_wspace(const char* first);
 const char* parse_skip_wspace(const char* first, const char* last);
 
-const char* parse_string(const char* first, const char* last, std::string* dest);
+const char* parse_string(const char* first, const char* last, std::string* dest, bool (*delim)(const char) = &parse_is_delim_default);
 void        parse_whole_string(const char* first, const char* last, std::string* dest);
 
 const char* parse_value(const char* src, int64_t* value, int base = 0, int unit = 1);
 const char* parse_value_nothrow(const char* src, int64_t* value, int base = 0, int unit = 1);
 
 void        parse_whole_value(const char* src, int64_t* value, int base = 0, int unit = 1);
 bool        parse_whole_value_nothrow(const char* src, int64_t* value, int base = 0, int unit = 1);
 
-const char* parse_list(const char* first, const char* last, torrent::Object* dest);
+const char* parse_object(const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char) = &parse_is_delim_default);
+const char* parse_list(const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char) = &parse_is_delim_default);
 const char* parse_whole_list(const char* first, const char* last, torrent::Object* dest);
 
 std::string convert_list_to_string(const torrent::Object& src);
 std::string convert_list_to_string(torrent::Object::list_type::const_iterator first, torrent::Object::list_type::const_iterator last);
 std::string convert_list_to_command(torrent::Object::list_type::const_iterator first, torrent::Object::list_type::const_iterator last);
 
@@ -81,9 +85,13 @@
   if (args.type() == torrent::Object::TYPE_LIST && args.as_list().size() == 1)
     return args.as_list().front();
   else
     return args;
 }
 
+static const int print_expand_tilde = 0x1;
+
+char*       print_object(char* first, char* last, const torrent::Object* src, int flags);
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/scgi_task.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/scgi_task.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/scgi_task.cc	2007-07-20 19:16:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/scgi_task.cc	2007-08-16 03:43:28.000000000 +0800
@@ -55,16 +55,17 @@
 // static rak::timer scgiTimer;
 
 namespace rpc {
 
 void
 SCgiTask::open(SCgi* parent, int fd) {
-  m_parent = parent;
+  m_parent   = parent;
   m_fileDesc = fd;
-  m_buffer = new char[(m_bufferSize = 2048)];
+  m_buffer   = new char[(m_bufferSize = default_buffer_size) + 1];
   m_position = m_buffer;
+  m_body     = NULL;
 
   control->poll()->open(this);
   control->poll()->insert_read(this);
   control->poll()->insert_error(this);
 
 //   scgiTimer = rak::timer::current();
@@ -91,60 +92,83 @@
 //   sprintf(buffer, "SCgi system call processed: %i", (int)(rak::timer::current() - scgiTimer).usec());
 //   control->core()->push_log(std::string(buffer));
 }
 
 void
 SCgiTask::event_read() {
-  int bytes = ::recv(m_fileDesc, m_position, m_bufferSize - 1 - (m_position - m_buffer), 0);
+  int bytes = ::recv(m_fileDesc, m_position, m_bufferSize - (m_position - m_buffer), 0);
 
   if (bytes == -1) {
     if (!rak::error_number::current().is_blocked_momentary())
       close();
 
     return;
   }
 
+  // The buffer has space to nul-terminate to ease the parsing below.
   m_position += bytes;
   *m_position = '\0';
 
-  // Don't bother caching the parsed values, as we're likely to
-  // receive all the data we need the first time.
-  char* current;
-  char* contentPos;
+  if (m_body == NULL) {
+    // Don't bother caching the parsed values, as we're likely to
+    // receive all the data we need the first time.
+    char* current;
 
-  int headerSize = strtol(m_buffer, &current, 0);
-  int contentSize;
+    int contentSize;
+    int headerSize = strtol(m_buffer, &current, 0);
 
-  if (current == m_buffer || current == m_position)
-    // Need to validate the header size.
-    return;
+    if (current == m_buffer || current == m_position)
+      return;
 
-  if (*current != ':' || headerSize < 17)
-    goto event_read_failed;
+    if (*current != ':' || headerSize < 17 || headerSize > max_header_size)
+      goto event_read_failed;
 
-  if (std::distance(++current, m_position) < headerSize + 1)
-    return;
+    if (std::distance(++current, m_position) < headerSize + 1)
+      return;
+
+    if (std::memcmp(current, "CONTENT_LENGTH", 15) != 0)
+      goto event_read_failed;
+
+    char* contentPos;
+    contentSize = strtol(current + 15, &contentPos, 0);
+
+    if (*contentPos != '\0' || contentSize <= 0 || contentSize > max_content_size)
+      goto event_read_failed;
 
-  if (std::memcmp(current, "CONTENT_LENGTH", 15) != 0)
-    goto event_read_failed;
+    m_body = current + headerSize + 1;
+    headerSize = std::distance(m_buffer, m_body);
 
-  contentSize = strtol(current + 15, &contentPos, 0);
+    if ((unsigned int)(contentSize + headerSize) < m_bufferSize) {
+      m_bufferSize = contentSize + headerSize;
 
-  if (*contentPos != '\0' || contentSize <= 0)
-    goto event_read_failed;
+    } else if ((unsigned int)(contentSize + headerSize) <= default_buffer_size) {
+      m_bufferSize = contentSize;
 
-  // Start of the data.
-  current += headerSize + 1;
+      std::memmove(m_buffer, m_body, std::distance(m_body, m_position));
+      m_position = m_buffer + std::distance(m_body, m_position);
+      m_body = m_buffer;
 
-  if (std::distance(current, m_position) < contentSize)
+    } else {
+      char* tmp = new char[(m_bufferSize = contentSize)];
+      std::memcpy(tmp, m_body, std::distance(m_body, m_position));
+      delete [] m_buffer;
+
+      m_position = tmp + std::distance(m_body, m_position);
+      m_buffer = tmp;
+      m_body = tmp;
+    }
+  }
+
+  if ((unsigned int)std::distance(m_buffer, m_position) != m_bufferSize)
     return;
 
   control->poll()->remove_read(this);
   control->poll()->insert_write(this);
 
-  if (!m_parent->receive_call(this, current, contentSize))
+  // Close if the call failed, else stay open to write back data.
+  if (!m_parent->receive_call(this, m_body, m_bufferSize - std::distance(m_buffer, m_body)))
     close();
 
   return;
 
  event_read_failed:
   throw torrent::internal_error("SCgiTask::event_read() fault not handled.");
@@ -172,13 +196,14 @@
 SCgiTask::event_error() {
   close();
 }
 
 bool
 SCgiTask::receive_write(const char* buffer, uint32_t length) {
-  if (length + 256 > m_bufferSize) {
+  // Need to cast due to a bug in MacOSX gcc-4.0.1.
+  if (length + 256 > std::max(m_bufferSize, (unsigned int)default_buffer_size)) {
     delete [] m_buffer;
     m_buffer = new char[length + 256];
   }
 
   // Who ever bothers to check the return value?
   int headerSize = sprintf(m_buffer, "Status: 200 OK\r\nContent-Type: text/xml\r\nContent-Length: %i\r\n\r\n", length);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/scgi_task.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/scgi_task.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/scgi_task.h	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/scgi_task.h	2007-08-16 03:35:33.000000000 +0800
@@ -46,12 +46,16 @@
 namespace rpc {
 
 class SCgi;
 
 class SCgiTask : public torrent::Event {
 public:
+  static const unsigned int default_buffer_size = 2047;
+  static const          int max_header_size     = 2000;
+  static const          int max_content_size    = (128 << 10);
+
   SCgiTask() { m_fileDesc = -1; }
 
   bool                is_open() const      { return m_fileDesc != -1; }
   bool                is_available() const { return m_fileDesc == -1; }
 
   void                open(SCgi* parent, int fd);
@@ -67,12 +71,14 @@
 
 private:
   SCgi*               m_parent;
 
   char*               m_buffer;
   char*               m_position;
+  char*               m_body;
+
   unsigned int        m_bufferSize;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/xmlrpc.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/xmlrpc.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/rpc/xmlrpc.cc	2007-07-27 20:42:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/xmlrpc.cc	2007-08-17 04:06:32.000000000 +0800
@@ -394,13 +394,13 @@
   torrent::Object object = xmlrpc_to_object_target(env, args, XmlRpc::call_file, (void**)&file);
 
   if (env->fault_occurred)
     return NULL;
 
   try {
-    return object_to_xmlrpc(env, rpc::call_command_f((const char*)voidServerInfo, file, object));
+    return object_to_xmlrpc(env, rpc::commands.call_command_f((const char*)voidServerInfo, file, object));
 
   } catch (torrent::local_error& e) {
     xmlrpc_env_set_fault(env, XMLRPC_PARSE_ERROR, e.what());
     return NULL;
   }
 }
@@ -411,13 +411,13 @@
   torrent::Object   object = xmlrpc_to_object_target(env, args, XmlRpc::call_tracker, (void**)&tracker);
 
   if (env->fault_occurred)
     return NULL;
 
   try {
-    return object_to_xmlrpc(env, rpc::call_command_t((const char*)voidServerInfo, tracker, object));
+    return object_to_xmlrpc(env, rpc::commands.call_command_t((const char*)voidServerInfo, tracker, object));
 
   } catch (torrent::local_error& e) {
     xmlrpc_env_set_fault(env, XMLRPC_PARSE_ERROR, e.what());
     return NULL;
   }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/download.cc	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/download.cc	2007-08-13 02:25:16.000000000 +0800
@@ -151,39 +151,39 @@
   element->push_column("Local id:",         te_string(&torrent::Download::local_id, string_base::flag_escape_html));
   element->push_column("Info hash:",        te_string(&torrent::Download::info_hash, string_base::flag_escape_hex));
   element->push_column("Created:",          te_value(&torrent::Download::creation_date, value_base::flag_date), " ", te_value(&torrent::Download::creation_date, value_base::flag_time));
 
   element->push_back("");
   element->push_column("Directory:",        te_string(&torrent::FileList::root_dir));
-  element->push_column("Tied to file:",     te_variable_string("get_d_tied_to_file"));
+  element->push_column("Tied to file:",     te_variable_string("d.get_tied_to_file"));
   element->push_column("File stats:",
                        te_branch(&core::Download::c_file_list, &torrent::FileList::is_multi_file, te_string("multi"), te_string("single")),
                        " ", te_value(&torrent::FileList::size_files), " files");
 
   element->push_back("");
   element->push_column("Chunks:",           te_value(&torrent::FileList::completed_chunks), " / ", te_value(&torrent::FileList::size_chunks), " * ", te_value(&torrent::FileList::chunk_size));
-  element->push_column("Priority:",         te_variable_value("get_d_priority"));
+  element->push_column("Priority:",         te_variable_value("d.get_priority"));
 
-  element->push_column("State changed:",    te_variable_value("get_d_state_changed", value_base::flag_timer | value_base::flag_elapsed));
+  element->push_column("State changed:",    te_variable_value("d.get_state_changed", value_base::flag_timer | value_base::flag_elapsed));
 
   element->push_back("");
   element->push_column("Memory usage:",     te_value(&torrent::ChunkManager::memory_usage, value_base::flag_mb), " MB");
   element->push_column("Max memory usage:", te_value(&torrent::ChunkManager::max_memory_usage, value_base::flag_mb), " MB");
   element->push_column("Free diskspace:",   te_value(&torrent::FileList::free_diskspace, value_base::flag_mb), " MB");
   element->push_column("Safe diskspace:",   te_value(&torrent::ChunkManager::safe_free_diskspace, value_base::flag_mb), " MB");
 
   element->push_back("");
-  element->push_column("Connection type:",  te_variable_string("get_d_connection_current"));
+  element->push_column("Connection type:",  te_variable_string("d.get_connection_current"));
   element->push_column("Safe sync:",        te_branch(&torrent::ChunkManager::safe_sync, torrent::chunk_manager(), te_string("yes"), te_string("no")));
   element->push_column("Send buffer:",      te_value(&torrent::ConnectionManager::send_buffer_size, value_base::flag_kb), " KB");
   element->push_column("Receive buffer:",   te_value(&torrent::ConnectionManager::receive_buffer_size, value_base::flag_kb), " KB");
 
   element->push_back("");
-  element->push_column("Upload:",           te_variable_value("get_d_up_rate", value_base::flag_kb), " KB / ", te_variable_value("get_d_up_total", value_base::flag_xb));
-  element->push_column("Download:",         te_variable_value("get_d_down_rate", value_base::flag_kb), " KB / ", te_variable_value("get_d_down_total", value_base::flag_xb));
-  element->push_column("Skipped:",          te_variable_value("get_d_skip_rate", value_base::flag_kb), " KB / ", te_variable_value("get_d_skip_total", value_base::flag_xb));
+  element->push_column("Upload:",           te_variable_value("d.get_up_rate", value_base::flag_kb), " KB / ", te_variable_value("d.get_up_total", value_base::flag_xb));
+  element->push_column("Download:",         te_variable_value("d.get_down_rate", value_base::flag_kb), " KB / ", te_variable_value("d.get_down_total", value_base::flag_xb));
+  element->push_column("Skipped:",          te_variable_value("d.get_skip_rate", value_base::flag_kb), " KB / ", te_variable_value("d.get_skip_total", value_base::flag_xb));
   element->push_column("Preload:",          te_value(&torrent::ChunkManager::preload_type), " / ", te_value(&torrent::ChunkManager::stats_preloaded), " / ", te_value(&torrent::ChunkManager::stats_not_preloaded));
 
   element->set_column_width(element->column_width() + 1);
 
   return element;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/download_list.cc	2007-07-21 07:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/download_list.cc	2007-08-13 02:25:16.000000000 +0800
@@ -285,14 +285,14 @@
       break;
 
     case INPUT_CHANGE_DIRECTORY:
       if (current_view()->focus() == current_view()->end_visible())
         throw torrent::input_error("No download in focus to change root directory.");
 
-      rpc::call_command_d("set_d_directory", *current_view()->focus(), rak::trim(input->str()));
-      control->core()->push_log_std("New root directory \"" + rpc::call_command_d_string("get_d_directory", *current_view()->focus()) + "\" for torrent.");
+      rpc::call_command_d("d.set_directory", *current_view()->focus(), rak::trim(input->str()));
+      control->core()->push_log_std("New root directory \"" + rpc::call_command_d_string("d.get_directory", *current_view()->focus()) + "\" for torrent.");
       break;
 
     case INPUT_COMMAND:
       rpc::parse_command_d_single_std(current_view()->focus() != current_view()->end_visible() ? *current_view()->focus() : NULL, input->str());
       break;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/element_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/element_download_list.cc	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_download_list.cc	2007-08-13 02:25:16.000000000 +0800
@@ -149,13 +149,13 @@
 
 void
 ElementDownloadList::receive_stop_download() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
-  if (rpc::call_command_d_value("get_d_state", *m_view->focus()) == 1)
+  if (rpc::call_command_d_value("d.get_state", *m_view->focus()) == 1)
     control->core()->download_list()->stop_normal(*m_view->focus());
   else
     control->core()->download_list()->erase_ptr(*m_view->focus());
 
   m_view->set_last_changed();
 }
@@ -164,13 +164,13 @@
 ElementDownloadList::receive_close_download() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
   core::Download* download = *m_view->focus();
 
-  rpc::call_command_d("set_d_ignore_commands", download, (int64_t)1);
+  rpc::call_command_d("d.set_ignore_commands", download, (int64_t)1);
 
   control->core()->download_list()->stop_normal(download);
   control->core()->download_list()->close(download);
   m_view->set_last_changed();
 }
 
@@ -203,30 +203,30 @@
 
 void
 ElementDownloadList::receive_ignore_ratio() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
-  if (rpc::call_command_d_value("get_d_ignore_commands", *m_view->focus()) != 0) {
-    rpc::call_command_d_set_value("set_d_ignore_commands", *m_view->focus(), (int64_t)0);
+  if (rpc::call_command_d_value("d.get_ignore_commands", *m_view->focus()) != 0) {
+    rpc::call_command_d_set_value("d.set_ignore_commands", *m_view->focus(), (int64_t)0);
     control->core()->push_log("Torrent set to heed commands.");
   } else {
-    rpc::call_command_d_set_value("set_d_ignore_commands", *m_view->focus(), (int64_t)1);
+    rpc::call_command_d_set_value("d.set_ignore_commands", *m_view->focus(), (int64_t)1);
     control->core()->push_log("Torrent set to ignore commands.");
   }
 }
 
 void
 ElementDownloadList::receive_clear_tied() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
-  const std::string& tiedFile = rpc::call_command_d_string("get_d_tied_to_file", *m_view->focus());
+  const std::string& tiedFile = rpc::call_command_d_string("d.get_tied_to_file", *m_view->focus());
 
   if (!tiedFile.empty()) {
-    rpc::call_command_d_void("d_delete_tied", *m_view->focus());
+    rpc::call_command_d_void("d.delete_tied", *m_view->focus());
 
     control->core()->push_log("Cleared tied to file association for the selected download.");
   }
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/root.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/root.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/root.cc	2007-07-20 05:23:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/root.cc	2007-08-03 03:53:42.000000000 +0800
@@ -61,16 +61,13 @@
 Root::Root() :
   m_control(NULL),
   m_downloadList(NULL),
   m_windowTitle(NULL),
   m_windowHttpQueue(NULL),
   m_windowInput(NULL),
-  m_windowStatusbar(NULL),
-
-  m_maxUploadsGlobal(0),
-  m_maxDownloadsGlobal(0) {
+  m_windowStatusbar(NULL) {
 }
 
 void
 Root::init(Control* c) {
   if (m_control != NULL)
     throw std::logic_error("Root::init() called twice on the same object");
@@ -184,59 +181,61 @@
 Root::set_down_throttle(unsigned int throttle) {
   if (m_windowStatusbar != NULL)
     m_windowStatusbar->mark_dirty();
 
   torrent::set_down_throttle(throttle * 1024);
 
-  int64_t div = rpc::call_command_value("get_max_downloads_div");
+  unsigned int div    = std::max<int>(rpc::call_command_value("get_max_downloads_div"), 0);
+  unsigned int global = std::max<int>(rpc::call_command_value("get_max_downloads_global"), 0);
 
-  if (throttle == 0 || div <= 0) {
-    torrent::set_max_download_unchoked(m_maxDownloadsGlobal);
+  if (throttle == 0 || div == 0) {
+    torrent::set_max_download_unchoked(global);
     return;
   }
 
   throttle /= rpc::call_command_value("get_max_downloads_div");
 
   unsigned int maxUnchoked;
 
   if (throttle <= 10)
     maxUnchoked = 1 + throttle / 1;
   else
     maxUnchoked = 10 + throttle / 5;
 
-  if (m_maxDownloadsGlobal != 0)
-    torrent::set_max_download_unchoked(std::min(maxUnchoked, m_maxDownloadsGlobal));
+  if (global != 0)
+    torrent::set_max_download_unchoked(std::min(maxUnchoked, global));
   else
     torrent::set_max_download_unchoked(maxUnchoked);
 }
 
 void
 Root::set_up_throttle(unsigned int throttle) {
   if (m_windowStatusbar != NULL)
     m_windowStatusbar->mark_dirty();
 
   torrent::set_up_throttle(throttle * 1024);
 
-  int64_t div = rpc::call_command_value("get_max_uploads_div");
+  unsigned int div    = std::max<int>(rpc::call_command_value("get_max_uploads_div"), 0);
+  unsigned int global = std::max<int>(rpc::call_command_value("get_max_uploads_global"), 0);
 
-  if (throttle == 0 || div <= 0) {
-    torrent::set_max_unchoked(m_maxUploadsGlobal);
+  if (throttle == 0 || div == 0) {
+    torrent::set_max_unchoked(global);
     return;
   }
 
   throttle /= rpc::call_command_value("get_max_uploads_div");
 
   unsigned int maxUnchoked;
 
   if (throttle <= 10)
     maxUnchoked = 1 + throttle / 1;
   else
     maxUnchoked = 10 + throttle / 5;
 
-  if (m_maxUploadsGlobal != 0)
-    torrent::set_max_unchoked(std::min(maxUnchoked, m_maxUploadsGlobal));
+  if (global != 0)
+    torrent::set_max_unchoked(std::min(maxUnchoked, global));
   else
     torrent::set_max_unchoked(maxUnchoked);
 }
 
 void
 Root::adjust_down_throttle(int throttle) {
@@ -246,32 +245,12 @@
 void
 Root::adjust_up_throttle(int throttle) {
   set_up_throttle(std::max<int>(torrent::up_throttle() / 1024 + throttle, 0));
 }
 
 void
-Root::set_max_uploads_global(int64_t slots) {
-  if (slots < 0)
-    throw torrent::input_error("Out of range.");
-
-  m_maxUploadsGlobal = slots;
-
-  set_up_throttle(torrent::up_throttle() / 1024);
-}
-
-void
-Root::set_max_downloads_global(int64_t slots) {
-  if (slots < 0)
-    throw torrent::input_error("Out of range.");
-
-  m_maxDownloadsGlobal = slots;
-
-  set_down_throttle(torrent::down_throttle() / 1024);
-}
-
-void
 Root::enable_input(const std::string& title, input::TextInput* input) {
   if (m_windowInput->input() != NULL)
     throw torrent::internal_error("Root::enable_input(...) m_windowInput->input() != NULL.");
 
   input->slot_dirty(sigc::mem_fun(m_windowInput, &WInput::mark_dirty));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/root.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/root.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/ui/root.h	2007-07-20 05:23:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/root.h	2007-08-03 03:37:08.000000000 +0800
@@ -81,18 +81,12 @@
   void                set_down_throttle_i64(int64_t throttle) { set_down_throttle(throttle >> 10); }
   void                set_up_throttle_i64(int64_t throttle)   { set_up_throttle(throttle >> 10); }
 
   void                adjust_down_throttle(int throttle);
   void                adjust_up_throttle(int throttle);
 
-  unsigned int        max_uploads_global()                    { return m_maxUploadsGlobal; }
-  void                set_max_uploads_global(int64_t slots);
-
-  unsigned int        max_downloads_global()                  { return m_maxDownloadsGlobal; }
-  void                set_max_downloads_global(int64_t slots);
-
   void                enable_input(const std::string& title, input::TextInput* input);
   void                disable_input();
 
   input::TextInput*   current_input();
 
 private:
@@ -104,14 +98,11 @@
   WTitle*             m_windowTitle;
   WHttpQueue*         m_windowHttpQueue;
   WInput*             m_windowInput;
   WStatusbar*         m_windowStatusbar;
 
   input::Bindings     m_bindings;
-
-  unsigned int        m_maxUploadsGlobal;
-  unsigned int        m_maxDownloadsGlobal;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/utils/socket_fd.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/utils/socket_fd.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.6/src/utils/socket_fd.cc	2007-07-20 05:23:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/utils/socket_fd.cc	2007-08-07 21:46:00.000000000 +0800
@@ -91,13 +91,13 @@
 }
 
 // bool
 // SocketFd::set_bind_to_device(const char* device) {
 //   check_valid();
 //   struct ifreq ifr;
-//   strncpy(ifr.ifr_name, device, IFNAMSIZ);
+//   strlcpy(ifr.ifr_name, device, IFNAMSIZ);
 
 //   return setsockopt(m_fd, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == 0;
 // }
 
 bool
 SocketFd::set_send_buffer_size(uint32_t s) {
