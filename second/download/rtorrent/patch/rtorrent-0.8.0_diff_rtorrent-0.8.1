diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/configure	2008-01-29 02:09:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/configure	2008-04-17 20:41:16.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.61 for rtorrent 0.8.0.
+# Generated by GNU Autoconf 2.61 for rtorrent 0.8.1.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
@@ -725,14 +725,14 @@
 MAKEFLAGS=
 SHELL=${CONFIG_SHELL-/bin/sh}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.8.0'
-PACKAGE_STRING='rtorrent 0.8.0'
+PACKAGE_VERSION='0.8.1'
+PACKAGE_STRING='rtorrent 0.8.1'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #ifdef HAVE_SYS_TYPES_H
@@ -1393,13 +1393,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.8.0 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.8.1 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1463,13 +1463,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.8.0:";;
+     short | recursive ) echo "Configuration of rtorrent 0.8.1:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
@@ -1581,13 +1581,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.8.0
+rtorrent configure 0.8.1
 generated by GNU Autoconf 2.61
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
@@ -1595,13 +1595,13 @@
   exit
 fi
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.8.0, which was
+It was created by rtorrent $as_me 0.8.1, which was
 generated by GNU Autoconf 2.61.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 exec 5>>config.log
@@ -2286,13 +2286,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.8.0'
+ VERSION='0.8.1'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -22356,13 +22356,13 @@
 exec 6>&1
 
 # Save the log message, to keep $[0] and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by rtorrent $as_me 0.8.0, which was
+This file was extended by rtorrent $as_me 0.8.1, which was
 generated by GNU Autoconf 2.61.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -22409,13 +22409,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.8.0
+rtorrent config.status 0.8.1
 configured by $0, generated by GNU Autoconf 2.61,
   with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2006 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/configure.ac	2008-01-29 02:07:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/configure.ac	2008-04-17 20:34:12.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.8.0, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.8.1, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 TORRENT_CHECK_CXXFLAGS()
 TORRENT_ENABLE_DEBUG()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/doc/rtorrent.1.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/doc/rtorrent.1.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/doc/rtorrent.1.xml	2008-01-27 23:44:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/doc/rtorrent.1.xml	2008-03-18 17:45:17.000000000 +0800
@@ -805,27 +805,29 @@
 <emphasis>state_changed</emphasis>,
 <emphasis>state_changed_reverse</emphasis>
 
         </para></listitem>
       </varlistentry>
 
-      <varlistentry>
-        <term>view_filter = <replaceable>name</replaceable>,<replaceable>...</replaceable></term>
-        <listitem><para>
+<!--       <varlistentry> -->
+<!--         <term>view_filter = <replaceable>command</replaceable></term> -->
+<!--         <listitem><para> -->
 
-Set a list of filter to apply when new new downloads are added and
-when <emphasis>view_sort</emphasis> is called. All filters must
-match for the download to be included.
+<!-- Set a list of filter to apply when new new downloads are added and -->
+<!-- when <emphasis>view_sort</emphasis> is called. All filters must -->
+<!-- match for the download to be included. -->
 
-        </para><para>
 
-<emphasis>stopped</emphasis>, <emphasis>started</emphasis>,
-<emphasis>complete</emphasis>, <emphasis>incomplete</emphasis>,
 
-        </para></listitem>
-      </varlistentry>
+<!--         </para><para> -->
+
+<!-- <emphasis>stopped</emphasis>, <emphasis>started</emphasis>, -->
+<!-- <emphasis>complete</emphasis>, <emphasis>incomplete</emphasis>, -->
+
+<!--         </para></listitem> -->
+<!--       </varlistentry> -->
 
       <varlistentry>
         <term>key_layout = <replaceable>qwerty|azerty|qwertz|dvorak</replaceable></term>
         <listitem><para>
 
 Change the key-bindings.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/rak/functional_fun.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/rak/functional_fun.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/rak/functional_fun.h	2008-01-13 23:02:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/rak/functional_fun.h	2008-03-28 22:07:16.000000000 +0800
@@ -303,12 +303,28 @@
   Object*    m_object;
   Func       m_func;
   const Arg1 m_arg1;
 };
 
 template <typename Object, typename Result, typename Arg1, typename Arg2>
+class mem_fn1_b1_t : public function_base1<Result, Arg2> {
+public:
+  typedef Result (Object::*Func)(Arg1, Arg2);
+
+  mem_fn1_b1_t(Object* object, Func func, const Arg1 arg1) : m_object(object), m_func(func), m_arg1(arg1) {}
+  virtual ~mem_fn1_b1_t() {}
+  
+  virtual Result operator () (const Arg2 arg2) { return (m_object->*m_func)(m_arg1, arg2); }
+
+private:
+  Object*    m_object;
+  Func       m_func;
+  const Arg1 m_arg1;
+};
+
+template <typename Object, typename Result, typename Arg1, typename Arg2>
 class mem_fn1_b2_t : public function_base1<Result, Arg1> {
 public:
   typedef Result (Object::*Func)(Arg1, Arg2);
 
   mem_fn1_b2_t(Object* object, Func func, const Arg2 arg2) : m_object(object), m_func(func), m_arg2(arg2) {}
   virtual ~mem_fn1_b2_t() {}
@@ -514,12 +530,18 @@
 inline function_base0<Result>*
 bind_mem_fn(Object* object, Result (Object::*func)(Arg1), const Arg1 arg1) {
   return new mem_fn0_b1_t<Object, Result, Arg1>(object, func, arg1);
 }
 
 template <typename Arg1, typename Arg2, typename Result, typename Object>
+inline function_base1<Result, Arg2>*
+bind_mem_fn(Object* object, Result (Object::*func)(Arg1, Arg2), const Arg1 arg1) {
+  return new mem_fn1_b1_t<Object, Result, Arg1, Arg2>(object, func, arg1);
+}
+
+template <typename Arg1, typename Arg2, typename Result, typename Object>
 inline function_base1<Result, Arg1>*
 bind2_mem_fn(Object* object, Result (Object::*func)(Arg1, Arg2), const Arg2 arg2) {
   return new mem_fn1_b2_t<Object, Result, Arg1, Arg2>(object, func, arg2);
 }
 
 template <typename Arg1, typename Result>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/rak/timer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/rak/timer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/rak/timer.h	2008-01-13 23:02:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/rak/timer.h	2008-02-20 17:59:47.000000000 +0800
@@ -60,12 +60,14 @@
     val.tv_sec  = m_time / 1000000;
     val.tv_usec = m_time % 1000000;
     return val;
   }
 
   static timer        current();
+  static int64_t      current_seconds()                   { return current().seconds(); }
+  static int64_t      current_usec()                      { return current().usec(); }
   static timer        from_seconds(uint32_t seconds)      { return rak::timer((uint64_t)seconds * 1000000); }
   static timer        from_milliseconds(uint32_t seconds) { return rak::timer((uint64_t)seconds * 1000); }
 
   static timer        max()                              { return std::numeric_limits<int64_t>::max(); }
 
   bool                operator <  (const timer& t) const { return m_time < t.m_time; }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_download.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_download.cc	2008-03-29 00:39:48.000000000 +0800
@@ -242,12 +242,24 @@
 retrieve_d_local_id_html(core::Download* download) {
   const torrent::HashString* hashString = &download->download()->local_id();
 
   return torrent::Object(rak::copy_escape_html(hashString->begin(), hashString->end()));
 }
 
+// Just a helper function atm.
+torrent::Object
+cmd_d_initialize_logs(core::Download* download) {
+  download->download()->signal_network_log(sigc::mem_fun(control->core(), &core::Manager::push_log_complete));
+  download->download()->signal_storage_error(sigc::mem_fun(control->core(), &core::Manager::push_log_complete));
+
+  if (!rpc::call_command_string("get_tracker_dump").empty())
+    download->download()->signal_tracker_dump(sigc::ptr_fun(&core::receive_tracker_dump));
+
+  return torrent::Object();
+}
+
 torrent::Object
 f_multicall(core::Download* download, const torrent::Object& rawArgs) {
   const torrent::Object::list_type& args = rawArgs.as_list();
 
   if (args.empty())
     throw torrent::input_error("Too few arguments.");
@@ -328,17 +340,17 @@
 
   return resultRaw;
 }
 
 #define ADD_CD_SLOT(key, function, slot, parm, doc)    \
   commandDownloadSlotsItr->set_slot(slot); \
-  rpc::commands.insert_download(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
+  rpc::commands.insert_type(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
 
 #define ADD_CD_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandDownloadSlotsItr->set_slot(slot); \
-  rpc::commands.insert_download(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_type(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CD_VOID(key, slot) \
   ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_fn(slot), "i:", "")
 
 #define ADD_CD_V_VOID(key, slot) \
   ADD_CD_SLOT_PUBLIC("d." key, call_unknown, rpc::object_fn(slot), "i:", "")
@@ -407,21 +419,28 @@
   ADD_CD_VOID("local_id",      &retrieve_d_local_id);
   ADD_CD_VOID("local_id_html", &retrieve_d_local_id_html);
   ADD_CD_VOID("base_path",     &retrieve_d_base_path);
   ADD_CD_VOID("base_filename", &retrieve_d_base_filename);
   ADD_CD_STRING_UNI("name",    rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::name)));
 
+  // ?????
   ADD_CD_LIST_OBSOLETE("create_link",   rak::bind_ptr_fn(&apply_d_change_link, 0));
   ADD_CD_LIST_OBSOLETE("delete_link",   rak::bind_ptr_fn(&apply_d_change_link, 1));
 
   ADD_CD_LIST("create_link",   rak::bind_ptr_fn(&apply_d_change_link, 0));
   ADD_CD_LIST("delete_link",   rak::bind_ptr_fn(&apply_d_change_link, 1));
   ADD_CD_V_VOID("delete_tied", &apply_d_delete_tied);
 
-  ADD_CD_F_VOID("start",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::start_normal));
-  ADD_CD_F_VOID("stop",       rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::stop_normal));
+  ADD_ANY_NONE("d.start",     rak::bind_ptr_fn(&cmd_call, "d.set_hashing_failed=0 ;d.set_state=1 ;view.set_not_visible=stopped ;view.set_visible=started"));
+  ADD_ANY_NONE("d.stop",      rak::bind_ptr_fn(&cmd_call, "d.set_state=0 ;view.set_visible=stopped ;view.set_not_visible=started"));
+  ADD_ANY_NONE("d.try_start", rak::bind_ptr_fn(&cmd_call, "branch=\"or={d.get_hashing_failed=,d.get_ignore_commands=}\",{},{d.set_state=1,view.set_not_visible=stopped,view.set_visible=started}"));
+  ADD_ANY_NONE("d.try_stop",  rak::bind_ptr_fn(&cmd_call, "branch=d.get_ignore_commands=, {}, {d.set_state=0, view.set_visible=stopped, view.set_not_visible=started}"));
+  ADD_ANY_NONE("d.try_close", rak::bind_ptr_fn(&cmd_call, "branch=d.get_ignore_commands=, {}, {d.set_state=0, view.set_visible=stopped, view.set_not_visible=started, d.close=}"));
+
+  ADD_CD_F_VOID("resume",     rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::resume_default));
+  ADD_CD_F_VOID("pause",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::pause_default));
   ADD_CD_F_VOID("open",       rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::open_throw));
   ADD_CD_F_VOID("close",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::close_throw));
   ADD_CD_F_VOID("erase",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::erase_ptr));
   ADD_CD_F_VOID("check_hash", rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::check_hash));
 
   ADD_CD_F_VOID("update_priorities", rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::update_priorities)));
@@ -471,12 +490,14 @@
   ADD_CD_VARIABLE_VALUE("state_changed",          "rtorrent", "state_changed");
   ADD_CD_VARIABLE_VALUE("state_counter",          "rtorrent", "state_counter");
   ADD_CD_VARIABLE_VALUE_PUBLIC("ignore_commands", "rtorrent", "ignore_commands");
 
   ADD_CD_STRING_BI("connection_current", std::ptr_fun(&apply_d_connection_type), std::ptr_fun(&retrieve_d_connection_type));
 
+  ADD_CD_VALUE_BI("hashing_failed",      std::mem_fun(&core::Download::set_hash_failed), std::mem_fun(&core::Download::is_hash_failed));
+
   // This command really needs to be improved, so we have proper
   // logging support.
   ADD_CD_STRING_BI("message",            std::mem_fun(&core::Download::set_message), std::mem_fun(&core::Download::message));
 
   add_copy_to_download("get_connection_leech", "d.get_connection_leech");
   add_copy_to_download("set_connection_leech", "d.set_connection_leech");
@@ -527,10 +548,13 @@
   ADD_CD_STRING_BI("directory",           std::ptr_fun(&apply_d_directory), rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::root_dir)));
   ADD_CD_STRING_BI("directory_base",      std::mem_fun(&core::Download::set_root_directory), rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::root_dir)));
 
   ADD_CD_VALUE_BI("priority",             std::mem_fun(&core::Download::set_priority), std::mem_fun(&core::Download::priority));
   ADD_CD_STRING_UNI("priority_str",       std::ptr_fun(&retrieve_d_priority_str));
 
-  ADD_CD_SLOT_PUBLIC("f.multicall",       call_list, rak::ptr_fn(&f_multicall), "i:", "")
-  ADD_CD_SLOT_PUBLIC("p.multicall",       call_list, rak::ptr_fn(&p_multicall), "i:", "")
-  ADD_CD_SLOT_PUBLIC("t.multicall",       call_list, rak::ptr_fn(&t_multicall), "i:", "")
+  ADD_CD_SLOT_PUBLIC("f.multicall",       call_list, rak::ptr_fn(&f_multicall), "i:", "");
+  ADD_CD_SLOT_PUBLIC("p.multicall",       call_list, rak::ptr_fn(&p_multicall), "i:", "");
+  ADD_CD_SLOT_PUBLIC("t.multicall",       call_list, rak::ptr_fn(&t_multicall), "i:", "");
+
+  // NEWISH:
+  CMD_D_VOID("d.initialize_logs",         &cmd_d_initialize_logs);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_events.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_events.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_events.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_events.cc	2008-04-03 00:27:24.000000000 +0800
@@ -62,21 +62,26 @@
 apply_on_state_change(core::DownloadList::slot_map* slotMap, const torrent::Object& rawArgs) {
   const torrent::Object::list_type& args = rawArgs.as_list();
 
   if (args.size() == 0 || args.size() > 2)
     throw torrent::input_error("Wrong number of arguments.");
 
-  if (args.front().as_string().empty())
+  const std::string& rawKey = args.front().as_string();
+
+  if (rawKey.empty())
     throw torrent::input_error("Empty key.");
 
-  std::string key = "1_state_" + args.front().as_string();
+  // If the key starts with '_' then it's supposed to be literal, with
+  // the initial '_' removed. This allows us to get proper ordering
+  // for internal rtorrent tasks.
+  std::string key = rawKey[0] != '_' ? ("1_state_" + rawKey) : rawKey.substr(1);
 
   if (args.size() == 1)
     slotMap->erase(key);
   else
-    (*slotMap)[key] = sigc::bind(sigc::ptr_fun(&rpc::parse_command_d_multiple_std), args.back().as_string());
+    (*slotMap)[key] = args.back().as_string();
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_on_ratio(int action, const torrent::Object& rawArgs) {
@@ -104,17 +109,19 @@
     int64_t totalUpload = current->download()->up_rate()->total();
 
     if (!(totalUpload >= minUpload && totalUpload * 100 >= totalDone * minRatio) &&
         !(maxRatio > 0 && totalUpload * 100 > totalDone * maxRatio))
       continue;
 
-    bool success;
+    bool success = true;
 
     switch (action) {
-    case core::DownloadList::SLOTS_CLOSE: success = downloadList->close_try(current); break;
-    case core::DownloadList::SLOTS_STOP:  success = downloadList->stop_try(current); break;
+//     case core::DownloadList::SLOTS_CLOSE: success = downloadList->close_try(current); break;
+//     case core::DownloadList::SLOTS_STOP:  success = downloadList->stop_try(current); break;
+    case core::DownloadList::SLOTS_CLOSE: rpc::parse_command_single(rpc::make_target(current), "d.try_close="); break;
+    case core::DownloadList::SLOTS_STOP:  rpc::parse_command_single(rpc::make_target(current), "d.try_stop="); break;
     default: success = false; break;
     }
 
     if (!success)
       continue;
 
@@ -134,13 +141,13 @@
       continue;
 
     rak::file_stat fs;
     const std::string& tiedToFile = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(*itr));
 
     if (!tiedToFile.empty() && fs.update(rak::path_expand(tiedToFile)))
-      control->core()->download_list()->start_try(*itr);
+      rpc::parse_command_single(rpc::make_target(*itr), "d.try_start=");
   }
 
   return torrent::Object();
 }
 
 torrent::Object
@@ -150,26 +157,26 @@
       continue;
 
     rak::file_stat fs;
     const std::string& tiedToFile = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(*itr));
 
     if (!tiedToFile.empty() && !fs.update(rak::path_expand(tiedToFile)))
-      control->core()->download_list()->stop_try(*itr);
+      rpc::parse_command_single(rpc::make_target(*itr), "d.try_stop=");
   }
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_close_untied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ++itr) {
     rak::file_stat fs;
     const std::string& tiedToFile = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(*itr));
 
     if (rpc::call_command_value("d.get_ignore_commands", rpc::make_target(*itr)) == 0 && !tiedToFile.empty() && !fs.update(rak::path_expand(tiedToFile)))
-      control->core()->download_list()->close(*itr);
+      rpc::parse_command_single(rpc::make_target(*itr), "d.try_close=");
   }
 
   return torrent::Object();
 }
 
 torrent::Object
@@ -210,13 +217,13 @@
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_load(int flags, const torrent::Object& rawArgs) {
-  const torrent::Object::list_type&          args    = rawArgs.as_list();
+  const torrent::Object::list_type&    args    = rawArgs.as_list();
   torrent::Object::list_const_iterator argsItr = args.begin();
 
   if (argsItr == args.end())
     throw torrent::input_error("Too few arguments.");
 
   const std::string& filename = argsItr->as_string();
@@ -329,12 +336,20 @@
     }
   }
 
   return resultRaw;
 }
 
+torrent::Object
+cmd_call(const char* cmd, rpc::target_type target, const torrent::Object& rawArgs) {
+  rpc::parse_command_multiple(target, cmd);
+
+  return torrent::Object();
+}
+
+
 void
 initialize_command_events() {
   core::DownloadList* downloadList = control->core()->download_list();
 
   ADD_VARIABLE_BOOL("check_hash", true);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_file.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_file.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_file.cc	2008-01-22 23:24:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_file.cc	2008-03-13 22:23:26.000000000 +0800
@@ -96,17 +96,17 @@
 
   return itr->file()->path()->at(itr->depth());
 }
 
 #define ADD_CF_SLOT(key, function, slot, parm, doc)    \
   commandFileSlotsItr->set_slot(slot); \
-  rpc::commands.insert_file(key, commandFileSlotsItr++, &rpc::CommandSlot<torrent::File*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
+  rpc::commands.insert_type(key, commandFileSlotsItr++, &rpc::CommandSlot<torrent::File*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
 
 #define ADD_CF_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandFileSlotsItr->set_slot(slot); \
-  rpc::commands.insert_file(key, commandFileSlotsItr++, &rpc::CommandSlot<torrent::File*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_type(key, commandFileSlotsItr++, &rpc::CommandSlot<torrent::File*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CF_VOID(key, slot) \
   ADD_CF_SLOT_PUBLIC("f." key, call_unknown, rpc::object_fn(slot), "i:", "")
 
 #define ADD_CF_VALUE(key, get) \
   ADD_CF_SLOT_PUBLIC("f." key, call_unknown, rpc::object_void_fn<torrent::File*>(get), "i:", "")
@@ -120,13 +120,13 @@
 
 #define ADD_CF_STRING_UNI(key, get) \
   ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_fn<torrent::File*>(get), "s:", "")
 
 #define ADD_CFI_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandFileItrSlotsItr->set_slot(slot); \
-  rpc::commands.insert_file_itr(key, commandFileItrSlotsItr++, &rpc::CommandSlot<torrent::FileListIterator*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_type(key, commandFileItrSlotsItr++, &rpc::CommandSlot<torrent::FileListIterator*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CFI_VOID(key, slot) \
   ADD_CFI_SLOT_PUBLIC("fi." key, call_unknown, rpc::object_fn(slot), "i:", "")
 
 #define ADD_CFI_VALUE(key, get) \
   ADD_CFI_SLOT_PUBLIC("fi." key, call_unknown, rpc::object_void_fn<torrent::FileListIterator*>(get), "i:", "")
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_helpers.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_helpers.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_helpers.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_helpers.cc	2008-04-02 21:53:55.000000000 +0800
@@ -66,54 +66,58 @@
 void initialize_command_events();
 void initialize_command_file();
 void initialize_command_peer();
 void initialize_command_local();
 void initialize_command_network();
 void initialize_command_tracker();
+void initialize_command_scheduler();
 void initialize_command_ui();
 
 void
 initialize_commands() {
   initialize_command_events();
   initialize_command_network();
   initialize_command_local();
   initialize_command_ui();
   initialize_command_download();
   initialize_command_file();
   initialize_command_peer();
   initialize_command_tracker();
+  initialize_command_scheduler();
 
 #ifdef ADDING_COMMANDS 
   if (commandSlotsItr > commandSlots + COMMAND_SLOTS_SIZE ||
       commandVariablesItr > commandVariables + COMMAND_VARIABLES_SIZE ||
       commandDownloadSlotsItr > commandDownloadSlots + COMMAND_DOWNLOAD_SLOTS_SIZE ||
       commandFileSlotsItr > commandFileSlots + COMMAND_FILE_SLOTS_SIZE ||
+      commandFileItrSlotsItr > commandFileItrSlots + COMMAND_FILE_ITR_SLOTS_SIZE ||
       commandPeerSlotsItr > commandPeerSlots + COMMAND_PEER_SLOTS_SIZE ||
       commandTrackerSlotsItr > commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE ||
       commandAnySlotsItr > commandAnySlots + COMMAND_ANY_SLOTS_SIZE)
 #else
   if (commandSlotsItr != commandSlots + COMMAND_SLOTS_SIZE ||
       commandVariablesItr != commandVariables + COMMAND_VARIABLES_SIZE ||
       commandDownloadSlotsItr != commandDownloadSlots + COMMAND_DOWNLOAD_SLOTS_SIZE ||
       commandFileSlotsItr != commandFileSlots + COMMAND_FILE_SLOTS_SIZE ||
+      commandFileItrSlotsItr != commandFileItrSlots + COMMAND_FILE_ITR_SLOTS_SIZE ||
       commandPeerSlotsItr != commandPeerSlots + COMMAND_PEER_SLOTS_SIZE ||
       commandTrackerSlotsItr != commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE ||
       commandAnySlotsItr != commandAnySlots + COMMAND_ANY_SLOTS_SIZE)
 #endif
     throw torrent::internal_error("initialize_commands() static command array size mismatch.");
 }
 
 void
 add_variable(const char* getKey, const char* setKey, const char* defaultSetKey,
-             rpc::CommandMap::generic_slot getSlot, rpc::CommandMap::generic_slot setSlot,
+             rpc::Command::generic_slot getSlot, rpc::Command::generic_slot setSlot,
              const torrent::Object& defaultObject) {
   rpc::CommandVariable* variable = commandVariablesItr++;
   variable->set_variable(defaultObject);
 
-  rpc::commands.insert_generic(getKey, variable, getSlot, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, "i:", "");
+  rpc::commands.insert_type(getKey, variable, getSlot, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, "i:", "");
 
   if (setKey)
-    rpc::commands.insert_generic(setKey, variable, setSlot, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, "i:", "");
+    rpc::commands.insert_type(setKey, variable, setSlot, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, "i:", "");
 
   if (defaultSetKey)
-    rpc::commands.insert_generic(defaultSetKey, variable, setSlot, rpc::CommandMap::flag_dont_delete, "i:", "");
+    rpc::commands.insert_type(defaultSetKey, variable, setSlot, rpc::CommandMap::flag_dont_delete, "i:", "");
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_helpers.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_helpers.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_helpers.h	2008-01-22 21:41:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_helpers.h	2008-04-02 23:32:53.000000000 +0800
@@ -43,20 +43,20 @@
 namespace rpc {
   class CommandVariable;
 }
 
 // By using a static array we avoid allocating the variables on the
 // heap. This should reduce memory use and improve cache locality.
-#define COMMAND_SLOTS_SIZE          150
+#define COMMAND_SLOTS_SIZE          200
 #define COMMAND_VARIABLES_SIZE      100
 #define COMMAND_DOWNLOAD_SLOTS_SIZE 150
 #define COMMAND_FILE_SLOTS_SIZE     30
 #define COMMAND_FILE_ITR_SLOTS_SIZE 10
 #define COMMAND_PEER_SLOTS_SIZE     20
 #define COMMAND_TRACKER_SLOTS_SIZE  15
-#define COMMAND_ANY_SLOTS_SIZE      20
+#define COMMAND_ANY_SLOTS_SIZE      50
 
 #define ADDING_COMMANDS
 
 extern rpc::CommandSlot<void>    commandSlots[COMMAND_SLOTS_SIZE];
 extern rpc::CommandSlot<void>*   commandSlotsItr;
 extern rpc::CommandVariable      commandVariables[COMMAND_VARIABLES_SIZE];
@@ -75,15 +75,17 @@
 extern rpc::CommandSlot<rpc::target_type>*           commandAnySlotsItr;
 
 void initialize_commands();
 
 void
 add_variable(const char* getKey, const char* setKey, const char* defaultSetKey,
-             rpc::CommandMap::generic_slot getSlot, rpc::CommandMap::generic_slot setSlot,
+             rpc::Command::generic_slot getSlot, rpc::Command::generic_slot setSlot,
              const torrent::Object& defaultObject);
 
+extern torrent::Object cmd_call(const char* cmd, rpc::target_type target, const torrent::Object& rawArgs);
+
 #define ADD_VARIABLE_BOOL(key, defaultValue) \
 add_variable("get_" key, "set_" key, key, &rpc::CommandVariable::get_bool, &rpc::CommandVariable::set_bool, (int64_t)defaultValue);
 
 #define ADD_VARIABLE_VALUE(key, defaultValue) \
 add_variable("get_" key, "set_" key, key, &rpc::CommandVariable::get_value, &rpc::CommandVariable::set_value, (int64_t)defaultValue);
 
@@ -92,27 +94,27 @@
 
 #define ADD_C_STRING(key, defaultValue) \
 add_variable(key, NULL, NULL, &rpc::CommandVariable::get_string, NULL, std::string(defaultValue));
 
 #define ADD_COMMAND_SLOT(key, function, slot, parm, doc)    \
   commandSlotsItr->set_slot(slot); \
-  rpc::commands.insert_generic(key, commandSlotsItr++, &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_type(key, commandSlotsItr++, &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_ANY_SLOT(key, function, slot, parm, doc)    \
   commandAnySlotsItr->set_slot(slot); \
-  rpc::commands.insert_any(key, commandAnySlotsItr++, &rpc::CommandSlot<rpc::target_type>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_type(key, commandAnySlotsItr++, &rpc::CommandSlot<rpc::target_type>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_COMMAND_SLOT_PRIVATE(key, function, slot) \
   commandSlotsItr->set_slot(slot); \
-  rpc::commands.insert_generic(key, commandSlotsItr++, &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete, NULL, NULL);
+  rpc::commands.insert_type(key, commandSlotsItr++, &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete, NULL, NULL);
 
 #define ADD_COMMAND_COPY(key, function, parm, doc) \
-  rpc::commands.insert_generic(key, (commandSlotsItr - 1), &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_type(key, (commandSlotsItr - 1), &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_COMMAND_COPY_PRIVATE(key, function) \
-  rpc::commands.insert_generic(key, (commandSlotsItr - 1), &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete, NULL, NULL);
+  rpc::commands.insert_type(key, (commandSlotsItr - 1), &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete, NULL, NULL);
 
 #define ADD_COMMAND_VALUE_TRI(key, set, get) \
   ADD_COMMAND_SLOT_PRIVATE(key, call_value, rpc::object_value_fn(set))      \
   ADD_COMMAND_COPY("set_" key,  call_value, "i:i", "")                      \
   ADD_COMMAND_SLOT("get_" key,  call_unknown, rpc::object_void_fn(get), "i:", "")
 
@@ -141,15 +143,12 @@
 #define ADD_COMMAND_VOID(key, slot) \
   ADD_COMMAND_SLOT(key, call_unknown, rpc::object_void_fn(slot), "i:", "")
 
 #define ADD_COMMAND_VALUE(key, slot) \
   ADD_COMMAND_SLOT(key, call_value, slot, "i:i", "")
 
-#define ADD_ANY_VALUE(key, slot) \
-  ADD_ANY_SLOT(key, call_value, slot, "i:i", "")
-
 #define ADD_COMMAND_VALUE_UN(key, slot) \
   ADD_COMMAND_SLOT(key, call_value, rpc::object_value_fn(slot), "i:i", "")
 
 #define ADD_COMMAND_STRING(key, slot) \
   ADD_COMMAND_SLOT(key, call_string, slot, "i:s", "")
 
@@ -162,10 +161,50 @@
 #define ADD_COMMAND_NONE(key, slot) \
   ADD_COMMAND_SLOT(key, call_unknown, slot, "i:", "")
 
 #define ADD_ANY_NONE(key, slot) \
   ADD_ANY_SLOT(key, call_unknown, slot, "i:", "")
 
+#define ADD_ANY_VALUE(key, slot) \
+  ADD_ANY_SLOT(key, call_value, slot, "i:i", "")
+
+#define ADD_ANY_LIST(key, slot) \
+  ADD_ANY_SLOT(key, call_list, slot, "i:i", "")
+
 #define ADD_COMMAND_NONE_L(key, slot) \
   ADD_COMMAND_SLOT(key, call_unknown, slot, "A:", "")
 
+//
+// NEW COMMAND MACROS
+//
+
+//
+// DOWNLOAD RELATED COMMANDS
+//
+
+#define CMD_V(prefix, postfix, type, defaultValue)                       \
+  add_variable(prefix "" postfix, prefix "set_" postfix, NULL, &rpc::CommandVariable::get_##type, &rpc::CommandVariable::set_##type, defaultValue);
+
+#define CMD_G_SLOT(key, function, slot, parm, doc)    \
+  commandAnySlotsItr->set_slot(slot); \
+  rpc::commands.insert_type(key, commandAnySlotsItr++, &rpc::CommandSlot<rpc::target_type>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+
+#define CMD_G(key, slot) \
+  CMD_G_SLOT(key, call_unknown, slot, "i:", "")
+
+#define CMD_G_STRING(key, slot) \
+  CMD_G_SLOT(key, call_string, slot, "i:", "")
+
+#define CMD_D_SLOT(key, function, slot, parm, doc)    \
+  commandDownloadSlotsItr->set_slot(slot); \
+  rpc::commands.insert_type(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+
+#define CMD_D_ANY(key, slot) \
+  CMD_D_SLOT(key, call_unknown, slot, "i:", "")
+
+#define CMD_D_STRING(key, slot) \
+  CMD_D_SLOT(key, call_string, slot, "i:", "")
+
+#define CMD_D_VOID(key, slot) \
+  CMD_D_SLOT(key, call_unknown, rpc::object_fn(slot), "i:", "")
+
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_local.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_local.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_local.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_local.cc	2008-02-20 18:00:20.000000000 +0800
@@ -128,34 +128,38 @@
   ADD_COMMAND_VOID("system.hostname",            rak::ptr_fun(&system_hostname));
   ADD_COMMAND_VOID("system.pid",                 rak::ptr_fun(&getpid));
 
   ADD_COMMAND_VOID("system.file_status_cache.size",  rak::make_mem_fun((utils::FileStatusCache::base_type*)control->core()->file_status_cache(), &utils::FileStatusCache::size));
   ADD_COMMAND_VOID("system.file_status_cache.prune", rak::make_mem_fun(control->core()->file_status_cache(), &utils::FileStatusCache::prune));
 
-  ADD_COMMAND_VALUE_SET_OCT("system.", "umask",  std::ptr_fun(&umask));
-  ADD_COMMAND_STRING_PREFIX("system.", "cwd",    std::ptr_fun(system_set_cwd), rak::ptr_fun(&system_get_cwd));
+  ADD_COMMAND_VOID("system.time",                    rak::make_mem_fun(&cachedTime, &rak::timer::seconds));
+  ADD_COMMAND_VOID("system.time_seconds",            rak::ptr_fun(&rak::timer::current_seconds));
+  ADD_COMMAND_VOID("system.time_usec",               rak::ptr_fun(&rak::timer::current_usec));
+
+  ADD_COMMAND_VALUE_SET_OCT("system.", "umask",      std::ptr_fun(&umask));
+  ADD_COMMAND_STRING_PREFIX("system.", "cwd",        std::ptr_fun(system_set_cwd), rak::ptr_fun(&system_get_cwd));
 
   ADD_VARIABLE_STRING("name", "");
 
   ADD_VARIABLE_VALUE("max_file_size", -1);
   ADD_VARIABLE_VALUE("split_file_size", -1);
   ADD_VARIABLE_STRING("split_suffix", ".part");
 
-  ADD_COMMAND_VOID("get_memory_usage",           rak::make_mem_fun(chunkManager, &CM_t::memory_usage));
-  ADD_COMMAND_VALUE_TRI("max_memory_usage",      rak::make_mem_fun(chunkManager, &CM_t::set_max_memory_usage), rak::make_mem_fun(chunkManager, &CM_t::max_memory_usage));
-  ADD_COMMAND_VALUE_TRI("safe_sync",             rak::make_mem_fun(chunkManager, &CM_t::set_safe_sync), rak::make_mem_fun(chunkManager, &CM_t::safe_sync));
-  ADD_COMMAND_VOID("get_safe_free_diskspace",    rak::make_mem_fun(chunkManager, &CM_t::safe_free_diskspace));
-  ADD_COMMAND_VALUE_TRI("timeout_sync",          rak::make_mem_fun(chunkManager, &CM_t::set_timeout_sync), rak::make_mem_fun(chunkManager, &CM_t::timeout_sync));
-  ADD_COMMAND_VALUE_TRI("timeout_safe_sync",     rak::make_mem_fun(chunkManager, &CM_t::set_timeout_safe_sync), rak::make_mem_fun(chunkManager, &CM_t::timeout_safe_sync));
-
-  ADD_COMMAND_VALUE_TRI("preload_type",          rak::make_mem_fun(chunkManager, &CM_t::set_preload_type), rak::make_mem_fun(chunkManager, &CM_t::preload_type));
-  ADD_COMMAND_VALUE_TRI("preload_min_size",      rak::make_mem_fun(chunkManager, &CM_t::set_preload_min_size), rak::make_mem_fun(chunkManager, &CM_t::preload_min_size));
-  ADD_COMMAND_VALUE_TRI_KB("preload_required_rate", rak::make_mem_fun(chunkManager, &CM_t::set_preload_required_rate), rak::make_mem_fun(chunkManager, &CM_t::preload_required_rate));
+  ADD_COMMAND_VOID("get_memory_usage",               rak::make_mem_fun(chunkManager, &CM_t::memory_usage));
+  ADD_COMMAND_VALUE_TRI("max_memory_usage",          rak::make_mem_fun(chunkManager, &CM_t::set_max_memory_usage), rak::make_mem_fun(chunkManager, &CM_t::max_memory_usage));
+  ADD_COMMAND_VALUE_TRI("safe_sync",                 rak::make_mem_fun(chunkManager, &CM_t::set_safe_sync), rak::make_mem_fun(chunkManager, &CM_t::safe_sync));
+  ADD_COMMAND_VOID("get_safe_free_diskspace",        rak::make_mem_fun(chunkManager, &CM_t::safe_free_diskspace));
+  ADD_COMMAND_VALUE_TRI("timeout_sync",              rak::make_mem_fun(chunkManager, &CM_t::set_timeout_sync), rak::make_mem_fun(chunkManager, &CM_t::timeout_sync));
+  ADD_COMMAND_VALUE_TRI("timeout_safe_sync",         rak::make_mem_fun(chunkManager, &CM_t::set_timeout_safe_sync), rak::make_mem_fun(chunkManager, &CM_t::timeout_safe_sync));
+
+  ADD_COMMAND_VALUE_TRI("preload_type",              rak::make_mem_fun(chunkManager, &CM_t::set_preload_type), rak::make_mem_fun(chunkManager, &CM_t::preload_type));
+  ADD_COMMAND_VALUE_TRI("preload_min_size",          rak::make_mem_fun(chunkManager, &CM_t::set_preload_min_size), rak::make_mem_fun(chunkManager, &CM_t::preload_min_size));
+  ADD_COMMAND_VALUE_TRI_KB("preload_required_rate",  rak::make_mem_fun(chunkManager, &CM_t::set_preload_required_rate), rak::make_mem_fun(chunkManager, &CM_t::preload_required_rate));
 
-  ADD_COMMAND_VOID("get_stats_preloaded",        rak::make_mem_fun(chunkManager, &CM_t::stats_preloaded));
-  ADD_COMMAND_VOID("get_stats_not_preloaded",    rak::make_mem_fun(chunkManager, &CM_t::stats_not_preloaded));
+  ADD_COMMAND_VOID("get_stats_preloaded",            rak::make_mem_fun(chunkManager, &CM_t::stats_preloaded));
+  ADD_COMMAND_VOID("get_stats_not_preloaded",        rak::make_mem_fun(chunkManager, &CM_t::stats_not_preloaded));
 
   ADD_VARIABLE_STRING("directory", "./");
 
   ADD_COMMAND_STRING_TRI("session",            rak::make_mem_fun(dStore, &core::DownloadStore::set_path), rak::make_mem_fun(dStore, &core::DownloadStore::path));
   ADD_COMMAND_VOID("session_save",             rak::make_mem_fun(dList, &core::DownloadList::session_save));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_network.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_network.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_network.cc	2008-01-28 22:31:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_network.cc	2008-03-21 21:28:05.000000000 +0800
@@ -346,14 +346,15 @@
   ADD_COMMAND_VALUE_TRI("max_open_files",       std::ptr_fun(&torrent::set_max_open_files), rak::ptr_fun(&torrent::max_open_files));
   ADD_COMMAND_VALUE_TRI("max_open_sockets",     rak::make_mem_fun(cm, &torrent::ConnectionManager::set_max_size), rak::make_mem_fun(cm, &torrent::ConnectionManager::max_size));
   ADD_COMMAND_VALUE_TRI("max_open_http",        rak::make_mem_fun(httpStack, &core::CurlStack::set_max_active), rak::make_mem_fun(httpStack, &core::CurlStack::max_active));
 
   ADD_COMMAND_STRING_UN("scgi_port",            rak::bind2nd(std::ptr_fun(&apply_scgi), 1));
   ADD_COMMAND_STRING_UN("scgi_local",           rak::bind2nd(std::ptr_fun(&apply_scgi), 2));
-  ADD_VARIABLE_BOOL("scgi_dont_route", false);
+  ADD_VARIABLE_BOOL    ("scgi_dont_route", false);
   ADD_COMMAND_STRING_UN("xmlrpc_dialect",       std::ptr_fun(&apply_xmlrpc_dialect));
+  ADD_COMMAND_VALUE_TRI("xmlrpc_size_limit",    std::ptr_fun(&rpc::XmlRpc::set_size_limit), rak::ptr_fun(&rpc::XmlRpc::size_limit));
 
   ADD_COMMAND_VALUE_TRI("hash_read_ahead",      std::ptr_fun(&apply_hash_read_ahead), rak::ptr_fun(torrent::hash_read_ahead));
   ADD_COMMAND_VALUE_TRI("hash_interval",        std::ptr_fun(&apply_hash_interval), rak::ptr_fun(torrent::hash_interval));
 
   ADD_COMMAND_VALUE_UN("enable_trackers",       std::ptr_fun(&apply_enable_trackers));
   ADD_COMMAND_STRING_UN("encoding_list",        std::ptr_fun(&apply_encoding_list));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_peer.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_peer.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_peer.cc	2008-01-27 21:00:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_peer.cc	2008-03-13 22:26:39.000000000 +0800
@@ -93,17 +93,17 @@
 retrieve_p_completed_percent(torrent::Peer* peer) {
   return (100 * peer->bitfield()->size_set()) / peer->bitfield()->size_bits();
 }
 
 #define ADD_CP_SLOT(key, function, slot, parm, doc)    \
   commandPeerSlotsItr->set_slot(slot); \
-  rpc::commands.insert_peer(key, commandPeerSlotsItr++, &rpc::CommandSlot<torrent::Peer*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
+  rpc::commands.insert_type(key, commandPeerSlotsItr++, &rpc::CommandSlot<torrent::Peer*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
 
 #define ADD_CP_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandPeerSlotsItr->set_slot(slot); \
-  rpc::commands.insert_peer(key, commandPeerSlotsItr++, &rpc::CommandSlot<torrent::Peer*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_type(key, commandPeerSlotsItr++, &rpc::CommandSlot<torrent::Peer*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CP_VOID(key, slot) \
   ADD_CP_SLOT_PUBLIC("p.get_" key, call_unknown, rpc::object_fn(slot), "i:", "")
 
 #define ADD_CP_VALUE(key, get) \
   ADD_CP_SLOT_PUBLIC("p." key, call_unknown, rpc::object_void_fn<torrent::Peer*>(get), "i:", "")
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src: command_scheduler.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_tracker.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_tracker.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_tracker.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_tracker.cc	2008-03-13 22:21:09.000000000 +0800
@@ -52,17 +52,17 @@
   else
     tracker->disable();
 }
 
 #define ADD_CT_SLOT(key, function, slot, parm, doc)    \
   commandTrackerSlotsItr->set_slot(slot); \
-  rpc::commands.insert_tracker(key, commandTrackerSlotsItr++, &rpc::CommandSlot<torrent::Tracker*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
+  rpc::commands.insert_type(key, commandTrackerSlotsItr++, &rpc::CommandSlot<torrent::Tracker*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
 
 #define ADD_CT_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandTrackerSlotsItr->set_slot(slot); \
-  rpc::commands.insert_tracker(key, commandTrackerSlotsItr++, &rpc::CommandSlot<torrent::Tracker*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_type(key, commandTrackerSlotsItr++, &rpc::CommandSlot<torrent::Tracker*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CT_VOID(key, slot) \
   ADD_CT_SLOT_PUBLIC("t." key, call_unknown,     rpc::object_void_fn<torrent::Tracker*>(slot), "i:", "")
 
 #define ADD_CT_VOID_UNI(key, get) \
   ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_fn<torrent::Tracker*>(get), "i:", "")
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_ui.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_ui.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/command_ui.cc	2008-01-22 22:25:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/command_ui.cc	2008-04-11 23:35:43.000000000 +0800
@@ -39,24 +39,26 @@
 #include <rak/functional.h>
 #include <rak/functional_fun.h>
 #include <sigc++/adaptors/bind.h>
 
 #include "core/manager.h"
 #include "core/view_manager.h"
+#include "ui/root.h"
+#include "ui/download_list.h"
 #include "rpc/command_slot.h"
 #include "rpc/command_variable.h"
 #include "rpc/parse.h"
 
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
-typedef void (core::ViewManager::*view_filter_slot)(const std::string&, const core::ViewManager::sort_args&);
+typedef void (core::ViewManager::*view_cfilter_slot)(const std::string&, const std::string&);
 
 torrent::Object
-apply_view_filter(view_filter_slot viewFilterSlot, const torrent::Object& rawArgs) {
+apply_view_filter_on(const torrent::Object& rawArgs) {
   const torrent::Object::list_type& args = rawArgs.as_list();
 
   if (args.size() < 1)
     throw torrent::input_error("Too few arguments.");
 
   const std::string& name = args.front().as_string();
@@ -66,13 +68,30 @@
 
   core::ViewManager::filter_args filterArgs;
 
   for (torrent::Object::list_const_iterator itr = ++args.begin(), last = args.end(); itr != last; itr++)
     filterArgs.push_back(itr->as_string());
 
-  (control->view_manager()->*viewFilterSlot)(name, filterArgs);
+  control->view_manager()->set_filter_on(name, filterArgs);
+
+  return torrent::Object();
+}
+
+torrent::Object
+apply_view_cfilter(view_cfilter_slot viewFilterSlot, const torrent::Object& rawArgs) {
+  const torrent::Object::list_type& args = rawArgs.as_list();
+
+  if (args.size() != 2)
+    throw torrent::input_error("Too few arguments.");
+
+  const std::string& name = args.front().as_string();
+  
+  if (name.empty())
+    throw torrent::input_error("First argument must be a string.");
+
+  (control->view_manager()->*viewFilterSlot)(name, args.back().as_string());
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_view_sort(const torrent::Object& rawArgs) {
@@ -105,12 +124,30 @@
     result.push_back((*itr)->name());
 
   return rawResult;
 }
 
 torrent::Object
+apply_view_set(const torrent::Object& rawArgs) {
+  const torrent::Object::list_type& args = rawArgs.as_list();
+
+  if (args.size() != 2)
+    throw torrent::input_error("Wrong argument count.");
+
+  core::ViewManager::iterator itr = control->view_manager()->find(args.back().as_string());
+
+  if (itr == control->view_manager()->end())
+    throw torrent::input_error("Could not find view \"" + args.back().as_string() + "\".");
+
+//   if (args.front().as_string() == "main")
+//     control->ui()->download_list()->set_view(*itr);
+//   else
+    throw torrent::input_error("No such target.");
+}
+
+torrent::Object
 apply_print(rpc::target_type target, const torrent::Object& rawArgs) {
   char buffer[1024];
   rpc::print_object(buffer, buffer + 1024, &rawArgs, 0);
 
   control->core()->push_log(buffer);
   return torrent::Object();
@@ -121,36 +158,118 @@
   std::string result;
 
   rpc::print_object_std(&result, &rawArgs, 0);
   return result;
 }
 
+// Move these boolean operators to a new file.
+
+bool
+as_boolean(const torrent::Object& rawArgs) {
+  switch (rawArgs.type()) {
+  case torrent::Object::TYPE_VALUE:  return rawArgs.as_value();
+  case torrent::Object::TYPE_STRING: return !rawArgs.as_string().empty();
+  case torrent::Object::TYPE_LIST:   return !rawArgs.as_list().empty();
+  case torrent::Object::TYPE_MAP:    return !rawArgs.as_map().empty();
+  default: return false;
+  }
+}
+
 torrent::Object
-apply_to_date(const torrent::Object& rawArgs) {
-  time_t t = (uint64_t)rawArgs.as_value();
-  std::tm *u = std::gmtime(&t);
-  
-  if (u == NULL)
-    return torrent::Object();
+apply_not(rpc::target_type target, const torrent::Object& rawArgs) {
+  return (int64_t)!as_boolean(rawArgs);
+}
 
-  char buffer[11];
-  snprintf(buffer, 11, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year));
+torrent::Object
+apply_false(rpc::target_type target, const torrent::Object& rawArgs) {
+  return (int64_t)0;
+}
+
+torrent::Object
+apply_and(rpc::target_type target, const torrent::Object& rawArgs) {
+  if (rawArgs.type() != torrent::Object::TYPE_LIST)
+    return as_boolean(rawArgs);
+
+  for (torrent::Object::list_const_iterator itr = rawArgs.as_list().begin(), last = rawArgs.as_list().end(); itr != last; itr++)
+    if (!as_boolean(rpc::parse_command_single(target, itr->as_string())))
+      return (int64_t)false;
+
+  return (int64_t)true;
+}
+
+torrent::Object
+apply_or(rpc::target_type target, const torrent::Object& rawArgs) {
+  if (rawArgs.type() != torrent::Object::TYPE_LIST)
+    return as_boolean(rawArgs);
+
+  for (torrent::Object::list_const_iterator itr = rawArgs.as_list().begin(), last = rawArgs.as_list().end(); itr != last; itr++)
+    if (as_boolean(rpc::parse_command_single(target, itr->as_string())))
+      return (int64_t)true;
+
+  return (int64_t)false;
+}
+
+torrent::Object
+apply_less(rpc::target_type target, const torrent::Object& rawArgs) {
+  const torrent::Object::list_type& args = rawArgs.as_list();
   
-  return std::string(buffer);
+  // We only need to check if empty() since if size() == 1 it calls
+  // the same command for both, or if size() == 2 then each side of
+  // the comparison has different commands.
+  if (args.empty())
+    throw torrent::input_error("Wrong argument count.");
+
+  // This really should be converted to using args flagged as
+  // commands, so that we can compare commands and statics values.
+
+  torrent::Object result1;
+  torrent::Object result2;
+
+  if (rpc::is_target_pair(target)) {
+    result1 = rpc::parse_command_single(rpc::get_target_left(target), args.front().as_string());
+    result2 = rpc::parse_command_single(rpc::get_target_right(target), args.back().as_string());
+  } else {
+    result1 = rpc::parse_command_single(target, args.front().as_string());
+    result2 = rpc::parse_command_single(target, args.back().as_string());
+  }    
+
+  if (result1.type() != result2.type())
+    throw torrent::input_error("Type mismatch.");
+    
+  switch (result1.type()) {
+  case torrent::Object::TYPE_VALUE:  return result1.as_value() < result2.as_value();
+  case torrent::Object::TYPE_STRING: return result1.as_string() < result2.as_string();
+  default: return (int64_t)false;
+  }
+}
+
+// Fixme.
+torrent::Object
+apply_greater(rpc::target_type target, const torrent::Object& rawArgs) {
+  return (int64_t)!apply_less(target, rawArgs).as_value();
 }
 
 torrent::Object
-apply_to_time(const torrent::Object& rawArgs) {
+apply_to_time(int flags, const torrent::Object& rawArgs) {
+  std::tm *u;
   time_t t = (uint64_t)rawArgs.as_value();
-  std::tm *u = std::gmtime(&t);
+
+  if (flags & 0x1)
+    u = std::localtime(&t);
+  else
+    u = std::gmtime(&t);
   
   if (u == NULL)
     return torrent::Object();
 
-  char buffer[9];
-  snprintf(buffer, 9, "%2d:%02d:%02d", u->tm_hour, u->tm_min, u->tm_sec);
+  char buffer[11];
+
+  if (flags & 0x2)
+    snprintf(buffer, 11, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year));
+  else
+    snprintf(buffer, 9, "%2d:%02d:%02d", u->tm_hour, u->tm_min, u->tm_sec);
 
   return std::string(buffer);
 }
 
 torrent::Object
 apply_to_elapsed_time(const torrent::Object& rawArgs) {
@@ -242,45 +361,120 @@
     itr++;
   }
 
   if (itr == args.end())
     return torrent::Object();
 
-  if (flags & 0x1 && itr->is_string())
+  if (flags & 0x1 && itr->is_string()) {
     return rpc::parse_command(target, itr->as_string().c_str(), itr->as_string().c_str() + itr->as_string().size()).first;
-  else
+
+  } else if (flags & 0x1 && itr->is_list()) {
+    // Move this into a special function or something. Also, might be
+    // nice to have a parse_command function that takes list
+    // iterator...
+
+    for (torrent::Object::list_type::const_iterator cmdItr = itr->as_list().begin(), last = itr->as_list().end(); cmdItr != last; cmdItr++)
+      if (cmdItr->is_string())
+        rpc::parse_command(target, cmdItr->as_string().c_str(), cmdItr->as_string().c_str() + cmdItr->as_string().size());
+
+    return torrent::Object();
+
+  } else {
     return *itr;
+  }
+}
+
+torrent::Object
+cmd_view_size(__UNUSED rpc::target_type target, const torrent::Object& rawArgs) {
+  return (*control->view_manager()->find_throw(rawArgs.as_string()))->size_visible();
+}
+
+torrent::Object
+cmd_view_size_not_visible(__UNUSED rpc::target_type target, const torrent::Object& rawArgs) {
+  return (*control->view_manager()->find_throw(rawArgs.as_string()))->size_not_visible();
+}
+
+torrent::Object
+cmd_ui_unfocus_download(core::Download* download, const torrent::Object& rawArgs) {
+  control->ui()->download_list()->unfocus_download(download);
+
+  return torrent::Object();
+}
+
+torrent::Object
+cmd_view_filter_download(core::Download* download, const torrent::Object& rawArgs) {
+  (*control->view_manager()->find_throw(rawArgs.as_string()))->filter_download(download);
+
+  return torrent::Object();
+}
+
+torrent::Object
+cmd_view_set_visible(core::Download* download, const torrent::Object& rawArgs) {
+  (*control->view_manager()->find_throw(rawArgs.as_string()))->set_visible(download);
+
+  return torrent::Object();
+}
+
+torrent::Object
+cmd_view_set_not_visible(core::Download* download, const torrent::Object& rawArgs) {
+  (*control->view_manager()->find_throw(rawArgs.as_string()))->set_not_visible(download);
+
+  return torrent::Object();
 }
 
 void
 initialize_command_ui() {
   ADD_VARIABLE_STRING("key_layout", "qwerty");
 
   ADD_COMMAND_STRING("view_add",        rpc::object_string_fn(rak::make_mem_fun(control->view_manager(), &core::ViewManager::insert_throw)));
   ADD_COMMAND_NONE_L("view_list",       rak::ptr_fn(&apply_view_list));
+  ADD_COMMAND_NONE_L("view_set",        rak::ptr_fn(&apply_view_set));
 
-  ADD_COMMAND_LIST("view_filter",       rak::bind_ptr_fn(&apply_view_filter, &core::ViewManager::set_filter));
-  ADD_COMMAND_LIST("view_filter_on",    rak::bind_ptr_fn(&apply_view_filter, &core::ViewManager::set_filter_on));
+  ADD_COMMAND_LIST("view_filter",       rak::bind_ptr_fn(&apply_view_cfilter, &core::ViewManager::set_filter));
+  ADD_COMMAND_LIST("view_filter_on",    rak::ptr_fn(&apply_view_filter_on));
 
   ADD_COMMAND_LIST("view_sort",         rak::ptr_fn(&apply_view_sort));
-  ADD_COMMAND_LIST("view_sort_new",     rak::bind_ptr_fn(&apply_view_filter, &core::ViewManager::set_sort_new));
-  ADD_COMMAND_LIST("view_sort_current", rak::bind_ptr_fn(&apply_view_filter, &core::ViewManager::set_sort_current));
+  ADD_COMMAND_LIST("view_sort_new",     rak::bind_ptr_fn(&apply_view_cfilter, &core::ViewManager::set_sort_new));
+  ADD_COMMAND_LIST("view_sort_current", rak::bind_ptr_fn(&apply_view_cfilter, &core::ViewManager::set_sort_current));
+
+  ADD_COMMAND_LIST("view.event_added",   rak::bind_ptr_fn(&apply_view_cfilter, &core::ViewManager::set_event_added));
+  ADD_COMMAND_LIST("view.event_removed", rak::bind_ptr_fn(&apply_view_cfilter, &core::ViewManager::set_event_removed));
+
+  // Cleanup and add . to view.
 
-//   ADD_COMMAND_LIST("view_sort_current", rak::bind_ptr_fn(&apply_view_filter, &core::ViewManager::set_sort_current));
+  CMD_G_STRING("view.size",              rak::ptr_fn(&cmd_view_size));
+  CMD_G_STRING("view.size_not_visible",  rak::ptr_fn(&cmd_view_size_not_visible));
+  CMD_D_STRING("view.filter_download",   rak::ptr_fn(&cmd_view_filter_download));
+  CMD_D_STRING("view.set_visible",       rak::ptr_fn(&cmd_view_set_visible));
+  CMD_D_STRING("view.set_not_visible",   rak::ptr_fn(&cmd_view_set_not_visible));
+
+  // Commands that affect the default rtorrent UI.
+
+//   ADD_ANY_NONE("ui.focus",              rak::ptr_fn(&cmd_ui_focus));
+  CMD_D_ANY("ui.unfocus_download",     rak::ptr_fn(&cmd_ui_unfocus_download));
 
   // Move.
 
   ADD_ANY_NONE("print",                 rak::ptr_fn(&apply_print));
   ADD_ANY_NONE("cat",                   rak::ptr_fn(&apply_cat));
   ADD_ANY_NONE("if",                    rak::bind_ptr_fn(&apply_if, 0));
+  ADD_ANY_NONE("not",                   rak::ptr_fn(&apply_not));
+  ADD_ANY_NONE("false",                 rak::ptr_fn(&apply_false));
+  ADD_ANY_NONE("and",                   rak::ptr_fn(&apply_and));
+  ADD_ANY_NONE("or",                    rak::ptr_fn(&apply_or));
+
+  ADD_ANY_LIST("less",                  rak::ptr_fn(&apply_less));
+  ADD_ANY_LIST("greater",               rak::ptr_fn(&apply_greater));
 
   // A temporary command for handling stuff until we get proper
   // support for seperation of commands and literals.
   ADD_ANY_NONE("branch",                rak::bind_ptr_fn(&apply_if, 1));
 
-  ADD_COMMAND_VALUE("to_date",          rak::ptr_fn(&apply_to_date));
-  ADD_COMMAND_VALUE("to_time",          rak::ptr_fn(&apply_to_time));
+  ADD_COMMAND_VALUE("to_gm_time",       rak::bind_ptr_fn(&apply_to_time, 0));
+  ADD_COMMAND_VALUE("to_gm_date",       rak::bind_ptr_fn(&apply_to_time, 0x2));
+  ADD_COMMAND_VALUE("to_time",          rak::bind_ptr_fn(&apply_to_time, 0x1));
+  ADD_COMMAND_VALUE("to_date",          rak::bind_ptr_fn(&apply_to_time, 0x1 | 0x2));
   ADD_COMMAND_VALUE("to_elapsed_time",  rak::ptr_fn(&apply_to_elapsed_time));
   ADD_COMMAND_VALUE("to_kb",            rak::ptr_fn(&apply_to_kb));
   ADD_COMMAND_VALUE("to_mb",            rak::ptr_fn(&apply_to_mb));
   ADD_COMMAND_VALUE("to_xb",            rak::ptr_fn(&apply_to_xb));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/control.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/control.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/control.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/control.cc	2008-03-27 19:19:57.000000000 +0800
@@ -71,13 +71,13 @@
 
   m_scgi(NULL),
 
   m_tick(0) {
 
   m_core        = new core::Manager();
-  m_viewManager = new core::ViewManager(m_core->download_list());
+  m_viewManager = new core::ViewManager();
   m_scheduler   = new core::Scheduler(m_core->download_list());
   m_dhtManager  = new core::DhtManager();
 
   m_inputStdin->slot_pressed(sigc::mem_fun(m_input, &input::Manager::pressed));
 
   m_taskShutdown.set_slot(rak::mem_fn(this, &Control::handle_shutdown));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/download.cc	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/download.cc	2008-03-28 01:32:12.000000000 +0800
@@ -95,14 +95,13 @@
 Download::priority() {
   return bencode()->get_key("rtorrent").get_key_value("priority");
 }
 
 void
 Download::set_priority(uint32_t p) {
-  if (p >= 4)
-    throw torrent::input_error("Priority out of range.");
+  p %= 4;
 
   // Seeding torrents get half the priority of unfinished torrents.
   if (!is_done())
     torrent::download_set_priority(m_download, p * p * 2);
   else
     torrent::download_set_priority(m_download, p * p);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/download_factory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/download_factory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/download_factory.cc	2008-01-20 02:57:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/download_factory.cc	2008-03-28 23:23:24.000000000 +0800
@@ -258,12 +258,29 @@
   try {
     std::for_each(m_commands.begin(), m_commands.end(), rak::bind1st(std::ptr_fun(&rpc::parse_command_d_multiple_std), download));
 
     if (m_manager->download_list()->find(infohash) == m_manager->download_list()->end())
       throw torrent::input_error("The newly created download was removed.");
 
+    // When a download scheduler is implemented, this is handled by
+    // the above insertion into download list.
+    if (m_session) {
+      // This torrent was queued for hashing or hashing when the
+      // session file was saved. Or it was in a started state.
+      if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped ||
+          rpc::call_command_value("d.get_state", rpc::make_target(download)) != 0)
+        m_manager->download_list()->resume(download);
+
+    } else {
+      // Use the state thingie here, move below.
+      if (m_start)
+        rpc::parse_command_single(rpc::make_target(download), "d.start=");
+
+      m_manager->download_store()->save(download);
+    }
+
   } catch (torrent::input_error& e) {
     std::string msg = "Command on torrent creation failed: " + std::string(e.what());
 
     if (m_printLog) {
       m_manager->get_log_important().push_front(msg);
       m_manager->get_log_complete().push_front(msg);
@@ -272,31 +289,12 @@
     if (m_manager->download_list()->find(infohash) != m_manager->download_list()->end()) {
       // Should stop it, mark it bad. Perhaps even delete it?
       download->set_hash_failed(true);
       download->set_message(msg);
       //     m_manager->download_list()->erase(m_manager->download_list()->find(infohash.data()));
     }
-
-    return m_slotFinished();
-  }
-
-  // When a download scheduler is implemented, this is handled by the
-  // above insertion into download list.
-  if (m_session) {
-    // This torrent was queued for hashing or hashing when the session
-    // file was saved. Or it was in a started state.
-    if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped ||
-        rpc::call_command_value("d.get_state", rpc::make_target(download)) != 0)
-      m_manager->download_list()->resume(download);
-
-  } else {
-    // Use the state thingie here, move below.
-    if (m_start)
-      m_manager->download_list()->start_normal(download);
-
-    m_manager->download_store()->save(download);
   }
 
   m_slotFinished();
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/download_list.cc	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/download_list.cc	2008-04-12 01:34:33.000000000 +0800
@@ -51,12 +51,14 @@
 
 #include "rpc/parse_commands.h"
 
 #include "control.h"
 #include "globals.h"
 #include "manager.h"
+#include "view.h"
+#include "view_manager.h"
 
 #include "dht_manager.h"
 #include "download.h"
 #include "download_list.h"
 #include "download_store.h"
 
@@ -72,13 +74,13 @@
 
 struct download_list_call {
   download_list_call(Download* d) : m_download(d) {}
 
   void operator () (const DownloadList::slot_map::value_type& s) {
     try {
-      s.second(m_download);
+      rpc::parse_command_d_multiple_std(m_download, s.second);
     } catch (torrent::input_error& e) {
       control->core()->push_log((std::string("Download event action failed: ") + e.what()).c_str());
     }
   }
 
   Download* m_download;
@@ -161,12 +163,17 @@
   iterator itr = base_type::insert(end(), download);
 
   try {
     (*itr)->download()->signal_download_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::received_finished), download));
     (*itr)->download()->signal_hash_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::hash_done), download));
 
+    // This needs to be separated into two different calls to ensure
+    // the download remains in the view.
+    std::for_each(control->view_manager()->begin(), control->view_manager()->end(), std::bind2nd(std::mem_fun(&View::insert), download));
+    std::for_each(control->view_manager()->begin(), control->view_manager()->end(), std::bind2nd(std::mem_fun(&View::filter_download), download));
+
     std::for_each(slot_map_insert().begin(), slot_map_insert().end(), download_list_call(*itr));
 
   } catch (torrent::local_error& e) {
     // Should perhaps relax this, just print an error and remove the
     // downloads?
     throw torrent::internal_error("Caught during DownloadList::insert(...): " + std::string(e.what()));
@@ -190,12 +197,13 @@
 
   close(*itr);
 
   control->core()->download_store()->remove(*itr);
 
   std::for_each(slot_map_erase().begin(), slot_map_erase().end(), download_list_call(*itr));
+  std::for_each(control->view_manager()->begin(), control->view_manager()->end(), std::bind2nd(std::mem_fun(&View::erase), *itr));
 
   torrent::download_remove(*(*itr)->download());
   delete *itr;
 
   return base_type::erase(itr);
 }
@@ -234,28 +242,12 @@
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
-bool
-DownloadList::close_try(Download* download) {
-  try {
-    if (rpc::call_command_value("d.get_ignore_commands", rpc::make_target(download)) != 0)
-      return false;
-
-    rpc::call_command("d.set_state", (int64_t)0, rpc::make_target(download));
-    close_throw(download);
-    return true;
-
-  } catch (torrent::local_error& e) {
-    control->core()->push_log(e.what());
-    return false;
-  }
-}
-
 void
 DownloadList::close_directly(Download* download) {
   if (download->download()->is_active()) {
     download->download()->stop(torrent::Download::stop_skip_tracker);
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
   }
@@ -304,72 +296,22 @@
 
   std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
   std::for_each(slot_map_close().begin(), slot_map_close().end(), download_list_call(download));
 }
 
 void
-DownloadList::start_normal(Download* download) {
-  check_contains(download);
-
-  // Clear hash failed as we're doing a manual start and want to try
-  // hashing again.
-  download->set_hash_failed(false);
-  rpc::call_command("d.set_state", (int64_t)1, rpc::make_target(download));
-
-  resume(download);
-}
-
-bool
-DownloadList::start_try(Download* download) {
-  check_contains(download);
-
-  // Also don't start if the state is one of those that indicate we
-  // were manually stopped?
-
-  if (download->is_hash_failed() || rpc::call_command_value("d.get_ignore_commands", rpc::make_target(download)) != 0)
-    return false;
-
-  // Don't clear the hash failed as this function is used by scripts,
-  // etc.
-  rpc::call_command("d.set_state", (int64_t)1, rpc::make_target(download));
-
-  resume(download);
-  return true;
-}
-
-void
-DownloadList::stop_normal(Download* download) {
-  check_contains(download);
-
-  rpc::call_command("d.set_state", (int64_t)0, rpc::make_target(download));
-
-  pause(download);
-}
-
-bool
-DownloadList::stop_try(Download* download) {
-  check_contains(download);
-
-  if (rpc::call_command_value("d.get_ignore_commands", rpc::make_target(download)) != 0)
-    return false;
-
-  rpc::call_command("d.set_state", (int64_t)0, rpc::make_target(download));
-
-  pause(download);
-  return true;
-}
-
-void
 DownloadList::resume(Download* download, int flags) {
   check_contains(download);
 
   try {
 
     if (download->download()->is_active())
       return;
 
+    rpc::parse_command_single(rpc::make_target(download), "view.set_visible=active");
+
     // We need to make sure the flags aren't reset if someone decideds
     // to call resume() while it is hashing, etc.
     if (download->resume_flags() == ~uint32_t())
       download->set_resume_flags(flags);
 
     // Manual or end-of-download rehashing clears the resume data so
@@ -431,12 +373,14 @@
   check_contains(download);
 
   try {
 
     download->set_resume_flags(~uint32_t());
 
+    rpc::parse_command_single(rpc::make_target(download), "view.set_not_visible=active");
+
     // Always clear hashing on pause. When a hashing request is added,
     // it should have cleared the hash resume data.
     if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped) {
       download->download()->hash_stop();
       rpc::call_command_set_value("d.set_hashing", Download::variable_hashing_stopped, rpc::make_target(download));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/download_list.h	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/download_list.h	2008-03-29 00:42:14.000000000 +0800
@@ -56,15 +56,14 @@
 // change the states from outside of core.
 //
 // Fix apply_on_ratio if the base_type is changed.
 
 class DownloadList : private std::list<Download*> {
 public:
-  typedef std::list<Download*>             base_type;
-  typedef sigc::slot1<void, Download*>     slot_type;
-  typedef std::map<std::string, slot_type> slot_map;
+  typedef std::list<Download*>               base_type;
+  typedef std::map<std::string, std::string> slot_map;
 
   using base_type::iterator;
   using base_type::const_iterator;
   using base_type::reverse_iterator;
   using base_type::const_reverse_iterator;
   using base_type::value_type;
@@ -100,26 +99,20 @@
   //void                save(Download* d);
 
   bool                open(Download* d);
   void                open_throw(Download* d);
 
   void                close(Download* d);
-  bool                close_try(Download* d);
   void                close_directly(Download* d);
   void                close_quick(Download* d);
   void                close_throw(Download* d);
 
-  void                start_normal(Download* d);
-  bool                start_try(Download* d);
-
-  void                stop_normal(Download* d);
-  bool                stop_try(Download* d);
-
   void                resume(Download* d, int flags = 0);
   void                pause(Download* d, int flags = 0);
 
+  void                resume_default(Download* d) { resume(d); }
   void                pause_default(Download* d) { pause(d); }
 
   void                check_hash(Download* d);
 
   enum {
     SLOTS_INSERT,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/manager.cc	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/manager.cc	2008-03-24 16:34:26.000000000 +0800
@@ -71,30 +71,13 @@
 #include "poll_manager_kqueue.h"
 #include "poll_manager_select.h"
 #include "view.h"
 
 namespace core {
 
-static void
-connect_signal_network_log(Download* d, torrent::Download::slot_string_type s) {
-  d->download()->signal_network_log(s);
-}
-
-static void
-connect_signal_storage_log(Download* d, torrent::Download::slot_string_type s) {
-  d->download()->signal_storage_error(s);
-}
-
-// Need a proper logging class for this.
-static void
-connect_signal_tracker_dump(Download* d, torrent::Download::slot_dump_type s) {
-  if (!rpc::call_command_string("get_tracker_dump").empty())
-    d->download()->signal_tracker_dump(s);
-}
-
-static void
+void
 receive_tracker_dump(const std::string& url, const char* data, size_t size) {
   const std::string& filename = rpc::call_command_string("get_tracker_dump");
 
   if (filename.empty())
     return;
 
@@ -226,17 +209,14 @@
   m_httpQueue->slot_factory(sigc::mem_fun(m_pollManager->get_http_stack(), &CurlStack::new_object));
 
   CurlStack::global_init();
 
   // Register slots to be called when a download is inserted/erased,
   // opened or closed.
-  m_downloadList->slot_map_insert()["1_connect_network_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_network_log), sigc::mem_fun(m_logComplete, &Log::push_front));
-  m_downloadList->slot_map_insert()["1_connect_storage_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_storage_log), sigc::mem_fun(m_logComplete, &Log::push_front));
-  m_downloadList->slot_map_insert()["1_connect_tracker_dump"] = sigc::bind(sigc::ptr_fun(&connect_signal_tracker_dump), sigc::ptr_fun(&receive_tracker_dump));
-
-  m_downloadList->slot_map_erase()["9_delete_tied"] = sigc::bind<0>(&rpc::call_command_d_v_void, "d.delete_tied");
+  m_downloadList->slot_map_insert()["1_connect_logs"] = "d.initialize_logs=";
+  m_downloadList->slot_map_erase()["9_delete_tied"]   = "d.delete_tied=";
 
   torrent::connection_manager()->set_signal_handshake_log(sigc::mem_fun(this, &Manager::handshake_log));
 }
 
 void
 Manager::cleanup() {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/manager.h	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/manager.h	2008-03-27 19:00:33.000000000 +0800
@@ -100,12 +100,13 @@
   void                set_proxy_address(const std::string& addr);
 
   void                shutdown(bool force);
 
   void                push_log(const char* msg);
   void                push_log_std(const std::string& msg) { m_logImportant.push_front(msg); m_logComplete.push_front(msg); }
+  void                push_log_complete(const std::string& msg) { m_logComplete.push_front(msg); }
 
   void                handshake_log(const sockaddr* sa, int msg, int err, const torrent::HashString* hash);
 
   static const int create_start    = 0x1;
   static const int create_tied     = 0x2;
   static const int create_quiet    = 0x4;
@@ -136,9 +136,12 @@
 
   PollManager*        m_pollManager;
   Log                 m_logImportant;
   Log                 m_logComplete;
 };
 
+// Meh, cleanup.
+extern void receive_tracker_dump(const std::string& url, const char* data, size_t size);
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/scheduler.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/scheduler.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/scheduler.cc	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/scheduler.cc	2008-03-28 23:47:23.000000000 +0800
@@ -68,40 +68,40 @@
 Scheduler::active() const {
   return std::count_if(m_view->begin_visible(), m_view->end_visible(), std::mem_fun(&Download::is_active));
 }
 
 void
 Scheduler::update() {
-  size_type curActive = active();
+//   size_type curActive = active();
   //  size_type curInactive = m_view->size() - curActive;
 
   // Hmm... Perhaps we should use a more complex sorting thingie.
-  m_view->sort();
+//   m_view->sort();
 
   // Just a hack for now, need to take into consideration how many
   // inactive we can switch with.
-  size_type target = m_maxActive - std::min(m_cycle, m_maxActive);
+//   size_type target = m_maxActive - std::min(m_cycle, m_maxActive);
 
-  for (View::iterator itr = m_view->begin_visible(), last = m_view->end_visible(); curActive > target; ++itr) {
-    if (itr == last)
-      throw torrent::internal_error("Scheduler::update() loop bork.");
-
-    if ((*itr)->is_active()) {
-      m_downloadList->pause(*itr);
-      --curActive;
-    }      
-  }
-
-  m_view->sort();
-
-  for (View::iterator itr = m_view->begin_visible(), last = m_view->end_visible(); curActive < m_maxActive; ++itr) {
-    if (itr == last)
-      throw torrent::internal_error("Scheduler::update() loop bork.");
-
-    if (!(*itr)->is_active()) {
-      m_downloadList->start_try(*itr);
-      ++curActive;
-    }      
-  }
+//   for (View::iterator itr = m_view->begin_visible(), last = m_view->end_visible(); curActive > target; ++itr) {
+//     if (itr == last)
+//       throw torrent::internal_error("Scheduler::update() loop bork.");
+
+//     if ((*itr)->is_active()) {
+//       m_downloadList->pause(*itr);
+//       --curActive;
+//     }      
+//   }
+
+//   m_view->sort();
+
+//   for (View::iterator itr = m_view->begin_visible(), last = m_view->end_visible(); curActive < m_maxActive; ++itr) {
+//     if (itr == last)
+//       throw torrent::internal_error("Scheduler::update() loop bork.");
+
+//     if (!(*itr)->is_active()) {
+//       m_downloadList->start_try(*itr);
+//       ++curActive;
+//     }      
+//   }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/view.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/view.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/view.cc	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/view.cc	2008-03-27 19:55:30.000000000 +0800
@@ -36,150 +36,281 @@
 
 #include "config.h"
 
 #include <algorithm>
 #include <functional>
 #include <rak/functional.h>
+#include <rak/functional_fun.h>
+#include <rpc/parse_commands.h>
 #include <sigc++/adaptors/bind.h>
 #include <torrent/download.h>
 #include <torrent/exceptions.h>
 
+#include "control.h"
 #include "download.h"
 #include "download_list.h"
-
+#include "manager.h"
 #include "view.h"
 
 namespace core {
 
+// Also add focus thingie here?
+struct view_downloads_compare : std::binary_function<Download*, Download*, bool> {
+  view_downloads_compare(const std::string& cmd) : m_command(cmd) {}
+
+  bool operator () (Download* d1, Download* d2) const {
+    try {
+      if (m_command.empty())
+        return false;
+
+      return rpc::parse_command_single(rpc::make_target_pair(d1, d2), m_command).as_value();
+
+    } catch (torrent::input_error& e) {
+      control->core()->push_log(e.what());
+
+      return false;
+    }
+  }
+
+  const std::string& m_command;
+};
+
+struct view_downloads_filter : std::unary_function<Download*, bool> {
+  view_downloads_filter(const std::string& cmd) : m_command(cmd) {}
+
+  bool operator () (Download* d1) const {
+    if (m_command.empty())
+      return true;
+
+    try {
+      torrent::Object result = rpc::parse_command_single(rpc::make_target(d1), m_command);
+
+      switch (result.type()) {
+      case torrent::Object::TYPE_NONE:   return false;
+      case torrent::Object::TYPE_VALUE:  return result.as_value();
+      case torrent::Object::TYPE_STRING: return !result.as_string().empty();
+      case torrent::Object::TYPE_LIST:   return !result.as_list().empty();
+      case torrent::Object::TYPE_MAP:    return !result.as_map().empty();
+      }
+
+      // The default filter action is to return true, to not filter
+      // the download out.
+      return true;
+
+    } catch (torrent::input_error& e) {
+      control->core()->push_log(e.what());
+
+      return false;
+    }
+  }
+
+  const std::string&       m_command;
+};
+
+inline void
+View::emit_changed() {
+  priority_queue_erase(&taskScheduler, &m_delayChanged);
+  priority_queue_insert(&taskScheduler, &m_delayChanged, cachedTime);
+}
+
 View::~View() {
   if (m_name.empty())
     return;
 
-  std::for_each(m_list->slot_map_begin(), m_list->slot_map_end(), rak::bind2nd(std::ptr_fun(&DownloadList::erase_key), "0_view_" + m_name));
+  std::for_each(control->core()->download_list()->slot_map_begin(), control->core()->download_list()->slot_map_end(),
+                rak::bind2nd(std::ptr_fun(&DownloadList::erase_key), "0_view_" + m_name));
+
+  priority_queue_erase(&taskScheduler, &m_delayChanged);
 }
 
 void
-View::initialize(const std::string& name, core::DownloadList* dlist) {
+View::initialize(const std::string& name) {
   if (!m_name.empty())
     throw torrent::internal_error("View::initialize(...) called on an already initialized view.");
 
   if (name.empty())
     throw torrent::internal_error("View::initialize(...) called with an empty name.");
 
   std::string key = "0_view_" + name;
+  core::DownloadList* dlist = control->core()->download_list();
 
   if (dlist->has_slot_insert(key) || dlist->has_slot_erase(key))
     throw torrent::internal_error("View::initialize(...) duplicate key name found in DownloadList.");
 
   m_name = name;
-  m_list = dlist;
 
   // Urgh, wrong. No filtering being done.
-  std::for_each(m_list->begin(), m_list->end(), rak::bind1st(std::mem_fun(&View::push_back), this));
+  std::for_each(dlist->begin(), dlist->end(), rak::bind1st(std::mem_fun(&View::push_back), this));
 
   m_size = base_type::size();
   m_focus = 0;
 
-  m_list->slot_map_insert()[key] = sigc::bind(sigc::mem_fun(this, &View::received), (int)DownloadList::SLOTS_INSERT);
-  m_list->slot_map_erase()[key]  = sigc::bind(sigc::mem_fun(this, &View::received), (int)DownloadList::SLOTS_ERASE);
-
   set_last_changed(rak::timer());
+  m_delayChanged.set_slot(rak::mem_fn(&m_signalChanged, &signal_type::operator()));
 }
 
 void
-View::next_focus() {
-  if (empty())
-    return;
+View::erase(Download* download) {
+  iterator itr = std::find(base_type::begin(), base_type::end(), download);
 
-  m_focus = (m_focus + 1) % (size() + 1);
+  if (itr >= end_visible()) {
+    erase_internal(itr);
 
-  m_signalChanged.emit();
+  } else {
+    erase_internal(itr);
+    rpc::parse_command_multiple_d_nothrow(download, m_eventRemoved);
+  }
 }
 
 void
-View::prev_focus() {
-  if (empty())
+View::set_visible(Download* download) {
+  iterator itr = std::find(begin_filtered(), end_filtered(), download);
+
+  if (itr == end_filtered())
     return;
 
-  m_focus = (m_focus - 1 + size() + 1) % (size() + 1);
+  // Don't optimize erase since we want to keep the order of the
+  // non-visible elements.
+  base_type::erase(itr);
+  insert_visible(download);
 
-  m_signalChanged.emit();
+  rpc::parse_command_multiple_d_nothrow(download, m_eventAdded);
 }
 
-// Need to use wrapper-functors so it will properly call the virtual
-// functions.
+void
+View::set_not_visible(Download* download) {
+  iterator itr = std::find(begin_visible(), end_visible(), download);
 
-// Also add focus thingie here?
-struct view_downloads_compare : std::binary_function<Download*, Download*, bool> {
-  view_downloads_compare(const View::sort_list& s) : m_sort(s) {}
+  if (itr == end_visible())
+    return;
 
-  bool operator () (Download* d1, Download* d2) const {
-    for (View::sort_list::const_iterator itr = m_sort.begin(), last = m_sort.end(); itr != last; ++itr)
-      if ((**itr)(d1, d2))
-        return true;
-      else if ((**itr)(d2, d1))
-        return false;
+  m_size--;
+  m_focus -= (m_focus > position(itr));
 
-    // Since we're testing equivalence, return false if we're
-    // equal. This is a requirement for the stl sorting algorithms.
-    return false;
-  }
+  // Don't optimize erase since we want to keep the order of the
+  // non-visible elements.
+  base_type::erase(itr);
+  base_type::push_back(download);
 
-  const View::sort_list& m_sort;
-};
+  rpc::parse_command_multiple_d_nothrow(download, m_eventRemoved);
+}
 
-struct view_downloads_filter : std::unary_function<Download*, bool> {
-  view_downloads_filter(const View::filter_list& s) : m_filter(s) {}
+void
+View::next_focus() {
+  if (empty())
+    return;
 
-  bool operator () (Download* d1) const {
-    for (View::filter_list::const_iterator itr = m_filter.begin(), last = m_filter.end(); itr != last; ++itr)
-      if (!(**itr)(d1))
-        return false;
+  m_focus = (m_focus + 1) % (size() + 1);
+  emit_changed();
+}
 
-    // The default filter action is to return true, to not filter the
-    // download out.
-    return true;
-  }
+void
+View::prev_focus() {
+  if (empty())
+    return;
 
-  const View::filter_list& m_filter;
-};
+  m_focus = (m_focus - 1 + size() + 1) % (size() + 1);
+  emit_changed();
+}
 
 void
 View::sort() {
   Download* curFocus = focus() != end_visible() ? *focus() : NULL;
 
   // Don't go randomly switching around equivalent elements.
   std::stable_sort(begin(), end_visible(), view_downloads_compare(m_sortCurrent));
 
   m_focus = position(std::find(begin(), end_visible(), curFocus));
-  m_signalChanged.emit();
+  emit_changed();
 }
 
 void
 View::filter() {
-  iterator split = std::stable_partition(base_type::begin(), base_type::end(), view_downloads_filter(m_filter));
+  // Parition the list in two steps so we know which elements changed.
+  iterator splitVisible  = std::stable_partition(begin_visible(),  end_visible(),  view_downloads_filter(m_filter));
+  iterator splitFiltered = std::stable_partition(begin_filtered(), end_filtered(), view_downloads_filter(m_filter));
 
-  m_size = position(split);
+  base_type changed(splitVisible, splitFiltered);
+  iterator splitChanged = changed.begin() + std::distance(splitVisible, end_visible());
+  
+  m_size = std::distance(begin(), std::copy(splitChanged, changed.end(), splitVisible));
+  std::copy(changed.begin(), splitChanged, begin_filtered());
 
-  // Fix focus
+  // Fix this...
   m_focus = std::min(m_focus, m_size);
+
+  // The commands are allowed to remove itself from or change View
+  // sorting since the commands are being called on the 'changed'
+  // vector. But this will cause undefined behavior if elements are
+  // removed.
+  //
+  // Consider if View should lock itself (and throw) if erase events
+  // are triggered on a Download in the 'changed' list. This can be
+  // done by using a base_type* member variable, and making sure we
+  // set the elements to NULL as we trigger commands on them. Or
+  // perhaps always clear them, thus not throwing anything.
+  if (!m_eventRemoved.empty())
+    std::for_each(changed.begin(), splitChanged, rak::bind2nd(std::ptr_fun(&rpc::parse_command_multiple_d_nothrow), m_eventRemoved));
+
+  if (!m_eventAdded.empty())
+    std::for_each(splitChanged, changed.end(),   rak::bind2nd(std::ptr_fun(&rpc::parse_command_multiple_d_nothrow), m_eventAdded));
+
+  emit_changed();
+}
+
+void
+View::filter_download(core::Download* download) {
+  iterator itr = std::find(base_type::begin(), base_type::end(), download);
+
+  if (itr == base_type::end())
+    throw torrent::internal_error("View::filter_download(...) could not find download.");
+
+  if (view_downloads_filter(m_filter)(download)) {
+      
+    if (itr >= end_visible()) {
+      erase_internal(itr);
+      insert_visible(download);
+
+      rpc::parse_command_multiple_d_nothrow(download, m_eventAdded);
+
+    } else {
+      // This makes sure the download is sorted even if it is
+      // already visible.
+      //
+      // Consider removing this.
+      erase_internal(itr);
+      insert_visible(download);
+    }
+
+  } else {
+    if (itr >= end_visible())
+      return;
+
+    erase_internal(itr);
+    base_type::push_back(download);
+
+    rpc::parse_command_multiple_d_nothrow(download, m_eventRemoved);
+  }
+
+  emit_changed();
 }
 
 void
 View::set_filter_on(int event) {
   if (event == DownloadList::SLOTS_INSERT || event == DownloadList::SLOTS_ERASE || event >= DownloadList::SLOTS_MAX_SIZE)
     throw torrent::internal_error("View::filter_on(...) invalid event.");
 
-  m_list->slots(event)["0_view_" + m_name]  = sigc::bind(sigc::mem_fun(this, &View::received), event);
+  control->core()->download_list()->slots(event)["0_view_" + m_name] = "view.filter_download=" + m_name;
 }
 
 void
 View::clear_filter_on() {
   // Don't clear insert and erase as these are required to keep the
   // View up-to-date with the available downloads.
-  std::for_each(m_list->slot_map_begin() + DownloadList::SLOTS_OPEN, m_list->slot_map_end(), rak::bind2nd(std::ptr_fun(&DownloadList::erase_key), "0_view_" + m_name));
+  std::for_each(control->core()->download_list()->slot_map_begin() + DownloadList::SLOTS_OPEN, control->core()->download_list()->slot_map_end(),
+                rak::bind2nd(std::ptr_fun(&DownloadList::erase_key), "0_view_" + m_name));
 }
 
 inline void
 View::insert_visible(Download* d) {
   iterator itr = std::find_if(begin_visible(), end_visible(), std::bind1st(view_downloads_compare(m_sortNew), d));
 
@@ -187,67 +318,17 @@
   m_focus += (m_focus >= position(itr));
 
   base_type::insert(itr, d);
 }
 
 inline void
-View::erase(iterator itr) {
+View::erase_internal(iterator itr) {
   if (itr == end_filtered())
     throw torrent::internal_error("View::erase_visible(...) iterator out of range.");
 
   m_size -= (itr < end_visible());
   m_focus -= (m_focus > position(itr));
 
   base_type::erase(itr);
 }
 
-void
-View::received(core::Download* download, int event) {
-  iterator itr = std::find(base_type::begin(), base_type::end(), download);
-
-  switch (event) {
-  case DownloadList::SLOTS_INSERT:
-  
-    if (itr != base_type::end())
-      throw torrent::internal_error("View::received(..., SLOTS_INSERT) already inserted.");
-
-    if (view_downloads_filter(m_filter)(download))
-      insert_visible(download);
-    else
-      base_type::insert(end_filtered(), download);
-
-    if (m_focus > m_size)
-      throw torrent::internal_error("View::received(...) m_focus > m_size.");
-
-    break;
-
-  case DownloadList::SLOTS_ERASE:
-    erase(itr);
-    break;
-
-  default:
-    if (itr == end_filtered())
-      throw torrent::internal_error("View::received(..., SLOTS_*) could not find download.");
-
-    if (view_downloads_filter(m_filter)(download)) {
-      
-      // Erase even if it is in visible so that the download is
-      // re-sorted.
-      erase(itr);
-      insert_visible(download);
-
-    } else {
-
-      if (itr >= begin_filtered())
-        return;
-
-      erase(itr);
-      base_type::push_back(download);
-    }
-
-    break;
-  }
-
-  m_signalChanged.emit();
-}
-
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/view.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/view.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/view.h	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/view.h	2008-04-02 23:19:52.000000000 +0800
@@ -57,40 +57,37 @@
 
 #include "globals.h"
 
 namespace core {
 
 class Download;
-class DownloadList;
-class ViewSort;
-class ViewFilter;
 
 class View : private std::vector<Download*> {
 public:
   typedef std::vector<Download*>         base_type;
   typedef sigc::signal0<void>            signal_type;
-  typedef std::vector<const ViewSort*>   sort_list;
-  typedef std::vector<const ViewFilter*> filter_list;
 
   using base_type::iterator;
   using base_type::const_iterator;
   using base_type::reverse_iterator;
   using base_type::const_reverse_iterator;
   
   using base_type::size_type;
 
   View() {}
   ~View();
 
-  void                initialize(const std::string& name, DownloadList* dlist);
+  void                initialize(const std::string& name);
 
   const std::string&  name() const                            { return m_name; }
 
   bool                empty_visible() const                   { return m_size == 0; }
 
   size_type           size() const                            { return m_size; }
+  size_type           size_visible() const                    { return m_size; }
+  size_type           size_not_visible() const                { return base_type::size() - m_size; }
 
   // Perhaps this should be renamed?
   iterator            begin_visible()                         { return begin(); }
   const_iterator      begin_visible() const                   { return begin(); }
 
   iterator            end_visible()                           { return begin() + m_size; }
@@ -103,28 +100,38 @@
   const_iterator      end_filtered() const                    { return base_type::end(); }
 
   iterator            focus()                                 { return begin() + m_focus; }
   const_iterator      focus() const                           { return begin() + m_focus; }
   void                set_focus(iterator itr)                 { m_focus = position(itr); m_signalChanged.emit(); }
 
+  void                insert(Download* download)              { base_type::push_back(download); }
+  void                erase(Download* download);
+
+  void                set_visible(Download* download);
+  void                set_not_visible(Download* download);
+
   void                next_focus();
   void                prev_focus();
 
   void                sort();
 
-  void                set_sort_new(const sort_list& s)        { m_sortNew = s; }
-  void                set_sort_current(const sort_list& s)    { m_sortCurrent = s; }
+  void                set_sort_new(const std::string& s)      { m_sortNew = s; }
+  void                set_sort_current(const std::string& s)  { m_sortCurrent = s; }
 
   // Need to explicity trigger filtering.
   void                filter();
+  void                filter_download(core::Download* download);
 
-  void                set_filter(const filter_list& s)        { m_filter = s; }
+  void                set_filter(const std::string& s)        { m_filter = s; }
   void                set_filter_on(int event);
 
   void                clear_filter_on();
 
+  void                set_event_added(const std::string& cmd)   { m_eventAdded = cmd; }
+  void                set_event_removed(const std::string& cmd) { m_eventRemoved = cmd; }
+
   // The time of the last change to the view, semantics of this is
   // user-dependent. Used by f.ex. ViewManager to decide if it should
   // sort and/or filter a view.
   //
   // Currently initialized to rak::timer(), though perhaps we should
   // use cachedTimer.
@@ -139,47 +146,37 @@
   View(const View&);
   void operator = (const View&);
 
   void                push_back(Download* d)                  { base_type::push_back(d); }
 
   inline void         insert_visible(Download* d);
-  inline void         erase(iterator itr);
+  inline void         erase_internal(iterator itr);
 
-  void                received(Download* d, int event);
+  inline void         emit_changed();
 
   size_type           position(const_iterator itr) const      { return itr - begin(); }
 
   // An received thing for changed status so we can sort and filter.
 
   std::string         m_name;
 
-  DownloadList*       m_list;
-
   size_type           m_size;
   size_type           m_focus;
 
-  sort_list           m_sortNew;
-  sort_list           m_sortCurrent;
-
-  filter_list         m_filter;
-
-  rak::timer          m_lastChanged;
-  signal_type         m_signalChanged;
-};
+  // These should be replaced by a faster non-string command type.
+  std::string         m_sortNew;
+  std::string         m_sortCurrent;
 
-class ViewSort {
-public:
-  virtual ~ViewSort() {}
+  std::string         m_filter;
 
-  virtual bool operator () (Download* d1, Download* d2) const = 0;
-};
+  std::string         m_eventAdded;
+  std::string         m_eventRemoved;
 
-class ViewFilter {
-public:
-  virtual ~ViewFilter() {}
+  rak::timer          m_lastChanged;
 
-  virtual bool operator () (Download* d1) const = 0;
+  signal_type         m_signalChanged;
+  rak::priority_item  m_delayChanged;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/view_manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/view_manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/view_manager.cc	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/view_manager.cc	2008-03-27 19:06:30.000000000 +0800
@@ -50,126 +50,26 @@
 #include "manager.h"
 #include "view.h"
 #include "view_manager.h"
 
 namespace core {
 
-class ViewSortFalse : public ViewSort {
-public:
-  virtual bool operator () (Download* d1, Download* d2) const {
-    return false;
-  }
-};
-
-class ViewSortName : public ViewSort {
-public:
-  virtual bool operator () (Download* d1, Download* d2) const {
-    return d1->download()->name() < d2->download()->name();
-  }
-};
-
-class ViewSortVariable : public ViewSort {
-public:
-  ViewSortVariable(const char* name, const char* value) : m_name(name), m_value(value) {}
-
-  virtual bool operator () (Download* d1, Download* d2) const {
-    return
-      rpc::call_command_string(m_name, rpc::make_target(d1)) == m_value &&
-      rpc::call_command_string(m_name, rpc::make_target(d2)) != m_value;
-  }
-
-private:
-  const char* m_name;
-  const char* m_value;
-};
-
-class ViewSortVariableValue : public ViewSort {
-public:
-  ViewSortVariableValue(const char* name, bool reverse = false) : m_name(name), m_reverse(reverse) {}
-
-  virtual bool operator () (Download* d1, Download* d2) const {
-    if (m_reverse)
-      return rpc::call_command_value(m_name, rpc::make_target(d2)) < rpc::call_command_value(m_name, rpc::make_target(d1));
-    else
-      return rpc::call_command_value(m_name, rpc::make_target(d1)) < rpc::call_command_value(m_name, rpc::make_target(d2));
-  }
-
-private:
-  const char* m_name;
-  bool        m_reverse;
-};
-
-class ViewSortReverse : public ViewSort {
-public:
-  ViewSortReverse(ViewSort* s) : m_sort(s) {}
-  ~ViewSortReverse() { delete m_sort; }
-
-  virtual bool operator () (Download* d1, Download* d2) const {
-    return (*m_sort)(d2, d1);
-  }
-
-private:
-  ViewSort* m_sort;
-};
-
-class ViewFilterVariableValue : public ViewFilter {
-public:
-  ViewFilterVariableValue(const char* name, torrent::Object::value_type v, bool inverse = false) :
-    m_name(name), m_value(v), m_inverse(inverse) {}
-
-  virtual bool operator () (Download* d1) const {
-    return (rpc::call_command_value(m_name, rpc::make_target(d1)) == m_value) != m_inverse;
-  }
-
-private:
-  const char*                 m_name;
-  torrent::Object::value_type m_value;
-  bool                        m_inverse;
-};
-
-// Really need to implement a factory and allow options in the sort
-// statements.
-ViewManager::ViewManager(DownloadList* dl) :
-  m_list(dl) {
-
-//   m_sort["first"]        = new ViewSortNot(new ViewSort());
-  m_sort["last"]          = new ViewSortFalse();
-  m_sort["name"]          = new ViewSortName();
-  m_sort["name_reverse"]  = new ViewSortReverse(new ViewSortName());
-
-  m_sort["stopped"]       = new ViewSortVariableValue("d.get_state");
-  m_sort["started"]       = new ViewSortVariableValue("d.get_state", true);
-  m_sort["complete"]      = new ViewSortVariableValue("d.get_complete");
-  m_sort["incomplete"]    = new ViewSortVariableValue("d.get_complete", true);
-
-  m_sort["state_changed"]         = new ViewSortVariableValue("d.get_state_changed");
-  m_sort["state_changed_reverse"] = new ViewSortVariableValue("d.get_state_changed", true);
-
-  m_filter["started"]     = new ViewFilterVariableValue("d.get_state", 1);
-  m_filter["stopped"]     = new ViewFilterVariableValue("d.get_state", 0);
-  m_filter["complete"]    = new ViewFilterVariableValue("d.get_complete", 0, true);
-  m_filter["incomplete"]  = new ViewFilterVariableValue("d.get_complete", 0);
-  m_filter["hashing"]     = new ViewFilterVariableValue("d.get_hashing", 0, true);
-}
-
 void
 ViewManager::clear() {
   std::for_each(begin(), end(), rak::call_delete<View>());
-  std::for_each(m_sort.begin(), m_sort.end(), rak::on(rak::mem_ref(&sort_map::value_type::second), rak::call_delete<ViewSort>()));
-  std::for_each(m_filter.begin(), m_filter.end(), rak::on(rak::mem_ref(&filter_map::value_type::second), rak::call_delete<ViewFilter>()));
 
   base_type::clear();
 }
 
 ViewManager::iterator
 ViewManager::insert(const std::string& name) {
   if (find(name) != end())
     throw torrent::internal_error("ViewManager::insert(...) name already inserted.");
 
   View* view = new View();
-  view->initialize(name, m_list);
+  view->initialize(name);
 
   return base_type::insert(end(), view);
 }
 
 ViewManager::iterator
 ViewManager::find(const std::string& name) {
@@ -183,29 +83,12 @@
   if (itr == end())
     throw torrent::input_error("Could not find view: " + name);
 
   return itr;
 }
 
-inline ViewManager::sort_list
-ViewManager::build_sort_list(const sort_args& args) {
-  View::sort_list sortList;
-  sortList.reserve(args.size());
-
-  for (sort_args::const_iterator itr = args.begin(), last = args.end(); itr != last; ++itr) {
-    sort_map::const_iterator sortItr = m_sort.find(itr->c_str());
-
-    if (sortItr == m_sort.end())
-      throw torrent::input_error("Invalid sorting identifier.");
-
-    sortList.push_back(sortItr->second);
-  }
-
-  return sortList;
-}
-
 void
 ViewManager::sort(const std::string& name, uint32_t timeout) {
   iterator viewItr = find_throw(name);
 
   if ((*viewItr)->last_changed() + rak::timer::from_seconds(timeout) > cachedTime)
     return;
@@ -209,52 +92,20 @@
 
   if ((*viewItr)->last_changed() + rak::timer::from_seconds(timeout) > cachedTime)
     return;
 
   // Should we rename sort, or add a seperate function?
   (*viewItr)->filter();
-
   (*viewItr)->sort();
 }
 
 void
-ViewManager::set_sort_new(const std::string& name, const sort_args& sort) {
-  iterator viewItr = find_throw(name);
-
-  (*viewItr)->set_sort_new(build_sort_list(sort));
-}
-
-void
-ViewManager::set_sort_current(const std::string& name, const sort_args& sort) {
-  iterator viewItr = find_throw(name);
-
-  (*viewItr)->set_sort_current(build_sort_list(sort));
-}
-
-inline ViewManager::filter_list
-ViewManager::build_filter_list(const filter_args& args) {
-  View::filter_list filterList;
-  filterList.reserve(args.size());
-
-  for (filter_args::const_iterator itr = args.begin(), last = args.end(); itr != last; ++itr) {
-    filter_map::const_iterator filterItr = m_filter.find(itr->c_str());
-
-    if (filterItr == m_filter.end())
-      throw torrent::input_error("Invalid filtering identifier.");
-
-    filterList.push_back(filterItr->second);
-  }
-
-  return filterList;
-}
-
-void
-ViewManager::set_filter(const std::string& name, const filter_args& args) {
+ViewManager::set_filter(const std::string& name, const std::string& cmd) {
   iterator viewItr = find_throw(name);
 
-  (*viewItr)->set_filter(build_filter_list(args));
+  (*viewItr)->set_filter(cmd);
   (*viewItr)->filter();
 }
 
 void
 ViewManager::set_filter_on(const std::string& name, const filter_args& args) {
   iterator viewItr = find_throw(name);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/view_manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/view_manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/core/view_manager.h	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/core/view_manager.h	2008-03-27 19:06:34.000000000 +0800
@@ -34,38 +34,23 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_CORE_VIEW_MANAGER_H
 #define RTORRENT_CORE_VIEW_MANAGER_H
 
-#include <map>
-#include <cstring>
 #include <string>
 #include <rak/unordered_vector.h>
 
 #include "view.h"
 
 namespace core {
 
-struct view_manager_comp : public std::binary_function<const char*, const char*, bool> {
-  bool operator () (const char* arg1, const char* arg2) const { return std::strcmp(arg1, arg2) < 0; }
-};
-
-class ViewSort;
-
 class ViewManager : public rak::unordered_vector<View*> {
 public:
   typedef rak::unordered_vector<View*> base_type;
-
-  typedef std::map<const char*, ViewSort*, view_manager_comp> sort_map;
-  typedef View::sort_list                       sort_list;
-  typedef std::list<std::string>                sort_args;
-  
-  typedef std::map<const char*, ViewFilter*, view_manager_comp> filter_map;
-  typedef View::filter_list                     filter_list;
-  typedef std::list<std::string>                filter_args;
+  typedef std::list<std::string>       filter_args;
   
   using base_type::iterator;
   using base_type::const_iterator;
   using base_type::reverse_iterator;
   using base_type::const_reverse_iterator;
   
@@ -76,13 +61,13 @@
   using base_type::rbegin;
   using base_type::rend;
 
   using base_type::empty;
   using base_type::size;
 
-  ViewManager(DownloadList* dl);
+  ViewManager() {}
   ~ViewManager() { clear(); }
 
   // Ffff... Just throwing together an interface, need to think some
   // more on this.
 
   void                clear();
@@ -99,25 +84,23 @@
   // If View::last_changed() is less than 'timeout' seconds ago, don't
   // sort.
   //
   // Find a better name for 'timeout'.
   void                sort(const std::string& name, uint32_t timeout = 0);
 
-  void                set_sort_new(const std::string& name, const sort_args& sort);
-  void                set_sort_current(const std::string& name, const sort_args& sort);
+  // These could be moved to where the command is implemented.
+  void                set_sort_new(const std::string& name, const std::string& cmd)     { (*find_throw(name))->set_sort_new(cmd); }
+  void                set_sort_current(const std::string& name, const std::string& cmd) { (*find_throw(name))->set_sort_current(cmd); }
 
-  void                set_filter(const std::string& name, const filter_args& args);
+  void                set_filter(const std::string& name, const std::string& cmd);
   void                set_filter_on(const std::string& name, const filter_args& args);
 
-private:
-  inline sort_list    build_sort_list(const sort_args& args);
-  inline filter_list  build_filter_list(const sort_args& args);
+  void                set_event_added(const std::string& name, const std::string& cmd)   { (*find_throw(name))->set_event_added(cmd); }
+  void                set_event_removed(const std::string& name, const std::string& cmd) { (*find_throw(name))->set_event_removed(cmd); }
 
+private:
   DownloadList*       m_list;
-
-  sort_map            m_sort;
-  filter_map          m_filter;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/display/window_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/display/window_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/display/window_file_list.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/display/window_file_list.cc	2008-04-15 19:49:22.000000000 +0800
@@ -33,12 +33,13 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include <stdio.h>
 #include <torrent/path.h>
 #include <torrent/data/file.h>
 #include <torrent/data/file_list.h>
 #include <torrent/data/file_list_iterator.h>
 
 #include "core/download.h"
@@ -130,44 +131,46 @@
                       itr.depth() < (*itr)->path()->size() ? (*itr)->path()->at(itr.depth()).c_str() : "UNKNOWN");
 
     } else if (itr.is_leaving()) {
       m_canvas->print(16 + itr.depth() - 1, pos, "/");
 
     } else if (itr.is_file()) {
+      char buffer[std::max<unsigned int>(m_canvas->width() + 1, 256)];
+      Canvas::attributes_list attributes;
+
       torrent::File* e = *itr;
 
       const char* priority;
 
       switch (e->priority()) {
       case torrent::PRIORITY_OFF:    priority = "off"; break;
       case torrent::PRIORITY_NORMAL: priority = "   "; break;
       case torrent::PRIORITY_HIGH:   priority = "hig"; break;
       default: priority = "BUG"; break;
       };
 
-      m_canvas->print(0, pos, "%3d %s ", done_percentage(e), priority);
+      sprintf(buffer, "%3d %s ", done_percentage(e), priority);
 
       int64_t val = e->size_bytes();
 
       if (val < (int64_t(1000) << 20))
-        m_canvas->print(8, pos, "%5.1f M", (double)val / (int64_t(1) << 20));
+        sprintf(buffer + 8, "%5.1f M", (double)val / (int64_t(1) << 20));
       else if (val < (int64_t(1000) << 30))
-        m_canvas->print(8, pos, "%5.1f G", (double)val / (int64_t(1) << 30));
+        sprintf(buffer + 8, "%5.1f G", (double)val / (int64_t(1) << 30));
       else
-        m_canvas->print(8, pos, "%5.1f T", (double)val / (int64_t(1) << 40));
+        sprintf(buffer + 8, "%5.1f T", (double)val / (int64_t(1) << 40));
 
-      m_canvas->print(16 + itr.depth(), pos, "| %s",
-                      itr.depth() < (*itr)->path()->size() ? (*itr)->path()->at(itr.depth()).c_str() : "UNKNOWN");
+      std::fill_n(buffer + 15, 64, ' ');
+
+      int first = 16 + std::min<unsigned int>(itr.depth(), 8);
+      int last = std::max<unsigned int>(m_canvas->width() + 1, 16 + 12);
+
+      snprintf(buffer + first, last - first, "| %s",
+               itr.depth() < (*itr)->path()->size() ? (*itr)->path()->at(itr.depth()).c_str() : "UNKNOWN");
 
-//       m_canvas->print(104, pos, "%i - %i %c%c %u %u",
-//                       e->range().first,
-//                       e->range().first != e->range().second ? (e->range().second - 1) : e->range().second,
-//                       e->is_created() ? 'E' : 'M',
-//                       e->is_correct_size() ? 'C' : 'W',
-//                       e->match_depth_prev(),
-//                       e->match_depth_next());
+      m_canvas->print_attributes(0, pos, buffer, buffer + std::strlen(buffer), &attributes);
 
     } else {
       m_canvas->print(0, pos, "BORK BORK");
     }
 
     if (itr == m_element->selected())
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/display/window_tracker_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/display/window_tracker_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/display/window_tracker_list.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/display/window_tracker_list.cc	2008-03-06 18:26:26.000000000 +0800
@@ -57,25 +57,25 @@
 void
 WindowTrackerList::redraw() {
   // TODO: Make this depend on tracker signal.
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(10)).round_seconds());
   m_canvas->erase();
 
-  int pos = 0;
+  unsigned int pos = 0;
   torrent::TrackerList* tl = m_download->tracker_list();
 
   m_canvas->print(2, pos, "Trackers: [Key: %08x]", tl->key());
   ++pos;
 
   if (tl->size() == 0 || *m_focus >= tl->size())
     return;
 
   typedef std::pair<unsigned int, unsigned int> Range;
 
-  unsigned int group = 0;
-  Range range = rak::advance_bidirectional<unsigned int>(0, *m_focus, tl->size(), (m_canvas->height() + 1) / 2);
+  Range range = rak::advance_bidirectional<unsigned int>(0, *m_focus, tl->size(), (m_canvas->height() - 1) / 2);
+  unsigned int group = tl->at(range.first)->group();
 
   while (range.first != range.second) {
     torrent::Tracker* tracker = tl->at(range.first);
 
 //     m_canvas->print(0, pos, "[%c] [S/L %5i/%5i] %s",
 //                     tracker->is_enabled() ? (tracker->is_open() ? '*' : ' ') : '-',
@@ -85,19 +85,20 @@
     if (tracker->group() == group)
       m_canvas->print(0, pos, "%2i:", group++);
 
     m_canvas->print(4, pos++, "%s",
                     tracker->url().c_str());
 
-    m_canvas->print(4, pos++, "Id: %s Focus: %s Enabled: %s Open: %s S/L: %u/%u",
-                    rak::copy_escape_html(tracker->tracker_id()).c_str(),
-                    range.first == tl->focus_index() ? "yes" : " no",
-                    tracker->is_usable() ? "yes" : tracker->is_enabled() ? "off" : " no",
-                    tracker->is_busy() ? "yes" : " no",
-                    tracker->scrape_complete(),
-                    tracker->scrape_incomplete());
+    if (pos < m_canvas->height())
+      m_canvas->print(4, pos++, "Id: %s Focus: %s Enabled: %s Open: %s S/L: %u/%u",
+                      rak::copy_escape_html(tracker->tracker_id()).c_str(),
+                      range.first == tl->focus_index() ? "yes" : " no",
+                      tracker->is_usable() ? "yes" : tracker->is_enabled() ? "off" : " no",
+                      tracker->is_busy() ? "yes" : " no",
+                      tracker->scrape_complete(),
+                      tracker->scrape_incomplete());
 
 //     m_canvas->print(4, pos++, "Id: %s Focus: %s Enabled: %s Open: %s Timer: %u/%u",
 //                     rak::copy_escape_html(tracker->tracker_id()).c_str(),
 //                     range.first == tl->focus() ? "yes" : " no",
 //                     tracker->is_enabled() ? "yes" : " no",
 //                     tracker->is_open() ? "yes" : " no",
@@ -107,10 +108,15 @@
     if (range.first == *m_focus) {
       m_canvas->set_attr(0, pos - 2, m_canvas->width(), is_focused() ? A_REVERSE : A_BOLD, COLOR_PAIR(0));
       m_canvas->set_attr(0, pos - 1, m_canvas->width(), is_focused() ? A_REVERSE : A_BOLD, COLOR_PAIR(0));
     }
 
     range.first++;
+
+    // If we're at the end of the range, check if we can
+    // show one more line for the following tracker.
+    if (range.first == range.second && pos < m_canvas->height() && range.first < tl->size())
+      range.second++;
   }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/main.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/main.cc	2008-04-11 23:48:46.000000000 +0800
@@ -177,56 +177,55 @@
 
        // Currently not doing any sorting on main.
        "view_add = main\n"
        "view_add = default\n"
 
        "view_add = name\n"
-       "view_sort_new = name,name\n"
-       "view_sort_current = name,name\n"
+       "view_sort_new     = name,less=d.get_name=\n"
+       "view_sort_current = name,less=d.get_name=\n"
+
+       "view_add = active\n"
+       "view_filter = active,false=\n"
 
        "view_add = started\n"
-       "view_filter = started,started\n"
-       "view_filter_on = started,start,stop\n"
-       "view_sort_new = started,name\n"
-       "view_sort_current = started,name\n"
+       "view_filter = started,false=\n"
+       "view.event_added = started,scheduler.simple.added=\n"
+       "view.event_removed = started,scheduler.simple.removed=\n"
 
        "view_add = stopped\n"
-       "view_filter = stopped,stopped\n"
-       "view_filter_on = stopped,start,stop\n"
-       "view_sort_new = stopped,name\n"
-       "view_sort_current = stopped,name\n"
+       "view_filter = stopped,false=\n"
 
        "view_add = complete\n"
-       "view_filter = complete,complete\n"
+       "view_filter = complete,d.get_complete=\n"
        "view_filter_on = complete,hash_done,finished\n"
-       "view_sort_new = complete,state_changed\n"
-       "view_sort_current = complete,state_changed_reverse\n"
+       "view_sort_new     = complete,less=d.get_state_changed=\n"
+       "view_sort_current = complete,less=d.get_state_changed=\n"
 
        "view_add = incomplete\n"
-       "view_filter = incomplete,incomplete\n"
+       "view_filter = incomplete,not=$d.get_complete=\n"
        "view_filter_on = incomplete,hash_done,finished\n"
-       "view_sort_new = incomplete,state_changed\n"
-       "view_sort_current = incomplete,state_changed_reverse\n"
+       "view_sort_new     = incomplete,less=d.get_state_changed=\n"
+       "view_sort_current = incomplete,less=d.get_state_changed=\n"
 
        // The hashing view does not include stopped torrents.
        "view_add = hashing\n"
-       "view_filter = hashing,hashing\n"
+       "view_filter = hashing,d.get_hashing=\n"
        "view_filter_on = hashing,hash_queued,hash_removed,hash_done\n"
-       "view_sort_new = hashing,state_changed\n"
-       "view_sort_current = hashing,state_changed\n"
+//        "view_sort_new     = hashing,less=d.get_state_changed=\n"
+//        "view_sort_current = hashing,less=d.get_state_changed=\n"
 
        "view_add = seeding\n"
-       "view_filter = seeding,started,complete\n"
+       "view_filter = seeding,\"and=d.get_state=,d.get_complete=\"\n"
        "view_filter_on = seeding,start,stop\n"
-       "view_sort_new = seeding,state_changed\n"
-       "view_sort_current = seeding,state_changed_reverse\n"
+       "view_sort_new     = seeding,less=d.get_state_changed=\n"
+       "view_sort_current = seeding,less=d.get_state_changed=\n"
 
        // Changing these will bork the (non-existant) scheduler.
        "view_add = scheduler\n"
-       "view_sort_new = scheduler,state_changed\n" // add started?
-       "view_sort_current = scheduler,state_changed\n"
+//        "view_sort_new     = scheduler,less=d.get_state_changed=\n"
+//        "view_sort_current = scheduler,less=d.get_state_changed=\n"
 
        //    "schedule = scheduler,10,10,download_scheduler=\n"
 
        "schedule = view_main,10,10,\"view_sort=main,20\"\n"
        "schedule = view_name,10,10,\"view_sort=name,20\"\n"
        //     "schedule = view_started,10,10,view_sort=started,5\n"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/Makefile.am	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/Makefile.am	2008-04-02 21:54:35.000000000 +0800
@@ -23,12 +23,13 @@
 	command_helpers.cc \
 	command_helpers.h \
 	command_local.cc \
 	command_network.cc \
 	command_peer.cc \
 	command_tracker.cc \
+	command_scheduler.cc \
 	command_ui.cc \
 	control.cc \
 	control.h \
 	globals.cc \
 	globals.h \
 	main.cc \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/Makefile.in	2008-01-29 02:09:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/Makefile.in	2008-04-17 20:41:14.000000000 +0800
@@ -48,15 +48,16 @@
 binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
 PROGRAMS = $(bin_PROGRAMS)
 am_rtorrent_OBJECTS = command_download.$(OBJEXT) \
 	command_events.$(OBJEXT) command_file.$(OBJEXT) \
 	command_helpers.$(OBJEXT) command_local.$(OBJEXT) \
 	command_network.$(OBJEXT) command_peer.$(OBJEXT) \
-	command_tracker.$(OBJEXT) command_ui.$(OBJEXT) \
-	control.$(OBJEXT) globals.$(OBJEXT) main.$(OBJEXT) \
-	option_parser.$(OBJEXT) signal_handler.$(OBJEXT)
+	command_tracker.$(OBJEXT) command_scheduler.$(OBJEXT) \
+	command_ui.$(OBJEXT) control.$(OBJEXT) globals.$(OBJEXT) \
+	main.$(OBJEXT) option_parser.$(OBJEXT) \
+	signal_handler.$(OBJEXT)
 rtorrent_OBJECTS = $(am_rtorrent_OBJECTS)
 rtorrent_DEPENDENCIES = $(top_srcdir)/src/ui/libsub_ui.a \
 	$(top_srcdir)/src/core/libsub_core.a \
 	$(top_srcdir)/src/display/libsub_display.a \
 	$(top_srcdir)/src/input/libsub_input.a \
 	$(top_srcdir)/src/rpc/libsub_rpc.a \
@@ -229,12 +230,13 @@
 	command_helpers.cc \
 	command_helpers.h \
 	command_local.cc \
 	command_network.cc \
 	command_peer.cc \
 	command_tracker.cc \
+	command_scheduler.cc \
 	command_ui.cc \
 	control.cc \
 	control.h \
 	globals.cc \
 	globals.h \
 	main.cc \
@@ -318,12 +320,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_events.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_file.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_helpers.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_local.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_network.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_peer.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_scheduler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_tracker.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_ui.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/control.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/globals.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/option_parser.Po@am__quote@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/command.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/command.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/command.h	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/command.h	2008-03-18 00:49:03.000000000 +0800
@@ -36,31 +36,123 @@
 
 #ifndef RTORRENT_RPC_VARIABLE_H
 #define RTORRENT_RPC_VARIABLE_H
 
 #include <torrent/object.h>
 
+namespace core {
+  class Download;
+}
+
+namespace torrent {
+  class File;
+  class FileListIterator;
+  class Peer;
+  class Tracker;
+}
+
 namespace rpc {
 
+// Since c++0x isn't out yet...
+template <typename T1, typename T2, typename T3>
+struct rt_triple : private std::pair<T1, T2> {
+  typedef std::pair<T1, T2> base_type;
+  typedef T3                third_type;
+
+  using base_type::first;
+  using base_type::second;
+  using base_type::first_type;
+  using base_type::second_type;
+
+  T3 third;
+
+  rt_triple() : base_type(), third() {}
+
+  rt_triple(const T1& a, const T2& b) :
+    base_type(a, b), third() {}
+
+  rt_triple(const T1& a, const T2& b, const T3& c) :
+    base_type(a, b), third(c) {}
+
+  template <typename U1, typename U2>
+  rt_triple(const std::pair<U1, U2>& b) : base_type(b), third() {}
+
+  template <typename U1, typename U2, typename U3>
+  rt_triple(const rt_triple& src) :
+    base_type(src.first, src.second), third(src.third) {}
+};
+
 // Since it gets used so many places we might as well put it in the
 // rpc namespace.
-typedef std::pair<int, void*> target_type;
+//typedef std::pair<int, void*> target_type;
+typedef rt_triple<int, void*, void*> target_type;
 
 class Command {
 public:
   typedef torrent::Object::value_type  value_type;
   typedef torrent::Object::string_type string_type;
   typedef torrent::Object::list_type   list_type;
   typedef torrent::Object::map_type    map_type;
   typedef torrent::Object::key_type    key_type;
 
+  typedef const torrent::Object (*generic_slot)  (Command*, const torrent::Object&);
+  typedef const torrent::Object (*any_slot)      (Command*, target_type, const torrent::Object&);
+  typedef const torrent::Object (*download_slot) (Command*, core::Download*, const torrent::Object&);
+  typedef const torrent::Object (*file_slot)     (Command*, torrent::File*, const torrent::Object&);
+  typedef const torrent::Object (*file_itr_slot) (Command*, torrent::FileListIterator*, const torrent::Object&);
+  typedef const torrent::Object (*peer_slot)     (Command*, torrent::Peer*, const torrent::Object&);
+  typedef const torrent::Object (*tracker_slot)  (Command*, torrent::Tracker*, const torrent::Object&);
+
+  typedef const torrent::Object (*download_pair_slot) (Command*, core::Download*, core::Download*, const torrent::Object&);
+
+  static const int target_generic  = 0;
+  static const int target_any      = 1;
+  static const int target_download = 2;
+  static const int target_peer     = 3;
+  static const int target_tracker  = 4;
+  static const int target_file     = 5;
+  static const int target_file_itr = 6;
+
+  static const int target_download_pair = 7;
+
   Command() {}
   virtual ~Command() {}
 
 protected:
   Command(const Command&);
   void operator = (const Command&);
 };
 
+template <typename T1 = void, typename T2 = void>
+struct target_type_id {
+  // Nothing here, so we cause an error.
+};
+
+template <> struct target_type_id<Command::generic_slot>       { static const int value = Command::target_generic; };
+template <> struct target_type_id<Command::any_slot>           { static const int value = Command::target_any; };
+template <> struct target_type_id<Command::download_slot>      { static const int value = Command::target_download; };
+template <> struct target_type_id<Command::peer_slot>          { static const int value = Command::target_peer; };
+template <> struct target_type_id<Command::tracker_slot>       { static const int value = Command::target_tracker; };
+template <> struct target_type_id<Command::file_slot>          { static const int value = Command::target_file; };
+template <> struct target_type_id<Command::file_itr_slot>      { static const int value = Command::target_file_itr; };
+
+template <> struct target_type_id<Command::download_pair_slot> { static const int value = Command::target_download_pair; };
+
+template <> struct target_type_id<>                            { static const int value = Command::target_generic; };
+template <> struct target_type_id<target_type>                 { static const int value = Command::target_any; };
+template <> struct target_type_id<core::Download*>             { static const int value = Command::target_download; };
+template <> struct target_type_id<torrent::Peer*>              { static const int value = Command::target_peer; };
+template <> struct target_type_id<torrent::Tracker*>           { static const int value = Command::target_tracker; };
+template <> struct target_type_id<torrent::File*>              { static const int value = Command::target_file; };
+template <> struct target_type_id<torrent::FileListIterator*>  { static const int value = Command::target_file_itr; };
+
+template <> struct target_type_id<core::Download*, core::Download*> { static const int value = Command::target_download_pair; };
+
+// Splitting pairs into separate targets.
+inline bool is_target_pair(const target_type& target) { return target.first >= Command::target_download_pair; }
+
+inline target_type get_target_left(const target_type& target)  { return target_type(target.first - 5, target.second); }
+inline target_type get_target_right(const target_type& target) { return target_type(target.first - 5, target.third); }
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/command_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/command_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/command_map.cc	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/command_map.cc	2008-03-17 15:46:47.000000000 +0800
@@ -58,153 +58,92 @@
   if (itr != base_type::end())
     throw torrent::internal_error("CommandMap::insert(...) tried to insert an already existing key.");
 
   return base_type::insert(itr, value_type(key, command_map_data_type(variable, flags, parm, doc)));
 }
 
-// The functions below should be reduced to just one.
-void
-CommandMap::insert_generic(key_type key, Command* variable, generic_slot targetSlot, int flags, const char* parm, const char* doc) {
-  iterator itr = insert(key, variable, flags, parm, doc);
-
-  itr->second.m_target      = target_generic;
-  itr->second.m_genericSlot = targetSlot;
-}
-
-void
-CommandMap::insert_any(key_type key, Command* variable, any_slot targetSlot, int flags, const char* parm, const char* doc) {
-  iterator itr = insert(key, variable, flags, parm, doc);
-
-  itr->second.m_target  = target_any;
-  itr->second.m_anySlot = targetSlot;
-}
-
-void
-CommandMap::insert_download(key_type key, Command* variable, download_slot targetSlot, int flags, const char* parm, const char* doc) {
-  iterator itr = insert(key, variable, flags, parm, doc);
-
-  itr->second.m_target       = target_download;
-  itr->second.m_downloadSlot = targetSlot;
-}
-
-void
-CommandMap::insert_peer(key_type key, Command* variable, peer_slot targetSlot, int flags, const char* parm, const char* doc) {
-  iterator itr = insert(key, variable, flags, parm, doc);
-
-  itr->second.m_target   = target_peer;
-  itr->second.m_peerSlot = targetSlot;
-}
-
-void
-CommandMap::insert_tracker(key_type key, Command* variable, tracker_slot targetSlot, int flags, const char* parm, const char* doc) {
-  iterator itr = insert(key, variable, flags, parm, doc);
-
-  itr->second.m_target      = target_tracker;
-  itr->second.m_trackerSlot = targetSlot;
-}
-
-void
-CommandMap::insert_file(key_type key, Command* variable, file_slot targetSlot, int flags, const char* parm, const char* doc) {
-  iterator itr = insert(key, variable, flags, parm, doc);
-
-  itr->second.m_target   = target_file;
-  itr->second.m_fileSlot = targetSlot;
-}
-
-void
-CommandMap::insert_file_itr(key_type key, Command* variable, file_itr_slot targetSlot, int flags, const char* parm, const char* doc) {
-  iterator itr = insert(key, variable, flags, parm, doc);
-
-  itr->second.m_target      = target_file_itr;
-  itr->second.m_fileItrSlot = targetSlot;
-}
-
 void
 CommandMap::insert(key_type key, const command_map_data_type src) {
   iterator itr = base_type::find(key);
 
   if (itr != base_type::end())
     throw torrent::internal_error("CommandMap::insert(...) tried to insert an already existing key.");
 
   itr = base_type::insert(itr, value_type(key, command_map_data_type(src.m_variable, src.m_flags | flag_dont_delete, src.m_parm, src.m_doc)));
 
-  itr->second.m_target       = src.m_target;
-
-  // This _should_ be optimized int just one assignment.
-  switch (itr->second.m_target) {
-  case target_generic:  itr->second.m_genericSlot  = src.m_genericSlot; break;
-  case target_any:      itr->second.m_anySlot      = src.m_anySlot; break;
-  case target_download: itr->second.m_downloadSlot = src.m_downloadSlot; break;
-  case target_file:     itr->second.m_fileSlot     = src.m_fileSlot; break;
-  case target_file_itr: itr->second.m_fileItrSlot  = src.m_fileItrSlot; break;
-  case target_peer:     itr->second.m_peerSlot     = src.m_peerSlot; break;
-  case target_tracker:  itr->second.m_trackerSlot  = src.m_trackerSlot; break;
-  default: throw torrent::internal_error("CommandMap::insert(...) Invalid target.");
-  }
+  // We can assume all the slots are the same size.
+  itr->second.m_target      = src.m_target;
+  itr->second.m_genericSlot = src.m_genericSlot;
 }
 
 const CommandMap::mapped_type
 CommandMap::call_command(key_type key, const mapped_type& arg, target_type target) {
   const_iterator itr = base_type::find(key);
 
   if (itr == base_type::end())
     throw torrent::input_error("Command \"" + std::string(key) + "\" does not exist.");
 
-  if (target.first != target_generic && target.second == NULL) {
+  if (target.first != Command::target_generic && target.second == NULL) {
     // We received a target that is NULL, so throw an exception unless
     // we can convert it to a void target.
-    if (itr->second.m_target > target_any)
+    if (itr->second.m_target > Command::target_any)
       throw torrent::input_error("Command type mis-match.");
 
-    target.first = target_generic;
+    target.first = Command::target_generic;
   }
 
-  if (itr->second.m_target != target.first && itr->second.m_target > target_any) {
+  if (itr->second.m_target != target.first && itr->second.m_target > Command::target_any) {
     // Mismatch between the target and command type. If it is not
     // possible to convert, then throw an input error.
-    if (target.first == target_file_itr && itr->second.m_target == target_file)
-      target = target_type((int)target_file, static_cast<torrent::FileListIterator*>(target.second)->file());
+    if (target.first == Command::target_file_itr && itr->second.m_target == Command::target_file)
+      target = target_type((int)Command::target_file, static_cast<torrent::FileListIterator*>(target.second)->file());
     else
       throw torrent::input_error("Command type mis-match.");
   }
 
   // This _should_ be optimized int just two calls.
   switch (itr->second.m_target) {
-  case target_generic:  return itr->second.m_genericSlot (itr->second.m_variable, arg);
-  case target_any:      return itr->second.m_anySlot     (itr->second.m_variable, target, arg);
-  case target_download: return itr->second.m_downloadSlot(itr->second.m_variable, (core::Download*)target.second, arg);
-  case target_peer:     return itr->second.m_peerSlot    (itr->second.m_variable, (torrent::Peer*)target.second, arg);
-  case target_tracker:  return itr->second.m_trackerSlot (itr->second.m_variable, (torrent::Tracker*)target.second, arg);
-  case target_file:     return itr->second.m_fileSlot    (itr->second.m_variable, (torrent::File*)target.second, arg);
-  case target_file_itr: return itr->second.m_fileItrSlot (itr->second.m_variable, (torrent::FileListIterator*)target.second, arg);
+  case Command::target_generic:  return itr->second.m_genericSlot (itr->second.m_variable, arg);
+  case Command::target_any:      return itr->second.m_anySlot     (itr->second.m_variable, target, arg);
+  case Command::target_download: return itr->second.m_downloadSlot(itr->second.m_variable, (core::Download*)target.second, arg);
+  case Command::target_peer:     return itr->second.m_peerSlot    (itr->second.m_variable, (torrent::Peer*)target.second, arg);
+  case Command::target_tracker:  return itr->second.m_trackerSlot (itr->second.m_variable, (torrent::Tracker*)target.second, arg);
+  case Command::target_file:     return itr->second.m_fileSlot    (itr->second.m_variable, (torrent::File*)target.second, arg);
+  case Command::target_file_itr: return itr->second.m_fileItrSlot (itr->second.m_variable, (torrent::FileListIterator*)target.second, arg);
+
+  case Command::target_download_pair: return itr->second.m_downloadPairSlot(itr->second.m_variable, (core::Download*)target.second, (core::Download*)target.third, arg);
+
   default: throw torrent::internal_error("CommandMap::call_command(...) Invalid target.");
   }
 }
 
 const CommandMap::mapped_type
 CommandMap::call_command(const_iterator itr, const mapped_type& arg, target_type target) {
-  if (target.first != target_generic && target.second == NULL) {
+  if (target.first != Command::target_generic && target.second == NULL) {
     // We received a target that is NULL, so throw an exception unless
     // we can convert it to a void target.
-    if (itr->second.m_target > target_any)
+    if (itr->second.m_target > Command::target_any)
       throw torrent::input_error("Command type mis-match.");
 
-    target.first = target_generic;
+    target.first = Command::target_generic;
   }
 
-  if (itr->second.m_target != target.first && itr->second.m_target > target_any)
+  if (itr->second.m_target != target.first && itr->second.m_target > Command::target_any)
     throw torrent::input_error("Command type mis-match.");
 
   // This _should_ be optimized int just two calls.
   switch (itr->second.m_target) {
-  case target_generic:  return itr->second.m_genericSlot (itr->second.m_variable, arg);
-  case target_any:      return itr->second.m_anySlot     (itr->second.m_variable, target, arg);
-  case target_download: return itr->second.m_downloadSlot(itr->second.m_variable, (core::Download*)target.second, arg);
-  case target_peer:     return itr->second.m_peerSlot    (itr->second.m_variable, (torrent::Peer*)target.second, arg);
-  case target_tracker:  return itr->second.m_trackerSlot (itr->second.m_variable, (torrent::Tracker*)target.second, arg);
-  case target_file:     return itr->second.m_fileSlot    (itr->second.m_variable, (torrent::File*)target.second, arg);
-  case target_file_itr: return itr->second.m_fileItrSlot (itr->second.m_variable, (torrent::FileListIterator*)target.second, arg);
+  case Command::target_generic:  return itr->second.m_genericSlot (itr->second.m_variable, arg);
+  case Command::target_any:      return itr->second.m_anySlot     (itr->second.m_variable, target, arg);
+  case Command::target_download: return itr->second.m_downloadSlot(itr->second.m_variable, (core::Download*)target.second, arg);
+  case Command::target_peer:     return itr->second.m_peerSlot    (itr->second.m_variable, (torrent::Peer*)target.second, arg);
+  case Command::target_tracker:  return itr->second.m_trackerSlot (itr->second.m_variable, (torrent::Tracker*)target.second, arg);
+  case Command::target_file:     return itr->second.m_fileSlot    (itr->second.m_variable, (torrent::File*)target.second, arg);
+  case Command::target_file_itr: return itr->second.m_fileItrSlot (itr->second.m_variable, (torrent::FileListIterator*)target.second, arg);
+
+  case Command::target_download_pair: return itr->second.m_downloadPairSlot(itr->second.m_variable, (core::Download*)target.second, (core::Download*)target.third, arg);
+
   default: throw torrent::internal_error("CommandMap::call_command(...) Invalid target.");
   }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/command_map.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/command_map.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/command_map.h	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/command_map.h	2008-03-18 00:36:19.000000000 +0800
@@ -41,58 +41,42 @@
 #include <string>
 #include <cstring>
 #include <torrent/object.h>
 
 #include "command.h"
 
-namespace core {
-  class Download;
-}
-
-namespace torrent {
-  class File;
-  class FileListIterator;
-  class Peer;
-  class Tracker;
-}
-
 namespace rpc {
 
 struct command_map_comp : public std::binary_function<const char*, const char*, bool> {
   bool operator () (const char* arg1, const char* arg2) const { return std::strcmp(arg1, arg2) < 0; }
 };
 
 struct command_map_data_type {
   // Some commands will need to share data, like get/set a variable. So
   // instead of using a single virtual member function, each command
   // will register a member function pointer to be used instead.
   //
   // The any_slot should perhaps replace generic_slot?
-  typedef const torrent::Object (*generic_slot)  (Command*, const torrent::Object&);
-  typedef const torrent::Object (*any_slot)      (Command*, target_type, const torrent::Object&);
-  typedef const torrent::Object (*download_slot) (Command*, core::Download*, const torrent::Object&);
-  typedef const torrent::Object (*file_slot)     (Command*, torrent::File*, const torrent::Object&);
-  typedef const torrent::Object (*file_itr_slot) (Command*, torrent::FileListIterator*, const torrent::Object&);
-  typedef const torrent::Object (*peer_slot)     (Command*, torrent::Peer*, const torrent::Object&);
-  typedef const torrent::Object (*tracker_slot)  (Command*, torrent::Tracker*, const torrent::Object&);
 
   command_map_data_type(Command* variable, int flags, const char* parm, const char* doc) :
     m_variable(variable), m_flags(flags), m_parm(parm), m_doc(doc) {}
 
   int                 target() const { return m_target; }
 
   Command*      m_variable;
 
   union {
-    generic_slot  m_genericSlot;
-    any_slot      m_anySlot;
-    download_slot m_downloadSlot;
-    file_slot     m_fileSlot;
-    file_itr_slot m_fileItrSlot;
-    peer_slot     m_peerSlot;
-    tracker_slot  m_trackerSlot;
+    Command::generic_slot  m_genericSlot;
+    Command::any_slot      m_anySlot;
+    Command::download_slot m_downloadSlot;
+    Command::file_slot     m_fileSlot;
+    Command::file_itr_slot m_fileItrSlot;
+    Command::peer_slot     m_peerSlot;
+    Command::tracker_slot  m_trackerSlot;
+
+    Command::download_pair_slot m_downloadPairSlot;
   };
 
   int           m_flags;
   int           m_target;
 
   const char*   m_parm;
@@ -100,79 +84,70 @@
 };
 
 class CommandMap : public std::map<const char*, command_map_data_type, command_map_comp> {
 public:
   typedef std::map<const char*, command_map_data_type, command_map_comp> base_type;
 
-  typedef command_map_data_type::generic_slot  generic_slot;
-  typedef command_map_data_type::any_slot      any_slot;
-  typedef command_map_data_type::download_slot download_slot;
-  typedef command_map_data_type::file_slot     file_slot;
-  typedef command_map_data_type::file_itr_slot file_itr_slot;
-  typedef command_map_data_type::peer_slot     peer_slot;
-  typedef command_map_data_type::tracker_slot  tracker_slot;
-
   typedef torrent::Object         mapped_type;
   typedef mapped_type::value_type mapped_value_type;
 
   using base_type::iterator;
   using base_type::const_iterator;
   using base_type::key_type;
   using base_type::value_type;
 
   using base_type::begin;
   using base_type::end;
   using base_type::find;
 
-  static const int target_generic  = 0;
-  static const int target_any      = 1;
-  static const int target_download = 2;
-  static const int target_peer     = 3;
-  static const int target_tracker  = 4;
-  static const int target_file     = 5;
-  static const int target_file_itr = 6;
-
   static const int flag_dont_delete   = 0x1;
   static const int flag_public_xmlrpc = 0x2;
 
   CommandMap() {}
   ~CommandMap();
 
   bool                has(const char* key) const        { return base_type::find(key) != base_type::end(); }
   bool                has(const std::string& key) const { return has(key.c_str()); }
 
   iterator            insert(key_type key, Command* variable, int flags, const char* parm, const char* doc);
 
-  void                insert_generic (key_type key, Command* variable, generic_slot targetSlot,  int flags, const char* parm, const char* doc);
-  void                insert_any     (key_type key, Command* variable, any_slot     targetSlot,  int flags, const char* parm, const char* doc);
-  void                insert_download(key_type key, Command* variable, download_slot targetSlot, int flags, const char* parm, const char* doc);
-  void                insert_peer    (key_type key, Command* variable, peer_slot targetSlot,     int flags, const char* parm, const char* doc);
-  void                insert_tracker (key_type key, Command* variable, tracker_slot targetSlot,  int flags, const char* parm, const char* doc);
-  void                insert_file    (key_type key, Command* variable, file_slot targetSlot,     int flags, const char* parm, const char* doc);
-  void                insert_file_itr(key_type key, Command* variable, file_itr_slot targetSlot, int flags, const char* parm, const char* doc);
+  // Make this a wrapper call to insert without extra fluff.
+  template <typename T>
+  void                insert_type(key_type key, Command* variable, T targetSlot, int flags, const char* parm, const char* doc) {
+    iterator itr = insert(key, variable, flags, parm, doc);
+
+    itr->second.m_target      = target_type_id<T>::value; 
+    itr->second.m_genericSlot = (Command::generic_slot)targetSlot;
+  }
 
   void                insert(key_type key, const command_map_data_type src);
 
-  const mapped_type   call_command  (key_type key,       const mapped_type& arg, target_type target = target_type((int)target_generic, NULL));
-  const mapped_type   call_command  (const_iterator itr, const mapped_type& arg, target_type target = target_type((int)target_generic, NULL));
+  const mapped_type   call_command  (key_type key,       const mapped_type& arg, target_type target = target_type((int)Command::target_generic, NULL));
+  const mapped_type   call_command  (const_iterator itr, const mapped_type& arg, target_type target = target_type((int)Command::target_generic, NULL));
 
-  const mapped_type   call_command_d(key_type key, core::Download* download, const mapped_type& arg)  { return call_command(key, arg, target_type((int)target_download, download)); }
-  const mapped_type   call_command_p(key_type key, torrent::Peer* peer, const mapped_type& arg)       { return call_command(key, arg, target_type((int)target_peer, peer)); }
-  const mapped_type   call_command_t(key_type key, torrent::Tracker* tracker, const mapped_type& arg) { return call_command(key, arg, target_type((int)target_tracker, tracker)); }
-  const mapped_type   call_command_f(key_type key, torrent::File* file, const mapped_type& arg)       { return call_command(key, arg, target_type((int)target_file, file)); }
+  const mapped_type   call_command_d(key_type key, core::Download* download, const mapped_type& arg)  { return call_command(key, arg, target_type((int)Command::target_download, download)); }
+  const mapped_type   call_command_p(key_type key, torrent::Peer* peer, const mapped_type& arg)       { return call_command(key, arg, target_type((int)Command::target_peer, peer)); }
+  const mapped_type   call_command_t(key_type key, torrent::Tracker* tracker, const mapped_type& arg) { return call_command(key, arg, target_type((int)Command::target_tracker, tracker)); }
+  const mapped_type   call_command_f(key_type key, torrent::File* file, const mapped_type& arg)       { return call_command(key, arg, target_type((int)Command::target_file, file)); }
 
 private:
   CommandMap(const CommandMap&);
   void operator = (const CommandMap&);
 };
 
-inline target_type make_target()                                  { return target_type((int)CommandMap::target_generic, NULL); }
-inline target_type make_target(core::Download* target)            { return target_type((int)CommandMap::target_download, target); }
-inline target_type make_target(torrent::Peer* target)             { return target_type((int)CommandMap::target_peer, target); }
-inline target_type make_target(torrent::Tracker* target)          { return target_type((int)CommandMap::target_tracker, target); }
-inline target_type make_target(torrent::File* target)             { return target_type((int)CommandMap::target_file, target); }
-inline target_type make_target(torrent::FileListIterator* target) { return target_type((int)CommandMap::target_file_itr, target); }
+inline target_type make_target()                                  { return target_type((int)Command::target_generic, NULL); }
 inline target_type make_target(int type, void* target)            { return target_type(type, target); }
+inline target_type make_target(int type, void* target1, void* target2) { return target_type(type, target1, target2); }
+
+template <typename T>
+inline target_type make_target(T target) {
+  return target_type((int)target_type_id<T>::value, target);
+}
+
+template <typename T>
+inline target_type make_target_pair(T target1, T target2) {
+  return target_type((int)target_type_id<T, T>::value, target1, target2);
+}
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/command_slot.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/command_slot.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/command_slot.h	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/command_slot.h	2008-03-13 21:54:47.000000000 +0800
@@ -77,13 +77,13 @@
 
   static const torrent::Object call_value(Command* rawCommand, Target target, const torrent::Object& args)     { return call_value_base(rawCommand, target, args, 0, 1); }
   static const torrent::Object call_value_kb(Command* rawCommand, Target target, const torrent::Object& args)  { return call_value_base(rawCommand, target, args, 0, 1 << 10); }
   static const torrent::Object call_value_oct(Command* rawCommand, Target target, const torrent::Object& args) { return call_value_base(rawCommand, target, args, 8, 1); }
 
   template <int base, int unit>
-  static const torrent::Object call_value(Command* rawCommand, Target target, const torrent::Object& args)     { return call_value_base(rawCommand, target, args, base, unit); }
+  static const torrent::Object call_value_tmpl(Command* rawCommand, Target target, const torrent::Object& args)     { return call_value_base(rawCommand, target, args, base, unit); }
 
 //   static const torrent::Object& get_list(Command* rawCommand, const torrent::Object& args);
 
 private:
   slot_type           m_slot;
 };
@@ -107,13 +107,13 @@
 
   static const torrent::Object call_value(Command* rawCommand, const torrent::Object& args)     { return call_value_base(rawCommand, args, 0, 1); }
   static const torrent::Object call_value_kb(Command* rawCommand, const torrent::Object& args)  { return call_value_base(rawCommand, args, 0, 1 << 10); }
   static const torrent::Object call_value_oct(Command* rawCommand, const torrent::Object& args) { return call_value_base(rawCommand, args, 8, 1); }
 
   template <int base, int unit>
-  static const torrent::Object call_value(Command* rawCommand, const torrent::Object& args)     { return call_value_base(rawCommand, args, base, unit); }
+  static const torrent::Object call_value_tmpl(Command* rawCommand, const torrent::Object& args)     { return call_value_base(rawCommand, args, base, unit); }
 
 //   static const torrent::Object& get_list(Command* rawCommand, const torrent::Object& args);
 
 private:
   slot_type           m_slot;
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/parse.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/parse.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/parse.cc	2008-01-22 23:38:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/parse.cc	2008-02-29 03:44:03.000000000 +0800
@@ -168,13 +168,13 @@
 
 // Somewhat ugly...
 const char*
 parse_object(const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char)) {
   if (*first == '{') {
     *dest = torrent::Object::create_list();
-    first = parse_list(first + 1, last, dest, &parse_is_delim_list);
+    first = parse_list(first + 1, last, dest, &parse_is_delim_block);
     first = parse_skip_wspace(first, last);
     
     if (first == last || *first != '}')
       throw torrent::input_error("Could not find closing '}'.");
 
     return ++first;
@@ -207,23 +207,23 @@
   }
 
   return first;
 }
 
 const char*
-parse_whole_list(const char* first, const char* last, torrent::Object* dest) {
+parse_whole_list(const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char)) {
   first = parse_skip_wspace(first, last);
-  first = parse_object(first, last, dest);
+  first = parse_object(first, last, dest, delim);
   first = parse_skip_wspace(first, last);
 
   if (first != last && parse_is_seperator(*first)) {
     torrent::Object tmp = torrent::Object::create_list();
     tmp.swap(*dest);
 
     dest->as_list().push_back(tmp);
-    first = parse_list(++first, last, dest);
+    first = parse_list(++first, last, dest, delim);
   }
 
   return first;
 }
 
 std::string
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/parse_commands.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/parse_commands.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/parse_commands.cc	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/parse_commands.cc	2008-02-03 20:29:08.000000000 +0800
@@ -114,13 +114,13 @@
   first = std::find_if(first, last, std::not1(command_map_is_space()));
   
   if (first == last || *first != '=')
     throw torrent::input_error("Could not find '='.");
 
   torrent::Object args;
-  first = parse_whole_list(first + 1, last, &args);
+  first = parse_whole_list(first + 1, last, &args, &parse_is_delim_command);
 
   // Find the last character that is part of this command, skipping
   // the whitespace at the end. This ensures us that the caller
   // doesn't need to do this nor check for junk at the end.
   first = std::find_if(first, last, std::not1(command_map_is_space()));
   
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/parse_commands.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/parse_commands.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/parse_commands.h	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/parse_commands.h	2008-03-20 17:38:11.000000000 +0800
@@ -62,24 +62,38 @@
 parse_command_type     parse_command(target_type target, const char* first, const char* last);
 void                   parse_command_multiple(target_type target, const char* first, const char* last);
 
 // Make this take care of lists too.
 parse_command_type     parse_command_object(target_type target, const torrent::Object& object);
 
-inline void            parse_command_single(target_type target, const char* first)   { parse_command(target, first, first + std::strlen(first)); }
+inline torrent::Object parse_command_single(target_type target, const char* first)   { return parse_command(target, first, first + std::strlen(first)).first; }
 inline void            parse_command_multiple(target_type target, const char* first) { parse_command_multiple(target, first, first + std::strlen(first)); }
 
 bool                   parse_command_file(const std::string& path);
 const char*            parse_command_name(const char* first, const char* last, std::string* dest);
 
+inline torrent::Object
+parse_command_single(target_type target, const std::string& cmd) {
+  return parse_command(target, cmd.c_str(), cmd.c_str() + cmd.size()).first;
+}
+
 inline void
 parse_command_single_std(const std::string& cmd) {
   parse_command(make_target(), cmd.c_str(), cmd.c_str() + cmd.size());
 }
 
 inline void
+parse_command_multiple_d_nothrow(core::Download* download, const std::string& cmd) {
+  try {
+    parse_command_multiple(make_target(download), cmd.c_str(), cmd.c_str() + cmd.size());
+  } catch (torrent::input_error& e) {
+    // Log?
+  }
+}
+
+inline void
 parse_command_d_single_std(core::Download* download, const std::string& cmd) {
   parse_command(make_target(download), cmd.c_str(), cmd.c_str() + cmd.size());
 }
 
 inline void
 parse_command_multiple_std(const std::string& cmd) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/parse.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/parse.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/parse.h	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/parse.h	2008-02-03 20:46:43.000000000 +0800
@@ -35,12 +35,13 @@
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_RPC_PARSE_H
 #define RTORRENT_RPC_PARSE_H
 
 #include <string>
+#include <cctype>
 #include <torrent/object.h>
 
 namespace rpc {
 
 // parse_* functions do the bare minimum necessary to parse what was
 // asked for. If a whitespace is found, it will be treated as empty
@@ -51,14 +52,21 @@
 
 inline bool parse_is_quote(const char c)     { return c == '"'; }
 inline bool parse_is_escape(const char c)    { return c == '\\'; }
 inline bool parse_is_seperator(const char c) { return c == ','; }
 inline bool parse_is_space(const char c)     { return c == ' ' || c == '\t'; }
 
+// The block delim is used in {} blocks to contain code. Since it
+// doesn't check for isspace, it will include useless characters but
+// that is the price for sane syntax.
+
 inline bool parse_is_delim_default(const char c) { return parse_is_seperator(c) || std::isspace(c); }
 inline bool parse_is_delim_list(const char c)    { return parse_is_seperator(c) || c == '}' || std::isspace(c); }
+inline bool parse_is_delim_command(const char c) { return parse_is_seperator(c) || c == ';' || std::isspace(c); }
+// inline bool parse_is_delim_block(const char c)   { return c == ';' || c == '}'; }
+inline bool parse_is_delim_block(const char c)   { return parse_is_seperator(c) || c == '}'; }
 
 const char* parse_skip_wspace(const char* first);
 const char* parse_skip_wspace(const char* first, const char* last);
 
 const char* parse_string(const char* first, const char* last, std::string* dest, bool (*delim)(const char) = &parse_is_delim_default);
 void        parse_whole_string(const char* first, const char* last, std::string* dest);
@@ -66,15 +74,15 @@
 const char* parse_value(const char* src, int64_t* value, int base = 0, int unit = 1);
 const char* parse_value_nothrow(const char* src, int64_t* value, int base = 0, int unit = 1);
 
 void        parse_whole_value(const char* src, int64_t* value, int base = 0, int unit = 1);
 bool        parse_whole_value_nothrow(const char* src, int64_t* value, int base = 0, int unit = 1);
 
-const char* parse_object(const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char) = &parse_is_delim_default);
-const char* parse_list(const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char) = &parse_is_delim_default);
-const char* parse_whole_list(const char* first, const char* last, torrent::Object* dest);
+const char* parse_object    (const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char) = &parse_is_delim_default);
+const char* parse_list      (const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char) = &parse_is_delim_default);
+const char* parse_whole_list(const char* first, const char* last, torrent::Object* dest, bool (*delim)(const char) = &parse_is_delim_default);
 
 std::string convert_list_to_string(const torrent::Object& src);
 std::string convert_list_to_string(torrent::Object::list_const_iterator first, torrent::Object::list_const_iterator last);
 std::string convert_list_to_command(torrent::Object::list_const_iterator first, torrent::Object::list_const_iterator last);
 
 int64_t     convert_to_value(const torrent::Object& src, int base = 0, int unit = 1);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/scgi_task.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/scgi_task.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/scgi_task.cc	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/scgi_task.cc	2008-04-16 18:54:37.000000000 +0800
@@ -53,12 +53,22 @@
 // #include <rak/timer.h>
 
 // static rak::timer scgiTimer;
 
 namespace rpc {
 
+// If bufferSize is zero then memcpy won't do anything.
+inline void
+SCgiTask::realloc_buffer(uint32_t size, const char* buffer, uint32_t bufferSize) {
+  char* tmp = new char[size];
+
+  std::memcpy(tmp, buffer, bufferSize);
+  delete [] m_buffer;
+  m_buffer = tmp;
+}
+
 void
 SCgiTask::open(SCgi* parent, int fd) {
   m_parent   = parent;
   m_fileDesc = fd;
   m_buffer   = new char[(m_bufferSize = default_buffer_size) + 1];
   m_position = m_buffer;
@@ -139,27 +149,24 @@
     m_body = current + headerSize + 1;
     headerSize = std::distance(m_buffer, m_body);
 
     if ((unsigned int)(contentSize + headerSize) < m_bufferSize) {
       m_bufferSize = contentSize + headerSize;
 
-    } else if ((unsigned int)(contentSize + headerSize) <= default_buffer_size) {
+    } else if ((unsigned int)contentSize <= default_buffer_size) {
       m_bufferSize = contentSize;
 
       std::memmove(m_buffer, m_body, std::distance(m_body, m_position));
       m_position = m_buffer + std::distance(m_body, m_position);
       m_body = m_buffer;
 
     } else {
-      char* tmp = new char[(m_bufferSize = contentSize)];
-      std::memcpy(tmp, m_body, std::distance(m_body, m_position));
-      delete [] m_buffer;
-
-      m_position = tmp + std::distance(m_body, m_position);
-      m_buffer = tmp;
-      m_body = tmp;
+      realloc_buffer((m_bufferSize = contentSize) + 1, m_body, std::distance(m_body, m_position));
+
+      m_position = m_buffer + std::distance(m_body, m_position);
+      m_body = m_buffer;
     }
   }
 
   if ((unsigned int)std::distance(m_buffer, m_position) != m_bufferSize)
     return;
 
@@ -200,16 +207,14 @@
   close();
 }
 
 bool
 SCgiTask::receive_write(const char* buffer, uint32_t length) {
   // Need to cast due to a bug in MacOSX gcc-4.0.1.
-  if (length + 256 > std::max(m_bufferSize, (unsigned int)default_buffer_size)) {
-    delete [] m_buffer;
-    m_buffer = new char[length + 256];
-  }
+  if (length + 256 > std::max(m_bufferSize, (unsigned int)default_buffer_size))
+    realloc_buffer(length + 256, NULL, 0);
 
   // Who ever bothers to check the return value?
   int headerSize = sprintf(m_buffer, "Status: 200 OK\r\nContent-Type: text/xml\r\nContent-Length: %i\r\n\r\n", length);
 
   m_position = m_buffer;
   m_bufferSize = length + headerSize;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/scgi_task.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/scgi_task.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/scgi_task.h	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/scgi_task.h	2008-04-15 19:40:02.000000000 +0800
@@ -67,12 +67,14 @@
 
   bool                receive_write(const char* buffer, uint32_t length);
 
   utils::SocketFd&    get_fd()            { return *reinterpret_cast<utils::SocketFd*>(&m_fileDesc); }
 
 private:
+  inline void         realloc_buffer(uint32_t size, const char* buffer, uint32_t bufferSize);
+
   SCgi*               m_parent;
 
   char*               m_buffer;
   char*               m_position;
   char*               m_body;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/xmlrpc.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/xmlrpc.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/xmlrpc.cc	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/xmlrpc.cc	2008-03-29 19:03:13.000000000 +0800
@@ -48,290 +48,317 @@
 #include "parse_commands.h"
 
 namespace rpc {
 
 #ifdef HAVE_XMLRPC_C
 
-torrent::Object
-xmlrpc_to_object(xmlrpc_env* env, xmlrpc_value* value) {
-  switch (xmlrpc_value_type(value)) {
+class xmlrpc_error : public torrent::base_error {
+public:
+  xmlrpc_error(xmlrpc_env* env) : m_type(env->fault_code), m_msg(env->fault_string) {}
+  xmlrpc_error(int type, char* msg) : m_type(type), m_msg(msg) {}
+  virtual ~xmlrpc_error() throw() {}
+
+  virtual int         type() const throw() { return m_type; }
+  virtual const char* what() const throw() { return m_msg; }
+
+private:
+  int                 m_type;
+  char*               m_msg;
+};
+
+torrent::Object xmlrpc_to_object(xmlrpc_env* env, xmlrpc_value* value, int callType = 0, rpc::target_type* target = NULL);
+
+inline torrent::Object
+xmlrpc_list_entry_to_object(xmlrpc_env* env, xmlrpc_value* src, int index) {
+  xmlrpc_value* tmp;
+  xmlrpc_array_read_item(env, src, index, &tmp);
+
+  if (env->fault_occurred)
+    throw xmlrpc_error(env);
+
+  torrent::Object obj = xmlrpc_to_object(env, tmp);
+  xmlrpc_DECREF(tmp);
+
+  return obj;
+}
+
+int64_t
+xmlrpc_list_entry_to_value(xmlrpc_env* env, xmlrpc_value* src, int index) {
+  xmlrpc_value* tmp;
+  xmlrpc_array_read_item(env, src, index, &tmp);
+
+  if (env->fault_occurred)
+    throw xmlrpc_error(env);
+
+  switch (xmlrpc_value_type(tmp)) {
   case XMLRPC_TYPE_INT:
     int v;
-    xmlrpc_read_int(env, value, &v);
-      
-    return torrent::Object((int64_t)v);
+    xmlrpc_read_int(env, tmp, &v);
+    xmlrpc_DECREF(tmp);
+    return v;
 
 #ifdef XMLRPC_HAVE_I8
   case XMLRPC_TYPE_I8:
     long long v2;
-    xmlrpc_read_i8(env, value, &v2);
-      
-    return torrent::Object((int64_t)v2);
+    xmlrpc_read_i8(env, tmp, &v2);
+    xmlrpc_DECREF(tmp);
+    return v2;
 #endif
 
-    //     case XMLRPC_TYPE_BOOL:
-    //     case XMLRPC_TYPE_DOUBLE:
-    //     case XMLRPC_TYPE_DATETIME:
-
   case XMLRPC_TYPE_STRING:
   {
-    const char* valueString;
-    xmlrpc_read_string(env, value, &valueString);
-
-    if (env->fault_occurred)
-      return torrent::Object();
-
-    torrent::Object result = torrent::Object(std::string(valueString));
-
-    // Urgh, seriously?
-    ::free((void*)valueString);
-    return result;
-  }
-
-  case XMLRPC_TYPE_BASE64:
-  {
-    size_t      valueSize;
-    const char* valueString;
-
-    xmlrpc_read_base64(env, value, &valueSize, (const unsigned char**)&valueString);
-
-    if (env->fault_occurred)
-      return torrent::Object();
-
-    torrent::Object result = torrent::Object(std::string(valueString, valueSize));
-
-    // Urgh, seriously?
-    ::free((void*)valueString);
-    return result;
-  }
-
-  case XMLRPC_TYPE_ARRAY:
-  {
-    torrent::Object result = torrent::Object::create_list();
-    torrent::Object::list_type& listRef = result.as_list();
-
-    unsigned int last = xmlrpc_array_size(env, value);
+    const char* str;
+    xmlrpc_read_string(env, tmp, &str);
 
     if (env->fault_occurred)
-      return torrent::Object();
+      throw xmlrpc_error(env);
 
-    // Move this into a helper function.
-    for (unsigned int i = 0; i != last; i++) {
-      // Need to decref.
-      xmlrpc_value* tmp;
-      xmlrpc_array_read_item(env, value, i, &tmp);
+    const char* end = str;
+    int64_t v3 = ::strtoll(str, (char**)&end, 0);
 
-      if (env->fault_occurred)
-        return torrent::Object();
+    ::free((void*)str);
 
-      listRef.push_back(xmlrpc_to_object(env, tmp));
-      xmlrpc_DECREF(tmp);
-    }
+    if (*str == '\0' || *end != '\0')
+      throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Invalid index.");
 
-    return result;
+    return v3;
   }
 
-  //     case XMLRPC_TYPE_STRUCT:
-    //     case XMLRPC_TYPE_C_PTR:
-    //     case XMLRPC_TYPE_NIL:
-    //     case XMLRPC_TYPE_DEAD:
   default:
-    xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Unsupported type found.");
-    return torrent::Object();
+    xmlrpc_DECREF(tmp);
+    throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Invalid type found.");
   }
 }
 
-core::Download*
-xmlrpc_to_download(xmlrpc_env* env, xmlrpc_value* value) {
-  core::Download* download = NULL;
+// Consider making a helper function that creates a target_type from a
+// torrent::Object, then we can just use xmlrpc_to_object.
+rpc::target_type
+xmlrpc_to_target(xmlrpc_env* env, xmlrpc_value* value) {
+  rpc::target_type target;
 
   switch (xmlrpc_value_type(value)) {
   case XMLRPC_TYPE_STRING:
   {
     const char* str;
     xmlrpc_read_string(env, value, &str);
 
     if (env->fault_occurred)
-      return NULL;
+      throw xmlrpc_error(env);
 
-    if (std::strlen(str) != 40 ||
-        (download = xmlrpc.get_slot_find_download()(str)) == NULL)
-      xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Could not find info-hash.");
+    if (std::strlen(str) == 0) {
+      // When specifying void, we require a zero-length string.
+      ::free((void*)str);
+      return rpc::make_target();
+
+    } else if (std::strlen(str) < 40) {
+      ::free((void*)str);
+      throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Unsupported target type found.");
+    }
 
-    // Urgh, seriously?
-    ::free((void*)str);
-    return download;
-  }
+    core::Download* download = xmlrpc.get_slot_find_download()(str);
 
-  default:
-    xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Unsupported type found.");
-    return NULL;
-  }
-}
+    if (download == NULL) {
+      ::free((void*)str);
+      throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Could not find info-hash.");
+    }
 
-void*
-xmlrpc_to_index_type(xmlrpc_env* env, xmlrpc_value* value, int callType, core::Download* download) {
-  int index;
+    if (std::strlen(str) == 40) {
+      ::free((void*)str);
+      return rpc::make_target(download);
+    }
 
-  switch (xmlrpc_value_type(value)) {
-  case XMLRPC_TYPE_INT:
-    xmlrpc_read_int(env, value, &index);
-    break;
+    if (std::strlen(str) < 42 || str[40] != ':') {
+      ::free((void*)str);
+      throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Unsupported target type found.");
+    }
 
-#ifdef XMLRPC_HAVE_I8
-  case XMLRPC_TYPE_I8:
-    long long v2;
-    xmlrpc_read_i8(env, value, &v2);
-      
-    index = v2;
-    break;
-#endif
+    // Files:    "<hash>:f<index>"
+    // Trackers: "<hash>:t<index>"
 
-  case XMLRPC_TYPE_STRING:
-  {
-    const char* str;
-    xmlrpc_read_string(env, value, &str);
+    int index;
+    const char* end;
 
-    if (env->fault_occurred)
-      return NULL;
+    switch (str[41]) {
+    case 'f':
+      end = str + 42;
+      index = ::strtol(str + 42, (char**)&end, 0);
 
-    const char* end = str;
-    index = ::strtol(str, (char**)&end, 0);
+      if (*str == '\0' || *end != '\0')
+        throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Invalid index.");
 
-    ::free((void*)str);
+      target = rpc::make_target(XmlRpc::call_file, xmlrpc.get_slot_find_file()(download, index));
+      break;
 
-    if (*str == '\0' || *end != '\0') {
-      xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Invalid index.");
-      return NULL;
+    case 't':
+      end = str + 42;
+      index = ::strtol(str + 42, (char**)&end, 0);
+
+      if (*str == '\0' || *end != '\0')
+        throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Invalid index.");
+
+      target = rpc::make_target(XmlRpc::call_tracker, xmlrpc.get_slot_find_tracker()(download, index));
+      break;
+
+    default:
+      ::free((void*)str);
+      throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Unsupported target type found.");
     }
 
-    break;
+    ::free((void*)str);
+
+    // Check if the target pointer is NULL.
+    if (target.second == NULL)
+      throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Invalid index.");
+
+    return target;
   }
 
   default:
-    xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Unsupported type found.");
-    return NULL;
+    return rpc::make_target();
   }
+}
 
-  if (env->fault_occurred)
-    return NULL;
-    
+rpc::target_type
+xmlrpc_to_index_type(int index, int callType, core::Download* download) {
   void* result;
 
   switch (callType) {
   case XmlRpc::call_file:    result = xmlrpc.get_slot_find_file()(download, index); break;
   case XmlRpc::call_tracker: result = xmlrpc.get_slot_find_tracker()(download, index); break;
   default: result = NULL; break;
   }
 
   if (result == NULL)
-    xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Invalid index.");
+    throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Invalid index.");
       
-  return result;
+  return rpc::make_target(callType, result);
 }
 
-// This should really be cleaned up and support for an array of
-// downloads should be added.
 torrent::Object
-xmlrpc_to_object_target(xmlrpc_env* env, xmlrpc_value* value, int callType, void** target) {
+xmlrpc_to_object(xmlrpc_env* env, xmlrpc_value* value, int callType, rpc::target_type* target) {
   switch (xmlrpc_value_type(value)) {
+  case XMLRPC_TYPE_INT:
+    int v;
+    xmlrpc_read_int(env, value, &v);
+      
+    return torrent::Object((int64_t)v);
+
+#ifdef XMLRPC_HAVE_I8
+  case XMLRPC_TYPE_I8:
+    long long v2;
+    xmlrpc_read_i8(env, value, &v2);
+      
+    return torrent::Object((int64_t)v2);
+#endif
+
+    //     case XMLRPC_TYPE_BOOL:
+    //     case XMLRPC_TYPE_DOUBLE:
+    //     case XMLRPC_TYPE_DATETIME:
+
   case XMLRPC_TYPE_STRING:
-    if (callType != XmlRpc::call_download) {
-      xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Unsupported type found.");
-      break;
+
+    if (callType != XmlRpc::call_generic) {
+      // When the call type is not supposed to be void, we'll try to
+      // convert it to a command target. It's not that important that
+      // it is converted to the right type here, as an mismatch will
+      // be caught when executing the command.
+      *target = xmlrpc_to_target(env, value);
+      return torrent::Object();
+
+    } else {
+      const char* valueString;
+      xmlrpc_read_string(env, value, &valueString);
+
+      if (env->fault_occurred)
+        throw xmlrpc_error(env);
+
+      torrent::Object result = torrent::Object(std::string(valueString));
+
+      // Urgh, seriously?
+      ::free((void*)valueString);
+      return result;
     }
 
-    *target = xmlrpc_to_download(env, value);
-    break;
+  case XMLRPC_TYPE_BASE64:
+  {
+    size_t      valueSize;
+    const char* valueString;
+
+    xmlrpc_read_base64(env, value, &valueSize, (const unsigned char**)&valueString);
+
+    if (env->fault_occurred)
+      throw xmlrpc_error(env);
+
+    torrent::Object result = torrent::Object(std::string(valueString, valueSize));
+
+    // Urgh, seriously?
+    ::free((void*)valueString);
+    return result;
+  }
 
   case XMLRPC_TYPE_ARRAY:
   {
     unsigned int current = 0;
     unsigned int last = xmlrpc_array_size(env, value);
 
     if (env->fault_occurred)
-      break;
+      throw xmlrpc_error(env);
 
-    if (last < 1) {
-      xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Too few arguments.");
-      break;
-    }
+    if (callType != XmlRpc::call_generic) {
+      if (last < 1)
+        throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Too few arguments.");
 
-    {
       xmlrpc_value* tmp;
       xmlrpc_array_read_item(env, value, current++, &tmp);
 
       if (env->fault_occurred)
-        break;
+        throw xmlrpc_error(env);
 
-      *target = xmlrpc_to_download(env, tmp);
+      *target = xmlrpc_to_target(env, tmp);
       xmlrpc_DECREF(tmp);
 
       if (env->fault_occurred)
-        break;
-    }
+        throw xmlrpc_error(env);
 
-    if (callType == XmlRpc::call_file || callType == XmlRpc::call_tracker) {
-      if (current == last) {
-        xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Too few arguments.");
-        break;
-      }
+      if (target->first == XmlRpc::call_download &&
+          (callType == XmlRpc::call_file || callType == XmlRpc::call_tracker)) {
+        // If we have a download target and the call type requires
+        // another contained type, then we try to use the next
+        // parameter as the index to support old-style calls.
 
-      xmlrpc_value* tmp;
-      xmlrpc_array_read_item(env, value, current++, &tmp);
+        if (current == last)
+          throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Too few arguments.");
 
-      if (env->fault_occurred)
-        break;
-
-      *target = xmlrpc_to_index_type(env, tmp, callType, (core::Download*)*target);
-      xmlrpc_DECREF(tmp);
-
-      if (env->fault_occurred)
-        break;
+        *target = xmlrpc_to_index_type(xmlrpc_list_entry_to_value(env, value, current++), callType, (core::Download*)target->second);
+      }
     }
 
-    torrent::Object result;
-
     if (current + 1 < last) {
-      result = torrent::Object::create_list();
+      torrent::Object result = torrent::Object::create_list();
       torrent::Object::list_type& listRef = result.as_list();
 
-      // Move this into a helper function?
-      while (current != last) {
-        xmlrpc_value* tmp;
-        xmlrpc_array_read_item(env, value, current++, &tmp);
-
-        if (env->fault_occurred)
-          break;
-
-        listRef.push_back(xmlrpc_to_object(env, tmp));
-        xmlrpc_DECREF(tmp);
-      }
+      while (current != last)
+        listRef.push_back(xmlrpc_list_entry_to_object(env, value, current++));
 
       return result;
 
     } else if (current + 1 == last) {
-      // Need to decref.
-      xmlrpc_value* tmp;
-      xmlrpc_array_read_item(env, value, current, &tmp);
-
-      if (env->fault_occurred)
-        break;
+      return xmlrpc_list_entry_to_object(env, value, current);
 
-      result = xmlrpc_to_object(env, tmp);
-      xmlrpc_DECREF(tmp);
+    } else {
+      return torrent::Object();
     }
-
-    return result;
   }
 
+  //     case XMLRPC_TYPE_STRUCT:
+    //     case XMLRPC_TYPE_C_PTR:
+    //     case XMLRPC_TYPE_NIL:
+    //     case XMLRPC_TYPE_DEAD:
   default:
-    xmlrpc_env_set_fault(env, XMLRPC_TYPE_ERROR, "Unsupported type found.");
+    throw xmlrpc_error(XMLRPC_TYPE_ERROR, "Unsupported type found.");
   }
-
-  return torrent::Object();
 }
 
 xmlrpc_value*
 object_to_xmlrpc(xmlrpc_env* env, const torrent::Object& object) {
   switch (object.type()) {
   case torrent::Object::TYPE_VALUE:
@@ -377,21 +404,26 @@
 
   if (itr == commands.end()) {
     xmlrpc_env_set_fault(env, XMLRPC_PARSE_ERROR, ("Command \"" + std::string((const char*)voidServerInfo) + "\" does not exist.").c_str());
     return NULL;
   }
 
-  int   type = itr->second.target();
-  void* target = NULL;
-  torrent::Object object = (type == 0) ? xmlrpc_to_object(env, args) : xmlrpc_to_object_target(env, args, type, &target);
+  try {
+    torrent::Object object;
+    rpc::target_type target = rpc::make_target();
 
-  if (env->fault_occurred)
-    return NULL;
+    xmlrpc_to_object(env, args, itr->second.target(), &target).swap(object);
 
-  try {
-    return object_to_xmlrpc(env, rpc::commands.call_command(itr, object, rpc::make_target(type, target)));
+    if (env->fault_occurred)
+      return NULL;
+
+    return object_to_xmlrpc(env, rpc::commands.call_command(itr, object, target));
+
+  } catch (xmlrpc_error& e) {
+    xmlrpc_env_set_fault(env, e.type(), e.what());
+    return NULL;
 
   } catch (torrent::local_error& e) {
     xmlrpc_env_set_fault(env, XMLRPC_PARSE_ERROR, e.what());
     return NULL;
   }
 }
@@ -480,19 +512,35 @@
   }
 
   xmlrpc_env_clean(&localEnv);
   m_dialect = dialect;
 }
 
+int64_t
+XmlRpc::size_limit() {
+  return xmlrpc_limit_get(XMLRPC_XML_SIZE_LIMIT_ID);
+}
+
+void
+XmlRpc::set_size_limit(uint64_t size) {
+  if (size >= (64 << 20))
+    throw torrent::input_error("Invalid XMLRPC limit size.");
+
+  xmlrpc_limit_set(XMLRPC_XML_SIZE_LIMIT_ID, size);
+}
+
 #else
 
 void XmlRpc::initialize() { throw torrent::resource_error("XMLRPC not supported."); }
 void XmlRpc::cleanup() {}
 
 void XmlRpc::insert_command(__UNUSED const char* name, __UNUSED const char* parm, __UNUSED const char* doc) {}
 void XmlRpc::set_dialect(__UNUSED int dialect) {}
 
 bool XmlRpc::process(__UNUSED const char* inBuffer, __UNUSED uint32_t length, __UNUSED slot_write slotWrite) { return false; }
 
+int64_t XmlRpc::size_limit() { return 0; }
+void    XmlRpc::set_size_limit(uint64_t size) {}
+
 #endif
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/xmlrpc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/xmlrpc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/rpc/xmlrpc.h	2008-01-13 23:02:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/rpc/xmlrpc.h	2008-02-23 18:35:18.000000000 +0800
@@ -91,12 +91,15 @@
   slot_find_file&     get_slot_find_file()                                        { return m_slotFindFile; }
   void                set_slot_find_file(slot_find_file::base_type* slot)         { m_slotFindFile.set(slot); }
 
   slot_find_tracker&  get_slot_find_tracker()                                     { return m_slotFindTracker; }
   void                set_slot_find_tracker(slot_find_tracker::base_type* slot)   { m_slotFindTracker.set(slot); }
 
+  static int64_t      size_limit();
+  static void         set_size_limit(uint64_t size);
+
 private:
   void*               m_env;
   void*               m_registry;
 
   int                 m_dialect;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/download.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/download.cc	2008-03-27 02:34:37.000000000 +0800
@@ -150,13 +150,14 @@
   element->push_column("Name:",             te_command("d.get_name="));
   element->push_column("Local id:",         te_command("d.get_local_id_html="));
   element->push_column("Info hash:",        te_command("d.get_hash="));
   element->push_column("Created:",          te_command("cat=$to_date=$d.get_creation_date=,\" \",$to_time=$d.get_creation_date="));
 
   element->push_back("");
-  element->push_column("Directory:",        te_command("d.get_base_path="));
+  element->push_column("Directory:",        te_command("d.get_directory="));
+  element->push_column("Base Path:",        te_command("d.get_base_path="));
   element->push_column("Tied to file:",     te_command("d.get_tied_to_file="));
   element->push_column("File stats:",       te_command("cat=$if=$d.is_multi_file=\\,multi\\,single,\" \",$d.get_size_files=,\" files\""));
 
   element->push_back("");
   element->push_column("Chunks:",           te_command("cat=$d.get_completed_chunks=,\" / \",$d.get_size_chunks=,\" * \",$d.get_chunk_size="));
   element->push_column("Priority:",         te_command("d.get_priority="));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/download_list.cc	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/download_list.cc	2008-03-24 21:09:46.000000000 +0800
@@ -95,13 +95,13 @@
   if (is_active())
     throw torrent::internal_error("ui::DownloadList::activate() called on an already activated object");
 
   m_frame = frame;
 
   control->input()->push_back(&m_bindings);
-  control->core()->download_list()->slot_map_erase()["0_download_list"] = sigc::mem_fun(this, &DownloadList::receive_download_erased);
+  control->core()->download_list()->slot_map_erase()["0_download_list"] = "ui.unfocus_download=";
 
   activate_display(DISPLAY_DOWNLOAD_LIST);
 }
 
 void
 DownloadList::disable() {
@@ -118,12 +118,24 @@
 
 core::View*
 DownloadList::current_view() {
   return dynamic_cast<ElementDownloadList*>(m_uiArray[DISPLAY_DOWNLOAD_LIST])->view();
 }
 
+// This should also do focus_next() or something.
+void
+DownloadList::unfocus_download(core::Download* d) {
+  if (current_view()->focus() >= current_view()->end_visible() || *current_view()->focus() != d)
+    return;
+
+  if (m_state == DISPLAY_DOWNLOAD)
+    activate_display(DISPLAY_DOWNLOAD_LIST);
+
+  current_view()->next_focus();
+}
+
 void
 DownloadList::activate_display(Display displayType) {
   if (!is_active())
     throw torrent::internal_error("ui::DownloadList::activate_display(...) !is_active().");
 
   if (displayType > DISPLAY_MAX_SIZE)
@@ -314,20 +326,12 @@
   activate_display(DISPLAY_DOWNLOAD_LIST);
 
   delete input;
 }
 
 void
-DownloadList::receive_download_erased(core::Download* d) {
-  if (m_state != DISPLAY_DOWNLOAD || current_view()->focus() == current_view()->end_visible() || *current_view()->focus() != d)
-    return;
-
-  activate_display(DISPLAY_DOWNLOAD_LIST);
-}
-
-void
 DownloadList::setup_keys() {
   m_bindings['\x7f']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
   m_bindings[KEY_BACKSPACE] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
   m_bindings['\n']          = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
   m_bindings[KEY_ENTER]     = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
   m_bindings['\x0F']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_CHANGE_DIRECTORY);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/download_list.h	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/download_list.h	2008-03-23 19:15:22.000000000 +0800
@@ -101,21 +101,21 @@
   void                activate_display(Display d);
 
   core::View*         current_view();
 
   void                slot_open_uri(SlotOpenUri s) { m_slotOpenUri = s; }
 
+  void                unfocus_download(core::Download* d);
+
 private:
   DownloadList(const DownloadList&);
   void operator = (const DownloadList&);
 
   void                receive_view_input(Input type);
   void                receive_exit_input(Input type);
 
-  void                receive_download_erased(core::Download* d);
-
   void                setup_keys();
   void                setup_input();
 
   Display             m_state;
 
   ElementBase*        m_uiArray[DISPLAY_MAX_SIZE];
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/element_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/element_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/element_download_list.cc	2008-01-22 23:45:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/element_download_list.cc	2008-04-02 22:41:41.000000000 +0800
@@ -60,36 +60,38 @@
 
   receive_change_view("main");
 
   if (m_view == NULL)
     throw torrent::internal_error("View \"main\" must be present to initialize the main display.");
 
-  m_bindings['\x13']        = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command), "d.start=");
-  m_bindings['\x04']        = sigc::mem_fun(*this, &ElementDownloadList::receive_stop_download);
-  m_bindings['\x0B']        = sigc::mem_fun(*this, &ElementDownloadList::receive_close_download);
-//   m_bindings['\x04']        = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command), "d.stop=");
-//   m_bindings['\x0B']        = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command), "d.close=");
-  m_bindings['\x12']        = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command), "d.check_hash=");
-
-  m_bindings['\x05']        = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command),
-                                         "f.multicall=,f.set_create_queued=,f.set_resize_queued= ; print=\"Queued create/resize of files in torrent.\"");
-
-  m_bindings['+']           = sigc::mem_fun(*this, &ElementDownloadList::receive_next_priority);
-  m_bindings['-']           = sigc::mem_fun(*this, &ElementDownloadList::receive_prev_priority);
-  m_bindings['I']           = sigc::mem_fun(*this, &ElementDownloadList::receive_ignore_ratio);
-  m_bindings['U']           = sigc::mem_fun(*this, &ElementDownloadList::receive_clear_tied);
+  m_bindings['\x13'] = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command), "d.start=");
+  m_bindings['\x04'] = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command), "branch=d.get_state=,d.stop=,d.erase=");
+  m_bindings['\x0B'] = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command), "d.set_ignore_commands=1; d.stop=; d.close=");
+  m_bindings['\x12'] = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command), "d.check_hash=");
+  m_bindings['\x05'] = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command),
+                                         "f.multicall=,f.set_create_queued=,f.set_resize_queued=; print=\"Queued create/resize of files in torrent.\"");
+
+  m_bindings['+']    = sigc::mem_fun(*this, &ElementDownloadList::receive_next_priority);
+  m_bindings['-']    = sigc::mem_fun(*this, &ElementDownloadList::receive_prev_priority);
+  m_bindings['I']    = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command),
+                                  "branch=d.get_ignore_commands=,"
+                                  "{d.set_ignore_commands=0, print=\"Torrent set to heed commands.\"},"
+                                  "{d.set_ignore_commands=1, print=\"Torrent set to ignore commands.\"}");
+
+  m_bindings['U']    = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_command), "d.delete_tied=; print=\"Cleared tied to file association for the selected download.\"");
 
   // These should also be commands.
   m_bindings['1']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "main");
   m_bindings['2']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "name");
   m_bindings['3']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "started");
   m_bindings['4']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "stopped");
   m_bindings['5']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "complete");
   m_bindings['6']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "incomplete");
   m_bindings['7']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "hashing");
   m_bindings['8']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "seeding");
+  m_bindings['9']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "active");
 
   m_bindings[KEY_UP]   = m_bindings['P' - '@'] = sigc::mem_fun(*this, &ElementDownloadList::receive_prev);
   m_bindings[KEY_DOWN] = m_bindings['N' - '@'] = sigc::mem_fun(*this, &ElementDownloadList::receive_next);
 }
 
 void
@@ -142,12 +144,13 @@
       rpc::parse_command_multiple(rpc::make_target(*m_view->focus()), cmd, cmd + strlen(cmd));
 
     m_view->set_last_changed();
 
   } catch (torrent::input_error& e) {
     control->core()->push_log(e.what());
+    return;
   }
 }
 
 void
 ElementDownloadList::receive_next() {
   m_view->next_focus();
@@ -158,85 +161,30 @@
 ElementDownloadList::receive_prev() {
   m_view->prev_focus();
   m_view->set_last_changed();
 }
 
 void
-ElementDownloadList::receive_stop_download() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
-
-  if (rpc::call_command_value("d.get_state", rpc::make_target(*m_view->focus())) == 1)
-    control->core()->download_list()->stop_normal(*m_view->focus());
-  else
-    control->core()->download_list()->erase_ptr(*m_view->focus());
-
-  m_view->set_last_changed();
-}
-
-void
-ElementDownloadList::receive_close_download() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
-
-  core::Download* download = *m_view->focus();
-
-  rpc::call_command("d.set_ignore_commands", (int64_t)1, rpc::make_target(download));
-
-  control->core()->download_list()->stop_normal(download);
-  control->core()->download_list()->close(download);
-  m_view->set_last_changed();
-}
-
-void
 ElementDownloadList::receive_next_priority() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
-  (*m_view->focus())->set_priority(((*m_view->focus())->priority() + 1) % 4);
+  (*m_view->focus())->set_priority((*m_view->focus())->priority() + 1);
   m_window->mark_dirty();
 }
 
 void
 ElementDownloadList::receive_prev_priority() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
-  (*m_view->focus())->set_priority(((*m_view->focus())->priority() - 1) % 4);
+  (*m_view->focus())->set_priority((*m_view->focus())->priority() - 1);
   m_window->mark_dirty();
 }
 
 void
-ElementDownloadList::receive_ignore_ratio() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
-
-  if (rpc::call_command_value("d.get_ignore_commands", rpc::make_target(*m_view->focus())) != 0) {
-    rpc::call_command_set_value("d.set_ignore_commands", (int64_t)0, rpc::make_target(*m_view->focus()));
-    control->core()->push_log("Torrent set to heed commands.");
-  } else {
-    rpc::call_command_set_value("d.set_ignore_commands", (int64_t)1, rpc::make_target(*m_view->focus()));
-    control->core()->push_log("Torrent set to ignore commands.");
-  }
-}
-
-void
-ElementDownloadList::receive_clear_tied() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
-
-  const std::string& tiedFile = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(*m_view->focus()));
-
-  if (!tiedFile.empty()) {
-    rpc::call_command_void("d.delete_tied", rpc::make_target(*m_view->focus()));
-
-    control->core()->push_log("Cleared tied to file association for the selected download.");
-  }
-}
-
-void
 ElementDownloadList::receive_change_view(const std::string& name) {
   core::ViewManager::iterator itr = control->view_manager()->find(name);
 
   if (itr == control->view_manager()->end()) {
     control->core()->push_log_std("Could not find view \"" + name + "\".");
     return;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/element_download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/element_download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/element_download_list.h	2008-01-22 22:29:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/element_download_list.h	2008-02-03 19:49:50.000000000 +0800
@@ -70,15 +70,12 @@
   void                receive_stop_download();
   void                receive_close_download();
 
   void                receive_next_priority();
   void                receive_prev_priority();
 
-  void                receive_ignore_ratio();
-  void                receive_clear_tied();
-
   void                receive_change_view(const std::string& name);
 
 private:
   WDownloadList*      m_window;
   core::View*         m_view;
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/root.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/root.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/ui/root.h	2008-01-13 23:02:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/ui/root.h	2008-02-02 23:48:20.000000000 +0800
@@ -71,12 +71,14 @@
   void                cleanup();
 
   WTitle*             window_title()                          { return m_windowTitle; }
   WStatusbar*         window_statusbar()                      { return m_windowStatusbar; }
   WInput*             window_input()                          { return m_windowInput; }
 
+  DownloadList*       download_list()                         { return m_downloadList; }
+
   void                set_down_throttle(unsigned int throttle);
   void                set_up_throttle(unsigned int throttle);
 
   // Rename to raw or something, make base function.
   void                set_down_throttle_i64(int64_t throttle) { set_down_throttle(throttle >> 10); }
   void                set_up_throttle_i64(int64_t throttle)   { set_up_throttle(throttle >> 10); }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/utils/directory.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/utils/directory.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.0/src/utils/directory.h	2008-01-13 23:02:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.1/src/utils/directory.h	2008-02-01 19:39:27.000000000 +0800
@@ -36,12 +36,13 @@
 
 #ifndef RTORRENT_UTILS_DIRECTORY_H
 #define RTORRENT_UTILS_DIRECTORY_H
 
 #include <string>
 #include <vector>
+#include <inttypes.h>
 
 namespace utils {
 
 struct directory_entry {
   // Fix.
   bool is_file() const { return true; }
